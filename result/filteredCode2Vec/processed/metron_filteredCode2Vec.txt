public String metron_f0_0()
{    return url;}
public void metron_f1_0(String url)
{    this.url = url;}
public Map<String, String> metron_f2_0()
{    return functions;}
public void metron_f3_0(Map<String, String> functions)
{    this.functions = functions;}
public String metron_f4_0()
{    return "Endpoint{" + "url='" + url + '\'' + ", functions=" + functions + '}';}
public boolean metron_f5_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Endpoint endpoint = (Endpoint) o;    if (getUrl() != null ? !getUrl().equals(endpoint.getUrl()) : endpoint.getUrl() != null)        return false;    return getFunctions() != null ? getFunctions().equals(endpoint.getFunctions()) : endpoint.getFunctions() == null;}
public int metron_f6_0()
{    int result = getUrl() != null ? getUrl().hashCode() : 0;    result = 31 * result + (getFunctions() != null ? getFunctions().hashCode() : 0);    return result;}
public String metron_f7_0()
{    return serviceRoot;}
public void metron_f8_0(String serviceRoot)
{    this.serviceRoot = serviceRoot;}
public QueueHandler metron_f9_0()
{    return queue;}
public void metron_f10_0(QueueHandler queue)
{    this.queue = queue;}
public Map<String, Object> metron_f11_0()
{    return queueConfig;}
public void metron_f12_0(Map<String, Object> queueConfig)
{    this.queueConfig = queueConfig;}
public Queue<ModelRequest> metron_f13_0(Map<String, Object> additionalConfig)
{    Map<String, Object> configs = new HashMap<>(getQueueConfig());    configs.putAll(additionalConfig);    return getQueue().create(configs);}
public String metron_f14_0()
{    return name;}
public void metron_f15_0(String name)
{    this.name = name;}
public String metron_f16_0()
{    return version;}
public void metron_f17_0(String version)
{    this.version = version;}
public boolean metron_f18_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Model model = (Model) o;    if (getName() != null ? !getName().equals(model.getName()) : model.getName() != null)        return false;    return getVersion() != null ? getVersion().equals(model.getVersion()) : model.getVersion() == null;}
public int metron_f19_0()
{    int result = getName() != null ? getName().hashCode() : 0;    result = 31 * result + (getVersion() != null ? getVersion().hashCode() : 0);    return result;}
public String metron_f20_0()
{    return containerId;}
public Endpoint metron_f21_0()
{    return endpoint;}
public void metron_f22_0(Endpoint endpoint)
{    this.endpoint = endpoint;}
public String metron_f23_0()
{    return name + ":" + version + " @ " + endpoint.getUrl() + " serving:\n\t" + Joiner.on("\n\t").join(getEndpoint().getFunctions().entrySet());}
public void metron_f24_0(String containerId)
{    this.containerId = containerId;}
public String metron_f25_0()
{    return name;}
public void metron_f26_0(String name)
{    this.name = name;}
public String metron_f27_0()
{    return version;}
public void metron_f28_0(String version)
{    this.version = version;}
public boolean metron_f29_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ModelEndpoint that = (ModelEndpoint) o;    if (getEndpoint() != null ? !getEndpoint().equals(that.getEndpoint()) : that.getEndpoint() != null)        return false;    if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null)        return false;    if (getVersion() != null ? !getVersion().equals(that.getVersion()) : that.getVersion() != null)        return false;    return getContainerId() != null ? getContainerId().equals(that.getContainerId()) : that.getContainerId() == null;}
public int metron_f30_0()
{    int result = getEndpoint() != null ? getEndpoint().hashCode() : 0;    result = 31 * result + (getName() != null ? getName().hashCode() : 0);    result = 31 * result + (getVersion() != null ? getVersion().hashCode() : 0);    result = 31 * result + (getContainerId() != null ? getContainerId().hashCode() : 0);    return result;}
public String metron_f31_0()
{    return path;}
public void metron_f32_0(String path)
{    this.path = path;}
public Action metron_f33_0()
{    return action;}
public void metron_f34_0(Action action)
{    this.action = action;}
public String metron_f35_0()
{    return name;}
public void metron_f36_0(String name)
{    this.name = name;}
public String metron_f37_0()
{    return version;}
public void metron_f38_0(String version)
{    this.version = version;}
public int metron_f39_0()
{    return numInstances;}
public void metron_f40_0(int numInstances)
{    this.numInstances = numInstances;}
public int metron_f41_0()
{    return memory;}
public void metron_f42_0(int memory)
{    this.memory = memory;}
public void metron_f43_1()
{    rwLock.readLock().lock();    ServiceInstance<ModelEndpoint> ep = null;    try {        for (Map.Entry<String, ServiceInstance<ModelEndpoint>> kv : containerToEndpoint.entrySet()) {            ep = kv.getValue();            serviceDiscovery.unregisterService(ep);        }    } catch (Exception e) {            } finally {        rwLock.readLock().unlock();    }}
public ServiceDiscovery<ModelEndpoint> metron_f44_0()
{    return serviceDiscovery;}
private void metron_f45_1()
{    Map<Model, List<ModelEndpoint>> state = new HashMap<>();    Map<String, String> modelToVersion = new HashMap<>();    Map<String, ServiceInstance<ModelEndpoint>> containerToEndpoint = new HashMap<>();    try {        for (String name : serviceDiscovery.queryForNames()) {            for (ServiceInstance<ModelEndpoint> endpoint : serviceDiscovery.queryForInstances(name)) {                ModelEndpoint ep = endpoint.getPayload();                if (LOG.isDebugEnabled()) {                                    }                                String currentVersion = modelToVersion.getOrDefault(ep.getName(), ep.getVersion());                                                                currentVersion = currentVersion.compareTo(ep.getVersion()) < 0 ? ep.getVersion() : currentVersion;                modelToVersion.put(ep.getName(), currentVersion);                containerToEndpoint.put(ep.getContainerId(), endpoint);                Model model = new Model(ep.getName(), ep.getVersion());                List<ModelEndpoint> endpoints = state.get(model);                if (endpoints == null) {                    endpoints = new ArrayList<>();                    state.put(model, endpoints);                }                endpoints.add(ep);            }        }        rwLock.writeLock().lock();        try {            this.modelToCurrentVersion = modelToVersion;            this.state = state;            this.containerToEndpoint = containerToEndpoint;            if (LOG.isDebugEnabled()) {                            }        } finally {            rwLock.writeLock().unlock();        }    } catch (Exception e) {            } finally {    }}
public void metron_f46_1()
{    try {        serviceDiscovery.start();        cache.start();        updateState();    } catch (Exception e) {                throw new IllegalStateException("Unable to start", e);    }}
public void metron_f47_1(String containerIdRaw)
{    rwLock.readLock().lock();    try {        String containerId = containerIdRaw;                                ServiceInstance<ModelEndpoint> ep = containerToEndpoint.get(containerId);        if (ep != null) {            serviceDiscovery.unregisterService(ep);        } else {                        throw new IllegalStateException("Unable.");        }    } catch (Exception e) {            } finally {        rwLock.readLock().unlock();    }}
public List<ModelEndpoint> metron_f48_0(Model model)
{    rwLock.readLock().lock();    try {        return state.getOrDefault(model, new ArrayList<>());    } finally {        rwLock.readLock().unlock();    }}
public void metron_f49_0(ModelEndpoint endpoint)
{    blacklist(toUrl(endpoint.getEndpoint().getUrl()));}
public void metron_f50_0(URL url)
{    rwLock.writeLock().lock();    try {        blacklist.put(url, true);    } finally {        rwLock.writeLock().unlock();    }}
public ModelEndpoint metron_f51_0(String modelName)
{    String version = null;    rwLock.readLock().lock();    try {        version = modelToCurrentVersion.get(modelName);    } finally {        rwLock.readLock().unlock();    }    if (version == null) {        throw new IllegalStateException("Unable to find version for " + modelName);    }    return getEndpoint(modelName, version);}
private static URL metron_f52_0(String url)
{    try {        return new URL(url);    } catch (MalformedURLException e) {        throw new IllegalStateException("Endpoint does not refer to an actual URL");    }}
public ModelEndpoint metron_f53_0(String modelName, String modelVersion)
{    return getEndpoint(new Model(modelName, modelVersion));}
public ModelEndpoint metron_f54_0(Model model)
{    rwLock.readLock().lock();    try {        List<ModelEndpoint> endpoints = state.get(model);        ModelEndpoint ret = null;        if (endpoints != null) {            for (int j = 0; j < 10; ++j) {                int i = ThreadLocalRandom.current().nextInt(endpoints.size());                ret = endpoints.get(i);                try {                    if (blacklist.asMap().containsKey(toUrl(ret.getEndpoint().getUrl()))) {                        continue;                    } else {                        return ret;                    }                } catch (IllegalStateException ise) {                /*             If an exception happens on an attempt then we move on.             Frankly this is an excess of caution since we parse the             URLs in the Runner before they go into zookeeper, so they are valid.             */                }            }        }        return ret;    } finally {        rwLock.readLock().unlock();    }}
public Map<Model, List<ModelEndpoint>> metron_f55_0(Model model)
{    Map<Model, List<ModelEndpoint>> ret = new HashMap<>();    rwLock.readLock().lock();    try {        Query query = new Query(model);        for (Map.Entry<Model, List<ModelEndpoint>> kv : state.entrySet()) {            if (query.match(kv.getKey())) {                ret.put(kv.getKey(), kv.getValue());            }        }        return ret;    } finally {        rwLock.readLock().unlock();    }}
public void metron_f56_0()
{    if (cache != null) {        CloseableUtils.closeQuietly(cache);    }    if (serviceDiscovery != null) {        CloseableUtils.closeQuietly(serviceDiscovery);    }}
public boolean metron_f57_0(Model m)
{    boolean isNameMatch = ((model.getName() != null && model.getName().equals(m.getName())) || model.getName() == null);    if (!isNameMatch) {        return false;    }    boolean isVersionMatch = (model.getVersion() != null && model.getVersion().equals(m.getVersion())) || model.getVersion() == null;    if (!isVersionMatch) {        return false;    }    return true;}
public boolean metron_f58_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ModelCacheKey that = (ModelCacheKey) o;    if (name != null ? !name.equals(that.name) : that.name != null)        return false;    if (version != null ? !version.equals(that.version) : that.version != null)        return false;    if (method != null ? !method.equals(that.method) : that.method != null)        return false;    return args != null ? args.equals(that.args) : that.args == null;}
public int metron_f59_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (version != null ? version.hashCode() : 0);    result = 31 * result + (method != null ? method.hashCode() : 0);    result = 31 * result + (args != null ? args.hashCode() : 0);    return result;}
public Object metron_f60_1(List<Object> args, Context context) throws ParseException
{    if (args.size() < 2) {        throw new ParseException("Unable to execute model_apply. " + "Expected arguments: endpoint_map:map, " + " [endpoint method:string], model_args:map");    }    if (!isInitialized) {        return null;    }    int i = 0;    if (args.size() == 0) {        return null;    }    Object endpointObj = args.get(i++);    Map endpoint = null;    String modelName;    String modelVersion;    String modelUrl;    if (endpointObj instanceof Map) {        endpoint = (Map) endpointObj;        modelName = endpoint.get("name") + "";        modelVersion = endpoint.get("version") + "";        modelUrl = endpoint.get("url") + "";    } else {        return null;    }    String modelFunction = "apply";    Map<String, String> modelArgs = new HashMap<>();    if (args.get(i) instanceof String) {        String func = (String) args.get(i);        if (endpoint.containsKey("endpoint:" + func)) {            modelFunction = "" + endpoint.get("endpoint:" + func);        } else {            modelFunction = func;        }        i++;    }    if (args.get(i) instanceof Map) {        if (endpoint.containsKey("endpoint:apply")) {            modelFunction = "" + endpoint.get("endpoint:apply");        }        modelArgs = (Map) args.get(i);    }    if (modelName == null || modelVersion == null || modelFunction == null) {        return null;    }    ModelCacheKey cacheKey = new ModelCacheKey(modelName, modelVersion, modelFunction, modelArgs);    Map<String, Object> ret = resultCache.getIfPresent(cacheKey);    if (ret != null) {        return ret;    } else {        String url = modelUrl;        if (url.endsWith("/")) {            url = url.substring(0, url.length() - 1);        }        if (modelFunction.startsWith("/")) {            modelFunction = modelFunction.substring(1);        }        try {            URL u = new URL(url + "/" + modelFunction);            String results = RESTUtil.INSTANCE.getRESTJSONResults(u, modelArgs);            ret = JSONUtils.INSTANCE.load(results, JSONUtils.MAP_SUPPLIER);            resultCache.put(cacheKey, ret);            return ret;        } catch (Exception e) {                        if (discoverer != null) {                try {                    URL u = new URL(modelUrl);                    discoverer.blacklist(u);                } catch (MalformedURLException e1) {                }            }        }    }    return null;}
public synchronized void metron_f61_1(Context context)
{    try {        Optional<ServiceDiscoverer> discovererOpt = (Optional) (context.getCapability(Context.Capabilities.SERVICE_DISCOVERER));        if (discovererOpt.isPresent()) {            discoverer = discovererOpt.get();        } else {            Optional<Object> clientOptional = context.getCapability(Context.Capabilities.ZOOKEEPER_CLIENT);            CuratorFramework client = null;            if (clientOptional.isPresent() && clientOptional.get() instanceof CuratorFramework) {                client = (CuratorFramework) clientOptional.get();            } else {                throw new IllegalStateException("Unable to initialize function: Cannot find zookeeper client.");            }            discoverer = createDiscoverer(client);        }    } catch (Exception ex) {            } finally {                isInitialized = true;    }}
public boolean metron_f62_0()
{    return isInitialized;}
private static ServiceDiscoverer metron_f63_0(CuratorFramework client) throws Exception
{    MaaSConfig config = ConfigUtil.INSTANCE.read(client, "/metron/maas/config", new MaaSConfig(), MaaSConfig.class);    ServiceDiscoverer discoverer = new ServiceDiscoverer(client, config.getServiceRoot());    discoverer.start();    return discoverer;}
public Object metron_f64_1(List<Object> args, Context context) throws ParseException
{    if (!isValidState) {                return null;    }    String modelName = null;    String modelVersion = null;    if (args.size() >= 1) {        modelName = args.get(0).toString();    }    if (args.size() >= 2) {        modelVersion = args.get(1).toString();    }    if (modelName == null) {        return null;    }    try {        ModelEndpoint ep = null;        if (modelVersion == null) {            ep = discoverer.getEndpoint(modelName);        } else {            ep = discoverer.getEndpoint(modelName, modelVersion);        }        return ep == null ? null : endpointToMap(ep.getName(), ep.getVersion(), ep.getEndpoint());    } catch (Exception ex) {                return null;    }}
public static Map<String, String> metron_f65_0(String name, String version, Endpoint ep)
{    Map<String, String> ret = new HashMap<>();    ret.put("url", ep.getUrl());    ret.put("name", name);    ret.put("version", version);    for (Map.Entry<String, String> kv : ep.getFunctions().entrySet()) {        ret.put("endpoint:" + kv.getKey(), kv.getValue());    }    return ret;}
public synchronized void metron_f66_1(Context context)
{    try {        Optional<Object> clientOptional = context.getCapability(Context.Capabilities.ZOOKEEPER_CLIENT);        CuratorFramework client = null;        if (clientOptional.isPresent() && clientOptional.get() instanceof CuratorFramework) {            client = (CuratorFramework) clientOptional.get();        } else {            throw new IllegalStateException("Unable to initialize function: Cannot find zookeeper client.");        }        try {            discoverer = createDiscoverer(client);            context.addCapability(Context.Capabilities.SERVICE_DISCOVERER, () -> discoverer);            isValidState = true;        } catch (Exception e) {                        throw new IllegalStateException("Unable to initialize MAAS_GET_ENDPOINT", e);        }    } finally {        isInitialized = true;    }}
public boolean metron_f67_0()
{    return isInitialized;}
public Queue<ModelRequest> metron_f68_0(Map<String, Object> config)
{    return queueCreator.apply(config);}
public ModelRequest metron_f69_0()
{    try {        byte[] payload = queue.take();        return ConfigUtil.INSTANCE.read(payload, ModelRequest.class);    } catch (Exception e) {        throw new IllegalStateException("Unable to dequeue: " + e.getMessage(), e);    }}
public void metron_f70_0(ModelRequest request)
{    try {        byte[] payload = ConfigUtil.INSTANCE.toBytes(request);        queue.offer(payload);    } catch (Exception e) {        throw new IllegalStateException("Unable to enqueue: " + e.getMessage(), e);    }}
public void metron_f71_0(Map<String, Object> config)
{    String path = (String) config.get(ZK_PATH);    if (path == null) {        throw new IllegalStateException("You must specify " + ZK_PATH + " for a zk queue");    }    CuratorFramework client = (CuratorFramework) config.get(ZK_CLIENT);    queue = new SimpleDistributedQueue(client, path);}
protected ObjectMapper metron_f72_0()
{    return new ObjectMapper();}
public T metron_f73_0(CuratorFramework client, String root, T def, Class<T> clazz) throws Exception
{    try {        byte[] data = client.getData().forPath(root);        return read(data, clazz);    } catch (KeeperException.NoNodeException nne) {        return def;    }}
public T metron_f74_0(byte[] data, Class<T> clazz) throws Exception
{    return _mapper.get().readValue(data, clazz);}
public byte[] metron_f75_0(Object o) throws IOException
{    return _mapper.get().writeValueAsBytes(o);}
protected HttpClient metron_f76_0()
{        return new DefaultHttpClient();}
public String metron_f77_0(URL endpointUrl, Map<String, String> getArgs) throws IOException, URISyntaxException
{    String encodedParams = encodeParams(getArgs);    HttpGet get = new HttpGet(appendToUrl(endpointUrl, encodedParams).toURI());    get.addHeader("accept", "application/json");    HttpResponse response = CLIENT.get().execute(get);    if (response.getStatusLine().getStatusCode() != 200) {        throw new IllegalStateException("Failed : HTTP error code : " + response.getStatusLine().getStatusCode());    }    return new BufferedReader(new InputStreamReader(response.getEntity().getContent(), StandardCharsets.UTF_8)).lines().collect(Collectors.joining("\n"));}
public URL metron_f78_0(URL endpointUrl, String params) throws MalformedURLException
{    return new URL(endpointUrl.toString() + "?" + params);}
public String metron_f79_0(Map<String, String> params)
{    Iterable<NameValuePair> nvp = Iterables.transform(params.entrySet(), kv -> new BasicNameValuePair(kv.getKey(), kv.getValue()));    return URLEncodedUtils.format(nvp, Charset.defaultCharset());}
public void metron_f80_0() throws Exception
{    testZkServer = new TestingServer(true);    zookeeperUrl = testZkServer.getConnectString();    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    client = CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy);    client.start();    discoverer = new ServiceDiscoverer(client, "/maas/discover");    discoverer.start();}
private ServiceInstance<ModelEndpoint> metron_f81_0(ModelEndpoint ep) throws Exception
{    URL url = new URL(ep.getEndpoint().getUrl());    ServiceInstanceBuilder<ModelEndpoint> builder = ServiceInstance.<ModelEndpoint>builder().address(url.getHost()).id(ep.getContainerId()).name(ep.getName()).port(url.getPort()).registrationTimeUTC(System.currentTimeMillis()).serviceType(ServiceType.STATIC).payload(ep);    return builder.build();}
private void metron_f82_0(ModelEndpoint ep) throws Exception
{    discoverer.getServiceDiscovery().registerService(createInstance(ep));}
private void metron_f83_0(String name, String version, AtomicInteger containerId) throws Exception
{    ModelEndpoint ep = new ModelEndpoint();    ep.setName(name);    ep.setVersion(version);    ep.setContainerId(containerId.incrementAndGet() + "");    ep.setEndpoint(new Endpoint() {        {            setUrl("http://localhost:9080/ep1");        }    });    registerService(ep);}
public void metron_f84_0() throws Exception
{        AtomicInteger containerId = new AtomicInteger(0);    registerService("casey", "3.14159", containerId);    registerService("casey", "3.14159", containerId);    registerService("casey", "3.14159", containerId);    registerService("casey", "3.1416", containerId);        Thread.sleep(2000);    Assert.assertEquals(3, discoverer.getEndpoints(new Model("casey", "3.14159")).size());    Assert.assertEquals(1, discoverer.getEndpoints(new Model("casey", "3.1416")).size());    Assert.assertEquals(0, discoverer.getEndpoints(new Model("casey", "3.17")).size());    discoverer.unregisterByContainer("1");    Thread.sleep(2000);    Assert.assertEquals(2, discoverer.getEndpoints(new Model("casey", "3.14159")).size());    Assert.assertEquals(1, discoverer.getEndpoints(new Model("casey", "3.1416")).size());    Assert.assertEquals(0, discoverer.getEndpoints(new Model("casey", "3.17")).size());    Assert.assertEquals(2, discoverer.listEndpoints(new Model("casey", null)).keySet().size());    Assert.assertEquals(1, discoverer.listEndpoints(new Model("casey", "3.1416")).keySet().size());    Assert.assertEquals(1, discoverer.listEndpoints(new Model("casey", "3.1416")).get(new Model("casey", "3.1416")).size());    Assert.assertEquals("4", discoverer.listEndpoints(new Model("casey", "3.1416")).get(new Model("casey", "3.1416")).get(0).getContainerId());    Assert.assertEquals(0, discoverer.listEndpoints(new Model("casey", "3.17")).keySet().size());    Assert.assertEquals(0, discoverer.listEndpoints(new Model("dummy", null)).keySet().size());}
public void metron_f85_0() throws Exception
{    if (discoverer != null) {        CloseableUtils.closeQuietly(discoverer);    }    if (client != null) {        CloseableUtils.closeQuietly(client);    }    if (testZkServer != null) {        CloseableUtils.closeQuietly(testZkServer);    }}
public boolean metron_f86_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f87_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f88_0(CommandLine cli, String def)
{    return has(cli) ? cli.getOptionValue(shortCode) : def;}
public Map.Entry<AMOptions, String> metron_f89_0(String value)
{    if (option.hasArg()) {        return new AbstractMap.SimpleEntry<>(this, value);    }    return new AbstractMap.SimpleEntry<>(this, null);}
public static String metron_f90_0(Map.Entry<AMOptions, String>... arg)
{    return Joiner.on(" ").join(Iterables.transform(Arrays.asList(arg), a -> "-" + a.getKey().shortCode + (a.getValue() == null ? "" : (" " + a.getValue()))));}
public static CommandLine metron_f91_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f92_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("MaaSApplicationMaster", getOptions());}
public static Options metron_f93_0()
{    Options ret = new Options();    for (AMOptions o : AMOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public static void metron_f94_1(String[] args)
{    boolean result = false;    try {        ApplicationMaster appMaster = new ApplicationMaster();                boolean doRun = appMaster.init(args);        if (!doRun) {            System.exit(0);        }        appMaster.run();        result = appMaster.finish();    } catch (Throwable t) {                LogManager.shutdown();        ExitUtil.terminate(1, t);    }    if (result) {                System.exit(0);    } else {                System.exit(2);    }}
public boolean metron_f95_1(String[] args) throws ParseException, IOException
{    CommandLine cliParser = AMOptions.parse(new GnuParser(), args);        if (fileExist(log4jPath)) {        try {            Log4jPropertyHelper.updateLog4jConfiguration(ApplicationMaster.class, log4jPath);        } catch (Exception e) {                    }    }    if (AMOptions.HELP.has(cliParser)) {        AMOptions.printHelp();        return false;    }    zkQuorum = AMOptions.ZK_QUORUM.get(cliParser);    zkRoot = AMOptions.ZK_ROOT.get(cliParser);    appJarPath = new Path(AMOptions.APP_JAR_PATH.get(cliParser));    Map<String, String> envs = System.getenv();    if (!envs.containsKey(Environment.CONTAINER_ID.name())) {        if (AMOptions.APP_ATTEMPT_ID.has(cliParser)) {            String appIdStr = AMOptions.APP_ATTEMPT_ID.get(cliParser, "");            appAttemptID = ConverterUtils.toApplicationAttemptId(appIdStr);        } else {            throw new IllegalArgumentException("Application Attempt Id not set in the environment");        }    } else {        ContainerId containerId = ConverterUtils.toContainerId(envs.get(Environment.CONTAINER_ID.name()));        appAttemptID = containerId.getApplicationAttemptId();    }    if (!envs.containsKey(ApplicationConstants.APP_SUBMIT_TIME_ENV)) {        throw new RuntimeException(ApplicationConstants.APP_SUBMIT_TIME_ENV + " not set in the environment");    }    if (!envs.containsKey(Environment.NM_HOST.name())) {        throw new RuntimeException(Environment.NM_HOST.name() + " not set in the environment");    }    if (!envs.containsKey(Environment.NM_HTTP_PORT.name())) {        throw new RuntimeException(Environment.NM_HTTP_PORT + " not set in the environment");    }    if (!envs.containsKey(Environment.NM_PORT.name())) {        throw new RuntimeException(Environment.NM_PORT.name() + " not set in the environment");    }        if (cliParser.hasOption("shell_env")) {        String[] shellEnvs = cliParser.getOptionValues("shell_env");        for (String env : shellEnvs) {            env = env.trim();            int index = env.indexOf('=');            if (index == -1) {                shellEnv.put(env, "");                continue;            }            String key = env.substring(0, index);            String val = "";            if (index < (env.length() - 1)) {                val = env.substring(index + 1);            }            shellEnv.put(key, val);        }    }    if (envs.containsKey(Constants.TIMELINEDOMAIN)) {        domainId = envs.get(Constants.TIMELINEDOMAIN);    }    return true;}
public void metron_f96_1() throws YarnException, IOException, InterruptedException
{                Credentials credentials = UserGroupInformation.getCurrentUser().getCredentials();    allTokens = YarnUtils.INSTANCE.tokensFromCredentials(credentials);        appSubmitterUgi = YarnUtils.INSTANCE.createUserGroup(credentials);    startTimelineClient(conf);    if (timelineClient != null) {        YarnUtils.INSTANCE.publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(), ContainerEvents.APP_ATTEMPT_START, domainId, appSubmitterUgi);    }    int minSize = getMinContainerMemoryIncrement(conf);    listener = new ContainerRequestListener(timelineClient, appSubmitterUgi, domainId, minSize);    amRMClient = AMRMClientAsync.createAMRMClientAsync(1000, listener);    amRMClient.init(conf);    amRMClient.start();    nmClientAsync = new NMClientAsyncImpl(listener);    nmClientAsync.init(conf);    nmClientAsync.start();                                appMasterHostname = NetUtils.getHostname();    RegisterApplicationMasterResponse response = amRMClient.registerApplicationMaster(appMasterHostname, appMasterRpcPort, appMasterTrackingUrl);            int maxMem = response.getMaximumResourceCapability().getMemory();        int maxVCores = response.getMaximumResourceCapability().getVirtualCores();        maasHandler = new MaaSHandler(zkQuorum, zkRoot);    try {        maasHandler.start();        maasHandler.getDiscoverer().resetState();        listener.initialize(amRMClient, nmClientAsync, maasHandler.getDiscoverer());    } catch (Exception e) {        throw new IllegalStateException("Unable to find zookeeper", e);    }    EnumMap<Resources, Integer> maxResources = Resources.toResourceMap(Resources.MEMORY.of(maxMem), Resources.V_CORE.of(maxVCores));    requestQueue = maasHandler.getConfig().createQueue(ImmutableMap.of(ZKQueue.ZK_CLIENT, maasHandler.getClient()));        while (true) {        ModelRequest request = requestQueue.dequeue();        if (request == null) {                        continue;        }                EnumMap<Resources, Integer> resourceRequest = Resources.toResourceMap(Resources.MEMORY.of(request.getMemory()), Resources.V_CORE.of(1));        EnumMap<Resources, Integer> resources = Resources.getRealisticResourceRequest(maxResources, Resources.toResource(resourceRequest));        Resource resource = Resources.toResource(resources);        Path appMasterJar = getAppMasterJar();        if (request.getAction() == Action.ADD) {            listener.requestContainers(request.getNumInstances(), resource);            for (int i = 0; i < request.getNumInstances(); ++i) {                Container container = listener.getContainers(resource).take();                                executor.execute(new LaunchContainer(conf, zkQuorum, zkRoot, nmClientAsync, request, container, allTokens, appMasterJar));                listener.getContainerState().registerRequest(container, request);            }        } else if (request.getAction() == Action.REMOVE) {            listener.removeContainers(request.getNumInstances(), request);        }    }}
private Path metron_f97_0()
{    return appJarPath;}
private int metron_f98_0(Configuration conf)
{    String incrementStr = conf.get("yarn.scheduler.increment-allocation-mb");    if (incrementStr == null || incrementStr.length() == 0) {        incrementStr = conf.get("yarn.scheduler.minimum-allocation-mb");    }    return Integer.parseInt(incrementStr);}
 void metron_f99_1(final Configuration conf) throws YarnException, IOException, InterruptedException
{    try {        appSubmitterUgi.doAs(new PrivilegedExceptionAction<Void>() {            @Override            public Void run() throws Exception {                if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {                                        timelineClient = TimelineClient.createTimelineClient();                    timelineClient.init(conf);                    timelineClient.start();                } else {                    timelineClient = null;                                    }                return null;            }        });    } catch (UndeclaredThrowableException e) {        throw new YarnException(e.getCause());    }}
public Void metron_f100_1() throws Exception
{    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {                timelineClient = TimelineClient.createTimelineClient();        timelineClient.init(conf);        timelineClient.start();    } else {        timelineClient = null;            }    return null;}
protected boolean metron_f101_0()
{    return true;}
private boolean metron_f102_0(String filePath)
{    return new File(filePath).exists();}
public void metron_f103_0(AMRMClientAsync<AMRMClient.ContainerRequest> amRMClient, NMClientAsync nmClient, ServiceDiscoverer serviceDiscoverer)
{    this.nmClient = nmClient;    this.amRMClient = amRMClient;    this.serviceDiscoverer = serviceDiscoverer;}
public void metron_f104_0(int number, ModelRequest request)
{    int i = 0;    for (Container c : state.getList(request)) {        if (i < number) {            amRMClient.releaseAssignedContainer(c.getId());            nmClient.stopContainerAsync(c.getId(), c.getNodeId());        } else {            break;        }        i++;    }}
public ContainerTracker metron_f105_0()
{    return state;}
private void metron_f106_0(ContainerId id)
{    containers.remove(id);    state.removeContainer(id);}
public void metron_f107_0(int number, Resource characteristic)
{    Priority pri = Priority.newInstance(0);    state.getQueue(characteristic);    AMRMClient.ContainerRequest request = new AMRMClient.ContainerRequest(characteristic, null, null, pri, true);    for (int i = 0; i < number; ++i) {        amRMClient.addContainerRequest(request);    }}
public void metron_f108_1(List<ContainerStatus> completedContainers)
{        for (ContainerStatus containerStatus : completedContainers) {                removeContainer(containerStatus.getContainerId());                serviceDiscoverer.unregisterByContainer(containerStatus.getContainerId() + "");                assert (containerStatus.getState() == ContainerState.COMPLETE);                int exitStatus = containerStatus.getExitStatus();        if (0 != exitStatus) {                        if (ContainerExitStatus.ABORTED != exitStatus) {                                    } else {                                                            }        } else {                                            }        if (timelineClient != null) {            YarnUtils.INSTANCE.publishContainerEndEvent(timelineClient, containerStatus, domainId, appSubmitterUgi);        }    }}
public BlockingQueue<Container> metron_f109_0(Resource resource)
{    return state.getQueue(resource);}
public void metron_f110_1(List<Container> allocatedContainers)
{        for (Container allocatedContainer : allocatedContainers) {        containers.put(allocatedContainer.getId(), allocatedContainer);        state.registerContainer(allocatedContainer.getResource(), allocatedContainer);            }}
public void metron_f111_0()
{}
public void metron_f112_0(List<NodeReport> updatedNodes)
{}
public float metron_f113_0()
{        float progress = 0;    return progress;}
public void metron_f114_1(Throwable e)
{    }
public void metron_f115_1(ContainerId containerId)
{    if (LOG.isDebugEnabled()) {            }    if (containerId == null) {                throw new IllegalStateException("onContainerStopped returned null container ID!");    }    serviceDiscoverer.unregisterByContainer(containerId.getContainerId() + "");    removeContainer(containerId);}
public void metron_f116_1(ContainerId containerId, ContainerStatus containerStatus)
{    if (LOG.isDebugEnabled()) {            }}
public void metron_f117_1(ContainerId containerId, Map<String, ByteBuffer> allServiceResponse)
{    if (LOG.isDebugEnabled()) {            }    Container container = containers.get(containerId);    if (container != null) {        nmClient.getContainerStatusAsync(containerId, container.getNodeId());    }    if (timelineClient != null && container != null) {        YarnUtils.INSTANCE.publishContainerStartEvent(timelineClient, container, domainId, appSubmitterUgi);    }}
public void metron_f118_1(ContainerId containerId, Throwable t)
{        serviceDiscoverer.unregisterByContainer(containerId.getContainerId() + "");    removeContainer(containerId);}
public void metron_f119_1(ContainerId containerId, Throwable t)
{    }
public void metron_f120_1(ContainerId containerId, Throwable t)
{        serviceDiscoverer.unregisterByContainer(containerId.getContainerId() + "");    removeContainer(containerId);}
public void metron_f121_1()
{            Map<String, LocalResource> localResources = new HashMap<>();        for (File f : new File(".").listFiles()) {            }        String modelScript = localizeResources(localResources, new Path(request.getPath()), appJarLocation);    for (Map.Entry<String, LocalResource> entry : localResources.entrySet()) {            }                        Map<String, String> env = new HashMap<>();                            StringBuffer classPathEnv = new StringBuffer("$CLASSPATH:./*:");        classPathEnv.append(System.getProperty("java.class.path"));        env.put("CLASSPATH", classPathEnv.toString());        String command = ApplicationConstants.Environment.JAVA_HOME.$$() + "/bin/java " + Runner.class.getName() + " " + RunnerOptions.toArgs(RunnerOptions.CONTAINER_ID.of(container.getId().getContainerId() + ""), RunnerOptions.ZK_QUORUM.of(zkQuorum), RunnerOptions.ZK_ROOT.of(zkRoot), RunnerOptions.SCRIPT.of(modelScript), RunnerOptions.NAME.of(request.getName()), RunnerOptions.HOSTNAME.of(containerHostname()), RunnerOptions.VERSION.of(request.getVersion())) + " 1>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/stdout" + " 2>" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/stderr";    List<String> commands = new ArrayList<String>();        commands.add(command);                                    ContainerLaunchContext ctx = ContainerLaunchContext.newInstance(localResources, env, commands, null, allTokens.duplicate(), null);        nmClientAsync.startContainerAsync(container, ctx);}
private Map.Entry<String, LocalResource> metron_f122_0(FileStatus status)
{    URL url = ConverterUtils.getYarnUrlFromURI(status.getPath().toUri());    LocalResource resource = LocalResource.newInstance(url, LocalResourceType.FILE, LocalResourceVisibility.APPLICATION, status.getLen(), status.getModificationTime());    String name = status.getPath().getName();    return new AbstractMap.SimpleEntry<>(name, resource);}
public String metron_f123_1(Map<String, LocalResource> resources, Path scriptLocation, Path appJarLocation)
{    try {                        FileSystem fs = scriptLocation.getFileSystem(conf);        String script = null;        Map.Entry<String, LocalResource> kv = localizeResource(fs.getFileStatus(appJarLocation));        resources.put(kv.getKey(), kv.getValue());        for (RemoteIterator<LocatedFileStatus> it = fs.listFiles(scriptLocation, true); it.hasNext(); ) {            LocatedFileStatus status = it.next();            kv = localizeResource(status);            String name = kv.getKey();            if (name.endsWith(".sh")) {                script = name;            }                        resources.put(name, kv.getValue());        }        return script;    } catch (Exception e) {                return null;    }}
private String metron_f124_1()
{    String nodeHost = null;    try {        boolean hasProtocol = container.getNodeHttpAddress().startsWith("http");        java.net.URL nodehttpAddress = new java.net.URL((hasProtocol ? "" : "http://") + container.getNodeHttpAddress());        nodeHost = nodehttpAddress.getHost();    } catch (MalformedURLException e) {                throw new IllegalStateException("Unable to parse " + container.getNodeHttpAddress() + " into a URL");    }    return nodeHost;}
public static void metron_f125_1(String[] args)
{    boolean result = false;    try {        Client client = new Client();                try {            boolean doRun = client.init(args);            if (!doRun) {                System.exit(0);            }        } catch (IllegalArgumentException e) {            System.err.println(e.getLocalizedMessage());            System.exit(-1);        }        result = client.run();    } catch (Throwable t) {                System.exit(1);    }    if (result) {                System.exit(0);    }        System.exit(2);}
public boolean metron_f126_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f127_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f128_0(CommandLine cli, String def)
{    return has(cli) ? cli.getOptionValue(shortCode) : def;}
public Map.Entry<ClientOptions, String> metron_f129_0(String value)
{    if (option.hasArg()) {        return new AbstractMap.SimpleEntry<>(this, value);    }    return new AbstractMap.SimpleEntry<>(this, null);}
public static String metron_f130_0(Map.Entry<ClientOptions, String>... arg)
{    return Joiner.on(" ").join(Iterables.transform(Arrays.asList(arg), a -> "-" + a.getKey().shortCode + (a.getValue() == null ? "" : (" " + a.getValue()))));}
public static CommandLine metron_f131_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f132_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("MaaSClient", getOptions());}
public static Options metron_f133_0()
{    Options ret = new Options();    for (ClientOptions o : ClientOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public static String metron_f134_0(Class klass) throws URISyntaxException
{    return klass.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();}
public boolean metron_f135_1(String[] args) throws ParseException
{    CommandLine cli = ClientOptions.parse(new PosixParser(), args);    if (LOG4J_PROPERTIES.has(cli)) {        String log4jPath = LOG4J_PROPERTIES.get(cli);        try {            Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);        } catch (Exception e) {                    }    }    keepContainers = false;    zkQuorum = ZK_QUORUM.get(cli);    zkRoot = ZK_ROOT.get(cli, "/metron/maas/config");    appName = "MaaS";    amPriority = 0;    amQueue = QUEUE.get(cli, "default");    amMemory = Integer.parseInt(MASTER_MEMORY.get(cli, "10"));    amVCores = Integer.parseInt(MASTER_VCORE.get(cli, "1"));    if (amMemory < 0) {        throw new IllegalArgumentException("Invalid memory specified for application master, exiting." + " Specified memory=" + amMemory);    }    if (amVCores < 0) {        throw new IllegalArgumentException("Invalid virtual cores specified for application master, exiting." + " Specified virtual cores=" + amVCores);    }    if (!JAR.has(cli)) {        try {            appMasterJar = getJar(ApplicationMaster.class);        } catch (URISyntaxException e) {            throw new IllegalArgumentException("No jar file specified for application master: " + e.getMessage(), e);        }    } else {        appMasterJar = JAR.get(cli);    }    if (SHELL_ENV.has(cli)) {        String[] envs = cli.getOptionValues(SHELL_ENV.option.getOpt());        for (String env : envs) {            env = env.trim();            int index = env.indexOf('=');            if (index == -1) {                shellEnv.put(env, "");                continue;            }            String key = env.substring(0, index);            String val = "";            if (index < (env.length() - 1)) {                val = env.substring(index + 1);            }            shellEnv.put(key, val);        }    }    nodeLabelExpression = NODE_LABEL_EXPRESSION.get(cli, null);    clientTimeout = Integer.parseInt(TIMEOUT.get(cli, "600000"));    attemptFailuresValidityInterval = -1;    log4jPropFile = LOG4J_PROPERTIES.get(cli, "");        if (DOMAIN.has(cli)) {        domainId = DOMAIN.get(cli);        toCreateDomain = CREATE.has(cli);        if (VIEW_ACLS.has(cli)) {            viewACLs = VIEW_ACLS.get(cli);        }        if (MODIFY_ACLS.has(cli)) {            modifyACLs = MODIFY_ACLS.get(cli);        }    }    return true;}
private boolean metron_f137_1(ApplicationId appId) throws YarnException, IOException
{    while (true) {                try {            Thread.sleep(1000);        } catch (InterruptedException e) {                    }                ApplicationReport report = yarnClient.getApplicationReport(appId);                YarnApplicationState state = report.getYarnApplicationState();        FinalApplicationStatus dsStatus = report.getFinalApplicationStatus();        if (YarnApplicationState.RUNNING == state) {                        return true;        }        if (YarnApplicationState.FINISHED == state) {            if (FinalApplicationStatus.SUCCEEDED == dsStatus) {                                return true;            } else {                                return false;            }        } else if (YarnApplicationState.KILLED == state || YarnApplicationState.FAILED == state) {                        return false;        }        if (System.currentTimeMillis() > (clientStartTime + clientTimeout)) {                        forceKillApplication(appId);            return false;        }    }}
private void metron_f138_0(ApplicationId appId) throws YarnException, IOException
{                        yarnClient.killApplication(appId);}
private void metron_f139_0(FileSystem fs, String appId) throws IOException
{    for (Path p : ImmutableList.of(new Path(fs.getHomeDirectory(), appName), new Path(fs.getHomeDirectory(), appName + "/" + appId))) {        if (!fs.exists(p)) {            fs.mkdirs(p);            fs.setPermission(p, new FsPermission((short) 0755));        }    }}
private Path metron_f140_0(FileSystem fs, String fileSrcPath, String fileDstPath, String appId, Map<String, LocalResource> localResources, String resources) throws IOException
{    String suffix = appName + "/" + appId + "/" + fileDstPath;    Path dst = new Path(fs.getHomeDirectory(), suffix);    if (fileSrcPath == null) {        FSDataOutputStream ostream = null;        try {            ostream = FileSystem.create(fs, dst, new FsPermission((short) 0710));            ostream.writeUTF(resources);        } finally {            IOUtils.closeQuietly(ostream);        }    } else {        fs.copyFromLocalFile(new Path(fileSrcPath), dst);    }    fs.setPermission(dst, new FsPermission((short) 0755));    FileStatus scFileStatus = fs.getFileStatus(dst);    LocalResource scRsrc = LocalResource.newInstance(ConverterUtils.getYarnUrlFromURI(dst.toUri()), LocalResourceType.FILE, LocalResourceVisibility.APPLICATION, scFileStatus.getLen(), scFileStatus.getModificationTime());    localResources.put(fileDstPath, scRsrc);    return dst;}
private void metron_f141_1()
{    TimelineClient timelineClient = null;    if (conf.getBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, YarnConfiguration.DEFAULT_TIMELINE_SERVICE_ENABLED)) {        timelineClient = TimelineClient.createTimelineClient();        timelineClient.init(conf);        timelineClient.start();    } else {                return;    }    try {        TimelineDomain domain = new TimelineDomain();        domain.setId(domainId);        domain.setReaders(viewACLs != null && viewACLs.length() > 0 ? viewACLs : " ");        domain.setWriters(modifyACLs != null && modifyACLs.length() > 0 ? modifyACLs : " ");        timelineClient.putDomain(domain);            } catch (Exception e) {            } finally {        timelineClient.stop();    }}
public int metron_f142_0(int size)
{    return (int) (minimumContainerSize * Math.ceil(1.0 * size / minimumContainerSize));}
public BlockingQueue<Container> metron_f143_0(Resource resource)
{    synchronized (acceptedContainersByResource) {        int key = getAdjustedSize(resource.getMemory());        BlockingQueue<Container> queue = acceptedContainersByResource.get(key);        if (queue == null) {            queue = new LinkedBlockingDeque<>();            acceptedContainersByResource.put(key, queue);        }        return queue;    }}
public void metron_f144_0(ContainerId container)
{    synchronized (acceptedContainersByResource) {        for (Map.Entry<Model, List<Container>> kv : launchedContainers.entrySet()) {            for (Iterator<Container> it = kv.getValue().iterator(); it.hasNext(); ) {                Container c = it.next();                if (c.getId().equals(container)) {                    it.remove();                }            }        }    }}
public List<Container> metron_f145_0(ModelRequest request)
{    synchronized (acceptedContainersByResource) {        List<Container> containers = launchedContainers.get(new Model(request.getName(), request.getVersion()));        if (containers == null) {            containers = new ArrayList<>();            launchedContainers.put(new Model(request.getName(), request.getVersion()), containers);        }        return containers;    }}
public void metron_f146_0(Resource resource, Container container)
{    synchronized (acceptedContainersByResource) {        BlockingQueue<Container> queue = getQueue(resource);        queue.add(container);    }}
public void metron_f147_0(Container container, ModelRequest request)
{    synchronized (acceptedContainersByResource) {        getList(request).add(container);    }}
public static void metron_f148_0(Class<?> targetClass, String log4jPath) throws Exception
{    Properties customProperties = new Properties();    FileInputStream fs = null;    InputStream is = null;    try {        fs = new FileInputStream(log4jPath);        is = targetClass.getResourceAsStream("/log4j.properties");        customProperties.load(fs);        Properties originalProperties = new Properties();        originalProperties.load(is);        for (Entry<Object, Object> entry : customProperties.entrySet()) {            originalProperties.setProperty(entry.getKey().toString(), entry.getValue().toString());        }        LogManager.resetConfiguration();        PropertyConfigurator.configure(originalProperties);    } finally {        IOUtils.closeQuietly(is);        IOUtils.closeQuietly(fs);    }}
public MaaSConfig metron_f149_0()
{    return config;}
public CuratorFramework metron_f150_0()
{    return client;}
public void metron_f151_0() throws Exception
{    if (client == null) {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        client = CuratorFrameworkFactory.newClient(zkQuorum, retryPolicy);        client.start();    }    config = ConfigUtil.INSTANCE.read(client, root, new MaaSConfig(), MaaSConfig.class);    cache = new NodeCache(client, root);    cache.getListenable().addListener(() -> {        byte[] data = cache.getCurrentData().getData();        Lock wLock = lock.writeLock();        wLock.lock();        try {            config = _mapper.readValue(data, MaaSConfig.class);        } finally {            wLock.unlock();        }    });    discoverer = new ServiceDiscoverer(client, config.getServiceRoot());    discoverer.start();}
public ServiceDiscoverer metron_f152_0()
{    return discoverer;}
public Map.Entry<RunnerOptions, String> metron_f153_0(String value)
{    if (option.hasArg()) {        return new AbstractMap.SimpleEntry<>(this, value);    }    return new AbstractMap.SimpleEntry<>(this, null);}
public static String metron_f154_0(Map.Entry<RunnerOptions, String>... arg)
{    return Joiner.on(" ").join(Iterables.transform(Arrays.asList(arg), a -> "-" + a.getKey().shortCode + (a.getValue() == null ? "" : (" " + a.getValue()))));}
public boolean metron_f155_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f156_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f157_0(CommandLine cli, String def)
{    return has(cli) ? cli.getOptionValue(shortCode) : def;}
public static CommandLine metron_f158_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f159_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("MaaSRunner", getOptions());}
public static Options metron_f160_0()
{    Options ret = new Options();    for (RunnerOptions o : RunnerOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public static void metron_f161_1(String... argv) throws Exception
{    CommandLine cli = RunnerOptions.parse(new PosixParser(), argv);    String zkQuorum = RunnerOptions.ZK_QUORUM.get(cli);    String zkRoot = RunnerOptions.ZK_ROOT.get(cli);    String script = RunnerOptions.SCRIPT.get(cli);    String name = RunnerOptions.NAME.get(cli);    String version = RunnerOptions.VERSION.get(cli);    String containerId = RunnerOptions.CONTAINER_ID.get(cli);    String hostname = RunnerOptions.HOSTNAME.get(cli);    CuratorFramework client = null;            for (File f : new File(".").listFiles()) {            }    try {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        client = CuratorFrameworkFactory.newClient(zkQuorum, retryPolicy);        client.start();        MaaSConfig config = ConfigUtil.INSTANCE.read(client, zkRoot, new MaaSConfig(), MaaSConfig.class);        JsonInstanceSerializer<ModelEndpoint> serializer = new JsonInstanceSerializer<>(ModelEndpoint.class);        try {            serviceDiscovery = ServiceDiscoveryBuilder.builder(ModelEndpoint.class).client(client).basePath(config.getServiceRoot()).serializer(serializer).build();        } finally {        }                serviceDiscovery.start();        File cwd = new File(script).getParentFile();        File scriptFile = new File(cwd, script);        if (scriptFile.exists() && !scriptFile.canExecute()) {            scriptFile.setExecutable(true);        }        final String cmd = scriptFile.getAbsolutePath();        try {            p = new ProcessBuilder(cmd).directory(cwd).start();        } catch (Exception e) {                                    throw new IllegalStateException(e.getMessage(), e);        }        try {                        Endpoint ep = readEndpoint(cwd);            URL endpointUrl = correctLocalUrl(hostname, ep.getUrl());            ep.setUrl(endpointUrl.toString());                        ModelEndpoint endpoint = new ModelEndpoint();            {                endpoint.setName(name);                endpoint.setContainerId(containerId);                endpoint.setEndpoint(ep);                endpoint.setVersion(version);            }            ;            ServiceInstanceBuilder<ModelEndpoint> builder = ServiceInstance.<ModelEndpoint>builder().address(endpointUrl.getHost()).id(containerId).name(name).port(endpointUrl.getPort()).registrationTimeUTC(System.currentTimeMillis()).serviceType(ServiceType.STATIC).payload(endpoint);            final ServiceInstance<ModelEndpoint> instance = builder.build();            try {                                serviceDiscovery.registerService(instance);                            } catch (Throwable t) {                            }            Runtime.getRuntime().addShutdownHook(new Thread() {                @Override                public void run() {                                        if (p != null) {                                                p.destroyForcibly();                    }                }            });        } finally {            if (p.waitFor() != 0) {                String stderr = Joiner.on("\n").join(IOUtils.readLines(p.getErrorStream()));                String stdout = Joiner.on("\n").join(IOUtils.readLines(p.getInputStream()));                throw new IllegalStateException("Unable to execute " + script + ".  Stderr is: " + stderr + "\nStdout is: " + stdout);            }        }    } finally {        if (serviceDiscovery != null) {            CloseableUtils.closeQuietly(serviceDiscovery);        }        if (client != null) {            CloseableUtils.closeQuietly(client);        }    }}
public void metron_f162_1()
{        if (p != null) {                p.destroyForcibly();    }}
private static URL metron_f163_1(String hostname, String tmpUrl) throws MalformedURLException
{    URL tmp = new URL(tmpUrl);    if (hostname != null && hostname.length() > 0 && localAddresses.contains(tmp.getHost())) {        URL endpointUrl = null;        try {            endpointUrl = new URL(tmp.getProtocol(), hostname, tmp.getPort(), tmp.getFile());        } catch (MalformedURLException e) {                        return tmp;        }        return endpointUrl;    }    return tmp;}
private static Endpoint metron_f164_1(File cwd) throws Exception
{    String content = "";    File f = new File(cwd, Constants.ENDPOINT_DAT);    for (int i = 0; i < NUM_ATTEMPTS; i++) {        if (f.exists()) {            try {                content = Files.toString(f, Charsets.US_ASCII);            } catch (IOException ioe) {            }            if (content != null && content.length() > 0) {                try {                    Endpoint ep = ConfigUtil.INSTANCE.read(content.getBytes(StandardCharsets.UTF_8), Endpoint.class);                    return ep;                } catch (Exception ex) {                                    }            }        }        Thread.sleep(SLEEP_AMT);    }    throw new IllegalStateException("Unable to start process within the allotted time (10 minutes)");}
public static EnumMap<Resources, Integer> metron_f165_0(EnumMap<Resources, Integer> requestedResources, Resource resource)
{    EnumMap<Resources, Integer> ret = new EnumMap<>(Resources.class);    for (Resources r : values()) {        Integer request = requestedResources.get(r);        int resourceAmt = r.callback.apply(resource);        if (request == null || request < 0) {            ret.put(r, resourceAmt);        } else {            ret.put(r, Math.min(resourceAmt, request));        }    }    return ret;}
public Map.Entry<Resources, Integer> metron_f166_0(int n)
{    return new AbstractMap.SimpleEntry<>(this, n);}
public static EnumMap<Resources, Integer> metron_f167_0(Map.Entry<Resources, Integer>... entry)
{    EnumMap<Resources, Integer> ret = new EnumMap<>(Resources.class);    for (Map.Entry<Resources, Integer> kv : entry) {        ret.put(kv.getKey(), kv.getValue());    }    return ret;}
public static Resource metron_f168_0(EnumMap<Resources, Integer> resourceMap)
{    return Resource.newInstance(resourceMap.get(Resources.MEMORY), resourceMap.get(Resources.V_CORE));}
public UserGroupInformation metron_f169_0(Credentials credentials) throws IOException
{    credentials = credentials == null ? UserGroupInformation.getCurrentUser().getCredentials() : credentials;    String appSubmitterUserName = System.getenv(ApplicationConstants.Environment.USER.name());    UserGroupInformation appSubmitterUgi = UserGroupInformation.createRemoteUser(appSubmitterUserName);    appSubmitterUgi.addCredentials(credentials);    return appSubmitterUgi;}
public ByteBuffer metron_f170_1(Credentials credentials) throws IOException
{            credentials = credentials == null ? UserGroupInformation.getCurrentUser().getCredentials() : credentials;    DataOutputBuffer dob = new DataOutputBuffer();    credentials.writeTokenStorageToStream(dob);        Iterator<Token<?>> iter = credentials.getAllTokens().iterator();        while (iter.hasNext()) {        Token<?> token = iter.next();                if (token.getKind().equals(AMRMTokenIdentifier.KIND_NAME)) {            iter.remove();        }    }    return ByteBuffer.wrap(dob.getData(), 0, dob.getLength());}
public void metron_f171_1(final TimelineClient timelineClient, ContainerStatus container, String domainId, UserGroupInformation ugi)
{    final TimelineEntity entity = new TimelineEntity();    entity.setEntityId(container.getContainerId().toString());    entity.setEntityType(ApplicationMaster.DSEntity.DS_CONTAINER.toString());    entity.setDomainId(domainId);    entity.addPrimaryFilter("user", ugi.getShortUserName());    TimelineEvent event = new TimelineEvent();    event.setTimestamp(System.currentTimeMillis());    event.setEventType(ContainerEvents.CONTAINER_END.toString());    event.addEventInfo("State", container.getState().name());    event.addEventInfo("Exit Status", container.getExitStatus());    entity.addEvent(event);    try {        timelineClient.putEntities(entity);    } catch (YarnException | IOException e) {            }}
public void metron_f172_1(final TimelineClient timelineClient, String appAttemptId, ContainerEvents appEvent, String domainId, UserGroupInformation ugi)
{    final TimelineEntity entity = new TimelineEntity();    entity.setEntityId(appAttemptId);    entity.setEntityType(ApplicationMaster.DSEntity.DS_APP_ATTEMPT.toString());    entity.setDomainId(domainId);    entity.addPrimaryFilter("user", ugi.getShortUserName());    TimelineEvent event = new TimelineEvent();    event.setEventType(appEvent.toString());    event.setTimestamp(System.currentTimeMillis());    entity.addEvent(event);    try {        timelineClient.putEntities(entity);    } catch (YarnException | IOException e) {            }}
public void metron_f173_1(final TimelineClient timelineClient, Container container, String domainId, UserGroupInformation ugi)
{    final TimelineEntity entity = new TimelineEntity();    entity.setEntityId("" + container.getId());    entity.setEntityType(ApplicationMaster.DSEntity.DS_CONTAINER.toString());    entity.setDomainId(domainId);    entity.addPrimaryFilter("user", ugi.getShortUserName());    TimelineEvent event = new TimelineEvent();    event.setTimestamp(System.currentTimeMillis());    event.setEventType(ContainerEvents.CONTAINER_START.toString());    event.addEventInfo("Node", container.getNodeId().toString());    event.addEventInfo("Resources", container.getResource().toString());    entity.addEvent(event);    try {        ugi.doAs(new PrivilegedExceptionAction<TimelinePutResponse>() {            @Override            public TimelinePutResponse run() throws Exception {                return timelineClient.putEntities(entity);            }        });    } catch (Exception e) {            }}
public TimelinePutResponse metron_f174_0() throws Exception
{    return timelineClient.putEntities(entity);}
public boolean metron_f175_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f176_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f177_0(CommandLine cli, String def)
{    return has(cli) ? cli.getOptionValue(shortCode) : def;}
public Map.Entry<ModelSubmissionOptions, String> metron_f178_0(String value)
{    if (option.hasArg()) {        return new AbstractMap.SimpleEntry<>(this, value);    }    return new AbstractMap.SimpleEntry<>(this, null);}
public static String metron_f179_0(Map.Entry<ModelSubmissionOptions, String>... arg)
{    return Joiner.on(" ").join(Iterables.transform(Arrays.asList(arg), a -> "-" + a.getKey().option.getOpt() + (a.getValue() == null ? "" : (" " + a.getValue()))));}
public static CommandLine metron_f180_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f181_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("ModelSubmission", getOptions());}
public static Options metron_f182_0()
{    Options ret = new Options();    for (ModelSubmissionOptions o : ModelSubmissionOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public void metron_f183_0(FileSystem fs, String... argv) throws Exception
{    CommandLine cli = ModelSubmissionOptions.parse(new PosixParser(), argv);    if (ModelSubmissionOptions.LOG4J_PROPERTIES.has(cli)) {        Log4jPropertyHelper.updateLog4jConfiguration(ModelSubmission.class, ModelSubmissionOptions.LOG4J_PROPERTIES.get(cli));    }    ModelRequest request = null;    CuratorFramework client = null;    try {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        client = CuratorFrameworkFactory.newClient(ModelSubmissionOptions.ZK_QUORUM.get(cli), retryPolicy);        client.start();        MaaSConfig config = ConfigUtil.INSTANCE.read(client, ModelSubmissionOptions.ZK_ROOT.get(cli, "/metron/maas/config"), new MaaSConfig(), MaaSConfig.class);        String mode = ModelSubmissionOptions.MODE.get(cli);        if (mode.equalsIgnoreCase("ADD")) {            request = new ModelRequest() {                {                    setName(ModelSubmissionOptions.NAME.get(cli));                    setAction(Action.ADD);                    setVersion(ModelSubmissionOptions.VERSION.get(cli));                    setNumInstances(Integer.parseInt(ModelSubmissionOptions.NUM_INSTANCES.get(cli)));                    setMemory(Integer.parseInt(ModelSubmissionOptions.MEMORY.get(cli)));                    setPath(ModelSubmissionOptions.HDFS_MODEL_PATH.get(cli));                }            };        } else if (mode.equalsIgnoreCase("REMOVE")) {            request = new ModelRequest() {                {                    setName(ModelSubmissionOptions.NAME.get(cli));                    setAction(Action.REMOVE);                    setNumInstances(Integer.parseInt(ModelSubmissionOptions.NUM_INSTANCES.get(cli)));                    setVersion(ModelSubmissionOptions.VERSION.get(cli));                }            };        } else if (mode.equalsIgnoreCase("LIST")) {            String name = ModelSubmissionOptions.NAME.get(cli, null);            String version = ModelSubmissionOptions.VERSION.get(cli, null);            ServiceDiscoverer serviceDiscoverer = new ServiceDiscoverer(client, config.getServiceRoot());            Model model = new Model(name, version);            Map<Model, List<ModelEndpoint>> endpoints = serviceDiscoverer.listEndpoints(model);            for (Map.Entry<Model, List<ModelEndpoint>> kv : endpoints.entrySet()) {                String modelTitle = "Model " + kv.getKey().getName() + " @ " + kv.getKey().getVersion();                System.out.println(modelTitle);                for (ModelEndpoint endpoint : kv.getValue()) {                    System.out.println(endpoint);                }            }        }        if (ModelSubmissionOptions.LOCAL_MODEL_PATH.has(cli)) {            File localDir = new File(ModelSubmissionOptions.LOCAL_MODEL_PATH.get(cli));            Path hdfsPath = new Path(ModelSubmissionOptions.HDFS_MODEL_PATH.get(cli));            updateHDFS(fs, localDir, hdfsPath);        }        Queue<ModelRequest> queue = config.createQueue(ImmutableMap.of(ZKQueue.ZK_CLIENT, client));        queue.enqueue(request);    } finally {        if (client != null) {            client.close();        }    }}
public static void metron_f184_0(String... argv) throws Exception
{    FileSystem fs = FileSystem.get(new Configuration());    ModelSubmission submission = new ModelSubmission();    submission.execute(fs, argv);}
public static void metron_f185_0(FileSystem fs, File localDir, Path hdfsPath) throws IOException
{    if (localDir.exists() && localDir.isDirectory()) {        if (!fs.exists(hdfsPath)) {            fs.mkdirs(hdfsPath);        }        for (File f : localDir.listFiles()) {            if (f.getName().equals(Constants.ENDPOINT_DAT)) {                                continue;            }            Path p = new Path(hdfsPath, f.getName());            FSDataOutputStream out = fs.create(p);            BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));            IOUtils.copy(in, out);            IOUtils.closeQuietly(in);            IOUtils.closeQuietly(out);        }    }}
public static void metron_f186_1() throws Exception
{    UnitTestHelper.setJavaLoggingLevel(Level.SEVERE);        zkServerComponent = new ZKServerComponent();    yarnComponent = new YarnComponent().withApplicationMasterClass(ApplicationMaster.class).withTestName(MaasIntegrationTest.class.getSimpleName());    runner = new ComponentRunner.Builder().withComponent("yarn", yarnComponent).withComponent("zk", zkServerComponent).withMillisecondsBetweenAttempts(15000).withNumRetries(10).build();    runner.start();    String zookeeperUrl = zkServerComponent.getConnectionString();    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    client = CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy);    client.start();}
public static void metron_f187_0()
{    if (client != null) {        client.close();    }    runner.stop();}
public void metron_f188_0()
{    runner.reset();}
public void metron_f189_0() throws Exception
{    testDSShell(true);}
public void metron_f190_0() throws Exception
{    testDSShell(false);}
public void metron_f191_1(boolean haveDomain) throws Exception
{    MaaSConfig config = new MaaSConfig() {        {            setServiceRoot("/maas/service");            setQueueConfig(new HashMap<String, Object>() {                {                    put(ZKQueue.ZK_PATH, "/maas/queue");                }            });        }    };    String configRoot = "/maas/config";    byte[] configData = ConfigUtil.INSTANCE.toBytes(config);    try {        client.setData().forPath(configRoot, configData);    } catch (KeeperException.NoNodeException e) {        client.create().creatingParentsIfNeeded().forPath(configRoot, configData);    }    String[] args = { "--jar", yarnComponent.getAppMasterJar(), "--zk_quorum", zkServerComponent.getConnectionString(), "--zk_root", configRoot, "--master_memory", "512", "--master_vcores", "2" };    if (haveDomain) {        String[] domainArgs = { "--domain", "TEST_DOMAIN", "--view_acls", "reader_user reader_group", "--modify_acls", "writer_user writer_group", "--create" };        List<String> argsList = new ArrayList<String>(Arrays.asList(args));        argsList.addAll(Arrays.asList(domainArgs));        args = argsList.toArray(new String[argsList.size()]);    }    YarnConfiguration conf = yarnComponent.getConfig();        final Client client = new Client(new Configuration(conf));    boolean initSuccess = client.init(args);    Assert.assertTrue(initSuccess);        final AtomicBoolean result = new AtomicBoolean(false);    Thread t = new Thread() {        @Override        public void run() {            try {                result.set(client.run());            } catch (Exception e) {                throw new RuntimeException(e);            }        }    };    t.start();    YarnClient yarnClient = YarnClient.createYarnClient();    yarnClient.init(new Configuration(conf));    yarnClient.start();    String hostName = NetUtils.getHostname();    boolean verified = false;    String errorMessage = "";    while (!verified) {        List<ApplicationReport> apps = yarnClient.getApplications();        if (apps.size() == 0) {            Thread.sleep(10);            continue;        }        ApplicationReport appReport = apps.get(0);        if (appReport.getHost().equals("N/A")) {            Thread.sleep(10);            continue;        }        errorMessage = "Expected host name to start with '" + hostName + "', was '" + appReport.getHost() + "'. Expected rpc port to be '-1', was '" + appReport.getRpcPort() + "'.";        if (checkHostname(appReport.getHost()) && appReport.getRpcPort() == -1) {            verified = true;        }        if (appReport.getYarnApplicationState() == YarnApplicationState.FINISHED) {            break;        }    }    Assert.assertTrue(errorMessage, verified);    FileSystem fs = FileSystem.get(conf);    try {        new ModelSubmission().execute(FileSystem.get(conf), new String[] { "--name", "dummy", "--version", "1.0", "--zk_quorum", zkServerComponent.getConnectionString(), "--zk_root", configRoot, "--local_model_path", "src/test/resources/maas", "--hdfs_model_path", new Path(fs.getHomeDirectory(), "maas/dummy").toString(), "--num_instances", "1", "--memory", "100", "--mode", "ADD", "--log4j", "src/test/resources/log4j.properties" });        ServiceDiscoverer discoverer = new ServiceDiscoverer(this.client, config.getServiceRoot());        discoverer.start();        {            boolean passed = false;            for (int i = 0; i < 100; ++i) {                try {                    List<ModelEndpoint> endpoints = discoverer.getEndpoints(new Model("dummy", "1.0"));                    if (endpoints != null && endpoints.size() == 1) {                        LOG.trace("Found endpoints: " + endpoints.get(0));                        String output = makeRESTcall(new URL(endpoints.get(0).getEndpoint().getUrl() + "/echo/casey"));                        if (output.contains("casey")) {                            passed = true;                            break;                        }                    }                } catch (Exception e) {                }                Thread.sleep(2000);            }            Assert.assertTrue(passed);        }        {            List<ModelEndpoint> endpoints = discoverer.getEndpoints(new Model("dummy", "1.0"));            Assert.assertNotNull(endpoints);            Assert.assertEquals(1, endpoints.size());        }        new ModelSubmission().execute(FileSystem.get(conf), new String[] { "--name", "dummy", "--version", "1.0", "--zk_quorum", zkServerComponent.getConnectionString(), "--zk_root", configRoot, "--num_instances", "1", "--mode", "REMOVE" });        {            boolean passed = false;            for (int i = 0; i < 100; ++i) {                try {                    List<ModelEndpoint> endpoints = discoverer.getEndpoints(new Model("dummy", "1.0"));                                        if (endpoints == null || endpoints.size() == 0) {                        passed = true;                        break;                    }                } catch (Exception e) {                }                Thread.sleep(2000);            }            Assert.assertTrue(passed);        }    } finally {        cleanup();    }}
public void metron_f192_0()
{    try {        result.set(client.run());    } catch (Exception e) {        throw new RuntimeException(e);    }}
private void metron_f193_0()
{    try {        LOG.trace("Cleaning up...");        String line;        Process p = Runtime.getRuntime().exec("ps -e");        BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream(), StandardCharsets.UTF_8));        while ((line = input.readLine()) != null) {            if (line.contains("dummy_rest.sh")) {                String pid = Iterables.get(Splitter.on(" ").split(line.replaceAll("\\s+", " ").trim()), 0);                LOG.trace("Killing " + pid + " from " + line);                Runtime.getRuntime().exec("kill -9 " + pid);            }        }        input.close();    } catch (Exception err) {        err.printStackTrace();    }}
private String metron_f194_0(URL url) throws IOException
{    HttpURLConnection conn = null;        try {        conn = (HttpURLConnection) url.openConnection();        conn.setRequestMethod("GET");        if (conn.getResponseCode() != 200) {            throw new RuntimeException("Failed : HTTP error code : " + conn.getResponseCode());        }        BufferedReader br = new BufferedReader(new InputStreamReader((conn.getInputStream()), StandardCharsets.UTF_8));        String output = "";        String line;        while ((line = br.readLine()) != null) {            output += line + "\n";        }        return output;    } finally {        if (conn != null) {            conn.disconnect();        }    }}
private boolean metron_f195_0(String appHostname) throws Exception
{    String hostname = NetUtils.getHostname();    if (hostname.equals(appHostname)) {        return true;    }    Assert.assertTrue("Unknown format for hostname " + appHostname, appHostname.contains("/"));    Assert.assertTrue("Unknown format for hostname " + hostname, hostname.contains("/"));    String[] appHostnameParts = appHostname.split("/");    String[] hostnameParts = hostname.split("/");    return (compareFQDNs(appHostnameParts[0], hostnameParts[0]) && checkIPs(hostnameParts[0], hostnameParts[1], appHostnameParts[1]));}
private boolean metron_f196_0(String appHostname, String hostname) throws Exception
{    if (appHostname.equals(hostname)) {        return true;    }    String appFQDN = InetAddress.getByName(appHostname).getCanonicalHostName();    String localFQDN = InetAddress.getByName(hostname).getCanonicalHostName();    return appFQDN.equals(localFQDN);}
private boolean metron_f197_0(String hostname, String localIP, String appIP) throws Exception
{    if (localIP.equals(appIP)) {        return true;    }    boolean appIPCheck = false;    boolean localIPCheck = false;    InetAddress[] addresses = InetAddress.getAllByName(hostname);    for (InetAddress ia : addresses) {        if (ia.getHostAddress().equals(appIP)) {            appIPCheck = true;            continue;        }        if (ia.getHostAddress().equals(localIP)) {            localIPCheck = true;        }    }    return (appIPCheck && localIPCheck);}
private int metron_f198_0(int containerNum, List<String> expectedContent, boolean count, String expectedWord)
{    File logFolder = new File(yarnComponent.getYARNCluster().getNodeManager(0).getConfig().get(YarnConfiguration.NM_LOG_DIRS, YarnConfiguration.DEFAULT_NM_LOG_DIRS));    File[] listOfFiles = logFolder.listFiles();    int currentContainerLogFileIndex = -1;    for (int i = listOfFiles.length - 1; i >= 0; i--) {        if (listOfFiles[i].listFiles().length == containerNum + 1) {            currentContainerLogFileIndex = i;            break;        }    }    Assert.assertTrue(currentContainerLogFileIndex != -1);    File[] containerFiles = listOfFiles[currentContainerLogFileIndex].listFiles();    int numOfWords = 0;    for (int i = 0; i < containerFiles.length; i++) {        for (File output : containerFiles[i].listFiles()) {            if (output.getName().trim().contains("stdout")) {                BufferedReader br = null;                List<String> stdOutContent = new ArrayList<String>();                try {                    String sCurrentLine;                    br = new BufferedReader(new InputStreamReader(new FileInputStream(output), StandardCharsets.UTF_8));                    int numOfline = 0;                    while ((sCurrentLine = br.readLine()) != null) {                        if (count) {                            if (sCurrentLine.contains(expectedWord)) {                                numOfWords++;                            }                        } else if (output.getName().trim().equals("stdout")) {                            if (!Shell.WINDOWS) {                                Assert.assertEquals("The current is" + sCurrentLine, expectedContent.get(numOfline), sCurrentLine.trim());                                numOfline++;                            } else {                                stdOutContent.add(sCurrentLine.trim());                            }                        }                    }                    /* By executing bat script using cmd /c,             * it will output all contents from bat script first             * It is hard for us to do check line by line             * Simply check whether output from bat file contains             * all the expected messages             */                    if (Shell.WINDOWS && !count && output.getName().trim().equals("stdout")) {                        Assert.assertTrue(stdOutContent.containsAll(expectedContent));                    }                } catch (IOException e) {                    e.printStackTrace();                } finally {                    try {                        if (br != null)                            br.close();                    } catch (IOException ex) {                        ex.printStackTrace();                    }                }            }        }    }    return numOfWords;}
public Response metron_f199_0(@QueryParam("host") String host) throws JsonProcessingException
{    Boolean b = isMalicious.get(host);    boolean isMalicious = b != null && b;    Map<String, Boolean> ret = new HashMap<String, Boolean>();    ret.put("is_malicious", isMalicious);    String resp = JSONUtils.INSTANCE.toJSON(ret, true);    return Response.ok(resp, MediaType.APPLICATION_JSON_TYPE).build();}
public Set<Class<?>> metron_f200_0()
{    return classes;}
public static void metron_f201_0(int port) throws IOException
{        URI uri = UriBuilder.fromUri("http://localhost/").port(port).build();    server = HttpServer.create(new InetSocketAddress(uri.getPort()), 0);    HttpHandler handler = RuntimeDelegate.getInstance().createEndpoint(new ApplicationConfig(), HttpHandler.class);    server.createContext(uri.getPath(), handler);    server.start();}
public static void metron_f202_0()
{    if (server != null) {        server.stop(0);    }}
public static void metron_f203_0() throws Exception
{    UnitTestHelper.setJavaLoggingLevel(WebApplicationImpl.class, Level.WARNING);    MockDGAModel.start(8282);    testZkServer = new TestingServer(true);    zookeeperUrl = testZkServer.getConnectString();    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    client = CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy);    client.start();    context = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).build();    MaaSConfig config = ConfigUtil.INSTANCE.read(client, "/metron/maas/config", new MaaSConfig(), MaaSConfig.class);    discoverer = new ServiceDiscoverer(client, config.getServiceRoot());    discoverer.start();    endpointUrl = new URL("http://localhost:8282");    ModelEndpoint endpoint = new ModelEndpoint();    {        endpoint.setName("dga");        endpoint.setContainerId("0");        Endpoint ep = new Endpoint();        ep.setUrl(endpointUrl.toString());        endpoint.setEndpoint(ep);        endpoint.setVersion("1.0");    }    ;    ServiceInstanceBuilder<ModelEndpoint> builder = ServiceInstance.<ModelEndpoint>builder().address(endpointUrl.getHost()).id("0").name("dga").port(endpointUrl.getPort()).registrationTimeUTC(System.currentTimeMillis()).serviceType(ServiceType.STATIC).payload(endpoint);    final ServiceInstance<ModelEndpoint> instance = builder.build();    discoverer.getServiceDiscovery().registerService(instance);        for (int i = 0; i < 10; ++i) {        try {            Object o = discoverer.getEndpoint("dga");            if (o != null) {                break;            }        } catch (Exception e) {        }        Thread.sleep(1000);    }}
public void metron_f204_0() throws Exception
{    String stellar = "MAAS_GET_ENDPOINT('dga')";    Object result = run(stellar, new HashMap<>(), context);    Assert.assertTrue(result instanceof Map);    Map<String, String> resMap = (Map<String, String>) result;    Assert.assertEquals(resMap.get("url"), "http://localhost:8282");    Assert.assertEquals(resMap.get("name"), "dga");    Assert.assertEquals(resMap.get("version"), "1.0");    Assert.assertEquals(resMap.get("endpoint:apply"), "apply");}
public void metron_f205_0() throws Exception
{    String stellar = "MAAS_GET_ENDPOINT('dga', '1.0')";    Object result = run(stellar, new HashMap<>(), context);    Assert.assertTrue(result instanceof Map);    Map<String, String> resMap = (Map<String, String>) result;    Assert.assertEquals(resMap.get("url"), "http://localhost:8282");    Assert.assertEquals(resMap.get("name"), "dga");    Assert.assertEquals(resMap.get("version"), "1.0");    Assert.assertEquals(resMap.get("endpoint:apply"), "apply");}
public void metron_f206_0() throws Exception
{    String stellar = "MAAS_GET_ENDPOINT('dga', '2.0')";    Object result = run(stellar, new HashMap<>(), context);    Assert.assertNull(result);}
public void metron_f207_0() throws Exception
{    {        String stellar = "MAP_GET('is_malicious', MAAS_MODEL_APPLY(MAAS_GET_ENDPOINT('dga'), {'host': host}))";        Object result = run(stellar, ImmutableMap.of("host", "badguy.com"), context);        Assert.assertTrue((Boolean) result);    }    {        String stellar = "MAP_GET('is_malicious', MAAS_MODEL_APPLY(MAAS_GET_ENDPOINT('dga'), {'host': host}))";        Object result = run(stellar, ImmutableMap.of("host", "youtube.com"), context);        Assert.assertFalse((Boolean) result);    }    {        String stellar = "MAP_GET('is_malicious', MAAS_MODEL_APPLY(MAAS_GET_ENDPOINT('dga'), 'apply', {'host': host}))";        Object result = run(stellar, ImmutableMap.of("host", "youtube.com"), context);        Assert.assertFalse((Boolean) result);    }}
public void metron_f208_0()
{    {        String stellar = "MAP_GET('is_malicious', MAAS_MODEL_APPLY(MAAS_GET_ENDPOINT('dga', '2.0'), {'host': host}))";        Object result = run(stellar, ImmutableMap.of("host", "youtube.com"), context);        Assert.assertNull(result);    }}
public static void metron_f209_0()
{    MockDGAModel.shutdown();    if (discoverer != null) {        CloseableUtils.closeQuietly(discoverer);    }    if (client != null) {        CloseableUtils.closeQuietly(client);    }    if (testZkServer != null) {        CloseableUtils.closeQuietly(testZkServer);    }}
public List<ProfileMeasurement> metron_f210_0(Class<T> clazz, String profile, String entity, List<Object> groups, long start, long end, Optional<T> defaultValue)
{    List<ProfilePeriod> periods = ProfilePeriod.visitPeriods(start, end, periodDurationMillis, TimeUnit.MILLISECONDS, Optional.empty(), period -> period);    return fetch(clazz, profile, entity, groups, periods, defaultValue);}
public List<ProfileMeasurement> metron_f211_0(Class<T> clazz, String profile, String entity, List<Object> groups, Iterable<ProfilePeriod> periods, Optional<T> defaultValue)
{        List<ProfileMeasurement> toFetch = new ArrayList<>();    for (ProfilePeriod period : periods) {        toFetch.add(new ProfileMeasurement().withProfileName(profile).withEntity(entity).withPeriod(period).withGroups(groups));    }        return doFetch(toFetch, clazz, defaultValue);}
private List<ProfileMeasurement> metron_f212_0(List<ProfileMeasurement> measurements, Class<T> clazz, Optional<T> defaultValue)
{    List<ProfileMeasurement> values = new ArrayList<>();        byte[] columnFamily = Bytes.toBytes(columnBuilder.getColumnFamily());    byte[] columnQualifier = columnBuilder.getColumnQualifier("value");    List<Get> gets = new ArrayList<>();    for (ProfileMeasurement measurement : measurements) {        byte[] rowKey = rowKeyBuilder.rowKey(measurement);        Get get = new Get(rowKey).addColumn(columnFamily, columnQualifier);        gets.add(get);    }        try {        Result[] results = tableProvider.getTable(hbaseConfig, tableName).get(gets);        for (int i = 0; i < results.length; ++i) {            Result result = results[i];            ProfileMeasurement measurement = measurements.get(i);            boolean exists = result.containsColumn(columnFamily, columnQualifier);            if (exists) {                                byte[] value = result.getValue(columnFamily, columnQualifier);                measurement.withProfileValue(SerDeUtils.fromBytes(value, clazz));                values.add(measurement);            } else if (defaultValue.isPresent()) {                                measurement.withProfileValue(defaultValue.get());                values.add(measurement);            } else {                        }        }    } catch (IOException e) {        throw new RuntimeException(e);    }    return values;}
public void metron_f213_0(TableProvider tableProvider)
{    this.tableProvider = tableProvider;}
public void metron_f214_0(RowKeyBuilder rowKeyBuilder)
{    this.rowKeyBuilder = rowKeyBuilder;}
public void metron_f215_0(ColumnBuilder columnBuilder)
{    this.columnBuilder = columnBuilder;}
public Object metron_f216_0(List<Object> args, Context context) throws ParseException
{    Optional<Map> configOverridesMap = Optional.empty();    long durationAgo = Util.getArg(0, Long.class, args);    String unitsName = Util.getArg(1, String.class, args);    TimeUnit units = TimeUnit.valueOf(unitsName);    if (args.size() > 2) {        Map rawMap = Util.getArg(2, Map.class, args);        configOverridesMap = rawMap == null || rawMap.isEmpty() ? Optional.empty() : Optional.of(rawMap);    }    Map<String, Object> effectiveConfigs = Util.getEffectiveConfig(context, configOverridesMap.orElse(null));    Long tickDuration = ProfilerClientConfig.PROFILER_PERIOD.get(effectiveConfigs, Long.class);    TimeUnit tickUnit = TimeUnit.valueOf(ProfilerClientConfig.PROFILER_PERIOD_UNITS.get(effectiveConfigs, String.class));    long end = System.currentTimeMillis();    long start = end - units.toMillis(durationAgo);    return ProfilePeriod.visitPeriods(start, end, tickDuration, tickUnit, Optional.empty(), period -> period);}
public void metron_f217_0(Context context)
{}
public boolean metron_f218_0()
{    return true;}
public void metron_f219_0(Context context)
{}
public boolean metron_f220_0()
{    return true;}
public Object metron_f221_0(List<Object> args, Context context) throws ParseException
{    String profile = getArg(0, String.class, args);    String entity = getArg(1, String.class, args);    Optional<List<ProfilePeriod>> periods = Optional.ofNullable(getArg(2, List.class, args));        @SuppressWarnings("unchecked")    List<Object> groups = null;    Map configOverridesMap = null;    if (args.size() < 4) {                groups = new ArrayList<>(0);    } else if (args.get(3) instanceof List) {                groups = getArg(3, List.class, args);        if (args.size() >= 5) {            configOverridesMap = getArg(4, Map.class, args);            if (configOverridesMap.isEmpty())                configOverridesMap = null;        }    } else {                        groups = getGroupsArg(3, args);    }    Map<String, Object> effectiveConfig = getEffectiveConfig(context, configOverridesMap);    Object defaultValue = null;        if (client == null || !cachedConfigMap.equals(effectiveConfig)) {        RowKeyBuilder rowKeyBuilder = getRowKeyBuilder(effectiveConfig);        ColumnBuilder columnBuilder = getColumnBuilder(effectiveConfig);        long periodDuration = getPeriodDurationInMillis(effectiveConfig);        String tableName = PROFILER_HBASE_TABLE.get(effectiveConfig, String.class);        Configuration hbaseConfig = HBaseConfiguration.create();        client = new HBaseProfilerClient(getTableProvider(effectiveConfig), rowKeyBuilder, columnBuilder, periodDuration, tableName, hbaseConfig);        cachedConfigMap = effectiveConfig;    }    if (cachedConfigMap != null) {        defaultValue = ProfilerClientConfig.PROFILER_DEFAULT_VALUE.get(cachedConfigMap);    }    List<ProfileMeasurement> measurements = client.fetch(Object.class, profile, entity, groups, periods.orElse(new ArrayList<>(0)), Optional.ofNullable(defaultValue));        List<Object> values = new ArrayList<>();    for (ProfileMeasurement m : measurements) {        values.add(m.getProfileValue());    }    return values;}
private List<Object> metron_f222_0(int startIndex, List<Object> args)
{    List<Object> groups = new ArrayList<>();    for (int i = startIndex; i < args.size(); i++) {        String group = getArg(i, String.class, args);        groups.add(group);    }    return groups;}
private ColumnBuilder metron_f223_0(Map<String, Object> global)
{    ColumnBuilder columnBuilder;    String columnFamily = PROFILER_COLUMN_FAMILY.get(global, String.class);    columnBuilder = new ValueOnlyColumnBuilder(columnFamily);    return columnBuilder;}
private RowKeyBuilder metron_f224_1(Map<String, Object> global)
{        long duration = PROFILER_PERIOD.get(global, Long.class);            String configuredUnits = PROFILER_PERIOD_UNITS.get(global, String.class);    TimeUnit units = TimeUnit.valueOf(configuredUnits);            Integer saltDivisor = PROFILER_SALT_DIVISOR.get(global, Integer.class);        return new SaltyRowKeyBuilder(saltDivisor, duration, units);}
private TableProvider metron_f225_0(Map<String, Object> global)
{    String clazzName = PROFILER_HBASE_TABLE_PROVIDER.get(global, String.class);    TableProvider provider;    try {        @SuppressWarnings("unchecked")        Class<? extends TableProvider> clazz = (Class<? extends TableProvider>) Class.forName(clazzName);        provider = clazz.getConstructor().newInstance();    } catch (Exception e) {        provider = new HTableProvider();    }    return provider;}
private boolean metron_f226_0(Range<Long> interval, long ts)
{    return interval.contains(ts) || interval.getMaximum() == ts;}
public boolean metron_f227_0(T x)
{    long ts = timestampTransformer.apply(x);    int pos = Collections.binarySearch(intervals, Range.is(ts), INTERVAL_COMPARATOR);    if (pos < 0) {        pos = -pos - 1;    }    Optional<Range<Long>> right = pos >= 0 && pos < intervals.size() ? Optional.of(intervals.get(pos)) : Optional.empty();    Optional<Range<Long>> left = pos - 1 >= 0 && pos - 1 < intervals.size() ? Optional.of(intervals.get(pos - 1)) : Optional.empty();    return (right.isPresent() ? containsInclusive(right.get(), ts) : false) || (left.isPresent() ? containsInclusive(left.get(), ts) : false);}
public String metron_f228_0()
{    return key;}
public Object metron_f229_0()
{    return getDefault(valueType);}
public T metron_f230_0(Class<T> clazz)
{    return defaultValue == null ? null : ConversionUtils.convert(defaultValue, clazz);}
public Object metron_f231_0(Map<String, Object> profilerConfig)
{    return getOrDefault(profilerConfig, defaultValue);}
public Object metron_f232_0(Map<String, Object> profilerConfig, Object defaultValue)
{    return getOrDefault(profilerConfig, defaultValue, valueType);}
public T metron_f233_0(Map<String, Object> profilerConfig, Class<T> clazz)
{    return getOrDefault(profilerConfig, defaultValue, clazz);}
public T metron_f234_0(Map<String, Object> profilerConfig, Object defaultValue, Class<T> clazz)
{    Object o = profilerConfig.getOrDefault(key, defaultValue);    return o == null ? null : ConversionUtils.convert(o, clazz);}
public String metron_f235_0()
{    return key;}
public static void metron_f236_0(Context context, Context.Capabilities[] required) throws IllegalStateException
{        String missing = Stream.of(required).filter(c -> !context.getCapability(c).isPresent()).map(c -> c.toString()).collect(Collectors.joining(", "));    if (StringUtils.isNotBlank(missing) || context == null) {        throw new IllegalStateException("missing required context: " + missing);    }}
public static Map<String, Object> metron_f237_0(Context context, Map configOverridesMap) throws ParseException
{        final Context.Capabilities[] required = { GLOBAL_CONFIG };    validateCapabilities(context, required);    @SuppressWarnings("unchecked")    Map<String, Object> global = (Map<String, Object>) context.getCapability(GLOBAL_CONFIG).get();    Map<String, Object> result = new HashMap<>(6);        for (ProfilerClientConfig k : ProfilerClientConfig.values()) {        Object globalValue = global.containsKey(k.key) ? ConversionUtils.convert(global.get(k.key), k.valueType) : null;        Object overrideValue = configOverridesMap == null ? null : k.getOrDefault(configOverridesMap, null);        Object defaultValue = k.defaultValue;        if (overrideValue != null) {            result.put(k.key, overrideValue);        } else if (globalValue != null) {            result.put(k.key, globalValue);        } else if (defaultValue != null) {            result.put(k.key, defaultValue);        }    }    return result;}
public static T metron_f238_0(int index, Class<T> clazz, List<Object> args)
{    if (index >= args.size()) {        throw new IllegalArgumentException(format("expected at least %d argument(s), found %d", index + 1, args.size()));    }    return ConversionUtils.convert(args.get(index), clazz);}
public static long metron_f239_1(Map<String, Object> global)
{    long duration = PROFILER_PERIOD.get(global, Long.class);        String configuredUnits = PROFILER_PERIOD_UNITS.get(global, String.class);    TimeUnit units = TimeUnit.valueOf(configuredUnits);        return units.toMillis(duration);}
public void metron_f240_0(Context context)
{}
public boolean metron_f241_0()
{    return true;}
public Object metron_f242_0(List<Object> args, Context context) throws ParseException
{        String profile = getArg(0, String.class, args);    String entity = getArg(1, String.class, args);    List<ProfilePeriod> periods = getArg(2, List.class, args);        List<Object> groups = new ArrayList<>();    if (args.size() >= 4) {        groups = getArg(3, List.class, args);    }        Map<String, Object> globals = (Map<String, Object>) context.getCapability(GLOBAL_CONFIG).orElse(Collections.emptyMap());        if (client == null) {        RowKeyBuilder rowKeyBuilder = getRowKeyBuilder(globals);        ColumnBuilder columnBuilder = getColumnBuilder(globals);        TableProvider provider = getTableProvider(globals);        long periodDuration = getPeriodDurationInMillis(globals);        client = new HBaseProfilerClient(provider, rowKeyBuilder, columnBuilder, periodDuration, getTableName(globals), HBaseConfiguration.create());    }        Optional<Object> defaultValue = Optional.empty();    if (globals != null) {        defaultValue = Optional.ofNullable(PROFILER_DEFAULT_VALUE.get(globals));    }    List<ProfileMeasurement> measurements = client.fetch(Object.class, profile, entity, groups, periods, defaultValue);        List<Object> results = new ArrayList<>();    for (ProfileMeasurement measurement : measurements) {        results.add(render(measurement));    }    return results;}
private Map<String, Object> metron_f243_0(ProfileMeasurement measurement)
{    Map<String, Object> view = new HashMap<>();    view.put(PROFILE_KEY, measurement.getProfileName());    view.put(ENTITY_KEY, measurement.getEntity());    view.put(PERIOD_KEY, measurement.getPeriod().getPeriod());    view.put(PERIOD_START_KEY, measurement.getPeriod().getStartTimeMillis());    view.put(PERIOD_END_KEY, measurement.getPeriod().getEndTimeMillis());    view.put(VALUE_KEY, measurement.getProfileValue());    view.put(GROUPS_KEY, measurement.getGroups());    return view;}
private ColumnBuilder metron_f244_0(Map<String, Object> global)
{    String columnFamily = PROFILER_COLUMN_FAMILY.get(global, String.class);    return new ValueOnlyColumnBuilder(columnFamily);}
private RowKeyBuilder metron_f245_0(Map<String, Object> global)
{    Integer saltDivisor = PROFILER_SALT_DIVISOR.get(global, Integer.class);    return new SaltyRowKeyBuilder(saltDivisor, getPeriodDurationInMillis(global), TimeUnit.MILLISECONDS);}
private String metron_f246_0(Map<String, Object> global)
{    return PROFILER_HBASE_TABLE.get(global, String.class);}
private TableProvider metron_f247_0(Map<String, Object> global)
{    String clazzName = PROFILER_HBASE_TABLE_PROVIDER.get(global, String.class);    TableProvider provider;    try {        @SuppressWarnings("unchecked")        Class<? extends TableProvider> clazz = (Class<? extends TableProvider>) Class.forName(clazzName);        provider = clazz.getConstructor().newInstance();    } catch (Exception e) {        provider = new HTableProvider();    }    return provider;}
public Object metron_f248_0(List<Object> args, Context context) throws ParseException
{    Optional<Map> configOverridesMap = Optional.empty();    long now = System.currentTimeMillis();    String windowSelector = Util.getArg(0, String.class, args);    if (args.size() > 1) {        Optional<Object> arg2 = Optional.ofNullable(args.get(1));        Optional<Object> mapArg = args.size() > 2 ? Optional.ofNullable(args.get(2)) : Optional.empty();        if (!mapArg.isPresent() && arg2.isPresent() && arg2.get() instanceof Map) {            mapArg = arg2;        }        if (arg2.isPresent() && arg2.get() instanceof Number) {            now = ConversionUtils.convert(arg2.get(), Long.class);        }        if (mapArg.isPresent()) {            Map rawMap = ConversionUtils.convert(mapArg.get(), Map.class);            configOverridesMap = rawMap == null || rawMap.isEmpty() ? Optional.empty() : Optional.of(rawMap);        }    }    Map<String, Object> effectiveConfigs = Util.getEffectiveConfig(context, configOverridesMap.orElse(null));    Long tickDuration = ProfilerClientConfig.PROFILER_PERIOD.get(effectiveConfigs, Long.class);    TimeUnit tickUnit = TimeUnit.valueOf(ProfilerClientConfig.PROFILER_PERIOD_UNITS.get(effectiveConfigs, String.class));    Window w = null;    try {        w = windowCache.get(windowSelector, (selector) -> WindowProcessor.process(selector));    } catch (ParseException e) {        throw new IllegalStateException("Unable to process " + windowSelector + ": " + e.getMessage(), e);    }    long end = w.getEndMillis(now);    long start = w.getStartMillis(now);    IntervalPredicate<ProfilePeriod> intervalSelector = new IntervalPredicate<>(period -> period.getStartTimeMillis(), w.toIntervals(now), ProfilePeriod.class);    return ProfilePeriod.visitPeriods(start, end, tickDuration, tickUnit, Optional.of(intervalSelector), period -> period);}
public void metron_f249_0(Context context)
{    windowCache = Caffeine.newBuilder().maximumSize(200).expireAfterAccess(10, TimeUnit.MINUTES).build();}
public boolean metron_f250_0()
{    return windowCache != null;}
public void metron_f251_0(WindowParser.WindowContext ctx)
{}
public void metron_f252_0(WindowParser.WindowContext ctx)
{}
public void metron_f253_0(WindowParser.NonRepeatingWindowContext ctx)
{}
public void metron_f254_0(WindowParser.NonRepeatingWindowContext ctx)
{}
public void metron_f255_0(WindowParser.RepeatingWindowContext ctx)
{}
public void metron_f256_0(WindowParser.RepeatingWindowContext ctx)
{}
public void metron_f257_0(WindowParser.DenseWindowContext ctx)
{}
public void metron_f258_0(WindowParser.DenseWindowContext ctx)
{}
public void metron_f259_0(WindowParser.Excluding_specifierContext ctx)
{}
public void metron_f260_0(WindowParser.Excluding_specifierContext ctx)
{}
public void metron_f261_0(WindowParser.Including_specifierContext ctx)
{}
public void metron_f262_0(WindowParser.Including_specifierContext ctx)
{}
public void metron_f263_0(WindowParser.SpecifierContext ctx)
{}
public void metron_f264_0(WindowParser.SpecifierContext ctx)
{}
public void metron_f265_0(WindowParser.Specifier_arg_listContext ctx)
{}
public void metron_f266_0(WindowParser.Specifier_arg_listContext ctx)
{}
public void metron_f267_0(WindowParser.Day_specifierContext ctx)
{}
public void metron_f268_0(WindowParser.Day_specifierContext ctx)
{}
public void metron_f269_0(WindowParser.IdentifierContext ctx)
{}
public void metron_f270_0(WindowParser.IdentifierContext ctx)
{}
public void metron_f271_0(WindowParser.Specifier_listContext ctx)
{}
public void metron_f272_0(WindowParser.Specifier_listContext ctx)
{}
public void metron_f273_0(WindowParser.FromToDurationContext ctx)
{}
public void metron_f274_0(WindowParser.FromToDurationContext ctx)
{}
public void metron_f275_0(WindowParser.FromDurationContext ctx)
{}
public void metron_f276_0(WindowParser.FromDurationContext ctx)
{}
public void metron_f277_0(WindowParser.SkipDistanceContext ctx)
{}
public void metron_f278_0(WindowParser.SkipDistanceContext ctx)
{}
public void metron_f279_0(WindowParser.WindowWidthContext ctx)
{}
public void metron_f280_0(WindowParser.WindowWidthContext ctx)
{}
public void metron_f281_0(WindowParser.TimeIntervalContext ctx)
{}
public void metron_f282_0(WindowParser.TimeIntervalContext ctx)
{}
public void metron_f283_0(WindowParser.TimeAmountContext ctx)
{}
public void metron_f284_0(WindowParser.TimeAmountContext ctx)
{}
public void metron_f285_0(WindowParser.TimeUnitContext ctx)
{}
public void metron_f286_0(WindowParser.TimeUnitContext ctx)
{}
public void metron_f287_0(ParserRuleContext ctx)
{}
public void metron_f288_0(ParserRuleContext ctx)
{}
public void metron_f289_0(TerminalNode node)
{}
public void metron_f290_0(ErrorNode node)
{}
public String[] metron_f291_0()
{    return tokenNames;}
public Vocabulary metron_f292_0()
{    return VOCABULARY;}
public String metron_f293_0()
{    return "Window.g4";}
public String[] metron_f294_0()
{    return ruleNames;}
public String metron_f295_0()
{    return _serializedATN;}
public String[] metron_f296_0()
{    return modeNames;}
public ATN metron_f297_0()
{    return _ATN;}
public String[] metron_f298_0()
{    return tokenNames;}
public Vocabulary metron_f299_0()
{    return VOCABULARY;}
public String metron_f300_0()
{    return "Window.g4";}
public String[] metron_f301_0()
{    return ruleNames;}
public String metron_f302_0()
{    return _serializedATN;}
public ATN metron_f303_0()
{    return _ATN;}
public Window_expressionContext metron_f304_0()
{    return getRuleContext(Window_expressionContext.class, 0);}
public TerminalNode metron_f305_0()
{    return getToken(WindowParser.EOF, 0);}
public int metron_f306_0()
{    return RULE_window;}
public void metron_f307_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterWindow(this);}
public void metron_f308_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitWindow(this);}
public final WindowContext metron_f309_0() throws RecognitionException
{    WindowContext _localctx = new WindowContext(_ctx, getState());    enterRule(_localctx, 0, RULE_window);    try {        enterOuterAlt(_localctx, 1);        {            setState(30);            window_expression();            setState(31);            match(EOF);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f310_0()
{    return RULE_window_expression;}
public void metron_f311_0(Window_expressionContext ctx)
{    super.copyFrom(ctx);}
public Window_widthContext metron_f312_0()
{    return getRuleContext(Window_widthContext.class, 0);}
public Skip_distanceContext metron_f313_0()
{    return getRuleContext(Skip_distanceContext.class, 0);}
public DurationContext metron_f314_0()
{    return getRuleContext(DurationContext.class, 0);}
public Including_specifierContext metron_f315_0()
{    return getRuleContext(Including_specifierContext.class, 0);}
public Excluding_specifierContext metron_f316_0()
{    return getRuleContext(Excluding_specifierContext.class, 0);}
public void metron_f317_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterRepeatingWindow(this);}
public void metron_f318_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitRepeatingWindow(this);}
public DurationContext metron_f319_0()
{    return getRuleContext(DurationContext.class, 0);}
public void metron_f320_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterDenseWindow(this);}
public void metron_f321_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitDenseWindow(this);}
public Window_widthContext metron_f322_0()
{    return getRuleContext(Window_widthContext.class, 0);}
public Including_specifierContext metron_f323_0()
{    return getRuleContext(Including_specifierContext.class, 0);}
public Excluding_specifierContext metron_f324_0()
{    return getRuleContext(Excluding_specifierContext.class, 0);}
public void metron_f325_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterNonRepeatingWindow(this);}
public void metron_f326_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitNonRepeatingWindow(this);}
public final Window_expressionContext metron_f327_0() throws RecognitionException
{    Window_expressionContext _localctx = new Window_expressionContext(_ctx, getState());    enterRule(_localctx, 2, RULE_window_expression);    int _la;    try {        setState(50);        switch(getInterpreter().adaptivePredict(_input, 4, _ctx)) {            case 1:                _localctx = new NonRepeatingWindowContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(33);                    window_width();                    setState(35);                    _la = _input.LA(1);                    if (_la == INCLUDE) {                        {                            setState(34);                            including_specifier();                        }                    }                    setState(38);                    _la = _input.LA(1);                    if (_la == EXCLUDE) {                        {                            setState(37);                            excluding_specifier();                        }                    }                }                break;            case 2:                _localctx = new RepeatingWindowContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(40);                    window_width();                    setState(41);                    skip_distance();                    setState(42);                    duration();                    setState(44);                    _la = _input.LA(1);                    if (_la == INCLUDE) {                        {                            setState(43);                            including_specifier();                        }                    }                    setState(47);                    _la = _input.LA(1);                    if (_la == EXCLUDE) {                        {                            setState(46);                            excluding_specifier();                        }                    }                }                break;            case 3:                _localctx = new DenseWindowContext(_localctx);                enterOuterAlt(_localctx, 3);                {                    setState(49);                    duration();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f328_0()
{    return getToken(WindowParser.EXCLUDE, 0);}
public Specifier_listContext metron_f329_0()
{    return getRuleContext(Specifier_listContext.class, 0);}
public int metron_f330_0()
{    return RULE_excluding_specifier;}
public void metron_f331_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterExcluding_specifier(this);}
public void metron_f332_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitExcluding_specifier(this);}
public final Excluding_specifierContext metron_f333_0() throws RecognitionException
{    Excluding_specifierContext _localctx = new Excluding_specifierContext(_ctx, getState());    enterRule(_localctx, 4, RULE_excluding_specifier);    try {        enterOuterAlt(_localctx, 1);        {            setState(52);            match(EXCLUDE);            setState(53);            specifier_list(0);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f334_0()
{    return getToken(WindowParser.INCLUDE, 0);}
public Specifier_listContext metron_f335_0()
{    return getRuleContext(Specifier_listContext.class, 0);}
public int metron_f336_0()
{    return RULE_including_specifier;}
public void metron_f337_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterIncluding_specifier(this);}
public void metron_f338_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitIncluding_specifier(this);}
public final Including_specifierContext metron_f339_0() throws RecognitionException
{    Including_specifierContext _localctx = new Including_specifierContext(_ctx, getState());    enterRule(_localctx, 6, RULE_including_specifier);    try {        enterOuterAlt(_localctx, 1);        {            setState(55);            match(INCLUDE);            setState(56);            specifier_list(0);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Day_specifierContext metron_f340_0()
{    return getRuleContext(Day_specifierContext.class, 0);}
public Specifier_arg_listContext metron_f341_0()
{    return getRuleContext(Specifier_arg_listContext.class, 0);}
public int metron_f342_0()
{    return RULE_specifier;}
public void metron_f343_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterSpecifier(this);}
public void metron_f344_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitSpecifier(this);}
public final SpecifierContext metron_f345_0() throws RecognitionException
{    SpecifierContext _localctx = new SpecifierContext(_ctx, getState());    enterRule(_localctx, 8, RULE_specifier);    try {        setState(62);        switch(getInterpreter().adaptivePredict(_input, 5, _ctx)) {            case 1:                enterOuterAlt(_localctx, 1);                {                    setState(58);                    day_specifier();                }                break;            case 2:                enterOuterAlt(_localctx, 2);                {                    setState(59);                    day_specifier();                    setState(60);                    specifier_arg_list();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public IdentifierContext metron_f346_0()
{    return getRuleContext(IdentifierContext.class, 0);}
public Specifier_arg_listContext metron_f347_0()
{    return getRuleContext(Specifier_arg_listContext.class, 0);}
public int metron_f348_0()
{    return RULE_specifier_arg_list;}
public void metron_f349_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterSpecifier_arg_list(this);}
public void metron_f350_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitSpecifier_arg_list(this);}
public final Specifier_arg_listContext metron_f351_0() throws RecognitionException
{    Specifier_arg_listContext _localctx = new Specifier_arg_listContext(_ctx, getState());    enterRule(_localctx, 10, RULE_specifier_arg_list);    try {        setState(68);        switch(getInterpreter().adaptivePredict(_input, 6, _ctx)) {            case 1:                enterOuterAlt(_localctx, 1);                {                    setState(64);                    identifier();                }                break;            case 2:                enterOuterAlt(_localctx, 2);                {                    setState(65);                    identifier();                    setState(66);                    specifier_arg_list();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f352_0()
{    return getToken(WindowParser.DAY_SPECIFIER, 0);}
public int metron_f353_0()
{    return RULE_day_specifier;}
public void metron_f354_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterDay_specifier(this);}
public void metron_f355_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitDay_specifier(this);}
public final Day_specifierContext metron_f356_0() throws RecognitionException
{    Day_specifierContext _localctx = new Day_specifierContext(_ctx, getState());    enterRule(_localctx, 12, RULE_day_specifier);    try {        enterOuterAlt(_localctx, 1);        {            setState(70);            match(DAY_SPECIFIER);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f357_0()
{    return getToken(WindowParser.NUMBER, 0);}
public TerminalNode metron_f358_0()
{    return getToken(WindowParser.IDENTIFIER, 0);}
public int metron_f359_0()
{    return RULE_identifier;}
public void metron_f360_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterIdentifier(this);}
public void metron_f361_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitIdentifier(this);}
public final IdentifierContext metron_f362_0() throws RecognitionException
{    IdentifierContext _localctx = new IdentifierContext(_ctx, getState());    enterRule(_localctx, 14, RULE_identifier);    int _la;    try {        enterOuterAlt(_localctx, 1);        {            setState(72);            _la = _input.LA(1);            if (!(_la == NUMBER || _la == IDENTIFIER)) {                _errHandler.recoverInline(this);            } else {                consume();            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public SpecifierContext metron_f363_0()
{    return getRuleContext(SpecifierContext.class, 0);}
public Specifier_listContext metron_f364_0()
{    return getRuleContext(Specifier_listContext.class, 0);}
public TerminalNode metron_f365_0()
{    return getToken(WindowParser.COMMA, 0);}
public int metron_f366_0()
{    return RULE_specifier_list;}
public void metron_f367_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterSpecifier_list(this);}
public void metron_f368_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitSpecifier_list(this);}
public final Specifier_listContext metron_f369_0() throws RecognitionException
{    return specifier_list(0);}
private Specifier_listContext metron_f370_0(int _p) throws RecognitionException
{    ParserRuleContext _parentctx = _ctx;    int _parentState = getState();    Specifier_listContext _localctx = new Specifier_listContext(_ctx, _parentState);    Specifier_listContext _prevctx = _localctx;    int _startState = 16;    enterRecursionRule(_localctx, 16, RULE_specifier_list, _p);    try {        int _alt;        enterOuterAlt(_localctx, 1);        {            {                setState(75);                specifier();            }            _ctx.stop = _input.LT(-1);            setState(82);            _errHandler.sync(this);            _alt = getInterpreter().adaptivePredict(_input, 7, _ctx);            while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {                if (_alt == 1) {                    if (_parseListeners != null)                        triggerExitRuleEvent();                    _prevctx = _localctx;                    {                        {                            _localctx = new Specifier_listContext(_parentctx, _parentState);                            pushNewRecursionContext(_localctx, _startState, RULE_specifier_list);                            setState(77);                            if (!(precpred(_ctx, 1)))                                throw new FailedPredicateException(this, "precpred(_ctx, 1)");                            setState(78);                            match(COMMA);                            setState(79);                            specifier();                        }                    }                }                setState(84);                _errHandler.sync(this);                _alt = getInterpreter().adaptivePredict(_input, 7, _ctx);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        unrollRecursionContexts(_parentctx);    }    return _localctx;}
public int metron_f371_0()
{    return RULE_duration;}
public void metron_f372_0(DurationContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f373_0()
{    return getToken(WindowParser.FROM, 0);}
public List<Time_intervalContext> metron_f374_0()
{    return getRuleContexts(Time_intervalContext.class);}
public Time_intervalContext metron_f375_0(int i)
{    return getRuleContext(Time_intervalContext.class, i);}
public TerminalNode metron_f376_0()
{    return getToken(WindowParser.TO, 0);}
public List<TerminalNode> metron_f377_0()
{    return getTokens(WindowParser.AGO);}
public TerminalNode metron_f378_0(int i)
{    return getToken(WindowParser.AGO, i);}
public void metron_f379_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterFromToDuration(this);}
public void metron_f380_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitFromToDuration(this);}
public TerminalNode metron_f381_0()
{    return getToken(WindowParser.FROM, 0);}
public Time_intervalContext metron_f382_0()
{    return getRuleContext(Time_intervalContext.class, 0);}
public TerminalNode metron_f383_0()
{    return getToken(WindowParser.AGO, 0);}
public void metron_f384_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterFromDuration(this);}
public void metron_f385_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitFromDuration(this);}
public final DurationContext metron_f386_0() throws RecognitionException
{    DurationContext _localctx = new DurationContext(_ctx, getState());    enterRule(_localctx, 18, RULE_duration);    int _la;    try {        setState(100);        switch(getInterpreter().adaptivePredict(_input, 11, _ctx)) {            case 1:                _localctx = new FromToDurationContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(85);                    match(FROM);                    setState(86);                    time_interval();                    setState(88);                    _la = _input.LA(1);                    if (_la == AGO) {                        {                            setState(87);                            match(AGO);                        }                    }                    setState(90);                    match(TO);                    setState(91);                    time_interval();                    setState(93);                    _la = _input.LA(1);                    if (_la == AGO) {                        {                            setState(92);                            match(AGO);                        }                    }                }                break;            case 2:                _localctx = new FromDurationContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(95);                    match(FROM);                    setState(96);                    time_interval();                    setState(98);                    _la = _input.LA(1);                    if (_la == AGO) {                        {                            setState(97);                            match(AGO);                        }                    }                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f387_0()
{    return RULE_skip_distance;}
public void metron_f388_0(Skip_distanceContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f389_0()
{    return getToken(WindowParser.EVERY, 0);}
public Time_intervalContext metron_f390_0()
{    return getRuleContext(Time_intervalContext.class, 0);}
public void metron_f391_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterSkipDistance(this);}
public void metron_f392_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitSkipDistance(this);}
public final Skip_distanceContext metron_f393_0() throws RecognitionException
{    Skip_distanceContext _localctx = new Skip_distanceContext(_ctx, getState());    enterRule(_localctx, 20, RULE_skip_distance);    try {        _localctx = new SkipDistanceContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(102);            match(EVERY);            setState(103);            time_interval();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f394_0()
{    return RULE_window_width;}
public void metron_f395_0(Window_widthContext ctx)
{    super.copyFrom(ctx);}
public Time_intervalContext metron_f396_0()
{    return getRuleContext(Time_intervalContext.class, 0);}
public TerminalNode metron_f397_0()
{    return getToken(WindowParser.WINDOW, 0);}
public void metron_f398_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterWindowWidth(this);}
public void metron_f399_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitWindowWidth(this);}
public final Window_widthContext metron_f400_0() throws RecognitionException
{    Window_widthContext _localctx = new Window_widthContext(_ctx, getState());    enterRule(_localctx, 22, RULE_window_width);    int _la;    try {        _localctx = new WindowWidthContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(105);            time_interval();            setState(107);            _la = _input.LA(1);            if (_la == WINDOW) {                {                    setState(106);                    match(WINDOW);                }            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f401_0()
{    return RULE_time_interval;}
public void metron_f402_0(Time_intervalContext ctx)
{    super.copyFrom(ctx);}
public Time_amountContext metron_f403_0()
{    return getRuleContext(Time_amountContext.class, 0);}
public Time_unitContext metron_f404_0()
{    return getRuleContext(Time_unitContext.class, 0);}
public void metron_f405_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterTimeInterval(this);}
public void metron_f406_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitTimeInterval(this);}
public final Time_intervalContext metron_f407_0() throws RecognitionException
{    Time_intervalContext _localctx = new Time_intervalContext(_ctx, getState());    enterRule(_localctx, 24, RULE_time_interval);    try {        _localctx = new TimeIntervalContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(109);            time_amount();            setState(110);            time_unit();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f408_0()
{    return RULE_time_amount;}
public void metron_f409_0(Time_amountContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f410_0()
{    return getToken(WindowParser.NUMBER, 0);}
public void metron_f411_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterTimeAmount(this);}
public void metron_f412_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitTimeAmount(this);}
public final Time_amountContext metron_f413_0() throws RecognitionException
{    Time_amountContext _localctx = new Time_amountContext(_ctx, getState());    enterRule(_localctx, 26, RULE_time_amount);    try {        _localctx = new TimeAmountContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(112);            match(NUMBER);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f414_0()
{    return RULE_time_unit;}
public void metron_f415_0(Time_unitContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f416_0()
{    return getToken(WindowParser.TIME_UNIT, 0);}
public void metron_f417_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).enterTimeUnit(this);}
public void metron_f418_0(ParseTreeListener listener)
{    if (listener instanceof WindowListener)        ((WindowListener) listener).exitTimeUnit(this);}
public final Time_unitContext metron_f419_0() throws RecognitionException
{    Time_unitContext _localctx = new Time_unitContext(_ctx, getState());    enterRule(_localctx, 28, RULE_time_unit);    try {        _localctx = new TimeUnitContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(114);            match(TIME_UNIT);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public boolean metron_f420_0(RuleContext _localctx, int ruleIndex, int predIndex)
{    switch(ruleIndex) {        case 8:            return specifier_list_sempred((Specifier_listContext) _localctx, predIndex);    }    return true;}
private boolean metron_f421_0(Specifier_listContext _localctx, int predIndex)
{    switch(predIndex) {        case 0:            return precpred(_ctx, 1);    }    return true;}
protected SimpleDateFormat metron_f422_0()
{    return new SimpleDateFormat("yyyy/MM/dd");}
public boolean metron_f423_0(Long ts)
{    return DateUtils.isSameDay(new Date(ts), date);}
private static Calendar metron_f424_0(Long ts)
{    Calendar c = Calendar.getInstance();    c.setTime(new Date(ts));    return c;}
public static int metron_f425_0(Long ts)
{    return toCalendar(ts).get(Calendar.DAY_OF_WEEK);}
public static Predicate<Long> metron_f426_0(int dayOfWeek)
{    return ts -> getDayOfWeek(ts) == dayOfWeek;}
public static Predicate<Long> metron_f427_0(String name, List<String> arg)
{    return DayPredicates.valueOf(name).predicateCreator.apply(arg);}
private static Optional<HolidayCalendar> metron_f428_0(String code)
{    for (HolidayCalendar cal : HolidayCalendar.values()) {        if (cal.getId().equalsIgnoreCase(code) || cal.name().equalsIgnoreCase(code)) {            return Optional.of(cal);        }    }    return Optional.empty();}
public boolean metron_f429_0(Long ts)
{    Calendar c = Calendar.getInstance();    c.setTime(new Date(ts));    return manager.isHoliday(c, args);}
public long metron_f430_0(long now)
{    return startMillis.apply(now);}
 void metron_f431_0(Function<Long, Long> startMillis)
{    this.startMillis = startMillis;}
public long metron_f432_0(long now)
{    return endMillis.apply(now);}
 void metron_f433_0(Function<Long, Long> endMillis)
{    this.endMillis = endMillis;}
public Iterable<Predicate<Long>> metron_f434_0(long now)
{    return includes.stream().map(include -> include.apply(now)).collect(Collectors.toList());}
 void metron_f435_0(List<Function<Long, Predicate<Long>>> includes)
{    this.includes = includes;}
public Iterable<Predicate<Long>> metron_f436_0(long now)
{    return excludes.stream().map(exclude -> exclude.apply(now)).collect(Collectors.toList());}
 void metron_f437_0(List<Function<Long, Predicate<Long>>> excludes)
{    this.excludes = excludes;}
public Optional<Long> metron_f438_0()
{    return binWidth;}
 void metron_f439_0(long binWidth)
{    this.binWidth = Optional.of(binWidth);}
public Optional<Long> metron_f440_0()
{    return skipDistance;}
 void metron_f441_0(long skipDistance)
{    this.skipDistance = Optional.of(skipDistance);}
public List<Range<Long>> metron_f442_0(long now)
{    List<Range<Long>> intervals = new ArrayList<>();    long startMillis = getStartMillis(now);    long endMillis = getEndMillis(now);    Iterable<Predicate<Long>> includes = getIncludes(now);    Iterable<Predicate<Long>> excludes = getExcludes(now);        long skipDistance = getSkipDistance().orElse(Long.MAX_VALUE);        Optional<Long> binWidthOpt = getBinWidth();    long binWidth = binWidthOpt.isPresent() ? binWidthOpt.get() : endMillis - startMillis;    for (long left = startMillis; left >= 0 && left + binWidth <= endMillis; left += skipDistance) {        Range<Long> interval = Range.between(left, left + binWidth);        boolean include = includes.iterator().hasNext() ? false : true;        for (Predicate<Long> inclusionPredicate : includes) {            include |= inclusionPredicate.test(left);        }        if (include) {            for (Predicate<Long> exclusionPredicate : excludes) {                include &= !exclusionPredicate.test(left);            }        }        if (include) {            intervals.add(interval);        }    }    return intervals;}
public Window metron_f443_0()
{    return window;}
private void metron_f444_0()
{    stack.push(LIST_MARKER);}
private List<Function<Long, Predicate<Long>>> metron_f445_0()
{    LinkedList<Function<Long, Predicate<Long>>> predicates = new LinkedList<>();    while (true) {        Token<?> token = stack.pop();        if (token == LIST_MARKER) {            break;        } else {            predicates.addFirst((Function<Long, Predicate<Long>>) token.getValue());        }    }    return predicates;}
public void metron_f446_0(WindowParser.IdentifierContext ctx)
{    if (checkForException(ctx)) {        return;    }    stack.push(new Token<>(ctx.getText().substring(1), String.class));}
public void metron_f447_0(WindowParser.SpecifierContext ctx)
{    if (checkForException(ctx)) {        return;    }    stack.push(SPECIFIER_MARKER);}
public void metron_f448_0(WindowParser.SpecifierContext ctx)
{    LinkedList<String> args = new LinkedList<>();    while (true) {        Token<?> token = stack.pop();        if (token == SPECIFIER_MARKER) {            break;        } else {            args.addFirst((String) token.getValue());        }    }    String specifier = args.removeFirst();    List<String> arg = args.size() > 0 ? args : new ArrayList<>();    Function<Long, Predicate<Long>> predicate = null;    try {        if (specifier.equals("THIS DAY OF THE WEEK") || specifier.equals("THIS DAY OF WEEK")) {            predicate = now -> DayPredicates.dayOfWeekPredicate(DayPredicates.getDayOfWeek(now));        } else {            final Predicate<Long> dayOfWeekPredicate = DayPredicates.create(specifier, arg);            predicate = now -> dayOfWeekPredicate;        }        stack.push(new Token<>(predicate, Function.class));    } catch (Throwable t) {        throwable = t;    }}
public void metron_f449_0(WindowParser.Day_specifierContext ctx)
{    if (checkForException(ctx)) {        return;    }    String specifier = ctx.getText().toUpperCase();    if (specifier.length() == 0 && ctx.exception != null) {        IllegalStateException ise = new IllegalStateException("Invalid day specifier: " + ctx.getStart().getText(), ctx.exception);        throwable = ise;        throw ise;    }    if (specifier.endsWith("S")) {        specifier = specifier.substring(0, specifier.length() - 1);    }    stack.push(new Token<>(specifier, String.class));}
public void metron_f450_0(WindowParser.Excluding_specifierContext ctx)
{    if (checkForException(ctx)) {        return;    }    enterList();}
public void metron_f451_0(WindowParser.Excluding_specifierContext ctx)
{    if (checkForException(ctx)) {        return;    }    window.setExcludes(getPredicates());}
public void metron_f452_0(WindowParser.Including_specifierContext ctx)
{    if (checkForException(ctx)) {        return;    }    enterList();}
public void metron_f453_0(WindowParser.Including_specifierContext ctx)
{    if (checkForException(ctx)) {        return;    }    window.setIncludes(getPredicates());}
private void metron_f454_0(long from, long to)
{    window.setEndMillis(now -> now - Math.min(to, from));    window.setStartMillis(now -> now - Math.max(from, to));}
public void metron_f455_0(org.apache.metron.profiler.client.window.generated.WindowParser.FromToDurationContext ctx)
{    if (checkForException(ctx)) {        return;    }    Token<?> toInterval = stack.pop();    Token<?> fromInterval = stack.pop();    Long to = (Long) toInterval.getValue();    Long from = (Long) fromInterval.getValue();    setFromTo(from, to);}
public void metron_f456_0(org.apache.metron.profiler.client.window.generated.WindowParser.FromDurationContext ctx)
{    if (checkForException(ctx)) {        return;    }    Token<?> timeInterval = stack.pop();    Long from = (Long) timeInterval.getValue();    setFromTo(from, 0);}
public void metron_f457_0(org.apache.metron.profiler.client.window.generated.WindowParser.SkipDistanceContext ctx)
{    if (checkForException(ctx)) {        return;    }    Token<?> timeInterval = stack.pop();    Long width = (Long) timeInterval.getValue();    window.setSkipDistance(width);}
public void metron_f458_0(org.apache.metron.profiler.client.window.generated.WindowParser.WindowWidthContext ctx)
{    if (checkForException(ctx)) {        return;    }    Token<?> timeInterval = stack.pop();    Long width = (Long) timeInterval.getValue();    window.setBinWidth(width);    window.setStartMillis(now -> now - width);    window.setEndMillis(now -> now);}
public void metron_f459_0(org.apache.metron.profiler.client.window.generated.WindowParser.TimeIntervalContext ctx)
{    if (checkForException(ctx)) {        return;    }    Token<?> timeUnit = stack.pop();    Token<?> timeDuration = stack.pop();    long duration = ConversionUtils.convert(timeDuration.getValue(), Long.class);    TimeUnit unit = (TimeUnit) timeUnit.getValue();    stack.push(new Token<>(unit.toMillis(duration), Long.class));}
public void metron_f460_0(org.apache.metron.profiler.client.window.generated.WindowParser.TimeAmountContext ctx)
{    if (checkForException(ctx)) {        return;    }    if (ctx.getText().length() == 0) {        throwable = new IllegalStateException("Unable to process empty string.");        return;    }    long duration = Long.parseLong(ctx.getText());    stack.push(new Token<>(duration, Long.class));}
public void metron_f461_0(org.apache.metron.profiler.client.window.generated.WindowParser.TimeUnitContext ctx)
{    checkForException(ctx);    switch(normalizeTimeUnit(ctx.getText())) {        case "DAY":            stack.push(new Token<>(TimeUnit.DAYS, TimeUnit.class));            break;        case "HOUR":            stack.push(new Token<>(TimeUnit.HOURS, TimeUnit.class));            break;        case "MINUTE":            stack.push(new Token<>(TimeUnit.MINUTES, TimeUnit.class));            break;        case "SECOND":            stack.push(new Token<>(TimeUnit.SECONDS, TimeUnit.class));            break;        default:            throw new IllegalStateException("Unsupported time unit: " + ctx.getText() + ".  Supported units are limited to: day, hour, minute, second " + "with any pluralization or capitalization.");    }}
private boolean metron_f462_0(ParserRuleContext ctx)
{    if (throwable != null) {        return true;    } else if (ctx.exception != null) {        return true;    }    return false;}
private static String metron_f463_0(String s)
{    String ret = s.toUpperCase().replaceAll("[^A-Z]", "");    if (ret.endsWith("S")) {        return ret.substring(0, ret.length() - 1);    }    return ret;}
private static TokenStream metron_f464_0(String statement)
{    if (statement == null || isEmpty(statement.trim())) {        return null;    }    statement = statement.trim();    ANTLRInputStream input = new ANTLRInputStream(statement);    WindowLexer lexer = new WindowLexer(input);    lexer.removeErrorListeners();    lexer.addErrorListener(new ErrorListener());    TokenStream tokens = new CommonTokenStream(lexer);    return tokens;}
private static WindowParser metron_f465_0(TokenStream tokens, Optional<WindowProcessor> windowProcessor)
{    WindowParser parser = new WindowParser(tokens);    if (windowProcessor.isPresent()) {        parser.addParseListener(windowProcessor.get());    }    parser.removeErrorListeners();    parser.addErrorListener(new ErrorListener());    return parser;}
public static Window metron_f466_0(String statement) throws ParseException
{    TokenStream tokens = createTokenStream(statement);    if (tokens == null) {        return null;    }    WindowProcessor treeBuilder = new WindowProcessor();    WindowParser parser = createParser(tokens, Optional.of(treeBuilder));    parser.window();    if (treeBuilder.throwable != null) {        throw new ParseException(treeBuilder.throwable.getMessage(), treeBuilder.throwable);    }    return treeBuilder.getWindow();}
public static String metron_f467_0(String statement)
{    TokenStream tokens = createTokenStream(statement);    if (tokens == null) {        return null;    }    WindowParser parser = createParser(tokens, Optional.empty());    ParseTree tree = parser.window();    return GrammarUtils.toSyntaxTree(tree);}
public void metron_f468_0() throws Exception
{    provider = new MockHBaseTableProvider();    executor = new DefaultStellarStatefulExecutor();    MockHBaseTableProvider.addToCache(tableName, columnFamily);        long periodDurationMillis = periodUnits.toMillis(periodDuration);    RowKeyBuilder rowKeyBuilder = new SaltyRowKeyBuilder();    ColumnBuilder columnBuilder = new ValueOnlyColumnBuilder(columnFamily);    profileWriter = new ProfileWriter(rowKeyBuilder, columnBuilder, provider, periodDurationMillis, tableName, null);    client = new HBaseProfilerClient(provider, rowKeyBuilder, columnBuilder, periodDurationMillis, tableName, null);}
public void metron_f469_0() throws Exception
{    ((MockHTable) provider.getTable(null, tableName)).clear();}
public void metron_f470_0() throws Exception
{    final String profile = "profile1";    final String entity = "entity1";    final int expectedValue = 2302;    final int hours = 2;    final int count = hours * periodsPerHour + 1;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);        ProfileMeasurement prototype = new ProfileMeasurement().withProfileName(profile).withEntity(entity).withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(prototype, count, Arrays.asList("weekdays"), val -> expectedValue);    profileWriter.write(prototype, count, Arrays.asList("weekends"), val -> 0);    long end = System.currentTimeMillis();    long start = end - TimeUnit.HOURS.toMillis(2);    {                List<Object> groups = Arrays.asList("weekdays");        List<ProfileMeasurement> results = client.fetch(Integer.class, profile, entity, groups, start, end, Optional.empty());        assertEquals(count, results.size());        results.forEach(actual -> {            assertEquals(profile, actual.getProfileName());            assertEquals(entity, actual.getEntity());            assertEquals(groups, actual.getGroups());            assertEquals(expectedValue, actual.getProfileValue());        });    }    {                List<Object> groups = Arrays.asList("weekends");        List<ProfileMeasurement> results = client.fetch(Integer.class, profile, entity, groups, start, end, Optional.empty());        assertEquals(count, results.size());        results.forEach(actual -> {            assertEquals(profile, actual.getProfileName());            assertEquals(entity, actual.getEntity());            assertEquals(groups, actual.getGroups());            assertEquals(0, actual.getProfileValue());        });    }}
public void metron_f471_0() throws Exception
{    final String profile = "profile1";    final String entity = "entity1";    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final int count = hours * periodsPerHour;    final long endTime = System.currentTimeMillis();    final long startTime = endTime - TimeUnit.HOURS.toMillis(hours);        ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, Arrays.asList("weekdays"), val -> expectedValue);    profileWriter.write(m, count, Arrays.asList("weekends"), val -> 0);    List<Object> weekdays = Arrays.asList("weekdays");    List<ProfileMeasurement> results = client.fetch(Integer.class, profile, entity, weekdays, startTime, endTime, Optional.empty());        assertEquals(count, results.size());    results.forEach(actual -> assertEquals(weekdays, actual.getGroups()));}
public void metron_f472_0()
{    final String profile = "profile1";    final String entity = "entity1";    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final int count = hours * periodsPerHour;    final long endTime = System.currentTimeMillis();    final long startTime = endTime - TimeUnit.HOURS.toMillis(hours);        ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, Arrays.asList("weekdays"), val -> expectedValue);    profileWriter.write(m, count, Arrays.asList("weekends"), val -> 0);        List<Object> groups = Arrays.asList("does-not-exist");    List<ProfileMeasurement> results = client.fetch(Integer.class, profile, entity, groups, startTime, endTime, Optional.empty());    assertEquals(0, results.size());}
public void metron_f473_0() throws Exception
{    final String profile = "profile1";    final String entity = "entity1";    final int hours = 2;    int numberToWrite = hours * periodsPerHour;    final List<Object> group = Arrays.asList("weekends");    final long measurementTime = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(1);        ProfileMeasurement prototype = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(measurementTime, periodDuration, periodUnits);    profileWriter.write(prototype, numberToWrite, group, val -> 1000);        final long endFetchAt = System.currentTimeMillis();    final long startFetchAt = endFetchAt - TimeUnit.MILLISECONDS.toMillis(30);    List<ProfileMeasurement> results = client.fetch(Integer.class, profile, entity, group, startFetchAt, endFetchAt, Optional.empty());    assertEquals(0, results.size());}
public void metron_f474_0(ProfileMeasurement prototype, int count, List<Object> group, Function<Object, Object> valueGenerator)
{    ProfileMeasurement m = prototype;    ProfilePeriod period = m.getPeriod();    for (int i = 0; i < count; i++) {                Object nextValue = valueGenerator.apply(m.getProfileValue());                m = new ProfileMeasurement().withProfileName(prototype.getProfileName()).withEntity(prototype.getEntity()).withPeriod(period).withGroups(group).withProfileValue(nextValue);        write(m);                period = m.getPeriod().next();    }}
private void metron_f475_0(ProfileMeasurement m)
{    byte[] rowKey = rowKeyBuilder.rowKey(m);    ColumnList cols = columnBuilder.columns(m);    hbaseClient.addMutation(rowKey, cols, Durability.SKIP_WAL);    hbaseClient.mutate();}
public static void metron_f476_0(String[] args) throws Exception
{    RowKeyBuilder rowKeyBuilder = new SaltyRowKeyBuilder();    ColumnBuilder columnBuilder = new ValueOnlyColumnBuilder();    Configuration config = HBaseConfiguration.create();    config.set("hbase.master.hostname", "node1");    config.set("hbase.regionserver.hostname", "node1");    config.set("hbase.zookeeper.quorum", "node1");    HTableProvider provider = new HTableProvider();    String tableName = "profiler";    long periodDurationMillis = TimeUnit.MINUTES.toMillis(15);    long when = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(2);    ProfileMeasurement measure = new ProfileMeasurement().withProfileName("profile1").withEntity("192.168.66.121").withPeriod(when, periodDurationMillis, TimeUnit.MILLISECONDS);    ProfileWriter writer = new ProfileWriter(rowKeyBuilder, columnBuilder, provider, periodDurationMillis, tableName, config);    writer.write(measure, 2 * 24 * 4, Collections.emptyList(), val -> new Random().nextInt(10));}
private T metron_f477_0(String expression, Class<T> clazz)
{    return executor.execute(expression, state, clazz);}
public void metron_f478_0()
{    state = new HashMap<>();    final Table table = MockHBaseTableProvider.addToCache(tableName, columnFamily);        long periodDurationMillis = TimeUnit.MINUTES.toMillis(15);    RowKeyBuilder rowKeyBuilder = new SaltyRowKeyBuilder();    ColumnBuilder columnBuilder = new ValueOnlyColumnBuilder(columnFamily);    profileWriter = new ProfileWriter(rowKeyBuilder, columnBuilder, new MockHBaseTableProvider(), periodDurationMillis, tableName, null);        Map<String, Object> global = new HashMap<String, Object>() {        {            put(PROFILER_HBASE_TABLE.getKey(), tableName);            put(PROFILER_COLUMN_FAMILY.getKey(), columnFamily);            put(PROFILER_HBASE_TABLE_PROVIDER.getKey(), MockHBaseTableProvider.class.getName());            put(PROFILER_PERIOD.getKey(), Long.toString(periodDuration));            put(PROFILER_PERIOD_UNITS.getKey(), periodUnits.toString());            put(PROFILER_SALT_DIVISOR.getKey(), Integer.toString(saltDivisor));        }    };        executor = new DefaultStellarStatefulExecutor(new SimpleFunctionResolver().withClass(GetProfile.class).withClass(FixedLookback.class), new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> global).build());}
private Context metron_f479_0()
{    state = new HashMap<>();        Map<String, Object> global = new HashMap<String, Object>() {        {            put(PROFILER_HBASE_TABLE.getKey(), tableName);            put(PROFILER_COLUMN_FAMILY.getKey(), columnFamily);            put(PROFILER_HBASE_TABLE_PROVIDER.getKey(), MockHBaseTableProvider.class.getName());            put(PROFILER_PERIOD.getKey(), Long.toString(periodDuration2));            put(PROFILER_PERIOD_UNITS.getKey(), periodUnits2.toString());            put(PROFILER_SALT_DIVISOR.getKey(), Integer.toString(saltDivisor2));        }    };        Context context2 = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> global).build();        executor = new DefaultStellarStatefulExecutor(new SimpleFunctionResolver().withClass(GetProfile.class).withClass(FixedLookback.class), context2);        return context2;}
public void metron_f480_0()
{    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Collections.emptyList();        final int count = hours * periodsPerHour;    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, group, val -> expectedValue);        String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'))";    @SuppressWarnings("unchecked")    List<Integer> result = run(expr, List.class);        Assert.assertEquals(count, result.size());    result.forEach(actual -> Assert.assertEquals(expectedValue, actual.intValue()));}
public void metron_f481_0()
{    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Arrays.asList("weekends");        final int count = hours * periodsPerHour;    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, group, val -> expectedValue);        state.put("groups", group);        String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'), ['weekends'])";    @SuppressWarnings("unchecked")    List<Integer> result = run(expr, List.class);        Assert.assertEquals(count, result.size());        expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'), 'weekends')";    result = run(expr, List.class);        Assert.assertEquals(count, result.size());    result.forEach(actual -> Assert.assertEquals(expectedValue, actual.intValue()));}
public void metron_f482_0()
{    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Arrays.asList("weekdays", "tuesday");        final int count = hours * periodsPerHour;    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, group, val -> expectedValue);        state.put("groups", group);        String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'), ['weekdays', 'tuesday'])";    @SuppressWarnings("unchecked")    List<Integer> result = run(expr, List.class);        Assert.assertEquals(count, result.size());        expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'), 'weekdays', 'tuesday')";    result = run(expr, List.class);        Assert.assertEquals(count, result.size());    result.forEach(actual -> Assert.assertEquals(expectedValue, actual.intValue()));}
public void metron_f483_0()
{    Context empty = Context.EMPTY_CONTEXT();        executor.setContext(empty);        SingletonFunctionResolver.getInstance().initialize(empty);        String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(1000, 'SECONDS'), groups)";    run(expr, List.class);}
public void metron_f484_0()
{    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Collections.emptyList();        ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, 1, group, val -> expectedValue);        state.put("groups", group);        String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'SECONDS'))";    @SuppressWarnings("unchecked")    List<Integer> result = run(expr, List.class);        Assert.assertEquals(0, result.size());}
public void metron_f485_0()
{    String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'))";    @SuppressWarnings("unchecked")    List<Integer> result = run(expr, List.class);        Assert.assertEquals(0, result.size());            testOverride("{'profiler.default.value' : 0}", 0);    testOverride("{'profiler.default.value' : 'metron'}", "metron");    testOverride("{'profiler.default.value' : []}", new ArrayList<>());}
private void metron_f486_0(String overrides, Object defaultVal)
{    String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'), [], " + overrides + ")";    List<Object> result = run(expr, List.class);            Assert.assertTrue(result.size() == 16 || result.size() == 17);    result.forEach(actual -> Assert.assertEquals(defaultVal, actual));}
public void metron_f487_0()
{    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Collections.emptyList();        final int count = hours * periodsPerHour;    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, group, val -> expectedValue);        Context context2 = setup2();        @SuppressWarnings("unchecked")    Map<String, Object> global = (Map<String, Object>) context2.getCapability(Context.Capabilities.GLOBAL_CONFIG).get();    Assert.assertEquals(PROFILER_PERIOD.get(global), periodDuration2);    Assert.assertNotEquals(periodDuration, periodDuration2);                String expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'))";    @SuppressWarnings("unchecked")    List<Integer> result = run(expr, List.class);        Assert.assertEquals(0, result.size());            String overrides = "{'profiler.client.period.duration' : '" + periodDuration + "', " + "'profiler.client.period.duration.units' : '" + periodUnits.toString() + "', " + "'profiler.client.salt.divisor' : " + saltDivisor + " }";    expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS', " + overrides + "), [], " + overrides + ")";    result = run(expr, List.class);        Assert.assertEquals(count, result.size());    result.forEach(actual -> Assert.assertEquals(expectedValue, actual.intValue()));}
public void metron_f488_0()
{    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Arrays.asList("weekends");        final int count = hours * periodsPerHour;    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, group, val -> expectedValue);        state.put("groups", group);        Context context2 = setup2();        @SuppressWarnings("unchecked")    Map<String, Object> global = (Map<String, Object>) context2.getCapability(Context.Capabilities.GLOBAL_CONFIG).get();    Assert.assertEquals(global.get(PROFILER_PERIOD.getKey()), Long.toString(periodDuration2));    Assert.assertNotEquals(periodDuration, periodDuration2);            String overrides = "{'profiler.client.period.duration' : '" + periodDuration + "', " + "'profiler.client.period.duration.units' : '" + periodUnits.toString() + "', " + "'profiler.client.salt.divisor' : " + saltDivisor + " }";    String expr = "PROFILE_GET('profile1', 'entity1'" + ", PROFILE_FIXED(4, 'HOURS', " + overrides + "), ['weekends'], " + overrides + ")";    @SuppressWarnings("unchecked")    List<Integer> result = run(expr, List.class);        Assert.assertEquals(count, result.size());                expr = "PROFILE_GET('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'), ['weekends'])";    result = run(expr, List.class);        Assert.assertEquals(0, result.size());}
public void metron_f489_0()
{    List<Range<Long>> intervals = new ArrayList<Range<Long>>() {        {            add(Range.between(0L, 10L));            add(Range.between(20L, 30L));            add(Range.between(40L, 50L));        }    };    IntervalPredicate<Long> predicate = new IntervalPredicate.Identity(intervals);    Assert.assertTrue(predicate.test(0L));    Assert.assertTrue(predicate.test(10L));    Assert.assertTrue(predicate.test(5L));    Assert.assertFalse(predicate.test(51L));    Assert.assertFalse(predicate.test(15L));}
public void metron_f490_0()
{    List<Range<Long>> intervals = new ArrayList<Range<Long>>() {        {            add(Range.between(0L, 10L));            add(Range.between(5L, 30L));            add(Range.between(40L, 50L));        }    };    IntervalPredicate<Long> predicate = new IntervalPredicate.Identity(intervals);    Assert.assertTrue(predicate.test(0L));    Assert.assertTrue(predicate.test(5L));    Assert.assertTrue(predicate.test(30L));    Assert.assertTrue(predicate.test(10L));    Assert.assertFalse(predicate.test(51L));    Assert.assertTrue(predicate.test(15L));    Assert.assertFalse(predicate.test(31L));    Assert.assertTrue(predicate.test(45L));}
public void metron_f491_0()
{    List<Range<Long>> intervals = new ArrayList<Range<Long>>() {        {            add(Range.between(0L, 10L));        }    };    IntervalPredicate<Long> predicate = new IntervalPredicate.Identity(intervals);    Assert.assertTrue(predicate.test(0L));    Assert.assertTrue(predicate.test(5L));    Assert.assertTrue(predicate.test(10L));    Assert.assertFalse(predicate.test(51L));    Assert.assertFalse(predicate.test(15L));}
public void metron_f492_0()
{    List<Range<Long>> intervals = new ArrayList<Range<Long>>() {        {            add(Range.between(10L, 10L));        }    };    IntervalPredicate<Long> predicate = new IntervalPredicate.Identity(intervals);    Assert.assertFalse(predicate.test(0L));    Assert.assertFalse(predicate.test(5L));    Assert.assertTrue(predicate.test(10L));    Assert.assertFalse(predicate.test(11L));}
private T metron_f493_0(String expression, Class<T> clazz)
{    return executor.execute(expression, state, clazz);}
public void metron_f494_0()
{    state = new HashMap<>();    final Table table = MockHBaseTableProvider.addToCache(tableName, columnFamily);    TableProvider provider = new MockHBaseTableProvider();        long periodDurationMillis = TimeUnit.MINUTES.toMillis(15);    RowKeyBuilder rowKeyBuilder = new SaltyRowKeyBuilder();    ColumnBuilder columnBuilder = new ValueOnlyColumnBuilder(columnFamily);    profileWriter = new ProfileWriter(rowKeyBuilder, columnBuilder, provider, periodDurationMillis, tableName, null);        globals = new HashMap<String, Object>() {        {            put(PROFILER_HBASE_TABLE.getKey(), tableName);            put(PROFILER_COLUMN_FAMILY.getKey(), columnFamily);            put(PROFILER_HBASE_TABLE_PROVIDER.getKey(), MockHBaseTableProvider.class.getName());            put(PROFILER_PERIOD.getKey(), Long.toString(periodDuration));            put(PROFILER_PERIOD_UNITS.getKey(), periodUnits.toString());            put(PROFILER_SALT_DIVISOR.getKey(), Integer.toString(saltDivisor));        }    };        executor = new DefaultStellarStatefulExecutor(new SimpleFunctionResolver().withClass(VerboseProfile.class).withClass(FixedLookback.class), new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> globals).build());}
public void metron_f495_0()
{    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Collections.emptyList();        final int count = hours * periodsPerHour;    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, group, val -> expectedValue);        List<Map<String, Object>> results;    results = run("PROFILE_VERBOSE('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'))", List.class);    Assert.assertEquals(count, results.size());    for (Map<String, Object> actual : results) {        Assert.assertEquals("profile1", actual.get(PROFILE_KEY));        Assert.assertEquals("entity1", actual.get(ENTITY_KEY));        Assert.assertNotNull(actual.get(PERIOD_KEY));        Assert.assertNotNull(actual.get(PERIOD_START_KEY));        Assert.assertNotNull(actual.get(PERIOD_END_KEY));        Assert.assertNotNull(actual.get(GROUPS_KEY));        Assert.assertEquals(expectedValue, actual.get(VALUE_KEY));    }}
public void metron_f496_0()
{    final int periodsPerHour = 4;    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Arrays.asList("weekends");        final int count = hours * periodsPerHour;    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, count, group, val -> expectedValue);        state.put("groups", group);        List<Map<String, Object>> results;    results = run("PROFILE_VERBOSE('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'), groups)", List.class);    Assert.assertEquals(count, results.size());    for (Map<String, Object> actual : results) {        Assert.assertEquals("profile1", actual.get(PROFILE_KEY));        Assert.assertEquals("entity1", actual.get(ENTITY_KEY));        Assert.assertNotNull(actual.get(PERIOD_KEY));        Assert.assertNotNull(actual.get(PERIOD_START_KEY));        Assert.assertNotNull(actual.get(PERIOD_END_KEY));        Assert.assertNotNull(actual.get(GROUPS_KEY));        Assert.assertEquals(expectedValue, actual.get(VALUE_KEY));    }}
public void metron_f497_0()
{    final int expectedValue = 2302;    final int hours = 2;    final long startTime = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hours);    final List<Object> group = Collections.emptyList();        ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile1").withEntity("entity1").withPeriod(startTime, periodDuration, periodUnits);    profileWriter.write(m, 1, group, val -> expectedValue);        List<Map<String, Object>> result;    result = run("PROFILE_VERBOSE('profile1', 'entity1', PROFILE_FIXED(4, 'SECONDS'))", List.class);    Assert.assertEquals(0, result.size());}
public void metron_f498_0()
{        String defaultVal = "this is the default value";    globals.put("profiler.default.value", defaultVal);        String expr = "PROFILE_VERBOSE('profile1', 'entity1', PROFILE_FIXED(4, 'HOURS'))";    List<Map<String, Object>> results = run(expr, List.class);        Assert.assertTrue(results.size() == 16 || results.size() == 17);    for (Map<String, Object> actual : results) {        Assert.assertEquals("profile1", actual.get(PROFILE_KEY));        Assert.assertEquals("entity1", actual.get(ENTITY_KEY));        Assert.assertNotNull(actual.get(PERIOD_KEY));        Assert.assertNotNull(actual.get(PERIOD_START_KEY));        Assert.assertNotNull(actual.get(PERIOD_END_KEY));        Assert.assertNotNull(actual.get(GROUPS_KEY));                Assert.assertEquals(defaultVal, actual.get(VALUE_KEY));    }}
public static void metron_f499_0()
{    resolver = new SimpleFunctionResolver().withClass(GetProfile.class).withClass(FixedLookback.class).withClass(WindowLookback.class);    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> new HashMap<>()).build();}
public void metron_f500_0() throws Exception
{                long durationMs = 60000;    Map<String, Object> config = new HashMap<>();    config.put(ProfilerClientConfig.PROFILER_PERIOD.getKey(), 1);    State state = test("1 hour", new Date(), Optional.of(config), Assertions.NOT_EMPTY, Assertions.CONTIGUOUS);    Assert.assertEquals(TimeUnit.HOURS.toMillis(1) / durationMs, state.periods.size());}
public void metron_f501_0()
{    String stellarStatement = "PROFILE_WINDOW('1 hour')";    Map<String, Object> variables = new HashMap<>();    StellarProcessor stellar = new StellarProcessor();    List<ProfilePeriod> periods = (List<ProfilePeriod>) stellar.parse(stellarStatement, new DefaultVariableResolver(k -> variables.get(k), k -> variables.containsKey(k)), resolver, context);    Assert.assertEquals(TimeUnit.HOURS.toMillis(1) / getDurationMs(), periods.size());}
public void metron_f502_0() throws Exception
{    State state = test("1 hour", Assertions.NOT_EMPTY, Assertions.CONTIGUOUS);    Assert.assertEquals(TimeUnit.HOURS.toMillis(1) / getDurationMs(), state.periods.size());}
public void metron_f503_0() throws Exception
{    State state = test("from 2 hours ago to 30 minutes ago", Assertions.NOT_EMPTY, Assertions.CONTIGUOUS, Assertions.INTERVALS_CONTAIN_ALL_PERIODS);    Assert.assertEquals(TimeUnit.MINUTES.toMillis(90) / getDurationMs(), state.periods.size());}
public void metron_f504_0() throws Exception
{    State state = test("30 minute window every 1 hour from 2 hours ago to 30 minutes ago", Assertions.NOT_EMPTY, Assertions.DISCONTIGUOUS, Assertions.INTERVALS_CONTAIN_ALL_PERIODS);    Assert.assertEquals(TimeUnit.MINUTES.toMillis(60) / getDurationMs(), state.periods.size());}
public void metron_f505_0() throws Exception
{    test("30 minute window every 24 hours from 7 days ago including saturdays excluding weekends", Assertions.EMPTY);}
public void metron_f506_0() throws Exception
{    test("30 minute idow every 24 hours from 7 days ago including saturdays excluding weekends", Assertions.EMPTY);}
 long metron_f507_0()
{    int duration = ProfilerClientConfig.PROFILER_PERIOD.getDefault(Integer.class);    TimeUnit unit = TimeUnit.valueOf(ProfilerClientConfig.PROFILER_PERIOD_UNITS.getDefault(String.class));    return unit.toMillis(duration);}
public State metron_f508_0(String windowSelector, Assertions... assertions)
{    return test(windowSelector, new Date(), Optional.empty(), assertions);}
public State metron_f509_0(String windowSelector, Date now, Optional<Map<String, Object>> config, Assertions... assertions)
{    List<Range<Long>> windowIntervals = WindowProcessor.process(windowSelector).toIntervals(now.getTime());    String stellarStatement = "PROFILE_WINDOW('" + windowSelector + "', now" + (config.isPresent() ? ", config" : "") + ")";    Map<String, Object> variables = new HashMap<>();    variables.put("now", now.getTime());    if (config.isPresent()) {        variables.put("config", config.get());    }    StellarProcessor stellar = new StellarProcessor();    List<ProfilePeriod> periods = (List<ProfilePeriod>) stellar.parse(stellarStatement, new DefaultVariableResolver(k -> variables.get(k), k -> variables.containsKey(k)), resolver, context);    State state = new State(windowIntervals, periods);    for (Assertions assertion : assertions) {        Assert.assertTrue(assertion.name(), assertion.test(state));    }    return state;}
public boolean metron_f510_0(State s)
{    return predicate.test(s);}
public void metron_f511_0()
{    for (String text : new String[] { "1 hour", "1 hour(s)", "1 hours" }) {        Window w = WindowProcessor.process(text);        Date now = new Date();        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(1, intervals.size());        Assert.assertEquals(now.getTime(), (long) intervals.get(0).getMaximum());        Assert.assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(1), (long) intervals.get(0).getMinimum());    }}
public void metron_f512_0()
{    for (String text : new String[] { "from 2 hours ago to 30 minutes ago", "starting from 2 hours until 30 minutes", "starting from 2 hours ago until 30 minutes ago", "starting from 30 minutes ago until 2 hours ago", "from 30 minutes ago to 2 hours ago " }) {        Window w = WindowProcessor.process(text);        /*    A dense window starting 2 hour ago and continuing until 30 minutes ago     */        Date now = new Date();        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(1, intervals.size());        assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(2), intervals.get(0).getMinimum());        assertEquals(now.getTime() - TimeUnit.MINUTES.toMillis(30), intervals.get(0).getMaximum());    }}
public void metron_f513_0()
{    for (String text : new String[] { "30 minute window every 1 hour from 2 hours ago to 30 minutes ago", "30 minute window every 1 hour starting from 2 hours ago to 30 minutes ago", "30 minute window every 1 hour starting from 2 hours ago until 30 minutes ago", "30 minute window for every 1 hour starting from 2 hours ago until 30 minutes ago" }) {        Window w = WindowProcessor.process(text);        /*    A window size of 30 minutes    Starting 2 hour ago and continuing until 30 minutes ago    window 1: ( now - 2 hour, now - 2 hour + 30 minutes)    window 2: (now - 1 hour, now - 1 hour + 30 minutes)     */        Date now = new Date();        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(2, intervals.size());        assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(2), intervals.get(0).getMinimum());        assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(2) + TimeUnit.MINUTES.toMillis(30), intervals.get(0).getMaximum());        assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(1), intervals.get(1).getMinimum());        assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(1) + TimeUnit.MINUTES.toMillis(30), intervals.get(1).getMaximum());    }}
public void metron_f514_0()
{    Window w = WindowProcessor.process("30 minute window every 1 hour from 3 hours ago");    /*    A window size of 30 minutes    Starting 3 hours ago and continuing until now    window 1: ( now - 3 hour, now - 3 hour + 30 minutes)    window 2: ( now - 2 hour, now - 2 hour + 30 minutes)    window 3: ( now - 1 hour, now - 1 hour + 30 minutes)     */    Date now = new Date();    List<Range<Long>> intervals = w.toIntervals(now.getTime());    Assert.assertEquals(3, intervals.size());    assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(3), intervals.get(0).getMinimum());    assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(3) + TimeUnit.MINUTES.toMillis(30), intervals.get(0).getMaximum());    assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(2), intervals.get(1).getMinimum());    assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(2) + TimeUnit.MINUTES.toMillis(30), intervals.get(1).getMaximum());    assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(1), intervals.get(2).getMinimum());    assertEquals(now.getTime() - TimeUnit.HOURS.toMillis(1) + TimeUnit.MINUTES.toMillis(30), intervals.get(2).getMaximum());}
public void metron_f515_0()
{    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago including tuesdays");        /*    A window size of 30 minutes    Starting 14 days ago  and continuing until now    Gotta be 2 tuesdays in 14 days.     */        Date now = new Date();                now.setHours(6);        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(2, intervals.size());    }    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago including this day of the week");        /*    A window size of 30 minutes    Starting 14 days ago  and continuing until now    Gotta be 2 days with the same dow in 14 days.     */        Date now = new Date();                now.setHours(6);        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(2, intervals.size());    }    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago");        /*    A window size of 30 minutes    Starting 14 days ago  and continuing until now    Gotta be 14 intervals in 14 days.     */        Date now = new Date();        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(14, intervals.size());    }}
public void metron_f516_0() throws ParseException
{    Window w = WindowProcessor.process("30 minute window every 24 hours from 7 days ago including saturdays excluding weekends");    Date now = new Date();        now.setHours(6);    List<Range<Long>> intervals = w.toIntervals(now.getTime());    Assert.assertEquals(0, intervals.size());}
public void metron_f517_0() throws ParseException
{    Window w = WindowProcessor.process("30 minute window every 24 hours from 7 days ago excluding weekends");    Date now = new Date();        now.setHours(6);    List<Range<Long>> intervals = w.toIntervals(now.getTime());    Assert.assertEquals(5, intervals.size());}
public void metron_f518_0() throws ParseException
{    Window w = WindowProcessor.process("30 minute window every 24 hours from 7 days ago including holidays:us excluding weekends");    SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm");    Date now = sdf.parse("2017/12/26 12:00");    List<Range<Long>> intervals = w.toIntervals(now.getTime());    Assert.assertEquals(1, intervals.size());}
public void metron_f519_0() throws ParseException
{    {        Window w = WindowProcessor.process("1 hour window every 24 hours starting from 56 days ago");        Date now = new Date();        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(56, intervals.size());    }    {        Window w = WindowProcessor.process("1 hour window every 24 hours starting from 56 days ago including this day of the week");        Date now = new Date();                now.setHours(6);        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(8, intervals.size());    }}
public void metron_f520_0() throws ParseException
{    Window w = WindowProcessor.process("30 minute window every 24 hours from 7 days ago excluding weekdays");    Date now = new Date();        now.setHours(6);    List<Range<Long>> intervals = w.toIntervals(now.getTime());    Assert.assertEquals(2, intervals.size());}
public void metron_f521_0() throws ParseException
{    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago excluding holidays:us");        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm");        Date now = sdf.parse("2017/12/26 12:00");        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(13, intervals.size());    }    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago excluding holidays:us:nyc");        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm");        Date now = sdf.parse("2017/12/26 12:00");        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(13, intervals.size());    }    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago excluding holidays:us");        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm");        Date now = sdf.parse("2017/08/26 12:00");        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(14, intervals.size());    }}
public void metron_f522_0() throws ParseException
{    for (String text : new String[] { "30 minute window every 24 hours from 14 days ago including date:20171225:yyyyMMdd", "30 minute window every 24 hours from 14 days ago including date:2017-12-25:yyyy-MM-dd", "30 minute window every 24 hours from 14 days ago including date:2017/12/25" }) {        Window w = WindowProcessor.process(text);        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm");        Date now = sdf.parse("2017/12/26 12:00");        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(1, intervals.size());        Date includedDate = new Date(intervals.get(0).getMinimum());        SimpleDateFormat equalityFormat = new SimpleDateFormat("yyyyMMdd");        Assert.assertEquals("20171225", equalityFormat.format(includedDate));    }    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago excluding date:2017/12/25");        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm");        Date now = sdf.parse("2017/12/26 12:00");        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(13, intervals.size());    }    {        Window w = WindowProcessor.process("30 minute window every 24 hours from 14 days ago including date:2017/12/25, date:2017/12/24");        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm");        Date now = sdf.parse("2017/12/26 12:00");        List<Range<Long>> intervals = w.toIntervals(now.getTime());        Assert.assertEquals(2, intervals.size());        {            Date includedDate = new Date(intervals.get(0).getMinimum());            SimpleDateFormat equalityFormat = new SimpleDateFormat("yyyyMMdd");            Assert.assertEquals("20171224", equalityFormat.format(includedDate));        }        {            Date includedDate = new Date(intervals.get(1).getMinimum());            SimpleDateFormat equalityFormat = new SimpleDateFormat("yyyyMMdd");            Assert.assertEquals("20171225", equalityFormat.format(includedDate));        }    }}
public void metron_f523_0() throws ParseException
{    WindowProcessor.process("30 minute window every 24 hours from 14 days ago excluding hoolidays:us");}
public void metron_f524_0() throws ParseException
{    WindowProcessor.process("30 minute window every 24 months from 14 days ago");}
public void metron_f525_0() throws ParseException
{    WindowProcessor.process("30 minuete window every 24 hours from 14 days ago");}
public void metron_f526_0() throws ParseException
{    WindowProcessor.process("30p minute window every 24 hours from 14 days ago");}
public void metron_f527_0() throws ParseException
{    WindowProcessor.process("30 minute window every 14 hours from 14 days ago including date");}
private static void metron_f528_0(long expected, long actual)
{    long diff = expected - actual;    long diffInMinutes = TimeUnit.MILLISECONDS.toMinutes(diff);    String message = expected + " - " + actual + " = " + diffInMinutes + " minutes off.";    Assert.assertEquals(message, expected, actual);}
public Clock metron_f529_0(ProfilerConfig config)
{    Clock clock;    boolean isEventTime = config.getTimestampField().isPresent();    if (isEventTime) {                String timestampField = config.getTimestampField().get();        clock = new EventTimeClock(timestampField);    } else {                clock = new WallClock();    }    return clock;}
public Optional<Long> metron_f530_1(JSONObject message)
{    Long result;    if (message != null && message.containsKey(timestampField)) {                Object timestamp = message.get(timestampField);        result = ConversionUtils.convert(timestamp, Long.class);    } else {                        result = null;    }    return Optional.ofNullable(result);}
public Clock metron_f531_0(ProfilerConfig config)
{    Clock clock;    boolean isEventTime = config.getTimestampField().isPresent();    if (isEventTime) {        String timestampField = config.getTimestampField().get();        clock = new EventTimeClock(timestampField);    } else {        throw new IllegalStateException("Expected profiler to use event time.");    }    return clock;}
public void metron_f532_0(long epochMillis)
{    this.epochMillis = epochMillis;}
public Optional<Long> metron_f533_0(JSONObject message)
{    return Optional.of(this.epochMillis);}
public Clock metron_f534_0(ProfilerConfig config)
{    return new FixedClock(timestamp);}
public Optional<Long> metron_f535_0(JSONObject message)
{        return Optional.of(System.currentTimeMillis());}
public void metron_f536_1(MessageRoute route, Context context)
{    try {        ProfileBuilder builder = getBuilder(route, context);        builder.apply(route.getMessage(), route.getTimestamp());    } catch (ExecutionException e) {                throw new RuntimeException(e);    }}
public List<ProfileMeasurement> metron_f537_1()
{            cacheMaintenance();    List<ProfileMeasurement> measurements = flushCache(activeCache);    return measurements;}
public List<ProfileMeasurement> metron_f538_1()
{            cacheMaintenance();        List<ProfileMeasurement> measurements = flushCache(expiredCache);        expiredCache.invalidateAll();    return measurements;}
private void metron_f539_1()
{    activeCache.cleanUp();        expiredCache.cleanUp();    }
private List<ProfileMeasurement> metron_f540_0(Cache<Integer, ProfileBuilder> cache)
{    List<ProfileMeasurement> measurements = new ArrayList<>();    for (ProfileBuilder profileBuilder : cache.asMap().values()) {                if (profileBuilder.isInitialized()) {                        Optional<ProfileMeasurement> measurement = profileBuilder.flush();            measurement.ifPresent(m -> measurements.add(m));        }    }    return measurements;}
public ProfileBuilder metron_f541_0(MessageRoute route, Context context) throws ExecutionException
{    ProfileConfig profile = route.getProfileDefinition();    String entity = route.getEntity();    Function<Integer, ProfileBuilder> profileCreator = (k) -> new DefaultProfileBuilder.Builder().withDefinition(profile).withEntity(entity).withPeriodDurationMillis(periodDurationMillis).withContext(context).build();    return activeCache.get(cacheKey(profile, entity), profileCreator);}
private int metron_f542_0(ProfileConfig profile, String entity)
{    return new HashCodeBuilder(17, 37).append(profile).append(entity).hashCode();}
public DefaultMessageDistributor metron_f543_0(long periodDurationMillis)
{    this.periodDurationMillis = periodDurationMillis;    return this;}
public DefaultMessageDistributor metron_f544_0(int duration, TimeUnit units)
{    return withPeriodDurationMillis(units.toMillis(duration));}
public void metron_f545_0(@Nonnull Integer key, @Nonnull ProfileBuilder value)
{}
public void metron_f547_0(@Nonnull Integer key, @Nonnull ProfileBuilder value)
{}
public List<MessageRoute> metron_f549_0(JSONObject message, ProfilerConfig config, Context context)
{    List<MessageRoute> routes = new ArrayList<>();        for (ProfileConfig profile : config.getProfiles()) {        Clock clock = clockFactory.createClock(config);        Optional<MessageRoute> route = routeToProfile(message, profile, clock);        route.ifPresent(routes::add);    }    return routes;}
private Optional<MessageRoute> metron_f550_1(JSONObject message, ProfileConfig profile, Clock clock)
{    Optional<MessageRoute> route = Optional.empty();        @SuppressWarnings("unchecked")    final Map<String, Object> state = (Map<String, Object>) message;    try {                if (executor.execute(profile.getOnlyif(), state, Boolean.class)) {                        Optional<Long> timestamp = clock.currentTimeMillis(message);            if (timestamp.isPresent()) {                                String entity = executor.execute(profile.getForeach(), state, String.class);                route = Optional.of(new MessageRoute(profile, entity, message, timestamp.get()));            }        }    } catch (Throwable e) {                String msg = format("error while executing profile; profile='%s', error='%s'", profile.getProfile(), e.getMessage());            }    return route;}
public void metron_f551_0(StellarStatefulExecutor executor)
{    this.executor = executor;}
public void metron_f552_0(ClockFactory clockFactory)
{    this.clockFactory = clockFactory;}
public Optional<ProfileMeasurement> metron_f554_1()
{    Optional<ProfileMeasurement> result;    ProfilePeriod period = ProfilePeriod.fromTimestamp(maxTimestamp, periodDurationMillis, TimeUnit.MILLISECONDS);    try {                String profileExpression = definition.getResult().getProfileExpressions().getExpression();        Object profileValue = execute(profileExpression, "result/profile");                Map<String, Object> triageValues = definition.getResult().getTriageExpressions().getExpressions().entrySet().stream().collect(Collectors.toMap(e -> e.getKey(), e -> execute(e.getValue(), "result/triage")));                Map<String, Object> state = new HashMap<>();        state.put("profile", profileName);        state.put("entity", entity);        state.put("start", period.getStartTimeMillis());        state.put("end", period.getEndTimeMillis());        state.put("duration", period.getDurationMillis());        state.put("result", profileValue);                List<Object> groups = execute(definition.getGroupBy(), state, "groupBy");        result = Optional.of(new ProfileMeasurement().withProfileName(profileName).withEntity(entity).withGroups(groups).withPeriod(period).withProfileValue(profileValue).withTriageValues(triageValues).withDefinition(definition));    } catch (Throwable e) {                        result = Optional.empty();    }        isInitialized = false;    return result;}
public Object metron_f555_0(String variable)
{    return executor.getState().get(variable);}
public boolean metron_f556_0()
{    return isInitialized;}
public ProfileConfig metron_f557_0()
{    return definition;}
private Object metron_f558_0(String expression, Map<String, Object> transientState, String expressionType)
{    Object result = null;    List<Object> allResults = execute(Collections.singletonList(expression), transientState, expressionType);    if (allResults.size() > 0) {        result = allResults.get(0);    }    return result;}
private Object metron_f559_0(String expression, String expressionType)
{    return execute(expression, Collections.emptyMap(), expressionType);}
private void metron_f560_1(Map<String, String> expressions, Map<String, Object> transientState, String expressionType)
{        for (Map.Entry<String, String> entry : MapUtils.emptyIfNull(expressions).entrySet()) {        String var = entry.getKey();        String expr = entry.getValue();        try {                        executor.assign(var, expr, transientState);        } catch (Throwable e) {                        Set<String> variablesInScope = new HashSet<>();            variablesInScope.addAll(transientState.keySet());            variablesInScope.addAll(executor.getState().keySet());            String msg = format("Bad '%s' expression: error='%s', expr='%s', profile='%s', entity='%s', variables-available='%s'", expressionType, e.getMessage(), expr, profileName, entity, variablesInScope);                        throw new ParseException(msg, e);        }    }}
private List<Object> metron_f561_1(List<String> expressions, Map<String, Object> transientState, String expressionType)
{    List<Object> results = new ArrayList<>();    for (String expr : ListUtils.emptyIfNull(expressions)) {        try {                        Object result = executor.execute(expr, transientState, Object.class);            results.add(result);        } catch (Throwable e) {                        Set<String> variablesInScope = new HashSet<>();            variablesInScope.addAll(transientState.keySet());            variablesInScope.addAll(executor.getState().keySet());            String msg = format("Bad '%s' expression: error='%s', expr='%s', profile='%s', entity='%s', variables-available='%s'", expressionType, e.getMessage(), expr, profileName, entity, variablesInScope);                        throw new ParseException(msg, e);        }    }    return results;}
public String metron_f562_0()
{    return entity;}
public Builder metron_f563_0(Context context)
{    this.context = context;    return this;}
public Builder metron_f564_0(ProfileConfig definition)
{    this.definition = definition;    return this;}
public Builder metron_f565_0(String entity)
{    this.entity = entity;    return this;}
public Builder metron_f566_0(long duration, TimeUnit units)
{    this.periodDurationMillis = units.toMillis(duration);    return this;}
public Builder metron_f567_0(long millis)
{    this.periodDurationMillis = millis;    return this;}
public ProfileBuilder metron_f568_0()
{    if (definition == null) {        throw new IllegalArgumentException("missing profiler definition; got null");    }    if (StringUtils.isEmpty(entity)) {        throw new IllegalArgumentException(format("missing entity name; got '%s'", entity));    }    if (periodDurationMillis == null) {        throw new IllegalArgumentException("missing period duration");    }    return new DefaultProfileBuilder(definition, entity, periodDurationMillis, context);}
public List<byte[]> metron_f569_0(String profile, String entity, List<Object> groups, long start, long end)
{        long max = Math.max(start, end);    start = Math.min(start, end);    end = max;        return ProfilePeriod.visitPeriods(start, end, periodDurationMillis, TimeUnit.MILLISECONDS, Optional.empty(), period -> rowKey(profile, entity, period, groups));}
public List<byte[]> metron_f570_0(String profile, String entity, List<Object> groups, Iterable<ProfilePeriod> periods)
{    List<byte[]> ret = new ArrayList<>();    for (ProfilePeriod period : periods) {        ret.add(rowKey(profile, entity, period, groups));    }    return ret;}
public byte[] metron_f571_0(ProfileMeasurement m)
{    return rowKey(m.getProfileName(), m.getEntity(), m.getPeriod(), m.getGroups());}
public byte[] metron_f572_0(String profile, String entity, ProfilePeriod period, List<Object> groups)
{    return rowKey(profile, entity, period.getPeriod(), groups);}
public byte[] metron_f573_0(String profile, String entity, long period, List<Object> groups)
{        byte[] salt = getSalt(period, saltDivisor);    byte[] prefixKey = prefixKey(profile, entity);    byte[] groupKey = groupKey(groups);    byte[] timeKey = timeKey(period);    int capacity = salt.length + prefixKey.length + groupKey.length + timeKey.length;    return ByteBuffer.allocate(capacity).put(salt).put(prefixKey).put(groupKey).put(timeKey).array();}
private static byte[] metron_f574_0(String profile, String entity)
{    byte[] profileBytes = Bytes.toBytes(profile);    byte[] entityBytes = Bytes.toBytes(entity);    return ByteBuffer.allocate(profileBytes.length + entityBytes.length).put(profileBytes).put(entityBytes).array();}
private static byte[] metron_f575_0(List<Object> groups)
{    StringBuilder builder = new StringBuilder();    groups.forEach(g -> builder.append(g));    return Bytes.toBytes(builder.toString());}
private static byte[] metron_f576_0(ProfilePeriod period)
{    return timeKey(period.getPeriod());}
private static byte[] metron_f577_0(long period)
{    return Bytes.toBytes(period);}
public static byte[] metron_f578_0(ProfilePeriod period, int saltDivisor)
{    return getSalt(period.getPeriod(), saltDivisor);}
public static byte[] metron_f579_0(long period, int saltDivisor)
{    try {                MessageDigest digest = MessageDigest.getInstance("MD5");        byte[] hash = digest.digest(timeKey(period));        int salt = Bytes.toShort(hash) % saltDivisor;        return Bytes.toBytes(salt);    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}
public void metron_f580_0(long duration, TimeUnit units)
{    periodDurationMillis = units.toMillis(duration);}
public void metron_f581_0(int saltDivisor)
{    this.saltDivisor = saltDivisor;}
public ColumnList metron_f582_0(ProfileMeasurement measurement)
{    ColumnList cols = new ColumnList();    cols.addColumn(columnFamilyBytes, getColumnQualifier("value"), SerDeUtils.toBytes(measurement.getProfileValue()));    return cols;}
public String metron_f583_0()
{    return this.columnFamily;}
public void metron_f584_0(String columnFamily)
{    this.columnFamily = columnFamily;    this.columnFamilyBytes = Bytes.toBytes(columnFamily);}
public byte[] metron_f585_0(String fieldName)
{    if ("value".equals(fieldName)) {        return Bytes.toBytes("value");    }    throw new IllegalArgumentException(("unexpected field name: " + fieldName));}
public String metron_f586_0()
{    return entity;}
public void metron_f587_0(String entity)
{    this.entity = entity;}
public ProfileConfig metron_f588_0()
{    return profileDefinition;}
public void metron_f589_0(ProfileConfig profileDefinition)
{    this.profileDefinition = profileDefinition;}
public JSONObject metron_f590_0()
{    return message;}
public void metron_f591_0(JSONObject message)
{    this.message = message;}
public void metron_f592_0(Map message)
{    this.message = new JSONObject(message);}
public Long metron_f593_0()
{    return timestamp;}
public void metron_f594_0(Long timestamp)
{    this.timestamp = timestamp;}
public boolean metron_f595_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    MessageRoute that = (MessageRoute) o;    return new EqualsBuilder().append(profileDefinition, that.profileDefinition).append(entity, that.entity).append(message, that.message).append(timestamp, that.timestamp).isEquals();}
public int metron_f596_0()
{    return new HashCodeBuilder(17, 37).append(profileDefinition).append(entity).append(message).append(timestamp).toHashCode();}
public ProfileMeasurement metron_f597_0(String profileName)
{    this.profileName = profileName;    return this;}
public ProfileMeasurement metron_f598_0(String entity)
{    this.entity = entity;    return this;}
public ProfileMeasurement metron_f599_0(List<Object> groups)
{    this.groups = groups;    return this;}
public ProfileMeasurement metron_f600_0(long whenMillis, long periodDuration, TimeUnit periodUnits)
{    this.withPeriod(ProfilePeriod.fromTimestamp(whenMillis, periodDuration, periodUnits));    return this;}
public ProfileMeasurement metron_f601_0(ProfilePeriod period)
{    this.period = period;    return this;}
public ProfileMeasurement metron_f602_0(ProfileConfig definition)
{    this.definition = definition;    return this;}
public ProfileMeasurement metron_f603_0(Object profileValue)
{    this.profileValue = profileValue;    return this;}
public ProfileMeasurement metron_f604_0(Map<String, Object> triageValues)
{    this.triageValues = triageValues;    return this;}
public String metron_f605_0()
{    return profileName;}
public void metron_f606_0(String profileName)
{    this.profileName = profileName;}
public String metron_f607_0()
{    return entity;}
public void metron_f608_0(String entity)
{    this.entity = entity;}
public List<Object> metron_f609_0()
{    return groups;}
public void metron_f610_0(List<Object> groups)
{    this.groups = groups;}
public ProfilePeriod metron_f611_0()
{    return period;}
public void metron_f612_0(ProfilePeriod period)
{    this.period = period;}
public ProfileConfig metron_f613_0()
{    return definition;}
public void metron_f614_0(ProfileConfig definition)
{    this.definition = definition;}
public Object metron_f615_0()
{    return profileValue;}
public void metron_f616_0(Object profileValue)
{    this.profileValue = profileValue;}
public Map<String, Object> metron_f617_0()
{    return triageValues;}
public void metron_f618_0(Map<String, Object> triageValues)
{    this.triageValues = triageValues;}
public boolean metron_f619_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ProfileMeasurement that = (ProfileMeasurement) o;    return new EqualsBuilder().append(profileName, that.profileName).append(entity, that.entity).append(groups, that.groups).append(period, that.period).append(definition, that.definition).append(profileValue, that.profileValue).append(triageValues, that.triageValues).isEquals();}
public int metron_f620_0()
{    return new HashCodeBuilder(17, 37).append(profileName).append(entity).append(groups).append(period).append(definition).append(profileValue).append(triageValues).toHashCode();}
public static ProfilePeriod metron_f621_0(long epochMillis, long duration, TimeUnit units)
{    if (duration <= 0) {        throw new IllegalArgumentException(format("period duration must be > 0; got '%d %s'", duration, units));    }    long durationMillis = units.toMillis(duration);    long periodId = epochMillis / durationMillis;    return new ProfilePeriod(periodId, duration, units);}
public static ProfilePeriod metron_f622_0(long periodId, long duration, TimeUnit units)
{    if (periodId < 0) {        throw new IllegalArgumentException(format("period id must be >= 0; got '%d'", periodId));    }    return new ProfilePeriod(periodId, duration, units);}
public long metron_f623_0()
{    return period * durationMillis;}
public long metron_f624_0()
{    return getStartTimeMillis() + getDurationMillis();}
public ProfilePeriod metron_f625_0()
{    return fromPeriodId(period + 1, durationMillis, TimeUnit.MILLISECONDS);}
public long metron_f626_0()
{    return period;}
public long metron_f627_0()
{    return durationMillis;}
public boolean metron_f628_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ProfilePeriod that = (ProfilePeriod) o;    if (period != that.period)        return false;    return durationMillis == that.durationMillis;}
public int metron_f629_0()
{    int result = (int) (period ^ (period >>> 32));    result = 31 * result + (int) (durationMillis ^ (durationMillis >>> 32));    return result;}
public String metron_f630_0()
{    return "ProfilePeriod{" + "period=" + period + ", durationMillis=" + durationMillis + ", startTime=" + Instant.ofEpochMilli(getStartTimeMillis()).toString() + ", endTime=" + Instant.ofEpochMilli(getEndTimeMillis()).toString() + '}';}
public static List<T> metron_f631_0(long startEpochMillis, long endEpochMillis, long duration, TimeUnit units, Optional<Predicate<ProfilePeriod>> inclusionPredicate, Function<ProfilePeriod, T> transformation)
{    ProfilePeriod period = ProfilePeriod.fromTimestamp(startEpochMillis, duration, units);    List<T> ret = new ArrayList<>();    while (period.getStartTimeMillis() <= endEpochMillis) {        if (!inclusionPredicate.isPresent() || inclusionPredicate.get().test(period)) {            ret.add(transformation.apply(period));        }        period = period.next();    }    return ret;}
public void metron_f632_0()
{    clockFactory = new DefaultClockFactory();}
public void metron_f633_0()
{        ProfilerConfig config = new ProfilerConfig();    config.setTimestampField(Optional.of("timestamp"));        Clock clock = clockFactory.createClock(config);    assertTrue(clock instanceof EventTimeClock);}
public void metron_f634_0()
{        ProfilerConfig config = new ProfilerConfig();        Clock clock = clockFactory.createClock(config);    assertTrue(clock instanceof WallClock);}
public JSONObject metron_f635_0()
{    return new JSONObject();}
public void metron_f636_0()
{    JSONObject message = createMessage();        final Long timestamp = System.currentTimeMillis();    message.put(timestampField, timestamp);        EventTimeClock clock = new EventTimeClock(timestampField);    Optional<Long> result = clock.currentTimeMillis(message);        assertTrue(result.isPresent());    assertEquals(timestamp, result.get());}
public void metron_f637_0()
{    JSONObject message = createMessage();        final Long timestamp = System.currentTimeMillis();    message.put(timestampField, timestamp.toString());        EventTimeClock clock = new EventTimeClock(timestampField);    Optional<Long> result = clock.currentTimeMillis(message);        assertTrue(result.isPresent());    assertEquals(timestamp, result.get());}
public void metron_f638_0()
{        JSONObject message = createMessage();        EventTimeClock clock = new EventTimeClock(timestampField);    Optional<Long> result = clock.currentTimeMillis(message);        assertFalse(result.isPresent());}
public void metron_f639_0()
{        JSONObject message = createMessage();    message.put(timestampField, "invalid-timestamp-value");        EventTimeClock clock = new EventTimeClock(timestampField);    Optional<Long> result = clock.currentTimeMillis(message);        assertFalse(result.isPresent());}
public void metron_f640_0()
{    clockFactory = new EventTimeOnlyClockFactory();}
public void metron_f641_0()
{        ProfilerConfig config = new ProfilerConfig();    config.setTimestampField(Optional.of("timestamp"));        Clock clock = clockFactory.createClock(config);    assertTrue(clock instanceof EventTimeClock);}
public void metron_f642_0()
{        ProfilerConfig config = new ProfilerConfig();    clockFactory.createClock(config);    fail("Expected exception");}
public JSONObject metron_f643_0()
{    return new JSONObject();}
public void metron_f644_0()
{    JSONObject message = createMessage();    long before = System.currentTimeMillis();        WallClock clock = new WallClock();    Optional<Long> result = clock.currentTimeMillis(message);        long after = System.currentTimeMillis();    assertTrue(result.isPresent());    assertTrue(result.get() >= before);    assertTrue(result.get() <= after);}
public void metron_f645_0() throws Exception
{    context = Context.EMPTY_CONTEXT();    JSONParser parser = new JSONParser();    messageOne = (JSONObject) parser.parse(inputOne);    messageTwo = (JSONObject) parser.parse(inputTwo);    distributor = new DefaultMessageDistributor(periodDurationMillis, profileTimeToLiveMillis, maxNumberOfRoutes, Ticker.systemTicker());}
private ProfileConfig metron_f646_0(String json) throws IOException
{    return JSONUtils.INSTANCE.load(json, ProfileConfig.class);}
public void metron_f647_0() throws Exception
{        long timestamp = 100;    ProfileConfig definition = createDefinition(profileOne);    String entity = (String) messageOne.get("ip_src_addr");    MessageRoute route = new MessageRoute(definition, entity, messageOne, timestamp);        distributor.distribute(route, context);    List<ProfileMeasurement> measurements = distributor.flush();        assertEquals(1, measurements.size());    ProfileMeasurement m = measurements.get(0);    assertEquals(definition.getProfile(), m.getProfileName());    assertEquals(entity, m.getEntity());}
public void metron_f648_0() throws Exception
{        long timestamp = 100;    String entity = (String) messageOne.get("ip_src_addr");        MessageRoute routeOne = new MessageRoute(createDefinition(profileOne), entity, messageOne, timestamp);    distributor.distribute(routeOne, context);        MessageRoute routeTwo = new MessageRoute(createDefinition(profileTwo), entity, messageOne, timestamp);    distributor.distribute(routeTwo, context);        List<ProfileMeasurement> measurements = distributor.flush();    assertEquals(2, measurements.size());}
public void metron_f649_0() throws Exception
{        long timestamp = 100;        String entityOne = (String) messageOne.get("ip_src_addr");    MessageRoute routeOne = new MessageRoute(createDefinition(profileOne), entityOne, messageOne, timestamp);    distributor.distribute(routeOne, context);        String entityTwo = (String) messageTwo.get("ip_src_addr");    MessageRoute routeTwo = new MessageRoute(createDefinition(profileTwo), entityTwo, messageTwo, timestamp);    distributor.distribute(routeTwo, context);        List<ProfileMeasurement> measurements = distributor.flush();    assertEquals(2, measurements.size());}
public void metron_f650_0() throws Exception
{        FixedTicker ticker = new FixedTicker();        ProfileConfig definition = createDefinition(profileOne);    String entity = (String) messageOne.get("ip_src_addr");    MessageRoute route = new MessageRoute(definition, entity, messageOne, ticker.read());    distributor = new DefaultMessageDistributor(periodDurationMillis, profileTimeToLiveMillis, maxNumberOfRoutes, ticker);        distributor.distribute(route, context);        ticker.advanceTime(profileTimeToLiveMillis - 1000, MILLISECONDS);        assertEquals(0, distributor.flushExpired().size());    assertEquals(1, distributor.flush().size());}
public void metron_f651_0() throws Exception
{        FixedTicker ticker = new FixedTicker();        ProfileConfig definition = createDefinition(profileOne);    String entity = (String) messageOne.get("ip_src_addr");    MessageRoute route = new MessageRoute(definition, entity, messageOne, ticker.read());    distributor = new DefaultMessageDistributor(periodDurationMillis, profileTimeToLiveMillis, maxNumberOfRoutes, ticker);        distributor.distribute(route, context);        ticker.advanceTime(profileTimeToLiveMillis + 1000, MILLISECONDS);        assertEquals(1, distributor.flushExpired().size());    assertEquals(0, distributor.flush().size());}
public void metron_f652_0() throws Exception
{        FixedTicker ticker = new FixedTicker();        ProfileConfig definition = createDefinition(profileOne);    String entity = (String) messageOne.get("ip_src_addr");    MessageRoute route = new MessageRoute(definition, entity, messageOne, ticker.read());    distributor = new DefaultMessageDistributor(periodDurationMillis, profileTimeToLiveMillis, maxNumberOfRoutes, ticker);        distributor.distribute(route, context);        ticker.advanceTime(2, HOURS);        assertEquals(0, distributor.flush().size());        ticker.advanceTime(2, HOURS);        assertEquals(0, distributor.flushExpired().size());}
public FixedTicker metron_f653_0(long timestampNanos)
{    this.timestampNanos = timestampNanos;    return this;}
public FixedTicker metron_f654_0(long time, TimeUnit units)
{    this.timestampNanos += units.toNanos(time);    return this;}
public long metron_f655_0()
{    return this.timestampNanos;}
private ProfilerConfig metron_f656_0(String json) throws IOException
{    return JSONUtils.INSTANCE.load(json, ProfilerConfig.class);}
public void metron_f657_0() throws Exception
{    this.router = new DefaultMessageRouter(Context.EMPTY_CONTEXT());    this.context = Context.EMPTY_CONTEXT();    JSONParser parser = new JSONParser();    this.messageOne = (JSONObject) parser.parse(inputOne);    this.messageTwo = (JSONObject) parser.parse(inputTwo);    this.messageWithTimestamp = (JSONObject) parser.parse(inputWithTimestamp);}
public void metron_f658_0() throws Exception
{    List<MessageRoute> routes = router.route(messageOne, createConfig(oneProfile), context);    assertEquals(1, routes.size());    MessageRoute route1 = routes.get(0);    assertEquals(messageOne.get("ip_src_addr"), route1.getEntity());    assertEquals("profile-one", route1.getProfileDefinition().getProfile());}
public void metron_f659_0() throws Exception
{    List<MessageRoute> routes = router.route(messageOne, createConfig(noProfiles), context);    assertEquals(0, routes.size());}
public void metron_f660_0() throws Exception
{    List<MessageRoute> routes = router.route(messageOne, createConfig(twoProfiles), context);    assertEquals(2, routes.size());    {        MessageRoute route1 = routes.get(0);        assertEquals(messageOne.get("ip_src_addr"), route1.getEntity());        assertEquals("profile-one", route1.getProfileDefinition().getProfile());    }    {        MessageRoute route2 = routes.get(1);        assertEquals(messageOne.get("ip_src_addr"), route2.getEntity());        assertEquals("profile-two", route2.getProfileDefinition().getProfile());    }}
public void metron_f661_0() throws Exception
{    List<MessageRoute> routes = router.route(messageOne, createConfig(exclusiveProfile), context);    assertEquals(0, routes.size());}
public void metron_f662_0() throws Exception
{    List<MessageRoute> routes = router.route(messageOne, createConfig(badForeach), context);    assertEquals(0, routes.size());}
public void metron_f663_0() throws Exception
{    List<MessageRoute> routes = router.route(messageOne, createConfig(badForeach), context);    assertEquals(0, routes.size());}
public void metron_f664_0() throws Exception
{    List<MessageRoute> routes = router.route(messageOne, createConfig(goodAndBad), context);    assertEquals(1, routes.size());    MessageRoute route1 = routes.get(0);    assertEquals("good-profile", route1.getProfileDefinition().getProfile());    assertEquals(messageOne.get("ip_src_addr"), route1.getEntity());}
public void metron_f665_0() throws Exception
{    List<MessageRoute> routes = router.route(messageWithTimestamp, createConfig(profileWithEventTime), context);    ;    assertEquals(1, routes.size());    MessageRoute route1 = routes.get(0);    assertEquals("profile-one", route1.getProfileDefinition().getProfile());    assertEquals(messageWithTimestamp.get("ip_src_addr"), route1.getEntity());    assertEquals(messageWithTimestamp.get("timestamp"), route1.getTimestamp());}
public void metron_f666_0() throws Exception
{        List<MessageRoute> routes = router.route(messageOne, createConfig(profileWithEventTime), context);    assertEquals(0, routes.size());}
public void metron_f667_0() throws Exception
{    message = (JSONObject) new JSONParser().parse(input);}
public void metron_f668_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testInitProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(100 + 200, (int) convert(m.get().getProfileValue(), Integer.class));}
public void metron_f669_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testInitProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(0, (int) convert(m.get().getProfileValue(), Integer.class));}
public void metron_f670_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testUpdateProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        int count = 10;    for (int i = 0; i < count; i++) {                builder.apply(message, timestamp);                timestamp += 5;    }    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(count * 1 + count * 2, (int) convert(m.get().getProfileValue(), Integer.class));}
public void metron_f671_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testResultProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(100, (int) convert(m.get().getProfileValue(), Integer.class));}
public void metron_f672_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testResultProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();    {                builder.apply(message, timestamp);        Optional<ProfileMeasurement> m = builder.flush();        assertTrue(m.isPresent());                ProfilePeriod expected = ProfilePeriod.fromTimestamp(timestamp, 10, TimeUnit.MINUTES);        assertEquals(expected, m.get().getPeriod());    }    {                timestamp += TimeUnit.MINUTES.toMillis(10);                builder.apply(message, timestamp);        Optional<ProfileMeasurement> m = builder.flush();        assertTrue(m.isPresent());                ProfilePeriod expected = ProfilePeriod.fromTimestamp(timestamp, 10, TimeUnit.MINUTES);        assertEquals(expected, m.get().getPeriod());    }}
public void metron_f673_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testGroupByProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(2, m.get().getGroups().size());    assertEquals(100, m.get().getGroups().get(0));    assertEquals(200, m.get().getGroups().get(1));}
public void metron_f674_0() throws Exception
{        long timestamp = 1503081070340L;    ProfilePeriod period = ProfilePeriod.fromTimestamp(timestamp, 10, TimeUnit.MINUTES);    definition = JSONUtils.INSTANCE.load(testStateAvailableToGroupBy, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(6, m.get().getGroups().size());    assertEquals("invalid profile", "test-profile", m.get().getGroups().get(0));    assertEquals("invalid entity", "10.0.0.1", m.get().getGroups().get(1));    assertEquals("invalid start", period.getStartTimeMillis(), m.get().getGroups().get(2));    assertEquals("invalid end", period.getEndTimeMillis(), m.get().getGroups().get(3));    assertEquals("invalid duration", period.getDurationMillis(), m.get().getGroups().get(4));    assertEquals("invalid result", 100, m.get().getGroups().get(5));}
public void metron_f675_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testFlushProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        int count = 10;    for (int i = 0; i < count; i++) {                builder.apply(message, timestamp);                timestamp += 5;    }    builder.flush();        timestamp += TimeUnit.MINUTES.toMillis(20);        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();        assertTrue(m.isPresent());    assertEquals(33, m.get().getProfileValue());}
public void metron_f676_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testFlushProfileWithNaiveInit, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        int count = 10;    for (int i = 0; i < count; i++) {                builder.apply(message, timestamp);                timestamp += 5;    }    builder.flush();        timestamp += TimeUnit.MINUTES.toMillis(20);        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(3, m.get().getProfileValue());}
public void metron_f677_0() throws Exception
{        long timestamp = 100;    final String entity = "10.0.0.1";    definition = JSONUtils.INSTANCE.load(testFlushProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity(entity).withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(entity, m.get().getEntity());}
public void metron_f678_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testResultWithProfileExpression, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(100, m.get().getProfileValue());}
public void metron_f679_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(testResultWithTriageExpression, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());        assertEquals(0, m.get().getTriageValues().get("zero"));    assertEquals(100, m.get().getTriageValues().get("hundred"));    assertEquals(100, m.get().getProfileValue());}
public void metron_f680_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(badInitProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    assertFalse(builder.flush().isPresent());}
public void metron_f681_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(badSimpleResultProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    assertFalse(builder.flush().isPresent());}
public void metron_f682_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(badGroupByProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    assertFalse(builder.flush().isPresent());}
public void metron_f683_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(badResultProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    assertFalse(builder.flush().isPresent());}
public void metron_f684_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(badResultTriage, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);    assertFalse(builder.flush().isPresent());}
public void metron_f685_0() throws Exception
{        long timestamp = 100;    definition = JSONUtils.INSTANCE.load(badUpdateProfile, ProfileConfig.class);    builder = new DefaultProfileBuilder.Builder().withDefinition(definition).withEntity("10.0.0.1").withPeriodDuration(10, TimeUnit.MINUTES).withContext(Context.EMPTY_CONTEXT()).build();        builder.apply(message, timestamp);        Optional<ProfileMeasurement> m = builder.flush();    assertTrue(m.isPresent());    assertEquals(0, m.get().getProfileValue());}
public void metron_f686_0() throws Exception
{        measurement = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withPeriod(AUG2016, periodDuration, periodUnits);    rowKeyBuilder = new SaltyRowKeyBuilder(saltDivisor, periodDuration, periodUnits);}
public void metron_f687_0() throws Exception
{        measurement.withGroups(Arrays.asList("group1"));        ByteBuffer buffer = ByteBuffer.allocate(100).put(SaltyRowKeyBuilder.getSalt(measurement.getPeriod(), saltDivisor)).put(measurement.getProfileName().getBytes(StandardCharsets.UTF_8)).put(measurement.getEntity().getBytes(StandardCharsets.UTF_8)).put("group1".getBytes(StandardCharsets.UTF_8)).putLong(1635701L);    buffer.flip();    final byte[] expected = new byte[buffer.limit()];    buffer.get(expected, 0, buffer.limit());        byte[] actual = rowKeyBuilder.rowKey(measurement);    Assert.assertTrue(Arrays.equals(expected, actual));}
public void metron_f688_0() throws Exception
{        measurement.withGroups(Arrays.asList("group1", "group2"));        ByteBuffer buffer = ByteBuffer.allocate(100).put(SaltyRowKeyBuilder.getSalt(measurement.getPeriod(), saltDivisor)).put(measurement.getProfileName().getBytes(StandardCharsets.UTF_8)).put(measurement.getEntity().getBytes(StandardCharsets.UTF_8)).put("group1".getBytes(StandardCharsets.UTF_8)).put("group2".getBytes(StandardCharsets.UTF_8)).putLong(1635701L);    buffer.flip();    final byte[] expected = new byte[buffer.limit()];    buffer.get(expected, 0, buffer.limit());        byte[] actual = rowKeyBuilder.rowKey(measurement);    Assert.assertTrue(Arrays.equals(expected, actual));}
public void metron_f689_0() throws Exception
{        measurement.withGroups(Arrays.asList(200));        ByteBuffer buffer = ByteBuffer.allocate(100).put(SaltyRowKeyBuilder.getSalt(measurement.getPeriod(), saltDivisor)).put(measurement.getProfileName().getBytes(StandardCharsets.UTF_8)).put(measurement.getEntity().getBytes(StandardCharsets.UTF_8)).put("200".getBytes(StandardCharsets.UTF_8)).putLong(1635701L);    buffer.flip();    final byte[] expected = new byte[buffer.limit()];    buffer.get(expected, 0, buffer.limit());        byte[] actual = rowKeyBuilder.rowKey(measurement);    Assert.assertTrue(Arrays.equals(expected, actual));}
public void metron_f690_0() throws Exception
{        measurement.withGroups(Arrays.asList(200, "group1"));        ByteBuffer buffer = ByteBuffer.allocate(100).put(SaltyRowKeyBuilder.getSalt(measurement.getPeriod(), saltDivisor)).put(measurement.getProfileName().getBytes(StandardCharsets.UTF_8)).put(measurement.getEntity().getBytes(StandardCharsets.UTF_8)).put("200".getBytes(StandardCharsets.UTF_8)).put("group1".getBytes(StandardCharsets.UTF_8)).putLong(1635701L);    buffer.flip();    final byte[] expected = new byte[buffer.limit()];    buffer.get(expected, 0, buffer.limit());        byte[] actual = rowKeyBuilder.rowKey(measurement);    Assert.assertTrue(Arrays.equals(expected, actual));}
public void metron_f691_0() throws Exception
{        measurement.withGroups(Collections.emptyList());        ByteBuffer buffer = ByteBuffer.allocate(100).put(SaltyRowKeyBuilder.getSalt(measurement.getPeriod(), saltDivisor)).put(measurement.getProfileName().getBytes(StandardCharsets.UTF_8)).put(measurement.getEntity().getBytes(StandardCharsets.UTF_8)).putLong(1635701L);    buffer.flip();    final byte[] expected = new byte[buffer.limit()];    buffer.get(expected, 0, buffer.limit());        byte[] actual = rowKeyBuilder.rowKey(measurement);    Assert.assertTrue(Arrays.equals(expected, actual));}
public void metron_f692_0() throws Exception
{    int hoursAgo = 1;        List<Object> groups = Collections.emptyList();    rowKeyBuilder = new SaltyRowKeyBuilder(saltDivisor, periodDuration, periodUnits);        long now = System.currentTimeMillis();    long oldest = now - TimeUnit.HOURS.toMillis(hoursAgo);    ProfileMeasurement m = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withPeriod(oldest, periodDuration, periodUnits).withProfileValue(22);        List<byte[]> expectedKeys = new ArrayList<>();    for (int i = 0; i < (hoursAgo * 4) + 1; i++) {                byte[] rk = rowKeyBuilder.rowKey(m);        expectedKeys.add(rk);                ProfilePeriod next = m.getPeriod().next();        m = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withPeriod(next.getStartTimeMillis(), periodDuration, periodUnits);    }        List<byte[]> actualKeys = rowKeyBuilder.rowKeys(measurement.getProfileName(), measurement.getEntity(), groups, oldest, now);        for (int i = 0; i < actualKeys.size(); i++) {        byte[] actual = actualKeys.get(i);        byte[] expected = expectedKeys.get(i);        assertThat(actual, equalTo(expected));    }}
private void metron_f693_0(byte[] bytes)
{    StringBuilder sb = new StringBuilder(bytes.length * 2);    Formatter formatter = new Formatter(sb);    for (byte b : bytes) {        formatter.format("%02x ", b);    }    System.out.println(sb.toString());}
public void metron_f694_0() throws Exception
{    definition = ProfileConfig.fromJSON(profile);    measurement = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withDefinition(definition).withPeriod(System.currentTimeMillis(), 10, TimeUnit.MINUTES).withProfileValue(22).withTriageValues(Collections.singletonMap("max", 200));}
public void metron_f695_0() throws Exception
{    assertNotNull(measurement);    Kryo kryo = new Kryo();        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();    Output output = new Output(byteStream);    kryo.writeObject(output, measurement);        byte[] bits = output.toBytes();    assertNotNull(bits);        Input input = new Input(new ByteArrayInputStream(bits));    ProfileMeasurement actual = kryo.readObject(input, ProfileMeasurement.class);        assertNotNull(actual);    assertEquals(measurement, actual);}
public void metron_f696_0() throws Exception
{    assertNotNull(measurement);        ByteArrayOutputStream bytes = new ByteArrayOutputStream();    ObjectOutputStream out = new ObjectOutputStream(bytes);    out.writeObject(measurement);        byte[] raw = bytes.toByteArray();    assertTrue(raw.length > 0);        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(raw));    Object actual = in.readObject();        assertEquals(measurement, actual);}
public void metron_f697_0()
{    long duration = 1;    TimeUnit units = TimeUnit.HOURS;    ProfilePeriod period = ProfilePeriod.fromTimestamp(0, duration, units);    assertEquals(0, period.getPeriod());    assertEquals(0, period.getStartTimeMillis());    assertEquals(units.toMillis(duration), period.getDurationMillis());}
public void metron_f698_0()
{    long duration = 1;    TimeUnit units = TimeUnit.MINUTES;    ProfilePeriod period = ProfilePeriod.fromTimestamp(AUG2016, duration, units);    assertEquals(24535527, period.getPeriod());        assertEquals(1472131620000L, period.getStartTimeMillis());    assertEquals(units.toMillis(duration), period.getDurationMillis());}
public void metron_f699_0()
{    long duration = 15;    TimeUnit units = TimeUnit.MINUTES;    ProfilePeriod period = ProfilePeriod.fromTimestamp(AUG2016, duration, units);    assertEquals(1635701, period.getPeriod());        assertEquals(1472130900000L, period.getStartTimeMillis());    assertEquals(units.toMillis(duration), period.getDurationMillis());}
public void metron_f700_0()
{    long duration = 1;    TimeUnit units = TimeUnit.HOURS;    ProfilePeriod period = ProfilePeriod.fromTimestamp(AUG2016, duration, units);    assertEquals(408925, period.getPeriod());        assertEquals(1472130000000L, period.getStartTimeMillis());    assertEquals(units.toMillis(duration), period.getDurationMillis());}
public void metron_f701_0()
{    long duration = 2;    TimeUnit units = TimeUnit.HOURS;    ProfilePeriod period = ProfilePeriod.fromTimestamp(AUG2016, duration, units);    assertEquals(204462, period.getPeriod());        assertEquals(1472126400000L, period.getStartTimeMillis());    assertEquals(units.toMillis(duration), period.getDurationMillis());}
public void metron_f702_0()
{    long duration = 8;    TimeUnit units = TimeUnit.HOURS;    ProfilePeriod period = ProfilePeriod.fromTimestamp(AUG2016, duration, units);    assertEquals(51115, period.getPeriod());        assertEquals(1472112000000L, period.getStartTimeMillis());    assertEquals(units.toMillis(duration), period.getDurationMillis());}
public void metron_f703_0()
{    long duration = 15;    TimeUnit units = TimeUnit.MINUTES;    ProfilePeriod previous = ProfilePeriod.fromTimestamp(AUG2016, duration, units);    IntStream.range(0, 100).forEach(i -> {        ProfilePeriod next = previous.next();        assertEquals(previous.getPeriod() + 1, next.getPeriod());        assertEquals(previous.getStartTimeMillis() + previous.getDurationMillis(), next.getStartTimeMillis());        assertEquals(previous.getDurationMillis(), next.getDurationMillis());    });}
public void metron_f704_0()
{    long duration = 0;    TimeUnit units = TimeUnit.HOURS;    ProfilePeriod.fromTimestamp(0, duration, units);}
public void metron_f705_0() throws Exception
{    ProfilePeriod expected = ProfilePeriod.fromTimestamp(AUG2016, 1, TimeUnit.HOURS);    Kryo kryo = new Kryo();        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();    Output output = new Output(byteStream);    kryo.writeObject(output, expected);        byte[] bits = output.toBytes();    assertNotNull(bits);        Input input = new Input(new ByteArrayInputStream(bits));    ProfilePeriod actual = kryo.readObject(input, ProfilePeriod.class);        assertNotNull(actual);    assertEquals(expected, actual);}
public void metron_f706_0() throws Exception
{    ProfilePeriod expected = ProfilePeriod.fromTimestamp(AUG2016, 1, TimeUnit.HOURS);        ByteArrayOutputStream bytes = new ByteArrayOutputStream();    ObjectOutputStream out = new ObjectOutputStream(bytes);    out.writeObject(expected);        byte[] raw = bytes.toByteArray();    assertTrue(raw.length > 0);        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(raw));    Object actual = in.readObject();        assertEquals(expected, actual);}
public void metron_f707_0()
{    ProfilePeriod expected = ProfilePeriod.fromTimestamp(AUG2016, 1, TimeUnit.HOURS);        long periodId = expected.getPeriod();    long duration = expected.getDurationMillis();    ProfilePeriod actual = ProfilePeriod.fromPeriodId(periodId, duration, TimeUnit.MILLISECONDS);    assertEquals(expected, actual);}
public void metron_f708_0()
{    ProfilePeriod.fromPeriodId(-1, 1, TimeUnit.HOURS);}
public void metron_f709_0()
{    assertEquals(ProfilePeriod.fromTimestamp(0, 1, TimeUnit.HOURS), ProfilePeriod.fromPeriodId(0, 1, TimeUnit.HOURS));}
public void metron_f710_0(Context context)
{}
public boolean metron_f711_0()
{    return true;}
public Object metron_f712_0(List<Object> args, Context context)
{    @SuppressWarnings("unchecked")    Map<String, Object> global = (Map<String, Object>) context.getCapability(GLOBAL_CONFIG, false).orElse(Collections.emptyMap());        long duration = PROFILER_PERIOD.getOrDefault(global, PROFILER_PERIOD.getDefault(), Long.class);    String configuredUnits = PROFILER_PERIOD_UNITS.getOrDefault(global, PROFILER_PERIOD_UNITS.getDefault(), String.class);    long periodDurationMillis = TimeUnit.valueOf(configuredUnits).toMillis(duration);        String arg0 = Util.getArg(0, String.class, args);    ProfilerConfig profilerConfig;    try {        profilerConfig = JSONUtils.INSTANCE.load(arg0, ProfilerConfig.class);    } catch (IOException e) {        throw new IllegalArgumentException("Invalid profiler configuration", e);    }        long profileTimeToLiveMillis = Long.MAX_VALUE;    long maxNumberOfRoutes = Long.MAX_VALUE;    return new StandAloneProfiler(profilerConfig, periodDurationMillis, profileTimeToLiveMillis, maxNumberOfRoutes, context);}
public void metron_f713_0(Context context)
{    parser = new JSONParser();}
public boolean metron_f714_0()
{    return parser != null;}
public Object metron_f715_0(List<Object> args, Context context) throws ParseException
{        Object arg0 = Util.getArg(0, Object.class, args);    List<JSONObject> messages = getMessages(arg0);        StandAloneProfiler profiler = Util.getArg(1, StandAloneProfiler.class, args);    for (JSONObject message : messages) {        profiler.apply(message);    }    return profiler;}
private List<JSONObject> metron_f716_0(Object arg)
{    List<JSONObject> messages;    if (arg instanceof String) {        messages = getMessagesFromString((String) arg);    } else if (arg instanceof Iterable) {        messages = getMessagesFromIterable((Iterable<String>) arg);    } else if (arg instanceof JSONObject) {        messages = Collections.singletonList((JSONObject) arg);    } else {        throw new IllegalArgumentException(format("invalid message: found '%s', expected String, List, or JSONObject", ClassUtils.getShortClassName(arg, "null")));    }    return messages;}
private List<JSONObject> metron_f717_0(Iterable<String> strings)
{    List<JSONObject> messages = new ArrayList<>();        for (String str : strings) {        messages.addAll(getMessagesFromString(str));    }    return messages;}
private List<JSONObject> metron_f718_0(String arg0)
{    List<JSONObject> messages = new ArrayList<>();    try {        Object parsedArg0 = parser.parse(arg0);        if (parsedArg0 instanceof JSONObject) {                        messages.add((JSONObject) parsedArg0);        } else if (parsedArg0 instanceof JSONArray) {                        JSONArray jsonArray = (JSONArray) parsedArg0;            for (Object item : jsonArray) {                messages.addAll(getMessages(item));            }        } else {            throw new IllegalArgumentException(format("invalid message: found '%s', expected JSONObject or JSONArray", ClassUtils.getShortClassName(parsedArg0, "null")));        }    } catch (org.json.simple.parser.ParseException e) {        throw new IllegalArgumentException(format("invalid message: '%s'", e.getMessage()), e);    }    return messages;}
public void metron_f719_0(Context context)
{}
public boolean metron_f720_0()
{    return true;}
public Object metron_f721_0(List<Object> args, Context context) throws ParseException
{        StandAloneProfiler profiler = Util.getArg(0, StandAloneProfiler.class, args);    if (profiler == null) {        throw new IllegalArgumentException(format("expected the profiler returned by PROFILER_INIT, found null"));    }        List<Map<String, Object>> measurements = new ArrayList<>();    for (ProfileMeasurement m : profiler.flush()) {                Map<String, Object> period = new HashMap<>();        period.put("period", m.getPeriod().getPeriod());        period.put("start", m.getPeriod().getStartTimeMillis());        period.put("duration", m.getPeriod().getDurationMillis());        period.put("end", m.getPeriod().getEndTimeMillis());                Map<String, Object> measurement = new HashMap<>();        measurement.put("profile", m.getProfileName());        measurement.put("entity", m.getEntity());        measurement.put("value", m.getProfileValue());        measurement.put("groups", m.getGroups());        measurement.put("period", period);        measurements.add(measurement);    }    return measurements;}
public void metron_f722_0(JSONObject message)
{        List<MessageRoute> routes = router.route(message, config, context);    for (MessageRoute route : routes) {        distributor.distribute(route, context);    }    routeCount += routes.size();    messageCount += 1;}
public List<ProfileMeasurement> metron_f723_0()
{    return distributor.flush();}
public ProfilerConfig metron_f724_0()
{    return config;}
public int metron_f725_0()
{    return (config == null) ? 0 : config.getProfiles().size();}
public int metron_f726_0()
{    return messageCount;}
public int metron_f727_0()
{    return routeCount;}
public String metron_f728_0()
{    return "Profiler{" + getProfileCount() + " profile(s), " + getMessageCount() + " messages(s), " + getRouteCount() + " route(s)" + '}';}
private T metron_f729_0(String expression, Class<T> clazz)
{    return executor.execute(expression, state, clazz);}
public void metron_f730_0()
{    state = new HashMap<>();        Map<String, Object> global = new HashMap<String, Object>() {        {            put(PROFILER_PERIOD.getKey(), Long.toString(periodDuration));            put(PROFILER_PERIOD_UNITS.getKey(), periodUnits.toString());        }    };        executor = new DefaultStellarStatefulExecutor(new SimpleFunctionResolver().withClass(ProfilerFunctions.ProfilerInit.class).withClass(ProfilerFunctions.ProfilerApply.class).withClass(ProfilerFunctions.ProfilerFlush.class), new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> global).build());}
public void metron_f731_0()
{    state.put("config", "{ \"profiles\" : [] }");    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    assertNotNull(profiler);    assertEquals(0, profiler.getProfileCount());    assertEquals(0, profiler.getMessageCount());    assertEquals(0, profiler.getRouteCount());}
public void metron_f732_0()
{    state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    assertNotNull(profiler);    assertEquals(1, profiler.getProfileCount());    assertEquals(0, profiler.getMessageCount());    assertEquals(0, profiler.getRouteCount());}
public void metron_f733_0()
{    run("PROFILER_INIT()", StandAloneProfiler.class);}
public void metron_f734_0()
{    run("PROFILER_INIT({ \"invalid\": 2 })", StandAloneProfiler.class);}
public void metron_f735_0()
{    state.put("config", helloWorldProfilerDef);    String expression = "PROFILER_INIT(config)";        StellarStatefulExecutor executor = new DefaultStellarStatefulExecutor(new SimpleFunctionResolver().withClass(ProfilerFunctions.ProfilerInit.class).withClass(ProfilerFunctions.ProfilerApply.class).withClass(ProfilerFunctions.ProfilerFlush.class), Context.EMPTY_CONTEXT());    StandAloneProfiler profiler = executor.execute(expression, state, StandAloneProfiler.class);    assertNotNull(profiler);    assertEquals(1, profiler.getProfileCount());    assertEquals(0, profiler.getMessageCount());    assertEquals(0, profiler.getRouteCount());}
public void metron_f736_0()
{        state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    state.put("profiler", profiler);        state.put("message", message);    StandAloneProfiler result = run("PROFILER_APPLY(message, profiler)", StandAloneProfiler.class);        assertSame(profiler, result);    assertEquals(1, profiler.getProfileCount());    assertEquals(1, profiler.getMessageCount());    assertEquals(1, profiler.getRouteCount());}
public void metron_f737_0() throws Exception
{        state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    state.put("profiler", profiler);        JSONParser parser = new JSONParser();    JSONObject jsonObject = (JSONObject) parser.parse(message);    state.put("jsonObj", jsonObject);    StandAloneProfiler result = run("PROFILER_APPLY(jsonObj, profiler)", StandAloneProfiler.class);        assertSame(profiler, result);    assertEquals(1, profiler.getProfileCount());    assertEquals(1, profiler.getMessageCount());    assertEquals(1, profiler.getRouteCount());}
public void metron_f738_0()
{        state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    state.put("profiler", profiler);        state.put("messages", messages);    StandAloneProfiler result = run("PROFILER_APPLY(messages, profiler)", StandAloneProfiler.class);        assertSame(profiler, result);    assertEquals(1, profiler.getProfileCount());    assertEquals(3, profiler.getMessageCount());    assertEquals(3, profiler.getRouteCount());}
public void metron_f739_0()
{        state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    state.put("profiler", profiler);        state.put("msg", message);    StandAloneProfiler result = run("PROFILER_APPLY([msg, msg, msg], profiler)", StandAloneProfiler.class);        assertSame(profiler, result);    assertEquals(1, profiler.getProfileCount());    assertEquals(3, profiler.getMessageCount());    assertEquals(3, profiler.getRouteCount());}
public void metron_f740_0()
{        state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    state.put("profiler", profiler);        state.put("messages", "[ ]");    StandAloneProfiler result = run("PROFILER_APPLY(messages, profiler)", StandAloneProfiler.class);        assertSame(profiler, result);    assertEquals(1, profiler.getProfileCount());    assertEquals(0, profiler.getMessageCount());    assertEquals(0, profiler.getRouteCount());}
public void metron_f741_0()
{    run("PROFILER_APPLY()", StandAloneProfiler.class);}
public void metron_f742_0()
{    run("PROFILER_APPLY(undefined)", StandAloneProfiler.class);}
public void metron_f743_0()
{        state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    state.put("profiler", profiler);        run("PROFILER_APPLY(messages, profiler)", StandAloneProfiler.class);}
public void metron_f744_0()
{        state.put("config", helloWorldProfilerDef);    StandAloneProfiler profiler = run("PROFILER_INIT(config)", StandAloneProfiler.class);    state.put("profiler", profiler);        state.put("message", message);    run("PROFILER_APPLY(message, profiler)", StandAloneProfiler.class);        List<Map<String, Object>> measurements = run("PROFILER_FLUSH(profiler)", List.class);        assertNotNull(measurements);    assertEquals(1, measurements.size());    Map<String, Object> measurement = measurements.get(0);    assertEquals("hello-world", measurement.get("profile"));    assertEquals("10.0.0.1", measurement.get("entity"));    assertEquals(1, measurement.get("value"));    assertEquals(Collections.emptyList(), measurement.get("groups"));}
public void metron_f745_0()
{    run("PROFILER_FLUSH()", StandAloneProfiler.class);}
public void metron_f746_0()
{    run("PROFILER_FLUSH(undefined)", StandAloneProfiler.class);}
public void metron_f747_0() throws Exception
{        JSONParser parser = new JSONParser();    message = (JSONObject) parser.parse(messageJson);}
public void metron_f748_0() throws Exception
{    StandAloneProfiler profiler = createProfiler(oneProfile);    profiler.apply(message);    profiler.apply(message);    profiler.apply(message);    List<ProfileMeasurement> measurements = profiler.flush();    assertEquals(1, measurements.size());        ProfileMeasurement m = measurements.get(0);    assertEquals("profile1", m.getProfileName());    assertEquals(3, m.getProfileValue());}
public void metron_f749_0() throws Exception
{    StandAloneProfiler profiler = createProfiler(twoProfiles);    profiler.apply(message);    profiler.apply(message);    profiler.apply(message);    List<ProfileMeasurement> measurements = profiler.flush();    assertEquals(2, measurements.size());        List<String> expected = Arrays.asList(new String[] { "profile1", "profile2" });    {        ProfileMeasurement m = measurements.get(0);        assertTrue(expected.contains(m.getProfileName()));        assertEquals("result", m.getProfileValue());    }    {        ProfileMeasurement m = measurements.get(1);        assertTrue(expected.contains(m.getProfileName()));        assertEquals("result", m.getProfileValue());    }}
public void metron_f750_0() throws Exception
{    {        StandAloneProfiler profiler = createProfiler(noProfiles);        profiler.apply(message);        assertEquals(1, profiler.getMessageCount());        assertEquals(0, profiler.getRouteCount());        profiler.apply(message);        assertEquals(2, profiler.getMessageCount());        assertEquals(0, profiler.getRouteCount());        profiler.apply(message);        assertEquals(3, profiler.getMessageCount());        assertEquals(0, profiler.getRouteCount());    }    {        StandAloneProfiler profiler = createProfiler(oneProfile);        profiler.apply(message);        assertEquals(1, profiler.getMessageCount());        assertEquals(1, profiler.getRouteCount());        profiler.apply(message);        assertEquals(2, profiler.getMessageCount());        assertEquals(2, profiler.getRouteCount());        profiler.apply(message);        assertEquals(3, profiler.getMessageCount());        assertEquals(3, profiler.getRouteCount());    }    {        StandAloneProfiler profiler = createProfiler(twoProfiles);        profiler.apply(message);        assertEquals(1, profiler.getMessageCount());        assertEquals(2, profiler.getRouteCount());        profiler.apply(message);        assertEquals(2, profiler.getMessageCount());        assertEquals(4, profiler.getRouteCount());        profiler.apply(message);        assertEquals(3, profiler.getMessageCount());        assertEquals(6, profiler.getRouteCount());    }}
public void metron_f751_0() throws Exception
{    {        StandAloneProfiler profiler = createProfiler(noProfiles);        assertEquals(0, profiler.getProfileCount());    }    {        StandAloneProfiler profiler = createProfiler(oneProfile);        assertEquals(1, profiler.getProfileCount());    }    {        StandAloneProfiler profiler = createProfiler(twoProfiles);        assertEquals(2, profiler.getProfileCount());    }}
private ProfilerConfig metron_f752_0(String configAsJSON) throws Exception
{    InputStream in = new ByteArrayInputStream(configAsJSON.getBytes(StandardCharsets.UTF_8));    return JSONUtils.INSTANCE.load(in, ProfilerConfig.class);}
private StandAloneProfiler metron_f753_0(String profileJson) throws Exception
{        long profileTimeToLiveMillis = Long.MAX_VALUE;    long maxNumberOfRoutes = Long.MAX_VALUE;    ProfilerConfig config = toProfilerConfig(profileJson);    return new StandAloneProfiler(config, periodDurationMillis, profileTimeToLiveMillis, maxNumberOfRoutes, context);}
public long metron_f754_1(SparkSession spark, Properties profilerProps, Properties globalProperties, Properties readerProps, ProfilerConfig profiles)
{        Map<String, String> globals = Maps.fromProperties(globalProperties);        TelemetryReader reader = TelemetryReaders.create(TELEMETRY_INPUT_READER.get(profilerProps, String.class));    Dataset<String> telemetry = reader.read(spark, profilerProps, readerProps);            Dataset<MessageRoute> routes = telemetry.flatMap(messageRouterFunction(profilerProps, profiles, globals), Encoders.bean(MessageRoute.class));            Dataset<ProfileMeasurementAdapter> measurements = routes.groupByKey(new GroupByPeriodFunction(profilerProps), Encoders.STRING()).mapGroups(new ProfileBuilderFunction(profilerProps, globals), Encoders.bean(ProfileMeasurementAdapter.class));            long count = measurements.mapPartitions(new HBaseWriterFunction(profilerProps), Encoders.INT()).agg(sum("value")).head().getLong(0);        return count;}
private MessageRouterFunction metron_f755_0(Properties profilerProps, ProfilerConfig profiles, Map<String, String> globals)
{    MessageRouterFunction routerFunction = new MessageRouterFunction(profiles, globals);        Optional<Long> beginAt = timestampParser.parse(TELEMETRY_INPUT_BEGIN.get(profilerProps, String.class));    beginAt.ifPresent(begin -> routerFunction.withBegin(begin));        Optional<Long> endAt = timestampParser.parse(TELEMETRY_INPUT_END.get(profilerProps, String.class));    endAt.ifPresent(end -> routerFunction.withEnd(end));    return routerFunction;}
public String metron_f756_0()
{    return key;}
public Object metron_f757_0()
{    return getDefault(valueType);}
public T metron_f758_0(Class<T> clazz)
{    return defaultValue == null ? null : ConversionUtils.convert(defaultValue, clazz);}
public Object metron_f759_0(Map<String, String> config)
{    return getOrDefault(config, defaultValue);}
public Object metron_f760_0(Properties properties)
{    return getOrDefault(properties, defaultValue);}
public T metron_f761_0(Map<String, String> config, Class<T> clazz)
{    return getOrDefault(config, defaultValue, clazz);}
public T metron_f762_0(Properties properties, Class<T> clazz)
{    return getOrDefault(properties, defaultValue, clazz);}
private Object metron_f763_0(Map<String, String> config, Object defaultValue)
{    return getOrDefault(config, defaultValue, valueType);}
private Object metron_f764_0(Properties properties, Object defaultValue)
{    return getOrDefault(properties, defaultValue, valueType);}
private T metron_f765_0(Map<String, String> config, Object defaultValue, Class<T> clazz)
{    Object value = config.getOrDefault(key, defaultValue.toString());    return value == null ? null : ConversionUtils.convert(value, clazz);}
private T metron_f766_0(Properties properties, Object defaultValue, Class<T> clazz)
{    Object value = properties.getOrDefault(key, defaultValue);    return value == null ? null : ConversionUtils.convert(value, clazz);}
public String metron_f767_0()
{    return key;}
public static void metron_f768_1(String[] args) throws IOException, org.apache.commons.cli.ParseException, Exception
{        CommandLine commandLine = parseCommandLine(args);        profiles = Preconditions.checkNotNull(handleProfileDefinitions(commandLine), "An error occurred while reading profile data");    profilerProps = handleProfilerProperties(commandLine);    globals = handleGlobals(commandLine);    readerProps = handleReaderProperties(commandLine);        if (!profiles.getTimestampField().isPresent()) {        throw new IllegalArgumentException("The Batch Profiler must use event time. The 'timestampField' must be defined in the profile definitions file or via the --timestampField argument.");    }        if (profiles.getProfiles().size() == 0) {        throw new IllegalArgumentException("No profile definitions found.");    }    SparkSession spark = SparkSession.builder().config(new SparkConf()).getOrCreate();    BatchProfiler profiler = new BatchProfiler();    long count = profiler.run(spark, profilerProps, globals, readerProps, profiles);    }
private static ProfilerConfig metron_f769_1(CommandLine commandLine) throws MissingOptionException, IOException
{    final String PROFILE_LOCATION_ERROR = "A single profile location (--profiles or --zookeeper) must be specified";    ProfilerConfig profiles;    if ((!PROFILE_ZK.has(commandLine)) && (!PROFILE_DEFN_FILE.has(commandLine))) {        throw new MissingOptionException(PROFILE_LOCATION_ERROR);    }    if (PROFILE_ZK.has(commandLine) && PROFILE_DEFN_FILE.has(commandLine)) {        throw new IllegalArgumentException(PROFILE_LOCATION_ERROR);    }    if (PROFILE_ZK.has(commandLine)) {        profiles = handleProfileDefinitionsZK(commandLine);    } else {        profiles = handleProfileDefinitionsFile(commandLine);    }        if (PROFILE_TIMESTAMP_FLD.has(commandLine)) {        final String timestampField = PROFILE_TIMESTAMP_FLD.get(commandLine);        Preconditions.checkArgument(!Strings.isNullOrEmpty(timestampField), "timestampField must be not be empty if specified");        profiles.setTimestampField(timestampField);    }        return profiles;}
private static CuratorFramework metron_f770_1(final String zkQuorum)
{        final CuratorFramework zkClient = ZKCache.createClient(zkQuorum, Optional.empty());    zkClient.start();        return zkClient;}
private static Properties metron_f771_1(CommandLine commandLine) throws IOException
{    Properties globals = new Properties();    if (GLOBALS_FILE.has(commandLine)) {        String globalsPath = GLOBALS_FILE.get(commandLine);                globals.load(new FileInputStream(globalsPath));            }    return globals;}
private static Properties metron_f772_1(CommandLine commandLine) throws IOException
{    Properties config = new Properties();    if (PROFILER_PROPS_FILE.has(commandLine)) {        String propertiesPath = PROFILER_PROPS_FILE.get(commandLine);                config.load(new FileInputStream(propertiesPath));            }    return config;}
private static Properties metron_f773_1(CommandLine commandLine) throws IOException
{    Properties config = new Properties();    if (READER_PROPS_FILE.has(commandLine)) {        String readerPropsPath = READER_PROPS_FILE.get(commandLine);                config.load(new FileInputStream(readerPropsPath));            }    return config;}
private static ProfilerConfig metron_f774_1(CommandLine commandLine) throws IOException
{    ProfilerConfig profiles;    if (PROFILE_DEFN_FILE.has(commandLine)) {        String profilePath = PROFILE_DEFN_FILE.get(commandLine);                String contents = IOUtils.toString(new FileInputStream(profilePath));        profiles = ProfilerConfig.fromJSON(contents);            } else {        throw new IllegalArgumentException("No profile(s) defined");    }    return profiles;}
private static ProfilerConfig metron_f775_0(final CommandLine commandLine) throws IOException
{    Preconditions.checkArgument(PROFILE_ZK.has(commandLine));    ProfilerConfig profiles;    final String zkQuorum = PROFILE_ZK.get(commandLine);    try (final CuratorFramework zkClient = createZKClient(zkQuorum)) {        profiles = readProfileFromZK(zkClient);    }    return profiles;}
 static ProfilerConfig metron_f776_1(CuratorFramework zkClient) throws IOException
{    ProfilerConfig profiles;    try {                profiles = ConfigurationsUtils.readProfilerConfigFromZookeeper(zkClient);            } catch (Exception ex) {        throw new IOException(String.format("Error reading configuration from Zookeeper client %s", zkClient.toString()), ex);    }    return profiles;}
private static CommandLine metron_f777_0(String[] args) throws ParseException
{    CommandLineParser parser = new PosixParser();    return parse(parser, args);}
public static Properties metron_f778_0()
{    return globals;}
public static Properties metron_f779_0()
{    return profilerProps;}
public static ProfilerConfig metron_f780_0()
{    return profiles;}
public static Properties metron_f781_0()
{    return readerProps;}
public boolean metron_f782_0(CommandLine cli)
{    return cli.hasOption(option.getOpt());}
public String metron_f783_0(CommandLine cli)
{    return cli.getOptionValue(option.getOpt());}
public String metron_f784_0(CommandLine cli, String defaultValue)
{    return has(cli) ? cli.getOptionValue(option.getOpt()) : defaultValue;}
public static CommandLine metron_f785_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("invalid arguments: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f786_0()
{    HelpFormatter formatter = new HelpFormatter();    String header = "options:";    String footer = "";    String cmd = String.format("spark-submit --class %s --properties-file [spark.properties] [jar] [options]", BatchProfilerCLI.class.getCanonicalName());    formatter.printHelp(cmd, header, getOptions(), footer);}
public static Options metron_f787_0()
{    Options allOptions = new Options();    for (BatchProfilerCLIOptions o : BatchProfilerCLIOptions.values()) {        allOptions.addOption(o.option);    }    return allOptions;}
public String metron_f788_0(MessageRoute route)
{    ProfilePeriod period = ProfilePeriod.fromTimestamp(route.getTimestamp(), periodDuration, periodDurationUnits);    return new StringBuilder().append(route.getProfileDefinition().getProfile()).append(SEPARATOR).append(route.getEntity()).append(SEPARATOR).append(period.getPeriod()).toString();}
public static String metron_f789_0(String groupKey)
{    String[] pieces = groupKey.split(SEPARATOR);    if (pieces.length == 3) {        return pieces[0];    } else {        return "unknown";    }}
public static String metron_f790_0(String groupKey)
{    String[] pieces = groupKey.split(SEPARATOR);    if (pieces.length == 3) {        return pieces[1];    } else {        return "unknown";    }}
public static String metron_f791_0(String groupKey)
{    String[] pieces = groupKey.split(SEPARATOR);    if (pieces.length == 3) {        return pieces[2];    } else {        return "unknown";    }}
public Iterator<Integer> metron_f792_1(Iterator<ProfileMeasurementAdapter> iterator) throws Exception
{    int count = 0;            List<ProfileMeasurementAdapter> measurements = IteratorUtils.toList(iterator);    if (measurements.size() > 0) {                Configuration config = HBaseConfiguration.create();        try (HBaseClient client = new HBaseClient(tableProvider, config, tableName)) {            for (ProfileMeasurementAdapter adapter : measurements) {                ProfileMeasurement m = adapter.toProfileMeasurement();                client.addMutation(rowKeyBuilder.rowKey(m), columnBuilder.columns(m), durability);            }            count = client.mutate();        } catch (IOException e) {                        throw new RuntimeException(e);        }    }        return IteratorUtils.singletonIterator(count);}
public HBaseWriterFunction metron_f793_0(String providerImpl)
{    this.tableProvider = createTableProvider(providerImpl);    return this;}
private static TableProvider metron_f794_0(String providerImpl)
{    LOG.trace("Creating table provider; className={}", providerImpl);        if (StringUtils.isEmpty(providerImpl) || providerImpl.charAt(0) == '$') {        return new HTableProvider();    }        try {        Class<? extends TableProvider> clazz = (Class<? extends TableProvider>) Class.forName(providerImpl);        return clazz.getConstructor().newInstance();    } catch (InstantiationException | IllegalAccessException | IllegalStateException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) {        throw new IllegalStateException("Unable to instantiate connector", e);    }}
public Iterator<MessageRoute> metron_f795_0(String jsonMessage) throws Exception
{    List<MessageRoute> routes = Collections.emptyList();    JSONParser parser = new JSONParser();    Context context = TaskUtils.getContext(globals);    MessageRouter router = new DefaultMessageRouter(context);        Optional<JSONObject> message = toMessage(jsonMessage, parser);    if (message.isPresent()) {                Optional<Long> timestampOpt = clock.currentTimeMillis(message.get());        if (timestampOpt.isPresent()) {                        Long timestamp = timestampOpt.get();            if (timestamp >= begin && timestamp <= end) {                routes = router.route(message.get(), profilerConfig, context);                LOG.trace("Found {} route(s) for a message", routes.size());            } else {                LOG.trace("Ignoring message; timestamp={} not in [{},{}]", () -> timestamp, () -> prettyPrint(begin), () -> prettyPrint(end));            }        } else {            LOG.trace("No timestamp in message. Message will be ignored.");        }    } else {        LOG.trace("Unable to parse message. Message will be ignored");    }    return routes.iterator();}
public MessageRouterFunction metron_f796_0(Long begin)
{    this.begin = begin;    return this;}
public MessageRouterFunction metron_f797_0(Long end)
{    this.end = end;    return this;}
public MessageRouterFunction metron_f798_0(ClockFactory clockFactory)
{    this.clock = clockFactory.createClock(profilerConfig);    return this;}
private static String metron_f800_0(Long value)
{    String result;    if (value == Long.MIN_VALUE) {        result = "MIN";    } else if (value == Long.MAX_VALUE) {        result = "MAX";    } else {        result = value.toString();    }    return result;}
private static Stream<T> metron_f802_0(Iterator<T> iterator)
{    Iterable<T> iterable = () -> iterator;    return StreamSupport.stream(iterable.spliterator(), false);}
public static Context metron_f803_0(Map<String, String> globals)
{    Context context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> globals).with(Context.Capabilities.STELLAR_CONFIG, () -> globals).build();    StellarFunctions.initialize(context);    return context;}
public ProfileMeasurement metron_f804_0()
{    ProfilePeriod period = ProfilePeriod.fromPeriodId(periodId, durationMillis, TimeUnit.MILLISECONDS);    ProfileMeasurement measurement = new ProfileMeasurement().withProfileName(profileName).withEntity(entity).withPeriod(period).withProfileValue(SerDeUtils.fromBytes(profileValue, Object.class));    return measurement;}
public String metron_f805_0()
{    return profileName;}
public void metron_f806_0(String profileName)
{    this.profileName = profileName;}
public String metron_f807_0()
{    return entity;}
public void metron_f808_0(String entity)
{    this.entity = entity;}
public Long metron_f809_0()
{    return periodId;}
public void metron_f810_0(Long periodId)
{    this.periodId = periodId;}
public Long metron_f811_0()
{    return durationMillis;}
public void metron_f812_0(Long durationMillis)
{    this.durationMillis = durationMillis;}
public byte[] metron_f813_0()
{    return profileValue;}
public void metron_f814_0(byte[] profileValue)
{    this.profileValue = profileValue;}
public void metron_f815_0(Object profileValue)
{    this.profileValue = SerDeUtils.toBytes(profileValue);}
public static TelemetryReader metron_f817_1(String propertyValue)
{        TelemetryReader reader = null;    try {        String key = StringUtils.upperCase(propertyValue);        TelemetryReaders strategy = TelemetryReaders.valueOf(key);        reader = strategy.supplier.get();    } catch (IllegalArgumentException e) {                throw e;    }    return reader;}
public Dataset<String> metron_f818_0(SparkSession spark, Properties profilerProps, Properties readerProps)
{    return supplier.get().read(spark, profilerProps, readerProps);}
public Optional<Long> metron_f820_0(String inputString)
{    Optional<Long> epochMilli = Optional.empty();        if (StringUtils.isNotBlank(inputString)) {        epochMilli = Optional.of(new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_INSTANT).toFormatter().parse(inputString, Instant::from).toEpochMilli());    }    return epochMilli;}
public static void metron_f821_0()
{    SparkConf conf = new SparkConf().setMaster("local").setAppName("BatchProfilerIntegrationTest").set("spark.sql.shuffle.partitions", "8");    spark = SparkSession.builder().config(conf).getOrCreate();}
public static void metron_f822_0()
{    if (spark != null) {        spark.close();    }}
public void metron_f823_0()
{    readerProperties = new Properties();    profilerProperties = new Properties();        String tableName = HBASE_TABLE_NAME.get(profilerProperties, String.class);    String columnFamily = HBASE_COLUMN_FAMILY.get(profilerProperties, String.class);    profilerProperties.put(HBASE_TABLE_PROVIDER.getKey(), MockHBaseTableProvider.class.getName());        MockHBaseTableProvider.addToCache(tableName, columnFamily);        Map<String, Object> global = new HashMap<String, Object>() {        {            put(PROFILER_HBASE_TABLE.getKey(), tableName);            put(PROFILER_COLUMN_FAMILY.getKey(), columnFamily);            put(PROFILER_HBASE_TABLE_PROVIDER.getKey(), MockHBaseTableProvider.class.getName());        }    };        executor = new DefaultStellarStatefulExecutor(new SimpleFunctionResolver().withClass(GetProfile.class).withClass(FixedLookback.class).withClass(WindowLookback.class), new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> global).build());}
public void metron_f824_0() throws Exception
{        profilerProperties.put(TELEMETRY_INPUT_READER.getKey(), JSON.toString());    profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), "src/test/resources/telemetry.json");    BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(profileJson));    validateProfiles();}
public void metron_f825_0() throws Exception
{        String pathToORC = tempFolder.getRoot().getAbsolutePath();    spark.read().format("json").load("src/test/resources/telemetry.json").write().mode("overwrite").format("org.apache.spark.sql.execution.datasources.orc").save(pathToORC);        profilerProperties.put(TELEMETRY_INPUT_READER.getKey(), ORC.toString());    profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), pathToORC);    BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(profileJson));    validateProfiles();}
public void metron_f826_0() throws Exception
{        String inputPath = tempFolder.getRoot().getAbsolutePath();    spark.read().format("json").load("src/test/resources/telemetry.json").write().mode("overwrite").format("parquet").save(inputPath);        profilerProperties.put(TELEMETRY_INPUT_READER.getKey(), PARQUET.toString());    profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), inputPath);    BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(profileJson));    validateProfiles();}
public void metron_f827_0() throws Exception
{        String pathToCSV = tempFolder.getRoot().getAbsolutePath();    spark.read().format("text").load("src/test/resources/telemetry.json").as(Encoders.STRING()).write().mode("overwrite").option("header", "true").format("csv").save(pathToCSV);            profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), pathToCSV);    profilerProperties.put(TELEMETRY_INPUT_READER.getKey(), "text");    profilerProperties.put(TELEMETRY_INPUT_FORMAT.getKey(), "csv");        readerProperties.put("header", "true");    BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(profileJson));    validateProfiles();}
public void metron_f828_0() throws Exception
{        profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), "src/test/resources/telemetry.json");    profilerProperties.put(TELEMETRY_INPUT_FORMAT.getKey(), "text");        profilerProperties.put(TELEMETRY_INPUT_BEGIN.getKey(), "");    profilerProperties.put(TELEMETRY_INPUT_END.getKey(), "2018-07-07T15:51:48Z");    BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(profileJson));        assign("maxTimestamp", "1530978728982L");        assign("window", "PROFILE_WINDOW('from 5 hours ago', maxTimestamp)");    assertTrue(execute("[12] == PROFILE_GET('count-by-ip', '192.168.66.1', window)", Boolean.class));    assertTrue(execute("[28] == PROFILE_GET('count-by-ip', '192.168.138.158', window)", Boolean.class));    assertTrue(execute("[40] == PROFILE_GET('total-count', 'total', window)", Boolean.class));}
public void metron_f829_0() throws Exception
{        profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), "src/test/resources/telemetry.json");    profilerProperties.put(TELEMETRY_INPUT_FORMAT.getKey(), "text");        profilerProperties.put(TELEMETRY_INPUT_BEGIN.getKey(), "2018-07-07T15:51:48Z");    profilerProperties.put(TELEMETRY_INPUT_END.getKey(), "");    BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(profileJson));        assign("maxTimestamp", "1530978728982L");        assign("window", "PROFILE_WINDOW('from 5 hours ago', maxTimestamp)");    assertTrue(execute("[14] == PROFILE_GET('count-by-ip', '192.168.66.1', window)", Boolean.class));    assertTrue(execute("[46] == PROFILE_GET('count-by-ip', '192.168.138.158', window)", Boolean.class));    assertTrue(execute("[60] == PROFILE_GET('total-count', 'total', window)", Boolean.class));}
public void metron_f830_0() throws Exception
{    profilerProperties.put(TELEMETRY_INPUT_READER.getKey(), JSON.toString());    profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), "src/test/resources/telemetry.json");        BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(invalidProfileJson));}
public void metron_f831_0() throws Exception
{    profilerProperties.put(TELEMETRY_INPUT_READER.getKey(), JSON.toString());    profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), "src/test/resources/telemetry.json");    BatchProfiler profiler = new BatchProfiler();    profiler.run(spark, profilerProperties, getGlobals(), readerProperties, fromJSON(statsProfileJson));        validateProfiles();}
private void metron_f832_0()
{        assign("maxTimestamp", "1530978728982L");        assign("window", "PROFILE_WINDOW('from 5 hours ago', maxTimestamp)");        assertTrue(execute("[26] == PROFILE_GET('count-by-ip', '192.168.66.1', window)", Boolean.class));        assertTrue(execute("[74] == PROFILE_GET('count-by-ip', '192.168.138.158', window)", Boolean.class));        assertTrue(execute("[100] == PROFILE_GET('total-count', 'total', window)", Boolean.class));}
private Properties metron_f833_0()
{    return new Properties();}
private void metron_f834_0(String var, String expression)
{    executor.assign(var, expression, Collections.emptyMap());}
private T metron_f835_1(String expression, Class<T> clazz)
{    T results = executor.execute(expression, Collections.emptyMap(), clazz);        return results;}
public void metron_f836_0() throws Exception
{    String[] args = new String[] { "--profiles", "src/test/resources/profiles-no-timestamp-field.json" };    BatchProfilerCLI.main(args);}
public void metron_f837_0() throws Exception
{    String[] args = new String[] {};    BatchProfilerCLI.main(args);}
public void metron_f838_0() throws Exception
{    String[] args = new String[] { "--profiles", "src/test/resources/profiles-no-timestamp-field.json", "--zookeeper", "node1:2181" };    BatchProfilerCLI.main(args);}
public void metron_f839_0() throws Exception
{    String[] args = new String[] { "--timestampfield" };    BatchProfilerCLI.main(args);}
public void metron_f840_0() throws Exception
{    String[] args = new String[] { "--profiles", "src/test/resources/profiles-empty.json" };    BatchProfilerCLI.main(args);}
public void metron_f841_0() throws Exception
{    final byte[] profileExpectedByte = profile.getBytes(StandardCharsets.UTF_8);    final ProfilerConfig expectedProfileConfig = ProfilerConfig.fromBytes(profileExpectedByte);    TestZKServer.runWithZK((zkServer, zkClient) -> {                ConfigurationsUtils.writeProfilerConfigToZookeeper(profileExpectedByte, zkClient);                final ProfilerConfig profiles = BatchProfilerCLI.readProfileFromZK(zkClient);                Assert.assertEquals("Profile read from zookeeper has changes", expectedProfileConfig, profiles);    });}
public void metron_f842_0() throws Exception
{    final byte[] profileExpectedByte = profile.getBytes(StandardCharsets.UTF_8);    final ProfilerConfig expectedProfileConfig = ProfilerConfig.fromBytes(profileExpectedByte);    expectedProfileConfig.setTimestampField("foobar");    TestZKServer.runWithZK((zkServer, zkClient) -> {                ConfigurationsUtils.writeProfilerConfigToZookeeper(profileExpectedByte, zkClient);                final ProfilerConfig profiles = BatchProfilerCLI.readProfileFromZK(zkClient);                Assert.assertNotEquals("Profile zookeeper integration test fails to detect change", expectedProfileConfig, profiles);    });}
public void metron_f843_0() throws Exception
{    final ProfileConfig profile = ProfileConfig.fromJSON(profileJSON);    final Long timestamp = System.currentTimeMillis();    final String entity = "192.168.1.1";    final JSONObject message = new JSONObject();    final String periodId = new Long(ProfilePeriod.fromTimestamp(timestamp, 15, TimeUnit.MINUTES).getPeriod()).toString();    MessageRoute route = new MessageRoute(profile, entity, message, timestamp);    String groupKey = new GroupByPeriodFunction(new Properties()).call(route);        Assert.assertEquals("my-profile-name", GroupByPeriodFunction.profileFromKey(groupKey));    Assert.assertEquals(entity, GroupByPeriodFunction.entityFromKey(groupKey));    Assert.assertEquals(periodId, GroupByPeriodFunction.periodFromKey(groupKey));}
public void metron_f844_0()
{    profilerProperties = getProfilerProperties();        String tableName = HBASE_TABLE_NAME.get(profilerProperties, String.class);    String columnFamily = HBASE_COLUMN_FAMILY.get(profilerProperties, String.class);    MockHBaseTableProvider.addToCache(tableName, columnFamily);}
public void metron_f845_0() throws Exception
{    JSONObject message = getMessage();    String entity = (String) message.get("ip_src_addr");    long timestamp = (Long) message.get("timestamp");    ProfileConfig profile = getProfile();        List<ProfileMeasurementAdapter> measurements = createMeasurements(1, entity, timestamp, profile);        HBaseWriterFunction function = new HBaseWriterFunction(profilerProperties);    function.withTableProviderImpl(MockHBaseTableProvider.class.getName());        Iterator<Integer> results = function.call(measurements.iterator());        List<Integer> counts = IteratorUtils.toList(results);    Assert.assertEquals(1, counts.size());    Assert.assertEquals(1, counts.get(0).intValue());}
public void metron_f846_0() throws Exception
{    JSONObject message = getMessage();    String entity = (String) message.get("ip_src_addr");    long timestamp = (Long) message.get("timestamp");    ProfileConfig profile = getProfile();        List<ProfileMeasurementAdapter> measurements = createMeasurements(10, entity, timestamp, profile);        HBaseWriterFunction function = new HBaseWriterFunction(profilerProperties);    function.withTableProviderImpl(MockHBaseTableProvider.class.getName());        Iterator<Integer> results = function.call(measurements.iterator());        List<Integer> counts = IteratorUtils.toList(results);    Assert.assertEquals(1, counts.size());    Assert.assertEquals(10, counts.get(0).intValue());}
public void metron_f847_0() throws Exception
{        List<ProfileMeasurementAdapter> measurements = new ArrayList<>();        HBaseWriterFunction function = new HBaseWriterFunction(profilerProperties);    function.withTableProviderImpl(MockHBaseTableProvider.class.getName());        Iterator<Integer> results = function.call(measurements.iterator());        List<Integer> counts = IteratorUtils.toList(results);    Assert.assertEquals(1, counts.size());    Assert.assertEquals(0, counts.get(0).intValue());}
private List<ProfileMeasurementAdapter> metron_f848_0(int count, String entity, long timestamp, ProfileConfig profile)
{    List<ProfileMeasurementAdapter> measurements = new ArrayList<>();    for (int i = 0; i < count; i++) {        ProfileMeasurement measurement = new ProfileMeasurement().withProfileName(profile.getProfile()).withEntity(entity).withPeriod(timestamp, 15, TimeUnit.MINUTES);                measurements.add(new ProfileMeasurementAdapter(measurement));    }    return measurements;}
private JSONObject metron_f849_0()
{    JSONObject message = new JSONObject();    message.put("ip_src_addr", "192.168.1.1");    message.put("status", "red");    message.put("timestamp", System.currentTimeMillis());    return message;}
private Properties metron_f850_0()
{    return new Properties();}
private ProfileConfig metron_f851_0()
{    return new ProfileConfig().withProfile("profile1").withForeach("ip_src_addr").withUpdate("count", "count + 1").withResult("count");}
public void metron_f852_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals());    Iterator<MessageRoute> iter = function.call(goodMessage);    List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(1, routes.size());    Assert.assertEquals("profile1", routes.get(0).getProfileDefinition().getProfile());}
public void metron_f853_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profileWithSystemTime(), getGlobals());    Iterator<MessageRoute> iter = function.call(goodMessage);    Assert.fail("Exception expected as system time is not supported.");}
public void metron_f854_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals());    Iterator<MessageRoute> iter = function.call(badMessage);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(0, routes.size());}
public void metron_f855_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(twoProfiles(), getGlobals());    Iterator<MessageRoute> iter = function.call(goodMessage);    List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(2, routes.size());    Assert.assertEquals("profile1", routes.get(0).getProfileDefinition().getProfile());    Assert.assertEquals("profile2", routes.get(1).getProfileDefinition().getProfile());}
public void metron_f856_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals());    Iterator<MessageRoute> iter = function.call(messageNoTimestamp);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(0, routes.size());}
public void metron_f857_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals()).withBegin(messageTimestamp + 1000);    Iterator<MessageRoute> iter = function.call(goodMessage);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(0, routes.size());}
public void metron_f858_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals()).withBegin(messageTimestamp - 1000);    Iterator<MessageRoute> iter = function.call(goodMessage);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(1, routes.size());}
public void metron_f859_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals()).withEnd(messageTimestamp - 1000);    Iterator<MessageRoute> iter = function.call(goodMessage);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(0, routes.size());}
public void metron_f860_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals()).withEnd(messageTimestamp + 1000);    Iterator<MessageRoute> iter = function.call(goodMessage);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(1, routes.size());}
public void metron_f861_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals()).withBegin(messageTimestamp + 1000).withEnd(messageTimestamp + 2000);    Iterator<MessageRoute> iter = function.call(goodMessage);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(0, routes.size());}
public void metron_f862_0() throws Exception
{    MessageRouterFunction function = new MessageRouterFunction(profile(), getGlobals()).withBegin(messageTimestamp - 1000).withEnd(messageTimestamp + 1000);    Iterator<MessageRoute> iter = function.call(goodMessage);        List<MessageRoute> routes = Lists.newArrayList(iter);    Assert.assertEquals(1, routes.size());}
private ProfilerConfig metron_f863_0()
{    ProfileConfig profile = new ProfileConfig().withProfile("profile1").withForeach("ip_src_addr").withUpdate("count", "count + 1").withResult("count");    return new ProfilerConfig().withProfile(profile).withTimestampField(Optional.of("timestamp"));}
private ProfilerConfig metron_f864_0()
{    ProfileConfig profile1 = new ProfileConfig().withProfile("profile1").withForeach("ip_src_addr").withUpdate("count", "count + 1").withResult("count");    ProfileConfig profile2 = new ProfileConfig().withProfile("profile2").withForeach("ip_src_addr").withUpdate("count", "count + 1").withResult("count");    return new ProfilerConfig().withProfile(profile1).withProfile(profile2).withTimestampField(Optional.of("timestamp"));}
private ProfilerConfig metron_f865_0()
{    ProfileConfig profile = new ProfileConfig().withProfile("profile1").withForeach("ip_src_addr").withUpdate("count", "count + 1").withResult("count");    return new ProfilerConfig().withProfile(profile);}
private Map<String, String> metron_f866_0()
{    return Collections.emptyMap();}
public void metron_f867_0() throws Exception
{        JSONObject message = getMessage();    String entity = "192.168.1.1";    long timestamp = (Long) message.get("timestamp");    ProfileConfig profile = ProfileConfig.fromJSON(profileJSON);        MessageRoute route = new MessageRoute(profile, entity, message, timestamp);    List<MessageRoute> routes = new ArrayList();    routes.add(route);    routes.add(route);    routes.add(route);    Properties profilerProperties = getProfilerProperties();        int periodDuration = PERIOD_DURATION.get(profilerProperties, Integer.class);    TimeUnit periodDurationUnits = TimeUnit.valueOf(PERIOD_DURATION_UNITS.get(profilerProperties, String.class));    ProfilePeriod expectedPeriod = ProfilePeriod.fromTimestamp(timestamp, periodDuration, periodDurationUnits);        ProfileBuilderFunction function = new ProfileBuilderFunction(profilerProperties, getGlobals());    ProfileMeasurementAdapter measurement = function.call("profile1-192.168.1.1-0", routes.iterator());        Assert.assertEquals(entity, measurement.getEntity());    Assert.assertEquals(profile.getProfile(), measurement.getProfileName());    Assert.assertEquals(routes.size(), measurement.toProfileMeasurement().getProfileValue());    Assert.assertEquals(expectedPeriod.getPeriod(), (long) measurement.getPeriodId());}
public void metron_f868_0() throws Exception
{        JSONObject message = getMessage();    String entity = "192.168.1.1";    long timestamp = (Long) message.get("timestamp");    ProfileConfig profile = ProfileConfig.fromJSON(invalidProfileJson);        MessageRoute route = new MessageRoute(profile, entity, message, timestamp);    List<MessageRoute> routes = new ArrayList();    routes.add(route);    routes.add(route);    routes.add(route);    Properties profilerProperties = getProfilerProperties();        ProfileBuilderFunction function = new ProfileBuilderFunction(profilerProperties, getGlobals());    ProfileMeasurementAdapter measurement = function.call("profile1-192.168.1.1-0", routes.iterator());}
private JSONObject metron_f869_0()
{    JSONObject message = new JSONObject();    message.put("ip_src_addr", "192.168.1.1");    message.put("status", "red");    message.put("timestamp", System.currentTimeMillis());    return message;}
private Properties metron_f870_0()
{    return new Properties();}
private Map<String, String> metron_f871_0()
{    return Collections.emptyMap();}
public static void metron_f872_0()
{    SparkConf conf = new SparkConf().setMaster("local").setAppName("BatchProfilerIntegrationTest").set("spark.sql.shuffle.partitions", "8");    spark = SparkSession.builder().config(conf).getOrCreate();}
public static void metron_f873_0()
{    if (spark != null) {        spark.close();    }}
public void metron_f874_0()
{    readerProperties = new Properties();    profilerProperties = new Properties();}
public void metron_f875_0()
{        String inputPath = tempFolder.getRoot().getAbsolutePath();    spark.read().format("json").load("src/test/resources/telemetry.json").write().mode("overwrite").format("parquet").save(inputPath);        profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), inputPath);    profilerProperties.put(TELEMETRY_INPUT_FORMAT.getKey(), "parquet");        readerProperties.put("header", "true");        Dataset<String> telemetry = TelemetryReaders.COLUMNAR.read(spark, profilerProperties, readerProperties);    Assert.assertEquals(100, telemetry.filter(new IsValidJSON()).count());}
public void metron_f876_0()
{        String pathToORC = tempFolder.getRoot().getAbsolutePath();    spark.read().format("json").load("src/test/resources/telemetry.json").write().mode("overwrite").format("org.apache.spark.sql.execution.datasources.orc").save(pathToORC);        profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), pathToORC);    profilerProperties.put(TELEMETRY_INPUT_FORMAT.getKey(), "org.apache.spark.sql.execution.datasources.orc");        Dataset<String> telemetry = TelemetryReaders.COLUMNAR.read(spark, profilerProperties, readerProperties);    Assert.assertEquals(100, telemetry.filter(new IsValidJSON()).count());}
public boolean metron_f877_0(String text) throws Exception
{    JSONParser parser = new JSONParser();    JSONObject json = (JSONObject) parser.parse(text);        return json.keySet().size() >= 32;}
public void metron_f878_0()
{    String key = JSON.toString();    Assert.assertTrue(TelemetryReaders.create(key) instanceof TextEncodedTelemetryReader);}
public void metron_f879_0()
{    String key = JSON.toString().toLowerCase();    Assert.assertTrue(TelemetryReaders.create(key) instanceof TextEncodedTelemetryReader);}
public void metron_f880_0()
{    String key = ORC.toString();    Assert.assertTrue(TelemetryReaders.create(key) instanceof ColumnEncodedTelemetryReader);}
public void metron_f881_0()
{    String key = ORC.toString().toLowerCase();    Assert.assertTrue(TelemetryReaders.create(key) instanceof ColumnEncodedTelemetryReader);}
public void metron_f882_0()
{    String key = PARQUET.toString();    Assert.assertTrue(TelemetryReaders.create(key) instanceof ColumnEncodedTelemetryReader);}
public void metron_f883_0()
{    String key = PARQUET.toString().toLowerCase();    Assert.assertTrue(TelemetryReaders.create(key) instanceof ColumnEncodedTelemetryReader);}
public void metron_f884_0()
{    String key = TEXT.toString();    Assert.assertTrue(TelemetryReaders.create(key) instanceof TextEncodedTelemetryReader);}
public void metron_f885_0()
{    String key = COLUMNAR.toString();    Assert.assertTrue(TelemetryReaders.create(key) instanceof ColumnEncodedTelemetryReader);}
public void metron_f886_0()
{    TelemetryReaders.create("invalid");    Assert.fail("exception expected");}
public static void metron_f887_0()
{    SparkConf conf = new SparkConf().setMaster("local").setAppName("BatchProfilerIntegrationTest").set("spark.sql.shuffle.partitions", "8");    spark = SparkSession.builder().config(conf).getOrCreate();}
public static void metron_f888_0()
{    if (spark != null) {        spark.close();    }}
public void metron_f889_0()
{    readerProperties = new Properties();    profilerProperties = new Properties();}
public void metron_f890_0()
{        String pathToCSV = tempFolder.getRoot().getAbsolutePath();    spark.read().format("text").load("src/test/resources/telemetry.json").as(Encoders.STRING()).write().mode("overwrite").option("header", "true").format("csv").save(pathToCSV);        profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), pathToCSV);    profilerProperties.put(TELEMETRY_INPUT_FORMAT.getKey(), "csv");        readerProperties.put("header", "true");        Dataset<String> telemetry = TelemetryReaders.TEXT.read(spark, profilerProperties, readerProperties);    Assert.assertEquals(100, telemetry.filter(new IsValidJSON()).count());}
public void metron_f891_0()
{        profilerProperties.put(TELEMETRY_INPUT_PATH.getKey(), "src/test/resources/telemetry.json");    profilerProperties.put(TELEMETRY_INPUT_FORMAT.getKey(), "text");        readerProperties.put("header", "true");        Dataset<String> telemetry = TelemetryReaders.TEXT.read(spark, profilerProperties, readerProperties);    Assert.assertEquals(100, telemetry.filter(new IsValidJSON()).count());}
public void metron_f892_0()
{    parser = new TimestampParser();}
public void metron_f893_0()
{    Optional<Long> millis = parser.parse("");    assertFalse(millis.isPresent());}
public void metron_f894_0()
{    Optional<Long> millis = parser.parse("      ");    assertFalse(millis.isPresent());}
public void metron_f895_0()
{        Optional<Long> millis = parser.parse("2011-12-03T10:15:30Z");    assertTrue(millis.isPresent());    assertEquals(1322907330000L, millis.get().longValue());}
public void metron_f896_0()
{    parser.parse("1537502400000");    fail("Expected exception");}
public void metron_f897_0(Exception e)
{    collector.reportError(e);    for (Tuple t : tupleBatch) {        collector.fail(t);    }    tupleBatch.clear();    forceFlush = false;}
public void metron_f898_0()
{    for (Tuple t : tupleBatch) {        collector.ack(t);    }    tupleBatch.clear();    forceFlush = false;}
public boolean metron_f899_1(Tuple tuple)
{    if (isTick(tuple)) {                forceFlush = true;        return false;    } else {        return true;    }}
public void metron_f900_0(Tuple tuple)
{    tupleBatch.add(tuple);    if (tupleBatch.size() >= batchSize) {        forceFlush = true;    }}
public List<Tuple> metron_f901_0()
{    return this.tupleBatch;}
public int metron_f902_0()
{    return this.batchSize;}
public boolean metron_f903_0()
{    return forceFlush && !tupleBatch.isEmpty();}
public boolean metron_f904_0(Tuple tuple)
{    return tuple != null && Constants.SYSTEM_COMPONENT_ID.equals(tuple.getSourceComponent()) && Constants.SYSTEM_TICK_STREAM_ID.equals(tuple.getSourceStreamId());}
public HBaseBolt metron_f905_0(boolean writeToWAL)
{    this.writeToWAL = writeToWAL;    return this;}
public HBaseBolt metron_f906_0(String tableProvider)
{    this.tableProviderClazzName = tableProvider;    return this;}
public HBaseBolt metron_f907_0(TableProvider tableProvider)
{    this.tableProvider = tableProvider;    return this;}
public HBaseBolt metron_f908_0(int batchSize)
{    this.batchSize = batchSize;    return this;}
public HBaseBolt metron_f909_0(int flushIntervalSecs)
{    this.flushIntervalSecs = flushIntervalSecs;    return this;}
public void metron_f910_0(HBaseClient hbaseClient)
{    this.hbaseClient = hbaseClient;}
public Map<String, Object> metron_f911_1()
{        Config conf = new Config();    conf.put(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, flushIntervalSecs);    return conf;}
public void metron_f912_0(Map map, TopologyContext topologyContext, OutputCollector collector)
{    this.collector = collector;    this.batchHelper = new BatchHelper(batchSize, collector);    TableProvider provider;    if (this.tableProvider == null) {        provider = createTableProvider(tableProviderClazzName);    } else {        provider = this.tableProvider;    }    hbaseClient = new HBaseClient(provider, HBaseConfiguration.create(), tableName);}
public void metron_f913_0(OutputFieldsDeclarer outputFieldsDeclarer)
{}
public void metron_f914_0(Tuple tuple)
{    LOG.trace("Received a tuple.");    try {        if (batchHelper.shouldHandle(tuple)) {            save(tuple);        }        if (batchHelper.shouldFlush()) {            flush();        }    } catch (Exception e) {        batchHelper.fail(e);        hbaseClient.clearMutations();    }}
private void metron_f916_1()
{        this.hbaseClient.mutate();    batchHelper.ack();}
private static TableProvider metron_f917_0(String connectorImpl)
{    LOG.trace("Creating table provider; className={}", connectorImpl);        if (StringUtils.isEmpty(connectorImpl) || connectorImpl.charAt(0) == '$') {        return new HTableProvider();    }        try {        Class<? extends TableProvider> clazz = (Class<? extends TableProvider>) Class.forName(connectorImpl);        return clazz.getConstructor().newInstance();    } catch (InstantiationException | IllegalAccessException | IllegalStateException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) {        throw new IllegalStateException("Unable to instantiate connector", e);    }}
public void metron_f918_1()
{    minTime = Long.MAX_VALUE;    maxTime = Long.MIN_VALUE;    }
public void metron_f919_0(long timestamp)
{    if (LOG.isWarnEnabled()) {        checkIfOutOfOrder(timestamp);    }    if (timestamp < minTime) {        minTime = timestamp;    }    if (timestamp > maxTime) {        maxTime = timestamp;    }}
private void metron_f920_1(long timestamp)
{        if (maxTime > Long.MIN_VALUE) {        long outOfOrderBy = maxTime - timestamp;        if (Math.abs(outOfOrderBy) > flushFrequency) {                    }    }}
public long metron_f922_0()
{    return maxTime;}
public void metron_f923_0(OutputFieldsDeclarer declarer)
{    declarer.declareStream(getStreamId(), new Fields("measurement"));}
public String metron_f925_0()
{    return streamId;}
public void metron_f926_0(String streamId)
{    this.streamId = streamId;}
public void metron_f927_0(OutputFieldsDeclarer declarer)
{        declarer.declareStream(getStreamId(), new Fields("message"));}
private JSONObject metron_f930_0(ProfileMeasurement measurement)
{    JSONObject message = new JSONObject();    message.put(PROFILE_FIELD, measurement.getDefinition().getProfile());    message.put(ENTITY_FIELD, measurement.getEntity());    message.put(PERIOD_ID_FIELD, measurement.getPeriod().getPeriod());    message.put(PERIOD_START_FIELD, measurement.getPeriod().getStartTimeMillis());    message.put(PERIOD_END_FIELD, measurement.getPeriod().getEndTimeMillis());    message.put(TIMESTAMP_FIELD, System.currentTimeMillis());    message.put(Constants.SENSOR_TYPE, sourceType);    message.put(ALERT_FIELD, "true");    message.put(Constants.GUID, UUID.randomUUID().toString());    return message;}
private boolean metron_f931_0(Object value)
{    return value != null && (value instanceof String || ClassUtils.isPrimitiveOrWrapper(value.getClass()));}
public String metron_f932_0()
{    return streamId;}
public void metron_f933_0(String streamId)
{    this.streamId = streamId;}
public String metron_f934_0()
{    return sourceType;}
public void metron_f935_0(String sourceType)
{    this.sourceType = sourceType;}
public void metron_f936_0(boolean flushNow)
{    this.flushNow = flushNow;}
public boolean metron_f937_0()
{    return flushNow;}
public void metron_f938_0(long timestamp)
{}
public void metron_f939_0()
{}
public long metron_f940_0()
{        return 0;}
public void metron_f941_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    super.prepare(stormConf, context, collector);    if (periodDurationMillis <= 0) {        throw new IllegalArgumentException("expect 'profiler.period.duration' >= 0");    }    if (profileTimeToLiveMillis <= 0) {        throw new IllegalArgumentException("expect 'profiler.ttl' >= 0");    }    if (profileTimeToLiveMillis < periodDurationMillis) {        throw new IllegalArgumentException("expect 'profiler.ttl' >= 'profiler.period.duration'");    }    if (maxNumberOfRoutes <= 0) {        throw new IllegalArgumentException("expect 'profiler.max.routes.per.bolt' > 0");    }    if (windowDurationMillis <= 0) {        throw new IllegalArgumentException("expect 'profiler.window.duration' > 0");    }    if (windowDurationMillis > periodDurationMillis) {        throw new IllegalArgumentException("expect 'profiler.period.duration' >= 'profiler.window.duration'");    }    if (periodDurationMillis % windowDurationMillis != 0) {        throw new IllegalArgumentException("expect 'profiler.period.duration' % 'profiler.window.duration' == 0");    }    this.collector = collector;    this.parser = new JSONParser();    this.messageDistributor = new DefaultMessageDistributor(periodDurationMillis, profileTimeToLiveMillis, maxNumberOfRoutes);    this.configurations = new ProfilerConfigurations();    this.activeFlushSignal = new FixedFrequencyFlushSignal(periodDurationMillis);    setupZookeeper();    startFlushingExpiredProfiles();}
public void metron_f942_1()
{    try {        zookeeperCache.close();        zookeeperClient.close();        flushExpiredExecutor.shutdown();    } catch (Throwable e) {            }}
private void metron_f943_1()
{    try {        if (zookeeperClient == null) {            RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);            zookeeperClient = CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy);        }        zookeeperClient.start();                        ConfigurationsUtils.setupStellarStatically(zookeeperClient);        if (zookeeperCache == null) {            ConfigurationsUpdater<ProfilerConfigurations> updater = createUpdater();            SimpleEventListener listener = new SimpleEventListener.Builder().with(updater::update, TreeCacheEvent.Type.NODE_ADDED, TreeCacheEvent.Type.NODE_UPDATED).with(updater::delete, TreeCacheEvent.Type.NODE_REMOVED).build();            zookeeperCache = new ZKCache.Builder().withClient(zookeeperClient).withListener(listener).withRoot(Constants.ZOOKEEPER_TOPOLOGY_ROOT).build();            updater.forceUpdate(zookeeperClient);            zookeeperCache.start();        }    } catch (Exception e) {                throw new RuntimeException(e);    }}
protected ConfigurationsUpdater<ProfilerConfigurations> metron_f944_0()
{    return new ProfilerUpdater(this, this::getConfigurations);}
public ProfilerConfigurations metron_f945_0()
{    return configurations;}
public void metron_f946_0(String name, ConfigurationType type)
{}
public void metron_f947_0(OutputFieldsDeclarer declarer)
{    if (emitters.size() == 0) {        throw new IllegalStateException("At least one destination handler must be defined.");    }        emitters.forEach(emitter -> emitter.declareOutputFields(declarer));}
private Context metron_f948_0()
{    Map<String, Object> global = getConfigurations().getGlobalConfig();    return new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> zookeeperClient).with(Context.Capabilities.GLOBAL_CONFIG, () -> global).with(Context.Capabilities.STELLAR_CONFIG, () -> global).build();}
public void metron_f950_1(TupleWindow window)
{    if (LOG.isDebugEnabled()) {        log(window);    }    try {                for (Tuple tuple : window.get()) {            handleMessage(tuple);        }                if (activeFlushSignal.isTimeToFlush()) {            flushActive();        }    } catch (Throwable e) {                collector.reportError(e);    }}
protected void metron_f951_1()
{    activeFlushSignal.reset();        List<ProfileMeasurement> measurements;    synchronized (messageDistributor) {        measurements = messageDistributor.flush();        emitMeasurements(measurements);    }    }
protected void metron_f952_1()
{    List<ProfileMeasurement> measurements = null;    try {                synchronized (messageDistributor) {            measurements = messageDistributor.flushExpired();            emitMeasurements(measurements);        }    } catch (Throwable t) {                            }    }
private void metron_f953_1(Tuple input)
{        JSONObject message = getField(MESSAGE_TUPLE_FIELD, input, JSONObject.class);    ProfileConfig definition = getField(PROFILE_TUPLE_FIELD, input, ProfileConfig.class);    String entity = getField(ENTITY_TUPLE_FIELD, input, String.class);    Long timestamp = getField(TIMESTAMP_TUPLE_FIELD, input, Long.class);        activeFlushSignal.update(timestamp);        MessageRoute route = new MessageRoute(definition, entity, message, timestamp);    synchronized (messageDistributor) {        messageDistributor.distribute(route, getStellarContext());    }    }
private T metron_f955_0(String fieldName, Tuple tuple, Class<T> clazz)
{    T value = ConversionUtils.convert(tuple.getValueByField(fieldName), clazz);    if (value == null) {        throw new IllegalStateException(format("Invalid tuple: missing or invalid field '%s'", fieldName));    }    return value;}
private void metron_f956_0()
{    long initialDelay = profileTimeToLiveMillis;    long period = profileTimeToLiveMillis;    flushExpiredExecutor = Executors.newSingleThreadScheduledExecutor();    flushExpiredExecutor.scheduleAtFixedRate(() -> flushExpired(), initialDelay, period, TimeUnit.MILLISECONDS);}
public BaseWindowedBolt metron_f957_0(BaseWindowedBolt.Duration duration)
{        this.windowDurationMillis = duration.value;    return super.withTumblingWindow(duration);}
public long metron_f958_0()
{    return periodDurationMillis;}
public ProfileBuilderBolt metron_f959_0(long periodDurationMillis)
{    this.periodDurationMillis = periodDurationMillis;    return this;}
public ProfileBuilderBolt metron_f960_0(int duration, TimeUnit units)
{    return withPeriodDurationMillis(units.toMillis(duration));}
public ProfileBuilderBolt metron_f961_0(long timeToLiveMillis)
{    this.profileTimeToLiveMillis = timeToLiveMillis;    return this;}
public long metron_f962_0()
{    return windowDurationMillis;}
public ProfileBuilderBolt metron_f963_0(int duration, TimeUnit units)
{    return withProfileTimeToLiveMillis(units.toMillis(duration));}
public ProfileBuilderBolt metron_f964_0(ProfileMeasurementEmitter emitter)
{    this.emitters.add(emitter);    return this;}
public MessageDistributor metron_f965_0()
{    return messageDistributor;}
public ProfileBuilderBolt metron_f966_0(String zookeeperUrl)
{    this.zookeeperUrl = zookeeperUrl;    return this;}
public ProfileBuilderBolt metron_f967_0(CuratorFramework zookeeperClient)
{    this.zookeeperClient = zookeeperClient;    return this;}
public ProfileBuilderBolt metron_f968_0(ZKCache zookeeperCache)
{    this.zookeeperCache = zookeeperCache;    return this;}
public ProfileBuilderBolt metron_f969_0(ProfilerConfigurations configurations)
{    this.configurations = configurations;    return this;}
public ProfileBuilderBolt metron_f970_0(long maxNumberOfRoutes)
{    this.maxNumberOfRoutes = maxNumberOfRoutes;    return this;}
public ProfileBuilderBolt metron_f971_0(FlushSignal flushSignal)
{    this.activeFlushSignal = flushSignal;    return this;}
public ProfileBuilderBolt metron_f972_0(MessageDistributor messageDistributor)
{    this.messageDistributor = messageDistributor;    return this;}
public byte[] metron_f973_0(Tuple tuple)
{    ProfileMeasurement measurement = (ProfileMeasurement) tuple.getValueByField("measurement");    return rowKeyBuilder.rowKey(measurement);}
public ColumnList metron_f974_0(Tuple tuple)
{    ProfileMeasurement measurement = (ProfileMeasurement) tuple.getValueByField("measurement");    return columnBuilder.columns(measurement);}
public Optional<Long> metron_f975_0(Tuple tuple)
{    Optional<Long> expiresMillis = Optional.empty();    ProfileMeasurement measurement = (ProfileMeasurement) tuple.getValueByField("measurement");    ProfileConfig profileConfig = measurement.getDefinition();    if (profileConfig.getExpires() != null) {                long expiresDays = profileConfig.getExpires();        expiresMillis = Optional.of(TimeUnit.DAYS.toMillis(expiresDays));    }    return expiresMillis;}
public void metron_f976_0(RowKeyBuilder rowKeyBuilder)
{    this.rowKeyBuilder = rowKeyBuilder;}
public void metron_f977_0(ColumnBuilder columnBuilder)
{    this.columnBuilder = columnBuilder;}
public void metron_f978_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    super.prepare(stormConf, context, collector);    this.collector = collector;    this.parser = new JSONParser();    this.router = new DefaultMessageRouter(getStellarContext());}
public Context metron_f979_0()
{    Map<String, Object> global = getConfigurations().getGlobalConfig();    return new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).with(Context.Capabilities.GLOBAL_CONFIG, () -> global).with(Context.Capabilities.STELLAR_CONFIG, () -> global).build();}
private void metron_f981_1(Tuple input) throws ParseException, UnsupportedEncodingException
{        byte[] data = input.getBinaryByField(VALUE.getFieldName());    if (data == null) {                return;    }        ProfilerConfig config = getProfilerConfig();    if (config == null || getProfilerConfig().getProfiles().size() == 0) {                return;    }    JSONObject message = (JSONObject) parser.parse(new String(data, StandardCharsets.UTF_8));    routeMessage(input, message, config);}
public void metron_f983_0(OutputFieldsDeclarer declarer)
{        Fields fields = new Fields(MESSAGE_TUPLE_FIELD, TIMESTAMP_TUPLE_FIELD, ENTITY_TUPLE_FIELD, PROFILE_TUPLE_FIELD);    declarer.declare(fields);}
private Values metron_f984_0(MessageRoute route)
{        return new Values(route.getMessage(), route.getTimestamp(), route.getEntity(), route.getProfileDefinition());}
protected MessageRouter metron_f985_0()
{    return router;}
public void metron_f986_0(MessageRouter router)
{    this.router = router;}
public void metron_f987_0() throws Exception
{        widget1 = new Widget("widget1", 100);    when(tuple1.getValueByField(eq("widget"))).thenReturn(widget1);        widget2 = new Widget("widget2", 200);    when(tuple2.getValueByField(eq("widget"))).thenReturn(widget2);}
public void metron_f988_0() throws Exception
{    tuple1 = mock(Tuple.class);    tuple2 = mock(Tuple.class);    client = mock(HBaseClient.class);    provider = mock(TableProvider.class);}
private HBaseBolt metron_f989_0(int batchSize, WidgetMapper mapper) throws IOException
{    HBaseBolt bolt = new HBaseBolt(tableName, mapper).withBatchSize(batchSize).withTableProviderInstance(provider);    bolt.prepare(Collections.emptyMap(), topologyContext, outputCollector);    bolt.setClient(client);    return bolt;}
public void metron_f990_0() throws Exception
{    HBaseBolt bolt = createBolt(2, new WidgetMapper());    bolt.execute(tuple1);    bolt.execute(tuple2);        verify(client, times(2)).addMutation(any(), any(), any());    verify(client, times(1)).mutate();}
public void metron_f991_0() throws Exception
{    HBaseBolt bolt = createBolt(2, new WidgetMapper());    bolt.execute(tuple1);        verify(client, times(1)).addMutation(any(), any(), any());    verify(client, times(0)).mutate();}
public void metron_f992_0() throws Exception
{    HBaseBolt bolt = createBolt(2, new WidgetMapper());        bolt.execute(tuple1);    verify(client, times(1)).addMutation(any(), any(), any());    verify(client, times(0)).mutate();        bolt.execute(mockTickTuple());    verify(client, times(1)).mutate();}
public void metron_f993_0() throws Exception
{        final Long expectedTTL = 2000L;    WidgetMapper mapperWithTTL = new WidgetMapper(expectedTTL);        HBaseBolt bolt = createBolt(2, mapperWithTTL);    bolt.execute(tuple1);    bolt.execute(tuple2);        ArgumentCaptor<Long> ttlCaptor = ArgumentCaptor.forClass(Long.class);        verify(client, times(2)).addMutation(any(), any(), any(), ttlCaptor.capture());    Assert.assertEquals(expectedTTL, ttlCaptor.getValue());}
private static Tuple metron_f994_0(String componentId, String streamId)
{    Tuple tuple = mock(Tuple.class);    when(tuple.getSourceComponent()).thenReturn(componentId);    when(tuple.getSourceStreamId()).thenReturn(streamId);    return tuple;}
private static Tuple metron_f995_0()
{    return mockTuple(Constants.SYSTEM_COMPONENT_ID, Constants.SYSTEM_TICK_STREAM_ID);}
public String metron_f996_0()
{    return name;}
public void metron_f997_0(String name)
{    this.name = name;}
public int metron_f998_0()
{    return cost;}
public void metron_f999_0(int cost)
{    this.cost = cost;}
public boolean metron_f1000_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Widget widget = (Widget) o;    if (cost != widget.cost)        return false;    return name != null ? name.equals(widget.name) : widget.name == null;}
public int metron_f1001_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + cost;    return result;}
public String metron_f1002_0()
{    return "Widget{" + "name='" + name + '\'' + ", cost=" + cost + '}';}
public byte[] metron_f1003_0(Tuple tuple)
{    Widget w = (Widget) tuple.getValueByField("widget");    return Bytes.toBytes(w.getName());}
public ColumnList metron_f1004_0(Tuple tuple)
{    Widget w = (Widget) tuple.getValueByField("widget");    ColumnList cols = new ColumnList();    cols.addColumn(CF, QNAME, Bytes.toBytes(w.getName()));    cols.addColumn(CF, QCOST, Bytes.toBytes(w.getCost()));    return cols;}
public Optional<Long> metron_f1005_0(Tuple tuple)
{    return ttl;}
public void metron_f1006_0()
{    int flushFreq = 1000;    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(flushFreq);        assertFalse(signal.isTimeToFlush());        signal.update(5000);    assertFalse(signal.isTimeToFlush());        signal.update(7000);    assertTrue(signal.isTimeToFlush());}
public void metron_f1007_0()
{    int flushFreq = 5000;    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(flushFreq);        signal.update(5000);    assertFalse(signal.isTimeToFlush());        signal.update(1000);    assertFalse(signal.isTimeToFlush());        signal.update(7000);    assertTrue(signal.isTimeToFlush());        signal.update(3000);    assertTrue(signal.isTimeToFlush());        assertTrue(signal.isTimeToFlush());}
public void metron_f1008_0()
{    int flushFreq = 7000;    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(flushFreq);        signal.update(5000);    assertFalse(signal.isTimeToFlush());        signal.update(1000);    assertFalse(signal.isTimeToFlush());        signal.update(7000);    assertFalse(signal.isTimeToFlush());        signal.update(3000);    assertFalse(signal.isTimeToFlush());}
public void metron_f1009_0()
{    int flushFreq = 3000;    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(flushFreq);        signal.update(4100);    assertFalse(signal.isTimeToFlush());        signal.update(3000);    assertFalse(signal.isTimeToFlush());        signal.update(2000);    assertFalse(signal.isTimeToFlush());        signal.update(1000);    assertTrue(signal.isTimeToFlush());}
public void metron_f1010_0()
{    int flushFreq = 4000;    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(flushFreq);        signal.update(4000);    assertFalse(signal.isTimeToFlush());        signal.update(3000);    assertFalse(signal.isTimeToFlush());        signal.update(2000);    assertFalse(signal.isTimeToFlush());        signal.update(1000);    assertFalse(signal.isTimeToFlush());}
public void metron_f1011_0()
{    int flushFreq = 3000;    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(flushFreq);        signal.update(1000);    assertFalse(signal.isTimeToFlush());        signal.update(2000);    assertFalse(signal.isTimeToFlush());        signal.update(3000);    assertFalse(signal.isTimeToFlush());        signal.update(4000);}
public void metron_f1012_0()
{    int flushFreq = 4000;    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(flushFreq);        signal.update(1000);    assertFalse(signal.isTimeToFlush());        signal.update(2000);    assertFalse(signal.isTimeToFlush());        signal.update(3000);    assertFalse(signal.isTimeToFlush());        signal.update(4000);    assertFalse(signal.isTimeToFlush());}
public void metron_f1013_0()
{        new FixedFrequencyFlushSignal(-1000);}
public void metron_f1014_0()
{    FixedFrequencyFlushSignal signal = new FixedFrequencyFlushSignal(4000);    signal.update(1000);    signal.update(6000);        assertTrue(signal.isTimeToFlush());        signal.reset();    assertFalse(signal.isTimeToFlush());}
public void metron_f1015_0() throws Exception
{    emitter = new HBaseEmitter();    profile = createDefinition(profileDefinition);    collector = Mockito.mock(OutputCollector.class);}
public void metron_f1016_0() throws Exception
{        ProfileMeasurement measurement = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withDefinition(profile).withProfileValue(22);        emitter.emit(measurement, collector);        ProfileMeasurement actual = expectMeasurement(emitter, collector);    assertEquals(measurement, actual);}
private ProfileMeasurement metron_f1017_0(HBaseEmitter hbaseEmitter, OutputCollector collector)
{    ArgumentCaptor<Values> arg = ArgumentCaptor.forClass(Values.class);    verify(collector, times(1)).emit(eq(hbaseEmitter.getStreamId()), arg.capture());    Values values = arg.getValue();    assertTrue(values.get(0) instanceof ProfileMeasurement);    return (ProfileMeasurement) values.get(0);}
private ProfileConfig metron_f1018_0(String json) throws IOException
{    return JSONUtils.INSTANCE.load(json, ProfileConfig.class);}
public void metron_f1019_0() throws UnableToStartException
{    try {        upload();    } catch (Exception e) {        throw new UnableToStartException(e.getMessage(), e);    }}
public void metron_f1020_0()
{}
public void metron_f1021_0() throws UnableToStartException
{    try {        upload();    } catch (Exception e) {        throw new UnableToStartException(e.getMessage(), e);    }}
private void metron_f1022_0() throws Exception
{    final String zookeeperUrl = topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY);    try (CuratorFramework client = getClient(zookeeperUrl)) {        if (client.getState() != CuratorFrameworkState.STARTED) {            client.start();        }        uploadGlobalConfig(client);        uploadProfilerConfig(client);    }}
private void metron_f1023_0(CuratorFramework client) throws Exception
{    byte[] configBytes = null;    if (profilerConfigurationPath != null) {        configBytes = readProfilerConfigFromFile(profilerConfigurationPath);    } else if (profilerConfig != null) {        configBytes = profilerConfig.toJSON().getBytes(StandardCharsets.UTF_8);    }    if (ArrayUtils.getLength(configBytes) > 0) {        writeProfilerConfigToZookeeper(configBytes, client);    }}
private void metron_f1024_0(CuratorFramework client) throws Exception
{    if (globalConfiguration != null) {        byte[] globalConfig = readGlobalConfigFromFile(globalConfiguration);        if (globalConfig.length > 0) {            writeGlobalConfigToZookeeper(readGlobalConfigFromFile(globalConfiguration), client);        }    }}
public ConfigUploadComponent metron_f1025_0(Properties topologyProperties)
{    this.topologyProperties = topologyProperties;    return this;}
public ConfigUploadComponent metron_f1026_0(String path)
{    this.globalConfiguration = path;    return this;}
public ConfigUploadComponent metron_f1027_0(String path)
{    this.profilerConfigurationPath = path;    return this;}
public ConfigUploadComponent metron_f1028_0(ProfilerConfig profilerConfig)
{    this.profilerConfig = profilerConfig;    return this;}
public MessageBuilder metron_f1029_0(JSONObject prototype)
{    prototype.forEach((key, val) -> this.fields.put(key, val));    return this;}
public MessageBuilder metron_f1030_0(String key, Object value)
{    this.fields.put(key, value);    return this;}
public JSONObject metron_f1031_0()
{    return new JSONObject(fields);}
public void metron_f1032_1() throws Exception
{    uploadConfigToZookeeper(ProfilerConfig.fromJSON(processingTimeProfile));        fluxComponent.submitTopology();    kafkaComponent.writeMessages(inputTopic, message1);    kafkaComponent.writeMessages(inputTopic, message2);    kafkaComponent.writeMessages(inputTopic, message3);        String profileGetExpression = "PROFILE_GET('processing-time-test', '10.0.0.1', PROFILE_FIXED('15', 'MINUTES'))";    List<Integer> measurements = execute(profileGetExpression, List.class);        int attempt = 0;    while (measurements.size() == 0 && attempt++ < 10) {                long sleep = windowDurationMillis;                Thread.sleep(sleep);                                kafkaComponent.writeMessages(inputTopic, message2);                measurements = execute(profileGetExpression, List.class);    }            assertTrue(measurements.size() > 0);            assertTrue(measurements.get(0) >= 3);}
public void metron_f1033_1() throws Exception
{    uploadConfigToZookeeper(ProfilerConfig.fromJSON(processingTimeProfile));        fluxComponent.submitTopology();    kafkaComponent.writeMessages(inputTopic, message1);    kafkaComponent.writeMessages(inputTopic, message2);    kafkaComponent.writeMessages(inputTopic, message3);            long sleep = windowLagMillis + periodDurationMillis;        Thread.sleep(sleep);    kafkaComponent.writeMessages(inputTopic, message3);        assertEventually(() -> {        List<Integer> results = execute("PROFILE_GET('processing-time-test', '10.0.0.1', PROFILE_FIXED('15', 'MINUTES'))", List.class);        assertThat(results, hasItem(3));    }, timeout);}
public void metron_f1034_1() throws Exception
{    uploadConfigToZookeeper(ProfilerConfig.fromJSON(eventTimeProfile));        fluxComponent.submitTopology();    List<String> messages = FileUtils.readLines(new File("src/test/resources/telemetry.json"));    kafkaComponent.writeMessages(inputTopic, messages);    long timestamp = System.currentTimeMillis();        kafkaComponent.writeMessages(inputTopic, getMessage("192.168.66.1", timestamp));    kafkaComponent.writeMessages(inputTopic, getMessage("192.168.138.158", timestamp));        assign("maxTimestamp", "1530978728982L");    assign("window", "PROFILE_WINDOW('from 5 hours ago', maxTimestamp)");                    assertEventually(() -> {        List<Integer> results = execute("PROFILE_GET('count-by-ip', '192.168.66.1', window)", List.class);        assertThat(results, hasItems(14, 12));    }, timeout);        assertEventually(() -> {        List<Integer> results = execute("PROFILE_GET('count-by-ip', '192.168.138.158', window)", List.class);        assertThat(results, hasItems(36, 38));    }, timeout);        assertEventually(() -> {        List<Integer> results = execute("PROFILE_GET('total-count', 'total', window)", List.class);        assertThat(results, hasItems(50, 50));    }, timeout);}
public void metron_f1035_0() throws Exception
{    uploadConfigToZookeeper(ProfilerConfig.fromJSON(profileWithStats));        fluxComponent.submitTopology();    List<String> messages = FileUtils.readLines(new File("src/test/resources/telemetry.json"));    kafkaComponent.writeMessages(inputTopic, messages);    assertEventually(() -> {                        assign("maxTimestamp", "1530978728982L");        assign("window", "PROFILE_WINDOW('from 5 hours ago', maxTimestamp)");                List results = execute("PROFILE_GET('profile-with-stats', 'global', window)", List.class);        assertTrue(results.size() > 0);        assertTrue(results.get(0) instanceof OnlineStatisticsProvider);    }, timeout);}
public void metron_f1036_0() throws Exception
{    uploadConfigToZookeeper(ProfilerConfig.fromJSON(profileWithTriageResult));        fluxComponent.submitTopology();    List<String> telemetry = FileUtils.readLines(new File("src/test/resources/telemetry.json"));    kafkaComponent.writeMessages(inputTopic, telemetry);        assertEventually(() -> {        outputMessages = kafkaComponent.readMessages(outputTopic);        assertEquals(1, outputMessages.size());    }, timeout);        JSONObject message = (JSONObject) new JSONParser().parse(new String(outputMessages.get(0), StandardCharsets.UTF_8));    assertEquals("profile-with-triage", message.get(PROFILE_FIELD));    assertEquals("global", message.get(ENTITY_FIELD));    assertEquals(76548935L, message.get(PERIOD_ID_FIELD));    assertEquals(1530978700000L, message.get(PERIOD_START_FIELD));    assertEquals(1530978720000L, message.get(PERIOD_END_FIELD));    assertEquals("profiler", message.get(Constants.SENSOR_TYPE));    assertEquals("true", message.get(ALERT_FIELD));    assertEquals(1.0, message.get("min"));    assertEquals(1.0, message.get("max"));    assertEquals(1.0, message.get("mean"));    assertTrue(message.containsKey(TIMESTAMP_FIELD));    assertTrue(message.containsKey(Constants.GUID));}
private static String metron_f1037_0(String ipSource, long timestamp)
{    return new MessageBuilder().withField("ip_src_addr", ipSource).withField("timestamp", timestamp).build().toJSONString();}
public static void metron_f1038_0() throws UnableToStartException
{        message1 = getMessage(entity, startAt);    message2 = getMessage(entity, startAt + 100);    message3 = getMessage(entity, startAt + (windowDurationMillis * 2));        final Properties topologyProperties = new Properties() {        {                        setProperty("profiler.workers", "1");            setProperty("profiler.executors", "0");            setProperty(Config.TOPOLOGY_AUTO_CREDENTIALS, "[]");            setProperty(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS, "60");            setProperty(Config.TOPOLOGY_MAX_SPOUT_PENDING, "100000");                                    setProperty(Config.TOPOLOGY_TESTING_ALWAYS_TRY_SERIALIZE, "true");            setProperty(Config.TOPOLOGY_FALL_BACK_ON_JAVA_SERIALIZATION, "false");            setProperty(Config.TOPOLOGY_KRYO_REGISTER, kryoSerializers);                        setProperty("profiler.input.topic", inputTopic);            setProperty("profiler.output.topic", outputTopic);            setProperty("kafka.start", "EARLIEST");            setProperty("kafka.security.protocol", "PLAINTEXT");                        setProperty("profiler.hbase.salt.divisor", Integer.toString(saltDivisor));            setProperty("profiler.hbase.table", tableName);            setProperty("profiler.hbase.column.family", columnFamily);            setProperty("profiler.hbase.batch", "10");            setProperty("profiler.hbase.flush.interval.seconds", "1");            setProperty("hbase.provider.impl", "" + MockHBaseTableProvider.class.getName());                        setProperty("profiler.period.duration", Long.toString(periodDurationMillis));            setProperty("profiler.period.duration.units", "MILLISECONDS");            setProperty("profiler.ttl", Long.toString(profileTimeToLiveMillis));            setProperty("profiler.ttl.units", "MILLISECONDS");            setProperty("profiler.window.duration", Long.toString(windowDurationMillis));            setProperty("profiler.window.duration.units", "MILLISECONDS");            setProperty("profiler.window.lag", Long.toString(windowLagMillis));            setProperty("profiler.window.lag.units", "MILLISECONDS");            setProperty("profiler.max.routes.per.bolt", Long.toString(maxRoutesPerBolt));        }    };        profilerTable = (MockHTable) MockHBaseTableProvider.addToCache(tableName, columnFamily);    zkComponent = getZKServerComponent(topologyProperties);        kafkaComponent = getKafkaComponent(topologyProperties, Arrays.asList(new KafkaComponent.Topic(inputTopic, 1), new KafkaComponent.Topic(outputTopic, 1)));        configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties);        fluxComponent = new FluxTopologyComponent.Builder().withTopologyLocation(new File(FLUX_PATH)).withTopologyName("profiler").withTopologyProperties(topologyProperties).build();        runner = new ComponentRunner.Builder().withComponent("zk", zkComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("storm", fluxComponent).withMillisecondsBetweenAttempts(15000).withNumRetries(10).withCustomShutdownOrder(new String[] { "storm", "config", "kafka", "zk" }).build();    runner.start();}
public static void metron_f1039_0() throws Exception
{    MockHBaseTableProvider.clear();    if (runner != null) {        runner.stop();    }}
public void metron_f1040_0()
{        profilerTable = (MockHTable) MockHBaseTableProvider.addToCache(tableName, columnFamily);        Map<String, Object> global = new HashMap<String, Object>() {        {            put(PROFILER_HBASE_TABLE.getKey(), tableName);            put(PROFILER_COLUMN_FAMILY.getKey(), columnFamily);            put(PROFILER_HBASE_TABLE_PROVIDER.getKey(), MockHBaseTableProvider.class.getName());                        put(PROFILER_PERIOD.getKey(), Long.toString(periodDurationMillis));            put(PROFILER_PERIOD_UNITS.getKey(), "MILLISECONDS");                        put(PROFILER_SALT_DIVISOR.getKey(), saltDivisor);        }    };        executor = new DefaultStellarStatefulExecutor(new SimpleFunctionResolver().withClass(GetProfile.class).withClass(FixedLookback.class).withClass(WindowLookback.class), new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> global).build());}
public void metron_f1041_0() throws Exception
{    MockHBaseTableProvider.clear();    profilerTable.clear();    if (runner != null) {        runner.reset();    }}
public void metron_f1042_0(ProfilerConfig profilerConfig) throws Exception
{    configUploadComponent.withProfilerConfiguration(profilerConfig).update();}
private void metron_f1043_0(String var, String expression)
{    executor.assign(var, expression, Collections.emptyMap());}
private T metron_f1044_1(String expression, Class<T> clazz)
{    T results = executor.execute(expression, Collections.emptyMap(), clazz);        return results;}
public void metron_f1045_0() throws Exception
{    kafkaEmitter = new KafkaEmitter();    profile = createDefinition(profileDefinitionWithTriage);    collector = Mockito.mock(OutputCollector.class);}
public void metron_f1046_0() throws Exception
{        ProfileMeasurement measurement = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withDefinition(profile).withTriageValues(Collections.singletonMap("triage-key", "triage-value"));        kafkaEmitter.emit(measurement, collector);        verify(collector, times(1)).emit(eq(kafkaEmitter.getStreamId()), any());}
public void metron_f1047_0() throws Exception
{        ProfileMeasurement measurement = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withDefinition(profile);        kafkaEmitter.emit(measurement, collector);        verify(collector, times(0)).emit(eq(kafkaEmitter.getStreamId()), any());}
public void metron_f1048_0() throws Exception
{        ProfileMeasurement measurement = new ProfileMeasurement().withDefinition(profile).withProfileName(profile.getProfile()).withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withTriageValues(Collections.singletonMap("triage-key", "triage-value"));        kafkaEmitter.emit(measurement, collector);    JSONObject actual = expectJsonObject(kafkaEmitter, collector);        assertEquals(measurement.getProfileName(), actual.get("profile"));    assertEquals(measurement.getEntity(), actual.get("entity"));    assertEquals(measurement.getPeriod().getPeriod(), actual.get("period"));    assertEquals(measurement.getPeriod().getStartTimeMillis(), actual.get("period.start"));    assertEquals(measurement.getPeriod().getEndTimeMillis(), actual.get("period.end"));    assertEquals("profiler", actual.get("source.type"));    assertNotNull(actual.get("timestamp"));    assertNotNull(actual.get(Constants.GUID));        assertEquals(measurement.getTriageValues().get("triage-key"), actual.get("triage-key"));}
public void metron_f1049_0() throws Exception
{        Map<String, Object> triageValues = ImmutableMap.of("x", 2, "y", "4", "z", 6.0);        ProfileMeasurement measurement = new ProfileMeasurement().withDefinition(profile).withProfileName(profile.getProfile()).withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withTriageValues(triageValues);        kafkaEmitter.emit(measurement, collector);    JSONObject actual = expectJsonObject(kafkaEmitter, collector);        assertEquals(measurement.getTriageValues().get("x"), actual.get("x"));    assertEquals(measurement.getTriageValues().get("y"), actual.get("y"));    assertEquals(measurement.getTriageValues().get("z"), actual.get("z"));}
public void metron_f1050_0() throws Exception
{        Map<String, Object> triageValues = ImmutableMap.of("invalid", new OnlineStatisticsProvider(), "valid", 4);        ProfileMeasurement measurement = new ProfileMeasurement().withDefinition(profile).withProfileName(profile.getProfile()).withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withTriageValues(triageValues);        kafkaEmitter.emit(measurement, collector);    JSONObject actual = expectJsonObject(kafkaEmitter, collector);        assertEquals(measurement.getProfileName(), actual.get("profile"));    assertEquals(measurement.getEntity(), actual.get("entity"));    assertEquals(measurement.getPeriod().getPeriod(), actual.get("period"));    assertEquals(measurement.getPeriod().getStartTimeMillis(), actual.get("period.start"));    assertEquals(measurement.getPeriod().getEndTimeMillis(), actual.get("period.end"));    assertEquals("profiler", actual.get("source.type"));    assertNotNull(actual.get("timestamp"));    assertNotNull(actual.get(Constants.GUID));        assertFalse(actual.containsKey("invalid"));        assertEquals(triageValues.get("valid"), actual.get("valid"));}
public void metron_f1051_0() throws Exception
{        ProfileMeasurement measurement = new ProfileMeasurement().withDefinition(profile).withProfileName(profile.getProfile()).withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withTriageValues(Collections.singletonMap("triage-key", 123));        kafkaEmitter.emit(measurement, collector);    JSONObject actual = expectJsonObject(kafkaEmitter, collector);        assertEquals(measurement.getTriageValues().get("triage-key"), actual.get("triage-key"));}
public void metron_f1052_0() throws Exception
{        ProfileMeasurement measurement = new ProfileMeasurement().withDefinition(profile).withProfileName(profile.getProfile()).withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withTriageValues(Collections.singletonMap("triage-key", "value"));        kafkaEmitter.emit(measurement, collector);    JSONObject actual = expectJsonObject(kafkaEmitter, collector);        assertEquals(measurement.getTriageValues().get("triage-key"), actual.get("triage-key"));}
private JSONObject metron_f1053_0(KafkaEmitter kafkaEmitter, OutputCollector collector)
{    ArgumentCaptor<Values> arg = ArgumentCaptor.forClass(Values.class);    verify(collector, times(1)).emit(eq(kafkaEmitter.getStreamId()), arg.capture());    Values values = arg.getValue();    assertTrue(values.get(0) instanceof JSONObject);    return (JSONObject) values.get(0);}
private ProfileConfig metron_f1054_0(String json) throws IOException
{    return JSONUtils.INSTANCE.load(json, ProfileConfig.class);}
public void metron_f1055_0() throws Exception
{    message1 = new MessageBuilder().withField("ip_src_addr", "10.0.0.1").withField("value", "22").build();    message2 = new MessageBuilder().withField("ip_src_addr", "10.0.0.2").withField("value", "22").build();    profile1 = new ProfileConfig().withProfile("profile1").withForeach("ip_src_addr").withInit("x", "0").withUpdate("x", "x + 1").withResult("x");    profile2 = new ProfileConfig().withProfile("profile2").withForeach("ip_src_addr").withInit(Collections.singletonMap("x", "0")).withUpdate(Collections.singletonMap("x", "x + 1")).withResult("x");    measurement = new ProfileMeasurement().withEntity("entity1").withProfileName("profile1").withPeriod(1000, 500, TimeUnit.MILLISECONDS).withProfileValue(22);    flushSignal = new ManualFlushSignal();    flushSignal.setFlushNow(false);}
public void metron_f1056_0() throws Exception
{    ProfileBuilderBolt bolt = createBolt();        MessageDistributor distributor = mock(MessageDistributor.class);    bolt.withMessageDistributor(distributor);        final long timestamp1 = 100000000L;    Tuple tuple1 = createTuple("entity1", message1, profile1, timestamp1);        TupleWindow tupleWindow = createWindow(tuple1);    bolt.execute(tupleWindow);        verify(distributor).distribute(any(MessageRoute.class), any());}
public void metron_f1057_0() throws Exception
{    ProfileBuilderBolt bolt = createBolt();        MessageDistributor distributor = mock(MessageDistributor.class);    when(distributor.flush()).thenReturn(Collections.singletonList(measurement));    bolt.withMessageDistributor(distributor);        flushSignal.setFlushNow(true);        Tuple tuple1 = createTuple("entity1", message1, profile1, 1000L);    TupleWindow tupleWindow = createWindow(tuple1);    bolt.execute(tupleWindow);        List<ProfileMeasurement> measurements = getProfileMeasurements(outputCollector, 1);    assertEquals(1, measurements.size());    assertEquals(measurement, measurements.get(0));}
public void metron_f1058_0() throws Exception
{    ProfileBuilderBolt bolt = createBolt();        MessageDistributor distributor = mock(MessageDistributor.class);    when(distributor.flush()).thenReturn(Collections.singletonList(measurement));    bolt.withMessageDistributor(distributor);        flushSignal.setFlushNow(false);        Tuple tuple1 = createTuple("entity1", message1, profile1, 1000L);    TupleWindow tupleWindow = createWindow(tuple1);    bolt.execute(tupleWindow);        getProfileMeasurements(outputCollector, 0);}
public void metron_f1059_0() throws Exception
{    ProfileBuilderBolt bolt = createBolt();        MessageDistributor distributor = mock(MessageDistributor.class);    when(distributor.flushExpired()).thenReturn(Collections.singletonList(measurement));    bolt.withMessageDistributor(distributor);        bolt.flushExpired();        List<ProfileMeasurement> measurements = getProfileMeasurements(outputCollector, 1);    assertEquals(1, measurements.size());    assertEquals(measurement, measurements.get(0));}
public void metron_f1060_0() throws Exception
{        ProfilerConfigurations configurations = new ProfilerConfigurations();    configurations.updateGlobalConfig(Collections.emptyMap());        ProfileBuilderBolt bolt = (ProfileBuilderBolt) new ProfileBuilderBolt().withProfileTimeToLive(30, TimeUnit.MINUTES).withPeriodDuration(10, TimeUnit.MINUTES).withMaxNumberOfRoutes(Long.MAX_VALUE).withZookeeperClient(client).withZookeeperCache(cache).withEmitter(new TestEmitter("destination1")).withEmitter(new TestEmitter("destination2")).withEmitter(new TestEmitter("destination3")).withProfilerConfigurations(configurations).withTumblingWindow(new BaseWindowedBolt.Duration(10, TimeUnit.MINUTES));    bolt.prepare(new HashMap<>(), topologyContext, outputCollector);        bolt.withFlushSignal(flushSignal);    flushSignal.setFlushNow(true);        Tuple tuple1 = createTuple("entity", message1, profile1, System.currentTimeMillis());    TupleWindow window = createWindow(tuple1);    bolt.execute(window);        verify(outputCollector, times(1)).emit(eq("destination1"), any());    verify(outputCollector, times(1)).emit(eq("destination2"), any());    verify(outputCollector, times(1)).emit(eq("destination3"), any());}
public void metron_f1061_0() throws Exception
{        ProfileMeasurementEmitter badEmitter = mock(ProfileMeasurementEmitter.class);    doThrow(new RuntimeException("flushExpired() should catch this exception")).when(badEmitter).emit(any(), any());        MessageDistributor distributor = mock(MessageDistributor.class);    when(distributor.flushExpired()).thenReturn(Collections.singletonList(measurement));        ProfileBuilderBolt bolt = (ProfileBuilderBolt) new ProfileBuilderBolt().withEmitter(badEmitter).withMessageDistributor(distributor);        bolt.flushExpired();}
private List<ProfileMeasurement> metron_f1062_0(OutputCollector collector, int expected)
{        final String streamId = emitter.getStreamId();        ArgumentCaptor<Values> argCaptor = ArgumentCaptor.forClass(Values.class);    verify(collector, times(expected)).emit(eq(streamId), argCaptor.capture());        return argCaptor.getAllValues().stream().map(val -> (ProfileMeasurement) val.get(0)).collect(Collectors.toList());}
private Tuple metron_f1063_0(String entity, JSONObject message, ProfileConfig profile, long timestamp)
{    Tuple tuple = mock(Tuple.class);    when(tuple.getValueByField(eq(ProfileSplitterBolt.MESSAGE_TUPLE_FIELD))).thenReturn(message);    when(tuple.getValueByField(eq(ProfileSplitterBolt.TIMESTAMP_TUPLE_FIELD))).thenReturn(timestamp);    when(tuple.getValueByField(eq(ProfileSplitterBolt.ENTITY_TUPLE_FIELD))).thenReturn(entity);    when(tuple.getValueByField(eq(ProfileSplitterBolt.PROFILE_TUPLE_FIELD))).thenReturn(profile);    return tuple;}
private ProfileBuilderBolt metron_f1064_0() throws IOException
{        ProfilerConfigurations configurations = new ProfilerConfigurations();    configurations.updateGlobalConfig(Collections.emptyMap());    emitter = new HBaseEmitter();    ProfileBuilderBolt bolt = (ProfileBuilderBolt) new ProfileBuilderBolt().withProfileTimeToLive(30, TimeUnit.MINUTES).withMaxNumberOfRoutes(Long.MAX_VALUE).withZookeeperClient(client).withZookeeperCache(cache).withEmitter(emitter).withProfilerConfigurations(configurations).withPeriodDuration(1, TimeUnit.MINUTES).withTumblingWindow(new BaseWindowedBolt.Duration(30, TimeUnit.SECONDS));    bolt.prepare(new HashMap<>(), topologyContext, outputCollector);        bolt.withFlushSignal(flushSignal);    return bolt;}
private TupleWindow metron_f1065_0(Tuple... tuples)
{    TupleWindow window = mock(TupleWindow.class);    when(window.get()).thenReturn(Arrays.asList(tuples));    return window;}
public String metron_f1066_0()
{    return streamId;}
public void metron_f1067_0(OutputFieldsDeclarer declarer)
{    declarer.declareStream(getStreamId(), new Fields("measurement"));}
public void metron_f1068_0(ProfileMeasurement measurement, OutputCollector collector)
{    collector.emit(getStreamId(), new Values(measurement));}
public void metron_f1069_0()
{    rowKeyBuilder = mock(RowKeyBuilder.class);    mapper = new ProfileHBaseMapper();    mapper.setRowKeyBuilder(rowKeyBuilder);    profile = new ProfileConfig("profile", "ip_src_addr", new ProfileResult("2 + 2"));    measurement = new ProfileMeasurement().withProfileName("profile").withEntity("entity").withPeriod(20000, 15, TimeUnit.MINUTES).withProfileValue(22).withDefinition(profile);        tuple = mock(Tuple.class);    when(tuple.getValueByField(eq("measurement"))).thenReturn(measurement);}
public void metron_f1070_0() throws Exception
{    final Long expiresDays = 30L;    profile.setExpires(expiresDays);    Optional<Long> actual = mapper.getTTL(tuple);    Assert.assertTrue(actual.isPresent());    Assert.assertEquals(expiresDays, (Long) TimeUnit.MILLISECONDS.toDays(actual.get()));}
public void metron_f1071_0() throws Exception
{        Optional<Long> actual = mapper.getTTL(tuple);    Assert.assertFalse(actual.isPresent());}
public void metron_f1072_0() throws ParseException
{        JSONParser parser = new JSONParser();    message = (JSONObject) parser.parse(input);        when(tuple.getBinaryByField(VALUE.getFieldName())).thenReturn(input.getBytes(StandardCharsets.UTF_8));}
public void metron_f1073_0() throws Exception
{        ProfilerConfig config = toProfilerConfig(profileWithOnlyIfTrue);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        String expectedEntity = "10.0.0.1";    ProfileConfig expectedConfig = config.getProfiles().get(0);    Values expected = new Values(message, timestamp, expectedEntity, expectedConfig);        verify(outputCollector, times(1)).emit(eq(tuple), eq(expected));        verify(outputCollector, times(1)).ack(eq(tuple));}
public void metron_f1074_0() throws Exception
{        ProfilerConfig config = toProfilerConfig(twoProfilesDefined);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        final String expectedEntity = "global";    {                ProfileConfig profile1 = config.getProfiles().get(0);        Values expected = new Values(message, timestamp, expectedEntity, profile1);        verify(outputCollector, times(1)).emit(eq(tuple), eq(expected));    }    {                ProfileConfig profile2 = config.getProfiles().get(1);        Values expected = new Values(message, timestamp, expectedEntity, profile2);        verify(outputCollector, times(1)).emit(eq(tuple), eq(expected));    }        verify(outputCollector, times(1)).ack(eq(tuple));}
public void metron_f1075_0() throws Exception
{        ProfilerConfig config = toProfilerConfig(noProfilesDefined);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        verify(outputCollector, times(0)).emit(any(Tuple.class), any());        verify(outputCollector, times(1)).ack(eq(tuple));}
public void metron_f1076_0() throws Exception
{    ProfilerConfig config = toProfilerConfig(profileWithOnlyIfTrue);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        verify(outputCollector, times(1)).emit(eq(tuple), any(Values.class));        verify(outputCollector, times(1)).ack(eq(tuple));}
public void metron_f1077_0() throws Exception
{    ProfilerConfig config = toProfilerConfig(profileWithOnlyIfMissing);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        verify(outputCollector, times(1)).emit(eq(tuple), any(Values.class));        verify(outputCollector, times(1)).ack(eq(tuple));}
public void metron_f1078_0() throws Exception
{    ProfilerConfig config = toProfilerConfig(profileWithOnlyIfFalse);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        verify(outputCollector, times(0)).emit(any());        verify(outputCollector, times(1)).ack(eq(tuple));}
public void metron_f1079_0() throws Exception
{    ProfilerConfig config = toProfilerConfig(profileWithOnlyIfTrue);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        String expectedEntity = "10.0.0.1";    ProfileConfig expectedConfig = config.getProfiles().get(0);    Values expected = new Values(message, timestamp, expectedEntity, expectedConfig);        verify(outputCollector, times(1)).emit(eq(tuple), eq(expected));        verify(outputCollector, times(1)).ack(eq(tuple));}
public void metron_f1080_0() throws Exception
{    ProfilerConfig config = toProfilerConfig(profileWithOnlyIfInvalid);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        verify(outputCollector, times(0)).emit(any(Values.class));}
public void metron_f1081_0() throws Exception
{        when(tuple.getBinary(0)).thenReturn(null);    ProfilerConfig config = toProfilerConfig(profileWithOnlyIfInvalid);    ProfileSplitterBolt bolt = createBolt(config);    bolt.execute(tuple);        verify(outputCollector, times(0)).emit(any(Values.class));}
private ProfilerConfig metron_f1082_0(String configAsJSON) throws Exception
{    InputStream in = new ByteArrayInputStream(configAsJSON.getBytes(StandardCharsets.UTF_8));    return JSONUtils.INSTANCE.load(in, ProfilerConfig.class);}
private ProfileSplitterBolt metron_f1083_0(ProfilerConfig config) throws Exception
{    ProfileSplitterBolt bolt = new ProfileSplitterBolt("zookeeperURL");    bolt.setCuratorFramework(client);    bolt.setZKCache(cache);    bolt.getConfigurations().updateProfilerConfig(config);    bolt.prepare(new HashMap<>(), topologyContext, outputCollector);        DefaultMessageRouter router = new DefaultMessageRouter(bolt.getStellarContext());    router.setClockFactory(new FixedClockFactory(timestamp));    bolt.setRouter(router);    return bolt;}
public static void metron_f1084_0(String[] args)
{    Options options = new Options();    try {        CommandLineParser parser = new PosixParser();        CommandLine cmd = null;        try {            cmd = ParserOptions.parse(parser, args);        } catch (ParseException pe) {            pe.printStackTrace();            final HelpFormatter usageFormatter = new HelpFormatter();            usageFormatter.printHelp("HLLPMeasurement", null, options, null, true);            System.exit(-1);        }        if (cmd.hasOption("h")) {            final HelpFormatter usageFormatter = new HelpFormatter();            usageFormatter.printHelp("HLLPMeasurement", null, options, null, true);            System.exit(0);        }        final String chartDelim = ParserOptions.CHART_DELIM.get(cmd, "|");        final int numTrials = Integer.parseInt(ParserOptions.NUM_TRIALS.get(cmd, "5000"));        final int cardMin = Integer.parseInt(ParserOptions.CARD_MIN.get(cmd, "200"));        final int cardMax = Integer.parseInt(ParserOptions.CARD_MAX.get(cmd, "1000"));        final int cardStep = Integer.parseInt(ParserOptions.CARD_STEP.get(cmd, "200"));        final int cardStart = (((cardMin - 1) / cardStep) * cardStep) + cardStep;        final int spMin = Integer.parseInt(ParserOptions.SP_MIN.get(cmd, "4"));        final int spMax = Integer.parseInt(ParserOptions.SP_MAX.get(cmd, "32"));        final int spStep = Integer.parseInt(ParserOptions.SP_STEP.get(cmd, "4"));        final int pMin = Integer.parseInt(ParserOptions.P_MIN.get(cmd, "4"));        final int pMax = Integer.parseInt(ParserOptions.P_MAX.get(cmd, "32"));        final int pStep = Integer.parseInt(ParserOptions.P_STEP.get(cmd, "4"));        final double errorPercentile = Double.parseDouble(ParserOptions.ERR_PERCENTILE.get(cmd, "50"));        final double timePercentile = Double.parseDouble(ParserOptions.TIME_PERCENTILE.get(cmd, "50"));        final double sizePercentile = Double.parseDouble(ParserOptions.SIZE_PERCENTILE.get(cmd, "50"));        final boolean formatErrPercent = Boolean.parseBoolean(ParserOptions.ERR_FORMAT_PERCENT.get(cmd, "true"));        final int errMultiplier = formatErrPercent ? 100 : 1;        final Function<Double, String> errorFormatter = (v -> ERR_FORMAT.format(v * errMultiplier));        final Function<Double, String> timeFormatter = (v -> TIME_FORMAT.format(v / NANO_TO_MILLIS));        final Function<Double, String> sizeFormatter = (v -> SIZE_FORMAT.format(v));        final String[] chartKey = new String[] { "card: cardinality", "sp: sparse precision value", "p: normal precision value", "err: error as a percent of the expected cardinality; ", "time: total time to add all values to the hllp estimator and calculate a cardinality estimate", "size: size of the hllp set in bytes once all values have been added for the specified cardinality", "l=low, m=mid(based on percentile chosen), h=high, std=standard deviation" };        final String[] chartHeader = new String[] { "card", "sp", "p", "err l/m/h/std (% of actual)", "time l/m/h/std (ms)", "size l/m/h/std (b)" };        final int[] chartPadding = new int[] { 10, 10, 10, 40, 40, 30 };        if (spMin < pMin) {            throw new IllegalArgumentException("p must be <= sp");        }        if (spMax < pMax) {            throw new IllegalArgumentException("p must be <= sp");        }        println("Options Used");        println("------------");        println("num trials: " + numTrials);        println("card min: " + cardMin);        println("card max: " + cardMax);        println("card step: " + cardStep);        println("card start: " + cardStart);        println("sp min: " + spMin);        println("sp max: " + spMax);        println("sp step: " + spStep);        println("p min: " + pMin);        println("p max: " + pMax);        println("p step: " + pStep);        println("error percentile: " + errorPercentile);        println("time percentile: " + timePercentile);        println("size percentile: " + sizePercentile);        println("format err as %: " + formatErrPercent);        println("");        printHeading(chartKey, chartHeader, chartPadding, chartDelim);        for (int c = cardStart; c <= cardMax; c += cardStep) {            for (int sp = spMin; sp <= spMax; sp += spStep) {                for (int p = pMin; p <= pMax; p += pStep) {                    DescriptiveStatistics errorStats = new DescriptiveStatistics();                    DescriptiveStatistics timeStats = new DescriptiveStatistics();                    DescriptiveStatistics sizeStats = new DescriptiveStatistics();                    for (int i = 0; i < numTrials; i++) {                        List<Object> trialSet = buildTrialSet(c);                        Set unique = new HashSet();                        unique.addAll(trialSet);                        long distinctVals = unique.size();                        HyperLogLogPlus hllp = new HyperLogLogPlus(p, sp);                        long timeStart = System.nanoTime();                        hllp.addAll(trialSet);                        long dvEstimate = hllp.cardinality();                        long timeEnd = System.nanoTime();                        long timeElapsed = timeEnd - timeStart;                        double rawError = Math.abs(dvEstimate - distinctVals) / (double) distinctVals;                        errorStats.addValue(rawError);                        timeStats.addValue(timeElapsed);                        sizeStats.addValue(SerDeUtils.toBytes(hllp).length);                    }                    MeasureResultFormatter errorRF = new MeasureResultFormatter(errorStats, errorFormatter, errorPercentile);                    MeasureResultFormatter timeRF = new MeasureResultFormatter(timeStats, timeFormatter, timePercentile);                    MeasureResultFormatter sizeRF = new MeasureResultFormatter(sizeStats, sizeFormatter, sizePercentile);                    println(formatWithPadding(new String[] { "" + c, "" + sp, "" + p, errorRF.getFormattedResults(), timeRF.getFormattedResults(), sizeRF.getFormattedResults() }, chartPadding, chartDelim));                }            }        }    } catch (Exception e) {        e.printStackTrace();        System.exit(-1);    }}
private static void metron_f1085_0(String[] key, String[] header, int[] chartPadding, String chartDelim)
{    printHeadingKey(key);    printDescription();    printHeaderRow(header, chartPadding, chartDelim);    printChartSpacer(header.length, chartPadding, chartDelim, CHART_SPACER);}
private static void metron_f1086_0(String[] key)
{    println("Table Key");    println("---------");    for (String v : key) {        println(v);    }    println("");}
private static void metron_f1087_0()
{    println("Metrics Table");    println("-------------");}
private static void metron_f1088_0(String[] header, int[] padding, String delim)
{    String headerPadded = formatWithPadding(header, padding, delim);    println(headerPadded);}
private static void metron_f1089_0(int totlength, int[] padding, String delim, String spacerStr)
{    String[] spacer = new String[totlength];    Arrays.fill(spacer, spacerStr);    String spacerPadded = formatWithPadding(spacer, padding, delim, spacerStr);    println(spacerPadded);}
private static void metron_f1090_0(String val)
{    System.out.println(val);}
private static String metron_f1091_0(String[] columns, int[] padding, String delim)
{    return formatWithPadding(columns, padding, delim, " ");}
private static String metron_f1092_0(String[] columns, int[] padding, String delim, String paddingStr)
{    StringBuilder sb = new StringBuilder();    sb.append(delim);    for (int i = 0; i < columns.length; i++) {        sb.append(org.apache.commons.lang.StringUtils.rightPad(columns[i], padding[i], paddingStr));        sb.append(delim);    }    return sb.toString();}
public String metron_f1093_0()
{    return formatter.apply(stats.getMin());}
public String metron_f1094_0()
{    return formatter.apply(stats.getPercentile(percentile));}
public String metron_f1095_0()
{    return formatter.apply(stats.getMax());}
public MeasureResultFormatter metron_f1096_0(boolean showStd)
{    this.showStd = showStd;    return this;}
public String metron_f1097_0()
{    if (showStd) {        return Joiner.on(delim).join(getMin(), getPercentile(), getMax(), getStd());    } else {        return Joiner.on(delim).join(getMin(), getPercentile(), getMax());    }}
public String metron_f1098_0()
{    return formatter.apply(stats.getStandardDeviation());}
private static List<Object> metron_f1099_0(int cardinality)
{    List<Object> trialSet = new ArrayList(cardinality);    for (int i = 0; i < cardinality; i++) {        trialSet.add(Math.random());    }    return trialSet;}
public boolean metron_f1100_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f1101_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f1102_0(CommandLine cli, String defaultVal)
{    return has(cli) ? cli.getOptionValue(shortCode) : defaultVal;}
public static CommandLine metron_f1103_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f1104_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("HLLPMeasurement", getOptions());}
public static Options metron_f1105_0()
{    Options ret = new Options();    for (ParserOptions o : ParserOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public int metron_f1106_0()
{    return sp;}
public int metron_f1107_0()
{    return p;}
public boolean metron_f1108_0(List<Object> objects)
{    boolean updated = false;    for (Object o : objects) {        updated |= add(o);    }    return updated;}
public boolean metron_f1109_0(Object o)
{    return hllp.offer(o);}
public long metron_f1110_0()
{    return hllp.cardinality();}
public HyperLogLogPlus metron_f1111_0(List<HyperLogLogPlus> estimators)
{    List<com.clearspring.analytics.stream.cardinality.HyperLogLogPlus> converted = Lists.transform(estimators, s -> s.hllp);    ICardinality merged = null;    try {        merged = hllp.merge(converted.toArray(new com.clearspring.analytics.stream.cardinality.HyperLogLogPlus[] {}));    } catch (CardinalityMergeException e) {        throw new IllegalArgumentException("Unable to merge estimators", e);    }    return new HyperLogLogPlus(p, sp, (com.clearspring.analytics.stream.cardinality.HyperLogLogPlus) merged);}
public boolean metron_f1112_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    HyperLogLogPlus that = (HyperLogLogPlus) o;    return hllp.equals(that.hllp);}
public int metron_f1113_0()
{    return hllp.hashCode();}
public Object metron_f1114_0(List<Object> args)
{    if (args.size() < 2) {        throw new IllegalArgumentException("Must pass an hllp estimator set and at least one value to add to the set");    } else {        HyperLogLogPlus hllp = ConversionUtils.convert(args.get(0), HyperLogLogPlus.class);        if (hllp == null) {            hllp = new HyperLogLogPlus();        }        Object secondArg = args.get(1);        if (secondArg instanceof List) {            hllp.addAll((List) secondArg);        } else {            hllp.add(secondArg);        }        return hllp;    }}
public Object metron_f1115_0(List<Object> args)
{    if (args.size() == 1) {        if (args.get(0) instanceof HyperLogLogPlus) {            HyperLogLogPlus hllpSet = (HyperLogLogPlus) args.get(0);            return hllpSet.cardinality();        } else {            return 0L;        }    } else {        return 0L;    }}
public Object metron_f1116_0(List<Object> args)
{    if (args.size() == 0) {        return new HyperLogLogPlus();    } else if (args.size() == 1) {        Integer p = ConversionUtils.convert(args.get(0), Integer.class);        if (p == null) {            throw new IllegalArgumentException(String.format("Unable to get p value from '%s'", args.get(0)));        }        return new HyperLogLogPlus(p);    } else {        Integer p = ConversionUtils.convert(args.get(0), Integer.class);        Integer sp = ConversionUtils.convert(args.get(1), Integer.class);        if (p == null) {            throw new IllegalArgumentException(String.format("Unable to get p value from '%s'", args.get(0)));        }        if (sp == null) {            throw new IllegalArgumentException(String.format("Unable to get sp value from '%s'", args.get(1)));        }        return new HyperLogLogPlus(p, sp);    }}
public Object metron_f1117_0(List<Object> args)
{    if (args.size() != 1) {        throw new IllegalArgumentException("Must pass single list of hllp sets to merge");    } else {        List<Object> estimators = new ArrayList();        if (args.get(0) instanceof List) {            estimators = (List) args.get(0);        } else {            estimators.add(args.get(0));        }        if (estimators.size() == 0) {            return null;        }        HyperLogLogPlus hllp = ConversionUtils.convert(estimators.get(0), HyperLogLogPlus.class);        if (estimators.size() > 1) {            hllp = hllp.merge(getEstimatorsFromIndex(estimators, 1));        }        return hllp;    }}
private List<HyperLogLogPlus> metron_f1118_0(List<Object> args, int index)
{    return ConversionUtils.convertList(args.subList(index, args.size()), HyperLogLogPlus.class);}
public static int metron_f1119_0(double value, int numBins, Function<Integer, Double> boundFunc)
{    double lastBound = Double.NEGATIVE_INFINITY;    for (int bin = 0; bin < numBins; ++bin) {        double bound = boundFunc.apply(bin);        if (lastBound > bound) {            throw new IllegalStateException("Your bins must be non-decreasing");        }        if (value <= bound) {            return bin;        }        lastBound = bound;    }    return numBins;}
public Object metron_f1120_0(List<Object> args)
{    Double value = convert(args.get(0), Double.class);    final List<Number> bins = args.size() > 1 ? convert(args.get(1), List.class) : null;    if (value == null || bins == null || bins.size() == 0) {        return -1;    }    return getBin(value, bins.size(), bin -> bins.get(bin).doubleValue());}
public Object metron_f1121_0(List<Object> args)
{    if (args.isEmpty()) {        throw new IllegalArgumentException("IT_ENTROPY expects exactly one argument.");    }    Object inputObj = args.get(0);    if (inputObj == null) {        return null;    }    if (!(inputObj instanceof Map)) {        throw new IllegalArgumentException("IT_ENTROPY expects exactly one argument and expects it to be a map of counts (e.g. Map<?, Integer>)");    }    Map<?, Integer> countMap = (Map<?, Integer>) inputObj;    return InformationTheoryUtil.INSTANCE.bitEntropy(countMap);}
public double metron_f1122_0(Map<?, Integer> counts, double logOfBase)
{    double ret = 0.0;    int n = 0;    if (counts == null || counts.isEmpty()) {        return ret;    }    for (Integer f : counts.values()) {        n += f;    }    for (Integer f : counts.values()) {        double p = f.doubleValue() / n;        ret -= p * Math.log(p) / logOfBase;    }    return ret;}
public double metron_f1123_0(Map<?, Integer> counts, int base)
{    return entropy(counts, Math.log(base));}
public double metron_f1124_0(Map<?, Integer> counts)
{    return entropy(counts, LOG2);}
public void metron_f1125_0(double value)
{    long n1 = n;    min = min == null ? value : Math.min(min, value);    max = max == null ? value : Math.max(max, value);    sum += value;    sumOfLogs += Math.log(value);    sumOfSquares += value * value;    digest.add(value);    n++;    double delta, delta_n, delta_n2, term1;        delta = value - M1;        delta_n = delta / n;    delta_n2 = delta_n * delta_n;    term1 = delta * delta_n * n1;        M1 += delta_n;        M4 += term1 * delta_n2 * (n * n - 3 * n + 3) + 6 * delta_n2 * M2 - 4 * delta_n * M3;    M3 += term1 * delta_n * (n - 2) - 3 * delta_n * M2;    M2 += term1;    checkFlowError(sumOfSquares, sum, sumOfSquares, M1, M2, M3, M4);}
private void metron_f1126_0(double sumOfSquares, double sum, double... vals)
{        for (double val : vals) {        if (Double.isInfinite(val)) {            throw new IllegalStateException("Double overflow!");        }    }        if (sumOfSquares == 0.0 && sum > 0) {        throw new IllegalStateException("Double overflow!");    }}
public long metron_f1127_0()
{    return n;}
public double metron_f1128_0()
{    return min == null ? Double.NaN : min;}
public double metron_f1129_0()
{    return max == null ? Double.NaN : max;}
public double metron_f1130_0()
{    return getSum() / getCount();}
public double metron_f1131_0()
{    return sum;}
public double metron_f1132_0()
{    return M2 / (n - 1.0);}
public double metron_f1133_0()
{    return FastMath.sqrt(getVariance());}
public double metron_f1134_0()
{    throw new UnsupportedOperationException("Unwilling to compute the geometric mean.");}
public double metron_f1135_0()
{    throw new UnsupportedOperationException("Unwilling to compute the geometric mean.");}
public double metron_f1136_0()
{    return FastMath.sqrt(sumOfSquares / n);}
public double metron_f1137_0()
{    return sumOfLogs;}
public double metron_f1138_0()
{    return sumOfSquares;}
public double metron_f1139_0()
{        if (n < 4) {        return Double.NaN;    }    double std = getStandardDeviation();    double t1 = (1.0 * n) * (n + 1) / ((n - 1) * (n - 2) * (n - 3));    double t3 = 3.0 * ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));    return t1 * (M4 / FastMath.pow(std, 4)) - t3;}
public double metron_f1140_0()
{        if (n < 3) {        return Double.NaN;    }    double t1 = (1.0 * n) / ((n - 1) * (n - 2));    double std = getStandardDeviation();    return t1 * M3 / FastMath.pow(std, 3);}
public double metron_f1141_0(double p)
{    return digest.quantile(p / 100.0);}
public StatisticsProvider metron_f1142_0(StatisticsProvider provider)
{    OnlineStatisticsProvider combined = new OnlineStatisticsProvider();    OnlineStatisticsProvider a = this;    OnlineStatisticsProvider b = (OnlineStatisticsProvider) provider;        combined.n = a.n + b.n;    combined.sum = a.sum + b.sum;    if (a.min != null && b.min != null) {        combined.min = Math.min(a.min, b.min);        combined.max = Math.max(a.max, b.max);    } else {        combined.min = a.min;        combined.max = a.max;    }    combined.sumOfSquares = a.sumOfSquares + b.sumOfSquares;    combined.sumOfLogs = a.sumOfLogs + b.sumOfLogs;        double delta = b.M1 - a.M1;    double delta2 = delta * delta;    double delta3 = delta * delta2;    double delta4 = delta2 * delta2;    combined.M1 = (a.n * a.M1 + b.n * b.M1) / combined.n;    combined.M2 = a.M2 + b.M2 + delta2 * a.n * b.n / combined.n;    combined.M3 = a.M3 + b.M3 + delta3 * a.n * b.n * (a.n - b.n) / (combined.n * combined.n);    combined.M3 += 3.0 * delta * (a.n * b.M2 - b.n * a.M2) / combined.n;    combined.M4 = a.M4 + b.M4 + delta4 * a.n * b.n * (a.n * a.n - a.n * b.n + b.n * b.n) / (combined.n * combined.n * combined.n);    combined.M4 += 6.0 * delta2 * (a.n * a.n * b.M2 + b.n * b.n * a.M2) / (combined.n * combined.n) + 4.0 * delta * (a.n * b.M3 - b.n * a.M3) / combined.n;        combined.digest.add(a.digest);    combined.digest.add(b.digest);    checkFlowError(combined.sumOfSquares, sum, combined.sumOfSquares, combined.M1, combined.M2, combined.M3, combined.M4);    return combined;}
public boolean metron_f1143_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    OnlineStatisticsProvider that = (OnlineStatisticsProvider) o;    if (n != that.n)        return false;    if (Double.compare(that.sum, sum) != 0)        return false;    if (Double.compare(that.sumOfSquares, sumOfSquares) != 0)        return false;    if (Double.compare(that.sumOfLogs, sumOfLogs) != 0)        return false;    if (Double.compare(that.M1, M1) != 0)        return false;    if (Double.compare(that.M2, M2) != 0)        return false;    if (Double.compare(that.M3, M3) != 0)        return false;    if (Double.compare(that.M4, M4) != 0)        return false;    if (digest != null ? !digest.equals(that.digest) : that.digest != null)        return false;    if (min != null ? !min.equals(that.min) : that.min != null)        return false;    return max != null ? max.equals(that.max) : that.max == null;}
public int metron_f1144_0()
{    int result;    long temp;    result = digest != null ? digest.hashCode() : 0;    result = 31 * result + (int) (n ^ (n >>> 32));    temp = Double.doubleToLongBits(sum);    result = 31 * result + (int) (temp ^ (temp >>> 32));    temp = Double.doubleToLongBits(sumOfSquares);    result = 31 * result + (int) (temp ^ (temp >>> 32));    temp = Double.doubleToLongBits(sumOfLogs);    result = 31 * result + (int) (temp ^ (temp >>> 32));    result = 31 * result + (min != null ? min.hashCode() : 0);    result = 31 * result + (max != null ? max.hashCode() : 0);    temp = Double.doubleToLongBits(M1);    result = 31 * result + (int) (temp ^ (temp >>> 32));    temp = Double.doubleToLongBits(M2);    result = 31 * result + (int) (temp ^ (temp >>> 32));    temp = Double.doubleToLongBits(M3);    result = 31 * result + (int) (temp ^ (temp >>> 32));    temp = Double.doubleToLongBits(M4);    result = 31 * result + (int) (temp ^ (temp >>> 32));    return result;}
public void metron_f1145_0(Kryo kryo, Output output)
{        ByteBuffer outBuffer = ByteBuffer.allocate(digest.byteSize());    digest.asBytes(outBuffer);    byte[] tdigestSerialized = outBuffer.array();    output.writeInt(tdigestSerialized.length);    output.writeBytes(tdigestSerialized);    output.writeLong(n);    output.writeDouble(sum);    output.writeDouble(sumOfSquares);    output.writeDouble(sumOfLogs);    output.writeDouble(getMin());    output.writeDouble(getMax());    output.writeDouble(M1);    output.writeDouble(M2);    output.writeDouble(M3);    output.writeDouble(M4);}
public void metron_f1146_0(Kryo kryo, Input input)
{    int digestSize = input.readInt();    byte[] digestBytes = input.readBytes(digestSize);    ByteBuffer digestBuff = ByteBuffer.wrap(digestBytes);    digest = AVLTreeDigest.fromBytes(digestBuff);    n = input.readLong();    sum = input.readDouble();    sumOfSquares = input.readDouble();    sumOfLogs = input.readDouble();    min = input.readDouble();    max = input.readDouble();    M1 = input.readDouble();    M2 = input.readDouble();    M3 = input.readDouble();    M4 = input.readDouble();}
public void metron_f1147_0(Double d)
{    if (!Double.isNaN(d)) {        tickMedianProvider.addValue(d);        double deviation = Math.abs(d - windowMedianProvider.getPercentile(50));        windowMedianProvider.addValue(d);        if (!Double.isNaN(deviation)) {            windowMADProvider.addValue(deviation);            tickMADProvider.addValue(deviation);        }    }}
public Object metron_f1148_0(List<Object> args, Context context) throws ParseException
{    State state = null;    @SuppressWarnings("unchecked")    List<State> states = (List<State>) args.get(0);    State currentState = null;    if (args.size() > 1) {        currentState = (State) args.get(1);    }    state = new State(Optional.ofNullable(states), Optional.ofNullable(currentState));    return state;}
public void metron_f1149_0(Context context)
{}
public boolean metron_f1150_0()
{    return true;}
public Object metron_f1151_0(List<Object> args, Context context) throws ParseException
{    State state = (State) args.get(0);    Object o = args.get(1);    List<Double> data = new ArrayList<>();    if (o != null) {        if (o instanceof List) {            @SuppressWarnings("unchecked")            List<Object> oList = (List<Object>) o;            for (Object datum : oList) {                Number n = (Number) datum;                data.add(n.doubleValue());            }        } else {            Number n = (Number) o;            data.add(n.doubleValue());        }    }    if (state != null) {        for (Double d : data) {            state.add(d);        }    }    return state;}
public void metron_f1152_0(Context context)
{}
public boolean metron_f1153_0()
{    return true;}
public Object metron_f1154_0(List<Object> args, Context context) throws ParseException
{    double scale = 0.6745;    State state = (State) args.get(0);    Number datum = (Number) args.get(1);    if (args.size() > 2) {        Number scaleNum = (Number) args.get(2);        if (scaleNum != null) {            scale = scaleNum.doubleValue();        }    }    if (datum == null || state == null) {        return Double.NaN;    }    double deviation = Math.abs(datum.doubleValue() - state.windowMedianProvider.getPercentile(50));    double medianAbsoluteDeviation = state.windowMADProvider.getPercentile(50);    double modifiedZScore = scale * deviation / medianAbsoluteDeviation;    return modifiedZScore;}
public void metron_f1155_0(Context context)
{}
public boolean metron_f1156_0()
{    return true;}
 void metron_f1157_0(Iterable<? extends Object> vals)
{    if (vals == null) {        return;    }    for (Object o : vals) {        add(o);    }}
public Sampler metron_f1158_0(Iterable<Sampler> samplers, Optional<Sampler> baseSampler)
{    if (Iterables.isEmpty(samplers)) {        return null;    }    Sampler ret = baseSampler.orElse(Iterables.getFirst(samplers, null).cloneEmpty());    for (Sampler s : samplers) {        ret.addAll(s.get());    }    return ret;}
public Object metron_f1159_0(List<Object> args, Context context) throws ParseException
{    if (args.size() == 0) {        return new UniformSampler();    } else {        Optional<Integer> sizeArg = get(args, 0, "Size", Integer.class);        if (sizeArg.isPresent() && sizeArg.get() <= 0) {            throw new IllegalStateException("Size must be a positive integer");        } else {            return new UniformSampler(sizeArg.orElse(Sampler.DEFAULT_SIZE));        }    }}
public void metron_f1160_0(Context context)
{}
public boolean metron_f1161_0()
{    return true;}
public static Optional<T> metron_f1162_0(List<Object> args, int offset, String argName, Class<T> expectedClazz)
{    Object obj = args.get(offset);    T ret = ConversionUtils.convert(obj, expectedClazz);    if (ret == null) {        if (obj != null) {            throw new IllegalStateException(argName + "argument(" + obj + " is expected to be an " + expectedClazz.getName() + ", but was " + obj);        }    }    return Optional.ofNullable(ret);}
public Object metron_f1163_0(List<Object> args, Context context) throws ParseException
{    if (args.size() == 0) {        return null;    }    Sampler s = null;    Object sObj = args.get(0);    if (sObj == null) {        return null;    } else if (sObj instanceof Sampler) {        s = (Sampler) sObj;    } else {        throw new IllegalStateException("Expected a sampler, but found " + sObj);    }    return s.get();}
public void metron_f1164_0(Context context)
{}
public boolean metron_f1165_0()
{    return true;}
public Object metron_f1166_0(List<Object> args, Context context) throws ParseException
{    if (args.size() == 0) {        return null;    }    if (args.size() < 2) {        throw new IllegalStateException("Expected sampler and value to add");    }    Sampler s = null;    Object sObj = args.get(0);    if (sObj == null) {        s = new UniformSampler();    } else if (sObj instanceof Sampler) {        s = (Sampler) sObj;    } else {        throw new IllegalStateException("Expected a sampler, but found " + sObj);    }    Object valsObj = args.get(1);    if (valsObj == null) {        return s;    } else if (valsObj instanceof Iterable) {        Iterable<Object> vals = (Iterable<Object>) valsObj;        s.addAll(vals);    } else {        s.add(valsObj);    }    return s;}
public void metron_f1167_0(Context context)
{}
public boolean metron_f1168_0()
{    return true;}
public Object metron_f1169_0(List<Object> args, Context context) throws ParseException
{    if (args.size() == 0) {        return null;    }    Object reservoirsObj = args.get(0);    if (reservoirsObj == null) {        return null;    }    if (!(reservoirsObj instanceof Iterable)) {        throw new IllegalStateException("Expected a collection of Samplers");    }    Iterable<Sampler> reservoirs = (Iterable<Sampler>) reservoirsObj;    Sampler baseSampler = null;    if (args.size() > 1) {        Object baseSamplerObj = args.get(1);        if (baseSamplerObj != null) {            if (!(baseSamplerObj instanceof Sampler)) {                throw new IllegalStateException("Expected baseSampler to be a Sampler");            } else {                baseSampler = (Sampler) baseSamplerObj;            }        }    }    return SamplerUtil.INSTANCE.merge(reservoirs, Optional.ofNullable(baseSampler));}
public void metron_f1170_0(Context context)
{}
public boolean metron_f1171_0()
{    return true;}
public Iterable<Object> metron_f1172_0()
{    return reservoir;}
public void metron_f1173_0(Object o)
{    if (o == null) {        return;    }    if (reservoir.size() < size) {        reservoir.add(o);    } else {        int rIndex = rng.nextInt(seen + 1);        if (rIndex < size) {            reservoir.set(rIndex, o);        }    }    seen++;}
public Sampler metron_f1174_0()
{    return new UniformSampler(getSize());}
public int metron_f1175_0()
{    return size;}
public boolean metron_f1176_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    UniformSampler that = (UniformSampler) o;    if (getSize() != that.getSize())        return false;    return reservoir != null ? reservoir.equals(that.reservoir) : that.reservoir == null;}
public int metron_f1177_0()
{    int result = reservoir != null ? reservoir.hashCode() : 0;    result = 31 * result + getSize();    return result;}
private static StatisticsProvider metron_f1178_0(List<Object> args)
{    int windowSize = 0;    if (args.size() > 0 && args.get(0) instanceof Number) {        windowSize = convert(args.get(0), Integer.class);    }    if (windowSize > 0) {        return new WindowedStatisticsProvider(windowSize);    }    return new OnlineStatisticsProvider();}
public Object metron_f1179_0(List<Object> args)
{    if (args.size() > 0) {        Object firstArg = args.get(0);        if (firstArg instanceof List) {            StatisticsProvider ret = null;            for (Object sp : (List) firstArg) {                if (sp instanceof StatisticsProvider) {                    if (ret == null) {                        ret = (StatisticsProvider) sp;                    } else {                        ret = ret.merge((StatisticsProvider) sp);                    }                }            }            return ret;        } else {            return null;        }    }    return null;}
public Object metron_f1180_0(List<Object> args)
{    return statsInit(args);}
public Object metron_f1181_0(List<Object> args)
{        StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    if (stats == null) {        stats = statsInit(Collections.emptyList());    }        for (int i = 1; i < args.size(); i++) {        Object n = args.get(i);        if (n != null) {            if (n instanceof Iterable) {                for (Object num : (Iterable<Object>) n) {                    if (num != null) {                        Double value = convert(num, Double.class);                        stats.addValue(value);                    }                }            } else {                Double value = convert(args.get(i), Double.class);                stats.addValue(value);            }        }    }    return stats;}
public Object metron_f1182_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getMean() : Double.NaN;}
public Object metron_f1183_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getGeometricMean() : Double.NaN;}
public Object metron_f1184_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getSum() : Double.NaN;}
public Object metron_f1185_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getMax() : Double.NaN;}
public Object metron_f1186_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getMin() : Double.NaN;}
public Object metron_f1187_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? convert(stats.getCount(), Double.class) : Double.NaN;}
public Object metron_f1188_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getPopulationVariance() : Double.NaN;}
public Object metron_f1189_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getVariance() : Double.NaN;}
public Object metron_f1190_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getQuadraticMean() : Double.NaN;}
public Object metron_f1191_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getStandardDeviation() : Double.NaN;}
public Object metron_f1192_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getSumLogs() : Double.NaN;}
public Object metron_f1193_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getSumSquares() : Double.NaN;}
public Object metron_f1194_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getKurtosis() : Double.NaN;}
public Object metron_f1195_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    return (stats != null) ? stats.getSkewness() : Double.NaN;}
public Object metron_f1196_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    Double p = convert(args.get(1), Double.class);    Double result;    if (stats == null || p == null) {        result = Double.NaN;    } else {        result = stats.getPercentile(p);    }    return result;}
public static List<Number> metron_f1197_0(Object o)
{    if (o instanceof String) {        return BinSplits.valueOf((String) o).split;    } else if (o instanceof List) {        return ConversionUtils.convert(o, List.class);    }    throw new IllegalStateException("The split you tried to pass is not a valid split: " + o.toString());}
public Object metron_f1198_0(List<Object> args)
{    StatisticsProvider stats = convert(args.get(0), StatisticsProvider.class);    Double value = convert(args.get(1), Double.class);    final List<Number> bins = args.size() > 2 ? BinSplits.getSplit(args.get(2)) : BinSplits.QUARTILE.split;    if (stats == null || value == null || bins.size() == 0) {        return -1;    }    return BinFunctions.Bin.getBin(value, bins.size(), bin -> stats.getPercentile(bins.get(bin).doubleValue()));}
public void metron_f1199_0(double value)
{    descStats.addValue(value);}
public long metron_f1200_0()
{    return descStats.getN();}
public double metron_f1201_0()
{    return descStats.getMin();}
public double metron_f1202_0()
{    return descStats.getMax();}
public double metron_f1203_0()
{    return descStats.getMean();}
public double metron_f1204_0()
{    return descStats.getSum();}
public double metron_f1205_0()
{    return descStats.getVariance();}
public double metron_f1206_0()
{    return descStats.getStandardDeviation();}
public double metron_f1207_0()
{    return descStats.getGeometricMean();}
public double metron_f1208_0()
{    return descStats.getPopulationVariance();}
public double metron_f1209_0()
{    return descStats.getQuadraticMean();}
public double metron_f1210_0()
{    throw new UnsupportedOperationException("sum logs not available if 'windowSize' > 0");}
public double metron_f1211_0()
{    return descStats.getSumsq();}
public double metron_f1212_0()
{    return descStats.getKurtosis();}
public double metron_f1213_0()
{    return descStats.getSkewness();}
public double metron_f1214_0(double p)
{    return descStats.getPercentile(p);}
public StatisticsProvider metron_f1215_0(StatisticsProvider provider)
{    throw new UnsupportedOperationException("Windowed Statistics cannot be merged.");}
public boolean metron_f1216_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    WindowedStatisticsProvider that = (WindowedStatisticsProvider) o;    return descStats != null ? descStats.equals(that.descStats) : that.descStats == null;}
public int metron_f1217_0()
{    return descStats != null ? descStats.hashCode() : 0;}
public void metron_f1218_0()
{    Long estimate = (Long) StellarProcessorUtils.run(hllpDefaultConstructorRule, values);    Assert.assertThat("Incorrect cardinality returned", estimate, equalTo(2L));}
public void metron_f1219_0()
{    Long estimate = (Long) StellarProcessorUtils.run(hllpBasicRule, values);    Assert.assertThat("Incorrect cardinality returned", estimate, equalTo(2L));}
public void metron_f1220_0()
{    Long estimate = (Long) StellarProcessorUtils.run(hllpMultipleAddItems, values);    Assert.assertThat("Incorrect cardinality returned", estimate, equalTo(4L));}
public void metron_f1221_0()
{    Long estimate = (Long) StellarProcessorUtils.run(hllpMergeRule, values);    Assert.assertThat("Incorrect cardinality returned", estimate, equalTo(4L));}
public void metron_f1222_0()
{    Long estimate = (Long) StellarProcessorUtils.run(zeroCardinalityRule, values);    Assert.assertThat("Incorrect cardinality returned", estimate, equalTo(0L));}
public void metron_f1223_0()
{    HyperLogLogPlus hllp = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of());    Assert.assertThat(hllp.getSp(), equalTo(25));    Assert.assertThat(hllp.getP(), equalTo(14));    Assert.assertThat("instance types should match for constructor with default precision values", new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5)), instanceOf(HyperLogLogPlus.class));    Assert.assertThat("instance types should match for constructor with sparse set disabled", new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5)), instanceOf(HyperLogLogPlus.class));    Assert.assertThat("instance types should match for full constructor", new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6)), instanceOf(HyperLogLogPlus.class));}
public void metron_f1224_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage("Unable to get p value from 'turkey'");    new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of("turkey"));}
public void metron_f1225_0()
{    HyperLogLogPlus actual = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6));    actual = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(actual, "item-1"));    actual = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(actual, "item-2"));    HyperLogLogPlus expected = new HyperLogLogPlus(5, 6);    expected.add("item-1");    expected.add("item-2");    Assert.assertThat("hllp set should have cardinality based on added values", actual.cardinality(), equalTo(2L));    Assert.assertThat("estimators should be equal", actual, equalTo(expected));}
public void metron_f1226_0()
{    HyperLogLogPlus actual = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(Arrays.asList(null, "item-1"));    Assert.assertThat(actual, notNullValue());}
public void metron_f1227_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage("Must pass an hllp estimator set and at least one value to add to the set");    new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6))));}
public void metron_f1228_0()
{    HyperLogLogPlus hllp = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6));    hllp = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp, "item-1"));    hllp = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp, "item-2"));    hllp = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp, "item-3"));    Assert.assertThat("cardinality not expected value", new HyperLogLogPlusFunctions.HLLPCardinality().apply(ImmutableList.of(hllp)), equalTo(3L));}
public void metron_f1229_0()
{    List nullArg = new ArrayList() {        {            add(null);        }    };    Assert.assertThat("Cardinality should be 0", new HyperLogLogPlusFunctions.HLLPCardinality().apply(nullArg), equalTo(0L));}
public void metron_f1230_0()
{    HyperLogLogPlus hllp1 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6));    hllp1 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp1, "item-1"));    hllp1 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp1, "item-2"));    HyperLogLogPlus hllp2 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6));    hllp2 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp2, "item-3"));    HyperLogLogPlus merged = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPMerge().apply(ImmutableList.of(ImmutableList.of(hllp1, hllp2)));    Long actual = (Long) new HyperLogLogPlusFunctions.HLLPCardinality().apply(ImmutableList.of(merged));    Assert.assertThat("cardinality should match merged set", actual, equalTo(3L));    HyperLogLogPlus hllp3 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6));    hllp3 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp3, "item-4"));    merged = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPMerge().apply(ImmutableList.of(ImmutableList.of(hllp1, hllp2, hllp3)));    actual = (Long) new HyperLogLogPlusFunctions.HLLPCardinality().apply(ImmutableList.of(merged));    Assert.assertThat("cardinality should match merged set", actual, equalTo(4L));}
public void metron_f1231_0()
{    HyperLogLogPlus hllp1 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of(5, 6));    hllp1 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp1, "item-1"));    hllp1 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPAdd().apply(ImmutableList.of(hllp1, "item-2"));    HyperLogLogPlus merged = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPMerge().apply(ImmutableList.of(hllp1));    Long actual = (Long) new HyperLogLogPlusFunctions.HLLPCardinality().apply(ImmutableList.of(merged));    Assert.assertThat("cardinality should match merged set", actual, equalTo(2L));}
public void metron_f1232_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage("Must pass single list of hllp sets to merge");    new HyperLogLogPlusFunctions.HLLPMerge().apply(ImmutableList.of());}
public void metron_f1233_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage("Must pass single list of hllp sets to merge");    HyperLogLogPlus hllp1 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of());    HyperLogLogPlus hllp2 = (HyperLogLogPlus) new HyperLogLogPlusFunctions.HLLPInit().apply(ImmutableList.of());    new HyperLogLogPlusFunctions.HLLPMerge().apply(ImmutableList.of(hllp1, hllp2));}
public void metron_f1234_0()
{    List emptyList = ImmutableList.of();    Assert.assertThat("Should be empty list", new HyperLogLogPlusFunctions.HLLPMerge().apply(ImmutableList.of(emptyList)), equalTo(null));}
public static Object metron_f1235_0(String rule, Map<String, Object> variables)
{    Context context = Context.EMPTY_CONTEXT();    StellarProcessor processor = new StellarProcessor();    Assert.assertTrue(rule + " not valid.", processor.validate(rule, context));    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f1236_0()
{    Assert.assertEquals(run("BIN(value, bounds)", ImmutableMap.of("value", 0, "bounds", ImmutableList.of(10, 20, 30))), 0);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 0)), 0);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 9)), 0);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 10)), 0);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 11)), 1);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 19)), 1);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 21)), 2);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 29)), 2);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 31)), 3);    Assert.assertEquals(run("BIN(value, [ 10, 20, 30 ])", ImmutableMap.of("value", 1000)), 3);}
public void metron_f1237_0() throws Exception
{        Assert.assertEquals(0.0, (Double) run("IT_ENTROPY({})", new HashMap<>()), 0.0);    /*    Now consider the string aaaaaaaaaabbbbbccccc or 10 a's followed by 5 b's and 5 c's.    The probabilities of each character is as follows:    p(a) = 1/2    p(b) = 1/4    p(c) = 1/4    so the shannon entropy should be      -p(a)*log_2(p(a)) - p(b)*log_2(p(b)) - p(c)*log_2(p(c)) =      -0.5*-1 - 0.25*-2 - 0.25*-2 = 1.5     */    Assert.assertEquals(1.5, (Double) run("IT_ENTROPY({ 'a' : 10, 'b' : 5, 'c' : 5} )", new HashMap<>()), 0.0);}
public static void metron_f1238_0(StatisticsProvider statsProvider, SummaryStatistics summaryStats, DescriptiveStatistics stats)
{        Assert.assertEquals(statsProvider.getCount(), stats.getN());        Assert.assertEquals(statsProvider.getSum(), stats.getSum(), 1e-3);        Assert.assertEquals(statsProvider.getSumSquares(), stats.getSumsq(), 1e-3);        Assert.assertEquals(statsProvider.getSumLogs(), summaryStats.getSumOfLogs(), 1e-3);        Assert.assertEquals(statsProvider.getMean(), stats.getMean(), 1e-3);        Assert.assertEquals(statsProvider.getQuadraticMean(), summaryStats.getQuadraticMean(), 1e-3);        Assert.assertEquals(statsProvider.getStandardDeviation(), stats.getStandardDeviation(), 1e-3);        Assert.assertEquals(statsProvider.getVariance(), stats.getVariance(), 1e-3);        Assert.assertEquals(statsProvider.getMin(), stats.getMin(), 1e-3);        Assert.assertEquals(statsProvider.getMax(), stats.getMax(), 1e-3);        Assert.assertEquals(stats.getKurtosis(), statsProvider.getKurtosis(), 1e-3);        Assert.assertEquals(stats.getSkewness(), statsProvider.getSkewness(), 1e-3);    for (double d = 10.0; d < 100.0; d += 10) {                Assert.assertEquals("Percentile mismatch for " + d + "th %ile", statsProvider.getPercentile(d), stats.getPercentile(d), 1e-2);    }}
private void metron_f1239_0(Iterable<Double> values)
{    DescriptiveStatistics stats = new DescriptiveStatistics();    SummaryStatistics summaryStats = new SummaryStatistics();    OnlineStatisticsProvider statsProvider = new OnlineStatisticsProvider();        List<OnlineStatisticsProvider> providers = new ArrayList<>();    for (int i = 0; i < 10; ++i) {        providers.add(new OnlineStatisticsProvider());    }    int i = 0;    for (double d : values) {        i++;        stats.addValue(d);        summaryStats.addValue(d);        providers.get(i % providers.size()).addValue(d);        statsProvider.addValue(d);    }    StatisticsProvider aggregatedProvider = providers.get(0);    for (int j = 1; j < providers.size(); ++j) {        aggregatedProvider = aggregatedProvider.merge(providers.get(j));    }    validateStatisticsProvider(statsProvider, summaryStats, stats);    validateStatisticsProvider(aggregatedProvider, summaryStats, stats);}
public void metron_f1240_0()
{    OnlineStatisticsProvider statsProvider = new OnlineStatisticsProvider();    statsProvider.addValue(Double.MAX_VALUE + 1);}
public void metron_f1241_0()
{    OnlineStatisticsProvider statsProvider = new OnlineStatisticsProvider();    double d = 3e-305;    for (int i = 0; i < 5; ++i, d /= 100000) {        statsProvider.addValue(d);    }}
public void metron_f1242_0()
{    List<Double> values = new ArrayList<>();    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(0L));    for (int i = 0; i < 1000000; ++i) {        double d = gaussian.nextNormalizedDouble();        values.add(d);    }    validateEquality(values);}
public void metron_f1243_0()
{    List<Double> values = new ArrayList<>();    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(0L));    for (int i = 0; i < 1000000; ++i) {        double d = gaussian.nextNormalizedDouble() + 10;        values.add(d);    }    validateEquality(values);}
public void metron_f1244_0()
{    List<Double> values = new ArrayList<>();    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(0L));    for (int i = 0; i < 1000000; ++i) {        double d = gaussian.nextNormalizedDouble() - 10;        values.add(d);    }    validateEquality(values);}
public void metron_f1245_0()
{    List<Double> values = new ArrayList<>();    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(0L));    for (int i = 0; i < 1000000; ++i) {        double d = (gaussian.nextNormalizedDouble() + 10000) / 1000;        values.add(d);    }    validateEquality(values);}
public void metron_f1246_0()
{    List<Double> values = new ArrayList<>();    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(0L));    for (int i = 0; i < 1000000; ++i) {        double d = -1 * gaussian.nextNormalizedDouble();        values.add(d);    }    validateEquality(values);}
public void metron_f1247_0()
{    List<Double> values = new ArrayList<>();    for (int i = 0; i < 100000; ++i) {        double d = Math.random();        values.add(d);    }    validateEquality(values);}
public static Object metron_f1248_0(String rule, Map<String, Object> variables)
{    Context context = Context.EMPTY_CONTEXT();    StellarProcessor processor = new StellarProcessor();    Assert.assertTrue(rule + " not valid.", processor.validate(rule, context));    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
private void metron_f1249_0(MedianAbsoluteDeviationFunctions.State currentState, MedianAbsoluteDeviationFunctions.State clonedState, double value)
{    Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", value));    Double clonedScore = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", clonedState, "value", value));    Assert.assertEquals(score, clonedScore, 1e-6);}
public void metron_f1250_0()
{    MedianAbsoluteDeviationFunctions.State currentState = null;    List<MedianAbsoluteDeviationFunctions.State> states = new ArrayList<>();    currentState = (MedianAbsoluteDeviationFunctions.State) run("OUTLIER_MAD_STATE_MERGE(states, NULL)", ImmutableMap.of("states", states));    for (int i = 0; i < 100; ++i) {        double d = 1.2 * i;        run("OUTLIER_MAD_ADD(currentState, data)", ImmutableMap.of("currentState", currentState, "data", d));    }    byte[] stateBytes = SerDeUtils.toBytes(currentState);    MedianAbsoluteDeviationFunctions.State clonedState = SerDeUtils.fromBytes(stateBytes, MedianAbsoluteDeviationFunctions.State.class);    assertScoreEquals(currentState, clonedState, 0d);    assertScoreEquals(currentState, clonedState, 1d);    assertScoreEquals(currentState, clonedState, 10d);}
public void metron_f1251_0()
{    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(0L));    DescriptiveStatistics stats = new DescriptiveStatistics();    List<MedianAbsoluteDeviationFunctions.State> states = new ArrayList<>();    MedianAbsoluteDeviationFunctions.State currentState = null;        currentState = (MedianAbsoluteDeviationFunctions.State) run("OUTLIER_MAD_STATE_MERGE(states, NULL)", ImmutableMap.of("states", states));    for (int i = 0, j = 0; i < 10000; ++i, ++j) {        Double d = gaussian.nextNormalizedDouble();        stats.addValue(d);        run("OUTLIER_MAD_ADD(currentState, data)", ImmutableMap.of("currentState", currentState, "data", d));        if (j >= 1000) {            j = 0;            List<MedianAbsoluteDeviationFunctions.State> stateWindow = new ArrayList<>();            for (int stateIndex = Math.max(0, states.size() - 5); stateIndex < states.size(); ++stateIndex) {                stateWindow.add(states.get(stateIndex));            }            currentState = (MedianAbsoluteDeviationFunctions.State) run("OUTLIER_MAD_STATE_MERGE(states, currentState)", ImmutableMap.of("states", stateWindow, "currentState", currentState));        }    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMin()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being a minimum.", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMax()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being a maximum", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMean() + 4 * stats.getStandardDeviation()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being 4 std deviations away from the mean", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMean() - 4 * stats.getStandardDeviation()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being 4 std deviations away from the mean", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMean()));        Assert.assertFalse("Score: " + score + " is an outlier despite being the mean", score > 3.5);    }}
public void metron_f1252_0()
{    TDistribution generator = new TDistribution(new MersenneTwister(0L), 100);    DescriptiveStatistics stats = new DescriptiveStatistics();    List<MedianAbsoluteDeviationFunctions.State> states = new ArrayList<>();    MedianAbsoluteDeviationFunctions.State currentState = null;        currentState = (MedianAbsoluteDeviationFunctions.State) run("OUTLIER_MAD_STATE_MERGE(states, NULL)", ImmutableMap.of("states", states));    for (int i = 0, j = 0; i < 10000; ++i, ++j) {        Double d = generator.sample();        stats.addValue(d);        run("OUTLIER_MAD_ADD(currentState, data)", ImmutableMap.of("currentState", currentState, "data", d));        if (j >= 1000) {            j = 0;            List<MedianAbsoluteDeviationFunctions.State> stateWindow = new ArrayList<>();            for (int stateIndex = Math.max(0, states.size() - 5); stateIndex < states.size(); ++stateIndex) {                stateWindow.add(states.get(stateIndex));            }            currentState = (MedianAbsoluteDeviationFunctions.State) run("OUTLIER_MAD_STATE_MERGE(states, currentState)", ImmutableMap.of("states", stateWindow, "currentState", currentState));        }    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMin()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being a minimum.", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMax()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being a maximum", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMean() + 4 * stats.getStandardDeviation()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being 4 std deviations away from the mean", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMean() - 4 * stats.getStandardDeviation()));        Assert.assertTrue("Score: " + score + " is not an outlier despite being 4 std deviations away from the mean", score > 3.5);    }    {        Double score = (Double) run("OUTLIER_MAD_SCORE(currentState, value)", ImmutableMap.of("currentState", currentState, "value", stats.getMean()));        Assert.assertFalse("Score: " + score + " is an outlier despite being the mean", score > 3.5);    }}
public static void metron_f1253_0()
{    Random rng = new Random(0);    int sampleSize = 1000000;    int numSubSamples = 10;    int subSampleSize = sampleSize / numSubSamples;    int currSample = -1;    for (int i = 0, j = 0; i < sampleSize; ++i, j = (j + 1) % subSampleSize) {        double us = 10 * rng.nextDouble();        sample.add(us);        sampleString.add(us + "");        if (j == 0) {            Sampler s = new UniformSampler(subSampleSize / 10);            samplers.add(s);            currSample++;        }        samplers.get(currSample).add(us);    }}
public void metron_f1254_0() throws Exception
{    String stmt = "SAMPLE_INIT()";    Sampler s = (Sampler) StellarProcessorUtils.run(stmt, new HashMap<>());    Assert.assertEquals(Sampler.DEFAULT_SIZE, s.getSize());}
public void metron_f1255_0() throws Exception
{    String stmt = "SAMPLE_INIT(size)";    Sampler s = (Sampler) StellarProcessorUtils.run(stmt, ImmutableMap.of("size", 10));    Assert.assertEquals(10, s.getSize());}
public void metron_f1256_0()
{    String stmt = "SAMPLE_INIT(size)";    Sampler s = (Sampler) StellarProcessorUtils.run(stmt, ImmutableMap.of("size", -10));}
public void metron_f1257_0() throws Exception
{    String stmt = "SAMPLE_GET(SAMPLE_ADD(SAMPLE_INIT(size), values))";    Iterable<? extends Object> s = (Iterable<? extends Object>) StellarProcessorUtils.run(stmt, ImmutableMap.of("size", 10, "values", sample));    Assert.assertEquals(10, Iterables.size(s));    for (Object o : s) {        Assert.assertTrue(o instanceof Double);        Assert.assertTrue(sample.contains(o));    }}
public void metron_f1258_0() throws Exception
{    String stmt = "SAMPLE_ADD(SAMPLE_INIT(size), value)";    Sampler s = (Sampler) StellarProcessorUtils.run(stmt, ImmutableMap.of("size", 10, "value", "blah"));    Assert.assertEquals(10, s.getSize());    Assert.assertTrue(Iterables.getFirst(s.get(), null) instanceof String);}
public void metron_f1259_0() throws Exception
{    String stmt = "SAMPLE_ADD(SAMPLE_INIT(size), value)";    Sampler s = (Sampler) StellarProcessorUtils.run(stmt, ImmutableMap.of("size", 10, "value", sampleString));    Assert.assertEquals(10, s.getSize());    for (Object o : s.get()) {        Assert.assertTrue(o instanceof String);        Assert.assertTrue(sampleString.contains(o));    }}
public void metron_f1260_0() throws Exception
{    Double sampleMean = null;    Double mergedSampleMean = null;    {                String stmt = "STATS_MEAN(STATS_ADD(STATS_INIT(), SAMPLE_GET(SAMPLE_ADD(SAMPLE_INIT(size), values))))";        sampleMean = (Double) StellarProcessorUtils.run(stmt, ImmutableMap.of("size", sample.size() / 10, "values", sample));    }    {                String stmt = "STATS_MEAN(STATS_ADD(STATS_INIT(), SAMPLE_GET(SAMPLE_MERGE(samples))))";        mergedSampleMean = (Double) StellarProcessorUtils.run(stmt, ImmutableMap.of("samples", samplers));    }    Assert.assertEquals(sampleMean, mergedSampleMean, .1);    {                String stmt = "SAMPLE_MERGE(samples, SAMPLE_INIT(10))";        Sampler s = (Sampler) StellarProcessorUtils.run(stmt, ImmutableMap.of("samples", samplers));        Assert.assertEquals(10, s.getSize());    }}
public static void metron_f1261_0()
{    Random rng = new Random(0);    GaussianRandomGenerator gen = new GaussianRandomGenerator(new MersenneTwister(0));    for (int i = 0; i < SAMPLE_SIZE; ++i) {        double us = 10 * rng.nextDouble();        uniformSample.add(us);        uniformStats.addValue(us);        double gs = 10 * gen.nextNormalizedDouble();        gaussianSample.add(gs);        gaussianStats.addValue(gs);    }}
public void metron_f1262_0()
{    Sampler s = new UniformSampler(SAMPLE_SIZE / 10);    s.addAll(uniformSample);    validateDistribution(s, uniformStats);}
public void metron_f1263_0()
{    Sampler s = new UniformSampler(SAMPLE_SIZE / 10);    s.addAll(gaussianSample);    validateDistribution(s, gaussianStats);}
public void metron_f1264_0(Sampler sample, DescriptiveStatistics distribution)
{    DescriptiveStatistics s = new DescriptiveStatistics();    for (Object d : sample.get()) {        s.addValue((Double) d);    }    Assert.assertEquals(s.getMean(), distribution.getMean(), .1);    Assert.assertEquals(s.getStandardDeviation(), distribution.getStandardDeviation(), .1);}
public void metron_f1265_0()
{    Iterable<Sampler> subsamples = getSubsamples(uniformSample);    Sampler s = SamplerUtil.INSTANCE.merge(subsamples, Optional.empty());    validateDistribution(s, uniformStats);}
public void metron_f1266_0()
{    UniformSampler sampler = new UniformSampler(10);    Iterable<Sampler> subsamples = getSubsamples(uniformSample);    Sampler s = SamplerUtil.INSTANCE.merge(subsamples, Optional.of(sampler));    Assert.assertEquals(s.getSize(), 10);}
public void metron_f1267_0()
{    Iterable<Sampler> subsamples = getSubsamples(gaussianSample);    Sampler s = SamplerUtil.INSTANCE.merge(subsamples, Optional.empty());    validateDistribution(s, gaussianStats);}
public Iterable<Sampler> metron_f1268_0(List<Double> sample)
{    int numSamplers = 20;    int numSamplesPerSampler = SAMPLE_SIZE / numSamplers;    Sampler[] samplers = new Sampler[numSamplers];    int j = 0;    for (int i = 0; i < numSamplers; ++i) {        samplers[i] = new UniformSampler(numSamplesPerSampler / 10);        for (; j < (i + 1) * numSamplesPerSampler && j < sample.size(); ++j) {            samplers[i].add(sample.get(j));        }    }    List<Sampler> ret = new ArrayList<>();    for (int i = 0; i < samplers.length; ++i) {        ret.add(samplers[i]);    }    return ret;}
public static void metron_f1269_0(String... argv)
{    DescriptiveStatistics perfStats = new DescriptiveStatistics();    OnlineStatisticsProvider statsProvider = new OnlineStatisticsProvider();    List<Double> values = new ArrayList<>();    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(0L));    for (int i = 0; i < NUM_DATA_POINTS; ++i) {                double d = 1000 * gaussian.nextNormalizedDouble();        values.add(d);        statsProvider.addValue(d);    }    for (int perfRun = 0; perfRun < NUM_RUNS; ++perfRun) {        StellarStatisticsFunctions.StatsBin bin = new StellarStatisticsFunctions.StatsBin();        long start = System.currentTimeMillis();        Random r = new Random(0);        for (int i = 0; i < TRIALS_PER_RUN; ++i) {                        bin.apply(ImmutableList.of(statsProvider, values.get(r.nextInt(values.size())) - 3.5, PERCENTILES));        }        perfStats.addValue(System.currentTimeMillis() - start);    }    System.out.println("Min/25th/50th/75th/Max Milliseconds: " + perfStats.getMin() + " / " + perfStats.getPercentile(25) + " / " + perfStats.getPercentile(50) + " / " + perfStats.getPercentile(75) + " / " + perfStats.getMax());}
public static Collection<Object[]> metron_f1270_0()
{        return Arrays.asList(new Object[][] { { 0 }, { 100 } });}
private static void metron_f1271_0(Function<StatisticsProvider, Number> func, StatisticsProvider left, StatisticsProvider right)
{    tolerantAssertEquals(func, left, right, null);}
private static void metron_f1272_0(Function<StatisticsProvider, Number> func, StatisticsProvider left, StatisticsProvider right, Double epsilon)
{    try {        Number leftVal = func.apply(left);        Number rightVal = func.apply(left);        if (epsilon != null) {            Assert.assertEquals((double) leftVal, (double) rightVal, epsilon);        } else {            Assert.assertEquals(leftVal, rightVal);        }    } catch (UnsupportedOperationException uoe) {        }}
private static Object metron_f1273_0(String expr, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    Object ret = processor.parse(expr, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());    byte[] raw = SerDeUtils.toBytes(ret);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    if (ret instanceof StatisticsProvider) {        StatisticsProvider left = (StatisticsProvider) ret;        StatisticsProvider right = (StatisticsProvider) actual;                tolerantAssertEquals(prov -> prov.getCount(), left, right);                tolerantAssertEquals(prov -> prov.getSum(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getSumSquares(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getSumLogs(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getMean(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getQuadraticMean(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getStandardDeviation(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getVariance(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getMin(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getMax(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getKurtosis(), left, right, 1e-3);                tolerantAssertEquals(prov -> prov.getSkewness(), left, right, 1e-3);        for (double d = 10.0; d < 100.0; d += 10) {            final double pctile = d;                        tolerantAssertEquals(prov -> prov.getPercentile(pctile), left, right, 1e-2);        }    }    return ret;}
public void metron_f1274_0()
{    variables = new HashMap<>();        values = Arrays.asList(10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0);        stats = new DescriptiveStatistics(1000);    values.stream().forEach(val -> stats.addValue(val));        summaryStats = new SummaryStatistics();    values.stream().forEach(val -> summaryStats.addValue(val));}
private void metron_f1275_0(int windowSize)
{        Object result = run("STATS_INIT(" + windowSize + ")", variables);    assertNotNull(result);    variables.put("stats", result);        values.stream().forEach(val -> run(format("STATS_ADD (stats, %f)", val), variables));}
public void metron_f1276_0() throws Exception
{    run(format("STATS_ADD(STATS_INIT(), %f)", (Double.MAX_VALUE + 1)), new HashMap<>());}
public void metron_f1277_0() throws Exception
{    for (int i = 0; i < 20; ++i) {        testMergeProviders();    }}
public void metron_f1278_0() throws Exception
{    List<StatisticsProvider> providers = new ArrayList<>();    /*    Create 10 providers, each with a sample drawn from a gaussian distribution.    Update the reference stats from commons math to ensure we are     */    GaussianRandomGenerator gaussian = new GaussianRandomGenerator(new MersenneTwister(1L));    SummaryStatistics sStatistics = new SummaryStatistics();    DescriptiveStatistics dStatistics = new DescriptiveStatistics();    for (int i = 0; i < 10; ++i) {        List<Double> sample = new ArrayList<>();        for (int j = 0; j < 100; ++j) {            double s = gaussian.nextNormalizedDouble();            sample.add(s);            sStatistics.addValue(s);            dStatistics.addValue(s);        }        StatisticsProvider provider = (StatisticsProvider) run("STATS_ADD(STATS_INIT(), " + Joiner.on(",").join(sample) + ")", new HashMap<>());        providers.add(provider);    }    /*    Merge the providers and validate     */    Map<String, Object> providerVariables = new HashMap<>();    for (int i = 0; i < providers.size(); ++i) {        providerVariables.put("provider_" + i, providers.get(i));    }    StatisticsProvider mergedProvider = (StatisticsProvider) run("STATS_MERGE([" + Joiner.on(",").join(providerVariables.keySet()) + "])", providerVariables);    OnlineStatisticsProviderTest.validateStatisticsProvider(mergedProvider, sStatistics, dStatistics);}
public void metron_f1279_0() throws Exception
{    statsInit(windowSize);    Object result = run("STATS_COUNT(stats)", variables);    double countAtStart = (double) result;    run("STATS_ADD(stats, [10, 20, 30, 40, 50])", variables);    Object actual = run("STATS_COUNT(stats)", variables);    assertEquals(countAtStart + 5.0, (double) actual, 0.1);}
public void metron_f1280_0() throws Exception
{    statsInit(windowSize);    Object result = run("STATS_COUNT(stats)", variables);    double countAtStart = (double) result;    run("STATS_ADD(stats, 10, 20, 30, 40, 50)", variables);    Object actual = run("STATS_COUNT(stats)", variables);    assertEquals(countAtStart + 5.0, (double) actual, 0.1);}
public void metron_f1281_0() throws Exception
{    statsInit(windowSize);    Object result = run("STATS_COUNT(stats)", variables);    double countAtStart = (double) result;    run("STATS_ADD(stats, [10.0, 20.0, 30.0, 40.0, 50.0, null])", variables);    Object actual = run("STATS_COUNT(stats)", variables);    assertEquals(countAtStart + 5.0, (double) actual, 0.1);}
public void metron_f1282_0() throws Exception
{    statsInit(windowSize);    Object result = run("STATS_COUNT(stats)", variables);    double countAtStart = (double) result;    run("STATS_ADD(stats, 10.0, 20.0, 30.0, 40.0, 50.0)", variables);    Object actual = run("STATS_COUNT(stats)", variables);    assertEquals(countAtStart + 5.0, (double) actual, 0.1);}
public void metron_f1283_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_COUNT(stats)", variables);    assertEquals(stats.getN(), (double) actual, 0.1);}
public void metron_f1284_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_MEAN(stats)", variables);    assertEquals(stats.getMean(), (Double) actual, 0.1);}
public void metron_f1285_0() throws Exception
{    if (windowSize > 0) {        statsInit(windowSize);        Object actual = run("STATS_GEOMETRIC_MEAN(stats)", variables);        assertEquals(stats.getGeometricMean(), (Double) actual, 0.1);    }}
public void metron_f1286_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_MAX(stats)", variables);    assertEquals(stats.getMax(), (Double) actual, 0.1);}
public void metron_f1287_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_MIN(stats)", variables);    assertEquals(stats.getMin(), (Double) actual, 0.1);}
public void metron_f1288_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_SUM(stats)", variables);    assertEquals(stats.getSum(), (Double) actual, 0.1);}
public void metron_f1289_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_SD(stats)", variables);    assertEquals(stats.getStandardDeviation(), (Double) actual, 0.1);}
public void metron_f1290_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_VARIANCE(stats)", variables);    assertEquals(stats.getVariance(), (Double) actual, 0.1);}
public void metron_f1291_0() throws Exception
{    if (windowSize > 0) {        statsInit(windowSize);        Object actual = run("STATS_POPULATION_VARIANCE(stats)", variables);        assertEquals(stats.getPopulationVariance(), (Double) actual, 0.1);    }}
public void metron_f1292_0() throws Exception
{    if (windowSize > 0) {        statsInit(windowSize);        Object actual = run("STATS_QUADRATIC_MEAN(stats)", variables);        assertEquals(stats.getQuadraticMean(), (Double) actual, 0.1);    }}
public void metron_f1293_0() throws Exception
{    statsInit(0);    Object actual = run("STATS_SUM_LOGS(stats)", variables);    assertEquals(summaryStats.getSumOfLogs(), (Double) actual, 0.1);}
public void metron_f1294_0() throws Exception
{    statsInit(100);    run("STATS_SUM_LOGS(stats)", variables);}
public void metron_f1295_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_SUM_SQUARES(stats)", variables);    assertEquals(stats.getSumsq(), (Double) actual, 0.1);}
public void metron_f1296_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_KURTOSIS(stats)", variables);    assertEquals(stats.getKurtosis(), (Double) actual, 0.1);}
public void metron_f1297_0() throws Exception
{    statsInit(windowSize);    Object actual = run("STATS_SKEWNESS(stats)", variables);    assertEquals(stats.getSkewness(), (Double) actual, 0.1);}
public void metron_f1298_0() throws Exception
{    statsInit(windowSize);    statsBinRunner(StellarStatisticsFunctions.StatsBin.BinSplits.QUARTILE.split);    statsBinRunner(StellarStatisticsFunctions.StatsBin.BinSplits.QUARTILE.split, "'QUARTILE'");    statsBinRunner(StellarStatisticsFunctions.StatsBin.BinSplits.QUINTILE.split, "'QUINTILE'");    statsBinRunner(StellarStatisticsFunctions.StatsBin.BinSplits.DECILE.split, "'DECILE'");    statsBinRunner(ImmutableList.of(25.0, 50.0, 75.0), "[25.0, 50.0, 75.0]");}
public void metron_f1299_0() throws Exception
{    StatisticsProvider provider = (StatisticsProvider) run("STATS_INIT(" + windowSize + ")", variables);    provider.addValue(10);    variables.put("stats", provider);    Assert.assertEquals(0, run(format("STATS_BIN(stats, %f)", 9.0), variables));    Assert.assertEquals(0, run(format("STATS_BIN(stats, %f)", 10.0), variables));    Assert.assertEquals(3, run(format("STATS_BIN(stats, %f)", 11.0), variables));}
public void metron_f1300_0(List<Number> splits) throws Exception
{    statsBinRunner(splits, null);}
public void metron_f1301_0(List<Number> splits, String splitsName) throws Exception
{    int bin = 0;    StatisticsProvider provider = (StatisticsProvider) variables.get("stats");    for (Double d : stats.getSortedValues()) {        while (bin < splits.size() && d > provider.getPercentile(splits.get(bin).doubleValue())) {                        bin++;        }        Object actual = null;        if (splitsName != null) {            actual = run(format("STATS_BIN(stats, %f, %s)", d, splitsName), variables);        } else {            actual = run(format("STATS_BIN(stats, %f)", d), variables);        }        assertEquals(bin, actual);    }}
public void metron_f1302_0() throws Exception
{    statsInit(0);    final double percentile = 0.9;    Object actual = run(format("STATS_PERCENTILE(stats, %f)", percentile), variables);    assertEquals(stats.getPercentile(percentile), (Double) actual, 1);}
public void metron_f1303_0() throws Exception
{    statsInit(100);    final double percentile = 0.9;    Object actual = run(format("STATS_PERCENTILE(stats, %f)", percentile), variables);    assertEquals(stats.getPercentile(percentile), (Double) actual, 0.1);}
public void metron_f1304_0() throws Exception
{    Object actual = run("STATS_MEAN(null)", variables);    assertTrue(((Double) actual).isNaN());    actual = run("STATS_COUNT(null)", variables);    assertTrue(((Double) actual).isNaN());    actual = run("STATS_VARIANCE(null)", variables);    assertTrue(((Double) actual).isNaN());}
public static void metron_f1305_0(String[] args) throws Exception
{    CommandLine cli = LoadOptions.parse(new PosixParser(), args);    EnumMap<LoadOptions, Optional<Object>> evaluatedArgs = LoadOptions.createConfig(cli);    Map<String, Object> kafkaConfig = new HashMap<>();    kafkaConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());    kafkaConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());    kafkaConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());    kafkaConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());    if (LoadOptions.ZK.has(cli)) {        String zkQuorum = (String) evaluatedArgs.get(LoadOptions.ZK).get();        kafkaConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, Joiner.on(",").join(KafkaUtils.INSTANCE.getBrokersFromZookeeper(zkQuorum)));    }    String groupId = evaluatedArgs.get(LoadOptions.CONSUMER_GROUP).get().toString();    System.out.println("Consumer Group: " + groupId);    kafkaConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);    if (LoadOptions.KAFKA_CONFIG.has(cli)) {        kafkaConfig.putAll((Map<String, Object>) evaluatedArgs.get(LoadOptions.KAFKA_CONFIG).get());    }    kafkaProducer = ThreadLocal.withInitial(() -> new KafkaProducer<>(kafkaConfig));    int numThreads = (int) evaluatedArgs.get(LoadOptions.NUM_THREADS).get();    System.out.println("Thread pool size: " + numThreads);    pool = Executors.newFixedThreadPool(numThreads);    Optional<Object> eps = evaluatedArgs.get(LoadOptions.EPS);    Optional<Object> outputTopic = evaluatedArgs.get(LoadOptions.OUTPUT_TOPIC);    Optional<Object> monitorTopic = evaluatedArgs.get(LoadOptions.MONITOR_TOPIC);    long sendDelta = (long) evaluatedArgs.get(LoadOptions.SEND_DELTA).get();    long monitorDelta = (long) evaluatedArgs.get(LoadOptions.MONITOR_DELTA).get();    if ((eps.isPresent() && outputTopic.isPresent()) || monitorTopic.isPresent()) {        Timer timer = new Timer(false);        long startTimeMs = System.currentTimeMillis();        if (outputTopic.isPresent() && eps.isPresent()) {            List<String> templates = (List<String>) evaluatedArgs.get(LoadOptions.TEMPLATE).get();            if (templates.isEmpty()) {                System.out.println("Empty templates, so nothing to do.");                return;            }            Optional<Object> biases = evaluatedArgs.get(LoadOptions.BIASED_SAMPLE);            Sampler sampler = new UnbiasedSampler();            if (biases.isPresent()) {                sampler = new BiasedSampler((List<Map.Entry<Integer, Integer>>) biases.get(), templates.size());            }            MessageGenerator generator = new MessageGenerator(templates, sampler);            Long targetLoad = (Long) eps.get();            int periodsPerSecond = (int) (1000 / sendDelta);            long messagesPerPeriod = targetLoad / periodsPerSecond;            String outputTopicStr = (String) outputTopic.get();            System.out.println("Generating data to " + outputTopicStr + " at " + targetLoad + " events per second");            System.out.println("Sending " + messagesPerPeriod + " messages to " + outputTopicStr + " every " + sendDelta + "ms");            timer.scheduleAtFixedRate(new SendToKafka(outputTopicStr, messagesPerPeriod, numThreads, generator, pool, numSent, kafkaProducer), 0, sendDelta);        }        List<AbstractMonitor> monitors = new ArrayList<>();        if (outputTopic.isPresent() && monitorTopic.isPresent()) {            System.out.println("Monitoring " + monitorTopic.get() + " every " + monitorDelta + " ms");            monitors.add(new EPSGeneratedMonitor(outputTopic, numSent));            monitors.add(new EPSThroughputWrittenMonitor(monitorTopic, kafkaConfig));        } else if (outputTopic.isPresent() && !monitorTopic.isPresent()) {            System.out.println("Monitoring " + outputTopic.get() + " every " + monitorDelta + " ms");            monitors.add(new EPSGeneratedMonitor(outputTopic, numSent));            monitors.add(new EPSThroughputWrittenMonitor(outputTopic, kafkaConfig));        } else if (!outputTopic.isPresent() && monitorTopic.isPresent()) {            System.out.println("Monitoring " + monitorTopic.get() + " every " + monitorDelta + " ms");            monitors.add(new EPSThroughputWrittenMonitor(monitorTopic, kafkaConfig));        } else if (!outputTopic.isPresent() && !monitorTopic.isPresent()) {            System.out.println("You have not specified an output topic or a monitoring topic, so I have nothing to do here.");        }        int lookback = (int) evaluatedArgs.get(LoadOptions.SUMMARY_LOOKBACK).get();        if (lookback > 0) {            System.out.println("Summarizing over the last " + lookback + " monitoring periods (" + lookback * monitorDelta + "ms)");        } else {            System.out.println("Turning off summarization.");        }        final CSVWriter csvWriter = new CSVWriter((File) evaluatedArgs.get(LoadOptions.CSV).orElse(null));        Writer writer = new Writer(monitors, lookback, new ArrayList<Consumer<Writable>>() {            {                add(new ConsoleWriter());                add(csvWriter);            }        });        timer.scheduleAtFixedRate(new MonitorTask(writer), 0, monitorDelta);        Optional<Object> timeLimit = evaluatedArgs.get(LoadOptions.TIME_LIMIT);        if (timeLimit.isPresent()) {            System.out.println("Ending in " + timeLimit.get() + " ms.");            timer.schedule(new TimerTask() {                @Override                public void run() {                    timer.cancel();                    long durationS = (System.currentTimeMillis() - startTimeMs) / 1000;                    System.out.println("\nGenerated " + numSent.get() + " in " + durationS + " seconds.");                    csvWriter.close();                    System.exit(0);                }            }, (Long) timeLimit.get());        }    }}
public void metron_f1306_0()
{    timer.cancel();    long durationS = (System.currentTimeMillis() - startTimeMs) / 1000;    System.out.println("\nGenerated " + numSent.get() + " in " + durationS + " seconds.");    csvWriter.close();    System.exit(0);}
public Option metron_f1307_0()
{    return option;}
public boolean metron_f1308_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f1309_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public OptionHandler<LoadOptions> metron_f1310_0()
{    return null;}
public static CommandLine metron_f1311_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static EnumMap<LoadOptions, Optional<Object>> metron_f1312_0(CommandLine cli)
{    EnumMap<LoadOptions, Optional<Object>> ret = new EnumMap<>(LoadOptions.class);    for (LoadOptions option : values()) {        ret.put(option, option.handler.getValue(option, cli));    }    return ret;}
public static void metron_f1313_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("Generator", getOptions());}
public static Options metron_f1314_0()
{    Options ret = new Options();    for (LoadOptions o : LoadOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public String metron_f1315_0()
{    return "h";}
public Option metron_f1316_0(@Nullable String s)
{    return new Option(s, "help", false, "Generate Help screen");}
public Option metron_f1317_0(@Nullable String s)
{    Option o = new Option(s, "zk_quorum", true, "zookeeper quorum");    o.setArgName("QUORUM");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1318_0(LoadOptions option, CommandLine cli)
{    if (option.has(cli)) {        return Optional.ofNullable(option.get(cli));    } else {        return Optional.empty();    }}
public String metron_f1319_0()
{    return "z";}
public Option metron_f1320_0(@Nullable String s)
{    Option o = new Option(s, "consumer_group", true, "Consumer Group.  The default is " + LoadGenerator.CONSUMER_GROUP);    o.setArgName("GROUP_ID");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1321_0(LoadOptions option, CommandLine cli)
{    if (option.has(cli)) {        return Optional.ofNullable(option.get(cli));    } else {        return Optional.of(LoadGenerator.CONSUMER_GROUP);    }}
public String metron_f1322_0()
{    return "cg";}
public Option metron_f1323_0(@Nullable String s)
{    Option o = new Option(s, "sample_bias", true, "The discrete distribution to bias the sampling. " + "This is a CSV of 2 columns.  The first column is the % of the templates " + "and the 2nd column is the probability (0-100) that it's chosen.  For instance:\n" + "  20,80\n" + "  80,20\n" + "implies that 20% of the templates will comprise 80% of the output and the remaining 80% of the templates will comprise 20% of the output.");    o.setArgName("BIAS_FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1324_0(LoadOptions option, CommandLine cli)
{    if (!option.has(cli)) {        return Optional.empty();    }    File discreteDistributionFile = new File(option.get(cli));    if (discreteDistributionFile.exists()) {        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(discreteDistributionFile), StandardCharsets.UTF_8))) {            return Optional.ofNullable(BiasedSampler.readDistribution(br));        } catch (IOException e) {            throw new IllegalStateException("Unable to read distribution file: " + option.get(cli), e);        }    } else {        throw new IllegalStateException("Unable to read distribution file: " + option.get(cli) + " file doesn't exist.");    }}
public String metron_f1325_0()
{    return "bs";}
public Option metron_f1326_0(@Nullable String s)
{    Option o = new Option(s, "csv", true, "A CSV file to emit monitoring data to.  " + "The format is a CSV with the following schema: timestamp, (name, eps, historical_mean, historical_stddev)+");    o.setArgName("CSV_FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1327_0(LoadOptions option, CommandLine cli)
{    if (!option.has(cli)) {        return Optional.empty();    }    return Optional.of(new File(option.get(cli)));}
public String metron_f1328_0()
{    return "c";}
public Option metron_f1329_0(@Nullable String s)
{    Option o = new Option(s, "template", true, "The template file to use for generation.  This should be a file with a template per line with $METRON_TS and $METRON_GUID in the spots for timestamp and guid, if you so desire them.");    o.setArgName("TEMPLATE_FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1330_0(LoadOptions option, CommandLine cli)
{    if (!option.has(cli)) {        return Optional.empty();    }    File templateFile = new File(option.get(cli));    if (templateFile.exists()) {        List<String> templates = new ArrayList<>();        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(templateFile), StandardCharsets.UTF_8))) {            for (String line = null; (line = br.readLine()) != null; ) {                templates.add(line);            }            return Optional.of(templates);        } catch (IOException e) {            throw new IllegalStateException("Unable to read template file: " + option.get(cli), e);        }    } else {        throw new IllegalStateException("Unable to read template file: " + option.get(cli) + " file doesn't exist.");    }}
public String metron_f1331_0()
{    return "t";}
public Option metron_f1332_0(@Nullable String s)
{    Option o = new Option(s, "lookback", true, "When summarizing, how many monitoring periods should we summarize over?  If 0, then no summary.  Default: 5");    o.setArgName("LOOKBACK");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1333_0(LoadOptions option, CommandLine cli)
{    if (option.has(cli)) {        return Optional.of(ConversionUtils.convert(option.get(cli), Integer.class));    } else {        return Optional.of(5);    }}
public String metron_f1334_0()
{    return "l";}
public Option metron_f1335_0(@Nullable String s)
{    Option o = new Option(s, "eps", true, "The target events per second");    o.setArgName("EPS");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1336_0(LoadOptions option, CommandLine cli)
{    if (option.has(cli)) {        return Optional.of(ConversionUtils.convert(option.get(cli), Long.class));    } else {        return Optional.empty();    }}
public String metron_f1337_0()
{    return "e";}
public Option metron_f1338_0(@Nullable String s)
{    Option o = new Option(s, "kafka_config", true, "The kafka config.  This is a file containing a JSON map with the kafka config.");    o.setArgName("CONFIG_FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1339_0(LoadOptions option, CommandLine cli)
{    if (!option.has(cli)) {        return Optional.empty();    }    File configFile = new File(option.get(cli));    if (configFile.exists()) {        try {            return Optional.ofNullable(JSONUtils.INSTANCE.load(configFile, JSONUtils.MAP_SUPPLIER));        } catch (FileNotFoundException e) {            throw new IllegalStateException("Unable to read file: " + option.get(cli), e);        } catch (IOException e) {            throw new IllegalStateException("Unable to read file: " + option.get(cli), e);        }    } else {        throw new IllegalStateException("Unable to read file: " + option.get(cli) + " file doesn't exist.");    }}
public String metron_f1340_0()
{    return "k";}
public Option metron_f1341_0(@Nullable String s)
{    Option o = new Option(s, "send_delta_ms", true, "The time (in ms) between sending a batch of messages. Default is " + LoadGenerator.SEND_PERIOD_MS);    o.setArgName("TIME_IN_MS");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1342_0(LoadOptions option, CommandLine cli)
{    if (option.has(cli)) {        Object res = option.get(cli);        return Optional.ofNullable(ConversionUtils.convert(res, Long.class));    }    return Optional.of(LoadGenerator.SEND_PERIOD_MS);}
public String metron_f1343_0()
{    return "sd";}
public Option metron_f1344_0(@Nullable String s)
{    Option o = new Option(s, "monitor_delta_ms", true, "The time (in ms) between monitoring output. Default is " + LoadGenerator.MONITOR_PERIOD_MS);    o.setArgName("TIME_IN_MS");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1345_0(LoadOptions option, CommandLine cli)
{    if (option.has(cli)) {        Object res = option.get(cli);        return Optional.ofNullable(ConversionUtils.convert(res, Long.class));    }    return Optional.of(LoadGenerator.MONITOR_PERIOD_MS);}
public String metron_f1346_0()
{    return "md";}
public Option metron_f1347_0(@Nullable String s)
{    Option o = new Option(s, "time_limit_ms", true, "The total amount of time to run this in milliseconds.  By default, it never stops.");    o.setArgName("MS");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1348_0(LoadOptions option, CommandLine cli)
{    if (option.has(cli)) {        Object res = option.get(cli);        Long timeMs = ConversionUtils.convert(res, Long.class);        return Optional.ofNullable(timeMs);    }    return Optional.empty();}
public String metron_f1349_0()
{    return "tl";}
public Option metron_f1350_0(@Nullable String s)
{    Option o = new Option(s, "threads", true, "The number of threads to use when extracting data.  The default is the number of cores of your machine.");    o.setArgName("NUM_THREADS");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1351_0(LoadOptions option, CommandLine cli)
{    int numThreads = Runtime.getRuntime().availableProcessors();    if (option.has(cli)) {        Object res = option.get(cli);        if (res instanceof String && res.toString().toUpperCase().endsWith("C")) {            numThreads *= ConversionUtils.convert(res.toString().trim().replace("C", ""), Integer.class);        } else {            numThreads = ConversionUtils.convert(res, Integer.class);        }    }    return Optional.of(numThreads);}
public String metron_f1352_0()
{    return "p";}
public Option metron_f1353_0(@Nullable String s)
{    Option o = new Option(s, "output_topic", true, "The kafka topic to write to");    o.setArgName("TOPIC");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1354_0(LoadOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli));}
public String metron_f1355_0()
{    return "ot";}
public Option metron_f1356_0(@Nullable String s)
{    Option o = new Option(s, "monitor_topic", true, "The kafka topic to monitor.");    o.setArgName("TOPIC");    o.setRequired(false);    return o;}
public Optional<Object> metron_f1357_0(LoadOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli));}
public String metron_f1358_0()
{    return "mt";}
public String metron_f1359_0()
{    int sample = sampler.sample(rng.get(), patterns.size());    String pattern = patterns.get(sample);    long guidId = guidOffset.getAndIncrement();    String guid = guidPrefix + guidId;    String ts = "" + System.currentTimeMillis();    return pattern.replace("$METRON_TS", ts).replace("$METRON_GUID", guid);}
public Long metron_f1360_0()
{    long timeStarted = System.currentTimeMillis();    Long ret = null;    if (timestampPrevious > 0) {        double deltaTs = (timeStarted - timestampPrevious) / 1000.0;        if (Math.abs(deltaTs) > EPSILON) {            ret = monitor(deltaTs);        }    }    timestampPrevious = timeStarted;    return ret;}
protected Long metron_f1361_0(double deltaTs)
{    if (kafkaTopic.isPresent()) {        long totalProcessed = numSent.get();        long written = (totalProcessed - numSentPrevious);        long epsWritten = (long) (written / deltaTs);        numSentPrevious = totalProcessed;        return epsWritten;    }    return null;}
public String metron_f1362_0()
{    return "%d eps generated to " + kafkaTopic.get();}
public String metron_f1363_0()
{    return "generated";}
private Long metron_f1364_0(Map<Integer, Long> partitionOffsets, Map<Integer, Long> lastOffsetMap)
{    if (partitionOffsets == null) {        return null;    }    long sum = 0;    for (Map.Entry<Integer, Long> partitionOffset : partitionOffsets.entrySet()) {        sum += partitionOffset.getValue() - lastOffsetMap.get(partitionOffset.getKey());    }    return sum;}
protected Long metron_f1365_0(double deltaTs)
{    Optional<Long> epsWritten = Optional.empty();    if (kafkaTopic.isPresent()) {        if (lastOffsetMap != null) {            Map<Integer, Long> currentOffsets = KafkaUtil.INSTANCE.getKafkaOffsetMap(consumer, (String) kafkaTopic.get());            Long eventsWrittenSince = writtenSince(currentOffsets, lastOffsetMap);            if (eventsWrittenSince != null) {                epsWritten = Optional.of((long) (eventsWrittenSince / deltaTs));            }            lastOffsetMap = currentOffsets == null ? lastOffsetMap : currentOffsets;            if (epsWritten.isPresent()) {                return epsWritten.get();            }        } else {            lastOffsetMap = KafkaUtil.INSTANCE.getKafkaOffsetMap(consumer, (String) kafkaTopic.get());        }    }    return null;}
public String metron_f1366_0()
{    return "%d eps throughput measured for " + kafkaTopic.get();}
public String metron_f1367_0()
{    return "throughput measured";}
public void metron_f1368_0()
{    writer.writeAll();}
public String metron_f1369_0()
{    return name;}
public Long metron_f1370_0()
{    return eps;}
public String metron_f1371_0()
{    return format;}
public Optional<DescriptiveStatistics> metron_f1372_0()
{    return history;}
private String metron_f1373_0(DescriptiveStatistics stats)
{    return String.format("Mean: %d, Std Dev: %d", (int) stats.getMean(), (int) Math.sqrt(stats.getVariance()));}
public void metron_f1374_0(Writable writable)
{    List<String> parts = new ArrayList<>();    Date date = writable.getDate();    for (Results r : writable.getResults()) {        Long eps = r.getEps();        if (eps != null) {            String part = String.format(r.getFormat(), eps);            if (r.getHistory().isPresent()) {                part += " (" + getSummary(r.getHistory().get()) + ")";            }            parts.add(part);        }    }    if (date != null) {        DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");        String header = dateFormat.format(date) + " - ";        String emptyHeader = StringUtils.repeat(" ", header.length());        for (int i = 0; i < parts.size(); ++i) {            String part = parts.get(i);            if (i == 0) {                System.out.println(header + (part == null ? "" : part));            } else {                System.out.println(emptyHeader + (part == null ? "" : part));            }        }    }}
public void metron_f1375_0(Writable writable)
{    if (pw.isPresent()) {        List<String> parts = new ArrayList<>();        parts.add("" + writable.getDate().getTime());        for (Results r : writable.getResults()) {            parts.add(r.getName());            parts.add(r.getEps() == null ? "" : (r.getEps() + ""));            if (r.getHistory().isPresent()) {                parts.add("" + (int) r.getHistory().get().getMean());                parts.add("" + (int) Math.sqrt(r.getHistory().get().getVariance()));            } else {                parts.add("");                parts.add("");            }        }        pw.get().println(Joiner.on(",").join(parts));        pw.get().flush();    }}
public void metron_f1376_0()
{    if (pw.isPresent()) {        pw.get().close();    }}
public Date metron_f1377_0()
{    return date;}
public List<Results> metron_f1378_0()
{    return results;}
public void metron_f1379_0()
{    int i = 0;    Date dateOf = new Date();    List<Results> results = new ArrayList<>();    for (AbstractMonitor m : monitors) {        Long eps = m.get();        if (eps != null && summaryLookback > 0) {            LinkedList<Double> summary = summaries.get(i);            addToLookback(eps.doubleValue(), summary);            results.add(new Results(m.format(), m.name(), eps, Optional.of(getStats(summary))));        } else {            results.add(new Results(m.format(), m.name(), eps, Optional.empty()));        }        i++;    }    Writable writable = new Writable(dateOf, results);    for (Consumer<Writable> writer : writers) {        writer.accept(writable);    }}
private void metron_f1380_0(Double d, LinkedList<Double> lookback)
{    if (lookback.size() >= summaryLookback) {        lookback.removeFirst();    }    lookback.addLast(d);}
public DescriptiveStatistics metron_f1381_0(List<Double> avg)
{    DescriptiveStatistics stats = new DescriptiveStatistics();    for (Double d : avg) {        if (d == null || Double.isNaN(d)) {            continue;        }        stats.addValue(d);    }    return stats;}
public void metron_f1382_0()
{    long numSentCurrent = numSent.get();    long numSentSince = numSentCurrent - numSentLast;    boolean sendMessages = numSentLast == 0 || numSentSince >= numMessagesSent;    if (sendMessages) {        Collection<Future<Long>> futures = Collections.synchronizedList(new ArrayList<>());        for (int batch = 0; batch < numBatches; ++batch) {            try {                futures.add(pool.submit(() -> {                    KafkaProducer<String, String> producer = kafkaProducer.get();                    Collection<Future<?>> b = Collections.synchronizedCollection(new ArrayList<>());                    for (int i = 0; i < batchSize; ++i) {                        b.add(sendToKafka(producer, kafkaTopic, messageSupplier.get()));                    }                    for (Future<?> f : b) {                        f.get();                    }                    return batchSize;                }));            } catch (Exception e) {                e.printStackTrace(System.err);            }        }        for (Future<Long> f : futures) {            try {                f.get();            } catch (Exception e) {                e.printStackTrace(System.err);            }        }        numSentLast = numSentCurrent;    }}
protected Future<?> metron_f1383_0(KafkaProducer<String, String> producer, String kafkaTopic, String message)
{    return producer.send(new ProducerRecord<>(kafkaTopic, message), (recordMetadata, e) -> {        if (e != null) {            e.printStackTrace(System.err);        }        numSent.incrementAndGet();    });}
public static List<Map.Entry<Integer, Integer>> metron_f1384_0(BufferedReader distrFile) throws IOException
{    return readDistribution(distrFile, false);}
public static List<Map.Entry<Integer, Integer>> metron_f1385_0(BufferedReader distrFile, boolean quiet) throws IOException
{    List<Map.Entry<Integer, Integer>> ret = new ArrayList<>();    if (!quiet) {        System.out.println("Using biased sampler with the following biases:");    }    int sumLeft = 0;    int sumRight = 0;    for (String line = null; (line = distrFile.readLine()) != null; ) {        if (line.startsWith("#")) {            continue;        }        Iterable<String> it = Splitter.on(",").split(line.trim());        if (Iterables.size(it) != 2) {            throw new IllegalArgumentException(line + " should be a comma separated pair of integers, but was not.");        }        int left = Integer.parseInt(Iterables.getFirst(it, null));        int right = Integer.parseInt(Iterables.getLast(it, null));        if (left <= 0 || left > 100) {            throw new IllegalArgumentException(line + ": " + (left < 0 ? left : right) + " must a positive integer in (0, 100]");        }        if (right <= 0 || right > 100) {            throw new IllegalArgumentException(line + ": " + right + " must a positive integer in (0, 100]");        }        if (!quiet) {            System.out.println("\t" + left + "% of templates will comprise roughly " + right + "% of sample output");        }        ret.add(new AbstractMap.SimpleEntry<>(left, right));        sumLeft += left;        sumRight += right;    }    if (sumLeft > 100 || sumRight > 100) {        throw new IllegalStateException("Neither columns must sum to beyond 100.  " + "The first column is the % of templates. " + "The second column is the % of the sample that % of template occupies.");    } else if (sumLeft < 100 && sumRight < 100) {        int left = 100 - sumLeft;        int right = 100 - sumRight;        if (!quiet) {            System.out.println("\t" + left + "% of templates will comprise roughly " + right + "% of sample output");        }        ret.add(new AbstractMap.SimpleEntry<>(left, right));    }    return ret;}
private static TreeMap<Double, Map.Entry<Integer, Integer>> metron_f1386_0(List<Map.Entry<Integer, Integer>> discreteDistribution, int max)
{    TreeMap<Double, Map.Entry<Integer, Integer>> ret = new TreeMap<>();    int from = 0;    double weight = 0.0d;    for (Map.Entry<Integer, Integer> kv : discreteDistribution) {        double pctVals = kv.getKey() / 100.0;        int to = from + (int) (max * pctVals);        double pctWeight = kv.getValue() / 100.0;        ret.put(weight, new AbstractMap.SimpleEntry<>(from, to));        weight += pctWeight;        from = to;    }    return ret;}
public int metron_f1387_0(Random rng, int limit)
{    double weight = rng.nextDouble();    Map.Entry<Integer, Integer> range = discreteDistribution.floorEntry(weight).getValue();    return rng.nextInt(range.getValue() - range.getKey()) + range.getKey();}
public int metron_f1388_0(Random rng, int limit)
{    return rng.nextInt(limit);}
public List<TopicPartition> metron_f1389_0(KafkaConsumer<String, String> consumer, String topic)
{    List<PartitionInfo> partitions = consumer.partitionsFor(topic);    List<TopicPartition> ret = new ArrayList<>(partitions.size());    for (PartitionInfo par : partitions) {        ret.add(new TopicPartition(topic, par.partition()));    }    return ret;}
public Map<Integer, Long> metron_f1390_0(KafkaConsumer<String, String> consumer, String topic)
{    Map<Integer, Long> ret = new HashMap<>();    if (!consumer.subscription().contains(topic)) {        consumer.subscribe(Collections.singletonList(topic));    }    consumer.poll(0);    List<TopicPartition> partitions = getTopicPartition(consumer, topic);    consumer.seekToEnd(partitions);    for (TopicPartition par : partitions) {        ret.put(par.partition(), consumer.position(par) - 1);    }    return ret;}
public void metron_f1391_0() throws Exception
{    CommandLine cli = LoadOptions.parse(new PosixParser(), new String[] { "-eps", "1000", "-ot", "foo" });    EnumMap<LoadOptions, Optional<Object>> results = LoadOptions.createConfig(cli);    Assert.assertEquals(1000L, results.get(LoadOptions.EPS).get());    Assert.assertEquals("foo", results.get(LoadOptions.OUTPUT_TOPIC).get());    Assert.assertEquals(LoadGenerator.CONSUMER_GROUP, results.get(LoadOptions.CONSUMER_GROUP).get());    Assert.assertEquals(Runtime.getRuntime().availableProcessors(), results.get(LoadOptions.NUM_THREADS).get());    Assert.assertFalse(results.get(LoadOptions.BIASED_SAMPLE).isPresent());    Assert.assertFalse(results.get(LoadOptions.CSV).isPresent());}
public void metron_f1392_0() throws Exception
{    CommandLine cli = LoadOptions.parse(new PosixParser(), new String[] { "-c", "/tmp/blah" });    EnumMap<LoadOptions, Optional<Object>> results = LoadOptions.createConfig(cli);    Assert.assertEquals(new File("/tmp/blah"), results.get(LoadOptions.CSV).get());}
public void metron_f1393_0() throws Exception
{    CommandLine cli = LoadOptions.parse(new PosixParser(), new String[] {});    EnumMap<LoadOptions, Optional<Object>> results = LoadOptions.createConfig(cli);    Assert.assertFalse(results.get(LoadOptions.CSV).isPresent());}
public void metron_f1394_0() throws Exception
{    CommandLine cli = LoadOptions.parse(new PosixParser(), new String[] { "-p", "2C" });    EnumMap<LoadOptions, Optional<Object>> results = LoadOptions.createConfig(cli);    Assert.assertEquals(2 * Runtime.getRuntime().availableProcessors(), results.get(LoadOptions.NUM_THREADS).get());}
public void metron_f1395_0() throws Exception
{    CommandLine cli = LoadOptions.parse(new PosixParser(), new String[] { "-p", "5" });    EnumMap<LoadOptions, Optional<Object>> results = LoadOptions.createConfig(cli);    Assert.assertEquals(5, results.get(LoadOptions.NUM_THREADS).get());}
public void metron_f1396_0() throws Exception
{    File templateFile = new File("target/template");    String template = "test template1";    try (BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(templateFile), StandardCharsets.UTF_8))) {        IOUtils.write(template, w);    }    templateFile.deleteOnExit();    CommandLine cli = LoadOptions.parse(new PosixParser(), new String[] { "-t", templateFile.getPath() });    EnumMap<LoadOptions, Optional<Object>> results = LoadOptions.createConfig(cli);    List<String> templates = (List<String>) results.get(LoadOptions.TEMPLATE).get();    Assert.assertEquals(1, templates.size());    Assert.assertEquals(template, templates.get(0));}
public void metron_f1397_0() throws Exception
{    LoadOptions.createConfig(LoadOptions.parse(new PosixParser(), new String[] { "-t", "target/template2" }));}
public void metron_f1398_0()
{    ExecutorService executor = ForkJoinPool.commonPool();    AtomicLong numSent = new AtomicLong(0);    long expectedSent = 100;    SendToKafka sender = new SendToKafka(null, expectedSent, 10, () -> "msg", executor, numSent, ThreadLocal.withInitial(() -> null)) {        @Override        protected Future<?> sendToKafka(KafkaProducer producer, String kafkaTopic, String message) {            Assert.assertEquals(message, "msg");            return ForkJoinPool.commonPool().submit(() -> {                numSent.incrementAndGet();            });        }    };    sender.run();    Assert.assertEquals(numSent.get(), expectedSent);}
protected Future<?> metron_f1399_0(KafkaProducer producer, String kafkaTopic, String message)
{    Assert.assertEquals(message, "msg");    return ForkJoinPool.commonPool().submit(() -> {        numSent.incrementAndGet();    });}
private void metron_f1400_0(Sampler sampler, Map<Integer, Double> expectedProbs)
{    Random rng = new Random(0);    Map<Integer, Double> empiricalProbs = new HashMap<>();    for (int i = 0; i < SIMULATION_SIZE; ++i) {        int sample = sampler.sample(rng, 10);        Double cnt = empiricalProbs.get(sample);        empiricalProbs.put(sample, ((cnt == null) ? 0 : cnt) + 1);    }    for (Map.Entry<Integer, Double> kv : empiricalProbs.entrySet()) {        double empiricalProb = kv.getValue() / SIMULATION_SIZE;        String msg = expectedProbs.get(kv.getKey()) + " != " + empiricalProb;        Assert.assertEquals(msg, expectedProbs.get(kv.getKey()), empiricalProb, 1e-2);    }}
public void metron_f1401_0()
{    Sampler sampler = new UnbiasedSampler();    testSampler(sampler, new HashMap<Integer, Double>() {        {            for (int i = 0; i < 10; ++i) {                put(i, 0.1);            }        }    });}
public void metron_f1402_0()
{    Sampler sampler = new BiasedSampler(new ArrayList<Map.Entry<Integer, Integer>>() {        {            add(new AbstractMap.SimpleEntry<>(30, 80));            add(new AbstractMap.SimpleEntry<>(70, 20));        }    }, 10);    testSampler(sampler, new HashMap<Integer, Double>() {        {            for (int i = 0; i < 3; ++i) {                put(i, 0.8 / 3);            }            for (int i = 3; i < 10; ++i) {                put(i, 0.2 / 7);            }        }    });}
public void metron_f1403_0() throws IOException
{    for (String config : ImmutableList.of(paretoConfig, paretoConfigImplicit)) {        List<Map.Entry<Integer, Integer>> endpoints = BiasedSampler.readDistribution(new BufferedReader(new StringReader(config)), true);        Assert.assertEquals(2, endpoints.size());        Assert.assertEquals(new AbstractMap.SimpleEntry<>(80, 20), endpoints.get(0));        Assert.assertEquals(new AbstractMap.SimpleEntry<>(20, 80), endpoints.get(1));    }}
public void metron_f1404_0() throws IOException
{    for (String config : ImmutableList.of(longerConfig, longerConfigImplicit)) {        List<Map.Entry<Integer, Integer>> endpoints = BiasedSampler.readDistribution(new BufferedReader(new StringReader(config)), true);        Assert.assertEquals(3, endpoints.size());        Assert.assertEquals(new AbstractMap.SimpleEntry<>(80, 20), endpoints.get(0));        Assert.assertEquals(new AbstractMap.SimpleEntry<>(10, 70), endpoints.get(1));        Assert.assertEquals(new AbstractMap.SimpleEntry<>(10, 10), endpoints.get(2));    }}
public void metron_f1405_0() throws IOException
{    BiasedSampler.readDistribution(new BufferedReader(new StringReader("blah foo")), true);}
public void metron_f1406_0() throws IOException
{    BiasedSampler.readDistribution(new BufferedReader(new StringReader("80,-20")), true);}
public void metron_f1407_0() throws IOException
{    BiasedSampler.readDistribution(new BufferedReader(new StringReader("200,20")), true);}
public Grok metron_f1408_0() throws GrokException
{    Grok grok = new Grok();    grok.addPatternFromReader(new InputStreamReader(getClass().getResourceAsStream("/patterns/common"), StandardCharsets.UTF_8));    return grok;}
public org.apache.hadoop.conf.Configuration metron_f1409_0() throws IOException
{    org.apache.hadoop.conf.Configuration configuration = new org.apache.hadoop.conf.Configuration();    if (environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)) {        UserGroupInformation.setConfiguration(configuration);        String keyTabLocation = environment.getProperty(MetronRestConstants.KERBEROS_KEYTAB_SPRING_PROPERTY);        String userPrincipal = environment.getProperty(MetronRestConstants.KERBEROS_PRINCIPLE_SPRING_PROPERTY);        UserGroupInformation.loginUserFromKeytab(userPrincipal, keyTabLocation);    }    return configuration;}
public UserSettingsClient metron_f1410_0()
{    UserSettingsClient userSettingsClient = new UserSettingsClient();    userSettingsClient.init(() -> {        try {            return globalConfigService.get();        } catch (RestException e) {            throw new IllegalStateException("Unable to retrieve the global config.", e);        }    }, new HTableProvider());    return userSettingsClient;}
public HBaseClient metron_f1411_0()
{    Map<String, Object> restConfig = null;    try {        restConfig = globalConfigService.get();    } catch (RestException e) {        throw new IllegalStateException("Unable to retrieve the global config.", e);    }    TableProvider provider = null;    try {        provider = TableProvider.create((String) restConfig.get(EnrichmentConfigurations.TABLE_PROVIDER), HTableProvider::new);    } catch (ClassNotFoundException | InstantiationException | InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {        throw new IllegalStateException("Unable to create table provider", e);    }    return new HBaseClient(provider, HBaseConfiguration.create(), (String) restConfig.get(EnrichmentConfigurations.TABLE_NAME));}
public IndexDao metron_f1412_0()
{    try {        String hbaseProviderImpl = environment.getProperty(MetronRestConstants.INDEX_HBASE_TABLE_PROVIDER_IMPL, String.class, null);        String indexDaoImpl = environment.getProperty(MetronRestConstants.INDEX_DAO_IMPL, String.class, null);        int searchMaxResults = environment.getProperty(MetronRestConstants.SEARCH_MAX_RESULTS, Integer.class, 1000);        int searchMaxGroups = environment.getProperty(MetronRestConstants.SEARCH_MAX_GROUPS, Integer.class, 1000);        String metaDaoImpl = environment.getProperty(MetronRestConstants.META_DAO_IMPL, String.class, null);        String metaDaoSort = environment.getProperty(MetronRestConstants.META_DAO_SORT, String.class, null);        AccessConfig config = new AccessConfig();        config.setMaxSearchResults(searchMaxResults);        config.setMaxSearchGroups(searchMaxGroups);        config.setGlobalConfigSupplier(() -> {            try {                return globalConfigService.get();            } catch (RestException e) {                throw new IllegalStateException("Unable to retrieve the global config.", e);            }        });        config.setIndexSupplier(IndexingCacheUtil.getIndexLookupFunction(cache, environment.getProperty(INDEX_WRITER_NAME)));        config.setTableProvider(TableProvider.create(hbaseProviderImpl, () -> new HTableProvider()));        config.setKerberosEnabled(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false));        if (indexDaoImpl == null) {            throw new IllegalStateException("You must provide an index DAO implementation via the " + INDEX_DAO_IMPL + " config");        }        IndexDao indexDao = IndexDaoFactory.combine(IndexDaoFactory.create(indexDaoImpl, config));        if (indexDao == null) {            throw new IllegalStateException("IndexDao is unable to be created.");        }        if (metaDaoImpl == null) {                        return indexDao;        }                MetaAlertDao ret = (MetaAlertDao) IndexDaoFactory.create(metaDaoImpl, config).get(0);        ret.init(indexDao, Optional.ofNullable(metaDaoSort));        return ret;    } catch (RuntimeException re) {        throw re;    } catch (Exception e) {        throw new IllegalStateException("Unable to create index DAO: " + e.getMessage(), e);    }}
protected AbstractJpaVendorAdapter metron_f1413_0()
{    return new EclipseLinkJpaVendorAdapter();}
protected Map<String, Object> metron_f1414_0()
{    return Collections.singletonMap("eclipselink.weaving", "false");}
public ZkUtils metron_f1415_0()
{    return ZkUtils.apply(zkClient, false);}
public Map<String, Object> metron_f1416_0()
{    final Map<String, Object> props = new HashMap<>();    props.put("bootstrap.servers", environment.getProperty(MetronRestConstants.KAFKA_BROKER_URL_SPRING_PROPERTY));    props.put("group.id", "metron-rest");    props.put("enable.auto.commit", "false");    props.put("auto.commit.interval.ms", "1000");    props.put("session.timeout.ms", "30000");    props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");    props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");    if (environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)) {        props.put("security.protocol", KafkaUtils.INSTANCE.normalizeProtocol(environment.getProperty(MetronRestConstants.KAFKA_SECURITY_PROTOCOL_SPRING_PROPERTY)));    }    return props;}
public ConsumerFactory<String, String> metron_f1417_0()
{    return new DefaultKafkaConsumerFactory<>(consumerProperties());}
public Map<String, Object> metron_f1418_0()
{    Map<String, Object> producerConfig = new HashMap<>();    producerConfig.put("bootstrap.servers", environment.getProperty(MetronRestConstants.KAFKA_BROKER_URL_SPRING_PROPERTY));    producerConfig.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");    producerConfig.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");    producerConfig.put("request.required.acks", 1);    if (environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)) {        producerConfig.put("security.protocol", KafkaUtils.INSTANCE.normalizeProtocol(environment.getProperty(MetronRestConstants.KAFKA_SECURITY_PROTOCOL_SPRING_PROPERTY)));    }    return producerConfig;}
public KafkaProducer metron_f1419_0()
{    return new KafkaProducer<>(producerProperties());}
public AdminUtils$ metron_f1420_0()
{    return AdminUtils$.MODULE$;}
public void metron_f1421_0(FilterConfig filterConfig)
{}
public void metron_f1422_0()
{}
public void metron_f1423_1(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException
{    HttpServletRequest httpRequest = (HttpServletRequest) request;        String authHeader = httpRequest.getHeader("Authorization");    if (authHeader == null || !authHeader.startsWith("Basic")) {        String serializedJWT = getJWTFromCookie(httpRequest);        if (serializedJWT != null) {            SignedJWT jwtToken;            try {                jwtToken = SignedJWT.parse(serializedJWT);                String userName = jwtToken.getJWTClaimsSet().getSubject();                                if (isValid(jwtToken, userName)) {                    Authentication authentication = getAuthentication(userName, httpRequest);                    SecurityContextHolder.getContext().setAuthentication(authentication);                }            } catch (ParseException e) {                            }        }    }    chain.doFilter(request, response);}
protected boolean metron_f1424_1(SignedJWT jwtToken, String userName) throws ParseException
{        if (userName == null || userName.isEmpty()) {                return false;    }    Date now = new Date();        Date expirationTime = jwtToken.getJWTClaimsSet().getExpirationTime();    if (expirationTime != null && now.after(expirationTime)) {                return false;    }        Date notBeforeTime = jwtToken.getJWTClaimsSet().getNotBeforeTime();    if (notBeforeTime != null && now.before(notBeforeTime)) {                return false;    }    return validateSignature(jwtToken);}
protected boolean metron_f1425_1(SignedJWT jwtToken)
{        String receivedSigAlg = jwtToken.getHeader().getAlgorithm().getName();    if (!receivedSigAlg.equals(JWSAlgorithm.RS256.getName())) {        return false;    }        if (JWSObject.State.SIGNED == jwtToken.getState()) {                if (jwtToken.getSignature() != null) {                        try {                JWSVerifier verifier = new RSASSAVerifier(SecurityUtils.parseRSAPublicKey(getKnoxKey()));                if (jwtToken.verify(verifier)) {                                        return true;                } else {                                    }            } catch (Exception e) {                            }        }    }    return false;}
protected String metron_f1426_1(HttpServletRequest req)
{    String serializedJWT = null;    Cookie[] cookies = req.getCookies();    if (cookies != null) {        for (Cookie cookie : cookies) {                        if (knoxCookie.equals(cookie.getName())) {                if (LOG.isDebugEnabled()) {                                    }                serializedJWT = cookie.getValue();                break;            }        }    } else {        if (LOG.isDebugEnabled()) {                    }    }    return serializedJWT;}
protected String metron_f1427_0() throws IOException
{    String knoxKey;    if ((this.knoxKeyString == null || this.knoxKeyString.isEmpty()) && this.knoxKeyFile != null) {        List<String> keyLines = Files.readAllLines(knoxKeyFile, StandardCharsets.UTF_8);        knoxKey = String.join("", keyLines);    } else {        knoxKey = this.knoxKeyString;    }    return knoxKey;}
protected Authentication metron_f1428_0(String userName, HttpServletRequest httpRequest)
{    String ldapName = LdapNameBuilder.newInstance().add(userSearchBase).add("uid", userName).build().toString();        List<GrantedAuthority> grantedAuths = ldapTemplate.search(query().where("objectclass").is("groupOfNames").and("member").is(ldapName), (AttributesMapper<String>) attrs -> (String) attrs.get("cn").get()).stream().map(group -> String.format("%s%s", SECURITY_ROLE_PREFIX, group.toUpperCase())).map(SimpleGrantedAuthority::new).collect(Collectors.toList());    final UserDetails principal = new User(userName, "", grantedAuths);    final UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(principal, "", grantedAuths);    WebAuthenticationDetails webDetails = new WebAuthenticationDetails(httpRequest);    authentication.setDetails(webDetails);    return authentication;}
public LdapTemplate metron_f1429_0()
{    LdapContextSource contextSource = new LdapContextSource();    contextSource.setUrl(environment.getProperty(LDAP_PROVIDER_URL_SPRING_PROPERTY));    contextSource.setUserDn(environment.getProperty(LDAP_PROVIDER_USERDN_SPRING_PROPERTY));    contextSource.setPassword(environment.getProperty(LDAP_PROVIDER_PASSWORD_SPRING_PROPERTY));    contextSource.afterPropertiesSet();    return new LdapTemplate(contextSource);}
public CommonsRequestLoggingFilter metron_f1430_0()
{    CommonsRequestLoggingFilter filter = new CommonsRequestLoggingFilter();    filter.setIncludeQueryString(true);    filter.setIncludePayload(true);    filter.setMaxPayloadLength(10000);    filter.setIncludeHeaders(true);    filter.setAfterMessagePrefix("request: ");    filter.setAfterMessageSuffix("");    return filter;}
public String metron_f1433_0()
{    return userRole;}
public void metron_f1434_0(String userRole)
{    this.userRole = userRole;}
public String metron_f1435_0()
{    return adminRole;}
public void metron_f1436_0(String adminRole)
{    this.adminRole = adminRole;}
public String metron_f1437_0()
{    return prefix;}
public void metron_f1438_0(String prefix)
{    this.prefix = prefix;}
public void metron_f1439_0(CorsRegistry registry)
{    registry.addMapping("/**");}
public JobManager metron_f1440_0()
{    return new InMemoryJobManager();}
public PcapJobSupplier metron_f1441_0()
{    return new PcapJobSupplier();}
public PcapToPdmlScriptWrapper metron_f1442_0()
{    return new PcapToPdmlScriptWrapper();}
public Statusable<Path> metron_f1443_0()
{    try {        PcapJob<Path> pcapJob = createPcapJob();        return pcapJob.submit(PcapFinalizerStrategies.REST, pcapRequest);    } catch (JobException e) {        throw new RuntimeJobException(e.getMessage(), e);    }}
public void metron_f1444_0(PcapRequest pcapRequest)
{    this.pcapRequest = pcapRequest;}
protected PcapJob metron_f1445_0()
{    return new PcapJob();}
public RestTemplate metron_f1446_0()
{    if (environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)) {        String keyTabLocation = environment.getProperty(MetronRestConstants.KERBEROS_KEYTAB_SPRING_PROPERTY);        String userPrincipal = environment.getProperty(MetronRestConstants.KERBEROS_PRINCIPLE_SPRING_PROPERTY);        return new KerberosRestTemplate(keyTabLocation, userPrincipal);    } else {        return new RestTemplate();    }}
public StormCLIWrapper metron_f1447_0()
{    if (Arrays.asList(environment.getActiveProfiles()).contains(DOCKER_PROFILE)) {        return new DockerStormCLIWrapper(environment);    } else {        return new StormCLIWrapper();    }}
public StormStatusService metron_f1448_0(@Autowired @Qualifier("StormStatusServiceImpl") StormStatusService wrappedService)
{    long maxCacheSize = environment.getProperty(MetronRestConstants.STORM_STATUS_CACHE_MAX_SIZE, Long.class, 10000L);    long maxCacheTimeoutSeconds = environment.getProperty(MetronRestConstants.STORM_STATUS_CACHE_TIMEOUT_SECONDS, Long.class, 5L);    return new CachedStormStatusServiceImpl(wrappedService, maxCacheSize, maxCacheTimeoutSeconds);}
public Docket metron_f1449_0()
{    List<String> activeProfiles = Arrays.asList(environment.getActiveProfiles());    Docket docket = new Docket(DocumentationType.SWAGGER_2);    if (activeProfiles.contains(KNOX_PROFILE)) {        String knoxRoot = environment.getProperty(MetronRestConstants.KNOX_ROOT_SPRING_PROPERTY, String.class, "");        docket = docket.pathProvider(new RelativePathProvider(servletContext) {            @Override            protected String applicationPath() {                return knoxRoot;            }            @Override            protected String getDocumentationPath() {                return knoxRoot;            }            @Override            public String getApplicationBasePath() {                return knoxRoot;            }            @Override            public String getOperationPath(String operationPath) {                return knoxRoot + super.getOperationPath(operationPath);            }        });    }    return docket.select().apis(RequestHandlerSelectors.withClassAnnotation(RestController.class)).paths(PathSelectors.any()).build();}
protected String metron_f1450_0()
{    return knoxRoot;}
protected String metron_f1451_0()
{    return knoxRoot;}
public String metron_f1452_0()
{    return knoxRoot;}
public String metron_f1453_0(String operationPath)
{    return knoxRoot + super.getOperationPath(operationPath);}
public String metron_f1454_0()
{    return "forward:/index.html";}
protected void metron_f1455_0(HttpSecurity http) throws Exception
{    http.authorizeRequests().antMatchers("/", "/home", "/login").permitAll().antMatchers("/app/**").permitAll().antMatchers("/vendor/**").permitAll().antMatchers("/fonts/**").permitAll().antMatchers("/assets/images/**").permitAll().antMatchers("/*.js").permitAll().antMatchers("/*.ttf").permitAll().antMatchers("/*.woff2").permitAll().anyRequest().authenticated().and().httpBasic().and().logout().logoutUrl("/api/v1/logout").logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler()).invalidateHttpSession(true).deleteCookies("JSESSIONID", knoxCookie);    List<String> activeProfiles = Arrays.asList(environment.getActiveProfiles());    if (activeProfiles.contains(MetronRestConstants.CSRF_ENABLE_PROFILE)) {        http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());    } else {        http.csrf().disable();    }    if (activeProfiles.contains(MetronRestConstants.KNOX_PROFILE)) {        http.addFilterAt(new KnoxSSOAuthenticationFilter(userSearchBase, knoxKeyFile, knoxKeyString, knoxCookie, ldapTemplate), UsernamePasswordAuthenticationFilter.class);    }}
public PasswordEncoder metron_f1457_0()
{    return NoOpPasswordEncoder.getInstance();}
public ConfigurationsCache metron_f1458_0(CuratorFramework client)
{    return new ZKConfigurationsCache(client, ZKConfigurationsCache.ConfiguredTypes.ENRICHMENT, ZKConfigurationsCache.ConfiguredTypes.PARSER, ZKConfigurationsCache.ConfiguredTypes.INDEXING);}
public CuratorFramework metron_f1459_0(Environment environment)
{    int sleepTime = Integer.parseInt(environment.getProperty(MetronRestConstants.CURATOR_SLEEP_TIME));    int maxRetries = Integer.parseInt(environment.getProperty(MetronRestConstants.CURATOR_MAX_RETRIES));    RetryPolicy retryPolicy = new ExponentialBackoffRetry(sleepTime, maxRetries);    CuratorFramework ret = CuratorFrameworkFactory.newClient(environment.getProperty(MetronRestConstants.ZK_URL_SPRING_PROPERTY), retryPolicy);    return ret;}
public ZkClient metron_f1460_0(Environment environment)
{    int sessionTimeout = Integer.parseInt(environment.getProperty(MetronRestConstants.ZK_CLIENT_SESSION_TIMEOUT));    int connectionTimeout = Integer.parseInt(environment.getProperty(MetronRestConstants.ZK_CLIENT_CONNECTION_TIMEOUT));    return new ZkClient(environment.getProperty(MetronRestConstants.ZK_URL_SPRING_PROPERTY), sessionTimeout, connectionTimeout, ZKStringSerializer$.MODULE$);}
 ResponseEntity<Void> metron_f1461_0(@ApiParam(name = "alerts", value = "The alerts to be escalated", required = true) @RequestBody final List<Map<String, Object>> alerts) throws RestException
{    alertsUIService.escalateAlerts(alerts);    return new ResponseEntity<>(HttpStatus.OK);}
 ResponseEntity<AlertsUIUserSettings> metron_f1462_0() throws RestException
{    Optional<AlertsUIUserSettings> alertUserSettings = alertsUIService.getAlertsUIUserSettings();    if (alertUserSettings.isPresent()) {        return new ResponseEntity<>(alertUserSettings.get(), HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Map<String, AlertsUIUserSettings>> metron_f1463_0() throws RestException
{    return new ResponseEntity<>(alertsUIService.findAllAlertsUIUserSettings(), HttpStatus.OK);}
 ResponseEntity<Void> metron_f1464_0(@ApiParam(name = "alertsUIUserSettings", value = "The user settings to be saved", required = true) @RequestBody AlertsUIUserSettings alertsUIUserSettings) throws RestException
{    ResponseEntity<Void> responseEntity;    if (alertsUIService.getAlertsUIUserSettings().isPresent()) {        responseEntity = new ResponseEntity<>(HttpStatus.OK);    } else {        responseEntity = new ResponseEntity<>(HttpStatus.CREATED);    }    alertsUIService.saveAlertsUIUserSettings(alertsUIUserSettings);    return responseEntity;}
 ResponseEntity<Void> metron_f1465_0(@ApiParam(name = "user", value = "The user whose settings will be deleted", required = true) @PathVariable String user) throws RestException
{    if (alertsUIService.deleteAlertsUIUserSettings(user)) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Map<String, Object>> metron_f1466_0(@ApiParam(name = "globalConfig", value = "The Global Config JSON to be saved", required = true) @RequestBody Map<String, Object> globalConfig) throws RestException
{    if (globalConfigService.get() == null) {        return new ResponseEntity<>(globalConfigService.save(globalConfig), HttpStatus.CREATED);    } else {        return new ResponseEntity<>(globalConfigService.save(globalConfig), HttpStatus.OK);    }}
 ResponseEntity<Map<String, Object>> metron_f1467_0() throws RestException
{    Map<String, Object> globalConfig = globalConfigService.get();    if (globalConfig != null) {        return new ResponseEntity<>(globalConfig, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Void> metron_f1468_0() throws RestException
{    if (globalConfigService.delete()) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<GrokValidation> metron_f1469_0(@ApiParam(name = "grokValidation", value = "Object containing Grok statement and sample message", required = true) @RequestBody GrokValidation grokValidation) throws RestException
{    return new ResponseEntity<>(grokService.validateGrokStatement(grokValidation), HttpStatus.OK);}
 ResponseEntity<Map<String, String>> metron_f1470_0() throws RestException
{    return new ResponseEntity<>(grokService.getCommonGrokPatterns(), HttpStatus.OK);}
 ResponseEntity<String> metron_f1471_0(@ApiParam(name = "path", value = "Path to classpath resource", required = true) @RequestParam String path) throws RestException
{    return new ResponseEntity<>(grokService.getStatementFromClasspath(path), HttpStatus.OK);}
 ResponseEntity<List<String>> metron_f1472_0(@ApiParam(name = "path", value = "Path to HDFS directory", required = true) @RequestParam String path) throws RestException
{    return new ResponseEntity<>(hdfsService.list(new Path(path)), HttpStatus.OK);}
 ResponseEntity<String> metron_f1473_0(@ApiParam(name = "path", value = "Path to HDFS file", required = true) @RequestParam String path) throws RestException
{    String contents = hdfsService.read(new Path(path));    if (contents != null) {        return new ResponseEntity<>(hdfsService.read(new Path(path)), HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Void> metron_f1474_0(@ApiParam(name = "path", value = "Path to HDFS file", required = true) @RequestParam String path, @ApiParam(name = "contents", value = "File contents", required = true) @RequestBody String contents, @ApiParam(name = "userMode", value = "requested user permissions") @RequestParam(required = false, defaultValue = "") String userMode, @ApiParam(name = "groupMode", value = "requested group permissions") @RequestParam(required = false, defaultValue = "") String groupMode, @ApiParam(name = "otherMode", value = "requested other permissions") @RequestParam(required = false, defaultValue = "") String otherMode) throws RestException
{    hdfsService.write(new Path(path), contents.getBytes(UTF_8), userMode, groupMode, otherMode);    return new ResponseEntity<>(HttpStatus.OK);}
 ResponseEntity<Boolean> metron_f1475_0(@ApiParam(name = "path", value = "Path to HDFS file", required = true) @RequestParam String path, @ApiParam(name = "recursive", value = "Delete files recursively") @RequestParam(required = false, defaultValue = "false") boolean recursive) throws RestException
{    if (hdfsService.delete(new Path(path), recursive)) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<KafkaTopic> metron_f1476_0(@ApiParam(name = "topic", value = "Kafka topic", required = true) @RequestBody final KafkaTopic topic) throws RestException
{    return new ResponseEntity<>(kafkaService.createTopic(topic), HttpStatus.CREATED);}
 ResponseEntity<KafkaTopic> metron_f1477_0(@ApiParam(name = "name", value = "Kafka topic name", required = true) @PathVariable final String name) throws RestException
{    KafkaTopic kafkaTopic = kafkaService.getTopic(name);    if (kafkaTopic != null) {        return new ResponseEntity<>(kafkaTopic, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Set<String>> metron_f1478_0() throws Exception
{    return new ResponseEntity<>(kafkaService.listTopics(), HttpStatus.OK);}
 ResponseEntity<Void> metron_f1479_0(@ApiParam(name = "name", value = "Kafka topic name", required = true) @PathVariable final String name) throws RestException
{    if (kafkaService.deleteTopic(name)) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<String> metron_f1480_0(@ApiParam(name = "name", value = "Kafka topic name", required = true) @PathVariable final String name) throws RestException
{    String sampleMessage = kafkaService.getSampleMessage(name);    if (sampleMessage != null) {        return new ResponseEntity<>(sampleMessage, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<String> metron_f1481_0(@ApiParam(name = "name", value = "Kafka topic name", required = true) @PathVariable final String name, @ApiParam(name = "message", value = "Message", required = true) @RequestBody final String message) throws RestException
{    kafkaService.produceMessage(name, message);    return new ResponseEntity<>(HttpStatus.OK);}
 ResponseEntity<SearchResponse> metron_f1482_0(@ApiParam(name = "guid", value = "Alert GUID", required = true) @RequestBody final String guid) throws RestException
{    return new ResponseEntity<>(metaAlertService.getAllMetaAlertsForAlert(guid), HttpStatus.OK);}
 ResponseEntity<Document> metron_f1483_0(@ApiParam(name = "createRequest", value = "Meta alert create request which includes a list of alert " + "get requests and a list of custom groups used to annotate a meta alert", required = true) @RequestBody final MetaAlertCreateRequest createRequest) throws RestException
{    return new ResponseEntity<>(metaAlertService.create(createRequest), HttpStatus.OK);}
 ResponseEntity<Document> metron_f1484_0(@ApiParam(name = "metaAlertAddRemoveRequest", value = "Meta alert add request which includes a meta alert GUID and list of alert get requests", required = true) @RequestBody final MetaAlertAddRemoveRequest metaAlertAddRemoveRequest) throws RestException
{    return new ResponseEntity<>(metaAlertService.addAlertsToMetaAlert(metaAlertAddRemoveRequest), HttpStatus.OK);}
 ResponseEntity<Document> metron_f1485_0(@ApiParam(name = "metaAlertAddRemoveRequest", value = "Meta alert remove request which includes a meta alert GUID and list of alert get requests", required = true) @RequestBody final MetaAlertAddRemoveRequest metaAlertAddRemoveRequest) throws RestException
{    return new ResponseEntity<>(metaAlertService.removeAlertsFromMetaAlert(metaAlertAddRemoveRequest), HttpStatus.OK);}
 ResponseEntity<Document> metron_f1486_0(@ApiParam(name = "guid", value = "Meta alert GUID", required = true) @PathVariable final String guid, @ApiParam(name = "status", value = "Meta alert status with a value of either 'ACTIVE' or 'INACTIVE'", required = true) @PathVariable final String status) throws RestException
{    return new ResponseEntity<>(metaAlertService.updateMetaAlertStatus(guid, MetaAlertStatus.valueOf(status.toUpperCase())), HttpStatus.OK);}
 ResponseEntity<PcapStatus> metron_f1487_0(@ApiParam(name = "fixedPcapRequest", value = "A Fixed Pcap Request" + " which includes fixed filter fields like ip source address and protocol", required = true) @RequestBody FixedPcapRequest fixedPcapRequest) throws RestException
{    PcapStatus pcapStatus = pcapQueryService.submit(SecurityUtils.getCurrentUser(), fixedPcapRequest);    return new ResponseEntity<>(pcapStatus, HttpStatus.OK);}
 ResponseEntity<PcapStatus> metron_f1488_0(@ApiParam(name = "queryPcapRequest", value = "A Query Pcap Request" + " which includes Stellar query field", required = true) @RequestBody QueryPcapRequest queryPcapRequest) throws RestException
{    PcapStatus pcapStatus = pcapQueryService.submit(SecurityUtils.getCurrentUser(), queryPcapRequest);    return new ResponseEntity<>(pcapStatus, HttpStatus.OK);}
 ResponseEntity<PcapStatus> metron_f1489_0(@ApiParam(name = "jobId", value = "Job ID of submitted job", required = true) @PathVariable String jobId) throws RestException
{    PcapStatus jobStatus = pcapQueryService.getJobStatus(SecurityUtils.getCurrentUser(), jobId);    if (jobStatus != null) {        return new ResponseEntity<>(jobStatus, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<List<PcapStatus>> metron_f1490_0(@ApiParam(name = "state", value = "Job state", required = true) @RequestParam String state) throws RestException
{    List<PcapStatus> jobs = pcapQueryService.getJobStatus(SecurityUtils.getCurrentUser(), JobStatus.State.valueOf(state));    return new ResponseEntity<>(jobs, HttpStatus.OK);}
 ResponseEntity<Pdml> metron_f1491_0(@ApiParam(name = "jobId", value = "Job ID of submitted job", required = true) @PathVariable String jobId, @ApiParam(name = "page", value = "Page number", required = true) @RequestParam Integer page) throws RestException
{    Pdml pdml = pcapQueryService.getPdml(SecurityUtils.getCurrentUser(), jobId, page);    if (pdml != null) {        return new ResponseEntity<>(pdml, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<PcapStatus> metron_f1492_0(@ApiParam(name = "jobId", value = "Job ID of submitted job", required = true) @PathVariable String jobId) throws RestException
{    PcapStatus jobStatus = pcapQueryService.killJob(SecurityUtils.getCurrentUser(), jobId);    if (jobStatus != null) {        return new ResponseEntity<>(jobStatus, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 void metron_f1493_0(@ApiParam(name = "jobId", value = "Job ID of submitted job", required = true) @PathVariable String jobId, @ApiParam(name = "page", value = "Page number", required = true) @RequestParam Integer page, @RequestParam(defaultValue = "", required = false) String fileName, final HttpServletRequest request, final HttpServletResponse response) throws RestException
{    try (InputStream inputStream = pcapQueryService.getRawPcap(SecurityUtils.getCurrentUser(), jobId, page);        OutputStream output = response.getOutputStream()) {        response.reset();        if (inputStream == null) {            response.setStatus(HttpStatus.NOT_FOUND.value());        } else {            response.setContentType("application/octet-stream");            if (fileName.isEmpty()) {                fileName = String.format(PCAP_FILENAME_FORMAT, jobId, page);            }            response.setHeader("Content-Disposition", "attachment; filename=\"" + fileName + "\"");            int size = IOUtils.copy(inputStream, output);            response.setContentLength(size);            output.flush();        }    } catch (IOException e) {        throw new RestException(e);    }}
 ResponseEntity<Map<String, Object>> metron_f1494_0(@ApiParam(name = "jobId", value = "Job ID of submitted job", required = true) @PathVariable String jobId) throws RestException
{    Map<String, Object> configuration = pcapQueryService.getConfiguration(SecurityUtils.getCurrentUser(), jobId);    if (configuration != null) {        return new ResponseEntity<>(configuration, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<?> metron_f1495_1(HttpServletRequest request, Throwable ex)
{    HttpStatus status = getStatus(request);        return new ResponseEntity<>(new RestError(status.value(), ex.getMessage(), ExceptionUtils.getRootCauseMessage(ex)), status);}
private HttpStatus metron_f1496_0(HttpServletRequest request)
{    Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");    if (statusCode == null) {        return HttpStatus.INTERNAL_SERVER_ERROR;    }    return HttpStatus.valueOf(statusCode);}
 ResponseEntity<SearchResponse> metron_f1497_0(@ApiParam(name = "searchRequest", value = "Search request", required = true) @RequestBody final SearchRequest searchRequest) throws RestException
{    return new ResponseEntity<>(searchService.search(searchRequest), HttpStatus.OK);}
 ResponseEntity<GroupResponse> metron_f1498_0(@ApiParam(name = "groupRequest", value = "Group request", required = true) @RequestBody final GroupRequest groupRequest) throws RestException
{    return new ResponseEntity<>(searchService.group(groupRequest), HttpStatus.OK);}
 ResponseEntity<Map<String, Object>> metron_f1499_0(@ApiParam(name = "getRequest", value = "Get Request", required = true) @RequestBody final GetRequest request) throws RestException
{    Optional<Map<String, Object>> latest = searchService.getLatest(request);    if (latest.isPresent()) {        return new ResponseEntity<>(latest.get(), HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Map<String, FieldType>> metron_f1500_0(@ApiParam(name = "sensorTypes", value = "Sensor Types", required = true) @RequestBody final List<String> sensorTypes) throws RestException
{    return new ResponseEntity<>(searchService.getColumnMetadata(sensorTypes), HttpStatus.OK);}
 ResponseEntity<SensorEnrichmentConfig> metron_f1501_0(@ApiParam(name = "name", value = "SensorEnrichmentConfig name", required = true) @PathVariable String name, @ApiParam(name = "sensorEnrichmentConfig", value = "SensorEnrichmentConfig", required = true) @RequestBody SensorEnrichmentConfig sensorEnrichmentConfig) throws RestException
{    if (sensorEnrichmentConfigService.findOne(name) == null) {        return new ResponseEntity<>(sensorEnrichmentConfigService.save(name, sensorEnrichmentConfig), HttpStatus.CREATED);    } else {        return new ResponseEntity<>(sensorEnrichmentConfigService.save(name, sensorEnrichmentConfig), HttpStatus.OK);    }}
 ResponseEntity<SensorEnrichmentConfig> metron_f1502_0(@ApiParam(name = "name", value = "SensorEnrichmentConfig name", required = true) @PathVariable String name) throws RestException
{    SensorEnrichmentConfig sensorEnrichmentConfig = sensorEnrichmentConfigService.findOne(name);    if (sensorEnrichmentConfig != null) {        return new ResponseEntity<>(sensorEnrichmentConfig, HttpStatus.OK);    }    return new ResponseEntity<>(HttpStatus.NOT_FOUND);}
 ResponseEntity<Map<String, SensorEnrichmentConfig>> metron_f1503_0() throws Exception
{    return new ResponseEntity<>(sensorEnrichmentConfigService.getAll(), HttpStatus.OK);}
 ResponseEntity<Void> metron_f1504_0(@ApiParam(name = "name", value = "SensorEnrichmentConfig name", required = true) @PathVariable String name) throws RestException
{    if (sensorEnrichmentConfigService.delete(name)) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<List<String>> metron_f1505_0() throws RestException
{    return new ResponseEntity<>(sensorEnrichmentConfigService.getAvailableEnrichments(), HttpStatus.OK);}
 ResponseEntity<List<String>> metron_f1506_0() throws RestException
{    return new ResponseEntity<>(sensorEnrichmentConfigService.getAvailableThreatTriageAggregators(), HttpStatus.OK);}
 ResponseEntity<Map<String, Object>> metron_f1507_0(@ApiParam(name = "name", value = "SensorIndexingConfig name", required = true) @PathVariable String name, @ApiParam(name = "sensorIndexingConfig", value = "SensorIndexingConfig", required = true) @RequestBody Map<String, Object> sensorIndexingConfig) throws RestException
{    if (sensorIndexingConfigService.findOne(name) == null) {        return new ResponseEntity<>(sensorIndexingConfigService.save(name, sensorIndexingConfig), HttpStatus.CREATED);    } else {        return new ResponseEntity<>(sensorIndexingConfigService.save(name, sensorIndexingConfig), HttpStatus.OK);    }}
 ResponseEntity<Map<String, Object>> metron_f1508_0(@ApiParam(name = "name", value = "SensorIndexingConfig name", required = true) @PathVariable String name) throws RestException
{    Map<String, Object> sensorIndexingConfig = sensorIndexingConfigService.findOne(name);    if (sensorIndexingConfig != null) {        return new ResponseEntity<>(sensorIndexingConfig, HttpStatus.OK);    }    return new ResponseEntity<>(HttpStatus.NOT_FOUND);}
 ResponseEntity<Map<String, Map<String, Object>>> metron_f1509_0() throws Exception
{    return new ResponseEntity<>(sensorIndexingConfigService.getAll(), HttpStatus.OK);}
 ResponseEntity<Iterable<String>> metron_f1510_0(@ApiParam(name = "writerName", value = "Writer name.  One of solr, elasticsearch or hdfs", required = true) @PathVariable String writerName) throws Exception
{    return new ResponseEntity<>(sensorIndexingConfigService.getAllIndices(writerName), HttpStatus.OK);}
 ResponseEntity<Void> metron_f1511_0(@ApiParam(name = "name", value = "SensorIndexingConfig name", required = true) @PathVariable String name) throws RestException
{    if (sensorIndexingConfigService.delete(name)) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<SensorParserConfig> metron_f1512_0(@ApiParam(name = "name", value = "SensorParserConfig name", required = true) @PathVariable String name, @ApiParam(name = "sensorParserConfig", value = "SensorParserConfig", required = true) @RequestBody SensorParserConfig sensorParserConfig) throws RestException
{    if (sensorParserConfigService.findOne(name) == null) {        return new ResponseEntity<>(sensorParserConfigService.save(name, sensorParserConfig), HttpStatus.CREATED);    } else {        return new ResponseEntity<>(sensorParserConfigService.save(name, sensorParserConfig), HttpStatus.OK);    }}
 ResponseEntity<SensorParserConfig> metron_f1513_0(@ApiParam(name = "name", value = "SensorParserConfig name", required = true) @PathVariable String name) throws RestException
{    SensorParserConfig sensorParserConfig = sensorParserConfigService.findOne(name);    if (sensorParserConfig != null) {        return new ResponseEntity<>(sensorParserConfig, HttpStatus.OK);    }    return new ResponseEntity<>(HttpStatus.NOT_FOUND);}
 ResponseEntity<Map<String, SensorParserConfig>> metron_f1514_0() throws RestException
{    return new ResponseEntity<>(sensorParserConfigService.getAll(), HttpStatus.OK);}
 ResponseEntity<Void> metron_f1515_0(@ApiParam(name = "name", value = "SensorParserConfig name", required = true) @PathVariable String name) throws RestException
{    if (sensorParserConfigService.delete(name)) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Map<String, String>> metron_f1516_0() throws RestException
{    return new ResponseEntity<>(sensorParserConfigService.getAvailableParsers(), HttpStatus.OK);}
 ResponseEntity<Map<String, String>> metron_f1517_0() throws RestException
{    return new ResponseEntity<>(sensorParserConfigService.reloadAvailableParsers(), HttpStatus.OK);}
 ResponseEntity<JSONObject> metron_f1518_0(@ApiParam(name = "parseMessageRequest", value = "Object containing a sample message and SensorParserConfig", required = true) @RequestBody ParseMessageRequest parseMessageRequest) throws RestException
{    return new ResponseEntity<>(sensorParserConfigService.parseMessage(parseMessageRequest), HttpStatus.OK);}
 ResponseEntity<SensorParserGroup> metron_f1519_0(@ApiParam(name = "sensorParserGroup", value = "SensorParserGroup", required = true) @RequestBody SensorParserGroup sensorParserGroup) throws RestException
{    if (sensorParserGroupService.findOne(sensorParserGroup.getName()) == null) {        return new ResponseEntity<>(sensorParserGroupService.save(sensorParserGroup), HttpStatus.CREATED);    } else {        return new ResponseEntity<>(sensorParserGroupService.save(sensorParserGroup), HttpStatus.OK);    }}
 ResponseEntity<SensorParserGroup> metron_f1520_0(@ApiParam(name = "name", value = "SensorParserGroup name", required = true) @PathVariable String name) throws RestException
{    SensorParserGroup sensorParserGroup = sensorParserGroupService.findOne(name);    if (sensorParserGroup != null) {        return new ResponseEntity<>(sensorParserGroup, HttpStatus.OK);    }    return new ResponseEntity<>(HttpStatus.NOT_FOUND);}
 ResponseEntity<Map<String, SensorParserGroup>> metron_f1521_0() throws RestException
{    return new ResponseEntity<>(sensorParserGroupService.getAll(), HttpStatus.OK);}
 ResponseEntity<Void> metron_f1522_0(@ApiParam(name = "name", value = "SensorParserGroup name", required = true) @PathVariable String name) throws RestException
{    if (sensorParserGroupService.delete(name)) {        return new ResponseEntity<>(HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Map<String, Boolean>> metron_f1523_0(@ApiParam(name = "statements", value = "List of statements to validate", required = true) @RequestBody List<String> statements) throws RestException
{    return new ResponseEntity<>(stellarService.validateRules(statements), HttpStatus.OK);}
 ResponseEntity<Map<String, Object>> metron_f1524_0(@ApiParam(name = "transformationValidation", value = "Object containing SensorParserConfig and sample message", required = true) @RequestBody SensorParserContext sensorParserContext) throws RestException
{    return new ResponseEntity<>(stellarService.applyTransformations(sensorParserContext), HttpStatus.OK);}
 ResponseEntity<FieldTransformations[]> metron_f1525_0() throws RestException
{    return new ResponseEntity<>(stellarService.getTransformations(), HttpStatus.OK);}
 ResponseEntity<List<StellarFunctionDescription>> metron_f1526_0() throws RestException
{    return new ResponseEntity<>(stellarService.getStellarFunctions(), HttpStatus.OK);}
 ResponseEntity<List<StellarFunctionDescription>> metron_f1527_0() throws RestException
{    return new ResponseEntity<>(stellarService.getSimpleStellarFunctions(), HttpStatus.OK);}
 ResponseEntity<SupervisorSummary> metron_f1528_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.getSupervisorSummary(), HttpStatus.OK);}
 ResponseEntity<List<TopologyStatus>> metron_f1529_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.getAllTopologyStatus(), HttpStatus.OK);}
 ResponseEntity<TopologyStatus> metron_f1530_0(@ApiParam(name = "name", value = "Topology name", required = true) @PathVariable String name) throws RestException
{    TopologyStatus topologyStatus = stormStatusService.getTopologyStatus(name);    if (topologyStatus != null) {        return new ResponseEntity<>(topologyStatus, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<TopologyResponse> metron_f1531_0(@ApiParam(name = "name", value = "Parser name", required = true) @PathVariable String name) throws RestException
{    return new ResponseEntity<>(stormAdminService.startParserTopology(name), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1532_0(@ApiParam(name = "name", value = "Parser name", required = true) @PathVariable String name, @ApiParam(name = "stopNow", value = "Stop the topology immediately") @RequestParam(required = false, defaultValue = "false") boolean stopNow) throws RestException
{    return new ResponseEntity<>(stormAdminService.stopParserTopology(name, stopNow), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1533_0(@ApiParam(name = "name", value = "Parser name", required = true) @PathVariable String name) throws RestException
{    return new ResponseEntity<>(stormStatusService.activateTopology(name), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1534_0(@ApiParam(name = "name", value = "Parser name", required = true) @PathVariable String name) throws RestException
{    return new ResponseEntity<>(stormStatusService.deactivateTopology(name), HttpStatus.OK);}
 ResponseEntity<TopologyStatus> metron_f1535_0() throws RestException
{    TopologyStatus sensorParserStatus = stormStatusService.getTopologyStatus(MetronRestConstants.ENRICHMENT_TOPOLOGY_NAME);    if (sensorParserStatus != null) {        return new ResponseEntity<>(sensorParserStatus, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<TopologyResponse> metron_f1536_0() throws RestException
{    return new ResponseEntity<>(stormAdminService.startEnrichmentTopology(), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1537_0(@ApiParam(name = "stopNow", value = "Stop the topology immediately") @RequestParam(required = false, defaultValue = "false") boolean stopNow) throws RestException
{    return new ResponseEntity<>(stormAdminService.stopEnrichmentTopology(stopNow), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1538_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.activateTopology(MetronRestConstants.ENRICHMENT_TOPOLOGY_NAME), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1539_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.deactivateTopology(MetronRestConstants.ENRICHMENT_TOPOLOGY_NAME), HttpStatus.OK);}
 ResponseEntity<TopologyStatus> metron_f1540_0() throws RestException
{    TopologyStatus topologyStatus = stormStatusService.getTopologyStatus(MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME);    if (topologyStatus != null) {        return new ResponseEntity<>(topologyStatus, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<TopologyResponse> metron_f1541_0() throws RestException
{    return new ResponseEntity<>(stormAdminService.startIndexingTopology(MetronRestConstants.RANDOM_ACCESS_INDEXING_SCRIPT_PATH_SPRING_PROPERTY), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1542_0(@ApiParam(name = "stopNow", value = "Stop the topology immediately") @RequestParam(required = false, defaultValue = "false") boolean stopNow) throws RestException
{    return new ResponseEntity<>(stormAdminService.stopIndexingTopology(MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME, stopNow), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1543_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.activateTopology(MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1544_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.deactivateTopology(MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME), HttpStatus.OK);}
 ResponseEntity<Map<String, String>> metron_f1545_0() throws RestException
{    return new ResponseEntity<>(stormAdminService.getStormClientStatus(), HttpStatus.OK);}
 ResponseEntity<TopologyStatus> metron_f1546_0() throws RestException
{    TopologyStatus topologyStatus = stormStatusService.getTopologyStatus(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME);    if (topologyStatus != null) {        return new ResponseEntity<>(topologyStatus, HttpStatus.OK);    } else {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<TopologyResponse> metron_f1547_0() throws RestException
{    return new ResponseEntity<>(stormAdminService.startIndexingTopology(MetronRestConstants.BATCH_INDEXING_SCRIPT_PATH_SPRING_PROPERTY), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1548_0(@ApiParam(name = "stopNow", value = "Stop the topology immediately") @RequestParam(required = false, defaultValue = "false") boolean stopNow) throws RestException
{    return new ResponseEntity<>(stormAdminService.stopIndexingTopology(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME, stopNow), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1549_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.activateTopology(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME), HttpStatus.OK);}
 ResponseEntity<TopologyResponse> metron_f1550_0() throws RestException
{    return new ResponseEntity<>(stormStatusService.deactivateTopology(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME), HttpStatus.OK);}
 ResponseEntity<Document> metron_f1551_0(@ApiParam(name = "request", value = "Patch request", required = true) @RequestBody final PatchRequest request) throws RestException
{    try {        return new ResponseEntity<>(service.patch(request), HttpStatus.OK);    } catch (OriginalNotFoundException e) {        return new ResponseEntity<>(HttpStatus.NOT_FOUND);    }}
 ResponseEntity<Document> metron_f1552_0(@RequestBody @ApiParam(name = "request", value = "Comment add request", required = true) final CommentAddRemoveRequest request) throws RestException
{    return new ResponseEntity<>(service.addComment(request), HttpStatus.OK);}
 ResponseEntity<Document> metron_f1553_0(@RequestBody @ApiParam(name = "request", value = "Comment remove request", required = true) final CommentAddRemoveRequest request) throws RestException
{    return new ResponseEntity<>(service.removeComment(request), HttpStatus.OK);}
public String metron_f1554_0(Principal user)
{    return user.getName();}
public List<String> metron_f1555_0()
{    UserDetails userDetails = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();    return userDetails.getAuthorities().stream().map(ga -> ga.getAuthority()).collect(Collectors.toList());}
protected ResponseEntity<Object> metron_f1556_1(HttpMessageNotReadableException ex, HttpHeaders headers, HttpStatus status, WebRequest request)
{        return super.handleHttpMessageNotReadable(ex, headers, status, request);}
public static void metron_f1557_0(String[] args)
{    ParserIndex.reload();    SpringApplication.run(MetronRestApplication.class, args);}
public String metron_f1558_0()
{    return this.fullMessage;}
public static String metron_f1559_0()
{    Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();    String user;    if (principal instanceof UserDetails) {        user = ((UserDetails) principal).getUsername();    } else {        user = principal.toString();    }    return user;}
public static RSAPublicKey metron_f1560_0(String pem) throws CertificateException, UnsupportedEncodingException
{    String PEM_HEADER = "-----BEGIN CERTIFICATE-----\n";    String PEM_FOOTER = "\n-----END CERTIFICATE-----";    String fullPem = (pem.startsWith(PEM_HEADER) && pem.endsWith(PEM_FOOTER)) ? pem : PEM_HEADER + pem + PEM_FOOTER;    PublicKey key = null;    try {        CertificateFactory fact = CertificateFactory.getInstance("X.509");        ByteArrayInputStream is = new ByteArrayInputStream(fullPem.getBytes(StandardCharsets.UTF_8));        X509Certificate cer = (X509Certificate) fact.generateCertificate(is);        key = cer.getPublicKey();    } catch (CertificateException ce) {        String message = null;        if (pem.startsWith(PEM_HEADER)) {            message = "CertificateException - be sure not to include PEM header " + "and footer in the PEM configuration element.";        } else {            message = "CertificateException - PEM may be corrupt";        }        throw new CertificateException(message, ce);    }    return (RSAPublicKey) key;}
public void metron_f1561_1(List<Map<String, Object>> alerts) throws RestException
{    String user = SecurityUtils.getCurrentUser();    String topic = environment.getProperty(KAFKA_TOPICS_ESCALATION_PROPERTY);    Long now = clock.currentTimeMillis();        try {        for (Map<String, Object> alert : alerts) {                        alert.put(METRON_ESCALATION_USER_FIELD, user);            alert.put(METRON_ESCALATION_TIMESTAMP_FIELD, now);                        String message = JSONUtils.INSTANCE.toJSON(alert, false);            kafkaService.produceMessage(topic, message);        }    } catch (JsonProcessingException e) {        throw new RestException(e);    }}
public Optional<AlertsUIUserSettings> metron_f1562_0() throws RestException
{    try {        Optional<String> alertUserSettings = userSettingsClient.findOne(SecurityUtils.getCurrentUser(), ALERT_USER_SETTING_TYPE);        if (alertUserSettings.isPresent()) {            return Optional.of(_mapper.get().readValue(alertUserSettings.get(), AlertsUIUserSettings.class));        } else {            return Optional.empty();        }    } catch (IOException e) {        throw new RestException(e);    }}
public Map<String, AlertsUIUserSettings> metron_f1563_0() throws RestException
{    Map<String, AlertsUIUserSettings> allAlertUserSettings = new HashMap<>();    try {        Map<String, Optional<String>> alertUserSettingsStrings = userSettingsClient.findAll(ALERT_USER_SETTING_TYPE);        for (Map.Entry<String, Optional<String>> entry : alertUserSettingsStrings.entrySet()) {            Optional<String> alertUserSettings = entry.getValue();            if (alertUserSettings.isPresent()) {                allAlertUserSettings.put(entry.getKey(), _mapper.get().readValue(alertUserSettings.get(), AlertsUIUserSettings.class));            }        }    } catch (IOException e) {        throw new RestException(e);    }    return allAlertUserSettings;}
public void metron_f1564_0(AlertsUIUserSettings alertsUIUserSettings) throws RestException
{    String user = SecurityUtils.getCurrentUser();    try {        userSettingsClient.save(user, ALERT_USER_SETTING_TYPE, _mapper.get().writeValueAsString(alertsUIUserSettings));    } catch (IOException e) {        throw new RestException(e);    }}
public boolean metron_f1565_0(String user)
{    boolean success = true;    try {        userSettingsClient.delete(user, ALERT_USER_SETTING_TYPE);    } catch (IOException e) {        success = false;    }    return success;}
public void metron_f1566_0(Clock clock)
{    this.clock = clock;}
public SupervisorSummary metron_f1567_1()
{    return (SupervisorSummary) statusCache.get(CacheKey.SUPERVISOR_SUMMARY, cacheKey -> {                return stormService.getSupervisorSummary();    });}
public TopologySummary metron_f1568_1()
{    return (TopologySummary) statusCache.get(CacheKey.TOPOLOGY_SUMMARY, cacheKey -> {                return stormService.getTopologySummary();    });}
public TopologyStatus metron_f1569_1(String name)
{    return (TopologyStatus) statusCache.get(CacheKey.TOPOLOGY_STATUS + name, cacheKey -> {                return stormService.getTopologyStatus(name);    });}
public List<TopologyStatus> metron_f1570_1()
{    return (List<TopologyStatus>) statusCache.get(CacheKey.ALL_TOPOLOGY_STATUS, cacheKey -> {                return stormService.getAllTopologyStatus();    });}
public TopologyResponse metron_f1571_0(String name)
{    return stormService.activateTopology(name);}
public TopologyResponse metron_f1572_0(String name)
{    return stormService.deactivateTopology(name);}
public void metron_f1573_0()
{    statusCache.invalidateAll();}
protected ProcessBuilder metron_f1574_0(final String... command)
{    final String[] dockerCommand = { "docker-compose", "-f", environment.getProperty("docker.compose.path"), "-p", "metron", "exec", "storm" };    final ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(dockerCommand, command));    final Map<String, String> pbEnvironment = pb.environment();    pbEnvironment.put("METRON_VERSION", environment.getProperty("metron.version"));    setDockerEnvironment(pbEnvironment);    return pb;}
private void metron_f1575_1(final Map<String, String> environmentVariables)
{    final ProcessBuilder pb = getDockerEnvironmentProcessBuilder();    try {        final Process process = pb.start();        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));        String line;        while ((line = inputStream.readLine()) != null) {            if (line.startsWith("export")) {                final String[] parts = line.replaceFirst("export ", "").split("=");                environmentVariables.put(parts[0], parts[1].replaceAll("\"", ""));            }        }        process.waitFor();    } catch (IOException | InterruptedException e) {            }}
private ProcessBuilder metron_f1576_0()
{    String[] command = { "docker-machine", "env", "metron-machine" };    return new ProcessBuilder(command);}
public void metron_f1577_0(ConfigurationsCache cache)
{    this.cache = cache;}
public Map<String, Object> metron_f1578_0(Map<String, Object> globalConfig) throws RestException
{    try {        ConfigurationsUtils.writeGlobalConfigToZookeeper(globalConfig, client);    } catch (Exception e) {        throw new RestException(e);    }    return globalConfig;}
public Map<String, Object> metron_f1579_0() throws RestException
{    Map<String, Object> globalConfig;    try {        EnrichmentConfigurations configs = cache.get(EnrichmentConfigurations.class);        globalConfig = configs.getGlobalConfig(false);    } catch (Exception e) {        throw new RestException(e.getMessage(), e);    }    return globalConfig;}
public boolean metron_f1580_0() throws RestException
{    try {        client.delete().forPath(ConfigurationType.GLOBAL.getZookeeperRoot());    } catch (KeeperException.NoNodeException e) {        return false;    } catch (Exception e) {        throw new RestException(e);    }    return true;}
public Map<String, String> metron_f1581_0()
{    return commonGrok.getPatterns();}
public GrokValidation metron_f1582_0(GrokValidation grokValidation) throws RestException
{    Map<String, Object> results;    try {        if (grokValidation.getPatternLabel() == null) {            throw new RestException("Pattern label is required");        }        if (Strings.isEmpty(grokValidation.getStatement())) {            throw new RestException("Grok statement is required");        }        Grok grok = new Grok();        grok.addPatternFromReader(new InputStreamReader(getClass().getResourceAsStream("/patterns/common"), StandardCharsets.UTF_8));        grok.addPatternFromReader(new StringReader(grokValidation.getStatement()));        String grokPattern = "%{" + grokValidation.getPatternLabel() + "}";        grok.compile(grokPattern);        Match gm = grok.match(grokValidation.getSampleData());        gm.captures();        results = gm.toMap();        results.remove(grokValidation.getPatternLabel());    } catch (Exception e) {        throw new RestException(e);    }    grokValidation.setResults(results);    return grokValidation;}
public Path metron_f1583_0(String statement, String name) throws RestException
{    if (statement != null) {        Path path = getTemporaryGrokRootPath();        hdfsService.mkdirs(path);        hdfsService.write(new Path(path, name), statement.getBytes(StandardCharsets.UTF_8), null, null, null);        return path;    } else {        throw new RestException("A grokStatement must be provided");    }}
public void metron_f1584_0() throws RestException
{    hdfsService.delete(getTemporaryGrokRootPath(), true);}
private Path metron_f1585_0()
{    String grokTempPath = environment.getProperty(GROK_TEMP_PATH_SPRING_PROPERTY);    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();    return new Path(grokTempPath, authentication.getName());}
public String metron_f1586_0(String path) throws RestException
{    try {        return IOUtils.toString(getClass().getResourceAsStream(path));    } catch (Exception e) {        throw new RestException("Could not find a statement at path " + path);    }}
public List<String> metron_f1587_0(Path path) throws RestException
{    try {        return Arrays.asList(FileSystem.get(configuration).listStatus(path)).stream().map(fileStatus -> fileStatus.getPath().getName()).collect(Collectors.toList());    } catch (IOException e) {        throw new RestException(e);    }}
public String metron_f1588_0(Path path) throws RestException
{    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    try {        IOUtils.copyBytes(FileSystem.get(configuration).open(path), byteArrayOutputStream, configuration);    } catch (FileNotFoundException e) {        return null;    } catch (IOException e) {        throw new RestException(e);    }    return new String(byteArrayOutputStream.toByteArray(), UTF_8);}
public void metron_f1589_0(Path path, byte[] contents, String userMode, String groupMode, String otherMode) throws RestException
{    FSDataOutputStream fsDataOutputStream;    try {        FsPermission permission = null;        boolean setPermissions = false;        if (StringUtils.isNotEmpty(userMode) && StringUtils.isNotEmpty(groupMode) && StringUtils.isNotEmpty(otherMode)) {                        FsAction userAction = FsAction.getFsAction(userMode);            FsAction groupAction = FsAction.getFsAction(groupMode);            FsAction otherAction = FsAction.getFsAction(otherMode);            if (userAction == null || groupAction == null || otherAction == null) {                throw new RestException(String.format("Invalid permission set: user[%s] " + "group[%s] other[%s]", userAction, groupAction, otherAction));            }            permission = new FsPermission(userAction, groupAction, otherAction);            setPermissions = true;        }        fsDataOutputStream = FileSystem.get(configuration).create(path, true);        fsDataOutputStream.write(contents);        fsDataOutputStream.close();        if (setPermissions) {            FileSystem.get(configuration).setPermission(path, permission);        }    } catch (IOException e) {        throw new RestException(e);    }}
public boolean metron_f1590_0(Path path, boolean recursive) throws RestException
{    try {        return FileSystem.get(configuration).delete(path, recursive);    } catch (IOException e) {        throw new RestException(e);    }}
public boolean metron_f1591_0(Path path) throws RestException
{    try {        return FileSystem.get(configuration).mkdirs(path);    } catch (IOException e) {        throw new RestException(e);    }}
public KafkaTopic metron_f1592_0(final KafkaTopic topic) throws RestException
{    if (!listTopics().contains(topic.getName())) {        try {            adminUtils.createTopic(zkUtils, topic.getName(), topic.getNumPartitions(), topic.getReplicationFactor(), topic.getProperties(), RackAwareMode.Disabled$.MODULE$);            if (environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)) {                addACLToCurrentUser(topic.getName());            }        } catch (AdminOperationException e) {            throw new RestException(e);        }    }    return topic;}
public boolean metron_f1593_0(final String name)
{    final Set<String> topics = listTopics();    if (topics != null && topics.contains(name)) {        adminUtils.deleteTopic(zkUtils, name);        return true;    } else {        return false;    }}
public KafkaTopic metron_f1594_0(final String name)
{    KafkaTopic kafkaTopic = null;    if (listTopics().contains(name)) {        try (Consumer<String, String> consumer = kafkaConsumerFactory.createConsumer()) {            final List<PartitionInfo> partitionInfos = consumer.partitionsFor(name);            if (partitionInfos.size() > 0) {                final PartitionInfo partitionInfo = partitionInfos.get(0);                kafkaTopic = new KafkaTopic();                kafkaTopic.setName(name);                kafkaTopic.setNumPartitions(partitionInfos.size());                kafkaTopic.setReplicationFactor(partitionInfo.replicas().length);            }        }    }    return kafkaTopic;}
public Set<String> metron_f1595_0()
{    try (Consumer<String, String> consumer = kafkaConsumerFactory.createConsumer()) {        final Map<String, List<PartitionInfo>> topicsInfo = consumer.listTopics();        final Set<String> topics = topicsInfo == null ? new HashSet<>() : topicsInfo.keySet();        topics.remove(CONSUMER_OFFSETS_TOPIC);        return topics;    }}
public String metron_f1596_0(final String topic)
{    String message = null;    if (listTopics().contains(topic)) {        try (Consumer<String, String> kafkaConsumer = kafkaConsumerFactory.createConsumer()) {            kafkaConsumer.assign(kafkaConsumer.partitionsFor(topic).stream().map(partitionInfo -> new TopicPartition(topic, partitionInfo.partition())).collect(Collectors.toList()));            kafkaConsumer.assignment().stream().filter(p -> (kafkaConsumer.position(p) - 1) >= 0).forEach(p -> kafkaConsumer.seek(p, kafkaConsumer.position(p) - 1));            final ConsumerRecords<String, String> records = kafkaConsumer.poll(KAFKA_CONSUMER_TIMEOUT);            message = records.isEmpty() ? null : records.iterator().next().value();            kafkaConsumer.unsubscribe();        }    }    return message;}
public void metron_f1597_0(String topic, String message) throws RestException
{    kafkaProducer.send(new ProducerRecord<>(topic, message));}
public boolean metron_f1598_0(String name)
{    if (listTopics().contains(name)) {        String zkServers = environment.getProperty(MetronRestConstants.ZK_URL_SPRING_PROPERTY);        User principal = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();        String user = principal.getUsername();        List<String> cmd = new ArrayList<>();        cmd.add("--add");        cmd.add("--allow-principal");        cmd.add("User:" + user);        cmd.add("--topic");        cmd.add(name);        cmd.add("--authorizer-properties");        cmd.add("zookeeper.connect=" + String.join(",", zkServers));        AclCommand.main(cmd.toArray(new String[cmd.size()]));    } else {        return false;    }    return true;}
public Document metron_f1599_0(MetaAlertCreateRequest createRequest) throws RestException
{    try {        return dao.createMetaAlert(createRequest);    } catch (InvalidCreateException | IOException e) {        throw new RestException(e.getMessage(), e);    }}
public SearchResponse metron_f1600_0(String guid) throws RestException
{    try {        return dao.getAllMetaAlertsForAlert(guid);    } catch (IOException | InvalidSearchException ise) {        throw new RestException(ise.getMessage(), ise);    }}
public Document metron_f1601_0(MetaAlertAddRemoveRequest metaAlertAddRemoveRequest) throws RestException
{    try {        return dao.addAlertsToMetaAlert(metaAlertAddRemoveRequest.getMetaAlertGuid(), metaAlertAddRemoveRequest.getAlerts());    } catch (IOException | IllegalStateException e) {        throw new RestException(e.getMessage(), e);    }}
public Document metron_f1602_0(MetaAlertAddRemoveRequest metaAlertAddRemoveRequest) throws RestException
{    try {        return dao.removeAlertsFromMetaAlert(metaAlertAddRemoveRequest.getMetaAlertGuid(), metaAlertAddRemoveRequest.getAlerts());    } catch (IOException | IllegalStateException e) {        throw new RestException(e.getMessage(), e);    }}
public Document metron_f1603_0(String metaAlertGuid, MetaAlertStatus status) throws RestException
{    try {        return dao.updateMetaAlertStatus(metaAlertGuid, status);    } catch (IOException ioe) {        throw new RestException(ioe.getMessage(), ioe);    }}
public PcapStatus metron_f1604_0(String username, PcapRequest pcapRequest) throws RestException
{    List<PcapStatus> runningJobs = getJobStatus(username, JobStatus.State.RUNNING);    Integer userJobLimit = environment.getProperty(MetronRestConstants.USER_JOB_LIMIT_SPRING_PROPERTY, Integer.class, 1);    if (runningJobs != null && runningJobs.size() >= userJobLimit) {        String jobIds = runningJobs.stream().map(PcapStatus::getJobId).collect(Collectors.joining(", "));        String message = String.format("Cannot submit job because a job is already running.  " + "Please contact the administrator to cancel job(s) with id(s) %s", jobIds);        throw new RestException(message);    }    try {        setPcapOptions(username, pcapRequest);        pcapRequest.setFields();        pcapJobSupplier.setPcapRequest(pcapRequest);        JobStatus jobStatus = jobManager.submit(pcapJobSupplier, username);        return jobStatusToPcapStatus(jobStatus);    } catch (IOException | JobException e) {        throw new RestException(e);    }}
public PcapStatus metron_f1605_1(String username, String jobId) throws RestException
{    PcapStatus pcapStatus = null;    try {        Statusable<Path> statusable = jobManager.getJob(username, jobId);        if (statusable != null) {            pcapStatus = statusableToPcapStatus(statusable);        }    } catch (JobNotFoundException | InterruptedException e) {            } catch (JobException e) {        throw new RestException(e);    }    return pcapStatus;}
public List<PcapStatus> metron_f1606_0(String username, JobStatus.State state) throws RestException
{    List<PcapStatus> pcapStatuses = new ArrayList<>();    try {        List<Statusable<Path>> statusables = jobManager.getJobs(username);        if (statusables != null) {            pcapStatuses = statusables.stream().filter(statusable -> {                try {                    return statusable.getStatus().getState() == state;                } catch (JobException e) {                    return JobStatus.State.FAILED == state;                }            }).map(statusable -> {                try {                    return statusableToPcapStatus(statusable);                } catch (JobException | InterruptedException e) {                    PcapStatus pcapStatus = new PcapStatus();                    pcapStatus.setJobStatus(JobStatus.State.FAILED.toString());                    pcapStatus.setDescription(e.getMessage());                    return pcapStatus;                }            }).collect(Collectors.toList());        }    } catch (JobNotFoundException e) {        } catch (JobException e) {        throw new RestException(e);    }    return pcapStatuses;}
public PcapStatus metron_f1607_1(String username, String jobId) throws RestException
{    try {        jobManager.killJob(username, jobId);    } catch (JobNotFoundException e) {                return null;    } catch (JobException e) {        throw new RestException(e);    }    return getJobStatus(username, jobId);}
public Path metron_f1608_1(String username, String jobId, Integer page) throws RestException
{    Path path = null;    try {        Statusable<Path> statusable = jobManager.getJob(username, jobId);        if (statusable != null && statusable.isDone()) {            Pageable<Path> pageable = statusable.get();            if (pageable != null && page <= pageable.getSize() && page > 0) {                path = pageable.getPage(page - 1);            }        }    } catch (JobNotFoundException e) {            } catch (JobException | InterruptedException e) {        throw new RestException(e);    }    return path;}
public Pdml metron_f1609_0(String username, String jobId, Integer page) throws RestException
{    Pdml pdml = null;    Path path = getPath(username, jobId, page);    try {        FileSystem fileSystem = getFileSystem();        if (path != null && fileSystem.exists(path)) {            String scriptPath = environment.getProperty(MetronRestConstants.PCAP_PDML_SCRIPT_PATH_SPRING_PROPERTY);            InputStream processInputStream = pcapToPdmlScriptWrapper.execute(scriptPath, fileSystem, path);            pdml = new XmlMapper().readValue(processInputStream, Pdml.class);            processInputStream.close();        }    } catch (IOException e) {        throw new RestException(e);    }    return pdml;}
public InputStream metron_f1610_0(String username, String jobId, Integer page) throws RestException
{    InputStream inputStream = null;    Path path = getPath(username, jobId, page);    try {        FileSystem fileSystem = getFileSystem();        if (path != null && fileSystem.exists(path)) {            inputStream = fileSystem.open(path);        }    } catch (IOException e) {        throw new RestException(e);    }    return inputStream;}
public Map<String, Object> metron_f1611_1(String username, String jobId) throws RestException
{    Map<String, Object> configuration = new HashMap<>();    try {        Statusable<Path> statusable = jobManager.getJob(username, jobId);        if (statusable != null) {            Map<String, Object> jobConfiguration = statusable.getConfiguration();            configuration.put(PcapOptions.BASE_PATH.getKey(), PcapOptions.BASE_PATH.get(jobConfiguration, String.class));            configuration.put(PcapOptions.FINAL_OUTPUT_PATH.getKey(), PcapOptions.FINAL_OUTPUT_PATH.get(jobConfiguration, String.class));            configuration.put(PcapOptions.START_TIME_MS.getKey(), PcapOptions.START_TIME_MS.get(jobConfiguration, Long.class));            configuration.put(PcapOptions.END_TIME_MS.getKey(), PcapOptions.END_TIME_MS.get(jobConfiguration, Long.class));            configuration.put(PcapOptions.NUM_REDUCERS.getKey(), PcapOptions.NUM_REDUCERS.get(jobConfiguration, Integer.class));            boolean isFixedFilter = PcapOptions.FILTER_IMPL.get(jobConfiguration, PcapFilterConfigurator.class) instanceof FixedPcapFilter.Configurator;            if (isFixedFilter) {                configuration.put(FixedPcapOptions.IP_SRC_ADDR.getKey(), FixedPcapOptions.IP_SRC_ADDR.get(jobConfiguration, String.class));                configuration.put(FixedPcapOptions.IP_DST_ADDR.getKey(), FixedPcapOptions.IP_DST_ADDR.get(jobConfiguration, String.class));                configuration.put(FixedPcapOptions.IP_SRC_PORT.getKey(), FixedPcapOptions.IP_SRC_PORT.get(jobConfiguration, Integer.class));                configuration.put(FixedPcapOptions.IP_DST_PORT.getKey(), FixedPcapOptions.IP_DST_PORT.get(jobConfiguration, Integer.class));                configuration.put(FixedPcapOptions.PROTOCOL.getKey(), FixedPcapOptions.PROTOCOL.get(jobConfiguration, String.class));                configuration.put(FixedPcapOptions.PACKET_FILTER.getKey(), FixedPcapOptions.PACKET_FILTER.get(jobConfiguration, String.class));                configuration.put(FixedPcapOptions.INCLUDE_REVERSE.getKey(), FixedPcapOptions.INCLUDE_REVERSE.get(jobConfiguration, Boolean.class));            } else {                configuration.put(QueryPcapOptions.QUERY.getKey(), QueryPcapOptions.QUERY.get(jobConfiguration, String.class));            }        }    } catch (JobNotFoundException e) {            } catch (JobException e) {        throw new RestException(e);    }    return configuration;}
protected void metron_f1612_0(String username, PcapRequest pcapRequest) throws IOException
{    PcapOptions.JOB_NAME.put(pcapRequest, "jobName");    PcapOptions.USERNAME.put(pcapRequest, username);    Configuration hadoopConf = new Configuration(configuration);    if (environment.containsProperty(PCAP_YARN_QUEUE_SPRING_PROPERTY)) {        String queue = environment.getProperty(PCAP_YARN_QUEUE_SPRING_PROPERTY);        if (queue != null && !queue.isEmpty()) {            hadoopConf.set(MRJobConfig.QUEUE_NAME, environment.getProperty(PCAP_YARN_QUEUE_SPRING_PROPERTY));        }    }    PcapOptions.HADOOP_CONF.put(pcapRequest, hadoopConf);    PcapOptions.FILESYSTEM.put(pcapRequest, getFileSystem());    if (pcapRequest.getBasePath() == null) {        pcapRequest.setBasePath(environment.getProperty(MetronRestConstants.PCAP_BASE_PATH_SPRING_PROPERTY));    }    if (pcapRequest.getBaseInterimResultPath() == null) {        pcapRequest.setBaseInterimResultPath(environment.getProperty(MetronRestConstants.PCAP_BASE_INTERIM_RESULT_PATH_SPRING_PROPERTY));    }    if (pcapRequest.getFinalOutputPath() == null) {        pcapRequest.setFinalOutputPath(environment.getProperty(MetronRestConstants.PCAP_FINAL_OUTPUT_PATH_SPRING_PROPERTY));    }    PcapOptions.NUM_RECORDS_PER_FILE.put(pcapRequest, Integer.parseInt(environment.getProperty(MetronRestConstants.PCAP_PAGE_SIZE_SPRING_PROPERTY)));    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(pcapRequest, environment.getProperty(MetronRestConstants.PCAP_FINALIZER_THREADPOOL_SIZE_SPRING_PROPERTY));}
protected FileSystem metron_f1613_0() throws IOException
{    return FileSystem.get(configuration);}
protected PcapStatus metron_f1614_0(Statusable<Path> statusable) throws JobException, InterruptedException
{    PcapStatus pcapStatus = jobStatusToPcapStatus(statusable.getStatus());    if (statusable.isDone()) {        Pageable<Path> pageable = statusable.get();        if (pageable != null) {            pcapStatus.setPageTotal(pageable.getSize());        }    }    return pcapStatus;}
protected PcapStatus metron_f1615_0(JobStatus jobStatus)
{    PcapStatus pcapStatus = new PcapStatus();    pcapStatus.setJobId(jobStatus.getJobId());    pcapStatus.setJobStatus(jobStatus.getState().toString());    pcapStatus.setDescription(jobStatus.getDescription());    pcapStatus.setPercentComplete(jobStatus.getPercentComplete());    return pcapStatus;}
public InputStream metron_f1616_0(String scriptPath, FileSystem fileSystem, Path pcapPath) throws IOException
{    ProcessBuilder processBuilder = getProcessBuilder(scriptPath, pcapPath.toUri().getPath());    Process process = processBuilder.start();    InputStream rawInputStream = getRawInputStream(fileSystem, pcapPath);    OutputStream processOutputStream = process.getOutputStream();    IOUtils.copy(rawInputStream, processOutputStream);    rawInputStream.close();    if (process.isAlive()) {                processOutputStream.close();        return process.getInputStream();    } else {        String errorMessage = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);        throw new IOException(errorMessage);    }}
protected InputStream metron_f1617_0(FileSystem fileSystem, Path path) throws IOException
{    return fileSystem.open(path);}
protected ProcessBuilder metron_f1618_0(String... command)
{    return new ProcessBuilder(command);}
public SearchResponse metron_f1619_0(SearchRequest searchRequest) throws RestException
{    try {        if (searchRequest.getIndices() == null || searchRequest.getIndices().isEmpty()) {            List<String> indices = getDefaultIndices();                        indices.add(METAALERT_TYPE);            searchRequest.setIndices(indices);        }        if (searchRequest.getFacetFields() != null && searchRequest.getFacetFields().isEmpty()) {            searchRequest.setFacetFields(getDefaultFacetFields());        }        return dao.search(searchRequest);    } catch (InvalidSearchException ise) {        throw new RestException(ise.getMessage(), ise);    }}
public GroupResponse metron_f1620_0(GroupRequest groupRequest) throws RestException
{    try {        if (groupRequest.getIndices() == null || groupRequest.getIndices().isEmpty()) {            groupRequest.setIndices(getDefaultIndices());        }        return dao.group(groupRequest);    } catch (InvalidSearchException ise) {        throw new RestException(ise.getMessage(), ise);    }}
public Optional<Map<String, Object>> metron_f1621_0(GetRequest request) throws RestException
{    try {        return dao.getLatestResult(request);    } catch (IOException e) {        throw new RestException(e.getMessage(), e);    }}
public Map<String, FieldType> metron_f1622_1(List<String> indices) throws RestException
{    try {        if (indices == null || indices.isEmpty()) {            indices = getDefaultIndices();                        indices.add(METAALERT_TYPE);                    }        return dao.getColumnMetadata(indices);    } catch (IOException ioe) {        throw new RestException(ioe.getMessage(), ioe);    }}
private List<String> metron_f1623_0() throws RestException
{        List<String> indices = Lists.newArrayList((sensorIndexingConfigService.getAllIndices(environment.getProperty(INDEX_WRITER_NAME))));        indices.remove(ERROR_TYPE);    return indices;}
public List<String> metron_f1624_0() throws RestException
{    Optional<AlertsUIUserSettings> alertUserSettings = alertsUIService.getAlertsUIUserSettings();    if (!alertUserSettings.isPresent() || alertUserSettings.get().getFacetFields() == null) {        String facetFieldsProperty = environment.getProperty(SEARCH_FACET_FIELDS_SPRING_PROPERTY, String.class, "");        String sourceTypeField = ConfigurationsUtils.getFieldName(globalConfigService.get(), SENSOR_TYPE_FIELD_PROPERTY, Constants.SENSOR_TYPE.replace('.', ':'));        List<String> facetFields = new ArrayList<>();        facetFields.add(sourceTypeField);        if (facetFieldsProperty != null) {            facetFields.addAll(Arrays.asList(facetFieldsProperty.split(",")));        }        return facetFields;    } else {        return alertUserSettings.get().getFacetFields();    }}
public SensorEnrichmentConfig metron_f1625_0(String name, SensorEnrichmentConfig sensorEnrichmentConfig) throws RestException
{    try {        ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(name, objectMapper.writeValueAsString(sensorEnrichmentConfig).getBytes(StandardCharsets.UTF_8), client);    } catch (Exception e) {        throw new RestException(e);    }    return sensorEnrichmentConfig;}
public SensorEnrichmentConfig metron_f1626_0(String name) throws RestException
{    EnrichmentConfigurations configs = cache.get(EnrichmentConfigurations.class);    return configs.getSensorEnrichmentConfig(name);}
public Map<String, SensorEnrichmentConfig> metron_f1627_0() throws RestException
{    Map<String, SensorEnrichmentConfig> sensorEnrichmentConfigs = new HashMap<>();    List<String> sensorNames = getAllTypes();    for (String name : sensorNames) {        SensorEnrichmentConfig config = findOne(name);        if (config != null) {            sensorEnrichmentConfigs.put(name, config);        }    }    return sensorEnrichmentConfigs;}
public List<String> metron_f1628_0() throws RestException
{    EnrichmentConfigurations configs = cache.get(EnrichmentConfigurations.class);    return configs.getTypes();}
public boolean metron_f1629_0(String name) throws RestException
{    try {        client.delete().forPath(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/" + name);    } catch (KeeperException.NoNodeException e) {        return false;    } catch (Exception e) {        throw new RestException(e);    }    return true;}
public List<String> metron_f1630_0() throws RestException
{    try {        List<String> enrichments = hBaseClient.readRecords();        enrichments.sort(Comparator.naturalOrder());        return enrichments;    } catch (IOException e) {        throw new RestException("Unable to retrieve enrichments", e);    }}
public List<String> metron_f1631_0()
{    return Arrays.asList(Aggregators.values()).stream().map(Enum::toString).collect(Collectors.toList());}
public Map<String, Object> metron_f1632_0(String name, Map<String, Object> sensorIndexingConfig) throws RestException
{    try {        ConfigurationsUtils.writeSensorIndexingConfigToZookeeper(name, objectMapper.writeValueAsString(sensorIndexingConfig).getBytes(StandardCharsets.UTF_8), client);    } catch (Exception e) {        throw new RestException(e);    }    return sensorIndexingConfig;}
public Map<String, Object> metron_f1633_0(String name) throws RestException
{    IndexingConfigurations configs = cache.get(IndexingConfigurations.class);    return configs.getSensorIndexingConfig(name, false);}
public Map<String, Map<String, Object>> metron_f1634_0() throws RestException
{    Map<String, Map<String, Object>> sensorIndexingConfigs = new HashMap<>();    List<String> sensorNames = getAllTypes();    for (String name : sensorNames) {        Map<String, Object> config = findOne(name);        if (config != null) {            sensorIndexingConfigs.put(name, config);        }    }    return sensorIndexingConfigs;}
public List<String> metron_f1635_0() throws RestException
{    IndexingConfigurations configs = cache.get(IndexingConfigurations.class);    return configs.getTypes();}
public Iterable<String> metron_f1636_0(String writerName) throws RestException
{    if (StringUtils.isEmpty(writerName)) {        return Collections.emptyList();    }    IndexingConfigurations indexingConfigs = cache.get(IndexingConfigurations.class);    ParserConfigurations parserConfigs = cache.get(ParserConfigurations.class);    Set<String> ret = new HashSet<>();    for (String sensorName : Iterables.concat(parserConfigs.getTypes(), indexingConfigs.getTypes())) {        if (indexingConfigs.isEnabled(sensorName, writerName)) {            String indexName = indexingConfigs.getIndex(sensorName, writerName);            ret.add(indexName == null ? sensorName : indexName);        }    }    return ret;}
public boolean metron_f1637_0(String name) throws RestException
{    try {        client.delete().forPath(ConfigurationType.INDEXING.getZookeeperRoot() + "/" + name);    } catch (KeeperException.NoNodeException e) {        return false;    } catch (Exception e) {        throw new RestException(e);    }    return true;}
public SensorParserConfig metron_f1638_0(String name, SensorParserConfig sensorParserConfig) throws RestException
{    try {        ConfigurationsUtils.writeSensorParserConfigToZookeeper(name, objectMapper.writeValueAsString(sensorParserConfig).getBytes(StandardCharsets.UTF_8), client);    } catch (Exception e) {        throw new RestException(e);    }    return sensorParserConfig;}
public SensorParserConfig metron_f1639_0(String name) throws RestException
{    ParserConfigurations configs = cache.get(ParserConfigurations.class);    return configs.getSensorParserConfig(name);}
public Map<String, SensorParserConfig> metron_f1640_0() throws RestException
{    Map<String, SensorParserConfig> sensorParserConfigs = new HashMap<>();    List<String> sensorNames = getAllTypes();    for (String name : sensorNames) {        SensorParserConfig config = findOne(name);        if (config != null) {            sensorParserConfigs.put(name, config);        }    }    return sensorParserConfigs;}
public boolean metron_f1641_0(String name) throws RestException
{    try {        client.delete().forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/" + name);    } catch (KeeperException.NoNodeException e) {        return false;    } catch (Exception e) {        throw new RestException(e);    }    return true;}
public List<String> metron_f1642_0() throws RestException
{    ParserConfigurations configs = cache.get(ParserConfigurations.class);    return configs.getTypes();}
public Map<String, String> metron_f1643_0()
{    return ParserIndex.INSTANCE.getIndex();}
public Map<String, String> metron_f1644_0()
{    ParserIndex.INSTANCE.reload();    return getAvailableParsers();}
public JSONObject metron_f1645_0(ParseMessageRequest parseMessageRequest) throws RestException
{    SensorParserConfig sensorParserConfig = parseMessageRequest.getSensorParserConfig();    if (sensorParserConfig == null) {        throw new RestException("SensorParserConfig is missing from ParseMessageRequest");    } else if (sensorParserConfig.getParserClassName() == null) {        throw new RestException("SensorParserConfig must have a parserClassName");    } else {        MessageParser<JSONObject> parser;        try {            parser = (MessageParser<JSONObject>) Class.forName(sensorParserConfig.getParserClassName()).newInstance();        } catch (Exception e) {            throw new RestException(e.toString(), e.getCause());        }        Path temporaryGrokPath = null;        if (isGrokConfig(sensorParserConfig)) {            String name = parseMessageRequest.getSensorParserConfig().getSensorTopic();            temporaryGrokPath = grokService.saveTemporary(parseMessageRequest.getGrokStatement(), name);            sensorParserConfig.getParserConfig().put(MetronRestConstants.GROK_PATH_KEY, new Path(temporaryGrokPath, name).toString());        }        parser.configure(sensorParserConfig.getParserConfig());        parser.init();        Optional<MessageParserResult<JSONObject>> result = parser.parseOptionalResult(parseMessageRequest.getSampleData().getBytes(StandardCharsets.UTF_8));        if (!result.isPresent()) {            throw new RestException("Unknown error parsing sample data");        }        if (result.get().getMasterThrowable().isPresent()) {            throw new RestException("Error parsing sample data", result.get().getMasterThrowable().get());        }        if (result.get().getMessages().isEmpty()) {            throw new RestException("No results from parsing sample data");        }        if (isGrokConfig(sensorParserConfig) && temporaryGrokPath != null) {            grokService.deleteTemporary();        }        return result.get().getMessages().get(0);    }}
private boolean metron_f1646_0(SensorParserConfig sensorParserConfig)
{    return GROK_CLASS_NAME.equals(sensorParserConfig.getParserClassName());}
public SensorParserGroup metron_f1647_0(SensorParserGroup sensorParserGroup) throws RestException
{    ParserConfigurations parserConfigurations = cache.get(ParserConfigurations.class);    Map<String, SensorParserGroup> groups = new HashMap<>(parserConfigurations.getSensorParserGroups());    groups.remove(sensorParserGroup.getName());    if (sensorParserGroup.getSensors().size() == 0) {        throw new RestException("A parser group must contain sensors");    }    for (String sensor : sensorParserGroup.getSensors()) {                if (sensorParserConfigService.findOne(sensor) == null) {            throw new RestException(String.format("Could not find config for sensor %s", sensor));        }                for (SensorParserGroup group : groups.values()) {            Set<String> groupSensors = group.getSensors();            if (groupSensors.contains(sensor)) {                throw new RestException(String.format("Sensor %s is already in group %s", sensor, group.getName()));            }        }    }    groups.put(sensorParserGroup.getName(), sensorParserGroup);    saveGroups(parserConfigurations, new HashSet<>(groups.values()));    return sensorParserGroup;}
public SensorParserGroup metron_f1648_0(String name)
{    return getAll().get(name);}
public Map<String, SensorParserGroup> metron_f1649_0()
{    ParserConfigurations configs = cache.get(ParserConfigurations.class);    return configs.getSensorParserGroups();}
public boolean metron_f1650_0(String name) throws RestException
{    ParserConfigurations parserConfigurations = cache.get(ParserConfigurations.class);    Map<String, SensorParserGroup> groups = parserConfigurations.getSensorParserGroups();    boolean deleted = false;    if (groups.containsKey(name)) {        groups.remove(name);        saveGroups(parserConfigurations, new HashSet<>(groups.values()));        deleted = true;    }    return deleted;}
private void metron_f1651_0(ParserConfigurations parserConfigurations, Collection<SensorParserGroup> groups) throws RestException
{    Map<String, Object> globalConfig = parserConfigurations.getGlobalConfig(true);    globalConfig.put(ParserConfigurations.PARSER_GROUPS_CONF, groups);    globalConfigService.save(globalConfig);}
public Map<String, Boolean> metron_f1652_0(List<String> rules)
{    Map<String, Boolean> results = new HashMap<>();    StellarProcessor stellarProcessor = new StellarProcessor();    for (String rule : rules) {        try {            boolean result = stellarProcessor.validate(rule, Context.EMPTY_CONTEXT());            results.put(rule, result);        } catch (ParseException e) {            results.put(rule, false);        }    }    return results;}
public Map<String, Object> metron_f1653_0(SensorParserContext sensorParserContext)
{    JSONObject sampleJson = new JSONObject(sensorParserContext.getSampleData());    sensorParserContext.getSensorParserConfig().getFieldTransformations().forEach(fieldTransformer -> {        fieldTransformer.transformAndUpdate(sampleJson, Context.EMPTY_CONTEXT(), sensorParserContext.getSensorParserConfig().getParserConfig());    });    return sampleJson;}
public FieldTransformations[] metron_f1654_0()
{    return FieldTransformations.values();}
public List<StellarFunctionDescription> metron_f1655_0()
{    List<StellarFunctionDescription> stellarFunctionDescriptions = new ArrayList<>();    Iterable<StellarFunctionInfo> stellarFunctionsInfo = StellarFunctions.FUNCTION_RESOLVER().getFunctionInfo();    stellarFunctionsInfo.forEach(stellarFunctionInfo -> {        stellarFunctionDescriptions.add(new StellarFunctionDescription(stellarFunctionInfo.getName(), stellarFunctionInfo.getDescription(), stellarFunctionInfo.getParams(), stellarFunctionInfo.getReturns()));    });    return stellarFunctionDescriptions;}
public List<StellarFunctionDescription> metron_f1656_0()
{    List<StellarFunctionDescription> stellarFunctionDescriptions = getStellarFunctions();    return stellarFunctionDescriptions.stream().filter(stellarFunctionDescription -> stellarFunctionDescription.getParams().length == 1).sorted((o1, o2) -> o1.getName().compareTo(o2.getName())).collect(Collectors.toList());}
public TopologyResponse metron_f1657_0(String name) throws RestException
{    TopologyResponse topologyResponse = new TopologyResponse();    if (globalConfigService.get() == null) {        topologyResponse.setErrorMessage(TopologyStatusCode.GLOBAL_CONFIG_MISSING.toString());        return topologyResponse;    }    List<String> sensorTypes = Collections.singletonList(name);        SensorParserGroup sensorParserGroup = sensorParserGroupService.findOne(name);    if (sensorParserGroup != null) {        sensorTypes = new ArrayList<>(sensorParserGroup.getSensors());    }    for (String sensorType : sensorTypes) {        if (sensorParserConfigService.findOne(sensorType.trim()) == null) {            topologyResponse.setErrorMessage(TopologyStatusCode.SENSOR_PARSER_CONFIG_MISSING.toString());            return topologyResponse;        }    }        Collections.sort(sensorTypes);    return createResponse(stormCLIClientWrapper.startParserTopology(String.join(ParserTopologyCLI.TOPOLOGY_OPTION_SEPARATOR, sensorTypes)), TopologyStatusCode.STARTED, TopologyStatusCode.START_ERROR);}
public TopologyResponse metron_f1658_0(String name, boolean stopNow) throws RestException
{        TopologyStatus topologyStatus = stormStatusService.getTopologyStatus(name);    String jobName = topologyStatus != null ? topologyStatus.getName() : name;    return createResponse(stormCLIClientWrapper.stopParserTopology(jobName, stopNow), TopologyStatusCode.STOPPED, TopologyStatusCode.STOP_ERROR);}
public TopologyResponse metron_f1659_0() throws RestException
{    return createResponse(stormCLIClientWrapper.startEnrichmentTopology(), TopologyStatusCode.STARTED, TopologyStatusCode.START_ERROR);}
public TopologyResponse metron_f1660_0(boolean stopNow) throws RestException
{    return createResponse(stormCLIClientWrapper.stopEnrichmentTopology(stopNow), TopologyStatusCode.STOPPED, TopologyStatusCode.STOP_ERROR);}
public TopologyResponse metron_f1661_0(String scriptPath) throws RestException
{    return createResponse(stormCLIClientWrapper.startIndexingTopology(scriptPath), TopologyStatusCode.STARTED, TopologyStatusCode.START_ERROR);}
public TopologyResponse metron_f1662_0(String name, boolean stopNow) throws RestException
{    return createResponse(stormCLIClientWrapper.stopIndexingTopology(name, stopNow), TopologyStatusCode.STOPPED, TopologyStatusCode.STOP_ERROR);}
private TopologyResponse metron_f1663_0(int responseCode, TopologyStatusCode successMessage, TopologyStatusCode errorMessage)
{    TopologyResponse topologyResponse = new TopologyResponse();    if (responseCode == 0) {        topologyResponse.setSuccessMessage(successMessage.toString());    } else {        topologyResponse.setErrorMessage(errorMessage.toString());    }    return topologyResponse;}
public Map<String, String> metron_f1664_0() throws RestException
{    return stormCLIClientWrapper.getStormClientStatus();}
public void metron_f1665_0(final Environment environment)
{    this.environment = environment;}
public int metron_f1666_0(String name) throws RestException
{    kinit();    return runCommand(getParserStartCommand(name));}
public int metron_f1667_0(String name, boolean stopNow) throws RestException
{    kinit();    return runCommand(getStopCommand(name, stopNow));}
public int metron_f1668_0() throws RestException
{    kinit();    return runCommand(getEnrichmentStartCommand());}
public int metron_f1669_0(boolean stopNow) throws RestException
{    kinit();    return runCommand(getStopCommand(ENRICHMENT_TOPOLOGY_NAME, stopNow));}
public int metron_f1670_0(String scriptPath) throws RestException
{    kinit();    return runCommand(getIndexingStartCommand(scriptPath));}
public int metron_f1671_0(String name, boolean stopNow) throws RestException
{    kinit();    return runCommand(getStopCommand(name, stopNow));}
protected int metron_f1672_1(String[] command) throws RestException
{    ProcessBuilder pb = getProcessBuilder(command);    pb.inheritIO();        Process process;    try {        process = pb.start();        process.waitFor();    } catch (Exception e) {        throw new RestException(e);    }    int exitValue = process.exitValue();        return exitValue;}
protected String[] metron_f1673_0(String names)
{    List<String> command = new ArrayList<>();    command.add(environment.getProperty(MetronRestConstants.PARSER_SCRIPT_PATH_SPRING_PROPERTY));        command.add("-s");    command.add(names);        command.add("-z");    command.add(environment.getProperty(MetronRestConstants.ZK_URL_SPRING_PROPERTY));        command.add("-k");    command.add(environment.getProperty(MetronRestConstants.KAFKA_BROKER_URL_SPRING_PROPERTY));        command.add("-ksp");    command.add(KafkaUtils.INSTANCE.normalizeProtocol(environment.getProperty(MetronRestConstants.KAFKA_SECURITY_PROTOCOL_SPRING_PROPERTY)));        boolean kerberosEnabled = environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false);    boolean topologyOptionsDefined = StringUtils.isNotBlank(environment.getProperty(MetronRestConstants.PARSER_TOPOLOGY_OPTIONS_SPRING_PROPERTY));    if (kerberosEnabled && topologyOptionsDefined) {        command.add("-e");        command.add(environment.getProperty(MetronRestConstants.PARSER_TOPOLOGY_OPTIONS_SPRING_PROPERTY));    }    return command.toArray(new String[0]);}
protected String[] metron_f1674_0()
{    String[] command = new String[1];    command[0] = environment.getProperty(MetronRestConstants.ENRICHMENT_SCRIPT_PATH_SPRING_PROPERTY);    return command;}
protected String[] metron_f1675_0(String scriptPath)
{    String[] command = new String[1];    command[0] = environment.getProperty(scriptPath);    return command;}
protected String[] metron_f1676_0(String name, boolean stopNow)
{    String[] command;    if (stopNow) {        command = new String[5];        command[3] = "-w";        command[4] = "0";    } else {        command = new String[3];    }    command[0] = "storm";    command[1] = "kill";    command[2] = name;    return command;}
protected ProcessBuilder metron_f1677_0(String... command)
{    return new ProcessBuilder(command);}
public Map<String, String> metron_f1678_0() throws RestException
{    Map<String, String> status = new HashMap<>();    status.put("parserScriptPath", environment.getProperty(MetronRestConstants.PARSER_SCRIPT_PATH_SPRING_PROPERTY));    status.put("enrichmentScriptPath", environment.getProperty(MetronRestConstants.ENRICHMENT_SCRIPT_PATH_SPRING_PROPERTY));    status.put("randomAccessIndexingScriptPath", environment.getProperty(MetronRestConstants.RANDOM_ACCESS_INDEXING_SCRIPT_PATH_SPRING_PROPERTY));    status.put("batchIndexingScriptPath", environment.getProperty(MetronRestConstants.BATCH_INDEXING_SCRIPT_PATH_SPRING_PROPERTY));    status.put("stormClientVersionInstalled", stormClientVersionInstalled());    return status;}
protected String metron_f1679_0() throws RestException
{    String stormClientVersionInstalled = "Storm client is not installed";    ProcessBuilder pb = getProcessBuilder("storm", "version");    pb.redirectErrorStream(true);    Process p;    try {        p = pb.start();    } catch (IOException e) {        throw new RestException(e);    }    BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream(), StandardCharsets.UTF_8));    List<String> lines = reader.lines().collect(toList());    lines.forEach(System.out::println);    if (lines.size() > 1) {        stormClientVersionInstalled = lines.get(1).replaceFirst("Storm ", "");    }    return stormClientVersionInstalled;}
protected void metron_f1680_0() throws RestException
{    if (environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)) {        String keyTabLocation = environment.getProperty(MetronRestConstants.KERBEROS_KEYTAB_SPRING_PROPERTY);        String userPrincipal = environment.getProperty(MetronRestConstants.KERBEROS_PRINCIPLE_SPRING_PROPERTY);        String[] kinitCommand = { "kinit", "-kt", keyTabLocation, userPrincipal };        runCommand(kinitCommand);    }}
public SupervisorSummary metron_f1681_0()
{    return restTemplate.getForObject(getStormUiProperty() + SUPERVISOR_SUMMARY_URL, SupervisorSummary.class);}
public TopologySummary metron_f1682_0()
{    return restTemplate.getForObject(getStormUiProperty() + TOPOLOGY_SUMMARY_URL, TopologySummary.class);}
public TopologyStatus metron_f1683_0(String name)
{    TopologyStatus topologyResponse = null;    String id = getTopologyId(name);    if (id != null) {        topologyResponse = restTemplate.getForObject(getStormUiProperty() + TOPOLOGY_URL + "/" + id, TopologyStatus.class);    }    return topologyResponse;}
public List<TopologyStatus> metron_f1684_0()
{    List<TopologyStatus> topologyStatus = new ArrayList<>();    for (TopologyStatus topology : getTopologySummary().getTopologies()) {        topologyStatus.add(restTemplate.getForObject(getStormUiProperty() + TOPOLOGY_URL + "/" + topology.getId(), TopologyStatus.class));    }    return topologyStatus;}
public TopologyResponse metron_f1685_0(String name)
{    TopologyResponse topologyResponse = new TopologyResponse();    String id = getTopologyId(name);    if (id != null) {        Map result = restTemplate.postForObject(getStormUiProperty() + TOPOLOGY_URL + "/" + id + "/activate", null, Map.class);        if ("success".equals(result.get("status"))) {            topologyResponse.setSuccessMessage(TopologyStatusCode.ACTIVE.toString());        } else {            topologyResponse.setErrorMessage((String) result.get("status"));        }    } else {        topologyResponse.setErrorMessage(TopologyStatusCode.TOPOLOGY_NOT_FOUND.toString());    }    return topologyResponse;}
public TopologyResponse metron_f1686_0(String name)
{    TopologyResponse topologyResponse = new TopologyResponse();    String id = getTopologyId(name);    if (id != null) {        Map result = restTemplate.postForObject(getStormUiProperty() + TOPOLOGY_URL + "/" + id + "/deactivate", null, Map.class);        if ("success".equals(result.get("status"))) {            topologyResponse.setSuccessMessage(TopologyStatusCode.INACTIVE.toString());        } else {            topologyResponse.setErrorMessage((String) result.get("status"));        }    } else {        topologyResponse.setErrorMessage(TopologyStatusCode.TOPOLOGY_NOT_FOUND.toString());    }    return topologyResponse;}
protected String metron_f1687_0()
{    String baseValue = environment.getProperty(STORM_UI_SPRING_PROPERTY);    if (!(baseValue.contains("://"))) {        return "http://" + baseValue;    }    return baseValue;}
protected String metron_f1688_0(String name)
{    String id = null;    for (TopologyStatus topology : getTopologySummary().getTopologies()) {        String topologyName = topology.getName();                if (topologyName.contains(ParserTopologyCLI.STORM_JOB_SEPARATOR)) {            Set<String> sensors = new HashSet<>(Arrays.asList(topologyName.split(ParserTopologyCLI.STORM_JOB_SEPARATOR)));            SensorParserGroup group = sensorParserGroupService.findOne(name);            if (group == null) {                break;            } else if (sensors.equals(group.getSensors())) {                id = topology.getId();                break;            }        }        if (topologyName.equals(name)) {            id = topology.getId();            break;        }    }    return id;}
public Document metron_f1689_0(PatchRequest request) throws RestException, OriginalNotFoundException
{    try {        return dao.patch(dao, request, Optional.of(System.currentTimeMillis()));    } catch (Exception e) {        throw new RestException(e.getMessage(), e);    }}
public Document metron_f1690_0(CommentAddRemoveRequest request) throws RestException
{    try {        return dao.addCommentToAlert(request);    } catch (Exception e) {        throw new RestException(e.getMessage(), e);    }}
public Document metron_f1691_0(CommentAddRemoveRequest request) throws RestException
{    try {        return dao.removeCommentFromAlert(request);    } catch (Exception e) {        throw new RestException(e.getMessage(), e);    }}
public synchronized void metron_f1692_0(Supplier<Map<String, Object>> globalConfigSupplier, TableProvider tableProvider)
{    if (this.userSettingsTable == null) {        Map<String, Object> globalConfig = globalConfigSupplier.get();        if (globalConfig == null) {            throw new IllegalStateException("Cannot find the global config.");        }        String table = (String) globalConfig.get(USER_SETTINGS_HBASE_TABLE);        String cf = (String) globalConfigSupplier.get().get(USER_SETTINGS_HBASE_CF);        if (table == null || cf == null) {            throw new IllegalStateException("You must configure " + USER_SETTINGS_HBASE_TABLE + " and " + USER_SETTINGS_HBASE_CF + " in the global config.");        }        try {            userSettingsTable = tableProvider.getTable(HBaseConfiguration.create(), table);            this.cf = cf.getBytes(StandardCharsets.UTF_8);        } catch (IOException e) {            throw new IllegalStateException("Unable to initialize HBaseDao: " + e.getMessage(), e);        }    }}
public Table metron_f1693_0()
{    if (userSettingsTable == null) {        init(globalConfigSupplier, tableProvider);    }    return userSettingsTable;}
public Map<String, String> metron_f1694_0(String user) throws IOException
{    Result result = getResult(user);    return getAllUserSettings(result);}
public Optional<String> metron_f1695_0(String user, String type) throws IOException
{    Result result = getResult(user);    return getUserSettings(result, type);}
public Map<String, Map<String, String>> metron_f1696_0() throws IOException
{    Scan scan = new Scan();    ResultScanner results = getTableInterface().getScanner(scan);    Map<String, Map<String, String>> allUserSettings = new HashMap<>();    for (Result result : results) {        allUserSettings.put(new String(result.getRow(), StandardCharsets.UTF_8), getAllUserSettings(result));    }    return allUserSettings;}
public Map<String, Optional<String>> metron_f1697_0(String type) throws IOException
{    Scan scan = new Scan();    ResultScanner results = getTableInterface().getScanner(scan);    Map<String, Optional<String>> allUserSettings = new HashMap<>();    for (Result result : results) {        allUserSettings.put(new String(result.getRow(), StandardCharsets.UTF_8), getUserSettings(result, type));    }    return allUserSettings;}
public void metron_f1698_0(String user, String type, String userSettings) throws IOException
{    byte[] rowKey = Bytes.toBytes(user);    Put put = new Put(rowKey);    put.addColumn(cf, Bytes.toBytes(type), Bytes.toBytes(userSettings));    getTableInterface().put(put);}
public void metron_f1699_0(String user) throws IOException
{    Delete delete = new Delete(Bytes.toBytes(user));    getTableInterface().delete(delete);}
public void metron_f1700_0(String user, String type) throws IOException
{    Delete delete = new Delete(Bytes.toBytes(user));    delete.addColumn(cf, Bytes.toBytes(type));    getTableInterface().delete(delete);}
private Result metron_f1701_0(String user) throws IOException
{    byte[] rowKey = Bytes.toBytes(user);    Get get = new Get(rowKey);    get.addFamily(cf);    return getTableInterface().get(get);}
private Optional<String> metron_f1702_0(Result result, String type) throws IOException
{    Optional<String> userSettings = Optional.empty();    if (result != null) {        byte[] value = result.getValue(cf, Bytes.toBytes(type));        if (value != null) {            userSettings = Optional.of(new String(value, StandardCharsets.UTF_8));        }    }    return userSettings;}
public Map<String, String> metron_f1703_0(Result result)
{    if (result == null) {        return new HashMap<>();    }    NavigableMap<byte[], byte[]> columns = result.getFamilyMap(cf);    if (columns == null || columns.size() == 0) {        return new HashMap<>();    }    Map<String, String> userSettingsMap = new HashMap<>();    for (Map.Entry<byte[], byte[]> column : columns.entrySet()) {        userSettingsMap.put(new String(column.getKey(), StandardCharsets.UTF_8), new String(column.getValue(), StandardCharsets.UTF_8));    }    return userSettingsMap;}
public synchronized Map<String, String> metron_f1704_0()
{    if (availableParsers == null) {        load();    }    return availableParsers;}
public synchronized Set<Class<? extends MessageParser>> metron_f1705_0()
{    if (index == null) {        load();    }    return index;}
public static void metron_f1706_0()
{    load();}
private static Collection<URL> metron_f1707_0(ClassLoader... classLoaders)
{    return ClasspathHelper.forManifest(ClasspathHelper.forClassLoader(classLoaders));}
public void metron_f1709_0(FilterConfig filterConfig) throws ServletException
{}
public void metron_f1711_0()
{}
public void metron_f1712_0() throws Exception
{    environment = mock(Environment.class);    hadoopConfig = new HadoopConfig(environment);    mockStatic(UserGroupInformation.class);}
public void metron_f1713_0() throws IOException
{    when(environment.getProperty(MetronRestConstants.KERBEROS_KEYTAB_SPRING_PROPERTY)).thenReturn("metron keytabLocation");    when(environment.getProperty(MetronRestConstants.KERBEROS_PRINCIPLE_SPRING_PROPERTY)).thenReturn("metron principal");    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(true);    Configuration configuration = hadoopConfig.configuration();    verifyStatic();    UserGroupInformation.setConfiguration(any(Configuration.class));    UserGroupInformation.loginUserFromKeytab("metron keytabLocation", "metron principal");}
public void metron_f1714_0() throws IOException
{    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    Configuration configuration = hadoopConfig.configuration();    verifyStatic(never());    UserGroupInformation.setConfiguration(any(Configuration.class));    UserGroupInformation.loginUserFromKeytab(anyString(), anyString());    assertEquals("simple", configuration.get("hadoop.security.authentication"));}
public void metron_f1715_0() throws Exception
{    globalConfigService = mock(GlobalConfigService.class);    hBaseConfig = new HBaseConfig(globalConfigService);    mockStatic(HBaseConfiguration.class);}
public void metron_f1716_0() throws Exception
{    when(globalConfigService.get()).thenReturn(new HashMap<String, Object>() {        {            put(USER_SETTINGS_HBASE_TABLE, "global_config_user_settings_table");            put(USER_SETTINGS_HBASE_CF, "global_config_user_settings_cf");        }    });    HTableProvider htableProvider = mock(HTableProvider.class);    whenNew(HTableProvider.class).withNoArguments().thenReturn(htableProvider);    Configuration configuration = mock(Configuration.class);    when(HBaseConfiguration.create()).thenReturn(configuration);    hBaseConfig.userSettingsClient();    verify(htableProvider).getTable(configuration, "global_config_user_settings_table");    verifyZeroInteractions(htableProvider);}
public void metron_f1717_0() throws Exception
{    when(globalConfigService.get()).thenReturn(new HashMap<String, Object>() {        {            put(EnrichmentConfigurations.TABLE_PROVIDER, MockHBaseTableProvider.class.getName());            put(EnrichmentConfigurations.TABLE_NAME, "enrichment_list_hbase_table_name");        }    });    Assert.assertNotNull(hBaseConfig.hBaseClient());}
public void metron_f1718_0() throws Exception
{    environment = mock(Environment.class);    kafkaConfig = new KafkaConfig(environment);}
public void metron_f1719_0() throws Exception
{    when(environment.getProperty(MetronRestConstants.KAFKA_BROKER_URL_SPRING_PROPERTY)).thenReturn("broker urls");    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    Map<String, Object> consumerProperties = kafkaConfig.consumerProperties();    assertEquals("broker urls", consumerProperties.get("bootstrap.servers"));    assertNull(consumerProperties.get("security.protocol"));    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(true);    when(environment.getProperty(MetronRestConstants.KAFKA_SECURITY_PROTOCOL_SPRING_PROPERTY)).thenReturn("kafka security protocol");    consumerProperties = kafkaConfig.consumerProperties();    assertEquals("kafka security protocol", consumerProperties.get("security.protocol"));}
public void metron_f1720_0() throws Exception
{    when(environment.getProperty(MetronRestConstants.KAFKA_BROKER_URL_SPRING_PROPERTY)).thenReturn("broker urls");    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    Map<String, Object> producerProperties = kafkaConfig.producerProperties();    assertEquals("broker urls", producerProperties.get("bootstrap.servers"));    assertNull(producerProperties.get("security.protocol"));    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(true);    when(environment.getProperty(MetronRestConstants.KAFKA_SECURITY_PROTOCOL_SPRING_PROPERTY)).thenReturn("kafka security protocol");    producerProperties = kafkaConfig.consumerProperties();    assertEquals("kafka security protocol", producerProperties.get("security.protocol"));}
public void metron_f1721_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("KnoxSSO requires LDAP. You must add 'ldap' to the active profiles.");    new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", null);}
public void metron_f1722_0() throws Exception
{    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));    HttpServletRequest request = mock(HttpServletRequest.class);    ServletResponse response = mock(ServletResponse.class);    FilterChain chain = mock(FilterChain.class);    SignedJWT signedJWT = mock(SignedJWT.class);    mockStatic(SignedJWT.class);    JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder().subject("userName").build();    Authentication authentication = mock(Authentication.class);    SecurityContext securityContext = mock(SecurityContext.class);    mockStatic(SecurityContextHolder.class);    when(request.getHeader("Authorization")).thenReturn(null);    doReturn("serializedJWT").when(knoxSSOAuthenticationFilter).getJWTFromCookie(request);    when(SignedJWT.parse("serializedJWT")).thenReturn(signedJWT);    when(signedJWT.getJWTClaimsSet()).thenReturn(jwtClaimsSet);    doReturn(true).when(knoxSSOAuthenticationFilter).isValid(signedJWT, "userName");    doReturn(authentication).when(knoxSSOAuthenticationFilter).getAuthentication("userName", request);    when(SecurityContextHolder.getContext()).thenReturn(securityContext);    knoxSSOAuthenticationFilter.doFilter(request, response, chain);    verify(securityContext).setAuthentication(authentication);    verify(chain).doFilter(request, response);    verifyNoMoreInteractions(chain, securityContext);}
public void metron_f1723_0() throws Exception
{    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));    HttpServletRequest request = mock(HttpServletRequest.class);    ServletResponse response = mock(ServletResponse.class);    FilterChain chain = mock(FilterChain.class);    when(request.getHeader("Authorization")).thenReturn("Basic ");    knoxSSOAuthenticationFilter.doFilter(request, response, chain);    verify(knoxSSOAuthenticationFilter, times(0)).getJWTFromCookie(request);    verify(chain).doFilter(request, response);    verifyNoMoreInteractions(chain);}
public void metron_f1724_0() throws Exception
{    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));    HttpServletRequest request = mock(HttpServletRequest.class);    ServletResponse response = mock(ServletResponse.class);    FilterChain chain = mock(FilterChain.class);    SignedJWT signedJWT = mock(SignedJWT.class);    mockStatic(SignedJWT.class);    when(request.getHeader("Authorization")).thenReturn(null);    doReturn("serializedJWT").when(knoxSSOAuthenticationFilter).getJWTFromCookie(request);    when(SignedJWT.parse("serializedJWT")).thenThrow(new ParseException("parse exception", 0));    knoxSSOAuthenticationFilter.doFilter(request, response, chain);    verify(knoxSSOAuthenticationFilter, times(0)).getAuthentication("userName", request);    verify(chain).doFilter(request, response);    verifyNoMoreInteractions(chain);}
public void metron_f1725_0() throws Exception
{    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));    HttpServletRequest request = mock(HttpServletRequest.class);    ServletResponse response = mock(ServletResponse.class);    FilterChain chain = mock(FilterChain.class);    SignedJWT signedJWT = mock(SignedJWT.class);    mockStatic(SignedJWT.class);    JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder().subject("userName").build();    when(request.getHeader("Authorization")).thenReturn(null);    doReturn("serializedJWT").when(knoxSSOAuthenticationFilter).getJWTFromCookie(request);    when(SignedJWT.parse("serializedJWT")).thenReturn(signedJWT);    when(signedJWT.getJWTClaimsSet()).thenReturn(jwtClaimsSet);    doReturn(false).when(knoxSSOAuthenticationFilter).isValid(signedJWT, "userName");    knoxSSOAuthenticationFilter.doFilter(request, response, chain);    verify(knoxSSOAuthenticationFilter, times(0)).getAuthentication("userName", request);    verify(chain).doFilter(request, response);    verifyNoMoreInteractions(chain);}
public void metron_f1726_0() throws Exception
{    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));    SignedJWT jwtToken = mock(SignedJWT.class);    {                assertFalse(knoxSSOAuthenticationFilter.isValid(jwtToken, null));    }    {                Date expiredDate = new Date(System.currentTimeMillis() - 10000);        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder().expirationTime(expiredDate).build();        when(jwtToken.getJWTClaimsSet()).thenReturn(jwtClaimsSet);        assertFalse(knoxSSOAuthenticationFilter.isValid(jwtToken, "userName"));    }    {                Date notBeforeDate = new Date(System.currentTimeMillis() + 10000);        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder().notBeforeTime(notBeforeDate).build();        when(jwtToken.getJWTClaimsSet()).thenReturn(jwtClaimsSet);        assertFalse(knoxSSOAuthenticationFilter.isValid(jwtToken, "userName"));    }    {                Date expiredDate = new Date(System.currentTimeMillis() + 10000);        Date notBeforeDate = new Date(System.currentTimeMillis() - 10000);        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder().expirationTime(expiredDate).notBeforeTime(notBeforeDate).build();        when(jwtToken.getJWTClaimsSet()).thenReturn(jwtClaimsSet);        doReturn(true).when(knoxSSOAuthenticationFilter).validateSignature(jwtToken);        assertTrue(knoxSSOAuthenticationFilter.isValid(jwtToken, "userName"));    }}
public void metron_f1727_0() throws Exception
{    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));    SignedJWT jwtToken = mock(SignedJWT.class);    {                JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.ES384);        when(jwtToken.getHeader()).thenReturn(jwsHeader);        assertFalse(knoxSSOAuthenticationFilter.validateSignature(jwtToken));    }    {                JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.RS256);        when(jwtToken.getHeader()).thenReturn(jwsHeader);        when(jwtToken.getState()).thenReturn(JWSObject.State.UNSIGNED);        assertFalse(knoxSSOAuthenticationFilter.validateSignature(jwtToken));    }    {                JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.RS256);        when(jwtToken.getHeader()).thenReturn(jwsHeader);        when(jwtToken.getState()).thenReturn(JWSObject.State.SIGNED);        assertFalse(knoxSSOAuthenticationFilter.validateSignature(jwtToken));    }    {        Base64URL signature = mock(Base64URL.class);        when(jwtToken.getSignature()).thenReturn(signature);        RSAPublicKey rsaPublicKey = mock(RSAPublicKey.class);        RSASSAVerifier rsaSSAVerifier = mock(RSASSAVerifier.class);        mockStatic(SecurityUtils.class);        when(SecurityUtils.parseRSAPublicKey("knoxKeyString")).thenReturn(rsaPublicKey);        whenNew(RSASSAVerifier.class).withArguments(rsaPublicKey).thenReturn(rsaSSAVerifier);        {                        when(jwtToken.verify(rsaSSAVerifier)).thenThrow(new JOSEException("verify exception"));            assertFalse(knoxSSOAuthenticationFilter.validateSignature(jwtToken));        }        {                        doReturn(false).when(jwtToken).verify(rsaSSAVerifier);            assertFalse(knoxSSOAuthenticationFilter.validateSignature(jwtToken));        }        {                        doReturn(true).when(jwtToken).verify(rsaSSAVerifier);            assertTrue(knoxSSOAuthenticationFilter.validateSignature(jwtToken));        }    }}
public void metron_f1728_0()
{    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));    HttpServletRequest request = mock(HttpServletRequest.class);    {                assertNull(knoxSSOAuthenticationFilter.getJWTFromCookie(request));    }    {                Cookie cookie = new Cookie("someCookie", "someValue");        when(request.getCookies()).thenReturn(new Cookie[] { cookie });        assertNull(knoxSSOAuthenticationFilter.getJWTFromCookie(request));    }    {                Cookie cookie = new Cookie("knoxCookie", "token");        when(request.getCookies()).thenReturn(new Cookie[] { cookie });        assertEquals("token", knoxSSOAuthenticationFilter.getJWTFromCookie(request));    }}
public void metron_f1729_0() throws Exception
{    {        KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", mock(Path.class), "knoxKeyString", "knoxCookie", mock(LdapTemplate.class)));        assertEquals("knoxKeyString", knoxSSOAuthenticationFilter.getKnoxKey());    }    {        FileUtils.writeStringToFile(new File("./target/knoxKeyFile"), "knoxKeyFileKeyString", StandardCharsets.UTF_8);        KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("userSearchBase", Paths.get("./target/knoxKeyFile"), null, "knoxCookie", mock(LdapTemplate.class)));        assertEquals("knoxKeyFileKeyString", knoxSSOAuthenticationFilter.getKnoxKey());    }}
public void metron_f1730_0() throws Exception
{    LdapTemplate ldapTemplate = mock(LdapTemplate.class);    KnoxSSOAuthenticationFilter knoxSSOAuthenticationFilter = spy(new KnoxSSOAuthenticationFilter("ou=people,dc=hadoop,dc=apache,dc=org", mock(Path.class), "knoxKeyString", "knoxCookie", ldapTemplate));    HttpServletRequest request = mock(HttpServletRequest.class);    when(ldapTemplate.search(any(LdapQuery.class), any(AttributesMapper.class))).thenReturn(Arrays.asList("USER", "ADMIN"));    Authentication authentication = knoxSSOAuthenticationFilter.getAuthentication("userName", request);    Object[] grantedAuthorities = authentication.getAuthorities().toArray();    assertEquals("ROLE_USER", grantedAuthorities[0].toString());    assertEquals("ROLE_ADMIN", grantedAuthorities[1].toString());    assertEquals("userName", authentication.getName());}
public void metron_f1731_0()
{    mapper = new MetronAuthoritiesMapper();    mapper.setUserRole("ACME_USER");    mapper.setAdminRole("ACME_ADMIN");    mapper.setPrefix("ROLE_");        List<GrantedAuthority> input = new ArrayList<>();    input.add(new SimpleGrantedAuthority("ROLE_" + "ACME_USER"));        Collection<? extends GrantedAuthority> actuals = mapper.mapAuthorities(input);    Assert.assertEquals(1, actuals.size());    Assert.assertEquals(SECURITY_ROLE_PREFIX + SECURITY_ROLE_USER, actuals.iterator().next().getAuthority());}
public void metron_f1732_0()
{    mapper = new MetronAuthoritiesMapper();    mapper.setUserRole("ACME_USER");    mapper.setAdminRole("ACME_ADMIN");    mapper.setPrefix("ROLE_");    List<GrantedAuthority> input = new ArrayList<>();    input.add(new SimpleGrantedAuthority("ROLE_" + "ACME_ADMIN"));        Collection<? extends GrantedAuthority> actuals = mapper.mapAuthorities(input);    Assert.assertEquals(1, actuals.size());    Assert.assertEquals(SECURITY_ROLE_PREFIX + SECURITY_ROLE_ADMIN, actuals.iterator().next().getAuthority());}
public void metron_f1733_0()
{    mapper = new MetronAuthoritiesMapper();    mapper.setUserRole("ACME_USER");    mapper.setAdminRole("ACME_ADMIN");    mapper.setPrefix("ROLE_");    List<GrantedAuthority> input = new ArrayList<>();    input.add(new SimpleGrantedAuthority("ROLE_" + "ANOTHER_ROLE"));    input.add(new SimpleGrantedAuthority("ROLE_" + "YET_ANOTHER_ROLE"));    Collection<? extends GrantedAuthority> actuals = mapper.mapAuthorities(input);    Assert.assertEquals(0, actuals.size());}
public void metron_f1734_0()
{        mapper = new MetronAuthoritiesMapper();    mapper.setUserRole("ACME_USER");    mapper.setAdminRole("ACME_ADMIN");    mapper.setPrefix("");    List<GrantedAuthority> input = new ArrayList<>();    input.add(new SimpleGrantedAuthority("ACME_ADMIN"));        Collection<? extends GrantedAuthority> actuals = mapper.mapAuthorities(input);    Assert.assertEquals(1, actuals.size());    Assert.assertEquals(SECURITY_ROLE_PREFIX + SECURITY_ROLE_ADMIN, actuals.iterator().next().getAuthority());}
public void metron_f1735_0() throws Exception
{    environment = mock(Environment.class);    restTemplateConfig = new RestTemplateConfig(environment);}
public void metron_f1736_0() throws Exception
{    when(environment.getProperty(MetronRestConstants.KERBEROS_KEYTAB_SPRING_PROPERTY)).thenReturn("metron keytabLocation");    when(environment.getProperty(MetronRestConstants.KERBEROS_PRINCIPLE_SPRING_PROPERTY)).thenReturn("metron principal");    whenNew(KerberosRestTemplate.class).withParameterTypes(String.class, String.class).withArguments("metron keytabLocation", "metron principal").thenReturn(null);    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(true);    restTemplateConfig.restTemplate();    verifyNew(KerberosRestTemplate.class).withArguments("metron keytabLocation", "metron principal");    whenNew(RestTemplate.class).withNoArguments().thenReturn(null);    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    restTemplateConfig.restTemplate();    verifyNew(RestTemplate.class).withNoArguments();}
public Properties metron_f1737_0()
{    return new Properties();}
public ZKServerComponent metron_f1738_0(Properties zkProperties)
{    return new ZKServerComponent().withPostStartCallback((zkComponent) -> zkProperties.setProperty(ZKServerComponent.ZOOKEEPER_PROPERTY, zkComponent.getConnectionString()));}
public KafkaComponent metron_f1739_0(Properties zkProperties)
{    return new KafkaComponent().withTopologyProperties(zkProperties);}
public ConfigurationsCache metron_f1740_0(CuratorFramework client)
{    return new ZKConfigurationsCache(client, ZKConfigurationsCache.ConfiguredTypes.ENRICHMENT, ZKConfigurationsCache.ConfiguredTypes.PARSER, ZKConfigurationsCache.ConfiguredTypes.INDEXING);}
public ComponentRunner metron_f1741_0(ZKServerComponent zkServerComponent, KafkaComponent kafkaWithZKComponent)
{    ComponentRunner runner = new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withCustomShutdownOrder(new String[] { "search", "zk" }).build();    try {        runner.start();        File globalConfigFile = new File("src/test/resources/zookeeper/global.json");        try (BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(globalConfigFile), StandardCharsets.UTF_8))) {            String globalConfig = IOUtils.toString(r);            ConfigurationsUtils.writeGlobalConfigToZookeeper(globalConfig.getBytes(StandardCharsets.UTF_8), zkServerComponent.getConnectionString());        } catch (Exception e) {            throw new IllegalStateException("Unable to upload global config", e);        }    } catch (UnableToStartException e) {        e.printStackTrace();    }    return runner;}
public CuratorFramework metron_f1742_0(ComponentRunner componentRunner)
{    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    ZKServerComponent zkServerComponent = componentRunner.getComponent("zk", ZKServerComponent.class);    return CuratorFrameworkFactory.newClient(zkServerComponent.getConnectionString(), retryPolicy);}
public ZkClient metron_f1743_0(ComponentRunner componentRunner)
{    ZKServerComponent zkServerComponent = componentRunner.getComponent("zk", ZKServerComponent.class);    return new ZkClient(zkServerComponent.getConnectionString(), 10000, 10000, ZKStringSerializer$.MODULE$);}
public ZkUtils metron_f1744_0(ZkClient zkClient)
{    return ZkUtils.apply(zkClient, false);}
public Map<String, Object> metron_f1745_0(KafkaComponent kafkaWithZKComponent)
{    Map<String, Object> props = new HashMap<>();    props.put("bootstrap.servers", kafkaWithZKComponent.getBrokerList());    props.put("group.id", "metron-config");    props.put("enable.auto.commit", "false");    props.put("auto.commit.interval.ms", "1000");    props.put("session.timeout.ms", "30000");    props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");    props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");    return props;}
public ConsumerFactory<String, String> metron_f1746_0()
{    return new DefaultKafkaConsumerFactory<>(kafkaConsumer(kafkaWithZKComponent(zkProperties())));}
public Map<String, Object> metron_f1747_0(KafkaComponent kafkaWithZKComponent)
{    Map<String, Object> producerConfig = new HashMap<>();    producerConfig.put("bootstrap.servers", kafkaWithZKComponent.getBrokerList());    producerConfig.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");    producerConfig.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");    producerConfig.put("request.required.acks", 1);    return producerConfig;}
public KafkaProducer metron_f1748_0(KafkaComponent kafkaWithZKComponent)
{    return new KafkaProducer<>(producerProperties(kafkaWithZKComponent));}
public StormCLIWrapper metron_f1749_0()
{    return new MockStormCLIClientWrapper();}
public RestTemplate metron_f1750_0(StormCLIWrapper stormCLIClientWrapper)
{    MockStormRestTemplate restTemplate = new MockStormRestTemplate();    restTemplate.setMockStormCLIClientWrapper((MockStormCLIClientWrapper) stormCLIClientWrapper);    return restTemplate;}
public AdminUtils$ metron_f1751_0()
{    return AdminUtils$.MODULE$;}
public UserSettingsClient metron_f1752_0() throws RestException, IOException
{    return new UserSettingsClient(new MockHBaseTableProvider().addToCache("user_settings", "cf"), Bytes.toBytes("cf"));}
public HBaseClient metron_f1753_0() throws RestException, IOException
{    final String cf = "t";    final String cq = "v";    Table table = MockHBaseTableProvider.addToCache("enrichment_list", cf);    List<String> enrichmentTypes = new ArrayList<String>() {        {            add("foo");            add("bar");            add("baz");        }    };    for (String type : enrichmentTypes) {        Put put = new Put(Bytes.toBytes(type));        put.addColumn(Bytes.toBytes(cf), Bytes.toBytes(cq), "{}".getBytes(StandardCharsets.UTF_8));        table.put(put);    }    return new HBaseClient(new MockHBaseTableProvider(), HBaseConfiguration.create(), "enrichment_list");}
public JobManager metron_f1754_0()
{    return new InMemoryJobManager();}
public MockPcapJob metron_f1755_0()
{    return new MockPcapJob();}
public PcapJobSupplier metron_f1756_0(MockPcapJob mockPcapJob)
{    MockPcapJobSupplier mockPcapJobSupplier = new MockPcapJobSupplier();    mockPcapJobSupplier.setMockPcapJob(mockPcapJob);    return mockPcapJobSupplier;}
public PcapToPdmlScriptWrapper metron_f1757_0()
{    return new MockPcapToPdmlScriptWrapper();}
public StormStatusService metron_f1758_0(@Autowired @Qualifier("StormStatusServiceImpl") StormStatusService wrappedService)
{    long maxCacheSize = 0L;    long maxCacheTimeoutSeconds = 0L;    return new CachedStormStatusServiceImpl(wrappedService, maxCacheSize, maxCacheTimeoutSeconds);}
public void metron_f1759_0() throws Exception
{    for (String user : alertsUIService.findAllAlertsUIUserSettings().keySet()) {        alertsUIService.deleteAlertsUIUserSettings(user);    }    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1760_0() throws Exception
{    this.mockMvc.perform(post(alertUrl + "/escalate").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(alerts)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(alertUrl + "/settings")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(alertUrl + "/settings/all")).andExpect(status().isUnauthorized());    this.mockMvc.perform(post(alertUrl + "/settings").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(user1AlertUserSettingsJson)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(alertUrl + "/settings/all").with(httpBasic(user1, password)).with(csrf())).andExpect(status().isForbidden());    this.mockMvc.perform(delete(alertUrl + "/settings/user1").with(httpBasic(user1, password)).with(csrf())).andExpect(status().isForbidden());}
public void metron_f1761_0() throws Exception
{    startKafka();    this.mockMvc.perform(post(alertUrl + "/escalate").with(httpBasic(user1, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(alerts)).andExpect(status().isOk());    stopKafka();}
public void metron_f1762_0() throws Exception
{    emptyProfileShouldReturnNotFound();    alertsProfilesShouldBeCreatedOrUpdated();    alertsProfilesShouldBeProperlyDeleted();}
private void metron_f1763_0() throws Exception
{        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user1, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user2, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(alertUrl + "/settings/all").with(httpBasic(admin, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(0)));}
private void metron_f1764_0() throws Exception
{        this.mockMvc.perform(post(alertUrl + "/settings").with(httpBasic(user1, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(user1AlertUserSettingsJson)).andExpect(status().isCreated());        this.mockMvc.perform(post(alertUrl + "/settings").with(httpBasic(user1, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(user1AlertUserSettingsJson)).andExpect(status().isOk());        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user1, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json(user1AlertUserSettingsJson));        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user2, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(alertUrl + "/settings/all").with(httpBasic(admin, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json("{\"" + user1 + "\": " + user1AlertUserSettingsJson + "}"));        this.mockMvc.perform(post(alertUrl + "/settings").with(httpBasic(user2, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(user2AlertUserSettingsJson)).andExpect(status().isCreated());        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user1, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json(user1AlertUserSettingsJson));        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user2, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json(user2AlertUserSettingsJson));        this.mockMvc.perform(get(alertUrl + "/settings/all").with(httpBasic(admin, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json("{\"" + user1 + "\": " + user1AlertUserSettingsJson + ",\"" + user2 + "\": " + user2AlertUserSettingsJson + "}"));}
private void metron_f1765_0() throws Exception
{        this.mockMvc.perform(delete(alertUrl + "/settings/user1").with(httpBasic(admin, password))).andExpect(status().isOk());        this.mockMvc.perform(delete(alertUrl + "/settings/user1").with(httpBasic(admin, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user1, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user2, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json(user2AlertUserSettingsJson));        this.mockMvc.perform(get(alertUrl + "/settings/all").with(httpBasic(admin, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json("{\"" + user2 + "\": " + user2AlertUserSettingsJson + "}"));        this.mockMvc.perform(delete(alertUrl + "/settings/user2").with(httpBasic(admin, password))).andExpect(status().isOk());        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user1, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(alertUrl + "/settings").with(httpBasic(user2, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(alertUrl + "/settings/all").with(httpBasic(admin, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(0)));}
private void metron_f1766_0()
{    runner = new ComponentRunner.Builder().withComponent("kafka", kafkaWithZKComponent).withCustomShutdownOrder(new String[] { "kafka" }).build();    try {        runner.start();    } catch (UnableToStartException e) {        e.printStackTrace();    }}
private void metron_f1767_0()
{    runner.stop();}
public void metron_f1768_0(Map<String, String> indicesToDataMap) throws ParseException
{    Map<String, List<String>> backingStore = new HashMap<>();    for (Map.Entry<String, String> indices : indicesToDataMap.entrySet()) {        List<String> results = new ArrayList<>();        backingStore.put(indices.getKey(), results);        JSONArray docArray = (JSONArray) new JSONParser().parse(indices.getValue());        int i = 0;        for (Object o : docArray) {            JSONObject jsonObject = (JSONObject) o;                        if (!jsonObject.containsKey(Constants.GUID)) {                jsonObject.put(Constants.GUID, indices.getKey() + ":" + i++);            }            results.add(jsonObject.toJSONString());        }    }    InMemoryDao.load(backingStore);}
public void metron_f1769_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1770_0() throws Exception
{    this.mockMvc.perform(post(globalConfigUrl).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(globalJson)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(globalConfigUrl)).andExpect(status().isUnauthorized());    this.mockMvc.perform(delete(globalConfigUrl).with(csrf())).andExpect(status().isUnauthorized());}
public void metron_f1771_0() throws Exception
{    this.globalConfigService.delete();    assertEventually(() -> this.mockMvc.perform(get(globalConfigUrl).with(httpBasic(user, password))).andExpect(status().isNotFound()));    this.mockMvc.perform(post(globalConfigUrl).with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(globalJson)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8")));    assertEventually(() -> this.mockMvc.perform(post(globalConfigUrl).with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(globalJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))));    this.mockMvc.perform(get(globalConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk());    this.mockMvc.perform(delete(globalConfigUrl).with(httpBasic(user, password)).with(csrf())).andExpect(status().isOk());    assertEventually(() -> this.mockMvc.perform(delete(globalConfigUrl).with(httpBasic(user, password)).with(csrf())).andExpect(status().isNotFound()));    this.globalConfigService.delete();}
public void metron_f1772_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1773_0() throws Exception
{    this.mockMvc.perform(post(grokUrl + "/validate").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(grokValidationJson)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(grokUrl + "/list")).andExpect(status().isUnauthorized());}
public void metron_f1774_0() throws Exception
{    this.mockMvc.perform(post(grokUrl + "/validate").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(grokValidationJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.results.action").value("TCP_MISS")).andExpect(jsonPath("$.results.bytes").value(337891)).andExpect(jsonPath("$.results.code").value(200)).andExpect(jsonPath("$.results.elapsed").value(415)).andExpect(jsonPath("$.results.ip_dst_addr").value("207.109.73.154")).andExpect(jsonPath("$.results.ip_src_addr").value("127.0.0.1")).andExpect(jsonPath("$.results.method").value("GET")).andExpect(jsonPath("$.results.timestamp").value("1467011157.401")).andExpect(jsonPath("$.results.url").value("http://www.aliexpress.com/af/shoes.html?"));    this.mockMvc.perform(post(grokUrl + "/validate").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(missingPatternLabelGrokValidationJson)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("Pattern label is required"));    this.mockMvc.perform(post(grokUrl + "/validate").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(missingStatementGrokValidationJson)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("Grok statement is required"));    this.mockMvc.perform(get(grokUrl + "/list").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$").isNotEmpty());    String statement = FileUtils.readFileToString(new File("../../metron-platform/metron-parsing/metron-parsers/src/main/resources/patterns/squid"));    this.mockMvc.perform(get(grokUrl + "/get/statement?path=/patterns/squid").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("text/plain;charset=UTF-8"))).andExpect(content().bytes(statement.getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(get(grokUrl + "/get/statement?path=/bad/path").with(httpBasic(user, password))).andExpect(status().isInternalServerError()).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("Could not find a statement at path /bad/path"));}
public void metron_f1775_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1776_0() throws Exception
{    this.mockMvc.perform(post(hdfsUrl).with(csrf()).contentType(MediaType.parseMediaType("text/plain;charset=UTF-8")).content(fileContents)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(hdfsUrl)).andExpect(status().isUnauthorized());    this.mockMvc.perform(delete(hdfsUrl).with(csrf())).andExpect(status().isUnauthorized());}
public void metron_f1777_0() throws Exception
{    this.hdfsService.delete(new Path(path), false);    this.mockMvc.perform(get(hdfsUrl + "?path=" + path).with(httpBasic(user, password))).andExpect(status().isNotFound());    this.mockMvc.perform(post(hdfsUrl + "?path=" + path).with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("text/plain;charset=UTF-8")).content(fileContents)).andExpect(status().isOk());    this.mockMvc.perform(get(hdfsUrl + "?path=" + path).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("text/plain;charset=UTF-8"))).andExpect(content().bytes(fileContents.getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(delete(hdfsUrl + "?path=" + path).with(httpBasic(user, password)).with(csrf())).andExpect(status().isOk());    this.mockMvc.perform(delete(hdfsUrl + "?path=" + path).with(httpBasic(user, password)).with(csrf())).andExpect(status().isNotFound());}
private void metron_f1778_0(Evaluation evaluation) throws Exception
{    testAndRetry(KAFKA_RETRY, evaluation);}
private void metron_f1779_0(int numRetries, Evaluation evaluation) throws Exception
{    AssertionError lastError = null;    for (int i = 0; i < numRetries; ++i) {        try {            evaluation.tryTest();            return;        } catch (AssertionError error) {            if (error.getMessage().contains("but was:<404>")) {                lastError = error;                Thread.sleep(1000);                continue;            } else {                throw error;            }        }    }    if (lastError != null) {        throw lastError;    }}
public void metron_f1780_0() throws Exception
{    runner = new ComponentRunner.Builder().withComponent("kafka", kafkaWithZKComponent).withCustomShutdownOrder(new String[] { "kafka" }).build();    try {        runner.start();    } catch (UnableToStartException e) {        e.printStackTrace();    }    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1781_0() throws Exception
{    this.mockMvc.perform(post(kafkaUrl + "/topic").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broTopic)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(kafkaUrl + "/topic/bro")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(kafkaUrl + "/topic")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(kafkaUrl + "/topic/bro/sample")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(kafkaUrl + "/topic/bro/produce")).andExpect(status().isUnauthorized());    this.mockMvc.perform(delete(kafkaUrl + "/topic/bro").with(csrf())).andExpect(status().isUnauthorized());}
public void metron_f1782_0() throws Exception
{    this.kafkaService.deleteTopic("bro");    this.kafkaService.deleteTopic("someTopic");    Thread.sleep(1000);    testAndRetry(() -> this.mockMvc.perform(delete(kafkaUrl + "/topic/bro").with(httpBasic(user, password)).with(csrf())).andExpect(status().isNotFound()));    testAndRetry(() -> this.mockMvc.perform(post(kafkaUrl + "/topic").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broTopic)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.name").value("bro")).andExpect(jsonPath("$.numPartitions").value(1)).andExpect(jsonPath("$.replicationFactor").value(1)));    Thread.sleep(1000);    testAndRetry(() -> this.mockMvc.perform(get(kafkaUrl + "/topic/bro").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.name").value("bro")).andExpect(jsonPath("$.numPartitions").value(1)).andExpect(jsonPath("$.replicationFactor").value(1)));    this.mockMvc.perform(get(kafkaUrl + "/topic/someTopic").with(httpBasic(user, password))).andExpect(status().isNotFound());    testAndRetry(() -> this.mockMvc.perform(get(kafkaUrl + "/topic").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$", Matchers.hasItem("bro"))));    testAndRetry(() -> this.mockMvc.perform(post(kafkaUrl + "/topic/bro/produce").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(message1)).andExpect(status().isOk()));    testAndRetry(() -> this.mockMvc.perform(get(kafkaUrl + "/topic/bro/sample").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("text/plain;charset=UTF-8"))).andExpect(jsonPath("$.type").value("message1")));    testAndRetry(() -> this.mockMvc.perform(post(kafkaUrl + "/topic/bro/produce").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(message2)).andExpect(status().isOk()));    testAndRetry(() -> this.mockMvc.perform(get(kafkaUrl + "/topic/bro/sample").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("text/plain;charset=UTF-8"))).andExpect(jsonPath("$.type").value("message2")));    testAndRetry(() -> this.mockMvc.perform(post(kafkaUrl + "/topic/bro/produce").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(message3)).andExpect(status().isOk()));    testAndRetry(() -> this.mockMvc.perform(get(kafkaUrl + "/topic/bro/sample").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("text/plain;charset=UTF-8"))).andExpect(jsonPath("$.type").value("message3")));    this.mockMvc.perform(get(kafkaUrl + "/topic/someTopic/sample").with(httpBasic(user, password))).andExpect(status().isNotFound());    boolean deleted = false;    for (int i = 0; i < KAFKA_RETRY; ++i) {        try {            MvcResult result = this.mockMvc.perform(delete(kafkaUrl + "/topic/bro").with(httpBasic(user, password)).with(csrf())).andReturn();            if (result.getResponse().getStatus() == 200) {                deleted = true;                break;            }            Thread.sleep(1000);        } catch (NestedServletException nse) {            Throwable t = nse.getRootCause();            if (t instanceof TopicAlreadyMarkedForDeletionException) {                continue;            } else {                throw nse;            }        } catch (Throwable t) {            throw t;        }    }    if (!deleted) {        throw new IllegalStateException("Unable to delete kafka topic \"bro\"");    }}
public void metron_f1783_0()
{    runner.stop();}
public void metron_f1784_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();    ImmutableMap<String, String> testData = ImmutableMap.of("bro_index_2017.01.01.01", SearchIntegrationTest.broData, "snort_index_2017.01.01.01", SearchIntegrationTest.snortData, metaAlertIndex, metaAlertData);    loadTestData(testData);}
public void metron_f1785_0()
{    InMemoryMetaAlertDao.clear();}
public void metron_f1786_0() throws Exception
{            String guid = "missing_1";    ResultActions result = this.mockMvc.perform(post(metaalertUrl + "/searchByAlert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("text/plain;charset=UTF-8")).content(guid));    result.andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(0));        guid = "snort_1";    result = this.mockMvc.perform(post(metaalertUrl + "/searchByAlert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("text/plain;charset=UTF-8")).content(guid));    result.andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(1)).andExpect(jsonPath("$.results[0].source.guid").value("meta_2")).andExpect(jsonPath("$.results[0].source.count").value(3.0));        guid = "bro_1";    result = this.mockMvc.perform(post(metaalertUrl + "/searchByAlert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("text/plain;charset=UTF-8")).content(guid));    result.andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(2)).andExpect(jsonPath("$.results[0].source.guid").value("meta_2")).andExpect(jsonPath("$.results[0].source.count").value(3.0)).andExpect(jsonPath("$.results[1].source.guid").value("meta_1")).andExpect(jsonPath("$.results[1].source.count").value(1.0));}
public void metron_f1787_0() throws Exception
{    ResultActions result = this.mockMvc.perform(post(metaalertUrl + "/create").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(create));    result.andExpect(status().isOk()).andExpect(jsonPath("$.guid", notNullValue())).andExpect(jsonPath("$.timestamp", greaterThan(0L))).andExpect(jsonPath("$.sensorType").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.timestamp", greaterThan(0L))).andExpect(jsonPath("$.document['source.type']").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.status").value("active")).andExpect(jsonPath("$.document.groups[0]").value("group_one")).andExpect(jsonPath("$.document.groups[1]").value("group_two")).andExpect(jsonPath("$.document.metron_alert[0].guid").value("bro_1")).andExpect(jsonPath("$.document.metron_alert[1].guid").value("snort_2"));}
public void metron_f1788_0() throws Exception
{    MetaAlertAddRemoveRequest addRequest = new MetaAlertAddRemoveRequest();    addRequest.setMetaAlertGuid("meta_1");    addRequest.setAlerts(new ArrayList<GetRequest>() {        {            add(new GetRequest("bro_2", "bro", "bro_index_2017.01.01.01"));            add(new GetRequest("bro_3", "bro", "bro_index_2017.01.01.01"));        }    });    ResultActions result = this.mockMvc.perform(post(metaalertUrl + "/add/alert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(JSONUtils.INSTANCE.toJSON(addRequest, false)));    result.andExpect(status().isOk()).andExpect(jsonPath("$.guid").value("meta_1")).andExpect(jsonPath("$.sensorType").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.metron_alert[0].guid").value("bro_1")).andExpect(jsonPath("$.document.metron_alert[1].guid").value("bro_2")).andExpect(jsonPath("$.document.metron_alert[2].metaalerts").value("meta_1")).andExpect(jsonPath("$.document.metron_alert[2].guid").value("bro_3")).andExpect(jsonPath("$.document.metron_alert[2].metaalerts").value("meta_1"));    MetaAlertAddRemoveRequest addDuplicateRequest = new MetaAlertAddRemoveRequest();    addDuplicateRequest.setMetaAlertGuid("meta_1");    addDuplicateRequest.setAlerts(new ArrayList<GetRequest>() {        {            add(new GetRequest("bro_1", "bro"));        }    });    result = this.mockMvc.perform(post(metaalertUrl + "/add/alert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(JSONUtils.INSTANCE.toJSON(addDuplicateRequest, false)));    result.andExpect(status().isOk()).andExpect(jsonPath("$.guid").value("meta_1")).andExpect(jsonPath("$.sensorType").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.metron_alert[0].guid").value("bro_1")).andExpect(jsonPath("$.document.metron_alert[1].guid").value("bro_2")).andExpect(jsonPath("$.document.metron_alert[2].metaalerts").value("meta_1")).andExpect(jsonPath("$.document.metron_alert[2].guid").value("bro_3")).andExpect(jsonPath("$.document.metron_alert[2].metaalerts").value("meta_1"));    MetaAlertAddRemoveRequest removeRequest = new MetaAlertAddRemoveRequest();    removeRequest.setMetaAlertGuid("meta_1");    removeRequest.setAlerts(new ArrayList<GetRequest>() {        {            add(new GetRequest("bro_2", "bro"));            add(new GetRequest("bro_3", "bro"));        }    });    result = this.mockMvc.perform(post(metaalertUrl + "/remove/alert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(JSONUtils.INSTANCE.toJSON(removeRequest, false)));    result.andExpect(status().isOk()).andExpect(jsonPath("$.guid").value("meta_1")).andExpect(jsonPath("$.sensorType").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.metron_alert.*", hasSize(equalTo(1)))).andExpect(jsonPath("$.document.metron_alert[0].guid").value("bro_1"));    MetaAlertAddRemoveRequest removeMissingRequest = new MetaAlertAddRemoveRequest();    removeMissingRequest.setMetaAlertGuid("meta_1");    removeMissingRequest.setAlerts(new ArrayList<GetRequest>() {        {            add(new GetRequest("bro_2", "bro"));        }    });    result = this.mockMvc.perform(post(metaalertUrl + "/remove/alert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(JSONUtils.INSTANCE.toJSON(removeMissingRequest, false)));    result.andExpect(status().isOk()).andExpect(jsonPath("$.guid").value("meta_1")).andExpect(jsonPath("$.sensorType").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.metron_alert.*", hasSize(equalTo(1)))).andExpect(jsonPath("$.document.metron_alert[0].guid").value("bro_1"));    MetaAlertAddRemoveRequest emptyMetaAlertRequest = new MetaAlertAddRemoveRequest();    emptyMetaAlertRequest.setMetaAlertGuid("meta_1");    emptyMetaAlertRequest.setAlerts(new ArrayList<GetRequest>() {        {            add(new GetRequest("bro_1", "bro"));        }    });    result = this.mockMvc.perform(post(metaalertUrl + "/remove/alert").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(JSONUtils.INSTANCE.toJSON(emptyMetaAlertRequest, false)));    result.andExpect(status().isInternalServerError()).andExpect(jsonPath("$.message").value("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.")).andExpect(jsonPath("$.fullMessage").value("IllegalStateException: Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed."));}
public void metron_f1789_0() throws Exception
{    ResultActions result = this.mockMvc.perform(post(metaalertUrl + "/update/status/meta_2/inactive").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")));    result.andExpect(status().isOk()).andExpect(jsonPath("$.guid").value("meta_2")).andExpect(jsonPath("$.sensorType").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.status").value("inactive"));    result = this.mockMvc.perform(post(metaalertUrl + "/update/status/meta_2/active").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")));    result.andExpect(status().isOk()).andExpect(jsonPath("$.guid").value("meta_2")).andExpect(jsonPath("$.sensorType").value(MetaAlertConstants.METAALERT_TYPE)).andExpect(jsonPath("$.document.status").value("active"));}
public void metron_f1790_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();    InMemoryJobManager jobManager = (InMemoryJobManager) wac.getBean("jobManager");    jobManager.clear();}
public void metron_f1791_0() throws Exception
{    this.mockMvc.perform(post(pcapUrl + "/fixed").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isUnauthorized());    this.mockMvc.perform(post(pcapUrl + "/query").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(queryJson)).andExpect(status().isUnauthorized());}
public void metron_f1792_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    Assert.assertEquals("/base/path", mockPcapJob.getBasePath());    Assert.assertEquals("/base/interim/result/path", mockPcapJob.getBaseInterrimResultPath());    Assert.assertEquals("/final/output/path", mockPcapJob.getFinalOutputPath());    Assert.assertEquals(10000000, mockPcapJob.getStartTimeNs());    Assert.assertEquals(20000000, mockPcapJob.getEndTimeNs());    Assert.assertEquals(2, mockPcapJob.getNumReducers());    Assert.assertTrue(mockPcapJob.getFilterImpl() instanceof FixedPcapFilter.Configurator);    Map<String, String> actualFixedFields = mockPcapJob.getFixedFields();    Assert.assertEquals("192.168.1.2", actualFixedFields.get(Constants.Fields.SRC_ADDR.getName()));    Assert.assertEquals("2000", actualFixedFields.get(Constants.Fields.SRC_PORT.getName()));    Assert.assertEquals("192.168.1.1", actualFixedFields.get(Constants.Fields.DST_ADDR.getName()));    Assert.assertEquals("1000", actualFixedFields.get(Constants.Fields.DST_PORT.getName()));    Assert.assertEquals("true", actualFixedFields.get(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName()));    Assert.assertEquals("TCP", actualFixedFields.get(Constants.Fields.PROTOCOL.getName()));    Assert.assertEquals("filter", actualFixedFields.get(PcapHelper.PacketFields.PACKET_FILTER.getName()));}
public void metron_f1793_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withState(JobStatus.State.RUNNING));    long beforeJobTime = System.currentTimeMillis();    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedWithDefaultsJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    Assert.assertEquals("/apps/metron/pcap/input", mockPcapJob.getBasePath());    Assert.assertEquals("/apps/metron/pcap/interim", mockPcapJob.getBaseInterrimResultPath());    Assert.assertEquals("/apps/metron/pcap/output", mockPcapJob.getFinalOutputPath());    Assert.assertEquals(0, mockPcapJob.getStartTimeNs());    Assert.assertTrue(beforeJobTime < mockPcapJob.getEndTimeNs() / 1000000);    Assert.assertTrue(System.currentTimeMillis() > mockPcapJob.getEndTimeNs() / 1000000);    Assert.assertEquals(10, mockPcapJob.getNumReducers());    Assert.assertTrue(mockPcapJob.getFilterImpl() instanceof FixedPcapFilter.Configurator);    Map<String, String> actualFixedFields = mockPcapJob.getFixedFields();    Assert.assertEquals("192.168.1.2", actualFixedFields.get(Constants.Fields.SRC_ADDR.getName()));    Assert.assertEquals("2000", actualFixedFields.get(Constants.Fields.SRC_PORT.getName()));    Assert.assertEquals("192.168.1.1", actualFixedFields.get(Constants.Fields.DST_ADDR.getName()));    Assert.assertEquals("1000", actualFixedFields.get(Constants.Fields.DST_PORT.getName()));    Assert.assertEquals("true", actualFixedFields.get(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName()));    Assert.assertEquals("TCP", actualFixedFields.get(Constants.Fields.PROTOCOL.getName()));    Assert.assertEquals("filter", actualFixedFields.get(PcapHelper.PacketFields.PACKET_FILTER.getName()));}
public void metron_f1794_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/query").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(queryJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    Assert.assertEquals("/base/path", mockPcapJob.getBasePath());    Assert.assertEquals("/base/interim/result/path", mockPcapJob.getBaseInterrimResultPath());    Assert.assertEquals("/final/output/path", mockPcapJob.getFinalOutputPath());    Assert.assertEquals(10000000, mockPcapJob.getStartTimeNs());    Assert.assertEquals(20000000, mockPcapJob.getEndTimeNs());    Assert.assertEquals(2, mockPcapJob.getNumReducers());    Assert.assertTrue(mockPcapJob.getFilterImpl() instanceof QueryPcapFilter.Configurator);    Assert.assertEquals("query", mockPcapJob.getQuery());}
public void metron_f1795_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.message").value("Cannot submit job because a job is already running.  Please contact the administrator to cancel job(s) with id(s) jobId"));}
public void metron_f1796_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.SUCCEEDED));    Pageable<Path> pageable = new PcapPages(Arrays.asList(new Path("path1"), new Path("path1")));    mockPcapJob.setIsDone(true);    mockPcapJob.setPageable(pageable);    this.mockMvc.perform(get(pcapUrl + "/jobId").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobStatus").value("SUCCEEDED")).andExpect(jsonPath("$.pageTotal").value(2));    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.FINALIZING));    this.mockMvc.perform(get(pcapUrl + "/jobId").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobStatus").value("FINALIZING"));    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.FAILED));    this.mockMvc.perform(get(pcapUrl + "/jobId").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobStatus").value("FAILED"));    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.KILLED));    this.mockMvc.perform(get(pcapUrl + "/jobId").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobStatus").value("KILLED"));    this.mockMvc.perform(get(pcapUrl + "/someJobId").with(httpBasic(user, password))).andExpect(status().isNotFound());}
public void metron_f1797_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    this.mockMvc.perform(get(pcapUrl + "?state=RUNNING").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[0].jobId").value("jobId")).andExpect(jsonPath("$[0].jobStatus").value("RUNNING"));    this.mockMvc.perform(get(pcapUrl + "?state=SUCCEEDED").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().json("[]"));}
public void metron_f1798_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    this.mockMvc.perform(get(pcapUrl + "/jobId123").with(httpBasic(user, password))).andExpect(status().isNotFound());    mockPcapJob.setStatus(new JobStatus().withJobId("jobId123").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId123")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    mockPcapJob.setStatus(new JobStatus().withJobId("jobId123").withState(JobStatus.State.KILLED));    this.mockMvc.perform(delete(pcapUrl + "/kill/{id}", "jobId123").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId123")).andExpect(jsonPath("$.jobStatus").value("KILLED"));    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.KILLED));}
public void metron_f1799_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    this.mockMvc.perform(get(pcapUrl + "/jobId123").with(httpBasic(user, password))).andExpect(status().isNotFound());    this.mockMvc.perform(delete(pcapUrl + "/kill/{id}", "jobId123").with(httpBasic(user, password))).andExpect(status().isNotFound());}
public void metron_f1800_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    Pageable<Path> pageable = new PcapPages(Arrays.asList(new Path("./target")));    mockPcapJob.setIsDone(true);    mockPcapJob.setPageable(pageable);    this.mockMvc.perform(get(pcapUrl + "/jobId/pdml?page=1").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.version").value("0")).andExpect(jsonPath("$.creator").value("wireshark/2.6.1")).andExpect(jsonPath("$.time").value("Thu Jun 28 14:14:38 2018")).andExpect(jsonPath("$.captureFile").value("/tmp/pcap-data-201806272004-289365c53112438ca55ea047e13a12a5+0001.pcap")).andExpect(jsonPath("$.packets[0].protos[0].name").value("geninfo")).andExpect(jsonPath("$.packets[0].protos[0].fields[0].name").value("num")).andExpect(jsonPath("$.packets[0].protos[1].name").value("ip")).andExpect(jsonPath("$.packets[0].protos[1].fields[0].name").value("ip.addr"));    this.mockMvc.perform(get(pcapUrl + "/jobId/pdml?page=0").with(httpBasic(user, password))).andExpect(status().isNotFound());    this.mockMvc.perform(get(pcapUrl + "/jobId/pdml?page=2").with(httpBasic(user, password))).andExpect(status().isNotFound());}
public void metron_f1801_0() throws Exception
{    String pcapFileContents = "pcap file contents";    FileUtils.write(new File("./target/pcapFile"), pcapFileContents, "UTF8");    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    Pageable<Path> pageable = new PcapPages(Arrays.asList(new Path("./target/pcapFile")));    mockPcapJob.setIsDone(true);    mockPcapJob.setPageable(pageable);    this.mockMvc.perform(get(pcapUrl + "/jobId/raw?page=1").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(header().string("Content-Disposition", "attachment; filename=\"pcap_jobId_1.pcap\"")).andExpect(header().string("Content-Length", Integer.toString(pcapFileContents.length()))).andExpect(content().contentType(MediaType.parseMediaType("application/octet-stream"))).andExpect(content().bytes(pcapFileContents.getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(get(pcapUrl + "/jobId/raw?page=1&fileName=pcapFile.pcap").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(header().string("Content-Disposition", "attachment; filename=\"pcapFile.pcap\"")).andExpect(header().string("Content-Length", Integer.toString(pcapFileContents.length()))).andExpect(content().contentType(MediaType.parseMediaType("application/octet-stream"))).andExpect(content().bytes(pcapFileContents.getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(get(pcapUrl + "/jobId/raw?page=2").with(httpBasic(user, password))).andExpect(status().isNotFound());}
public void metron_f1802_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/fixed").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(fixedJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    this.mockMvc.perform(get(pcapUrl + "/jobId/config").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.basePath").value("/base/path")).andExpect(jsonPath("$.finalOutputPath").value("/final/output/path")).andExpect(jsonPath("$.startTimeMs").value(10)).andExpect(jsonPath("$.endTimeMs").value(20)).andExpect(jsonPath("$.numReducers").value(2)).andExpect(jsonPath("$.ipSrcAddr").value("192.168.1.2")).andExpect(jsonPath("$.ipDstAddr").value("192.168.1.1")).andExpect(jsonPath("$.ipSrcPort").value("2000")).andExpect(jsonPath("$.ipDstPort").value("1000")).andExpect(jsonPath("$.protocol").value("TCP")).andExpect(jsonPath("$.packetFilter").value("filter")).andExpect(jsonPath("$.includeReverse").value("true"));}
public void metron_f1803_0() throws Exception
{    MockPcapJob mockPcapJob = (MockPcapJob) wac.getBean("mockPcapJob");    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withState(JobStatus.State.RUNNING));    this.mockMvc.perform(post(pcapUrl + "/query").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(queryJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.jobId").value("jobId")).andExpect(jsonPath("$.jobStatus").value("RUNNING"));    this.mockMvc.perform(get(pcapUrl + "/jobId/config").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.basePath").value("/base/path")).andExpect(jsonPath("$.finalOutputPath").value("/final/output/path")).andExpect(jsonPath("$.startTimeMs").value(10)).andExpect(jsonPath("$.endTimeMs").value(20)).andExpect(jsonPath("$.numReducers").value(2)).andExpect(jsonPath("$.query").value("query"));}
public void metron_f1804_0() throws Exception
{    restExceptionHandler = new RestExceptionHandler();    request = mock(HttpServletRequest.class);}
public void metron_f1805_0() throws Exception
{    when(request.getAttribute("javax.servlet.error.status_code")).thenReturn(401);    Throwable throwable = new RuntimeException("unauthorized");    ResponseEntity responseEntity = restExceptionHandler.handleControllerException(request, throwable);    assertEquals(HttpStatus.UNAUTHORIZED, responseEntity.getStatusCode());    RestError actualRestError = (RestError) responseEntity.getBody();    assertEquals("unauthorized", actualRestError.getMessage());    assertEquals("RuntimeException: unauthorized", actualRestError.getFullMessage());    assertEquals(401, actualRestError.getResponseCode());}
public void metron_f1806_0() throws Exception
{    when(request.getAttribute("javax.servlet.error.status_code")).thenReturn(null);    Throwable throwable = new RuntimeException("some error");    ResponseEntity responseEntity = restExceptionHandler.handleControllerException(request, throwable);    assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());}
public void metron_f1807_0() throws Exception
{    when(request.getAttribute("javax.servlet.error.status_code")).thenReturn(500);    Throwable throwable = new RuntimeException("some error", new RuntimeException("some root cause"));    ResponseEntity responseEntity = restExceptionHandler.handleControllerException(request, throwable);    assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());    RestError actualRestError = (RestError) responseEntity.getBody();    assertEquals("some error", actualRestError.getMessage());    assertEquals("RuntimeException: some root cause", actualRestError.getFullMessage());    assertEquals(500, actualRestError.getResponseCode());}
public void metron_f1808_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();    ImmutableMap<String, String> testData = ImmutableMap.of("bro_index_2017.01.01.01", SearchIntegrationTest.broData, "snort_index_2017.01.01.01", SearchIntegrationTest.snortData);    loadTestData(testData);    loadColumnTypes();    loadFacetCounts();}
public void metron_f1809_0() throws Exception
{    InMemoryDao.clear();}
public void metron_f1810_0() throws Exception
{    this.mockMvc.perform(post(searchUrl + "/search").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.allQuery)).andExpect(status().isUnauthorized());}
public void metron_f1811_0() throws Exception
{    sensorIndexingConfigService.save("bro", new HashMap<String, Object>() {        {            put("index", "bro");        }    });    assertEventually(() -> this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(defaultQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(5)).andExpect(jsonPath("$.results[0].source.source:type").value("bro")).andExpect(jsonPath("$.results[0].source.timestamp").value(5)).andExpect(jsonPath("$.results[1].source.source:type").value("bro")).andExpect(jsonPath("$.results[1].source.timestamp").value(4)).andExpect(jsonPath("$.results[2].source.source:type").value("bro")).andExpect(jsonPath("$.results[2].source.timestamp").value(3)).andExpect(jsonPath("$.results[3].source.source:type").value("bro")).andExpect(jsonPath("$.results[3].source.timestamp").value(2)).andExpect(jsonPath("$.results[4].source.source:type").value("bro")).andExpect(jsonPath("$.results[4].source.timestamp").value(1)).andExpect(jsonPath("$.facetCounts.*", hasSize(2))).andExpect(jsonPath("$.facetCounts.source:type.*", hasSize(1))).andExpect(jsonPath("$.facetCounts.source:type['bro']").value(5)).andExpect(jsonPath("$.facetCounts.ip_src_addr.*", hasSize(2))).andExpect(jsonPath("$.facetCounts.ip_src_addr['192.168.1.1']").value(3)).andExpect(jsonPath("$.facetCounts.ip_src_addr['192.168.1.2']").value(1)));    sensorIndexingConfigService.delete("bro");}
public void metron_f1812_0() throws Exception
{    assertEventually(() -> this.mockMvc.perform(post("/api/v1/alerts/ui/settings").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(alertProfile)).andExpect(status().isOk()));    assertEventually(() -> this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(defaultQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.facetCounts.*", hasSize(1))).andExpect(jsonPath("$.facetCounts.ip_src_port.*", hasSize(2))).andExpect(jsonPath("$.facetCounts.ip_src_port['8010']").value(1)).andExpect(jsonPath("$.facetCounts.ip_src_port['8009']").value(2)));    alertsUIService.deleteAlertsUIUserSettings(user);}
public void metron_f1813_0() throws Exception
{        sensorIndexingConfigService.save("bro", new HashMap<String, Object>() {        {            put("index", "bro");        }    });    sensorIndexingConfigService.save("snort", new HashMap<String, Object>() {        {            put("index", "snort");        }    });        assertEventually(() -> this.mockMvc.perform(post(searchUrl + "/column/metadata").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content("[]")).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(5))).andExpect(jsonPath("$.common_string_field").value("text")).andExpect(jsonPath("$.common_integer_field").value("integer")).andExpect(jsonPath("$.bro_field").value("boolean")).andExpect(jsonPath("$.snort_field").value("double")).andExpect(jsonPath("$.duplicate_field").value("other")));    sensorIndexingConfigService.delete("bro");    sensorIndexingConfigService.delete("snort");}
public void metron_f1814_0() throws Exception
{    this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.allQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(10)).andExpect(jsonPath("$.results[0].source.source:type").value("snort")).andExpect(jsonPath("$.results[0].source.timestamp").value(10)).andExpect(jsonPath("$.results[1].source.source:type").value("snort")).andExpect(jsonPath("$.results[1].source.timestamp").value(9)).andExpect(jsonPath("$.results[2].source.source:type").value("snort")).andExpect(jsonPath("$.results[2].source.timestamp").value(8)).andExpect(jsonPath("$.results[3].source.source:type").value("snort")).andExpect(jsonPath("$.results[3].source.timestamp").value(7)).andExpect(jsonPath("$.results[4].source.source:type").value("snort")).andExpect(jsonPath("$.results[4].source.timestamp").value(6)).andExpect(jsonPath("$.results[5].source.source:type").value("bro")).andExpect(jsonPath("$.results[5].source.timestamp").value(5)).andExpect(jsonPath("$.results[6].source.source:type").value("bro")).andExpect(jsonPath("$.results[6].source.timestamp").value(4)).andExpect(jsonPath("$.results[7].source.source:type").value("bro")).andExpect(jsonPath("$.results[7].source.timestamp").value(3)).andExpect(jsonPath("$.results[8].source.source:type").value("bro")).andExpect(jsonPath("$.results[8].source.timestamp").value(2)).andExpect(jsonPath("$.results[9].source.source:type").value("bro")).andExpect(jsonPath("$.results[9].source.timestamp").value(1));    this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.filterQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(3)).andExpect(jsonPath("$.results[0].source.source:type").value("snort")).andExpect(jsonPath("$.results[0].source.timestamp").value(9)).andExpect(jsonPath("$.results[1].source.source:type").value("snort")).andExpect(jsonPath("$.results[1].source.timestamp").value(7)).andExpect(jsonPath("$.results[2].source.source:type").value("bro")).andExpect(jsonPath("$.results[2].source.timestamp").value(1));    this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.sortQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(10)).andExpect(jsonPath("$.results[0].source.ip_src_port").value(8001)).andExpect(jsonPath("$.results[1].source.ip_src_port").value(8002)).andExpect(jsonPath("$.results[2].source.ip_src_port").value(8003)).andExpect(jsonPath("$.results[3].source.ip_src_port").value(8004)).andExpect(jsonPath("$.results[4].source.ip_src_port").value(8005)).andExpect(jsonPath("$.results[5].source.ip_src_port").value(8006)).andExpect(jsonPath("$.results[6].source.ip_src_port").value(8007)).andExpect(jsonPath("$.results[7].source.ip_src_port").value(8008)).andExpect(jsonPath("$.results[8].source.ip_src_port").value(8009)).andExpect(jsonPath("$.results[9].source.ip_src_port").value(8010));    this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.paginationQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(10)).andExpect(jsonPath("$.results[0].source.source:type").value("snort")).andExpect(jsonPath("$.results[0].source.timestamp").value(6)).andExpect(jsonPath("$.results[1].source.source:type").value("bro")).andExpect(jsonPath("$.results[1].source.timestamp").value(5)).andExpect(jsonPath("$.results[2].source.source:type").value("bro")).andExpect(jsonPath("$.results[2].source.timestamp").value(4));    this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.indexQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.total").value(5)).andExpect(jsonPath("$.results[0].source.source:type").value("bro")).andExpect(jsonPath("$.results[0].source.timestamp").value(5)).andExpect(jsonPath("$.results[1].source.source:type").value("bro")).andExpect(jsonPath("$.results[1].source.timestamp").value(4)).andExpect(jsonPath("$.results[2].source.source:type").value("bro")).andExpect(jsonPath("$.results[2].source.timestamp").value(3)).andExpect(jsonPath("$.results[3].source.source:type").value("bro")).andExpect(jsonPath("$.results[3].source.timestamp").value(2)).andExpect(jsonPath("$.results[4].source.source:type").value("bro")).andExpect(jsonPath("$.results[4].source.timestamp").value(1));    this.mockMvc.perform(post(searchUrl + "/search").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.exceededMaxResultsQuery)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("Search result size must be less than 100"));    this.mockMvc.perform(post(searchUrl + "/group").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(SearchIntegrationTest.groupByQuery)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(2))).andExpect(jsonPath("$.groupedBy").value("is_alert")).andExpect(jsonPath("$.groupResults.*", hasSize(1))).andExpect(jsonPath("$.groupResults[0].*", hasSize(5))).andExpect(jsonPath("$.groupResults[0].key").value("is_alert_value")).andExpect(jsonPath("$.groupResults[0].total").value(10)).andExpect(jsonPath("$.groupResults[0].groupedBy").value("latitude")).andExpect(jsonPath("$.groupResults[0].groupResults.*", hasSize(1))).andExpect(jsonPath("$.groupResults[0].groupResults[0].*", hasSize(3))).andExpect(jsonPath("$.groupResults[0].groupResults[0].key").value("latitude_value")).andExpect(jsonPath("$.groupResults[0].groupResults[0].total").value(10)).andExpect(jsonPath("$.groupResults[0].groupResults[0].score").value(50));    this.mockMvc.perform(post(searchUrl + "/column/metadata").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content("[\"bro\",\"snort\"]")).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(5))).andExpect(jsonPath("$.common_string_field").value("text")).andExpect(jsonPath("$.common_integer_field").value("integer")).andExpect(jsonPath("$.bro_field").value("boolean")).andExpect(jsonPath("$.snort_field").value("double")).andExpect(jsonPath("$.duplicate_field").value("other"));    this.mockMvc.perform(post(searchUrl + "/column/metadata").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content("[\"bro\"]")).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(4))).andExpect(jsonPath("$.common_string_field").value("text")).andExpect(jsonPath("$.common_integer_field").value("integer")).andExpect(jsonPath("$.bro_field").value("boolean")).andExpect(jsonPath("$.duplicate_field").value("date"));    this.mockMvc.perform(post(searchUrl + "/column/metadata").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content("[\"snort\"]")).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(4))).andExpect(jsonPath("$.common_string_field").value("text")).andExpect(jsonPath("$.common_integer_field").value("integer")).andExpect(jsonPath("$.snort_field").value("double")).andExpect(jsonPath("$.duplicate_field").value("long"));    this.mockMvc.perform(post(searchUrl + "/column/metadata").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content("[\"someindex\"]")).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(0)));}
private void metron_f1815_0() throws ParseException
{    Map<String, Map<String, FieldType>> columnTypes = new HashMap<>();    Map<String, FieldType> broTypes = new HashMap<>();    broTypes.put("common_string_field", FieldType.TEXT);    broTypes.put("common_integer_field", FieldType.INTEGER);    broTypes.put("bro_field", FieldType.BOOLEAN);    broTypes.put("duplicate_field", FieldType.DATE);    Map<String, FieldType> snortTypes = new HashMap<>();    snortTypes.put("common_string_field", FieldType.TEXT);    snortTypes.put("common_integer_field", FieldType.INTEGER);    snortTypes.put("snort_field", FieldType.DOUBLE);    snortTypes.put("duplicate_field", FieldType.LONG);    columnTypes.put("bro", broTypes);    columnTypes.put("snort", snortTypes);    InMemoryDao.setColumnMetadata(columnTypes);}
private void metron_f1816_0()
{    Map<String, Map<String, Long>> facetCounts = new HashMap<>();    Map<String, Long> ipSrcAddrCounts = new HashMap<>();    ipSrcAddrCounts.put("192.168.1.1", 3L);    ipSrcAddrCounts.put("192.168.1.2", 1L);    Map<String, Long> ipSrcPortCounts = new HashMap<>();    ipSrcPortCounts.put("8010", 1L);    ipSrcPortCounts.put("8009", 2L);    Map<String, Long> sourceTypeCounts = new HashMap<>();    sourceTypeCounts.put("bro", 5L);    facetCounts.put("ip_src_addr", ipSrcAddrCounts);    facetCounts.put("ip_src_port", ipSrcPortCounts);    facetCounts.put("source:type", sourceTypeCounts);    InMemoryDao.setFacetCounts(facetCounts);}
public void metron_f1817_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1818_0() throws Exception
{    this.mockMvc.perform(post(sensorEnrichmentConfigUrl).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(sensorEnrichmentConfigUrl + "/broTest")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(sensorEnrichmentConfigUrl)).andExpect(status().isUnauthorized());    this.mockMvc.perform(delete(sensorEnrichmentConfigUrl + "/broTest").with(csrf())).andExpect(status().isUnauthorized());}
public void metron_f1819_0() throws Exception
{    sensorEnrichmentConfigService.delete("broTest");    this.mockMvc.perform(get(sensorEnrichmentConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().bytes("{}".getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(post(sensorEnrichmentConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.enrichment.fieldMap.geo[0]").value("ip_dst_addr")).andExpect(jsonPath("$.enrichment.fieldMap.host[0]").value("ip_dst_addr")).andExpect(jsonPath("$.enrichment.fieldMap.hbaseEnrichment[0]").value("ip_src_addr")).andExpect(jsonPath("$.enrichment.fieldToTypeMap.ip_src_addr[0]").value("sample")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group1.foo").value("1 + 1")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group1.bar").value("foo")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group2.ALL_CAPS").value("TO_UPPER(source.type)")).andExpect(jsonPath("$.threatIntel.fieldMap.hbaseThreatIntel[0]").value("ip_src_addr")).andExpect(jsonPath("$.threatIntel.fieldMap.hbaseThreatIntel[1]").value("ip_dst_addr")).andExpect(jsonPath("$.threatIntel.fieldToTypeMap.ip_src_addr[0]").value("malicious_ip")).andExpect(jsonPath("$.threatIntel.fieldToTypeMap.ip_dst_addr[0]").value("malicious_ip")).andExpect(jsonPath("$.threatIntel.triageConfig.riskLevelRules[0].rule").value("ip_src_addr == '10.122.196.204' or ip_dst_addr == '10.122.196.204'")).andExpect(jsonPath("$.threatIntel.triageConfig.riskLevelRules[0].score").value(10)).andExpect(jsonPath("$.threatIntel.triageConfig.aggregator").value("MAX"));    assertEventually(() -> this.mockMvc.perform(post(sensorEnrichmentConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.enrichment.fieldMap.geo[0]").value("ip_dst_addr")).andExpect(jsonPath("$.enrichment.fieldMap.host[0]").value("ip_dst_addr")).andExpect(jsonPath("$.enrichment.fieldMap.hbaseEnrichment[0]").value("ip_src_addr")).andExpect(jsonPath("$.enrichment.fieldToTypeMap.ip_src_addr[0]").value("sample")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group1.foo").value("1 + 1")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group1.bar").value("foo")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group2.ALL_CAPS").value("TO_UPPER(source.type)")).andExpect(jsonPath("$.threatIntel.fieldMap.hbaseThreatIntel[0]").value("ip_src_addr")).andExpect(jsonPath("$.threatIntel.fieldMap.hbaseThreatIntel[1]").value("ip_dst_addr")).andExpect(jsonPath("$.threatIntel.fieldToTypeMap.ip_src_addr[0]").value("malicious_ip")).andExpect(jsonPath("$.threatIntel.fieldToTypeMap.ip_dst_addr[0]").value("malicious_ip")).andExpect(jsonPath("$.threatIntel.triageConfig.riskLevelRules[0].rule").value("ip_src_addr == '10.122.196.204' or ip_dst_addr == '10.122.196.204'")).andExpect(jsonPath("$.threatIntel.triageConfig.riskLevelRules[0].score").value(10)).andExpect(jsonPath("$.threatIntel.triageConfig.aggregator").value("MAX")));    this.mockMvc.perform(get(sensorEnrichmentConfigUrl + "/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.enrichment.fieldMap.geo[0]").value("ip_dst_addr")).andExpect(jsonPath("$.enrichment.fieldMap.host[0]").value("ip_dst_addr")).andExpect(jsonPath("$.enrichment.fieldMap.hbaseEnrichment[0]").value("ip_src_addr")).andExpect(jsonPath("$.enrichment.fieldToTypeMap.ip_src_addr[0]").value("sample")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group1.foo").value("1 + 1")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group1.bar").value("foo")).andExpect(jsonPath("$.enrichment.fieldMap.stellar.config.group2.ALL_CAPS").value("TO_UPPER(source.type)")).andExpect(jsonPath("$.threatIntel.fieldMap.hbaseThreatIntel[0]").value("ip_src_addr")).andExpect(jsonPath("$.threatIntel.fieldMap.hbaseThreatIntel[1]").value("ip_dst_addr")).andExpect(jsonPath("$.threatIntel.fieldToTypeMap.ip_src_addr[0]").value("malicious_ip")).andExpect(jsonPath("$.threatIntel.fieldToTypeMap.ip_dst_addr[0]").value("malicious_ip")).andExpect(jsonPath("$.threatIntel.triageConfig.riskLevelRules[0].rule").value("ip_src_addr == '10.122.196.204' or ip_dst_addr == '10.122.196.204'")).andExpect(jsonPath("$.threatIntel.triageConfig.riskLevelRules[0].score").value(10)).andExpect(jsonPath("$.threatIntel.triageConfig.aggregator").value("MAX"));    this.mockMvc.perform(get(sensorEnrichmentConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[?(@.broTest.enrichment.fieldMap.geo[0] == 'ip_dst_addr' &&" + "@.broTest.enrichment.fieldMap.host[0] == 'ip_dst_addr' &&" + "@.broTest.enrichment.fieldMap.hbaseEnrichment[0] == 'ip_src_addr' &&" + "@.broTest.enrichment.fieldToTypeMap.ip_src_addr[0] == 'sample' &&" + "@.broTest.enrichment.fieldMap.stellar.config.group1.foo == '1 + 1' &&" + "@.broTest.enrichment.fieldMap.stellar.config.group1.bar == 'foo' &&" + "@.broTest.enrichment.fieldMap.stellar.config.group2.ALL_CAPS == 'TO_UPPER(source.type)' &&" + "@.broTest.threatIntel.fieldMap.hbaseThreatIntel[0] == 'ip_src_addr' &&" + "@.broTest.threatIntel.fieldMap.hbaseThreatIntel[1] == 'ip_dst_addr' &&" + "@.broTest.threatIntel.fieldToTypeMap.ip_src_addr[0] == 'malicious_ip' &&" + "@.broTest.threatIntel.fieldToTypeMap.ip_dst_addr[0] == 'malicious_ip' &&" + "@.broTest.threatIntel.triageConfig.riskLevelRules[0].rule == \"ip_src_addr == '10.122.196.204' or ip_dst_addr == '10.122.196.204'\" &&" + "@.broTest.threatIntel.triageConfig.riskLevelRules[0].score == 10 &&" + "@.broTest.threatIntel.triageConfig.aggregator == 'MAX'" + ")]").exists());    this.mockMvc.perform(delete(sensorEnrichmentConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isOk());    this.mockMvc.perform(get(sensorEnrichmentConfigUrl + "/broTest").with(httpBasic(user, password))).andExpect(status().isNotFound());    this.mockMvc.perform(delete(sensorEnrichmentConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isNotFound());    this.mockMvc.perform(get(sensorEnrichmentConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[?(@.sensorTopic == 'broTest')]").doesNotExist());    this.mockMvc.perform(get(sensorEnrichmentConfigUrl + "/list/available/enrichments").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.length()").value("3")).andExpect(jsonPath("$.*").value(IsCollectionContaining.hasItems("foo", "bar", "baz")));    this.mockMvc.perform(get(sensorEnrichmentConfigUrl + "/list/available/threat/triage/aggregators").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[0]").value("MAX")).andExpect(jsonPath("$[1]").value("MIN")).andExpect(jsonPath("$[2]").value("SUM")).andExpect(jsonPath("$[3]").value("MEAN")).andExpect(jsonPath("$[4]").value("POSITIVE_MEAN"));    sensorEnrichmentConfigService.delete("broTest");}
public void metron_f1820_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1821_0() throws Exception
{    this.mockMvc.perform(post(sensorIndexingConfigUrl).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isUnauthorized());    assertEventually(() -> this.mockMvc.perform(get(sensorIndexingConfigUrl + "/broTest")).andExpect(status().isUnauthorized()));    assertEventually(() -> this.mockMvc.perform(get(sensorIndexingConfigUrl)).andExpect(status().isUnauthorized()));    assertEventually(() -> this.mockMvc.perform(delete(sensorIndexingConfigUrl + "/broTest").with(csrf())).andExpect(status().isUnauthorized()));}
public void metron_f1822_0() throws Exception
{    sensorIndexingConfigService.delete("broTest");    this.mockMvc.perform(get(sensorIndexingConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().bytes("{}".getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(get(sensorIndexingConfigUrl + "/list/indices/elasticsearch").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().bytes("[]".getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(get(sensorIndexingConfigUrl + "/list/indices/blah").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().bytes("[]".getBytes(StandardCharsets.UTF_8)));    this.mockMvc.perform(post(sensorIndexingConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.index").value("broTest")).andExpect(jsonPath("$.batchSize").value(1));    assertEventually(() -> this.mockMvc.perform(get(sensorIndexingConfigUrl + "/list/indices/elasticsearch").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(content().bytes("[\"broTest\"]".getBytes(StandardCharsets.UTF_8))));    assertEventually(() -> this.mockMvc.perform(post(sensorIndexingConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.index").value("broTest")).andExpect(jsonPath("$.batchSize").value(1)));    this.mockMvc.perform(get(sensorIndexingConfigUrl + "/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.index").value("broTest")).andExpect(jsonPath("$.batchSize").value(1));    this.mockMvc.perform(get(sensorIndexingConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[?(@.broTest.index == 'broTest' &&" + "@.broTest.batchSize == 1" + ")]").exists());    this.mockMvc.perform(delete(sensorIndexingConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isOk());    assertEventually(() -> this.mockMvc.perform(get(sensorIndexingConfigUrl + "/broTest").with(httpBasic(user, password))).andExpect(status().isNotFound()));    this.mockMvc.perform(delete(sensorIndexingConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isNotFound());    assertEventually(() -> this.mockMvc.perform(get(sensorIndexingConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[?(@.sensorTopic == 'broTest')]").doesNotExist()));    sensorIndexingConfigService.delete("broTest");}
public void metron_f1823_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1824_0() throws Exception
{    this.mockMvc.perform(post(sensorParserConfigUrl).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(squidJson)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(sensorParserConfigUrl + "/squidTest")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(sensorParserConfigUrl)).andExpect(status().isUnauthorized());    this.mockMvc.perform(delete(sensorParserConfigUrl + "/squidTest").with(csrf())).andExpect(status().isUnauthorized());}
public void metron_f1825_0() throws Exception
{    cleanFileSystem();    this.sensorParserConfigService.delete("broTest");    this.sensorParserConfigService.delete("squidTest");    Method[] method = SensorParserConfig.class.getMethods();    final AtomicInteger numFields = new AtomicInteger(0);    for (Method m : method) {        if (m.getName().startsWith("set")) {            numFields.set(numFields.get() + 1);        }    }    this.mockMvc.perform(post(sensorParserConfigUrl + "/squidTest").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(squidJson)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.parserClassName").value("org.apache.metron.parsers.GrokParser")).andExpect(jsonPath("$.sensorTopic").value("squidTest")).andExpect(jsonPath("$.parserConfig.grokPath").value("target/patterns/squidTest")).andExpect(jsonPath("$.parserConfig.patternLabel").value("SQUIDTEST")).andExpect(jsonPath("$.parserConfig.timestampField").value("timestamp")).andExpect(jsonPath("$.fieldTransformations[0].transformation").value("STELLAR")).andExpect(jsonPath("$.fieldTransformations[0].output[0]").value("full_hostname")).andExpect(jsonPath("$.fieldTransformations[0].output[1]").value("domain_without_subdomains")).andExpect(jsonPath("$.fieldTransformations[0].config.full_hostname").value("URL_TO_HOST(url)")).andExpect(jsonPath("$.fieldTransformations[0].config.domain_without_subdomains").value("DOMAIN_REMOVE_SUBDOMAINS(full_hostname)"));    assertEventually(() -> this.mockMvc.perform(get(sensorParserConfigUrl + "/squidTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.parserClassName").value("org.apache.metron.parsers.GrokParser")).andExpect(jsonPath("$.sensorTopic").value("squidTest")).andExpect(jsonPath("$.parserConfig.grokPath").value("target/patterns/squidTest")).andExpect(jsonPath("$.parserConfig.patternLabel").value("SQUIDTEST")).andExpect(jsonPath("$.parserConfig.timestampField").value("timestamp")).andExpect(jsonPath("$.fieldTransformations[0].transformation").value("STELLAR")).andExpect(jsonPath("$.fieldTransformations[0].output[0]").value("full_hostname")).andExpect(jsonPath("$.fieldTransformations[0].output[1]").value("domain_without_subdomains")).andExpect(jsonPath("$.fieldTransformations[0].config.full_hostname").value("URL_TO_HOST(url)")).andExpect(jsonPath("$.fieldTransformations[0].config.domain_without_subdomains").value("DOMAIN_REMOVE_SUBDOMAINS(full_hostname)")));    this.mockMvc.perform(get(sensorParserConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.squidTest.*", hasSize(numFields.get()))).andExpect(jsonPath("$.squidTest.parserClassName").value("org.apache.metron.parsers.GrokParser")).andExpect(jsonPath("$.squidTest.sensorTopic").value("squidTest")).andExpect(jsonPath("$.squidTest.parserConfig.grokPath").value("target/patterns/squidTest")).andExpect(jsonPath("$.squidTest.parserConfig.patternLabel").value("SQUIDTEST")).andExpect(jsonPath("$.squidTest.parserConfig.timestampField").value("timestamp")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].transformation").value("STELLAR")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].output[0]").value("full_hostname")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].output[1]").value("domain_without_subdomains")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].config.full_hostname").value("URL_TO_HOST(url)")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].config.domain_without_subdomains").value("DOMAIN_REMOVE_SUBDOMAINS(full_hostname)"));    this.mockMvc.perform(post(sensorParserConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.parserClassName").value("org.apache.metron.parsers.bro.BasicBroParser")).andExpect(jsonPath("$.sensorTopic").value("broTest")).andExpect(jsonPath("$.readMetadata").value("true")).andExpect(jsonPath("$.mergeMetadata").value("true")).andExpect(jsonPath("$.parserConfig").isEmpty());    assertEventually(() -> this.mockMvc.perform(post(sensorParserConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(broJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.parserClassName").value("org.apache.metron.parsers.bro.BasicBroParser")).andExpect(jsonPath("$.sensorTopic").value("broTest")).andExpect(jsonPath("$.readMetadata").value("true")).andExpect(jsonPath("$.mergeMetadata").value("true")).andExpect(jsonPath("$.parserConfig").isEmpty()));    this.mockMvc.perform(get(sensorParserConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(2))).andExpect(jsonPath("$.squidTest.*", hasSize(numFields.get()))).andExpect(jsonPath("$.squidTest.parserClassName").value("org.apache.metron.parsers.GrokParser")).andExpect(jsonPath("$.squidTest.sensorTopic").value("squidTest")).andExpect(jsonPath("$.squidTest.parserConfig.grokPath").value("target/patterns/squidTest")).andExpect(jsonPath("$.squidTest.parserConfig.patternLabel").value("SQUIDTEST")).andExpect(jsonPath("$.squidTest.parserConfig.timestampField").value("timestamp")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].transformation").value("STELLAR")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].output[0]").value("full_hostname")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].output[1]").value("domain_without_subdomains")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].config.full_hostname").value("URL_TO_HOST(url)")).andExpect(jsonPath("$.squidTest.fieldTransformations[0].config.domain_without_subdomains").value("DOMAIN_REMOVE_SUBDOMAINS(full_hostname)")).andExpect(jsonPath("$.broTest.parserClassName").value("org.apache.metron.parsers.bro.BasicBroParser")).andExpect(jsonPath("$.broTest.*", hasSize(numFields.get()))).andExpect(jsonPath("$.broTest.sensorTopic").value("broTest")).andExpect(jsonPath("$.broTest.readMetadata").value("true")).andExpect(jsonPath("$.broTest.mergeMetadata").value("true")).andExpect(jsonPath("$.broTest.parserConfig").isEmpty());    this.mockMvc.perform(delete(sensorParserConfigUrl + "/squidTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isOk());    {                TestUtils.assertEventually(() -> Assert.assertNull(sensorParserConfigService.findOne("squidTest")));    }    this.mockMvc.perform(get(sensorParserConfigUrl + "/squidTest").with(httpBasic(user, password))).andExpect(status().isNotFound());    this.mockMvc.perform(delete(sensorParserConfigUrl + "/squidTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isNotFound());    this.mockMvc.perform(get(sensorParserConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.squidTest").doesNotExist()).andExpect(jsonPath("$.broTest").exists());    this.mockMvc.perform(delete(sensorParserConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isOk());    this.mockMvc.perform(delete(sensorParserConfigUrl + "/broTest").with(httpBasic(user, password)).with(csrf())).andExpect(status().isNotFound());    this.mockMvc.perform(get(sensorParserConfigUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.squidTest").doesNotExist()).andExpect(jsonPath("$.broTest").doesNotExist());    this.mockMvc.perform(get(sensorParserConfigUrl + "/list/available").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.Bro").value("org.apache.metron.parsers.bro.BasicBroParser")).andExpect(jsonPath("$.Grok").value("org.apache.metron.parsers.GrokParser"));    this.mockMvc.perform(get(sensorParserConfigUrl + "/reload/available").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.Bro").value("org.apache.metron.parsers.bro.BasicBroParser")).andExpect(jsonPath("$.Grok").value("org.apache.metron.parsers.GrokParser"));    this.mockMvc.perform(post(sensorParserConfigUrl + "/parseMessage").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(parseRequest)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.elapsed").value(415)).andExpect(jsonPath("$.code").value(200)).andExpect(jsonPath("$.ip_dst_addr").value("207.109.73.154")).andExpect(jsonPath("$.method").value("GET")).andExpect(jsonPath("$.bytes").value(337891)).andExpect(jsonPath("$.action").value("TCP_MISS")).andExpect(jsonPath("$.ip_src_addr").value("127.0.0.1")).andExpect(jsonPath("$.url").value("http://www.aliexpress.com/af/shoes.html?")).andExpect(jsonPath("$.timestamp").value(1467011157401L));    this.mockMvc.perform(post(sensorParserConfigUrl + "/parseMessage").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(missingConfigParseRequest)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("SensorParserConfig is missing from ParseMessageRequest"));    this.mockMvc.perform(post(sensorParserConfigUrl + "/parseMessage").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(missingClassParseRequest)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("SensorParserConfig must have a parserClassName"));    this.mockMvc.perform(post(sensorParserConfigUrl + "/parseMessage").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(badClassParseRequest)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("java.lang.ClassNotFoundException: badClass"));    this.sensorParserConfigService.delete("broTest");    this.sensorParserConfigService.delete("squidTest");}
private void metron_f1826_0() throws IOException
{    File grokTempPath = new File(environment.getProperty(MetronRestConstants.GROK_TEMP_PATH_SPRING_PROPERTY));    if (grokTempPath.exists()) {        FileUtils.cleanDirectory(grokTempPath);        FileUtils.deleteDirectory(grokTempPath);    }}
public void metron_f1827_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();    Method[] method = SensorParserGroup.class.getMethods();    numFields = new AtomicInteger(0);    for (Method m : method) {        if (m.getName().startsWith("set")) {            numFields.set(numFields.get() + 1);        }    }    this.globalConfigService.save(new HashMap<>());    this.sensorParserConfigService.save("bro", new SensorParserConfig());    this.sensorParserConfigService.save("snort", new SensorParserConfig());    this.sensorParserConfigService.save("squid", new SensorParserConfig());    this.sensorParserConfigService.save("yaf", new SensorParserConfig());    this.sensorParserConfigService.save("jsonMap", new SensorParserConfig());    TestUtils.assertEventually(() -> Assert.assertNotNull(sensorParserConfigService.findOne("bro")));    TestUtils.assertEventually(() -> Assert.assertNotNull(sensorParserConfigService.findOne("snort")));    TestUtils.assertEventually(() -> Assert.assertNotNull(sensorParserConfigService.findOne("squid")));    TestUtils.assertEventually(() -> Assert.assertNotNull(sensorParserConfigService.findOne("yaf")));    TestUtils.assertEventually(() -> Assert.assertNotNull(sensorParserConfigService.findOne("jsonMap")));}
public void metron_f1828_0() throws Exception
{    this.mockMvc.perform(post(sensorParserGroupUrl).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(group1BroSnort)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(sensorParserGroupUrl + "/group1")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(sensorParserGroupUrl)).andExpect(status().isUnauthorized());    this.mockMvc.perform(delete(sensorParserGroupUrl + "/group1").with(csrf())).andExpect(status().isUnauthorized());}
public void metron_f1829_0() throws Exception
{    this.mockMvc.perform(post(sensorParserGroupUrl).with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(group1BroSnort)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.name").value("group1")).andExpect(jsonPath("$.description").value("group1 description")).andExpect(jsonPath("$.sensors[0]").value("bro")).andExpect(jsonPath("$.sensors[1]").value("snort"));    this.mockMvc.perform(post(sensorParserGroupUrl).with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(group2YafJsonMap)).andExpect(status().isCreated()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.name").value("group2")).andExpect(jsonPath("$.description").value("group2 description")).andExpect(jsonPath("$.sensors[0]").value("jsonMap")).andExpect(jsonPath("$.sensors[1]").value("yaf"));}
public void metron_f1830_0() throws Exception
{    SensorParserGroup group1 = JSONUtils.INSTANCE.load(group1BroSquid, SensorParserGroup.class);    this.sensorParserGroupService.save(group1);    TestUtils.assertEventually(() -> Assert.assertEquals(group1, this.sensorParserGroupService.findOne("group1")));    this.mockMvc.perform(post(sensorParserGroupUrl).with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(group1BroSquid)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.name").value("group1")).andExpect(jsonPath("$.description").value("group1 description")).andExpect(jsonPath("$.sensors[0]").value("squid")).andExpect(jsonPath("$.sensors[1]").value("bro"));}
public void metron_f1831_0() throws Exception
{    SensorParserGroup group1 = JSONUtils.INSTANCE.load(group1BroSquid, SensorParserGroup.class);    this.sensorParserGroupService.save(group1);    TestUtils.assertEventually(() -> Assert.assertEquals(group1, this.sensorParserGroupService.findOne("group1")));    this.mockMvc.perform(get(sensorParserGroupUrl + "/group1").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(numFields.get()))).andExpect(jsonPath("$.name").value("group1")).andExpect(jsonPath("$.description").value("group1 description")).andExpect(jsonPath("$.sensors[0]").value("squid")).andExpect(jsonPath("$.sensors[1]").value("bro"));    this.mockMvc.perform(get(sensorParserGroupUrl + "/missingGroup").with(httpBasic(user, password))).andExpect(status().isNotFound());}
public void metron_f1832_0() throws Exception
{    SensorParserGroup group1 = JSONUtils.INSTANCE.load(group1BroSquid, SensorParserGroup.class);    this.sensorParserGroupService.save(group1);    TestUtils.assertEventually(() -> Assert.assertEquals(group1, this.sensorParserGroupService.findOne("group1")));    SensorParserGroup group2 = JSONUtils.INSTANCE.load(group2YafJsonMap, SensorParserGroup.class);    this.sensorParserGroupService.save(group2);    TestUtils.assertEventually(() -> Assert.assertEquals(group2, this.sensorParserGroupService.findOne("group2")));    this.mockMvc.perform(get(sensorParserGroupUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.*", hasSize(2))).andExpect(jsonPath("$.group1.*", hasSize(numFields.get()))).andExpect(jsonPath("$.group1.name").value("group1")).andExpect(jsonPath("$.group1.description").value("group1 description")).andExpect(jsonPath("$.group1.sensors[0]").value("squid")).andExpect(jsonPath("$.group1.sensors[1]").value("bro")).andExpect(jsonPath("$.group2.*", hasSize(numFields.get()))).andExpect(jsonPath("$.group2.name").value("group2")).andExpect(jsonPath("$.group2.description").value("group2 description")).andExpect(jsonPath("$.group2.sensors[0]").value("jsonMap")).andExpect(jsonPath("$.group2.sensors[1]").value("yaf"));}
public void metron_f1833_0() throws Exception
{    SensorParserGroup group1 = JSONUtils.INSTANCE.load(group1BroSquid, SensorParserGroup.class);    this.sensorParserGroupService.save(group1);    TestUtils.assertEventually(() -> Assert.assertEquals(group1, this.sensorParserGroupService.findOne("group1")));    this.mockMvc.perform(post(sensorParserGroupUrl).with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(errorGroup)).andExpect(status().isInternalServerError()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.responseCode").value(500)).andExpect(jsonPath("$.message").value("Sensor bro is already in group group1")).andExpect(jsonPath("$.fullMessage").value("RestException: Sensor bro is already in group group1"));}
public void metron_f1834_0() throws Exception
{    SensorParserGroup group1 = JSONUtils.INSTANCE.load(group1BroSquid, SensorParserGroup.class);    this.sensorParserGroupService.save(group1);    TestUtils.assertEventually(() -> Assert.assertEquals(group1, this.sensorParserGroupService.findOne("group1")));    this.mockMvc.perform(delete(sensorParserGroupUrl + "/group1").with(httpBasic(user, password)).with(csrf())).andExpect(status().isOk());    this.mockMvc.perform(delete(sensorParserGroupUrl + "/missingGroup").with(httpBasic(user, password))).andExpect(status().isNotFound());    {                TestUtils.assertEventually(() -> Assert.assertNull(sensorParserGroupService.findOne("group1")));    }}
public void metron_f1835_0() throws Exception
{    this.globalConfigService.delete();    this.sensorParserConfigService.delete("bro");    this.sensorParserConfigService.delete("snort");    this.sensorParserConfigService.delete("squid");    this.sensorParserConfigService.delete("yaf");    this.sensorParserConfigService.delete("jsonMap");}
public void metron_f1836_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1837_0() throws Exception
{    this.mockMvc.perform(post(stellarUrl + "/validate/rules").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(rulesJson)).andExpect(status().isUnauthorized());    this.mockMvc.perform(post(stellarUrl + "/apply/transformations").with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(sensorParseContext)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stellarUrl + "/list")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stellarUrl + "/list/functions")).andExpect(status().isUnauthorized());}
public void metron_f1838_0() throws Exception
{    this.mockMvc.perform(post(stellarUrl + "/validate/rules").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(rulesJson)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.['" + valid + "']").value(Boolean.TRUE)).andExpect(jsonPath("$.['" + invalid + "']").value(Boolean.FALSE));    this.mockMvc.perform(post(stellarUrl + "/apply/transformations").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(sensorParseContext)).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.url").value("https://caseystella.com/blog")).andExpect(jsonPath("$.url_host").value("caseystella.com"));    this.mockMvc.perform(get(stellarUrl + "/list").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$", hasSize(greaterThan(0))));    this.mockMvc.perform(get(stellarUrl + "/list/functions").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$", hasSize(greaterThan(0))));    this.mockMvc.perform(get(stellarUrl + "/list/simple/functions").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$", hasSize(greaterThan(0))));}
public void metron_f1839_0() throws Exception
{    this.metronVersion = this.environment.getProperty("metron.version");    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1840_0() throws Exception
{    this.mockMvc.perform(get(stormUrl)).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/supervisors")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/broTest")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/parser/start/broTest")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/parser/stop/broTest")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/parser/activate/broTest")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/parser/deactivate/broTest")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get("/enrichment")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/enrichment/start")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/enrichment/stop")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/enrichment/activate")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/enrichment/deactivate")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get("/indexing")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/indexing/start")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/indexing/stop")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/indexing/activate")).andExpect(status().isUnauthorized());    this.mockMvc.perform(get(stormUrl + "/indexing/deactivate")).andExpect(status().isUnauthorized());}
public void metron_f1841_0() throws Exception
{    this.mockMvc.perform(get(stormUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$", hasSize(0)));    this.mockMvc.perform(get(stormUrl + "/broTest").with(httpBasic(user, password))).andExpect(status().isNotFound());    Map<String, Object> globalConfig = globalConfigService.get();    if (globalConfig == null) {        globalConfig = new HashMap<>();    }    globalConfigService.delete();    sensorParserConfigService.delete("broTest");    this.mockMvc.perform(get(stormUrl + "/parser/stop/broTest?stopNow=true").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STOP_ERROR.toString()));    this.mockMvc.perform(get(stormUrl + "/parser/activate/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.TOPOLOGY_NOT_FOUND.name()));    this.mockMvc.perform(get(stormUrl + "/parser/deactivate/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.TOPOLOGY_NOT_FOUND.name()));    this.mockMvc.perform(get(stormUrl + "/parser/start/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.GLOBAL_CONFIG_MISSING.name()));    globalConfigService.save(globalConfig);    {        final Map<String, Object> expectedGlobalConfig = globalConfig;                TestUtils.assertEventually(() -> Assert.assertEquals(expectedGlobalConfig, globalConfigService.get()));    }    this.mockMvc.perform(get(stormUrl + "/parser/start/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.SENSOR_PARSER_CONFIG_MISSING.name()));    SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setParserClassName("org.apache.metron.parsers.bro.BasicBroParser");    sensorParserConfig.setSensorTopic("broTest");    sensorParserConfigService.save("broTest", sensorParserConfig);    {        final SensorParserConfig expectedSensorParserConfig = sensorParserConfig;                TestUtils.assertEventually(() -> Assert.assertEquals(expectedSensorParserConfig, sensorParserConfigService.findOne("broTest")));    }    this.mockMvc.perform(get(stormUrl + "/parser/start/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STARTED.name()));    this.mockMvc.perform(get(stormUrl + "/supervisors").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.supervisors[0]").exists()).andExpect(jsonPath("$.supervisors[0].id").exists()).andExpect(jsonPath("$.supervisors[0].host").exists()).andExpect(jsonPath("$.supervisors[0].uptime").exists()).andExpect(jsonPath("$.supervisors[0].slotsTotal").exists()).andExpect(jsonPath("$.supervisors[0].slotsUsed").exists());    this.mockMvc.perform(get(stormUrl + "/broTest").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.name").value("broTest")).andExpect(jsonPath("$.id", containsString("broTest"))).andExpect(jsonPath("$.status").value("ACTIVE")).andExpect(jsonPath("$.latency").exists()).andExpect(jsonPath("$.throughput").exists()).andExpect(jsonPath("$.emitted").exists()).andExpect(jsonPath("$.acked").exists());    this.mockMvc.perform(get(stormUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[?(@.name == 'broTest' && @.status == 'ACTIVE')]").exists());    this.mockMvc.perform(get(stormUrl + "/parser/stop/broTest?stopNow=true").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STOPPED.name()));    this.mockMvc.perform(get(stormUrl + "/enrichment").with(httpBasic(user, password))).andExpect(status().isNotFound());    this.mockMvc.perform(get(stormUrl + "/enrichment/activate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.TOPOLOGY_NOT_FOUND.name()));    this.mockMvc.perform(get(stormUrl + "/enrichment/deactivate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.TOPOLOGY_NOT_FOUND.name()));    this.mockMvc.perform(get(stormUrl + "/enrichment/stop?stopNow=true").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STOP_ERROR.toString()));    this.mockMvc.perform(get(stormUrl + "/enrichment/start").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STARTED.toString()));    this.mockMvc.perform(get(stormUrl + "/enrichment/deactivate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.INACTIVE.name()));    this.mockMvc.perform(get(stormUrl + "/enrichment/deactivate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.INACTIVE.name()));    this.mockMvc.perform(get(stormUrl + "/enrichment/activate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.ACTIVE.name()));    this.mockMvc.perform(get(stormUrl + "/enrichment").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.name").value("enrichment")).andExpect(jsonPath("$.id", containsString("enrichment"))).andExpect(jsonPath("$.status").value("ACTIVE")).andExpect(jsonPath("$.latency").exists()).andExpect(jsonPath("$.throughput").exists()).andExpect(jsonPath("$.emitted").exists()).andExpect(jsonPath("$.acked").exists());    this.mockMvc.perform(get(stormUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[?(@.name == 'enrichment' && @.status == 'ACTIVE')]").exists());    this.mockMvc.perform(get(stormUrl + "/enrichment/stop").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STOPPED.name()));    for (String type : ImmutableList.of("randomaccess", "batch")) {        this.mockMvc.perform(get(stormUrl + "/indexing/" + type).with(httpBasic(user, password))).andExpect(status().isNotFound());        this.mockMvc.perform(get(stormUrl + "/indexing/" + type + "/activate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.TOPOLOGY_NOT_FOUND.name()));        this.mockMvc.perform(get(stormUrl + "/indexing/" + type + "/deactivate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.TOPOLOGY_NOT_FOUND.name()));        this.mockMvc.perform(get(stormUrl + "/indexing/" + type + "/stop?stopNow=true").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("ERROR")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STOP_ERROR.toString()));        this.mockMvc.perform(get(stormUrl + "/indexing/" + type + "/start").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STARTED.toString()));        ResultActions actions = this.mockMvc.perform(get(stormUrl + "/indexing/" + type + "/deactivate").with(httpBasic(user, password)));        actions.andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.INACTIVE.name()));        this.mockMvc.perform(get(stormUrl + "/indexing/" + type + "/activate").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.ACTIVE.name()));        String topologyName = type.equals("randomaccess") ? MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME : MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME;        this.mockMvc.perform(get(stormUrl + "/indexing/" + type).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.name").value(topologyName)).andExpect(jsonPath("$.id", containsString("indexing"))).andExpect(jsonPath("$.status").value("ACTIVE")).andExpect(jsonPath("$.latency").exists()).andExpect(jsonPath("$.throughput").exists()).andExpect(jsonPath("$.emitted").exists()).andExpect(jsonPath("$.acked").exists());        this.mockMvc.perform(get(stormUrl).with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$[?(@.name == '" + topologyName + "' && @.status == 'ACTIVE')]").exists());        this.mockMvc.perform(get(stormUrl + "/indexing/" + type + "/stop").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.status").value("SUCCESS")).andExpect(jsonPath("$.message").value(TopologyStatusCode.STOPPED.name()));    }    this.mockMvc.perform(get(stormUrl + "/client/status").with(httpBasic(user, password))).andExpect(status().isOk()).andExpect(jsonPath("$.stormClientVersionInstalled").value("1.0.1")).andExpect(jsonPath("$.parserScriptPath").value("/usr/metron/" + metronVersion + "/bin/start_parser_topology.sh")).andExpect(jsonPath("$.enrichmentScriptPath").value("/usr/metron/" + metronVersion + "/bin/start_enrichment_topology.sh")).andExpect(jsonPath("$.randomAccessIndexingScriptPath").value("/usr/metron/" + metronVersion + "/bin/start_elasticsearch_topology.sh")).andExpect(jsonPath("$.batchIndexingScriptPath").value("/usr/metron/" + metronVersion + "/bin/start_hdfs_topology.sh"));    globalConfigService.delete();    sensorParserConfigService.delete("broTest");}
public void metron_f1842_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();    ImmutableMap<String, String> testData = ImmutableMap.of("bro_index_2017.01.01.01", SearchIntegrationTest.broData, "snort_index_2017.01.01.01", SearchIntegrationTest.snortData, metaAlertIndex, MetaAlertControllerIntegrationTest.metaAlertData);    loadTestData(testData);}
public void metron_f1843_0() throws Exception
{    String guid = "bro_2";        MockHttpServletRequestBuilder findOneRequest = post(searchUrl + "/findOne").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(findMessage0);        MockHttpServletRequestBuilder patchRequest = patch(updateUrl + "/patch").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(patch);        this.mockMvc.perform(findOneRequest).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.source:type").value("bro")).andExpect(jsonPath("$.guid").value(guid)).andExpect(jsonPath("$.project").doesNotExist()).andExpect(jsonPath("$.timestamp").value(2));        MockHTable table = (MockHTable) MockHBaseTableProvider.getFromCache(TABLE);    Assert.assertEquals(0, table.size());        this.mockMvc.perform(patchRequest).andExpect(status().isOk());        this.mockMvc.perform(findOneRequest).andExpect(status().isOk()).andExpect(content().contentType(MediaType.parseMediaType("application/json;charset=UTF-8"))).andExpect(jsonPath("$.source:type").value("bro")).andExpect(jsonPath("$.guid").value(guid)).andExpect(jsonPath("$.project").value("metron")).andExpect(jsonPath("$.timestamp").value(2));        Assert.assertEquals(1, table.size());    {                Get g = new Get(new HBaseDao.Key(guid, "bro").toBytes());        Result r = table.get(g);        NavigableMap<byte[], byte[]> columns = r.getFamilyMap(CF.getBytes(StandardCharsets.UTF_8));        Assert.assertEquals(1, columns.size());    }}
public void metron_f1844_0() throws Exception
{    CommentAddRemoveRequest commentAddRemoveRequest = new CommentAddRemoveRequest();    commentAddRemoveRequest.setGuid("bro_1");    commentAddRemoveRequest.setSensorType("bro");    commentAddRemoveRequest.setComment("test_comment");    commentAddRemoveRequest.setUsername("test_username");    commentAddRemoveRequest.setTimestamp(0L);    updateService.addComment(commentAddRemoveRequest);    ResultActions result = this.mockMvc.perform(post(updateUrl + "/add/comment").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(addComment));    result.andExpect(status().isOk());}
public void metron_f1845_0() throws Exception
{    CommentAddRemoveRequest commentAddRemoveRequest = new CommentAddRemoveRequest();    commentAddRemoveRequest.setGuid("bro_1");    commentAddRemoveRequest.setSensorType("bro");    commentAddRemoveRequest.setComment("test_comment");    commentAddRemoveRequest.setUsername("test_username");    commentAddRemoveRequest.setTimestamp(0L);    updateService.removeComment(commentAddRemoveRequest);    ResultActions result = this.mockMvc.perform(post(updateUrl + "/remove/comment").with(httpBasic(user, password)).with(csrf()).contentType(MediaType.parseMediaType("application/json;charset=UTF-8")).content(removeComment));    result.andExpect(status().isOk());}
public void metron_f1846_0() throws Exception
{    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).apply(springSecurity()).build();}
public void metron_f1847_0() throws Exception
{    this.mockMvc.perform(get(userUrl)).andExpect(status().isUnauthorized());}
public void metron_f1848_0() throws Exception
{    this.mockMvc.perform(get(userUrl).with(httpBasic(user1, password))).andExpect(status().isOk()).andExpect(content().string(user1));}
public void metron_f1849_0(String brokerUrl)
{    this.brokerUrl = brokerUrl;}
public void metron_f1850_0(Integer num)
{    this.num = num;}
public void metron_f1851_0(String selectedSensorType)
{    this.selectedSensorType = selectedSensorType;}
public void metron_f1852_0(Integer delay)
{    this.delay = delay;}
public static void metron_f1853_0(String[] args) throws org.apache.commons.cli.ParseException, IOException, ParseException
{    CommandLineParser parser = new PosixParser();    CommandLine cli = parser.parse(getOptions(), args);    Integer num = Integer.parseInt(cli.getOptionValue("n", "-1"));    String selectedSensorType = cli.getOptionValue("s");    Integer delay = Integer.parseInt(cli.getOptionValue("d", "1000"));    String path = cli.getOptionValue("p");    if (selectedSensorType == null || path == null) {        HelpFormatter formatter = new HelpFormatter();        formatter.printHelp("sample_data_generator", getOptions());    } else {        SampleDataGenerator sampleDataGenerator = new SampleDataGenerator();        sampleDataGenerator.setNum(num);        sampleDataGenerator.setSelectedSensorType(selectedSensorType);        sampleDataGenerator.setDelay(delay);        sampleDataGenerator.generateSampleData(path);    }}
private static Options metron_f1854_0()
{    Options options = new Options();    options.addOption("b", "brokerUrl", true, "Kafka Broker Url");    options.addOption("n", "num", false, "Number of messages to emit");    options.addOption("s", "sensorType", true, "Emit messages to this topic");    options.addOption("d", "delay", false, "Number of milliseconds to wait between each message.  Defaults to 1 second");    options.addOption("p", "path", true, "Local path to data file");    return options;}
public void metron_f1855_0(String path) throws IOException, ParseException
{    loadData(path);    startClients();    try {        emitData(num, selectedSensorType, delay);    } finally {        stopClients();    }}
private void metron_f1856_0(String sampleDataPath) throws IOException, ParseException
{    sampleData.put(selectedSensorType, FileUtils.readLines(new File(sampleDataPath)));    indexes.put(selectedSensorType, 0);}
private void metron_f1857_0(int num, String selectedSensorType, int delay)
{    int count = 0;    boolean continueEmitting = false;    do {        for (String sensorType : sampleData.keySet()) {            if (selectedSensorType == null || selectedSensorType.equals(sensorType)) {                List<String> sensorData = sampleData.get(sensorType);                int index = indexes.get(sensorType);                String message = sensorData.get(index++);                emitSensorData(sensorType, message, delay);                if (num != -1 && ++count >= num) {                    continueEmitting = false;                    break;                }                continueEmitting = true;                if (index == sensorData.size()) {                    index = 0;                }                indexes.put(sensorType, index);            }        }    } while (continueEmitting);}
private void metron_f1858_1(String sensorType, String message, int delay)
{    try {        Thread.sleep(delay);    } catch (InterruptedException e) {        e.printStackTrace();    }        emitToKafka(sensorType, message);}
private void metron_f1859_0()
{    startKafka();}
private void metron_f1860_0()
{    Map<String, Object> producerConfig = new HashMap<>();    producerConfig.put("bootstrap.servers", brokerUrl);    producerConfig.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");    producerConfig.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");    kafkaProducer = new KafkaProducer<>(producerConfig);}
private void metron_f1861_0()
{    stopKafka();}
private void metron_f1862_1()
{        kafkaProducer.close();}
private void metron_f1863_0(String topic, String message)
{    kafkaProducer.send(new ProducerRecord<String, String>(topic, message));}
public void metron_f1864_0()
{    mockStatic(SpringApplication.class);    String[] args = { "arg1", "arg2" };    MetronRestApplication.main(args);    verifyStatic(times(1));    SpringApplication.run(MetronRestApplication.class, args);}
public Statusable<Path> metron_f1865_0(Finalizer<Path> finalizer, Map<String, Object> configuration) throws JobException
{    when(statusable.getConfiguration()).thenReturn(new HashMap<>(configuration));    this.basePath = PcapOptions.BASE_PATH.get(configuration, String.class);    this.baseInterrimResultPath = PcapOptions.BASE_INTERIM_RESULT_PATH.get(configuration, String.class);    this.finalOutputPath = PcapOptions.FINAL_OUTPUT_PATH.get(configuration, String.class);    this.startTimeNs = PcapOptions.START_TIME_MS.get(configuration, Long.class) * 1000000;    this.endTimeNs = PcapOptions.END_TIME_MS.get(configuration, Long.class) * 1000000;    this.numReducers = PcapOptions.NUM_REDUCERS.get(configuration, Integer.class);    Object fields = PcapOptions.FIELDS.get(configuration, Object.class);    if (fields instanceof Map) {        this.fixedFields = (Map<String, String>) fields;    } else {        this.query = (String) fields;    }    this.filterImpl = PcapOptions.FILTER_IMPL.get(configuration, PcapFilterConfigurator.class);    this.recPerFile = PcapOptions.NUM_RECORDS_PER_FILE.get(configuration, Integer.class);    this.yarnQueue = PcapOptions.HADOOP_CONF.get(configuration, Configuration.class).get(MRJobConfig.QUEUE_NAME);    this.finalizerThreadpoolSize = PcapOptions.FINALIZER_THREADPOOL_SIZE.get(configuration, String.class);    return statusable;}
public JobStatus metron_f1866_0() throws JobException
{    return statusable.getStatus();}
public Pageable<Path> metron_f1867_0() throws JobException, InterruptedException
{    return statusable.get();}
public void metron_f1868_0(JobStatus jobStatus) throws JobException
{    when(statusable.getStatus()).thenReturn(jobStatus);}
public void metron_f1869_0(Pageable<Path> pageable) throws JobException, InterruptedException
{    when(statusable.get()).thenReturn(pageable);}
public void metron_f1870_0(boolean isDone)
{    when(statusable.isDone()).thenReturn(isDone);}
public String metron_f1871_0()
{    return basePath;}
public void metron_f1872_0(String basePath)
{    this.basePath = basePath;}
public String metron_f1873_0()
{    return baseInterrimResultPath;}
public void metron_f1874_0(String baseInterrimResultPath)
{    this.baseInterrimResultPath = baseInterrimResultPath;}
public String metron_f1875_0()
{    return finalOutputPath;}
public void metron_f1876_0(String finalOutputPath)
{    this.finalOutputPath = finalOutputPath;}
public long metron_f1877_0()
{    return startTimeNs;}
public long metron_f1878_0()
{    return endTimeNs;}
public int metron_f1879_0()
{    return numReducers;}
public Map<String, String> metron_f1880_0()
{    return fixedFields;}
public String metron_f1881_0()
{    return query;}
public PcapFilterConfigurator metron_f1882_0()
{    return filterImpl;}
public int metron_f1883_0()
{    return recPerFile;}
public String metron_f1884_0()
{    return yarnQueue;}
public String metron_f1885_0()
{    return finalizerThreadpoolSize;}
protected PcapJob metron_f1886_0()
{    return mockPcapJob;}
public void metron_f1887_0(MockPcapJob mockPcapJob)
{    this.mockPcapJob = mockPcapJob;}
public InputStream metron_f1888_0(String scriptPath, FileSystem fileSystem, Path pcapPath) throws IOException
{    return new ByteArrayInputStream(pdmlXml.getBytes(StandardCharsets.UTF_8));}
public Set<String> metron_f1889_0()
{    return parsersStatus.keySet();}
public TopologyStatusCode metron_f1890_0(String name)
{    TopologyStatusCode parserStatus = parsersStatus.get(name);    if (parserStatus == null) {        return TopologyStatusCode.TOPOLOGY_NOT_FOUND;    } else {        return parserStatus;    }}
public int metron_f1891_0(String name) throws RestException
{    TopologyStatusCode parserStatus = parsersStatus.get(name);    if (parserStatus == null || parserStatus == TopologyStatusCode.TOPOLOGY_NOT_FOUND) {        parsersStatus.put(name, TopologyStatusCode.ACTIVE);        return 0;    } else {        return 1;    }}
public int metron_f1892_0(String name, boolean stopNow) throws RestException
{    TopologyStatusCode parserStatus = parsersStatus.get(name);    if (parserStatus == TopologyStatusCode.ACTIVE) {        parsersStatus.put(name, TopologyStatusCode.TOPOLOGY_NOT_FOUND);        return 0;    } else {        return 1;    }}
public int metron_f1893_0(String name)
{    TopologyStatusCode parserStatus = parsersStatus.get(name);    if (parserStatus == TopologyStatusCode.INACTIVE || parserStatus == TopologyStatusCode.ACTIVE) {        parsersStatus.put(name, TopologyStatusCode.ACTIVE);        return 0;    } else {        return 1;    }}
public int metron_f1894_0(String name)
{    TopologyStatusCode parserStatus = parsersStatus.get(name);    if (parserStatus == TopologyStatusCode.INACTIVE || parserStatus == TopologyStatusCode.ACTIVE) {        parsersStatus.put(name, TopologyStatusCode.INACTIVE);        return 0;    } else {        return 1;    }}
public TopologyStatusCode metron_f1895_0()
{    return enrichmentStatus;}
public int metron_f1896_0() throws RestException
{    if (enrichmentStatus == TopologyStatusCode.TOPOLOGY_NOT_FOUND) {        enrichmentStatus = TopologyStatusCode.ACTIVE;        return 0;    } else {        return 1;    }}
public int metron_f1897_0(boolean stopNow) throws RestException
{    if (enrichmentStatus == TopologyStatusCode.ACTIVE) {        enrichmentStatus = TopologyStatusCode.TOPOLOGY_NOT_FOUND;        return 0;    } else {        return 1;    }}
public int metron_f1898_0()
{    if (enrichmentStatus == TopologyStatusCode.INACTIVE || enrichmentStatus == TopologyStatusCode.ACTIVE) {        enrichmentStatus = TopologyStatusCode.ACTIVE;        return 0;    } else {        return 1;    }}
public int metron_f1899_0()
{    if (enrichmentStatus == TopologyStatusCode.INACTIVE || enrichmentStatus == TopologyStatusCode.ACTIVE) {        enrichmentStatus = TopologyStatusCode.INACTIVE;        return 0;    } else {        return 1;    }}
public TopologyStatusCode metron_f1900_0(String name)
{    return name.equals(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME) ? batchIndexingStatus : randomAccessIndexingStatus;}
public int metron_f1901_0(String scriptPath) throws RestException
{    if (scriptPath.equals(MetronRestConstants.BATCH_INDEXING_SCRIPT_PATH_SPRING_PROPERTY)) {        if (batchIndexingStatus == TopologyStatusCode.TOPOLOGY_NOT_FOUND) {            batchIndexingStatus = TopologyStatusCode.ACTIVE;            return 0;        } else {            return 1;        }    } else {        if (randomAccessIndexingStatus == TopologyStatusCode.TOPOLOGY_NOT_FOUND) {            randomAccessIndexingStatus = TopologyStatusCode.ACTIVE;            return 0;        } else {            return 1;        }    }}
public int metron_f1902_0(String name, boolean stopNow) throws RestException
{    if (name.equals(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME)) {        if (batchIndexingStatus == TopologyStatusCode.ACTIVE) {            batchIndexingStatus = TopologyStatusCode.TOPOLOGY_NOT_FOUND;            return 0;        } else {            return 1;        }    } else {        if (randomAccessIndexingStatus == TopologyStatusCode.ACTIVE) {            randomAccessIndexingStatus = TopologyStatusCode.TOPOLOGY_NOT_FOUND;            return 0;        } else {            return 1;        }    }}
public int metron_f1903_0(String name)
{    if (name.equals(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME)) {        if (batchIndexingStatus == TopologyStatusCode.INACTIVE || batchIndexingStatus == TopologyStatusCode.ACTIVE) {            batchIndexingStatus = TopologyStatusCode.ACTIVE;            return 0;        } else {            return 1;        }    } else {        if (randomAccessIndexingStatus == TopologyStatusCode.INACTIVE || randomAccessIndexingStatus == TopologyStatusCode.ACTIVE) {            randomAccessIndexingStatus = TopologyStatusCode.ACTIVE;            return 0;        } else {            return 1;        }    }}
public int metron_f1904_0(String name)
{    if (name.equals(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME)) {        if (batchIndexingStatus == TopologyStatusCode.INACTIVE || batchIndexingStatus == TopologyStatusCode.ACTIVE) {            batchIndexingStatus = TopologyStatusCode.INACTIVE;            return 0;        } else {            return 1;        }    } else {        if (randomAccessIndexingStatus == TopologyStatusCode.INACTIVE || randomAccessIndexingStatus == TopologyStatusCode.ACTIVE) {            randomAccessIndexingStatus = TopologyStatusCode.INACTIVE;            return 0;        } else {            return 1;        }    }}
protected String metron_f1905_0() throws RestException
{    return "1.0.1";}
public void metron_f1906_0(MockStormCLIClientWrapper mockStormCLIClientWrapper)
{    this.mockStormCLIClientWrapper = mockStormCLIClientWrapper;}
public Object metron_f1907_0(String url, Class responseType, Object... urlVariables) throws RestClientException
{    Object response = null;    if (url.equals(getStormUiProperty() + MetronRestConstants.TOPOLOGY_SUMMARY_URL)) {        TopologySummary topologySummary = new TopologySummary();        List<TopologyStatus> topologyStatusList = new ArrayList<>();        for (String name : mockStormCLIClientWrapper.getParserTopologyNames()) {            topologyStatusList.add(getTopologyStatus(name));        }        TopologyStatusCode enrichmentStatus = mockStormCLIClientWrapper.getEnrichmentStatus();        if (enrichmentStatus != TopologyStatusCode.TOPOLOGY_NOT_FOUND) {            topologyStatusList.add(getTopologyStatus("enrichment"));        }        TopologyStatusCode batchIndexingStatus = mockStormCLIClientWrapper.getIndexingStatus(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME);        if (batchIndexingStatus != TopologyStatusCode.TOPOLOGY_NOT_FOUND) {            topologyStatusList.add(getTopologyStatus(MetronRestConstants.BATCH_INDEXING_TOPOLOGY_NAME));        }        TopologyStatusCode randomIndexingStatus = mockStormCLIClientWrapper.getIndexingStatus(MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME);        if (randomIndexingStatus != TopologyStatusCode.TOPOLOGY_NOT_FOUND) {            topologyStatusList.add(getTopologyStatus(MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME));        }        topologySummary.setTopologies(topologyStatusList.toArray(new TopologyStatus[topologyStatusList.size()]));        response = topologySummary;    } else if (url.startsWith(getStormUiProperty() + MetronRestConstants.TOPOLOGY_URL + "/")) {        String name = url.substring(url.lastIndexOf('/') + 1, url.length()).replaceFirst("-id", "");        response = getTopologyStatus(name);    } else if (url.startsWith("http://" + environment.getProperty(MetronRestConstants.STORM_UI_SPRING_PROPERTY) + MetronRestConstants.SUPERVISOR_SUMMARY_URL)) {        SupervisorSummary supervisorSummary = new SupervisorSummary();        List<SupervisorStatus> supervisorStatusList = new ArrayList<>();        SupervisorStatus status = new SupervisorStatus("sup1", "localhost", "1m 2s", 1, 1);        supervisorStatusList.add(status);        supervisorSummary.setSupervisors(supervisorStatusList.toArray(new SupervisorStatus[1]));        response = supervisorSummary;    }    return response;}
private TopologyStatus metron_f1908_0(String name)
{    TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setName(name);    topologyStatus.setId(name + "-id");    if ("enrichment".equals(name)) {        topologyStatus.setStatus(mockStormCLIClientWrapper.getEnrichmentStatus());    } else if (name.contains("indexing")) {        topologyStatus.setStatus(mockStormCLIClientWrapper.getIndexingStatus(name));    } else {        topologyStatus.setStatus(mockStormCLIClientWrapper.getParserStatus(name));    }    return topologyStatus;}
public Object metron_f1909_0(String url, Object request, Class responseType, Object... uriVariables) throws RestClientException
{    Map<String, String> result = new HashMap<>();    String[] urlParts = url.split("/");    String name = urlParts[urlParts.length - 2].replaceFirst("-id", "");    String action = urlParts[urlParts.length - 1];    int returnCode = 0;    if (action.equals("activate")) {        if (name.equals("enrichment")) {            returnCode = mockStormCLIClientWrapper.activateEnrichmentTopology();        } else if (name.contains("indexing")) {            returnCode = mockStormCLIClientWrapper.activateIndexingTopology(name);        } else {            returnCode = mockStormCLIClientWrapper.activateParserTopology(name);        }    } else if (action.equals("deactivate")) {        if (name.equals("enrichment")) {            returnCode = mockStormCLIClientWrapper.deactivateEnrichmentTopology();        } else if (name.contains("indexing")) {            returnCode = mockStormCLIClientWrapper.deactivateIndexingTopology(name);        } else {            returnCode = mockStormCLIClientWrapper.deactivateParserTopology(name);        }    }    if (returnCode == 0) {        result.put("status", "success");    } else {        result.put("status", "error");    }    return result;}
protected String metron_f1910_0()
{    String baseValue = environment.getProperty(MetronRestConstants.STORM_UI_SPRING_PROPERTY);    if (!(baseValue.contains("://"))) {        return "http://" + baseValue;    }    return baseValue;}
public void metron_f1911_0() throws Exception
{    kafkaService = mock(KafkaService.class);    environment = mock(Environment.class);    userSettingsClient = mock(UserSettingsClient.class);    alertsUIService = new AlertsUIServiceImpl(kafkaService, environment, userSettingsClient);        clock = new FakeClock();    clock.elapseSeconds(1000);    alertsUIService.setClock(clock);        Authentication authentication = Mockito.mock(Authentication.class);    UserDetails userDetails = Mockito.mock(UserDetails.class);    when(authentication.getPrincipal()).thenReturn(userDetails);    when(userDetails.getUsername()).thenReturn(user1);    SecurityContextHolder.getContext().setAuthentication(authentication);}
public void metron_f1912_0() throws Exception
{    final String field = "field";    final String value1 = "value1";    final String value2 = "value2";        final String escalationTopic = "escalation";    when(environment.getProperty(MetronRestConstants.KAFKA_TOPICS_ESCALATION_PROPERTY)).thenReturn(escalationTopic);        final Map<String, Object> alert1 = mapOf(field, value1);    String escalationMessage1 = escalationMessage(field, value1, user1, clock.currentTimeMillis());    final Map<String, Object> alert2 = mapOf(field, value2);    String escalationMessage2 = escalationMessage(field, value2, user1, clock.currentTimeMillis());        alertsUIService.escalateAlerts(Arrays.asList(alert1, alert2));    verify(kafkaService).produceMessage(escalationTopic, escalationMessage1);    verify(kafkaService).produceMessage(escalationTopic, escalationMessage2);    verifyZeroInteractions(kafkaService);}
public void metron_f1913_0() throws Exception
{    when(userSettingsClient.findOne(user1, AlertsUIServiceImpl.ALERT_USER_SETTING_TYPE)).thenReturn(Optional.of(user1AlertUserSettings));    AlertsUIUserSettings expectedAlertsUIUserSettings = new AlertsUIUserSettings();    expectedAlertsUIUserSettings.setTableColumns(Collections.singletonList("user1_field"));    assertEquals(expectedAlertsUIUserSettings, alertsUIService.getAlertsUIUserSettings().get());    verify(userSettingsClient, times(1)).findOne(user1, AlertsUIServiceImpl.ALERT_USER_SETTING_TYPE);    verifyNoMoreInteractions(userSettingsClient);}
public void metron_f1914_0() throws Exception
{    AlertsUIUserSettings alertsProfile1 = new AlertsUIUserSettings();    alertsProfile1.setUser(user1);    AlertsUIUserSettings alertsProfile2 = new AlertsUIUserSettings();    alertsProfile2.setUser(user1);    when(userSettingsClient.findAll(AlertsUIServiceImpl.ALERT_USER_SETTING_TYPE)).thenReturn(new HashMap<String, Optional<String>>() {        {            put(user1, Optional.of(user1AlertUserSettings));            put(user2, Optional.of(user2AlertUserSettings));        }    });    AlertsUIUserSettings expectedAlertsUIUserSettings1 = new AlertsUIUserSettings();    expectedAlertsUIUserSettings1.setTableColumns(Collections.singletonList("user1_field"));    AlertsUIUserSettings expectedAlertsUIUserSettings2 = new AlertsUIUserSettings();    expectedAlertsUIUserSettings2.setTableColumns(Collections.singletonList("user2_field"));    Map<String, AlertsUIUserSettings> actualAlertsProfiles = alertsUIService.findAllAlertsUIUserSettings();    assertEquals(2, actualAlertsProfiles.size());    assertEquals(expectedAlertsUIUserSettings1, actualAlertsProfiles.get(user1));    assertEquals(expectedAlertsUIUserSettings2, actualAlertsProfiles.get(user2));    verify(userSettingsClient, times(1)).findAll(AlertsUIServiceImpl.ALERT_USER_SETTING_TYPE);    verifyNoMoreInteractions(userSettingsClient);}
public void metron_f1915_0() throws Exception
{    AlertsUIUserSettings alertsUIUserSettings = new AlertsUIUserSettings();    alertsUIUserSettings.setTableColumns(Collections.singletonList("user1_field"));    alertsUIService.saveAlertsUIUserSettings(alertsUIUserSettings);    String expectedAlertUserSettings = _mapper.get().writeValueAsString(alertsUIUserSettings);    verify(userSettingsClient, times(1)).save(user1, AlertsUIServiceImpl.ALERT_USER_SETTING_TYPE, expectedAlertUserSettings);    verifyNoMoreInteractions(userSettingsClient);}
public void metron_f1916_0() throws Exception
{    assertTrue(alertsUIService.deleteAlertsUIUserSettings(user1));    doThrow(new IOException()).when(userSettingsClient).delete(user1, AlertsUIServiceImpl.ALERT_USER_SETTING_TYPE);    assertFalse(alertsUIService.deleteAlertsUIUserSettings(user1));    verify(userSettingsClient, times(2)).delete(user1, AlertsUIServiceImpl.ALERT_USER_SETTING_TYPE);    verifyNoMoreInteractions(userSettingsClient);}
private String metron_f1917_0(String field, String value, String user, Long timestamp)
{    return String.format("{\"%s\":\"%s\",\"%s\":\"%s\",\"%s\":%d}", field, value, MetronRestConstants.METRON_ESCALATION_USER_FIELD, user, MetronRestConstants.METRON_ESCALATION_TIMESTAMP_FIELD, timestamp);}
private Map<String, Object> metron_f1918_0(String key, Object value)
{    Map<String, Object> map = new HashMap<>();    map.put(key, value);    return map;}
public void metron_f1919_0()
{    MockitoAnnotations.initMocks(this);    cachedStormStatusService = new CachedStormStatusServiceImpl(stormService, 150, 30);}
public void metron_f1920_0()
{    SupervisorStatus supervisorStatus1 = new SupervisorStatus();    SupervisorStatus supervisorStatus2 = new SupervisorStatus();    SupervisorSummary supervisorSummary = new SupervisorSummary(new SupervisorStatus[] { supervisorStatus1, supervisorStatus2 });    when(stormService.getSupervisorSummary()).thenReturn(supervisorSummary);        for (int i = 0; i < 100; i++) {        cachedStormStatusService.getSupervisorSummary();    }    SupervisorSummary summary = cachedStormStatusService.getSupervisorSummary();    assertThat("Number of supervisors did not match.", summary.getSupervisors().length, CoreMatchers.equalTo(2));    verify(stormService, times(1)).getSupervisorSummary();    cachedStormStatusService.reset();    summary = cachedStormStatusService.getSupervisorSummary();    assertThat("Number of supervisors did not match.", summary.getSupervisors().length, CoreMatchers.equalTo(2));    verify(stormService, times(2)).getSupervisorSummary();}
public void metron_f1921_0()
{    TopologyStatus topologyStatus1 = new TopologyStatus();    TopologyStatus topologyStatus2 = new TopologyStatus();    TopologySummary topologySummary = new TopologySummary(new TopologyStatus[] { topologyStatus1, topologyStatus2 });    when(stormService.getTopologySummary()).thenReturn(topologySummary);        for (int i = 0; i < 100; i++) {        cachedStormStatusService.getTopologySummary();    }    TopologySummary summary = cachedStormStatusService.getTopologySummary();    assertThat("Number of topologies did not match.", summary.getTopologies().length, CoreMatchers.equalTo(2));    verify(stormService, times(1)).getTopologySummary();    cachedStormStatusService.reset();    summary = cachedStormStatusService.getTopologySummary();    assertThat("Number of topologies did not match.", summary.getTopologies().length, CoreMatchers.equalTo(2));    verify(stormService, times(2)).getTopologySummary();}
public void metron_f1922_0()
{    String topologyName1 = "topology-1";    String topologyName2 = "topology-2";    TopologyStatus topologyStatus1 = new TopologyStatus();    topologyStatus1.setName(topologyName1);    TopologyStatus topologyStatus2 = new TopologyStatus();    topologyStatus2.setName(topologyName2);    when(stormService.getTopologyStatus(topologyName1)).thenReturn(topologyStatus1);    when(stormService.getTopologyStatus(topologyName2)).thenReturn(topologyStatus2);        for (int i = 0; i < 100; i++) {        cachedStormStatusService.getTopologyStatus(topologyName1);        cachedStormStatusService.getTopologyStatus(topologyName2);    }    TopologyStatus status1 = cachedStormStatusService.getTopologyStatus(topologyName1);    TopologyStatus status2 = cachedStormStatusService.getTopologyStatus(topologyName2);    assertThat("Name did not match for topology 1.", status1.getName(), CoreMatchers.equalTo(topologyName1));    assertThat("Name did not match for topology 2.", status2.getName(), CoreMatchers.equalTo(topologyName2));    verify(stormService, times(1)).getTopologyStatus(topologyName1);    verify(stormService, times(1)).getTopologyStatus(topologyName2);    cachedStormStatusService.reset();    cachedStormStatusService.getTopologyStatus(topologyName1);    cachedStormStatusService.getTopologyStatus(topologyName2);    verify(stormService, times(2)).getTopologyStatus(topologyName1);    verify(stormService, times(2)).getTopologyStatus(topologyName2);}
public void metron_f1923_0()
{    TopologyStatus topologyStatus1 = new TopologyStatus();    TopologyStatus topologyStatus2 = new TopologyStatus();    List<TopologyStatus> allTopologyStatus = ImmutableList.of(topologyStatus1, topologyStatus2);    when(stormService.getAllTopologyStatus()).thenReturn(allTopologyStatus);        for (int i = 0; i < 100; i++) {        cachedStormStatusService.getAllTopologyStatus();    }    List<TopologyStatus> allStatus = cachedStormStatusService.getAllTopologyStatus();    assertThat("Number of topologies returned by all topology status check did not match.", allStatus.size(), CoreMatchers.equalTo(2));    verify(stormService, times(1)).getAllTopologyStatus();    cachedStormStatusService.reset();    cachedStormStatusService.getAllTopologyStatus();    verify(stormService, times(2)).getAllTopologyStatus();}
public void metron_f1924_0()
{    TopologyResponse topologyResponse = new TopologyResponse();    when(stormService.activateTopology(anyString())).thenReturn(topologyResponse);    when(stormService.deactivateTopology(anyString())).thenReturn(topologyResponse);    for (int i = 0; i < 100; i++) {        cachedStormStatusService.activateTopology("foo");        cachedStormStatusService.deactivateTopology("foo");    }    verify(stormService, times(100)).activateTopology(anyString());    verify(stormService, times(100)).deactivateTopology(anyString());}
public void metron_f1925_0() throws Exception
{    processBuilder = mock(ProcessBuilder.class);    environment = mock(Environment.class);    dockerStormCLIWrapper = new DockerStormCLIWrapper(environment);}
public void metron_f1926_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.environment()).thenReturn(new HashMap<>());    when(processBuilder.command()).thenReturn(new ArrayList<>());    Process process = mock(Process.class);    InputStream inputStream = new ByteArrayInputStream("export DOCKER_HOST=\"tcp://192.168.99.100:2376\"".getBytes(StandardCharsets.UTF_8));    when(processBuilder.start()).thenReturn(process);    when(process.getInputStream()).thenReturn(inputStream);    when(environment.getProperty("docker.compose.path")).thenReturn("/test");    when(environment.getProperty("metron.version")).thenReturn("1");    ProcessBuilder actualBuilder = dockerStormCLIWrapper.getProcessBuilder("oo", "ooo");    assertEquals(new HashMap<String, String>() {        {            put("METRON_VERSION", "1");            put("DOCKER_HOST", "tcp://192.168.99.100:2376");        }    }, actualBuilder.environment());    assertEquals(new ArrayList<>(), actualBuilder.command());    verify(process).waitFor();}
public void metron_f1927_0() throws Exception
{    curatorFramework = mock(CuratorFramework.class);    cache = mock(ConfigurationsCache.class);    globalConfigService = new GlobalConfigServiceImpl(curatorFramework, cache);}
public void metron_f1928_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.GLOBAL.getZookeeperRoot())).thenThrow(KeeperException.NoNodeException.class);    assertFalse(globalConfigService.delete());}
public void metron_f1929_0() throws Exception
{    exception.expect(RestException.class);    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.GLOBAL.getZookeeperRoot())).thenThrow(Exception.class);    assertFalse(globalConfigService.delete());}
public void metron_f1930_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.GLOBAL.getZookeeperRoot())).thenReturn(null);    assertTrue(globalConfigService.delete());    verify(curatorFramework).delete();}
public void metron_f1931_0() throws Exception
{    final String config = "{\"k\":\"v\"}";    final Map<String, Object> configMap = new HashMap<String, Object>() {        {            put("k", "v");        }    };    EnrichmentConfigurations configs = new EnrichmentConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(ConfigurationType.GLOBAL.getTypeName(), configMap);        }    };    when(cache.get(eq(EnrichmentConfigurations.class))).thenReturn(configs);    assertEquals(configMap, globalConfigService.get());}
public Map<String, Object> metron_f1932_0()
{    return ImmutableMap.of(ConfigurationType.GLOBAL.getTypeName(), configMap);}
public void metron_f1933_0() throws Exception
{    exception.expect(RestException.class);    GetDataBuilder getDataBuilder = mock(GetDataBuilder.class);    when(getDataBuilder.forPath(ConfigurationType.GLOBAL.getZookeeperRoot())).thenThrow(Exception.class);    when(curatorFramework.getData()).thenReturn(getDataBuilder);    globalConfigService.get();}
public void metron_f1934_0() throws Exception
{    exception.expect(RestException.class);    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.GLOBAL.getZookeeperRoot(), "{ }".getBytes(StandardCharsets.UTF_8))).thenThrow(Exception.class);    when(curatorFramework.setData()).thenReturn(setDataBuilder);    globalConfigService.save(new HashMap<>());}
public void metron_f1935_0() throws Exception
{    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.GLOBAL.getZookeeperRoot(), "{ }".getBytes(StandardCharsets.UTF_8))).thenReturn(new Stat());    when(curatorFramework.setData()).thenReturn(setDataBuilder);    assertEquals(new HashMap<>(), globalConfigService.save(new HashMap<>()));    verify(setDataBuilder).forPath(eq(ConfigurationType.GLOBAL.getZookeeperRoot()), eq("{ }".getBytes(StandardCharsets.UTF_8)));}
public void metron_f1936_0() throws Exception
{    environment = mock(Environment.class);    grok = mock(Grok.class);    hdfsService = new HdfsServiceImpl(new Configuration());    grokService = new GrokServiceImpl(environment, grok, hdfsService);}
public void metron_f1937_0() throws Exception
{    grokService.getCommonGrokPatterns();    verify(grok).getPatterns();}
public void metron_f1938_0() throws Exception
{    final Map<String, String> actual = new HashMap<String, String>() {        {            put("k", "v");            put("k1", "v1");        }    };    when(grok.getPatterns()).thenReturn(actual);    Map<String, String> expected = new HashMap<String, String>() {        {            put("k", "v");            put("k1", "v1");        }    };    assertEquals(expected, grokService.getCommonGrokPatterns());}
public void metron_f1939_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("Pattern label is required");    GrokValidation grokValidation = new GrokValidation();    grokValidation.setResults(new HashMap<>());    grokValidation.setSampleData("asdf asdf");    grokValidation.setStatement("LABEL %{WORD:word1} %{WORD:word2}");    grokService.validateGrokStatement(grokValidation);}
public void metron_f1940_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("Grok statement is required");    GrokValidation grokValidation = new GrokValidation();    grokValidation.setResults(new HashMap<>());    grokValidation.setSampleData("asdf asdf");    grokValidation.setPatternLabel("LABEL");    grokValidation.setStatement("");    grokService.validateGrokStatement(grokValidation);}
public void metron_f1941_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("Grok statement is required");    GrokValidation grokValidation = new GrokValidation();    grokValidation.setResults(new HashMap<>());    grokValidation.setSampleData("asdf asdf");    grokValidation.setPatternLabel("LABEL");    grokValidation.setStatement(null);    grokService.validateGrokStatement(grokValidation);}
public void metron_f1942_0() throws Exception
{    final GrokValidation grokValidation = new GrokValidation();    grokValidation.setResults(new HashMap<>());    grokValidation.setSampleData("asdf asdf");    grokValidation.setStatement("LABEL %{WORD:word1} %{WORD:word2}");    grokValidation.setPatternLabel("LABEL");    GrokValidation expected = new GrokValidation();    expected.setResults(new HashMap<String, Object>() {        {            put("word1", "asdf");            put("word2", "asdf");        }    });    expected.setSampleData("asdf asdf");    expected.setStatement("LABEL %{WORD:word1} %{WORD:word2}");    expected.setPatternLabel("LABEL");    GrokValidation actual = grokService.validateGrokStatement(grokValidation);    assertEquals(expected, actual);    assertEquals(expected.hashCode(), actual.hashCode());}
public void metron_f1943_0() throws Exception
{    final GrokValidation grokValidation = new GrokValidation();    grokValidation.setResults(new HashMap<>());    grokValidation.setSampleData("");    grokValidation.setPatternLabel("LABEL");    grokValidation.setStatement("LABEL %{WORD:word1} %{WORD:word2}");    GrokValidation expected = new GrokValidation();    expected.setResults(new HashMap<>());    expected.setSampleData("");    expected.setPatternLabel("LABEL");    expected.setStatement("LABEL %{WORD:word1} %{WORD:word2}");    assertEquals(expected, grokService.validateGrokStatement(grokValidation));}
public void metron_f1944_0() throws Exception
{    final GrokValidation grokValidation = new GrokValidation();    grokValidation.setResults(new HashMap<>());    grokValidation.setSampleData(null);    grokValidation.setStatement("LABEL %{WORD:word1} %{WORD:word2}");    grokValidation.setPatternLabel("LABEL");    GrokValidation expected = new GrokValidation();    expected.setResults(new HashMap<>());    expected.setSampleData(null);    expected.setStatement("LABEL %{WORD:word1} %{WORD:word2}");    expected.setPatternLabel("LABEL");    assertEquals(expected, grokService.validateGrokStatement(grokValidation));}
public void metron_f1945_0() throws Exception
{    exception.expect(RestException.class);    GrokValidation grokValidation = new GrokValidation();    grokValidation.setResults(new HashMap<>());    grokValidation.setSampleData(null);    grokValidation.setStatement("LABEL %{WORD:word1} %{WORD:word2");    grokService.validateGrokStatement(grokValidation);}
public void metron_f1946_0() throws Exception
{    new File("./target/user1").delete();    String statement = "grok statement";    Authentication authentication = mock(Authentication.class);    when(authentication.getName()).thenReturn("user1");    SecurityContextHolder.getContext().setAuthentication(authentication);    when(environment.getProperty(GROK_TEMP_PATH_SPRING_PROPERTY)).thenReturn("./target");    grokService.saveTemporary(statement, "squid");    File testRoot = new File("./target/user1");    assertEquals(statement, FileUtils.readFileToString(new File(testRoot, "squid"), StandardCharsets.UTF_8));    testRoot.delete();}
public void metron_f1947_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("A grokStatement must be provided");    grokService.saveTemporary(null, "squid");}
public void metron_f1948_0() throws Exception
{    String expected = FileUtils.readFileToString(new File("../../metron-platform/metron-parsing/metron-parsers/src/main/resources/patterns/squid"));    assertEquals(expected, grokService.getStatementFromClasspath("/patterns/squid"));}
public void metron_f1949_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("Could not find a statement at path /bad/path");    grokService.getStatementFromClasspath("/bad/path");}
public void metron_f1950_0() throws IOException
{    configuration = new Configuration();    hdfsService = new HdfsServiceImpl(configuration);    mockStatic(FileSystem.class);}
public void metron_f1951_0() throws Exception
{    exception.expect(RestException.class);    FileSystem fileSystem = mock(FileSystem.class);    when(FileSystem.get(configuration)).thenReturn(fileSystem);    when(fileSystem.listStatus(new Path(testDir))).thenThrow(new IOException());    hdfsService.list(new Path(testDir));}
public void metron_f1952_0() throws Exception
{    exception.expect(RestException.class);    FileSystem fileSystem = mock(FileSystem.class);    when(FileSystem.get(configuration)).thenReturn(fileSystem);    when(fileSystem.open(new Path(testDir))).thenThrow(new IOException());    hdfsService.read(new Path(testDir));}
public void metron_f1953_0() throws Exception
{    exception.expect(RestException.class);    FileSystem fileSystem = mock(FileSystem.class);    when(FileSystem.get(configuration)).thenReturn(fileSystem);    when(fileSystem.create(new Path(testDir), true)).thenThrow(new IOException());    hdfsService.write(new Path(testDir), "contents".getBytes(UTF_8), null, null, null);}
public void metron_f1954_0() throws Exception
{    exception.expect(RestException.class);    FileSystem fileSystem = mock(FileSystem.class);    when(FileSystem.get(configuration)).thenReturn(fileSystem);    hdfsService.write(new Path(testDir, "test"), "oops".getBytes(UTF_8), "foo", "r-x", "r--");}
public void metron_f1955_0() throws Exception
{    exception.expect(RestException.class);    FileSystem fileSystem = mock(FileSystem.class);    when(FileSystem.get(configuration)).thenReturn(fileSystem);    when(fileSystem.delete(new Path(testDir), false)).thenThrow(new IOException());    hdfsService.delete(new Path(testDir), false);}
public void metron_f1956_0() throws IOException
{    configuration = new Configuration();    hdfsService = new HdfsServiceImpl(configuration);    File file = new File(testDir);    if (!file.exists()) {        file.mkdirs();    }    FileUtils.cleanDirectory(file);}
public void metron_f1957_0() throws IOException
{    File file = new File(testDir);    FileUtils.cleanDirectory(file);}
public void metron_f1958_0() throws Exception
{    FileUtils.writeStringToFile(new File(testDir, "file1.txt"), "value1");    FileUtils.writeStringToFile(new File(testDir, "file2.txt"), "value2");    List<String> paths = hdfsService.list(new Path(testDir));    Collections.sort(paths);    assertEquals(2, paths.size());    assertEquals("file1.txt", paths.get(0));    assertEquals("file2.txt", paths.get(1));}
public void metron_f1959_0() throws Exception
{    String contents = "contents";    FileUtils.writeStringToFile(new File(testDir, "readTest.txt"), contents);    assertEquals("contents", hdfsService.read(new Path(testDir, "readTest.txt")));}
public void metron_f1960_0() throws Exception
{    String contents = "contents";    hdfsService.write(new Path(testDir, "writeTest.txt"), contents.getBytes(UTF_8), null, null, null);    assertEquals("contents", FileUtils.readFileToString(new File(testDir, "writeTest.txt")));}
public void metron_f1961_0() throws Exception
{    String contents = "contents";    Path thePath = new Path(testDir, "writeTest2.txt");    hdfsService.write(thePath, contents.getBytes(UTF_8), "rw-", "r-x", "r--");    assertEquals("contents", FileUtils.readFileToString(new File(testDir, "writeTest2.txt")));    assertEquals(FileSystem.get(configuration).listStatus(thePath)[0].getPermission().toShort(), new FsPermission(FsAction.READ_WRITE, FsAction.READ_EXECUTE, FsAction.READ).toShort());}
public void metron_f1962_0() throws Exception
{    String contents = "contents";    FileUtils.writeStringToFile(new File(testDir, "deleteTest.txt"), contents);    List<String> paths = hdfsService.list(new Path(testDir));    assertEquals(1, paths.size());    assertEquals("deleteTest.txt", paths.get(0));    hdfsService.delete(new Path(testDir, "deleteTest.txt"), false);    paths = hdfsService.list(new Path(testDir));    assertEquals(0, paths.size());}
public void metron_f1963_0() throws Exception
{    zkUtils = mock(ZkUtils.class);    kafkaConsumerFactory = mock(ConsumerFactory.class);    kafkaConsumer = mock(KafkaConsumer.class);    kafkaProducer = mock(KafkaProducer.class);    adminUtils = mock(AdminUtils$.class);    when(kafkaConsumerFactory.createConsumer()).thenReturn(kafkaConsumer);    kafkaService = new KafkaServiceImpl(zkUtils, kafkaConsumerFactory, kafkaProducer, adminUtils);}
public void metron_f1964_0() throws Exception
{    final Map<String, List<PartitionInfo>> topics = null;    when(kafkaConsumer.listTopics()).thenReturn(topics);    final Set<String> listedTopics = kafkaService.listTopics();    assertEquals(Sets.newHashSet(), listedTopics);    verifyZeroInteractions(zkUtils);    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer).close();    verifyNoMoreInteractions(kafkaConsumer, zkUtils, adminUtils);}
public void metron_f1965_0() throws Exception
{    final Map<String, List<PartitionInfo>> topics = new HashMap<>();    when(kafkaConsumer.listTopics()).thenReturn(topics);    final Set<String> listedTopics = kafkaService.listTopics();    assertEquals(Sets.newHashSet(), listedTopics);    verifyZeroInteractions(zkUtils);    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer).close();    verifyNoMoreInteractions(kafkaConsumer, zkUtils);}
public void metron_f1966_0() throws Exception
{    final Map<String, List<PartitionInfo>> topics = new HashMap<>();    topics.put("topic1", Lists.newArrayList());    topics.put("topic2", Lists.newArrayList());    topics.put("topic3", Lists.newArrayList());    when(kafkaConsumer.listTopics()).thenReturn(topics);    final Set<String> listedTopics = kafkaService.listTopics();    assertEquals(Sets.newHashSet("topic1", "topic2", "topic3"), listedTopics);    verifyZeroInteractions(zkUtils);    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer).close();    verifyNoMoreInteractions(kafkaConsumer, zkUtils);}
public void metron_f1967_0() throws Exception
{    final Map<String, List<PartitionInfo>> topics = new HashMap<>();    topics.put("topic1", Lists.newArrayList());    topics.put("topic2", Lists.newArrayList());    topics.put("topic3", Lists.newArrayList());    topics.put("__consumer_offsets", Lists.newArrayList());    when(kafkaConsumer.listTopics()).thenReturn(topics);    final Set<String> listedTopics = kafkaService.listTopics();    assertEquals(Sets.newHashSet("topic1", "topic2", "topic3"), listedTopics);    verifyZeroInteractions(zkUtils);    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer).close();    verifyNoMoreInteractions(kafkaConsumer, zkUtils);}
public void metron_f1968_0() throws Exception
{    when(kafkaConsumer.listTopics()).thenReturn(Maps.newHashMap());    assertFalse(kafkaService.deleteTopic("non_existent_topic"));    verifyZeroInteractions(zkUtils);    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer).close();    verifyNoMoreInteractions(kafkaConsumer, zkUtils);}
public void metron_f1969_0() throws Exception
{    final Map<String, List<PartitionInfo>> topics = new HashMap<>();    topics.put("non_existent_topic", Lists.newArrayList());    when(kafkaConsumer.listTopics()).thenReturn(topics);    assertTrue(kafkaService.deleteTopic("non_existent_topic"));    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer).close();    verify(adminUtils).deleteTopic(zkUtils, "non_existent_topic");    verifyNoMoreInteractions(kafkaConsumer);}
public void metron_f1970_0() throws Exception
{    final Map<String, List<PartitionInfo>> topics = null;    when(kafkaConsumer.listTopics()).thenReturn(topics);    assertFalse(kafkaService.deleteTopic("non_existent_topic"));    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer).close();    verifyNoMoreInteractions(kafkaConsumer);}
public void metron_f1971_0() throws Exception
{    final PartitionInfo partitionInfo = mock(PartitionInfo.class);    when(partitionInfo.replicas()).thenReturn(new Node[] { new Node(1, "host", 8080) });    final Map<String, List<PartitionInfo>> topics = new HashMap<>();    topics.put("t", Lists.newArrayList(partitionInfo));    topics.put("t1", Lists.newArrayList());    final KafkaTopic expected = new KafkaTopic();    expected.setName("t");    expected.setNumPartitions(1);    expected.setReplicationFactor(1);    when(kafkaConsumer.listTopics()).thenReturn(topics);    when(kafkaConsumer.partitionsFor("t")).thenReturn(Lists.newArrayList(partitionInfo));    KafkaTopic actual = kafkaService.getTopic("t");    assertEquals(expected, actual);    assertEquals(expected.hashCode(), actual.hashCode());}
public void metron_f1972_0() throws Exception
{    final Map<String, List<PartitionInfo>> topics = new HashMap<>();    topics.put("t1", Lists.newArrayList());    when(kafkaConsumer.listTopics()).thenReturn(topics);    when(kafkaConsumer.partitionsFor("t")).thenReturn(Lists.newArrayList());    assertEquals(null, kafkaService.getTopic("t"));    verify(kafkaConsumer).listTopics();    verify(kafkaConsumer, times(0)).partitionsFor("t");    verify(kafkaConsumer).close();    verifyZeroInteractions(zkUtils);    verifyNoMoreInteractions(kafkaConsumer);}
public void metron_f1973_0() throws Exception
{    exception.expect(RestException.class);    doThrow(AdminOperationException.class).when(adminUtils).createTopic(eq(zkUtils), eq("t"), eq(1), eq(2), eq(new Properties()), eq(RackAwareMode.Disabled$.MODULE$));    kafkaService.createTopic(VALID_KAFKA_TOPIC);}
public void metron_f1974_0() throws Exception
{    exception.expect(RestException.class);    final Map<String, List<PartitionInfo>> topics = new HashMap<>();    topics.put("1", new ArrayList<>());    when(kafkaConsumer.listTopics()).thenReturn(topics);    doThrow(AdminOperationException.class).when(adminUtils).createTopic(eq(zkUtils), eq("t"), eq(1), eq(2), eq(new Properties()), eq(RackAwareMode.Disabled$.MODULE$));    kafkaService.createTopic(VALID_KAFKA_TOPIC);}
public void metron_f1975_0() throws Exception
{    final String topicName = "t";    final Node host = new Node(1, "host", 8080);    final Node[] replicas = { host };    final List<PartitionInfo> partitionInfo = Lists.newArrayList(new PartitionInfo(topicName, 1, host, replicas, replicas));    final TopicPartition topicPartition = new TopicPartition(topicName, 1);    final List<TopicPartition> topicPartitions = Lists.newArrayList(topicPartition);    final Set<TopicPartition> topicPartitionsSet = Sets.newHashSet(topicPartitions);    final ConsumerRecords<String, String> records = new ConsumerRecords<>(new HashMap<TopicPartition, List<ConsumerRecord<String, String>>>() {        {            put(topicPartition, Lists.newArrayList(new ConsumerRecord<>(topicName, 1, 1, "k", "message")));        }    });    when(kafkaConsumer.listTopics()).thenReturn(new HashMap<String, List<PartitionInfo>>() {        {            put(topicName, Lists.newArrayList());        }    });    when(kafkaConsumer.partitionsFor(eq(topicName))).thenReturn(partitionInfo);    when(kafkaConsumer.assignment()).thenReturn(topicPartitionsSet);    when(kafkaConsumer.position(topicPartition)).thenReturn(1L);    when(kafkaConsumer.poll(100)).thenReturn(records);    assertEquals("message", kafkaService.getSampleMessage(topicName));    verify(kafkaConsumer).assign(eq(topicPartitions));    verify(kafkaConsumer).assignment();    verify(kafkaConsumer).poll(100);    verify(kafkaConsumer).unsubscribe();    verify(kafkaConsumer, times(2)).position(topicPartition);    verify(kafkaConsumer).seek(topicPartition, 0);    verifyZeroInteractions(zkUtils, adminUtils);}
public void metron_f1976_0() throws Exception
{    final String topicName = "t";    final String message = "{\"field\":\"value\"}";    kafkaService.produceMessage(topicName, message);    String expectedMessage = "{\"field\":\"value\"}";    verify(kafkaProducer).send(new ProducerRecord<>(topicName, expectedMessage));    verifyZeroInteractions(kafkaProducer);}
public void metron_f1977_0() throws Exception
{    when(kafkaConsumer.listTopics()).thenReturn(Maps.newHashMap());    assertFalse(kafkaService.addACLToCurrentUser("non_existent_topic"));}
public void metron_f1978_0() throws Exception
{    environment = mock(Environment.class);    configuration = new Configuration();    mockPcapJobSupplier = new MockPcapJobSupplier();    pcapToPdmlScriptWrapper = new PcapToPdmlScriptWrapper();    when(environment.getProperty(MetronRestConstants.PCAP_BASE_PATH_SPRING_PROPERTY)).thenReturn("/base/path");    when(environment.getProperty(MetronRestConstants.PCAP_BASE_INTERIM_RESULT_PATH_SPRING_PROPERTY)).thenReturn("/base/interim/result/path");    when(environment.getProperty(MetronRestConstants.PCAP_FINAL_OUTPUT_PATH_SPRING_PROPERTY)).thenReturn("/final/output/path");    when(environment.getProperty(MetronRestConstants.PCAP_PAGE_SIZE_SPRING_PROPERTY)).thenReturn("100");    when(environment.getProperty(MetronRestConstants.PCAP_FINALIZER_THREADPOOL_SIZE_SPRING_PROPERTY)).thenReturn("2C");    when(environment.getProperty(MetronRestConstants.PCAP_PDML_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/path/to/pdml/script");    when(environment.getProperty(MetronRestConstants.USER_JOB_LIMIT_SPRING_PROPERTY, Integer.class, 1)).thenReturn(1);}
public void metron_f1979_0() throws Exception
{    when(environment.containsProperty(MetronRestConstants.PCAP_YARN_QUEUE_SPRING_PROPERTY)).thenReturn(true);    when(environment.getProperty(MetronRestConstants.PCAP_YARN_QUEUE_SPRING_PROPERTY)).thenReturn("pcap");    FixedPcapRequest fixedPcapRequest = new FixedPcapRequest();    fixedPcapRequest.setBasePath("basePath");    fixedPcapRequest.setBaseInterimResultPath("baseOutputPath");    fixedPcapRequest.setFinalOutputPath("finalOutputPath");    fixedPcapRequest.setStartTimeMs(1L);    fixedPcapRequest.setEndTimeMs(2L);    fixedPcapRequest.setNumReducers(2);    fixedPcapRequest.setIpSrcAddr("ip_src_addr");    fixedPcapRequest.setIpDstAddr("ip_dst_addr");    fixedPcapRequest.setIpSrcPort(1000);    fixedPcapRequest.setIpDstPort(2000);    fixedPcapRequest.setProtocol("tcp");    fixedPcapRequest.setPacketFilter("filter");    fixedPcapRequest.setIncludeReverse(true);    MockPcapJob mockPcapJob = new MockPcapJob();    mockPcapJobSupplier.setMockPcapJob(mockPcapJob);    JobManager jobManager = new InMemoryJobManager<>();    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withDescription("description").withPercentComplete(0L).withState(JobStatus.State.RUNNING));    Map<String, String> expectedFields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "ip_src_addr");            put(Constants.Fields.DST_ADDR.getName(), "ip_dst_addr");            put(Constants.Fields.SRC_PORT.getName(), "1000");            put(Constants.Fields.DST_PORT.getName(), "2000");            put(Constants.Fields.PROTOCOL.getName(), "tcp");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "true");            put(PcapHelper.PacketFields.PACKET_FILTER.getName(), "filter");        }    };    PcapStatus expectedPcapStatus = new PcapStatus();    expectedPcapStatus.setJobId("jobId");    expectedPcapStatus.setJobStatus(JobStatus.State.RUNNING.name());    expectedPcapStatus.setDescription("description");    Assert.assertEquals(expectedPcapStatus, pcapService.submit("user", fixedPcapRequest));    Assert.assertEquals(expectedPcapStatus, pcapService.jobStatusToPcapStatus(jobManager.getJob("user", "jobId").getStatus()));    Assert.assertEquals("basePath", mockPcapJob.getBasePath());    Assert.assertEquals("baseOutputPath", mockPcapJob.getBaseInterrimResultPath());    Assert.assertEquals("finalOutputPath", mockPcapJob.getFinalOutputPath());    Assert.assertEquals(1000000, mockPcapJob.getStartTimeNs());    Assert.assertEquals(2000000, mockPcapJob.getEndTimeNs());    Assert.assertEquals(2, mockPcapJob.getNumReducers());    Assert.assertEquals(100, mockPcapJob.getRecPerFile());    Assert.assertEquals("pcap", mockPcapJob.getYarnQueue());    Assert.assertEquals("2C", mockPcapJob.getFinalizerThreadpoolSize());    Assert.assertTrue(mockPcapJob.getFilterImpl() instanceof FixedPcapFilter.Configurator);    Map<String, String> actualFixedFields = mockPcapJob.getFixedFields();    Assert.assertEquals("ip_src_addr", actualFixedFields.get(Constants.Fields.SRC_ADDR.getName()));    Assert.assertEquals("1000", actualFixedFields.get(Constants.Fields.SRC_PORT.getName()));    Assert.assertEquals("ip_dst_addr", actualFixedFields.get(Constants.Fields.DST_ADDR.getName()));    Assert.assertEquals("2000", actualFixedFields.get(Constants.Fields.DST_PORT.getName()));    Assert.assertEquals("true", actualFixedFields.get(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName()));    Assert.assertEquals("tcp", actualFixedFields.get(Constants.Fields.PROTOCOL.getName()));    Assert.assertEquals("filter", actualFixedFields.get(PcapHelper.PacketFields.PACKET_FILTER.getName()));}
public void metron_f1980_0() throws Exception
{    long beforeJobTime = System.currentTimeMillis();    FixedPcapRequest fixedPcapRequest = new FixedPcapRequest();    MockPcapJob mockPcapJob = new MockPcapJob();    mockPcapJobSupplier.setMockPcapJob(mockPcapJob);    JobManager jobManager = new InMemoryJobManager<>();    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withDescription("description").withPercentComplete(0L).withState(JobStatus.State.RUNNING));    PcapStatus expectedPcapStatus = new PcapStatus();    expectedPcapStatus.setJobId("jobId");    expectedPcapStatus.setJobStatus(JobStatus.State.RUNNING.name());    expectedPcapStatus.setDescription("description");    Assert.assertEquals(expectedPcapStatus, pcapService.submit("user", fixedPcapRequest));    Assert.assertEquals("/base/path", mockPcapJob.getBasePath());    Assert.assertEquals("/base/interim/result/path", mockPcapJob.getBaseInterrimResultPath());    Assert.assertEquals("/final/output/path", mockPcapJob.getFinalOutputPath());    Assert.assertEquals(0, mockPcapJob.getStartTimeNs());    Assert.assertTrue(beforeJobTime <= mockPcapJob.getEndTimeNs() / 1000000);    Assert.assertTrue(System.currentTimeMillis() >= mockPcapJob.getEndTimeNs() / 1000000);    Assert.assertEquals(10, mockPcapJob.getNumReducers());    Assert.assertEquals(100, mockPcapJob.getRecPerFile());    Assert.assertTrue(mockPcapJob.getFilterImpl() instanceof FixedPcapFilter.Configurator);    Assert.assertEquals(new HashMap<>(), mockPcapJob.getFixedFields());}
public void metron_f1981_0() throws Exception
{    QueryPcapRequest queryPcapRequest = new QueryPcapRequest();    queryPcapRequest.setBasePath("basePath");    queryPcapRequest.setBaseInterimResultPath("baseOutputPath");    queryPcapRequest.setFinalOutputPath("finalOutputPath");    queryPcapRequest.setStartTimeMs(1L);    queryPcapRequest.setEndTimeMs(2L);    queryPcapRequest.setNumReducers(2);    queryPcapRequest.setQuery("query");    MockPcapJob mockPcapJob = new MockPcapJob();    mockPcapJobSupplier.setMockPcapJob(mockPcapJob);    JobManager jobManager = new InMemoryJobManager<>();    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    mockPcapJob.setStatus(new JobStatus().withJobId("jobId").withDescription("description").withPercentComplete(0L).withState(JobStatus.State.RUNNING));    String expectedFields = "query";    PcapStatus expectedPcapStatus = new PcapStatus();    expectedPcapStatus.setJobId("jobId");    expectedPcapStatus.setJobStatus(JobStatus.State.RUNNING.name());    expectedPcapStatus.setDescription("description");    Assert.assertEquals(expectedPcapStatus, pcapService.submit("user", queryPcapRequest));    Assert.assertEquals(expectedPcapStatus, pcapService.jobStatusToPcapStatus(jobManager.getJob("user", "jobId").getStatus()));    Assert.assertEquals("basePath", mockPcapJob.getBasePath());    Assert.assertEquals("baseOutputPath", mockPcapJob.getBaseInterrimResultPath());    Assert.assertEquals("finalOutputPath", mockPcapJob.getFinalOutputPath());    Assert.assertEquals(1000000, mockPcapJob.getStartTimeNs());    Assert.assertEquals(2000000, mockPcapJob.getEndTimeNs());    Assert.assertEquals(2, mockPcapJob.getNumReducers());    Assert.assertEquals(100, mockPcapJob.getRecPerFile());    Assert.assertTrue(mockPcapJob.getFilterImpl() instanceof QueryPcapFilter.Configurator);    Map<String, String> actualFixedFields = mockPcapJob.getFixedFields();    Assert.assertEquals("query", mockPcapJob.getQuery());}
public void metron_f1982_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("Cannot submit job because a job is already running.  Please contact the administrator to cancel job(s) with id(s) jobId");    PcapStatus runningStatus1 = new PcapStatus();    runningStatus1.setJobStatus("RUNNING");    runningStatus1.setJobId("jobId1");    PcapStatus runningStatus2 = new PcapStatus();    runningStatus2.setJobStatus("RUNNING");    runningStatus2.setJobId("jobId2");    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, new InMemoryJobManager<>(), pcapToPdmlScriptWrapper));    doReturn(Arrays.asList(runningStatus1, runningStatus2)).when(pcapService).getJobStatus("user", JobStatus.State.RUNNING);    when(environment.getProperty(MetronRestConstants.USER_JOB_LIMIT_SPRING_PROPERTY, Integer.class, 1)).thenReturn(2);    pcapService.submit("user", new FixedPcapRequest());}
public void metron_f1983_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("some job exception");    FixedPcapRequest fixedPcapRequest = new FixedPcapRequest();    JobManager jobManager = mock(JobManager.class);    PcapJobSupplier pcapJobSupplier = new PcapJobSupplier();    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, pcapJobSupplier, jobManager, pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    when(jobManager.submit(pcapJobSupplier, "user")).thenThrow(new JobException("some job exception"));    pcapService.submit("user", fixedPcapRequest);}
public void metron_f1984_0() throws Exception
{    MockPcapJob mockPcapJob = mock(MockPcapJob.class);    JobManager jobManager = mock(JobManager.class);    JobStatus actualJobStatus = new JobStatus().withJobId("jobId").withState(JobStatus.State.SUCCEEDED).withDescription("description").withPercentComplete(100.0);    Pageable pageable = mock(Pageable.class);    when(pageable.getSize()).thenReturn(2);    when(mockPcapJob.getStatus()).thenReturn(actualJobStatus);    when(mockPcapJob.isDone()).thenReturn(true);    when(mockPcapJob.get()).thenReturn(pageable);    when(jobManager.getJob("user", "jobId")).thenReturn(mockPcapJob);    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper);    PcapStatus expectedPcapStatus = new PcapStatus();    expectedPcapStatus.setJobId("jobId");    expectedPcapStatus.setJobStatus(JobStatus.State.SUCCEEDED.name());    expectedPcapStatus.setDescription("description");    expectedPcapStatus.setPercentComplete(100.0);    expectedPcapStatus.setPageTotal(2);    Assert.assertEquals(expectedPcapStatus, pcapService.getJobStatus("user", "jobId"));}
public void metron_f1985_0() throws Exception
{    JobManager jobManager = new InMemoryJobManager();    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), jobManager, pcapToPdmlScriptWrapper);    Assert.assertNull(pcapService.getJobStatus("user", "jobId"));}
public void metron_f1986_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("some job exception");    JobManager jobManager = mock(JobManager.class);    when(jobManager.getJob("user", "jobId")).thenThrow(new JobException("some job exception"));    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), jobManager, pcapToPdmlScriptWrapper);    pcapService.getJobStatus("user", "jobId");}
public void metron_f1987_0() throws Exception
{    MockPcapJob mockPcapJob = mock(MockPcapJob.class);    JobManager jobManager = mock(JobManager.class);    Statusable<Path> runningJob = mock(Statusable.class);    JobStatus runningStatus = mock(JobStatus.class);    when(runningStatus.getJobId()).thenReturn("runningJob");    when(runningStatus.getState()).thenReturn(JobStatus.State.RUNNING);    when(runningJob.getStatus()).thenReturn(runningStatus);    Statusable<Path> failedJob = mock(Statusable.class);    when(failedJob.getStatus()).thenThrow(new JobException("job exception"));    Statusable<Path> succeededJob = mock(Statusable.class);    JobStatus succeededStatus = mock(JobStatus.class);    when(succeededStatus.getJobId()).thenReturn("succeededJob");    when(succeededStatus.getState()).thenReturn(JobStatus.State.SUCCEEDED);    when(succeededJob.isDone()).thenReturn(true);    when(succeededJob.getStatus()).thenReturn(succeededStatus);    Pageable<Path> succeededPageable = mock(Pageable.class);    when(succeededPageable.getSize()).thenReturn(5);    when(succeededJob.get()).thenReturn(succeededPageable);    when(jobManager.getJobs("user")).thenReturn(Arrays.asList(runningJob, failedJob, succeededJob));    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper);    PcapStatus expectedRunningPcapStatus = new PcapStatus();    expectedRunningPcapStatus.setJobId("runningJob");    expectedRunningPcapStatus.setJobStatus(JobStatus.State.RUNNING.name());    Assert.assertEquals(expectedRunningPcapStatus, pcapService.getJobStatus("user", JobStatus.State.RUNNING).get(0));    PcapStatus expectedFailedPcapStatus = new PcapStatus();    expectedFailedPcapStatus.setJobStatus(JobStatus.State.FAILED.name());    expectedFailedPcapStatus.setDescription("job exception");    Assert.assertEquals(expectedFailedPcapStatus, pcapService.getJobStatus("user", JobStatus.State.FAILED).get(0));    PcapStatus expectedSucceededPcapStatus = new PcapStatus();    expectedSucceededPcapStatus.setJobId("succeededJob");    expectedSucceededPcapStatus.setJobStatus(JobStatus.State.SUCCEEDED.name());    expectedSucceededPcapStatus.setPageTotal(5);    Assert.assertEquals(expectedSucceededPcapStatus, pcapService.getJobStatus("user", JobStatus.State.SUCCEEDED).get(0));}
public void metron_f1988_0() throws Exception
{    MockPcapJob mockPcapJob = mock(MockPcapJob.class);    JobManager jobManager = mock(JobManager.class);    JobStatus actualJobStatus = new JobStatus().withJobId("jobId").withState(JobStatus.State.KILLED).withDescription("description").withPercentComplete(100.0);    Pageable pageable = mock(Pageable.class);    when(pageable.getSize()).thenReturn(0);    when(mockPcapJob.getStatus()).thenReturn(actualJobStatus);    when(mockPcapJob.isDone()).thenReturn(true);    when(mockPcapJob.get()).thenReturn(pageable);    when(jobManager.getJob("user", "jobId")).thenReturn(mockPcapJob);    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper);    PcapStatus status = pcapService.killJob("user", "jobId");    verify(jobManager, times(1)).killJob("user", "jobId");    assertThat(status.getJobStatus(), CoreMatchers.equalTo(JobStatus.State.KILLED.toString()));}
public void metron_f1989_0() throws Exception
{    MockPcapJob mockPcapJob = mock(MockPcapJob.class);    JobManager jobManager = mock(JobManager.class);    doThrow(new JobNotFoundException("Not found test exception.")).when(jobManager).killJob("user", "jobId");    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper);    PcapStatus status = pcapService.killJob("user", "jobId");    verify(jobManager, times(1)).killJob("user", "jobId");    assertNull(status);}
public void metron_f1990_0() throws Exception
{    Path actualPath = new Path("/path");    MockPcapJob mockPcapJob = mock(MockPcapJob.class);    JobManager jobManager = mock(JobManager.class);    Pageable pageable = mock(Pageable.class);    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), jobManager, pcapToPdmlScriptWrapper);    when(pageable.getSize()).thenReturn(2);    when(mockPcapJob.isDone()).thenReturn(true);    when(mockPcapJob.get()).thenReturn(pageable);    when(pageable.getPage(0)).thenReturn(actualPath);    when(jobManager.getJob("user", "jobId")).thenReturn(mockPcapJob);    Assert.assertEquals("/path", pcapService.getPath("user", "jobId", 1).toUri().getPath());}
public void metron_f1991_0() throws Exception
{    MockPcapJob mockPcapJob = mock(MockPcapJob.class);    JobManager jobManager = mock(JobManager.class);    Pageable pageable = mock(Pageable.class);    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), jobManager, pcapToPdmlScriptWrapper);    when(pageable.getSize()).thenReturn(2);    when(mockPcapJob.isDone()).thenReturn(true);    when(mockPcapJob.get()).thenReturn(pageable);    when(jobManager.getJob("user", "jobId")).thenReturn(mockPcapJob);    Assert.assertNull(pcapService.getPath("user", "jobId", 0));    Assert.assertNull(pcapService.getPath("user", "jobId", 3));}
public void metron_f1992_0() throws Exception
{    Path path = new Path("./target");    PcapToPdmlScriptWrapper pcapToPdmlScriptWrapper = spy(new PcapToPdmlScriptWrapper());    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), new InMemoryJobManager<>(), pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    when(fileSystem.exists(path)).thenReturn(true);    doReturn(path).when(pcapService).getPath("user", "jobId", 1);    doReturn(new ByteArrayInputStream(pdmlXml.getBytes(StandardCharsets.UTF_8))).when(pcapToPdmlScriptWrapper).getRawInputStream(fileSystem, path);    ProcessBuilder pb = PowerMockito.mock(ProcessBuilder.class);    Process p = PowerMockito.mock(Process.class);    OutputStream outputStream = new ByteArrayOutputStream();    when(p.getOutputStream()).thenReturn(outputStream);    when(p.isAlive()).thenReturn(true);    when(p.getInputStream()).thenReturn(new ByteArrayInputStream(pdmlXml.getBytes(StandardCharsets.UTF_8)));    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(pb);    PowerMockito.when(pb.start()).thenReturn(p);    assertEquals(JSONUtils.INSTANCE.load(expectedPdml, Pdml.class), pcapService.getPdml("user", "jobId", 1));}
public void metron_f1993_0() throws Exception
{    Path path = new Path("/some/path");    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), new InMemoryJobManager<>(), pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    when(fileSystem.exists(path)).thenReturn(false);    doReturn(path).when(pcapService).getPath("user", "jobId", 1);    assertNull(pcapService.getPdml("user", "jobId", 1));}
public void metron_f1994_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("some exception");    Path path = new Path("./target");    PcapToPdmlScriptWrapper pcapToPdmlScriptWrapper = spy(new PcapToPdmlScriptWrapper());    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), new InMemoryJobManager<>(), pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    when(fileSystem.exists(path)).thenReturn(true);    doReturn(path).when(pcapService).getPath("user", "jobId", 1);    ProcessBuilder pb = PowerMockito.mock(ProcessBuilder.class);    doReturn(pb).when(pcapToPdmlScriptWrapper).getProcessBuilder("/path/to/pdml/script", "target");    PowerMockito.when(pb.start()).thenThrow(new IOException("some exception"));    pcapService.getPdml("user", "jobId", 1);}
public void metron_f1995_0() throws Exception
{    FSDataInputStream inputStream = mock(FSDataInputStream.class);    Path path = new Path("./target");    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), new InMemoryJobManager<>(), new PcapToPdmlScriptWrapper()));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    when(fileSystem.exists(path)).thenReturn(true);    doReturn(path).when(pcapService).getPath("user", "jobId", 1);    when(fileSystem.open(path)).thenReturn(inputStream);    Assert.assertEquals(inputStream, pcapService.getRawPcap("user", "jobId", 1));}
public void metron_f1996_0() throws Exception
{    Path path = new Path("/some/path");    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), new InMemoryJobManager<>(), pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    assertNull(pcapService.getRawPcap("user", "jobId", 1));}
public void metron_f1997_0() throws Exception
{    Path path = new Path("/some/path");    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), new InMemoryJobManager<>(), pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    when(fileSystem.exists(path)).thenReturn(false);    doReturn(path).when(pcapService).getPath("user", "jobId", 1);    assertNull(pcapService.getRawPcap("user", "jobId", 1));}
public void metron_f1998_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("some exception");    Path path = new Path("./target");    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), new InMemoryJobManager<>(), pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    when(fileSystem.exists(path)).thenReturn(true);    doReturn(path).when(pcapService).getPath("user", "jobId", 1);    when(fileSystem.open(path)).thenThrow(new IOException("some exception"));    pcapService.getRawPcap("user", "jobId", 1);}
public void metron_f1999_0() throws Exception
{    FixedPcapRequest fixedPcapRequest = new FixedPcapRequest();    fixedPcapRequest.setBasePath("basePath");    fixedPcapRequest.setBaseInterimResultPath("baseOutputPath");    fixedPcapRequest.setFinalOutputPath("finalOutputPath");    fixedPcapRequest.setStartTimeMs(1L);    fixedPcapRequest.setEndTimeMs(2L);    fixedPcapRequest.setNumReducers(2);    fixedPcapRequest.setIpSrcAddr("ip_src_addr");    fixedPcapRequest.setIpDstAddr("ip_dst_addr");    fixedPcapRequest.setIpSrcPort(1000);    fixedPcapRequest.setIpDstPort(2000);    fixedPcapRequest.setProtocol("tcp");    fixedPcapRequest.setPacketFilter("filter");    fixedPcapRequest.setIncludeReverse(true);    MockPcapJob mockPcapJob = new MockPcapJob();    mockPcapJobSupplier.setMockPcapJob(mockPcapJob);    JobManager jobManager = new InMemoryJobManager<>();    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    mockPcapJob.setStatus(new JobStatus().withJobId("jobId"));    pcapService.submit("user", fixedPcapRequest);    Map<String, Object> configuration = pcapService.getConfiguration("user", "jobId");    Assert.assertEquals("basePath", configuration.get(PcapOptions.BASE_PATH.getKey()));    Assert.assertEquals("finalOutputPath", configuration.get(PcapOptions.FINAL_OUTPUT_PATH.getKey()));    Assert.assertEquals(1L, configuration.get(PcapOptions.START_TIME_MS.getKey()));    Assert.assertEquals(2L, configuration.get(PcapOptions.END_TIME_MS.getKey()));    Assert.assertEquals(2, configuration.get(PcapOptions.NUM_REDUCERS.getKey()));    Assert.assertEquals("ip_src_addr", configuration.get(FixedPcapOptions.IP_SRC_ADDR.getKey()));    Assert.assertEquals("ip_dst_addr", configuration.get(FixedPcapOptions.IP_DST_ADDR.getKey()));    Assert.assertEquals(1000, configuration.get(FixedPcapOptions.IP_SRC_PORT.getKey()));    Assert.assertEquals(2000, configuration.get(FixedPcapOptions.IP_DST_PORT.getKey()));    Assert.assertEquals("tcp", configuration.get(FixedPcapOptions.PROTOCOL.getKey()));    Assert.assertEquals("filter", configuration.get(FixedPcapOptions.PACKET_FILTER.getKey()));    Assert.assertEquals(true, configuration.get(FixedPcapOptions.INCLUDE_REVERSE.getKey()));}
public void metron_f2000_0() throws Exception
{    QueryPcapRequest queryPcapRequest = new QueryPcapRequest();    queryPcapRequest.setBasePath("basePath");    queryPcapRequest.setBaseInterimResultPath("baseOutputPath");    queryPcapRequest.setFinalOutputPath("finalOutputPath");    queryPcapRequest.setStartTimeMs(1L);    queryPcapRequest.setEndTimeMs(2L);    queryPcapRequest.setNumReducers(2);    queryPcapRequest.setQuery("query");    MockPcapJob mockPcapJob = new MockPcapJob();    mockPcapJobSupplier.setMockPcapJob(mockPcapJob);    JobManager jobManager = new InMemoryJobManager<>();    PcapServiceImpl pcapService = spy(new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper));    FileSystem fileSystem = mock(FileSystem.class);    doReturn(fileSystem).when(pcapService).getFileSystem();    mockPcapJob.setStatus(new JobStatus().withJobId("jobId"));    pcapService.submit("user", queryPcapRequest);    Map<String, Object> configuration = pcapService.getConfiguration("user", "jobId");    Assert.assertEquals("basePath", configuration.get(PcapOptions.BASE_PATH.getKey()));    Assert.assertEquals("finalOutputPath", configuration.get(PcapOptions.FINAL_OUTPUT_PATH.getKey()));    Assert.assertEquals(1L, configuration.get(PcapOptions.START_TIME_MS.getKey()));    Assert.assertEquals(2L, configuration.get(PcapOptions.END_TIME_MS.getKey()));    Assert.assertEquals(2, configuration.get(PcapOptions.NUM_REDUCERS.getKey()));    Assert.assertEquals("query", configuration.get(QueryPcapOptions.QUERY.getKey()));}
public void metron_f2001_0() throws Exception
{    MockPcapJob mockPcapJob = mock(MockPcapJob.class);    JobManager jobManager = mock(JobManager.class);    doThrow(new JobNotFoundException("Not found test exception.")).when(jobManager).getJob("user", "jobId");    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, mockPcapJobSupplier, jobManager, pcapToPdmlScriptWrapper);    Map<String, Object> configuration = pcapService.getConfiguration("user", "jobId");    Assert.assertEquals(new HashMap<>(), configuration);}
public void metron_f2002_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("some job exception");    JobManager jobManager = mock(JobManager.class);    when(jobManager.getJob("user", "jobId")).thenThrow(new JobException("some job exception"));    PcapServiceImpl pcapService = new PcapServiceImpl(environment, configuration, new PcapJobSupplier(), jobManager, pcapToPdmlScriptWrapper);    pcapService.getConfiguration("user", "jobId");}
public void metron_f2003_0() throws Exception
{    dao = mock(IndexDao.class);    environment = mock(Environment.class);    sensorIndexingConfigService = mock(SensorIndexingConfigService.class);    globalConfigService = mock(GlobalConfigService.class);    alertsUIService = mock(AlertsUIService.class);    searchService = new SearchServiceImpl(dao, environment, sensorIndexingConfigService, globalConfigService, alertsUIService);}
public void metron_f2004_0() throws Exception
{    when(environment.getProperty(INDEX_WRITER_NAME)).thenReturn("elasticsearch");    when(sensorIndexingConfigService.getAllIndices("elasticsearch")).thenReturn(Arrays.asList("bro", "snort", "error"));    SearchRequest searchRequest = new SearchRequest();    searchService.search(searchRequest);    SearchRequest expectedSearchRequest = new SearchRequest();    expectedSearchRequest.setIndices(Arrays.asList("bro", "snort", "metaalert"));    verify(dao).search(eq(expectedSearchRequest));    verifyNoMoreInteractions(dao);}
public void metron_f2005_0() throws Exception
{    when(environment.getProperty(SEARCH_FACET_FIELDS_SPRING_PROPERTY, String.class, "")).thenReturn("");    SearchRequest searchRequest = new SearchRequest();    searchRequest.setIndices(Arrays.asList("bro", "snort", "metaalert"));    searchService.search(searchRequest);    SearchRequest expectedSearchRequest = new SearchRequest();    expectedSearchRequest.setIndices(Arrays.asList("bro", "snort", "metaalert"));    verify(dao).search(eq(expectedSearchRequest));}
public void metron_f2006_0() throws Exception
{    when(environment.getProperty(SEARCH_FACET_FIELDS_SPRING_PROPERTY, String.class, "")).thenReturn("ip_src_addr,ip_dst_addr");    when(alertsUIService.getAlertsUIUserSettings()).thenReturn(Optional.empty());    SearchRequest searchRequest = new SearchRequest();    searchRequest.setIndices(Arrays.asList("bro", "snort", "metaalert"));    searchRequest.setFacetFields(new ArrayList<>());    searchService.search(searchRequest);    SearchRequest expectedSearchRequest = new SearchRequest();    expectedSearchRequest.setIndices(Arrays.asList("bro", "snort", "metaalert"));    expectedSearchRequest.setFacetFields(Arrays.asList("source:type", "ip_src_addr", "ip_dst_addr"));    verify(dao).search(eq(expectedSearchRequest));}
public void metron_f2007_0() throws Exception
{    AlertsUIUserSettings alertsUIUserSettings = new AlertsUIUserSettings();    alertsUIUserSettings.setFacetFields(Arrays.asList("ip_src_addr", "ip_dst_addr"));    when(alertsUIService.getAlertsUIUserSettings()).thenReturn(Optional.of(alertsUIUserSettings));    SearchRequest searchRequest = new SearchRequest();    searchRequest.setIndices(Arrays.asList("bro", "snort", "metaalert"));    searchRequest.setFacetFields(new ArrayList<>());    searchService.search(searchRequest);    SearchRequest expectedSearchRequest = new SearchRequest();    expectedSearchRequest.setIndices(Arrays.asList("bro", "snort", "metaalert"));    expectedSearchRequest.setFacetFields(Arrays.asList("ip_src_addr", "ip_dst_addr"));    verify(dao).search(eq(expectedSearchRequest));}
public void metron_f2008_0() throws Exception
{    SearchRequest searchRequest = new SearchRequest();    searchRequest.setIndices(Arrays.asList("bro"));    searchRequest.setFacetFields(Arrays.asList("ip_src_addr"));    searchService.search(searchRequest);    SearchRequest expectedSearchRequest = new SearchRequest();    expectedSearchRequest.setIndices(Arrays.asList("bro"));    expectedSearchRequest.setFacetFields(Arrays.asList("ip_src_addr"));    verify(dao).search(eq(expectedSearchRequest));    verifyNoMoreInteractions(dao);}
public void metron_f2009_0() throws Exception
{    exception.expect(RestException.class);    when(dao.search(any(SearchRequest.class))).thenThrow(InvalidSearchException.class);    SearchRequest searchRequest = new SearchRequest();    searchRequest.setIndices(Arrays.asList("bro"));    searchRequest.setFacetFields(Arrays.asList("ip_src_addr"));    searchService.search(searchRequest);}
public void metron_f2010_0() throws Exception
{    when(environment.getProperty(INDEX_WRITER_NAME)).thenReturn("elasticsearch");    when(sensorIndexingConfigService.getAllIndices("elasticsearch")).thenReturn(Arrays.asList("bro", "snort", "error"));    searchService.getColumnMetadata(new ArrayList<>());    verify(dao).getColumnMetadata(eq(Arrays.asList("bro", "snort", "metaalert")));    verifyNoMoreInteractions(dao);}
public void metron_f2011_0() throws RestException
{    when(environment.getProperty(SEARCH_FACET_FIELDS_SPRING_PROPERTY, String.class, "")).thenReturn("ip_src_addr");    Map<String, Object> globalConfig = new HashMap<>();    globalConfig.put(SENSOR_TYPE_FIELD_PROPERTY, "source.type");    when(globalConfigService.get()).thenReturn(globalConfig);    when(alertsUIService.getAlertsUIUserSettings()).thenReturn(Optional.empty());    List<String> defaultFields = searchService.getDefaultFacetFields();    List<String> expectedFields = new ArrayList<>();    expectedFields.add("source.type");    expectedFields.add("ip_src_addr");    assertEquals(expectedFields, defaultFields);}
public void metron_f2012_0() throws RestException
{    when(environment.getProperty(SEARCH_FACET_FIELDS_SPRING_PROPERTY, String.class, "")).thenReturn("ip_src_addr");    Map<String, Object> globalConfig = new HashMap<>();    when(globalConfigService.get()).thenReturn(globalConfig);    when(alertsUIService.getAlertsUIUserSettings()).thenReturn(Optional.empty());    List<String> defaultFields = searchService.getDefaultFacetFields();    List<String> expectedFields = new ArrayList<>();    expectedFields.add("source:type");    expectedFields.add("ip_src_addr");    assertEquals(expectedFields, defaultFields);}
public void metron_f2013_0() throws Exception
{    objectMapper = mock(ObjectMapper.class);    curatorFramework = mock(CuratorFramework.class);    cache = mock(ConfigurationsCache.class);    hBaseClient = mock(HBaseClient.class);    sensorEnrichmentConfigService = new SensorEnrichmentConfigServiceImpl(objectMapper, curatorFramework, cache, hBaseClient);}
public void metron_f2014_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/bro")).thenThrow(KeeperException.NoNodeException.class);    assertFalse(sensorEnrichmentConfigService.delete("bro"));}
public void metron_f2015_0() throws Exception
{    exception.expect(RestException.class);    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/bro")).thenThrow(Exception.class);    assertFalse(sensorEnrichmentConfigService.delete("bro"));}
public void metron_f2016_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/bro")).thenReturn(null);    assertTrue(sensorEnrichmentConfigService.delete("bro"));    verify(curatorFramework).delete();}
public void metron_f2017_0() throws Exception
{    final SensorEnrichmentConfig sensorEnrichmentConfig = getTestSensorEnrichmentConfig();    EnrichmentConfigurations configs = new EnrichmentConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(EnrichmentConfigurations.getKey("bro"), sensorEnrichmentConfig);        }    };    when(cache.get(eq(EnrichmentConfigurations.class))).thenReturn(configs);        assertEquals(getTestSensorEnrichmentConfig(), sensorEnrichmentConfigService.findOne("bro"));        assertNull(sensorEnrichmentConfigService.findOne("blah"));}
public Map<String, Object> metron_f2018_0()
{    return ImmutableMap.of(EnrichmentConfigurations.getKey("bro"), sensorEnrichmentConfig);}
public void metron_f2019_0() throws Exception
{    EnrichmentConfigurations configs = new EnrichmentConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(EnrichmentConfigurations.getKey("bro"), new HashMap<>(), EnrichmentConfigurations.getKey("squid"), new HashMap<>());        }    };    when(cache.get(eq(EnrichmentConfigurations.class))).thenReturn(configs);    assertEquals(new ArrayList() {        {            add("bro");            add("squid");        }    }, sensorEnrichmentConfigService.getAllTypes());}
public Map<String, Object> metron_f2020_0()
{    return ImmutableMap.of(EnrichmentConfigurations.getKey("bro"), new HashMap<>(), EnrichmentConfigurations.getKey("squid"), new HashMap<>());}
public void metron_f2021_0() throws Exception
{    final SensorEnrichmentConfig sensorEnrichmentConfig = getTestSensorEnrichmentConfig();    EnrichmentConfigurations configs = new EnrichmentConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(EnrichmentConfigurations.getKey("bro"), sensorEnrichmentConfig);        }    };    when(cache.get(eq(EnrichmentConfigurations.class))).thenReturn(configs);    assertEquals(new HashMap() {        {            put("bro", sensorEnrichmentConfig);        }    }, sensorEnrichmentConfigService.getAll());}
public Map<String, Object> metron_f2022_0()
{    return ImmutableMap.of(EnrichmentConfigurations.getKey("bro"), sensorEnrichmentConfig);}
public void metron_f2023_0() throws Exception
{    exception.expect(RestException.class);    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/bro", broJson.getBytes(StandardCharsets.UTF_8))).thenThrow(Exception.class);    when(curatorFramework.setData()).thenReturn(setDataBuilder);    sensorEnrichmentConfigService.save("bro", new SensorEnrichmentConfig());}
public void metron_f2024_0() throws Exception
{    final SensorEnrichmentConfig sensorEnrichmentConfig = getTestSensorEnrichmentConfig();    when(objectMapper.writeValueAsString(sensorEnrichmentConfig)).thenReturn(broJson);    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/bro", broJson.getBytes(StandardCharsets.UTF_8))).thenReturn(new Stat());    when(curatorFramework.setData()).thenReturn(setDataBuilder);    assertEquals(sensorEnrichmentConfig, sensorEnrichmentConfigService.save("bro", sensorEnrichmentConfig));    verify(setDataBuilder).forPath(eq(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/bro"), eq(broJson.getBytes(StandardCharsets.UTF_8)));}
public void metron_f2025_0() throws Exception
{    when(hBaseClient.readRecords()).thenReturn(new ArrayList<String>() {        {            add("geo");            add("whois");            add("host");            add("a-new-one");        }    });    assertEquals(new ArrayList<String>() {        {            add("a-new-one");            add("geo");            add("host");            add("whois");        }    }, sensorEnrichmentConfigService.getAvailableEnrichments());}
public void metron_f2026_0() throws Exception
{    assertEquals(new ArrayList<String>() {        {            add("MAX");            add("MIN");            add("SUM");            add("MEAN");            add("POSITIVE_MEAN");        }    }, sensorEnrichmentConfigService.getAvailableThreatTriageAggregators());}
private SensorEnrichmentConfig metron_f2027_0()
{    SensorEnrichmentConfig sensorEnrichmentConfig = new SensorEnrichmentConfig();    EnrichmentConfig enrichmentConfig = new EnrichmentConfig();    enrichmentConfig.setFieldMap(new HashMap() {        {            put("geo", Arrays.asList("ip_dst_addr"));        }    });    sensorEnrichmentConfig.setEnrichment(enrichmentConfig);    ThreatIntelConfig threatIntelConfig = new ThreatIntelConfig();    threatIntelConfig.setFieldMap(new HashMap() {        {            put("hbaseThreatIntel", Arrays.asList("ip_src_addr"));        }    });    threatIntelConfig.setFieldToTypeMap(new HashMap() {        {            put("ip_src_addr", Arrays.asList("malicious_ip"));        }    });    sensorEnrichmentConfig.setThreatIntel(threatIntelConfig);    return sensorEnrichmentConfig;}
public void metron_f2028_0() throws Exception
{    objectMapper = mock(ObjectMapper.class);    curatorFramework = mock(CuratorFramework.class);    cache = mock(ConfigurationsCache.class);    sensorIndexingConfigService = new SensorIndexingConfigServiceImpl(objectMapper, curatorFramework, cache);}
public void metron_f2029_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.INDEXING.getZookeeperRoot() + "/bro")).thenThrow(KeeperException.NoNodeException.class);    assertFalse(sensorIndexingConfigService.delete("bro"));}
public void metron_f2030_0() throws Exception
{    exception.expect(RestException.class);    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.INDEXING.getZookeeperRoot() + "/bro")).thenThrow(Exception.class);    assertFalse(sensorIndexingConfigService.delete("bro"));}
public void metron_f2031_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.INDEXING.getZookeeperRoot() + "/bro")).thenReturn(null);    assertTrue(sensorIndexingConfigService.delete("bro"));    verify(curatorFramework).delete();}
public void metron_f2032_0() throws Exception
{    final Map<String, Object> sensorIndexingConfig = getTestSensorIndexingConfig();    IndexingConfigurations configs = new IndexingConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(IndexingConfigurations.getKey("bro"), sensorIndexingConfig);        }    };    when(cache.get(eq(IndexingConfigurations.class))).thenReturn(configs);        assertEquals(getTestSensorIndexingConfig(), sensorIndexingConfigService.findOne("bro"));        assertNull(sensorIndexingConfigService.findOne("blah"));}
public Map<String, Object> metron_f2033_0()
{    return ImmutableMap.of(IndexingConfigurations.getKey("bro"), sensorIndexingConfig);}
public void metron_f2034_0() throws RestException
{    ParserConfigurations parserConfiguration = mock(ParserConfigurations.class);    when(parserConfiguration.getTypes()).thenReturn(ImmutableList.of("bro", "snort"));    IndexingConfigurations indexingConfiguration = mock(IndexingConfigurations.class);    when(indexingConfiguration.getTypes()).thenReturn(Collections.emptyList());    when(indexingConfiguration.getIndex(eq("bro"), eq("elasticsearch"))).thenReturn(null);    when(indexingConfiguration.getIndex(eq("snort"), eq("elasticsearch"))).thenReturn(null);    when(indexingConfiguration.isEnabled(eq("snort"), eq("elasticsearch"))).thenReturn(true);    when(indexingConfiguration.isEnabled(eq("bro"), eq("elasticsearch"))).thenReturn(true);    when(cache.get(eq(ParserConfigurations.class))).thenReturn(parserConfiguration);    when(cache.get(eq(IndexingConfigurations.class))).thenReturn(indexingConfiguration);    List<String> indices = new ArrayList<String>();    Iterables.addAll(indices, sensorIndexingConfigService.getAllIndices("elasticsearch"));    Assert.assertEquals(2, indices.size());    Assert.assertTrue(indices.contains("bro"));    Assert.assertTrue(indices.contains("snort"));}
public void metron_f2035_0() throws RestException
{    ParserConfigurations parserConfiguration = mock(ParserConfigurations.class);    when(parserConfiguration.getTypes()).thenReturn(Collections.emptyList());    IndexingConfigurations indexingConfiguration = mock(IndexingConfigurations.class);        when(indexingConfiguration.getTypes()).thenReturn(ImmutableList.of("bro", "snort", "yaf"));    when(indexingConfiguration.getIndex(eq("bro"), eq("elasticsearch"))).thenReturn("renamed_bro");    when(indexingConfiguration.getIndex(eq("snort"), eq("elasticsearch"))).thenReturn(null);    when(indexingConfiguration.isEnabled(eq("snort"), eq("elasticsearch"))).thenReturn(true);    when(indexingConfiguration.isEnabled(eq("bro"), eq("elasticsearch"))).thenReturn(true);    when(indexingConfiguration.isEnabled(eq("yaf"), eq("elasticsearch"))).thenReturn(false);    when(cache.get(eq(ParserConfigurations.class))).thenReturn(parserConfiguration);    when(cache.get(eq(IndexingConfigurations.class))).thenReturn(indexingConfiguration);    List<String> indices = new ArrayList<String>();    Iterables.addAll(indices, sensorIndexingConfigService.getAllIndices("elasticsearch"));    Assert.assertEquals(2, indices.size());    Assert.assertTrue(indices.contains("renamed_bro"));    Assert.assertTrue(indices.contains("snort"));}
public void metron_f2036_0() throws RestException
{    ParserConfigurations parserConfiguration = mock(ParserConfigurations.class);    when(parserConfiguration.getTypes()).thenReturn(ImmutableList.of("bro", "yaf"));    IndexingConfigurations indexingConfiguration = mock(IndexingConfigurations.class);    when(indexingConfiguration.getTypes()).thenReturn(ImmutableList.of("bro", "snort", "squid"));    when(indexingConfiguration.getIndex(eq("bro"), eq("elasticsearch"))).thenReturn("renamed_bro");    when(indexingConfiguration.getIndex(eq("snort"), eq("elasticsearch"))).thenReturn("snort");    when(indexingConfiguration.getIndex(eq("yaf"), eq("elasticsearch"))).thenReturn(null);    when(indexingConfiguration.isEnabled(eq("snort"), eq("elasticsearch"))).thenReturn(true);    when(indexingConfiguration.isEnabled(eq("bro"), eq("elasticsearch"))).thenReturn(true);    when(indexingConfiguration.isEnabled(eq("yaf"), eq("elasticsearch"))).thenReturn(true);    when(indexingConfiguration.isEnabled(eq("squid"), eq("elasticsearch"))).thenReturn(false);    when(cache.get(eq(ParserConfigurations.class))).thenReturn(parserConfiguration);    when(cache.get(eq(IndexingConfigurations.class))).thenReturn(indexingConfiguration);    List<String> indices = new ArrayList<String>();    Iterables.addAll(indices, sensorIndexingConfigService.getAllIndices("elasticsearch"));    Assert.assertEquals(3, indices.size());    Assert.assertTrue(indices.contains("renamed_bro"));    Assert.assertTrue(indices.contains("snort"));    Assert.assertTrue(indices.contains("yaf"));}
public void metron_f2037_0() throws RestException
{    ParserConfigurations parserConfiguration = mock(ParserConfigurations.class);    when(parserConfiguration.getTypes()).thenReturn(Collections.emptyList());    IndexingConfigurations indexingConfiguration = mock(IndexingConfigurations.class);    when(indexingConfiguration.getTypes()).thenReturn(Collections.emptyList());    when(cache.get(eq(ParserConfigurations.class))).thenReturn(parserConfiguration);    when(cache.get(eq(IndexingConfigurations.class))).thenReturn(indexingConfiguration);    List<String> indices = new ArrayList<String>();    Iterables.addAll(indices, sensorIndexingConfigService.getAllIndices("elasticsearch"));    Assert.assertEquals(0, indices.size());}
public void metron_f2038_0() throws Exception
{    IndexingConfigurations configs = new IndexingConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(IndexingConfigurations.getKey("bro"), new HashMap<>(), IndexingConfigurations.getKey("squid"), new HashMap<>());        }    };    when(cache.get(eq(IndexingConfigurations.class))).thenReturn(configs);    assertEquals(new ArrayList() {        {            add("bro");            add("squid");        }    }, sensorIndexingConfigService.getAllTypes());}
public Map<String, Object> metron_f2039_0()
{    return ImmutableMap.of(IndexingConfigurations.getKey("bro"), new HashMap<>(), IndexingConfigurations.getKey("squid"), new HashMap<>());}
public void metron_f2040_0() throws Exception
{    final Map<String, Object> sensorIndexingConfig = getTestSensorIndexingConfig();    IndexingConfigurations configs = new IndexingConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(IndexingConfigurations.getKey("bro"), sensorIndexingConfig);        }    };    when(cache.get(eq(IndexingConfigurations.class))).thenReturn(configs);    assertEquals(new HashMap() {        {            put("bro", sensorIndexingConfig);        }    }, sensorIndexingConfigService.getAll());}
public Map<String, Object> metron_f2041_0()
{    return ImmutableMap.of(IndexingConfigurations.getKey("bro"), sensorIndexingConfig);}
public void metron_f2042_0() throws Exception
{    exception.expect(RestException.class);    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.INDEXING.getZookeeperRoot() + "/bro", broJson.getBytes(StandardCharsets.UTF_8))).thenThrow(Exception.class);    when(curatorFramework.setData()).thenReturn(setDataBuilder);    sensorIndexingConfigService.save("bro", new HashMap<>());}
public void metron_f2043_0() throws Exception
{    final Map<String, Object> sensorIndexingConfig = getTestSensorIndexingConfig();    when(objectMapper.writeValueAsString(sensorIndexingConfig)).thenReturn(broJson);    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.INDEXING.getZookeeperRoot() + "/bro", broJson.getBytes(StandardCharsets.UTF_8))).thenReturn(new Stat());    when(curatorFramework.setData()).thenReturn(setDataBuilder);    assertEquals(sensorIndexingConfig, sensorIndexingConfigService.save("bro", sensorIndexingConfig));    verify(setDataBuilder).forPath(eq(ConfigurationType.INDEXING.getZookeeperRoot() + "/bro"), eq(broJson.getBytes(StandardCharsets.UTF_8)));}
private Map<String, Object> metron_f2044_0()
{    Map<String, Object> sensorIndexingConfig = new HashMap<>();    sensorIndexingConfig.put("hdfs", new HashMap() {        {            put("index", "bro");            put("batchSize", 5);            put("enabled", true);        }    });    return sensorIndexingConfig;}
public void metron_f2045_0() throws Exception
{    objectMapper = mock(ObjectMapper.class);    curatorFramework = mock(CuratorFramework.class);    Environment environment = mock(Environment.class);    Authentication authentication = mock(Authentication.class);    when(authentication.getName()).thenReturn(user);    SecurityContextHolder.getContext().setAuthentication(authentication);    when(environment.getProperty(GROK_TEMP_PATH_SPRING_PROPERTY)).thenReturn("./target");    grokService = new GrokServiceImpl(environment, mock(Grok.class), new HdfsServiceImpl(new Configuration()));    cache = mock(ConfigurationsCache.class);    sensorParserConfigService = new SensorParserConfigServiceImpl(objectMapper, curatorFramework, grokService, cache);}
public void metron_f2046_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/bro")).thenThrow(KeeperException.NoNodeException.class);    assertFalse(sensorParserConfigService.delete("bro"));}
public void metron_f2047_0() throws Exception
{    exception.expect(RestException.class);    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/bro")).thenThrow(Exception.class);    assertFalse(sensorParserConfigService.delete("bro"));}
public void metron_f2048_0() throws Exception
{    DeleteBuilder builder = mock(DeleteBuilder.class);    when(curatorFramework.delete()).thenReturn(builder);    when(builder.forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/bro")).thenReturn(null);    assertTrue(sensorParserConfigService.delete("bro"));    verify(curatorFramework).delete();}
public void metron_f2049_0() throws Exception
{    final SensorParserConfig sensorParserConfig = getTestBroSensorParserConfig();    ParserConfigurations configs = new ParserConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(ParserConfigurations.getKey("bro"), sensorParserConfig);        }    };    when(cache.get(eq(ParserConfigurations.class))).thenReturn(configs);        assertEquals(getTestBroSensorParserConfig(), sensorParserConfigService.findOne("bro"));        assertNull(sensorParserConfigService.findOne("blah"));}
public Map<String, Object> metron_f2050_0()
{    return ImmutableMap.of(ParserConfigurations.getKey("bro"), sensorParserConfig);}
public void metron_f2051_0() throws Exception
{    ParserConfigurations configs = new ParserConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(ParserConfigurations.getKey("bro"), new HashMap<>(), ParserConfigurations.getKey("squid"), new HashMap<>());        }    };    when(cache.get(eq(ParserConfigurations.class))).thenReturn(configs);    assertEquals(new ArrayList() {        {            add("bro");            add("squid");        }    }, sensorParserConfigService.getAllTypes());}
public Map<String, Object> metron_f2052_0()
{    return ImmutableMap.of(ParserConfigurations.getKey("bro"), new HashMap<>(), ParserConfigurations.getKey("squid"), new HashMap<>());}
public void metron_f2053_0() throws Exception
{    final SensorParserConfig broSensorParserConfig = getTestBroSensorParserConfig();    final SensorParserConfig squidSensorParserConfig = getTestSquidSensorParserConfig();    ParserConfigurations configs = new ParserConfigurations() {        @Override        public Map<String, Object> getConfigurations() {            return ImmutableMap.of(ParserConfigurations.getKey("bro"), broSensorParserConfig, ParserConfigurations.getKey("squid"), squidSensorParserConfig);        }    };    when(cache.get(eq(ParserConfigurations.class))).thenReturn(configs);    assertEquals(new HashMap() {        {            put("bro", getTestBroSensorParserConfig());            put("squid", getTestSquidSensorParserConfig());        }    }, sensorParserConfigService.getAll());}
public Map<String, Object> metron_f2054_0()
{    return ImmutableMap.of(ParserConfigurations.getKey("bro"), broSensorParserConfig, ParserConfigurations.getKey("squid"), squidSensorParserConfig);}
public void metron_f2055_0() throws Exception
{    exception.expect(RestException.class);    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/bro", broJson.getBytes(StandardCharsets.UTF_8))).thenThrow(Exception.class);    when(curatorFramework.setData()).thenReturn(setDataBuilder);    final SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setSensorTopic("bro");    sensorParserConfigService.save("bro", sensorParserConfig);}
public void metron_f2056_0() throws Exception
{    final SensorParserConfig sensorParserConfig = getTestBroSensorParserConfig();    when(objectMapper.writeValueAsString(sensorParserConfig)).thenReturn(broJson);    SetDataBuilder setDataBuilder = mock(SetDataBuilder.class);    when(setDataBuilder.forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/bro", broJson.getBytes(StandardCharsets.UTF_8))).thenReturn(new Stat());    when(curatorFramework.setData()).thenReturn(setDataBuilder);    assertEquals(getTestBroSensorParserConfig(), sensorParserConfigService.save("bro", sensorParserConfig));    verify(setDataBuilder).forPath(eq(ConfigurationType.PARSER.getZookeeperRoot() + "/bro"), eq(broJson.getBytes(StandardCharsets.UTF_8)));}
public void metron_f2057_0() throws Exception
{    Map<String, String> availableParsers = sensorParserConfigService.reloadAvailableParsers();    assertTrue(availableParsers.size() > 0);    assertEquals("org.apache.metron.parsers.GrokParser", availableParsers.get("Grok"));    assertEquals("org.apache.metron.parsers.bro.BasicBroParser", availableParsers.get("Bro"));}
public void metron_f2058_0() throws Exception
{    final SensorParserConfig sensorParserConfig = getTestSquidSensorParserConfig();    String grokStatement = "SQUID_DELIMITED %{NUMBER:timestamp}[^0-9]*%{INT:elapsed} %{IP:ip_src_addr} %{WORD:action}/%{NUMBER:code} %{NUMBER:bytes} %{WORD:method} %{NOTSPACE:url}[^0-9]*(%{IP:ip_dst_addr})?";    String sampleData = "1461576382.642    161 127.0.0.1 TCP_MISS/200 103701 GET http://www.cnn.com/ - DIRECT/199.27.79.73 text/html";    ParseMessageRequest parseMessageRequest = new ParseMessageRequest();    parseMessageRequest.setSensorParserConfig(sensorParserConfig);    parseMessageRequest.setGrokStatement(grokStatement);    parseMessageRequest.setSampleData(sampleData);    File grokRoot = new File("./target", user);    grokRoot.mkdir();    File patternFile = new File(grokRoot, "squid");    Writer writer = new OutputStreamWriter(new FileOutputStream(patternFile), StandardCharsets.UTF_8);    writer.write(grokStatement);    writer.close();    assertEquals(new HashMap() {        {            put("elapsed", 161);            put("code", 200);            put("ip_dst_addr", "199.27.79.73");            put("ip_src_addr", "127.0.0.1");            put("action", "TCP_MISS");            put("bytes", 103701);            put("method", "GET");            put("url", "http://www.cnn.com/");            put("timestamp", 1461576382642L);            put("original_string", "1461576382.642    161 127.0.0.1 TCP_MISS/200 103701 GET http://www.cnn.com/ - DIRECT/199.27.79.73 text/html");        }    }, sensorParserConfigService.parseMessage(parseMessageRequest));}
public void metron_f2059_0() throws Exception
{    exception.expect(RestException.class);    ParseMessageRequest parseMessageRequest = new ParseMessageRequest();    sensorParserConfigService.parseMessage(parseMessageRequest);}
public void metron_f2060_0() throws Exception
{    exception.expect(RestException.class);    final SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setSensorTopic("squid");    ParseMessageRequest parseMessageRequest = new ParseMessageRequest();    parseMessageRequest.setSensorParserConfig(sensorParserConfig);    sensorParserConfigService.parseMessage(parseMessageRequest);}
public void metron_f2061_0() throws Exception
{    exception.expect(RestException.class);    final SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setSensorTopic("squid");    sensorParserConfig.setParserClassName("bad.class.package.BadClassName");    ParseMessageRequest parseMessageRequest = new ParseMessageRequest();    parseMessageRequest.setSensorParserConfig(sensorParserConfig);    sensorParserConfigService.parseMessage(parseMessageRequest);}
private SensorParserConfig metron_f2062_0()
{    SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setSensorTopic("bro");    sensorParserConfig.setParserClassName("org.apache.metron.parsers.bro.BasicBroParser");    return sensorParserConfig;}
private SensorParserConfig metron_f2063_0()
{    SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setSensorTopic("squid");    sensorParserConfig.setParserClassName("org.apache.metron.parsers.GrokParser");    sensorParserConfig.setParserConfig(new HashMap() {        {            put("grokPath", "/patterns/squid");            put("patternLabel", "SQUID_DELIMITED");            put("timestampField", "timestamp");        }    });    return sensorParserConfig;}
public void metron_f2064_0() throws Exception
{    cache = mock(ConfigurationsCache.class);    globalConfigService = mock(GlobalConfigService.class);    sensorParserConfigService = mock(SensorParserConfigService.class);    sensorParserGroupService = new SensorParserGroupServiceImpl(cache, globalConfigService, sensorParserConfigService);}
public void metron_f2065_0() throws Exception
{    when(cache.get(ParserConfigurations.class)).thenReturn(new ParserConfigurations());    when(sensorParserConfigService.findOne("bro")).thenReturn(new SensorParserConfig());    SensorParserGroup sensorParserGroup = new SensorParserGroup();    sensorParserGroup.setName("group1");    sensorParserGroup.setDescription("description 1");    sensorParserGroup.setSensors(Collections.singleton("bro"));    Map<String, Object> expectedGlobalConfig = new HashMap<>();    Collection<SensorParserGroup> expectedGroup = Collections.singleton(sensorParserGroup);    expectedGlobalConfig.put(PARSER_GROUPS_CONF, expectedGroup);    assertEquals(sensorParserGroup, sensorParserGroupService.save(sensorParserGroup));    verify(globalConfigService, times(1)).save(expectedGlobalConfig);    verifyNoMoreInteractions(globalConfigService);}
public void metron_f2066_0() throws Exception
{    SensorParserGroup oldGroup = new SensorParserGroup();    oldGroup.setName("oldGroup");    oldGroup.setDescription("old description");    oldGroup.setSensors(Collections.singleton("oldSensor"));    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    when(cache.get(ParserConfigurations.class)).thenReturn(new ParserConfigurations());    when(parserConfigurations.getSensorParserGroups()).thenReturn(new HashMap<String, SensorParserGroup>() {        {            put("newSensor", oldGroup);        }    });    when(sensorParserConfigService.findOne("newSensor")).thenReturn(new SensorParserConfig());    SensorParserGroup newGroup = new SensorParserGroup();    newGroup.setName("newGroup");    newGroup.setDescription("new description");    newGroup.setSensors(Collections.singleton("newSensor"));    Map<String, Object> expectedGlobalConfig = new HashMap<>();    Collection<SensorParserGroup> expectedGroup = Collections.singleton(newGroup);    expectedGlobalConfig.put(PARSER_GROUPS_CONF, expectedGroup);    assertEquals(newGroup, sensorParserGroupService.save(newGroup));    verify(globalConfigService, times(1)).save(expectedGlobalConfig);    verifyNoMoreInteractions(globalConfigService);}
public void metron_f2067_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("A parser group must contain sensors");    when(cache.get(ParserConfigurations.class)).thenReturn(new ParserConfigurations());    sensorParserGroupService.save(new SensorParserGroup());}
public void metron_f2068_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("Could not find config for sensor bro");    when(cache.get(ParserConfigurations.class)).thenReturn(new ParserConfigurations());    SensorParserGroup sensorParserGroup = new SensorParserGroup();    sensorParserGroup.setSensors(Collections.singleton("bro"));    sensorParserGroupService.save(sensorParserGroup);}
public void metron_f2069_0() throws Exception
{    exception.expect(RestException.class);    exception.expectMessage("Sensor bro is already in group existingGroup");    SensorParserGroup existingGroup = new SensorParserGroup();    existingGroup.setName("existingGroup");    existingGroup.setSensors(Collections.singleton("bro"));    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    when(parserConfigurations.getSensorParserGroups()).thenReturn(new HashMap<String, SensorParserGroup>() {        {            put("existingGroup", existingGroup);        }    });    when(cache.get(ParserConfigurations.class)).thenReturn(parserConfigurations);    when(sensorParserConfigService.findOne("bro")).thenReturn(new SensorParserConfig());    SensorParserGroup newGroup = new SensorParserGroup();    newGroup.setName("newGroup");    newGroup.setSensors(Collections.singleton("bro"));    sensorParserGroupService.save(newGroup);}
public void metron_f2070_0() throws Exception
{    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    SensorParserGroup group1 = new SensorParserGroup();    group1.setName("group1");    group1.setDescription("group1 description");    group1.setSensors(Collections.singleton("group1Sensor"));    SensorParserGroup group2 = new SensorParserGroup();    group2.setName("group2");    group2.setDescription("group2 description");    group2.setSensors(Collections.singleton("group2Sensor"));    when(parserConfigurations.getSensorParserGroups()).thenReturn(new HashMap<String, SensorParserGroup>() {        {            put("group1", group1);            put("group2", group2);        }    });    when(cache.get(ParserConfigurations.class)).thenReturn(parserConfigurations);    assertEquals(group2, sensorParserGroupService.findOne("group2"));}
public void metron_f2071_0() throws Exception
{    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    SensorParserGroup group1 = new SensorParserGroup();    group1.setName("group1");    group1.setDescription("group1 description");    group1.setSensors(Collections.singleton("group1Sensor"));    when(parserConfigurations.getSensorParserGroups()).thenReturn(new HashMap<String, SensorParserGroup>() {        {            put("group1", group1);        }    });    when(cache.get(ParserConfigurations.class)).thenReturn(parserConfigurations);    Map<String, Object> expectedGlobalConfig = new HashMap<>();    expectedGlobalConfig.put(PARSER_GROUPS_CONF, new HashSet<>());    assertEquals(true, sensorParserGroupService.delete("group1"));    assertEquals(false, sensorParserGroupService.delete("group2"));    verify(globalConfigService, times(1)).save(expectedGlobalConfig);    verifyNoMoreInteractions(globalConfigService);}
public void metron_f2072_0() throws Exception
{    curatorFramework = mock(CuratorFramework.class);    stellarService = new StellarServiceImpl(curatorFramework);}
public void metron_f2073_0()
{    List<String> rules = Arrays.asList("TO_LOWER(test)", "BAD_FUNCTION(test)");    Map<String, Boolean> results = stellarService.validateRules(rules);    assertEquals(2, results.size());    assertEquals(true, results.get("TO_LOWER(test)"));    assertEquals(false, results.get("BAD_FUNCTION(test)"));}
public void metron_f2074_0()
{    SensorParserConfig sensorParserConfig = new SensorParserConfig();    FieldTransformer fieldTransformater = new FieldTransformer();    fieldTransformater.setOutput("url_host");    fieldTransformater.setTransformation("STELLAR");    fieldTransformater.setConfig(new LinkedHashMap<String, Object>() {        {            put("url_host", "TO_LOWER(URL_TO_HOST(url))");        }    });    sensorParserConfig.setFieldTransformations(ImmutableList.of(fieldTransformater));    SensorParserContext sensorParserContext = new SensorParserContext();    sensorParserContext.setSensorParserConfig(sensorParserConfig);    sensorParserContext.setSampleData(new HashMap<String, Object>() {        {            put("url", "https://caseystella.com/blog");        }    });    Map<String, Object> results = stellarService.applyTransformations(sensorParserContext);    assertEquals(2, results.size());    assertEquals("https://caseystella.com/blog", results.get("url"));    assertEquals("caseystella.com", results.get("url_host"));}
public void metron_f2075_0()
{    assertTrue(stellarService.getTransformations().length > 0);}
public void metron_f2076_0()
{    assertTrue(stellarService.getStellarFunctions().size() > 0);}
public void metron_f2077_0()
{    assertEquals(1, stellarService.getSimpleStellarFunctions().stream().filter(stellarFunctionDescription -> stellarFunctionDescription.getName().equals("TO_LOWER")).count());}
public void metron_f2078_0() throws Exception
{    stormCLIClientWrapper = mock(StormCLIWrapper.class);    globalConfigService = mock(GlobalConfigService.class);    sensorParserConfigService = mock(SensorParserConfigService.class);    sensorParserGroupService = mock(SensorParserGroupService.class);    stormStatusService = mock(StormStatusService.class);    stormAdminService = new StormAdminServiceImpl(stormCLIClientWrapper, globalConfigService, sensorParserConfigService, sensorParserGroupService, stormStatusService);}
public void metron_f2079_0() throws Exception
{    when(stormCLIClientWrapper.startParserTopology("bro")).thenReturn(0);    when(globalConfigService.get()).thenReturn(new HashMap<String, Object>());    when(sensorParserConfigService.findOne("bro")).thenReturn(new SensorParserConfig());    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.STARTED.toString());    TopologyResponse actual = stormAdminService.startParserTopology("bro");    assertEquals(expected, actual);    assertEquals(expected.hashCode(), actual.hashCode());}
public void metron_f2080_0() throws Exception
{    SensorParserGroup group = new SensorParserGroup();    group.setName("group");    group.setSensors(new HashSet<String>() {        {            add("bro");            add("snort");        }    });    when(sensorParserGroupService.findOne("group")).thenReturn(group);    when(stormCLIClientWrapper.startParserTopology("bro,snort")).thenReturn(0);    when(globalConfigService.get()).thenReturn(new HashMap<String, Object>());    when(sensorParserConfigService.findOne("bro")).thenReturn(new SensorParserConfig());    when(sensorParserConfigService.findOne("snort")).thenReturn(new SensorParserConfig());    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.STARTED.toString());    TopologyResponse actual = stormAdminService.startParserTopology("group");    assertEquals(expected, actual);    assertEquals(expected.hashCode(), actual.hashCode());}
public void metron_f2081_0() throws Exception
{    when(globalConfigService.get()).thenReturn(null);    TopologyResponse expected = new TopologyResponse();    expected.setErrorMessage(TopologyStatusCode.GLOBAL_CONFIG_MISSING.toString());    assertEquals(expected, stormAdminService.startParserTopology("bro"));}
public void metron_f2082_0() throws Exception
{    when(globalConfigService.get()).thenReturn(new HashMap<String, Object>());    when(sensorParserConfigService.findOne("bro")).thenReturn(null);    TopologyResponse expected = new TopologyResponse();    expected.setErrorMessage(TopologyStatusCode.SENSOR_PARSER_CONFIG_MISSING.toString());    assertEquals(expected, stormAdminService.startParserTopology("bro"));}
public void metron_f2083_0() throws Exception
{    TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setName("bro");    when(stormCLIClientWrapper.stopParserTopology("bro", false)).thenReturn(1);    when(stormStatusService.getTopologyStatus("bro")).thenReturn(topologyStatus);    TopologyResponse expected = new TopologyResponse();    expected.setErrorMessage(TopologyStatusCode.STOP_ERROR.toString());    assertEquals(expected, stormAdminService.stopParserTopology("bro", false));}
public void metron_f2084_0() throws Exception
{    when(stormCLIClientWrapper.startEnrichmentTopology()).thenReturn(0);    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.STARTED.toString());    assertEquals(expected, stormAdminService.startEnrichmentTopology());}
public void metron_f2085_0() throws Exception
{    when(stormCLIClientWrapper.stopEnrichmentTopology(false)).thenReturn(0);    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.STOPPED.toString());    assertEquals(expected, stormAdminService.stopEnrichmentTopology(false));}
public void metron_f2086_0() throws Exception
{    when(stormCLIClientWrapper.startIndexingTopology("random_access_indexing_script_path")).thenReturn(0);    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.STARTED.toString());    assertEquals(expected, stormAdminService.startIndexingTopology("random_access_indexing_script_path"));}
public void metron_f2087_0() throws Exception
{    when(stormCLIClientWrapper.stopIndexingTopology("random_access_indexing", false)).thenReturn(0);    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.STOPPED.toString());    assertEquals(expected, stormAdminService.stopIndexingTopology("random_access_indexing", false));}
public void metron_f2088_0() throws Exception
{    final Map<String, String> status = new HashMap() {        {            put("status", "statusValue");        }    };    when(stormCLIClientWrapper.getStormClientStatus()).thenReturn(status);    assertEquals(new HashMap() {        {            put("status", "statusValue");        }    }, stormAdminService.getStormClientStatus());}
public void metron_f2089_0() throws Exception
{    processBuilder = mock(ProcessBuilder.class);    environment = mock(Environment.class);    process = mock(Process.class);    stormCLIWrapper = new StormCLIWrapper();    stormCLIWrapper.setEnvironment(environment);}
public void metron_f2090_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.PARSER_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_parser");    when(environment.getProperty(MetronRestConstants.KAFKA_BROKER_URL_SPRING_PROPERTY)).thenReturn("kafka_broker_url");    when(environment.getProperty(MetronRestConstants.ZK_URL_SPRING_PROPERTY)).thenReturn("zookeeper_url");    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    when(environment.getProperty(MetronRestConstants.KAFKA_SECURITY_PROTOCOL_SPRING_PROPERTY)).thenReturn("kafka_security_protocol");    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.startParserTopology("bro"));    verify(process).waitFor();    verifyNew(ProcessBuilder.class).withArguments("/start_parser", "-s", "bro", "-z", "zookeeper_url", "-k", "kafka_broker_url", "-ksp", "kafka_security_protocol");}
public void metron_f2091_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.PARSER_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_parser");    when(environment.getProperty(MetronRestConstants.KAFKA_BROKER_URL_SPRING_PROPERTY)).thenReturn("kafka_broker_url");    when(environment.getProperty(MetronRestConstants.ZK_URL_SPRING_PROPERTY)).thenReturn("zookeeper_url");    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(true);    when(environment.getProperty(MetronRestConstants.KAFKA_SECURITY_PROTOCOL_SPRING_PROPERTY)).thenReturn("kafka_security_protocol");    when(environment.getProperty(MetronRestConstants.PARSER_TOPOLOGY_OPTIONS_SPRING_PROPERTY)).thenReturn("parser_topology_options");    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.startParserTopology("bro"));    verify(process, times(2)).waitFor();    verifyNew(ProcessBuilder.class).withArguments("/start_parser", "-s", "bro", "-z", "zookeeper_url", "-k", "kafka_broker_url", "-ksp", "kafka_security_protocol", "-e", "parser_topology_options");}
public void metron_f2092_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.stopParserTopology("bro", false));    verify(process).waitFor();    verifyNew(ProcessBuilder.class).withArguments("storm", "kill", "bro");}
public void metron_f2093_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.stopParserTopology("bro", true));    verify(process).waitFor();    verifyNew(ProcessBuilder.class).withArguments("storm", "kill", "bro", "-w", "0");}
public void metron_f2094_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.ENRICHMENT_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_enrichment");    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.startEnrichmentTopology());    verify(process).waitFor();    verifyNew(ProcessBuilder.class).withArguments("/start_enrichment");}
public void metron_f2095_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.stopEnrichmentTopology(false));    verify(process).waitFor();    verifyNew(ProcessBuilder.class).withArguments("storm", "kill", MetronRestConstants.ENRICHMENT_TOPOLOGY_NAME);}
public void metron_f2096_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.RANDOM_ACCESS_INDEXING_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_indexing");    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.startIndexingTopology(MetronRestConstants.RANDOM_ACCESS_INDEXING_SCRIPT_PATH_SPRING_PROPERTY));    verify(process).waitFor();    verifyNew(ProcessBuilder.class).withArguments("/start_indexing");}
public void metron_f2097_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(false);    when(process.exitValue()).thenReturn(0);    assertEquals(0, stormCLIWrapper.stopIndexingTopology("random_access_indexing", false));    verify(process).waitFor();    verifyNew(ProcessBuilder.class).withArguments("storm", "kill", MetronRestConstants.RANDOM_ACCESS_INDEXING_TOPOLOGY_NAME);}
public void metron_f2098_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    Process process = mock(Process.class);    InputStream inputStream = new ByteArrayInputStream("\nStorm 1.1".getBytes(UTF_8));    when(processBuilder.start()).thenReturn(process);    when(process.getInputStream()).thenReturn(inputStream);    when(environment.getProperty(MetronRestConstants.PARSER_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_parser");    when(environment.getProperty(MetronRestConstants.ENRICHMENT_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_enrichment");    when(environment.getProperty(MetronRestConstants.RANDOM_ACCESS_INDEXING_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_elasticsearch");    when(environment.getProperty(MetronRestConstants.BATCH_INDEXING_SCRIPT_PATH_SPRING_PROPERTY)).thenReturn("/start_hdfs");    Map<String, String> actual = stormCLIWrapper.getStormClientStatus();    assertEquals(new HashMap<String, String>() {        {            put("randomAccessIndexingScriptPath", "/start_elasticsearch");            put("enrichmentScriptPath", "/start_enrichment");            put("stormClientVersionInstalled", "1.1");            put("parserScriptPath", "/start_parser");            put("batchIndexingScriptPath", "/start_hdfs");        }    }, actual);    verifyNew(ProcessBuilder.class).withArguments("storm", "version");}
public void metron_f2099_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    Process process = mock(Process.class);    InputStream inputStream = new ByteArrayInputStream("".getBytes(UTF_8));    when(processBuilder.start()).thenReturn(process);    when(process.getInputStream()).thenReturn(inputStream);    assertEquals("Storm client is not installed", stormCLIWrapper.stormClientVersionInstalled());}
public void metron_f2100_0() throws Exception
{    exception.expect(RestException.class);    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenThrow(new IOException());    stormCLIWrapper.runCommand(new String[] { "storm", "kill" });}
public void metron_f2101_0() throws Exception
{    exception.expect(RestException.class);    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenThrow(new IOException());    stormCLIWrapper.stormClientVersionInstalled();}
public void metron_f2102_0() throws Exception
{    whenNew(ProcessBuilder.class).withParameterTypes(String[].class).withArguments(anyVararg()).thenReturn(processBuilder);    when(processBuilder.start()).thenReturn(process);    when(environment.getProperty(MetronRestConstants.KERBEROS_ENABLED_SPRING_PROPERTY, Boolean.class, false)).thenReturn(true);    when(environment.getProperty(MetronRestConstants.KERBEROS_KEYTAB_SPRING_PROPERTY)).thenReturn("metron keytabLocation");    when(environment.getProperty(MetronRestConstants.KERBEROS_PRINCIPLE_SPRING_PROPERTY)).thenReturn("metron principal");    when(process.exitValue()).thenReturn(0);    stormCLIWrapper.kinit();    verify(process, times(1)).waitFor();    verifyNew(ProcessBuilder.class).withArguments("kinit", "-kt", "metron keytabLocation", "metron principal");}
public void metron_f2103_0() throws Exception
{    environment = mock(Environment.class);    restTemplate = mock(RestTemplate.class);    sensorParserGroupService = mock(SensorParserGroupService.class);    stormStatusService = new StormStatusServiceImpl(environment, restTemplate, sensorParserGroupService);}
public void metron_f2104_0()
{    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    StormStatusServiceImpl serviceImpl = (StormStatusServiceImpl) stormStatusService;    assertEquals(HTTP_STORM_UI, serviceImpl.getStormUiProperty());}
public void metron_f2105_0()
{    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTPS_STORM_UI);    StormStatusServiceImpl serviceImpl = (StormStatusServiceImpl) stormStatusService;    assertEquals(HTTPS_STORM_UI, serviceImpl.getStormUiProperty());}
public void metron_f2106_0()
{    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(NO_PROTOCOL_STORM_UI);    StormStatusServiceImpl serviceImpl = (StormStatusServiceImpl) stormStatusService;    assertEquals(HTTP_STORM_UI, serviceImpl.getStormUiProperty());}
public void metron_f2107_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setStatus(TopologyStatusCode.STARTED);    topologyStatus.setName("bro");    topologyStatus.setId("bro_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    TopologyStatus expectedStatus = new TopologyStatus();    expectedStatus.setStatus(TopologyStatusCode.STARTED);    expectedStatus.setName("bro");    expectedStatus.setId("bro_id");    TopologySummary expected = new TopologySummary();    expected.setTopologies(new TopologyStatus[] { expectedStatus });    TopologySummary actual = stormStatusService.getTopologySummary();    assertEquals(expected, actual);    assertEquals(expected.hashCode(), actual.hashCode());}
public void metron_f2108_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setStatus(TopologyStatusCode.STARTED);    topologyStatus.setName("bro");    topologyStatus.setId("bro_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_URL + "/bro_id", TopologyStatus.class)).thenReturn(topologyStatus);    TopologyStatus expected = new TopologyStatus();    expected.setStatus(TopologyStatusCode.STARTED);    expected.setName("bro");    expected.setId("bro_id");    TopologyStatus actual = stormStatusService.getTopologyStatus("bro");    assertEquals(expected, actual);    assertEquals(expected.hashCode(), actual.hashCode());}
public void metron_f2109_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setStatus(TopologyStatusCode.STARTED);    topologyStatus.setName("bro__snort");    topologyStatus.setId("bro_snort_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    SensorParserGroup group = new SensorParserGroup();    group.setName("group");    group.setSensors(new HashSet<String>() {        {            add("bro");            add("snort");        }    });    when(sensorParserGroupService.findOne("group")).thenReturn(group);    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_URL + "/bro_snort_id", TopologyStatus.class)).thenReturn(topologyStatus);    TopologyStatus expected = new TopologyStatus();    expected.setStatus(TopologyStatusCode.STARTED);    expected.setName("bro__snort");    expected.setId("bro_snort_id");    TopologyStatus actual = stormStatusService.getTopologyStatus("group");    assertEquals(expected, actual);    assertEquals(expected.hashCode(), actual.hashCode());}
public void metron_f2110_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setStatus(TopologyStatusCode.STARTED);    topologyStatus.setName("bro");    topologyStatus.setId("bro_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_URL + "/bro_id", TopologyStatus.class)).thenReturn(topologyStatus);    TopologyStatus expected = new TopologyStatus();    expected.setStatus(TopologyStatusCode.STARTED);    expected.setName("bro");    expected.setId("bro_id");    assertEquals(new ArrayList() {        {            add(expected);        }    }, stormStatusService.getAllTopologyStatus());}
public void metron_f2111_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setName("bro");    topologyStatus.setId("bro_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    when(restTemplate.postForObject(HTTP_STORM_UI + TOPOLOGY_URL + "/bro_id/activate", null, Map.class)).thenReturn(new HashMap() {        {            put("status", "success");        }    });    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.ACTIVE.toString());    assertEquals(expected, stormStatusService.activateTopology("bro"));}
public void metron_f2112_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setName("bro");    topologyStatus.setId("bro_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    when(restTemplate.postForObject(HTTP_STORM_UI + TOPOLOGY_URL + "/bro_id/activate", null, Map.class)).thenReturn(new HashMap() {        {            put("status", "error message");        }    });    TopologyResponse expected = new TopologyResponse();    expected.setErrorMessage("error message");    assertEquals(expected, stormStatusService.activateTopology("bro"));}
public void metron_f2113_0() throws Exception
{    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(new TopologySummary());    TopologyResponse expected = new TopologyResponse();    expected.setErrorMessage(TopologyStatusCode.TOPOLOGY_NOT_FOUND.toString());    assertEquals(expected, stormStatusService.activateTopology("bro"));}
public void metron_f2114_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setName("bro");    topologyStatus.setId("bro_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    when(restTemplate.postForObject(HTTP_STORM_UI + TOPOLOGY_URL + "/bro_id/deactivate", null, Map.class)).thenReturn(new HashMap() {        {            put("status", "success");        }    });    TopologyResponse expected = new TopologyResponse();    expected.setSuccessMessage(TopologyStatusCode.INACTIVE.toString());    assertEquals(expected, stormStatusService.deactivateTopology("bro"));}
public void metron_f2115_0() throws Exception
{    final TopologyStatus topologyStatus = new TopologyStatus();    topologyStatus.setName("bro");    topologyStatus.setId("bro_id");    final TopologySummary topologySummary = new TopologySummary();    topologySummary.setTopologies(new TopologyStatus[] { topologyStatus });    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(topologySummary);    when(restTemplate.postForObject(HTTP_STORM_UI + TOPOLOGY_URL + "/bro_id/deactivate", null, Map.class)).thenReturn(new HashMap() {        {            put("status", "error message");        }    });    TopologyResponse expected = new TopologyResponse();    expected.setErrorMessage("error message");    assertEquals(expected, stormStatusService.deactivateTopology("bro"));}
public void metron_f2116_0() throws Exception
{    when(environment.getProperty(STORM_UI_SPRING_PROPERTY)).thenReturn(HTTP_STORM_UI);    when(restTemplate.getForObject(HTTP_STORM_UI + TOPOLOGY_SUMMARY_URL, TopologySummary.class)).thenReturn(new TopologySummary());    TopologyResponse expected = new TopologyResponse();    expected.setErrorMessage(TopologyStatusCode.TOPOLOGY_NOT_FOUND.toString());    assertEquals(expected, stormStatusService.deactivateTopology("bro"));}
public void metron_f2117_0() throws Exception
{    userSettingsTable = mock(Table.class);    globalConfigSupplier = () -> new HashMap<String, Object>() {        {            put(USER_SETTINGS_HBASE_CF, "cf");        }    };}
public void metron_f2118_0() throws Exception
{    Result result = mock(Result.class);    when(result.getValue(cf, Bytes.toBytes("type"))).thenReturn("userSettings1String".getBytes(StandardCharsets.UTF_8));    Get get = new Get("user1".getBytes(StandardCharsets.UTF_8));    get.addFamily(cf);    when(userSettingsTable.get(get)).thenReturn(result);    UserSettingsClient userSettingsClient = new UserSettingsClient(userSettingsTable, cf);    assertEquals("userSettings1String", userSettingsClient.findOne("user1", "type").get());    assertFalse(userSettingsClient.findOne("missingUser", "type").isPresent());}
public void metron_f2119_0() throws Exception
{    ResultScanner resultScanner = mock(ResultScanner.class);    Result result1 = mock(Result.class);    Result result2 = mock(Result.class);    when(result1.getRow()).thenReturn("user1".getBytes(StandardCharsets.UTF_8));    when(result2.getRow()).thenReturn("user2".getBytes(StandardCharsets.UTF_8));    when(result1.getValue(cf, Bytes.toBytes("type"))).thenReturn("userSettings1String".getBytes(StandardCharsets.UTF_8));    when(result2.getValue(cf, Bytes.toBytes("type"))).thenReturn("userSettings2String".getBytes(StandardCharsets.UTF_8));    when(resultScanner.iterator()).thenReturn(Arrays.asList(result1, result2).iterator());    when(userSettingsTable.getScanner(any(Scan.class))).thenReturn(resultScanner);    UserSettingsClient userSettingsClient = new UserSettingsClient(userSettingsTable, cf);    assertEquals(new HashMap<String, Optional<String>>() {        {            put("user1", Optional.of("userSettings1String"));            put("user2", Optional.of("userSettings2String"));        }    }, userSettingsClient.findAll("type"));}
public String metron_f2120_0()
{    return message;}
public void metron_f2121_0(String message)
{    this.message = message;}
public int metron_f2122_0()
{    return code;}
public void metron_f2123_0(int code)
{    this.code = code;}
public String metron_f2124_0()
{    return path;}
public void metron_f2125_0(String path)
{    this.path = path;}
public String metron_f2126_0()
{    return description;}
public void metron_f2127_0(String description)
{    this.description = description;}
public RequestMethod metron_f2128_0()
{    return method;}
public void metron_f2129_0(RequestMethod method)
{    this.method = method;}
public List<Response> metron_f2130_0()
{    return responses;}
public void metron_f2131_0(String message, int code)
{    Response response = new Response();    response.setMessage(message);    response.setCode(code);    this.responses.add(response);}
public Map<String, String> metron_f2132_0()
{    return parameterDescriptions;}
public void metron_f2133_0(String name, String description)
{    parameterDescriptions.put(name, description);}
public String metron_f2134_1(Object savedSearches)
{    try {        return JSONUtils.INSTANCE.toJSON(savedSearches, false);    } catch (JsonProcessingException e) {            }    return null;}
public Object metron_f2135_1(String savedSearches)
{    try {        return JSONUtils.INSTANCE.load(savedSearches, Object.class);    } catch (IOException e) {            }    return null;}
public String metron_f2136_0()
{    return user;}
public void metron_f2137_0(String user)
{    this.user = user;}
public List<String> metron_f2138_0()
{    return tableColumns;}
public void metron_f2139_0(List<String> tableColumns)
{    this.tableColumns = tableColumns;}
public List<SavedSearch> metron_f2140_0()
{    return savedSearches;}
public void metron_f2141_0(List<SavedSearch> savedSearches)
{    this.savedSearches = savedSearches;}
public List<String> metron_f2142_0()
{    return facetFields;}
public void metron_f2143_0(List<String> facetFields)
{    this.facetFields = facetFields;}
public boolean metron_f2144_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    AlertsUIUserSettings that = (AlertsUIUserSettings) o;    return (user != null ? user.equals(that.user) : that.user == null) && (tableColumns != null ? tableColumns.equals(that.tableColumns) : that.tableColumns == null) && (savedSearches != null ? savedSearches.equals(that.savedSearches) : that.savedSearches == null) && (facetFields != null ? facetFields.equals(that.facetFields) : that.facetFields == null);}
public int metron_f2145_0()
{    int result = user != null ? user.hashCode() : 0;    result = 31 * result + (tableColumns != null ? tableColumns.hashCode() : 0);    result = 31 * result + (savedSearches != null ? savedSearches.hashCode() : 0);    result = 31 * result + (facetFields != null ? facetFields.hashCode() : 0);    return result;}
public String metron_f2146_0()
{    return patternLabel;}
public void metron_f2147_0(String patternLabel)
{    this.patternLabel = patternLabel;}
public String metron_f2148_0()
{    return statement;}
public void metron_f2149_0(String statement)
{    this.statement = statement;}
public String metron_f2150_0()
{    return sampleData;}
public void metron_f2151_0(String sampleData)
{    this.sampleData = sampleData;}
public Map<String, Object> metron_f2152_0()
{    if (results == null) {        return new HashMap<>();    }    return results;}
public void metron_f2153_0(Map<String, Object> results)
{    this.results = results;}
public boolean metron_f2154_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    GrokValidation that = (GrokValidation) o;    if (patternLabel != null ? !patternLabel.equals(that.patternLabel) : that.patternLabel != null)        return false;    if (statement != null ? !statement.equals(that.statement) : that.statement != null)        return false;    if (sampleData != null ? !sampleData.equals(that.sampleData) : that.sampleData != null)        return false;    return results != null ? results.equals(that.results) : that.results == null;}
public int metron_f2155_0()
{    int result = patternLabel != null ? patternLabel.hashCode() : 0;    result = 31 * result + (statement != null ? statement.hashCode() : 0);    result = 31 * result + (sampleData != null ? sampleData.hashCode() : 0);    result = 31 * result + (results != null ? results.hashCode() : 0);    return result;}
public String metron_f2156_0()
{    return name;}
public void metron_f2157_0(String name)
{    this.name = name;}
public int metron_f2158_0()
{    return numPartitions;}
public void metron_f2159_0(int numPartitions)
{    this.numPartitions = numPartitions;}
public int metron_f2160_0()
{    return replicationFactor;}
public void metron_f2161_0(int replicationFactor)
{    this.replicationFactor = replicationFactor;}
public Properties metron_f2162_0()
{    return properties;}
public void metron_f2163_0(Properties properties)
{    this.properties = properties;}
public boolean metron_f2164_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    KafkaTopic that = (KafkaTopic) o;    if (numPartitions != that.numPartitions)        return false;    if (replicationFactor != that.replicationFactor)        return false;    if (name != null ? !name.equals(that.name) : that.name != null)        return false;    return properties != null ? properties.equals(that.properties) : that.properties == null;}
public int metron_f2165_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + numPartitions;    result = 31 * result + replicationFactor;    result = 31 * result + (properties != null ? properties.hashCode() : 0);    return result;}
public SensorParserConfig metron_f2166_0()
{    return sensorParserConfig;}
public void metron_f2167_0(SensorParserConfig sensorParserConfig)
{    this.sensorParserConfig = sensorParserConfig;}
public String metron_f2168_0()
{    return grokStatement;}
public void metron_f2169_0(String grokStatement)
{    this.grokStatement = grokStatement;}
public String metron_f2170_0()
{    return sampleData;}
public void metron_f2171_0(String sampleData)
{    this.sampleData = sampleData;}
public String metron_f2172_0()
{    return name;}
public void metron_f2173_0(String name)
{    this.name = name;}
public String metron_f2174_0()
{    return pos;}
public void metron_f2175_0(String pos)
{    this.pos = pos;}
public String metron_f2176_0()
{    return showname;}
public void metron_f2177_0(String showname)
{    this.showname = showname;}
public String metron_f2178_0()
{    return size;}
public void metron_f2179_0(String size)
{    this.size = size;}
public String metron_f2180_0()
{    return value;}
public void metron_f2181_0(String value)
{    this.value = value;}
public String metron_f2182_0()
{    return show;}
public void metron_f2183_0(String show)
{    this.show = show;}
public String metron_f2184_0()
{    return unmaskedvalue;}
public void metron_f2185_0(String unmaskedvalue)
{    this.unmaskedvalue = unmaskedvalue;}
public String metron_f2186_0()
{    return hide;}
public void metron_f2187_0(String hide)
{    this.hide = hide;}
public List<Field> metron_f2188_0()
{    return fields;}
public void metron_f2189_0(List<Field> fields)
{    this.fields = fields;}
public List<Proto> metron_f2190_0()
{    return protos;}
public void metron_f2191_0(List<Proto> protos)
{    this.protos = protos;}
public boolean metron_f2192_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Field field = (Field) o;    return Objects.equals(name, field.name) && Objects.equals(pos, field.pos) && Objects.equals(showname, field.showname) && Objects.equals(size, field.size) && Objects.equals(value, field.value) && Objects.equals(show, field.show) && Objects.equals(unmaskedvalue, field.unmaskedvalue) && Objects.equals(hide, field.hide) && Objects.equals(fields, field.fields) && Objects.equals(protos, field.protos);}
public int metron_f2193_0()
{    return Objects.hash(name, pos, showname, size, value, show, unmaskedvalue, hide, fields, protos);}
public String metron_f2194_0()
{    return key;}
public String metron_f2195_0()
{    return FixedPcapOptions.IP_SRC_ADDR.get(this, String.class);}
public void metron_f2196_0(String ipSrcAddr)
{    FixedPcapOptions.IP_SRC_ADDR.put(this, ipSrcAddr);}
public String metron_f2197_0()
{    return FixedPcapOptions.IP_DST_ADDR.get(this, String.class);}
public void metron_f2198_0(String ipDstAddr)
{    FixedPcapOptions.IP_DST_ADDR.put(this, ipDstAddr);}
public Integer metron_f2199_0()
{    return FixedPcapOptions.IP_SRC_PORT.get(this, Integer.class);}
public void metron_f2200_0(Integer ipSrcPort)
{    FixedPcapOptions.IP_SRC_PORT.put(this, ipSrcPort);}
public Integer metron_f2201_0()
{    return FixedPcapOptions.IP_DST_PORT.get(this, Integer.class);}
public void metron_f2202_0(Integer ipDstPort)
{    FixedPcapOptions.IP_DST_PORT.put(this, ipDstPort);}
public String metron_f2203_0()
{    return FixedPcapOptions.PROTOCOL.get(this, String.class);}
public void metron_f2204_0(String protocol)
{    FixedPcapOptions.PROTOCOL.put(this, protocol);}
public String metron_f2205_0()
{    return FixedPcapOptions.PACKET_FILTER.get(this, String.class);}
public void metron_f2206_0(String packetFilter)
{    FixedPcapOptions.PACKET_FILTER.put(this, packetFilter);}
public Boolean metron_f2207_0()
{    return FixedPcapOptions.INCLUDE_REVERSE.get(this, Boolean.class);}
public void metron_f2208_0(Boolean includeReverse)
{    FixedPcapOptions.INCLUDE_REVERSE.put(this, includeReverse);}
public void metron_f2209_0()
{    Map<String, String> fields = new HashMap<>();    if (getIpSrcAddr() != null) {        fields.put(Constants.Fields.SRC_ADDR.getName(), getIpSrcAddr());    }    if (getIpDstAddr() != null) {        fields.put(Constants.Fields.DST_ADDR.getName(), getIpDstAddr());    }    if (getIpSrcPort() != null) {        fields.put(Constants.Fields.SRC_PORT.getName(), getIpSrcPort().toString());    }    if (getIpDstPort() != null) {        fields.put(Constants.Fields.DST_PORT.getName(), getIpDstPort().toString());    }    if (getProtocol() != null) {        fields.put(Constants.Fields.PROTOCOL.getName(), getProtocol());    }    if (getIncludeReverse() != null) {        fields.put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), getIncludeReverse().toString());    }    if (getPacketFilter() != null) {        fields.put(PcapHelper.PacketFields.PACKET_FILTER.getName(), getPacketFilter());    }    PcapOptions.FIELDS.put(this, fields);}
public List<Proto> metron_f2210_0()
{    return protos;}
public void metron_f2211_0(List<Proto> protos)
{    this.protos = protos;}
public boolean metron_f2212_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Packet packet = (Packet) o;    return Objects.equals(protos, packet.protos);}
public int metron_f2213_0()
{    return Objects.hash(protos);}
public String metron_f2214_0()
{    return PcapOptions.BASE_PATH.get(this, String.class);}
public void metron_f2215_0(String basePath)
{    PcapOptions.BASE_PATH.put(this, basePath);}
public String metron_f2216_0()
{    return PcapOptions.BASE_INTERIM_RESULT_PATH.get(this, String.class);}
public void metron_f2217_0(String baseInterimResultPath)
{    PcapOptions.BASE_INTERIM_RESULT_PATH.put(this, baseInterimResultPath);}
public String metron_f2218_0()
{    return PcapOptions.FINAL_OUTPUT_PATH.get(this, String.class);}
public void metron_f2219_0(String finalOutputPath)
{    PcapOptions.FINAL_OUTPUT_PATH.put(this, finalOutputPath);}
public Long metron_f2220_0()
{    return PcapOptions.START_TIME_MS.get(this, Long.class);}
public void metron_f2221_0(Long startTime)
{    PcapOptions.START_TIME_MS.put(this, startTime);}
public Long metron_f2222_0()
{    return PcapOptions.END_TIME_MS.get(this, Long.class);}
public void metron_f2223_0(Long endTime)
{    PcapOptions.END_TIME_MS.put(this, endTime);}
public Integer metron_f2224_0()
{    return PcapOptions.NUM_REDUCERS.get(this, Integer.class);}
public void metron_f2225_0(Integer numReducers)
{    PcapOptions.NUM_REDUCERS.put(this, numReducers);}
public String metron_f2226_0()
{    return jobId;}
public void metron_f2227_0(String jobId)
{    this.jobId = jobId;}
public String metron_f2228_0()
{    return jobStatus;}
public void metron_f2229_0(String jobStatus)
{    this.jobStatus = jobStatus;}
public String metron_f2230_0()
{    return description;}
public void metron_f2231_0(String description)
{    this.description = description;}
public Double metron_f2232_0()
{    return percentComplete;}
public void metron_f2233_0(Double percentComplete)
{    this.percentComplete = percentComplete;}
public Integer metron_f2234_0()
{    return pageTotal;}
public void metron_f2235_0(Integer size)
{    this.pageTotal = size;}
public boolean metron_f2236_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    PcapStatus that = (PcapStatus) o;    return Objects.equals(jobId, that.jobId) && Objects.equals(jobStatus, that.jobStatus) && Objects.equals(description, that.description) && Objects.equals(percentComplete, that.percentComplete) && Objects.equals(pageTotal, that.pageTotal);}
public int metron_f2237_0()
{    return Objects.hash(jobId, jobStatus, description, percentComplete, pageTotal);}
public String metron_f2238_0()
{    return version;}
public void metron_f2239_0(String version)
{    this.version = version;}
public String metron_f2240_0()
{    return creator;}
public void metron_f2241_0(String creator)
{    this.creator = creator;}
public String metron_f2242_0()
{    return time;}
public void metron_f2243_0(String time)
{    this.time = time;}
public String metron_f2244_0()
{    return captureFile;}
public void metron_f2245_0(String captureFile)
{    this.captureFile = captureFile;}
public List<Packet> metron_f2246_0()
{    return packets;}
public void metron_f2247_0(List<Packet> packets)
{    this.packets = packets;}
public boolean metron_f2248_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Pdml pdml = (Pdml) o;    return Objects.equals(version, pdml.version) && Objects.equals(creator, pdml.creator) && Objects.equals(time, pdml.time) && Objects.equals(captureFile, pdml.captureFile) && Objects.equals(packets, pdml.packets);}
public int metron_f2249_0()
{    return Objects.hash(version, creator, time, captureFile, packets);}
public String metron_f2250_0()
{    return name;}
public void metron_f2251_0(String name)
{    this.name = name;}
public String metron_f2252_0()
{    return pos;}
public void metron_f2253_0(String pos)
{    this.pos = pos;}
public String metron_f2254_0()
{    return showname;}
public void metron_f2255_0(String showname)
{    this.showname = showname;}
public String metron_f2256_0()
{    return size;}
public void metron_f2257_0(String size)
{    this.size = size;}
public String metron_f2258_0()
{    return hide;}
public void metron_f2259_0(String hide)
{    this.hide = hide;}
public List<Field> metron_f2260_0()
{    return fields;}
public void metron_f2261_0(List<Field> fields)
{    this.fields = fields;}
public boolean metron_f2262_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Proto proto = (Proto) o;    return Objects.equals(name, proto.name) && Objects.equals(pos, proto.pos) && Objects.equals(showname, proto.showname) && Objects.equals(size, proto.size) && Objects.equals(hide, proto.hide) && Objects.equals(fields, proto.fields);}
public int metron_f2263_0()
{    return Objects.hash(name, pos, showname, size, hide, fields);}
public String metron_f2264_0()
{    return key;}
public String metron_f2265_0()
{    return QueryPcapOptions.QUERY.get(this, String.class);}
public void metron_f2266_0(String query)
{    QueryPcapOptions.QUERY.put(this, query);}
public void metron_f2267_0()
{    PcapOptions.FIELDS.put(this, getQuery());}
public List<byte[]> metron_f2268_0()
{    if (pcaps == null) {        return new ArrayList<>();    } else {        return pcaps;    }}
public void metron_f2269_0(List<byte[]> pcaps)
{    this.pcaps = pcaps;}
public int metron_f2270_0()
{    return responseCode;}
public String metron_f2271_0()
{    return message;}
public String metron_f2272_0()
{    return fullMessage;}
public String metron_f2273_0()
{    return name;}
public void metron_f2274_0(String name)
{    this.name = name;}
public SearchRequest metron_f2275_0()
{    return searchRequest;}
public void metron_f2276_0(SearchRequest searchRequest)
{    this.searchRequest = searchRequest;}
public boolean metron_f2277_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SavedSearch that = (SavedSearch) o;    return name != null ? name.equals(that.name) : that.name == null && (searchRequest != null ? searchRequest.equals(that.searchRequest) : that.searchRequest == null);}
public int metron_f2278_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (searchRequest != null ? searchRequest.hashCode() : 0);    return result;}
public Map<String, Object> metron_f2279_0()
{    if (sampleData == null) {        return new HashMap<>();    }    return sampleData;}
public void metron_f2280_0(Map<String, Object> sampleData)
{    this.sampleData = sampleData;}
public SensorParserConfig metron_f2281_0()
{    if (sensorParserConfig == null) {        return new SensorParserConfig();    }    return sensorParserConfig;}
public void metron_f2282_0(SensorParserConfig sensorParserConfig)
{    this.sensorParserConfig = sensorParserConfig;}
public String metron_f2283_0()
{    return name;}
public String metron_f2284_0()
{    return description;}
public String[] metron_f2285_0()
{    if (params == null) {        return new String[0];    }    return params;}
public String metron_f2286_0()
{    return returns;}
public String metron_f2287_0()
{    return id;}
public void metron_f2288_0(String id)
{    this.id = id;}
public String metron_f2289_0()
{    return host;}
public void metron_f2290_0(String host)
{    this.host = host;}
public String metron_f2291_0()
{    return uptime;}
public void metron_f2292_0(String upTime)
{    this.uptime = upTime;}
public int metron_f2293_0()
{    return slotsTotal;}
public void metron_f2294_0(int slotsTotal)
{    this.slotsTotal = slotsTotal;}
public int metron_f2295_0()
{    return slotsUsed;}
public void metron_f2296_0(int slotsUsed)
{    this.slotsUsed = slotsUsed;}
public boolean metron_f2297_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SupervisorStatus that = (SupervisorStatus) o;    if (getSlotsTotal() != that.getSlotsTotal()) {        return false;    }    if (getSlotsUsed() != that.getSlotsUsed()) {        return false;    }    if (!getId().equals(that.getId())) {        return false;    }    if (!getHost().equals(that.getHost())) {        return false;    }    return getUptime().equals(that.getUptime());}
public int metron_f2298_0()
{    int result = id != null ? id.hashCode() : 0;    result = 31 * result + (host != null ? host.hashCode() : 0);    result = 31 * result + (uptime != null ? uptime.hashCode() : 0);    result = 31 * result + getSlotsTotal();    result = 31 * result + getSlotsUsed();    return result;}
public SupervisorStatus[] metron_f2299_0()
{    return supervisors;}
public void metron_f2300_0(SupervisorStatus[] supervisors)
{    this.supervisors = supervisors;}
public boolean metron_f2301_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    SupervisorSummary that = (SupervisorSummary) o;    return supervisors != null ? Arrays.equals(supervisors, that.supervisors) : that.supervisors != null;}
public int metron_f2302_0()
{    return supervisors != null ? Arrays.hashCode(supervisors) : 0;}
public TopologyResponseCode metron_f2303_0()
{    return status;}
public String metron_f2304_0()
{    return message;}
public void metron_f2305_0(String message)
{    this.status = TopologyResponseCode.SUCCESS;    this.message = message;}
public void metron_f2306_0(String message)
{    this.status = TopologyResponseCode.ERROR;    this.message = message;}
public boolean metron_f2307_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    TopologyResponse that = (TopologyResponse) o;    if (status != null ? !status.equals(that.status) : that.status != null)        return false;    return message != null ? message.equals(that.message) : that.message == null;}
public int metron_f2308_0()
{    int result = status != null ? status.hashCode() : 0;    result = 31 * result + (message != null ? message.hashCode() : 0);    return result;}
public String metron_f2309_0()
{    return id;}
public void metron_f2310_0(String id)
{    this.id = id;}
public String metron_f2311_0()
{    return name;}
public void metron_f2312_0(String name)
{    this.name = name;}
public TopologyStatusCode metron_f2313_0()
{    return status;}
public void metron_f2314_0(TopologyStatusCode status)
{    this.status = status;}
public double metron_f2315_0()
{    return latency;}
public double metron_f2316_0()
{    return throughput;}
public Integer metron_f2317_0()
{    return emitted;}
public long metron_f2318_0()
{    return acked;}
public void metron_f2319_0(List<Map<String, Object>> topologyStats)
{    for (Map<String, Object> topologyStatsItem : topologyStats) {        if ("600".equals(topologyStatsItem.get("window"))) {            latency = Double.parseDouble((String) topologyStatsItem.get("completeLatency"));            if (topologyStatsItem.get("acked") != null) {                acked = (int) topologyStatsItem.get("acked");            }            if (topologyStatsItem.get("emitted") != null) {                emitted = (int) topologyStatsItem.get("emitted");            }            throughput = acked / 600.00;        }    }}
public boolean metron_f2320_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    TopologyStatus that = (TopologyStatus) o;    if (id != null ? !id.equals(that.id) : that.id != null)        return false;    if (name != null ? !name.equals(that.name) : that.name != null)        return false;    if (status != null ? !status.equals(that.status) : that.status != null)        return false;    if (!latency.equals(that.latency))        return false;    return throughput.equals(that.throughput);}
public int metron_f2321_0()
{    int result = id != null ? id.hashCode() : 0;    result = 31 * result + (name != null ? name.hashCode() : 0);    result = 31 * result + (status != null ? status.hashCode() : 0);    result = 31 * result + (latency != null ? latency.hashCode() : 0);    result = 31 * result + (throughput != null ? throughput.hashCode() : 0);    return result;}
public TopologyStatus[] metron_f2322_0()
{    if (topologies == null) {        return new TopologyStatus[0];    }    return topologies;}
public void metron_f2323_0(TopologyStatus[] topologies)
{    this.topologies = topologies;}
public boolean metron_f2324_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    TopologySummary that = (TopologySummary) o;    return topologies != null ? Arrays.equals(topologies, that.topologies) : that.topologies != null;}
public int metron_f2325_0()
{    return topologies != null ? Arrays.hashCode(topologies) : 0;}
public static int metron_f2326_0()
{    return NettyRuntime.availableProcessors();}
public Aggregator metron_f2327_0()
{    return aggregator;}
private static double metron_f2328_0(List<Number> list, Map<String, Object> config)
{    Double ret = 0d;    int num = 0;    boolean negValuesTrump = doNegativeValuesTrump(config);    for (Number n : list) {        if (n.doubleValue() < 0) {            if (negValuesTrump) {                return Double.NEGATIVE_INFINITY;            }        } else if (n.doubleValue() > 0) {            ret += n.doubleValue();            num++;        }    }    return num > 0 ? ret / num : 0d;}
private static boolean metron_f2329_0(Map<String, Object> config)
{    boolean negativeValuesTrump = true;    Object negValuesObj = config.get(NEGATIVE_VALUES_TRUMP_CONF);    if (negValuesObj != null) {        Boolean b = ConversionUtils.convert(negValuesObj, Boolean.class);        if (b != null) {            negativeValuesTrump = b;        }    }    return negativeValuesTrump;}
private static double metron_f2330_0(double initial, BinaryOperator<Number> op, List<Number> list, Map<String, Object> config)
{    if (list.isEmpty()) {        return 0d;    }    boolean negativeValuesTrump = doNegativeValuesTrump(config);    BinaryOperator<Number> binOp = op;    if (negativeValuesTrump) {        binOp = (x, y) -> {            if (y.doubleValue() < 0 || x.doubleValue() < 0) {                return Double.NEGATIVE_INFINITY;            } else {                return op.apply(x, y);            }        };    }    return list.stream().reduce(initial, binOp).doubleValue();}
private static double metron_f2331_0(double numberToScale, List<Number> list, Predicate<Number> filterFunc)
{    double scale = list.stream().filter(filterFunc).count();    if (scale < 1e-5) {        scale = 1;    }    return numberToScale / scale;}
public Double metron_f2332_0(List<Number> scores, Map<String, Object> config)
{    return aggregator.aggregate(scores, config);}
public boolean metron_f2333_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f2334_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public static CommandLine metron_f2335_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (ConfigurationOptions.HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static void metron_f2336_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("configuration_manager", getOptions());}
public static Options metron_f2337_0()
{    Options ret = new Options();    for (ConfigurationOptions o : ConfigurationOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public void metron_f2338_0(CuratorFramework client) throws Exception
{    ConfigurationsUtils.dumpConfigs(System.out, client);}
public void metron_f2339_0(CuratorFramework client, ConfigurationType type, Optional<String> configName) throws Exception
{    ConfigurationsUtils.dumpConfigs(System.out, client, type, configName);}
public void metron_f2340_0(CuratorFramework client, String outFileStr, final boolean force) throws Exception
{    final File outputDir = new File(outFileStr);    if (!outputDir.exists()) {        if (!outputDir.mkdirs()) {            throw new IllegalStateException("Unable to make directories: " + outputDir.getAbsolutePath());        }    }    ConfigurationsUtils.visitConfigs(client, new ConfigurationsUtils.ConfigurationVisitor() {        @Override        public void visit(ConfigurationType configurationType, String name, String data) {            File out = getFile(outputDir, configurationType, name);            if (!out.exists() || force) {                if (!out.exists()) {                    out.getParentFile().mkdirs();                }                try {                    Files.write(data, out, Charset.defaultCharset());                } catch (IOException e) {                    throw new RuntimeException("Sorry, something bad happened writing the config to " + out.getAbsolutePath() + ": " + e.getMessage(), e);                }            } else if (out.exists() && !force) {                throw new IllegalStateException("Unable to overwrite existing file (" + out.getAbsolutePath() + ") without the force flag (-f or --force) being set.");            }        }    });}
public void metron_f2341_0(ConfigurationType configurationType, String name, String data)
{    File out = getFile(outputDir, configurationType, name);    if (!out.exists() || force) {        if (!out.exists()) {            out.getParentFile().mkdirs();        }        try {            Files.write(data, out, Charset.defaultCharset());        } catch (IOException e) {            throw new RuntimeException("Sorry, something bad happened writing the config to " + out.getAbsolutePath() + ": " + e.getMessage(), e);        }    } else if (out.exists() && !force) {        throw new IllegalStateException("Unable to overwrite existing file (" + out.getAbsolutePath() + ") without the force flag (-f or --force) being set.");    }}
public void metron_f2342_0(String inputDirStr, CuratorFramework client) throws Exception
{    final File inputDir = new File(inputDirStr);    if (!inputDir.exists() || !inputDir.isDirectory()) {        throw new IllegalStateException("Input directory: " + inputDir + " does not exist or is not a directory.");    }    ConfigurationsUtils.uploadConfigsToZookeeper(inputDirStr, client);}
public void metron_f2343_0(String inputDirStr, CuratorFramework client, ConfigurationType type, Optional<String> configName) throws Exception
{    final File inputDir = new File(inputDirStr);    if (!inputDir.exists() || !inputDir.isDirectory()) {        throw new IllegalStateException("Input directory: " + inputDir + " does not exist or is not a directory.");    }    ConfigurationsUtils.uploadConfigsToZookeeper(inputDirStr, client, type, configName);}
public void metron_f2344_0(CommandLine cli) throws Exception
{    try (CuratorFramework client = ConfigurationsUtils.getClient(ConfigurationOptions.ZK_QUORUM.get(cli))) {        client.start();        run(client, cli);    }}
public void metron_f2345_0(CuratorFramework client, CommandLine cli) throws Exception
{    final boolean force = ConfigurationOptions.FORCE.has(cli);    String mode = ConfigurationOptions.MODE.get(cli);    Optional<String> configType = Optional.ofNullable(ConfigurationOptions.CONFIG_TYPE.get(cli));    Optional<String> configName = Optional.ofNullable(ConfigurationOptions.CONFIG_NAME.get(cli));    switch(mode.toLowerCase()) {        case "push":            String inputDirStr = ConfigurationOptions.INPUT.get(cli);            if (StringUtils.isEmpty(inputDirStr)) {                throw new IllegalArgumentException("Input directory is required when performing a PUSH operation.");            }            if (configType.isPresent()) {                push(inputDirStr, client, ConfigurationType.valueOf(configType.get()), configName);            } else {                push(inputDirStr, client);            }            break;        case "dump":            if (configType.isPresent()) {                dump(client, ConfigurationType.valueOf(configType.get()), configName);            } else {                dump(client);            }            break;        case "pull":            pull(client, ConfigurationOptions.OUTPUT.get(cli), force);            break;        case "patch":            if (configType.isPresent()) {                Optional<String> patchPath = Optional.ofNullable(ConfigurationOptions.PATCH_FILE.get(cli));                Optional<String> patchMode = Optional.ofNullable(ConfigurationOptions.PATCH_MODE.get(cli));                Optional<String> patchKey = Optional.ofNullable(ConfigurationOptions.PATCH_KEY.get(cli));                Optional<String> patchValue = Optional.ofNullable(ConfigurationOptions.PATCH_VALUE.get(cli));                patch(client, ConfigurationType.valueOf(configType.get()), configName, patchMode, patchPath, patchKey, patchValue);            } else {                throw new IllegalArgumentException("Patch requires config type");            }            break;        default:            throw new IllegalStateException("Invalid mode: " + mode + " expected DUMP, PULL, PUSH, or PATCH");    }}
private void metron_f2346_1(CuratorFramework client, ConfigurationType configType, Optional<String> configName, Optional<String> patchMode, Optional<String> patchPath, Optional<String> patchKey, Optional<String> patchValue) throws Exception
{    try {        byte[] patchData;        if (patchKey.isPresent()) {            patchData = buildPatch(patchMode, patchKey, patchValue).getBytes(StandardCharsets.UTF_8);        } else {            patchData = java.nio.file.Files.readAllBytes(Paths.get(patchPath.get()));        }        ConfigurationsUtils.applyConfigPatchToZookeeper(configType, configName, patchData, client);    } catch (IOException e) {                throw e;    } catch (Exception e) {                throw e;    }}
private String metron_f2347_0(Optional<String> patchMode, Optional<String> patchKey, Optional<String> patchValue)
{    PatchMode mode = PatchMode.ADD;    if (patchMode.isPresent()) {        mode = PatchMode.valueOf(patchMode.get());    }    String patch = "";    switch(mode) {        case ADD:            if (!patchKey.isPresent() || !patchValue.isPresent()) {                throw new IllegalArgumentException("Key and value are required to apply patches without a file");            }            patch = String.format("[ { \"op\": \"%s\", \"path\": \"%s\", \"value\": %s } ]", patchMode.get().toString().toLowerCase(), patchKey.get(), patchValue.get());            break;        case REMOVE:            if (!patchKey.isPresent()) {                throw new IllegalArgumentException("Key is required to apply a remove patch without a file");            }            patch = String.format("[ { \"op\": \"%s\", \"path\": \"%s\" } ]", patchMode.get().toString().toLowerCase(), patchKey.get());            break;        default:            throw new UnsupportedOperationException("Patch mode not supported: " + mode.toString());    }    return patch;}
private static File metron_f2348_0(File baseDir, ConfigurationType configurationType, String name)
{    return new File(new File(baseDir, configurationType.getDirectory()), name + ".json");}
public static void metron_f2349_0(String... argv) throws Exception
{    CommandLineParser parser = new PosixParser();    CommandLine cli = ConfigurationOptions.parse(parser, argv);    ConfigurationManager manager = new ConfigurationManager();    manager.run(cli);}
 BiFunction<String, Object, Object> metron_f2350_0()
{    return (s, o) -> o;}
 boolean metron_f2351_0(Map<String, Object> map)
{    return map.containsKey(getKey());}
 void metron_f2352_0(Map<String, Object> map, Object value)
{    map.put(getKey(), value);}
 T metron_f2353_0(Map<String, Object> map, Class<T> clazz, T defaultValue)
{    T val;    return ((val = get(map, clazz)) == null ? defaultValue : val);}
 T metron_f2354_0(Map<String, Object> map, Class<T> clazz)
{    Object obj = map.get(getKey());    if (clazz.isInstance(obj)) {        return clazz.cast(obj);    } else {        return ConversionUtils.convert(obj, clazz);    }}
 T metron_f2355_0(Map<String, Object> map, BiFunction<String, Object, T> transform, Class<T> clazz, T defaultValue)
{    T val;    return ((val = get(map, transform, clazz)) == null ? defaultValue : val);}
 T metron_f2356_0(Map<String, Object> map, BiFunction<String, Object, T> transform, Class<T> clazz)
{    return clazz.cast(transform.apply(getKey(), map.get(getKey())));}
 T metron_f2357_0(Map<String, Object> map, Class<T> clazz, T defaultValue)
{    T val;    return ((val = getTransformed(map, clazz)) == null ? defaultValue : val);}
 T metron_f2358_0(Map<String, Object> map, Class<T> clazz)
{    return clazz.cast(transform().apply(getKey(), map.get(getKey())));}
public void metron_f2359_0() throws Exception
{    if (null != curatorFramework) {        ConfigurationsUtils.updateConfigsFromZookeeper(this, this.curatorFramework);    } else {        updateGlobalConfig(ConfigurationsUtils.readGlobalConfigFromFile(configFileRoot.toAbsolutePath().toString()));    }}
 String metron_f2360_0()
{    return getTypeName();}
 String metron_f2361_0()
{    return Constants.ZOOKEEPER_TOPOLOGY_ROOT + "/" + getTypeName();}
public Map<String, Object> metron_f2362_0()
{    return configurations;}
public Map<String, Object> metron_f2363_0()
{    return getGlobalConfig(true);}
public Map<String, Object> metron_f2364_0(boolean emptyMapOnNonExistent)
{    return (Map<String, Object>) getConfigurations().getOrDefault(ConfigurationType.GLOBAL.getTypeName(), emptyMapOnNonExistent ? new HashMap() : null);}
public List<FieldValidator> metron_f2365_0()
{    return validations;}
public void metron_f2366_0(byte[] data) throws IOException
{    if (data == null)        throw new IllegalStateException("global config data cannot be null");    updateGlobalConfig(new ByteArrayInputStream(data));}
public void metron_f2367_0(InputStream io) throws IOException
{    Map<String, Object> globalConfig = JSONUtils.INSTANCE.load(io, JSONUtils.MAP_SUPPLIER);    updateGlobalConfig(globalConfig);}
public void metron_f2368_0(Map<String, Object> globalConfig)
{    if (globalConfig != null) {        getConfigurations().put(ConfigurationType.GLOBAL.getTypeName(), globalConfig);        validations = FieldValidator.readValidations(getGlobalConfig());    }}
public void metron_f2369_0()
{    getConfigurations().remove(ConfigurationType.GLOBAL.getTypeName());}
public static T metron_f2370_0(String key, Map<String, Object> map, T defaultValue, Class<T> clazz)
{    return map == null ? defaultValue : ConversionUtils.convert(map.getOrDefault(key, defaultValue), clazz);}
public boolean metron_f2371_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Configurations that = (Configurations) o;    if (validations != null ? !validations.equals(that.validations) : that.validations != null)        return false;    return getConfigurations() != null ? getConfigurations().equals(that.getConfigurations()) : that.getConfigurations() == null;}
public int metron_f2372_0()
{    int result = validations != null ? validations.hashCode() : 0;    result = 31 * result + (getConfigurations() != null ? getConfigurations().hashCode() : 0);    return result;}
public String metron_f2373_0()
{    return "Configurations{" + "validations=" + validations + ", configurations=" + getConfigurations() + '}';}
public static CuratorFramework metron_f2374_0(String zookeeperUrl)
{    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    return CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy);}
public static void metron_f2375_0(Map<String, Object> globalConfig, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeGlobalConfigToZookeeper(globalConfig, client);    }}
public static void metron_f2376_0(Map<String, Object> globalConfig, CuratorFramework client) throws Exception
{    writeGlobalConfigToZookeeper(JSONUtils.INSTANCE.toJSONPretty(globalConfig), client);}
public static void metron_f2377_0(byte[] globalConfig, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeGlobalConfigToZookeeper(globalConfig, client);    }}
public static void metron_f2378_0(byte[] globalConfig, CuratorFramework client) throws Exception
{    GLOBAL.deserialize(new String(globalConfig, StandardCharsets.UTF_8));    writeToZookeeper(GLOBAL.getZookeeperRoot(), globalConfig, client);}
public static void metron_f2379_0(byte[] config, CuratorFramework client) throws Exception
{    PROFILER.deserialize(new String(config, StandardCharsets.UTF_8));    writeToZookeeper(PROFILER.getZookeeperRoot(), config, client);}
public static void metron_f2380_0(String sensorType, SensorParserConfig sensorParserConfig, String zookeeperUrl) throws Exception
{    writeSensorParserConfigToZookeeper(sensorType, JSONUtils.INSTANCE.toJSONPretty(sensorParserConfig), zookeeperUrl);}
public static void metron_f2381_0(String sensorType, byte[] configData, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeSensorParserConfigToZookeeper(sensorType, configData, client);    }}
public static void metron_f2382_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    SensorParserConfig c = (SensorParserConfig) PARSER.deserialize(new String(configData, StandardCharsets.UTF_8));    c.init();    writeToZookeeper(PARSER.getZookeeperRoot() + "/" + sensorType, configData, client);}
public static void metron_f2383_0(String sensorType, Map<String, Object> sensorIndexingConfig, String zookeeperUrl) throws Exception
{    writeSensorIndexingConfigToZookeeper(sensorType, JSONUtils.INSTANCE.toJSONPretty(sensorIndexingConfig), zookeeperUrl);}
public static void metron_f2384_0(String sensorType, byte[] configData, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeSensorIndexingConfigToZookeeper(sensorType, configData, client);    }}
public static void metron_f2385_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    INDEXING.deserialize(new String(configData, StandardCharsets.UTF_8));    writeToZookeeper(INDEXING.getZookeeperRoot() + "/" + sensorType, configData, client);}
public static void metron_f2386_0(String sensorType, SensorEnrichmentConfig sensorEnrichmentConfig, String zookeeperUrl) throws Exception
{    writeSensorEnrichmentConfigToZookeeper(sensorType, JSONUtils.INSTANCE.toJSONPretty(sensorEnrichmentConfig), zookeeperUrl);}
public static void metron_f2387_0(String sensorType, byte[] configData, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeSensorEnrichmentConfigToZookeeper(sensorType, configData, client);    }}
public static void metron_f2388_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    ENRICHMENT.deserialize(new String(configData, StandardCharsets.UTF_8));    writeToZookeeper(ENRICHMENT.getZookeeperRoot() + "/" + sensorType, configData, client);}
public static void metron_f2389_0(String name, Map<String, Object> config, String zookeeperUrl) throws Exception
{    writeConfigToZookeeper(Constants.ZOOKEEPER_TOPOLOGY_ROOT + "/" + name, JSONUtils.INSTANCE.toJSONPretty(config), zookeeperUrl);}
public static void metron_f2390_0(ConfigurationType configType, byte[] configData, String zookeeperUrl) throws Exception
{    writeConfigToZookeeper(configType, Optional.empty(), configData, zookeeperUrl);}
public static void metron_f2391_0(ConfigurationType configType, Optional<String> configName, byte[] configData, String zookeeperUrl) throws Exception
{    writeConfigToZookeeper(getConfigZKPath(configType, configName), configData, zookeeperUrl);}
public static void metron_f2392_0(ConfigurationType configType, Optional<String> configName, byte[] configData, CuratorFramework client) throws Exception
{    writeToZookeeper(getConfigZKPath(configType, configName), configData, client);}
private static String metron_f2393_0(ConfigurationType configType, Optional<String> configName)
{    String pathSuffix = configName.isPresent() && configType != GLOBAL ? "/" + configName.get() : "";    return configType.getZookeeperRoot() + pathSuffix;}
public static void metron_f2394_0(String configPath, byte[] config, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeToZookeeper(configPath, config, client);    }}
public static void metron_f2395_0(String path, byte[] configData, CuratorFramework client) throws Exception
{    try {        client.setData().forPath(path, configData);    } catch (KeeperException.NoNodeException e) {        client.create().creatingParentsIfNeeded().forPath(path, configData);    }}
public static void metron_f2396_0(Configurations configurations, CuratorFramework client) throws Exception
{    configurations.updateGlobalConfig(readGlobalConfigBytesFromZookeeper(client));}
private static void metron_f2397_1(Configurations configurations, ConfigurationType type, Callback callback, CuratorFramework client) throws Exception
{    Exception globalUpdateException = null;    try {        updateConfigsFromZookeeper(configurations, client);    } catch (Exception e) {                globalUpdateException = e;    }    List<String> sensorTypes = client.getChildren().forPath(type.getZookeeperRoot());    for (String sensorType : sensorTypes) {        callback.apply(sensorType);    }    if (globalUpdateException != null) {        throw globalUpdateException;    }}
public static void metron_f2398_0(ParserConfigurations configurations, CuratorFramework client) throws Exception
{    updateConfigsFromZookeeper(configurations, PARSER, sensorType -> configurations.updateSensorParserConfig(sensorType, readSensorParserConfigBytesFromZookeeper(sensorType, client)), client);}
public static void metron_f2399_0(IndexingConfigurations configurations, CuratorFramework client) throws Exception
{    updateConfigsFromZookeeper(configurations, INDEXING, sensorType -> configurations.updateSensorIndexingConfig(sensorType, readSensorIndexingConfigBytesFromZookeeper(sensorType, client)), client);}
public static void metron_f2400_0(EnrichmentConfigurations configurations, CuratorFramework client) throws Exception
{    updateConfigsFromZookeeper(configurations, ENRICHMENT, sensorType -> configurations.updateSensorEnrichmentConfig(sensorType, readSensorEnrichmentConfigBytesFromZookeeper(sensorType, client)), client);}
public static Map<String, Object> metron_f2401_0(CuratorFramework client) throws Exception
{    Map<String, Object> config = null;    Optional<byte[]> bytes = readFromZookeeperSafely(GLOBAL.getZookeeperRoot(), client);    if (bytes.isPresent()) {        InputStream in = new ByteArrayInputStream(bytes.get());        config = JSONUtils.INSTANCE.load(in, JSONUtils.MAP_SUPPLIER);    }    return config;}
public static Map<String, Object> metron_f2402_0(String sensorType, CuratorFramework client) throws Exception
{    Map<String, Object> config = null;    Optional<byte[]> bytes = readFromZookeeperSafely(INDEXING.getZookeeperRoot() + "/" + sensorType, client);    if (bytes.isPresent()) {        InputStream in = new ByteArrayInputStream(bytes.get());        config = JSONUtils.INSTANCE.load(in, JSONUtils.MAP_SUPPLIER);    }    return config;}
public static SensorEnrichmentConfig metron_f2403_0(String sensorType, CuratorFramework client) throws Exception
{    SensorEnrichmentConfig config = null;    Optional<byte[]> bytes = readFromZookeeperSafely(ENRICHMENT.getZookeeperRoot() + "/" + sensorType, client);    if (bytes.isPresent()) {        config = SensorEnrichmentConfig.fromBytes(bytes.get());    }    return config;}
public static SensorParserConfig metron_f2404_0(String sensorType, CuratorFramework client) throws Exception
{    SensorParserConfig config = null;    Optional<byte[]> bytes = readFromZookeeperSafely(PARSER.getZookeeperRoot() + "/" + sensorType, client);    if (bytes.isPresent()) {        config = SensorParserConfig.fromBytes(bytes.get());    }    return config;}
public static ProfilerConfig metron_f2405_0(CuratorFramework client) throws Exception
{    ProfilerConfig config = null;    Optional<byte[]> bytes = readFromZookeeperSafely(PROFILER.getZookeeperRoot(), client);    if (bytes.isPresent()) {        config = ProfilerConfig.fromBytes(bytes.get());    }    return config;}
public static byte[] metron_f2406_0(CuratorFramework client) throws Exception
{    return readFromZookeeper(GLOBAL.getZookeeperRoot(), client);}
public static byte[] metron_f2407_0(CuratorFramework client) throws Exception
{    return readFromZookeeper(PROFILER.getZookeeperRoot(), client);}
public static byte[] metron_f2408_0(String sensorType, CuratorFramework client) throws Exception
{    return readFromZookeeper(INDEXING.getZookeeperRoot() + "/" + sensorType, client);}
public static byte[] metron_f2409_0(String sensorType, CuratorFramework client) throws Exception
{    return readFromZookeeper(PARSER.getZookeeperRoot() + "/" + sensorType, client);}
public static byte[] metron_f2410_0(String sensorType, CuratorFramework client) throws Exception
{    return readFromZookeeper(ENRICHMENT.getZookeeperRoot() + "/" + sensorType, client);}
public static byte[] metron_f2411_0(String name, CuratorFramework client) throws Exception
{    return readFromZookeeper(Constants.ZOOKEEPER_TOPOLOGY_ROOT + "/" + name, client);}
public static byte[] metron_f2412_0(ConfigurationType configType, String zookeeperUrl) throws Exception
{    return readConfigBytesFromZookeeper(configType, Optional.empty(), zookeeperUrl);}
public static byte[] metron_f2413_0(ConfigurationType configType, Optional<String> configName, CuratorFramework client) throws Exception
{    return readFromZookeeper(getConfigZKPath(configType, configName), client);}
public static byte[] metron_f2414_0(ConfigurationType configType, Optional<String> configName, String zookeeperUrl) throws Exception
{    return readFromZookeeper(getConfigZKPath(configType, configName), zookeeperUrl);}
public static byte[] metron_f2415_0(String path, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        return readFromZookeeper(path, client);    }}
public static byte[] metron_f2417_0(String path, CuratorFramework client) throws Exception
{    if (client != null && client.getData() != null && path != null) {        return client.getData().forPath(path);    }    return new byte[] {};}
public static void metron_f2418_0(String globalConfigPath, String parsersConfigPath, String enrichmentsConfigPath, String indexingConfigPath, String profilerConfigPath, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        uploadConfigsToZookeeper(globalConfigPath, parsersConfigPath, enrichmentsConfigPath, indexingConfigPath, profilerConfigPath, client);    }}
public static void metron_f2419_0(String rootFilePath, CuratorFramework client) throws Exception
{    uploadConfigsToZookeeper(rootFilePath, rootFilePath, rootFilePath, rootFilePath, rootFilePath, client);}
public static void metron_f2420_0(String rootFilePath, CuratorFramework client, ConfigurationType type) throws Exception
{    uploadConfigsToZookeeper(rootFilePath, client, type, Optional.empty());}
public static void metron_f2421_0(String rootFilePath, CuratorFramework client, ConfigurationType type, Optional<String> configName) throws Exception
{    switch(type) {        case GLOBAL:            final byte[] globalConfig = readGlobalConfigFromFile(rootFilePath);            if (globalConfig.length > 0) {                setupStellarStatically(client, Optional.of(new String(globalConfig, StandardCharsets.UTF_8)));                writeGlobalConfigToZookeeper(globalConfig, client);            }            break;                case PARSER:                case ENRICHMENT:        case         INDEXING:            {                Map<String, byte[]> configs = readSensorConfigsFromFile(rootFilePath, type, configName);                for (String sensorType : configs.keySet()) {                    byte[] configData = configs.get(sensorType);                    type.writeSensorConfigToZookeeper(sensorType, configData, client);                }                break;            }        case PROFILER:            {                byte[] configData = readProfilerConfigFromFile(rootFilePath);                if (configData.length > 0) {                    ConfigurationsUtils.writeProfilerConfigToZookeeper(configData, client);                }                break;            }        default:            throw new IllegalArgumentException("Configuration type not found: " + type);    }}
public static void metron_f2422_0(String globalConfigPath, String parsersConfigPath, String enrichmentsConfigPath, String indexingConfigPath, String profilerConfigPath, CuratorFramework client) throws Exception
{        if (globalConfigPath != null) {        final byte[] globalConfig = readGlobalConfigFromFile(globalConfigPath);        if (globalConfig.length > 0) {            setupStellarStatically(client, Optional.of(new String(globalConfig, StandardCharsets.UTF_8)));            ConfigurationsUtils.writeGlobalConfigToZookeeper(readGlobalConfigFromFile(globalConfigPath), client);        }    }        if (parsersConfigPath != null) {        Map<String, byte[]> sensorParserConfigs = readSensorParserConfigsFromFile(parsersConfigPath);        for (String sensorType : sensorParserConfigs.keySet()) {            ConfigurationsUtils.writeSensorParserConfigToZookeeper(sensorType, sensorParserConfigs.get(sensorType), client);        }    }        if (indexingConfigPath != null) {        Map<String, byte[]> sensorIndexingConfigs = readSensorIndexingConfigsFromFile(indexingConfigPath);        for (String sensorType : sensorIndexingConfigs.keySet()) {            ConfigurationsUtils.writeSensorIndexingConfigToZookeeper(sensorType, sensorIndexingConfigs.get(sensorType), client);        }    }        if (enrichmentsConfigPath != null) {        Map<String, byte[]> sensorEnrichmentConfigs = readSensorEnrichmentConfigsFromFile(enrichmentsConfigPath);        for (String sensorType : sensorEnrichmentConfigs.keySet()) {            ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(sensorType, sensorEnrichmentConfigs.get(sensorType), client);        }    }        if (profilerConfigPath != null) {        byte[] profilerConfig = readProfilerConfigFromFile(profilerConfigPath);        if (profilerConfig.length > 0) {            ConfigurationsUtils.writeProfilerConfigToZookeeper(profilerConfig, client);        }    }}
public static void metron_f2423_0(CuratorFramework client) throws Exception
{    byte[] ret = null;    try {        ret = readGlobalConfigBytesFromZookeeper(client);    } catch (KeeperException.NoNodeException nne) {        }    if (ret == null || ret.length == 0) {        setupStellarStatically(client, Optional.empty());    } else {        setupStellarStatically(client, Optional.of(new String(ret, StandardCharsets.UTF_8)));    }}
public static void metron_f2424_0(CuratorFramework client, Optional<String> globalConfig)
{    /*      In order to validate stellar functions, the function resolver must be initialized.  Otherwise,      those utilities that require validation cannot validate the stellar expressions necessarily.    */    Context.Builder builder = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client);    if (globalConfig.isPresent()) {        builder = builder.with(Context.Capabilities.GLOBAL_CONFIG, () -> GLOBAL.deserialize(globalConfig.get())).with(Context.Capabilities.STELLAR_CONFIG, () -> GLOBAL.deserialize(globalConfig.get()));    } else {        builder = builder.with(Context.Capabilities.STELLAR_CONFIG, () -> new HashMap<>());    }    Context stellarContext = builder.build();    StellarFunctions.FUNCTION_RESOLVER().initialize(stellarContext);}
public static byte[] metron_f2425_0(String rootPath) throws IOException
{    byte[] globalConfig = new byte[0];    File configPath = new File(rootPath, GLOBAL.getTypeName() + ".json");    if (configPath.exists()) {        globalConfig = Files.readAllBytes(configPath.toPath());    }    return globalConfig;}
public static Map<String, byte[]> metron_f2426_0(String rootPath) throws IOException
{    return readSensorConfigsFromFile(rootPath, PARSER, Optional.empty());}
public static Map<String, byte[]> metron_f2427_0(String rootPath) throws IOException
{    return readSensorConfigsFromFile(rootPath, ENRICHMENT, Optional.empty());}
public static Map<String, byte[]> metron_f2428_0(String rootPath) throws IOException
{    return readSensorConfigsFromFile(rootPath, INDEXING, Optional.empty());}
public static byte[] metron_f2429_0(String rootPath) throws IOException
{    byte[] config = new byte[0];    File configPath = new File(rootPath, PROFILER.getTypeName() + ".json");    if (configPath.exists()) {        config = Files.readAllBytes(configPath.toPath());    }    return config;}
public static Map<String, byte[]> metron_f2430_0(String rootPath, ConfigurationType configType) throws IOException
{    return readSensorConfigsFromFile(rootPath, configType, Optional.empty());}
public static Map<String, byte[]> metron_f2431_0(String rootPath, ConfigurationType configType, Optional<String> configName) throws IOException
{    Map<String, byte[]> sensorConfigs = new HashMap<>();    File configPath = new File(rootPath, configType.getDirectory());    if (configPath.exists() && configPath.isDirectory()) {        File[] children = configPath.listFiles();        if (!configName.isPresent()) {            for (File file : children) {                sensorConfigs.put(FilenameUtils.removeExtension(file.getName()), Files.readAllBytes(file.toPath()));            }        } else {            for (File file : children) {                if (FilenameUtils.removeExtension(file.getName()).equals(configName.get())) {                    sensorConfigs.put(FilenameUtils.removeExtension(file.getName()), Files.readAllBytes(file.toPath()));                }            }            if (sensorConfigs.isEmpty()) {                throw new RuntimeException("Unable to find configuration for " + configName.get());            }        }    }    return sensorConfigs;}
public static void metron_f2432_0(ConfigurationType configurationType, byte[] patchData, String zookeeperUrl) throws Exception
{    applyConfigPatchToZookeeper(configurationType, Optional.empty(), patchData, zookeeperUrl);}
public static void metron_f2433_0(ConfigurationType configurationType, Optional<String> configName, byte[] patchData, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        applyConfigPatchToZookeeper(configurationType, configName, patchData, client);    }}
public static void metron_f2434_0(ConfigurationType configurationType, Optional<String> configName, byte[] patchData, CuratorFramework client) throws Exception
{    byte[] configData = readConfigBytesFromZookeeper(configurationType, configName, client);    byte[] prettyPatchedConfig = JSONUtils.INSTANCE.applyPatch(patchData, configData);        String prettyPatchedConfigStr = new String(prettyPatchedConfig, StandardCharsets.UTF_8);    configurationType.deserialize(prettyPatchedConfigStr);    writeConfigToZookeeper(configurationType, configName, prettyPatchedConfig, client);}
public static void metron_f2435_0(CuratorFramework client, final ConfigurationVisitor callback) throws Exception
{    visitConfigs(client, (type, name, data) -> {        setupStellarStatically(client, Optional.ofNullable(data));        callback.visit(type, name, data);    }, GLOBAL, Optional.empty());    visitConfigs(client, callback, PARSER, Optional.empty());    visitConfigs(client, callback, INDEXING, Optional.empty());    visitConfigs(client, callback, ENRICHMENT, Optional.empty());    visitConfigs(client, callback, PROFILER, Optional.empty());}
public static void metron_f2436_0(CuratorFramework client, ConfigurationVisitor callback, ConfigurationType configType, Optional<String> configName) throws Exception
{    if (client.checkExists().forPath(configType.getZookeeperRoot()) != null) {        if (configType.equals(GLOBAL)) {            byte[] globalConfigData = client.getData().forPath(configType.getZookeeperRoot());            callback.visit(configType, "global", new String(globalConfigData, StandardCharsets.UTF_8));        } else if (configType.equals(PROFILER)) {            byte[] profilerConfigData = client.getData().forPath(configType.getZookeeperRoot());            callback.visit(configType, "profiler", new String(profilerConfigData, StandardCharsets.UTF_8));        } else if (configType.equals(PARSER) || configType.equals(ENRICHMENT) || configType.equals(INDEXING)) {            if (configName.isPresent()) {                byte[] data = readConfigBytesFromZookeeper(configType, configName, client);                callback.visit(configType, configName.get(), new String(data, StandardCharsets.UTF_8));            } else {                List<String> children = client.getChildren().forPath(configType.getZookeeperRoot());                for (String child : children) {                    byte[] data = client.getData().forPath(configType.getZookeeperRoot() + "/" + child);                    callback.visit(configType, child, new String(data, StandardCharsets.UTF_8));                }            }        }    }}
public static void metron_f2437_0(PrintStream out, CuratorFramework client) throws Exception
{    ConfigurationsUtils.visitConfigs(client, (type, name, data) -> {        type.deserialize(data);        out.println(type + " Config: " + name + System.lineSeparator() + data);    });}
public static void metron_f2438_0(PrintStream out, CuratorFramework client, ConfigurationType configType, Optional<String> configName) throws Exception
{    ConfigurationsUtils.visitConfigs(client, (type, name, data) -> {        setupStellarStatically(client, Optional.ofNullable(data));        type.deserialize(data);        out.println(type + " Config: " + name + System.lineSeparator() + data);    }, configType, configName);}
public static String metron_f2439_0(Map<String, Object> globalConfig, String globalConfigKey, String defaultFieldName)
{    if (globalConfig == null) {        return defaultFieldName;    }    return (String) globalConfig.getOrDefault(globalConfigKey, defaultFieldName);}
public String metron_f2440_0()
{    return ops.getTypeName();}
public String metron_f2441_0()
{    return ops.getDirectory();}
public Object metron_f2442_0(String s)
{    try {        return ops.deserialize(s);    } catch (IOException e) {        throw new RuntimeException("Unable to load " + s, e);    }}
public Object metron_f2443_0(String s)
{    return deserialize(s);}
public void metron_f2444_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    ops.writeSensorConfigToZookeeper(sensorType, configData, client);}
public String metron_f2445_0()
{    return ops.getZookeeperRoot();}
public Map<String, Object> metron_f2446_0()
{    return config;}
public void metron_f2447_0(Map<String, Object> config)
{    this.config = config;}
public Map<String, Object> metron_f2448_0()
{    return fieldMap;}
public Map<String, ConfigHandler> metron_f2449_0()
{    return enrichmentConfigs;}
public void metron_f2450_0(Map<String, Object> fieldMap)
{    this.fieldMap = fieldMap;    for (Map.Entry<String, Object> kv : fieldMap.entrySet()) {        if (kv.getValue() instanceof List) {            enrichmentConfigs.put(kv.getKey(), new ConfigHandler((List<String>) kv.getValue()));        } else {            enrichmentConfigs.put(kv.getKey(), new ConfigHandler(kv.getKey(), (Map<String, Object>) kv.getValue()));        }    }}
public Map<String, List<String>> metron_f2451_0()
{    return fieldToTypeMap;}
public void metron_f2452_0(Map<String, List<String>> fieldToTypeMap)
{    this.fieldToTypeMap = fieldToTypeMap;}
public String metron_f2453_0()
{    return "EnrichmentConfig{" + "fieldMap=" + fieldMap + ", fieldToTypeMap=" + fieldToTypeMap + ", config=" + config + '}';}
public boolean metron_f2454_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    EnrichmentConfig that = (EnrichmentConfig) o;    if (getFieldMap() != null ? !getFieldMap().equals(that.getFieldMap()) : that.getFieldMap() != null)        return false;    if (getFieldToTypeMap() != null ? !getFieldToTypeMap().equals(that.getFieldToTypeMap()) : that.getFieldToTypeMap() != null)        return false;    return getConfig() != null ? getConfig().equals(that.getConfig()) : that.getConfig() == null;}
public int metron_f2455_0()
{    int result = getFieldMap() != null ? getFieldMap().hashCode() : 0;    result = 31 * result + (getFieldToTypeMap() != null ? getFieldToTypeMap().hashCode() : 0);    result = 31 * result + (getConfig() != null ? getConfig().hashCode() : 0);    return result;}
 List<JSONObject> metron_f2456_0(JSONObject message, Object fields, Function<String, String> fieldToEnrichmentKey, ConfigHandler handler)
{    return splitByFields(message, fields, fieldToEnrichmentKey, handler.getType().toConfig(handler.getConfig()));}
 List<String> metron_f2457_0(ConfigHandler handler)
{    return getSubgroups(handler.getType().toConfig(handler.getConfig()));}
public Object metron_f2458_0()
{    return config;}
public void metron_f2459_0(Object config)
{    this.config = config;}
public Configs metron_f2460_0()
{    return type;}
public void metron_f2461_0(Configs retriever)
{    this.type = retriever;}
public boolean metron_f2462_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ConfigHandler that = (ConfigHandler) o;    if (getConfig() != null ? !getConfig().equals(that.getConfig()) : that.getConfig() != null)        return false;    return getType() != null ? getType().equals(that.getType()) : that.getType() == null;}
public int metron_f2463_0()
{    int result = getConfig() != null ? getConfig().hashCode() : 0;    result = 31 * result + (getType() != null ? getType().hashCode() : 0);    return result;}
public List<JSONObject> metron_f2464_0(JSONObject message, Object fields, Function<String, String> fieldToEnrichmentKey, Iterable<Map.Entry<String, Object>> config)
{    return configCreator.splitByFields(message, fields, fieldToEnrichmentKey, config);}
public List<String> metron_f2465_0(Iterable<Map.Entry<String, Object>> config)
{    return configCreator.getSubgroups(config);}
public Iterable<Map.Entry<String, Object>> metron_f2466_0(Object c)
{    return configCreator.toConfig(c);}
public List<JSONObject> metron_f2467_0(JSONObject message, Object fieldsObj, Function<String, String> fieldToEnrichmentKey, Iterable<Map.Entry<String, Object>> config)
{    List<String> fields = (List<String>) fieldsObj;    JSONObject enrichmentObject = new JSONObject();    if (fields != null && fields.size() > 0) {        for (String field : fields) {            enrichmentObject.put(fieldToEnrichmentKey.apply(field), message.get(field));        }    }    return ImmutableList.of(enrichmentObject);}
public List<String> metron_f2468_0(Iterable<Map.Entry<String, Object>> config)
{    return ImmutableList.of("");}
public Iterable<Map.Entry<String, Object>> metron_f2469_0(Object c)
{    if (c instanceof Map) {        return ((Map<String, Object>) c).entrySet();    } else {        return new ArrayList<>();    }}
public List<String> metron_f2470_0(Iterable<Map.Entry<String, Object>> config)
{    boolean includeEmpty = false;    List<String> ret = new ArrayList<>();    for (Map.Entry<String, Object> kv : config) {        if (kv.getValue() instanceof String) {            includeEmpty = true;        } else if (kv.getValue() instanceof Map || kv.getValue() instanceof List) {            ret.add(kv.getKey());        }    }    if (includeEmpty) {        ret.add("");    }    return ret;}
public Iterable<Map.Entry<String, Object>> metron_f2471_0(Object c)
{    if (c instanceof Map) {        return ((Map<String, Object>) c).entrySet();    } else if (c instanceof Collection) {        List<Map.Entry<String, Object>> ret = new ArrayList<>();        for (Object o : (Collection) c) {            if (o instanceof String) {                StellarAssignment assignment = StellarAssignment.from((String) o);                ret.add(assignment);            } else if (o instanceof Map.Entry) {                ret.add((Map.Entry<String, Object>) o);            } else {                throw new IllegalStateException("Expected " + c + " to be a list of strings, but got non-string.");            }        }        return ret;    }    throw new IllegalStateException("Unable to convert config " + c + " to stellar config.  Expected List<String> or Map<String, Object>");}
private Set<String> metron_f2473_0(StellarProcessor processor, List<String> stellarStatementGroup)
{    Set<String> stellarFields = new HashSet<>();    for (String stellarStatementExpr : stellarStatementGroup) {        StellarAssignment assignment = StellarAssignment.from(stellarStatementExpr);        if (assignment.getStatement() != null) {            Set<String> variables = processor.variablesUsed(assignment.getStatement());            if (variables != null) {                stellarFields.addAll(variables);            }        }    }    return stellarFields;}
private Set<String> metron_f2474_0(StellarProcessor processor, Map<String, String> stellarStatementGroup)
{    Set<String> stellarFields = new HashSet<>();    for (String stellarStatement : stellarStatementGroup.values()) {        Set<String> variables = processor.variablesUsed(stellarStatement);        if (variables != null) {            stellarFields.addAll(variables);        }    }    return stellarFields;}
private Map<String, Object> metron_f2475_0(Set<String> stellarFields, JSONObject message)
{    Map<String, Object> messageSegment = new HashMap<>();    if (stellarFields.contains(VariableResolver.ALL_FIELDS)) {                messageSegment.putAll(message);    } else {        for (String variable : stellarFields) {            messageSegment.put(variable, message.get(variable));        }    }    return messageSegment;}
public Map<String, Object> metron_f2476_0()
{    return configuration;}
public void metron_f2477_0(Map<String, Object> configuration)
{    this.configuration = configuration;}
public EnrichmentConfig metron_f2478_0()
{    return enrichment;}
public void metron_f2479_0(EnrichmentConfig enrichment)
{    this.enrichment = enrichment;}
public ThreatIntelConfig metron_f2480_0()
{    return threatIntel;}
public void metron_f2481_0(ThreatIntelConfig threatIntel)
{    this.threatIntel = threatIntel;}
public String metron_f2482_0()
{    return "SensorEnrichmentConfig{" + ", enrichment=" + enrichment + ", threatIntel=" + threatIntel + ", configuration=" + configuration + '}';}
public boolean metron_f2483_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    SensorEnrichmentConfig that = (SensorEnrichmentConfig) o;    if (getEnrichment() != null ? !getEnrichment().equals(that.getEnrichment()) : that.getEnrichment() != null)        return false;    if (getThreatIntel() != null ? !getThreatIntel().equals(that.getThreatIntel()) : that.getThreatIntel() != null)        return false;    return getConfiguration() != null ? getConfiguration().equals(that.getConfiguration()) : that.getConfiguration() == null;}
public int metron_f2484_0()
{    int result = getEnrichment() != null ? getEnrichment().hashCode() : 0;    result = 31 * result + (getEnrichment() != null ? getEnrichment().hashCode() : 0);    result = 31 * result + (getThreatIntel() != null ? getThreatIntel().hashCode() : 0);    result = 31 * result + (getConfiguration() != null ? getConfiguration().hashCode() : 0);    return result;}
public static SensorEnrichmentConfig metron_f2485_0(byte[] config) throws IOException
{    return JSONUtils.INSTANCE.load(new String(config, StandardCharsets.UTF_8), SensorEnrichmentConfig.class);}
public String metron_f2486_0() throws JsonProcessingException
{    return JSONUtils.INSTANCE.toJSON(this, true);}
public Type metron_f2487_0()
{    return type;}
public void metron_f2488_0(Type type)
{    this.type = type;}
public Map<String, List<String>> metron_f2489_0()
{    return fieldToEnrichmentTypes;}
public void metron_f2490_0(Map<String, List<String>> fieldToEnrichmentTypes)
{    this.fieldToEnrichmentTypes = fieldToEnrichmentTypes;}
public String metron_f2491_0()
{    return zkQuorum;}
public void metron_f2492_0(String zkQuorum)
{    this.zkQuorum = zkQuorum;}
public Map<String, FieldList> metron_f2493_0()
{    return sensorToFieldList;}
public void metron_f2494_0(Map<String, FieldList> sensorToFieldList)
{    this.sensorToFieldList = sensorToFieldList;}
public void metron_f2495_0() throws Exception
{    CuratorFramework client = ConfigurationsUtils.getClient(getZkQuorum());    try {        client.start();        updateSensorConfigs(new ZKSourceConfigHandler(client), sensorToFieldList);    } finally {        client.close();    }}
public SensorEnrichmentConfig metron_f2496_0(String sensor) throws Exception
{    SensorEnrichmentConfig sensorEnrichmentConfig = new SensorEnrichmentConfig();    try {        sensorEnrichmentConfig = SensorEnrichmentConfig.fromBytes(ConfigurationsUtils.readSensorEnrichmentConfigBytesFromZookeeper(sensor, client));    } catch (KeeperException.NoNodeException e) {    }    return sensorEnrichmentConfig;}
public void metron_f2497_0(String sensor, SensorEnrichmentConfig config) throws Exception
{    ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(sensor, config.toJSON().getBytes(StandardCharsets.UTF_8), client);}
public static void metron_f2498_1(SourceConfigHandler scHandler, Map<String, FieldList> sensorToFieldList) throws Exception
{    Map<String, SensorEnrichmentConfig> sourceConfigsChanged = new HashMap<>();    for (Map.Entry<String, FieldList> kv : sensorToFieldList.entrySet()) {        SensorEnrichmentConfig config = findConfigBySensorType(scHandler, sourceConfigsChanged, kv.getKey());        Map<String, Object> fieldMap = null;        Map<String, List<String>> fieldToTypeMap = null;        List<String> fieldList = null;        if (kv.getValue().type == Type.THREAT_INTEL) {            fieldMap = config.getThreatIntel().getFieldMap();            if (fieldMap != null) {                fieldList = (List<String>) fieldMap.get(Constants.SIMPLE_HBASE_THREAT_INTEL);            } else {                fieldMap = new HashMap<>();            }            if (fieldList == null) {                fieldList = new ArrayList<>();                fieldMap.put(Constants.SIMPLE_HBASE_THREAT_INTEL, fieldList);            }            fieldToTypeMap = config.getThreatIntel().getFieldToTypeMap();            if (fieldToTypeMap == null) {                fieldToTypeMap = new HashMap<>();                config.getThreatIntel().setFieldToTypeMap(fieldToTypeMap);            }        } else if (kv.getValue().type == Type.ENRICHMENT) {            fieldMap = config.getEnrichment().getFieldMap();            if (fieldMap != null) {                fieldList = (List<String>) fieldMap.get(Constants.SIMPLE_HBASE_ENRICHMENT);            } else {                fieldMap = new HashMap<>();            }            if (fieldList == null) {                fieldList = new ArrayList<>();                fieldMap.put(Constants.SIMPLE_HBASE_ENRICHMENT, fieldList);            }            fieldToTypeMap = config.getEnrichment().getFieldToTypeMap();            if (fieldToTypeMap == null) {                fieldToTypeMap = new HashMap<>();                config.getEnrichment().setFieldToTypeMap(fieldToTypeMap);            }        }        if (fieldToTypeMap == null || fieldMap == null) {                        continue;        }                {            HashSet<String> fieldSet = new HashSet<>(fieldList);            List<String> additionalFields = new ArrayList<>();            for (String field : kv.getValue().getFieldToEnrichmentTypes().keySet()) {                if (!fieldSet.contains(field)) {                    additionalFields.add(field);                }            }                        if (additionalFields.size() > 0) {                                fieldList.addAll(additionalFields);                sourceConfigsChanged.put(kv.getKey(), config);            }        }                {            for (Map.Entry<String, List<String>> fieldToType : kv.getValue().getFieldToEnrichmentTypes().entrySet()) {                String field = fieldToType.getKey();                final HashSet<String> types = new HashSet<>(fieldToType.getValue());                int sizeBefore = 0;                if (fieldToTypeMap.containsKey(field)) {                    List<String> typeList = (List<String>) fieldToTypeMap.get(field);                    sizeBefore = new HashSet<>(typeList).size();                    types.addAll(typeList);                }                int sizeAfter = types.size();                boolean changed = sizeBefore != sizeAfter;                if (changed) {                    fieldToTypeMap.put(field, new ArrayList<String>() {                        {                            addAll(types);                        }                    });                    sourceConfigsChanged.put(kv.getKey(), config);                }            }        }    }    for (Map.Entry<String, SensorEnrichmentConfig> kv : sourceConfigsChanged.entrySet()) {        scHandler.persistConfig(kv.getKey(), kv.getValue());    }}
private static SensorEnrichmentConfig metron_f2499_1(SourceConfigHandler scHandler, Map<String, SensorEnrichmentConfig> sourceConfigsChanged, String key) throws Exception
{    SensorEnrichmentConfig config = sourceConfigsChanged.get(key);    if (config == null) {        config = scHandler.readConfig(key);        if (LOG.isDebugEnabled()) {                    }    }    return config;}
public String metron_f2500_0()
{    return name;}
public void metron_f2501_0(String name)
{    this.name = name;}
public String metron_f2502_0()
{    return comment;}
public void metron_f2503_0(String comment)
{    this.comment = comment;}
public String metron_f2504_0()
{    return rule;}
public void metron_f2505_0(String rule)
{    this.rule = rule;}
public String metron_f2506_0()
{    return scoreExpression;}
public void metron_f2507_0(Object scoreExpression)
{    if (scoreExpression instanceof Number) {                scoreExpression = Number.class.cast(scoreExpression).toString();    } else if (scoreExpression instanceof String) {                scoreExpression = String.class.cast(scoreExpression);    } else {        throw new IllegalArgumentException(String.format("Expected 'score' to be number or string, but got '%s'", scoreExpression));    }    this.scoreExpression = scoreExpression.toString();}
public String metron_f2508_0()
{    return reason;}
public void metron_f2509_0(String reason)
{    this.reason = reason;}
public boolean metron_f2510_0(Object o)
{    if (this == o)        return true;    if (!(o instanceof RiskLevelRule))        return false;    RiskLevelRule that = (RiskLevelRule) o;    return Objects.equals(name, that.name) && Objects.equals(comment, that.comment) && Objects.equals(rule, that.rule) && Objects.equals(scoreExpression, that.scoreExpression) && Objects.equals(reason, that.reason);}
public int metron_f2511_0()
{    return Objects.hash(name, comment, rule, scoreExpression, reason);}
public String metron_f2512_0()
{    return "RiskLevelRule{" + "name='" + name + '\'' + ", comment='" + comment + '\'' + ", rule='" + rule + '\'' + ", scoreExpression='" + scoreExpression + '\'' + ", reason='" + reason + '\'' + '}';}
public String metron_f2513_0()
{    return reason;}
public RiskLevelRule metron_f2514_0()
{    return rule;}
public Number metron_f2515_0()
{    return score;}
public boolean metron_f2516_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof RuleScore)) {        return false;    }    RuleScore ruleScore = (RuleScore) o;    return Objects.equals(rule, ruleScore.rule) && Objects.equals(reason, ruleScore.reason) && Objects.equals(score, ruleScore.score);}
public int metron_f2517_0()
{    return Objects.hash(rule, reason, score);}
public String metron_f2518_0()
{    return "RuleScore{" + "rule=" + rule + ", reason='" + reason + '\'' + ", score=" + score + '}';}
public ThreatTriageConfig metron_f2519_0()
{    return triageConfig;}
public void metron_f2520_0(ThreatTriageConfig triageConfig)
{    this.triageConfig = triageConfig;}
public boolean metron_f2521_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    if (!super.equals(o))        return false;    ThreatIntelConfig that = (ThreatIntelConfig) o;    return getTriageConfig() != null ? getTriageConfig().equals(that.getTriageConfig()) : that.getTriageConfig() == null;}
public int metron_f2522_0()
{    int result = super.hashCode();    result = 31 * result + (getTriageConfig() != null ? getTriageConfig().hashCode() : 0);    return result;}
public String metron_f2523_0()
{    return "ThreatIntelConfig{" + "triageConfig=" + triageConfig + '}';}
public Double metron_f2524_0()
{    return score;}
public void metron_f2525_0(Double score)
{    this.score = score;}
public List<RuleScore> metron_f2526_0()
{    return ruleScores;}
public void metron_f2527_0(RuleScore score)
{    this.ruleScores.add(score);}
public boolean metron_f2528_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ThreatScore that = (ThreatScore) o;    if (score != null ? !score.equals(that.score) : that.score != null)        return false;    return ruleScores != null ? ruleScores.equals(that.ruleScores) : that.ruleScores == null;}
public int metron_f2529_0()
{    int result = score != null ? score.hashCode() : 0;    result = 31 * result + (ruleScores != null ? ruleScores.hashCode() : 0);    return result;}
public String metron_f2530_0()
{    return "ThreatScore{" + "score=" + score + ", ruleScores=" + ruleScores + '}';}
public List<RiskLevelRule> metron_f2531_0()
{    return riskLevelRules;}
public void metron_f2532_0(List<RiskLevelRule> riskLevelRules)
{    List<RiskLevelRule> rules = new ArrayList<>();    Set<String> ruleIndex = new HashSet<>();    StellarPredicateProcessor predicateProcessor = new StellarPredicateProcessor();    StellarProcessor processor = new StellarProcessor();    for (RiskLevelRule rule : riskLevelRules) {        if (rule.getRule() == null || rule.getScoreExpression() == null) {            throw new IllegalStateException("Risk level rules must contain both a rule and a score.");        }        if (ruleIndex.contains(rule.getRule())) {            continue;        } else {            ruleIndex.add(rule.getRule());        }                predicateProcessor.validate(rule.getRule());        if (rule.getReason() != null) {            processor.validate(rule.getReason());        }        rules.add(rule);    }    this.riskLevelRules = rules;}
public Aggregators metron_f2533_0()
{    return aggregator;}
public void metron_f2534_0(String aggregator)
{    try {        this.aggregator = Aggregators.valueOf(aggregator);    } catch (IllegalArgumentException iae) {        throw new IllegalArgumentException("Unable to load aggregator of " + aggregator + ".  Valid aggregators are " + Joiner.on(',').join(Aggregators.values()));    }}
public Map<String, Object> metron_f2535_0()
{    return aggregationConfig;}
public void metron_f2536_0(Map<String, Object> aggregationConfig)
{    this.aggregationConfig = aggregationConfig;}
public String metron_f2537_0()
{    return "ThreatTriageConfig{" + "riskLevelRules=" + riskLevelRules + ", aggregator=" + aggregator + ", aggregationConfig=" + aggregationConfig + '}';}
public boolean metron_f2538_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ThreatTriageConfig that = (ThreatTriageConfig) o;    if (riskLevelRules != null ? !riskLevelRules.equals(that.riskLevelRules) : that.riskLevelRules != null)        return false;    if (aggregator != that.aggregator)        return false;    return aggregationConfig != null ? aggregationConfig.equals(that.aggregationConfig) : that.aggregationConfig == null;}
public int metron_f2539_0()
{    int result = riskLevelRules != null ? riskLevelRules.hashCode() : 0;    result = 31 * result + (aggregator != null ? aggregator.hashCode() : 0);    result = 31 * result + (aggregationConfig != null ? aggregationConfig.hashCode() : 0);    return result;}
public String metron_f2540_0()
{    return "enrichments";}
public Object metron_f2541_0(String s) throws IOException
{    return JSONUtils.INSTANCE.load(s, SensorEnrichmentConfig.class);}
public void metron_f2542_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(sensorType, configData, client);}
public SensorEnrichmentConfig metron_f2543_0(String sensorType)
{    return (SensorEnrichmentConfig) getConfigurations().get(getKey(sensorType));}
public void metron_f2544_0(String sensorType, byte[] data) throws IOException
{    updateSensorEnrichmentConfig(sensorType, new ByteArrayInputStream(data));}
public void metron_f2545_0(String sensorType, InputStream io) throws IOException
{    SensorEnrichmentConfig sensorEnrichmentConfig = JSONUtils.INSTANCE.load(io, SensorEnrichmentConfig.class);    updateSensorEnrichmentConfig(sensorType, sensorEnrichmentConfig);}
public void metron_f2546_0(String sensorType, SensorEnrichmentConfig sensorEnrichmentConfig)
{    getConfigurations().put(getKey(sensorType), sensorEnrichmentConfig);}
public void metron_f2547_0(String sensorType)
{    getConfigurations().remove(getKey(sensorType));}
public int metron_f2548_0()
{    return getAs(BATCH_SIZE_CONF, getGlobalConfig(true), DEFAULT_KAFKA_BATCH_SIZE, Integer.class);}
public int metron_f2549_0()
{    return getAs(BATCH_TIMEOUT_CONF, getGlobalConfig(true), 0, Integer.class);}
public List<String> metron_f2550_0()
{    List<String> ret = new ArrayList<>();    for (String keyedSensor : getConfigurations().keySet()) {        if (!keyedSensor.isEmpty() && keyedSensor.startsWith(ConfigurationType.ENRICHMENT.getTypeName())) {            ret.add(keyedSensor.substring(ConfigurationType.ENRICHMENT.getTypeName().length() + 1));        }    }    return ret;}
public static String metron_f2551_0(String sensorType)
{    return ConfigurationType.ENRICHMENT.getTypeName() + "." + sensorType;}
public List<String> metron_f2552_0()
{    return input;}
public void metron_f2553_0(Object inputFields)
{    if (inputFields instanceof String) {        this.input = ImmutableList.of(inputFields.toString());    } else if (inputFields instanceof List) {        this.input = (List<String>) inputFields;    }}
public List<String> metron_f2554_0()
{    return output;}
public void metron_f2555_0(Object outputField)
{    if (outputField instanceof String) {        this.output = ImmutableList.of(outputField.toString());    } else if (outputField instanceof List) {        this.output = (List<String>) outputField;    }}
public Map<String, Object> metron_f2556_0()
{    return config;}
public void metron_f2557_0(LinkedHashMap<String, Object> config)
{    this.config = config;}
public String metron_f2558_0()
{    return transformationName;}
public FieldTransformation metron_f2559_0()
{    return transformation;}
public void metron_f2560_0(String transformation)
{    this.transformationName = transformation;    this.transformation = FieldTransformations.get(transformation);}
public void metron_f2561_0()
{    if (!initialized) {        if (getTransformation() == null) {            throw new IllegalStateException("Mapping cannot be null.");        }        if (output == null || output.isEmpty()) {            if (input == null || input.isEmpty()) {                                output = null;                input = null;            } else {                output = input;            }        }        initialized = true;    }}
public Map<String, Object> metron_f2562_0(JSONObject input, Context context, Map<String, Object>... sensorConfig)
{    if (getInput() == null || getInput().isEmpty()) {        return transformation.map(input, getOutput(), config, context, sensorConfig);    } else {        Map<String, Object> in = new HashMap<>();        for (String inputField : getInput()) {            in.put(inputField, input.get(inputField));        }        return transformation.map(in, getOutput(), config, context, sensorConfig);    }}
public void metron_f2563_0(JSONObject message, Context context, Map<String, Object>... sensorConfig)
{    Map<String, Object> currentValue = transform(message, context, sensorConfig);    if (currentValue != null) {        for (Map.Entry<String, Object> kv : currentValue.entrySet()) {            if (kv.getValue() == null) {                message.remove(kv.getKey());            } else {                message.put(kv.getKey(), kv.getValue());            }        }    }}
public String metron_f2564_0()
{    return "MappingHandler{" + "input=" + input + ", output='" + output + '\'' + ", transformation=" + transformation + ", config=" + config + '}';}
public boolean metron_f2565_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    FieldTransformer that = (FieldTransformer) o;    if (getInput() != null ? !getInput().equals(that.getInput()) : that.getInput() != null)        return false;    if (getOutput() != null ? !getOutput().equals(that.getOutput()) : that.getOutput() != null)        return false;    if (getTransformation() != null ? !getTransformation().equals(that.getTransformation()) : that.getTransformation() != null)        return false;    return getConfig() != null ? getConfig().equals(that.getConfig()) : that.getConfig() == null;}
public int metron_f2566_0()
{    int result = getInput() != null ? getInput().hashCode() : 0;    result = 31 * result + (getOutput() != null ? getOutput().hashCode() : 0);    result = 31 * result + (getTransformation() != null ? getTransformation().hashCode() : 0);    result = 31 * result + (getConfig() != null ? getConfig().hashCode() : 0);    return result;}
public T metron_f2567_0(Map<String, Object> config, Class<T> clazz)
{    Object o = config.get(key);    if (o == null) {        return null;    }    return clazz.cast(o);}
public FieldValidation metron_f2568_0()
{    return validation;}
public List<String> metron_f2569_0()
{    return input;}
public Map<String, Object> metron_f2570_0()
{    return config;}
public boolean metron_f2571_0(JSONObject inputData, Map<String, Object> globalConfig, Context context)
{    Map<String, Object> in = inputData;    if (input != null && !input.isEmpty()) {        in = new HashMap<>();        for (String i : input) {            Object o = inputData.get(i);            in.put(i, o);        }    }    return validation.isValid(in, config, globalConfig, context);}
public static List<FieldValidator> metron_f2572_0(Map<String, Object> globalConfig)
{    List<FieldValidator> validators = new ArrayList<>();    List<Object> validations = (List<Object>) Config.FIELD_VALIDATIONS.get(globalConfig, List.class);    if (validations != null) {        for (Object o : validations) {            FieldValidator f = new FieldValidator(o);            f.getValidation().initialize(f.getConfig(), globalConfig);            validators.add(new FieldValidator(o));        }    }    return validators;}
public boolean metron_f2573_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    FieldValidator that = (FieldValidator) o;    if (getValidation() != null ? !getValidation().equals(that.getValidation()) : that.getValidation() != null)        return false;    if (getInput() != null ? !getInput().equals(that.getInput()) : that.getInput() != null)        return false;    return getConfig() != null ? getConfig().equals(that.getConfig()) : that.getConfig() == null;}
public int metron_f2574_0()
{    int result = getValidation() != null ? getValidation().hashCode() : 0;    result = 31 * result + (getInput() != null ? getInput().hashCode() : 0);    result = 31 * result + (getConfig() != null ? getConfig().hashCode() : 0);    return result;}
public String metron_f2575_0()
{    return "FieldValidator{" + "validation=" + validation + ", input=" + input + ", config=" + config + '}';}
public String metron_f2576_0()
{    return "global";}
public String metron_f2577_0()
{    return ".";}
public Object metron_f2578_0(String s) throws IOException
{    return JSONUtils.INSTANCE.load(s, JSONUtils.MAP_SUPPLIER);}
public void metron_f2579_0(String sensorType, byte[] configData, CuratorFramework client)
{    throw new UnsupportedOperationException("Global configs are not per-sensor");}
public String metron_f2580_0()
{    return "indexing";}
public Object metron_f2581_0(String s) throws IOException
{    return JSONUtils.INSTANCE.load(s, JSONUtils.MAP_SUPPLIER);}
public void metron_f2582_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    ConfigurationsUtils.writeSensorIndexingConfigToZookeeper(sensorType, configData, client);}
public Map<String, Object> metron_f2583_0(String sensorType, boolean emptyMapOnNonExistent)
{    Map<String, Object> ret = (Map<String, Object>) getConfigurations().get(getKey(sensorType));    if (ret == null) {        return emptyMapOnNonExistent ? new HashMap<>() : null;    } else {        return ret;    }}
public Map<String, Object> metron_f2584_0(String sensorType)
{    return getSensorIndexingConfig(sensorType, true);}
public List<String> metron_f2585_0()
{    List<String> ret = new ArrayList<>();    for (String keyedSensor : getConfigurations().keySet()) {        if (!keyedSensor.isEmpty() && keyedSensor.startsWith(ConfigurationType.INDEXING.getTypeName())) {            ret.add(keyedSensor.substring(ConfigurationType.INDEXING.getTypeName().length() + 1));        }    }    return ret;}
public void metron_f2586_0(String sensorType)
{    getConfigurations().remove(getKey(sensorType));}
public Map<String, Object> metron_f2587_0(String sensorType, String writerName)
{    String key = getKey(sensorType);    Map<String, Object> ret = (Map<String, Object>) getConfigurations().get(key);    if (ret == null) {        return new HashMap();    } else {        Map<String, Object> writerConfig = (Map<String, Object>) ret.get(writerName);        return writerConfig != null ? writerConfig : new HashMap<>();    }}
public void metron_f2588_0(String sensorType, byte[] data) throws IOException
{    updateSensorIndexingConfig(sensorType, new ByteArrayInputStream(data));}
public void metron_f2589_0(String sensorType, InputStream io) throws IOException
{    Map<String, Object> sensorIndexingConfig = JSONUtils.INSTANCE.load(io, JSONUtils.MAP_SUPPLIER);    updateSensorIndexingConfig(sensorType, sensorIndexingConfig);}
public void metron_f2590_0(String sensorType, Map<String, Object> sensorIndexingConfig)
{    getConfigurations().put(getKey(sensorType), sensorIndexingConfig);}
public static String metron_f2591_0(String sensorType)
{    return ConfigurationType.INDEXING.getTypeName() + "." + sensorType;}
public boolean metron_f2592_0(String sensorName, String writerName)
{    Map<String, Object> ret = (Map<String, Object>) getConfigurations().get(getKey(sensorName));    if (ret == null) {        return true;    } else {        Map<String, Object> writerConfig = (Map<String, Object>) ret.get(writerName);        return writerConfig != null ? false : true;    }}
public int metron_f2593_0(String sensorName, String writerName)
{    return getBatchSize(getSensorIndexingConfig(sensorName, writerName));}
public int metron_f2594_0(String sensorName, String writerName)
{    return getBatchTimeout(getSensorIndexingConfig(sensorName, writerName));}
public List<Integer> metron_f2595_0(String writerName)
{                        String keyPrefixString = getKey("");    int prefixStringLength = keyPrefixString.length();    List<Integer> configuredBatchTimeouts = new ArrayList<>();    for (String sensorKeyString : getConfigurations().keySet()) {        if (sensorKeyString.startsWith(keyPrefixString)) {            String configuredSensorName = sensorKeyString.substring(prefixStringLength);            configuredBatchTimeouts.add(getBatchTimeout(configuredSensorName, writerName));        }    }    return configuredBatchTimeouts;}
public String metron_f2596_0(String sensorName, String writerName)
{    return getIndex(getSensorIndexingConfig(sensorName, writerName), sensorName);}
public boolean metron_f2597_0(String sensorName, String writerName)
{    return isEnabled(getSensorIndexingConfig(sensorName, writerName));}
public String metron_f2598_0(String sensorName, String writerName)
{    return getOutputPathFunction(getSensorIndexingConfig(sensorName, writerName), sensorName);}
public String metron_f2599_0(String sensorName, String writerName)
{    return getFieldNameConverter(getSensorIndexingConfig(sensorName, writerName), sensorName);}
public boolean metron_f2600_0(String sensorName, String writerName)
{    return isSetDocumentId(getGlobalConfig(true), getSensorIndexingConfig(sensorName, writerName));}
public static boolean metron_f2601_0(Map<String, Object> conf)
{    return getAs(ENABLED_CONF, conf, true, Boolean.class);}
public static int metron_f2602_0(Map<String, Object> conf)
{    return getAs(BATCH_SIZE_CONF, conf, 1, Integer.class);}
public static int metron_f2603_0(Map<String, Object> conf)
{    return getAs(BATCH_TIMEOUT_CONF, conf, 0, Integer.class);}
public static String metron_f2604_0(Map<String, Object> conf, String sensorName)
{    return getAs(INDEX_CONF, conf, sensorName, String.class);}
public static String metron_f2605_0(Map<String, Object> conf, String sensorName)
{    return getAs(OUTPUT_PATH_FUNCTION_CONF, conf, "", String.class);}
public static String metron_f2606_0(Map<String, Object> conf, String sensorName)
{    return getAs(FIELD_NAME_CONVERTER_CONF, conf, "", String.class);}
public static boolean metron_f2607_0(Map<String, Object> globalConf, Map<String, Object> sensorConf)
{    return getAs(SET_DOCUMENT_ID_CONF, sensorConf, getAs(GLOBAL_ELASTICSEARCH_SET_DOCUMENT_ID_CONF, globalConf, false, Boolean.class), Boolean.class);}
public static Map<String, Object> metron_f2608_0(Map<String, Object> conf, boolean enabled)
{    Map<String, Object> ret = conf == null ? new HashMap<>() : conf;    ret.put(ENABLED_CONF, enabled);    return ret;}
public static Map<String, Object> metron_f2609_0(Map<String, Object> conf, int batchSize)
{    Map<String, Object> ret = conf == null ? new HashMap<>() : conf;    ret.put(BATCH_SIZE_CONF, batchSize);    return ret;}
public static Map<String, Object> metron_f2610_0(Map<String, Object> conf, int batchTimeout)
{    Map<String, Object> ret = conf == null ? new HashMap<>() : conf;    ret.put(BATCH_TIMEOUT_CONF, batchTimeout);    return ret;}
public static Map<String, Object> metron_f2611_0(Map<String, Object> conf, String index)
{    Map<String, Object> ret = conf == null ? new HashMap<>() : conf;    ret.put(INDEX_CONF, index);    return ret;}
public static Map<String, Object> metron_f2612_0(Map<String, Object> conf, String index)
{    Map<String, Object> ret = conf == null ? new HashMap<>() : conf;    ret.put(FIELD_NAME_CONVERTER_CONF, index);    return ret;}
public String metron_f2613_0()
{    return "parsers";}
public Object metron_f2614_0(String s) throws IOException
{    return JSONUtils.INSTANCE.load(s, SensorParserConfig.class);}
public void metron_f2615_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    ConfigurationsUtils.writeSensorParserConfigToZookeeper(sensorType, configData, client);}
public SensorParserConfig metron_f2616_0(String sensorType)
{    return (SensorParserConfig) getConfigurations().get(getKey(sensorType));}
public void metron_f2617_0(String sensorType, byte[] data) throws IOException
{    updateSensorParserConfig(sensorType, new ByteArrayInputStream(data));}
public void metron_f2618_0(String sensorType, InputStream io) throws IOException
{    SensorParserConfig sensorParserConfig = JSONUtils.INSTANCE.load(io, SensorParserConfig.class);    updateSensorParserConfig(sensorType, sensorParserConfig);}
public void metron_f2619_0(String sensorType, SensorParserConfig sensorParserConfig)
{    sensorParserConfig.init();    getConfigurations().put(getKey(sensorType), sensorParserConfig);}
public Map<String, SensorParserGroup> metron_f2620_0()
{    Object groups = getGlobalConfig(true).getOrDefault(PARSER_GROUPS_CONF, new ArrayList<>());    Collection<SensorParserGroup> sensorParserGroups = JSONUtils.INSTANCE.getMapper().convertValue(groups, new TypeReference<Collection<SensorParserGroup>>() {        {        }    });    return sensorParserGroups.stream().collect(Collectors.toMap(SensorParserGroup::getName, sensorParserGroup -> sensorParserGroup));}
public List<String> metron_f2621_0()
{    List<String> ret = new ArrayList<>();    for (String keyedSensor : getConfigurations().keySet()) {        if (!keyedSensor.isEmpty() && keyedSensor.startsWith(ConfigurationType.PARSER.getTypeName())) {            ret.add(keyedSensor.substring(ConfigurationType.PARSER.getTypeName().length() + 1));        }    }    return ret;}
public void metron_f2622_0(String sensorType)
{    getConfigurations().remove(getKey(sensorType));}
public static String metron_f2623_0(String sensorType)
{    return ConfigurationType.PARSER.getTypeName() + "." + sensorType;}
public String metron_f2624_0()
{    return profile;}
public void metron_f2625_0(String profile)
{    this.profile = profile;}
public ProfileConfig metron_f2626_0(String profile)
{    this.profile = profile;    return this;}
public String metron_f2627_0()
{    return foreach;}
public void metron_f2628_0(String foreach)
{    this.foreach = foreach;}
public ProfileConfig metron_f2629_0(String foreach)
{    this.foreach = foreach;    return this;}
public String metron_f2630_0()
{    return onlyif;}
public void metron_f2631_0(String onlyif)
{    this.onlyif = onlyif;}
public ProfileConfig metron_f2632_0(String onlyif)
{    this.onlyif = onlyif;    return this;}
public Map<String, String> metron_f2633_0()
{    return init;}
public void metron_f2634_0(Map<String, String> init)
{    this.init = init;}
public ProfileConfig metron_f2635_0(Map<String, String> init)
{    this.init.putAll(init);    return this;}
public ProfileConfig metron_f2636_0(String var, String expression)
{    this.init.put(var, expression);    return this;}
public Map<String, String> metron_f2637_0()
{    return update;}
public void metron_f2638_0(Map<String, String> update)
{    this.update = update;}
public ProfileConfig metron_f2639_0(Map<String, String> update)
{    this.update.putAll(update);    return this;}
public ProfileConfig metron_f2640_0(String var, String expression)
{    this.update.put(var, expression);    return this;}
public List<String> metron_f2641_0()
{    return groupBy;}
public void metron_f2642_0(List<String> groupBy)
{    this.groupBy = groupBy;}
public ProfileConfig metron_f2643_0(List<String> groupBy)
{    this.groupBy = groupBy;    return this;}
public ProfileResult metron_f2644_0()
{    return result;}
public void metron_f2645_0(ProfileResult result)
{    this.result = result;}
public ProfileConfig metron_f2646_0(String profileExpression)
{    this.result = new ProfileResult(profileExpression);    return this;}
public Long metron_f2647_0()
{    return expires;}
public void metron_f2648_0(Long expiresDays)
{    this.expires = expiresDays;}
public ProfileConfig metron_f2649_0(Long expiresDays)
{    this.expires = TimeUnit.DAYS.toMillis(expiresDays);    return this;}
public boolean metron_f2650_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ProfileConfig that = (ProfileConfig) o;    return new EqualsBuilder().append(profile, that.profile).append(foreach, that.foreach).append(onlyif, that.onlyif).append(init, that.init).append(update, that.update).append(groupBy, that.groupBy).append(result, that.result).append(expires, that.expires).isEquals();}
public int metron_f2651_0()
{    return new HashCodeBuilder(17, 37).append(profile).append(foreach).append(onlyif).append(init).append(update).append(groupBy).append(result).append(expires).toHashCode();}
public String metron_f2652_0()
{    return new ToStringBuilder(this).append("profile", profile).append("foreach", foreach).append("onlyif", onlyif).append("init", init).append("update", update).append("groupBy", groupBy).append("result", result).append("expires", expires).toString();}
public static ProfileConfig metron_f2653_0(byte[] bytes) throws IOException
{    return JSONUtils.INSTANCE.load(new String(bytes, StandardCharsets.UTF_8), ProfileConfig.class);}
public static ProfileConfig metron_f2654_0(String json) throws IOException
{    return JSONUtils.INSTANCE.load(json, ProfileConfig.class);}
public String metron_f2655_0() throws JsonProcessingException
{    return JSONUtils.INSTANCE.toJSON(this, true);}
public List<ProfileConfig> metron_f2656_0()
{    return profiles;}
public void metron_f2657_0(List<ProfileConfig> profiles)
{    this.profiles = profiles;}
public ProfilerConfig metron_f2658_0(ProfileConfig profileConfig)
{    this.profiles.add(profileConfig);    return this;}
public String metron_f2659_0()
{    return timestampField;}
public Optional<String> metron_f2660_0()
{    return Optional.ofNullable(timestampField);}
public void metron_f2661_0(String timestampField)
{    this.timestampField = timestampField;}
public void metron_f2662_0(Optional<String> timestampField)
{    this.timestampField = timestampField.orElse(null);}
public ProfilerConfig metron_f2663_0(Optional<String> timestampField)
{    this.timestampField = timestampField.orElse(null);    return this;}
public String metron_f2664_0()
{    return new ToStringBuilder(this).append("profiles", profiles).append("timestampField", timestampField).toString();}
public boolean metron_f2665_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ProfilerConfig that = (ProfilerConfig) o;    return new EqualsBuilder().append(profiles, that.profiles).append(timestampField, that.timestampField).isEquals();}
public int metron_f2666_0()
{    return new HashCodeBuilder(17, 37).append(profiles).append(timestampField).toHashCode();}
public static ProfilerConfig metron_f2667_0(byte[] bytes) throws IOException
{    return JSONUtils.INSTANCE.load(new String(bytes, StandardCharsets.UTF_8), ProfilerConfig.class);}
public static ProfilerConfig metron_f2668_0(String json) throws IOException
{    return JSONUtils.INSTANCE.load(json, ProfilerConfig.class);}
public String metron_f2669_0() throws JsonProcessingException
{    return JSONUtils.INSTANCE.toJSON(this, true);}
public ProfilerConfig metron_f2670_0()
{    return (ProfilerConfig) getConfigurations().get(getKey());}
public void metron_f2671_0(byte[] data) throws IOException
{    updateProfilerConfig(new ByteArrayInputStream(data));}
public void metron_f2672_0(InputStream io) throws IOException
{    ProfilerConfig config = JSONUtils.INSTANCE.load(io, ProfilerConfig.class);    updateProfilerConfig(config);}
public void metron_f2673_0(ProfilerConfig config)
{    getConfigurations().put(getKey(), config);}
public static String metron_f2674_0()
{    return ConfigurationType.PROFILER.getTypeName();}
public void metron_f2675_0()
{    configurations.remove(getKey());}
public int metron_f2676_0()
{    return getAs(BATCH_SIZE_CONF, getGlobalConfig(true), DEFAULT_KAFKA_BATCH_SIZE, Integer.class);}
public int metron_f2677_0()
{    return getAs(BATCH_TIMEOUT_CONF, getGlobalConfig(true), 0, Integer.class);}
public ProfileResultExpressions metron_f2678_0()
{    return profileExpressions;}
public void metron_f2679_0(ProfileResultExpressions profileExpressions)
{    this.profileExpressions = profileExpressions;}
public ProfileTriageExpressions metron_f2680_0()
{    return triageExpressions;}
public void metron_f2681_0(ProfileTriageExpressions triageExpressions)
{    this.triageExpressions = triageExpressions;}
public String metron_f2682_0()
{    return "ProfileResult{" + "profileExpressions=" + profileExpressions + ", triageExpressions=" + triageExpressions + '}';}
public boolean metron_f2683_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ProfileResult that = (ProfileResult) o;    if (profileExpressions != null ? !profileExpressions.equals(that.profileExpressions) : that.profileExpressions != null)        return false;    return triageExpressions != null ? triageExpressions.equals(that.triageExpressions) : that.triageExpressions == null;}
public int metron_f2684_0()
{    int result = profileExpressions != null ? profileExpressions.hashCode() : 0;    result = 31 * result + (triageExpressions != null ? triageExpressions.hashCode() : 0);    return result;}
public String metron_f2685_0()
{    return expression;}
public void metron_f2686_0(String expression)
{    this.expression = expression;}
public String metron_f2687_0()
{    return "ProfileResultExpressions{" + "expression='" + expression + '\'' + '}';}
public boolean metron_f2688_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ProfileResultExpressions that = (ProfileResultExpressions) o;    return expression != null ? expression.equals(that.expression) : that.expression == null;}
public int metron_f2689_0()
{    return expression != null ? expression.hashCode() : 0;}
public String metron_f2690_0(String name)
{    return expressions.get(name);}
public Map<String, String> metron_f2691_0()
{    return expressions;}
public void metron_f2692_0(Map<String, String> expressions)
{    this.expressions = expressions;}
public String metron_f2693_0()
{    return "ProfileTriageExpressions{" + "expressions=" + expressions + '}';}
public boolean metron_f2694_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ProfileTriageExpressions that = (ProfileTriageExpressions) o;    return getExpressions() != null ? getExpressions().equals(that.getExpressions()) : that.getExpressions() == null;}
public int metron_f2695_0()
{    return getExpressions() != null ? getExpressions().hashCode() : 0;}
public String metron_f2696_0()
{    return "profiler";}
public String metron_f2697_0()
{    return ".";}
public Object metron_f2698_0(String s) throws IOException
{    return JSONUtils.INSTANCE.load(s, ProfilerConfig.class);}
public void metron_f2699_0(String sensorType, byte[] configData, CuratorFramework client) throws Exception
{    throw new UnsupportedOperationException("Profiler configs are not per-sensor");}
public RawMessageStrategy metron_f2700_0()
{    return rawMessageStrategy;}
public void metron_f2701_0(String rawMessageSupplierName)
{    this.rawMessageStrategy = RawMessageStrategies.valueOf(rawMessageSupplierName);}
public Map<String, Object> metron_f2702_0()
{    return rawMessageStrategyConfig;}
public void metron_f2703_0(Map<String, Object> rawMessageStrategyConfig)
{    this.rawMessageStrategyConfig = rawMessageStrategyConfig;}
public Map<String, Object> metron_f2704_0()
{    return cacheConfig;}
public void metron_f2705_0(Map<String, Object> cacheConfig)
{    this.cacheConfig = cacheConfig;}
public Integer metron_f2706_0()
{    return numWorkers;}
public void metron_f2707_0(Integer numWorkers)
{    this.numWorkers = numWorkers;}
public Integer metron_f2708_0()
{    return numAckers;}
public void metron_f2709_0(Integer numAckers)
{    this.numAckers = numAckers;}
public Integer metron_f2710_0()
{    return spoutParallelism;}
public void metron_f2711_0(Integer spoutParallelism)
{    this.spoutParallelism = spoutParallelism;}
public Integer metron_f2712_0()
{    return spoutNumTasks;}
public void metron_f2713_0(Integer spoutNumTasks)
{    this.spoutNumTasks = spoutNumTasks;}
public Integer metron_f2714_0()
{    return parserParallelism;}
public void metron_f2715_0(Integer parserParallelism)
{    this.parserParallelism = parserParallelism;}
public Integer metron_f2716_0()
{    return parserNumTasks;}
public void metron_f2717_0(Integer parserNumTasks)
{    this.parserNumTasks = parserNumTasks;}
public Integer metron_f2718_0()
{    return errorWriterParallelism;}
public void metron_f2719_0(Integer errorWriterParallelism)
{    this.errorWriterParallelism = errorWriterParallelism;}
public Integer metron_f2720_0()
{    return errorWriterNumTasks;}
public void metron_f2721_0(Integer errorWriterNumTasks)
{    this.errorWriterNumTasks = errorWriterNumTasks;}
public Map<String, Object> metron_f2722_0()
{    return spoutConfig;}
public void metron_f2723_0(Map<String, Object> spoutConfig)
{    this.spoutConfig = spoutConfig;}
public String metron_f2724_0()
{    return securityProtocol;}
public void metron_f2725_0(String securityProtocol)
{    this.securityProtocol = securityProtocol;}
public Map<String, Object> metron_f2726_0()
{    return stormConfig;}
public void metron_f2727_0(Map<String, Object> stormConfig)
{    this.stormConfig = stormConfig;}
public Boolean metron_f2728_0()
{    return Optional.ofNullable(mergeMetadata).orElse(getRawMessageStrategy().mergeMetadataDefault());}
public void metron_f2729_0(Boolean mergeMetadata)
{    this.mergeMetadata = mergeMetadata;}
public Boolean metron_f2730_0()
{    return Optional.ofNullable(readMetadata).orElse(getRawMessageStrategy().readMetadataDefault());}
public void metron_f2731_0(Boolean readMetadata)
{    this.readMetadata = readMetadata;}
public String metron_f2732_0()
{    return errorWriterClassName;}
public void metron_f2733_0(String errorWriterClassName)
{    this.errorWriterClassName = errorWriterClassName;}
public String metron_f2734_0()
{    return writerClassName;}
public void metron_f2735_0(String classNames)
{    this.writerClassName = classNames;}
public List<FieldTransformer> metron_f2736_0()
{    return fieldTransformations;}
public void metron_f2737_0(List<FieldTransformer> fieldTransformations)
{    this.fieldTransformations = fieldTransformations;}
public String metron_f2738_0()
{    return filterClassName;}
public void metron_f2739_0(String filterClassName)
{    this.filterClassName = filterClassName;}
public String metron_f2740_0()
{    return parserClassName;}
public void metron_f2741_0(String parserClassName)
{    this.parserClassName = parserClassName;}
public String metron_f2742_0()
{    return sensorTopic;}
public void metron_f2743_0(String sensorTopic)
{    this.sensorTopic = sensorTopic;}
public String metron_f2744_0()
{    return outputTopic;}
public void metron_f2745_0(String outputTopic)
{    this.outputTopic = outputTopic;}
public String metron_f2746_0()
{    return errorTopic;}
public void metron_f2747_0(String errorTopic)
{    this.errorTopic = errorTopic;}
public Map<String, Object> metron_f2748_0()
{    return parserConfig;}
public void metron_f2749_0(Map<String, Object> parserConfig)
{    this.parserConfig = parserConfig;}
public static SensorParserConfig metron_f2750_0(byte[] config) throws IOException
{    SensorParserConfig ret = JSONUtils.INSTANCE.load(new String(config, StandardCharsets.UTF_8), SensorParserConfig.class);    ret.init();    return ret;}
public void metron_f2751_0()
{    for (FieldTransformer h : getFieldTransformations()) {        h.initAndValidate();    }}
public String metron_f2752_0() throws JsonProcessingException
{    return JSONUtils.INSTANCE.toJSON(this, true);}
public boolean metron_f2753_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SensorParserConfig that = (SensorParserConfig) o;    return new EqualsBuilder().append(parserClassName, that.parserClassName).append(filterClassName, that.filterClassName).append(sensorTopic, that.sensorTopic).append(outputTopic, that.outputTopic).append(errorTopic, that.errorTopic).append(writerClassName, that.writerClassName).append(errorWriterClassName, that.errorWriterClassName).append(getReadMetadata(), that.getReadMetadata()).append(getMergeMetadata(), that.getMergeMetadata()).append(numWorkers, that.numWorkers).append(numAckers, that.numAckers).append(spoutParallelism, that.spoutParallelism).append(spoutNumTasks, that.spoutNumTasks).append(parserParallelism, that.parserParallelism).append(parserNumTasks, that.parserNumTasks).append(errorWriterParallelism, that.errorWriterParallelism).append(errorWriterNumTasks, that.errorWriterNumTasks).append(spoutConfig, that.spoutConfig).append(securityProtocol, that.securityProtocol).append(stormConfig, that.stormConfig).append(cacheConfig, that.cacheConfig).append(parserConfig, that.parserConfig).append(fieldTransformations, that.fieldTransformations).append(rawMessageStrategy, that.rawMessageStrategy).append(rawMessageStrategyConfig, that.rawMessageStrategyConfig).isEquals();}
public int metron_f2754_0()
{    return new HashCodeBuilder(17, 37).append(parserClassName).append(filterClassName).append(sensorTopic).append(outputTopic).append(errorTopic).append(writerClassName).append(errorWriterClassName).append(getReadMetadata()).append(getMergeMetadata()).append(numWorkers).append(numAckers).append(spoutParallelism).append(spoutNumTasks).append(parserParallelism).append(parserNumTasks).append(errorWriterParallelism).append(errorWriterNumTasks).append(spoutConfig).append(securityProtocol).append(stormConfig).append(cacheConfig).append(parserConfig).append(fieldTransformations).append(rawMessageStrategy).append(rawMessageStrategyConfig).toHashCode();}
public String metron_f2755_0()
{    return new ToStringBuilder(this).append("parserClassName", parserClassName).append("filterClassName", filterClassName).append("sensorTopic", sensorTopic).append("outputTopic", outputTopic).append("errorTopic", errorTopic).append("writerClassName", writerClassName).append("errorWriterClassName", errorWriterClassName).append("readMetadata", getReadMetadata()).append("mergeMetadata", getMergeMetadata()).append("numWorkers", numWorkers).append("numAckers", numAckers).append("spoutParallelism", spoutParallelism).append("spoutNumTasks", spoutNumTasks).append("parserParallelism", parserParallelism).append("parserNumTasks", parserNumTasks).append("errorWriterParallelism", errorWriterParallelism).append("errorWriterNumTasks", errorWriterNumTasks).append("spoutConfig", spoutConfig).append("securityProtocol", securityProtocol).append("stormConfig", stormConfig).append("cacheConfig", cacheConfig).append("parserConfig", parserConfig).append("fieldTransformations", fieldTransformations).append("rawMessageStrategy", rawMessageStrategy).append("rawMessageStrategyConfig", rawMessageStrategyConfig).toString();}
public String metron_f2756_0()
{    return name;}
public void metron_f2757_0(String name)
{    this.name = name;}
public String metron_f2758_0()
{    return description;}
public void metron_f2759_0(String description)
{    this.description = description;}
public Set<String> metron_f2760_0()
{    return sensors;}
public void metron_f2761_0(Set<String> sensors)
{    this.sensors = sensors;}
public boolean metron_f2762_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    SensorParserGroup that = (SensorParserGroup) o;    return Objects.equals(name, that.name) && Objects.equals(description, that.description) && Objects.equals(sensors, that.sensors);}
public int metron_f2763_0()
{    return Objects.hash(name, description, sensors);}
public String metron_f2764_0()
{    return "SensorParserGroup{" + "name='" + name + '\'' + ", description='" + description + '\'' + ", sensors=" + sensors + '}';}
public WriterConfiguration metron_f2765_0(BulkMessageWriter writer, Configurations configs)
{    return strategy.createWriterConfig(writer, configs);}
public ConfigurationsUpdater metron_f2766_0(Reloadable reloadable, Supplier configSupplier)
{    return strategy.createUpdater(reloadable, configSupplier);}
public WriterConfiguration metron_f2767_0(BulkMessageWriter writer, Configurations configs)
{    if (configs instanceof ParserConfigurations) {        return new ParserWriterConfiguration((ParserConfigurations) configs);    } else {        throw new IllegalArgumentException("Expected config of type ParserConfigurations but found " + configs.getClass());    }}
public ConfigurationsUpdater<ParserConfigurations> metron_f2768_0(Reloadable reloadable, Supplier configSupplier)
{    return new ParserUpdater(reloadable, configSupplier);}
public WriterConfiguration metron_f2769_0(BulkMessageWriter writer, Configurations configs)
{    if (configs instanceof EnrichmentConfigurations) {        return new EnrichmentWriterConfiguration((EnrichmentConfigurations) configs);    } else {        throw new IllegalArgumentException("Expected config of type EnrichmentConfigurations but found " + configs.getClass());    }}
public ConfigurationsUpdater<EnrichmentConfigurations> metron_f2770_0(Reloadable reloadable, Supplier configSupplier)
{    return new EnrichmentUpdater(reloadable, configSupplier);}
public WriterConfiguration metron_f2771_0(BulkMessageWriter writer, Configurations configs)
{    if (configs instanceof IndexingConfigurations) {        return new IndexingWriterConfiguration(writer.getName(), (IndexingConfigurations) configs);    } else {        throw new IllegalArgumentException("Expected config of type IndexingConfigurations but found " + configs.getClass());    }}
public ConfigurationsUpdater<IndexingConfigurations> metron_f2772_0(Reloadable reloadable, Supplier configSupplier)
{    return new IndexingUpdater(reloadable, configSupplier);}
public WriterConfiguration metron_f2773_0(BulkMessageWriter writer, Configurations configs)
{    if (configs instanceof ProfilerConfigurations) {        return new ProfilerWriterConfiguration((ProfilerConfigurations) configs);    } else {        throw new IllegalArgumentException("Expected config of type IndexingConfigurations but found " + configs.getClass());    }}
public ConfigurationsUpdater metron_f2774_0(Reloadable reloadable, Supplier configSupplier)
{    return new ProfilerUpdater(reloadable, configSupplier);}
public int metron_f2775_0(String sensorName)
{    return config.orElse(new EnrichmentConfigurations()).getBatchSize();}
public int metron_f2776_0(String sensorName)
{    return config.orElse(new EnrichmentConfigurations()).getBatchTimeout();}
public List<Integer> metron_f2777_0()
{    return asList(getBatchTimeout(null));}
public String metron_f2778_0(String sensorName)
{    return null;}
public boolean metron_f2779_0(String sensorName)
{    return true;}
public Map<String, Object> metron_f2780_0(String sensorName)
{    return config.orElse(new EnrichmentConfigurations()).getSensorEnrichmentConfig(sensorName).getConfiguration();}
public Map<String, Object> metron_f2781_0()
{    return config.orElse(new EnrichmentConfigurations()).getGlobalConfig();}
public boolean metron_f2782_0(String sensorName)
{    return false;}
public String metron_f2783_0(String sensorName)
{        return null;}
public int metron_f2784_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).getBatchSize(sensorName, writerName);}
public int metron_f2785_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).getBatchTimeout(sensorName, writerName);}
public List<Integer> metron_f2786_0()
{    return config.orElse(new IndexingConfigurations()).getAllConfiguredTimeouts(writerName);}
public String metron_f2787_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).getIndex(sensorName, writerName);}
public boolean metron_f2788_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).isEnabled(sensorName, writerName);}
public Map<String, Object> metron_f2789_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).getSensorIndexingConfig(sensorName, writerName);}
public Map<String, Object> metron_f2790_0()
{    return config.orElse(new IndexingConfigurations()).getGlobalConfig();}
public boolean metron_f2791_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).isDefault(sensorName, writerName);}
public String metron_f2792_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).getFieldNameConverter(sensorName, writerName);}
public boolean metron_f2793_0(String sensorName)
{    return config.orElse(new IndexingConfigurations()).isSetDocumentId(sensorName, writerName);}
public int metron_f2794_0(String sensorName)
{    if (config != null && config.getSensorParserConfig(sensorName) != null && config.getSensorParserConfig(sensorName).getParserConfig() != null) {        Object batchObj = config.getSensorParserConfig(sensorName).getParserConfig().get(IndexingConfigurations.BATCH_SIZE_CONF);        return batchObj == null ? ParserConfigurations.DEFAULT_KAFKA_BATCH_SIZE : ConversionUtils.convert(batchObj, Integer.class);    }    return 1;}
public int metron_f2795_0(String sensorName)
{    if (config != null && config.getSensorParserConfig(sensorName) != null && config.getSensorParserConfig(sensorName).getParserConfig() != null) {        Object batchObj = config.getSensorParserConfig(sensorName).getParserConfig().get(IndexingConfigurations.BATCH_TIMEOUT_CONF);        return batchObj == null ? 0 : ConversionUtils.convert(batchObj, Integer.class);    }    return 0;}
public List<Integer> metron_f2796_0()
{        return new ArrayList<Integer>();}
public String metron_f2797_0(String sensorName)
{    if (config != null && config.getSensorParserConfig(sensorName) != null && config.getSensorParserConfig(sensorName).getParserConfig() != null) {        Object indexObj = config.getSensorParserConfig(sensorName).getParserConfig().get(IndexingConfigurations.INDEX_CONF);        if (indexObj != null) {            return indexObj.toString();        }        return null;    }    return sensorName;}
public boolean metron_f2798_0(String sensorName)
{    if (config != null && config.getSensorParserConfig(sensorName) != null && config.getSensorParserConfig(sensorName).getParserConfig() != null) {        Object enabledObj = config.getSensorParserConfig(sensorName).getParserConfig().get(IndexingConfigurations.ENABLED_CONF);        return enabledObj == null ? true : ConversionUtils.convert(enabledObj, Boolean.class);    }    return true;}
public Map<String, Object> metron_f2799_0(String sensorName)
{    return config.getSensorParserConfig(sensorName).getParserConfig();}
public Map<String, Object> metron_f2800_0()
{    return config.getGlobalConfig();}
public boolean metron_f2801_0(String sensorName)
{    return false;}
public String metron_f2802_0(String sensorName)
{        return null;}
public int metron_f2803_0(String sensorName)
{    return config.orElse(new ProfilerConfigurations()).getBatchSize();}
public int metron_f2804_0(String sensorName)
{    return config.orElse(new ProfilerConfigurations()).getBatchTimeout();}
public List<Integer> metron_f2805_0()
{    return asList(getBatchTimeout(null));}
public String metron_f2806_0(String sensorName)
{    return null;}
public boolean metron_f2807_0(String sensorName)
{    return true;}
public Map<String, Object> metron_f2808_0(String sensorName)
{    throw new UnsupportedOperationException("Profiler does not have sensor configs");}
public Map<String, Object> metron_f2809_0()
{    return config.orElse(new ProfilerConfigurations()).getGlobalConfig();}
public boolean metron_f2810_0(String sensorName)
{    return false;}
public String metron_f2811_0(String sensorName)
{        return null;}
public int metron_f2812_0(String sensorName)
{    return 1;}
public int metron_f2813_0(String sensorName)
{    return 0;}
public List<Integer> metron_f2814_0()
{        return new ArrayList<Integer>();}
public String metron_f2815_0(String sensorName)
{    return config.getIndex(sensorName);}
public boolean metron_f2816_0(String sensorName)
{    return true;}
public Map<String, Object> metron_f2817_0(String sensorName)
{    return config.getSensorConfig(sensorName);}
public Map<String, Object> metron_f2818_0()
{    return config.getGlobalConfig();}
public boolean metron_f2819_0(String sensorName)
{    return false;}
public String metron_f2820_0(String sensorName)
{        return null;}
 boolean metron_f2821_0(String sensorName)
{    return false;}
public String metron_f2822_0()
{    return name;}
public static Fields metron_f2823_0(String fieldName)
{    return nameToField.get(fieldName);}
public String metron_f2824_0()
{    return name;}
public String metron_f2825_0()
{    return type;}
public Map<String, Integer> metron_f2826_0()
{    return columnMap;}
public CSVParser metron_f2827_0()
{    return parser;}
public Map<String, String> metron_f2828_0(String line) throws IOException
{    if (ignore(line)) {        return null;    }    String[] tokens = parser.parseLine(line);    Map<String, String> values = new HashMap<>();    for (Map.Entry<String, Integer> kv : columnMap.entrySet()) {        values.put(kv.getKey().trim(), tokens[kv.getValue()].trim());    }    return values;}
public void metron_f2829_0(Map<String, Object> config)
{    if (config.containsKey(COLUMNS_KEY)) {        columnMap = getColumnMap(config);    } else {        throw new IllegalStateException("CSVExtractor requires " + COLUMNS_KEY + " configuration");    }    char separator = ',';    if (config.containsKey(SEPARATOR_KEY)) {        separator = config.get(SEPARATOR_KEY).toString().charAt(0);    }    parser = new CSVParserBuilder().withSeparator(separator).build();}
protected boolean metron_f2830_0(String line)
{    if (null == line) {        return true;    }    String trimmedLine = line.trim();    return trimmedLine.startsWith("#") || isEmpty(trimmedLine);}
public static Map.Entry<String, Integer> metron_f2831_0(String column, int i)
{    if (column.contains(":")) {        Iterable<String> tokens = Splitter.on(':').split(column);        String col = Iterables.getFirst(tokens, null);        Integer pos = Integer.parseInt(Iterables.getLast(tokens));        return new AbstractMap.SimpleEntry<>(col, pos);    } else {        return new AbstractMap.SimpleEntry<>(column, i);    }}
public static Map<String, Integer> metron_f2832_0(Map<String, Object> config)
{    Map<String, Integer> columnMap = new HashMap<>();    if (config.containsKey(COLUMNS_KEY)) {        Object columnsObj = config.get(COLUMNS_KEY);        if (columnsObj instanceof String) {            String columns = (String) columnsObj;            int i = 0;            for (String column : Splitter.on(',').split(columns)) {                Map.Entry<String, Integer> e = getColumnMapEntry(column, i++);                columnMap.put(e.getKey(), e.getValue());            }        } else if (columnsObj instanceof List) {            List columns = (List) columnsObj;            int i = 0;            for (Object column : columns) {                Map.Entry<String, Integer> e = getColumnMapEntry(column.toString(), i++);                columnMap.put(e.getKey(), e.getValue());            }        } else if (columnsObj instanceof Map) {            Map<Object, Object> map = (Map<Object, Object>) columnsObj;            for (Map.Entry<Object, Object> e : map.entrySet()) {                columnMap.put(e.getKey().toString(), Integer.parseInt(e.getValue().toString()));            }        }    }    return columnMap;}
public MetronError metron_f2833_0(String message)
{    this.message = message;    return this;}
public MetronError metron_f2834_0(Throwable throwable)
{    this.throwable = throwable;    return this;}
public MetronError metron_f2835_0(Set<String> sensorTypes)
{    this.sensorTypes = sensorTypes;    return this;}
public MetronError metron_f2836_0(ErrorType errorType)
{    this.errorType = errorType;    return this;}
public MetronError metron_f2837_0(Set<String> errorFields)
{    this.errorFields = errorFields;    return this;}
public MetronError metron_f2838_0(Map<String, Object> metadata)
{    this.metadata.putAll(metadata);    return this;}
public MetronError metron_f2839_0(Object rawMessage)
{    if (rawMessage != null) {        if (this.rawMessages == null) {            this.rawMessages = new ArrayList<>();        }        this.rawMessages.add(rawMessage);    }    return this;}
public MetronError metron_f2840_0(List<Object> rawMessages)
{    this.rawMessages = rawMessages;    return this;}
public Optional<Throwable> metron_f2841_0()
{    return throwable != null ? Optional.of(throwable) : Optional.empty();}
public List<Object> metron_f2842_0()
{    return rawMessages;}
public JSONObject metron_f2843_0()
{    JSONObject errorMessage = new JSONObject();    errorMessage.put(Constants.GUID, UUID.randomUUID().toString());    errorMessage.put(Constants.SENSOR_TYPE, Constants.ERROR_TYPE);    errorMessage.put(ErrorFields.ERROR_TYPE.getName(), errorType.getType());    addFailedSensorType(errorMessage);    addMessageString(errorMessage);    addStacktrace(errorMessage);    addTimestamp(errorMessage);    addHostname(errorMessage);    addRawMessages(errorMessage);    addErrorHash(errorMessage);    addMetadata(errorMessage);    return errorMessage;}
private void metron_f2844_0(JSONObject errorMessage)
{    if (sensorTypes.size() == 1) {        errorMessage.put(ErrorFields.FAILED_SENSOR_TYPE.getName(), sensorTypes.iterator().next());    } else {        errorMessage.put(ErrorFields.FAILED_SENSOR_TYPE.getName(), new JSONArray().addAll(sensorTypes));    }}
private void metron_f2845_0(JSONObject errorMessage)
{    if (message != null) {        errorMessage.put(ErrorFields.MESSAGE.getName(), message);    } else if (throwable != null) {        errorMessage.put(ErrorFields.MESSAGE.getName(), throwable.getMessage());    }}
private void metron_f2846_0(JSONObject errorMessage)
{    if (throwable != null) {        String stackTrace = ExceptionUtils.getStackTrace(throwable);        String exception = throwable.toString();        errorMessage.put(ErrorFields.EXCEPTION.getName(), exception);        errorMessage.put(ErrorFields.STACK.getName(), stackTrace);    }}
private void metron_f2847_0(JSONObject errorMessage)
{    errorMessage.put(ErrorFields.TIMESTAMP.getName(), System.currentTimeMillis());}
private void metron_f2848_0(JSONObject errorMessage)
{    try {        errorMessage.put(ErrorFields.HOSTNAME.getName(), InetAddress.getLocalHost().getHostName());    } catch (UnknownHostException ex) {        }}
private void metron_f2849_0(JSONObject errorMessage)
{    if (rawMessages != null) {        for (int i = 0; i < rawMessages.size(); i++) {            Object rawMessage = rawMessages.get(i);                        String rawMessageField = rawMessages.size() == 1 ? ErrorFields.RAW_MESSAGE.getName() : ErrorFields.RAW_MESSAGE.getName() + "_" + i;                        if (rawMessage instanceof byte[]) {                errorMessage.put(rawMessageField, new String((byte[]) rawMessage, UTF_8));                        } else if (rawMessage instanceof JSONObject) {                JSONObject rawMessageJSON = (JSONObject) rawMessage;                String rawMessageJSONString = rawMessageJSON.toJSONString();                errorMessage.put(rawMessageField, rawMessageJSONString);                        } else {                errorMessage.put(rawMessageField, rawMessage.toString());                        }        }    }}
private void metron_f2850_0(JSONObject errorMessage)
{    if (rawMessages != null && rawMessages.size() == 1) {        Object rawMessage = rawMessages.get(0);        if (rawMessage instanceof JSONObject) {            JSONObject rawJSON = (JSONObject) rawMessage;            if (errorFields != null) {                errorMessage.put(ErrorFields.ERROR_FIELDS.getName(), String.join(",", errorFields));                errorMessage.put(ErrorFields.ERROR_HASH.getName(), HashUtils.getMessageHash(rawJSON, errorFields));            } else {                errorMessage.put(ErrorFields.ERROR_HASH.getName(), HashUtils.getMessageHash(rawJSON));            }        } else if (rawMessage instanceof byte[]) {            errorMessage.put(ErrorFields.ERROR_HASH.getName(), HashUtils.getMessageHash((byte[]) rawMessage));        } else {            errorMessage.put(ErrorFields.ERROR_HASH.getName(), HashUtils.getMessageHash(rawMessage.toString().getBytes(UTF_8)));        }    }}
private void metron_f2851_0(JSONObject errorMessage)
{    if (metadata != null && metadata.keySet().size() > 0) {                                errorMessage.putAll(metadata);    }}
public boolean metron_f2852_0(Object o)
{    if (this == o)        return true;    if (!(o instanceof MetronError))        return false;    MetronError that = (MetronError) o;    return Objects.equals(message, that.message) && Objects.equals(throwable, that.throwable) && Objects.equals(sensorTypes, that.sensorTypes) && errorType == that.errorType && Objects.equals(errorFields, that.errorFields) && Objects.equals(rawMessages, that.rawMessages) && Objects.equals(metadata, that.metadata);}
public int metron_f2853_0()
{    return Objects.hash(message, throwable, sensorTypes, errorType, errorFields, rawMessages, metadata);}
public FieldNameConverter metron_f2855_0()
{    return converter;}
public String metron_f2856_0(String originalField)
{    return converter.convert(originalField);}
public String metron_f2858_0(String originalField)
{        return originalField;}
public static FieldTransformation metron_f2859_0(String mapping)
{    try {        return FieldTransformations.valueOf(mapping).mapping;    } catch (Exception ex) {        return ReflectionUtils.createInstance(mapping);    }}
public Class<? extends FieldTransformation> metron_f2860_0()
{    return mapping.getClass();}
public Map<String, Object> metron_f2861_0(Object value, String outputField)
{    Map<String, Object> ret = new HashMap<>();    if (value != null && value instanceof Number) {        int protocolNum = ((Number) value).intValue();        ret.put(outputField, PROTOCOLS.get(protocolNum));    }    return ret;}
public Object metron_f2862_0(List<Object> objects, Context context) throws ParseException
{    Object keyObj = objects.get(0);    if (keyObj == null) {        return keyObj;    }    Integer key = ConversionUtils.convert(keyObj, Integer.class);    if (key == null) {        return keyObj;    }    Object ret = PROTOCOLS.get(key);    if (ret == null) {        return keyObj;    }    return ret;}
public void metron_f2863_0(Context context)
{}
public boolean metron_f2864_0()
{    return true;}
public Map<String, Object> metron_f2865_0(Map<String, Object> input, List<String> outputField, LinkedHashMap<String, Object> fieldMappingConfig, Context context, Map<String, Object>... sensorConfig)
{    String outField = null;    if (!(outputField == null || outputField.isEmpty())) {        outField = outputField.get(0);    }    String inVal = null;    if (!(input == null || input.isEmpty() || input.size() > 1)) {        Object inValObj = Iterables.getFirst(input.entrySet(), null).getValue();        if (inValObj != null) {            inVal = inValObj.toString();        }    }    Map<String, Object> ret = new HashMap<>(1);    if (outField == null || inVal == null) {                return ret;    }    for (Map.Entry<String, Object> valToRegex : fieldMappingConfig.entrySet()) {        if (isMatch(valToRegex.getValue(), inVal)) {            ret.put(outField, valToRegex.getKey());            break;        }    }    return ret;}
private static boolean metron_f2866_0(Object regexes, String field)
{    if (regexes instanceof String) {        return isMatch((String) regexes, field);    } else if (regexes instanceof List) {        for (Object regex : (List) regexes) {            if (isMatch(regex.toString(), field)) {                return true;            }        }    }    return false;}
private static boolean metron_f2867_0(String regex, String field)
{    try {        Pattern p = PatternCache.INSTANCE.getPattern(regex);        if (p == null) {            return false;        }        return p.asPredicate().test(field);    } catch (PatternSyntaxException pse) {        return false;    }}
public Boolean metron_f2868_0(String rule, VariableResolver resolver, FunctionResolver functionResolver, Context context)
{    return true;}
public boolean metron_f2869_0(String rule) throws ParseException
{    return true;}
public boolean metron_f2870_0(String rule, boolean throwException, Context context) throws ParseException
{    return true;}
private String metron_f2871_0(Map<String, Object> fieldMappingConfig)
{    Object conditionObj = fieldMappingConfig.get(CONDITION_CONF);    if (conditionObj == null || !(conditionObj instanceof String)) {        return null;    }    return conditionObj.toString();}
private StellarPredicateProcessor metron_f2872_0(String condition)
{    if (condition == null) {        return PASSTHROUGH_PROCESSOR;    } else {        return new StellarPredicateProcessor();    }}
public Map<String, Object> metron_f2873_0(Map<String, Object> input, final List<String> outputFields, LinkedHashMap<String, Object> fieldMappingConfig, Context context, Map<String, Object>... sensorConfig)
{    String condition = getCondition(fieldMappingConfig);    StellarPredicateProcessor processor = getPredicateProcessor(condition);    if (processor.parse(condition, new MapVariableResolver(input), StellarFunctions.FUNCTION_RESOLVER(), context)) {        return new HashMap<String, Object>() {            {                for (String outputField : outputFields) {                    put(outputField, null);                }            }        };    }    return null;}
public Map<String, Object> metron_f2874_0(Map<String, Object> input, List<String> outputField, LinkedHashMap<String, Object> fieldMappingConfig, Context context, Map<String, Object>... sensorConfig)
{    if (fieldMappingConfig == null || fieldMappingConfig.isEmpty()) {        return input;    }    Map<String, Object> ret = new HashMap<>();    for (Map.Entry<String, Object> kv : input.entrySet()) {        Object renamed = fieldMappingConfig.get(kv.getKey());        if (renamed != null) {                        ret.put(renamed.toString(), kv.getValue());                        ret.put(kv.getKey(), null);        } else {            ret.put(kv.getKey(), kv.getValue());        }    }    return ret;}
public Map<String, Object> metron_f2875_0(Map<String, Object> input, List<String> outputField, LinkedHashMap<String, Object> fieldMappingConfig, Context context, Map<String, Object>... sensorConfig)
{                        HashMap<String, Object> output = new HashMap<String, Object>();    for (Entry<String, Object> e : input.entrySet()) {        if (outputField.contains(e.getKey())) {            output.put(e.getKey(), e.getValue());        } else {            if (!systemFields.contains(e.getKey())) {                output.put(e.getKey(), null);            }        }    }    return output;}
public Map<String, Object> metron_f2876_0(Map<String, Object> input, List<String> outputField, LinkedHashMap<String, Object> fieldMappingConfig, Context context, Map<String, Object>... sensorConfig)
{    Object value = (input == null) ? null : Iterables.getFirst(input.values(), null);    return map(value, outputField.get(0));}
public Map<String, Object> metron_f2877_0(Map<String, Object> input, List<String> outputField, LinkedHashMap<String, Object> fieldMappingConfig, Context context, Map<String, Object>... sensorConfig)
{    Map<String, Object> ret = new HashMap<>();    Map<String, Object> intermediateVariables = new HashMap<>();    Set<String> outputs = new HashSet<>(outputField);    MapVariableResolver resolver = new MapVariableResolver(ret, intermediateVariables, input);    resolver.add(sensorConfig);    StellarProcessor processor = new CachingStellarProcessor();    for (Map.Entry<String, Object> kv : fieldMappingConfig.entrySet()) {        String oField = kv.getKey();        Object transformObj = kv.getValue();        if (transformObj != null) {            try {                Object o = processor.parse(transformObj.toString(), resolver, StellarFunctions.FUNCTION_RESOLVER(), context);                if (o != null) {                    if (outputs.contains(oField)) {                        ret.put(oField, o);                    } else {                        intermediateVariables.put(oField, o);                    }                } else {                    if (outputs.contains(oField)) {                        ret.put(oField, o);                    }                    if (o != null) {                        intermediateVariables.put(oField, o);                    } else {                                                intermediateVariables.remove(oField);                    }                }            } catch (Exception ex) {                throw new IllegalStateException("Unable to process transformation: " + transformObj.toString() + " for " + oField + " because " + ex.getMessage(), ex);            }        }    }    return ret;}
public static FieldValidation metron_f2878_0(String validation)
{    try {        return FieldValidations.valueOf(validation).validation;    } catch (Exception ex) {        return ReflectionUtils.createInstance(validation);    }}
public Predicate<Object> metron_f2879_0()
{    return domain -> DomainValidator.getInstance().isValid(domain == null ? null : domain.toString());}
public Predicate<Object> metron_f2880_0()
{    return email -> EmailValidator.getInstance().isValid(email == null ? null : email.toString());}
public boolean metron_f2881_0(String ip)
{    return validationPredicate.test(ip);}
public static IPType metron_f2882_0(String type)
{    if (type == null) {        return DEFAULT;    } else {        try {            return IPType.valueOf(type);        } catch (Exception e) {            return DEFAULT;        }    }}
public List metron_f2883_0(Map<String, Object> config)
{    Object o = config.get(key);    if (o == null) {        return Collections.singletonList("DEFAULT");    }    if (o instanceof ArrayList) {        return (ArrayList) o;    }    return Collections.singletonList(o);}
public boolean metron_f2884_0(List<Object> strings)
{    IPType type = IPType.DEFAULT;    if (strings.isEmpty()) {        return false;    }    Object ip = strings.get(0);    if (ip == null) {        return false;    }    if (strings.size() >= 2) {        Object ipType = strings.get(1);        if (ipType != null) {            try {                type = IPType.get(ipType.toString());            } catch (Exception e) {                type = IPType.DEFAULT;            }        }    }    return type.isValid(ip.toString());}
public boolean metron_f2885_0(Map<String, Object> input, Map<String, Object> validationConfig, Map<String, Object> globalConfig, Context context)
{    List types = Config.TYPE.get(validationConfig);    for (Object typeObject : types) {        IPType type = IPType.get(typeObject.toString());        for (Object o : input.values()) {            if (o == null || type.isValid(o.toString())) {                return true;            }        }    }    return false;}
public void metron_f2886_0(Map<String, Object> validationConfig, Map<String, Object> globalConfig)
{}
public Predicate<Object> metron_f2887_0()
{    return url -> UrlValidator.getInstance().isValid(url == null ? null : url.toString());}
public boolean metron_f2888_0(List<Object> strings)
{    if (strings.isEmpty()) {        return false;    }    if (strings.size() >= 2) {        Object date = strings.get(0);        Object format = strings.get(1);        if (date == null || format == null) {            return false;        }        try {            SimpleDateFormat sdf = new SimpleDateFormat(format.toString());            sdf.setLenient(false);            sdf.parse(date.toString());            return true;        } catch (ParseException pe) {            return false;        }    } else {        return false;    }}
public T metron_f2889_0(Map<String, Object> config, Class<T> clazz)
{    Object o = config.get(key);    if (o == null) {        return null;    }    return clazz.cast(o);}
public boolean metron_f2890_0(Map<String, Object> input, Map<String, Object> validationConfig, Map<String, Object> globalConfig, Context context)
{    String format = Config.FORMAT.get(validationConfig, String.class);    if (format == null) {        return false;    }    SimpleDateFormat sdf = new SimpleDateFormat(format);    sdf.setLenient(false);    for (Object o : input.values()) {        if (o == null) {            return true;        }        try {            Date d = sdf.parse(o.toString());        } catch (ParseException e) {            return false;        }    }    return true;}
public void metron_f2891_0(Map<String, Object> validationConfig, Map<String, Object> globalConfig)
{    String format = Config.FORMAT.get(validationConfig, String.class);    if (format == null) {        throw new IllegalStateException("You must specify '" + Config.FORMAT.key + "' in the config");    }    SimpleDateFormat sdf = new SimpleDateFormat(format);    sdf.setLenient(false);    try {        sdf.format(new Date());    } catch (Exception e) {        throw new IllegalStateException("Invalid date format: " + format, e);    }}
public Predicate<Object> metron_f2892_0()
{    return x -> LongValidator.getInstance().isValid(x == null ? null : x.toString());}
public Predicate<Object> metron_f2893_0()
{    return s -> !(s == null || s.toString().trim().isEmpty());}
protected boolean metron_f2894_0()
{    return false;}
public T metron_f2895_0(Map<String, Object> config, Class<T> clazz)
{    Object o = config.get(key);    if (o == null) {        return null;    }    return clazz.cast(o);}
public boolean metron_f2896_0(Map<String, Object> input, Map<String, Object> validationConfig, Map<String, Object> globalConfig, Context context)
{    String regex = Config.REGEX.get(validationConfig, String.class);    if (regex == null) {        return false;    }    for (Object o : input.values()) {        if (o != null && !o.toString().matches(regex)) {            return false;        }    }    return true;}
public void metron_f2897_0(Map<String, Object> validationConfig, Map<String, Object> globalConfig)
{    String regex = Config.REGEX.get(validationConfig, String.class);    if (regex == null) {        throw new IllegalStateException("You must specify '" + Config.REGEX.key + "' in the config");    }}
public T metron_f2898_0(Map<String, Object> config, Class<T> clazz)
{    Object o = config.get(key);    if (o == null) {        return null;    }    return clazz.cast(o);}
public boolean metron_f2899_0(Map<String, Object> input, Map<String, Object> validationConfig, Map<String, Object> globalConfig, Context context)
{    String condition = Config.CONDITION.get(validationConfig, String.class);    if (condition == null) {        return true;    } else {        StellarPredicateProcessor processor = new StellarPredicateProcessor();        return processor.parse(condition, new MapVariableResolver(input, validationConfig, globalConfig), StellarFunctions.FUNCTION_RESOLVER(), context);    }}
public void metron_f2900_0(Map<String, Object> validationConfig, Map<String, Object> globalConfig)
{    String condition = Config.CONDITION.get(validationConfig, String.class);    if (condition == null) {        throw new IllegalStateException("You must specify a condition.");    }    try {        new StellarPredicateProcessor().validate(condition);    } catch (Exception e) {        throw new IllegalStateException("Invalid condition: " + condition, e);    }}
public boolean metron_f2901_0(Map<String, Object> input, Map<String, Object> validationConfig, Map<String, Object> globalConfig, Context context)
{    Predicate<Object> predicate = getPredicate();    if (isNonExistentOk()) {        for (Object o : input.values()) {            if (o != null && !predicate.test(o.toString())) {                return false;            }        }    } else {        for (Object o : input.values()) {            if (o == null || !predicate.test(o.toString())) {                return false;            }        }    }    return true;}
public boolean metron_f2902_0(List<Object> input)
{    if (input.isEmpty()) {        return false;    }    Predicate<Object> predicate = getPredicate();    for (Object o : input) {        if (o == null || !predicate.test(o)) {            return false;        }    }    return true;}
public void metron_f2903_0(Map<String, Object> validationConfig, Map<String, Object> globalConfig)
{}
protected boolean metron_f2904_0()
{    return true;}
public Iterator<byte[]> metron_f2905_0()
{    return Iterators.concat(getIterators(files, config));}
private Iterator<byte[]>[] metron_f2906_0(List<Path> files, Configuration config)
{    return files.stream().map(f -> new SequenceFileIterator(f, config)).toArray(Iterator[]::new);}
public boolean metron_f2907_0() throws IOException
{    FileSystem fileSystem = FileSystem.get(config);    boolean success = true;    for (Path file : files) {        success &= fileSystem.delete(file, false);    }    return success;}
public boolean metron_f2908_1()
{    if (!finished && null == reader) {        try {            reader = new SequenceFile.Reader(config, SequenceFile.Reader.file(path));                    } catch (IOException e) {            throw new RuntimeException("Failed to get reader", e);        }    } else {            }    try {                if (!finished) {            if (null == next && reader.next(key, value)) {                next = value.copyBytes();            } else if (null == next) {                close();            }        }    } catch (IOException e) {        close();        throw new RuntimeException("Failed to get next record", e);    }    return (null != next);}
private void metron_f2909_1()
{        finished = true;    try {        if (reader != null) {            reader.close();            reader = null;        }    } catch (IOException e) {                    }}
public byte[] metron_f2910_0()
{    byte[] ret = null;    if (hasNext()) {        ret = next;                next = null;    } else {        throw new NoSuchElementException("No more records");    }    return ret;}
public RawMessage metron_f2911_0(Map<String, Object> rawMetadata, byte[] rawMessage, boolean readMetadata, Map<String, Object> config)
{    return new RawMessage(rawMessage, rawMetadata);}
public void metron_f2912_0(JSONObject message, Map<String, Object> metadata, boolean mergeMetadata, Map<String, Object> config)
{    if (mergeMetadata) {        message.putAll(metadata);    }}
public boolean metron_f2913_0()
{    return false;}
public boolean metron_f2914_0()
{    return false;}
public void metron_f2916_0(JSONObject message, Map<String, Object> metadata, boolean mergeMetadata, Map<String, Object> config)
{        String prefix = MetadataUtil.INSTANCE.getMetadataPrefix(config);    String originalStringFromMetadata = (String) metadata.get(MetadataUtil.INSTANCE.prefixKey(prefix, Constants.Fields.ORIGINAL.getName()));    if (mergeMetadata) {        for (Map.Entry<String, Object> kv : metadata.entrySet()) {                        message.putIfAbsent(kv.getKey(), kv.getValue());        }    }    if (originalStringFromMetadata != null) {        message.put(Constants.Fields.ORIGINAL.getName(), originalStringFromMetadata);    }}
public boolean metron_f2917_0()
{    return true;}
public boolean metron_f2918_0()
{    return true;}
public String metron_f2919_0(Map<String, Object> config)
{    String prefix = (String) config.getOrDefault(METADATA_PREFIX_CONFIG, METADATA_PREFIX);    if (StringUtils.isEmpty(prefix)) {        return null;    }    return prefix;}
public String metron_f2920_0(String prefix, String key)
{    if (StringUtils.isEmpty(prefix)) {        return key;    } else {        return prefix + "." + key;    }}
public byte[] metron_f2921_0()
{    return message;}
public void metron_f2922_0(byte[] message)
{    this.message = message;}
public Map<String, Object> metron_f2923_0()
{    return metadata;}
public void metron_f2924_0(Map<String, Object> metadata)
{    this.metadata = metadata;}
public String metron_f2925_0()
{    return "RawMessage{" + "message=" + Arrays.toString(message) + ", metadata=" + metadata + '}';}
public boolean metron_f2926_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    RawMessage that = (RawMessage) o;    if (!Arrays.equals(getMessage(), that.getMessage()))        return false;    return getMetadata() != null ? getMetadata().equals(that.getMetadata()) : that.getMetadata() == null;}
public int metron_f2927_0()
{    int result = Arrays.hashCode(getMessage());    result = 31 * result + (getMetadata() != null ? getMetadata().hashCode() : 0);    return result;}
public RawMessage metron_f2928_0(Map<String, Object> rawMetadata, byte[] originalMessage, boolean readMetadata, Map<String, Object> config)
{    return this.supplier.get(rawMetadata, originalMessage, readMetadata, config);}
public void metron_f2929_0(JSONObject message, Map<String, Object> metadata, boolean mergeMetadata, Map<String, Object> config)
{    this.supplier.mergeMetadata(message, metadata, mergeMetadata, config);}
public boolean metron_f2930_0()
{    return this.supplier.mergeMetadataDefault();}
public boolean metron_f2931_0()
{    return this.supplier.readMetadataDefault();}
public void metron_f2932_0(String markName)
{    timing.mark(markName);}
public void metron_f2933_0(String markName)
{    if (okToLog()) {        log(markName, "");    }}
public void metron_f2934_1(String markName, String message)
{    if (okToLog()) {        if (timing.exists(markName)) {                    } else {                    }    }}
private boolean metron_f2935_0()
{    return logger.isDebugEnabled() && thresholdCalc.isPast(getPercentThreshold());}
private Integer metron_f2936_0()
{    return ConversionUtils.convert(getProperty(LOG_PERCENT, LOG_PERCENT_DEFAULT), Integer.class);}
private Object metron_f2937_0(String key, Object defaultValue)
{    return configSupplier.get().getOrDefault(key, defaultValue);}
public void metron_f2938_0(String markName, String format, Object arg)
{    if (okToLog()) {        FormattingTuple formattedMessage = MessageFormatter.format(format, arg);        log(markName, formattedMessage.getMessage());    }}
public void metron_f2939_0(String markName, String format, Object arg1, Object arg2)
{    if (okToLog()) {        FormattingTuple formattedMessage = MessageFormatter.format(format, arg1, arg2);        log(markName, formattedMessage.getMessage());    }}
public void metron_f2940_0(String markName, String format, Object... arguments)
{    if (okToLog()) {        FormattingTuple formattedMessage = MessageFormatter.arrayFormat(format, arguments);        log(markName, formattedMessage.getMessage());    }}
public boolean metron_f2941_0()
{    return logger.isDebugEnabled();}
public boolean metron_f2942_0(int percent)
{    double rd = Math.random();    if (rd <= toDecimal(percent)) {        return true;    }    return false;}
private double metron_f2943_0(int percent)
{    return percent / 100.0;}
public void metron_f2944_0(String name)
{    startTimes.put(name, System.nanoTime());}
public long metron_f2945_0(String name)
{    if (startTimes.containsKey(name)) {        return System.nanoTime() - startTimes.get(name);    } else {        return 0;    }}
public boolean metron_f2946_0(String name)
{    return startTimes.containsKey(name);}
public long metron_f2947_0()
{    return System.currentTimeMillis();}
public String metron_f2948_0(String stdDateFormat)
{    SimpleDateFormat format = new SimpleDateFormat(stdDateFormat);    format.setTimeZone(TimeZone.getTimeZone(UTC));    return format.format(new Date(currentTimeMillis()));}
public String metron_f2949_0(String variable)
{    return System.getenv().get(variable);}
public long metron_f2950_0()
{    return now_ms;}
public void metron_f2951_0(long duration_ms)
{    long instant_ms = now_ms + duration_ms;    if (duration_ms < 0) {        throw new IllegalArgumentClockNegative(String.format("Attempted to move backward in time, by %d milliseconds.", duration_ms));    } else if (instant_ms < 0) {        throw new IllegalArgumentClockOverflow(String.format("Attempted to advance beyond the edge of time, to epoch %d + %d.", now_ms, duration_ms));    }    now_ms = instant_ms;}
public void metron_f2952_0(long duration_secs)
{    elapseMillis(TimeUnit.SECONDS.toMillis(duration_secs));}
public void metron_f2953_0(long instant_ms)
{    if (instant_ms < now_ms) {        throw new IllegalArgumentClockNegative(String.format("Attempted to move backward in time, from epoch %d to %d.", now_ms, instant_ms));    }    if (instant_ms == now_ms) {        throw new IllegalArgumentClockZero(String.format("Time was set to current time, with null advance, at epoch %d.", now_ms));    }    now_ms = instant_ms;}
public void metron_f2954_0(long instant_secs)
{    advanceToMillis(TimeUnit.SECONDS.toMillis(instant_secs));}
public Set<String> metron_f2955_0(String domain)
{    Set<String> ret = new HashSet<>();    for (int i = 97; i < 123; ++i) {        char c = Character.toChars(i)[0];        ret.add(domain + c);    }    return ret;}
public String metron_f2956_0()
{    return "Addition";}
public Set<String> metron_f2957_0(String originalString)
{    Set<String> ret = new HashSet<>();    char[] str = originalString.toCharArray();    for (int i = 0; i < str.length; ++i) {        char c = str[i];        for (int j : MASK) {            int maskedNum = (int) c ^ j;            char maskedChar = (char) maskedNum;            if ((maskedNum >= 48 && maskedNum <= 57) || (maskedNum >= 97 && maskedNum <= 122) || maskedNum == 45) {                ret.add(pasteTogether(str, i, maskedChar));            }        }    }    return ret;}
public String metron_f2958_0()
{    return "Bitsquatting";}
private static String metron_f2959_0(char[] str, int replacementPoint, char maskedChar)
{    String ret = "";    for (int i = 0; i < replacementPoint; ++i) {        ret += str[i];    }    ret += maskedChar;    for (int i = replacementPoint + 1; i < str.length; ++i) {        ret += str[i];    }    return ret;}
public Set<String> metron_f2960_1(String originalString)
{    Set<String> result = new HashSet<>();    String domain = originalString;    if (StringUtils.isEmpty(domain)) {        return result;    }    if (isAce(domain)) {                domain = IDN.toUnicode(domain);    }    for (int ws = 0; ws < domain.length(); ws++) {        for (int i = 0; i < domain.length() - ws + 1; ++i) {            String win = domain.substring(i, i + ws);            for (int j = 0; j < ws; j++) {                char c = win.charAt(j);                if (glyphs.containsKey(c)) {                    for (String g : glyphs.get(c)) {                        String winNew = win.replaceAll("" + c, g);                        String d = domain.substring(0, i) + winNew + domain.substring(i + ws);                        result.add(d);                        if (!isAce(d)) {                            try {                                String dAscii = IDN.toASCII(d, IDN.ALLOW_UNASSIGNED);                                if (!d.equals(dAscii)) {                                    result.add(dAscii);                                }                            } catch (IllegalArgumentException iae) {                                                            }                        }                    }                }            }        }    }    return result;}
public static boolean metron_f2961_0(String domainRaw)
{    String domain = domainRaw.toLowerCase();    return domain.startsWith("xn--") || domain.contains(".xn--");}
public String metron_f2962_0()
{    return "Homoglyph";}
public Set<String> metron_f2963_0(String originalString)
{    Set<String> ret = new HashSet<>();    for (int i = 1; i < originalString.length(); ++i) {        ret.add(originalString.substring(0, i) + "-" + originalString.substring(i));    }    return ret;}
public String metron_f2964_0()
{    return "Hyphenation";}
public Set<String> metron_f2965_0(String domain)
{    Set<String> ret = new HashSet<>();    for (int i = 1; i < domain.length() - 1; ++i) {        for (Keyboards keyboard : Keyboards.values()) {            String mapping = keyboard.getMapping().get(domain.charAt(i));            if (mapping != null) {                for (Character c : mapping.toCharArray()) {                    ret.add(domain.substring(0, i) + c + domain.charAt(i) + domain.substring(i + 1, domain.length()));                    ret.add(domain.substring(0, i) + domain.charAt(i) + c + domain.substring(i + 1, domain.length()));                }            }        }    }    return ret;}
public String metron_f2966_0()
{    return "Insertion";}
public Map<Character, String> metron_f2967_0()
{    return mapping;}
public Set<String> metron_f2968_0(String domain)
{    HashSet<String> ret = new HashSet<>();    for (int i = 0; i < domain.length(); ++i) {        ret.add(domain.substring(0, i) + domain.substring(i + 1, domain.length()));    }    return ret;}
public String metron_f2969_0()
{    return "Omission";}
public Set<String> metron_f2970_0(String domain)
{    Set<String> ret = new HashSet<>();    for (int i = 0; i < domain.length(); ++i) {        Character c = domain.charAt(i);        if (Character.isLetter(c)) {            ret.add(domain.substring(0, i) + c + c + domain.substring(i + 1, domain.length()));        }    }    return ret;}
public String metron_f2971_0()
{    return "Repetition";}
public Set<String> metron_f2972_0(String domain)
{    Set<String> ret = new HashSet<>();    for (int i = 0; i < domain.length(); ++i) {        for (Keyboards keyboard : Keyboards.values()) {            String mapping = keyboard.getMapping().get(domain.charAt(i));            if (mapping != null) {                for (Character c : mapping.toCharArray()) {                    ret.add(domain.substring(0, i) + c + domain.substring(i + 1, domain.length()));                }            }        }    }    return ret;}
public String metron_f2973_0()
{    return "Replacement";}
public Set<String> metron_f2974_0(String domain)
{    Set<String> ret = new HashSet<>();    for (int i = 1; i < domain.length(); ++i) {        Character c = domain.charAt(i);        Character prevC = domain.charAt(i - 1);        if (c != '-' && c != '.' && prevC != '-' && prevC != '.') {            ret.add(domain.substring(0, i) + "." + domain.substring(i, domain.length()));        }    }    return ret;}
public String metron_f2975_0()
{    return "Subdomain";}
public Set<String> metron_f2976_0(String domain)
{    Set<String> ret = new HashSet<>();    for (int i = 0; i < domain.length() - 1; ++i) {        char nextC = domain.charAt(i + 1);        char c = domain.charAt(i);        if (nextC != c) {            ret.add(domain.substring(0, i) + nextC + c + domain.substring(i + 2));        }    }    return ret;}
public String metron_f2977_0()
{    return "Transposition";}
public Set<String> metron_f2978_0(String originalString)
{    Set<String> candidates = strategy.generateCandidates(originalString);    candidates.remove(originalString);    return candidates;}
public static Set<String> metron_f2979_0(String originalString)
{    Set<String> ret = new HashSet<>();    for (TyposquattingStrategy s : values()) {        ret.addAll(s.generateCandidates(originalString));    }    return ret;}
public static TyposquattingStrategies metron_f2980_0(String name)
{    for (TyposquattingStrategies s : values()) {        if (s.strategy.name().equals(name)) {            return s;        }    }    return null;}
public Object metron_f2981_0(List<Object> args, Context context) throws ParseException
{    if (args.size() == 0) {        return null;    }    Object dnObj = args.get(0);    if (dnObj == null) {        return null;    }    if (!(dnObj instanceof String)) {        throw new IllegalStateException("Expected a domain without subdomains or a TLD, but got " + dnObj);    }    return TyposquattingStrategies.generateAllCandidates((String) dnObj);}
public void metron_f2982_0(Context context)
{}
public boolean metron_f2983_0()
{    return true;}
public Set<String> metron_f2984_0(String domain)
{    HashSet<String> ret = new HashSet<>();    for (int i = 0; i < domain.length(); ++i) {        char c = domain.charAt(i);        for (char vowel : VOWELS) {            if (VOWELS.contains(c)) {                ret.add(domain.substring(0, i) + vowel + domain.substring(i + 1));            }        }    }    return ret;}
public String metron_f2985_0()
{    return "Vowel-swap";}
public Optional<Object> metron_f2986_0(OPT_T option, CommandLine cli)
{    return Optional.empty();}
public static Options metron_f2987_0(CLIOptions[] values)
{    Options ret = new Options();    for (CLIOptions o : values) {        ret.addOption(o.getOption());    }    return ret;}
public static void metron_f2988_0(String name, CLIOptions[] values)
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp(name, getOptions(values));}
public static EnumMap<OPT_T, Optional<Object>> metron_f2989_0(CommandLine cli, OPT_T[] values, Class<OPT_T> clazz)
{    EnumMap<OPT_T, Optional<Object>> ret = new EnumMap<>(clazz);    for (OPT_T option : values) {        ret.put(option, option.getHandler().getValue(option, cli));    }    return ret;}
public static CommandLine metron_f2990_0(String name, CommandLineParser parser, String[] args, CLIOptions[] values, CLIOptions helpOption)
{    try {        CommandLine cli = parser.parse(getOptions(values), args);        if (helpOption.has(cli)) {            printHelp(name, values);            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp(name, values);        System.exit(-1);        return null;    }}
public void metron_f2991_0(File inFile, File outFile) throws IOException
{    strategy.compress(inFile, outFile);}
public void metron_f2992_0(File inFile, File outFile) throws IOException
{    strategy.decompress(inFile, outFile);}
public boolean metron_f2993_0(File gzipFile)
{    return strategy.test(gzipFile);}
public void metron_f2994_0(File inFile, File outFile) throws IOException
{    try (FileInputStream fis = new FileInputStream(inFile);        FileOutputStream fos = new FileOutputStream(outFile);        GZIPOutputStream gzipOS = new GZIPOutputStream(fos)) {        byte[] buffer = new byte[1024];        int len;        while ((len = fis.read(buffer)) != -1) {            gzipOS.write(buffer, 0, len);        }    }}
public void metron_f2995_0(File inFile, File outFile) throws IOException
{    try (FileInputStream fis = new FileInputStream(inFile);        GZIPInputStream gis = new GZIPInputStream(fis);        FileOutputStream fos = new FileOutputStream(outFile)) {        byte[] buffer = new byte[1024];        int len;        while ((len = gis.read(buffer)) != -1) {            fos.write(buffer, 0, len);        }    }}
public boolean metron_f2996_0(File gzipFile)
{    try (FileInputStream fis = new FileInputStream(gzipFile);        GZIPInputStream gis = new GZIPInputStream(fis)) {        byte[] buffer = new byte[1024];                gis.read(buffer);    } catch (ZipException | EOFException e) {        return false;    } catch (IOException e) {        throw new IllegalStateException("Error occurred while attempting to validate gzip file", e);    }    return true;}
public void metron_f2997_0(Consumer<? super String> action)
{    if (action == null) {        throw new NullPointerException();    }    try {        for (String line = null; (line = reader.readLine()) != null; ) {            action.accept(line);        }    } catch (RuntimeException e) {        throw e;    } catch (Exception e) {        throw new IllegalStateException(e);    }}
public boolean metron_f2998_0(Consumer<? super String> action)
{    if (action == null) {        throw new NullPointerException();    }    try {        final String line = reader.readLine();        if (line == null) {            return false;        }        action.accept(line);        return true;    } catch (RuntimeException e) {        throw e;    } catch (Exception e) {        throw new IllegalStateException(e);    }}
public Spliterator<String> metron_f2999_0()
{    final ConsumerWithLookback holder = new ConsumerWithLookback();    if (!tryAdvance(holder)) {        return null;    }    final String[] batch = new String[batchSize];    int j = 0;    do {        batch[j] = holder.value;    } while (++j < batchSize && tryAdvance(holder));    return spliterator(batch, 0, j, characteristics() | SIZED);}
public long metron_f3000_0()
{    return Long.MAX_VALUE;}
public int metron_f3001_0()
{    return characteristics;}
public void metron_f3002_0(String string)
{    this.value = string;}
public static Stream<String> metron_f3003_0(BufferedReader in, int batchSize)
{    return lineStream(in, batchSize, false);}
public static Stream<String> metron_f3004_0(BufferedReader in, int batchSize, boolean isParallel)
{    return StreamSupport.stream(new ReaderSpliterator(in, batchSize), isParallel).onClose(() -> {        try {            in.close();        } catch (IOException e) {            throw new UncheckedIOException(e);        }    });}
public static String metron_f3005_0(JSONObject message, Collection<String> hashFields)
{    List<String> hashElements = hashFields.stream().map(errorField -> String.format("%s-%s", errorField, message.get(errorField))).collect(Collectors.toList());    return DigestUtils.sha256Hex(String.join("|", hashElements).getBytes(UTF_8));}
public static String metron_f3006_0(JSONObject message)
{    return DigestUtils.sha256Hex(message.toJSONString().getBytes(UTF_8));}
public static String metron_f3007_0(byte[] bytes)
{    return DigestUtils.sha256Hex(bytes);}
public static byte[] metron_f3008_0(String path) throws IOException
{    return readBytes(new Path(path));}
public static byte[] metron_f3009_0(Path inPath) throws IOException
{    FileSystem fs = FileSystem.get(inPath.toUri(), new Configuration());    try (FSDataInputStream inputStream = fs.open(inPath)) {        return IOUtils.toByteArray(inputStream);    }}
public static List<String> metron_f3010_0(String path) throws IOException
{    return readFile(new Configuration(), path);}
public static List<String> metron_f3011_0(Configuration config, String path) throws IOException
{    Path inPath = new Path(path);    FileSystem fs = FileSystem.get(inPath.toUri(), config);    try (FSDataInputStream inputStream = fs.open(inPath)) {        return IOUtils.readLines(inputStream, "UTF-8");    }}
public static void metron_f3012_0(Configuration config, byte[] bytes, String path) throws IOException
{    Path outPath = new Path(path);    FileSystem fs = FileSystem.get(outPath.toUri(), config);    fs.mkdirs(outPath.getParent());    try (FSDataOutputStream outputStream = fs.create(outPath)) {        outputStream.write(bytes);        outputStream.flush();    }}
public TypeReference<T> metron_f3013_0()
{    return new TypeReference<T>() {        @Override        public Type getType() {            return type;        }    };}
public Type metron_f3014_0()
{    return type;}
public T metron_f3015_0(Object original, Class<T> targetClass)
{    return _mapper.get().convertValue(original, targetClass);}
public ObjectMapper metron_f3016_0()
{    return _mapper.get();}
public T metron_f3017_0(InputStream is, ReferenceSupplier<T> ref) throws IOException
{    return _mapper.get().readValue(is, (TypeReference<T>) ref.get());}
public T metron_f3018_0(String is, ReferenceSupplier<T> ref) throws IOException
{    return _mapper.get().readValue(is, (TypeReference<T>) ref.get());}
public T metron_f3019_0(File f, ReferenceSupplier<T> ref) throws IOException
{    try (InputStream is = new BufferedInputStream(new FileInputStream(f))) {        return _mapper.get().readValue(is, (TypeReference<T>) ref.get());    }}
public T metron_f3020_0(InputStream is, Class<T> clazz) throws IOException
{    return _mapper.get().readValue(is, clazz);}
public T metron_f3021_0(File f, Class<T> clazz) throws IOException
{    try (InputStream is = new BufferedInputStream(new FileInputStream(f))) {        return _mapper.get().readValue(is, clazz);    }}
public T metron_f3022_0(String is, Class<T> clazz) throws IOException
{    return _mapper.get().readValue(is, clazz);}
public String metron_f3023_0(Object o, boolean pretty) throws JsonProcessingException
{    if (pretty) {        return _mapper.get().writerWithDefaultPrettyPrinter().writeValueAsString(o);    } else {        return _mapper.get().writeValueAsString(o);    }}
public byte[] metron_f3024_0(String config) throws IOException
{    return toJSONPretty(readTree(config));}
public byte[] metron_f3025_0(Object config) throws JsonProcessingException
{    return _mapper.get().writerWithDefaultPrettyPrinter().writeValueAsBytes(config);}
public JSONObject metron_f3026_0(Object o) throws JsonProcessingException, ParseException
{    return (JSONObject) _parser.get().parse(toJSON(o, false));}
 JsonNode metron_f3027_0(String json) throws IOException
{    return _mapper.get().readTree(json);}
 JsonNode metron_f3028_0(byte[] json) throws IOException
{    return _mapper.get().readTree(json);}
public byte[] metron_f3029_0(String patch, String source) throws IOException
{    JsonNode patchNode = readTree(patch);    JsonNode sourceNode = readTree(source);    return toJSONPretty(JsonPatch.apply(patchNode, sourceNode));}
public byte[] metron_f3030_0(byte[] patch, byte[] source) throws IOException
{    JsonNode patchNode = readTree(patch);    JsonNode sourceNode = readTree(source);    return toJSONPretty(JsonPatch.apply(patchNode, sourceNode));}
public Map<String, Object> metron_f3031_0(List<Map<String, Object>> patch, Map<String, Object> source)
{    JsonNode originalNode = convert(source, JsonNode.class);    JsonNode patchNode = convert(patch, JsonNode.class);    JsonNode patched = JsonPatch.apply(patchNode, originalNode);    return _mapper.get().convertValue(patched, new TypeReference<Map<String, Object>>() {    });}
public List<String> metron_f3032_0(String zkQuorum) throws Exception
{    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    CuratorFramework framework = CuratorFrameworkFactory.newClient(zkQuorum, retryPolicy);    framework.start();    try {        return getBrokersFromZookeeper(framework);    } finally {        framework.close();    }}
public List<String> metron_f3033_0(CuratorFramework client) throws Exception
{    List<String> ret = new ArrayList<>();    for (String id : client.getChildren().forPath("/brokers/ids")) {        byte[] data = client.getData().forPath("/brokers/ids/" + id);        String brokerInfoStr = new String(data, StandardCharsets.UTF_8);        Map<String, Object> brokerInfo = JSONUtils.INSTANCE.load(brokerInfoStr, JSONUtils.MAP_SUPPLIER);        String host = (String) brokerInfo.get("host");        if (host != null) {            ret.add(host + ":" + brokerInfo.get("port"));        } else {            Object endpoints = brokerInfo.get("endpoints");            if (endpoints != null && endpoints instanceof List) {                List<String> eps = (List<String>) endpoints;                for (String url : eps) {                    ret.addAll(fromEndpoint(url));                }            }        }    }    return ret;}
public Map<String, Object> metron_f3034_0(Map<String, Object> configs)
{    if (configs.containsKey(SECURITY_PROTOCOL)) {        String protocol = normalizeProtocol((String) configs.get(SECURITY_PROTOCOL));        configs.put(SECURITY_PROTOCOL, protocol);    }    return configs;}
public String metron_f3035_0(String protocol)
{    if (protocol.equalsIgnoreCase("PLAINTEXTSASL") || protocol.equalsIgnoreCase("SASL_PLAINTEXT")) {        if (SecurityProtocol.getNames().contains("PLAINTEXTSASL")) {            return "PLAINTEXTSASL";        } else if (SecurityProtocol.getNames().contains("SASL_PLAINTEXT")) {            return "SASL_PLAINTEXT";        } else {            throw new IllegalStateException("Unable to find the appropriate SASL protocol, " + "viable options are: " + Joiner.on(",").join(SecurityProtocol.getNames()));        }    } else {        return protocol.trim();    }}
 List<String> metron_f3036_0(String url)
{    List<String> ret = new ArrayList<>();    if (url != null) {        Iterable<String> splits = Splitter.on("//").split(url);        if (Iterables.size(splits) == 2) {            String hostPort = Iterables.getLast(splits);            ret.add(hostPort);        }    }    return ret;}
protected HashFunction metron_f3037_0()
{    return Hashing.murmur3_128(SEED);}
public byte[] metron_f3038_0(byte[] key)
{    Hasher hasher = hFunction.get().newHasher();    hasher.putBytes(key);    return hasher.hash().asBytes();}
public byte[] metron_f3039_0(byte[] prefix, byte[] key)
{    byte[] val = new byte[key.length + prefix.length];    int offset = 0;    System.arraycopy(prefix, 0, val, offset, prefix.length);    offset += prefix.length;    System.arraycopy(key, 0, val, offset, key.length);    return val;}
public static LazyLogger metron_f3040_0(String name)
{    final Logger logger = org.slf4j.LoggerFactory.getLogger(name);    if (logger != null) {                return new LazyLoggerImpl(logger);    } else {        throw new NullPointerException(String.format("Logger not returned for class %s", name == null ? "Null String" : name));    }}
public static LazyLogger metron_f3041_0(Class clazz)
{    return getLogger(clazz.getName());}
public static LazyLogger metron_f3042_0(Logger logger)
{    if (logger != null) {        return new LazyLoggerImpl(logger);    } else {        throw new NullPointerException("Null logger passed");    }}
public Logger metron_f3043_0()
{    return logger;}
public String metron_f3044_0()
{    return logger.getName();}
public boolean metron_f3045_0()
{    return logger.isTraceEnabled();}
public void metron_f3046_0(String msg)
{    logger.trace(msg);}
public void metron_f3047_0(String format, Object arg)
{    logger.trace(format, arg);}
public void metron_f3048_0(String format, Supplier<Object> arg)
{    if (logger.isTraceEnabled()) {        logger.trace(format, arg.get());    }}
public void metron_f3049_0(String format, Object arg1, Object arg2)
{    logger.trace(format, arg1, arg2);}
public void metron_f3050_0(String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isTraceEnabled()) {        logger.trace(format, arg1.get(), arg2.get());    }}
public void metron_f3051_0(String format, Object... arguments)
{    logger.trace(format, arguments);}
public final void metron_f3052_0(String format, Supplier<Object>... arguments)
{    if (logger.isTraceEnabled()) {        logger.trace(format, Arrays.stream(arguments).map(Supplier::get).toArray());    }}
public void metron_f3053_0(String msg, Throwable t)
{    logger.trace(msg, t);}
public boolean metron_f3054_0(Marker marker)
{    return logger.isTraceEnabled(marker);}
public void metron_f3055_0(Marker marker, String msg)
{    logger.trace(marker, msg);}
public void metron_f3056_0(Marker marker, String format, Object arg)
{    logger.trace(marker, format, arg);}
public void metron_f3057_0(Marker marker, String format, Supplier<Object> arg)
{    if (logger.isTraceEnabled(marker)) {        logger.trace(marker, format, arg.get());    }}
public void metron_f3058_0(Marker marker, String format, Object arg1, Object arg2)
{    logger.trace(marker, format, arg1, arg2);}
public void metron_f3059_0(Marker marker, String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isTraceEnabled(marker)) {        logger.trace(marker, format, arg1.get(), arg2.get());    }}
public void metron_f3060_0(Marker marker, String format, Object... arguments)
{    logger.trace(marker, format, arguments);}
public final void metron_f3061_0(Marker marker, String format, Supplier<Object>... arguments)
{    if (logger.isTraceEnabled(marker)) {        logger.trace(marker, format, Arrays.stream(arguments).map(Supplier::get).toArray());    }}
public void metron_f3062_0(Marker marker, String msg, Throwable t)
{    logger.trace(marker, msg, t);}
public boolean metron_f3063_0()
{    return logger.isDebugEnabled();}
public void metron_f3064_1(String msg)
{    }
public void metron_f3065_1(String format, Object arg)
{    }
public void metron_f3066_1(String format, Supplier<Object> arg)
{    if (logger.isDebugEnabled()) {            }}
public void metron_f3067_1(String format, Object arg1, Object arg2)
{    }
public void metron_f3068_1(String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isDebugEnabled()) {            }}
public void metron_f3069_1(String format, Object... arguments)
{    }
public final void metron_f3070_1(String format, Supplier<Object>... arguments)
{    if (logger.isDebugEnabled()) {            }}
public void metron_f3071_1(String msg, Throwable t)
{    }
public boolean metron_f3072_0(Marker marker)
{    return logger.isDebugEnabled(marker);}
public void metron_f3073_1(Marker marker, String msg)
{    }
public void metron_f3074_1(Marker marker, String format, Object arg)
{    }
public void metron_f3075_1(Marker marker, String format, Supplier<Object> arg)
{    if (logger.isDebugEnabled(marker)) {            }}
public void metron_f3076_1(Marker marker, String format, Object arg1, Object arg2)
{    }
public void metron_f3077_1(Marker marker, String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isDebugEnabled(marker)) {            }}
public void metron_f3078_1(Marker marker, String format, Object... arguments)
{    }
public final void metron_f3079_1(Marker marker, String format, Supplier<Object>... arguments)
{    if (logger.isDebugEnabled(marker)) {            }}
public void metron_f3080_1(Marker marker, String msg, Throwable t)
{    }
public boolean metron_f3081_0()
{    return logger.isInfoEnabled();}
public void metron_f3082_1(String msg)
{    }
public void metron_f3083_1(String format, Object arg)
{    }
public void metron_f3084_1(String format, Supplier<Object> arg)
{    if (logger.isInfoEnabled()) {            }}
public void metron_f3085_1(String format, Object arg1, Object arg2)
{    }
public void metron_f3086_1(String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isInfoEnabled()) {            }}
public void metron_f3087_1(String format, Object... arguments)
{    }
public final void metron_f3088_1(String format, Supplier<Object>... arguments)
{    if (logger.isInfoEnabled()) {            }}
public void metron_f3089_1(String msg, Throwable t)
{    }
public boolean metron_f3090_0(Marker marker)
{    return logger.isInfoEnabled(marker);}
public void metron_f3091_1(Marker marker, String msg)
{    }
public void metron_f3092_1(Marker marker, String format, Object arg)
{    }
public void metron_f3093_1(Marker marker, String format, Supplier<Object> arg)
{    if (logger.isInfoEnabled(marker)) {            }}
public void metron_f3094_1(Marker marker, String format, Object arg1, Object arg2)
{    }
public void metron_f3095_1(Marker marker, String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isInfoEnabled(marker)) {            }}
public void metron_f3096_1(Marker marker, String format, Object... arguments)
{    }
public final void metron_f3097_1(Marker marker, String format, Supplier<Object>... arguments)
{    if (logger.isInfoEnabled(marker)) {            }}
public void metron_f3098_1(Marker marker, String msg, Throwable t)
{    }
public boolean metron_f3099_0()
{    return logger.isWarnEnabled();}
public void metron_f3100_1(String msg)
{    }
public void metron_f3101_1(String format, Object arg)
{    }
public void metron_f3102_1(String format, Supplier<Object> arg)
{    if (logger.isWarnEnabled()) {            }}
public void metron_f3103_1(String format, Object... arguments)
{    }
public final void metron_f3104_1(String format, Supplier<Object>... arguments)
{    if (logger.isWarnEnabled()) {            }}
public void metron_f3105_1(String format, Object arg1, Object arg2)
{    }
public void metron_f3106_1(String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isWarnEnabled()) {            }}
public void metron_f3107_1(String msg, Throwable t)
{    }
public boolean metron_f3108_0(Marker marker)
{    return logger.isWarnEnabled(marker);}
public void metron_f3109_1(Marker marker, String msg)
{    }
public void metron_f3110_1(Marker marker, String format, Object arg)
{    }
public void metron_f3111_1(Marker marker, String format, Supplier<Object> arg)
{    if (logger.isWarnEnabled(marker)) {            }}
public void metron_f3112_1(Marker marker, String format, Object arg1, Object arg2)
{    }
public void metron_f3113_1(Marker marker, String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isWarnEnabled(marker)) {            }}
public void metron_f3114_1(Marker marker, String format, Object... arguments)
{    }
public final void metron_f3115_1(Marker marker, String format, Supplier<Object>... arguments)
{    if (logger.isWarnEnabled(marker)) {            }}
public void metron_f3116_1(Marker marker, String msg, Throwable t)
{    }
public boolean metron_f3117_0()
{    return logger.isErrorEnabled();}
public void metron_f3118_1(String msg)
{    }
public void metron_f3119_1(String format, Object arg)
{    }
public void metron_f3120_1(String format, Supplier<Object> arg)
{    if (logger.isErrorEnabled()) {            }}
public void metron_f3121_1(String format, Object arg1, Object arg2)
{    }
public void metron_f3122_1(String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isErrorEnabled()) {            }}
public void metron_f3123_1(String format, Object... arguments)
{    }
public final void metron_f3124_1(String format, Supplier<Object>... arguments)
{    if (logger.isErrorEnabled()) {            }}
public void metron_f3125_1(String msg, Throwable t)
{    }
public boolean metron_f3126_0(Marker marker)
{    return logger.isErrorEnabled(marker);}
public void metron_f3127_1(Marker marker, String msg)
{    }
public void metron_f3128_1(Marker marker, String format, Object arg)
{    }
public void metron_f3129_1(Marker marker, String format, Supplier<Object> arg)
{    if (logger.isErrorEnabled(marker)) {            }}
public void metron_f3130_1(Marker marker, String format, Object arg1, Object arg2)
{    }
public final void metron_f3131_1(Marker marker, String format, Supplier<Object> arg1, Supplier<Object> arg2)
{    if (logger.isErrorEnabled(marker)) {            }}
public void metron_f3132_1(Marker marker, String format, Object... arguments)
{    }
public final void metron_f3133_1(Marker marker, String format, Supplier<Object>... arguments)
{    if (logger.isErrorEnabled(marker)) {            }}
public void metron_f3134_1(Marker marker, String msg, Throwable t)
{    }
public static String metron_f3135_0(JSONObject message)
{    return (String) message.get(Constants.GUID);}
public static String metron_f3136_0(JSONObject message)
{    return (String) message.get(Constants.SENSOR_TYPE);}
public static T metron_f3137_0(String className, T defaultClass)
{    T instance;    if (className == null || className.length() == 0 || className.charAt(0) == '$') {        return defaultClass;    } else {        instance = createInstance(className);    }    return instance;}
public static T metron_f3138_0(String className)
{    T instance;    try {        Class<? extends T> clazz = (Class<? extends T>) Class.forName(className);        instance = createInstance(clazz);    } catch (ClassNotFoundException e) {        throw new IllegalStateException("Unable to instantiate connector: class not found", e);    }    return instance;}
public static T metron_f3139_0(Class<? extends T> clazz)
{    return createInstance(clazz, null, null);}
public static T metron_f3140_0(Class<? extends T> clazz, Class<?>[] parameterTypes, Object[] parameters)
{    T instance;    try {        if (parameterTypes != null) {            instance = clazz.getConstructor(parameterTypes).newInstance(parameters);        } else {            instance = clazz.getConstructor().newInstance();        }    } catch (InstantiationException e) {        throw new IllegalStateException("Unable to instantiate connector.", e);    } catch (IllegalAccessException e) {        throw new IllegalStateException("Unable to instantiate connector: illegal access", e);    } catch (InvocationTargetException e) {        throw new IllegalStateException("Unable to instantiate connector", e);    } catch (NoSuchMethodException e) {        throw new IllegalStateException("Unable to instantiate connector: no such method", e);    }    return instance;}
public static T metron_f3141_0(String className, Class<?>[] parameterTypes, Object[] parameters)
{    T instance;    try {        Class<? extends T> clazz = (Class<? extends T>) Class.forName(className);        instance = createInstance(clazz, parameterTypes, parameters);    } catch (ClassNotFoundException e) {        throw new IllegalStateException("Unable to instantiate connector: class not found", e);    }    return instance;}
public void metron_f3142_0(String reason)
{    throwRuntime(reason, Optional.empty());}
public void metron_f3143_0(String reason, Throwable t)
{    throwRuntime(reason, Optional.of(t));}
public void metron_f3144_0(String reason, Optional<Throwable> t)
{    throw func.apply(Pair.of(reason, t));}
private static String metron_f3145_0(Pair<String, Optional<Throwable>> p)
{    return formatReason(p.getLeft(), p.getRight());}
private static String metron_f3146_0(String reason, Optional<Throwable> t)
{    if (t.isPresent()) {        return format("%s - reason:%s", reason, t.get());    } else {        return format("%s", reason);    }}
protected Kryo metron_f3147_0()
{    Kryo ret = new Kryo();    ret.setReferences(true);    ret.setInstantiatorStrategy(new DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));    ret.register(Arrays.asList("").getClass(), new ArraysAsListSerializer());    ret.register(Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer());    ret.register(Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer());    ret.register(Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer());    ret.register(Collections.singletonList("").getClass(), new CollectionsSingletonListSerializer());    ret.register(Collections.singleton("").getClass(), new CollectionsSingletonSetSerializer());    ret.register(Collections.singletonMap("", "").getClass(), new CollectionsSingletonMapSerializer());    ret.register(GregorianCalendar.class, new GregorianCalendarSerializer());    ret.register(InvocationHandler.class, new JdkProxySerializer());    UnmodifiableCollectionsSerializer.registerSerializers(ret);    SynchronizedCollectionsSerializer.registerSerializers(ret);            ret.register(CGLibProxySerializer.CGLibProxyMarker.class, new CGLibProxySerializer());        ret.register(LocalDate.class, new JodaLocalDateSerializer());    ret.register(LocalDateTime.class, new JodaLocalDateTimeSerializer());        ImmutableListSerializer.registerSerializers(ret);    ImmutableSetSerializer.registerSerializers(ret);    ImmutableMapSerializer.registerSerializers(ret);    ImmutableMultimapSerializer.registerSerializers(ret);    return ret;}
public void metron_f3148_0(final InstantiatorStrategy fallbackStrategy)
{    this.fallbackStrategy = fallbackStrategy;}
public InstantiatorStrategy metron_f3149_0()
{    return fallbackStrategy;}
public ObjectInstantiator metron_f3150_0(final Class type)
{    if (!Util.isAndroid) {                Class enclosingType = type.getEnclosingClass();        boolean isNonStaticMemberClass = enclosingType != null && type.isMemberClass() && !Modifier.isStatic(type.getModifiers());        if (!isNonStaticMemberClass) {            try {                final ConstructorAccess access = ConstructorAccess.get(type);                return new ObjectInstantiator() {                    @Override                    public Object newInstance() {                        try {                            return access.newInstance();                        } catch (Exception ex) {                            throw new KryoException("Error constructing instance of class: " + className(type), ex);                        }                    }                };            } catch (Exception ignored) {            }        }    }        try {        Constructor ctor;        try {            ctor = type.getConstructor((Class[]) null);        } catch (Exception ex) {            ctor = type.getDeclaredConstructor((Class[]) null);            ctor.setAccessible(true);        }        final Constructor constructor = ctor;        return new ObjectInstantiator() {            @Override            public Object newInstance() {                try {                    return constructor.newInstance();                } catch (Exception ex) {                    throw new KryoException("Error constructing instance of class: " + className(type), ex);                }            }        };    } catch (Exception ignored) {    }    if (fallbackStrategy == null) {        if (type.isMemberClass() && !Modifier.isStatic(type.getModifiers()))            throw new KryoException("Class cannot be created (non-static member class): " + className(type));        else            throw new KryoException("Class cannot be created (missing no-arg constructor): " + className(type));    }        return fallbackStrategy.newInstantiatorOf(type);}
public Object metron_f3151_0()
{    try {        return access.newInstance();    } catch (Exception ex) {        throw new KryoException("Error constructing instance of class: " + className(type), ex);    }}
public Object metron_f3152_0()
{    try {        return constructor.newInstance();    } catch (Exception ex) {        throw new KryoException("Error constructing instance of class: " + className(type), ex);    }}
public byte[] metron_f3153_0(Object o)
{    return toBytes(o);}
public T metron_f3154_0(byte[] bytes)
{    return fromBytes(bytes, clazz);}
public static byte[] metron_f3155_1(Object value)
{    try {        ByteArrayOutputStream bos = new ByteArrayOutputStream();        Output output = new Output(bos);        kryo.get().writeClassAndObject(output, value);        output.flush();        bos.flush();        return bos.toByteArray();    } catch (Throwable t) {                throw new IllegalStateException("Unable to serialize " + value + " because " + t.getMessage(), t);    }}
public static T metron_f3156_1(byte[] value, Class<T> clazz)
{    try {        Input input = new Input(new ByteArrayInputStream(value));        return clazz.cast(kryo.get().readClassAndObject(input));    } catch (Throwable t) {                throw t;    }}
public static String metron_f3157_0(String delim, Optional<String>... parts)
{    return Joiner.on(delim).join(Arrays.asList(parts).stream().filter(part -> part.isPresent()).map(part -> part.get()).toArray());}
public static String metron_f3158_0(String val, int numLines)
{    int start = org.apache.commons.lang3.StringUtils.ordinalIndexOf(val, System.lineSeparator(), numLines);    start = start >= 0 ? start : 0;    return val.substring(start);}
public static TimestampConverter metron_f3159_0(String converter)
{    if (converter != null) {        return TimestampConverters.valueOf(converter.toUpperCase()).converter;    } else {        throw new IllegalStateException(converter + " is not a valid timestamp converter: " + Joiner.on(",").join(TimestampConverters.values()));    }}
public long metron_f3160_0(long in)
{    return converter.toNanoseconds(in);}
public MessageId metron_f3161_0()
{    return id;}
public MESSAGE_T metron_f3162_0()
{    return message;}
public boolean metron_f3163_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    BulkMessage<?> that = (BulkMessage<?>) o;    return Objects.equals(id, that.id) && Objects.equals(message, that.message);}
public int metron_f3164_0()
{    return Objects.hash(id, message);}
public void metron_f3165_0(Throwable error, MessageId id)
{    errors.put(error, id);}
public void metron_f3166_0(Throwable error, Iterable<MessageId> ids)
{    if (ids != null) {        errors.putAll(error, ids);    }}
public boolean metron_f3167_0()
{    return !errors.isEmpty();}
public void metron_f3168_0(MessageId success)
{    successes.add(success);}
public void metron_f3169_0(Iterable<MessageId> allSuccesses)
{    if (allSuccesses != null) {        Iterables.addAll(successes, allSuccesses);    }}
public Map<Throwable, Collection<MessageId>> metron_f3170_0()
{    return errors.asMap();}
public List<MessageId> metron_f3171_0()
{    return successes;}
public boolean metron_f3172_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    BulkWriterResponse that = (BulkWriterResponse) o;    if (!errors.equals(that.errors))        return false;    return successes.equals(that.successes);}
public int metron_f3173_0()
{    int result = errors.hashCode();    result = 31 * result + successes.hashCode();    return result;}
public String metron_f3174_0()
{    return "BulkWriterResponse{" + "errors=" + errors + ", successes=" + successes + '}';}
public String metron_f3175_0()
{    return id;}
public boolean metron_f3176_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    MessageId messageId = (MessageId) o;    return Objects.equals(id, messageId.id);}
public int metron_f3177_0()
{    return Objects.hash(id);}
public String metron_f3178_0()
{    return "MessageId{" + "id='" + id + '\'' + '}';}
public void metron_f3179_1(CuratorFramework client, String path, byte[] data) throws IOException
{    if (data.length != 0) {        String name = path.substring(path.lastIndexOf("/") + 1);        if (path.startsWith(getType().getZookeeperRoot())) {                        update(name, data);            reloadCallback(name, getType());        } else if (ConfigurationType.GLOBAL.getZookeeperRoot().equals(path)) {                        getConfigurations().updateGlobalConfig(data);            reloadCallback(name, ConfigurationType.GLOBAL);        }    }}
public void metron_f3180_1(CuratorFramework client, String path, byte[] data) throws IOException
{    String name = path.substring(path.lastIndexOf("/") + 1);    if (path.startsWith(getType().getZookeeperRoot())) {                delete(name);        reloadCallback(name, getType());    } else if (ConfigurationType.GLOBAL.getZookeeperRoot().equals(path)) {                getConfigurations().deleteGlobalConfig();        reloadCallback(name, ConfigurationType.GLOBAL);    }}
protected void metron_f3181_0(String name, ConfigurationType type)
{    reloadable.reloadCallback(name, type);}
protected T metron_f3182_0()
{    return configSupplier.get();}
public Class<EnrichmentConfigurations> metron_f3183_0()
{    return EnrichmentConfigurations.class;}
public void metron_f3184_1(CuratorFramework client)
{    try {        ConfigurationsUtils.updateEnrichmentConfigsFromZookeeper(getConfigurations(), client);    } catch (KeeperException.NoNodeException nne) {            } catch (Exception e) {            }}
public EnrichmentConfigurations metron_f3185_0()
{    return new EnrichmentConfigurations();}
public ConfigurationType metron_f3186_0()
{    return ConfigurationType.ENRICHMENT;}
public void metron_f3187_0(String name)
{    getConfigurations().delete(name);}
public void metron_f3188_0(String name, byte[] data) throws IOException
{    getConfigurations().updateSensorEnrichmentConfig(name, data);}
public Class<IndexingConfigurations> metron_f3189_0()
{    return IndexingConfigurations.class;}
public void metron_f3190_1(CuratorFramework client)
{    try {        ConfigurationsUtils.updateSensorIndexingConfigsFromZookeeper(getConfigurations(), client);    } catch (KeeperException.NoNodeException nne) {            } catch (Exception e) {            }}
public IndexingConfigurations metron_f3191_0()
{    return new IndexingConfigurations();}
public ConfigurationType metron_f3192_0()
{    return ConfigurationType.INDEXING;}
public void metron_f3193_0(String name)
{    getConfigurations().delete(name);}
public void metron_f3194_0(String name, byte[] data) throws IOException
{    getConfigurations().updateSensorIndexingConfig(name, data);}
public Class<ParserConfigurations> metron_f3195_0()
{    return ParserConfigurations.class;}
public void metron_f3196_1(CuratorFramework client)
{    try {        ConfigurationsUtils.updateParserConfigsFromZookeeper(getConfigurations(), client);    } catch (KeeperException.NoNodeException nne) {            } catch (Exception e) {            }}
public ParserConfigurations metron_f3197_0()
{    return new ParserConfigurations();}
public ConfigurationType metron_f3198_0()
{    return ConfigurationType.PARSER;}
public void metron_f3199_0(String name)
{    getConfigurations().delete(name);}
public void metron_f3200_0(String name, byte[] data) throws IOException
{    getConfigurations().updateSensorParserConfig(name, data);}
public Class<ProfilerConfigurations> metron_f3201_0()
{    return ProfilerConfigurations.class;}
private ProfilerConfig metron_f3202_0(CuratorFramework client) throws Exception
{    byte[] raw = client.getData().forPath(PROFILER.getZookeeperRoot());    return JSONUtils.INSTANCE.load(new ByteArrayInputStream(raw), ProfilerConfig.class);}
public void metron_f3203_1(CuratorFramework client)
{    try {        ConfigurationsUtils.updateConfigsFromZookeeper(getConfigurations(), client);    } catch (KeeperException.NoNodeException nne) {            } catch (Exception e) {            }    try {        ProfilerConfig config = readFromZookeeper(client);        if (config != null) {            getConfigurations().updateProfilerConfig(config);        }    } catch (KeeperException.NoNodeException nne) {            } catch (Exception e) {            }}
public ProfilerConfigurations metron_f3204_0()
{    return new ProfilerConfigurations();}
public ConfigurationType metron_f3205_0()
{    return ConfigurationType.PROFILER;}
public void metron_f3206_0(String name)
{    getConfigurations().delete();}
public void metron_f3207_0(String name, byte[] data) throws IOException
{    getConfigurations().updateProfilerConfig(data);}
public ConfigurationsUpdater<? extends Configurations> metron_f3208_0(Map<Class<? extends Configurations>, Configurations> configs, Reloadable reloadCallback)
{    return updaterSupplier.create(configs, reloadCallback);}
private static Supplier<T> metron_f3209_0(Class<T> clazz, Map<Class<? extends Configurations>, Configurations> configs)
{    return () -> clazz.cast(configs.get(clazz));}
public void metron_f3210_0()
{    initializeCache(client);}
public void metron_f3211_0()
{    Lock writeLock = lock.writeLock();    try {        writeLock.lock();        if (cache != null) {            cache.close();        }    } finally {        writeLock.unlock();    }}
public void metron_f3212_0()
{    Lock writeLock = lock.writeLock();    try {        writeLock.lock();        close();        initializeCache(client);    } finally {        writeLock.unlock();    }}
private void metron_f3213_1(CuratorFramework client)
{    Lock writeLock = lock.writeLock();    try {        writeLock.lock();        SimpleEventListener listener = new SimpleEventListener.Builder().with(Iterables.transform(updaters, u -> u::update), TreeCacheEvent.Type.NODE_ADDED, TreeCacheEvent.Type.NODE_UPDATED).with(Iterables.transform(updaters, u -> u::delete), TreeCacheEvent.Type.NODE_REMOVED).build();        cache = new ZKCache.Builder().withClient(client).withListener(listener).withRoot(Constants.ZOOKEEPER_TOPOLOGY_ROOT).build();        for (ConfigurationsUpdater<? extends Configurations> updater : updaters) {            updater.forceUpdate(client);        }        cache.start();    } catch (Exception e) {                throw new IllegalStateException("Unable to initialize zookeeper cache: " + e.getMessage(), e);    } finally {        writeLock.unlock();    }}
public T metron_f3214_0(Class<T> configClass)
{    Lock readLock = lock.readLock();    try {        readLock.lock();        return configClass.cast(configs.get(configClass));    } finally {        readLock.unlock();    }}
public void metron_f3215_0()
{    Assert.assertEquals(Double.NEGATIVE_INFINITY, Aggregators.MAX.aggregate(ImmutableList.of(1, 5, -1, 7), new HashMap<>()), 1e-7);    Assert.assertEquals(Double.NEGATIVE_INFINITY, Aggregators.MAX.aggregate(ImmutableList.of(1, 5, -1, -2), new HashMap<>()), 1e-7);    Assert.assertEquals(7d, Aggregators.MAX.aggregate(ImmutableList.of(1, 5, -1, 7, 0), ImmutableMap.of(Aggregators.NEGATIVE_VALUES_TRUMP_CONF, "false")), 1e-7);}
public void metron_f3216_0()
{    Assert.assertEquals(Double.NEGATIVE_INFINITY, Aggregators.MIN.aggregate(ImmutableList.of(1, 5, -1, 7, 0), new HashMap<>()), 1e-7);    Assert.assertEquals(Double.NEGATIVE_INFINITY, Aggregators.MIN.aggregate(ImmutableList.of(1, 5, -1, -2, 0), new HashMap<>()), 1e-7);    Assert.assertEquals(-1d, Aggregators.MIN.aggregate(ImmutableList.of(1, 5, -1, 7, 0), ImmutableMap.of(Aggregators.NEGATIVE_VALUES_TRUMP_CONF, "false")), 1e-7);}
public void metron_f3217_0()
{    Assert.assertEquals(1, Aggregators.MIN.aggregate(ImmutableList.of(1, 5, 7), ImmutableMap.of(Aggregators.NEGATIVE_VALUES_TRUMP_CONF, "false")), 1e-7);}
public void metron_f3218_0()
{    Assert.assertEquals(Double.NEGATIVE_INFINITY, Aggregators.MEAN.aggregate(ImmutableList.of(1, 5, -1, 7, 0), new HashMap<>()), 1e-7);    Assert.assertEquals(12.0 / 5.0, Aggregators.MEAN.aggregate(ImmutableList.of(1, 5, -1, 7, 0), ImmutableMap.of(Aggregators.NEGATIVE_VALUES_TRUMP_CONF, "false")), 1e-7);}
public void metron_f3219_0()
{    Assert.assertEquals(Double.NEGATIVE_INFINITY, Aggregators.POSITIVE_MEAN.aggregate(ImmutableList.of(1, 5, -1, 7, 0), new HashMap<>()), 1e-7);    Assert.assertEquals(13.0 / 3.0, Aggregators.POSITIVE_MEAN.aggregate(ImmutableList.of(1, 5, -1, 7, 0), ImmutableMap.of(Aggregators.NEGATIVE_VALUES_TRUMP_CONF, "false")), 1e-7);}
public void metron_f3220_0()
{    Assert.assertEquals(Double.NEGATIVE_INFINITY, Aggregators.SUM.aggregate(ImmutableList.of(1, 5, -1, 7), new HashMap<>()), 1e-7);    Assert.assertEquals(1 + 5 + -1 + 7, Aggregators.SUM.aggregate(ImmutableList.of(1, 5, -1, 7), ImmutableMap.of(Aggregators.NEGATIVE_VALUES_TRUMP_CONF, "false")), 1e-7);}
private void metron_f3221_0(File rootDir) throws IOException
{    if (rootDir.isDirectory()) {        try {            Files.delete(Paths.get(rootDir.toURI()));        } catch (DirectoryNotEmptyException dne) {            for (File f : rootDir.listFiles()) {                cleanDir(f);            }            rootDir.delete();        }    } else {        rootDir.delete();    }}
public void metron_f3222_0() throws Exception
{    testZkServer = new TestingServer(true);    zookeeperUrl = testZkServer.getConnectString();    client = ConfigurationsUtils.getClient(zookeeperUrl);    client.start();    File sensorDir = new File(new File(TestConstants.SAMPLE_CONFIG_PATH), ENRICHMENT.getDirectory());    sensors.addAll(Collections2.transform(Arrays.asList(sensorDir.list()), s -> Iterables.getFirst(Splitter.on('.').split(s), "null")));    tmpDir = TestUtils.createTempDir(this.getClass().getName());    configDir = TestUtils.createDir(tmpDir, "config");    parsersDir = TestUtils.createDir(configDir, "parsers");    enrichmentsDir = TestUtils.createDir(configDir, "enrichments");    indexingDir = TestUtils.createDir(configDir, "indexing");    pushAllConfigs();}
private void metron_f3223_0() throws Exception
{    pushAllConfigs(TestConstants.SAMPLE_CONFIG_PATH);}
private void metron_f3224_0(String inputDir) throws Exception
{    String[] args = new String[] { "-z", zookeeperUrl, "--mode", "PUSH", "--input_dir", inputDir };    ConfigurationManager manager = new ConfigurationManager();    manager.run(ConfigurationManager.ConfigurationOptions.parse(new PosixParser(), args));}
private void metron_f3225_0(boolean force) throws Exception
{    String[] args = null;    if (force) {        args = new String[] { "-z", zookeeperUrl, "--mode", "PULL", "--output_dir", outDir, "--force" };    } else {        args = new String[] { "-z", zookeeperUrl, "--mode", "PULL", "--output_dir", outDir };    }    ConfigurationManager manager = new ConfigurationManager();    manager.run(ConfigurationManager.ConfigurationOptions.parse(new PosixParser(), args));}
private void metron_f3226_0(File configDir) throws IOException
{    File globalConfigFile = new File(configDir, "global.json");    Assert.assertTrue("Global config does not exist", globalConfigFile.exists());    validateConfig("global", GLOBAL, new String(Files.readAllBytes(Paths.get(globalConfigFile.toURI())), StandardCharsets.UTF_8));    for (String sensor : sensors) {        File sensorFile = new File(configDir, ENRICHMENT.getDirectory() + "/" + sensor + ".json");        Assert.assertTrue(sensor + " config does not exist", sensorFile.exists());        validateConfig(sensor, ENRICHMENT, new String(Files.readAllBytes(Paths.get(sensorFile.toURI())), StandardCharsets.UTF_8));    }}
public void metron_f3227_0() throws Exception
{    cleanDir(new File(outDir));    pullConfigs(false);    validateConfigsOnDisk(new File(outDir));    try {                pullConfigs(false);        fail("Should have failed to pull configs in a directory structure that already exists.");    } catch (IllegalStateException t) {                validateConfigsOnDisk(new File(outDir));    }    pullConfigs(true);    validateConfigsOnDisk(new File(outDir));}
private void metron_f3228_0(String name, ConfigurationType type, String data)
{    try {        type.deserialize(data);    } catch (Exception e) {        fail("Unable to load config " + name + ": " + data);    }}
public void metron_f3229_0() throws Exception
{        pushAllConfigs();        final Set<String> sensorsInZookeeper = new HashSet<>();    final BooleanWritable foundGlobal = new BooleanWritable(false);    ConfigurationsUtils.visitConfigs(client, new ConfigurationsUtils.ConfigurationVisitor() {        @Override        public void visit(ConfigurationType configurationType, String name, String data) {            Assert.assertTrue(data.length() > 0);            validateConfig(name, configurationType, data);            if (configurationType == GLOBAL) {                validateConfig(name, configurationType, data);                foundGlobal.set(true);            } else {                sensorsInZookeeper.add(name);            }        }    });    Assert.assertEquals(true, foundGlobal.get());    Assert.assertEquals(sensorsInZookeeper, sensors);}
public void metron_f3230_0(ConfigurationType configurationType, String name, String data)
{    Assert.assertTrue(data.length() > 0);    validateConfig(name, configurationType, data);    if (configurationType == GLOBAL) {        validateConfig(name, configurationType, data);        foundGlobal.set(true);    } else {        sensorsInZookeeper.add(name);    }}
public void metron_f3231_0() throws Exception
{        File globalConfigFile = new File(configDir, "global.json");    TestUtils.write(globalConfigFile, badGlobalConfig);        File squidConfigFile = new File(parsersDir, "squid.json");    TestUtils.write(squidConfigFile, badParserConfig);    pushAllConfigs(configDir.getAbsolutePath());}
public void metron_f3232_0() throws Exception
{        File configFile = new File(configDir, "global.json");    TestUtils.write(configFile, globalConfig);        pushConfigs(GLOBAL, configDir);        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(globalConfig);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(GLOBAL), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3233_0() throws Exception
{        File configFile = new File(configDir, "global.json");    TestUtils.write(configFile, badGlobalConfig);        pushConfigs(GLOBAL, configDir);}
private void metron_f3234_0(ConfigurationType type, File configPath) throws Exception
{    pushConfigs(type, configPath, Optional.empty());}
private void metron_f3235_0(ConfigurationType type, File configPath, Optional<String> configName) throws Exception
{    String[] args = new String[] { "-z", zookeeperUrl, "--mode", "PUSH", "--config_type", type.toString(), "--input_dir", configPath.getAbsolutePath() };    if (configName.isPresent()) {        args = ArrayUtils.addAll(args, "--config_name", configName.get());    }    ConfigurationManager manager = new ConfigurationManager();    manager.run(ConfigurationManager.ConfigurationOptions.parse(new PosixParser(), args));}
private String metron_f3236_0(ConfigurationType type) throws Exception
{    return dumpConfigs(type, Optional.empty());}
private String metron_f3237_0(ConfigurationType type, Optional<String> configName) throws Exception
{    String[] args = new String[] { "-z", zookeeperUrl, "--mode", "DUMP", "--config_type", type.toString() };    if (configName.isPresent()) {        args = ArrayUtils.addAll(args, "--config_name", configName.get());    }    ConfigurationManager manager = new ConfigurationManager();    return redirectSystemOut(args, (a) -> {        manager.run(ConfigurationManager.ConfigurationOptions.parse(new PosixParser(), a));    });}
private String metron_f3238_0(final String[] args, RedirectCallback callback) throws Exception
{    PrintStream os = System.out;    try (OutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos, false, StandardCharsets.UTF_8.name())) {        System.setOut(ps);        callback.call(args);        System.out.flush();        System.setOut(os);        return baos.toString();    } finally {        System.setOut(os);    }}
public void metron_f3239_0() throws Exception
{        File configFile = new File(parsersDir, "myparser.json");    TestUtils.write(configFile, squidParserConfig);        pushConfigs(PARSER, configDir, Optional.of("myparser"));        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(squidParserConfig);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(PARSER, Optional.of("myparser")), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3240_0() throws Exception
{        File configFile = new File(parsersDir, "badparser.json");    TestUtils.write(configFile, badParserConfig);        pushConfigs(PARSER, configDir, Optional.of("badparser"));}
public void metron_f3241_0() throws Exception
{        File configFile = new File(enrichmentsDir, "myenrichment.json");    TestUtils.write(configFile, someEnrichmentConfig);        pushConfigs(ENRICHMENT, configDir, Optional.of("myenrichment"));        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(someEnrichmentConfig);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(ENRICHMENT, Optional.of("myenrichment")), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3242_0() throws Exception
{        File configFile = new File(enrichmentsDir, "badenrichment.json");    TestUtils.write(configFile, badEnrichmentConfig);        pushConfigs(ENRICHMENT, configDir, Optional.of("badenrichment"));}
public void metron_f3243_0() throws Exception
{        File configFile = new File(indexingDir, "myindex.json");    TestUtils.write(configFile, someIndexingConfig);        pushConfigs(INDEXING, configDir, Optional.of("myindex"));        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(someIndexingConfig);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(INDEXING, Optional.of("myindex")), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3244_0() throws Exception
{        File configFile = new File(indexingDir, "myindex.json");    TestUtils.write(configFile, badIndexingConfig);        pushConfigs(INDEXING, configDir, Optional.of("myindex"));}
public void metron_f3245_0() throws Exception
{        File configFile = new File(configDir, "profiler.json");    TestUtils.write(configFile, someProfilerConfig);        Optional<String> configName = Optional.empty();    pushConfigs(PROFILER, configDir, configName);        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(someProfilerConfig);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(PROFILER, configName), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3246_0() throws Exception
{        File configFile = new File(configDir, "profiler.json");    TestUtils.write(configFile, badProfilerConfig);        Optional<String> configName = Optional.empty();    pushConfigs(PROFILER, configDir, configName);}
public void metron_f3247_0() throws Exception
{        File patchFile = new File(tmpDir, "global-config-patch.json");    TestUtils.write(patchFile, somePatchConfig);        File configFile = new File(configDir, "global.json");    TestUtils.write(configFile, globalConfig);    pushConfigs(GLOBAL, configDir, Optional.of("global"));        patchConfigs(GLOBAL, Optional.of(patchFile), Optional.of("global"), Optional.empty(), Optional.empty(), Optional.empty());        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(expectedSomeConfig);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(GLOBAL, Optional.of("global")), 1));    Assert.assertThat(actual, equalTo(expected));}
private void metron_f3248_0(ConfigurationType type, Optional<File> patchPath, Optional<String> configName, Optional<PatchMode> patchMode, Optional<String> key, Optional<String> value) throws Exception
{    String[] args = new String[] { "-z", zookeeperUrl, "--mode", "PATCH", "--config_type", type.toString() };    if (configName.isPresent()) {        args = ArrayUtils.addAll(args, "--config_name", configName.get());    }    if (patchPath.isPresent()) {        args = ArrayUtils.addAll(args, "--patch_file", patchPath.get().getAbsolutePath());    } else if (patchMode.isPresent()) {        args = ArrayUtils.addAll(args, "--patch_mode", patchMode.get().toString(), "--patch_key", key.get(), "--patch_value", value.get());    }    ConfigurationManager manager = new ConfigurationManager();    manager.run(ConfigurationManager.ConfigurationOptions.parse(new PosixParser(), args));}
public void metron_f3249_0() throws Exception
{        File patchFile = new File(tmpDir, "parser-patch.json");    TestUtils.write(patchFile, someParserPatch);        File configFile = new File(parsersDir, "myparser.json");    TestUtils.write(configFile, squidParserConfig);    pushConfigs(PARSER, configDir, Optional.of("myparser"));        patchConfigs(PARSER, Optional.of(patchFile), Optional.of("myparser"), Optional.empty(), Optional.empty(), Optional.empty());        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(expectedPatchedParser);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(PARSER, Optional.of("myparser")), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3250_0() throws Exception
{        File configFile = new File(parsersDir, "myparser.json");    TestUtils.write(configFile, squidParserConfig);    pushConfigs(PARSER, configDir, Optional.of("myparser"));        patchConfigs(PARSER, Optional.empty(), Optional.of("myparser"), Optional.of(ADD), Optional.of("/parserConfig/timestampField"), Optional.of("\"\"heyjoe\"\""));        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(expectedPatchedParser);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(PARSER, Optional.of("myparser")), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3251_0() throws Exception
{        File patchFile = new File(tmpDir, "parser-patch.json");    TestUtils.write(patchFile, badParserPatch);        File configFile = new File(parsersDir, "myparser.json");    TestUtils.write(configFile, squidParserConfig);    pushConfigs(PARSER, configDir, Optional.of("myparser"));        patchConfigs(PARSER, Optional.of(patchFile), Optional.of("myparser"), Optional.empty(), Optional.empty(), Optional.empty());}
public void metron_f3252_0() throws Exception
{        File configFile = new File(configDir, "global.json");    TestUtils.write(configFile, globalConfig);    pushConfigs(GLOBAL, configDir, Optional.of("global"));        patchConfigs(GLOBAL, Optional.empty(), Optional.of("global"), Optional.of(ADD), Optional.of("/foo"), Optional.of("{ \"bar\" : { \"baz\" : [ \"bazval1\", \"bazval2\" ] } }"));        byte[] expected = JSONUtils.INSTANCE.toJSONPretty(expectedComplexConfig);    byte[] actual = JSONUtils.INSTANCE.toJSONPretty(stripLines(dumpConfigs(GLOBAL, Optional.of("global")), 1));    Assert.assertThat(actual, equalTo(expected));}
public void metron_f3253_0() throws Exception
{        File patchFile = new File(tmpDir, "patch.json");    TestUtils.write(patchFile, badProfilerPatch);        File configFile = new File(configDir, "profiler.json");    TestUtils.write(configFile, someProfilerConfig);        pushConfigs(PROFILER, configDir, Optional.empty());        patchConfigs(PROFILER, Optional.of(patchFile), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());}
public void metron_f3254_0() throws IOException
{    client.close();    testZkServer.close();    testZkServer.stop();}
public void metron_f3255_0()
{}
public void metron_f3256_0()
{    ConfigOption option = newOption("foo");    Map<String, Object> config = new HashMap<>();    option.put(config, 25L);    assertThat(option.get(config, Long.class), equalTo(25L));    assertThat(option.get(mapWith("foo", 25L), Long.class), equalTo(25L));}
public void metron_f3257_0()
{    ConfigOption option = newOption("foo");    Map<String, Object> config = new HashMap<>();    option.put(config, "25");    BiFunction<String, Object, Long> transform = (s, o) -> o == null ? null : new Long(o.toString());    assertThat(option.get(config, transform, Long.class), equalTo(25L));    assertThat(option.get(mapWith("foo", "25"), transform, Long.class), equalTo(25L));}
public void metron_f3258_0()
{    ConfigOption option = newOption("foo");    Map<String, Object> config = new HashMap<>();    option.put(config, null);    BiFunction<String, Object, Long> transform = (s, o) -> o == null ? null : new Long(o.toString());    assertThat(option.getOrDefault(config, transform, Long.class, 25L), equalTo(25L));    assertThat(option.getOrDefault(mapWith("foo", null), transform, Long.class, 25L), equalTo(25L));}
public void metron_f3259_0()
{    ConfigOption option = newOption("foo");    Map<String, Object> config = new HashMap<>();    option.put(config, null);    assertThat(option.getOrDefault(config, Long.class, 0L), equalTo(0L));    assertThat(option.getOrDefault(mapWith("foo", null), Long.class, 0L), equalTo(0L));}
public void metron_f3260_0()
{    ConfigOption option = newOption("foo");    Map<String, Object> config = new HashMap<>();    option.put(config, (Object) 25L);    assertThat(option.getTransformed(config, Long.class), equalTo(25L));    assertThat(option.getTransformed(mapWith("foo", (Object) 25L), Long.class), equalTo(25L));}
public void metron_f3261_0()
{    ConfigOption option = newOption("foo");    Map<String, Object> config = new HashMap<>();    option.put(config, null);    assertThat(option.getTransformedOrDefault(config, Long.class, 25L), equalTo(25L));    assertThat(option.getTransformedOrDefault(mapWith("foo", null), Long.class, 25L), equalTo(25L));}
private Map<K, V> metron_f3262_0(K key, V val)
{    Map<K, V> map = new HashMap<>();    map.put(key, val);    return map;}
private ConfigOption metron_f3263_0(final String key)
{    return new ConfigOption() {        @Override        public String getKey() {            return key;        }    };}
public String metron_f3264_0()
{    return key;}
public void metron_f3265_0() throws IOException
{    EqualsVerifier.forClass(Configurations.class).suppress(Warning.NONFINAL_FIELDS, Warning.NULL_FIELDS).usingGetClass().verify();    Configurations configurations = new Configurations();    try {        configurations.updateGlobalConfig((byte[]) null);        Assert.fail("Updating a config with null should throw an IllegalStateException");    } catch (IllegalStateException e) {    }    Assert.assertTrue(configurations.toString() != null && configurations.toString().length() > 0);}
public void metron_f3266_0() throws Exception
{    testZkServer = new TestingServer(true);    zookeeperUrl = testZkServer.getConnectString();    client = ConfigurationsUtils.getClient(zookeeperUrl);    client.start();    expectedGlobalConfig = ConfigurationsUtils.readGlobalConfigFromFile(TestConstants.SAMPLE_CONFIG_PATH);    expectedSensorParserConfigMap = ConfigurationsUtils.readSensorParserConfigsFromFile(TestConstants.PARSER_CONFIGS_PATH);    expectedSensorEnrichmentConfigMap = ConfigurationsUtils.readSensorEnrichmentConfigsFromFile(TestConstants.ENRICHMENTS_CONFIGS_PATH);}
public void metron_f3267_0() throws Exception
{    Assert.assertTrue(expectedGlobalConfig.length > 0);    ConfigurationsUtils.writeGlobalConfigToZookeeper(expectedGlobalConfig, zookeeperUrl);    byte[] actualGlobalConfigBytes = ConfigurationsUtils.readGlobalConfigBytesFromZookeeper(client);    Assert.assertTrue(Arrays.equals(expectedGlobalConfig, actualGlobalConfigBytes));    Assert.assertTrue(expectedSensorParserConfigMap.size() > 0);    String testSensorType = "yaf";    byte[] expectedSensorParserConfigBytes = expectedSensorParserConfigMap.get(testSensorType);    ConfigurationsUtils.writeSensorParserConfigToZookeeper(testSensorType, expectedSensorParserConfigBytes, zookeeperUrl);    byte[] actualSensorParserConfigBytes = ConfigurationsUtils.readSensorParserConfigBytesFromZookeeper(testSensorType, client);    Assert.assertTrue(Arrays.equals(expectedSensorParserConfigBytes, actualSensorParserConfigBytes));    Assert.assertTrue(expectedSensorEnrichmentConfigMap.size() > 0);    byte[] expectedSensorEnrichmentConfigBytes = expectedSensorEnrichmentConfigMap.get(testSensorType);    ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(testSensorType, expectedSensorEnrichmentConfigBytes, zookeeperUrl);    byte[] actualSensorEnrichmentConfigBytes = ConfigurationsUtils.readSensorEnrichmentConfigBytesFromZookeeper(testSensorType, client);    Assert.assertTrue(Arrays.equals(expectedSensorEnrichmentConfigBytes, actualSensorEnrichmentConfigBytes));    String name = "testConfig";    Map<String, Object> testConfig = new HashMap<>();    testConfig.put("stringField", "value");    testConfig.put("intField", 1);    testConfig.put("doubleField", 1.1);    ConfigurationsUtils.writeConfigToZookeeper(name, testConfig, zookeeperUrl);    byte[] readConfigBytes = ConfigurationsUtils.readConfigBytesFromZookeeper(name, client);    Assert.assertTrue(Arrays.equals(JSONUtils.INSTANCE.toJSONPretty(testConfig), readConfigBytes));}
public void metron_f3268_0() throws Exception
{        ConfigurationType type = ConfigurationType.GLOBAL;    ConfigurationsUtils.writeConfigToZookeeper(type, JSONUtils.INSTANCE.toJSONPretty(someParserConfig), zookeeperUrl);        byte[] actual = ConfigurationsUtils.readConfigBytesFromZookeeper(type, zookeeperUrl);    assertThat(actual, equalTo(JSONUtils.INSTANCE.toJSONPretty(someParserConfig)));}
public void metron_f3269_0() throws Exception
{        ConfigurationType type = ConfigurationType.PARSER;    String parserName = "a-happy-metron-parser";    byte[] config = JSONUtils.INSTANCE.toJSONPretty(someParserConfig);    ConfigurationsUtils.writeConfigToZookeeper(type, Optional.of(parserName), config, zookeeperUrl);        byte[] actual = ConfigurationsUtils.readConfigBytesFromZookeeper(type, Optional.of(parserName), zookeeperUrl);    assertThat(actual, equalTo(JSONUtils.INSTANCE.toJSONPretty(someParserConfig)));}
public void metron_f3270_0() throws Exception
{        final ConfigurationType type = ConfigurationType.GLOBAL;    byte[] config = JSONUtils.INSTANCE.toJSONPretty(someGlobalConfig);    ConfigurationsUtils.writeConfigToZookeeper(type, config, zookeeperUrl);        byte[] patch = JSONUtils.INSTANCE.toJSONPretty(patchGlobalConfig);    ConfigurationsUtils.applyConfigPatchToZookeeper(type, patch, zookeeperUrl);        byte[] actual = ConfigurationsUtils.readConfigBytesFromZookeeper(type, zookeeperUrl);    byte[] expected = JSONUtils.INSTANCE.toJSONPretty(modifiedGlobalConfig);    assertThat(actual, equalTo(expected));}
public void metron_f3271_0() throws Exception
{        final ConfigurationType type = ConfigurationType.PARSER;    final String parserName = "patched-metron-parser";    byte[] config = JSONUtils.INSTANCE.toJSONPretty(someParserConfig);    ConfigurationsUtils.writeConfigToZookeeper(type, Optional.of(parserName), config, zookeeperUrl);        byte[] patch = JSONUtils.INSTANCE.toJSONPretty(patchParserConfig);    ConfigurationsUtils.applyConfigPatchToZookeeper(type, Optional.of(parserName), patch, zookeeperUrl);        byte[] actual = ConfigurationsUtils.readConfigBytesFromZookeeper(type, Optional.of(parserName), zookeeperUrl);    byte[] expected = JSONUtils.INSTANCE.toJSONPretty(modifiedParserConfig);    assertThat(actual, equalTo(expected));}
public void metron_f3272_0() throws IOException
{    client.close();    testZkServer.close();    testZkServer.stop();}
public void metron_f3273_0() throws Exception
{    Configuration configuration = new Configuration(Paths.get("./src/test/resources/config/"));    configuration.update();    checkResult(configuration);}
public void metron_f3274_0() throws Exception
{    CuratorFramework curatorFramework = mock(CuratorFramework.class);    ExistsBuilder existsBuilder = mock(ExistsBuilder.class);    GetDataBuilder getDataBuilder = mock(GetDataBuilder.class);    GetChildrenBuilder getChildrenBuilder = mock(GetChildrenBuilder.class);    when(getDataBuilder.forPath(ConfigurationType.GLOBAL.getZookeeperRoot())).thenReturn(mockGlobalData());    when(curatorFramework.checkExists()).thenReturn(existsBuilder);    when(curatorFramework.getData()).thenReturn(getDataBuilder);    when(curatorFramework.getChildren()).thenReturn(getChildrenBuilder);    when(getChildrenBuilder.forPath(anyString())).thenReturn(Collections.<String>emptyList());    Configuration configuration = new Configuration(Paths.get("foo"));    configuration.curatorFramework = curatorFramework;    configuration.update();    checkResult(configuration);}
private byte[] metron_f3275_0()
{    JSONObject global = new JSONObject();    global.put(TEST_PROPERTY, TEST_VALUE);    return global.toString().getBytes(StandardCharsets.UTF_8);}
private void metron_f3276_0(Configuration configuration)
{    assertEquals("File contains 1 entry: ", 1, configuration.getGlobalConfig().size());    String testValue = configuration.getGlobalConfig().get(TEST_PROPERTY).toString();    assertEquals(TEST_PROPERTY + " should be \"" + TEST_VALUE + "\"", TEST_VALUE, testValue);}
public void metron_f3277_0() throws Exception
{        SensorEnrichmentConfig enrichment = (SensorEnrichmentConfig) ENRICHMENT.deserialize(triageRuleWithNumericScore);    ThreatTriageConfig threatTriage = enrichment.getThreatIntel().getTriageConfig();    assertNotNull(threatTriage);    List<RiskLevelRule> rules = threatTriage.getRiskLevelRules();    assertEquals(1, rules.size());    RiskLevelRule rule = rules.get(0);    assertEquals("Rule Name", rule.getName());    assertEquals("Rule Comment", rule.getComment());    assertEquals("ip_src_addr == '10.0.2.3'", rule.getRule());    assertEquals("'Rule Reason'", rule.getReason());    assertEquals("10", rule.getScoreExpression());}
public void metron_f3278_0() throws Exception
{        SensorEnrichmentConfig enrichment = (SensorEnrichmentConfig) ENRICHMENT.deserialize(triageRuleWithScoreExpression);    ThreatTriageConfig threatTriage = enrichment.getThreatIntel().getTriageConfig();    assertNotNull(threatTriage);    List<RiskLevelRule> rules = threatTriage.getRiskLevelRules();    assertEquals(1, rules.size());    RiskLevelRule rule = rules.get(0);    assertEquals("Rule Name", rule.getName());    assertEquals("Rule Comment", rule.getComment());    assertEquals("'Rule Reason'", rule.getReason());    assertEquals("ip_src_addr == '10.0.2.3'", rule.getRule());    assertEquals("10 + 10", rule.getScoreExpression());}
public void metron_f3279_0() throws Exception
{    EnrichmentConfig config = JSONUtils.INSTANCE.load(sourceConfigStr, EnrichmentConfig.class);    Assert.assertTrue(config.getFieldMap().get("stellar") instanceof Map);    Assert.assertTrue(config.getEnrichmentConfigs().get("stellar") instanceof ConfigHandler);    Assert.assertEquals(Configs.STELLAR, ((ConfigHandler) config.getEnrichmentConfigs().get("stellar")).getType());}
public void metron_f3280_0()
{    configurations = new IndexingConfigurations();}
public void metron_f3281_0() throws Exception
{        assertFalse(configurations.isSetDocumentId("sensor", "writer"));}
public void metron_f3282_0() throws Exception
{        configurations.updateGlobalConfig(globalConfig.getBytes(StandardCharsets.UTF_8));    assertTrue(configurations.isSetDocumentId("sensor", "writer"));    assertTrue(configurations.isSetDocumentId("anySensor", "writer"));}
public void metron_f3283_0() throws Exception
{        configurations.updateGlobalConfig(new HashMap<>());    configurations.updateSensorIndexingConfig("sensor", sensorConfig.getBytes(StandardCharsets.UTF_8));    assertTrue(configurations.isSetDocumentId("sensor", "writer"));    assertFalse(configurations.isSetDocumentId("anySensor", "writer"));}
public void metron_f3284_0() throws IOException
{    ParserConfigurations parserConfigs = new ParserConfigurations();    parserConfigs.updateSensorParserConfig("test-sensor", parserConfig.getBytes(StandardCharsets.UTF_8));    SensorParserConfig actualSensorConfig = parserConfigs.getSensorParserConfig("test-sensor");    assertThat(actualSensorConfig.getParserClassName(), equalTo("parser-class"));    assertThat(actualSensorConfig.getFilterClassName(), equalTo("filter-class"));    assertThat(actualSensorConfig.getSensorTopic(), equalTo("sensor-topic"));    assertThat(actualSensorConfig.getOutputTopic(), equalTo("output-topic"));    assertThat(actualSensorConfig.getErrorTopic(), equalTo("error-topic"));    assertThat(actualSensorConfig.getWriterClassName(), equalTo("writer-class"));    assertThat(actualSensorConfig.getErrorWriterClassName(), equalTo("error-writer-class"));    assertThat(actualSensorConfig.getReadMetadata(), equalTo(true));    assertThat(actualSensorConfig.getMergeMetadata(), equalTo(true));    assertThat(actualSensorConfig.getNumWorkers(), equalTo(40));    assertThat(actualSensorConfig.getNumAckers(), equalTo(40));    assertThat(actualSensorConfig.getSpoutParallelism(), equalTo(40));    assertThat(actualSensorConfig.getSpoutNumTasks(), equalTo(40));    assertThat(actualSensorConfig.getParserParallelism(), equalTo(40));    assertThat(actualSensorConfig.getParserNumTasks(), equalTo(40));    assertThat(actualSensorConfig.getErrorWriterParallelism(), equalTo(40));    assertThat(actualSensorConfig.getErrorWriterNumTasks(), equalTo(40));    assertThat(actualSensorConfig.getSecurityProtocol(), equalTo("security-protocol"));    assertThat(actualSensorConfig.getSpoutConfig(), not(new HashMap<>()));    assertThat(actualSensorConfig.getSpoutConfig().get("foo"), equalTo("bar"));    assertThat(actualSensorConfig.getStormConfig(), not(new HashMap<>()));    assertThat(actualSensorConfig.getStormConfig().get("storm"), equalTo("config"));    assertThat(actualSensorConfig.getCacheConfig(), not(new HashMap<>()));    assertThat(actualSensorConfig.getCacheConfig().get("stellar.cache.maxSize"), equalTo(20000));    assertThat(actualSensorConfig.getParserConfig(), not(new HashMap<>()));    assertThat(actualSensorConfig.getParserConfig().get("parser"), equalTo("config"));    assertThat(actualSensorConfig.getFieldTransformations(), not(new ArrayList<>()));    assertThat(actualSensorConfig.getFieldTransformations().get(0), not(nullValue()));    assertThat(((FieldTransformer) actualSensorConfig.getFieldTransformations().get(0)).getInput().size(), equalTo(1));    assertThat(((FieldTransformer) actualSensorConfig.getFieldTransformations().get(0)).getInput().get(0), equalTo("input-field"));    assertThat(((FieldTransformer) actualSensorConfig.getFieldTransformations().get(0)).getTransformation(), equalTo("REMOVE"));}
public void metron_f3285_0() throws IOException
{    ProfileConfig profile = ProfileConfig.fromJSON(onlyIfDefault);    assertEquals("true", profile.getOnlyif());}
public void metron_f3286_0() throws Exception
{        ProfileConfig expected = ProfileConfig.fromJSON(onlyIfDefault);        String asJson = expected.toJSON();        ProfileConfig actual = ProfileConfig.fromJSON(asJson);    assertEquals(expected, actual);}
public void metron_f3287_0() throws IOException
{    ProfileConfig.fromJSON(nameMissing);}
public void metron_f3288_0() throws IOException
{    ProfileConfig.fromJSON(foreachMissing);}
public void metron_f3289_0() throws IOException
{    ProfileConfig.fromJSON(resultMissing);}
public void metron_f3290_0() throws IOException
{    ProfileConfig.fromJSON(resultMissingProfileExpression);}
public void metron_f3291_0() throws IOException
{    ProfileConfig profile = ProfileConfig.fromJSON(resultWithExpression);    assertEquals("2 + 2", profile.getResult().getProfileExpressions().getExpression());        assertEquals(0, profile.getResult().getTriageExpressions().getExpressions().size());}
public void metron_f3292_0() throws Exception
{        ProfileConfig expected = ProfileConfig.fromJSON(resultWithExpression);        String asJson = expected.toJSON();        ProfileConfig actual = ProfileConfig.fromJSON(asJson);    assertEquals(expected, actual);}
public void metron_f3293_0() throws IOException
{    ProfileConfig profile = ProfileConfig.fromJSON(resultWithProfileOnly);    assertEquals("2 + 2", profile.getResult().getProfileExpressions().getExpression());        assertEquals(0, profile.getResult().getTriageExpressions().getExpressions().size());}
public void metron_f3294_0() throws Exception
{        ProfileConfig expected = ProfileConfig.fromJSON(resultWithProfileOnly);        String asJson = expected.toJSON();        ProfileConfig actual = ProfileConfig.fromJSON(asJson);    assertEquals(expected, actual);}
public void metron_f3295_0() throws IOException
{    ProfileConfig profile = ProfileConfig.fromJSON(resultWithTriage);    assertEquals("4 + 4", profile.getResult().getTriageExpressions().getExpression("eight"));    assertEquals("8 + 8", profile.getResult().getTriageExpressions().getExpression("sixteen"));}
public void metron_f3296_0() throws Exception
{        ProfileConfig expected = ProfileConfig.fromJSON(resultWithTriage);        String asJson = expected.toJSON();        ProfileConfig actual = ProfileConfig.fromJSON(asJson);    assertEquals(expected, actual);}
public void metron_f3297_0() throws IOException
{    ProfilerConfig conf = ProfilerConfig.fromJSON(profile);    assertFalse(conf.getTimestampField().isPresent());    assertEquals(1, conf.getProfiles().size());}
public void metron_f3298_0() throws IOException
{    ProfilerConfig conf = ProfilerConfig.fromJSON(noTimestampField);    assertFalse(conf.getTimestampField().isPresent());}
public void metron_f3299_0() throws IOException
{    ProfilerConfig conf = ProfilerConfig.fromJSON(timestampField);    assertTrue(conf.getTimestampField().isPresent());}
public void metron_f3300_0() throws IOException
{    ProfilerConfig conf = ProfilerConfig.fromJSON(twoProfiles);    assertEquals(2, conf.getProfiles().size());    assertFalse(conf.getTimestampField().isPresent());}
public void metron_f3301_0() throws Exception
{        ProfilerConfig expected = ProfilerConfig.fromJSON(profile);        String asJson = expected.toJSON();        ProfilerConfig actual = ProfilerConfig.fromJSON(asJson);    assertEquals(expected, actual);}
public void metron_f3302_0() throws Exception
{        ProfilerConfig expected = ProfilerConfig.fromJSON(profileWithTriageExpression);        String asJson = expected.toJSON();        ProfilerConfig actual = ProfilerConfig.fromJSON(asJson);    assertEquals(expected, actual);}
public void metron_f3303_0() throws Exception
{        ProfilerConfig expected = ProfilerConfig.fromJSON(twoProfiles);        String asJson = expected.toJSON();        ProfilerConfig actual = ProfilerConfig.fromJSON(asJson);    assertEquals(expected, actual);}
public void metron_f3304_0() throws Exception
{        ProfilerConfig expected = ProfilerConfig.fromJSON(profilesToSerialize);    assertNotNull(expected);    Kryo kryo = new Kryo();        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();    Output output = new Output(byteStream);    kryo.writeObject(output, expected);        byte[] bits = output.toBytes();    assertNotNull(bits);        Input input = new Input(new ByteArrayInputStream(bits));    ProfilerConfig actual = kryo.readObject(input, ProfilerConfig.class);        assertNotNull(actual);    assertEquals(expected, actual);}
public void metron_f3305_0() throws Exception
{        ProfilerConfig expected = ProfilerConfig.fromJSON(profilesToSerialize);        ByteArrayOutputStream bytes = new ByteArrayOutputStream();    ObjectOutputStream out = new ObjectOutputStream(bytes);    out.writeObject(expected);        byte[] raw = bytes.toByteArray();    assertTrue(raw.length > 0);        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(raw));    Object actual = in.readObject();        assertEquals(expected, actual);}
public void metron_f3306_0() throws IOException
{    EqualsVerifier.forClass(SensorEnrichmentConfig.class).suppress(Warning.NONFINAL_FIELDS).usingGetClass().verify();    Map<String, byte[]> testSensorConfigMap = ConfigurationsUtils.readSensorEnrichmentConfigsFromFile(TestConstants.ENRICHMENTS_CONFIGS_PATH);    byte[] sensorConfigBytes = testSensorConfigMap.get("yaf");    SensorEnrichmentConfig sensorEnrichmentConfig = SensorEnrichmentConfig.fromBytes(sensorConfigBytes);    Assert.assertNotNull(sensorEnrichmentConfig);    Assert.assertTrue(sensorEnrichmentConfig.toString() != null && sensorEnrichmentConfig.toString().length() > 0);}
public void metron_f3307_0() throws IOException
{    for (File enrichmentConfig : new File(new File(TestConstants.ENRICHMENTS_CONFIGS_PATH), "enrichments").listFiles()) {        SensorEnrichmentConfig config = null;        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(enrichmentConfig), StandardCharsets.UTF_8))) {            String parserStr = IOUtils.toString(br);            config = SensorEnrichmentConfig.fromBytes(parserStr.getBytes(StandardCharsets.UTF_8));        }        SensorEnrichmentConfig config2 = SensorEnrichmentConfig.fromBytes(config.toJSON().getBytes(StandardCharsets.UTF_8));        Assert.assertEquals(config2, config);    }}
public void metron_f3308_0() throws Exception
{    SensorEnrichmentConfig broSc = (SensorEnrichmentConfig) ConfigurationType.ENRICHMENT.deserialize(sourceConfigStr);    SensorEnrichmentUpdateConfig threatIntelConfig = JSONUtils.INSTANCE.load(threatIntelConfigStr, SensorEnrichmentUpdateConfig.class);    final Map<String, SensorEnrichmentConfig> finalEnrichmentConfig = new HashMap<>();    SensorEnrichmentUpdateConfig.SourceConfigHandler scHandler = new SensorEnrichmentUpdateConfig.SourceConfigHandler() {        @Override        public SensorEnrichmentConfig readConfig(String sensor) throws Exception {            if (sensor.equals("bro")) {                return JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);            } else {                throw new IllegalStateException("Tried to retrieve an unexpected sensor: " + sensor);            }        }        @Override        public void persistConfig(String sensor, SensorEnrichmentConfig config) throws Exception {            finalEnrichmentConfig.put(sensor, config);        }    };    SensorEnrichmentUpdateConfig.updateSensorConfigs(scHandler, threatIntelConfig.getSensorToFieldList());    Assert.assertNotNull(finalEnrichmentConfig.get("bro"));    Assert.assertNotSame(finalEnrichmentConfig.get("bro"), broSc);    Assert.assertEquals(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) finalEnrichmentConfig.get("bro").getThreatIntel().getFieldMap().get(Constants.SIMPLE_HBASE_THREAT_INTEL)).size(), 2);    Assert.assertEquals(1, finalEnrichmentConfig.get("bro").getThreatIntel().getTriageConfig().getRiskLevelRules().size());    Assert.assertTrue(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) finalEnrichmentConfig.get("bro").getThreatIntel().getFieldMap().get(Constants.SIMPLE_HBASE_THREAT_INTEL)).contains("ip_src_addr"));    Assert.assertTrue(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) finalEnrichmentConfig.get("bro").getThreatIntel().getFieldMap().get(Constants.SIMPLE_HBASE_THREAT_INTEL)).contains("ip_dst_addr"));    Assert.assertEquals(finalEnrichmentConfig.get("bro").toJSON(), finalEnrichmentConfig.get("bro").getThreatIntel().getFieldToTypeMap().keySet().size(), 2);    Assert.assertEquals(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) (finalEnrichmentConfig.get("bro").getThreatIntel().getFieldToTypeMap().get("ip_src_addr"))).size(), 2);    Assert.assertTrue(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) (finalEnrichmentConfig.get("bro").getThreatIntel().getFieldToTypeMap().get("ip_src_addr"))).contains("playful"));    Assert.assertTrue(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) (finalEnrichmentConfig.get("bro").getThreatIntel().getFieldToTypeMap().get("ip_src_addr"))).contains("malicious_ip"));    Assert.assertEquals(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) (finalEnrichmentConfig.get("bro").getThreatIntel().getFieldToTypeMap().get("ip_dst_addr"))).size(), 2);    Assert.assertTrue(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) (finalEnrichmentConfig.get("bro").getThreatIntel().getFieldToTypeMap().get("ip_dst_addr"))).contains("playful"));    Assert.assertTrue(finalEnrichmentConfig.get("bro").toJSON(), ((List<String>) (finalEnrichmentConfig.get("bro").getThreatIntel().getFieldToTypeMap().get("ip_dst_addr"))).contains("malicious_ip"));}
public SensorEnrichmentConfig metron_f3309_0(String sensor) throws Exception
{    if (sensor.equals("bro")) {        return JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    } else {        throw new IllegalStateException("Tried to retrieve an unexpected sensor: " + sensor);    }}
public void metron_f3310_0(String sensor, SensorEnrichmentConfig config) throws Exception
{    finalEnrichmentConfig.put(sensor, config);}
public void metron_f3311_0() throws Exception
{    SensorEnrichmentConfig broSc = JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    SensorEnrichmentUpdateConfig config = JSONUtils.INSTANCE.load(enrichmentConfigStr, SensorEnrichmentUpdateConfig.class);    final Map<String, SensorEnrichmentConfig> outputScs = new HashMap<>();    SensorEnrichmentUpdateConfig.SourceConfigHandler scHandler = new SensorEnrichmentUpdateConfig.SourceConfigHandler() {        @Override        public SensorEnrichmentConfig readConfig(String sensor) throws Exception {            if (sensor.equals("bro")) {                return JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);            } else {                throw new IllegalStateException("Tried to retrieve an unexpected sensor: " + sensor);            }        }        @Override        public void persistConfig(String sensor, SensorEnrichmentConfig config) throws Exception {            outputScs.put(sensor, config);        }    };    SensorEnrichmentUpdateConfig.updateSensorConfigs(scHandler, config.getSensorToFieldList());    Assert.assertNotNull(outputScs.get("bro"));    Assert.assertNotSame(outputScs.get("bro"), broSc);    Assert.assertEquals(outputScs.get("bro").toJSON(), ((List<String>) outputScs.get("bro").getEnrichment().getFieldMap().get(Constants.SIMPLE_HBASE_ENRICHMENT)).size(), 2);    Assert.assertTrue(outputScs.get("bro").toJSON(), ((List<String>) outputScs.get("bro").getEnrichment().getFieldMap().get(Constants.SIMPLE_HBASE_ENRICHMENT)).contains("ip_src_addr"));    Assert.assertTrue(outputScs.get("bro").toJSON(), ((List<String>) outputScs.get("bro").getEnrichment().getFieldMap().get(Constants.SIMPLE_HBASE_ENRICHMENT)).contains("ip_dst_addr"));    Assert.assertEquals(outputScs.get("bro").toJSON(), outputScs.get("bro").getEnrichment().getFieldToTypeMap().keySet().size(), 2);    Assert.assertEquals(outputScs.get("bro").toJSON(), ((List<String>) (outputScs.get("bro").getEnrichment().getFieldToTypeMap().get("ip_src_addr"))).size(), 1);    Assert.assertEquals(outputScs.get("bro").toJSON(), ((List<String>) (outputScs.get("bro").getEnrichment().getFieldToTypeMap().get("ip_src_addr"))).get(0), "playful");    Assert.assertEquals(outputScs.get("bro").toJSON(), ((List<String>) (outputScs.get("bro").getEnrichment().getFieldToTypeMap().get("ip_dst_addr"))).size(), 1);    Assert.assertEquals(outputScs.get("bro").toJSON(), ((List<String>) (outputScs.get("bro").getEnrichment().getFieldToTypeMap().get("ip_dst_addr"))).get(0), "playful");}
public SensorEnrichmentConfig metron_f3312_0(String sensor) throws Exception
{    if (sensor.equals("bro")) {        return JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    } else {        throw new IllegalStateException("Tried to retrieve an unexpected sensor: " + sensor);    }}
public void metron_f3313_0(String sensor, SensorEnrichmentConfig config) throws Exception
{    outputScs.put(sensor, config);}
public void metron_f3314_0() throws IOException
{    for (File parserConfig : new File(new File(TestConstants.PARSER_CONFIGS_PATH), "parsers").listFiles()) {        SensorParserConfig config = null;        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(parserConfig), StandardCharsets.UTF_8))) {            String parserStr = IOUtils.toString(br);            config = SensorParserConfig.fromBytes(parserStr.getBytes(StandardCharsets.UTF_8));        }        SensorParserConfig config2 = SensorParserConfig.fromBytes(config.toJSON().getBytes(StandardCharsets.UTF_8));        Assert.assertEquals(config2, config);    }}
public void metron_f3315_0() throws IOException
{    JSONObject message = new JSONObject(ImmutableMap.of("domain_without_subdomains", "yahoo.com"));    EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(conf, EnrichmentConfig.class);    Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));    ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");    List<JSONObject> splits = Configs.STELLAR.splitByFields(message, null, x -> null, handler);    Assert.assertEquals(1, splits.size());    Map<String, Object> split = (Map<String, Object>) (splits.get(0)).get("");    Assert.assertEquals("yahoo.com", split.get("domain_without_subdomains"));    Assert.assertTrue(split.containsKey("dga_result"));    Assert.assertTrue(split.containsKey("dga_model_endpoint"));    Assert.assertTrue(split.containsKey("dga_result_map"));}
public void metron_f3316_0() throws IOException
{    JSONObject message = getMessage();    for (String c : DEFAULT_CONFIGS) {        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        List<JSONObject> splits = Configs.STELLAR.splitByFields(message, null, x -> null, handler);        Assert.assertEquals(1, splits.size());        Map<String, Object> split = (Map<String, Object>) splits.get(0).get("");        Assert.assertEquals(3, split.size());        Assert.assertEquals("stellar_test", split.get("source.type"));        Assert.assertEquals("foo", split.get("string"));        Assert.assertNull(split.get("stmt1"));    }}
public void metron_f3317_0() throws IOException
{    for (String c : DEFAULT_CONFIGS) {        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        List<String> subgroups = Configs.STELLAR.getSubgroups(handler);        Assert.assertEquals("", subgroups.get(0));        Assert.assertEquals(1, subgroups.size());    }}
public void metron_f3318_0() throws IOException
{    JSONObject message = getMessage();    for (String c : GROUPED_CONFIGS) {        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        List<JSONObject> splits = Configs.STELLAR.splitByFields(message, null, x -> null, handler);        Assert.assertEquals(2, splits.size());        {            Map<String, Object> split = (Map<String, Object>) splits.get(0).get("group1");            Assert.assertEquals(2, split.size());            Assert.assertEquals("stellar_test", split.get("source.type"));            Assert.assertNull(split.get("stmt1"));        }        {            Map<String, Object> split = (Map<String, Object>) splits.get(1).get("group2");            Assert.assertEquals(1, split.size());            Assert.assertEquals("foo", split.get("string"));        }    }}
public void metron_f3319_0() throws IOException
{    for (String c : GROUPED_CONFIGS) {        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        List<String> subgroups = Configs.STELLAR.getSubgroups(handler);        Assert.assertEquals("group1", subgroups.get(0));        Assert.assertEquals("group2", subgroups.get(1));        Assert.assertEquals(2, subgroups.size());    }}
public void metron_f3320_0() throws IOException
{    JSONObject message = getMessage();    for (String c : Iterables.concat(MIXED_CONFIGS, ImmutableList.of(tempVarStellarConfig_list))) {        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        List<JSONObject> splits = Configs.STELLAR.splitByFields(message, null, x -> null, handler);        Assert.assertEquals(3, splits.size());        {            Map<String, Object> split = (Map<String, Object>) splits.get(0).get("group1");            Assert.assertEquals(2, split.size());            Assert.assertEquals("stellar_test", split.get("source.type"));            Assert.assertNull(split.get("stmt1"));        }        {            Map<String, Object> split = (Map<String, Object>) splits.get(1).get("group2");            Assert.assertEquals(1, split.size());            Assert.assertEquals("foo", split.get("string"));        }        {            Map<String, Object> split = (Map<String, Object>) splits.get(2).get("");            Assert.assertEquals(1, split.size());            Assert.assertEquals("stellar_test", split.get("source.type"));        }    }}
public void metron_f3321_0() throws IOException
{    for (String c : MIXED_CONFIGS) {        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        List<String> subgroups = Configs.STELLAR.getSubgroups(handler);        Assert.assertEquals("group1", subgroups.get(0));        Assert.assertEquals("group2", subgroups.get(1));        Assert.assertEquals("", subgroups.get(2));        Assert.assertEquals(3, subgroups.size());    }}
public static JSONObject metron_f3322_0() throws IOException
{    Map<String, Object> ret = JSONUtils.INSTANCE.load(message, JSONUtils.MAP_SUPPLIER);    return new JSONObject(ret);}
public void metron_f3323_0()
{    MockitoAnnotations.initMocks(this);}
public void metron_f3324_0()
{    assertThat(PARSERS.createWriterConfig(writer, new ParserConfigurations()), instanceOf(ParserWriterConfiguration.class));    assertThat(ENRICHMENT.createWriterConfig(writer, new EnrichmentConfigurations()), instanceOf(EnrichmentWriterConfiguration.class));    assertThat(INDEXING.createWriterConfig(writer, new IndexingConfigurations()), instanceOf(IndexingWriterConfiguration.class));    assertThat(PROFILER.createWriterConfig(writer, new ProfilerConfigurations()), instanceOf(ProfilerWriterConfiguration.class));}
public void metron_f3325_0()
{    assertThat(PARSERS.createUpdater(reloadable, ParserConfigurations::new), instanceOf(ParserUpdater.class));    assertThat(ENRICHMENT.createUpdater(reloadable, EnrichmentConfigurations::new), instanceOf(EnrichmentUpdater.class));    assertThat(INDEXING.createUpdater(reloadable, IndexingConfigurations::new), instanceOf(IndexingUpdater.class));    assertThat(PROFILER.createUpdater(reloadable, ProfilerConfigurations::new), instanceOf(ProfilerUpdater.class));}
public void metron_f3326_0() throws IOException
{    EnrichmentConfigurations configs = new EnrichmentConfigurations();    configs.updateGlobalConfig(globalJson.getBytes(StandardCharsets.UTF_8));    EnrichmentWriterConfiguration writerConfig = new EnrichmentWriterConfiguration(configs);    assertThat("batch timeout should match global config setting", writerConfig.getBatchTimeout(null), equalTo(555));    assertThat("list should have single batch timeout matching global config setting", writerConfig.getAllConfiguredTimeouts(), equalTo(asList(555)));    assertThat("batch size should match global config setting", writerConfig.getBatchSize(null), equalTo(12345));}
public void metron_f3327_0()
{    IndexingWriterConfiguration config = new IndexingWriterConfiguration("hdfs", new IndexingConfigurations());    Assert.assertEquals(1, config.getBatchSize("foo"));}
public void metron_f3328_0()
{    IndexingWriterConfiguration config = new IndexingWriterConfiguration("hdfs", new IndexingConfigurations());    Assert.assertEquals(0, config.getBatchTimeout("foo"));}
public void metron_f3329_0() throws FileNotFoundException, IOException
{        IndexingWriterConfiguration config = new IndexingWriterConfiguration("hdfs", new IndexingConfigurations());    Assert.assertEquals(0, config.getAllConfiguredTimeouts().size());        IndexingConfigurations iconfigs = new IndexingConfigurations();    iconfigs.updateSensorIndexingConfig(sensorType, new FileInputStream(sampleSensorIndexingConfigPath));    config = new IndexingWriterConfiguration("elasticsearch", iconfigs);    Assert.assertEquals(1, config.getAllConfiguredTimeouts().size());    Assert.assertEquals(7, (long) config.getAllConfiguredTimeouts().get(0));}
public void metron_f3330_0()
{    IndexingWriterConfiguration config = new IndexingWriterConfiguration("hdfs", new IndexingConfigurations());    Assert.assertEquals("foo", config.getIndex("foo"));}
public void metron_f3331_0()
{    ParserWriterConfiguration config = new ParserWriterConfiguration(new ParserConfigurations());    Assert.assertEquals(1, config.getBatchSize("foo"));}
public void metron_f3332_0()
{    ParserWriterConfiguration config = new ParserWriterConfiguration(new ParserConfigurations());    Assert.assertEquals("foo", config.getIndex("foo"));}
public void metron_f3333_0() throws IOException
{    ParserConfigurations parserConfigurations = new ParserConfigurations();    final String sensorName = "some-sensor";    parserConfigurations.updateSensorParserConfig("some-sensor", configJson.getBytes(StandardCharsets.UTF_8));    ParserWriterConfiguration writerConfiguration = new ParserWriterConfiguration(parserConfigurations);    assertThat("batch size should match", writerConfiguration.getBatchSize(sensorName), equalTo(5));    assertThat("batch timeout should match", writerConfiguration.getBatchTimeout(sensorName), equalTo(10000));    assertThat("index should match", writerConfiguration.getIndex(sensorName), equalTo("modified-index"));    assertThat("enabled should match", writerConfiguration.isEnabled(sensorName), equalTo(false));}
public void metron_f3334_0() throws IOException
{    ProfilerConfigurations configs = new ProfilerConfigurations();    configs.updateGlobalConfig(globalJson.getBytes(StandardCharsets.UTF_8));    ProfilerWriterConfiguration writerConfig = new ProfilerWriterConfiguration(configs);    assertThat("batch timeout should match global config setting", writerConfig.getBatchTimeout(null), equalTo(555));    assertThat("list should have single batch timeout matching global config setting", writerConfig.getAllConfiguredTimeouts(), equalTo(asList(555)));    assertThat("batch size should match global config setting", writerConfig.getBatchSize(null), equalTo(12345));}
public void metron_f3335_0()
{    message1.put("value", "message1");    message2.put("value", "message2");}
public void metron_f3336_0()
{    MetronError error = new MetronError().withMessage("test message").withErrorType(Constants.ErrorType.PARSER_ERROR).withSensorType(Collections.singleton("sensorType"));    JSONObject errorJSON = error.getJSONObject();    assertEquals("test message", errorJSON.get(Constants.ErrorFields.MESSAGE.getName()));    assertEquals(Constants.ErrorType.PARSER_ERROR.getType(), errorJSON.get(Constants.ErrorFields.ERROR_TYPE.getName()));    assertEquals("error", errorJSON.get(Constants.SENSOR_TYPE));    assertEquals("sensorType", errorJSON.get(Constants.ErrorFields.FAILED_SENSOR_TYPE.getName()));    String hostName = null;    try {        hostName = InetAddress.getLocalHost().getHostName();    } catch (UnknownHostException uhe) {        }    if (!StringUtils.isEmpty(hostName)) {        assertTrue(((String) errorJSON.get(Constants.ErrorFields.HOSTNAME.getName())).length() > 0);        assertEquals(hostName, (String) errorJSON.get(Constants.ErrorFields.HOSTNAME.getName()));    }    assertTrue(((long) errorJSON.get(Constants.ErrorFields.TIMESTAMP.getName())) > 0);}
public void metron_f3337_0()
{    Throwable e = new Exception("test exception");    MetronError error = new MetronError().withThrowable(e);    JSONObject errorJSON = error.getJSONObject();    assertEquals("java.lang.Exception: test exception", errorJSON.get(Constants.ErrorFields.EXCEPTION.getName()));    assertTrue(((String) errorJSON.get(Constants.ErrorFields.STACK.getName())).startsWith("java.lang.Exception: test exception"));    assertEquals(e.getMessage(), errorJSON.get(Constants.ErrorFields.MESSAGE.getName()));}
public void metron_f3338_0()
{    JSONObject message1 = new JSONObject();    JSONObject message2 = new JSONObject();    message1.put("value", "message1");    message2.put("value", "message2");    MetronError error = new MetronError().withRawMessages(Arrays.asList(message1, message2));    JSONObject errorJSON = error.getJSONObject();    assertEquals("{\"value\":\"message1\"}", errorJSON.get(Constants.ErrorFields.RAW_MESSAGE.getName() + "_0"));    assertEquals("{\"value\":\"message2\"}", errorJSON.get(Constants.ErrorFields.RAW_MESSAGE.getName() + "_1"));    error = new MetronError().addRawMessage("raw message".getBytes(StandardCharsets.UTF_8));    errorJSON = error.getJSONObject();    assertEquals("raw message", errorJSON.get(Constants.ErrorFields.RAW_MESSAGE.getName()));            assertEquals("3b02cb29676bc448c69da1ec5eef7c89f4d6dc6a5a7ce0296ea25b207eea36be", errorJSON.get(Constants.ErrorFields.ERROR_HASH.getName()));    error = new MetronError().addRawMessage(message1);    errorJSON = error.getJSONObject();    assertEquals("{\"value\":\"message1\"}", errorJSON.get(Constants.ErrorFields.RAW_MESSAGE.getName()));    assertEquals("e8aaf87c8494d345aac2d612ffd94fcf0b98c975fe6c4b991e2f8280a3a0bd10", errorJSON.get(Constants.ErrorFields.ERROR_HASH.getName()));}
public void metron_f3339_0()
{    JSONObject message = new JSONObject();    message.put("field1", "value1");    message.put("field2", "value2");    MetronError error = new MetronError().addRawMessage(message).withErrorFields(Sets.newHashSet("field1", "field2"));    JSONObject errorJSON = error.getJSONObject();    assertEquals(Sets.newHashSet("field1", "field2"), Sets.newHashSet(((String) errorJSON.get(Constants.ErrorFields.ERROR_FIELDS.getName())).split(",")));    assertEquals("04a2629c39e098c3944be85f35c75876598f2b44b8e5e3f52c59fa1ac182817c", errorJSON.get(Constants.ErrorFields.ERROR_HASH.getName()));}
public void metron_f3340_0()
{        Map<String, Object> metadata = new HashMap<>();    metadata.put("metron.metadata.topic", "bro");    metadata.put("metron.metadata.partition", 0);    metadata.put("metron.metadata.offset", 123);    JSONObject message = new JSONObject();    message.put("field1", "value1");    message.put("field2", "value2");    MetronError error = new MetronError().addRawMessage(message).withMetadata(metadata);        JSONObject errorMessage = error.getJSONObject();    assertEquals("bro", errorMessage.get("metron.metadata.topic"));    assertEquals(0, errorMessage.get("metron.metadata.partition"));    assertEquals(123, errorMessage.get("metron.metadata.offset"));}
public void metron_f3341_0()
{        Map<String, Object> metadata = new HashMap<>();    JSONObject message = new JSONObject();    message.put("field1", "value1");    message.put("field2", "value2");    MetronError error = new MetronError().addRawMessage(message).withMetadata(metadata);        JSONObject errorMessage = error.getJSONObject();    assertFalse(errorMessage.containsKey("metron.metadata.topic"));    assertFalse(errorMessage.containsKey("metron.metadata.partition"));    assertFalse(errorMessage.containsKey("metron.metadata.offset"));}
public void metron_f3342_0() throws Exception
{    String actual = new DeDotFieldNameConverter().convert("testfield.with.colons");    assertEquals("testfield:with:colons", actual);}
public void metron_f3343_0() throws Exception
{    String actual = new DeDotFieldNameConverter().convert("test-field-no-colons");    assertEquals("test-field-no-colons", actual);}
private WriterConfiguration metron_f3344_0(String writer, String sensor, String json) throws Exception
{    IndexingConfigurations indexingConfig = new IndexingConfigurations();    indexingConfig.updateSensorIndexingConfig(sensor, json.getBytes(StandardCharsets.UTF_8));    return new IndexingWriterConfiguration(writer, indexingConfig);}
public void metron_f3345_0() throws Exception
{    final String writer = "elasticsearch";    final String sensor = "bro";    WriterConfiguration config = createConfig(writer, sensor, jsonWithDedot);        FieldNameConverter converter = FieldNameConverters.create(sensor, config);    assertEquals(FieldNameConverters.DEDOT, converter);}
public void metron_f3346_0() throws Exception
{    final String writer = "elasticsearch";    final String sensor = "bro";    WriterConfiguration config = createConfig(writer, sensor, jsonWithNoop);        FieldNameConverter converter = FieldNameConverters.create(sensor, config);    assertEquals(FieldNameConverters.NOOP, converter);}
public void metron_f3347_0() throws Exception
{    final String writer = "elasticsearch";    final String sensor = "bro";    WriterConfiguration config = createConfig(writer, sensor, jsonWithNoConverter);        FieldNameConverter converter = FieldNameConverters.create(sensor, config);    assertEquals(FieldNameConverters.DEDOT, converter);}
public void metron_f3348_0() throws Exception
{    final String writer = "elasticsearch";    final String sensor = "bro";        WriterConfiguration config = createConfig(writer, sensor, jsonWithNoConverter);    assertEquals(FieldNameConverters.DEDOT, FieldNameConverters.create(sensor, config));        WriterConfiguration newConfig = createConfig(writer, sensor, jsonWithNoop);    assertEquals(FieldNameConverters.NOOP, FieldNameConverters.create(sensor, newConfig));}
public void metron_f3349_0() throws Exception
{    final String writer = "elasticsearch";    final String sensor = "bro";    WriterConfiguration config = createConfig(writer, sensor, jsonWithInvalidConverter);        FieldNameConverter converter = FieldNameConverters.create(sensor, config);    assertEquals(FieldNameConverters.DEDOT, converter);}
public void metron_f3350_0() throws Exception
{    final String writer = "elasticsearch";    final String sensor = "bro";    WriterConfiguration config = createConfig(writer, sensor, jsonWithInvalidConverter);        FieldNameConverter converter = FieldNameConverters.create(sensor, config);    assertEquals(FieldNameConverters.DEDOT, converter);}
public Map<String, Object> metron_f3351_0(Map<String, Object> input, List<String> outputField, LinkedHashMap<String, Object> fieldMappingConfig, Context context, Map<String, Object>... sensorConfig)
{    return ImmutableMap.of(outputField.get(0), Joiner.on(fieldMappingConfig.get("delim").toString()).join(input.entrySet()));}
public void metron_f3352_0() throws IOException
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(config));    Assert.assertEquals(1, c.getFieldTransformations().size());    Assert.assertEquals(IPProtocolTransformation.class, c.getFieldTransformations().get(0).getFieldTransformation().getClass());    Assert.assertEquals(ImmutableList.of("protocol"), c.getFieldTransformations().get(0).getInput());}
public void metron_f3353_0() throws IOException
{    SensorParserConfig.fromBytes(Bytes.toBytes(badConfigMissingMapping));}
public void metron_f3354_0() throws IOException
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(complexConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    Assert.assertNotNull(handler);    Assert.assertEquals(ImmutableMap.of("output", "field1=value1,field2=value2"), handler.transform(new JSONObject(ImmutableMap.of("field1", "value1", "field2", "value2")), Context.EMPTY_CONTEXT(), c.getParserConfig()));}
public void metron_f3355_0() throws IOException
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(config));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    Assert.assertNotNull(handler);    Assert.assertEquals(ImmutableMap.of("protocol", "TCP"), handler.transform(new JSONObject(ImmutableMap.of("protocol", 6)), Context.EMPTY_CONTEXT(), c.getParserConfig()));}
private String metron_f3356_0(String in, String config) throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(config));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            put("in_field", in);                        put("dummy_field", "dummy");        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    return (String) input.get("out_field");}
public void metron_f3357_0() throws Exception
{    Assert.assertEquals("option_1", transform("foo", routeSingleInSingleOut));    Assert.assertNull(transform("bar", routeSingleInSingleOut));}
public void metron_f3358_0() throws Exception
{    Assert.assertEquals("option_2", transform("I am mortron", routeSingleInSingleOut));    Assert.assertEquals("option_2", transform("metron is for smelling", routeSingleInSingleOut));}
public void metron_f3359_0() throws Exception
{    Assert.assertEquals("option_1", transform("metron is for foorensic cybersecurity", routeSingleInSingleOut));}
public void metron_f3360_0() throws Exception
{    Assert.assertNull(transform("metron", routeMissingInput));}
public void metron_f3361_0() throws Exception
{    Assert.assertNull(transform("metron", routeMissingOutput));}
public void metron_f3362_0() throws Exception
{    Assert.assertEquals("option_1", transform("foo", routeMultiOutput));    Assert.assertNull(transform("bar", routeMultiOutput));}
public void metron_f3363_0() throws Exception
{    Assert.assertEquals("option_2", transform("metron", routeBadRegex));}
public void metron_f3364_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(removeUnconditionalConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            put("field1", "foo");        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertFalse(input.containsKey("field1"));}
public void metron_f3365_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(removeConditionalConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    {        JSONObject input = new JSONObject(new HashMap<String, Object>() {            {                put("field1", "foo");            }        });        handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());                Assert.assertTrue(input.containsKey("field1"));        Assert.assertFalse(input.containsKey("field2"));    }    {        JSONObject input = new JSONObject(new HashMap<String, Object>() {            {                put("field1", "foo");                put("field2", "bar");            }        });        handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());                Assert.assertTrue(input.containsKey("field1"));        Assert.assertTrue(input.containsKey("field2"));    }    {        JSONObject input = new JSONObject(new HashMap<String, Object>() {            {                put("field1", "bar");                put("field2", "foo");            }        });                handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());        Assert.assertFalse(input.containsKey("field1"));        Assert.assertTrue(input.containsKey("field2"));    }}
public void metron_f3366_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(smoketestConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            for (int i = 1; i <= 10; ++i) {                put("old_field" + i, "f" + i);            }        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertEquals("f1", input.get("new_field1"));    Assert.assertEquals("f2", input.get("new_field2"));    for (int i = 3; i <= 10; ++i) {        Assert.assertEquals("f" + i, input.get("old_field" + i));    }    Assert.assertFalse(input.containsKey("old_field1"));    Assert.assertFalse(input.containsKey("old_field2"));    Assert.assertEquals(10, input.size());}
public void metron_f3367_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(renameMissingField));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            for (int i = 2; i <= 10; ++i) {                put("old_field" + i, "f" + i);            }        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertFalse(input.containsKey("new_field1"));    for (int i = 2; i <= 10; ++i) {        Assert.assertEquals("f" + i, input.get("old_field" + i));    }    Assert.assertEquals(9, input.size());}
public void metron_f3368_0() throws Exception
{    SensorParserConfig sensorConfig = SensorParserConfig.fromBytes(Bytes.toBytes(selectSingleFieldConfig));    FieldTransformer handler = Iterables.getFirst(sensorConfig.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            put("field1", "foo");            put("field2", "bar");        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertTrue(input.containsKey("field1"));    Assert.assertFalse(input.containsKey("field2"));    Assert.assertEquals(1, input.size());}
public void metron_f3369_0() throws Exception
{    SensorParserConfig sensorConfig = SensorParserConfig.fromBytes(Bytes.toBytes(selectMultiFieldConfig));    FieldTransformer handler = Iterables.getFirst(sensorConfig.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            put("field1", "foo");            put("field2", "bar");            put("field3", "bar2");        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertTrue(input.containsKey("field1"));    Assert.assertTrue(input.containsKey("field2"));    Assert.assertFalse(input.containsKey("field3"));    Assert.assertEquals(2, input.size());}
public void metron_f3370_0() throws Exception
{    SensorParserConfig sensorConfig = SensorParserConfig.fromBytes(Bytes.toBytes(selectSingleFieldConfig));    FieldTransformer handler = Iterables.getFirst(sensorConfig.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            put("timestamp", 12345);            put("original_string", "foo,bar");            put("source.type", "test");            put("field1", "foo");            put("field2", "bar");        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertTrue(input.containsKey("timestamp"));    Assert.assertTrue(input.containsKey("original_string"));    Assert.assertTrue(input.containsKey("source.type"));    Assert.assertTrue(input.containsKey("field1"));    Assert.assertFalse(input.containsKey("field2"));    Assert.assertEquals(4, input.size());}
public static Collection<Object[]> metron_f3371_0()
{    return Arrays.asList(new Object[][] { { CachingStellarProcessor.createCache(ImmutableMap.of(CachingStellarProcessor.MAX_CACHE_SIZE_PARAM, 10)) }, { CachingStellarProcessor.createCache(ImmutableMap.of(CachingStellarProcessor.MAX_CACHE_SIZE_PARAM, 1)) }, { CachingStellarProcessor.createCache(ImmutableMap.of(CachingStellarProcessor.MAX_CACHE_SIZE_PARAM, 0)) }, { null } });}
public void metron_f3372_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(configAll));    JSONObject input = new JSONObject();    input.put("source.type", "test");    for (FieldTransformer handler : c.getFieldTransformations()) {        handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    }    Assert.assertEquals(2, input.size());    Assert.assertTrue(input.containsKey("new_field"));    Assert.assertEquals("test", input.get("new_field"));}
public void metron_f3373_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(configRename));    {        JSONObject input = new JSONObject();        input.put("old_field", "val");        input.put("old_field2", "val2");        for (FieldTransformer handler : c.getFieldTransformations()) {            handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());        }        Assert.assertEquals(2, input.size());        Assert.assertTrue(input.containsKey("new_field"));        Assert.assertEquals("val", input.get("new_field"));        Assert.assertEquals("val2", input.get("new_field2"));        Assert.assertTrue(!input.containsKey("old_field"));        Assert.assertTrue(!input.containsKey("old_field2"));    }    {        JSONObject input = new JSONObject();        input.put("old_field", "val");        for (FieldTransformer handler : c.getFieldTransformations()) {            handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());        }        Assert.assertEquals(1, input.size());        Assert.assertTrue(input.containsKey("new_field"));        Assert.assertEquals("val", input.get("new_field"));    }}
public void metron_f3374_0() throws Exception
{    /*    Despite the domain being weird, URL_TO_HOST should allow it to pass through.    However, because it does NOT form a proper domain (no TLD), DOMAIN_REMOVE_SUBDOMAINS returns    null indicating that the input is semantically incorrect.     */    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(configNumericDomain));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject();    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertTrue(input.containsKey("full_hostname"));    Assert.assertEquals("1234567890123456789012345678901234567890123456789012345678901234567890", input.get("full_hostname"));    Assert.assertFalse(input.containsKey("domain_without_subdomains"));}
public void metron_f3375_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(badConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject();    try {        handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    } catch (IllegalStateException ex) {        Assert.assertTrue(ex.getMessage().contains("URL_TO_HOST"));        Assert.assertTrue(ex.getMessage().contains("123"));        throw ex;    }}
public void metron_f3376_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(intermediateValuesConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    int expected = 3;    Assert.assertEquals(expected, input.get("final_value"));    Assert.assertFalse(input.containsKey("value1"));    Assert.assertFalse(input.containsKey("value2"));}
public void metron_f3377_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(stellarConfigEspecial));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            put("timestamp", "2016-01-05 17:02:30");        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    long expected = 1452013350000L;    Assert.assertEquals(expected, input.get("utc_timestamp"));    Assert.assertTrue(input.containsKey("timestamp"));    Assert.assertTrue(input.containsKey("newStellarField"));}
public void metron_f3378_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(stellarConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    JSONObject input = new JSONObject(new HashMap<String, Object>() {        {            put("timestamp", "2016-01-05 17:02:30");        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    long expected = 1452013350000L;    Assert.assertEquals(expected, input.get("utc_timestamp"));    Assert.assertTrue(input.containsKey("timestamp"));}
public void metron_f3379_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(stellarConfig));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);        JSONObject input = new JSONObject(new HashMap<String, Object>() {        {        }    });    handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());    Assert.assertFalse(input.containsKey("utc_timestamp"));    Assert.assertTrue(input.isEmpty());}
public void metron_f3380_0() throws Exception
{    SensorParserConfig c = SensorParserConfig.fromBytes(Bytes.toBytes(stellarConfig_multi));    FieldTransformer handler = Iterables.getFirst(c.getFieldTransformations(), null);    {                JSONObject input = new JSONObject(new HashMap<String, Object>() {            {                put("timestamp", "2016-01-05 17:02:30");                put("url", "https://caseystella.com/blog");                                put("dc", "portland");            }        });        handler.transformAndUpdate(input, Context.EMPTY_CONTEXT());        long expected = 1452013350000L;        Assert.assertEquals(expected, input.get("utc_timestamp"));        Assert.assertEquals("caseystella.com", input.get("url_host"));        Assert.assertEquals("https", input.get("url_protocol"));        Assert.assertTrue(input.containsKey("timestamp"));        Assert.assertTrue(input.containsKey("url"));    }    {                JSONObject input = new JSONObject(new HashMap<String, Object>() {            {                put("timestamp", "2016-01-05 17:02:30");                put("url", "https://caseystella.com/blog");                put("dc", "london");            }        });        handler.transformAndUpdate(input, Context.EMPTY_CONTEXT(), c.getParserConfig());        long expected = 1452013350000L;        Assert.assertEquals(expected, input.get("utc_timestamp"));        Assert.assertEquals("caseystella.com", input.get("url_host"));        Assert.assertEquals("https", input.get("url_protocol"));        Assert.assertTrue(input.containsKey("timestamp"));        Assert.assertTrue(input.containsKey("url"));    }        {        JSONObject input = new JSONObject(new HashMap<String, Object>() {            {                put("timestamp", "2016-01-05 17:02:30");                put("url", "https://caseystella.com/blog");            }        });        handler.transformAndUpdate(input, Context.EMPTY_CONTEXT(), c.getParserConfig());        long expected = 1452013350000L;        Assert.assertEquals(expected, input.get("utc_timestamp"));        Assert.assertEquals("caseystella.com", input.get("url_host"));        Assert.assertEquals("https", input.get("url_protocol"));        Assert.assertTrue(input.containsKey("timestamp"));        Assert.assertTrue(input.containsKey("url"));    }}
public Configurations metron_f3381_0(String config) throws IOException
{    Configurations configurations = new Configurations();    configurations.updateGlobalConfig(Bytes.toBytes(config));    return configurations;}
public FieldValidator metron_f3382_0(Configurations configurations) throws IOException
{    return configurations.getFieldValidations().get(0);}
public boolean metron_f3383_0(String config, Map<String, Object> input) throws IOException
{    Configurations configurations = getConfiguration(config);    FieldValidator validator = getValidator(configurations);    return validator.isValid(new JSONObject(input), configurations.getGlobalConfig(), Context.EMPTY_CONTEXT());}
public void metron_f3384_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "caseystella.com")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "caseystella.com")));    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "www.hotmail.co.uk")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "www.hotmail.co.uk")));}
public void metron_f3385_0() throws IOException
{    Assert.assertFalse(runPredicate("IS_DOMAIN()", Collections.emptyMap()));    Assert.assertFalse(runPredicate("IS_DOMAIN('')", Collections.emptyMap()));}
public void metron_f3386_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "foo")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "foo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "caseystella.turtle")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "caseystella.turtle")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 2.7f)));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", 2.7f)));}
public void metron_f3387_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", "www.gmail.com", "field2", "www.hotmail.com")));    Assert.assertTrue(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "www.gmail.com", "field2", "www.hotmail.com")));}
public void metron_f3388_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field2", "hotmail.edu")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field2", "hotmail.edu")));    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field1", "", "field2", "gmail.com")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "", "field2", "gmail.com")));}
public void metron_f3389_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "me@caseystella.com")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "me@caseystella.com")));    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "me@www.hotmail.co.uk")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "me@www.hotmail.co.uk")));}
public void metron_f3390_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "me@foo")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "me@foo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "caseystella.turtle")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "caseystella.turtle")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "caseystella.com")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "caseystella.com")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 2.7f)));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", 2.7f)));}
public void metron_f3391_0() throws IOException
{    Assert.assertFalse(runPredicate("IS_EMAIL()", Collections.emptyMap()));    Assert.assertFalse(runPredicate("IS_EMAIL('')", Collections.emptyMap()));}
public void metron_f3392_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", "me@www.gmail.com", "field2", "me@www.hotmail.com")));    Assert.assertTrue(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "me@www.gmail.com", "field2", "me@www.hotmail.com")));}
public void metron_f3393_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field2", "me@hotmail.edu")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field2", "me@hotmail.edu")));    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field1", "", "field2", "me@gmail.com")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "", "field2", "me@gmail.com")));}
public void metron_f3394_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "127.0.0.1")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "127.0.0.1")));}
public void metron_f3395_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "2014/05/01")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "2014/05/01")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 2.3f)));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", 2.3f)));}
public void metron_f3396_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", "192.168.0.1", "field2", "127.0.0.2")));    Assert.assertTrue(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "192.168.0.1", "field2", "127.0.0.2")));}
public void metron_f3397_0() throws IOException
{    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field1", 1, "field2", "192.168.1")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", 1, "field2", "192.168.1")));}
public void metron_f3398_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFieldsMultipleTypes, ImmutableMap.of("field1", "192.168.0.1", "field2", "127.0.0.2")));    Assert.assertTrue(runPredicate(validWithMultipleFieldsMultipleTypes_MQL, ImmutableMap.of("field1", "192.168.0.1", "field2", "127.0.0.2")));}
public void metron_f3399_0() throws IOException
{    Assert.assertFalse(execute(validWithMultipleFieldsMultipleTypes, ImmutableMap.of("field1", 1, "field2", "192.168.1")));    Assert.assertFalse(runPredicate(validWithMultipleFieldsMultipleTypes_MQL, ImmutableMap.of("field1", 1, "field2", "192.168.1")));}
public void metron_f3400_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "http://caseystella.com/foo")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "http://caseystella.com/foo")));    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "https://www.hotmail.co.uk")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "https://www.hotmail.co.uk")));}
public void metron_f3401_0() throws IOException
{    Assert.assertFalse(runPredicate("IS_URL()", Collections.emptyMap()));    Assert.assertFalse(runPredicate("IS_URL('')", Collections.emptyMap()));}
public void metron_f3402_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "foo")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "foo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "http://caseystella.turtle")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "http://caseystella.turtle")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 2.7f)));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", 2.7f)));}
public void metron_f3403_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", "ftp://www.gmail.com", "field2", "http://www.hotmail.com")));    Assert.assertTrue(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "ftp://www.gmail.com", "field2", "http://www.hotmail.com")));}
public void metron_f3404_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field2", "http://hotmail.edu")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field2", "http://hotmail.edu")));    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field1", "", "field2", "http://gmail.com")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "", "field2", "http://gmail.com")));}
public void metron_f3405_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "2014-05-01")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "2014-05-01")));}
public void metron_f3406_0() throws IOException
{    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", 2.3f)));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "2014/05/01")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "2014/05/01")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 2.3f)));        Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "2014-25-01")));        Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "2014-05-32")));}
public void metron_f3407_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", "2014-06-01", "field2", "2014-06-02")));    Assert.assertTrue(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "2014-06-01", "field2", "2014-06-02")));}
public void metron_f3408_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field2", "2014-06-02")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field2", "2014-06-02")));    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field1", 1, "field2", "2014-06-02")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", 1, "field2", "2014-06-02")));    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field3", "2014-06-02")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field3", "2014-06-02")));}
public void metron_f3409_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", 1)));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", 1)));    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "1")));    Assert.assertTrue(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "1")));}
public void metron_f3410_0() throws IOException
{    Assert.assertFalse(runPredicate("IS_INTEGER()", Collections.emptyMap()));    Assert.assertFalse(runPredicate("IS_INTEGER('')", Collections.emptyMap()));}
public void metron_f3411_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "foo")));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", "foo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 2.3f)));    Assert.assertFalse(runPredicate(validWithSingleField_MQL, ImmutableMap.of("field1", 2.3f)));}
public void metron_f3412_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", 1, "field2", "2")));    Assert.assertTrue(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", 1, "field2", "2")));}
public void metron_f3413_0() throws IOException
{    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field2", "foo")));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field2", "foo")));    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field1", "", "field2", 1)));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", "", "field2", 1)));    Assert.assertFalse(execute(validWithMultipleFields, ImmutableMap.of("field1", " ", "field2", 2)));    Assert.assertFalse(runPredicate(validWithMultipleFields_MQL, ImmutableMap.of("field1", " ", "field2", 2)));}
public void metron_f3414_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "foo")));}
public void metron_f3415_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field2", "foo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", " ")));}
public void metron_f3416_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", "foo", "field2", "bar")));}
public void metron_f3417_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field2", "foo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "", "field2", "bar")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", " ", "field2", "bar")));}
public void metron_f3418_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "foo")));    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "fop")));    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field1", "fo")));}
public void metron_f3419_0() throws IOException
{    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", "flo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 2.3f)));}
public void metron_f3420_0() throws IOException
{    Assert.assertTrue(execute(validWithMultipleFields, ImmutableMap.of("field1", "fooo", "field2", "foll")));}
public void metron_f3421_0() throws IOException
{    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field2", "foo")));    Assert.assertFalse(execute(validWithSingleField, ImmutableMap.of("field1", 1, "field2", "foo")));    Assert.assertTrue(execute(validWithSingleField, ImmutableMap.of("field3", "foo")));}
public void metron_f3422_0() throws IOException
{    Assert.assertTrue(execute(validQueryConfig, ImmutableMap.of("field1", "foo")));}
public void metron_f3423_0() throws IOException
{    Assert.assertTrue(execute(validQueryConfig_map, ImmutableMap.of("dc", "la")));}
public void metron_f3424_0() throws IOException
{    Assert.assertFalse(execute(validQueryConfig_map, ImmutableMap.of("dc", "nyc")));    Assert.assertFalse(execute(validQueryConfig_map, ImmutableMap.of("foo", "nyc")));}
public void metron_f3425_0() throws IOException
{    Assert.assertFalse(execute(validQueryConfig, ImmutableMap.of("field2", "foo")));}
public void metron_f3426_0() throws IOException
{    getConfiguration(invalidQueryConfig1);}
public void metron_f3427_0() throws IOException
{    getConfiguration(invalidQueryConfig2);}
public void metron_f3428_0() throws IOException
{    {        Configurations configurations = getConfiguration(validValidationConfigWithStringInput);        Assert.assertNotNull(configurations.getFieldValidations());        Assert.assertEquals(1, configurations.getFieldValidations().size());        Assert.assertEquals(ImmutableList.of("field1"), configurations.getFieldValidations().get(0).getInput());    }    {        Configurations configurations = getConfiguration(validValidationConfigWithListInput);        Assert.assertNotNull(configurations.getFieldValidations());        Assert.assertEquals(1, configurations.getFieldValidations().size());        Assert.assertEquals(ImmutableList.of("field1", "field2"), configurations.getFieldValidations().get(0).getInput());    }}
public void metron_f3429_0() throws IOException
{    getConfiguration(invalidValidationConfig);}
public void metron_f3430_0()
{    MockitoAnnotations.initMocks(this);    configSupplier = () -> ImmutableMap.of("performance.logging.percent.records", thresholdPercent);    when(thresholdCalc.isPast(thresholdPercent)).thenReturn(false).thenReturn(false).thenReturn(true);    when(logger.isDebugEnabled()).thenReturn(true);    when(timing.exists("t1")).thenReturn(true);    perfLogger = new PerformanceLogger(configSupplier, logger, thresholdCalc, timing);}
public void metron_f3431_0() throws Exception
{    when(timing.getElapsed("t1")).thenReturn(111L).thenReturn(222L).thenReturn(333L);    perfLogger.mark("t1");    perfLogger.log("t1");    perfLogger.log("t1");    perfLogger.log("t1");    verify(timing).mark("t1");    verify(logger, times(1)).debug(anyString(), anyObject(), eq(111L), eq(""));}
public void metron_f3432_0() throws Exception
{    when(timing.getElapsed("t1")).thenReturn(111L).thenReturn(222L).thenReturn(333L);    perfLogger.mark("t1");    perfLogger.log("t1", "my message");    perfLogger.log("t1", "my message");    perfLogger.log("t1", "my message");    verify(timing).mark("t1");    verify(logger, times(1)).debug(anyString(), anyObject(), eq(111L), eq("my message"));}
public void metron_f3433_0() throws Exception
{    when(thresholdCalc.isPast(thresholdPercent)).thenReturn(true);    when(timing.getElapsed("t1")).thenReturn(111L);    when(timing.getElapsed("t2")).thenReturn(222L);    when(timing.getElapsed("t3")).thenReturn(333L);    when(timing.exists("t1")).thenReturn(true);    when(timing.exists("t2")).thenReturn(false);    when(timing.exists("t3")).thenReturn(false);    perfLogger.mark("t1");    perfLogger.log("t1", "my message");    perfLogger.log("t2", "my message");    perfLogger.log("t3", "my message");    verify(timing).mark("t1");    verify(timing, never()).mark("t2");    verify(timing, never()).mark("t3");    verify(logger).debug(anyString(), anyObject(), eq(111L), eq("my message"));    verify(logger).debug(anyString(), eq("WARNING - MARK NOT SET"), eq(222L), eq("my message"));    verify(logger).debug(anyString(), eq("WARNING - MARK NOT SET"), eq(333L), eq("my message"));}
public void metron_f3434_0() throws Exception
{    when(thresholdCalc.isPast(thresholdPercent)).thenReturn(true);    when(timing.getElapsed("t1")).thenReturn(111L);    when(timing.getElapsed("t2")).thenReturn(222L);    perfLogger.mark("t1");    perfLogger.mark("t2");    perfLogger.log("t2", "my message 2");    perfLogger.log("t1", "my message 1");    verify(timing).mark("t1");    verify(timing).mark("t2");    verify(logger).debug(anyString(), anyObject(), eq(111L), eq("my message 1"));    verify(logger).debug(anyString(), anyObject(), eq(222L), eq("my message 2"));}
public void metron_f3435_0() throws Exception
{    configSupplier = () -> new HashMap<>();    when(thresholdCalc.isPast(1)).thenReturn(false).thenReturn(false).thenReturn(true);    when(timing.getElapsed("t1")).thenReturn(111L).thenReturn(222L).thenReturn(333L);    perfLogger.mark("t1");    perfLogger.log("t1", "my message");    perfLogger.log("t1", "my message");    perfLogger.log("t1", "my message");    verify(timing).mark("t1");    verify(logger, times(1)).debug(anyString(), anyObject(), eq(111L), eq("my message"));}
public void metron_f3436_0() throws Exception
{    when(logger.isDebugEnabled()).thenReturn(false);    when(timing.getElapsed("t1")).thenReturn(111L).thenReturn(222L).thenReturn(333L);    perfLogger.mark("t1");    perfLogger.log("t1", "my message");    perfLogger.log("t1", "my message");    perfLogger.log("t1", "my message");    verify(timing).mark("t1");    verify(logger, times(0)).debug(anyString(), anyObject(), eq(111L), eq("my message"));}
public void metron_f3437_0() throws Exception
{    when(thresholdCalc.isPast(thresholdPercent)).thenReturn(true);    when(timing.getElapsed("t1")).thenReturn(111L).thenReturn(222L).thenReturn(333L).thenReturn(444L);    perfLogger.mark("t1");    perfLogger.log("t1", "my {} message", "1");    perfLogger.log("t1", "my {} message {}", "1", "2");    perfLogger.log("t1", "my {} message {} {}", "1", "2", "3");    perfLogger.log("t1", "my {} message {} {} {}", "1", "2", "3", "4");    verify(timing).mark("t1");    verify(logger, times(1)).debug(anyString(), anyObject(), eq(111L), eq("my 1 message"));    verify(logger, times(1)).debug(anyString(), anyObject(), eq(222L), eq("my 1 message 2"));    verify(logger, times(1)).debug(anyString(), anyObject(), eq(333L), eq("my 1 message 2 3"));    verify(logger, times(1)).debug(anyString(), anyObject(), eq(444L), eq("my 1 message 2 3 4"));}
public void metron_f3438_0()
{    when(logger.isDebugEnabled()).thenReturn(true);    assertThat(perfLogger.isDebugEnabled(), equalTo(true));}
public void metron_f3439_0()
{    timing = new Timing();}
public void metron_f3440_0() throws InterruptedException
{    timing.mark("mark1");    long tlast = 0;    for (int i = 0; i < 10; i++) {        tlast = timing.getElapsed("mark1");        Thread.sleep(10);        assertThat(timing.getElapsed("mark1") > tlast, equalTo(true));    }}
public void metron_f3441_0() throws InterruptedException
{    timing.mark("mark1");    timing.mark("mark2");    long tlast1 = 0;    long tlast2 = 0;    for (int i = 0; i < 10; i++) {        tlast1 = timing.getElapsed("mark1");        tlast2 = timing.getElapsed("mark2");        Thread.sleep(10);        assertThat(timing.getElapsed("mark1") > tlast1, equalTo(true));        assertThat(timing.getElapsed("mark2") > tlast2, equalTo(true));    }}
public void metron_f3442_0() throws InterruptedException
{    timing.mark("mark1");    long tlast1 = 0;    for (int i = 0; i < 10; i++) {        tlast1 = timing.getElapsed("mark1");        Thread.sleep(10);        assertThat(timing.getElapsed("mark1") > tlast1, equalTo(true));        assertThat(timing.getElapsed("mark2"), equalTo(0L));    }}
public void metron_f3443_0() throws InterruptedException
{    timing.mark("mark1");    long tlast1 = 0;    for (int i = 0; i < 5; i++) {        Thread.sleep(10);        tlast1 = timing.getElapsed("mark1");        timing.mark("mark1");        assertThat(timing.getElapsed("mark1") < tlast1, equalTo(true));    }}
public void metron_f3444_0()
{    timing.mark("mark1");    assertThat(timing.exists("mark1"), equalTo(true));    assertThat(timing.exists("mark2"), equalTo(false));    assertThat(timing.exists("mark3"), equalTo(false));}
public void metron_f3445_0() throws Exception
{    Clock clock = new Clock();    long t1 = clock.currentTimeMillis();    Thread.sleep(50);    long t2 = clock.currentTimeMillis();    Thread.sleep(50);    long t3 = clock.currentTimeMillis();    assertThat("t3 should be greater", t3 > t2, equalTo(true));    assertThat("t2 should be greater", t2 > t1, equalTo(true));}
public void metron_f3446_0() throws Exception
{    Clock clock = Mockito.spy(Clock.class);    SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmssSSSZ");    sdf.setTimeZone(TimeZone.getTimeZone("UTC"));    Date date = sdf.parse("20160615183527162+0000");    Mockito.when(clock.currentTimeMillis()).thenReturn(date.getTime());    assertThat("time not right", clock.currentTimeFormatted("yyyyMMddHHmmssSSSZ"), equalTo("20160615183527162+0000"));}
public static void metron_f3447_0() throws Exception
{    for (Map.Entry<String, EnumMap<TyposquattingStrategies, Set<String>>> kv : expected.entrySet()) {        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("src/test/resources/typosquat/" + kv.getKey() + ".csv"), StandardCharsets.UTF_8))) {            for (String line = null; (line = br.readLine()) != null; ) {                if (line.startsWith("#")) {                    continue;                }                Iterable<String> tokens = Splitter.on(",").split(line);                String name = Iterables.get(tokens, 0);                String domain = Iterables.get(tokens, 1);                domain = domain.replaceAll(".com", "");                EnumMap<TyposquattingStrategies, Set<String>> expectedValues = kv.getValue();                if (typesToSkip.contains(name)) {                    continue;                }                TyposquattingStrategies strategy = TyposquattingStrategies.byName(name);                Assert.assertNotNull("Couldn't find " + name, strategy);                Set<String> s = expectedValues.get(strategy);                if (s == null) {                    s = new HashSet<>();                    expectedValues.put(strategy, s);                }                s.add(domain);            }        }    }}
public static Collection<Object[]> metron_f3448_0()
{    List<Object[]> ret = new ArrayList<>();    for (TyposquattingStrategies strategy : TyposquattingStrategies.values()) {        ret.add(new Object[] { strategy });    }    return ret;}
public void metron_f3449_0(String domain, TyposquattingStrategies strategy)
{    Set<String> expectedValues = expected.get(domain).get(strategy);    Set<String> actualValues = strategy.generateCandidates(domain);    Assert.assertFalse(actualValues.contains(domain));    {        Sets.SetView<String> vals = Sets.difference(expectedValues, actualValues);        String diff = Joiner.on(",").join(vals);        Assert.assertTrue(strategy.name() + ": Found values expected but not generated: " + diff, vals.isEmpty());    }}
public void metron_f3450_0()
{    for (String domain : expected.keySet()) {        assertExpected(domain, strategy);    }}
public void metron_f3451_0()
{    for (String domain : expected.keySet()) {        Set<String> expectedAll = TyposquattingStrategies.generateAllCandidates(domain);        Set<String> generatedAll = (Set<String>) StellarProcessorUtils.run("DOMAIN_TYPOSQUAT(domain)", ImmutableMap.of("domain", domain));        Assert.assertTrue(Sets.symmetricDifference(expectedAll, generatedAll).isEmpty());    }}
public void metron_f3452_0() throws IOException
{    tempDir = TestUtils.createTempDir(this.getClass().getName());    textFile = new File(tempDir, "test-text-file.txt");    TestUtils.write(textFile, SAMPLE_TEXT);}
public void metron_f3453_0() throws IOException
{    File gzipFile = new File(tempDir, "test-gz-compression-file.gz");    CompressionStrategies.GZIP.compress(textFile, gzipFile);    assertThat(CompressionStrategies.GZIP.test(gzipFile), equalTo(true));}
public void metron_f3454_0() throws IOException
{    File gzipFile = new File(tempDir, "test-gz-decompress.gz");    CompressionStrategies.GZIP.compress(textFile, gzipFile);    assertThat("gzipped file should exist", gzipFile.exists(), equalTo(true));    File unzippedText = new File(tempDir, "test-gz-decompressed.txt");    CompressionStrategies.GZIP.decompress(gzipFile, unzippedText);    assertThat("decompressed file should exist", unzippedText.exists(), equalTo(true));    String actual = TestUtils.read(unzippedText);    assertThat("decompressed text should match", actual, equalTo(SAMPLE_TEXT));}
public static void metron_f3455_0() throws IOException
{    if (dataFile.exists()) {        dataFile.delete();    }    Files.write(dataFile.toPath(), data.getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE_NEW, StandardOpenOption.TRUNCATE_EXISTING);    dataFile.deleteOnExit();}
public static BufferedReader metron_f3456_0()
{    try {        return new BufferedReader(new InputStreamReader(new FileInputStream(dataFile), StandardCharsets.UTF_8));    } catch (FileNotFoundException e) {        throw new IllegalStateException(e.getMessage(), e);    }}
private static void metron_f3457_0(Map<String, Integer> count)
{    Assert.assertEquals(5, count.size());    Assert.assertEquals(3, (int) count.get("foo"));    Assert.assertEquals(2, (int) count.get("bar"));    Assert.assertEquals(1, (int) count.get("and"));    Assert.assertEquals(1, (int) count.get("the"));}
public void metron_f3458_0() throws FileNotFoundException
{    try (Stream<String> stream = ReaderSpliterator.lineStream(getReader(), 2)) {        Map<String, Integer> count = stream.parallel().map(s -> s.trim()).collect(Collectors.toMap(s -> s, s -> 1, Integer::sum));        validateMapCount(count);    }}
public void metron_f3459_0() throws FileNotFoundException
{    try (Stream<String> stream = ReaderSpliterator.lineStream(getReader(), 100)) {        Map<String, Integer> count = stream.parallel().map(s -> s.trim()).collect(Collectors.toMap(s -> s, s -> 1, Integer::sum));        validateMapCount(count);    }}
public void metron_f3460_0() throws FileNotFoundException
{    try (Stream<String> stream = ReaderSpliterator.lineStream(getReader(), 100)) {        Map<String, Integer> count = stream.map(s -> s.trim()).collect(Collectors.toMap(s -> s, s -> 1, Integer::sum));        validateMapCount(count);    }}
private int metron_f3461_0(final ReaderSpliterator spliterator) throws ExecutionException, InterruptedException
{    final AtomicInteger numSplits = new AtomicInteger(0);        Spliterator<String> delegatingSpliterator = spy(spliterator);    doAnswer(invocationOnMock -> {        Spliterator<String> ret = spliterator.trySplit();        if (ret != null) {            numSplits.incrementAndGet();        }        return ret;    }).when(delegatingSpliterator).trySplit();    Stream<String> stream = StreamSupport.stream(delegatingSpliterator, true);        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();    forkJoinPool.submit(() -> {        Map<String, Integer> threads = stream.parallel().map(s -> Thread.currentThread().getName()).collect(Collectors.toMap(s -> s, s -> 1, Integer::sum));        Assert.assertTrue(threads.size() > 0);    }).get();    return numSplits.get();}
public void metron_f3462_0() throws ExecutionException, InterruptedException, IOException
{        try (BufferedReader reader = getReader()) {        Assert.assertEquals(9, getNumberOfBatches(new ReaderSpliterator(reader, 1)));    }}
public void metron_f3463_0() throws ExecutionException, InterruptedException, IOException
{        try (BufferedReader reader = getReader()) {        Assert.assertEquals(5, getNumberOfBatches(new ReaderSpliterator(reader, 2)));    }}
public void metron_f3464_0() throws ExecutionException, InterruptedException, IOException
{        try (BufferedReader reader = getReader()) {        Assert.assertEquals(1, getNumberOfBatches(new ReaderSpliterator(reader, 10)));    }}
public void metron_f3465_0()
{    JSONObject message = new JSONObject();    message.put("field1", "value1");    message.put("field2", "value2");    message.put("field3", "value3");    Collection<String> fields = Arrays.asList("field2", "field3");    assertEquals("6eab1c2c827387803ce457c76552f0511858fc1f9505c7dc620e198c0d1f4d02", HashUtils.getMessageHash(message, fields));}
public void metron_f3466_0()
{    JSONObject message = new JSONObject();    message.put("field1", "value1");    message.put("field2", "value2");    message.put("field3", "value3");    assertEquals("a76cdafc5aa49180c0b22c78d4415c505f9997c54847cec6c623f4cacf6a2811", HashUtils.getMessageHash(message));}
public void metron_f3467_0()
{    assertEquals("ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d", HashUtils.getMessageHash("message".getBytes(UTF_8)));}
public void metron_f3468_0() throws Exception
{    String outText = "small brown bike and casket lottery";    String outFile = tempDir.getRoot().getAbsolutePath() + "/outfile.txt";    Configuration config = new Configuration();    config.set("fs.default.name", "file:///");    HDFSUtils.write(config, outText.getBytes(StandardCharsets.UTF_8), outFile);    String actual = TestUtils.read(new File(outFile));    assertThat("Text should match", actual, equalTo(outText));}
public void metron_f3469_0() throws Exception
{    String outText = "small brown bike and casket lottery";    String outFile = tempDir.getRoot().getAbsolutePath() + "/outfile.txt";    Configuration config = new Configuration();    HDFSUtils.write(config, outText.getBytes(StandardCharsets.UTF_8), "file:///" + outFile);    String actual = TestUtils.read(new File(outFile));    assertThat("Text should match", actual, equalTo(outText));}
public static void metron_f3470_0() throws Exception
{    tmpDir = UnitTestHelper.createTempDir(new File("target/jsonutilstest"));    configFile = UnitTestHelper.write(new File(tmpDir, "config.json"), config);}
public void metron_f3471_0() throws Exception
{    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("a", "hello");            put("b", "world");        }    };    Map<String, Object> actual = JSONUtils.INSTANCE.load(configFile, JSONUtils.MAP_SUPPLIER);    assertThat("config not equal", actual, equalTo(expected));}
public void metron_f3472_0() throws Exception
{    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("a", "hello");            put("b", "world");        }    };    Map<String, Object> actual = JSONUtils.INSTANCE.load(configFile, Map.class);    assertThat("config not equal", actual, equalTo(expected));}
public void metron_f3473_0() throws Exception
{    TestConfig expected = new TestConfig().setA("hello").setB("world");    TestConfig actual = JSONUtils.INSTANCE.load(configFile, TestConfig.class);    assertThat("a not equal", actual.getA(), equalTo(expected.getA()));    assertThat("b not equal", actual.getB(), equalTo(expected.getB()));}
public String metron_f3474_0()
{    return a;}
public TestConfig metron_f3475_0(String a)
{    this.a = a;    return this;}
public String metron_f3476_0()
{    return b;}
public TestConfig metron_f3477_0(String b)
{    this.b = b;    return this;}
public void metron_f3478_0() throws IOException
{    String actual = new String(JSONUtils.INSTANCE.applyPatch(patchJson, sourceJson), StandardCharsets.UTF_8);    assertThat(JSONUtils.INSTANCE.load(actual, JSONUtils.MAP_SUPPLIER), equalTo(JSONUtils.INSTANCE.load(expectedJson, JSONUtils.MAP_SUPPLIER)));}
public void metron_f3479_0() throws IOException
{    String actual = new String(JSONUtils.INSTANCE.applyPatch(patchComplexJson, complexJson), StandardCharsets.UTF_8);    assertThat(JSONUtils.INSTANCE.load(actual, JSONUtils.MAP_SUPPLIER), equalTo(JSONUtils.INSTANCE.load(expectedComplexJson, JSONUtils.MAP_SUPPLIER)));}
public void metron_f3480_0() throws Exception
{    ArrayList<String> brokerIds = new ArrayList<>();    brokerIds.add("1");    when(client.getChildren()).thenReturn(childrenBuilder);    when(childrenBuilder.forPath("/brokers/ids")).thenReturn(brokerIds);    when(client.getData()).thenReturn(dataBuilder);    when(dataBuilder.forPath("/brokers/ids/1")).thenReturn(brokerWithHostPort.getBytes(StandardCharsets.UTF_8));    ArrayList<String> expected = new ArrayList<>();    expected.add("192.168.1.148:9092");    assertEquals(expected, (KafkaUtils.INSTANCE.getBrokersFromZookeeper(client)));}
public void metron_f3481_0() throws Exception
{    ArrayList<String> brokerIds = new ArrayList<>();    brokerIds.add("1");    when(client.getChildren()).thenReturn(childrenBuilder);    when(childrenBuilder.forPath("/brokers/ids")).thenReturn(brokerIds);    when(client.getData()).thenReturn(dataBuilder);    when(dataBuilder.forPath("/brokers/ids/1")).thenReturn(brokerWithEndpoints.getBytes(StandardCharsets.UTF_8));    ArrayList<String> expected = new ArrayList<>();    expected.add("host1:9092");    expected.add("host1:9093");    expected.add("host1:9094");    expected.add("host1:9095");    assertEquals(expected, (KafkaUtils.INSTANCE.getBrokersFromZookeeper(client)));}
public void metron_f3482_0() throws Exception
{    ArrayList<String> brokerIds = new ArrayList<>();    brokerIds.add("1");    when(client.getChildren()).thenReturn(childrenBuilder);    when(childrenBuilder.forPath("/brokers/ids")).thenReturn(brokerIds);    when(client.getData()).thenReturn(dataBuilder);    when(dataBuilder.forPath("/brokers/ids/1")).thenReturn(brokerWithHostPortAndEndpoints.getBytes(StandardCharsets.UTF_8));    ArrayList<String> expected = new ArrayList<>();    expected.add("192.168.1.148:9092");    assertEquals(expected, (KafkaUtils.INSTANCE.getBrokersFromZookeeper(client)));}
public static Collection<Object[]> metron_f3483_0()
{    List<Object[]> ret = new ArrayList<>();    for (String scheme : schemes) {        for (String hostname : hostnames) {            for (String port : ports) {                port = port != null ? (":" + port) : "";                String expected = hostname + port;                ret.add(new Object[] { scheme + "://" + expected, expected });            }        }    }    return ret;}
public void metron_f3484_0() throws URISyntaxException
{    assertEquals(expected, KafkaUtils.INSTANCE.fromEndpoint(endpoint).get(0));}
public String metron_f3485_0()
{    return null;}
public void metron_f3486_0(Marker reference)
{}
public boolean metron_f3487_0(Marker reference)
{    return false;}
public boolean metron_f3488_0()
{    return false;}
public boolean metron_f3489_0()
{    return false;}
public Iterator<Marker> metron_f3490_0()
{    return null;}
public boolean metron_f3491_0(Marker other)
{    return false;}
public boolean metron_f3492_0(String name)
{    return false;}
private List<UUID> metron_f3493_0(int numGuids)
{    return IntStream.range(0, numGuids).mapToObj(x -> UUID.randomUUID()).collect(Collectors.toList());}
private LazyLogger metron_f3494_0()
{    final Logger loggerMock = mock(Logger.class);    return LazyLoggerFactory.getLogger(loggerMock);}
private LazyLogger metron_f3495_0()
{    final LazyLogger lazyLogger = getDisabledLogger();    Mockito.when(lazyLogger.getLogger().isTraceEnabled()).thenReturn(true);    Mockito.when(lazyLogger.getLogger().isTraceEnabled(any(Marker.class))).thenReturn(true);    return lazyLogger;}
private LazyLogger metron_f3496_0()
{    final LazyLogger lazyLogger = getDisabledLogger();    Mockito.when(lazyLogger.getLogger().isDebugEnabled()).thenReturn(true);    Mockito.when(lazyLogger.getLogger().isDebugEnabled(any(Marker.class))).thenReturn(true);    return lazyLogger;}
private LazyLogger metron_f3497_0()
{    final LazyLogger lazyLogger = getDisabledLogger();    Mockito.when(lazyLogger.getLogger().isInfoEnabled()).thenReturn(true);    Mockito.when(lazyLogger.getLogger().isInfoEnabled(any(Marker.class))).thenReturn(true);    return lazyLogger;}
private LazyLogger metron_f3498_0()
{    final LazyLogger lazyLogger = getDisabledLogger();    Mockito.when(lazyLogger.getLogger().isWarnEnabled()).thenReturn(true);    Mockito.when(lazyLogger.getLogger().isWarnEnabled(any(Marker.class))).thenReturn(true);    return lazyLogger;}
private LazyLogger metron_f3499_0()
{    final LazyLogger lazyLogger = getDisabledLogger();    Mockito.when(lazyLogger.getLogger().isErrorEnabled()).thenReturn(true);    Mockito.when(lazyLogger.getLogger().isErrorEnabled(any(Marker.class))).thenReturn(true);    return lazyLogger;}
private Supplier<Object> metron_f3500_0()
{    return mock(Supplier.class);}
public void metron_f3501_0()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getTraceEnabledLogger();    logger.isTraceEnabled();    Mockito.verify(logger.getLogger()).isTraceEnabled();    logger.isTraceEnabled(marker);    Mockito.verify(logger.getLogger()).isTraceEnabled(marker);    logger.trace(logString0);    Mockito.verify(logger.getLogger()).trace(logString0);    logger.trace(logString0, exception);    Mockito.verify(logger.getLogger()).trace(logString0, exception);    logger.trace(logString1, guids.get(0));    Mockito.verify(logger.getLogger()).trace(logString1, guids.get(0));    logger.trace(marker, logString0);    Mockito.verify(logger.getLogger()).trace(marker, logString0);    logger.trace(marker, logString0, exception);    Mockito.verify(logger.getLogger()).trace(marker, logString0, exception);    logger.trace(marker, logString1, guids.get(0));    Mockito.verify(logger.getLogger()).trace(marker, logString1, guids.get(0));}
public void metron_f3502_0()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getTraceEnabledLogger();    logger.trace(logString1, () -> guids.get(0));    Mockito.verify(logger.getLogger()).trace(logString1, guids.get(0));    logger.trace(marker, logString1, () -> guids.get(0));    Mockito.verify(logger.getLogger()).trace(marker, logString1, guids.get(0));}
public void metron_f3503_0()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();    logger.trace(logString1, supplier);    Mockito.verify(supplier, never()).get();    logger.trace(marker, logString1, supplier);    Mockito.verify(supplier, never()).get();}
public void metron_f3504_0()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getTraceEnabledLogger();    logger.trace(logString2, guids.get(0), guids.get(1));    Mockito.verify(logger.getLogger()).trace(logString2, guids.get(0), guids.get(1));    logger.trace(marker, logString2, guids.get(0), guids.get(1));    Mockito.verify(logger.getLogger()).trace(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3505_0()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getTraceEnabledLogger();    logger.trace(logString2, () -> guids.get(0), () -> guids.get(1));    Mockito.verify(logger.getLogger()).trace(logString2, guids.get(0), guids.get(1));    logger.trace(marker, logString2, () -> guids.get(0), () -> guids.get(1));    Mockito.verify(logger.getLogger()).trace(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3506_0()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();    logger.trace(logString2, supplier, supplier);    Mockito.verify(supplier, never()).get();    logger.trace(marker, logString2, supplier, supplier);    Mockito.verify(supplier, never()).get();}
public void metron_f3507_0()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getTraceEnabledLogger();    logger.trace(logString3, guids.get(0), guids.get(1), guids.get(2));    Mockito.verify(logger.getLogger()).trace(logString3, guids.get(0), guids.get(1), guids.get(2));    logger.trace(marker, logString3, guids.get(0), guids.get(1), guids.get(2));    Mockito.verify(logger.getLogger()).trace(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3508_0()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getTraceEnabledLogger();    logger.trace(logString3, () -> guids.get(0), () -> guids.get(1), () -> guids.get(2));    Mockito.verify(logger.getLogger()).trace(logString3, guids.get(0), guids.get(1), guids.get(2));    logger.trace(marker, logString3, () -> guids.get(0), () -> guids.get(1), () -> guids.get(2));    Mockito.verify(logger.getLogger()).trace(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3509_0()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();    logger.trace(logString3, supplier, supplier, supplier);    Mockito.verify(supplier, never()).get();    logger.trace(marker, logString3, supplier, supplier, supplier);    Mockito.verify(supplier, never()).get();}
public void metron_f3510_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getDebugEnabledLogger();    logger.isDebugEnabled();    Mockito.verify(logger.getLogger()).isDebugEnabled();    logger.isDebugEnabled(marker);    Mockito.verify(logger.getLogger()).isDebugEnabled(marker);        Mockito.verify(logger.getLogger()).debug(logString0);        Mockito.verify(logger.getLogger()).debug(logString0, exception);        Mockito.verify(logger.getLogger()).debug(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).debug(marker, logString0);        Mockito.verify(logger.getLogger()).debug(marker, logString0, exception);        Mockito.verify(logger.getLogger()).debug(marker, logString1, guids.get(0));}
public void metron_f3511_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getDebugEnabledLogger();        Mockito.verify(logger.getLogger()).debug(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).debug(marker, logString1, guids.get(0));}
public void metron_f3512_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3513_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getDebugEnabledLogger();        Mockito.verify(logger.getLogger()).debug(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).debug(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3514_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getDebugEnabledLogger();        Mockito.verify(logger.getLogger()).debug(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).debug(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3515_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3516_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getDebugEnabledLogger();        Mockito.verify(logger.getLogger()).debug(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).debug(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3517_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getDebugEnabledLogger();        Mockito.verify(logger.getLogger()).debug(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).debug(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3518_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3519_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getInfoEnabledLogger();        Mockito.verify(logger.getLogger()).info(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).info(marker, logString1, guids.get(0));}
public void metron_f3520_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getInfoEnabledLogger();    logger.isInfoEnabled();    Mockito.verify(logger.getLogger()).isInfoEnabled();    logger.isInfoEnabled(marker);    Mockito.verify(logger.getLogger()).isInfoEnabled(marker);        Mockito.verify(logger.getLogger()).info(logString0);        Mockito.verify(logger.getLogger()).info(logString0, exception);        Mockito.verify(logger.getLogger()).info(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).info(marker, logString0);        Mockito.verify(logger.getLogger()).info(marker, logString0, exception);        Mockito.verify(logger.getLogger()).info(marker, logString1, guids.get(0));}
public void metron_f3521_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3522_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getInfoEnabledLogger();        Mockito.verify(logger.getLogger()).info(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).info(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3523_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getInfoEnabledLogger();        Mockito.verify(logger.getLogger()).info(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).info(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3524_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3525_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getInfoEnabledLogger();        Mockito.verify(logger.getLogger()).info(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).info(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3526_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getInfoEnabledLogger();        Mockito.verify(logger.getLogger()).info(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).info(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3527_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3528_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getWarnEnabledLogger();        Mockito.verify(logger.getLogger()).warn(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).warn(marker, logString1, guids.get(0));}
public void metron_f3529_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getWarnEnabledLogger();    logger.isWarnEnabled();    Mockito.verify(logger.getLogger()).isWarnEnabled();    logger.isWarnEnabled(marker);    Mockito.verify(logger.getLogger()).isWarnEnabled(marker);        Mockito.verify(logger.getLogger()).warn(logString0);        Mockito.verify(logger.getLogger()).warn(logString0, exception);        Mockito.verify(logger.getLogger()).warn(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).warn(marker, logString0);        Mockito.verify(logger.getLogger()).warn(marker, logString0, exception);        Mockito.verify(logger.getLogger()).warn(marker, logString1, guids.get(0));}
public void metron_f3530_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3531_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getWarnEnabledLogger();        Mockito.verify(logger.getLogger()).warn(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).warn(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3532_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getWarnEnabledLogger();        Mockito.verify(logger.getLogger()).warn(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).warn(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3533_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3534_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getWarnEnabledLogger();        Mockito.verify(logger.getLogger()).warn(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).warn(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3535_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getWarnEnabledLogger();        Mockito.verify(logger.getLogger()).warn(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).warn(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3536_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3537_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getErrorEnabledLogger();        Mockito.verify(logger.getLogger()).error(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).error(marker, logString1, guids.get(0));}
public void metron_f3538_1()
{    final List<UUID> guids = getGuids(1);    final LazyLogger logger = getErrorEnabledLogger();    logger.isErrorEnabled();    Mockito.verify(logger.getLogger()).isErrorEnabled();    logger.isErrorEnabled(marker);    Mockito.verify(logger.getLogger()).isErrorEnabled(marker);        Mockito.verify(logger.getLogger()).error(logString0);        Mockito.verify(logger.getLogger()).error(logString0, exception);        Mockito.verify(logger.getLogger()).error(logString1, guids.get(0));        Mockito.verify(logger.getLogger()).error(marker, logString0);        Mockito.verify(logger.getLogger()).error(marker, logString0, exception);        Mockito.verify(logger.getLogger()).error(marker, logString1, guids.get(0));}
public void metron_f3539_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3540_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getErrorEnabledLogger();        Mockito.verify(logger.getLogger()).error(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).error(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3541_1()
{    final List<UUID> guids = getGuids(2);    final LazyLogger logger = getErrorEnabledLogger();        Mockito.verify(logger.getLogger()).error(logString2, guids.get(0), guids.get(1));        Mockito.verify(logger.getLogger()).error(marker, logString2, guids.get(0), guids.get(1));}
public void metron_f3542_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3543_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getErrorEnabledLogger();        Mockito.verify(logger.getLogger()).error(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).error(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3544_1()
{    final List<UUID> guids = getGuids(3);    final LazyLogger logger = getErrorEnabledLogger();        Mockito.verify(logger.getLogger()).error(logString3, guids.get(0), guids.get(1), guids.get(2));        Mockito.verify(logger.getLogger()).error(marker, logString3, guids.get(0), guids.get(1), guids.get(2));}
public void metron_f3545_1()
{    final Supplier<Object> supplier = getMockedSupplier();    final LazyLogger logger = getDisabledLogger();        Mockito.verify(supplier, never()).get();        Mockito.verify(supplier, never()).get();}
public void metron_f3546_0()
{    Map<String, Object> smallMap = new HashMap<>();    for (int i = 0; i < 10; i++) {        smallMap.put("key" + i, RandomStringUtils.randomAlphabetic(10));    }    Map<String, Object> largeMap = new HashMap<>();    for (int i = 0; i < 500; i++) {        largeMap.put("key" + i, RandomStringUtils.randomAlphabetic(1000));    }    JSONObject largeObject = new JSONObject(largeMap);    JSONObject smallObject = new JSONObject(smallMap);    int reps = 1000;    StatisticalSummary summary = runTrial(reps, () -> {        LOG.trace("Writing message {} to path: {}", smallObject.toJSONString(), PATH);    });    printSummary(String.format("Small object %s times", reps), summary);    summary = runTrial(reps, () -> {        LOG.trace("Writing message {} to path: {}", () -> smallObject.toJSONString(), () -> PATH);    });    printSummary(String.format("Small object %s times using lazy logging", reps), summary);    summary = runTrial(reps, () -> {        LOG.trace("Writing message {} to path: {}", largeObject.toJSONString(), PATH);    });    printSummary(String.format("Large object %s times", reps), summary);    summary = runTrial(reps, () -> {        LOG.trace("Writing message {} to path: {}", () -> largeObject.toJSONString(), () -> PATH);    });    printSummary(String.format("Large object %s times using lazy logging", reps), summary);    summary = runTrial(reps, () -> {        LOG.trace("Writing message {} to path: {}", "hello", PATH);    });    printSummary(String.format("Simple string %s times", reps), summary);    summary = runTrial(reps, () -> {        LOG.trace("Writing message {} to path: {}", () -> "hello", () -> PATH);    });    printSummary(String.format("Simple string %s times using lazy logging", reps), summary);}
private StatisticalSummary metron_f3547_0(int reps, Operation operation)
{    DescriptiveStatistics stats = new DescriptiveStatistics();    long trialTime = timeOperation(() -> {        for (int i = 0; i < reps; i++) {            long time = timeOperation(operation);            stats.addValue(time / NANO_TO_MILLIS);        }    });    System.out.println("Total trial time (ms): " + (trialTime / NANO_TO_MILLIS));    return stats;}
private long metron_f3548_0(Operation o)
{    final long start = System.nanoTime();    o.run();    final long finish = System.nanoTime();    return finish - start;}
private void metron_f3549_0(String desc, StatisticalSummary summary)
{    final String border = "===============================";    System.out.println(border);    System.out.println(desc);    System.out.println(summary.toString());    System.out.println(border);}
public void metron_f3550_0() throws Exception
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("illegal arg happened");    exception.expectCause(nullValue(Throwable.class));    RuntimeErrors.ILLEGAL_ARG.throwRuntime("illegal arg happened");}
public void metron_f3551_0() throws Exception
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("illegal arg happened");    exception.expectCause(instanceOf(IOException.class));    RuntimeErrors.ILLEGAL_ARG.throwRuntime("illegal arg happened", new IOException("bad io"));}
public void metron_f3552_0() throws Exception
{    exception.expect(IllegalStateException.class);    exception.expectMessage("illegal state happened");    exception.expectCause(nullValue(Throwable.class));    RuntimeErrors.ILLEGAL_STATE.throwRuntime("illegal state happened");}
public void metron_f3553_0() throws Exception
{    exception.expect(IllegalStateException.class);    exception.expectMessage("illegal state happened");    exception.expectCause(instanceOf(IOException.class));    RuntimeErrors.ILLEGAL_STATE.throwRuntime("illegal state happened", new IOException("bad io"));}
public void metron_f3554_0()
{    final int expected = 2;    byte[] raw = SerDeUtils.toBytes(expected);    int actual = SerDeUtils.fromBytes(raw, Integer.class);    assertEquals(expected, actual);}
public void metron_f3555_0()
{    final double expected = 2.0;    byte[] raw = SerDeUtils.toBytes(expected);    {        double actual = SerDeUtils.fromBytes(raw, Double.class);        assertEquals(expected, actual, 0.01);    }    {        double actual = (double) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual, 0.01);    }}
public void metron_f3556_0()
{    final short expected = 2;    byte[] raw = SerDeUtils.toBytes(expected);    {        short actual = SerDeUtils.fromBytes(raw, Short.class);        assertEquals(expected, actual);    }    {        short actual = (short) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual);    }}
public void metron_f3557_0()
{    final long expected = 2L;    byte[] raw = SerDeUtils.toBytes(expected);    {        long actual = SerDeUtils.fromBytes(raw, Long.class);        assertEquals(expected, actual);    }    {        long actual = (Long) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual);    }}
public void metron_f3558_0()
{    final Float expected = 2.2F;    byte[] raw = SerDeUtils.toBytes(expected);    {        float actual = SerDeUtils.fromBytes(raw, Float.class);        assertEquals(expected, actual, 0.01);    }    {        float actual = (float) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual, 0.01);    }}
public void metron_f3559_0()
{    final Map<String, Object> expected = new HashMap<>();    expected.put("foo", "bar");    expected.put("bar", 1.0);    ;    byte[] raw = SerDeUtils.toBytes(expected);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    assertEquals(expected, actual);}
public void metron_f3560_0()
{    final List<String> expected = new ArrayList<String>();    expected.add("foo");    expected.add("bar");    byte[] raw = SerDeUtils.toBytes(expected);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    assertEquals(expected, actual);}
public void metron_f3561_0()
{    final BloomFilter<Object> expected = new BloomFilter<>(new BloomFilter.DefaultSerializer<>(), 10000, 0.01);    expected.add("foo");    expected.add("bar");    byte[] raw = SerDeUtils.toBytes(expected);    BloomFilter<Object> actual = (BloomFilter) SerDeUtils.fromBytes(raw, Object.class);    Assert.assertTrue(actual.mightContain("foo"));    Assert.assertFalse(actual.mightContain("timothy"));    assertEquals(expected, actual);}
public List<String> metron_f3562_0()
{    return list;}
public void metron_f3563_0(List<String> list)
{    this.list = list;}
public String metron_f3564_0()
{    return string;}
public void metron_f3565_0(String string)
{    this.string = string;}
public Double metron_f3566_0()
{    return d;}
public void metron_f3567_0(Double d)
{    this.d = d;}
public Map<String, String> metron_f3568_0()
{    return map;}
public void metron_f3569_0(Map<String, String> map)
{    this.map = map;}
public boolean metron_f3570_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ArbitraryPojo that = (ArbitraryPojo) o;    if (getList() != null ? !getList().equals(that.getList()) : that.getList() != null)        return false;    if (getString() != null ? !getString().equals(that.getString()) : that.getString() != null)        return false;    if (getD() != null ? !getD().equals(that.getD()) : that.getD() != null)        return false;    if (getMap() != null ? !getMap().equals(that.getMap()) : that.getMap() != null)        return false;    return immutableList != null ? immutableList.equals(that.immutableList) : that.immutableList == null;}
public int metron_f3571_0()
{    int result = getList() != null ? getList().hashCode() : 0;    result = 31 * result + (getString() != null ? getString().hashCode() : 0);    result = 31 * result + (getD() != null ? getD().hashCode() : 0);    result = 31 * result + (getMap() != null ? getMap().hashCode() : 0);    result = 31 * result + (immutableList != null ? immutableList.hashCode() : 0);    return result;}
public void metron_f3572_0()
{    final ArbitraryPojo expected = new ArbitraryPojo();    byte[] raw = SerDeUtils.toBytes(expected);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    assertEquals(expected, actual);}
public void metron_f3573_0() throws Exception
{    zkComponent = new ZKServerComponent();    zkComponent.start();    client = ConfigurationsUtils.getClient(zkComponent.getConnectionString());    client.start();    cache = new ZKConfigurationsCache(client);    cache.start();    {                byte[] config = IOUtils.toByteArray(new FileInputStream(new File(TestConstants.PARSER_CONFIGS_PATH + "/parsers/bro.json")));        ConfigurationsUtils.writeSensorParserConfigToZookeeper("bro", config, client);    }    {                byte[] config = IOUtils.toByteArray(new FileInputStream(new File(TestConstants.SAMPLE_CONFIG_PATH + "/indexing/test.json")));        ConfigurationsUtils.writeSensorIndexingConfigToZookeeper("test", config, client);    }    {                byte[] config = IOUtils.toByteArray(new FileInputStream(new File(TestConstants.SAMPLE_CONFIG_PATH + "/enrichments/test.json")));        ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper("test", config, client);    }    {                byte[] config = IOUtils.toByteArray(new FileInputStream(new File(TestConstants.SAMPLE_CONFIG_PATH + "/enrichments/test.json")));        ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper("test", config, client);    }    {                byte[] config = IOUtils.toByteArray(new FileInputStream(new File("src/test/resources/profiler/profiler.json")));        ConfigurationsUtils.writeProfilerConfigToZookeeper(config, client);    }    {                byte[] config = IOUtils.toByteArray(new FileInputStream(new File(TestConstants.SAMPLE_CONFIG_PATH + "/global.json")));        ConfigurationsUtils.writeGlobalConfigToZookeeper(config, client);    }}
public void metron_f3574_0() throws Exception
{    if (cache != null) {        cache.close();    }    if (client != null) {        client.close();    }    if (zkComponent != null) {        zkComponent.stop();    }}
public void metron_f3575_0() throws Exception
{    client.delete().forPath(ConfigurationType.GLOBAL.getZookeeperRoot());    client.delete().forPath(ConfigurationType.INDEXING.getZookeeperRoot() + "/test");    client.delete().forPath(ConfigurationType.ENRICHMENT.getZookeeperRoot() + "/test");    client.delete().forPath(ConfigurationType.PARSER.getZookeeperRoot() + "/bro");    client.delete().forPath(ConfigurationType.PROFILER.getZookeeperRoot());        {        IndexingConfigurations config = cache.get(IndexingConfigurations.class);        assertEventually(() -> Assert.assertNull(config.getGlobalConfig(false)));    }        {        IndexingConfigurations config = cache.get(IndexingConfigurations.class);        assertEventually(() -> Assert.assertNull(config.getSensorIndexingConfig("test", false)));        assertEventually(() -> Assert.assertNull(config.getGlobalConfig(false)));    }        {        EnrichmentConfigurations config = cache.get(EnrichmentConfigurations.class);        assertEventually(() -> Assert.assertNull(config.getSensorEnrichmentConfig("test")));        assertEventually(() -> Assert.assertNull(config.getGlobalConfig(false)));    }        {        ParserConfigurations config = cache.get(ParserConfigurations.class);        assertEventually(() -> Assert.assertNull(config.getSensorParserConfig("bro")));        assertEventually(() -> Assert.assertNull(config.getGlobalConfig(false)));    }        {        ProfilerConfigurations config = cache.get(ProfilerConfigurations.class);        assertEventually(() -> Assert.assertNull(config.getProfilerConfig()));        assertEventually(() -> Assert.assertNull(config.getGlobalConfig(false)));    }}
public void metron_f3576_0() throws Exception
{    ConfigurationsUtils.writeSensorIndexingConfigToZookeeper("test", testIndexingConfig.getBytes(StandardCharsets.UTF_8), client);    ConfigurationsUtils.writeGlobalConfigToZookeeper(globalConfig.getBytes(StandardCharsets.UTF_8), client);    ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper("test", testEnrichmentConfig.getBytes(StandardCharsets.UTF_8), client);    ConfigurationsUtils.writeSensorParserConfigToZookeeper("bro", testParserConfig.getBytes(StandardCharsets.UTF_8), client);    ConfigurationsUtils.writeProfilerConfigToZookeeper(profilerConfig.getBytes(StandardCharsets.UTF_8), client);        {        Map<String, Object> expectedConfig = JSONUtils.INSTANCE.load(testIndexingConfig, JSONUtils.MAP_SUPPLIER);        IndexingConfigurations config = cache.get(IndexingConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getSensorIndexingConfig("test")));    }        {        SensorEnrichmentConfig expectedConfig = JSONUtils.INSTANCE.load(testEnrichmentConfig, SensorEnrichmentConfig.class);        Map<String, Object> expectedGlobalConfig = JSONUtils.INSTANCE.load(globalConfig, JSONUtils.MAP_SUPPLIER);        EnrichmentConfigurations config = cache.get(EnrichmentConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getSensorEnrichmentConfig("test")));        assertEventually(() -> Assert.assertEquals(expectedGlobalConfig, config.getGlobalConfig()));    }        {        SensorParserConfig expectedConfig = JSONUtils.INSTANCE.load(testParserConfig, SensorParserConfig.class);        ParserConfigurations config = cache.get(ParserConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getSensorParserConfig("bro")));    }        {        ProfilerConfig expectedConfig = JSONUtils.INSTANCE.load(profilerConfig, ProfilerConfig.class);        ProfilerConfigurations config = cache.get(ProfilerConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getProfilerConfig()));    }}
public void metron_f3577_0() throws Exception
{    File globalConfigFile = new File(TestConstants.SAMPLE_CONFIG_PATH + "/global.json");    Map<String, Object> expectedGlobalConfig = JSONUtils.INSTANCE.load(globalConfigFile, JSONUtils.MAP_SUPPLIER);        {        File inFile = new File(TestConstants.SAMPLE_CONFIG_PATH + "/indexing/test.json");        Map<String, Object> expectedConfig = JSONUtils.INSTANCE.load(inFile, JSONUtils.MAP_SUPPLIER);        IndexingConfigurations config = cache.get(IndexingConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getSensorIndexingConfig("test")));        assertEventually(() -> Assert.assertEquals(expectedGlobalConfig, config.getGlobalConfig()));        assertEventually(() -> Assert.assertNull(config.getSensorIndexingConfig("notthere", false)));    }        {        File inFile = new File(TestConstants.SAMPLE_CONFIG_PATH + "/enrichments/test.json");        SensorEnrichmentConfig expectedConfig = JSONUtils.INSTANCE.load(inFile, SensorEnrichmentConfig.class);        EnrichmentConfigurations config = cache.get(EnrichmentConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getSensorEnrichmentConfig("test")));        assertEventually(() -> Assert.assertEquals(expectedGlobalConfig, config.getGlobalConfig()));        assertEventually(() -> Assert.assertNull(config.getSensorEnrichmentConfig("notthere")));    }        {        File inFile = new File(TestConstants.PARSER_CONFIGS_PATH + "/parsers/bro.json");        SensorParserConfig expectedConfig = JSONUtils.INSTANCE.load(inFile, SensorParserConfig.class);        ParserConfigurations config = cache.get(ParserConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getSensorParserConfig("bro")));        assertEventually(() -> Assert.assertEquals(expectedGlobalConfig, config.getGlobalConfig()));        assertEventually(() -> Assert.assertNull(config.getSensorParserConfig("notthere")));    }        {        File inFile = new File("src/test/resources/profiler/profiler.json");        ProfilerConfig expectedConfig = JSONUtils.INSTANCE.load(inFile, ProfilerConfig.class);        ProfilerConfigurations config = cache.get(ProfilerConfigurations.class);        assertEventually(() -> Assert.assertEquals(expectedConfig, config.getProfilerConfig()));        assertEventually(() -> Assert.assertEquals(expectedGlobalConfig, config.getGlobalConfig()));    }}
public ConfigUploadComponent metron_f3578_0(String connectionString)
{    this.connectionString = connectionString;    return this;}
public ConfigUploadComponent metron_f3579_0(Properties topologyProperties)
{    this.topologyProperties = topologyProperties;    return this;}
public ConfigUploadComponent metron_f3580_0(String globalConfigPath)
{    this.globalConfigPath = globalConfigPath;    return this;}
public ConfigUploadComponent metron_f3581_0(String parserConfigsPath)
{    this.parserConfigsPath = parserConfigsPath;    return this;}
public ConfigUploadComponent metron_f3582_0(String enrichmentConfigsPath)
{    this.enrichmentConfigsPath = enrichmentConfigsPath;    return this;}
public ConfigUploadComponent metron_f3583_0(String indexingConfigsPath)
{    this.indexingConfigsPath = indexingConfigsPath;    return this;}
public ConfigUploadComponent metron_f3584_0(String profilerConfigsPath)
{    this.profilerConfigPath = profilerConfigsPath;    return this;}
public ConfigUploadComponent metron_f3585_0(String name, SensorParserConfig config)
{    parserSensorConfigs.put(name, config);    return this;}
public ConfigUploadComponent metron_f3586_0(String globalConfig)
{    this.globalConfig = Optional.ofNullable(globalConfig);    return this;}
public ConfigUploadComponent metron_f3587_0(Consumer<ConfigUploadComponent> f)
{    this.postStartCallback = Optional.ofNullable(f);    return this;}
public Properties metron_f3588_0()
{    return topologyProperties;}
public String metron_f3589_0()
{    return globalConfigPath;}
public String metron_f3590_0()
{    return parserConfigsPath;}
public String metron_f3591_0()
{    return enrichmentConfigsPath;}
public String metron_f3592_0()
{    return indexingConfigsPath;}
public String metron_f3593_0()
{    return profilerConfigPath;}
public Optional<Consumer<ConfigUploadComponent>> metron_f3594_0()
{    return postStartCallback;}
public Optional<String> metron_f3595_0()
{    return globalConfig;}
public Map<String, SensorParserConfig> metron_f3596_0()
{    return parserSensorConfigs;}
public void metron_f3597_0() throws UnableToStartException
{    update();}
public void metron_f3598_0() throws UnableToStartException
{    try {        final String zookeeperUrl = connectionString == null ? topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY) : connectionString;        if (globalConfigPath != null || parserConfigsPath != null || enrichmentConfigsPath != null || indexingConfigsPath != null || profilerConfigPath != null) {            uploadConfigsToZookeeper(globalConfigPath, parserConfigsPath, enrichmentConfigsPath, indexingConfigsPath, profilerConfigPath, zookeeperUrl);        }        for (Map.Entry<String, SensorParserConfig> kv : parserSensorConfigs.entrySet()) {            writeSensorParserConfigToZookeeper(kv.getKey(), kv.getValue(), zookeeperUrl);        }        if (globalConfig.isPresent()) {            writeGlobalConfigToZookeeper(globalConfig.get().getBytes(StandardCharsets.UTF_8), zookeeperUrl);        }        if (postStartCallback.isPresent()) {            postStartCallback.get().accept(this);        }    } catch (Exception e) {        throw new UnableToStartException(e.getMessage(), e);    }}
public SensorParserConfig metron_f3599_0(String sensorType)
{    SensorParserConfig sensorParserConfig = new SensorParserConfig();    CuratorFramework client = getClient(topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY));    client.start();    try {        sensorParserConfig = readSensorParserConfigFromZookeeper(sensorType, client);    } catch (Exception e) {        e.printStackTrace();    } finally {        client.close();    }    return sensorParserConfig;}
public void metron_f3600_0()
{}
public void metron_f3601_0(CuratorFramework client)
{    this.client = client;}
public void metron_f3602_0(ZKCache cache)
{    this.cache = cache;}
public void metron_f3603_0(String name, ConfigurationType type)
{}
public CONFIG_T metron_f3604_0()
{    return configurations;}
protected ConfigurationStrategy<CONFIG_T> metron_f3605_0()
{    return ConfigurationsStrategies.valueOf(configurationStrategy);}
protected ConfigurationsUpdater<CONFIG_T> metron_f3606_0()
{    return getConfigurationStrategy().createUpdater(this, this::getConfigurations);}
public void metron_f3607_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    prepCache();}
protected void metron_f3608_1()
{    try {        if (client == null) {            RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);            client = CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy);        }        client.start();                                ConfigurationsUtils.setupStellarStatically(client);        if (cache == null) {            ConfigurationsUpdater<CONFIG_T> updater = createUpdater();            SimpleEventListener listener = new SimpleEventListener.Builder().with(updater::update, TreeCacheEvent.Type.NODE_ADDED, TreeCacheEvent.Type.NODE_UPDATED).with(updater::delete, TreeCacheEvent.Type.NODE_REMOVED).build();            cache = new ZKCache.Builder().withClient(client).withListener(listener).withRoot(Constants.ZOOKEEPER_TOPOLOGY_ROOT).build();            updater.forceUpdate(client);            cache.start();        }    } catch (Exception e) {                throw new RuntimeException(e);    }}
public void metron_f3609_0()
{    cache.close();    client.close();}
public void metron_f3610_1()
{            super.cleanup();    try {        StellarFunctions.close();    } catch (IOException e) {            }}
protected SensorParserConfig metron_f3611_0(String sensorType)
{    return getConfigurations().getSensorParserConfig(sensorType);}
public void metron_f3612_1()
{            super.cleanup();    try {        StellarFunctions.close();    } catch (IOException e) {            }}
protected ProfilerConfig metron_f3613_0()
{    return getConfigurations().getProfilerConfig();}
public byte[] metron_f3614_0(Tuple tuple)
{    return tuple.getBinary(position);}
public JSONObject metron_f3615_0(Tuple tuple)
{    return (JSONObject) ((JSONObject) tuple.getValueByField(fieldValue)).clone();}
public JSONObject metron_f3616_0(Tuple tuple)
{    return (JSONObject) tuple.getValueByField(messageFieldName);}
protected JSONParser metron_f3617_0()
{    return new JSONParser();}
public JSONObject metron_f3618_0(Tuple tuple)
{    String s = null;    try {        s = new String(tuple.getBinary(position), Charsets.UTF_8);        return (JSONObject) parser.get().parse(s);    } catch (Exception e) {        throw new IllegalStateException("Unable to parse " + s + " due to " + e.getMessage(), e);    }}
public MessageGetStrategy metron_f3619_0(String arg)
{    return messageGetStrategyFunction.apply(arg);}
public MessageGetStrategy metron_f3620_0()
{    return messageGetStrategy;}
public RawMessage metron_f3621_0(RawMessageStrategy strategy, Tuple t, byte[] rawMessage, boolean readMetadata, Map<String, Object> config)
{    Map<String, Object> metadata = new HashMap<>();    if (readMetadata) {        String prefix = MetadataUtil.INSTANCE.getMetadataPrefix(config);        metadata = extractMetadata(prefix, t);    }    return strategy.get(metadata, rawMessage, readMetadata, config);}
public Map<String, Object> metron_f3622_1(String prefix, Tuple t)
{    Map<String, Object> metadata = new HashMap<>();    if (t == null) {        return metadata;    }    Fields tupleFields = t.getFields();    if (tupleFields == null) {        return metadata;    }    for (int i = 2; i < tupleFields.size(); ++i) {        String envMetadataFieldName = tupleFields.get(i);        Object envMetadataFieldValue = t.getValue(i);        if (!StringUtils.isEmpty(envMetadataFieldName) && envMetadataFieldValue != null) {            metadata.put(MetadataUtil.INSTANCE.prefixKey(prefix, envMetadataFieldName), envMetadataFieldValue);        }    }    byte[] keyObj = t.getBinary(KEY_INDEX);    String keyStr = null;    try {        keyStr = keyObj == null ? null : new String(keyObj, StandardCharsets.UTF_8);        if (!StringUtils.isEmpty(keyStr)) {            Map<String, Object> rawMetadata = JSONUtils.INSTANCE.load(keyStr, JSONUtils.MAP_SUPPLIER);            for (Map.Entry<String, Object> kv : rawMetadata.entrySet()) {                metadata.put(MetadataUtil.INSTANCE.prefixKey(prefix, kv.getKey()), kv.getValue());            }        }    } catch (IOException e) {        String reason = "Unable to parse metadata; expected JSON Map: " + (keyStr == null ? "NON-STRING!" : keyStr);                throw new IllegalStateException(reason, e);    }    return metadata;}
public Object metron_f3623_0(Tuple tuple)
{    return tuple.getValueByField(fieldValue);}
public static void metron_f3624_0(OutputCollector collector, MetronError error)
{    collector.emit(Constants.ERROR_STREAM, new Values(error.getJSONObject()));    Optional<Throwable> throwable = error.getThrowable();    if (throwable.isPresent()) {        collector.reportError(throwable.get());    }}
protected void metron_f3625_0(final String expectedConfigUpdate)
{    waitForConfigUpdate(new HashSet<String>() {        {            add(expectedConfigUpdate);        }    });}
protected void metron_f3626_0(Set<String> expectedConfigUpdates)
{    int count = 0;    while (!configsUpdated.equals(expectedConfigUpdates)) {        if (count++ > 5) {            Assert.fail("ConfiguredBolt was not updated in time");            return;        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}
public void metron_f3627_0(Tuple input)
{}
public void metron_f3628_0(OutputFieldsDeclarer declarer)
{}
public void metron_f3629_0(String name, ConfigurationType type)
{    configsUpdated.add(name);}
public void metron_f3630_0() throws Exception
{    TestingServer testZkServer = new TestingServer(true);    this.zookeeperUrl = testZkServer.getConnectString();    byte[] globalConfig = ConfigurationsUtils.readGlobalConfigFromFile(sampleConfigPath);    ConfigurationsUtils.writeGlobalConfigToZookeeper(globalConfig, zookeeperUrl);    enrichmentConfigurationTypes.add(ConfigurationType.GLOBAL.getTypeName());    Map<String, byte[]> sensorEnrichmentConfigs = ConfigurationsUtils.readSensorEnrichmentConfigsFromFile(enrichmentsConfigPath);    for (String sensorType : sensorEnrichmentConfigs.keySet()) {        ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(sensorType, sensorEnrichmentConfigs.get(sensorType), zookeeperUrl);        enrichmentConfigurationTypes.add(sensorType);    }    Map<String, byte[]> sensorParserConfigs = ConfigurationsUtils.readSensorParserConfigsFromFile(parserConfigsPath);    for (String sensorType : sensorParserConfigs.keySet()) {        ConfigurationsUtils.writeSensorParserConfigToZookeeper(sensorType, sensorParserConfigs.get(sensorType), zookeeperUrl);    }}
public void metron_f3631_0() throws Exception
{    EnrichmentConfigurations sampleConfigurations = new EnrichmentConfigurations();    UnitTestHelper.setLog4jLevel(ConfiguredBolt.class, Level.FATAL);    try {        StandAloneConfiguredEnrichmentBolt configuredBolt = new StandAloneConfiguredEnrichmentBolt(null);        configuredBolt.prepare(new HashMap(), topologyContext, outputCollector);        Assert.fail("A valid zookeeper url must be supplied");    } catch (RuntimeException e) {    }    UnitTestHelper.setLog4jLevel(ConfiguredBolt.class, Level.ERROR);    configsUpdated = new HashSet<>();    sampleConfigurations.updateGlobalConfig(ConfigurationsUtils.readGlobalConfigFromFile(sampleConfigPath));    Map<String, byte[]> sensorEnrichmentConfigs = ConfigurationsUtils.readSensorEnrichmentConfigsFromFile(enrichmentsConfigPath);    for (String sensorType : sensorEnrichmentConfigs.keySet()) {        sampleConfigurations.updateSensorEnrichmentConfig(sensorType, sensorEnrichmentConfigs.get(sensorType));    }    StandAloneConfiguredEnrichmentBolt configuredBolt = new StandAloneConfiguredEnrichmentBolt(zookeeperUrl);    configuredBolt.prepare(new HashMap(), topologyContext, outputCollector);    waitForConfigUpdate(enrichmentConfigurationTypes);    Assert.assertEquals(sampleConfigurations, configuredBolt.getConfigurations());    configsUpdated = new HashSet<>();    Map<String, Object> sampleGlobalConfig = sampleConfigurations.getGlobalConfig();    sampleGlobalConfig.put("newGlobalField", "newGlobalValue");    ConfigurationsUtils.writeGlobalConfigToZookeeper(sampleGlobalConfig, zookeeperUrl);    waitForConfigUpdate(ConfigurationType.GLOBAL.getTypeName());    Assert.assertEquals("Add global config field", sampleConfigurations.getGlobalConfig(), configuredBolt.getConfigurations().getGlobalConfig());    configsUpdated = new HashSet<>();    sampleGlobalConfig.remove("newGlobalField");    ConfigurationsUtils.writeGlobalConfigToZookeeper(sampleGlobalConfig, zookeeperUrl);    waitForConfigUpdate(ConfigurationType.GLOBAL.getTypeName());    Assert.assertEquals("Remove global config field", sampleConfigurations, configuredBolt.getConfigurations());    configsUpdated = new HashSet<>();    String sensorType = "testSensorConfig";    SensorEnrichmentConfig testSensorConfig = new SensorEnrichmentConfig();    Map<String, Object> enrichmentFieldMap = new HashMap<>();    enrichmentFieldMap.put("enrichmentTest", new ArrayList<String>() {        {            add("enrichmentField");        }    });    testSensorConfig.getEnrichment().setFieldMap(enrichmentFieldMap);    Map<String, Object> threatIntelFieldMap = new HashMap<>();    threatIntelFieldMap.put("threatIntelTest", new ArrayList<String>() {        {            add("threatIntelField");        }    });    testSensorConfig.getThreatIntel().setFieldMap(threatIntelFieldMap);    sampleConfigurations.updateSensorEnrichmentConfig(sensorType, testSensorConfig);    ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(sensorType, testSensorConfig, zookeeperUrl);    waitForConfigUpdate(sensorType);    Assert.assertEquals("Add new sensor config", sampleConfigurations, configuredBolt.getConfigurations());    configuredBolt.cleanup();}
public void metron_f3632_0(Tuple input)
{}
public void metron_f3633_0(OutputFieldsDeclarer declarer)
{}
public void metron_f3634_0(String name, ConfigurationType type)
{    configsUpdated.add(name);}
public void metron_f3635_0() throws Exception
{    TestingServer testZkServer = new TestingServer(true);    this.zookeeperUrl = testZkServer.getConnectString();    byte[] globalConfig = ConfigurationsUtils.readGlobalConfigFromFile("../" + TestConstants.SAMPLE_CONFIG_PATH);    ConfigurationsUtils.writeGlobalConfigToZookeeper(globalConfig, zookeeperUrl);    parserConfigurationTypes.add(ConfigurationType.GLOBAL.getTypeName());    Map<String, byte[]> sensorEnrichmentConfigs = ConfigurationsUtils.readSensorEnrichmentConfigsFromFile("../" + TestConstants.ENRICHMENTS_CONFIGS_PATH);    for (String sensorType : sensorEnrichmentConfigs.keySet()) {        ConfigurationsUtils.writeSensorEnrichmentConfigToZookeeper(sensorType, sensorEnrichmentConfigs.get(sensorType), zookeeperUrl);    }    Map<String, byte[]> sensorParserConfigs = ConfigurationsUtils.readSensorParserConfigsFromFile("../" + TestConstants.PARSER_CONFIGS_PATH);    for (String sensorType : sensorParserConfigs.keySet()) {        ConfigurationsUtils.writeSensorParserConfigToZookeeper(sensorType, sensorParserConfigs.get(sensorType), zookeeperUrl);        parserConfigurationTypes.add(sensorType);    }}
public void metron_f3636_0() throws Exception
{    ParserConfigurations sampleConfigurations = new ParserConfigurations();    UnitTestHelper.setLog4jLevel(ConfiguredBolt.class, Level.FATAL);    try {        StandAloneConfiguredParserBolt configuredBolt = new StandAloneConfiguredParserBolt(null);        configuredBolt.prepare(new HashMap(), topologyContext, outputCollector);        Assert.fail("A valid zookeeper url must be supplied");    } catch (RuntimeException e) {    }    UnitTestHelper.setLog4jLevel(ConfiguredBolt.class, Level.ERROR);    configsUpdated = new HashSet<>();    sampleConfigurations.updateGlobalConfig(ConfigurationsUtils.readGlobalConfigFromFile("../" + TestConstants.SAMPLE_CONFIG_PATH));    Map<String, byte[]> sensorParserConfigs = ConfigurationsUtils.readSensorParserConfigsFromFile("../" + TestConstants.PARSER_CONFIGS_PATH);    for (String sensorType : sensorParserConfigs.keySet()) {        sampleConfigurations.updateSensorParserConfig(sensorType, sensorParserConfigs.get(sensorType));    }    StandAloneConfiguredParserBolt configuredBolt = new StandAloneConfiguredParserBolt(zookeeperUrl);    configuredBolt.prepare(new HashMap(), topologyContext, outputCollector);    waitForConfigUpdate(parserConfigurationTypes);    Assert.assertEquals(sampleConfigurations, configuredBolt.getConfigurations());    configsUpdated = new HashSet<>();    Map<String, Object> sampleGlobalConfig = sampleConfigurations.getGlobalConfig();    sampleGlobalConfig.put("newGlobalField", "newGlobalValue");    ConfigurationsUtils.writeGlobalConfigToZookeeper(sampleGlobalConfig, zookeeperUrl);    waitForConfigUpdate(ConfigurationType.GLOBAL.getTypeName());    Assert.assertEquals("Add global config field", sampleConfigurations.getGlobalConfig(), configuredBolt.getConfigurations().getGlobalConfig());    configsUpdated = new HashSet<>();    sampleGlobalConfig.remove("newGlobalField");    ConfigurationsUtils.writeGlobalConfigToZookeeper(sampleGlobalConfig, zookeeperUrl);    waitForConfigUpdate(ConfigurationType.GLOBAL.getTypeName());    Assert.assertEquals("Remove global config field", sampleConfigurations, configuredBolt.getConfigurations());    configsUpdated = new HashSet<>();    String sensorType = "testSensorConfig";    SensorParserConfig testSensorConfig = new SensorParserConfig();    testSensorConfig.setParserClassName("className");    testSensorConfig.setSensorTopic("sensorTopic");    testSensorConfig.setParserConfig(new HashMap<String, Object>() {        {            put("configName", "configObject");        }    });    sampleConfigurations.updateSensorParserConfig(sensorType, testSensorConfig);    ConfigurationsUtils.writeSensorParserConfigToZookeeper(sensorType, testSensorConfig, zookeeperUrl);    waitForConfigUpdate(sensorType);    ParserConfigurations configuredBoltConfigs = configuredBolt.getConfigurations();    if (!sampleConfigurations.equals(configuredBoltConfigs)) {                if (sampleConfigurations.getFieldValidations().size() != configuredBoltConfigs.getFieldValidations().size()) {            System.out.println("Field validations don't line up");        }        for (int i = 0; i < sampleConfigurations.getFieldValidations().size(); ++i) {            FieldValidator l = sampleConfigurations.getFieldValidations().get(i);            FieldValidator r = configuredBoltConfigs.getFieldValidations().get(i);            if (!l.equals(r)) {                System.out.println(l + " != " + r);            }        }        if (sampleConfigurations.getConfigurations().size() != configuredBoltConfigs.getConfigurations().size()) {            System.out.println("Configs don't line up");        }        for (Map.Entry<String, Object> kv : sampleConfigurations.getConfigurations().entrySet()) {            Object l = kv.getValue();            Object r = configuredBoltConfigs.getConfigurations().get(kv.getKey());            if (!l.equals(r)) {                System.out.println(kv.getKey() + " config does not line up: ");                System.out.println(l);                System.out.println(r);            }        }        Assert.assertEquals("Add new sensor config", sampleConfigurations, configuredBoltConfigs);    }    Assert.assertEquals("Add new sensor config", sampleConfigurations, configuredBoltConfigs);    configuredBolt.cleanup();}
public void metron_f3637_0()
{    Tuple tuple = mock(Tuple.class);    when(tuple.getBinary(1)).thenReturn("bytes".getBytes(UTF_8));    MessageGetStrategy messageGetStrategy = MessageGetters.BYTES_FROM_POSITION.get("1");    assertEquals("bytes", new String((byte[]) messageGetStrategy.get(tuple), UTF_8));}
public void metron_f3638_0()
{    Tuple tuple = mock(Tuple.class);    when(tuple.getBinary(1)).thenReturn("{\"field\":\"value\"}".getBytes(UTF_8));    JSONObject expected = new JSONObject();    expected.put("field", "value");    MessageGetStrategy messageGetStrategy = MessageGetters.JSON_FROM_POSITION.get("1");    assertEquals(expected, messageGetStrategy.get(tuple));}
public void metron_f3639_0()
{    exception.expect(IllegalStateException.class);    Tuple tuple = mock(Tuple.class);    when(tuple.getBinary(1)).thenReturn("{\"field\":".getBytes(UTF_8));    MessageGetStrategy messageGetStrategy = MessageGetters.JSON_FROM_POSITION.get("1");    messageGetStrategy.get(tuple);}
public void metron_f3640_0()
{    JSONObject actual = new JSONObject();    actual.put("field", "value");    Tuple tuple = mock(Tuple.class);    when(tuple.getValueByField("tuple_field")).thenReturn(actual);    JSONObject expected = new JSONObject();    expected.put("field", "value");    MessageGetStrategy messageGetStrategy = MessageGetters.JSON_FROM_FIELD.get("tuple_field");    assertEquals(expected, messageGetStrategy.get(tuple));}
public void metron_f3641_0()
{    Object actual = "object";    Tuple tuple = mock(Tuple.class);    when(tuple.getValueByField("tuple_field")).thenReturn(actual);    Object expected = "object";    MessageGetStrategy messageGetStrategy = MessageGetters.OBJECT_FROM_FIELD.get("tuple_field");    assertEquals(expected, messageGetStrategy.get(tuple));}
public void metron_f3642_0()
{    Tuple tuple = mock(Tuple.class);    when(tuple.getBinary(0)).thenReturn("bytes".getBytes(UTF_8));    MessageGetStrategy messageGetStrategy = MessageGetters.DEFAULT_BYTES_FROM_POSITION.get();    assertEquals("bytes", new String((byte[]) messageGetStrategy.get(tuple), UTF_8));}
public void metron_f3643_0()
{    Tuple tuple = mock(Tuple.class);    when(tuple.getBinary(0)).thenReturn("{\"field\":\"value\"}".getBytes(UTF_8));    JSONObject expected = new JSONObject();    expected.put("field", "value");    MessageGetStrategy messageGetStrategy = MessageGetters.DEFAULT_JSON_FROM_POSITION.get();    assertEquals(expected, messageGetStrategy.get(tuple));}
public void metron_f3644_0()
{    JSONObject actual = new JSONObject();    actual.put("field", "value");    Tuple tuple = mock(Tuple.class);    when(tuple.getValueByField("message")).thenReturn(actual);    JSONObject expected = new JSONObject();    expected.put("field", "value");    MessageGetStrategy messageGetStrategy = MessageGetters.DEFAULT_JSON_FROM_FIELD.get();    assertEquals(expected, messageGetStrategy.get(tuple));}
public void metron_f3645_0()
{    Object actual = "object";    Tuple tuple = mock(Tuple.class);    when(tuple.getValueByField("message")).thenReturn(actual);    Object expected = "object";    MessageGetStrategy messageGetStrategy = MessageGetters.DEFAULT_OBJECT_FROM_FIELD.get();    assertEquals(expected, messageGetStrategy.get(tuple));}
private static Tuple metron_f3646_0(Map<String, Object> kafkaFields, String metadata) throws Exception
{    List<Map.Entry<String, Object>> fields = new ArrayList<>();    for (Map.Entry<String, Object> kv : kafkaFields.entrySet()) {        fields.add(kv);    }    Tuple t = mock(Tuple.class);    Fields f = mock(Fields.class);    when(f.size()).thenReturn(fields.size() + 2);    for (int i = 0; i < fields.size(); ++i) {        when(f.get(eq(i + 2))).thenReturn(fields.get(i).getKey());        when(t.getValue(eq(i + 2))).thenReturn(fields.get(i).getValue());    }    when(t.getFields()).thenReturn(f);    when(t.getBinary(eq(RawMessageUtil.KEY_INDEX))).thenReturn(metadata.getBytes(StandardCharsets.UTF_8));    return t;}
private void metron_f3647_0(RawMessage m, boolean isEmpty)
{    if (!isEmpty) {        Assert.assertEquals("kafka_meta_1_val", m.getMetadata().get(MetadataUtil.METADATA_PREFIX + ".kafka_meta_1"));        Assert.assertEquals("kafka_meta_2_val", m.getMetadata().get(MetadataUtil.METADATA_PREFIX + ".kafka_meta_2"));    } else {        Assert.assertFalse(m.getMetadata().containsKey(MetadataUtil.METADATA_PREFIX + ".kafka_meta_1"));        Assert.assertFalse(m.getMetadata().containsKey(MetadataUtil.METADATA_PREFIX + ".kafka_meta_2"));    }}
private void metron_f3648_0(RawMessage m, boolean isEmpty)
{    if (!isEmpty) {        Assert.assertEquals("app_meta_1_val", m.getMetadata().get(MetadataUtil.METADATA_PREFIX + ".app_meta_1"));        Assert.assertEquals("app_meta_2_val", m.getMetadata().get(MetadataUtil.METADATA_PREFIX + ".app_meta_2"));    } else {        Assert.assertFalse(m.getMetadata().containsKey(MetadataUtil.METADATA_PREFIX + ".app_meta_1"));        Assert.assertFalse(m.getMetadata().containsKey(MetadataUtil.METADATA_PREFIX + ".app_meta_2"));    }}
public void metron_f3649_0() throws Exception
{    Tuple t = createTuple(kafkaMetadata, appMetadata);    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), true, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        checkKafkaMetadata(m, false);        checkAppMetadata(m, false);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), false, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
public void metron_f3650_0() throws Exception
{    Tuple t = createTuple(kafkaMetadata, "{}");    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), true, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        checkKafkaMetadata(m, false);        checkAppMetadata(m, true);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), false, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
public void metron_f3651_0() throws Exception
{    Tuple t = createTuple(new HashMap<>(), appMetadata);    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), true, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        checkKafkaMetadata(m, true);        checkAppMetadata(m, false);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), false, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
public void metron_f3652_0() throws Exception
{    Tuple t = createTuple(new HashMap<>(), "{}");    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), true, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        checkKafkaMetadata(m, true);        checkAppMetadata(m, true);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.DEFAULT, t, "raw_message".getBytes(StandardCharsets.UTF_8), false, new HashMap<>());        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
private void metron_f3653_0(RawMessage m)
{    Assert.assertEquals("real_original_string", m.getMetadata().get(MetadataUtil.METADATA_PREFIX + "." + Constants.Fields.ORIGINAL.getName()));    Assert.assertEquals("enveloped_metadata_val_1", m.getMetadata().get(MetadataUtil.METADATA_PREFIX + ".enveloped_metadata_field_1"));    Assert.assertEquals("enveloped_metadata_val_2", m.getMetadata().get(MetadataUtil.METADATA_PREFIX + ".enveloped_metadata_field_2"));}
private void metron_f3654_0(RawMessage m)
{    JSONObject message = new JSONObject(envelopedMessage);    RawMessageStrategies.ENVELOPE.mergeMetadata(message, m.getMetadata(), true, new HashMap<String, Object>() {    });    if (m.getMetadata().containsKey(MetadataUtil.METADATA_PREFIX + "." + Constants.Fields.ORIGINAL.getName())) {        Assert.assertEquals(m.getMetadata().get(MetadataUtil.METADATA_PREFIX + "." + Constants.Fields.ORIGINAL.getName()), message.get(Constants.Fields.ORIGINAL.getName()));    }    Assert.assertEquals("message_val1", message.get("message_field1"));}
public void metron_f3655_0() throws Exception
{    Tuple t = createTuple(kafkaMetadata, appMetadata);    Map<String, Object> config = ImmutableMap.of(EnvelopedRawMessageStrategy.MESSAGE_FIELD_CONFIG, "data");    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), true, config);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertFalse(m.getMetadata().containsKey("data"));        checkEnvelopeMetadata(m);        checkMergedData(m);        checkKafkaMetadata(m, false);        checkAppMetadata(m, false);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), false, config);        checkMergedData(m);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertFalse(m.getMetadata().containsKey("data"));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
public void metron_f3656_0() throws Exception
{    Tuple t = createTuple(kafkaMetadata, "{}");    Map<String, Object> config = ImmutableMap.of(EnvelopedRawMessageStrategy.MESSAGE_FIELD_CONFIG, "data");    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), true, config);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertFalse(m.getMetadata().containsKey("data"));        checkMergedData(m);        checkEnvelopeMetadata(m);        checkKafkaMetadata(m, false);        checkAppMetadata(m, true);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), false, config);        Assert.assertFalse(m.getMetadata().containsKey("data"));        checkMergedData(m);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
public void metron_f3657_0() throws Exception
{    Tuple t = createTuple(new HashMap<>(), appMetadata);    Map<String, Object> config = ImmutableMap.of(EnvelopedRawMessageStrategy.MESSAGE_FIELD_CONFIG, "data");    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), true, config);        Assert.assertFalse(m.getMetadata().containsKey("data"));        checkMergedData(m);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        checkEnvelopeMetadata(m);        checkKafkaMetadata(m, true);        checkAppMetadata(m, false);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), false, config);        Assert.assertFalse(m.getMetadata().containsKey("data"));        checkMergedData(m);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
public void metron_f3658_0() throws Exception
{    Tuple t = createTuple(new HashMap<>(), "{}");    Map<String, Object> config = ImmutableMap.of(EnvelopedRawMessageStrategy.MESSAGE_FIELD_CONFIG, "data");    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), true, config);        Assert.assertFalse(m.getMetadata().containsKey("data"));        checkMergedData(m);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        checkEnvelopeMetadata(m);        checkKafkaMetadata(m, true);        checkAppMetadata(m, true);    }    {        RawMessage m = RawMessageUtil.INSTANCE.getRawMessage(RawMessageStrategies.ENVELOPE, t, envelopedData.getBytes(StandardCharsets.UTF_8), false, config);        Assert.assertFalse(m.getMetadata().containsKey("data"));        checkMergedData(m);        Assert.assertEquals("raw_message", new String(m.getMessage(), StandardCharsets.UTF_8));        Assert.assertTrue(m.getMetadata().isEmpty());    }}
public void metron_f3659_0() throws Exception
{    Throwable e = new Exception("error");    MetronError error = new MetronError().withMessage("error message").withThrowable(e);    OutputCollector collector = mock(OutputCollector.class);    StormErrorUtils.handleError(collector, error);    verify(collector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    verify(collector, times(1)).reportError(any());}
protected Date metron_f3660_0(Date date)
{    Calendar calendar = Calendar.getInstance();    calendar.setTime(date);    calendar.set(Calendar.HOUR_OF_DAY, 0);    calendar.set(Calendar.MINUTE, 0);    calendar.set(Calendar.SECOND, 0);    calendar.set(Calendar.MILLISECOND, 0);    return calendar.getTime();}
public static void metron_f3661_1(String... argv) throws IOException, java.text.ParseException, ClassNotFoundException, InterruptedException
{    /**     * Example     * start=$(date -d '30 days ago' +%m/%d/%Y)     * yarn jar Metron-DataLoads-0.1BETA.jar org.apache.metron.dataloads.bulk.HDFSDataPruner -f hdfs://ec2-52-36-25-217.us-west-2.compute.amazonaws.com:8020 -g '/apps/metron/enrichment/indexed/bro_doc/*enrichment-*' -s $(date -d '30 days ago' +%m/%d/%Y) -n 1;     * echo ${start}     */    Options options = new Options();    Options help = new Options();    {        Option o = new Option("h", "help", false, "This screen");        o.setRequired(false);        help.addOption(o);    }    {        Option o = new Option("s", "start-date", true, "Starting Date (MM/DD/YYYY)");        o.setArgName("START_DATE");        o.setRequired(true);        options.addOption(o);    }    {        Option o = new Option("f", "filesystem", true, "Filesystem uri - e.g. hdfs://host:8020 or file:///");        o.setArgName("FILESYSTEM");        o.setRequired(true);        options.addOption(o);    }    {        Option o = new Option("n", "numdays", true, "Number of days back to purge");        o.setArgName("NUMDAYS");        o.setRequired(true);        options.addOption(o);    }    {        Option o = new Option("g", "glob-string", true, "Glob filemask for files to delete - e.g. /apps/metron/enrichment/bro_doc/file-*");        o.setArgName("GLOBSTRING");        o.setRequired(true);        options.addOption(o);    }    try {        CommandLineParser parser = new PosixParser();        CommandLine cmd = null;        try {            cmd = parser.parse(help, argv, true);            if (cmd.getOptions().length > 0) {                final HelpFormatter usageFormatter = new HelpFormatter();                usageFormatter.printHelp("HDFSDataPruner", null, options, null, true);                System.exit(0);            }            cmd = parser.parse(options, argv);        } catch (ParseException pe) {            final HelpFormatter usageFormatter = new HelpFormatter();            usageFormatter.printHelp("HDFSDataPruner", null, options, null, true);            System.exit(-1);        }        String start = cmd.getOptionValue("s");        Date startDate = new SimpleDateFormat("MM/dd/yyyy").parse(start);        String fileSystemUri = cmd.getOptionValue("f");        Integer numDays = Integer.parseInt(cmd.getOptionValue("n"));        String globString = cmd.getOptionValue("g");                DataPruner pruner = new HDFSDataPruner(startDate, numDays, fileSystemUri, globString);            } catch (Exception e) {        e.printStackTrace();        System.exit(-1);    }}
public Long metron_f3662_1() throws IOException
{    long filesPruned = 0L;    FileStatus[] filesToDelete = fileSystem.globStatus(globPath, new HDFSDataPruner.DateFileFilter(this));    for (FileStatus fileStatus : filesToDelete) {                fileSystem.delete(fileStatus.getPath(), false);        filesPruned++;    }    return filesPruned;}
public boolean metron_f3663_1(Path path)
{    try {                if (pruner.fileSystem.isDirectory(path)) {            return false;        }    } catch (IOException e) {                if (failOnError) {            throw new RuntimeException(e);        }        return false;    }    try {        FileStatus file = pruner.fileSystem.getFileStatus(path);        long fileModificationTime = file.getModificationTime();        boolean accept = false;        if (fileModificationTime >= pruner.firstTimeMillis && fileModificationTime < pruner.lastTimeMillis) {            accept = true;        }        return accept;    } catch (IOException e) {                if (failOnError) {            throw new RuntimeException(e);        }        return false;    }}
public boolean metron_f3664_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f3665_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
private static long metron_f3666_0(CommandLine cli) throws java.text.ParseException
{    Date d = getFormat(cli).parse(BulkLoadOptions.AS_OF_TIME.get(cli));    return d.getTime();}
private static DateFormat metron_f3667_0(CommandLine cli)
{    DateFormat format = new SimpleDateFormat();    if (BulkLoadOptions.AS_OF_TIME_FORMAT.has(cli)) {        format = new SimpleDateFormat(BulkLoadOptions.AS_OF_TIME_FORMAT.get(cli));    }    return format;}
public static CommandLine metron_f3668_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (BulkLoadOptions.HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static void metron_f3669_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("LeastRecentlyUsedPruner", getOptions());}
public static Options metron_f3670_0()
{    Options ret = new Options();    for (BulkLoadOptions o : BulkLoadOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public Option metron_f3671_0(@Nullable String s)
{    return new Option(s, "help", false, "Generate Help screen");}
public Option metron_f3672_0(@Nullable String s)
{    Option o = new Option(s, "table", true, "HBase table to prune");    o.setRequired(true);    o.setArgName("HBASE_TABLE");    return o;}
public Option metron_f3673_0(@Nullable String s)
{    Option o = new Option(s, "column_family", true, "Column family of the HBase table to prune");    o.setRequired(false);    o.setArgName("CF_NAME");    return o;}
public Option metron_f3674_0(@Nullable String s)
{    Option o = new Option(s, "as_of", true, "The earliest access tracker you want to use.");    o.setArgName("datetime");    o.setRequired(true);    return o;}
public Option metron_f3675_0(@Nullable String s)
{    String defaultFormat = new SimpleDateFormat().toLocalizedPattern();    Option o = new Option(s, "as_of_format", true, "The format of the as_of time (only used in conjunction with the as_of option) (Default is: " + defaultFormat + ")");    o.setArgName("format");    o.setRequired(false);    return o;}
public Option metron_f3676_0(@Nullable String s)
{    Option o = new Option(s, "access_table", true, "HBase table containing the access trackers.");    o.setRequired(true);    o.setArgName("HBASE_TABLE");    return o;}
public Option metron_f3677_0(@Nullable String s)
{    Option o = new Option(s, "access_column_family", true, "Column family of the HBase table containing the access trackers");    o.setRequired(true);    o.setArgName("CF_NAME");    return o;}
public static void metron_f3678_0(Job job, String sourceTable, String cf) throws IOException
{    Scan scan = new Scan();    if (cf != null) {        scan.addFamily(Bytes.toBytes(cf));    }        scan.setCaching(500);        scan.setCacheBlocks(false);        TableMapReduceUtil.initTableMapperJob(    sourceTable,     scan,     PrunerMapper.class,     null,     null, job);    TableMapReduceUtil.initTableReducerJob(    sourceTable,     null, job);}
public static Job metron_f3679_0(Configuration conf, String table, String cf, String accessTrackerTable, String accessTrackerColumnFamily, Long ts) throws IOException
{    Job job = new Job(conf);    job.setJobName("LeastRecentlyUsedPruner: Pruning " + table + ":" + cf + " since " + new SimpleDateFormat().format(new Date(ts)));    System.out.println("Configuring " + job.getJobName());    job.setJarByClass(LeastRecentlyUsedPruner.class);    job.getConfiguration().setLong(PrunerMapper.TIMESTAMP_CONF, ts);    job.getConfiguration().set(PrunerMapper.ACCESS_TRACKER_NAME_CONF, table);    job.getConfiguration().set(PrunerMapper.ACCESS_TRACKER_CF_CONF, accessTrackerColumnFamily);    job.getConfiguration().set(PrunerMapper.ACCESS_TRACKER_TABLE_CONF, accessTrackerTable);    setupHBaseJob(job, table, cf);    job.setNumReduceTasks(0);    return job;}
public static void metron_f3680_0(String... argv) throws IOException, java.text.ParseException, ClassNotFoundException, InterruptedException
{    Configuration conf = HBaseConfiguration.create();    String[] otherArgs = new GenericOptionsParser(conf, argv).getRemainingArgs();    CommandLine cli = BulkLoadOptions.parse(new PosixParser(), otherArgs);    Long ts = BulkLoadOptions.getTimestamp(cli);    String table = BulkLoadOptions.TABLE.get(cli);    String cf = BulkLoadOptions.COLUMN_FAMILY.get(cli);    String accessTrackerTable = BulkLoadOptions.ACCESS_TABLE.get(cli);    String accessTrackerCF = BulkLoadOptions.ACCESS_COLUMN_FAMILY.get(cli);    Job job = createJob(conf, table, cf, accessTrackerTable, accessTrackerCF, ts);    System.exit(job.waitForCompletion(true) ? 0 : 1);}
public int metron_f3681_0()
{    return typeColumnIndex;}
public String metron_f3682_0()
{    return type;}
public int metron_f3683_0()
{    return indicatorColumn;}
public LookupConverter metron_f3684_0()
{    return converter;}
public Iterable<LookupKV> metron_f3685_0(String line) throws IOException
{    if (ignore(line)) {        return Collections.emptyList();    }    String[] tokens = parser.parseLine(line);    LookupKey key = converter.toKey(getType(tokens), tokens[indicatorColumn]);    Map<String, Object> values = new HashMap<>();    for (Map.Entry<String, Integer> kv : columnMap.entrySet()) {        values.put(kv.getKey(), tokens[kv.getValue()]);    }    return Arrays.asList(new LookupKV(key, converter.toValue(values)));}
private String metron_f3686_0(String[] tokens)
{    if (type == null) {        return tokens[typeColumnIndex];    } else {        return type;    }}
public void metron_f3687_0(Map<String, Object> config)
{    super.initialize(config);    if (config.containsKey(INDICATOR_COLUMN_KEY)) {        indicatorColumn = columnMap.get(config.get(INDICATOR_COLUMN_KEY).toString());    }    if (config.containsKey(TYPE_KEY)) {        type = config.get(TYPE_KEY).toString();    } else if (config.containsKey(TYPE_COLUMN_KEY)) {        typeColumnIndex = columnMap.get(config.get(TYPE_COLUMN_KEY).toString());    }    if (config.containsKey(LOOKUP_CONVERTER)) {        converter = LookupConverters.getConverter((String) config.get(LOOKUP_CONVERTER));    }}
public LookupConverter metron_f3688_0()
{    return converter;}
public static LookupConverter metron_f3689_0(String name)
{    try {        return LookupConverters.valueOf(name).getConverter();    } catch (Throwable t) {        try {            return (LookupConverter) Class.forName(name).getConstructor().newInstance();        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException e) {            throw new IllegalStateException("Unable to parse " + name, e);        }    }}
public LookupKey metron_f3690_0(String type, String indicator)
{    return new EnrichmentKey(type, indicator);}
public LookupValue metron_f3691_0(Map<String, Object> metadata)
{    return new EnrichmentValue(metadata);}
 Set<ExtractorCapabilities> metron_f3692_0()
{    return EnumSet.noneOf(ExtractorCapabilities.class);}
public Iterable<LookupKV> metron_f3693_0(String line) throws IOException
{    return decoratedExtractor.extract(line);}
public void metron_f3694_0(Map<String, Object> config)
{    decoratedExtractor.initialize(config);}
public Extractor metron_f3695_0()
{    return decoratedExtractor;}
public Map<String, Object> metron_f3696_0()
{    return config;}
public void metron_f3697_0(Map<String, Object> config)
{    this.config = config;}
public InputFormatHandler metron_f3698_0()
{    return inputFormat;}
public void metron_f3699_0(String handler)
{    try {        this.inputFormat = Formats.create(handler);    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {        throw new IllegalStateException("Unable to create an inputformathandler", e);    }}
public Extractor metron_f3700_0()
{    return extractor;}
public void metron_f3701_0(String extractor)
{    try {        this.extractor = Extractors.create(extractor);    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) {        throw new IllegalStateException("Unable to create an extractor", e);    }}
public static synchronized ExtractorHandler metron_f3702_0(InputStream is) throws IOException
{    ExtractorHandler ret = _mapper.readValue(is, ExtractorHandler.class);    ret.getExtractor().initialize(ret.getConfig());    return ret;}
public static synchronized ExtractorHandler metron_f3703_0(String s, Charset c) throws IOException
{    return load(new ByteArrayInputStream(s.getBytes(c)));}
public static synchronized ExtractorHandler metron_f3704_0(String s) throws IOException
{    return load(s, Charset.defaultCharset());}
public Extractor metron_f3705_0()
{    return _creator.create();}
public static Extractor metron_f3706_0(String extractorName) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException
{    try {        ExtractorCreator ec = Extractors.valueOf(extractorName);        return new TransformFilterExtractorDecorator(ec.create());    } catch (IllegalArgumentException iae) {        Extractor ex = (Extractor) Class.forName(extractorName).getConstructor().newInstance();        return new TransformFilterExtractorDecorator(ex);    }}
public Extractor metron_f3707_0()
{    return new CSVExtractor();}
public Extractor metron_f3708_0()
{    return new StixExtractor();}
public void metron_f3709_0(Job job, List<Path> path, Map<String, Object> config) throws IOException
{    _handler.set(job, path, config);}
public static InputFormatHandler metron_f3710_0(String handlerName) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException
{    try {        InputFormatHandler ec = Formats.valueOf(handlerName)._handler;        return ec;    } catch (IllegalArgumentException iae) {        InputFormatHandler ex = (InputFormatHandler) Class.forName(handlerName).getConstructor().newInstance();        return ex;    }}
 void metron_f3711_0(Job job, Path input, Map<String, Object> config) throws IOException
{    set(job, ImmutableList.of(input), config);}
public void metron_f3712_0(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    this.fileSplit = (FileSplit) split;    this.conf = context.getConfiguration();}
public boolean metron_f3713_0() throws IOException, InterruptedException
{    if (!processed) {        byte[] contents = new byte[(int) fileSplit.getLength()];        Path file = fileSplit.getPath();        FileSystem fs = file.getFileSystem(conf);        FSDataInputStream in = null;        try {            in = fs.open(file);            IOUtils.readFully(in, contents, 0, contents.length);            value.set(contents, 0, contents.length);        } finally {            IOUtils.closeStream(in);        }        processed = true;        return true;    }    return false;}
public NullWritable metron_f3714_0() throws IOException, InterruptedException
{    return NullWritable.get();}
public Text metron_f3715_0() throws IOException, InterruptedException
{    return value;}
public float metron_f3716_0() throws IOException
{    return processed ? 1.0f : 0.0f;}
public void metron_f3717_0() throws IOException
{}
protected boolean metron_f3718_0(JobContext context, Path file)
{    return false;}
public RecordReader<NullWritable, Text> metron_f3719_0(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    WholeFileRecordReader reader = new WholeFileRecordReader();    reader.initialize(split, context);    return reader;}
public void metron_f3720_0(Job job, List<Path> inputs, Map<String, Object> config) throws IOException
{    for (Path input : inputs) {        WholeFileInputFormat.addInputPath(job, input);    }    job.setInputFormatClass(WholeFileInputFormat.class);}
public Iterable<LookupKV> metron_f3721_1(String line) throws IOException
{    STIXPackage stixPackage = STIXPackage.fromXMLString(line.replaceAll("\"Equal\"", "\"Equals\""));    List<LookupKV> ret = new ArrayList<>();    for (Observable o : getObservables(stixPackage)) {        ObjectType obj = o.getObject();        if (obj != null) {            ObjectPropertiesType props = obj.getProperties();            if (props != null) {                ObjectTypeHandler handler = ObjectTypeHandlers.getHandlerByInstance(props);                if (handler != null) {                    if (LOG.isDebugEnabled()) {                                            }                    Iterable<LookupKV> extractions = handler.extract(props, config);                    for (LookupKV extraction : extractions) {                        ret.add(extraction);                    }                } else if (LOG.isDebugEnabled()) {                                    }            }        }    }    return ret;}
public List<Observable> metron_f3722_0(STIXPackage stixPackage)
{    List<Observable> ret = new ArrayList<>();    Observables observables = stixPackage.getObservables();    if (observables != null) {        for (Observable o : observables.getObservables()) {            ret.add(o);        }    }    if (stixPackage.getIndicators() != null) {        if (stixPackage.getIndicators().getIndicators() != null) {            List<IndicatorBaseType> indicators = stixPackage.getIndicators().getIndicators();            int indicatorCount = indicators.size();            for (int i = 0; i < indicatorCount; i++) {                Indicator indicator = (Indicator) indicators.get(i);                if (indicator.getObservable() != null) {                    ret.add(indicator.getObservable());                }            }        }    }    return ret;}
public void metron_f3723_0(Map<String, Object> config)
{    this.config = config;}
public static Iterable<String> metron_f3724_0(StringObjectPropertyType value)
{    final ConditionTypeEnum condition = value.getCondition() == null ? ConditionTypeEnum.EQUALS : value.getCondition();    final ConditionApplicationEnum applyCondition = value.getApplyCondition();    List<String> tokens = new ArrayList<>();    if (condition == ConditionTypeEnum.EQUALS && applyCondition == ConditionApplicationEnum.ANY) {        String delim = value.getDelimiter();        String line = value.getValue().toString();        if (delim != null) {            for (String token : Splitter.on(delim).split(line)) {                tokens.add(token);            }        } else {            tokens.add(line);        }    }    return tokens;}
public static void metron_f3725_0(String[] args) throws IOException
{    File file = new File("/tmp/sample.xml");    /*if (args.length > 0) {            file = new File(args[0]);        } else {            try {                URL url = XML2Object.class.getClass().getResource(                        "/org/mitre/stix/examples/sample.xml");                file = new File(url.toURI());            } catch (URISyntaxException e) {                throw new RuntimeException(e);            }        }*/    String line = FileUtils.readFileToString(file);    StixExtractor extractor = new StixExtractor();    for (LookupKV results : extractor.extract(line)) {        System.out.println(results);    }}
public Class<T> metron_f3726_0()
{    return objectPropertiesType;}
public String metron_f3727_0()
{    return getTypeClass().getSimpleName().toLowerCase();}
public Iterable<LookupKV> metron_f3728_0(final Address type, Map<String, Object> config) throws IOException
{    List<LookupKV> ret = new ArrayList<>();    final CategoryTypeEnum category = type.getCategory();    if (!SUPPORTED_CATEGORIES.contains(category)) {        return ret;    }    String typeStr = getType();    if (config != null) {        if (config.containsKey(SPECIFIC_CATEGORY_CONFIG)) {            List<CategoryTypeEnum> categories = new ArrayList<>();            for (String c : Splitter.on(",").split(config.get(SPECIFIC_CATEGORY_CONFIG).toString())) {                categories.add(CategoryTypeEnum.valueOf(c));            }            EnumSet<CategoryTypeEnum> specificCategories = EnumSet.copyOf(categories);            if (!specificCategories.contains(category)) {                return ret;            }        }        if (config.containsKey(TYPE_CONFIG)) {            typeStr = config.get(TYPE_CONFIG).toString();        }    }    StringObjectPropertyType value = type.getAddressValue();    for (String token : StixExtractor.split(value)) {        final String indicatorType = typeStr + ":" + category;        LookupKV results = new LookupKV(new EnrichmentKey(indicatorType, token), new EnrichmentValue(new HashMap<String, Object>() {            {                put("source-type", "STIX");                put("indicator-type", indicatorType);                put("source", type.toXMLString());            }        }));        ret.add(results);    }    return ret;}
public List<String> metron_f3729_0()
{    String typeStr = getType();    List<String> ret = new ArrayList<>();    for (CategoryTypeEnum e : SUPPORTED_CATEGORIES) {        ret.add(typeStr + ":" + e);    }    return ret;}
public Iterable<LookupKV> metron_f3730_0(final DomainName type, Map<String, Object> config) throws IOException
{    List<LookupKV> ret = new ArrayList<>();    String typeStr = getType();    if (config != null) {        Object o = config.get(TYPE_CONFIG);        if (o != null) {            typeStr = o.toString();        }    }    final DomainNameTypeEnum domainType = type.getType();    if (domainType == null || SUPPORTED_TYPES.contains(domainType)) {        StringObjectPropertyType value = type.getValue();        for (String token : StixExtractor.split(value)) {            final String indicatorType = typeStr + ":" + DomainNameTypeEnum.FQDN;            LookupKV results = new LookupKV(new EnrichmentKey(indicatorType, token), new EnrichmentValue(new HashMap<String, Object>() {                {                    put("source-type", "STIX");                    put("indicator-type", indicatorType);                    put("source", type.toXMLString());                }            }));            ret.add(results);        }    }    return ret;}
public List<String> metron_f3731_0()
{    String typeStr = getType();    List<String> ret = new ArrayList<>();    for (DomainNameTypeEnum e : SUPPORTED_TYPES) {        ret.add(typeStr + ":" + e);    }    return ret;}
public Iterable<LookupKV> metron_f3732_0(final Hostname type, Map<String, Object> config) throws IOException
{    StringObjectPropertyType value = type.getHostnameValue();    String typeStr = getType();    if (config != null) {        Object o = config.get(TYPE_CONFIG);        if (o != null) {            typeStr = o.toString();        }    }    List<LookupKV> ret = new ArrayList<>();    for (String token : StixExtractor.split(value)) {        final String indicatorType = typeStr;        LookupKV results = new LookupKV(new EnrichmentKey(indicatorType, token), new EnrichmentValue(new HashMap<String, Object>() {            {                put("source-type", "STIX");                put("indicator-type", indicatorType);                put("source", type.toXMLString());            }        }));        ret.add(results);    }    return ret;}
public List<String> metron_f3733_0()
{    return ImmutableList.of(getType());}
 ObjectTypeHandler metron_f3734_0()
{    return _handler;}
public static ObjectTypeHandler metron_f3735_0(ObjectPropertiesType inst)
{    for (ObjectTypeHandlers h : values()) {        if (inst.getClass().equals(h.getHandler().getTypeClass())) {            return h.getHandler();        }    }    return null;}
public Iterable<LookupKV> metron_f3736_0(URIObjectType type, Map<String, Object> config) throws IOException
{    List<LookupKV> ret = new ArrayList<>();    if (type != null) {        AnyURIObjectPropertyType val = type.getValue();        if (val != null) {            Object v = val.getValue();            if (v != null) {                final String indicatorType = getType();                LookupKV results = new LookupKV(new EnrichmentKey(indicatorType, v.toString()), new EnrichmentValue(new HashMap<String, Object>() {                    {                        put("source-type", "STIX");                        put("uri", v.toString());                        put("indicator-type", indicatorType);                        put("source", type.toXMLString());                    }                }));                ret.add(results);            }        }    }    return ret;}
public List<String> metron_f3737_0()
{    return ImmutableList.of(getType());}
public String metron_f3738_0()
{    return key;}
public boolean metron_f3739_0(Map<String, Object> config)
{    return config == null ? false : config.containsKey(key);}
public void metron_f3740_0(Map<String, Object> config)
{    super.initialize(config);    if (VALUE_TRANSFORM.existsIn(config)) {        this.valueTransforms = getTransforms(config, VALUE_TRANSFORM.toString());    }    if (INDICATOR_TRANSFORM.existsIn(config)) {        this.indicatorTransforms = getTransforms(config, INDICATOR_TRANSFORM.toString());    }    if (VALUE_FILTER.existsIn(config)) {        this.valueFilter = getFilter(config, VALUE_FILTER.toString());    }    if (INDICATOR_FILTER.existsIn(config)) {        this.indicatorFilter = getFilter(config, INDICATOR_FILTER.toString());    }    if (STATE_UPDATE.existsIn(config)) {        capabilities.add(ExtractorCapabilities.STATEFUL);        this.stateUpdate = getTransforms(config, STATE_UPDATE.toString());    }    if (STATE_INIT.existsIn(config)) {        capabilities.add(ExtractorCapabilities.STATEFUL);    }    if (STATE_MERGE.existsIn(config)) {        capabilities.add(ExtractorCapabilities.MERGEABLE);        this.stateMerge = getFilter(config, STATE_MERGE.toString());    }    String zkClientUrl = "";    if (ZK_QUORUM.existsIn(config)) {        zkClientUrl = ConversionUtils.convert(config.get(ZK_QUORUM.toString()), String.class);    }    zkClient = setupClient(zkClient, zkClientUrl);    this.globalConfig = getGlobalConfig(zkClient);    this.stellarContext = createContext(zkClient);    StellarFunctions.initialize(stellarContext);    this.transformProcessor = new StellarProcessor();    this.filterProcessor = new StellarPredicateProcessor();}
public Object metron_f3741_0(Map<String, Object> config)
{    if (STATE_INIT.existsIn(config)) {        MapVariableResolver resolver = new MapVariableResolver(globalConfig);        return transformProcessor.parse(config.get(STATE_INIT.toString()).toString(), resolver, StellarFunctions.FUNCTION_RESOLVER(), stellarContext);    }    return null;}
public Object metron_f3742_0(List<? extends Object> states)
{    return transformProcessor.parse(stateMerge, new MapVariableResolver(new HashMap<String, Object>() {        {            put(STATES_KEY, states);        }    }, globalConfig), StellarFunctions.FUNCTION_RESOLVER(), stellarContext);}
private String metron_f3743_0(Map<String, Object> config, String valueFilter)
{    return (String) config.get(valueFilter);}
private Map<String, String> metron_f3744_0(Map<String, Object> config, String type)
{        @SuppressWarnings("unchecked")    Map<Object, Object> transformsConfig = (Map) config.get(type);    Map<String, String> transforms = new LinkedHashMap<>();    for (Map.Entry<Object, Object> e : transformsConfig.entrySet()) {        transforms.put((String) e.getKey(), (String) e.getValue());    }    return transforms;}
private Optional<CuratorFramework> metron_f3745_1(Optional<CuratorFramework> zkClient, String zookeeperUrl)
{        if (!zkClient.isPresent()) {        if (StringUtils.isNotBlank(zookeeperUrl)) {            CuratorFramework client = ConfigurationsUtils.getClient(zookeeperUrl);            client.start();            return Optional.of(client);        } else {                        return Optional.empty();        }    } else {        return zkClient;    }}
private Map<String, Object> metron_f3746_1(Optional<CuratorFramework> zkClient)
{    if (zkClient.isPresent()) {        try {            return JSONUtils.INSTANCE.load(new ByteArrayInputStream(ConfigurationsUtils.readGlobalConfigBytesFromZookeeper(zkClient.get())), JSONUtils.MAP_SUPPLIER);        } catch (Exception e) {                    }    }    return new LinkedHashMap<>();}
private Context metron_f3747_0(Optional<CuratorFramework> zkClient)
{    Context.Builder builder = new Context.Builder();    if (zkClient.isPresent()) {        builder.with(Context.Capabilities.ZOOKEEPER_CLIENT, zkClient::get);    }    builder.with(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    builder.with(Context.Capabilities.STELLAR_CONFIG, () -> globalConfig);    return builder.build();}
public Set<ExtractorCapabilities> metron_f3748_0()
{    return capabilities;}
public Iterable<LookupKV> metron_f3749_0(String line) throws IOException
{    return extract(line, new AtomicReference<>(null));}
public Iterable<LookupKV> metron_f3750_0(String line, AtomicReference<Object> state) throws IOException
{    List<LookupKV> lkvs = new ArrayList<>();    for (LookupKV lkv : super.extract(line)) {        if (updateLookupKV(lkv, state)) {            lkvs.add(lkv);        }    }    return lkvs;}
private boolean metron_f3751_0(LookupKV lkv, AtomicReference<Object> state)
{    Map<String, Object> ret = lkv.getValue().getMetadata();    Map<String, Object> ind = new LinkedHashMap<>();    String indicator = lkv.getKey().getIndicator();        ind.put(INDICATOR.toString(), indicator);    Map<String, Object> stateMap = new LinkedHashMap<>();    stateMap.put(STATE_KEY, state.get());    MapVariableResolver resolver = new MapVariableResolver(ret, ind, globalConfig, stateMap);    transform(valueTransforms, ret, resolver);    transform(indicatorTransforms, ind, resolver);        Object updatedIndicator = ind.get(INDICATOR.toString());    if (updatedIndicator != null || getCapabilities().contains(ExtractorCapabilities.STATEFUL)) {        if (!(updatedIndicator instanceof String)) {            throw new UnsupportedOperationException("Indicator transform must return String type");        }        lkv.getKey().setIndicator((String) updatedIndicator);        boolean update = filter(indicatorFilter, resolver) && filter(valueFilter, resolver);        if (update && !stateUpdate.isEmpty()) {            transform(stateUpdate, stateMap, resolver);            state.set(stateMap.get(STATE_KEY));        }        return update;    } else {        return false;    }}
private void metron_f3752_0(Map<String, String> transforms, Map<String, Object> variableMap, MapVariableResolver variableResolver)
{    for (Map.Entry<String, String> entry : transforms.entrySet()) {        Object o = transformProcessor.parse(entry.getValue(), variableResolver, StellarFunctions.FUNCTION_RESOLVER(), stellarContext);        if (o == null) {            variableMap.remove(entry.getKey());        } else {            variableMap.put(entry.getKey(), o);        }    }}
private Boolean metron_f3753_0(String filterPredicate, MapVariableResolver variableResolver)
{    if (StringUtils.isEmpty(filterPredicate)) {        return true;    }    return filterProcessor.parse(filterPredicate, variableResolver, StellarFunctions.FUNCTION_RESOLVER(), stellarContext);}
protected void metron_f3754_0(Optional<CuratorFramework> zkClient)
{    this.zkClient = zkClient;}
public void metron_f3755_0(Context context) throws IOException, InterruptedException
{    initialize(context.getConfiguration());}
public void metron_f3756_0(Object key, Text value, Context context) throws IOException, InterruptedException
{    for (LookupKV results : extractor.extract(value.toString())) {        if (results != null) {            Put put = converter.toPut(columnFamily, results.getKey(), results.getValue());            write(new ImmutableBytesWritable(results.getKey().toBytes()), put, context);        }    }}
protected void metron_f3757_0(Configuration configuration) throws IOException
{    String configStr = configuration.get(CONFIG_KEY);    extractor = ExtractorHandler.load(configStr).getExtractor();    columnFamily = configuration.get(COLUMN_FAMILY_KEY);    try {        converter = (HbaseConverter) Class.forName(configuration.get(CONVERTER_KEY)).getConstructor().newInstance();    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException e) {        throw new IllegalStateException("Unable to create converter object: " + configuration.get(CONVERTER_KEY), e);    }}
protected void metron_f3758_0(ImmutableBytesWritable key, Put value, Context context) throws IOException, InterruptedException
{    context.write(key, value);}
public void metron_f3759_0(Context context) throws IOException
{    String atTable = context.getConfiguration().get(ACCESS_TRACKER_TABLE_CONF);    String atCF = context.getConfiguration().get(ACCESS_TRACKER_CF_CONF);    String atName = context.getConfiguration().get(ACCESS_TRACKER_NAME_CONF);    Table table = new HTableProvider().getTable(context.getConfiguration(), atTable);    long timestamp = context.getConfiguration().getLong(TIMESTAMP_CONF, -1);    if (timestamp < 0) {        throw new IllegalStateException("Must specify a timestamp that is positive.");    }    try {        tracker = AccessTrackerUtil.INSTANCE.loadAll(AccessTrackerUtil.INSTANCE.loadAll(table, atCF, atName, timestamp));    } catch (Throwable e) {        throw new IllegalStateException("Unable to load the accesstrackers from the directory", e);    }}
public void metron_f3760_0(ImmutableBytesWritable key, Result value, Context context) throws IOException, InterruptedException
{    if (tracker == null || key == null) {        throw new RuntimeException("Tracker = " + tracker + " key = " + key);    }    if (!tracker.hasSeen(toLookupKey(key.get()))) {        Delete d = new Delete(key.get());        context.write(key, d);    }}
protected LookupKey metron_f3761_0(final byte[] bytes)
{    return new LookupKey() {        @Override        public byte[] toBytes() {            return bytes;        }        @Override        public void fromBytes(byte[] in) {        }        @Override        public String getIndicator() {            return null;        }        @Override        public void setIndicator(String indicator) {        }    };}
public byte[] metron_f3762_0()
{    return bytes;}
public void metron_f3763_0(byte[] in)
{}
public String metron_f3764_0()
{    return null;}
public void metron_f3765_0(String indicator)
{}
public String metron_f3766_0()
{    return "h";}
public Option metron_f3767_0(@Nullable String input)
{    return new Option(getShortCode(), "help", false, "Generate Help screen");}
public String metron_f3768_0()
{    return "q";}
public Option metron_f3769_0(@Nullable String input)
{    return new Option(getShortCode(), "quiet", false, "Do not update progress");}
public Optional<Object> metron_f3770_0(OPT_T option, CommandLine cli)
{    return Optional.of(option.has(cli));}
public String metron_f3771_0()
{    return "m";}
public Option metron_f3772_0(@Nullable String input)
{    Option o = new Option(getShortCode(), "import_mode", true, "The Import mode to use: " + Joiner.on(",").join(importModes) + ".  Default: " + defaultMode);    o.setArgName("MODE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f3773_0(OPT_T option, CommandLine cli)
{    String mode = option.get(cli);    return resolver.apply(mode);}
public Option metron_f3774_0(@Nullable String s)
{    Option o = new Option(s, "extractor_config", true, "JSON Document describing the extractor for this input data source");    o.setArgName("JSON_FILE");    o.setRequired(true);    return o;}
public Optional<Object> metron_f3775_0(OPT_T option, CommandLine cli)
{    try {        return Optional.ofNullable(FileUtils.readFileToString(new File(option.get(cli).trim())));    } catch (IOException e) {        throw new IllegalStateException("Unable to retrieve extractor config from " + option.get(cli) + ": " + e.getMessage(), e);    }}
public String metron_f3776_0()
{    return "e";}
public Option metron_f3777_0(@Nullable String s)
{    Option o = new Option(s, "log4j", true, "The log4j properties file to load");    o.setArgName("FILE");    o.setRequired(false);    return o;}
public String metron_f3778_0()
{    return "l";}
public Option metron_f3779_0(@Nullable String s)
{    Option o = new Option(s, "threads", true, "The number of threads to use when extracting data.  The default is the number of cores of your machine.");    o.setArgName("NUM_THREADS");    o.setRequired(false);    return o;}
public Optional<Object> metron_f3780_0(OPT_T option, CommandLine cli)
{    int numThreads = Runtime.getRuntime().availableProcessors();    if (option.has(cli)) {        numThreads = ConversionUtils.convert(option.get(cli), Integer.class);    }    return Optional.of(numThreads);}
public String metron_f3781_0()
{    return "p";}
public Option metron_f3782_0(@Nullable String s)
{    Option o = new Option(s, "batchSize", true, "The batch size to use for HBase puts");    o.setArgName("SIZE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f3783_0(OPT_T option, CommandLine cli)
{    int batchSize = 128;    if (option.has(cli)) {        batchSize = ConversionUtils.convert(option.get(cli), Integer.class);    }    return Optional.of(batchSize);}
public String metron_f3784_0()
{    return "b";}
public Option metron_f3785_0(@Nullable String s)
{    Option o = new Option(s, "input", true, "The CSV File to load");    o.setArgName("FILE");    o.setRequired(true);    return o;}
public Optional<Object> metron_f3786_0(OPT_T option, CommandLine cli)
{    List<String> inputs = new ArrayList<>();    for (String input : Splitter.on(",").split(Optional.ofNullable(option.get(cli)).orElse(""))) {        inputs.add(input.trim());    }    return Optional.of(inputs);}
public String metron_f3787_0()
{    return "i";}
public String metron_f3788_0()
{    return cf;}
public Table metron_f3789_0()
{    return table;}
public Extractor metron_f3790_0()
{    return extractor;}
public HbaseConverter metron_f3791_0()
{    return converter;}
public FileSystem metron_f3792_0()
{    return fs;}
public void metron_f3793_0(final EnumMap<OPTIONS_T, Optional<Object>> config, final ExtractorHandler handler, final Configuration hadoopConfig) throws IOException, InvalidWriterOutput
{    validateState(config, handler);    ThreadLocal<STATE_T> state = createState(config, hadoopConfig, handler);    boolean quiet = isQuiet(config);    boolean lineByLine = !handler.getInputFormat().getClass().equals(WholeFileFormat.class);    List<String> inputs = getInputs(config);    FileSystem fs = FileSystem.get(hadoopConfig);    if (!lineByLine) {        extractWholeFiles(inputs, fs, state, quiet);    } else {        int batchSize = batchSize(config);        int numThreads = numThreads(config, handler);        extractLineByLine(inputs, fs, state, batchSize, numThreads, quiet);    }    if (!quiet) {        System.out.println();    }}
protected Location metron_f3794_0(String input, FileSystem fs)
{    return LocationStrategy.getLocation(input, fs);}
public void metron_f3795_0(List<String> inputs, FileSystem fs, ThreadLocal<STATE_T> state, int batchSize, int numThreads, boolean quiet) throws IOException
{    inputs.stream().map(input -> resolveLocation(input, fs)).forEach(loc -> {        final Progress progress = new Progress();        if (!quiet) {            System.out.println("\nProcessing " + loc.toString());        }        try (Stream<String> stream = ReaderSpliterator.lineStream(loc.openReader(), batchSize)) {            ForkJoinPool forkJoinPool = new ForkJoinPool(numThreads);            forkJoinPool.submit(() -> stream.parallel().forEach(input -> {                try {                    extract(state.get(), input);                    if (!quiet) {                        progress.update();                    }                } catch (IOException e) {                    throw new IllegalStateException("Unable to continue: " + e.getMessage(), e);                }            })).get();        } catch (Exception e) {            throw new IllegalStateException(e.getMessage(), e);        }    });}
public void metron_f3796_0(List<String> inputs, FileSystem fs, ThreadLocal<STATE_T> state, boolean quiet) throws IOException
{    final Progress progress = new Progress();    final List<Location> locations = getLocationsRecursive(inputs, fs);    locations.parallelStream().forEach(loc -> {        try (BufferedReader br = loc.openReader()) {            String s = br.lines().collect(Collectors.joining());            extract(state.get(), s);            if (!quiet) {                progress.update();            }        } catch (IOException e) {            throw new IllegalStateException("Unable to read " + loc + ": " + e.getMessage(), e);        }    });}
protected List<Location> metron_f3797_0(List<String> inputs, FileSystem fs) throws IOException
{    final List<Location> locations = new ArrayList<>();    Location.fileVisitor(inputs, loc -> locations.add(loc), fs);    return locations;}
public synchronized void metron_f3798_0()
{    int currentCount = count++;    System.out.print("\rProcessed " + currentCount + " - " + anim.charAt(currentCount % anim.length()));}
protected void metron_f3799_0(EnumMap<OPTIONS_T, Optional<Object>> config, OPTIONS_T option)
{    if (!config.containsKey(option)) {        throw new IllegalStateException("Expected " + option.getOption().getOpt() + " to be set");    }}
public Importer metron_f3800_0()
{    return importer;}
public static Optional<ImportStrategy> metron_f3801_0(String strategyName)
{    if (strategyName == null) {        return Optional.empty();    }    for (ImportStrategy strategy : values()) {        if (strategy.name().equalsIgnoreCase(strategyName.trim())) {            return Optional.of(strategy);        }    }    return Optional.empty();}
protected List<String> metron_f3802_0(EnumMap<LoadOptions, Optional<Object>> config)
{    return (List<String>) config.get(LoadOptions.INPUT).get();}
protected boolean metron_f3803_0(EnumMap<LoadOptions, Optional<Object>> config)
{    return (boolean) config.get(LoadOptions.QUIET).get();}
protected int metron_f3804_0(EnumMap<LoadOptions, Optional<Object>> config)
{    return (int) config.get(LoadOptions.BATCH_SIZE).get();}
protected int metron_f3805_0(EnumMap<LoadOptions, Optional<Object>> config, ExtractorHandler handler)
{    return (int) config.get(LoadOptions.NUM_THREADS).get();}
protected void metron_f3806_0(EnumMap<LoadOptions, Optional<Object>> config, ExtractorHandler handler)
{    assertOption(config, LoadOptions.HBASE_CF);    assertOption(config, LoadOptions.HBASE_TABLE);}
protected ThreadLocal<HBaseExtractorState> metron_f3807_0(EnumMap<LoadOptions, Optional<Object>> config, Configuration hadoopConfig, final ExtractorHandler handler)
{    ThreadLocal<HBaseExtractorState> state = new ThreadLocal<HBaseExtractorState>() {        @Override        protected HBaseExtractorState initialValue() {            try {                String cf = (String) config.get(LoadOptions.HBASE_CF).get();                Table table = provider.retrieve().getTable(hadoopConfig, (String) config.get(LoadOptions.HBASE_TABLE).get());                return new HBaseExtractorState(table, cf, handler.getExtractor(), new EnrichmentConverter(), hadoopConfig);            } catch (IOException e1) {                throw new IllegalStateException("Unable to get table: " + e1);            }        }    };    return state;}
protected HBaseExtractorState metron_f3808_0()
{    try {        String cf = (String) config.get(LoadOptions.HBASE_CF).get();        Table table = provider.retrieve().getTable(hadoopConfig, (String) config.get(LoadOptions.HBASE_TABLE).get());        return new HBaseExtractorState(table, cf, handler.getExtractor(), new EnrichmentConverter(), hadoopConfig);    } catch (IOException e1) {        throw new IllegalStateException("Unable to get table: " + e1);    }}
protected void metron_f3809_0(HBaseExtractorState state, String line) throws IOException
{    HBaseExtractorState es = state;    es.getTable().put(toPut(line, es.getExtractor(), state.getCf(), es.getConverter()));}
public List<Put> metron_f3810_0(String line, Extractor extractor, String cf, HbaseConverter converter) throws IOException
{    List<Put> ret = new ArrayList<>();    Iterable<LookupKV> kvs = extractor.extract(line);    for (LookupKV kv : kvs) {        Put put = converter.toPut(cf, kv.getKey(), kv.getValue());        ret.add(put);    }    return ret;}
public AtomicReference<Object> metron_f3811_0()
{    return state;}
public StatefulExtractor metron_f3812_0()
{    return extractor;}
protected boolean metron_f3813_0(EnumMap<SummarizeOptions, Optional<Object>> config)
{    return (boolean) config.getOrDefault(SummarizeOptions.QUIET, Optional.of(false)).get();}
protected int metron_f3814_0(EnumMap<SummarizeOptions, Optional<Object>> config)
{    return (int) config.getOrDefault(SummarizeOptions.BATCH_SIZE, Optional.of(1)).get();}
protected int metron_f3815_0(EnumMap<SummarizeOptions, Optional<Object>> config, ExtractorHandler handler)
{    if (handler.getExtractor().getCapabilities().contains(ExtractorCapabilities.MERGEABLE)) {        return (int) config.get(SummarizeOptions.NUM_THREADS).get();    } else {                return 1;    }}
protected void metron_f3816_0(EnumMap<SummarizeOptions, Optional<Object>> config, ExtractorHandler handler)
{    if (!(handler.getExtractor() instanceof StatefulExtractor)) {        throw new IllegalStateException("Extractor must be a stateful extractor and " + handler.getExtractor().getClass().getName() + " is not.");    }    assertOption(config, SummarizeOptions.OUTPUT);    if (!handler.getExtractor().getCapabilities().contains(ExtractorCapabilities.STATEFUL)) {        throw new IllegalStateException("Unable to operate on a non-stateful extractor.  " + "If you have not specified \"stateUpdate\" in your Extractor config, there is nothing to do here and nothing will be written.");    }}
protected ThreadLocal<SummarizationState> metron_f3817_0(EnumMap<SummarizeOptions, Optional<Object>> config, Configuration hadoopConfig, ExtractorHandler handler)
{    final StatefulExtractor extractor = (StatefulExtractor) handler.getExtractor();    return ThreadLocal.withInitial(() -> {        Object initState = extractor.initializeState(handler.getConfig());        SummarizationState ret = new SummarizationState(extractor, initState);        stateList.add(ret);        return ret;    });}
protected void metron_f3818_0(SummarizationState state, String line) throws IOException
{    state.getExtractor().extract(line, state.getState());}
public void metron_f3819_0(EnumMap<SummarizeOptions, Optional<Object>> config, ExtractorHandler handler, Configuration hadoopConfig) throws IOException, InvalidWriterOutput
{    Writer writer = (Writer) config.get(SummarizeOptions.OUTPUT_MODE).get();    Optional<String> fileName = Optional.ofNullable((String) config.get(SummarizeOptions.OUTPUT).orElse(null));    writer.validate(fileName, hadoopConfig);    super.importData(config, handler, hadoopConfig);    StatefulExtractor extractor = (StatefulExtractor) handler.getExtractor();    Object finalState = null;    if (stateList.size() == 1) {        finalState = stateList.get(0).getState().get();    } else if (stateList.size() > 1) {        List<Object> states = new ArrayList<>();        for (SummarizationState s : stateList) {            states.add(s.getState().get());        }        finalState = extractor.mergeStates(states);    }    writer.write(finalState, fileName, hadoopConfig);}
protected List<String> metron_f3820_0(EnumMap<SummarizeOptions, Optional<Object>> config)
{    Object o = config.get(SummarizeOptions.INPUT).get();    if (o == null) {        return new ArrayList<>();    }    if (o instanceof String) {        return ImmutableList.of((String) o);    }    return (List<String>) config.get(SummarizeOptions.INPUT).get();}
public void metron_f3821_1(EnumMap<LoadOptions, Optional<Object>> config, ExtractorHandler handler, Configuration hadoopConfig) throws IOException
{    String table = (String) config.get(LoadOptions.HBASE_TABLE).get();    String cf = (String) config.get(LoadOptions.HBASE_CF).get();    String extractorConfigContents = (String) config.get(LoadOptions.EXTRACTOR_CONFIG).get();    Job job = Job.getInstance(hadoopConfig);    List<String> inputs = (List<String>) config.get(LoadOptions.INPUT).get();    job.setJobName("MapReduceImporter: " + inputs.stream().collect(Collectors.joining(",")) + " => " + table + ":" + cf);        job.setJarByClass(MapReduceImporter.class);    job.setMapperClass(org.apache.metron.dataloads.hbase.mr.BulkLoadMapper.class);    job.setOutputFormatClass(TableOutputFormat.class);    job.getConfiguration().set(TableOutputFormat.OUTPUT_TABLE, table);    job.getConfiguration().set(BulkLoadMapper.COLUMN_FAMILY_KEY, cf);    job.getConfiguration().set(BulkLoadMapper.CONFIG_KEY, extractorConfigContents);    job.getConfiguration().set(BulkLoadMapper.CONVERTER_KEY, EnrichmentConverter.class.getName());    job.setOutputKeyClass(ImmutableBytesWritable.class);    job.setOutputValueClass(Put.class);    job.setNumReduceTasks(0);    List<Path> paths = inputs.stream().map(p -> new Path(p)).collect(Collectors.toList());    handler.getInputFormat().set(job, paths, handler.getConfig());    TableMapReduceUtil.initCredentials(job);    try {        job.waitForCompletion(true);    } catch (Exception e) {        throw new IllegalStateException("Unable to complete job: " + e.getMessage(), e);    }}
public Importer metron_f3822_0()
{    return importer;}
public static Optional<Summarizers> metron_f3823_0(String strategyName)
{    if (strategyName == null) {        return Optional.empty();    }    for (Summarizers strategy : values()) {        if (strategy.name().equalsIgnoreCase(strategyName.trim())) {            return Optional.of(strategy);        }    }    return Optional.empty();}
public OptionHandler<LoadOptions> metron_f3824_0()
{    return handler;}
public Option metron_f3825_0()
{    return option;}
public boolean metron_f3826_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f3827_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public static CommandLine metron_f3828_0(CommandLineParser parser, String[] args)
{    return OptionHandler.parse("SimpleEnrichmentFlatFileLoader", parser, args, values(), HELP);}
public static EnumMap<LoadOptions, Optional<Object>> metron_f3829_0(CommandLine cli)
{    return OptionHandler.createConfig(cli, values(), LoadOptions.class);}
public Option metron_f3830_0(@Nullable String s)
{    Option o = new Option(s, "hbase_table", true, "HBase table to ingest the data into.");    o.setArgName("TABLE");    o.setRequired(true);    return o;}
public Optional<Object> metron_f3831_0(LoadOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public String metron_f3832_0()
{    return "t";}
public Option metron_f3833_0(@Nullable String s)
{    Option o = new Option(s, "hbase_cf", true, "HBase column family to ingest the data into.");    o.setArgName("CF");    o.setRequired(true);    return o;}
public Optional<Object> metron_f3834_0(LoadOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public String metron_f3835_0()
{    return "c";}
public String metron_f3836_0()
{    return "n";}
public Option metron_f3837_0(@Nullable String s)
{    Option o = new Option(s, "enrichment_config", true, "JSON Document describing the enrichment configuration details." + "  This is used to associate an enrichment type with a field type in zookeeper.");    o.setArgName("JSON_FILE");    o.setRequired(false);    return o;}
public Optional<List<String>> metron_f3838_0(String loc)
{    List<String> children = new ArrayList<>();    for (File f : new File(loc).listFiles()) {        children.add(f.getPath());    }    return Optional.of(children);}
public boolean metron_f3839_0(String loc) throws IOException
{    return new File(loc).exists();}
public boolean metron_f3840_0(String loc) throws IOException
{    return new File(loc).isDirectory();}
public InputStream metron_f3841_0(String loc) throws IOException
{    return new FileInputStream(loc);}
public boolean metron_f3842_0(String loc)
{    return new File(loc).exists();}
public Optional<List<String>> metron_f3843_0(String loc) throws IOException
{    List<String> children = new ArrayList<>();    for (FileStatus f : fs.listStatus(new Path(loc))) {        children.add(f.getPath().toString());    }    return Optional.of(children);}
public boolean metron_f3844_0(String loc) throws IOException
{    return fs.exists(new Path(loc));}
public boolean metron_f3845_0(String loc) throws IOException
{    return fs.isDirectory(new Path(loc));}
public InputStream metron_f3846_0(String loc) throws IOException
{    return fs.open(new Path(loc));}
public boolean metron_f3847_0(String loc)
{    try {        return loc.startsWith("hdfs://") && exists(loc);    } catch (IOException e) {        return false;    }}
public void metron_f3848_0(FileSystem state)
{    this.fs = state;}
public RawLocation<?> metron_f3849_0()
{    return rawLocation;}
public Optional<List<Location>> metron_f3850_0() throws IOException
{    if (exists() && isDirectory()) {        List<Location> children = new ArrayList<>();        for (String child : rawLocation.list(loc).orElse(new ArrayList<>())) {            children.add(new Location(child, rawLocation));        }        return Optional.of(children);    } else {        return Optional.empty();    }}
public boolean metron_f3851_0() throws IOException
{    return rawLocation.exists(loc);}
public boolean metron_f3852_0() throws IOException
{    return rawLocation.isDirectory(loc);}
public BufferedReader metron_f3853_0() throws IOException
{    return rawLocation.openReader(loc);}
public String metron_f3854_0()
{    return loc;}
public static void metron_f3855_0(List<String> inputs, final Consumer<Location> importConsumer, final FileSystem fs) throws IOException
{    Stack<Location> stack = new Stack<>();    for (String input : inputs) {        Location loc = LocationStrategy.getLocation(input, fs);        if (loc.exists()) {            stack.add(loc);        }    }    while (!stack.empty()) {        Location loc = stack.pop();        if (loc.isDirectory()) {            for (Location child : loc.getChildren().orElse(Collections.emptyList())) {                stack.push(child);            }        } else {            importConsumer.accept(loc);        }    }}
public static Optional<RawLocation<?>> metron_f3856_0(String loc, FileSystem fs)
{    for (LocationStrategy strategy : values()) {        RawLocation<?> location = strategy.locationCreator.apply(fs);        if (location.match(loc)) {            return Optional.of(location);        }    }    return Optional.empty();}
public static Location metron_f3857_0(String loc, FileSystem fs)
{    Optional<RawLocation<?>> rawLoc = getRawLocation(loc, fs);    if (rawLoc.isPresent()) {        return new Location(loc, rawLoc.get());    } else {        throw new IllegalStateException("Unsupported type: " + loc);    }}
 void metron_f3858_0(T state)
{}
 BufferedReader metron_f3859_0(String loc) throws IOException
{    InputStream is = openInputStream(loc);    if (loc.endsWith(".gz")) {        return new BufferedReader(new InputStreamReader(new GZIPInputStream(is), StandardCharsets.UTF_8));    } else if (loc.endsWith(".zip")) {        ZipInputStream zis = new ZipInputStream(is);        ZipEntry entry = zis.getNextEntry();        if (entry != null) {            return new BufferedReader(new InputStreamReader(zis, StandardCharsets.UTF_8));        } else {            return new BufferedReader(new InputStreamReader(new ByteArrayInputStream(new byte[] {}), StandardCharsets.UTF_8));        }    } else {        return new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));    }}
public Optional<List<String>> metron_f3860_0(String loc) throws IOException
{    return Optional.of(Collections.emptyList());}
public boolean metron_f3861_0(String loc) throws IOException
{    return true;}
public boolean metron_f3862_0(String loc) throws IOException
{    return false;}
public InputStream metron_f3863_0(String loc) throws IOException
{    return new URL(loc).openConnection().getInputStream();}
public boolean metron_f3864_0(String loc)
{    try {        new URL(loc);        return true;    } catch (MalformedURLException e) {        return false;    }}
public static void metron_f3865_0(String... argv) throws Exception
{    Configuration hadoopConfig = HBaseConfiguration.create();    String[] otherArgs = new GenericOptionsParser(hadoopConfig, argv).getRemainingArgs();    main(hadoopConfig, otherArgs);}
public static void metron_f3866_0(Configuration hadoopConfig, String[] argv) throws Exception
{    CommandLine cli = LoadOptions.parse(new PosixParser(), argv);    EnumMap<LoadOptions, Optional<Object>> config = LoadOptions.createConfig(cli);    if (LoadOptions.LOG4J_PROPERTIES.has(cli)) {        PropertyConfigurator.configure(LoadOptions.LOG4J_PROPERTIES.get(cli));    }    ExtractorHandler handler = ExtractorHandler.load(FileUtils.readFileToString(new File(LoadOptions.EXTRACTOR_CONFIG.get(cli).trim())));    ImportStrategy strategy = (ImportStrategy) config.get(LoadOptions.IMPORT_MODE).get();    strategy.getImporter().importData(config, handler, hadoopConfig);    SensorEnrichmentUpdateConfig sensorEnrichmentUpdateConfig = null;    if (LoadOptions.ENRICHMENT_CONFIG.has(cli)) {        sensorEnrichmentUpdateConfig = JSONUtils.INSTANCE.load(new File(LoadOptions.ENRICHMENT_CONFIG.get(cli)), SensorEnrichmentUpdateConfig.class);    }    if (sensorEnrichmentUpdateConfig != null) {        sensorEnrichmentUpdateConfig.updateSensorConfigs();    }}
public static void metron_f3867_0(String... argv) throws Exception
{    Configuration hadoopConfig = HBaseConfiguration.create();    String[] otherArgs = new GenericOptionsParser(hadoopConfig, argv).getRemainingArgs();    main(hadoopConfig, otherArgs);}
public static void metron_f3868_0(Configuration hadoopConfig, String[] argv) throws Exception
{    CommandLine cli = SummarizeOptions.parse(new PosixParser(), argv);    EnumMap<SummarizeOptions, Optional<Object>> config = SummarizeOptions.createConfig(cli);    if (SummarizeOptions.LOG4J_PROPERTIES.has(cli)) {        PropertyConfigurator.configure(SummarizeOptions.LOG4J_PROPERTIES.get(cli));    }    ExtractorHandler handler = ExtractorHandler.load(FileUtils.readFileToString(new File(SummarizeOptions.EXTRACTOR_CONFIG.get(cli).trim())));    Summarizers strategy = (Summarizers) config.get(SummarizeOptions.IMPORT_MODE).get();    strategy.getSummarizer().importData(config, handler, hadoopConfig);}
public OptionHandler<SummarizeOptions> metron_f3869_0()
{    return handler;}
public Option metron_f3870_0()
{    return option;}
public boolean metron_f3871_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f3872_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public static CommandLine metron_f3873_0(CommandLineParser parser, String[] args)
{    return OptionHandler.parse("SimpleFlatFileSummarizer", parser, args, values(), HELP);}
public static EnumMap<SummarizeOptions, Optional<Object>> metron_f3874_0(CommandLine cli)
{    return OptionHandler.createConfig(cli, values(), SummarizeOptions.class);}
public Option metron_f3875_0(@Nullable String s)
{    Option o = new Option(s, "output_mode", true, "The output mode to use: " + Joiner.on(",").join(Writers.values()) + ".  Default: " + Writers.LOCAL);    o.setArgName("MODE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f3876_0(SummarizeOptions option, CommandLine cli)
{    String mode = option.get(cli);    return Optional.of(Writers.getStrategy(mode).orElse(Writers.LOCAL));}
public String metron_f3877_0()
{    return "om";}
public Option metron_f3878_0(@Nullable String s)
{    Option o = new Option(s, "output", true, "The output file to write");    o.setArgName("FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f3879_0(SummarizeOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli));}
public String metron_f3880_0()
{    return "o";}
public void metron_f3881_0(Optional<String> output, Configuration hadoopConfig)
{}
public void metron_f3882_0(Object obj, Optional<String> output, Configuration hadoopConfig) throws IOException
{    System.out.println(obj);}
public void metron_f3883_0(byte[] obj, Optional<String> output, Configuration hadoopConfig) throws IOException
{    System.out.println(SerDeUtils.fromBytes(obj, Object.class));}
public void metron_f3884_0(Optional<String> fileNameOptional, Configuration hadoopConfig) throws InvalidWriterOutput
{    if (!fileNameOptional.isPresent()) {        throw new InvalidWriterOutput("Filename is not present.");    }    String fileName = fileNameOptional.get();    if (StringUtils.isEmpty(fileName) || fileName.trim().equals(".") || fileName.trim().equals("..") || fileName.trim().endsWith("/")) {        throw new InvalidWriterOutput("Filename is empty or otherwise invalid.");    }}
public void metron_f3885_0(byte[] obj, Optional<String> output, Configuration hadoopConfig) throws IOException
{    FileSystem fs = FileSystem.get(hadoopConfig);    try (FSDataOutputStream stream = fs.create(new Path(output.get()))) {        IOUtils.write(obj, stream);        stream.flush();    }}
public void metron_f3886_0(Optional<String> fileNameOptional, Configuration hadoopConfig) throws InvalidWriterOutput
{    if (!fileNameOptional.isPresent()) {        throw new InvalidWriterOutput("Filename is not present.");    }    String fileName = fileNameOptional.get();    if (StringUtils.isEmpty(fileName) || fileName.trim().equals(".") || fileName.trim().equals("..") || fileName.trim().endsWith("/")) {        throw new InvalidWriterOutput("Filename is empty or otherwise invalid.");    }}
public void metron_f3887_0(byte[] obj, Optional<String> output, Configuration hadoopConfig) throws IOException
{    File outFile = new File(output.get());    if (!outFile.getParentFile().exists()) {        outFile.getParentFile().mkdirs();    }    try (FileOutputStream fs = new FileOutputStream(outFile)) {        IOUtils.write(obj, fs);        fs.flush();    }}
 void metron_f3888_0(Object obj, Optional<String> output, Configuration hadoopConfig) throws IOException
{    if (obj != null) {        write(SerDeUtils.toBytes(obj), output, hadoopConfig);    }}
public static Optional<Writers> metron_f3889_0(String strategyName)
{    if (strategyName == null) {        return Optional.empty();    }    for (Writers strategy : values()) {        if (strategy.name().equalsIgnoreCase(strategyName.trim())) {            return Optional.of(strategy);        }    }    return Optional.empty();}
public void metron_f3890_0(Optional<String> output, Configuration hadoopConf) throws InvalidWriterOutput
{    writer.validate(output, hadoopConf);}
public void metron_f3891_0(byte[] obj, Optional<String> output, Configuration hadoopConf) throws IOException
{    writer.write(obj, output, hadoopConf);}
public boolean metron_f3892_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f3893_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f3894_0(CommandLine cli, String defaultValue)
{    return cli.getOptionValue(shortCode, defaultValue);}
public static CommandLine metron_f3895_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static void metron_f3896_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("MaxmindDbEnrichmentLoader", getOptions());}
public static Options metron_f3897_0()
{    Options ret = new Options();    for (MaxmindDbEnrichmentLoader.GeoEnrichmentOptions o : MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public Option metron_f3898_0(@Nullable String s)
{    return new Option(s, "help", false, "Generate Help screen");}
public Option metron_f3899_0(@Nullable String s)
{    Option o = new Option(s, "asn_url", true, "GeoIP URL - " + ASN_URL_DEFAULT);    o.setArgName("ASN_URL");    o.setRequired(false);    return o;}
public Option metron_f3900_0(@Nullable String s)
{    Option o = new Option(s, "geo_url", true, "GeoIP URL - defaults to " + GEO_CITY_URL_DEFAULT);    o.setArgName("GEO_URL");    o.setRequired(false);    return o;}
public Option metron_f3901_0(@Nullable String s)
{    Option o = new Option(s, "remote_dir", true, "HDFS directory to land formatted GeoLite2 City file - defaults to /apps/metron/geo/<epoch millis>/");    o.setArgName("REMOTE_DIR");    o.setRequired(false);    return o;}
public Option metron_f3902_0(@Nullable String s)
{    Option o = new Option(s, "remote_asn_dir", true, "HDFS directory to land formatted GeoLite2 ASN file - defaults to /apps/metron/asn/<epoch millis>/");    o.setArgName("REMOTE_DIR");    o.setRequired(false);    return o;}
public Option metron_f3903_0(@Nullable String s)
{    Option o = new Option(s, "retries", true, "Number of GeoLite2 database download retries, after an initial failure.");    o.setArgName("RETRIES");    o.setRequired(false);    return o;}
public Option metron_f3904_0(@Nullable String s)
{    Option o = new Option(s, "tmp_dir", true, "Directory for landing the temporary GeoLite2 data - defaults to /tmp");    o.setArgName("TMP_DIR");    o.setRequired(false);    return o;}
public Option metron_f3905_0(@Nullable String s)
{    Option o = new Option(s, "zk_quorum", true, "Zookeeper Quorum URL (zk1:port,zk2:port,...)");    o.setArgName("ZK_QUORUM");    o.setRequired(true);    return o;}
protected void metron_f3906_0(CommandLine cli) throws IOException
{        System.out.println("Retrieving GeoLite2 archive");    String geo_url = GeoEnrichmentOptions.GEO_URL.get(cli, GEO_CITY_URL_DEFAULT);    String asn_url = GeoEnrichmentOptions.ASN_URL.get(cli, ASN_URL_DEFAULT);        String tmpDir = GeoEnrichmentOptions.TMP_DIR.get(cli, "/tmp") + "/";    int numRetries = Integer.parseInt(GeoEnrichmentOptions.RETRIES.get(cli, DEFAULT_RETRIES));    File localGeoFile = null;    File localAsnFile = null;    try {        localGeoFile = downloadGeoFile(geo_url, tmpDir, numRetries);        localAsnFile = downloadGeoFile(asn_url, tmpDir, numRetries);    } catch (IllegalStateException ies) {        System.err.println("Failed to download geo db file. Aborting");        System.exit(5);    }        localGeoFile.deleteOnExit();    localAsnFile.deleteOnExit();    System.out.println("GeoIP files downloaded successfully");        String zookeeper = GeoEnrichmentOptions.ZK_QUORUM.get(cli);    long millis = LocalDateTime.now().toInstant(ZoneOffset.UTC).toEpochMilli();    String hdfsGeoLoc = GeoEnrichmentOptions.REMOTE_GEO_DIR.get(cli, "/apps/metron/geo/" + millis);    System.out.println("Putting GeoLite City file into HDFS at: " + hdfsGeoLoc);        Path srcPath = new Path(localGeoFile.getAbsolutePath());    Path dstPath = new Path(hdfsGeoLoc);    putDbFile(srcPath, dstPath);    pushConfig(srcPath, dstPath, GeoLiteCityDatabase.GEO_HDFS_FILE, zookeeper);        String hdfsAsnLoc = GeoEnrichmentOptions.REMOTE_ASN_DIR.get(cli, "/apps/metron/asn/" + millis);    System.out.println("Putting ASN file into HDFS at: " + hdfsAsnLoc);        srcPath = new Path(localAsnFile.getAbsolutePath());    dstPath = new Path(hdfsAsnLoc);    putDbFile(srcPath, dstPath);    pushConfig(srcPath, dstPath, GeoLiteAsnDatabase.ASN_HDFS_FILE, zookeeper);    System.out.println("GeoLite2 file placement complete");    System.out.println("Successfully created and updated new GeoLite information");}
protected File metron_f3907_0(String urlStr, String tmpDir, int numRetries)
{    File localFile = null;    int attempts = 0;    boolean valid = false;    while (!valid && attempts <= numRetries) {        try {            URL url = new URL(urlStr);            localFile = new File(tmpDir + new File(url.getPath()).getName());            System.out.println("Downloading " + url.toString() + " to " + localFile.getAbsolutePath());            if (localFile.exists() && !localFile.delete()) {                System.err.println("File already exists locally and can't be deleted.  Please delete before continuing");                System.exit(3);            }            FileUtils.copyURLToFile(url, localFile, 5000, 10000);            if (!CompressionStrategies.GZIP.test(localFile)) {                throw new IOException("Invalid Gzip file");            } else {                valid = true;            }        } catch (MalformedURLException e) {            System.err.println("Malformed URL - aborting: " + e);            e.printStackTrace();            System.exit(4);        } catch (IOException e) {            System.err.println("Warning: Unable to copy remote GeoIP database to local file, attempt " + attempts + ": " + e);            e.printStackTrace();        }        attempts++;    }    if (!valid) {        System.err.println("Unable to copy remote GeoIP database to local file after " + attempts + " attempts");        throw new IllegalStateException("Unable to download geo enrichment database.");    }    return localFile;}
protected void metron_f3908_0(Path srcPath, Path dstPath, String configName, String zookeeper)
{    System.out.println("Beginning update of global configs");    try (CuratorFramework client = ConfigurationsUtils.getClient(zookeeper)) {        client.start();                        Map<String, Object> global = JSONUtils.INSTANCE.load(new ByteArrayInputStream(ConfigurationsUtils.readGlobalConfigBytesFromZookeeper(client)), JSONUtils.MAP_SUPPLIER);                global.put(configName, dstPath.toString() + "/" + srcPath.getName());        ConfigurationsUtils.writeGlobalConfigToZookeeper(global, client);    } catch (Exception e) {        System.err.println("Unable to load new GeoLite2 config for " + configName + " into HDFS: " + e);        e.printStackTrace();        System.exit(2);    }    System.out.println("Finished update of global configs");}
protected void metron_f3909_0(Path src, Path dst) throws IOException
{    Configuration conf = new Configuration();    FileSystem fileSystem = FileSystem.get(conf);    System.out.println("Putting: " + src + " onto HDFS at: " + dst);    fileSystem.mkdirs(dst);    fileSystem.copyFromLocalFile(true, true, src, dst);    System.out.println("Done putting GeoLite file into HDFS");}
public static void metron_f3910_0(String... argv) throws IOException
{    String[] otherArgs = new GenericOptionsParser(argv).getRemainingArgs();    CommandLine cli = GeoEnrichmentOptions.parse(new PosixParser(), otherArgs);    MaxmindDbEnrichmentLoader loader = new MaxmindDbEnrichmentLoader();    loader.loadGeoLiteDatabase(cli);}
public String metron_f3911_0()
{    return tableName;}
public String metron_f3912_0()
{    return columnFamily;}
public boolean metron_f3913_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    TableInfo tableInfo = (TableInfo) o;    if (getTableName() != null ? !getTableName().equals(tableInfo.getTableName()) : tableInfo.getTableName() != null)        return false;    return getColumnFamily() != null ? getColumnFamily().equals(tableInfo.getColumnFamily()) : tableInfo.getColumnFamily() == null;}
public int metron_f3914_0()
{    int result = getTableName() != null ? getTableName().hashCode() : 0;    result = 31 * result + (getColumnFamily() != null ? getColumnFamily().hashCode() : 0);    return result;}
public String metron_f3915_0()
{    return "TableInfo{" + "tableName='" + tableName + '\'' + ", columnFamily='" + columnFamily + '\'' + '}';}
public TaxiiConnectionConfig metron_f3916_0(List<String> indicatorTypes)
{    allowedIndicatorTypes = new HashSet(indicatorTypes);    return this;}
public TaxiiConnectionConfig metron_f3917_0(String table)
{    this.table = table;    return this;}
public TaxiiConnectionConfig metron_f3918_0(String cf)
{    this.columnFamily = cf;    return this;}
public TaxiiConnectionConfig metron_f3919_0(Date time)
{    this.beginTime = time;    return this;}
public TaxiiConnectionConfig metron_f3920_0(String subId)
{    this.subscriptionId = subId;    return this;}
public TaxiiConnectionConfig metron_f3921_0(String collection)
{    this.collection = collection;    return this;}
public TaxiiConnectionConfig metron_f3922_0(int port)
{    this.port = port;    return this;}
public TaxiiConnectionConfig metron_f3923_0(URL endpoint)
{    this.endpoint = endpoint;    return this;}
public TaxiiConnectionConfig metron_f3924_0(URL proxy)
{    this.proxy = proxy;    return this;}
public TaxiiConnectionConfig metron_f3925_0(String username)
{    this.username = username;    return this;}
public TaxiiConnectionConfig metron_f3926_0(String password)
{    this.password = password;    return this;}
public TaxiiConnectionConfig metron_f3927_0(ConnectionType type)
{    this.type = type;    return this;}
public void metron_f3928_0(String endpoint) throws MalformedURLException
{    this.endpoint = new URL(endpoint);}
public void metron_f3929_0(int port)
{    this.port = port;}
public void metron_f3930_0(String proxy) throws MalformedURLException
{    this.proxy = new URL(proxy);}
public void metron_f3931_0(String username)
{    this.username = username;}
public void metron_f3932_0(String password)
{    this.password = password;}
public void metron_f3933_0(ConnectionType type)
{    this.type = type;}
public void metron_f3934_0(String collection)
{    this.collection = collection;}
public void metron_f3935_0(String subscriptionId)
{    this.subscriptionId = subscriptionId;}
public void metron_f3936_0(String beginTime) throws ParseException
{    SimpleDateFormat sdf = (SimpleDateFormat) DateFormat.getDateInstance(DateFormat.MEDIUM);    this.beginTime = sdf.parse(beginTime);}
public String metron_f3937_0()
{    return table;}
public void metron_f3938_0(String table)
{    this.table = table;}
public String metron_f3939_0()
{    return columnFamily;}
public void metron_f3940_0(String columnFamily)
{    this.columnFamily = columnFamily;}
public Date metron_f3941_0()
{    return beginTime;}
public int metron_f3942_0()
{    return port;}
public URL metron_f3943_0()
{    return endpoint;}
public URL metron_f3944_0()
{    return proxy;}
public String metron_f3945_0()
{    return username;}
public String metron_f3946_0()
{    return password;}
public ConnectionType metron_f3947_0()
{    return type;}
public String metron_f3948_0()
{    return collection;}
public String metron_f3949_0()
{    return subscriptionId;}
public void metron_f3950_0(List<String> allowedIndicatorTypes)
{    withAllowedIndicatorTypes(allowedIndicatorTypes);}
public Set<String> metron_f3951_0()
{    return allowedIndicatorTypes;}
public static synchronized TaxiiConnectionConfig metron_f3952_0(InputStream is) throws IOException
{    TaxiiConnectionConfig ret = _mapper.readValue(is, TaxiiConnectionConfig.class);    return ret;}
public static synchronized TaxiiConnectionConfig metron_f3953_0(String s, Charset c) throws IOException
{    return load(new ByteArrayInputStream(s.getBytes(c)));}
public static synchronized TaxiiConnectionConfig metron_f3954_0(String s) throws IOException
{    return load(s, Charset.defaultCharset());}
public String metron_f3955_0()
{    return "TaxiiConnectionConfig{" + "endpoint=" + endpoint + ", port=" + port + ", proxy=" + proxy + ", username='" + username + '\'' + ", password=" + (password == null ? "null" : "'******'") + ", type=" + type + ", allowedIndicatorTypes=" + Joiner.on(',').join(allowedIndicatorTypes) + ", collection='" + collection + '\'' + ", subscriptionId='" + subscriptionId + '\'' + ", beginTime=" + beginTime + ", table=" + table + ":" + columnFamily + '}';}
protected TaxiiXmlFactory metron_f3956_0()
{    return new TaxiiXmlFactory();}
protected ObjectFactory metron_f3957_0()
{    return new ObjectFactory();}
protected synchronized Table metron_f3958_0(String table) throws IOException
{    Table ret = connectionCache.get(table);    if (ret == null) {        ret = createHTable(table);        connectionCache.put(table, ret);    }    return ret;}
protected synchronized Table metron_f3959_0(String tableInfo) throws IOException
{    return new HTableProvider().getTable(config, tableInfo);}
public void metron_f3960_1()
{    if (inProgress) {        return;    }    Date ts = new Date();        try {        inProgress = true;                String sessionID = MessageHelper.generateMessageId();        PollRequest request = messageFactory.get().createPollRequest().withMessageId(sessionID).withCollectionName(collection);        if (subscriptionId != null) {            request = request.withSubscriptionID(subscriptionId);        } else {            request = request.withPollParameters(messageFactory.get().createPollParametersType());        }        if (beginTime != null) {            Calendar gc = GregorianCalendar.getInstance();            gc.setTime(beginTime);            XMLGregorianCalendar gTime = null;            try {                gTime = DatatypeFactory.newInstance().newXMLGregorianCalendar((GregorianCalendar) gc).normalize();            } catch (DatatypeConfigurationException e) {                RuntimeErrors.ILLEGAL_STATE.throwRuntime("Unable to set the begin time due to", e);            }            gTime.setFractionalSecond(null);                        request.setExclusiveBeginTimestamp(gTime);        }        try {            PollResponse response = call(request, PollResponse.class);                        int numProcessed = 0;            long avgTimeMS = 0;            long timeStartedBlock = System.currentTimeMillis();            for (ContentBlock block : response.getContentBlocks()) {                AnyMixedContentType content = block.getContent();                for (Object o : content.getContent()) {                    numProcessed++;                    long timeS = System.currentTimeMillis();                    String xml = null;                    if (o instanceof Element) {                        Element element = (Element) o;                        xml = getStringFromDocument(element.getOwnerDocument());                        if (LOG.isDebugEnabled() && Math.random() < 0.01) {                                                    }                        for (LookupKV<EnrichmentKey, EnrichmentValue> kv : extractor.extract(xml)) {                            if (allowedIndicatorTypes.isEmpty() || allowedIndicatorTypes.contains(kv.getKey().type)) {                                kv.getValue().getMetadata().put("source_type", "taxii");                                kv.getValue().getMetadata().put("taxii_url", endpoint.toString());                                kv.getValue().getMetadata().put("taxii_collection", collection);                                Put p = converter.toPut(columnFamily, kv.getKey(), kv.getValue());                                Table table = getTable(hbaseTable);                                table.put(p);                                                            }                        }                    }                    avgTimeMS += System.currentTimeMillis() - timeS;                }                if ((numProcessed + 1) % 100 == 0) {                                        timeStartedBlock = System.currentTimeMillis();                    avgTimeMS = 0;                    numProcessed = 0;                }            }        } catch (Exception e) {                        throw new RuntimeException("Unable to make request", e);        }    } finally {        inProgress = false;        beginTime = ts;    }}
public String metron_f3961_0(Document doc)
{    try {        DOMSource domSource = new DOMSource(doc);        StringWriter writer = new StringWriter();        StreamResult result = new StreamResult(writer);        TransformerFactory tf = TransformerFactory.newInstance();        tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);        Transformer transformer = tf.newTransformer();        transformer.transform(domSource, result);        return writer.toString();    } catch (TransformerException ex) {        ex.printStackTrace();        return null;    }}
private RESPONSE_T metron_f3962_0(Object request, Class<RESPONSE_T> responseClazz) throws Exception
{    HttpClient taxiiClient = buildClient(proxy, username, password);    return call(taxiiClient, endpoint.toURI(), request, context, responseClazz);}
private void metron_f3963_1(TaxiiConnectionConfig config) throws Exception
{        if (context == null) {        context = createContext(config.getEndpoint(), config.getUsername(), config.getPassword(), config.getPort());    }    URL endpoint = config.getEndpoint();    if (config.getType() == ConnectionType.DISCOVER) {                endpoint = discoverPollingClient(config.getProxy(), endpoint, config.getUsername(), config.getPassword(), context, collection).pollEndpoint;        this.endpoint = endpoint;            }}
private static HttpClientContext metron_f3965_0(URL endpoint, String username, String password, int port)
{    HttpClientContext context = null;    HttpHost target = new HttpHost(endpoint.getHost(), port, endpoint.getProtocol());    if (username != null && password != null) {        CredentialsProvider credsProvider = new BasicCredentialsProvider();        credsProvider.setCredentials(new AuthScope(target.getHostName(), target.getPort()), new UsernamePasswordCredentials(username, password));                AuthCache authCache = new BasicAuthCache();        authCache.put(target, new BasicScheme());                context = HttpClientContext.create();        context.setCredentialsProvider(credsProvider);        context.setAuthCache(authCache);    } else {        context = null;    }    return context;}
public static RESPONSE_T metron_f3966_1(HttpClient taxiiClient, URI endpoint, REQUEST_T request, HttpClientContext context, Class<RESPONSE_T> responseClazz) throws JAXBException, IOException
{    Object responseObj = taxiiClient.callTaxiiService(endpoint, request, context);        try {        return responseClazz.cast(responseObj);    } catch (ClassCastException cce) {        TaxiiXml taxiiXml = xmlFactory.get().createTaxiiXml();        String resp = taxiiXml.marshalToString(responseObj, true);        String msg = "Didn't return the response we expected: " + responseObj.getClass() + " \n" + resp;                throw new RuntimeException(msg, cce);    }}
private static HttpClient metron_f3967_0(URL proxy, String username, String password) throws Exception
{        HttpClient client = new HttpClient();        HttpClientBuilder builder = HttpClientBuilder.create().useSystemProperties();        if (proxy != null) {        HttpHost proxyHost = new HttpHost(proxy.getHost(), proxy.getPort(), proxy.getProtocol());        builder.setProxy(proxyHost);    }        if (username != null ^ password != null) {        throw new Exception("'username' and 'password' arguments are required to appear together.");    }        SSLContextBuilder ssbldr = new SSLContextBuilder();    ssbldr.loadTrustMaterial(null, new TrustSelfSignedStrategy());    SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(ssbldr.build(), SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);    Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create().register("http", new PlainConnectionSocketFactory()).register("https", sslsf).build();    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(registry);        cm.setMaxTotal(20);        System.setProperty("jsse.enableSNIExtension", "false");    CloseableHttpClient httpClient = builder.setSSLSocketFactory(sslsf).setConnectionManager(cm).build();    client.setHttpclient(httpClient);    return client;}
public boolean metron_f3968_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f3969_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public static CommandLine metron_f3970_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (TaxiiOptions.HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static void metron_f3971_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("TaxiiLoader", getOptions());}
public static Options metron_f3972_0()
{    Options ret = new Options();    for (TaxiiOptions o : TaxiiOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public Option metron_f3973_0(@Nullable String s)
{    return new Option(s, "help", false, "Generate Help screen");}
public Option metron_f3974_0(@Nullable String s)
{    Option o = new Option(s, "extractor_config", true, "JSON Document describing the extractor for this input data source");    o.setArgName("JSON_FILE");    o.setRequired(true);    return o;}
public Option metron_f3975_0(@Nullable String s)
{    Option o = new Option(s, "taxii_connection_config", true, "The JSON config file to configure the connection");    o.setArgName("config_file");    o.setRequired(true);    return o;}
public Option metron_f3976_0(@Nullable String s)
{    Option o = new Option(s, "time_between_polls", true, "The time between polls (in ms)");    o.setArgName("MS");    o.setRequired(false);    return o;}
public Option metron_f3977_0(@Nullable String s)
{    Option o = new Option(s, "begin_time", true, "Start time to poll the Taxii server (all data from that point will be gathered in the first pull).");    o.setArgName(DATE_FORMAT.toPattern());    o.setRequired(false);    return o;}
public Option metron_f3978_0(@Nullable String s)
{    Option o = new Option(s, "log4j", true, "The log4j properties file to load");    o.setArgName("FILE");    o.setRequired(false);    return o;}
public Option metron_f3979_0(@Nullable String s)
{    Option o = new Option(s, "enrichment_config", true, "JSON Document describing the enrichment configuration details." + "  This is used to associate an enrichment type with a field type in zookeeper.");    o.setArgName("JSON_FILE");    o.setRequired(false);    return o;}
public static boolean metron_f3980_0(Extractor e)
{    if (e instanceof StixExtractor || (e instanceof ExtractorDecorator && ((ExtractorDecorator) e).getUnderlyingExtractor() instanceof StixExtractor)) {        return true;    } else {        return false;    }}
public static void metron_f3981_0(String... argv) throws Exception
{    Configuration conf = HBaseConfiguration.create();    String zkQuorum = conf.get(HConstants.ZOOKEEPER_QUORUM);    String[] otherArgs = new GenericOptionsParser(conf, argv).getRemainingArgs();    CommandLine cli = TaxiiOptions.parse(new PosixParser(), otherArgs);    if (TaxiiOptions.LOG4J_PROPERTIES.has(cli)) {        PropertyConfigurator.configure(TaxiiOptions.LOG4J_PROPERTIES.get(cli));    }    ExtractorHandler handler = ExtractorHandler.load(FileUtils.readFileToString(new File(TaxiiOptions.EXTRACTOR_CONFIG.get(cli))));    Extractor e = handler.getExtractor();    SensorEnrichmentUpdateConfig sensorEnrichmentUpdateConfig = null;    if (TaxiiOptions.ENRICHMENT_CONFIG.has(cli)) {        sensorEnrichmentUpdateConfig = JSONUtils.INSTANCE.load(new File(TaxiiOptions.ENRICHMENT_CONFIG.get(cli)), SensorEnrichmentUpdateConfig.class);        sensorEnrichmentUpdateConfig.updateSensorConfigs();    }    Timer timer = new Timer();    if (isStixExtractor(e)) {        Extractor extractor = e;        TaxiiConnectionConfig connectionConfig = TaxiiConnectionConfig.load(FileUtils.readFileToString(new File(TaxiiOptions.CONNECTION_CONFIG.get(cli))));        if (TaxiiOptions.BEGIN_TIME.has(cli)) {            Date d = DATE_FORMAT.parse(TaxiiOptions.BEGIN_TIME.get(cli));            connectionConfig.withBeginTime(d);        }        long timeBetween = DEFAULT_TIME_BETWEEN_POLLS;        if (TaxiiOptions.TIME_BETWEEN_POLLS.has(cli)) {            timeBetween = Long.parseLong(TaxiiOptions.TIME_BETWEEN_POLLS.get(cli));        }        timer.scheduleAtFixedRate(new TaxiiHandler(connectionConfig, extractor, conf), 0, timeBetween);    } else {        throw new IllegalStateException("Extractor must be a STIX Extractor");    }}
public static void metron_f3982_0() throws Exception
{    if (dataPath.isDirectory()) {        dataPath.delete();    }    if (!dataPath.mkdirs()) {        throw new RuntimeException("Couldn't create dataPath at: " + dataPath.getAbsolutePath());    }    dataPath.deleteOnExit();}
public void metron_f3983_0() throws Exception
{    Calendar today = Calendar.getInstance();    today.clear(Calendar.HOUR);    today.clear(Calendar.MINUTE);    today.clear(Calendar.SECOND);    todaysDate = today.getTime();    yesterday.setTime(todaysDate.getTime() - TimeUnit.DAYS.toMillis(1));}
public void metron_f3984_0() throws Exception
{    HDFSDataPruner pruner = new HDFSDataPruner(todaysDate, 30, "file:///", dataPath.getAbsolutePath() + "/file-*");}
public void metron_f3985_0() throws Exception
{    createTestFiles();    HDFSDataPruner pruner = new HDFSDataPruner(yesterday, 30, "file:///", dataPath.getAbsolutePath() + "/file-*");    Long prunedCount = pruner.prune();    assertTrue("Should have pruned 45 files- pruned: " + prunedCount, 45 == prunedCount);    File[] filesLeft = dataPath.listFiles();    File[] filesList = new File[filesLeft.length];    for (int i = 0; i < 5; i++) {        filesList[i] = new File(dataPath.getPath() + "//file-" + String.format("%02d", i));    }    Arrays.sort(filesLeft);    assertArrayEquals("First four files should have been left behind", filesLeft, filesList);}
public void metron_f3986_0() throws Exception
{    FileSystem testFS = mock(FileSystem.class);    when(testFS.isDirectory(any())).thenThrow(new IOException("Test Exception"));    HDFSDataPruner pruner = new HDFSDataPruner(yesterday, 30, "file:///", dataPath.getAbsolutePath() + "/file-*");    pruner.fileSystem = testFS;    HDFSDataPruner.DateFileFilter filter = new HDFSDataPruner.DateFileFilter(pruner, true);    UnitTestHelper.setLog4jLevel(HDFSDataPruner.class, Level.FATAL);    try {        filter.accept(new Path("foo"));        Assert.fail("Expected Runtime exception, but did not receive one.");    } catch (RuntimeException e) {    }    UnitTestHelper.setLog4jLevel(HDFSDataPruner.class, Level.ERROR);}
public void metron_f3987_0() throws Exception
{    FileSystem testFS = mock(FileSystem.class);    when(testFS.isDirectory(any())).thenReturn(true);    HDFSDataPruner pruner = new HDFSDataPruner(yesterday, 30, "file:///", dataPath.getAbsolutePath() + "/file-*");    pruner.fileSystem = testFS;    HDFSDataPruner.DateFileFilter filter = new HDFSDataPruner.DateFileFilter(pruner, false);    assertFalse("Should ignore directories", filter.accept(new Path("/tmp")));}
public void metron_f3988_0() throws Exception
{    FileSystem testFS = mock(FileSystem.class);    when(testFS.isDirectory(any())).thenReturn(false);    when(testFS.getFileStatus(any())).thenThrow(new IOException("Test Exception"));    HDFSDataPruner pruner = new HDFSDataPruner(yesterday, 30, "file:///", dataPath.getAbsolutePath() + "/file-*");    pruner.fileSystem = testFS;    HDFSDataPruner.DateFileFilter filter = new HDFSDataPruner.DateFileFilter(pruner, true);    UnitTestHelper.setLog4jLevel(HDFSDataPruner.class, Level.FATAL);    try {        filter.accept(new Path("foo"));        Assert.fail("Expected Runtime exception, but did not receive one.");    } catch (RuntimeException e) {    }    UnitTestHelper.setLog4jLevel(HDFSDataPruner.class, Level.ERROR);}
private void metron_f3989_0() throws IOException
{        for (int i = 0; i < 50; i++) {        File file = new File(dataPath.getAbsolutePath() + "//file-" + String.format("%02d", i));        file.createNewFile();        file.deleteOnExit();    }        for (int i = 5; i < 25; i++) {        File file = new File(dataPath.getAbsolutePath() + "//file-" + String.format("%02d", i));        file.setLastModified(todaysDate.getTime() - TimeUnit.DAYS.toMillis(1));        file.deleteOnExit();    }        for (int i = 25; i < 40; i++) {        File file = new File(dataPath.getAbsolutePath() + "//file-" + String.format("%02d", i));        file.setLastModified(todaysDate.getTime() - TimeUnit.DAYS.toMillis(10));        file.deleteOnExit();    }        for (int i = 40; i < 50; i++) {        File file = new File(dataPath.getAbsolutePath() + "//file-" + String.format("%02d", i));        file.setLastModified(todaysDate.getTime() - TimeUnit.DAYS.toMillis(20));        file.deleteOnExit();    }}
public void metron_f3990_0() throws Exception
{    CSVExtractor ex = new CSVExtractor();    ExtractorHandler handler = ExtractorHandler.load(testCSVConfig);    ex.initialize(handler.getConfig());    Assert.assertEquals(0, (int) ex.getColumnMap().get("host"));    Assert.assertEquals(2, (int) ex.getColumnMap().get("meta"));    Assert.assertEquals(0, ex.getTypeColumnIndex());    Assert.assertEquals(0, ex.getIndicatorColumn());    Assert.assertEquals("threat", ex.getType());    Assert.assertEquals(',', ex.getParser().getSeparator());}
public void metron_f3991_0() throws Exception
{    ExtractorHandler handler = ExtractorHandler.load(testCSVConfig);    validate(handler);}
public void metron_f3992_0(ExtractorHandler handler) throws IOException
{    {        LookupKV results = Iterables.getFirst(handler.getExtractor().extract("google.com,1.0,foo"), null);        EnrichmentKey key = (EnrichmentKey) results.getKey();        EnrichmentValue value = (EnrichmentValue) results.getValue();        Assert.assertEquals("google.com", key.indicator);        Assert.assertEquals("threat", key.type);        Assert.assertEquals("google.com", value.getMetadata().get("host"));        Assert.assertEquals("foo", value.getMetadata().get("meta"));        Assert.assertEquals(2, value.getMetadata().size());    }    {        Iterable<LookupKV> results = handler.getExtractor().extract("#google.com,1.0,foo");        Assert.assertEquals(0, Iterables.size(results));    }    {        Iterable<LookupKV> results = handler.getExtractor().extract("");        Assert.assertEquals(0, Iterables.size(results));    }    {        Iterable<LookupKV> results = handler.getExtractor().extract(" ");        Assert.assertEquals(0, Iterables.size(results));    }    {        Iterable<LookupKV> results = handler.getExtractor().extract(null);        Assert.assertEquals(0, Iterables.size(results));    }}
public void metron_f3993_0()
{    MockitoAnnotations.initMocks(this);}
public void metron_f3994_0()
{    ExtractorDecorator decorator = new ExtractorDecorator(extractor);    Assert.assertThat(decorator.decoratedExtractor, notNullValue());}
public void metron_f3995_0() throws IOException
{    ExtractorDecorator decorator = new ExtractorDecorator(extractor);    decorator.initialize(new HashMap());    decorator.extract("line");    verify(extractor).initialize(isA(Map.class));    verify(extractor).extract("line");}
public Iterable<LookupKV> metron_f3996_0(String line) throws IOException
{    EnrichmentKey key = new EnrichmentKey();    key.indicator = "dummy";    key.type = "type";    Map<String, Object> value = new HashMap<>();    value.put("indicator", "dummy");    return Arrays.asList(new LookupKV(key, new EnrichmentValue(value)));}
public void metron_f3997_0(Map<String, Object> config)
{}
public void metron_f3998_0() throws IllegalAccessException, InstantiationException, ClassNotFoundException, IOException, NoSuchMethodException, InvocationTargetException
{    Extractor extractor = Extractors.create(DummyExtractor.class.getName());    LookupKV results = Iterables.getFirst(extractor.extract(null), null);    EnrichmentKey key = (EnrichmentKey) results.getKey();    EnrichmentValue value = (EnrichmentValue) results.getValue();    Assert.assertEquals("dummy", key.indicator);    Assert.assertEquals("type", key.type);    Assert.assertEquals("dummy", value.getMetadata().get("indicator"));}
public void metron_f3999_0() throws Exception
{    /**     *         config:     *         {     *            "config" : {}     *            ,"extractor" : "org.apache.metron.dataloads.extractor.ExtractorTest$DummyExtractor"     *         }     */    String config = "{\n" + "            \"config\" : {}\n" + "            ,\"extractor\" : \"org.apache.metron.dataloads.extractor.ExtractorTest$DummyExtractor\"\n" + "         }";    ExtractorHandler handler = ExtractorHandler.load(config);    LookupKV results = Iterables.getFirst(handler.getExtractor().extract(null), null);    EnrichmentKey key = (EnrichmentKey) results.getKey();    EnrichmentValue value = (EnrichmentValue) results.getValue();    Assert.assertEquals("dummy", key.indicator);    Assert.assertEquals("type", key.type);    Assert.assertEquals("dummy", value.getMetadata().get("indicator"));}
public void metron_f4000_0() throws IOException
{    stixDoc = Joiner.on("\n").join(IOUtils.readLines(new InputStreamReader(new FileInputStream(new File("src/test/resources/stix_example.xml")), StandardCharsets.UTF_8)));    stixDocWithoutCondition = Joiner.on("\n").join(IOUtils.readLines(new InputStreamReader(new FileInputStream(new File("src/test/resources/stix_example_wo_conditions.xml")), StandardCharsets.UTF_8)));}
public void metron_f4001_0() throws Exception
{    testStixAddresses(stixDoc);}
public void metron_f4002_0() throws Exception
{    testStixAddresses(stixDocWithoutCondition);}
public void metron_f4003_0(final String stixDoc) throws Exception
{    Thread t1 = new Thread(() -> {        try {            ExtractorHandler handler = ExtractorHandler.load(stixConfigOnlyIPV4);            Extractor extractor = handler.getExtractor();            Iterable<LookupKV> results = extractor.extract(stixDoc);            Assert.assertEquals(3, Iterables.size(results));            Assert.assertEquals("10.0.0.0", ((EnrichmentKey) (Iterables.get(results, 0).getKey())).indicator);            Assert.assertEquals("10.0.0.1", ((EnrichmentKey) (Iterables.get(results, 1).getKey())).indicator);            Assert.assertEquals("10.0.0.2", ((EnrichmentKey) (Iterables.get(results, 2).getKey())).indicator);        } catch (Exception ex) {            throw new RuntimeException(ex.getMessage(), ex);        }    });    Thread t2 = new Thread(() -> {        try {            ExtractorHandler handler = ExtractorHandler.load(stixConfig);            Extractor extractor = handler.getExtractor();            Iterable<LookupKV> results = extractor.extract(stixDoc);            Assert.assertEquals(3, Iterables.size(results));            Assert.assertEquals("10.0.0.0", ((EnrichmentKey) (Iterables.get(results, 0).getKey())).indicator);            Assert.assertEquals("10.0.0.1", ((EnrichmentKey) (Iterables.get(results, 1).getKey())).indicator);            Assert.assertEquals("10.0.0.2", ((EnrichmentKey) (Iterables.get(results, 2).getKey())).indicator);        } catch (Exception ex) {            throw new RuntimeException(ex.getMessage(), ex);        }    });    Thread t3 = new Thread(() -> {        try {            ExtractorHandler handler = ExtractorHandler.load(stixConfigOnlyIPV6);            Extractor extractor = handler.getExtractor();            Iterable<LookupKV> results = extractor.extract(stixDoc);            Assert.assertEquals(0, Iterables.size(results));        } catch (Exception ex) {            throw new RuntimeException(ex.getMessage(), ex);        }    });    t1.run();    t2.run();    t3.run();    t1.join();    t2.join();    t3.join();}
public void metron_f4004_0() throws Exception
{    StixExtractor extractor = new StixExtractor();    extractor.initialize(new HashMap<>());    Iterable<LookupKV> kvs = extractor.extract(uriHandlerObject);    Assert.assertEquals(1, Iterables.size(kvs));    LookupKV kv = Iterables.getFirst(kvs, null);    EnrichmentKey key = (EnrichmentKey) kv.getKey();    Assert.assertEquals("http://www.kotimi.com/alpha/gtex/", key.getIndicator());    Assert.assertEquals("uriobjecttype", key.type);}
public void metron_f4005_0() throws Exception
{    MockitoAnnotations.initMocks(this);    config1 = new ObjectMapper().readValue(config1Contents, LinkedHashMap.class);    decorator = new TransformFilterExtractorDecorator(extractor);    decorator.setZkClient(Optional.of(zkClient));    decorator.initialize(config1);}
public void metron_f4006_0() throws IOException
{    final String indicatorVal = "val2";    EnrichmentKey lookupKey = new EnrichmentKey("testenrichment", indicatorVal);    EnrichmentValue lookupValue = new EnrichmentValue(new HashMap<String, Object>() {        {            put("foo", "val1");            put("bar", indicatorVal);            put("baz", "val3");        }    });    LookupKV lkv = new LookupKV<>(lookupKey, lookupValue);    List<LookupKV> extractedLkvs = new ArrayList<>();    extractedLkvs.add(lkv);    Mockito.when(extractor.extract("val1,val2,val3")).thenReturn(extractedLkvs);    Iterable<LookupKV> extracted = decorator.extract("val1,val2,val3");    EnrichmentKey expectedLookupKey = new EnrichmentKey("testenrichment", "VAL2");    EnrichmentValue expectedLookupValue = new EnrichmentValue(new HashMap<String, Object>() {        {            put("foo", "VAL1");            put("bar", "val2");            put("baz", "val3");            put("newvar", "VAL1");            put("lowernewvar", "val1");        }    });    LookupKV expectedLkv = new LookupKV<>(expectedLookupKey, expectedLookupValue);    List<LookupKV> expectedLkvs = new ArrayList<>();    expectedLkvs.add(expectedLkv);    Assert.assertThat(extracted, CoreMatchers.equalTo(expectedLkvs));}
public void metron_f4007_0() throws Exception
{    final String indicatorVal = "val2";    EnrichmentKey lookupKey = new EnrichmentKey("testenrichment", indicatorVal);    EnrichmentValue lookupValue = new EnrichmentValue(new HashMap<String, Object>() {        {            put("foo", "val1");            put("bar", indicatorVal);            put("baz", "");        }    });    LookupKV lkv = new LookupKV<>(lookupKey, lookupValue);    List<LookupKV> extractedLkvs = new ArrayList<>();    extractedLkvs.add(lkv);    Mockito.when(extractor.extract("val1,val2,")).thenReturn(extractedLkvs);    Iterable<LookupKV> extracted = decorator.extract("val1,val2,");    Assert.assertThat(extracted, CoreMatchers.equalTo(new ArrayList<>()));}
public void metron_f4008_0() throws Exception
{    EnrichmentKey lookupKey = new EnrichmentKey("testenrichment", "");    EnrichmentValue lookupValue = new EnrichmentValue(new HashMap<String, Object>() {        {            put("foo", "val1");            put("bar", "");            put("baz", "val3");        }    });    LookupKV lkv = new LookupKV<>(lookupKey, lookupValue);    List<LookupKV> extractedLkvs = new ArrayList<>();    extractedLkvs.add(lkv);    Mockito.when(extractor.extract("val1,,val3")).thenReturn(extractedLkvs);    Iterable<LookupKV> extracted = decorator.extract("val1,,val3");    Assert.assertThat(extracted, CoreMatchers.equalTo(new ArrayList<>()));}
public void metron_f4009_0() throws Exception
{    final int badValue = 5;    exception.expect(ClassCastException.class);    config1.put(TransformFilterExtractorDecorator.ExtractorOptions.VALUE_TRANSFORM.toString(), badValue);    decorator = new TransformFilterExtractorDecorator(extractor);    decorator.setZkClient(Optional.of(zkClient));    decorator.initialize(config1);}
public void metron_f4010_0() throws Exception
{    final int badValue = 5;    exception.expect(ClassCastException.class);    config1.put(TransformFilterExtractorDecorator.ExtractorOptions.VALUE_FILTER.toString(), badValue);    decorator = new TransformFilterExtractorDecorator(extractor);    decorator.setZkClient(Optional.of(zkClient));    decorator.initialize(config1);}
public void metron_f4011_0() throws Exception
{    final int badValue = 5;    exception.expect(ClassCastException.class);    config1.put(TransformFilterExtractorDecorator.ExtractorOptions.INDICATOR_TRANSFORM.toString(), badValue);    decorator = new TransformFilterExtractorDecorator(extractor);    decorator.setZkClient(Optional.of(zkClient));    decorator.initialize(config1);}
public void metron_f4012_0() throws Exception
{    final int badValue = 5;    exception.expect(ClassCastException.class);    config1.put(TransformFilterExtractorDecorator.ExtractorOptions.INDICATOR_FILTER.toString(), badValue);    decorator = new TransformFilterExtractorDecorator(extractor);    decorator.setZkClient(Optional.of(zkClient));    decorator.initialize(config1);}
public void metron_f4013_0()
{    byte[] raw = key.toBytes();    Assert.assertArrayEquals(raw, keyBytes);}
public void metron_f4014_0()
{    byte[] serialized = key.toBytes();    EnrichmentKey deserialized = new EnrichmentKey();    deserialized.fromBytes(serialized);    Assert.assertEquals(key, deserialized);}
public void metron_f4015_0() throws IOException
{    HbaseConverter<EnrichmentKey, EnrichmentValue> converter = new EnrichmentConverter();    Put put = converter.toPut("cf", key, value);    LookupKV<EnrichmentKey, EnrichmentValue> converted = converter.fromPut(put, "cf");    Assert.assertEquals(results, converted);}
public void metron_f4016_0() throws IOException
{    HbaseConverter<EnrichmentKey, EnrichmentValue> converter = new EnrichmentConverter();    Result r = converter.toResult("cf", key, value);    LookupKV<EnrichmentKey, EnrichmentValue> converted = converter.fromResult(r, "cf");    Assert.assertEquals(results, converted);}
public void metron_f4017_0() throws Exception
{    HbaseConverter<EnrichmentKey, EnrichmentValue> converter = new EnrichmentConverter();    Get get = converter.toGet("cf", key);    Assert.assertArrayEquals(key.toBytes(), get.getRow());}
public void metron_f4018_0() throws IOException, InterruptedException
{    final Map<ImmutableBytesWritable, Put> puts = new HashMap<>();    BulkLoadMapper mapper = new BulkLoadMapper() {        @Override        protected void write(ImmutableBytesWritable key, Put value, Context context) throws IOException, InterruptedException {            puts.put(key, value);        }    };    mapper.initialize(new Configuration() {        {            set(BulkLoadMapper.COLUMN_FAMILY_KEY, "cf");            set(BulkLoadMapper.CONFIG_KEY, extractorConfig);            set(BulkLoadMapper.LAST_SEEN_KEY, "0");            set(BulkLoadMapper.CONVERTER_KEY, EnrichmentConverter.class.getName());        }    });    {        mapper.map(null, new Text("#google.com,1,foo"), null);        Assert.assertTrue(puts.size() == 0);    }    {        mapper.map(null, new Text("google.com,1,foo"), null);        Assert.assertTrue(puts.size() == 1);        EnrichmentKey expectedKey = new EnrichmentKey() {            {                indicator = "google.com";                type = "threat";            }        };        EnrichmentConverter converter = new EnrichmentConverter();        Put put = puts.get(new ImmutableBytesWritable(expectedKey.toBytes()));        Assert.assertNotNull(puts);        LookupKV<EnrichmentKey, EnrichmentValue> results = converter.fromPut(put, "cf");        Assert.assertEquals(results.getKey().indicator, "google.com");        Assert.assertEquals(results.getValue().getMetadata().size(), 2);        Assert.assertEquals(results.getValue().getMetadata().get("meta"), "foo");        Assert.assertEquals(results.getValue().getMetadata().get("host"), "google.com");    }}
protected void metron_f4019_0(ImmutableBytesWritable key, Put value, Context context) throws IOException, InterruptedException
{    puts.put(key, value);}
public Map.Entry<HBaseTestingUtility, Configuration> metron_f4020_0(boolean startMRCluster) throws Exception
{    return create(startMRCluster, null);}
public Map.Entry<HBaseTestingUtility, Configuration> metron_f4021_0(boolean startMRCluster, Configuration extraConfig) throws Exception
{    Configuration config = HBaseConfiguration.create();    config.set("hbase.master.hostname", "localhost");    config.set("hbase.regionserver.hostname", "localhost");    if (null != extraConfig) {        for (Entry<String, String> entry : extraConfig) {            config.set(entry.getKey(), entry.getValue());        }    }    HBaseTestingUtility testUtil = new HBaseTestingUtility(config);    testUtil.startMiniCluster(1);    if (startMRCluster) {        testUtil.startMiniMapReduceCluster();    }    return new AbstractMap.SimpleEntry<>(testUtil, config);}
public void metron_f4022_0(String contents, Path filename, FileSystem fs) throws IOException
{    FSDataOutputStream os = fs.create(filename, true);    PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, StandardCharsets.UTF_8));    pw.print(contents);    pw.flush();    os.close();}
public String metron_f4023_0(FileSystem fs, Path filename) throws IOException
{    FSDataInputStream in = fs.open(filename);    BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));    List<String> contents = new ArrayList<>();    for (String line = null; (line = br.readLine()) != null; ) {        contents.add(line);    }    return Joiner.on('\n').join(contents);}
public void metron_f4024_0(HBaseTestingUtility testUtil) throws Exception
{    testUtil.shutdownMiniMapReduceCluster();    testUtil.shutdownMiniCluster();    testUtil.cleanupTestDir();}
public static void metron_f4025_0() throws Exception
{    UnitTestHelper.setJavaLoggingLevel(Level.SEVERE);    Map.Entry<HBaseTestingUtility, Configuration> kv = HBaseUtil.INSTANCE.create(true);    config = kv.getValue();    testUtil = kv.getKey();    testTable = testUtil.createTable(Bytes.toBytes(tableName), Bytes.toBytes(cf));    atTable = testUtil.createTable(Bytes.toBytes(atTableName), Bytes.toBytes(atCF));}
public static void metron_f4026_0() throws Exception
{    HBaseUtil.INSTANCE.teardown(testUtil);}
public List<LookupKey> metron_f4027_0(int start, int end)
{    List<LookupKey> keys = new ArrayList<>();    for (int i = start; i < end; ++i) {        keys.add(new EnrichmentKey("type", "key-" + i));    }    return keys;}
public void metron_f4028_0() throws Exception
{    Configuration conf = HBaseConfiguration.create();    String[] argv = { "-a 04/14/2016 12:00:00", "-f cf", "-t malicious_domains", "-u access_trackers", "-v georgia", "-z cf" };    String[] otherArgs = new GenericOptionsParser(conf, argv).getRemainingArgs();    CommandLine cli = LeastRecentlyUsedPruner.BulkLoadOptions.parse(new PosixParser(), otherArgs);    Assert.assertEquals(cf, LeastRecentlyUsedPruner.BulkLoadOptions.COLUMN_FAMILY.get(cli).trim());    Assert.assertEquals(tableName, LeastRecentlyUsedPruner.BulkLoadOptions.TABLE.get(cli).trim());    Assert.assertEquals(atTableName, LeastRecentlyUsedPruner.BulkLoadOptions.ACCESS_TABLE.get(cli).trim());    Assert.assertEquals(atCF, LeastRecentlyUsedPruner.BulkLoadOptions.ACCESS_COLUMN_FAMILY.get(cli).trim());    Assert.assertEquals(beginTime, LeastRecentlyUsedPruner.BulkLoadOptions.AS_OF_TIME.get(cli).trim());    Assert.assertEquals(timeFormat, LeastRecentlyUsedPruner.BulkLoadOptions.AS_OF_TIME_FORMAT.get(cli).trim());}
public void metron_f4029_0() throws Exception
{    long ts = System.currentTimeMillis();    BloomAccessTracker bat = new BloomAccessTracker("tracker1", 100, 0.03);    PersistentAccessTracker pat = new PersistentAccessTracker(tableName, "0", atTable, atCF, bat, 0L);    EnrichmentLookup lookup = new EnrichmentLookup(testTable, cf, pat);    List<LookupKey> goodKeysHalf = getKeys(0, 5);    List<LookupKey> goodKeysOtherHalf = getKeys(5, 10);    Iterable<LookupKey> goodKeys = Iterables.concat(goodKeysHalf, goodKeysOtherHalf);    List<LookupKey> badKey = getKeys(10, 11);    EnrichmentConverter converter = new EnrichmentConverter();    for (LookupKey k : goodKeysHalf) {        testTable.put(converter.toPut(cf, (EnrichmentKey) k, new EnrichmentValue(new HashMap<String, Object>() {            {                put("k", "dummy");            }        })));        Assert.assertTrue(lookup.exists((EnrichmentKey) k, new EnrichmentLookup.HBaseContext(testTable, cf), true));    }    pat.persist(true);    for (LookupKey k : goodKeysOtherHalf) {        testTable.put(converter.toPut(cf, (EnrichmentKey) k, new EnrichmentValue(new HashMap<String, Object>() {            {                put("k", "dummy");            }        })));        Assert.assertTrue(lookup.exists((EnrichmentKey) k, new EnrichmentLookup.HBaseContext(testTable, cf), true));    }    testUtil.flush();    Assert.assertFalse(lookup.getAccessTracker().hasSeen(goodKeysHalf.get(0)));    for (LookupKey k : goodKeysOtherHalf) {        Assert.assertTrue(lookup.getAccessTracker().hasSeen(k));    }    pat.persist(true);    {        testTable.put(converter.toPut(cf, (EnrichmentKey) badKey.get(0), new EnrichmentValue(new HashMap<String, Object>() {            {                put("k", "dummy");            }        })));    }    testUtil.flush();    Assert.assertFalse(lookup.getAccessTracker().hasSeen(badKey.get(0)));    Job job = LeastRecentlyUsedPruner.createJob(config, tableName, cf, atTableName, atCF, ts);    Assert.assertTrue(job.waitForCompletion(true));    for (LookupKey k : goodKeys) {        Assert.assertTrue(lookup.exists((EnrichmentKey) k, new EnrichmentLookup.HBaseContext(testTable, cf), true));    }    for (LookupKey k : badKey) {        Assert.assertFalse(lookup.exists((EnrichmentKey) k, new EnrichmentLookup.HBaseContext(testTable, cf), true));    }}
public static void metron_f4030_0() throws Exception
{    UnitTestHelper.setJavaLoggingLevel(Level.SEVERE);    Map.Entry<HBaseTestingUtility, Configuration> kv = HBaseUtil.INSTANCE.create(true);    config = kv.getValue();    testUtil = kv.getKey();    testTable = testUtil.createTable(Bytes.toBytes(tableName), Bytes.toBytes(cf));    zookeeperUrl = getZookeeperUrl(config.get("hbase.zookeeper.quorum"), testUtil.getZkCluster().getClientPort());    setupGlobalConfig(zookeeperUrl);    for (Result r : testTable.getScanner(Bytes.toBytes(cf))) {        Delete d = new Delete(r.getRow());        testTable.delete(d);    }    if (lineByLineExtractorConfigFile.exists()) {        lineByLineExtractorConfigFile.delete();    }    Files.write(lineByLineExtractorConfigFile.toPath(), lineByLineExtractorConfig.getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE_NEW, StandardOpenOption.TRUNCATE_EXISTING);    if (wholeFileExtractorConfigFile.exists()) {        wholeFileExtractorConfigFile.delete();    }    Files.write(wholeFileExtractorConfigFile.toPath(), wholeFileExtractorConfig.getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE_NEW, StandardOpenOption.TRUNCATE_EXISTING);    if (stellarExtractorConfigFile.exists()) {        stellarExtractorConfigFile.delete();    }    Files.write(stellarExtractorConfigFile.toPath(), stellarExtractorConfig.replace("%ZK_QUORUM%", zookeeperUrl).getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE_NEW, StandardOpenOption.TRUNCATE_EXISTING);    if (customLineByLineExtractorConfigFile.exists()) {        customLineByLineExtractorConfigFile.delete();    }    Files.write(customLineByLineExtractorConfigFile.toPath(), customLineByLineExtractorConfig.replace("%EXTRACTOR_CLASS%", CSVExtractor.class.getName()).getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE_NEW, StandardOpenOption.TRUNCATE_EXISTING);    if (file1.exists()) {        file1.delete();    }    Files.write(file1.toPath(), "google1.com,1,foo2\n".getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE_NEW, StandardOpenOption.TRUNCATE_EXISTING);    if (file2.exists()) {        file2.delete();    }    Files.write(file2.toPath(), "google2.com,2,foo2\n".getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE_NEW, StandardOpenOption.TRUNCATE_EXISTING);    if (multilineFile.exists()) {        multilineFile.delete();    }    if (multilineGzFile.exists()) {        multilineGzFile.delete();    }    if (multilineGzFile.exists()) {        multilineZipFile.delete();    }    PrintWriter[] pws = new PrintWriter[] {};    try {        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(multilineZipFile));        ZipEntry entry = new ZipEntry("file");        zos.putNextEntry(entry);                pws = new PrintWriter[] { new PrintWriter(multilineFile, StandardCharsets.UTF_8.name()), new PrintWriter(new OutputStreamWriter(zos, StandardCharsets.UTF_8)), new PrintWriter(new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(multilineGzFile)), StandardCharsets.UTF_8)) };        for (int i = 0; i < NUM_LINES; ++i) {            for (PrintWriter pw : pws) {                pw.println("google" + i + ".com," + i + ",foo" + i);            }        }    } finally {        for (PrintWriter pw : pws) {            pw.close();        }    }}
private static String metron_f4031_0(String host, int port)
{    return host + ":" + port;}
private static void metron_f4032_0(String zookeeperUrl) throws Exception
{    client = ConfigurationsUtils.getClient(zookeeperUrl);    client.start();    ConfigurationsUtils.writeGlobalConfigToZookeeper(globalConfig.getBytes(StandardCharsets.UTF_8), zookeeperUrl);}
public static void metron_f4033_0() throws Exception
{    HBaseUtil.INSTANCE.teardown(testUtil);    file1.delete();    file2.delete();    multilineFile.delete();    multilineGzFile.delete();    multilineZipFile.delete();    lineByLineExtractorConfigFile.delete();    wholeFileExtractorConfigFile.delete();    stellarExtractorConfigFile.delete();    customLineByLineExtractorConfigFile.delete();}
public void metron_f4034_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e extractor.json", "-n enrichment_config.json", "-l log4j", "-i input.csv", "-p 2", "-b 128", "-q" };    String[] otherArgs = new GenericOptionsParser(config, argv).getRemainingArgs();    CommandLine cli = LoadOptions.parse(new PosixParser(), otherArgs);    Assert.assertEquals(extractorJson, LoadOptions.EXTRACTOR_CONFIG.get(cli).trim());    Assert.assertEquals(cf, LoadOptions.HBASE_CF.get(cli).trim());    Assert.assertEquals(tableName, LoadOptions.HBASE_TABLE.get(cli).trim());    Assert.assertEquals(enrichmentJson, LoadOptions.ENRICHMENT_CONFIG.get(cli).trim());    Assert.assertEquals(csvFile, LoadOptions.INPUT.get(cli).trim());    Assert.assertEquals(log4jProperty, LoadOptions.LOG4J_PROPERTIES.get(cli).trim());    Assert.assertEquals("2", LoadOptions.NUM_THREADS.get(cli).trim());    Assert.assertEquals("128", LoadOptions.BATCH_SIZE.get(cli).trim());}
public void metron_f4035_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e " + lineByLineExtractorConfigFile.getPath(), "-i " + multilineFile.getPath(), "-p 2", "-b 128", "-q" };    SimpleEnrichmentFlatFileLoader.main(config, argv);    EnrichmentConverter converter = new EnrichmentConverter();    ResultScanner scanner = testTable.getScanner(Bytes.toBytes(cf));    List<LookupKV<EnrichmentKey, EnrichmentValue>> results = new ArrayList<>();    for (Result r : scanner) {        results.add(converter.fromResult(r, cf));        testTable.delete(new Delete(r.getRow()));    }    Assert.assertEquals(NUM_LINES, results.size());    Assert.assertTrue(results.get(0).getKey().indicator.startsWith("google"));    Assert.assertEquals(results.get(0).getKey().type, "enrichment");    Assert.assertEquals(results.get(0).getValue().getMetadata().size(), 2);    Assert.assertTrue(results.get(0).getValue().getMetadata().get("meta").toString().startsWith("foo"));    Assert.assertTrue(results.get(0).getValue().getMetadata().get("host").toString().startsWith("google"));}
public void metron_f4036_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e " + lineByLineExtractorConfigFile.getPath(), "-i " + multilineGzFile.getPath(), "-p 2", "-b 128", "-q" };    SimpleEnrichmentFlatFileLoader.main(config, argv);    EnrichmentConverter converter = new EnrichmentConverter();    ResultScanner scanner = testTable.getScanner(Bytes.toBytes(cf));    List<LookupKV<EnrichmentKey, EnrichmentValue>> results = new ArrayList<>();    for (Result r : scanner) {        results.add(converter.fromResult(r, cf));        testTable.delete(new Delete(r.getRow()));    }    Assert.assertEquals(NUM_LINES, results.size());    Assert.assertTrue(results.get(0).getKey().indicator.startsWith("google"));    Assert.assertEquals(results.get(0).getKey().type, "enrichment");    Assert.assertEquals(results.get(0).getValue().getMetadata().size(), 2);    Assert.assertTrue(results.get(0).getValue().getMetadata().get("meta").toString().startsWith("foo"));    Assert.assertTrue(results.get(0).getValue().getMetadata().get("host").toString().startsWith("google"));}
public void metron_f4037_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e " + lineByLineExtractorConfigFile.getPath(), "-i " + multilineZipFile.getPath(), "-p 2", "-b 128", "-q" };    SimpleEnrichmentFlatFileLoader.main(config, argv);    EnrichmentConverter converter = new EnrichmentConverter();    ResultScanner scanner = testTable.getScanner(Bytes.toBytes(cf));    List<LookupKV<EnrichmentKey, EnrichmentValue>> results = new ArrayList<>();    for (Result r : scanner) {        results.add(converter.fromResult(r, cf));        testTable.delete(new Delete(r.getRow()));    }    Assert.assertEquals(NUM_LINES, results.size());    Assert.assertTrue(results.get(0).getKey().indicator.startsWith("google"));    Assert.assertEquals(results.get(0).getKey().type, "enrichment");    Assert.assertEquals(results.get(0).getValue().getMetadata().size(), 2);    Assert.assertTrue(results.get(0).getValue().getMetadata().get("meta").toString().startsWith("foo"));    Assert.assertTrue(results.get(0).getValue().getMetadata().get("host").toString().startsWith("google"));}
public void metron_f4038_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e " + wholeFileExtractorConfigFile.getPath(), "-i " + file1.getPath() + "," + file2.getPath(), "-p 2", "-b 128", "-q" };    SimpleEnrichmentFlatFileLoader.main(config, argv);    EnrichmentConverter converter = new EnrichmentConverter();    ResultScanner scanner = testTable.getScanner(Bytes.toBytes(cf));    List<LookupKV<EnrichmentKey, EnrichmentValue>> results = new ArrayList<>();    for (Result r : scanner) {        results.add(converter.fromResult(r, cf));        testTable.delete(new Delete(r.getRow()));    }    Assert.assertEquals(2, results.size());    Assert.assertTrue(results.get(0).getKey().indicator.startsWith("google"));    Assert.assertEquals(results.get(0).getKey().type, "enrichment");    Assert.assertEquals(results.get(0).getValue().getMetadata().size(), 2);    Assert.assertTrue(results.get(0).getValue().getMetadata().get("meta").toString().startsWith("foo"));    Assert.assertTrue(results.get(0).getValue().getMetadata().get("host").toString().startsWith("google"));}
public void metron_f4039_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e " + lineByLineExtractorConfigFile.getPath(), "-i " + multilineFile.getName(), "-m MR", "-p 2", "-b 128", "-q" };    FileSystem fs = FileSystem.get(config);    HBaseUtil.INSTANCE.writeFile(new String(Files.readAllBytes(multilineFile.toPath()), StandardCharsets.UTF_8), new Path(multilineFile.getName()), fs);    SimpleEnrichmentFlatFileLoader.main(config, argv);    EnrichmentConverter converter = new EnrichmentConverter();    ResultScanner scanner = testTable.getScanner(Bytes.toBytes(cf));    List<LookupKV<EnrichmentKey, EnrichmentValue>> results = new ArrayList<>();    for (Result r : scanner) {        results.add(converter.fromResult(r, cf));        testTable.delete(new Delete(r.getRow()));    }    Assert.assertEquals(NUM_LINES, results.size());    Assert.assertTrue(results.get(0).getKey().indicator.startsWith("google"));    Assert.assertEquals(results.get(0).getKey().type, "enrichment");    Assert.assertEquals(results.get(0).getValue().getMetadata().size(), 2);    Assert.assertTrue(results.get(0).getValue().getMetadata().get("meta").toString().startsWith("foo"));    Assert.assertTrue(results.get(0).getValue().getMetadata().get("host").toString().startsWith("google"));}
public void metron_f4040_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e " + stellarExtractorConfigFile.getPath(), "-i " + multilineFile.getPath(), "-p 2", "-b 128", "-q" };    SimpleEnrichmentFlatFileLoader.main(config, argv);    EnrichmentConverter converter = new EnrichmentConverter();    ResultScanner scanner = testTable.getScanner(Bytes.toBytes(cf));    List<LookupKV<EnrichmentKey, EnrichmentValue>> results = new ArrayList<>();    for (Result r : scanner) {        results.add(converter.fromResult(r, cf));        testTable.delete(new Delete(r.getRow()));    }    Assert.assertEquals(NUM_LINES, results.size());    Assert.assertThat(results.get(0).getKey().getIndicator(), startsWith("GOOGLE"));    Assert.assertThat(results.get(0).getKey().type, equalTo("enrichment"));    Assert.assertThat(results.get(0).getValue().getMetadata().size(), equalTo(3));    Assert.assertThat(results.get(0).getValue().getMetadata().get("meta").toString(), startsWith("foo"));    Assert.assertThat(results.get(0).getValue().getMetadata().get("empty").toString(), startsWith("valfromglobalconfig"));    Assert.assertThat(results.get(0).getValue().getMetadata().get("host").toString(), startsWith("GOOGLE"));}
public void metron_f4041_0() throws Exception
{    String[] argv = { "-c cf", "-t enrichment", "-e " + customLineByLineExtractorConfigFile.getPath(), "-i " + multilineFile.getPath(), "-p 2", "-b 128", "-q" };    SimpleEnrichmentFlatFileLoader.main(config, argv);    EnrichmentConverter converter = new EnrichmentConverter();    ResultScanner scanner = testTable.getScanner(Bytes.toBytes(cf));    List<LookupKV<EnrichmentKey, EnrichmentValue>> results = new ArrayList<>();    for (Result r : scanner) {        results.add(converter.fromResult(r, cf));        testTable.delete(new Delete(r.getRow()));    }    Assert.assertEquals(NUM_LINES, results.size());    Assert.assertThat(results.get(0).getKey().getIndicator(), startsWith("GOOGLE"));    Assert.assertThat(results.get(0).getKey().type, equalTo("enrichment"));    Assert.assertThat(results.get(0).getValue().getMetadata().size(), equalTo(2));    Assert.assertThat(results.get(0).getValue().getMetadata().get("meta").toString(), startsWith("foo"));    Assert.assertThat(results.get(0).getValue().getMetadata().get("host").toString(), startsWith("GOOGLE"));}
public static String metron_f4042_0()
{    List<String> tmp = new ArrayList<>();    int i = 1;    for (String d : domains) {        tmp.add(i + "," + d);    }    return Joiner.on("\n").join(tmp);}
public void metron_f4043_0() throws Exception
{    String[] argv = { "-e extractor.json", "-o out.ser", "-l log4j", "-i input.csv", "-p 2", "-b 128", "-q" };    Configuration config = new Configuration();    String[] otherArgs = new GenericOptionsParser(config, argv).getRemainingArgs();    CommandLine cli = SummarizeOptions.parse(new PosixParser(), otherArgs);    Assert.assertEquals("extractor.json", SummarizeOptions.EXTRACTOR_CONFIG.get(cli).trim());    Assert.assertEquals("input.csv", SummarizeOptions.INPUT.get(cli).trim());    Assert.assertEquals("log4j", SummarizeOptions.LOG4J_PROPERTIES.get(cli).trim());    Assert.assertEquals("2", SummarizeOptions.NUM_THREADS.get(cli).trim());    Assert.assertEquals("128", SummarizeOptions.BATCH_SIZE.get(cli).trim());}
public Optional<List<String>> metron_f4044_0(String loc) throws IOException
{    if (loc.equals(".")) {        ArrayList<String> ret = new ArrayList<>(inMemoryData.keySet());        return Optional.of(ret);    }    return Optional.empty();}
public boolean metron_f4045_0(String loc)
{    return loc.equals(".") ? true : inMemoryData.containsKey(loc);}
public boolean metron_f4046_0(String loc) throws IOException
{    return loc.equals(".") ? true : false;}
public InputStream metron_f4047_0(String loc) throws IOException
{    return new ByteArrayInputStream(inMemoryData.get(loc).getBytes(StandardCharsets.UTF_8));}
public boolean metron_f4048_0(String loc)
{    return exists(loc);}
protected List<Location> metron_f4049_0(List<String> inputs, FileSystem fs) throws IOException
{    Set<Location> ret = new HashSet<>();    for (String input : inputs) {        if (input.equals(".")) {            for (String s : mockData.keySet()) {                ret.add(resolveLocation(s, fs));            }        } else {            ret.add(resolveLocation(input, fs));        }    }    return new ArrayList<>(ret);}
protected Location metron_f4050_0(String input, FileSystem fs)
{    return new Location(input, new InMemoryLocation(mockData));}
public void metron_f4051_0(Optional<String> output, Configuration hadoopConfig)
{}
public void metron_f4052_0(Object obj, Optional<String> output, Configuration hadoopConfig) throws IOException
{    ref.set(obj);}
public void metron_f4053_0(byte[] obj, Optional<String> output, Configuration hadoopConfig) throws IOException
{}
public void metron_f4054_0() throws IOException, InvalidWriterOutput
{    testLineByLine(5);    testLineByLine(1);}
public void metron_f4055_0(final int numThreads) throws IOException, InvalidWriterOutput
{    ExtractorHandler handler = ExtractorHandler.load(stellarExtractorConfigLineByLine);    LocalSummarizer summarizer = new MockSummarizer(ImmutableMap.of("input.csv", generateData()));    final AtomicReference<Object> finalObj = new AtomicReference<>(null);    EnumMap<SummarizeOptions, Optional<Object>> options = new EnumMap<SummarizeOptions, Optional<Object>>(SummarizeOptions.class) {        {            put(SummarizeOptions.INPUT, Optional.of("input.csv"));            put(SummarizeOptions.BATCH_SIZE, Optional.of(5));            put(SummarizeOptions.QUIET, Optional.of(true));            put(SummarizeOptions.OUTPUT_MODE, Optional.of(new PeekingWriter(finalObj)));            put(SummarizeOptions.OUTPUT, Optional.of("out"));            put(SummarizeOptions.NUM_THREADS, Optional.of(numThreads));        }    };    summarizer.importData(options, handler, new Configuration());    String expr = "MAP_GET(DOMAIN_REMOVE_TLD(domain), s) > 0";    for (String domain : domains) {        Boolean b = (Boolean) StellarProcessorUtils.run(expr, ImmutableMap.of("s", finalObj.get(), "domain", domain));        Assert.assertTrue("Can't find " + domain, b);    }}
public void metron_f4056_0() throws Exception
{    testWholeFile(5);    testWholeFile(1);}
public void metron_f4057_0(final int numThreads) throws IOException, InvalidWriterOutput
{    ExtractorHandler handler = ExtractorHandler.load(stellarExtractorConfigWholeFile);    LocalSummarizer summarizer = new MockSummarizer(new HashMap<String, String>() {        {            for (String domain : domains) {                put(domain, "1," + domain);            }        }    });    final AtomicReference<Object> finalObj = new AtomicReference<>(null);    EnumMap<SummarizeOptions, Optional<Object>> options = new EnumMap<SummarizeOptions, Optional<Object>>(SummarizeOptions.class) {        {            put(SummarizeOptions.INPUT, Optional.of("."));            put(SummarizeOptions.BATCH_SIZE, Optional.of(5));            put(SummarizeOptions.QUIET, Optional.of(true));            put(SummarizeOptions.OUTPUT_MODE, Optional.of(new PeekingWriter(finalObj)));            put(SummarizeOptions.OUTPUT, Optional.of("out"));            put(SummarizeOptions.NUM_THREADS, Optional.of(numThreads));        }    };    summarizer.importData(options, handler, new Configuration());    String expr = "MAP_GET(DOMAIN_REMOVE_TLD(domain), s) > 0";    for (String domain : domains) {        Boolean b = (Boolean) StellarProcessorUtils.run(expr, ImmutableMap.of("s", finalObj.get(), "domain", domain));        Assert.assertTrue("Can't find " + domain, b);    }}
protected void metron_f4058_0(Path srcPath, Path dstPath, String configName, String zookeeper)
{}
public void metron_f4059_0() throws Exception
{    testFolder.create();    remoteDir = testFolder.newFolder("remoteDir");    tmpDir = testFolder.newFolder("tmpDir");}
public void metron_f4060_0() throws Exception
{    String[] argv = { "-g testGeoUrl", "-a testAsnUrl", "-r /test/remoteDirGeo", "-ra", "/test/remoteDirAsn", "-t /test/tmpDir", "-z test:2181" };    String[] otherArgs = new GenericOptionsParser(argv).getRemainingArgs();    CommandLine cli = MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.parse(new PosixParser(), otherArgs);    Assert.assertEquals("testGeoUrl", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.GEO_URL.get(cli).trim());    Assert.assertEquals("testAsnUrl", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.ASN_URL.get(cli).trim());    Assert.assertEquals("/test/remoteDirGeo", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.REMOTE_GEO_DIR.get(cli).trim());    Assert.assertEquals("/test/remoteDirAsn", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.REMOTE_ASN_DIR.get(cli).trim());    Assert.assertEquals("/test/tmpDir", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.TMP_DIR.get(cli).trim());    Assert.assertEquals("test:2181", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.ZK_QUORUM.get(cli).trim());}
public void metron_f4061_0() throws Exception
{    String[] argv = { "--geo_url", "testGeoUrl", "--remote_dir", "/test/remoteDir", "-ra", "/test/remoteDir", "--tmp_dir", "/test/tmpDir", "--zk_quorum", "test:2181" };    String[] otherArgs = new GenericOptionsParser(argv).getRemainingArgs();    CommandLine cli = MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.parse(new PosixParser(), otherArgs);    Assert.assertEquals("testGeoUrl", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.GEO_URL.get(cli).trim());    Assert.assertEquals("/test/remoteDir", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.REMOTE_GEO_DIR.get(cli).trim());    Assert.assertEquals("/test/tmpDir", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.TMP_DIR.get(cli).trim());    Assert.assertEquals("test:2181", MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.ZK_QUORUM.get(cli).trim());}
public void metron_f4062_0() throws Exception
{    File dbPlainTextFile = new File(remoteDir.getAbsolutePath() + "/MaxmindDbEnrichmentLoaderTest.mmdb");    TestUtils.write(dbPlainTextFile, "hello world");    File dbFile = new File(remoteDir.getAbsolutePath() + "/MaxmindDbEnrichmentLoaderTest.mmdb.gz");    CompressionStrategies.GZIP.compress(dbPlainTextFile, dbFile);    String[] argv = { "--geo_url", "file://" + dbFile.getAbsolutePath(), "--remote_dir", remoteDir.getAbsolutePath(), "--remote_asn_dir", remoteDir.getAbsolutePath(), "--tmp_dir", tmpDir.getAbsolutePath(), "--zk_quorum", "test:2181" };    String[] otherArgs = new GenericOptionsParser(argv).getRemainingArgs();    CommandLine cli = MaxmindDbEnrichmentLoader.GeoEnrichmentOptions.parse(new PosixParser(), otherArgs);    MaxmindDbEnrichmentLoader loader = new MockMaxmindDbEnrichmentLoader();    loader.loadGeoLiteDatabase(cli);    Configuration config = new Configuration();    FileSystem fs = FileSystem.get(config);    assertTrue(fs.exists(new Path(remoteDir + "/" + dbFile.getName())));}
public void metron_f4063_0() throws Exception
{    File dbFile = new File(remoteDir.getAbsolutePath() + "/MaxmindDbEnrichmentLoaderTest.mmdb");    dbFile.createNewFile();    String geoUrl = "file://" + dbFile.getAbsolutePath();    int numRetries = 2;    exception.expect(IllegalStateException.class);    exception.expectMessage("Unable to download geo enrichment database.");    MaxmindDbEnrichmentLoader loader = new MockMaxmindDbEnrichmentLoader();    loader.downloadGeoFile(geoUrl, tmpDir.getAbsolutePath(), numRetries);}
public Response metron_f4064_0()
{    return Response.ok(discoveryMsg, MediaType.APPLICATION_XML_TYPE).header("x-taxii-content-type", "urn:taxii.mitre.org:message:xml:1.1").build();}
public Response metron_f4065_0()
{    return Response.ok(pollMsg).type(MediaType.APPLICATION_XML_TYPE).header("x-taxii-content-type", "urn:taxii.mitre.org:message:xml:1.1").build();}
public Set<Class<?>> metron_f4066_0()
{    return classes;}
public static void metron_f4067_0(int port) throws IOException
{        URI uri = UriBuilder.fromUri("http://localhost/").port(port).build();    server = HttpServer.create(new InetSocketAddress(uri.getPort()), 0);    HttpHandler handler = RuntimeDelegate.getInstance().createEndpoint(new ApplicationConfig(), HttpHandler.class);    server.createContext(uri.getPath(), handler);    discoveryMsg = discoveryMsg.replaceAll("PORT", "" + uri.getPort());    server.start();}
public static void metron_f4068_0()
{    if (server != null) {        server.stop(0);    }}
public static void metron_f4069_0() throws IOException
{    MockTaxiiService.start(8282);}
public static void metron_f4070_0()
{    MockTaxiiService.shutdown();    MockHBaseTableProvider.clear();}
public void metron_f4071_0() throws Exception
{    Configuration conf = HBaseConfiguration.create();    String[] argv = { "-c connection.json", "-e extractor.json", "-n enrichment_config.json", "-l log4j", "-p 10", "-b 04/14/2016 12:00:00" };    String[] otherArgs = new GenericOptionsParser(conf, argv).getRemainingArgs();    CommandLine cli = TaxiiLoader.TaxiiOptions.parse(new PosixParser(), otherArgs);    Assert.assertEquals(extractorJson, TaxiiLoader.TaxiiOptions.EXTRACTOR_CONFIG.get(cli).trim());    Assert.assertEquals(connectionConfig, TaxiiLoader.TaxiiOptions.CONNECTION_CONFIG.get(cli).trim());    Assert.assertEquals(beginTime, TaxiiLoader.TaxiiOptions.BEGIN_TIME.get(cli).trim());    Assert.assertEquals(enrichmentJson, TaxiiLoader.TaxiiOptions.ENRICHMENT_CONFIG.get(cli).trim());    Assert.assertEquals(timeInteval, TaxiiLoader.TaxiiOptions.TIME_BETWEEN_POLLS.get(cli).trim());    Assert.assertEquals(log4jProperty, TaxiiLoader.TaxiiOptions.LOG4J_PROPERTIES.get(cli).trim());}
public void metron_f4072_0() throws Exception
{    final MockHBaseTableProvider provider = new MockHBaseTableProvider();    final Configuration config = HBaseConfiguration.create();    Extractor extractor = new TransformFilterExtractorDecorator(new StixExtractor());    TaxiiHandler handler = new TaxiiHandler(TaxiiConnectionConfig.load(taxiiConnectionConfig), extractor, config) {        @Override        protected synchronized Table createHTable(String tableInfo) throws IOException {            return provider.addToCache("threat_intel", "cf");        }    };        handler.run();    Set<String> maliciousDomains;    {        MockHTable table = (MockHTable) provider.getTable(config, "threat_intel");        maliciousDomains = getIndicators("domainname:FQDN", table.getPutLog(), "cf");    }    Assert.assertTrue(maliciousDomains.contains("www.office-112.com"));    Assert.assertEquals(numStringsMatch(MockTaxiiService.pollMsg, "DomainNameObj:Value condition=\"Equals\""), maliciousDomains.size());    Set<String> maliciousAddresses;    {        MockHTable table = (MockHTable) provider.getTable(config, "threat_intel");        maliciousAddresses = getIndicators("address:IPV_4_ADDR", table.getPutLog(), "cf");    }    Assert.assertTrue(maliciousAddresses.contains("94.102.53.142"));    Assert.assertEquals(numStringsMatch(MockTaxiiService.pollMsg, "AddressObj:Address_Value condition=\"Equal\""), maliciousAddresses.size());    MockHBaseTableProvider.clear();        handler.run();}
protected synchronized Table metron_f4073_0(String tableInfo) throws IOException
{    return provider.addToCache("threat_intel", "cf");}
private static int metron_f4074_0(String xmlBundle, String text)
{    int cnt = 0;    for (String line : Splitter.on("\n").split(xmlBundle)) {        if (line.contains(text)) {            cnt++;        }    }    return cnt;}
private static Set<String> metron_f4075_0(String indicatorType, Iterable<Put> puts, String cf) throws IOException
{    EnrichmentConverter converter = new EnrichmentConverter();    Set<String> ret = new HashSet<>();    for (Put p : puts) {        LookupKV<EnrichmentKey, EnrichmentValue> kv = converter.fromPut(p, cf);        if (kv.getKey().type.equals(indicatorType)) {            ret.add(kv.getKey().indicator);        }    }    return ret;}
public void metron_f4076_0(WriteSuccess<D> success)
{    this.successes.add(success);}
public void metron_f4077_0(D success)
{    add(new WriteSuccess<D>(success));}
public void metron_f4078_0(List<D> successes)
{    for (D success : successes) {        addSuccess(success);    }}
public List<WriteSuccess<D>> metron_f4079_0()
{    return successes;}
public void metron_f4080_0(WriteFailure<D> failure)
{    this.failures.add(failure);}
public void metron_f4081_0(D document, Throwable cause, String message)
{    add(new WriteFailure(document, cause, message));}
public List<WriteFailure<D>> metron_f4082_0()
{    return failures;}
public int metron_f4085_0()
{    return documents.size();}
public ElasticsearchBulkDocumentWriter<D> metron_f4086_0(WriteRequest.RefreshPolicy refreshPolicy)
{    this.refreshPolicy = refreshPolicy;    return this;}
private void metron_f4088_0(BulkResponse bulkResponse, List<Indexable> documents, BulkDocumentWriterResults<D> results)
{    if (bulkResponse.hasFailures()) {                for (BulkItemResponse response : bulkResponse) {            if (response.isFailed()) {                                D failed = getDocument(response.getItemId());                Exception cause = response.getFailure().getCause();                String message = response.getFailureMessage();                results.addFailure(failed, cause, message);            } else {                                D success = getDocument(response.getItemId());                success.setDocumentID(response.getResponse().getId());                results.addSuccess(success);            }        }    } else {                for (Indexable success : documents) {            results.addSuccess(success.document);        }    }}
private D metron_f4089_0(int index)
{    return documents.get(index).document;}
public static void metron_f4090_0(String[] args)
{    if (args.length != 2) {        throw new RuntimeException("Expects 'input' and 'output' file arguments.");    }    final String inPath = args[0];    final String outPath = args[1];    try {        new ElasticsearchImportExport().bulkify(Paths.get(inPath), Paths.get(outPath));    } catch (IOException e) {        e.printStackTrace();        System.exit(1);    }    System.exit(0);}
public void metron_f4091_0(Path input, Path output) throws IOException
{    List<String> outRecs = new ArrayList<String>();    try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(input.toFile()), StandardCharsets.UTF_8))) {        String line;        while ((line = br.readLine()) != null) {            Map<String, Object> inDoc = JSONUtils.INSTANCE.load(line, JSONUtils.MAP_SUPPLIER);            Object id = inDoc.get("_id");            Object type = inDoc.get("_type");            String createRaw = String.format("{ \"create\" : { \"_id\": \"%s\", \"_type\": \"%s\" } }", id, type);            String outData = JSONUtils.INSTANCE.toJSON(inDoc.get("_source"), false);            outRecs.add(createRaw);            outRecs.add(outData);        }    }    try (BufferedWriter br = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(output.toFile()), StandardCharsets.UTF_8))) {        for (String line : outRecs) {            br.write(line);            br.write(System.lineSeparator());        }    }}
public D metron_f4092_0()
{    return document;}
public Throwable metron_f4093_0()
{    return cause;}
public String metron_f4094_0()
{    return message;}
public D metron_f4095_0()
{    return document;}
public RestClient metron_f4096_0()
{    return lowLevelClient;}
public RestHighLevelClient metron_f4097_0()
{    return highLevelClient;}
public void metron_f4098_0() throws IOException
{    if (lowLevelClient != null) {        lowLevelClient.close();    }}
public void metron_f4099_0(String index, String mappingType, String mapping) throws IOException
{    HttpEntity entity = new StringEntity(mapping);    Response response = lowLevelClient.performRequest("PUT", "/" + index + "/_mapping/" + mappingType, Collections.emptyMap(), entity);    if (response.getStatusLine().getStatusCode() != 200) {        String responseStr = IOUtils.toString(response.getEntity().getContent());        throw new IllegalStateException("Got a " + response.getStatusLine().getStatusCode() + " due to " + responseStr);    }}
public String[] metron_f4100_0() throws IOException
{    Response response = lowLevelClient.performRequest("GET", "/_cat/indices");    if (response.getStatusLine().getStatusCode() == 200) {        String responseStr = IOUtils.toString(response.getEntity().getContent());        List<String> indices = new ArrayList<>();        for (String line : Splitter.on("\n").split(responseStr)) {            Iterable<String> splits = Splitter.on(" ").split(line.replaceAll("\\s+", " ").trim());            if (Iterables.size(splits) > 3) {                String index = Iterables.get(splits, 2, "");                if (!StringUtils.isEmpty(index)) {                    indices.add(index.trim());                }            }        }        String[] ret = new String[indices.size()];        ret = indices.toArray(ret);        return ret;    }    return null;}
public Map<String, FieldMapping> metron_f4101_0(String[] indices) throws IOException
{    Map<String, FieldMapping> ret = new HashMap<>();    String indicesCsv = Joiner.on(",").join(indices);    Response response = lowLevelClient.performRequest("GET", "/" + indicesCsv + "/_mapping");    if (response.getStatusLine().getStatusCode() == 200) {        String responseStr = IOUtils.toString(response.getEntity().getContent());        Map<String, Object> indexToMapping = JSONUtils.INSTANCE.load(responseStr, JSONUtils.MAP_SUPPLIER);        for (Map.Entry<String, Object> index2Mapping : indexToMapping.entrySet()) {            String index = index2Mapping.getKey();            Map<String, Object> mappings = getInnerMap((Map<String, Object>) index2Mapping.getValue(), "mappings");            if (mappings.size() > 0) {                Map.Entry<String, Object> docMap = Iterables.getFirst(mappings.entrySet(), null);                if (docMap != null) {                    Map<String, Object> fieldPropertiesMap = getInnerMap((Map<String, Object>) docMap.getValue(), "properties");                    if (fieldPropertiesMap != null) {                        FieldMapping mapping = new FieldMapping();                        for (Map.Entry<String, Object> field2PropsKV : fieldPropertiesMap.entrySet()) {                            if (field2PropsKV.getValue() != null) {                                FieldProperties props = new FieldProperties((Map<String, Object>) field2PropsKV.getValue());                                mapping.put(field2PropsKV.getKey(), props);                            }                        }                        ret.put(index, mapping);                    }                }            }        }    }    return ret;}
private Map<String, Object> metron_f4102_0(Map<String, Object> outerMap, String... keys)
{    Map<String, Object> ret = outerMap;    if (keys.length == 0) {        return outerMap;    }    for (String key : keys) {        ret = (Map<String, Object>) ret.get(key);        if (ret == null) {            return ret;        }    }    return ret;}
public static ElasticsearchClient metron_f4103_0(Map<String, Object> globalConfig)
{    ElasticsearchClientConfig esClientConfig = new ElasticsearchClientConfig(getEsSettings(globalConfig));    HttpHost[] httpHosts = getHttpHosts(globalConfig, esClientConfig.getConnectionScheme());    RestClientBuilder builder = RestClient.builder(httpHosts);    builder.setRequestConfigCallback(reqConfigBuilder -> {                        reqConfigBuilder.setConnectTimeout(esClientConfig.getConnectTimeoutMillis());        reqConfigBuilder.setSocketTimeout(esClientConfig.getSocketTimeoutMillis());        return reqConfigBuilder;    });    builder.setMaxRetryTimeoutMillis(esClientConfig.getMaxRetryTimeoutMillis());    builder.setHttpClientConfigCallback(clientBuilder -> {        clientBuilder.setDefaultIOReactorConfig(getIOReactorConfig(esClientConfig));        clientBuilder.setDefaultCredentialsProvider(getCredentialsProvider(esClientConfig));        clientBuilder.setSSLContext(getSSLContext(esClientConfig));        return clientBuilder;    });    RestClient lowLevelClient = builder.build();    RestHighLevelClient client = new RestHighLevelClient(lowLevelClient);    return new ElasticsearchClient(lowLevelClient, client);}
private static Map<String, Object> metron_f4104_0(Map<String, Object> globalConfig)
{    return (Map<String, Object>) globalConfig.getOrDefault(ES_SETTINGS_KEY, new HashMap<>());}
private static HttpHost[] metron_f4105_0(Map<String, Object> globalConfiguration, String scheme)
{    List<HostnamePort> hps = ElasticsearchUtils.getIps(globalConfiguration);    HttpHost[] httpHosts = new HttpHost[hps.size()];    int i = 0;    for (HostnamePort hp : hps) {        httpHosts[i++] = new HttpHost(hp.hostname, hp.port, scheme);    }    return httpHosts;}
private static IOReactorConfig metron_f4106_1(ElasticsearchClientConfig esClientConfig)
{    if (esClientConfig.getNumClientConnectionThreads().isPresent()) {        Integer numThreads = esClientConfig.getNumClientConnectionThreads().get();                return IOReactorConfig.custom().setIoThreadCount(numThreads).build();    } else {        return IOReactorConfig.DEFAULT;    }}
private static CredentialsProvider metron_f4107_1(ElasticsearchClientConfig esClientConfig)
{    Optional<Entry<String, String>> credentials = esClientConfig.getCredentials();    if (credentials.isPresent()) {                final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();        UsernamePasswordCredentials upcredentials = new UsernamePasswordCredentials(credentials.get().getKey(), credentials.get().getValue());        credentialsProvider.setCredentials(AuthScope.ANY, upcredentials);        return credentialsProvider;    } else {                return null;    }}
private static SSLContext metron_f4108_1(ElasticsearchClientConfig esClientConfig)
{    if (esClientConfig.isSSLEnabled()) {                if (!esClientConfig.getKeyStorePath().isPresent()) {            throw new IllegalStateException("KeyStore path must be provided for SSL connection.");        }        Optional<String> optKeyStorePass = esClientConfig.getKeyStorePassword();        char[] keyStorePass = optKeyStorePass.map(String::toCharArray).orElse(null);        KeyStore trustStore = getStore(esClientConfig.getKeyStoreType(), esClientConfig.getKeyStorePath().get(), keyStorePass);        try {            SSLContextBuilder sslBuilder = SSLContexts.custom().loadTrustMaterial(trustStore, null);            return sslBuilder.build();        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {            throw new IllegalStateException("Unable to load truststore.", e);        }    }    return null;}
private static KeyStore metron_f4109_0(String type, Path path, char[] pass)
{    KeyStore store;    try {        store = KeyStore.getInstance(type);    } catch (KeyStoreException e) {        throw new IllegalStateException("Unable to get keystore type '" + type + "'", e);    }    try (InputStream is = Files.newInputStream(path)) {        store.load(is, pass);    } catch (IOException | NoSuchAlgorithmException | CertificateException e) {        throw new IllegalStateException("Unable to load keystore from path '" + path + "'", e);    }    return store;}
public Integer metron_f4110_0()
{    return ElasticsearchClientOptions.CONNECTION_TIMEOUT_MILLIS.getOrDefault(this, Integer.class, ONE_SECONDS_IN_MILLIS);}
public Integer metron_f4111_0()
{    return ElasticsearchClientOptions.SOCKET_TIMEOUT_MILLIS.getOrDefault(this, Integer.class, THIRTY_SECONDS_IN_MILLIS);}
public Integer metron_f4112_0()
{    return ElasticsearchClientOptions.MAX_RETRY_TIMEOUT_MILLIS.getOrDefault(this, Integer.class, THIRTY_SECONDS_IN_MILLIS);}
public Optional<Map.Entry<String, String>> metron_f4113_0()
{    if (ElasticsearchClientOptions.XPACK_PASSWORD_FILE.containsOption(this)) {        if (!ElasticsearchClientOptions.XPACK_USERNAME.containsOption(this) || StringUtils.isEmpty(ElasticsearchClientOptions.XPACK_USERNAME.get(this, String.class))) {            throw new IllegalArgumentException("X-pack username is required when password supplied and cannot be empty");        }        String user = ElasticsearchClientOptions.XPACK_USERNAME.get(this, String.class);        String password = getPasswordFromFile(ElasticsearchClientOptions.XPACK_PASSWORD_FILE.get(this, String.class));        if (user != null && password != null) {            return Optional.of(new AbstractMap.SimpleImmutableEntry<String, String>(user, password));        }    }    return Optional.empty();}
private static String metron_f4114_0(String hdfsPath)
{    List<String> lines = readLines(hdfsPath);    if (lines.size() == 0) {        throw new IllegalArgumentException(format("No password found in file '%s'", hdfsPath));    }    return lines.get(0);}
private static List<String> metron_f4115_0(String hdfsPath)
{    try {        return HDFSUtils.readFile(hdfsPath);    } catch (IOException e) {        throw new IllegalStateException(format("Unable to read XPack password file from HDFS location '%s'", hdfsPath), e);    }}
public boolean metron_f4116_0()
{    return ElasticsearchClientOptions.SSL_ENABLED.getOrDefault(this, Boolean.class, false);}
public String metron_f4117_0()
{    return isSSLEnabled() ? "https" : "http";}
public Optional<Integer> metron_f4118_0()
{    if (ElasticsearchClientOptions.NUM_CLIENT_CONNECTION_THREADS.containsOption(this)) {        return Optional.of(ElasticsearchClientOptions.NUM_CLIENT_CONNECTION_THREADS.get(this, Integer.class));    }    return Optional.empty();}
public String metron_f4119_0()
{    if (ElasticsearchClientOptions.KEYSTORE_TYPE.containsOption(this) && StringUtils.isNotEmpty(ElasticsearchClientOptions.KEYSTORE_TYPE.get(this, String.class))) {        return ElasticsearchClientOptions.KEYSTORE_TYPE.get(this, String.class);    }    return DEFAULT_KEYSTORE_TYPE;}
public Optional<String> metron_f4120_0()
{    if (ElasticsearchClientOptions.KEYSTORE_PASSWORD_FILE.containsOption(this)) {        String password = getPasswordFromFile(ElasticsearchClientOptions.KEYSTORE_PASSWORD_FILE.get(this, String.class));        if (StringUtils.isNotEmpty(password)) {            return Optional.of(password);        }    }    return Optional.empty();}
public Optional<Path> metron_f4121_0()
{    if (ElasticsearchClientOptions.KEYSTORE_PATH.containsOption(this)) {        return Optional.of(Paths.get(ElasticsearchClientOptions.KEYSTORE_PATH.get(this, String.class)));    }    return Optional.empty();}
public String metron_f4122_0()
{    return key;}
public static void metron_f4123_0()
{    String newLine = "";    for (ElasticsearchClientOptions opt : ElasticsearchClientOptions.values()) {        System.out.print(newLine);        System.out.print(opt.getKey());        newLine = System.lineSeparator();    }}
private FieldType metron_f4126_0(String type)
{    return elasticsearchTypeMap.getOrDefault(type, FieldType.OTHER);}
public AccessConfig metron_f4127_0()
{    return accessConfig;}
public void metron_f4128_0(AccessConfig accessConfig)
{    this.accessConfig = accessConfig;}
public synchronized void metron_f4129_0(AccessConfig config)
{    if (this.client == null) {        this.client = ElasticsearchClientFactory.create(config.getGlobalConfigSupplier().get());        this.accessConfig = config;        this.columnMetadataDao = new ElasticsearchColumnMetadataDao(this.client);        this.requestSubmitter = new ElasticsearchRequestSubmitter(this.client);        this.searchDao = new ElasticsearchSearchDao(client, accessConfig, columnMetadataDao, requestSubmitter);        this.retrieveLatestDao = new ElasticsearchRetrieveLatestDao(client);        this.updateDao = new ElasticsearchUpdateDao(client, accessConfig, retrieveLatestDao).withRefreshPolicy(refreshPolicy);    }    if (columnMetadataDao == null) {        throw new IllegalArgumentException("No ColumnMetadataDao available");    }    if (requestSubmitter == null) {        throw new IllegalArgumentException("No ElasticsearchRequestSubmitter available");    }}
public SearchResponse metron_f4130_0(SearchRequest searchRequest) throws InvalidSearchException
{    return this.searchDao.search(searchRequest);}
public GroupResponse metron_f4131_0(GroupRequest groupRequest) throws InvalidSearchException
{    return this.searchDao.group(groupRequest);}
public Document metron_f4132_0(final String guid, final String sensorType) throws IOException
{    return retrieveLatestDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f4133_0(final List<GetRequest> getRequests) throws IOException
{    return retrieveLatestDao.getAllLatest(getRequests);}
public Document metron_f4134_0(Document update, Optional<String> index) throws IOException
{    return updateDao.update(update, index);}
public Map<Document, Optional<String>> metron_f4135_0(Map<Document, Optional<String>> updates) throws IOException
{    return updateDao.batchUpdate(updates);}
public Document metron_f4136_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    return updateDao.patch(retrieveLatestDao, request, timestamp);}
public Document metron_f4137_0(CommentAddRemoveRequest request) throws IOException
{    return updateDao.addCommentToAlert(request);}
public Document metron_f4138_0(CommentAddRemoveRequest request) throws IOException
{    return updateDao.removeCommentFromAlert(request);}
public Map<String, FieldType> metron_f4139_0(List<String> indices) throws IOException
{    return this.columnMetadataDao.getColumnMetadata(indices);}
public Optional<Map<String, Object>> metron_f4140_0(GetRequest request) throws IOException
{    return retrieveLatestDao.getLatestResult(request);}
public Document metron_f4141_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return this.updateDao.addCommentToAlert(request, latest);}
public Document metron_f4142_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return this.updateDao.removeCommentFromAlert(request, latest);}
public ElasticsearchDao metron_f4143_0(WriteRequest.RefreshPolicy refreshPolicy)
{    this.refreshPolicy = refreshPolicy;    return this;}
protected Optional<String> metron_f4144_0(String guid, String sensorType) throws IOException
{    return updateDao.findIndexNameByGUID(guid, sensorType);}
protected SearchResponse metron_f4145_0(SearchRequest request, QueryBuilder queryBuilder) throws InvalidSearchException
{    return searchDao.search(request, queryBuilder);}
protected GroupResponse metron_f4146_0(GroupRequest groupRequest, QueryBuilder queryBuilder) throws InvalidSearchException
{    return searchDao.group(groupRequest, queryBuilder);}
public ElasticsearchClient metron_f4147_0()
{    return this.client;}
public void metron_f4148_0(IndexDao indexDao, Optional<String> threatSort)
{    if (indexDao instanceof MultiIndexDao) {        this.indexDao = indexDao;        MultiIndexDao multiIndexDao = (MultiIndexDao) indexDao;        for (IndexDao childDao : multiIndexDao.getIndices()) {            if (childDao instanceof ElasticsearchDao) {                this.elasticsearchDao = (ElasticsearchDao) childDao;            }        }    } else if (indexDao instanceof ElasticsearchDao) {        this.indexDao = indexDao;        this.elasticsearchDao = (ElasticsearchDao) indexDao;    } else {        throw new IllegalArgumentException("Need an ElasticsearchDao when using ElasticsearchMetaAlertDao");    }    if (threatSort.isPresent()) {        this.threatSort = threatSort.get();    }    Supplier<Map<String, Object>> globalConfigSupplier = () -> new HashMap<>();    if (elasticsearchDao != null && elasticsearchDao.getAccessConfig() != null) {        globalConfigSupplier = elasticsearchDao.getAccessConfig().getGlobalConfigSupplier();    }    MetaAlertConfig config = new MetaAlertConfig(metaAlertsIndex, this.threatSort, globalConfigSupplier) {        @Override        protected String getDefaultThreatTriageField() {            return THREAT_TRIAGE_FIELD;        }        @Override        protected String getDefaultSourceTypeField() {            return SOURCE_TYPE_FIELD;        }    };    this.metaAlertSearchDao = new ElasticsearchMetaAlertSearchDao(elasticsearchDao, config, pageSize);    this.metaAlertRetrieveLatestDao = new ElasticsearchMetaAlertRetrieveLatestDao(indexDao);    this.metaAlertUpdateDao = new ElasticsearchMetaAlertUpdateDao(elasticsearchDao, metaAlertRetrieveLatestDao, config, pageSize);}
protected String metron_f4149_0()
{    return THREAT_TRIAGE_FIELD;}
protected String metron_f4150_0()
{    return SOURCE_TYPE_FIELD;}
public void metron_f4151_0(AccessConfig config)
{}
public Map<String, FieldType> metron_f4152_0(List<String> indices) throws IOException
{    return indexDao.getColumnMetadata(indices);}
public Document metron_f4153_0(String guid, String sensorType) throws IOException
{    return indexDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f4154_0(List<GetRequest> getRequests) throws IOException
{    return indexDao.getAllLatest(getRequests);}
public SearchResponse metron_f4155_0(String guid) throws InvalidSearchException, IOException
{    return metaAlertSearchDao.getAllMetaAlertsForAlert(guid);}
public Document metron_f4156_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    return metaAlertUpdateDao.createMetaAlert(request);}
public Document metron_f4157_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.addAlertsToMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f4158_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.removeAlertsFromMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f4159_0(String metaAlertGuid, MetaAlertStatus status) throws IOException
{    return metaAlertUpdateDao.updateMetaAlertStatus(metaAlertGuid, status);}
public SearchResponse metron_f4160_0(SearchRequest searchRequest) throws InvalidSearchException
{    return metaAlertSearchDao.search(searchRequest);}
public GroupResponse metron_f4161_0(GroupRequest groupRequest) throws InvalidSearchException
{    return metaAlertSearchDao.group(groupRequest);}
public Document metron_f4162_0(Document update, Optional<String> index) throws IOException
{    return metaAlertUpdateDao.update(update, index);}
public Map<Document, Optional<String>> metron_f4163_0(Map<Document, Optional<String>> updates)
{    return metaAlertUpdateDao.batchUpdate(updates);}
public Document metron_f4164_0(CommentAddRemoveRequest request) throws IOException
{    return indexDao.addCommentToAlert(request);}
public Document metron_f4165_0(CommentAddRemoveRequest request) throws IOException
{    return indexDao.removeCommentFromAlert(request);}
public Document metron_f4166_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return indexDao.addCommentToAlert(request, latest);}
public Document metron_f4167_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return indexDao.removeCommentFromAlert(request, latest);}
public Document metron_f4168_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    return metaAlertUpdateDao.patch(retrieveLatestDao, request, timestamp);}
public void metron_f4169_0(int pageSize)
{    this.pageSize = pageSize;}
public Document metron_f4170_0(String guid, String sensorType) throws IOException
{    return retrieveLatestDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f4171_0(List<GetRequest> getRequests) throws IOException
{    return retrieveLatestDao.getAllLatest(getRequests);}
public SearchResponse metron_f4172_0(SearchRequest searchRequest) throws InvalidSearchException
{        QueryBuilder qb = constantScoreQuery(boolQuery().must(boolQuery().should(new QueryStringQueryBuilder(searchRequest.getQuery())).should(nestedQuery(MetaAlertConstants.ALERT_FIELD, new QueryStringQueryBuilder(searchRequest.getQuery()), ScoreMode.None))).must(boolQuery().should(termQuery(MetaAlertConstants.STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString())).should(boolQuery().mustNot(existsQuery(MetaAlertConstants.STATUS_FIELD)))).mustNot(existsQuery(MetaAlertConstants.METAALERT_FIELD)));    return elasticsearchDao.search(searchRequest, qb);}
public GroupResponse metron_f4173_0(GroupRequest groupRequest) throws InvalidSearchException
{        QueryBuilder qb = QueryBuilders.boolQuery().must(new QueryStringQueryBuilder(groupRequest.getQuery())).mustNot(existsQuery(MetaAlertConstants.METAALERT_FIELD));    return elasticsearchDao.group(groupRequest, qb);}
public SearchResponse metron_f4174_0(String guid) throws InvalidSearchException, IOException
{    if (guid == null || guid.trim().isEmpty()) {        throw new InvalidSearchException("Guid cannot be empty");    }        QueryBuilder qb = boolQuery().must(nestedQuery(MetaAlertConstants.ALERT_FIELD, boolQuery().must(termQuery(MetaAlertConstants.ALERT_FIELD + "." + GUID, guid)), ScoreMode.None).innerHit(new InnerHitBuilder())).must(termQuery(MetaAlertConstants.STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString()));    return queryAllResults(elasticsearchDao.getClient().getHighLevelClient(), qb, config.getMetaAlertIndex(), pageSize);}
public Document metron_f4175_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    List<GetRequest> alertRequests = request.getAlerts();    if (request.getAlerts().isEmpty()) {        throw new InvalidCreateException("MetaAlertCreateRequest must contain alerts");    }    if (request.getGroups().isEmpty()) {        throw new InvalidCreateException("MetaAlertCreateRequest must contain UI groups");    }        Iterable<Document> alerts = retrieveLatestDao.getAllLatest(alertRequests);    Document metaAlert = buildCreateDocument(alerts, request.getGroups(), MetaAlertConstants.ALERT_FIELD);    MetaScores.calculateMetaScores(metaAlert, getConfig().getThreatTriageField(), getConfig().getThreatSort());        metaAlert.getDocument().put(getConfig().getSourceTypeField(), MetaAlertConstants.METAALERT_TYPE);        Map<Document, Optional<String>> updates = new HashMap<>();    updates.put(metaAlert, Optional.of(getConfig().getMetaAlertIndex()));    try {                        Map<String, Optional<String>> guidToIndices = alertRequests.stream().collect(Collectors.toMap(GetRequest::getGuid, GetRequest::getIndex));        Map<String, String> guidToSensorTypes = alertRequests.stream().collect(Collectors.toMap(GetRequest::getGuid, GetRequest::getSensorType));        for (Document alert : alerts) {            if (addMetaAlertToAlert(metaAlert.getGuid(), alert)) {                                Optional<String> index = guidToIndices.get(alert.getGuid());                if (!index.isPresent()) {                                        index = elasticsearchDao.getIndexName(alert.getGuid(), guidToSensorTypes.get(alert.getGuid()));                    if (!index.isPresent()) {                        throw new IllegalArgumentException("Could not find index for " + alert.getGuid());                    }                }                updates.put(alert, index);            }        }                update(updates);        return metaAlert;    } catch (IOException ioe) {        throw new InvalidCreateException("Unable to create meta alert", ioe);    }}
public Document metron_f4176_0(Document update, Optional<String> index) throws IOException
{    if (MetaAlertConstants.METAALERT_TYPE.equals(update.getSensorType())) {                throw new UnsupportedOperationException("Meta alerts cannot be directly updated");    } else {        Map<Document, Optional<String>> updates = new HashMap<>();        updates.put(update, index);        try {                                    SearchResponse response = getMetaAlertsForAlert(update.getGuid());            Collection<Document> metaAlerts = response.getResults().stream().map(result -> toDocument(result, update.getTimestamp())).collect(Collectors.toList());                        for (Document metaAlert : metaAlerts) {                replaceAlertInMetaAlert(metaAlert, update);                updates.put(metaAlert, Optional.of(METAALERTS_INDEX));            }        } catch (IndexNotFoundException e) {            List<String> indicesNotFound = e.getMetadata(INDEX_NOT_FOUND_INDICES_KEY);                        if (indicesNotFound.size() != 1 || !METAALERTS_INDEX.equals(indicesNotFound.get(0))) {                throw e;            }        }                elasticsearchDao.batchUpdate(updates);        return update;    }}
private Document metron_f4177_0(SearchResult result, Long timestamp)
{    Document document = Document.fromJSON(result.getSource());    document.setTimestamp(timestamp);    document.setDocumentID(result.getId());    return document;}
public Document metron_f4178_0(CommentAddRemoveRequest request) throws IOException
{    return getUpdateDao().addCommentToAlert(request);}
public Document metron_f4179_0(CommentAddRemoveRequest request) throws IOException
{    return getUpdateDao().removeCommentFromAlert(request);}
public Document metron_f4180_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return getUpdateDao().addCommentToAlert(request, latest);}
public Document metron_f4181_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return getUpdateDao().removeCommentFromAlert(request, latest);}
protected SearchResponse metron_f4182_0(String alertGuid) throws IOException
{    QueryBuilder qb = boolQuery().must(nestedQuery(MetaAlertConstants.ALERT_FIELD, boolQuery().must(termQuery(MetaAlertConstants.ALERT_FIELD + "." + Constants.GUID, alertGuid)), ScoreMode.None).innerHit(new InnerHitBuilder())).must(termQuery(MetaAlertConstants.STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString()));    return ElasticsearchUtils.queryAllResults(elasticsearchDao.getClient().getHighLevelClient(), qb, getConfig().getMetaAlertIndex(), pageSize);}
protected void metron_f4183_0(Document metaAlert, Document alert)
{    boolean metaAlertUpdated = removeAlertsFromMetaAlert(metaAlert, Collections.singleton(alert.getGuid()));    if (metaAlertUpdated) {        addAlertsToMetaAlert(metaAlert, Collections.singleton(alert));    }}
public Document metron_f4186_0(String guid, String sensorType) throws IOException
{    Optional<Document> doc = searchByGuid(guid, sensorType, hit -> toDocument(hit));    return doc.orElse(null);}
public Iterable<Document> metron_f4187_0(List<GetRequest> getRequests) throws IOException
{    Collection<String> guids = new HashSet<>();    Collection<String> sensorTypes = new HashSet<>();    for (GetRequest getRequest : getRequests) {        guids.add(getRequest.getGuid());        sensorTypes.add(getRequest.getSensorType());    }    List<Document> documents = searchByGuids(guids, sensorTypes, hit -> toDocument(hit));    return documents;}
 Optional<T> metron_f4188_0(String guid, String sensorType, Function<SearchHit, Optional<T>> callback) throws IOException
{    Collection<String> sensorTypes = sensorType != null ? Collections.singleton(sensorType) : null;    List<T> results = searchByGuids(Collections.singleton(guid), sensorTypes, callback);    if (results.size() > 0) {        return Optional.of(results.get(0));    } else {        return Optional.empty();    }}
 List<T> metron_f4189_0(Collection<String> guids, Collection<String> sensorTypes, Function<SearchHit, Optional<T>> callback) throws IOException
{    if (guids == null || guids.isEmpty()) {        return Collections.emptyList();    }            BoolQueryBuilder guidQuery = boolQuery().must(termsQuery(Constants.GUID, guids));        BoolQueryBuilder sensorQuery = boolQuery();    sensorTypes.forEach(sensorType -> sensorQuery.should(typeQuery(sensorType + "_doc")));        BoolQueryBuilder query = boolQuery().must(guidQuery).must(sensorQuery);        SearchResponse response;    try {        SearchSourceBuilder source = new SearchSourceBuilder().query(query).size(guids.size());        SearchRequest request = new SearchRequest().source(source);        response = submitter.submitSearch(request);    } catch (InvalidSearchException e) {        throw new IOException(e);    }        List<T> results = new ArrayList<>();    for (SearchHit hit : response.getHits()) {        Optional<T> result = callback.apply(hit);        result.ifPresent(r -> results.add(r));    }    return results;}
private Optional<Document> metron_f4190_0(SearchHit hit)
{    Document document = Document.fromJSON(hit.getSource());    document.setDocumentID(hit.getId());    return Optional.of(document);}
public SearchResponse metron_f4191_0(SearchRequest searchRequest) throws InvalidSearchException
{    if (searchRequest.getQuery() == null) {        throw new InvalidSearchException("Search query is invalid: null");    }    return search(searchRequest, new QueryStringQueryBuilder(searchRequest.getQuery()));}
public GroupResponse metron_f4192_0(GroupRequest groupRequest) throws InvalidSearchException
{    return group(groupRequest, new QueryStringQueryBuilder(groupRequest.getQuery()));}
protected SearchResponse metron_f4193_0(SearchRequest request, QueryBuilder queryBuilder) throws InvalidSearchException
{    org.elasticsearch.action.search.SearchRequest esRequest;    org.elasticsearch.action.search.SearchResponse esResponse;    if (client == null) {        throw new InvalidSearchException("Uninitialized Dao!  You must call init() prior to use.");    }    if (request.getSize() > accessConfig.getMaxSearchResults()) {        throw new InvalidSearchException("Search result size must be less than " + accessConfig.getMaxSearchResults());    }    esRequest = buildSearchRequest(request, queryBuilder);    esResponse = requestSubmitter.submitSearch(esRequest);    return buildSearchResponse(request, esResponse);}
private org.elasticsearch.search.sort.SortOrder metron_f4196_0(org.apache.metron.indexing.dao.search.SortOrder sortOrder)
{    return sortOrder == org.apache.metron.indexing.dao.search.SortOrder.DESC ? org.elasticsearch.search.sort.SortOrder.DESC : org.elasticsearch.search.sort.SortOrder.ASC;}
private String metron_f4197_0(String field)
{    return String.format("%s_count", field);}
private String[] metron_f4198_0(List<String> indices)
{    if (indices == null)        return new String[] {};    return indices.stream().map(index -> String.format("%s%s*", index, INDEX_NAME_DELIMITER)).toArray(value -> new String[indices.size()]);}
private SearchResult metron_f4199_0(SearchHit searchHit, List<String> fields)
{    SearchResult searchResult = new SearchResult();    searchResult.setId(searchHit.getId());    Map<String, Object> source;    if (fields != null) {        Map<String, Object> resultSourceAsMap = searchHit.getSourceAsMap();        source = new HashMap<>();        fields.forEach(field -> {            source.put(field, resultSourceAsMap.get(field));        });    } else {        source = searchHit.getSource();    }    searchResult.setSource(source);    searchResult.setScore(searchHit.getScore());    searchResult.setIndex(searchHit.getIndex());    return searchResult;}
private Map<String, Map<String, Long>> metron_f4200_0(List<String> fields, Aggregations aggregations, Map<String, FieldType> commonColumnMetadata)
{    Map<String, Map<String, Long>> fieldCounts = new HashMap<>();    for (String field : fields) {        Map<String, Long> valueCounts = new HashMap<>();        if (aggregations != null) {            Aggregation aggregation = aggregations.get(getFacetAggregationName(field));            if (aggregation instanceof Terms) {                Terms terms = (Terms) aggregation;                terms.getBuckets().stream().forEach(bucket -> valueCounts.put(formatKey(bucket.getKey(), commonColumnMetadata.get(field)), bucket.getDocCount()));            }        }        fieldCounts.put(field, valueCounts);    }    return fieldCounts;}
private String metron_f4201_0(Object key, FieldType type)
{    if (FieldType.IP.equals(type) && key instanceof Long) {        return LegacyIpFieldMapper.longToIp((Long) key);    } else if (FieldType.BOOLEAN.equals(type)) {        return (Long) key == 1 ? "true" : "false";    } else {        return key.toString();    }}
protected GroupResponse metron_f4202_0(GroupRequest groupRequest, QueryBuilder queryBuilder) throws InvalidSearchException
{    org.elasticsearch.action.search.SearchRequest esRequest;    org.elasticsearch.action.search.SearchResponse esResponse;    if (client == null) {        throw new InvalidSearchException("Uninitialized Dao!  You must call init() prior to use.");    }    if (groupRequest.getGroups() == null || groupRequest.getGroups().size() == 0) {        throw new InvalidSearchException("At least 1 group must be provided.");    }    esRequest = buildGroupRequest(groupRequest, queryBuilder);    esResponse = requestSubmitter.submitSearch(esRequest);    GroupResponse response = buildGroupResponse(groupRequest, esResponse);    return response;}
private org.elasticsearch.action.search.SearchRequest metron_f4203_0(GroupRequest groupRequest, QueryBuilder queryBuilder)
{        TermsAggregationBuilder groups = getGroupsTermBuilder(groupRequest, 0);    final SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().query(queryBuilder).aggregation(groups);        String[] indices = wildcardIndices(groupRequest.getIndices());    return new org.elasticsearch.action.search.SearchRequest().indices(indices).source(searchSourceBuilder);}
private TermsAggregationBuilder metron_f4204_0(GroupRequest groupRequest, int index)
{    List<Group> groups = groupRequest.getGroups();    Group group = groups.get(index);    String aggregationName = getGroupByAggregationName(group.getField());    TermsAggregationBuilder termsBuilder = AggregationBuilders.terms(aggregationName);    termsBuilder.field(group.getField()).size(accessConfig.getMaxSearchGroups()).order(getElasticsearchGroupOrder(group.getOrder()));    if (index < groups.size() - 1) {        termsBuilder.subAggregation(getGroupsTermBuilder(groupRequest, index + 1));    }    Optional<String> scoreField = groupRequest.getScoreField();    if (scoreField.isPresent()) {        SumAggregationBuilder scoreSumAggregationBuilder = AggregationBuilders.sum(getSumAggregationName(scoreField.get())).field(scoreField.get()).missing(0);        termsBuilder.subAggregation(scoreSumAggregationBuilder);    }    return termsBuilder;}
private String metron_f4205_0(String field)
{    return String.format("%s_group", field);}
private String metron_f4206_0(String field)
{    return String.format("%s_score", field);}
private Order metron_f4207_0(GroupOrder groupOrder)
{    if (groupOrder.getGroupOrderType() == GroupOrderType.TERM) {        return groupOrder.getSortOrder() == SortOrder.ASC ? Order.term(true) : Order.term(false);    } else {        return groupOrder.getSortOrder() == SortOrder.ASC ? Order.count(true) : Order.count(false);    }}
private GroupResponse metron_f4208_0(GroupRequest groupRequest, org.elasticsearch.action.search.SearchResponse response) throws InvalidSearchException
{        Map<String, FieldType> commonColumnMetadata;    try {        commonColumnMetadata = columnMetadataDao.getColumnMetadata(groupRequest.getIndices());    } catch (IOException e) {        throw new InvalidSearchException(String.format("Could not get common column metadata for indices %s", Arrays.toString(groupRequest.getIndices().toArray())));    }    GroupResponse groupResponse = new GroupResponse();    groupResponse.setGroupedBy(groupRequest.getGroups().get(0).getField());    groupResponse.setGroupResults(getGroupResults(groupRequest, 0, response.getAggregations(), commonColumnMetadata));    return groupResponse;}
private List<GroupResult> metron_f4209_0(GroupRequest groupRequest, int index, Aggregations aggregations, Map<String, FieldType> commonColumnMetadata)
{    List<Group> groups = groupRequest.getGroups();    String field = groups.get(index).getField();    List<GroupResult> searchResultGroups = new ArrayList<>();    if (aggregations != null) {        Terms terms = aggregations.get(getGroupByAggregationName(field));        for (Bucket bucket : terms.getBuckets()) {            GroupResult groupResult = new GroupResult();            groupResult.setKey(formatKey(bucket.getKey(), commonColumnMetadata.get(field)));            groupResult.setTotal(bucket.getDocCount());            Optional<String> scoreField = groupRequest.getScoreField();            if (scoreField.isPresent()) {                Sum score = bucket.getAggregations().get(getSumAggregationName(scoreField.get()));                groupResult.setScore(score.getValue());            }            if (index < groups.size() - 1) {                groupResult.setGroupedBy(groups.get(index + 1).getField());                groupResult.setGroupResults(getGroupResults(groupRequest, index + 1, bucket.getAggregations(), commonColumnMetadata));            }            searchResultGroups.add(groupResult);        }    }    return searchResultGroups;}
public Document metron_f4210_0(Document update, Optional<String> index) throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<>();    updates.put(update, index);    Map<Document, Optional<String>> results = batchUpdate(updates);    return results.keySet().iterator().next();}
public Map<Document, Optional<String>> metron_f4211_1(Map<Document, Optional<String>> updates) throws IOException
{    Map<String, Object> globalConfig = accessConfig.getGlobalConfigSupplier().get();    String indexPostfix = ElasticsearchUtils.getIndexFormat(globalConfig).format(new Date());    for (Map.Entry<Document, Optional<String>> entry : updates.entrySet()) {        Document document = entry.getKey();        Optional<String> optionalIndex = entry.getValue();        String indexName = optionalIndex.orElse(getIndexName(document, indexPostfix));        documentWriter.addDocument(document, indexName);    }        BulkDocumentWriterResults<Document> results = documentWriter.write();    int failures = results.getFailures().size();    if (failures > 0) {        int successes = results.getSuccesses().size();        String msg = format("Failed to update all documents; %d successes, %d failures", successes, failures);                        for (WriteFailure<Document> failure : results.getFailures()) {                    }                Throwable cause = results.getFailures().get(0).getCause();        throw new IOException(msg, cause);    }    return updates;}
public Document metron_f4212_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = retrieveLatestDao.getLatest(request.getGuid(), request.getSensorType());    return addCommentToAlert(request, latest);}
public Document metron_f4213_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    if (latest == null || latest.getDocument() == null) {        throw new IOException(String.format("Unable to add comment. Document with guid %s cannot be found.", request.getGuid()));    }    List<Map<String, Object>> commentsField = (List<Map<String, Object>>) latest.getDocument().getOrDefault(COMMENTS_FIELD, new ArrayList<>());    List<Map<String, Object>> originalComments = new ArrayList<>(commentsField);    originalComments.add(new AlertComment(request.getComment(), request.getUsername(), request.getTimestamp()).asMap());    Document newVersion = new Document(latest);    newVersion.getDocument().put(COMMENTS_FIELD, originalComments);    return update(newVersion, Optional.empty());}
public Document metron_f4214_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = retrieveLatestDao.getLatest(request.getGuid(), request.getSensorType());    return removeCommentFromAlert(request, latest);}
public Document metron_f4215_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    if (latest == null || latest.getDocument() == null) {        throw new IOException(String.format("Unable to remove comment. Document with guid %s cannot be found.", request.getGuid()));    }    List<Map<String, Object>> commentMap = (List<Map<String, Object>>) latest.getDocument().get(COMMENTS_FIELD);        if (commentMap == null) {        throw new IOException(String.format("Unable to remove comment. Document with guid %s has no comments.", request.getGuid()));    }    List<Map<String, Object>> originalComments = new ArrayList<>(commentMap);    List<AlertComment> alertComments = new ArrayList<>();    for (Map<String, Object> commentRaw : originalComments) {        alertComments.add(new AlertComment(commentRaw));    }    alertComments.remove(new AlertComment(request.getComment(), request.getUsername(), request.getTimestamp()));    List<Map<String, Object>> commentsFinal = alertComments.stream().map(AlertComment::asMap).collect(Collectors.toList());    Document newVersion = new Document(latest);    if (commentsFinal.size() > 0) {        newVersion.getDocument().put(COMMENTS_FIELD, commentsFinal);        update(newVersion, Optional.empty());    } else {        newVersion.getDocument().remove(COMMENTS_FIELD);    }    return update(newVersion, Optional.empty());}
public ElasticsearchUpdateDao metron_f4216_0(WriteRequest.RefreshPolicy refreshPolicy)
{    documentWriter.withRefreshPolicy(refreshPolicy);    return this;}
protected String metron_f4217_0(Document update, String indexPostFix) throws IOException
{    return findIndexNameByGUID(update.getGuid(), update.getSensorType()).orElse(ElasticsearchUtils.getIndexName(update.getSensorType(), indexPostFix, null));}
protected Optional<String> metron_f4218_0(String guid, String sensorType) throws IOException
{    return retrieveLatestDao.searchByGuid(guid, sensorType, hit -> Optional.ofNullable(hit.getIndex()));}
public static SimpleDateFormat metron_f4219_0(Map<String, Object> globalConfig)
{    String format = (String) globalConfig.get("es.date.format");    return DATE_FORMAT_CACHE.get().computeIfAbsent(format, SimpleDateFormat::new);}
public static String metron_f4220_0(String sensorType, String indexPostfix, WriterConfiguration configurations)
{    String indexName = sensorType;    if (configurations != null) {        indexName = configurations.getIndex(sensorType);    }    indexName = indexName + INDEX_NAME_DELIMITER + "_" + indexPostfix;    return indexName;}
public static List<HostnamePort> metron_f4221_0(Map<String, Object> globalConfiguration)
{    Object ipObj = globalConfiguration.get("es.ip");    Object portObj = globalConfiguration.get("es.port");    if (ipObj == null) {        return Collections.emptyList();    }    if (ipObj instanceof String && ipObj.toString().contains(",") && ipObj.toString().contains(":")) {        List<String> ips = Arrays.asList(((String) ipObj).split(","));        List<HostnamePort> ret = new ArrayList<>();        for (String ip : ips) {            Iterable<String> tokens = Splitter.on(":").split(ip);            String host = Iterables.getFirst(tokens, null);            String portStr = Iterables.getLast(tokens, null);            ret.add(new HostnamePort(host, Integer.parseInt(portStr)));        }        return ret;    } else if (ipObj instanceof String && ipObj.toString().contains(",")) {        List<String> ips = Arrays.asList(((String) ipObj).split(","));        List<HostnamePort> ret = new ArrayList<>();        for (String ip : ips) {            ret.add(new HostnamePort(ip, Integer.parseInt(portObj + "")));        }        return ret;    } else if (ipObj instanceof String && !ipObj.toString().contains(":")) {        return ImmutableList.of(new HostnamePort(ipObj.toString(), Integer.parseInt(portObj + "")));    } else if (ipObj instanceof String && ipObj.toString().contains(":")) {        Iterable<String> tokens = Splitter.on(":").split(ipObj.toString());        String host = Iterables.getFirst(tokens, null);        String portStr = Iterables.getLast(tokens, null);        return ImmutableList.of(new HostnamePort(host, Integer.parseInt(portStr)));    } else if (ipObj instanceof List) {        List<String> ips = (List) ipObj;        List<HostnamePort> ret = new ArrayList<>();        for (String ip : ips) {            Iterable<String> tokens = Splitter.on(":").split(ip);            String host = Iterables.getFirst(tokens, null);            String portStr = Iterables.getLast(tokens, null);            ret.add(new HostnamePort(host, Integer.parseInt(portStr)));        }        return ret;    }    throw new IllegalStateException("Unable to read the elasticsearch ips, expected es.ip to be either a list of strings, a string hostname or a host:port string");}
public static Optional<String> metron_f4222_1(org.elasticsearch.action.search.SearchRequest esRequest)
{    Optional<String> json = Optional.empty();    if (esRequest != null && esRequest.source() != null) {        try {            BytesReference requestBytes = esRequest.source().buildAsBytes();            json = Optional.of(XContentHelper.convertToJson(requestBytes, true));        } catch (Throwable t) {                    }    }    return json;}
public static Optional<String> metron_f4223_1(Object request)
{    Optional<String> json = Optional.empty();    if (request != null) {        try {            json = Optional.of(new ObjectMapper().writer().withDefaultPrettyPrinter().writeValueAsString(request));        } catch (Throwable t) {                    }    }    return json;}
public static SearchResponse metron_f4224_0(RestHighLevelClient transportClient, QueryBuilder qb, String index, int pageSize) throws IOException
{    org.elasticsearch.action.search.SearchRequest request = new org.elasticsearch.action.search.SearchRequest();    SearchSourceBuilder builder = new SearchSourceBuilder();    builder.query(qb);    builder.size(pageSize);    builder.fetchSource(true);    builder.storedField("*");    request.source(builder);    request.indices(index);    org.elasticsearch.action.search.SearchResponse esResponse = transportClient.search(request);    List<SearchResult> allResults = getSearchResults(esResponse);    long total = esResponse.getHits().getTotalHits();    if (total > pageSize) {        int pages = (int) (total / pageSize) + 1;        for (int i = 1; i < pages; i++) {            int from = i * pageSize;            builder.from(from);            esResponse = transportClient.search(request);            allResults.addAll(getSearchResults(esResponse));        }    }    SearchResponse searchResponse = new SearchResponse();    searchResponse.setTotal(total);    searchResponse.setResults(allResults);    return searchResponse;}
protected static List<SearchResult> metron_f4225_0(org.elasticsearch.action.search.SearchResponse searchResponse)
{    return Arrays.stream(searchResponse.getHits().getHits()).map(searchHit -> {        SearchResult searchResult = new SearchResult();        searchResult.setId(searchHit.getId());        searchResult.setSource(searchHit.getSource());        searchResult.setScore(searchHit.getScore());        searchResult.setIndex(searchHit.getIndex());        return searchResult;    }).collect(Collectors.toList());}
public void metron_f4226_0(Map stormConf, WriterConfiguration configurations)
{    Map<String, Object> globalConfiguration = configurations.getGlobalConfig();    dateFormat = ElasticsearchUtils.getIndexFormat(globalConfiguration);        if (documentWriter == null) {        client = ElasticsearchClientFactory.create(globalConfiguration);        documentWriter = new ElasticsearchBulkDocumentWriter<>(client);    }}
public BulkWriterResponse metron_f4227_0(String sensorType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages)
{        FieldNameConverter fieldNameConverter = FieldNameConverters.create(sensorType, configurations);    String indexPostfix = dateFormat.format(new Date());    String indexName = ElasticsearchUtils.getIndexName(sensorType, indexPostfix, configurations);        for (BulkMessage<JSONObject> bulkWriterMessage : messages) {        MessageIdBasedDocument document = createDocument(bulkWriterMessage, sensorType, fieldNameConverter, configurations.isSetDocumentId(sensorType));        documentWriter.addDocument(document, indexName);    }        BulkDocumentWriterResults<MessageIdBasedDocument> results = documentWriter.write();        BulkWriterResponse response = new BulkWriterResponse();    for (WriteSuccess<MessageIdBasedDocument> success : results.getSuccesses()) {        response.addSuccess(success.getDocument().getMessageId());    }    for (WriteFailure<MessageIdBasedDocument> failure : results.getFailures()) {        response.addError(failure.getCause(), failure.getDocument().getMessageId());    }    return response;}
public String metron_f4229_0()
{    return "elasticsearch";}
public void metron_f4230_0() throws Exception
{    if (client != null) {        client.close();    }}
private void metron_f4231_0(String sourceFieldName, JSONObject source, JSONObject destination, FieldNameConverter fieldNameConverter)
{        String destinationFieldName = fieldNameConverter.convert(sourceFieldName);        destination.put(destinationFieldName, source.get(sourceFieldName));}
public void metron_f4232_0(BulkDocumentWriter<MessageIdBasedDocument> documentWriter)
{    this.documentWriter = documentWriter;}
public MessageId metron_f4233_0()
{    return messageId;}
public void metron_f4234_0()
{        highLevelClient = mock(RestHighLevelClient.class);    client = mock(ElasticsearchClient.class);    when(client.getHighLevelClient()).thenReturn(highLevelClient);    writer = new ElasticsearchBulkDocumentWriter<>(client);}
public void metron_f4235_0() throws IOException
{    setupElasticsearchToSucceed();        Document doc = document(message());    String index = "bro_index";    writer.addDocument(doc, index);    BulkDocumentWriterResults<Document> results = writer.write();    assertEquals(1, results.getSuccesses().size());    assertEquals(0, results.getFailures().size());    WriteSuccess<Document> success = results.getSuccesses().get(0);    assertEquals(doc, success.getDocument());}
public void metron_f4236_0() throws IOException
{    setupElasticsearchToFail();        Document doc = document(message());    String index = "bro_index";    writer.addDocument(doc, index);    BulkDocumentWriterResults<Document> results = writer.write();    assertEquals(0, results.getSuccesses().size());    assertEquals(1, results.getFailures().size());    WriteFailure<Document> failure = results.getFailures().get(0);    assertEquals(doc, failure.getDocument());    assertEquals("error message", failure.getMessage());    assertNotNull(failure.getCause());}
public void metron_f4237_0() throws IOException
{    setupElasticsearchToSucceed();    assertEquals(0, writer.size());        String index = "bro_index";    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    assertEquals(5, writer.size());        writer.write();    assertEquals(0, writer.size());}
public void metron_f4238_0() throws IOException
{    setupElasticsearchToFail();    assertEquals(0, writer.size());        String index = "bro_index";    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    writer.addDocument(document(message()), index);    assertEquals(5, writer.size());        writer.write();    assertEquals(0, writer.size());}
private void metron_f4239_0() throws IOException
{    final String errorMessage = "error message";    final Exception cause = new Exception("test exception");    final boolean isFailed = true;    final int itemID = 0;        BulkItemResponse.Failure failure = mock(BulkItemResponse.Failure.class);    when(failure.getCause()).thenReturn(cause);    when(failure.getMessage()).thenReturn(errorMessage);        BulkItemResponse itemResponse = mock(BulkItemResponse.class);    when(itemResponse.isFailed()).thenReturn(isFailed);    when(itemResponse.getItemId()).thenReturn(itemID);    when(itemResponse.getFailure()).thenReturn(failure);    when(itemResponse.getFailureMessage()).thenReturn("error message");    List<BulkItemResponse> itemsResponses = Collections.singletonList(itemResponse);        BulkResponse response = mock(BulkResponse.class);    when(response.iterator()).thenReturn(itemsResponses.iterator());    when(response.hasFailures()).thenReturn(isFailed);        when(highLevelClient.bulk(any(BulkRequest.class))).thenReturn(response);}
private void metron_f4240_0() throws IOException
{    final String documentId = UUID.randomUUID().toString();    final boolean isFailed = false;    final int itemID = 0;        DocWriteResponse writeResponse = mock(DocWriteResponse.class);    when(writeResponse.getId()).thenReturn(documentId);        BulkItemResponse itemResponse = mock(BulkItemResponse.class);    when(itemResponse.isFailed()).thenReturn(isFailed);    when(itemResponse.getItemId()).thenReturn(itemID);    when(itemResponse.getResponse()).thenReturn(writeResponse);    List<BulkItemResponse> itemsResponses = Collections.singletonList(itemResponse);        BulkResponse response = mock(BulkResponse.class);    when(response.iterator()).thenReturn(itemsResponses.iterator());    when(response.hasFailures()).thenReturn(isFailed);        when(highLevelClient.bulk(any(BulkRequest.class))).thenReturn(response);}
private Document metron_f4241_0(JSONObject message)
{    String guid = UUID.randomUUID().toString();    String sensorType = "bro";    Long timestamp = System.currentTimeMillis();    return new Document(message, guid, sensorType, timestamp);}
private JSONObject metron_f4242_0()
{    JSONObject message = new JSONObject();    message.put(Constants.GUID, UUID.randomUUID().toString());    message.put(Constants.Fields.TIMESTAMP.getName(), System.currentTimeMillis());    message.put(Constants.Fields.SRC_ADDR.getName(), "192.168.1.1");    return message;}
public void metron_f4243_0() throws Exception
{    tempDir = TestUtils.createTempDir(this.getClass().getName());}
public void metron_f4244_0() throws Exception
{    Path recordsFile = Paths.get(tempDir.getPath(), "inputfile.json");    Path outputFile = Paths.get(tempDir.getPath(), "outputfile.json");    TestUtils.write(recordsFile.toFile(), records);    ElasticsearchImportExport tool = new ElasticsearchImportExport();    tool.bulkify(recordsFile, outputFile);    String actual = TestUtils.read(outputFile.toFile());    assertThat(actual, equalTo(expected));}
public ElasticsearchColumnMetadataDao metron_f4245_0(String[] indices)
{    return setup(indices, new HashMap<>());}
public ElasticsearchColumnMetadataDao metron_f4246_0(String[] indices, Map<String, FieldMapping> mappings)
{    ElasticsearchClient client = new ElasticsearchClient(mock(RestClient.class), mock(RestHighLevelClient.class)) {        @Override        public String[] getIndices() throws IOException {            return indices;        }        @Override        public Map<String, FieldMapping> getMappingByIndex(String[] indices) throws IOException {            return mappings;        }    };    return new ElasticsearchColumnMetadataDao(client);}
public String[] metron_f4247_0() throws IOException
{    return indices;}
public Map<String, FieldMapping> metron_f4248_0(String[] indices) throws IOException
{    return mappings;}
public void metron_f4249_0() throws IOException
{        String[] existingIndices = new String[] { "bro_index_2017.10.03.19", "bro_index_2017.10.03.20", "bro_index_2017.10.03.21", "snort_index_2017.10.03.19", "snort_index_2017.10.03.20", "snort_index_2017.10.03.21" };    ElasticsearchColumnMetadataDao dao = setup(existingIndices);        List<String> args = Collections.singletonList("bro");    String[] actual = dao.getLatestIndices(args);        String[] expected = new String[] { "bro_index_2017.10.03.21" };    assertArrayEquals(expected, actual);}
public void metron_f4250_0() throws IOException
{        String[] existingIndices = new String[] { "bro_index_2017.10.03.19", "bro_index_2017.10.03.20", "bro_index_2017.10.03.21", "snort_index_2017.10.03.19", "snort_index_2017.10.03.19", "snort_index_2017.10.03.21" };    ElasticsearchColumnMetadataDao dao = setup(existingIndices);        List<String> args = Arrays.asList("bro", "snort");    String[] actual = dao.getLatestIndices(args);        String[] expected = new String[] { "bro_index_2017.10.03.21", "snort_index_2017.10.03.21" };    assertArrayEquals(expected, actual);}
public void metron_f4251_0() throws IOException
{        String[] existingIndices = new String[] {};    ElasticsearchColumnMetadataDao dao = setup(existingIndices);        List<String> args = Arrays.asList("bro", "snort");    String[] actual = dao.getLatestIndices(args);        String[] expected = new String[] {};    assertArrayEquals(expected, actual);}
private void metron_f4252_0(RestStatus status, int maxSearchResults, Map<String, FieldType> metadata) throws Exception
{        SearchHit hit1 = mock(SearchHit.class);    when(hit1.getId()).thenReturn("id1");    when(hit1.getSource()).thenReturn(new HashMap<String, Object>() {        {            put("field", "value1");        }    });    when(hit1.getScore()).thenReturn(0.1f);    SearchHit hit2 = mock(SearchHit.class);    when(hit2.getId()).thenReturn("id2");    when(hit2.getSource()).thenReturn(new HashMap<String, Object>() {        {            put("field", "value2");        }    });    when(hit2.getScore()).thenReturn(0.2f);        SearchHit[] hits = { hit1, hit2 };    SearchHits searchHits = mock(SearchHits.class);    when(searchHits.getHits()).thenReturn(hits);    when(searchHits.getTotalHits()).thenReturn(Integer.toUnsignedLong(hits.length));        org.elasticsearch.action.search.SearchResponse response = mock(org.elasticsearch.action.search.SearchResponse.class);    when(response.status()).thenReturn(status);    when(response.getHits()).thenReturn(searchHits);        ElasticsearchColumnMetadataDao columnMetadataDao = mock(ElasticsearchColumnMetadataDao.class);    when(columnMetadataDao.getColumnMetadata(any())).thenReturn(metadata);        requestSubmitter = mock(ElasticsearchRequestSubmitter.class);    when(requestSubmitter.submitSearch(any())).thenReturn(response);    RestHighLevelClient highLevel = mock(RestHighLevelClient.class);    ElasticsearchClient client = new ElasticsearchClient(mock(RestClient.class), highLevel);        AccessConfig config = mock(AccessConfig.class);    when(config.getMaxSearchResults()).thenReturn(maxSearchResults);    ElasticsearchSearchDao elasticsearchSearchDao = new ElasticsearchSearchDao(client, config, columnMetadataDao, requestSubmitter);    ElasticsearchRetrieveLatestDao elasticsearchRetrieveLatestDao = new ElasticsearchRetrieveLatestDao(client);    ElasticsearchUpdateDao elasticsearchUpdateDao = new ElasticsearchUpdateDao(client, config, elasticsearchRetrieveLatestDao);    dao = new ElasticsearchDao(client, config, elasticsearchSearchDao, elasticsearchUpdateDao, elasticsearchRetrieveLatestDao, columnMetadataDao, requestSubmitter);}
private void metron_f4253_0(RestStatus status, int maxSearchResults) throws Exception
{    setup(status, maxSearchResults, new HashMap<>());}
public void metron_f4254_0() throws Exception
{        Map<String, FieldType> columnMetadata = new HashMap<>();    columnMetadata.put("sortByStringDesc", FieldType.TEXT);    columnMetadata.put("sortByIntAsc", FieldType.INTEGER);        setup(RestStatus.OK, 25, columnMetadata);        SortField[] expectedSortFields = { sortBy("sortByStringDesc", SortOrder.DESC), sortBy("sortByIntAsc", SortOrder.ASC), sortBy("sortByUndefinedDesc", SortOrder.DESC) };        final List<String> indices = Arrays.asList("bro", "snort");    SearchRequest searchRequest = new SearchRequest();    searchRequest.setSize(2);    searchRequest.setIndices(indices);    searchRequest.setFrom(5);    searchRequest.setSort(Arrays.asList(expectedSortFields));    searchRequest.setQuery("some query");        SearchResponse searchResponse = dao.search(searchRequest);    assertNotNull(searchResponse);        ArgumentCaptor<org.elasticsearch.action.search.SearchRequest> argument = ArgumentCaptor.forClass(org.elasticsearch.action.search.SearchRequest.class);    verify(requestSubmitter).submitSearch(argument.capture());    org.elasticsearch.action.search.SearchRequest request = argument.getValue();        JSONParser parser = new JSONParser();    JSONObject json = (JSONObject) parser.parse(ElasticsearchUtils.toJSON(request).orElse("???"));        JSONArray sortFields = (JSONArray) json.get("sort");    assertEquals(3, sortFields.size());    {                JSONObject aSortField = (JSONObject) sortFields.get(0);        JSONObject sortBy = (JSONObject) aSortField.get("sortByStringDesc");        assertEquals("desc", sortBy.get("order"));        assertEquals("_last", sortBy.get("missing"));        assertEquals("text", sortBy.get("unmapped_type"));    }    {                JSONObject aSortField = (JSONObject) sortFields.get(1);        JSONObject sortByIntAsc = (JSONObject) aSortField.get("sortByIntAsc");        assertEquals("asc", sortByIntAsc.get("order"));        assertEquals("_first", sortByIntAsc.get("missing"));        assertEquals("integer", sortByIntAsc.get("unmapped_type"));    }    {                JSONObject aSortField = (JSONObject) sortFields.get(2);        JSONObject sortByUndefinedDesc = (JSONObject) aSortField.get("sortByUndefinedDesc");        assertEquals("desc", sortByUndefinedDesc.get("order"));        assertEquals("_last", sortByUndefinedDesc.get("missing"));        assertEquals("other", sortByUndefinedDesc.get("unmapped_type"));    }}
public void metron_f4255_0() throws Exception
{        setup(RestStatus.OK, 25);        SortField[] expectedSortFields = { sortBy("sortByStringDesc", SortOrder.DESC), sortBy("sortByIntAsc", SortOrder.ASC), sortBy("sortByUndefinedDesc", SortOrder.DESC) };        final List<String> indices = Arrays.asList("bro", "snort");    SearchRequest searchRequest = new SearchRequest();    searchRequest.setSize(2);    searchRequest.setIndices(indices);    searchRequest.setFrom(5);    searchRequest.setSort(Arrays.asList(expectedSortFields));    searchRequest.setQuery("some query");        SearchResponse searchResponse = dao.search(searchRequest);    assertNotNull(searchResponse);        ArgumentCaptor<org.elasticsearch.action.search.SearchRequest> argument = ArgumentCaptor.forClass(org.elasticsearch.action.search.SearchRequest.class);    verify(requestSubmitter).submitSearch(argument.capture());    org.elasticsearch.action.search.SearchRequest request = argument.getValue();        JSONParser parser = new JSONParser();    JSONObject json = (JSONObject) parser.parse(ElasticsearchUtils.toJSON(request).orElse("???"));        String[] expected = { "bro_index*", "snort_index*" };    assertArrayEquals(expected, request.indices());}
public void metron_f4256_0() throws Exception
{    int maxSearchResults = 20;    setup(RestStatus.OK, maxSearchResults);    SearchRequest searchRequest = new SearchRequest();    searchRequest.setSize(maxSearchResults + 1);    searchRequest.setQuery("");    dao.search(searchRequest);}
private SortField metron_f4257_0(String field, SortOrder order)
{    SortField sortField = new SortField();    sortField.setField(field);    sortField.setSortOrder(order.toString());    return sortField;}
public void metron_f4258_0()
{    IndexDao dao = new IndexDao() {        @Override        public SearchResponse search(SearchRequest searchRequest) {            return null;        }        @Override        public GroupResponse group(GroupRequest groupRequest) {            return null;        }        @Override        public void init(AccessConfig config) {        }        @Override        public Document getLatest(String guid, String sensorType) {            return null;        }        @Override        public Iterable<Document> getAllLatest(List<GetRequest> getRequests) {            return null;        }        @Override        public Document update(Document update, Optional<String> index) {            return update;        }        @Override        public Map<Document, Optional<String>> batchUpdate(Map<Document, Optional<String>> updates) {            return updates;        }        @Override        public Map<String, FieldType> getColumnMetadata(List<String> indices) {            return null;        }        @Override        public Document addCommentToAlert(CommentAddRemoveRequest request) {            return null;        }        @Override        public Document removeCommentFromAlert(CommentAddRemoveRequest request) {            return null;        }        @Override        public Document addCommentToAlert(CommentAddRemoveRequest request, Document latest) {            return null;        }        @Override        public Document removeCommentFromAlert(CommentAddRemoveRequest request, Document latest) {            return null;        }    };    ElasticsearchMetaAlertDao metaAlertDao = new ElasticsearchMetaAlertDao();    metaAlertDao.init(dao);}
public SearchResponse metron_f4259_0(SearchRequest searchRequest)
{    return null;}
public GroupResponse metron_f4260_0(GroupRequest groupRequest)
{    return null;}
public void metron_f4261_0(AccessConfig config)
{}
public Document metron_f4262_0(String guid, String sensorType)
{    return null;}
public Iterable<Document> metron_f4263_0(List<GetRequest> getRequests)
{    return null;}
public Document metron_f4264_0(Document update, Optional<String> index)
{    return update;}
public Map<Document, Optional<String>> metron_f4265_0(Map<Document, Optional<String>> updates)
{    return updates;}
public Map<String, FieldType> metron_f4266_0(List<String> indices)
{    return null;}
public Document metron_f4267_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f4268_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f4269_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f4270_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public void metron_f4271_0()
{    HBaseDao dao = new HBaseDao();    ElasticsearchMetaAlertDao esDao = new ElasticsearchMetaAlertDao();    esDao.init(dao, Optional.empty());}
public void metron_f4272_0() throws InvalidCreateException, IOException
{    ElasticsearchDao esDao = new ElasticsearchDao();    ElasticsearchMetaAlertDao emaDao = new ElasticsearchMetaAlertDao();    emaDao.init(esDao);    MetaAlertCreateRequest createRequest = new MetaAlertCreateRequest();    emaDao.createMetaAlert(createRequest);}
public void metron_f4273_0() throws InvalidCreateException, IOException
{    ElasticsearchDao esDao = new ElasticsearchDao();    MultiIndexDao miDao = new MultiIndexDao(esDao);    ElasticsearchMetaAlertDao emaDao = new ElasticsearchMetaAlertDao();    emaDao.init(miDao);    MetaAlertCreateRequest createRequest = new MetaAlertCreateRequest();    createRequest.setAlerts(Collections.singletonList(new GetRequest("don't", "care")));    emaDao.createMetaAlert(createRequest);}
public void metron_f4274_0() throws Exception
{    ElasticsearchDao elasticsearchDao = mock(ElasticsearchDao.class);    ElasticsearchMetaAlertRetrieveLatestDao elasticsearchMetaAlertRetrieveLatestDao = mock(ElasticsearchMetaAlertRetrieveLatestDao.class);    MetaAlertConfig metaAlertConfig = mock(MetaAlertConfig.class);    ElasticsearchMetaAlertUpdateDao emauDao = spy(new ElasticsearchMetaAlertUpdateDao(elasticsearchDao, elasticsearchMetaAlertRetrieveLatestDao, metaAlertConfig, 1));    doThrow(new IndexNotFoundException(ElasticsearchMetaAlertDao.METAALERTS_INDEX)).when(emauDao).getMetaAlertsForAlert("alert_one");    Document update = new Document(new HashMap<>(), "alert_one", "", 0L);    emauDao.update(update, Optional.empty());    Map<Document, Optional<String>> expectedUpdate = new HashMap<Document, Optional<String>>() {        {            put(update, Optional.empty());        }    };    verify(elasticsearchDao).batchUpdate(expectedUpdate);}
public void metron_f4275_0() throws Exception
{    ElasticsearchDao elasticsearchDao = mock(ElasticsearchDao.class);    ElasticsearchMetaAlertRetrieveLatestDao elasticsearchMetaAlertRetrieveLatestDao = mock(ElasticsearchMetaAlertRetrieveLatestDao.class);    MetaAlertConfig metaAlertConfig = mock(MetaAlertConfig.class);    ElasticsearchMetaAlertUpdateDao emauDao = spy(new ElasticsearchMetaAlertUpdateDao(elasticsearchDao, elasticsearchMetaAlertRetrieveLatestDao, metaAlertConfig, 1));    doThrow(new IndexNotFoundException("bro")).when(emauDao).getMetaAlertsForAlert("alert_one");    Document update = new Document(new HashMap<>(), "alert_one", "", 0L);    emauDao.update(update, Optional.empty());}
public ElasticsearchRequestSubmitter metron_f4276_0(SearchResponse response) throws IOException
{        RestHighLevelClient highLevelClient = mock(RestHighLevelClient.class);    ElasticsearchClient client = new ElasticsearchClient(mock(RestClient.class), highLevelClient);        when(highLevelClient.search(any())).thenReturn(response);    return new ElasticsearchRequestSubmitter(client);}
public void metron_f4277_0() throws InvalidSearchException, IOException
{        SearchResponse response = mock(SearchResponse.class);    SearchRequest request = new SearchRequest();        SearchHits hits = mock(SearchHits.class);    when(hits.getTotalHits()).thenReturn(1L);        when(response.status()).thenReturn(RestStatus.OK);    when(response.getFailedShards()).thenReturn(0);    when(response.getTotalShards()).thenReturn(2);    when(response.getHits()).thenReturn(hits);        ElasticsearchRequestSubmitter submitter = setup(response);    SearchResponse actual = submitter.submitSearch(request);    assertNotNull(actual);}
public void metron_f4278_0() throws InvalidSearchException, IOException
{        SearchResponse response = mock(SearchResponse.class);    SearchRequest request = new SearchRequest();        when(response.status()).thenReturn(RestStatus.PARTIAL_CONTENT);    when(response.getFailedShards()).thenReturn(0);    when(response.getTotalShards()).thenReturn(2);        ElasticsearchRequestSubmitter submitter = setup(response);    submitter.submitSearch(request);}
public void metron_f4279_0() throws InvalidSearchException, IOException
{        SearchResponse response = mock(SearchResponse.class);    SearchRequest request = new SearchRequest();    ShardSearchFailure fail = mock(ShardSearchFailure.class);    SearchShardTarget target = new SearchShardTarget("node1", mock(Index.class), 1, "metron");        when(response.status()).thenReturn(RestStatus.OK);        SearchHits hits = mock(SearchHits.class);    when(hits.getTotalHits()).thenReturn(1L);        when(response.getFailedShards()).thenReturn(1);    when(response.getTotalShards()).thenReturn(2);    when(response.getHits()).thenReturn(hits);        ShardSearchFailure[] failures = { fail };    when(response.getShardFailures()).thenReturn(failures);        when(fail.shard()).thenReturn(target);        when(fail.index()).thenReturn("bro_index_2017-10-11");    when(fail.shardId()).thenReturn(1);        ElasticsearchRequestSubmitter submitter = setup(response);    SearchResponse actual = submitter.submitSearch(request);    assertNotNull(actual);}
public void metron_f4280_0()
{    accessConfig = new AccessConfig();    retrieveLatestDao = mock(ElasticsearchRetrieveLatestDao.class);    RestHighLevelClient highLevel = mock(RestHighLevelClient.class);    ElasticsearchClient client = new ElasticsearchClient(mock(RestClient.class), highLevel);    updateDao = new ElasticsearchUpdateDao(client, accessConfig, retrieveLatestDao);}
public UpdateDao metron_f4281_0()
{    return updateDao;}
public Builder metron_f4282_0(String index, String docType, String mapping)
{    mappings.add(new Mapping(index, docType, mapping));    return this;}
public Builder metron_f4283_0(int httpPort)
{    this.httpPort = httpPort;    return this;}
public Builder metron_f4284_0(File indexDir)
{    this.indexDir = indexDir;    return this;}
public Builder metron_f4285_0(Map<String, String> extraElasticSearchSettings)
{    this.extraElasticSearchSettings = extraElasticSearchSettings;    return this;}
public Builder metron_f4286_0(AccessConfig accessConfig)
{    this.accessConfig = accessConfig;    return this;}
public ElasticSearchComponent metron_f4287_0()
{    return new ElasticSearchComponent(httpPort, indexDir, extraElasticSearchSettings, mappings, accessConfig);}
public void metron_f4288_0() throws UnableToStartException
{    File logDir = new File(indexDir, "/logs");    File dataDir = new File(indexDir, "/data");    try {        cleanDir(logDir);        cleanDir(dataDir);    } catch (IOException e) {        throw new UnableToStartException("Unable to clean log or data directories", e);    }    Settings.Builder settingsBuilder = Settings.builder().put("cluster.name", "metron").put("path.logs", logDir.getAbsolutePath()).put("path.data", dataDir.getAbsolutePath()).put("path.home", indexDir.getAbsoluteFile()).put("transport.type", "netty4").put("http.enabled", "true");    if (extraElasticSearchSettings != null) {        settingsBuilder = settingsBuilder.put(extraElasticSearchSettings);    }    node = new TestNode(settingsBuilder.build(), asList(Netty4Plugin.class));    client = node.client();    try {        node.start();    } catch (NodeValidationException e) {        throw new UnableToStartException("Error starting ES node.", e);    }    waitForCluster(client, ClusterHealthStatus.YELLOW, STARTUP_TIMEOUT);    for (Mapping m : Optional.ofNullable(mappings).orElse(new ArrayList<>())) {        client.admin().indices().prepareCreate(m.index).addMapping(m.docType, m.mapping).get();    }    indexDao = new ElasticsearchDao().withRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);    indexDao.init(accessConfig);}
private void metron_f4289_0(File dir) throws IOException
{    if (dir.exists()) {        FileUtils.deleteDirectory(dir);    }    dir.mkdirs();}
public static void metron_f4290_0(Client client, ClusterHealthStatus statusThreshold, String timeout) throws UnableToStartException
{    try {        ClusterHealthResponse healthResponse = (ClusterHealthResponse) client.execute(ClusterHealthAction.INSTANCE, new ClusterHealthRequest().waitForStatus(statusThreshold).timeout(timeout)).actionGet();        if (healthResponse != null && healthResponse.isTimedOut()) {            throw new UnableToStartException("cluster state is " + healthResponse.getStatus().name() + " and not " + statusThreshold.name() + ", from here on, everything will fail!");        }    } catch (ElasticsearchTimeoutException e) {        throw new UnableToStartException("timeout, cluster does not respond to health request, cowardly refusing to continue with operations");    }}
public Client metron_f4291_0()
{    return client;}
public void metron_f4292_0(String indexName, String sensorType, String... docs) throws IOException, ParseException
{    List<String> d = new ArrayList<>();    Collections.addAll(d, docs);    add(indexName, sensorType, d, false);}
public void metron_f4293_0(String indexName, String sensorType, Iterable<String> docs) throws IOException, ParseException
{    add(indexName, sensorType, docs, false);}
public void metron_f4294_0(String indexName, String sensorType, Iterable<String> docs, boolean setDocumentId) throws IOException, ParseException
{        JSONParser parser = new JSONParser();    Map<Document, Optional<String>> documents = new HashMap<>();    for (String json : docs) {        JSONObject message = (JSONObject) parser.parse(json);        documents.put(createDocument(message, sensorType, setDocumentId), Optional.of(indexName));    }        indexDao.batchUpdate(documents);}
private static Document metron_f4295_0(JSONObject message, String docType, boolean setDocumentId) throws IOException
{    Long timestamp = ConversionUtils.convert(message.get("timestamp"), Long.class);    String source = message.toJSONString();    String guid = (String) message.get("guid");    Document document = new Document(source, guid, docType, timestamp);    if (setDocumentId) {        document.setDocumentID(guid);    }    return document;}
public void metron_f4296_0(String indexName, String mappingType, String mappingSource) throws IOException
{    CreateIndexResponse cir = client.admin().indices().prepareCreate(indexName).addMapping(mappingType, mappingSource).get();    if (!cir.isAcknowledged()) {        throw new IOException("Create index was not acknowledged");    }}
public List<Map<String, Object>> metron_f4297_0(String index, String sourceType) throws IOException
{    return getAllIndexedDocs(index, sourceType, null);}
public List<Map<String, Object>> metron_f4298_0(String index, String sourceType, String subMessage) throws IOException
{    getClient().admin().indices().refresh(new RefreshRequest());    SearchResponse response = getClient().prepareSearch(index).setTypes(sourceType).setFrom(0).setSize(1000).execute().actionGet();    List<Map<String, Object>> ret = new ArrayList<Map<String, Object>>();    for (SearchHit hit : response.getHits()) {        Object o = null;        if (subMessage == null) {            o = hit.getSource();        } else {            o = hit.getSource().get(subMessage);        }        ret.add((Map<String, Object>) (o));    }    return ret;}
public boolean metron_f4299_0(String indexName)
{    Set<String> indices = getClient().admin().indices().stats(new IndicesStatsRequest()).actionGet().getIndices().keySet();    return indices.contains(indexName);}
public void metron_f4300_0()
{    try {        if (node != null) {            node.close();        }    } catch (IOException e) {        throw new RuntimeException("Unable to stop node.", e);    }    node = null;    client = null;}
public void metron_f4301_0()
{    client.admin().indices().delete(new DeleteIndexRequest("*")).actionGet();}
public static void metron_f4302_0() throws Exception
{    AccessConfig accessConfig = new AccessConfig();    accessConfig.setGlobalConfigSupplier(() -> globals());    elasticsearch = new ElasticSearchComponent.Builder().withHttpPort(9211).withIndexDir(indexDir.getRoot()).withAccessConfig(accessConfig).build();    elasticsearch.start();}
public static void metron_f4303_0()
{    if (elasticsearch != null) {        elasticsearch.stop();    }}
public void metron_f4304_0() throws Exception
{    client = ElasticsearchClientFactory.create(globals());    retrieveDao = new ElasticsearchRetrieveLatestDao(client);    writer = new ElasticsearchBulkDocumentWriter<>(client).withRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);        JSONObject broTemplate = JSONUtils.INSTANCE.load(new File(broTemplatePath), JSONObject.class);    String broTemplateJson = JSONUtils.INSTANCE.toJSON(broTemplate, true);    HttpEntity broEntity = new NStringEntity(broTemplateJson, ContentType.APPLICATION_JSON);    Response response = client.getLowLevelClient().performRequest("PUT", "/_template/bro_template", Collections.emptyMap(), broEntity);    assertThat(response.getStatusLine().getStatusCode(), CoreMatchers.equalTo(200));}
public void metron_f4305_0() throws IOException
{    if (client != null) {        client.close();    }}
public void metron_f4306_0() throws Exception
{        List<Document> documents = new ArrayList<>();    for (int i = 0; i < 10; i++) {        Document document = Document.fromJSON(createMessage());        documents.add(document);    }        for (Document doc : documents) {        writer.addDocument(doc, "bro_index");    }    writer.write();        for (Document expected : documents) {        Document actual = retrieveDao.getLatest(expected.getGuid(), expected.getSensorType());        assertNotNull("No document found", actual);        assertEquals(expected.getGuid(), actual.getGuid());        assertEquals(expected.getSensorType(), actual.getSensorType());        assertEquals(expected.getDocument(), actual.getDocument());        assertTrue(actual.getDocumentID().isPresent());                assertNotEquals(actual.getDocument(), actual.getGuid());    }}
private static Map<String, Object> metron_f4307_0()
{    Map<String, Object> globals = new HashMap<>();    globals.put("es.clustername", "metron");    globals.put("es.ip", "localhost");    globals.put("es.port", "9200");    globals.put("es.date.format", "yyyy.MM.dd.HH");    return globals;}
private JSONObject metron_f4308_0()
{    JSONObject message = new JSONObject();    message.put(Constants.GUID, UUID.randomUUID().toString());    message.put(Constants.Fields.TIMESTAMP.getName(), System.currentTimeMillis());    message.put(Constants.Fields.SRC_ADDR.getName(), "192.168.1.1");    message.put("source:type", "bro");    return message;}
public static Collection<Object[]> metron_f4309_0()
{    Function<List<String>, List<String>> asteriskTransform = x -> ImmutableList.of("*");    Function<List<String>, List<String>> explicitTransform = allIndices -> allIndices.stream().map(x -> x.replace("_index", "")).collect(Collectors.toCollection(ArrayList::new));    return Arrays.asList(new Object[][] { { asteriskTransform }, { explicitTransform } });}
public static void metron_f4310_0() throws Exception
{        MAX_RETRIES = 10;    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put("es.clustername", "metron");            put("es.port", "9200");            put("es.ip", "localhost");            put("es.date.format", DATE_FORMAT);        }    };    accessConfig = new AccessConfig();    accessConfig.setMaxSearchResults(1000);    accessConfig.setMaxSearchGroups(100);    accessConfig.setGlobalConfigSupplier(() -> globalConfig);        es = new ElasticSearchComponent.Builder().withHttpPort(9211).withIndexDir(new File(INDEX_DIR)).withAccessConfig(accessConfig).build();    es.start();}
public void metron_f4311_0() throws IOException
{    es.createIndexWithMapping(METAALERTS_INDEX, METAALERT_DOC, template.replace("%MAPPING_NAME%", METAALERT_TYPE));    es.createIndexWithMapping(INDEX, "test_doc", template.replace("%MAPPING_NAME%", "test"));    esDao = new ElasticsearchDao();    esDao.init(accessConfig);    ElasticsearchMetaAlertDao elasticsearchMetaDao = new ElasticsearchMetaAlertDao(esDao);    elasticsearchMetaDao.setPageSize(5);    metaDao = elasticsearchMetaDao;}
public static void metron_f4312_0()
{    if (es != null) {        es.stop();    }}
public void metron_f4313_0()
{    es.reset();}
public void metron_f4314_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(4);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(0).put("ip_src_addr", "192.168.1.1");    alerts.get(0).put("ip_src_port", 8010);    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put("ip_src_addr", "192.168.1.2");    alerts.get(1).put("ip_src_port", 8009);    alerts.get(2).put("ip_src_addr", "192.168.1.3");    alerts.get(2).put("ip_src_port", 8008);    alerts.get(3).put("ip_src_addr", "192.168.1.4");    alerts.get(3).put("ip_src_port", 8007);    addRecords(alerts, INDEX, SENSOR_NAME);        setupTypings();        Map<String, Object> activeMetaAlert = buildMetaAlert("meta_active", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));    Map<String, Object> inactiveMetaAlert = buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.of(Arrays.asList(alerts.get(2), alerts.get(3))));        addRecords(Arrays.asList(activeMetaAlert, inactiveMetaAlert), METAALERTS_INDEX, METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME), new GetRequest("meta_active", METAALERT_TYPE), new GetRequest("meta_inactive", METAALERT_TYPE)));    SearchResponse searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("(ip_src_addr:192.168.1.1 AND ip_src_port:8009) OR (metron_alert.ip_src_addr:192.168.1.1 AND metron_alert.ip_src_port:8009)");            setIndices(Collections.singletonList(METAALERT_TYPE));            setFrom(0);            setSize(5);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(0, searchResponse.getTotal());            searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("(ip_src_addr:192.168.1.1 AND ip_src_port:8010)" + " OR (metron_alert.ip_src_addr:192.168.1.1 AND metron_alert.ip_src_port:8010)");            setIndices(queryIndices);            setFrom(0);            setSize(5);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());    Assert.assertEquals("meta_active", searchResponse.getResults().get(0).getSource().get("guid"));            searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("(ip_src_addr:192.168.1.3 AND ip_src_port:8008)" + " OR (metron_alert.ip_src_addr:192.168.1.3 AND metron_alert.ip_src_port:8008)");            setIndices(Collections.singletonList("*"));            setFrom(0);            setSize(1);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());    Assert.assertEquals("message_2", searchResponse.getResults().get(0).getSource().get("guid"));}
protected long metron_f4315_0(String fieldName, Object fieldValue) throws IOException, InterruptedException
{    long cnt = 0;    for (int t = 0; t < MAX_RETRIES && cnt == 0; ++t, Thread.sleep(SLEEP_MS)) {        List<Map<String, Object>> docs = es.getAllIndexedDocs(INDEX, SENSOR_NAME + "_doc");        cnt = docs.stream().filter(d -> {            Object newfield = d.get(fieldName);            return newfield != null && newfield.equals(fieldValue);        }).count();    }    return cnt;}
protected long metron_f4316_0(String fieldName, String fieldValue) throws IOException, InterruptedException
{    long cnt = 0;    for (int t = 0; t < MAX_RETRIES && cnt == 0; ++t, Thread.sleep(SLEEP_MS)) {        List<Map<String, Object>> docs = es.getAllIndexedDocs(METAALERTS_INDEX, METAALERT_DOC);        cnt = docs.stream().filter(d -> {            @SuppressWarnings("unchecked")            List<Map<String, Object>> alerts = (List<Map<String, Object>>) d.get(ALERT_FIELD);            for (Map<String, Object> alert : alerts) {                Object newField = alert.get(fieldName);                if (newField != null && newField.equals(fieldValue)) {                    return true;                }            }            return false;        }).count();    }    return cnt;}
protected void metron_f4317_0(List<Map<String, Object>> inputData, String index, String docType) throws IOException, ParseException
{    es.add(index, docType, inputData.stream().map(m -> {        try {            return JSONUtils.INSTANCE.toJSON(m, true);        } catch (JsonProcessingException e) {            throw new IllegalStateException(e.getMessage(), e);        }    }).collect(Collectors.toList()));}
protected void metron_f4318_0() throws IOException
{    ((ElasticsearchDao) esDao).getClient().putMapping(INDEX, "test_doc", nestedAlertMapping);}
protected String metron_f4319_0()
{    return INDEX_RAW;}
protected String metron_f4320_0()
{    return INDEX;}
protected String metron_f4321_0()
{    return METAALERTS_INDEX;}
protected String metron_f4322_0()
{    return ElasticsearchMetaAlertDao.SOURCE_TYPE_FIELD;}
protected void metron_f4323_0(Map<String, Object> docMap)
{    docMap.put(METAALERT_FIELD, new ArrayList<>());}
protected boolean metron_f4324_0()
{    return true;}
protected boolean metron_f4325_0()
{    return true;}
public static void metron_f4326_0() throws Exception
{    globalConfig = new HashMap<String, Object>() {        {            put("es.clustername", "metron");            put("es.port", "9200");            put("es.ip", "localhost");            put("es.date.format", dateFormat);        }    };    accessConfig = new AccessConfig();    accessConfig.setMaxSearchResults(100);    accessConfig.setMaxSearchGroups(100);    accessConfig.setGlobalConfigSupplier(() -> globalConfig);    indexComponent = startIndex();    ElasticsearchClient esClient = ElasticsearchClientFactory.create(globalConfig);    lowLevelClient = esClient.getLowLevelClient();    highLevelClient = esClient.getHighLevelClient();    dao = new ElasticsearchDao();    dao.init(accessConfig);        loadTestData();}
protected static InMemoryComponent metron_f4327_0() throws Exception
{    InMemoryComponent es = new ElasticSearchComponent.Builder().withHttpPort(9211).withIndexDir(new File(indexDir)).withAccessConfig(accessConfig).build();    es.start();    return es;}
protected static void metron_f4328_0() throws Exception
{    ElasticSearchComponent es = (ElasticSearchComponent) indexComponent;        JSONObject broTemplate = JSONUtils.INSTANCE.load(new File(broTemplatePath), JSONObject.class);    addTestFieldMappings(broTemplate, "bro_doc");    String broTemplateJson = JSONUtils.INSTANCE.toJSON(broTemplate, true);    HttpEntity broEntity = new NStringEntity(broTemplateJson, ContentType.APPLICATION_JSON);    Response response = lowLevelClient.performRequest("PUT", "/_template/bro_template", Collections.emptyMap(), broEntity);    assertThat(response.getStatusLine().getStatusCode(), equalTo(200));        JSONObject snortTemplate = JSONUtils.INSTANCE.load(new File(snortTemplatePath), JSONObject.class);    addTestFieldMappings(snortTemplate, "snort_doc");    String snortTemplateJson = JSONUtils.INSTANCE.toJSON(snortTemplate, true);    HttpEntity snortEntity = new NStringEntity(snortTemplateJson, ContentType.APPLICATION_JSON);    response = lowLevelClient.performRequest("PUT", "/_template/snort_template", Collections.emptyMap(), snortEntity);    assertThat(response.getStatusLine().getStatusCode(), equalTo(200));        response = lowLevelClient.performRequest("PUT", BRO_INDEX);    assertThat(response.getStatusLine().getStatusCode(), equalTo(200));        response = lowLevelClient.performRequest("PUT", SNORT_INDEX);    assertThat(response.getStatusLine().getStatusCode(), equalTo(200));        List<String> broDocuments = new ArrayList<>();    for (Object broObject : (JSONArray) new JSONParser().parse(broData)) {        broDocuments.add(((JSONObject) broObject).toJSONString());    }        es.add(BRO_INDEX, "bro", broDocuments.subList(0, 4), true);        es.add(BRO_INDEX, "bro", broDocuments.subList(4, 5), false);        List<String> snortDocuments = new ArrayList<>();    for (Object snortObject : (JSONArray) new JSONParser().parse(snortData)) {        snortDocuments.add(((JSONObject) snortObject).toJSONString());    }    es.add(SNORT_INDEX, "snort", snortDocuments);}
private static void metron_f4329_0(JSONObject template, String docType)
{    Map mappings = (Map) template.get("mappings");    Map docTypeJSON = (Map) mappings.get(docType);    Map properties = (Map) docTypeJSON.get("properties");    Map<String, String> longType = new HashMap<>();    longType.put("type", "long");    properties.put("long_field", longType);    Map<String, String> floatType = new HashMap<>();    floatType.put("type", "float");    properties.put("latitude", floatType);    Map<String, String> doubleType = new HashMap<>();    doubleType.put("type", "double");    properties.put("score", doubleType);}
public void metron_f4330_0() throws Exception
{    thrown.expect(InvalidSearchException.class);    thrown.expectMessage("Failed to execute search");    SearchRequest request = JSONUtils.INSTANCE.load(badFacetQuery, SearchRequest.class);    dao.search(request);}
public void metron_f4331_0() throws Exception
{        {        Map<String, FieldType> fieldTypes = dao.getColumnMetadata(Collections.singletonList("bro"));        Assert.assertEquals(262, fieldTypes.size());        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("method"));        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("ttl"));        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("guid"));        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("source:type"));        Assert.assertEquals(FieldType.IP, fieldTypes.get("ip_src_addr"));        Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ip_src_port"));        Assert.assertEquals(FieldType.LONG, fieldTypes.get("long_field"));        Assert.assertEquals(FieldType.DATE, fieldTypes.get("timestamp"));        Assert.assertEquals(FieldType.FLOAT, fieldTypes.get("latitude"));        Assert.assertEquals(FieldType.DOUBLE, fieldTypes.get("score"));        Assert.assertEquals(FieldType.BOOLEAN, fieldTypes.get("is_alert"));        Assert.assertEquals(FieldType.TEXT, fieldTypes.get("location_point"));        Assert.assertEquals(FieldType.OTHER, fieldTypes.get("metron_alert"));    }        {        Map<String, FieldType> fieldTypes = dao.getColumnMetadata(Collections.singletonList("snort"));        Assert.assertEquals(32, fieldTypes.size());        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("sig_generator"));        Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ttl"));        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("guid"));        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("source:type"));        Assert.assertEquals(FieldType.IP, fieldTypes.get("ip_src_addr"));        Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ip_src_port"));        Assert.assertEquals(FieldType.LONG, fieldTypes.get("long_field"));        Assert.assertEquals(FieldType.DATE, fieldTypes.get("timestamp"));        Assert.assertEquals(FieldType.FLOAT, fieldTypes.get("latitude"));        Assert.assertEquals(FieldType.DOUBLE, fieldTypes.get("score"));        Assert.assertEquals(FieldType.BOOLEAN, fieldTypes.get("is_alert"));        Assert.assertEquals(FieldType.TEXT, fieldTypes.get("location_point"));        Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ttl"));        Assert.assertEquals(FieldType.OTHER, fieldTypes.get("metron_alert"));    }}
public void metron_f4332_0() throws Exception
{    Map<String, FieldType> fieldTypes = dao.getColumnMetadata(Arrays.asList("bro", "snort"));    Assert.assertEquals(277, fieldTypes.size());        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("guid"));    Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("source:type"));    Assert.assertEquals(FieldType.FLOAT, fieldTypes.get("threat:triage:score"));    Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("alert_status"));    Assert.assertEquals(FieldType.OTHER, fieldTypes.get("metron_alert"));    Assert.assertEquals(FieldType.IP, fieldTypes.get("ip_src_addr"));    Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ip_src_port"));    Assert.assertEquals(FieldType.LONG, fieldTypes.get("long_field"));    Assert.assertEquals(FieldType.DATE, fieldTypes.get("timestamp"));    Assert.assertEquals(FieldType.FLOAT, fieldTypes.get("latitude"));    Assert.assertEquals(FieldType.DOUBLE, fieldTypes.get("score"));    Assert.assertEquals(FieldType.DOUBLE, fieldTypes.get("suppress_for"));    Assert.assertEquals(FieldType.BOOLEAN, fieldTypes.get("is_alert"));        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("method"));        Assert.assertEquals(FieldType.KEYWORD, fieldTypes.get("sig_generator"));        Assert.assertEquals(FieldType.OTHER, fieldTypes.get("ttl"));    Assert.assertEquals(FieldType.OTHER, fieldTypes.get("msg"));}
public void metron_f4333_0() throws Exception
{    thrown.expect(InvalidSearchException.class);    thrown.expectMessage("Failed to execute search");    GroupRequest request = JSONUtils.INSTANCE.load(badGroupQuery, GroupRequest.class);    dao.group(request);}
public void metron_f4334_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(differentTypeFilterQuery, SearchRequest.class);    SearchResponse response = dao.search(request);    Assert.assertEquals(1, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals("bro", results.get(0).getSource().get("source:type"));    Assert.assertEquals("data 1", results.get(0).getSource().get("ttl"));}
protected String metron_f4335_0()
{    return Constants.SENSOR_TYPE.replace('.', ':');}
protected IndexDao metron_f4336_0()
{    return dao;}
protected String metron_f4337_0(String sensorType)
{    if ("bro".equals(sensorType)) {        return BRO_INDEX;    } else {        return SNORT_INDEX;    }}
protected String metron_f4338_0()
{    return SENSOR_NAME + "_index_" + new SimpleDateFormat(dateFormat).format(new Date());}
public static void metron_f4339_0() throws UnableToStartException, IOException
{    Configuration config = HBaseConfiguration.create();    MockHBaseTableProvider tableProvider = new MockHBaseTableProvider();    MockHBaseTableProvider.addToCache(TABLE_NAME, CF);    table = (MockHTable) tableProvider.getTable(config, TABLE_NAME);    globalConfig = new HashMap<>();    globalConfig.put("es.clustername", "metron");    globalConfig.put("es.port", "9200");    globalConfig.put("es.ip", "localhost");    globalConfig.put("es.date.format", dateFormat);    globalConfig.put(HBaseDao.HBASE_TABLE, TABLE_NAME);    globalConfig.put(HBaseDao.HBASE_CF, CF);    accessConfig = new AccessConfig();    accessConfig.setTableProvider(tableProvider);    accessConfig.setGlobalConfigSupplier(() -> globalConfig);    es = new ElasticSearchComponent.Builder().withHttpPort(9211).withIndexDir(new File(indexDir)).withAccessConfig(accessConfig).build();    es.start();    installIndexTemplate();}
public void metron_f4340_0()
{    elasticsearchDao = new ElasticsearchDao().withRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);    elasticsearchDao.init(accessConfig);    setDao(elasticsearchDao);}
public void metron_f4341_0()
{    es.reset();    table.clear();}
public static void metron_f4342_0()
{    es.stop();}
protected void metron_f4343_0(String indexName, String sensorType, List<Map<String, Object>> docs) throws Exception
{    es.add(index, SENSOR_NAME, Iterables.transform(docs, m -> {        try {            return JSONUtils.INSTANCE.toJSON(m, true);        } catch (JsonProcessingException e) {            throw new IllegalStateException(e.getMessage(), e);        }    }));}
protected List<Map<String, Object>> metron_f4344_0(String indexName, String sensorType) throws Exception
{    return es.getAllIndexedDocs(index, SENSOR_NAME + "_doc");}
private static void metron_f4345_0() throws IOException
{    HttpEntity broEntity = new NStringEntity(indexTemplate, ContentType.APPLICATION_JSON);    ElasticsearchClient client = ElasticsearchClientFactory.create(globalConfig);    Response response = client.getLowLevelClient().performRequest("PUT", "/_template/test_template", Collections.emptyMap(), broEntity);    Assert.assertThat(response.getStatusLine().getStatusCode(), CoreMatchers.equalTo(200));}
public void metron_f4346_0()
{    writerConfiguration = mock(WriterConfiguration.class);    when(writerConfiguration.getGlobalConfig()).thenReturn(globals());    stormConf = new HashMap();}
public void metron_f4347_0()
{        List<BulkMessage<JSONObject>> messages = createMessages(1);        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addSuccess(createDocument(messages.get(0)));    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        assertFalse(response.hasErrors());    assertTrue(response.getSuccesses().contains(new MessageId("message1")));}
public void metron_f4348_0()
{        List<BulkMessage<JSONObject>> messages = createMessages(3);        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addSuccess(createDocument(messages.get(0)));    results.addSuccess(createDocument(messages.get(1)));    results.addSuccess(createDocument(messages.get(2)));    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        assertFalse(response.hasErrors());    assertTrue(response.getSuccesses().contains(new MessageId("message1")));    assertTrue(response.getSuccesses().contains(new MessageId("message2")));    assertTrue(response.getSuccesses().contains(new MessageId("message3")));}
public void metron_f4349_0()
{        List<BulkMessage<JSONObject>> messages = createMessages(3);    Exception cause = new Exception();        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addFailure(createDocument(messages.get(0)), cause, "error");    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        assertEquals(0, response.getSuccesses().size());    assertEquals(1, response.getErrors().size());    Collection<MessageId> errors = response.getErrors().get(cause);    assertTrue(errors.contains(new MessageId("message1")));}
public void metron_f4350_0()
{        int count = 3;    List<BulkMessage<JSONObject>> messages = createMessages(count);    Exception cause = new Exception();        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addFailure(createDocument(messages.get(0)), cause, "error");    results.addFailure(createDocument(messages.get(1)), cause, "error");    results.addFailure(createDocument(messages.get(2)), cause, "error");    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        assertEquals(0, response.getSuccesses().size());    assertEquals(1, response.getErrors().size());    Collection<MessageId> errors = response.getErrors().get(cause);    assertTrue(errors.contains(new MessageId("message1")));    assertTrue(errors.contains(new MessageId("message2")));    assertTrue(errors.contains(new MessageId("message3")));}
public void metron_f4351_0()
{        int count = 2;    List<BulkMessage<JSONObject>> messages = createMessages(count);    Exception cause = new Exception();        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addFailure(createDocument(messages.get(0)), cause, "error");    results.addSuccess(createDocument(messages.get(1)));    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        assertEquals(1, response.getSuccesses().size());    assertEquals(1, response.getErrors().size());    assertTrue(response.getErrors().get(cause).contains(new MessageId("message1")));    assertTrue(response.getSuccesses().contains(new MessageId("message2")));}
public void metron_f4352_0()
{    List<BulkMessage<JSONObject>> messages = createMessages(1);    JSONObject message = messages.get(0).getMessage();        message.put(Constants.Fields.TIMESTAMP.getName(), new Long(System.currentTimeMillis()).toString());        String timestamp = (String) message.get(Constants.Fields.TIMESTAMP.getName());    String guid = (String) message.get(Constants.GUID);    String sensorType = (String) message.get(Constants.SENSOR_TYPE);    MessageIdBasedDocument document = new MessageIdBasedDocument(message, guid, sensorType, Long.parseLong(timestamp), new MessageId("message1"));        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addSuccess(document);    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        assertFalse(response.hasErrors());    assertTrue(response.getSuccesses().contains(new MessageId("message1")));}
public void metron_f4353_0()
{        List<BulkMessage<JSONObject>> messages = createMessages(1);        assertNotNull(messages.get(0).getMessage().remove(Constants.GUID));        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addSuccess(createDocument(messages.get(0)));    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        assertFalse(response.hasErrors());    assertTrue(response.getSuccesses().contains(new MessageId("message1")));}
public void metron_f4354_0()
{    when(writerConfiguration.isSetDocumentId("bro")).thenReturn(true);    when(writerConfiguration.getFieldNameConverter("bro")).thenReturn("NOOP");    mockStatic(ElasticsearchUtils.class);    when(ElasticsearchUtils.getIndexFormat(globals())).thenReturn(new SimpleDateFormat());    when(ElasticsearchUtils.getIndexName(eq("bro"), any(), eq(writerConfiguration))).thenReturn("bro_index");        List<BulkMessage<JSONObject>> messages = createMessages(3);        MessageIdBasedDocument document1 = createDocument(messages.get(0));    MessageIdBasedDocument document2 = createDocument(messages.get(1));    MessageIdBasedDocument document3 = createDocument(messages.get(2));        document1.setDocumentID(document1.getGuid());    document2.setDocumentID(document1.getGuid());    document3.setDocumentID(document1.getGuid());        BulkDocumentWriterResults<MessageIdBasedDocument> results = new BulkDocumentWriterResults<>();    results.addSuccess(document1);    results.addSuccess(document2);    results.addSuccess(document3);    BulkDocumentWriter<MessageIdBasedDocument> docWriter = mock(BulkDocumentWriter.class);    when(docWriter.write()).thenReturn(results);        ElasticsearchWriter esWriter = new ElasticsearchWriter();    esWriter.setDocumentWriter(docWriter);    esWriter.init(stormConf, writerConfiguration);    BulkWriterResponse response = esWriter.write("bro", writerConfiguration, messages);        verify(docWriter, times(1)).addDocument(document1, "bro_index");    verify(docWriter, times(1)).addDocument(document1, "bro_index");    verify(docWriter, times(1)).addDocument(document1, "bro_index");        assertFalse(response.hasErrors());    assertTrue(response.getSuccesses().contains(new MessageId("message1")));    assertTrue(response.getSuccesses().contains(new MessageId("message2")));    assertTrue(response.getSuccesses().contains(new MessageId("message3")));}
private MessageIdBasedDocument metron_f4355_0(BulkMessage<JSONObject> bulkWriterMessage)
{    MessageId messageId = bulkWriterMessage.getId();    JSONObject message = bulkWriterMessage.getMessage();    Long timestamp = (Long) bulkWriterMessage.getMessage().get(Constants.Fields.TIMESTAMP.getName());    String guid = (String) message.get(Constants.GUID);    String sensorType = (String) message.get(Constants.SENSOR_TYPE);    return new MessageIdBasedDocument(message, guid, sensorType, timestamp, messageId);}
private JSONObject metron_f4356_0()
{    JSONObject message = new JSONObject();    message.put(Constants.GUID, UUID.randomUUID().toString());    message.put(Constants.Fields.TIMESTAMP.getName(), System.currentTimeMillis());    message.put(Constants.Fields.SRC_ADDR.getName(), "192.168.1.1");    message.put(Constants.SENSOR_TYPE, "bro");    return message;}
private Map<String, Object> metron_f4357_0()
{    Map<String, Object> globals = new HashMap<>();    globals.put("es.date.format", "yyyy.MM.dd.HH");    return globals;}
private List<BulkMessage<JSONObject>> metron_f4358_0(int count)
{    List<BulkMessage<JSONObject>> messages = new ArrayList<>();    for (int i = 0; i < count; i++) {        messages.add(new BulkMessage<>(new MessageId("message" + (i + 1)), message()));    }    return messages;}
public FieldNameConverter metron_f4359_0()
{    return fieldNameConverter;}
public InMemoryComponent metron_f4360_0(final Properties topologyProperties)
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put("es.clustername", "metron");            put("es.port", "9200");            put("es.ip", "localhost");            put("es.date.format", dateFormat);        }    };    AccessConfig accessConfig = new AccessConfig();    accessConfig.setGlobalConfigSupplier(() -> globalConfig);    return new ElasticSearchComponent.Builder().withHttpPort(9211).withIndexDir(new File(indexDir)).withMapping(index, "yaf_doc", mapping).withAccessConfig(accessConfig).build();}
public Processor<List<Map<String, Object>>> metron_f4361_0(final List<byte[]> inputMessages)
{    return new Processor<List<Map<String, Object>>>() {        List<Map<String, Object>> docs = null;        List<byte[]> errors = null;        final AtomicInteger missCount = new AtomicInteger(0);        @Override        public ReadinessState process(ComponentRunner runner) {            ElasticSearchComponent elasticSearchComponent = runner.getComponent("search", ElasticSearchComponent.class);            KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);            if (elasticSearchComponent.hasIndex(index)) {                try {                    docs = elasticSearchComponent.getAllIndexedDocs(index, testSensorType + "_doc");                } catch (IOException e) {                    throw new IllegalStateException("Unable to retrieve indexed documents.", e);                }                if (docs.size() < inputMessages.size()) {                    errors = kafkaComponent.readMessages(ERROR_TOPIC);                    if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {                        return ReadinessState.READY;                    }                    return ReadinessState.NOT_READY;                } else {                    return ReadinessState.READY;                }            } else {                return ReadinessState.NOT_READY;            }        }        @Override        public ProcessorResult<List<Map<String, Object>>> getResult() {            ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();            return builder.withResult(docs).withProcessErrors(errors).build();        }    };}
public ReadinessState metron_f4362_0(ComponentRunner runner)
{    ElasticSearchComponent elasticSearchComponent = runner.getComponent("search", ElasticSearchComponent.class);    KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);    if (elasticSearchComponent.hasIndex(index)) {        try {            docs = elasticSearchComponent.getAllIndexedDocs(index, testSensorType + "_doc");        } catch (IOException e) {            throw new IllegalStateException("Unable to retrieve indexed documents.", e);        }        if (docs.size() < inputMessages.size()) {            errors = kafkaComponent.readMessages(ERROR_TOPIC);            if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {                return ReadinessState.READY;            }            return ReadinessState.NOT_READY;        } else {            return ReadinessState.READY;        }    } else {        return ReadinessState.NOT_READY;    }}
public ProcessorResult<List<Map<String, Object>>> metron_f4363_0()
{    ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();    return builder.withResult(docs).withProcessErrors(errors).build();}
public void metron_f4364_0(Properties topologyProperties)
{    topologyProperties.setProperty("es.clustername", "metron");    topologyProperties.setProperty("es.port", "9300");    topologyProperties.setProperty("es.ip", "localhost");    topologyProperties.setProperty("ra_indexing_writer_class_name", "org.apache.metron.elasticsearch.writer.ElasticsearchWriter");    topologyProperties.setProperty("ra_indexing_kafka_start", "UNCOMMITTED_EARLIEST");    topologyProperties.setProperty("ra_indexing_workers", "1");    topologyProperties.setProperty("ra_indexing_acker_executors", "0");    topologyProperties.setProperty("ra_indexing_topology_max_spout_pending", "");    topologyProperties.setProperty("ra_indexing_kafka_spout_parallelism", "1");    topologyProperties.setProperty("ra_indexing_writer_parallelism", "1");}
public String metron_f4365_0(String field)
{    return field;}
public String metron_f4366_0()
{    return "./src/main/config/elasticsearch.properties.j2";}
public String metron_f4367_0()
{    return "../../metron-indexing/metron-indexing-storm/src/main/flux/indexing/random_access/remote.yaml";}
public void metron_f4368_0()
{}
public void metron_f4369_0(CacheKey value)
{}
public JSONObject metron_f4370_1(CacheKey k)
{    String metadata = k.coerceValue(String.class);    JSONObject output = new JSONObject();        output.putAll(getCIFObject(metadata));    return output;}
protected Map metron_f4371_1(String key)
{        Get get = new Get(key.getBytes(StandardCharsets.UTF_8));    Result rs;    Map output = new HashMap();    try {        rs = table.get(get);        for (KeyValue kv : rs.raw()) output.put(new String(kv.getQualifier(), StandardCharsets.UTF_8), "Y");    } catch (IOException e) {                e.printStackTrace();    }    return output;}
public boolean metron_f4372_1(Map<String, Object> config)
{        Configuration conf = null;    conf = HBaseConfiguration.create();    conf.set("hbase.zookeeper.quorum", _quorum);    conf.set("hbase.zookeeper.property.clientPort", _port);    try {                        Connection connection = ConnectionFactory.createConnection(conf);        table = connection.getTable(TableName.valueOf(_tableName));        return true;    } catch (IOException e) {                e.printStackTrace();    }    return false;}
public void metron_f4373_0(Map<String, Object> config)
{}
public String metron_f4374_0(String metadata)
{    return null;}
public String metron_f4375_0(String metadata)
{    return null;}
public String metron_f4376_0(String metadata)
{    return null;}
public void metron_f4377_0()
{}
public String metron_f4378_0(CacheKey value)
{    return value.getField();}
public void metron_f4379_0(CacheKey value)
{}
public String metron_f4380_0(CacheKey value)
{    return value.getField();}
public JSONObject metron_f4381_0(CacheKey value)
{    JSONObject enriched = new JSONObject();    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(value.coerceValue(String.class));    if (!result.isPresent()) {        return new JSONObject();    }    enriched = new JSONObject(result.get());    _LOG.trace("GEO Enrichment success: {}", enriched);    return enriched;}
public boolean metron_f4382_0(Map<String, Object> config)
{    GeoLiteCityDatabase.INSTANCE.update((String) config.get(GeoLiteCityDatabase.GEO_HDFS_FILE));    return true;}
public void metron_f4383_0(Map<String, Object> config)
{    GeoLiteCityDatabase.INSTANCE.updateIfNecessary(config);}
public void metron_f4384_0()
{}
public void metron_f4385_0()
{}
public String metron_f4386_0(CacheKey value)
{    return value.getField();}
public boolean metron_f4387_0(Map<String, Object> config)
{    if (_known_hosts.size() > 0)        return true;    else        return false;}
public void metron_f4388_0(Map<String, Object> config)
{}
public void metron_f4389_0(CacheKey value)
{}
public JSONObject metron_f4390_0(CacheKey k)
{    String metadata = k.coerceValue(String.class);    if (!_known_hosts.containsKey(metadata))        return new JSONObject();    JSONObject enrichment = new JSONObject();    String prefix = "known_info.";    JSONObject knownInfo = _known_hosts.get(metadata);    for (Object key : knownInfo.keySet()) {        enrichment.put(prefix + key, knownInfo.get(key));    }        return enrichment;}
public boolean metron_f4391_0(Map<String, Object> config)
{    if (_known_hosts.size() > 0)        return true;    else        return false;}
public void metron_f4392_0(Map<String, Object> config)
{}
public String metron_f4393_0(CacheKey value)
{    return value.getField();}
public void metron_f4394_0(CacheKey value)
{}
public JSONObject metron_f4395_0(CacheKey metadata)
{    if (!_known_hosts.containsKey(metadata.getValue()))        return new JSONObject();    JSONObject enrichment = new JSONObject();    enrichment.put("known_info", (JSONObject) _known_hosts.get(metadata.getValue()));    return enrichment;}
public String metron_f4396_0()
{    return host;}
public void metron_f4397_0(String host)
{    this.host = host;}
public int metron_f4398_0()
{    return port;}
public void metron_f4399_0(int port)
{    this.port = port;}
public String metron_f4400_0()
{    return username;}
public void metron_f4401_0(String username)
{    this.username = username;}
public String metron_f4402_0()
{    return password;}
public void metron_f4403_0(String password)
{    this.password = password;}
public String metron_f4404_0()
{    return table;}
public void metron_f4405_0(String table)
{    this.table = table;}
protected boolean metron_f4406_1()
{    boolean isClosed = statement == null || connection == null;    if (!isClosed) {        try {            isClosed = statement.isClosed() || connection.isClosed();        } catch (SQLException e) {            _            isClosed = true;        }    }    return isClosed;}
protected boolean metron_f4407_0()
{    if (isConnectionClosed()) {        this.cleanup();        return this.initializeAdapter(null);    }    return true;}
public void metron_f4408_0(Statement statement)
{    this.statement = statement;}
public JdbcAdapter metron_f4409_0(JdbcConfig config)
{    this.config = config;    this.host = config.getHost();    return this;}
public String metron_f4412_0()
{    return "com.mysql.jdbc.Driver";}
public String metron_f4413_0()
{    StringBuilder url = new StringBuilder();    url.append("jdbc:mysql://").append(host);    if (port > 0) {        url.append(":").append(port);    }    url.append("/").append(table);    url.append("?user=").append(username);    url.append("&password=").append(password);    return url.toString();}
public String metron_f4414_0()
{    return simpleName;}
public Object metron_f4415_0(Map<String, Object> map)
{    return getter.apply(map);}
public void metron_f4416_0(Map<String, Object> map, Object val)
{    map.put(simpleName, val);}
public String metron_f4417_0()
{    return ASN_HDFS_FILE;}
public String metron_f4418_0()
{    return ASN_HDFS_FILE_DEFAULT;}
public void metron_f4419_0()
{    writeLock.lock();}
public void metron_f4420_0()
{    writeLock.unlock();}
public DatabaseReader metron_f4421_0()
{    return reader;}
public void metron_f4422_0(DatabaseReader reader)
{    GeoLiteAsnDatabase.reader = reader;}
public synchronized void metron_f4423_0(Map<String, Object> globalConfig)
{        LOG.trace("Determining if GeoLiteAsnDatabase update required");    String hdfsFile = ASN_HDFS_FILE_DEFAULT;    if (globalConfig != null) {        hdfsFile = (String) globalConfig.getOrDefault(ASN_HDFS_FILE, ASN_HDFS_FILE_DEFAULT);    }        if (reader == null || !hdfsLoc.equals(hdfsFile)) {                hdfsLoc = hdfsFile;        update(hdfsFile);    } else {        LOG.trace("Update to GeoLiteAsnDatabase unnecessary");    }}
public Optional<Map<String, Object>> metron_f4424_1(String ip)
{    if (MaxMindDbUtilities.invalidIp(ip)) {        return Optional.empty();    }    try {        readLock.lock();        InetAddress addr = InetAddress.getByName(ip);        AsnResponse asnResponse = reader.asn(addr);        HashMap<String, Object> asnInfo = new HashMap<>();        AsnProps.ASN.set(asnInfo, asnResponse.getAutonomousSystemNumber());        AsnProps.ASO.set(asnInfo, MaxMindDbUtilities.convertNullToEmptyString(asnResponse.getAutonomousSystemOrganization()));        AsnProps.NETWORK.set(asnInfo, MaxMindDbUtilities.convertNullToEmptyString(asnResponse.getIpAddress()));        return Optional.of(asnInfo);    } catch (UnknownHostException | AddressNotFoundException e) {            } catch (GeoIp2Exception | IOException e) {            } finally {        readLock.unlock();    }    return Optional.empty();}
public String metron_f4425_0()
{    return simpleName;}
public String metron_f4426_0(Map<String, String> map)
{    return getter.apply(map);}
public void metron_f4427_0(Map<String, String> map, String val)
{    map.put(simpleName, val);}
public String metron_f4428_0()
{    return GEO_HDFS_FILE;}
public String metron_f4429_0()
{    return GEO_HDFS_FILE_DEFAULT;}
public void metron_f4430_0()
{    writeLock.lock();}
public void metron_f4431_0()
{    writeLock.unlock();}
public DatabaseReader metron_f4432_0()
{    return reader;}
public void metron_f4433_0(DatabaseReader reader)
{    GeoLiteCityDatabase.reader = reader;}
public synchronized void metron_f4434_0(Map<String, Object> globalConfig)
{        LOG.trace("Determining if GeoIpDatabase update required");    String hdfsFile = GEO_HDFS_FILE_DEFAULT;    if (globalConfig != null) {        hdfsFile = (String) globalConfig.getOrDefault(GEO_HDFS_FILE, GEO_HDFS_FILE_DEFAULT);        hdfsFile = determineHdfsDirWithFallback(globalConfig, hdfsFile, GEO_HDFS_FILE_DEFAULT_FALLBACK);    }        if (reader == null || !hdfsLoc.equals(hdfsFile)) {                hdfsLoc = hdfsFile;        update(hdfsFile);    } else {        LOG.trace("Update to GeoLiteCity2Database unnecessary");    }}
protected String metron_f4435_1(Map<String, Object> globalConfig, String hdfsFile, String hdfsFallbackFile)
{        if (!globalConfig.containsKey(GEO_HDFS_FILE)) {        FileSystem fs = MaxMindDbUtilities.getFileSystem();        try {                        if (hdfsPathsExist(fs, hdfsFile, hdfsFallbackFile)) {                hdfsFile = hdfsFallbackFile;            }        } catch (IOException e) {                            }    }    return hdfsFile;}
protected boolean metron_f4436_0(FileSystem fs, String hdfsFile, String fallbackFile) throws IOException
{    return !fs.exists(new Path(hdfsFile)) && fs.exists(new Path(fallbackFile));}
public Optional<Map<String, String>> metron_f4437_1(String ip)
{    if (MaxMindDbUtilities.invalidIp(ip)) {        return Optional.empty();    }    try {        readLock.lock();        InetAddress addr = InetAddress.getByName(ip);        CityResponse cityResponse = reader.city(addr);        HashMap<String, String> geoInfo = new HashMap<>();        Country country = cityResponse.getCountry();        City city = cityResponse.getCity();        Postal postal = cityResponse.getPostal();        Location location = cityResponse.getLocation();        GeoProps.LOC_ID.set(geoInfo, MaxMindDbUtilities.convertNullToEmptyString(city.getGeoNameId()));        GeoProps.COUNTRY.set(geoInfo, MaxMindDbUtilities.convertNullToEmptyString(country.getIsoCode()));        GeoProps.CITY.set(geoInfo, MaxMindDbUtilities.convertNullToEmptyString(city.getName()));        GeoProps.POSTAL_CODE.set(geoInfo, MaxMindDbUtilities.convertNullToEmptyString(postal.getCode()));        GeoProps.DMA_CODE.set(geoInfo, MaxMindDbUtilities.convertNullToEmptyString(location.getMetroCode()));        Double latitudeRaw = location.getLatitude();        String latitude = MaxMindDbUtilities.convertNullToEmptyString(latitudeRaw);        GeoProps.LATITUDE.set(geoInfo, latitude);        Double longitudeRaw = location.getLongitude();        String longitude = MaxMindDbUtilities.convertNullToEmptyString(longitudeRaw);        GeoProps.LONGITUDE.set(geoInfo, longitude);        if (latitudeRaw == null || longitudeRaw == null) {            GeoProps.LOCATION_POINT.set(geoInfo, "");        } else {            GeoProps.LOCATION_POINT.set(geoInfo, latitude + "," + longitude);        }        return Optional.of(geoInfo);    } catch (UnknownHostException | AddressNotFoundException e) {            } catch (GeoIp2Exception | IOException e) {            } finally {        readLock.unlock();    }    return Optional.empty();}
public Optional<WGS84Point> metron_f4438_1(Map<String, String> geoInfo)
{    String latitude = GeoProps.LATITUDE.get(geoInfo);    String longitude = GeoProps.LONGITUDE.get(geoInfo);    if (latitude == null || longitude == null) {        return Optional.empty();    }    try {        double latD = Double.parseDouble(latitude);        double longD = Double.parseDouble(longitude);        return Optional.of(new WGS84Point(latD, longD));    } catch (NumberFormatException nfe) {                return Optional.empty();    }}
public double metron_f4439_0(WGS84Point point1, WGS84Point point2)
{    return strat.distance(point1, point2);}
public Optional<String> metron_f4440_0(Double latitude, Double longitude, int precision)
{    if (latitude == null || longitude == null) {        return Optional.empty();    }    return computeHash(new WGS84Point(latitude, longitude), precision);}
public Optional<String> metron_f4441_0(WGS84Point point, int precision)
{    GeoHash hash = GeoHash.withCharacterPrecision(point.getLatitude(), point.getLongitude(), precision);    return Optional.of(hash.toBase32());}
public Optional<String> metron_f4442_0(Map<String, String> geoLoc, int precision)
{    Optional<WGS84Point> point = GeoLiteCityDatabase.INSTANCE.toPoint(geoLoc);    if (point.isPresent()) {        return computeHash(point.get(), precision);    } else {        return Optional.empty();    }}
public Optional<WGS84Point> metron_f4443_0(String hash)
{    if (hash == null) {        return Optional.empty();    }    GeoHash h = GeoHash.fromGeohashString(hash);    return Optional.ofNullable(h == null ? null : h.getPoint());}
public double metron_f4444_0(WGS84Point point1, WGS84Point point2, DistanceStrategy strategy)
{    return strategy.distance(point1, point2);}
public WGS84Point metron_f4445_0(Iterable<String> hashes)
{    Iterable<WGS84Point> points = Iterables.transform(hashes, h -> toPoint(h).orElse(null));    return centroidOfPoints(points);}
public WGS84Point metron_f4446_0(Iterable<WGS84Point> points)
{    Iterable<WGS84Point> nonNullPoints = Iterables.filter(points, p -> p != null);    return centroid(Iterables.transform(nonNullPoints, p -> new AbstractMap.SimpleImmutableEntry<>(p, 1)));}
public WGS84Point metron_f4447_0(Map<String, Number> points)
{    Iterable<Map.Entry<WGS84Point, Number>> weightedPoints = Iterables.transform(points.entrySet(), kv -> {        WGS84Point pt = toPoint(kv.getKey()).orElse(null);        return new AbstractMap.SimpleImmutableEntry<>(pt, kv.getValue());    });    return centroid(Iterables.filter(weightedPoints, kv -> kv.getKey() != null));}
private WGS84Point metron_f4448_0(Iterable<Map.Entry<WGS84Point, Number>> points)
{    double x = 0d, y = 0d, z = 0d, totalWeight = 0d;    int n = 0;    /**     * So, it's first important to realize that long/lat are not cartesian, so simple weighted averaging     * is insufficient here as it denies the fact that we're not living on a flat square, but rather the surface of     * an ellipsoid.  A crow, for instance, does not fly a straight line to an observer outside of Earth, but     * rather flies across the arc tracing the surface of earth, or a "great-earth arc".  When computing the centroid     * you want to find the centroid of the points with distance defined as the great-earth arc.     *     * The general strategy is to:     * 1. Change coordinate systems from degrees on a WGS84 projection (e.g. lat/long)     *    to a 3 dimensional cartesian surface atop a sphere approximating the earth.     * 2. Compute a weighted average of the cartesian coordinates     * 3. Change coordinate systems of the resulting centroid in cartesian space back to lat/long     *     * This is generally detailed at http://www.geomidpoint.com/example.html     */    for (Map.Entry<WGS84Point, Number> weightedPoint : points) {        WGS84Point pt = weightedPoint.getKey();        if (pt == null) {            continue;        }        double latRad = Math.toRadians(pt.getLatitude());        double longRad = Math.toRadians(pt.getLongitude());        double cosLat = Math.cos(latRad);        /*       Convert from lat/long coordinates to cartesian coordinates.  The cartesian coordinate system is a right-hand,       rectangular, three-dimensional, earth-fixed coordinate system       with an origin at (0, 0, 0). The Z-axis, is parrallel to the axis of rotation of the earth. The Z-coordinate       is positive toward the North pole. The X-Y plane lies in the equatorial plane. The X-axis lies along the       intersection of the plane containing the prime meridian and the equatorial plane. The X-coordinate is positive       toward the intersection of the prime meridian and equator.       Please see https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates       for more information about this coordinate transformation.       */        double ptX = cosLat * Math.cos(longRad);        double ptY = cosLat * Math.sin(longRad);        double ptZ = Math.sin(latRad);        double weight = weightedPoint.getValue().doubleValue();        x += ptX * weight;        y += ptY * weight;        z += ptZ * weight;        n++;        totalWeight += weight;    }    if (n == 0) {        return null;    }        x /= totalWeight;    y /= totalWeight;    z /= totalWeight;        double longitude = Math.atan2(y, x);    double hypotenuse = Math.sqrt(x * x + y * y);    double latitude = Math.atan2(z, hypotenuse);        return new WGS84Point(Math.toDegrees(latitude), Math.toDegrees(longitude));}
public double metron_f4449_0(Iterable<String> hashes, DistanceStrategy strategy)
{    Iterable<WGS84Point> points = Iterables.transform(hashes, s -> toPoint(s).orElse(null));    return maxDistancePoints(Iterables.filter(points, p -> p != null), strategy);}
public double metron_f4450_0(Iterable<WGS84Point> points, DistanceStrategy strategy)
{        int i = 0;    double max = Double.NaN;    for (WGS84Point pt1 : points) {        int j = 0;        for (WGS84Point pt2 : points) {            if (j <= i) {                double d = strategy.distance(pt1, pt2);                if (Double.isNaN(max) || d > max) {                    max = d;                }                j++;            } else {                break;            }        }        i++;    }    return max;}
 void metron_f4451_1(String hdfsFile)
{        if (hdfsFile == null || hdfsFile.isEmpty()) {                hdfsFile = getHdfsFileDefault();    }    FileSystem fs = MaxMindDbUtilities.getFileSystem();    if (hdfsFile.endsWith(MaxMindDatabase.EXTENSION_MMDB)) {        lockIfNecessary();        try (BufferedInputStream is = new BufferedInputStream(fs.open(new Path(hdfsFile)))) {            setReader(MaxMindDbUtilities.readNewDatabase(getReader(), hdfsFile, is));        } catch (IOException e) {            MaxMindDbUtilities.handleDatabaseIOException(hdfsFile, e);        } finally {            unlockIfNecessary();        }    } else if (hdfsFile.endsWith(MaxMindDatabase.EXTENSION_MMDB_GZ)) {        lockIfNecessary();        try (GZIPInputStream is = new GZIPInputStream(fs.open(new Path(hdfsFile)))) {            setReader(MaxMindDbUtilities.readNewDatabase(getReader(), hdfsFile, is));        } catch (IOException e) {            MaxMindDbUtilities.handleDatabaseIOException(hdfsFile, e);        } finally {            unlockIfNecessary();        }    } else if (hdfsFile.endsWith(MaxMindDatabase.EXTENSION_TAR_GZ)) {        lockIfNecessary();        try (TarArchiveInputStream is = new TarArchiveInputStream(new GZIPInputStream(fs.open(new Path(hdfsFile))))) {                        TarArchiveEntry entry = is.getNextTarEntry();            while (entry != null) {                if (entry.isFile() && entry.getName().endsWith(MaxMindDatabase.EXTENSION_MMDB)) {                    try (InputStream mmdb = new BufferedInputStream(is)) {                                                setReader(MaxMindDbUtilities.readNewDatabase(getReader(), hdfsFile, mmdb));                                                break;                    }                }                entry = is.getNextTarEntry();            }        } catch (IOException e) {            MaxMindDbUtilities.handleDatabaseIOException(hdfsFile, e);        } finally {            unlockIfNecessary();        }    }}
public static boolean metron_f4452_1(String ip)
{    LOG.trace("Called validateIp({})", ip);    InetAddress addr;    try {        addr = InetAddress.getByName(ip);    } catch (UnknownHostException e) {                return true;    }    if (isIneligibleAddress(ip, addr)) {                return true;    }    return false;}
public static boolean metron_f4453_0(String ipStr, InetAddress addr)
{    return addr.isAnyLocalAddress() || addr.isLoopbackAddress() || addr.isSiteLocalAddress() || addr.isMulticastAddress() || !ipvalidator.isValidInet4Address(ipStr);}
public static void metron_f4454_1(String hdfsFile, IOException e)
{        throw new IllegalStateException("Unable to update MaxMind database");}
public static DatabaseReader metron_f4455_1(DatabaseReader reader, String hdfsFile, InputStream is) throws IOException
{            DatabaseReader newReader = new DatabaseReader.Builder(is).withCache(new CHMCache()).build();        if (reader != null) {        reader.close();    }        return newReader;}
public static FileSystem metron_f4456_1()
{    FileSystem fs;    try {        fs = FileSystem.get(new Configuration());    } catch (IOException e) {                throw new IllegalStateException("Unable to get HDFS FileSystem");    }    return fs;}
public static String metron_f4457_0(Object raw)
{    return raw == null ? "" : String.valueOf(raw);}
public SimpleHBaseAdapter metron_f4458_0(SimpleHBaseConfig config)
{    this.config = config;    return this;}
public void metron_f4459_0(CacheKey value)
{}
public boolean metron_f4460_0()
{    return lookup != null && lookup.getTable() != null;}
public JSONObject metron_f4461_1(CacheKey value)
{    JSONObject enriched = new JSONObject();    if (!isInitialized()) {        initializeAdapter(null);    }    List<String> enrichmentTypes = value.getConfig().getEnrichment().getFieldToTypeMap().get(EnrichmentUtils.toTopLevelField(value.getField()));    if (isInitialized() && enrichmentTypes != null && value.getValue() != null) {        try {            for (LookupKV<EnrichmentKey, EnrichmentValue> kv : lookup.get(Iterables.transform(enrichmentTypes, new EnrichmentUtils.TypeToKey(value.coerceValue(String.class), lookup.getTable(), value.getConfig().getEnrichment())), false)) {                if (kv != null && kv.getValue() != null && kv.getValue().getMetadata() != null) {                    for (Map.Entry<String, Object> values : kv.getValue().getMetadata().entrySet()) {                        enriched.put(kv.getKey().type + "." + values.getKey(), values.getValue());                    }                    LOG.trace("Enriched type {} => {}", () -> kv.getKey().type, () -> enriched);                }            }        } catch (IOException e) {                        initializeAdapter(null);            throw new RuntimeException("Unable to retrieve value: " + e.getMessage(), e);        }    }    LOG.trace("SimpleHBaseAdapter succeeded: {}", enriched);    return enriched;}
public boolean metron_f4462_1(Map<String, Object> configuration)
{    String hbaseTable = config.getHBaseTable();    Configuration hbaseConfig = HBaseConfiguration.create();    try {        lookup = new EnrichmentLookup(config.getProvider().getTable(hbaseConfig, hbaseTable), config.getHBaseCF(), new NoopAccessTracker());    } catch (IOException e) {                return false;    }    return true;}
public void metron_f4463_0(Map<String, Object> config)
{}
public void metron_f4464_1()
{    try {        lookup.close();    } catch (Exception e) {            }}
public String metron_f4465_0(CacheKey value)
{    return value.getField();}
public String metron_f4466_0()
{    return hBaseTable;}
public String metron_f4467_0()
{    return hBaseCF;}
public TableProvider metron_f4468_0()
{    return provider;}
public SimpleHBaseConfig metron_f4469_0(String connectorImpl)
{    provider = EnrichmentUtils.getTableProvider(connectorImpl, new HTableProvider());    return this;}
public SimpleHBaseConfig metron_f4470_0(String hBaseTable)
{    this.hBaseTable = hBaseTable;    return this;}
public SimpleHBaseConfig metron_f4471_0(String cf)
{    this.hBaseCF = cf;    return this;}
public ConfigHandler metron_f4472_0(SensorEnrichmentConfig cacheKey)
{    return func.apply(cacheKey);}
public StellarAdapter metron_f4473_0(String enrichmentType)
{    this.enrichmentType = enrichmentType;    return this;}
public String metron_f4474_0(CacheKey value)
{    return "";}
public void metron_f4475_0(CacheKey value)
{}
public String metron_f4476_0(String enrichmentType, String field)
{    return field;}
public static Iterable<Map.Entry<String, Object>> metron_f4477_0(ConfigHandler handler, String field)
{    if (field.length() == 0) {        return handler.getType().toConfig(handler.getConfig());    } else {        Map<String, Object> groupStatements = (Map<String, Object>) handler.getConfig();        return handler.getType().toConfig(groupStatements.get(field));    }}
public JSONObject metron_f4479_0(CacheKey value)
{    Context stellarContext = (Context) value.getConfig().getConfiguration().get(STELLAR_CONTEXT_CONF);    ConfigHandler handler = getHandler.apply(value.getConfig());    Map<String, Object> globalConfig = value.getConfig().getConfiguration();    Map<String, Object> sensorConfig = value.getConfig().getEnrichment().getConfig();    if (handler == null) {        _LOG.trace("Stellar ConfigHandler is null.");        return new JSONObject();    }    Long slowLogThreshold = null;    if (_PERF_LOG.isDebugEnabled()) {        slowLogThreshold = ConversionUtils.convert(globalConfig.getOrDefault(STELLAR_SLOW_LOG, STELLAR_SLOW_LOG_DEFAULT), Long.class);    }            Map<String, Object> message = new HashMap<>(value.getValue(Map.class));    VariableResolver resolver = new MapVariableResolver(message, sensorConfig, globalConfig);    StellarProcessor processor = new StellarProcessor();    JSONObject enriched = process(message, handler, value.getField(), slowLogThreshold, processor, resolver, stellarContext);    _LOG.trace("Stellar Enrichment Success: {}", enriched);    return enriched;}
public boolean metron_f4480_0(Map<String, Object> config)
{    getHandler = EnrichmentType.valueOf(enrichmentType);    return true;}
public void metron_f4481_0(Map<String, Object> config)
{}
public void metron_f4482_0()
{}
public ThreatIntelAdapter metron_f4483_0(ThreatIntelConfig config)
{    this.config = config;    return this;}
public void metron_f4484_0(CacheKey value)
{    List<String> enrichmentTypes = value.getConfig().getThreatIntel().getFieldToTypeMap().get(value.getField());    if (enrichmentTypes != null) {        for (String enrichmentType : enrichmentTypes) {            lookup.getAccessTracker().logAccess(new EnrichmentKey(enrichmentType, value.coerceValue(String.class)));        }    }}
public JSONObject metron_f4485_1(CacheKey value)
{    if (!isInitialized()) {        initializeAdapter(null);    }    JSONObject enriched = new JSONObject();    List<String> enrichmentTypes = value.getConfig().getThreatIntel().getFieldToTypeMap().get(EnrichmentUtils.toTopLevelField(value.getField()));    if (isInitialized() && enrichmentTypes != null) {        int i = 0;        try {            for (Boolean isThreat : lookup.exists(Iterables.transform(enrichmentTypes, new EnrichmentUtils.TypeToKey(value.coerceValue(String.class), lookup.getTable(), value.getConfig().getThreatIntel())), false)) {                String enrichmentType = enrichmentTypes.get(i++);                if (isThreat) {                    enriched.put(enrichmentType, "alert");                    LOG.trace("Theat Intel Enriched value => {}", enriched);                }            }        } catch (IOException e) {                        initializeAdapter(null);            throw new RuntimeException("Theat Intel Unable to retrieve value", e);        }    }    LOG.trace("Threat Intel Enrichment Success: {}", enriched);    return enriched;}
public boolean metron_f4486_0()
{    return lookup != null && lookup.getTable() != null;}
public boolean metron_f4487_1(Map<String, Object> configuration)
{    PersistentAccessTracker accessTracker;    String hbaseTable = config.getHBaseTable();    int expectedInsertions = config.getExpectedInsertions();    double falsePositives = config.getFalsePositiveRate();    String trackerHBaseTable = config.getTrackerHBaseTable();    String trackerHBaseCF = config.getTrackerHBaseCF();    long millisecondsBetweenPersist = config.getMillisecondsBetweenPersists();    BloomAccessTracker bat = new BloomAccessTracker(hbaseTable, expectedInsertions, falsePositives);    Configuration hbaseConfig = HBaseConfiguration.create();    try {        accessTracker = new PersistentAccessTracker(hbaseTable, UUID.randomUUID().toString(), config.getProvider().getTable(hbaseConfig, trackerHBaseTable), trackerHBaseCF, bat, millisecondsBetweenPersist);        lookup = new EnrichmentLookup(config.getProvider().getTable(hbaseConfig, hbaseTable), config.getHBaseCF(), accessTracker);    } catch (IOException e) {                return false;    }    return true;}
public void metron_f4488_0(Map<String, Object> config)
{}
public void metron_f4489_0()
{    try {        lookup.close();    } catch (Exception e) {        throw new RuntimeException("Unable to cleanup access tracker", e);    }}
public String metron_f4490_0(CacheKey value)
{    return value.getField();}
public String metron_f4491_0()
{    return hBaseTable;}
public int metron_f4492_0()
{    return expectedInsertions;}
public double metron_f4493_0()
{    return falsePositiveRate;}
public String metron_f4494_0()
{    return trackerHBaseTable;}
public String metron_f4495_0()
{    return trackerHBaseCF;}
public long metron_f4496_0()
{    return millisecondsBetweenPersists;}
public String metron_f4497_0()
{    return hBaseCF;}
public TableProvider metron_f4498_0()
{    return provider;}
public ThreatIntelConfig metron_f4499_0(String connectorImpl)
{    provider = EnrichmentUtils.getTableProvider(connectorImpl, new HTableProvider());    return this;}
public ThreatIntelConfig metron_f4500_0(String hBaseTable)
{    this.trackerHBaseTable = hBaseTable;    return this;}
public ThreatIntelConfig metron_f4501_0(String cf)
{    this.trackerHBaseCF = cf;    return this;}
public ThreatIntelConfig metron_f4502_0(String hBaseTable)
{    this.hBaseTable = hBaseTable;    return this;}
public ThreatIntelConfig metron_f4503_0(String cf)
{    this.hBaseCF = cf;    return this;}
public ThreatIntelConfig metron_f4504_0(double falsePositiveRate)
{    this.falsePositiveRate = falsePositiveRate;    return this;}
public ThreatIntelConfig metron_f4505_0(int expectedInsertions)
{    this.expectedInsertions = expectedInsertions;    return this;}
public ThreatIntelConfig metron_f4506_0(long millisecondsBetweenPersists)
{    this.millisecondsBetweenPersists = millisecondsBetweenPersists;    return this;}
public String metron_f4507_0()
{    return field;}
public Object metron_f4508_0()
{    return value;}
public T metron_f4509_0(Class<T> clazz)
{    return clazz.cast(getValue());}
public T metron_f4510_0(Class<T> clazz)
{    return ConversionUtils.convert(getValue(), clazz);}
public SensorEnrichmentConfig metron_f4511_0()
{    return config;}
public String metron_f4512_0()
{    return "CacheKey{" + "field='" + field + '\'' + ", value='" + value + '\'' + '}';}
public boolean metron_f4513_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    CacheKey cacheKey = (CacheKey) o;    if (getField() != null ? !getField().equals(cacheKey.getField()) : cacheKey.getField() != null)        return false;    if (getValue() != null ? !getValue().equals(cacheKey.getValue()) : cacheKey.getValue() != null)        return false;    return config != null ? config.equals(cacheKey.config) : cacheKey.config == null;}
public int metron_f4514_0()
{    int result = getField() != null ? getField().hashCode() : 0;    result = 31 * result + (getValue() != null ? getValue().hashCode() : 0);    result = 31 * result + (config != null ? config.hashCode() : 0);    return result;}
public Object metron_f4515_1(String s) throws Exception
{        if (StringUtils.isEmpty(s)) {        throw new IllegalArgumentException("Path cannot be empty");    }    Object object = null;    Path p = new Path(s);    if (fs.exists(p)) {        if (fs.getFileStatus(p).getLen() <= objectCacheConfig.getMaxFileSize()) {            try (InputStream is = new BufferedInputStream(fs.open(p))) {                byte[] serialized = IOUtils.toByteArray(is);                if (serialized.length > 0) {                    object = SerDeUtils.fromBytes(serialized, Object.class);                }            }        } else {            throw new IllegalArgumentException(String.format("File at path '%s' is larger than the configured max file size of %s", p, objectCacheConfig.getMaxFileSize()));        }    } else {        throw new IllegalArgumentException(String.format("Path '%s' could not be found in HDFS", s));    }    return object;}
public Object metron_f4516_0(String path)
{    return cache.get(path);}
public void metron_f4517_0(ObjectCacheConfig config)
{    try {        lock.writeLock().lock();        cache = setupCache(config);    } catch (IOException e) {        throw new IllegalStateException("Unable to initialize: " + e.getMessage(), e);    } finally {        lock.writeLock().unlock();    }}
public boolean metron_f4518_0()
{    try {        lock.readLock().lock();        return cache != null;    } finally {        lock.readLock().unlock();    }}
protected LoadingCache<String, Object> metron_f4519_1(ObjectCacheConfig config) throws IOException
{        return Caffeine.newBuilder().maximumSize(config.getCacheSize()).expireAfterWrite(config.getCacheExpiration(), config.getTimeUnit()).removalListener((path, value, removalCause) -> {            }).build(new Loader(new Configuration(), config));}
public boolean metron_f4520_0()
{    return cache == null || cache.estimatedSize() == 0;}
public boolean metron_f4521_0(String key)
{    return cache != null && cache.asMap().containsKey(key);}
public long metron_f4522_0()
{    return cacheSize;}
public void metron_f4523_0(long cacheSize)
{    this.cacheSize = cacheSize;}
public long metron_f4524_0()
{    return cacheExpiration;}
public void metron_f4525_0(long cacheExpiration)
{    this.cacheExpiration = cacheExpiration;}
public TimeUnit metron_f4526_0()
{    return timeUnit;}
public void metron_f4527_0(TimeUnit timeUnit)
{    this.timeUnit = timeUnit;}
public long metron_f4528_0()
{    return maxFileSize;}
public void metron_f4529_0(long maxFileSize)
{    this.maxFileSize = maxFileSize;}
public boolean metron_f4530_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ObjectCacheConfig that = (ObjectCacheConfig) o;    return cacheSize == that.cacheSize && cacheExpiration == that.cacheExpiration && timeUnit == that.timeUnit && maxFileSize == that.maxFileSize;}
public int metron_f4531_0()
{    return Objects.hash(cacheSize, cacheExpiration, timeUnit, maxFileSize);}
public String metron_f4532_0()
{    return "ObjectCacheConfig{" + "cacheSize=" + cacheSize + ", cacheExpiration=" + cacheExpiration + ", timeUnit=" + timeUnit + ", maxFileSize=" + maxFileSize + '}';}
public void metron_f4533_0(List<String> metrics)
{    this.metrics = metrics;}
public Map<Pair, DescriptiveStatistics> metron_f4534_0(int depth)
{    Map<Pair, DescriptiveStatistics> statsMap = depthMap.get(depth);    if (statsMap == null) {        statsMap = new HashMap<>();        depthMap.put(depth, statsMap);    }    return statsMap;}
public DescriptiveStatistics metron_f4535_0(int depth, Pair p)
{    Map<Pair, DescriptiveStatistics> statsMap = getStatsMap(depth);    DescriptiveStatistics stats = statsMap.get(p);    if (stats == null) {        stats = new DescriptiveStatistics();        statsMap.put(p, stats);    }    return stats;}
public void metron_f4536_0(int depth, Pair p, double val)
{    getStats(depth, p).addValue(val);}
public static void metron_f4537_0(String title, DescriptiveStatistics statistics, PrintStream pw, boolean meanOnly)
{    if (meanOnly) {        pw.println(title + ": " + "\n\tMean: " + statistics.getMean());    } else {        pw.println(title + ": " + "\n\tMean: " + statistics.getMean() + "\n\tMin: " + statistics.getMin() + "\n\t1th: " + statistics.getPercentile(1) + "\n\t5th: " + statistics.getPercentile(5) + "\n\t10th: " + statistics.getPercentile(10) + "\n\t25th: " + statistics.getPercentile(25) + "\n\t50th: " + statistics.getPercentile(50) + "\n\t90th: " + statistics.getPercentile(90) + "\n\t95th: " + statistics.getPercentile(95) + "\n\t99th: " + statistics.getPercentile(99) + "\n\tMax: " + statistics.getMax() + "\n\tStdDev: " + statistics.getStandardDeviation());    }}
public void metron_f4538_0(int depth, boolean meanOnly)
{    Map<Pair, DescriptiveStatistics> statsMap = depthMap.get(depth);    System.out.println("\nDistance " + depth);    System.out.println("----------------\n");    List<Map.Entry<Pair, DescriptiveStatistics>> sortedStats = new ArrayList<>();    for (Map.Entry<Pair, DescriptiveStatistics> stats : statsMap.entrySet()) {        sortedStats.add(stats);    }    Collections.sort(sortedStats, new Comparator<Map.Entry<Pair, DescriptiveStatistics>>() {        @Override        public int compare(Map.Entry<Pair, DescriptiveStatistics> o1, Map.Entry<Pair, DescriptiveStatistics> o2) {            return -1 * Double.compare(o1.getValue().getMean(), o2.getValue().getMean());        }    });    for (Map.Entry<Pair, DescriptiveStatistics> stats : sortedStats) {        summary(stats.getKey().getKey() + " -> " + stats.getKey().getValue(), stats.getValue(), System.out, meanOnly);    }}
public int metron_f4539_0(Map.Entry<Pair, DescriptiveStatistics> o1, Map.Entry<Pair, DescriptiveStatistics> o2)
{    return -1 * Double.compare(o1.getValue().getMean(), o2.getValue().getMean());}
public void metron_f4540_0(boolean meanOnly)
{    System.out.println("Flow:");    System.out.println("\t" + Joiner.on(" -> ").join(metrics));    System.out.println("\nSUMMARY BY DISTANCE\n--------------------------");    for (int depth : depthMap.keySet()) {        printDepthSummary(depth, meanOnly);    }}
public static String metron_f4541_0(String s)
{    Iterable<String> tokenIt = Splitter.on('.').split(s);    int num = Iterables.size(tokenIt);    return Joiner.on('.').join(Iterables.limit(tokenIt, num - 1));}
public static void metron_f4542_0(LatencyStats stats, Map<String, Object> doc)
{    Map<String, Long> latencyMap = new HashMap<>();    NavigableMap<Long, String> latencyInvMap = new TreeMap<>();    for (Map.Entry<String, Object> kv : doc.entrySet()) {        if (kv.getKey().endsWith(".ts")) {            String base = getBaseMetric(kv.getKey());            long latency = Long.parseLong(kv.getValue().toString());            latencyInvMap.put(latency, base);            latencyMap.put(base, latency);        }    }    List<String> metrics = new ArrayList<>();    for (Map.Entry<Long, String> kv : latencyInvMap.entrySet()) {        metrics.add(kv.getValue());    }    stats.updateMetrics(metrics);    for (int i = 0; i < metrics.size(); ++i) {        for (int j = i + 1; j < metrics.size(); ++j) {            Pair p = new Pair(metrics.get(i), metrics.get(j));            long ms = latencyMap.get(metrics.get(j)) - latencyMap.get(metrics.get(i));            stats.put(j - i, p, ms);        }    }}
public static void metron_f4543_0(String... argv) throws IOException
{    Options options = new Options();    {        Option o = new Option("h", "help", false, "This screen");        o.setRequired(false);        options.addOption(o);    }    {        Option o = new Option("m", "mean_only", false, "Print the mean only when we summarize");        o.setRequired(false);        options.addOption(o);    }    CommandLineParser parser = new PosixParser();    CommandLine cmd = null;    try {        cmd = parser.parse(options, argv);    } catch (ParseException pe) {        pe.printStackTrace();        final HelpFormatter usageFormatter = new HelpFormatter();        usageFormatter.printHelp(LatencySummarizer.class.getSimpleName().toLowerCase(), null, options, null, true);        System.exit(-1);    }    if (cmd.hasOption("h")) {        final HelpFormatter usageFormatter = new HelpFormatter();        usageFormatter.printHelp(LatencySummarizer.class.getSimpleName().toLowerCase(), null, options, null, true);        System.exit(0);    }    LatencyStats statsMap = new LatencyStats();    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, StandardCharsets.UTF_8));    for (String line = null; (line = reader.readLine()) != null; ) {        Map<String, Object> doc = JSONUtils.INSTANCE.load(line, JSONUtils.MAP_SUPPLIER);        updateStats(statsMap, doc);    }    statsMap.printSummary(cmd.hasOption('m'));}
public List<String> metron_f4544_0()
{    return fields;}
public void metron_f4545_0(List<String> fields)
{    this.fields = fields;}
public String metron_f4546_0()
{    return type;}
public void metron_f4547_0(String type)
{    this.type = type;}
public T metron_f4548_0()
{    return adapter;}
public void metron_f4549_0(T adapter)
{    this.adapter = adapter;}
public Map.Entry<byte[], byte[]> metron_f4550_0(@Nullable Cell cell)
{    return new AbstractMap.SimpleEntry<>(cell.getQualifier(), cell.getValue());}
public Put metron_f4551_0(String columnFamily, KEY_T key, VALUE_T values) throws IOException
{    Put put = new Put(key.toBytes());    byte[] cf = Bytes.toBytes(columnFamily);    for (Map.Entry<byte[], byte[]> kv : values.toColumns()) {        put.add(cf, kv.getKey(), kv.getValue());    }    return put;}
public LookupKV<KEY_T, VALUE_T> metron_f4552_0(Put put, String columnFamily, KEY_T key, VALUE_T value) throws IOException
{    key.fromBytes(put.getRow());    byte[] cf = Bytes.toBytes(columnFamily);    value.fromColumns(Iterables.transform(put.getFamilyCellMap().get(cf), CELL_TO_ENTRY));    return new LookupKV<>(key, value);}
public Result metron_f4553_0(String columnFamily, KEY_T key, VALUE_T values) throws IOException
{    Put put = toPut(columnFamily, key, values);    return Result.create(put.getFamilyCellMap().get(Bytes.toBytes(columnFamily)));}
public LookupKV<KEY_T, VALUE_T> metron_f4554_0(Result result, String columnFamily, KEY_T key, VALUE_T value) throws IOException
{    if (result == null || result.getRow() == null) {        return null;    }    key.fromBytes(result.getRow());    byte[] cf = Bytes.toBytes(columnFamily);    NavigableMap<byte[], byte[]> cols = result.getFamilyMap(cf);    value.fromColumns(cols.entrySet());    return new LookupKV<>(key, value);}
public Get metron_f4555_0(String columnFamily, KEY_T key)
{    Get ret = new Get(key.toBytes());    ret.addFamily(Bytes.toBytes(columnFamily));    return ret;}
public static Iterable<Map.Entry<byte[], byte[]>> metron_f4556_0(byte[]... kvs)
{    if (kvs.length % 2 != 0) {        throw new IllegalStateException("Must be an even size");    }    List<Map.Entry<byte[], byte[]>> ret = new ArrayList<>(kvs.length / 2);    for (int i = 0; i < kvs.length; i += 2) {        ret.add(new AbstractMap.SimpleImmutableEntry<>(kvs[i], kvs[i + 1]));    }    return ret;}
public LookupKV<EnrichmentKey, EnrichmentValue> metron_f4557_0(Put put, String columnFamily) throws IOException
{    return fromPut(put, columnFamily, new EnrichmentKey(), new EnrichmentValue());}
public LookupKV<EnrichmentKey, EnrichmentValue> metron_f4558_0(Result result, String columnFamily) throws IOException
{    return fromResult(result, columnFamily, new EnrichmentKey(), new EnrichmentValue());}
public void metron_f4559_0(Table table, String cf, Iterable<LookupKV<EnrichmentKey, EnrichmentValue>> results) throws IOException
{    for (LookupKV<EnrichmentKey, EnrichmentValue> result : results) {        Put put = converter.toPut(cf, result.getKey(), result.getValue());        table.put(put);    }}
private byte[] metron_f4560_0() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream w = new DataOutputStream(baos);    w.writeUTF(type);    w.writeUTF(indicator);    w.flush();    return baos.toByteArray();}
public byte[] metron_f4561_0()
{    byte[] indicatorBytes = new byte[0];    try {        indicatorBytes = typedIndicatorToBytes();    } catch (IOException e) {        throw new RuntimeException("Unable to convert type and indicator to bytes", e);    }    byte[] prefix = KeyUtil.INSTANCE.getPrefix(Bytes.toBytes(indicator));    return KeyUtil.INSTANCE.merge(prefix, indicatorBytes);}
public void metron_f4562_0(byte[] row)
{    ByteArrayInputStream baos = new ByteArrayInputStream(row);    baos.skip(KeyUtil.HASH_PREFIX_SIZE);    DataInputStream w = new DataInputStream(baos);    try {        type = w.readUTF();        indicator = w.readUTF();    } catch (IOException e) {        throw new RuntimeException("Unable to convert type and indicator from bytes", e);    }}
public boolean metron_f4563_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    EnrichmentKey that = (EnrichmentKey) o;    if (indicator != null ? !indicator.equals(that.indicator) : that.indicator != null)        return false;    return type != null ? type.equals(that.type) : that.type == null;}
public int metron_f4564_0()
{    int result = indicator != null ? indicator.hashCode() : 0;    result = 31 * result + (type != null ? type.hashCode() : 0);    return result;}
public String metron_f4565_0()
{    return "EnrichmentKey{" + "indicator='" + indicator + '\'' + ", type='" + type + '\'' + '}';}
public String metron_f4566_0()
{    return indicator;}
public void metron_f4567_0(String indicator)
{    this.indicator = indicator;}
protected ObjectMapper metron_f4568_0()
{    return new ObjectMapper();}
public Map<String, Object> metron_f4569_0()
{    return metadata;}
public Iterable<Map.Entry<byte[], byte[]>> metron_f4570_0()
{    return AbstractConverter.toEntries(VALUE_COLUMN_NAME_B, Bytes.toBytes(valueToString(metadata)));}
public void metron_f4571_0(Iterable<Map.Entry<byte[], byte[]>> values)
{    for (Map.Entry<byte[], byte[]> cell : values) {        if (Bytes.equals(cell.getKey(), VALUE_COLUMN_NAME_B)) {            metadata = stringToValue(Bytes.toString(cell.getValue()));        }    }}
public Map<String, Object> metron_f4572_0(String s)
{    try {        return _mapper.get().readValue(s, new TypeReference<Map<String, Object>>() {        });    } catch (IOException e) {        throw new RuntimeException("Unable to convert string to metadata: " + s);    }}
public String metron_f4573_0(Map<String, Object> value)
{    try {        return _mapper.get().writeValueAsString(value);    } catch (IOException e) {        throw new RuntimeException("Unable to convert metadata to string: " + value);    }}
public boolean metron_f4574_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    EnrichmentValue that = (EnrichmentValue) o;    return getMetadata() != null ? getMetadata().equals(that.getMetadata()) : that.getMetadata() == null;}
public int metron_f4575_0()
{    return getMetadata() != null ? getMetadata().hashCode() : 0;}
public String metron_f4576_0()
{    return "EnrichmentValue{" + "metadata=" + metadata + '}';}
 String metron_f4577_0(String enrichmentType, String field)
{    return "";}
public AccessTracker metron_f4578_0(Map<String, Object> config, TableProvider provider) throws IOException
{    return creator.create(config, provider);}
public AccessTracker metron_f4579_0(byte[] bytes) throws IOException, ClassNotFoundException
{    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));    return (AccessTracker) ois.readObject();}
public byte[] metron_f4580_0(AccessTracker tracker) throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream oos = new ObjectOutputStream(bos);    oos.writeObject(tracker);    oos.flush();    oos.close();    return bos.toByteArray();}
public void metron_f4581_0(Table accessTrackerTable, String columnFamily, PersistentAccessTracker.AccessTrackerKey key, AccessTracker underlyingTracker) throws IOException
{    Put put = new Put(key.toRowKey());    put.add(Bytes.toBytes(columnFamily), COLUMN, serializeTracker(underlyingTracker));    accessTrackerTable.put(put);}
public Iterable<AccessTracker> metron_f4582_0(Table accessTrackerTable, final String columnFamily, final String name, final long earliest) throws IOException
{    Scan scan = new Scan(PersistentAccessTracker.AccessTrackerKey.getTimestampScanKey(name, earliest));    ResultScanner scanner = accessTrackerTable.getScanner(scan);    return Iterables.transform(scanner, new Function<Result, AccessTracker>() {        @Nullable        @Override        public AccessTracker apply(@Nullable Result result) {            try {                return deserializeTracker(result.getValue(Bytes.toBytes(columnFamily), COLUMN));            } catch (Exception e) {                throw new RuntimeException("Unable to deserialize " + name + " @ " + earliest);            }        }    });}
public AccessTracker metron_f4583_0(@Nullable Result result)
{    try {        return deserializeTracker(result.getValue(Bytes.toBytes(columnFamily), COLUMN));    } catch (Exception e) {        throw new RuntimeException("Unable to deserialize " + name + " @ " + earliest);    }}
public AccessTracker metron_f4584_0(Iterable<AccessTracker> trackers) throws IOException, ClassNotFoundException
{    AccessTracker tracker = null;    for (AccessTracker t : trackers) {        if (tracker == null) {            tracker = t;        } else {            tracker = tracker.union(t);        }    }    return tracker;}
public byte[] metron_f4585_0(LookupKey lookupKey)
{    return lookupKey.toBytes();}
protected BloomFilter<LookupKey> metron_f4586_0()
{    return filter;}
public void metron_f4587_0(LookupKey key)
{    numInsertions++;    filter.add(key);}
public void metron_f4588_0(Map<String, Object> config)
{    expectedInsertions = toInt(config.get(EXPECTED_INSERTIONS_KEY));    falsePositiveRate = toDouble(config.get(FALSE_POSITIVE_RATE_KEY));    name = config.get(NAME_KEY).toString();    filter = new BloomFilter<LookupKey>(new LookupKeySerializer(), expectedInsertions, falsePositiveRate);}
public boolean metron_f4589_0(LookupKey key)
{    return filter.mightContain(key);}
public void metron_f4590_0()
{    filter = new BloomFilter<LookupKey>(new LookupKeySerializer(), expectedInsertions, falsePositiveRate);}
private static double metron_f4591_0(Object o)
{    if (o instanceof String) {        return Double.parseDouble((String) o);    } else if (o instanceof Number) {        return ((Number) o).doubleValue();    } else {        throw new IllegalStateException("Unable to convert " + o + " to a double.");    }}
private static int metron_f4592_0(Object o)
{    if (o instanceof String) {        return Integer.parseInt((String) o);    } else if (o instanceof Number) {        return ((Number) o).intValue();    } else {        throw new IllegalStateException("Unable to convert " + o + " to a double.");    }}
public String metron_f4593_0()
{    return name;}
public AccessTracker metron_f4594_0(AccessTracker tracker)
{    if (filter == null) {        throw new IllegalStateException("Unable to union access tracker, because this tracker is not initialized.");    }    if (tracker instanceof BloomAccessTracker) {        filter.merge(((BloomAccessTracker) tracker).getFilter());        return this;    } else {        throw new IllegalStateException("Unable to union access tracker, because it's not of the right type (BloomAccessTracker)");    }}
public boolean metron_f4595_0()
{    return numInsertions >= expectedInsertions;}
public void metron_f4596_0() throws IOException
{}
public void metron_f4597_0(LookupKey key)
{}
public void metron_f4598_0(Map<String, Object> config)
{}
public boolean metron_f4599_0(LookupKey key)
{    return false;}
public String metron_f4600_0()
{    return "noop";}
public AccessTracker metron_f4601_0(AccessTracker tracker)
{    return null;}
public void metron_f4602_0()
{}
public boolean metron_f4603_0()
{    return false;}
public void metron_f4604_0() throws IOException
{}
public byte[] metron_f4605_0()
{    ByteArrayOutputStream os = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(os);    try {        dos.writeUTF(name);        dos.writeLong(timestamp);        dos.writeUTF(containerName);        dos.flush();    } catch (IOException e) {        throw new RuntimeException("Unable to write rowkey: " + this, e);    }    return os.toByteArray();}
public static byte[] metron_f4606_0(String name, long timestamp)
{    ByteArrayOutputStream os = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(os);    try {        dos.writeUTF(name);        dos.writeLong(timestamp);    } catch (IOException e) {        throw new RuntimeException("Unable to create scan key ", e);    }    return os.toByteArray();}
public static AccessTrackerKey metron_f4607_0(byte[] rowKey)
{    ByteArrayInputStream is = new ByteArrayInputStream(rowKey);    DataInputStream dis = new DataInputStream(is);    try {        String name = dis.readUTF();        long timestamp = dis.readLong();        String containerName = dis.readUTF();        return new AccessTrackerKey(name, containerName, timestamp);    } catch (IOException e) {        throw new RuntimeException("Unable to read rowkey: ", e);    }}
public void metron_f4608_0()
{    tracker.persist(false);}
public void metron_f4609_1(boolean force)
{    synchronized (sync) {        if (force || (System.currentTimeMillis() - timestamp) >= maxMillisecondsBetweenPersists) {                        try {                AccessTrackerUtil.INSTANCE.persistTracker(accessTrackerTable, accessTrackerColumnFamily, new AccessTrackerKey(name, containerName, timestamp), underlyingTracker);                timestamp = System.currentTimeMillis();                reset();            } catch (IOException e) {                            }        }    }}
public void metron_f4610_0(LookupKey key)
{    synchronized (sync) {        underlyingTracker.logAccess(key);        if (isFull()) {            persist(true);        }    }}
public void metron_f4611_0(Map<String, Object> config)
{    underlyingTracker.configure(config);}
public boolean metron_f4612_0(LookupKey key)
{    synchronized (sync) {        return underlyingTracker.hasSeen(key);    }}
public String metron_f4613_0()
{    return underlyingTracker.getName();}
public AccessTracker metron_f4614_0(AccessTracker tracker)
{    PersistentAccessTracker t1 = (PersistentAccessTracker) tracker;    underlyingTracker = underlyingTracker.union(t1.underlyingTracker);    return this;}
public void metron_f4615_0()
{    synchronized (sync) {        underlyingTracker.reset();    }}
public boolean metron_f4616_0()
{    synchronized (sync) {        return underlyingTracker.isFull();    }}
public void metron_f4617_1() throws IOException
{    synchronized (sync) {        try {            persist(true);        } catch (Throwable t) {                    }        underlyingTracker.cleanup();        accessTrackerTable.close();    }}
public String metron_f4618_0()
{    return hBaseTable;}
public String metron_f4619_0()
{    return hBaseCF;}
public double metron_f4620_0()
{    return falsePositiveRate;}
public int metron_f4621_0()
{    return expectedInsertions;}
public long metron_f4622_0()
{    return millisecondsBetweenPersists;}
public AccessTracker metron_f4623_0(Map<String, Object> config, TableProvider provider) throws IOException
{    Config patConfig = new Config(config);    String hbaseTable = patConfig.getHBaseTable();    int expectedInsertions = patConfig.getExpectedInsertions();    double falsePositives = patConfig.getFalsePositiveRate();    long millisecondsBetweenPersist = patConfig.getMillisecondsBetweenPersists();    BloomAccessTracker bat = new BloomAccessTracker(hbaseTable, expectedInsertions, falsePositives);    Configuration hbaseConfig = HBaseConfiguration.create();    AccessTracker ret = new PersistentAccessTracker(hbaseTable, UUID.randomUUID().toString(), provider.getTable(hbaseConfig, hbaseTable), patConfig.getHBaseCF(), bat, millisecondsBetweenPersist);    return ret;}
public Table metron_f4624_0()
{    return table;}
public String metron_f4625_0()
{    return columnFamily;}
private String metron_f4626_0(HBaseContext context)
{    return context.getColumnFamily() == null ? columnFamily : context.getColumnFamily();}
public boolean metron_f4627_0(EnrichmentKey key, HBaseContext context, boolean logAccess) throws IOException
{    return context.getTable().exists(converter.toGet(getColumnFamily(context), key));}
public LookupKV<EnrichmentKey, EnrichmentValue> metron_f4628_0(EnrichmentKey key, HBaseContext context, boolean logAccess) throws IOException
{    return converter.fromResult(context.getTable().get(converter.toGet(getColumnFamily(context), key)), getColumnFamily(context));}
private List<Get> metron_f4629_0(Iterable<KeyWithContext<EnrichmentKey, HBaseContext>> keys)
{    List<Get> ret = new ArrayList<>();    for (KeyWithContext<EnrichmentKey, HBaseContext> key : keys) {        ret.add(converter.toGet(getColumnFamily(key.getContext()), key.getKey()));    }    return ret;}
public Iterable<Boolean> metron_f4630_0(Iterable<KeyWithContext<EnrichmentKey, HBaseContext>> key, boolean logAccess) throws IOException
{    List<Boolean> ret = new ArrayList<>();    if (Iterables.isEmpty(key)) {        return Collections.emptyList();    }    Table table = Iterables.getFirst(key, null).getContext().getTable();    for (boolean b : table.existsAll(keysToGets(key))) {        ret.add(b);    }    return ret;}
public Iterable<LookupKV<EnrichmentKey, EnrichmentValue>> metron_f4631_0(Iterable<KeyWithContext<EnrichmentKey, HBaseContext>> keys, boolean logAccess) throws IOException
{    if (Iterables.isEmpty(keys)) {        return Collections.emptyList();    }    Table table = Iterables.getFirst(keys, null).getContext().getTable();    List<LookupKV<EnrichmentKey, EnrichmentValue>> ret = new ArrayList<>();    Iterator<KeyWithContext<EnrichmentKey, HBaseContext>> keyWithContextIterator = keys.iterator();    for (Result result : table.get(keysToGets(keys))) {        HBaseContext context = keyWithContextIterator.next().getContext();        ret.add(converter.fromResult(result, getColumnFamily(context)));    }    return ret;}
public void metron_f4632_0() throws Exception
{}
public Table metron_f4633_0()
{    return table;}
public void metron_f4634_0() throws Exception
{    super.close();    table.close();}
public KEY_T metron_f4635_0()
{    return key;}
public CONTEXT_T metron_f4636_0()
{    return context;}
public String metron_f4637_0()
{    return name;}
public void metron_f4638_0(String name)
{    this.name = name;}
public AccessTracker metron_f4639_0()
{    return accessTracker;}
public void metron_f4640_0(AccessTracker accessTracker)
{    this.accessTracker = accessTracker;}
public Handler<CONTEXT_T, KEY_T, RESULT_T> metron_f4641_0()
{    return lookupHandler;}
public void metron_f4642_0(Handler<CONTEXT_T, KEY_T, RESULT_T> lookupHandler)
{    this.lookupHandler = lookupHandler;}
public boolean metron_f4643_0(KEY_T key, CONTEXT_T context, boolean logAccess) throws IOException
{    if (logAccess) {        accessTracker.logAccess(key);    }    return lookupHandler.exists(key, context, logAccess);}
public RESULT_T metron_f4644_0(KEY_T key, CONTEXT_T context, boolean logAccess) throws IOException
{    if (logAccess) {        accessTracker.logAccess(key);    }    return lookupHandler.get(key, context, logAccess);}
public Iterable<Boolean> metron_f4645_0(Iterable<KeyWithContext<KEY_T, CONTEXT_T>> key, boolean logAccess) throws IOException
{    if (logAccess) {        for (KeyWithContext<KEY_T, CONTEXT_T> k : key) {            accessTracker.logAccess(k.getKey());        }    }    return lookupHandler.exists(key, logAccess);}
public Iterable<RESULT_T> metron_f4646_0(Iterable<KeyWithContext<KEY_T, CONTEXT_T>> key, boolean logAccess) throws IOException
{    if (logAccess) {        for (KeyWithContext<KEY_T, CONTEXT_T> k : key) {            accessTracker.logAccess(k.getKey());        }    }    return lookupHandler.get(key, logAccess);}
public void metron_f4647_0() throws Exception
{    accessTracker.cleanup();    lookupHandler.close();}
public KEY_T metron_f4648_0()
{    return key;}
public VALUE_T metron_f4649_0()
{    return value;}
public boolean metron_f4650_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    LookupKV<?, ?> lookupKV = (LookupKV<?, ?>) o;    if (key != null ? !key.equals(lookupKV.key) : lookupKV.key != null)        return false;    return value != null ? value.equals(lookupKV.value) : lookupKV.value == null;}
public int metron_f4651_0()
{    int result = key != null ? key.hashCode() : 0;    result = 31 * result + (value != null ? value.hashCode() : 0);    return result;}
public String metron_f4652_0()
{    return "LookupKV{" + "key=" + key + ", value=" + value + '}';}
public static ConcurrencyContext metron_f4653_0(EnrichmentStrategies strategy)
{    return strategyToInfrastructure.get(strategy);}
public synchronized void metron_f4654_1(int numThreads, long maxCacheSize, long maxTimeRetain, WorkerPoolStrategies poolStrategy, Logger log, boolean logStats)
{    if (executor == null) {        if (log != null) {                    }        executor = (poolStrategy == null ? WorkerPoolStrategies.FIXED : poolStrategy).create(numThreads);    }    if (cache == null) {        if (log != null) {                    }        Caffeine builder = Caffeine.newBuilder().maximumSize(maxCacheSize).expireAfterWrite(maxTimeRetain, TimeUnit.MINUTES).executor(executor);        if (logStats) {            builder = builder.recordStats();        }        cache = builder.build();    }}
public static Executor metron_f4655_0()
{    return executor;}
public Cache<CacheKey, JSONObject> metron_f4656_0()
{    return cache;}
public JSONObject metron_f4657_0() throws Exception
{        adapter.logAccess(key);    return adapter.enrich(key);}
public JSONObject metron_f4658_0(CacheKey cacheKey)
{    adapter.logAccess(key);    return adapter.enrich(cacheKey);}
public FunctionResolver metron_f4659_0()
{    return functionResolver;}
public Context metron_f4660_0()
{    return stellarContext;}
public EnrichmentConfig metron_f4661_0(SensorEnrichmentConfig config)
{    return enrichmentStrategy.getUnderlyingConfig(config);}
public String metron_f4662_0(String type, String field)
{    return enrichmentStrategy.fieldToEnrichmentKey(type, field);}
public JSONObject metron_f4663_0(JSONObject message, SensorEnrichmentConfig config, EnrichmentContext context)
{    return enrichmentStrategy.postProcess(message, config, context);}
public Constants.ErrorType metron_f4664_0()
{    return enrichmentStrategy.getErrorType();}
public EnrichmentConfig metron_f4665_0(SensorEnrichmentConfig config)
{    return config.getEnrichment();}
public Constants.ErrorType metron_f4666_0()
{    return Constants.ErrorType.ENRICHMENT_ERROR;}
public String metron_f4667_0(String type, String field)
{    return EnrichmentUtils.getEnrichmentKey(type, field);}
public EnrichmentConfig metron_f4668_0(SensorEnrichmentConfig config)
{    return config.getThreatIntel();}
public Constants.ErrorType metron_f4669_0()
{    return Constants.ErrorType.THREAT_INTEL_ERROR;}
public String metron_f4670_0(String type, String field)
{    return ThreatIntelUtils.getThreatIntelKey(type, field);}
public JSONObject metron_f4671_0(JSONObject message, SensorEnrichmentConfig config, EnrichmentContext context)
{    return ThreatIntelUtils.triage(message, config, context.getFunctionResolver(), context.getStellarContext());}
 JSONObject metron_f4672_0(JSONObject message, SensorEnrichmentConfig config, EnrichmentContext context)
{    return message;}
public JSONObject metron_f4673_0()
{    return result;}
public List<Map.Entry<Object, Throwable>> metron_f4674_0()
{    return enrichmentErrors;}
public EnrichmentResult metron_f4675_0(JSONObject message, EnrichmentStrategies strategy, SensorEnrichmentConfig config, PerformanceLogger perfLog) throws ExecutionException, InterruptedException
{    if (message == null) {        return null;    }    if (perfLog != null) {        perfLog.mark("execute");        if (perfLog.isDebugEnabled() && !cacheStats.isEmpty()) {            CacheStats before = cacheStats.get(strategy);            CacheStats after = concurrencyContext.getCache().stats();            if (before != null && after != null) {                CacheStats delta = after.minus(before);                perfLog.log("cache", delta.toString());            }            cacheStats.put(strategy, after);        }    }    String sensorType = MessageUtils.getSensorType(message);    message.put(getClass().getSimpleName().toLowerCase() + ".splitter.begin.ts", "" + System.currentTimeMillis());                        Map<String, List<JSONObject>> tasks = splitMessage(message, strategy, config);    message.put(getClass().getSimpleName().toLowerCase() + ".splitter.end.ts", "" + System.currentTimeMillis());    message.put(getClass().getSimpleName().toLowerCase() + ".enrich.begin.ts", "" + System.currentTimeMillis());    if (perfLog != null) {        perfLog.mark("enrich");    }    List<CompletableFuture<JSONObject>> taskList = new ArrayList<>();    List<Map.Entry<Object, Throwable>> errors = Collections.synchronizedList(new ArrayList<>());    for (Map.Entry<String, List<JSONObject>> task : tasks.entrySet()) {                EnrichmentAdapter<CacheKey> adapter = enrichmentsByType.get(task.getKey());        if (adapter == null) {            throw new IllegalStateException("Unable to find an adapter for " + task.getKey() + ", possible adapters are: " + Joiner.on(",").join(enrichmentsByType.keySet()));        }        message.put("adapter." + adapter.getClass().getSimpleName().toLowerCase() + ".begin.ts", "" + System.currentTimeMillis());        for (JSONObject m : task.getValue()) {            /* now for each unit of work (each of these only has one element in them)         * the key is the field name and the value is value associated with that field.         *         * In the case of stellar enrichment, the field name is the subgroup name or empty string.         * The value is the subset of the message needed for the enrichment.         *         * In the case of another enrichment (e.g. hbase), the field name is the field name being enriched.         * The value is the corresponding value.         */            for (Object o : m.keySet()) {                String field = (String) o;                Object value = m.get(o);                if (value == null) {                    message.put("adapter." + adapter.getClass().getSimpleName().toLowerCase() + ".end.ts", "" + System.currentTimeMillis());                    continue;                }                CacheKey cacheKey = new CacheKey(field, value, config);                String prefix = adapter.getOutputPrefix(cacheKey);                Supplier<JSONObject> supplier = () -> {                    try {                        JSONObject ret = concurrencyContext.getCache().get(cacheKey, new EnrichmentCallable(cacheKey, adapter));                        if (ret == null) {                            ret = new JSONObject();                        }                                                JSONObject adjustedKeys = EnrichmentUtils.adjustKeys(new JSONObject(), ret, cacheKey.getField(), prefix);                        adjustedKeys.put("adapter." + adapter.getClass().getSimpleName().toLowerCase() + ".end.ts", "" + System.currentTimeMillis());                        return adjustedKeys;                    } catch (Throwable e) {                        JSONObject errorMessage = new JSONObject();                        errorMessage.putAll(m);                        errorMessage.put(Constants.SENSOR_TYPE, sensorType);                        errors.add(new AbstractMap.SimpleEntry<>(errorMessage, new IllegalStateException(strategy + " error with " + task.getKey() + " failed: " + e.getMessage(), e)));                        return new JSONObject();                    }                };                                taskList.add(CompletableFuture.supplyAsync(supplier, ConcurrencyContext.getExecutor()));            }        }    }    if (taskList.isEmpty()) {        message.put(getClass().getSimpleName().toLowerCase() + ".enrich.end.ts", "" + System.currentTimeMillis());        return new EnrichmentResult(message, errors);    }    EnrichmentResult ret = new EnrichmentResult(all(taskList, message, (left, right) -> join(left, right)).get(), errors);    ret.getResult().put(getClass().getSimpleName().toLowerCase() + ".enrich.end.ts", "" + System.currentTimeMillis());    if (perfLog != null) {        String key = message.get(Constants.GUID) + "";        perfLog.log("enrich", "key={}, elapsed time to enrich", key);        perfLog.log("execute", "key={}, elapsed time to run execute", key);    }    return ret;}
private static JSONObject metron_f4676_0(JSONObject left, JSONObject right)
{    JSONObject message = new JSONObject();    message.putAll(left);    message.putAll(right);    List<Object> emptyKeys = new ArrayList<>();    for (Object key : message.keySet()) {        Object value = message.get(key);        if (value == null || value.toString().length() == 0) {            emptyKeys.add(key);        }    }    for (Object o : emptyKeys) {        message.remove(o);    }    return message;}
public static CompletableFuture<JSONObject> metron_f4677_0(List<CompletableFuture<JSONObject>> futures, JSONObject identity, BinaryOperator<JSONObject> reduceOp)
{    CompletableFuture[] cfs = futures.toArray(new CompletableFuture[futures.size()]);    CompletableFuture<Void> future = CompletableFuture.allOf(cfs);    return future.thenApply(aVoid -> futures.stream().map(CompletableFuture::join).reduce(identity, reduceOp));}
public Map<String, List<JSONObject>> metron_f4678_0(JSONObject message, EnrichmentStrategy enrichmentStrategy, SensorEnrichmentConfig config)
{    Map<String, List<JSONObject>> streamMessageMap = new HashMap<>();    Map<String, Object> enrichmentFieldMap = enrichmentStrategy.getUnderlyingConfig(config).getFieldMap();    Map<String, ConfigHandler> fieldToHandler = enrichmentStrategy.getUnderlyingConfig(config).getEnrichmentConfigs();    Set<String> enrichmentTypes = new HashSet<>(enrichmentFieldMap.keySet());        enrichmentTypes.addAll(fieldToHandler.keySet());        for (String enrichmentType : enrichmentTypes) {        Object fields = enrichmentFieldMap.get(enrichmentType);        ConfigHandler retriever = fieldToHandler.get(enrichmentType);                List<JSONObject> enrichmentObject = retriever.getType().splitByFields(message, fields, field -> enrichmentStrategy.fieldToEnrichmentKey(enrichmentType, field), retriever);        streamMessageMap.put(enrichmentType, enrichmentObject);    }    return streamMessageMap;}
public ExecutorService metron_f4679_0(int numThreads)
{    return creator.apply(numThreads);}
public Object metron_f4680_1(List<Object> args, Context context) throws ParseException
{    if (!initialized) {        return null;    }    if (args.size() > 2) {        throw new IllegalArgumentException("ASN_GET received more arguments than expected: " + args.size());    }    if (args.size() == 1 && args.get(0) instanceof String) {                String ip = (String) args.get(0);        if (ip == null || ip.trim().isEmpty()) {                        return null;        }        Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get(ip);        return result.orElse(Collections.EMPTY_MAP);    } else if (args.size() == 2 && args.get(1) instanceof List) {                String ip = (String) args.get(0);        @SuppressWarnings("unchecked")        List<String> fields = (List) args.get(1);        Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get(ip);                if (fields.size() == 1 && result.isPresent()) {            if (!result.get().containsKey(fields.get(0))) {                return null;            }            return result.get().get(fields.get(0));        } else if (result.isPresent()) {                        Map<String, Object> filteredInfo = new HashMap<>();            for (String field : fields) {                Map<String, Object> asnInfo = result.get();                filteredInfo.put(field, asnInfo.get(field));            }            return filteredInfo;        }    }    return null;}
public void metron_f4681_1(Context context)
{        Map<String, Object> config = getConfig(context);    String hdfsDir = (String) config.get(GeoLiteAsnDatabase.ASN_HDFS_FILE);    GeoLiteAsnDatabase.INSTANCE.update(hdfsDir);    initialized = true;}
private static Map<String, Object> metron_f4682_0(Context context)
{    return (Map<String, Object>) context.getCapability(Context.Capabilities.GLOBAL_CONFIG, false).orElse(new HashMap<>());}
public boolean metron_f4683_0()
{    return initialized;}
public Object metron_f4684_1(List<Object> args, Context context) throws ParseException
{    if (args.size() != 2) {        throw new IllegalArgumentException("All parameters are mandatory, submit 'hdfs path', 'indicator'");    }    if (!isInitialized()) {        return null;    }    String path = (String) args.get(0);    String indicator = (String) args.get(1);    if (path == null || indicator == null) {        return null;    }    Object value;    try {        Map cachedMap = (Map) objectCache.get(path);                value = cachedMap.get(indicator);    } catch (ClassCastException e) {        throw new ClassCastException(String.format("The object stored in HDFS at '%s' must be serialized in JSON format.", path));    }    return value;}
public void metron_f4685_0(Context context)
{    Map<String, Object> config = (Map<String, Object>) context.getCapability(Context.Capabilities.GLOBAL_CONFIG, false).orElse(new HashMap<>());    Map<String, Object> enrichmentGetConfig = (Map<String, Object>) config.getOrDefault(ENRICHMENT_OBJECT_GET_SETTINGS, new HashMap<>());    ObjectCacheConfig objectCacheConfig = new ObjectCacheConfig(enrichmentGetConfig);    objectCache = new ObjectCache();    objectCache.initialize(objectCacheConfig);}
public boolean metron_f4686_0()
{    return objectCache != null && objectCache.isInitialized();}
public Object metron_f4687_0(List<Object> args, Context context) throws ParseException
{    if (!initialized) {        return null;    }    if (args.size() > 2) {        throw new IllegalArgumentException("GEO_GET received more arguments than expected: " + args.size());    }    if (args.size() == 1 && args.get(0) instanceof String) {                String ip = (String) args.get(0);        if (ip == null || ip.trim().isEmpty()) {            return null;        }        Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(ip);        return result.orElse(Collections.emptyMap());    } else if (args.size() == 2 && args.get(1) instanceof List) {                String ip = (String) args.get(0);        @SuppressWarnings("unchecked")        List<String> fields = (List) args.get(1);        Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(ip);                if (fields.size() == 1 && result.isPresent()) {            return result.get().get(fields.get(0));        } else if (result.isPresent()) {                        Map<String, String> filteredInfo = new HashMap<>();            for (String field : fields) {                Map<String, String> geoInfo = result.get();                filteredInfo.put(field, geoInfo.get(field));            }            return filteredInfo;        }    }    return null;}
public void metron_f4688_1(Context context)
{        Map<String, Object> config = getConfig(context);    String hdfsDir = (String) config.get(GeoLiteCityDatabase.GEO_HDFS_FILE);    GeoLiteCityDatabase.INSTANCE.update(hdfsDir);    initialized = true;}
private static Map<String, Object> metron_f4689_0(Context context)
{    return (Map<String, Object>) context.getCapability(Context.Capabilities.GLOBAL_CONFIG, false).orElse(new HashMap<>());}
public boolean metron_f4690_0()
{    return initialized;}
public Object metron_f4691_0(List<Object> args, Context context) throws ParseException
{    if (args.size() < 1) {        return null;    }    String hash = (String) args.get(0);    if (hash == null) {        return null;    }    Optional<WGS84Point> point = GeoHashUtil.INSTANCE.toPoint(hash);    if (point.isPresent()) {        Map<String, Object> ret = new HashMap<>();        ret.put(GeoLiteCityDatabase.GeoProps.LONGITUDE.getSimpleName(), point.get().getLongitude());        ret.put(GeoLiteCityDatabase.GeoProps.LATITUDE.getSimpleName(), point.get().getLatitude());        return ret;    }    return null;}
public void metron_f4692_0(Context context)
{}
public boolean metron_f4693_0()
{    return true;}
public Object metron_f4694_0(List<Object> args, Context context) throws ParseException
{    if (args.size() < 2) {        return null;    }    Object latObj = args.get(0);    Object longObj = args.get(1);    if (latObj == null || longObj == null) {        return null;    }    Double latitude = ConversionUtils.convert(latObj, Double.class);    Double longitude = ConversionUtils.convert(longObj, Double.class);    int charPrecision = 12;    if (args.size() > 2) {        charPrecision = ConversionUtils.convert(args.get(2), Integer.class);    }    Optional<String> ret = GeoHashUtil.INSTANCE.computeHash(latitude, longitude, charPrecision);    return ret.orElse(null);}
public void metron_f4695_0(Context context)
{}
public boolean metron_f4696_0()
{    return true;}
public Object metron_f4697_0(List<Object> args, Context context) throws ParseException
{    if (args.size() < 1) {        return null;    }    Map<String, String> map = (Map<String, String>) args.get(0);    if (map == null) {        return null;    }    int charPrecision = 12;    if (args.size() > 1) {        charPrecision = ConversionUtils.convert(args.get(1), Integer.class);    }    Optional<String> ret = GeoHashUtil.INSTANCE.computeHash(map, charPrecision);    return ret.orElse(null);}
public void metron_f4698_0(Context context)
{}
public boolean metron_f4699_0()
{    return true;}
public Object metron_f4700_0(List<Object> args, Context context) throws ParseException
{    if (args.size() < 2) {        return null;    }    String hash1 = (String) args.get(0);    if (hash1 == null) {        return null;    }    Optional<WGS84Point> pt1 = GeoHashUtil.INSTANCE.toPoint(hash1);    String hash2 = (String) args.get(1);    if (hash2 == null) {        return null;    }    Optional<WGS84Point> pt2 = GeoHashUtil.INSTANCE.toPoint(hash2);    DistanceStrategy strat = DistanceStrategies.HAVERSINE;    if (args.size() > 2) {        strat = DistanceStrategies.valueOf((String) args.get(2));    }    if (pt1.isPresent() && pt2.isPresent()) {        return GeoHashUtil.INSTANCE.distance(pt1.get(), pt2.get(), strat);    }    return Double.NaN;}
public void metron_f4701_0(Context context)
{}
public boolean metron_f4702_0()
{    return true;}
public Object metron_f4703_0(List<Object> args, Context context) throws ParseException
{    if (args.size() < 1) {        return null;    }    Iterable<String> hashes = (Iterable<String>) args.get(0);    if (hashes == null) {        return null;    }    DistanceStrategy strat = DistanceStrategies.HAVERSINE;    if (args.size() > 1) {        strat = DistanceStrategies.valueOf((String) args.get(1));    }    return GeoHashUtil.INSTANCE.maxDistanceHashes(hashes, strat);}
public void metron_f4704_0(Context context)
{}
public boolean metron_f4705_0()
{    return true;}
public Object metron_f4706_0(List<Object> args, Context context) throws ParseException
{    if (args.size() < 1) {        return null;    }    Object o1 = args.get(0);    if (o1 == null) {        return null;    }    WGS84Point centroid = null;    if (o1 instanceof Map) {        centroid = GeoHashUtil.INSTANCE.centroidOfWeightedPoints((Map<String, Number>) o1);    } else if (o1 instanceof Iterable) {        centroid = GeoHashUtil.INSTANCE.centroidOfHashes((Iterable<String>) o1);    }    if (centroid == null) {        return null;    }    Integer precision = 12;    if (args.size() > 1) {        precision = (Integer) args.get(1);    }    return GeoHashUtil.INSTANCE.computeHash(centroid, precision).orElse(null);}
public void metron_f4707_0(Context context)
{}
public boolean metron_f4708_0()
{    return true;}
public Object metron_f4709_0(List<Object> args, Context context) throws ParseException
{    if (!isInitialized()) {        return null;    }    if (args.size() < 1) {        return null;    }    Object o = args.get(0);    if (o == null) {        return null;    }    if (o instanceof String) {        return objectCache.get((String) o);    } else {        throw new IllegalStateException("Unable to retrieve " + o + " as it is not a path");    }}
public void metron_f4710_0(Context context)
{    Map<String, Object> config = getConfig(context);    objectCache = new ObjectCache();    objectCache.initialize(new ObjectCacheConfig(config));}
public boolean metron_f4711_0()
{    return objectCache != null && objectCache.isInitialized();}
protected Map<String, Object> metron_f4712_0(Context context)
{    return (Map<String, Object>) context.getCapability(Context.Capabilities.GLOBAL_CONFIG, false).orElse(new HashMap<>());}
public String metron_f4713_0()
{    return "Table{" + "name='" + name + '\'' + ", columnFamily='" + columnFamily + '\'' + '}';}
public boolean metron_f4714_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    WrapperTable table = (WrapperTable) o;    if (name != null ? !name.equals(table.name) : table.name != null)        return false;    return columnFamily != null ? columnFamily.equals(table.columnFamily) : table.columnFamily == null;}
public int metron_f4715_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (columnFamily != null ? columnFamily.hashCode() : 0);    return result;}
private static Map<String, Object> metron_f4716_0(Context context)
{    return (Map<String, Object>) context.getCapability(Context.Capabilities.GLOBAL_CONFIG).orElse(new HashMap<>());}
private static synchronized void metron_f4717_0(Map<String, Object> config, TableProvider provider) throws IOException
{    if (tracker == null) {        String accessTrackerType = (String) config.getOrDefault(ACCESS_TRACKER_TYPE_CONF, AccessTrackers.NOOP.toString());        AccessTrackers trackers = AccessTrackers.valueOf(accessTrackerType);        tracker = trackers.create(config, provider);    }}
private static TableProvider metron_f4718_0(String tableProviderClass)
{    try {        Class<? extends TableProvider> providerClazz = (Class<? extends TableProvider>) Class.forName(tableProviderClass);        return providerClazz.getConstructor().newInstance();    } catch (Exception e) {        return new HTableProvider();    }}
private static synchronized void metron_f4719_0(Map<String, Object> config)
{    if (provider != null) {        return;    } else {        String tableProviderClass = (String) config.getOrDefault(TABLE_PROVIDER_TYPE_CONF, HTableProvider.class.getName());        provider = createProvider(tableProviderClass);    }}
public Object metron_f4720_1(List<Object> args, Context context) throws ParseException
{    if (!initialized) {        return false;    }    if (args.size() != 4) {        throw new IllegalStateException("All parameters are mandatory, submit 'enrichment type', 'indicator', 'nosql_table' and 'column_family'");    }    int i = 0;    String enrichmentType = (String) args.get(i++);    String indicator = (String) args.get(i++);    String table = (String) args.get(i++);    String cf = (String) args.get(i++);    if (enrichmentType == null || indicator == null) {        return false;    }    final WrapperTable key = new WrapperTable(table, cf);    EnrichmentLookup lookup = null;    try {        lookup = enrichmentCollateralCache.get(key, () -> {            Table hTable = provider.getTable(HBaseConfiguration.create(), key.name);            return new EnrichmentLookup(hTable, key.columnFamily, tracker);        });    } catch (ExecutionException e) {                return false;    }    EnrichmentLookup.HBaseContext hbaseContext = new EnrichmentLookup.HBaseContext(lookup.getTable(), cf);    try {        return lookup.exists(new EnrichmentKey(enrichmentType, indicator), hbaseContext, true);    } catch (IOException e) {                return false;    }}
public void metron_f4721_1(Context context)
{    try {        Map<String, Object> config = getConfig(context);        initializeProvider(config);        initializeTracker(config, provider);    } catch (IOException e) {            } finally {        initialized = true;    }}
public boolean metron_f4722_0()
{    return initialized;}
public Object metron_f4723_1(List<Object> args, Context context) throws ParseException
{    if (!initialized) {        return false;    }    if (args.size() != 4) {        throw new IllegalStateException("All parameters are mandatory, submit 'enrichment type', 'indicator', 'nosql_table' and 'column_family'");    }    int i = 0;    String enrichmentType = (String) args.get(i++);    String indicator = (String) args.get(i++);    String table = (String) args.get(i++);    String cf = (String) args.get(i++);    if (enrichmentType == null || indicator == null) {        return new HashMap<String, Object>();    }    final WrapperTable key = new WrapperTable(table, cf);    EnrichmentLookup lookup = null;    try {        lookup = enrichmentCollateralCache.get(key, () -> {            Table hTable = provider.getTable(HBaseConfiguration.create(), key.name);            return new EnrichmentLookup(hTable, key.columnFamily, tracker);        });    } catch (ExecutionException e) {                return new HashMap<String, Object>();    }    EnrichmentLookup.HBaseContext hbaseContext = new EnrichmentLookup.HBaseContext(lookup.getTable(), cf);    try {        LookupKV<EnrichmentKey, EnrichmentValue> kv = lookup.get(new EnrichmentKey(enrichmentType, indicator), hbaseContext, true);        if (kv != null && kv.getValue() != null && kv.getValue().getMetadata() != null) {            return kv.getValue().getMetadata();        }        return new HashMap<String, Object>();    } catch (IOException e) {                return new HashMap<String, Object>();    }}
public void metron_f4724_1(Context context)
{    try {        Map<String, Object> config = getConfig(context);        initializeProvider(config);        initializeTracker(config, provider);    } catch (IOException e) {            } finally {        initialized = true;    }}
public boolean metron_f4725_0()
{    return initialized;}
public static String metron_f4726_0(String enrichmentName, String field)
{    return Joiner.on(".").join(new String[] { KEY_PREFIX, enrichmentName, field });}
public KeyWithContext<EnrichmentKey, EnrichmentLookup.HBaseContext> metron_f4727_0(@Nullable String enrichmentType)
{    EnrichmentKey key = new EnrichmentKey(enrichmentType, indicator);    EnrichmentLookup.HBaseContext context = new EnrichmentLookup.HBaseContext(table, getColumnFamily(enrichmentType, config));    return new KeyWithContext<>(key, context);}
protected Map<Object, Map<String, String>> metron_f4728_0()
{    return new HashMap<>();}
public static String metron_f4729_0(String enrichmentType, EnrichmentConfig config)
{    Object o = config.getConfig().get(TYPE_TO_COLUMN_FAMILY_CONF);    if (o == null) {        return null;    } else {        Map<String, String> cfMap = typeToCFs.get().get(o);        if (cfMap == null) {            cfMap = new HashMap<>();            if (o instanceof Map) {                Map map = (Map) o;                for (Object key : map.keySet()) {                    cfMap.put(key.toString(), map.get(key).toString());                }            }            typeToCFs.get().put(o, cfMap);        }        return cfMap.get(enrichmentType);    }}
public static String metron_f4730_0(String field)
{    if (field == null) {        return null;    }    return Iterables.getLast(Splitter.on('.').split(field));}
public static TableProvider metron_f4731_0(String connectorImpl, TableProvider defaultImpl)
{    if (connectorImpl == null || connectorImpl.length() == 0 || connectorImpl.charAt(0) == '$') {        return defaultImpl;    } else {        try {            Class<? extends TableProvider> clazz = (Class<? extends TableProvider>) Class.forName(connectorImpl);            return clazz.getConstructor().newInstance();        } catch (InstantiationException e) {            throw new IllegalStateException("Unable to instantiate connector.", e);        } catch (IllegalAccessException e) {            throw new IllegalStateException("Unable to instantiate connector: illegal access", e);        } catch (InvocationTargetException e) {            throw new IllegalStateException("Unable to instantiate connector", e);        } catch (NoSuchMethodException e) {            throw new IllegalStateException("Unable to instantiate connector: no such method", e);        } catch (ClassNotFoundException e) {            throw new IllegalStateException("Unable to instantiate connector: class not found", e);        }    }}
public static JSONObject metron_f4732_0(JSONObject enrichedMessage, JSONObject enrichedField, String field, String prefix)
{    if (!enrichedField.isEmpty()) {        for (Object enrichedKey : enrichedField.keySet()) {            if (!StringUtils.isEmpty(prefix)) {                enrichedMessage.put(field + "." + enrichedKey, enrichedField.get(enrichedKey));            } else {                enrichedMessage.put(enrichedKey, enrichedField.get(enrichedKey));            }        }    }    return enrichedMessage;}
public static String metron_f4733_0(String threatIntelName, String field)
{    return Joiner.on(".").join(new String[] { KEY_PREFIX, threatIntelName, field });}
public static JSONObject metron_f4734_1(JSONObject ret, SensorEnrichmentConfig config, FunctionResolver functionResolver, Context stellarContext)
{    LOG.trace("Received joined messages: {}", ret);    boolean isAlert = ret.containsKey("is_alert");    if (!isAlert) {        for (Object key : ret.keySet()) {            if (key.toString().startsWith("threatintels") && !key.toString().endsWith(".ts")) {                isAlert = true;                break;            }        }    } else {        Object isAlertObj = ret.get("is_alert");        isAlert = ConversionUtils.convert(isAlertObj, Boolean.class);        if (!isAlert) {            ret.remove("is_alert");        }    }    if (isAlert) {        ret.put("is_alert", "true");        String sourceType = MessageUtils.getSensorType(ret);        ThreatTriageConfig triageConfig = null;        if (config != null) {            triageConfig = config.getThreatIntel().getTriageConfig();            if (LOG.isDebugEnabled()) {                            }        } else {                    }        if (triageConfig != null) {            if (LOG.isDebugEnabled()) {                            }            if (LOG.isDebugEnabled() && (triageConfig.getRiskLevelRules() == null || triageConfig.getRiskLevelRules().isEmpty())) {                            }                        ThreatTriageProcessor threatTriageProcessor = new ThreatTriageProcessor(config, functionResolver, stellarContext);            ThreatScore score = threatTriageProcessor.apply(ret);            if (LOG.isDebugEnabled()) {                String rules = Joiner.on('\n').join(triageConfig.getRiskLevelRules());                            }                        if (score.getRuleScores().size() > 0) {                appendThreatScore(score, ret);            }        } else {                    }    }    return ret;}
private static void metron_f4735_0(ThreatScore threatScore, JSONObject message)
{        message.put(THREAT_TRIAGE_SCORE_KEY, threatScore.getScore());        Joiner joiner = Joiner.on(".");    int i = 0;    for (RuleScore score : threatScore.getRuleScores()) {        message.put(joiner.join(THREAT_TRIAGE_RULES_KEY, i, THREAT_TRIAGE_RULE_NAME), score.getRule().getName());        message.put(joiner.join(THREAT_TRIAGE_RULES_KEY, i, THREAT_TRIAGE_RULE_COMMENT), score.getRule().getComment());        message.put(joiner.join(THREAT_TRIAGE_RULES_KEY, i, THREAT_TRIAGE_RULE_SCORE), score.getRule().getScoreExpression());        message.put(joiner.join(THREAT_TRIAGE_RULES_KEY, i++, THREAT_TRIAGE_RULE_REASON), score.getReason());    }}
public ThreatScore metron_f4736_0(@Nullable Map message)
{    ThreatScore threatScore = new ThreatScore();    StellarPredicateProcessor predicateProcessor = new StellarPredicateProcessor();    StellarProcessor processor = new StellarProcessor();    VariableResolver variableResolver = new MapVariableResolver(message, sensorConfig.getConfiguration(), threatIntelConfig.getConfig());        for (RiskLevelRule rule : threatTriageConfig.getRiskLevelRules()) {        if (predicateProcessor.parse(rule.getRule(), variableResolver, functionResolver, context)) {                        String reason = execute(rule.getReason(), processor, variableResolver, String.class);            Double score = execute(rule.getScoreExpression(), processor, variableResolver, Double.class);            threatScore.addRuleScore(new RuleScore(rule, reason, score));        }    }        List<Number> ruleScores = new ArrayList<>();    for (RuleScore ruleScore : threatScore.getRuleScores()) {        ruleScores.add(ruleScore.getScore());    }    Aggregators aggregators = threatTriageConfig.getAggregator();    Double aggregateScore = aggregators.aggregate(ruleScores, threatTriageConfig.getAggregationConfig());    threatScore.setScore(aggregateScore);    return threatScore;}
private T metron_f4737_0(String expression, StellarProcessor processor, VariableResolver resolver, Class<T> clazz)
{    Object result = processor.parse(expression, resolver, functionResolver, context);    return ConversionUtils.convert(result, clazz);}
public List<RiskLevelRule> metron_f4738_0()
{    return threatTriageConfig.getRiskLevelRules();}
public SensorEnrichmentConfig metron_f4739_0()
{    return sensorConfig;}
public String metron_f4740_0()
{    return String.format("ThreatTriage{%d rule(s)}", threatTriageConfig.getRiskLevelRules().size());}
public void metron_f4741_0() throws ParseException
{    JSONParser jsonParser = new JSONParser();    expectedMessage = (JSONObject) jsonParser.parse(expectedMessageString);}
public void metron_f4742_0() throws Exception
{    HostFromJSONListAdapter hja = new HostFromJSONListAdapter(expectedKnownHostsString);    JSONObject actualMessage = hja.enrich(new CacheKey("dummy", ip, null));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(expectedMessage, actualMessage);    actualMessage = hja.enrich(new CacheKey("dummy", ip1, null));    JSONObject emptyJson = new JSONObject();    Assert.assertEquals(emptyJson, actualMessage);}
public void metron_f4743_0() throws Exception
{    HostFromJSONListAdapter hja = new HostFromJSONListAdapter(expectedKnownHostsString);    JSONObject actualMessage = hja.enrich(new CacheKey("dummy", ip, null));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(expectedMessage, actualMessage);    actualMessage = hja.enrich(new CacheKey("dummy", 10L, null));    JSONObject emptyJson = new JSONObject();    Assert.assertEquals(emptyJson, actualMessage);}
public void metron_f4744_0() throws Exception
{    HostFromJSONListAdapter hja = new HostFromJSONListAdapter(expectedKnownHostsString);    Assert.assertTrue(hja.initializeAdapter(null));}
public void metron_f4745_0() throws ParseException
{    JSONParser jsonParser = new JSONParser();    expectedMessage = (JSONObject) jsonParser.parse(expectedMessageString);}
public void metron_f4746_0() throws Exception
{    Map<String, JSONObject> mapKnownHosts = new HashMap<>();    JSONArray jsonArray = (JSONArray) JSONValue.parse(expectedKnownHostsString);    Iterator jsonArrayIterator = jsonArray.iterator();    while (jsonArrayIterator.hasNext()) {        JSONObject jsonObject = (JSONObject) jsonArrayIterator.next();        String host = (String) jsonObject.remove("ip");        mapKnownHosts.put(host, jsonObject);    }    HostFromPropertiesFileAdapter hfa = new HostFromPropertiesFileAdapter(mapKnownHosts);    JSONObject actualMessage = hfa.enrich(new CacheKey("dummy", ip, null));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(expectedMessage, actualMessage);    actualMessage = hfa.enrich(new CacheKey("dummy", ip1, null));    JSONObject emptyJson = new JSONObject();    Assert.assertEquals(emptyJson, actualMessage);}
public void metron_f4747_0() throws Exception
{    Map<String, JSONObject> mapKnownHosts = new HashMap<>();    HostFromPropertiesFileAdapter hfa = new HostFromPropertiesFileAdapter(mapKnownHosts);    Assert.assertFalse(hfa.initializeAdapter(null));    JSONArray jsonArray = (JSONArray) JSONValue.parse(expectedKnownHostsString);    Iterator jsonArrayIterator = jsonArray.iterator();    while (jsonArrayIterator.hasNext()) {        JSONObject jsonObject = (JSONObject) jsonArrayIterator.next();        String host = (String) jsonObject.remove("ip");        mapKnownHosts.put(host, jsonObject);    }    hfa = new HostFromPropertiesFileAdapter(mapKnownHosts);    Assert.assertTrue(hfa.initializeAdapter(null));}
public void metron_f4748_0()
{    conn = new MySqlConfig();    conn.setHost("10.22.0.214");    conn.setPort(3306);    conn.setTable("GEO");    conn.setUsername("root");    conn.setPassword("hadoop123");}
public void metron_f4749_0() throws Exception
{    Assert.assertEquals(sampleURL, conn.getJdbcUrl());}
public static void metron_f4750_0() throws IOException
{        expectedAsnMessage.put("autonomous_system_organization", "Google LLC");    expectedAsnMessage.put("autonomous_system_number", 15169);    expectedAsnMessage.put("network", "8.8.4.0");    String baseDir = UnitTestHelper.findDir("GeoLite");    asnHdfsFile = new File(new File(baseDir), GEO_ASN_FILE_NAME);    asnHdfsFile_update = new File(new File(baseDir), GEO_ASN_COPY_FILE_NAME);    FileUtils.copyFile(asnHdfsFile, asnHdfsFile_update);}
public static void metron_f4751_0()
{    FileUtils.deleteQuietly(asnHdfsFile_update);}
public void metron_f4752_0() throws Exception
{    testFolder.create();    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> ImmutableMap.of(GeoLiteAsnDatabase.ASN_HDFS_FILE, asnHdfsFile.getAbsolutePath())).build();}
public void metron_f4753_0()
{    GeoLiteAsnDatabase.INSTANCE.update(asnHdfsFile.getAbsolutePath());    Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get("192.168.0.1");    Assert.assertFalse("Local address result should be empty", result.isPresent());}
public void metron_f4754_0()
{    GeoLiteAsnDatabase.INSTANCE.update(asnHdfsFile.getAbsolutePath());        Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get("203.0.113.1");    Assert.assertFalse("External address not found", result.isPresent());}
public void metron_f4755_0()
{    GeoLiteAsnDatabase.INSTANCE.update(asnHdfsFile.getAbsolutePath());    Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get(IP_ADDR);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedAsnMessage, result.get());}
public void metron_f4756_0()
{    GeoLiteAsnDatabase.INSTANCE.update(asnHdfsFile.getAbsolutePath());    GeoLiteAsnDatabase.INSTANCE.update(asnHdfsFile.getAbsolutePath());    Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get(IP_ADDR);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedAsnMessage, result.get());}
public void metron_f4757_0()
{    HashMap<String, Object> globalConfig = new HashMap<>();    globalConfig.put(GeoLiteAsnDatabase.ASN_HDFS_FILE, asnHdfsFile.getAbsolutePath());    GeoLiteAsnDatabase.INSTANCE.updateIfNecessary(globalConfig);    Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get(IP_ADDR);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedAsnMessage, result.get());}
public void metron_f4758_0()
{    HashMap<String, Object> globalConfig = new HashMap<>();    globalConfig.put(GeoLiteAsnDatabase.ASN_HDFS_FILE, asnHdfsFile.getAbsolutePath());    GeoLiteAsnDatabase.INSTANCE.updateIfNecessary(globalConfig);    GeoLiteAsnDatabase.INSTANCE.updateIfNecessary(globalConfig);    Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get(IP_ADDR);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedAsnMessage, result.get());}
public void metron_f4759_0()
{    HashMap<String, Object> globalConfig = new HashMap<>();    globalConfig.put(GeoLiteAsnDatabase.ASN_HDFS_FILE, asnHdfsFile.getAbsolutePath());    GeoLiteAsnDatabase.INSTANCE.updateIfNecessary(globalConfig);    Optional<Map<String, Object>> result = GeoLiteAsnDatabase.INSTANCE.get(IP_ADDR);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedAsnMessage, result.get());    globalConfig.put(GeoLiteAsnDatabase.ASN_HDFS_FILE, asnHdfsFile_update.getAbsolutePath());    GeoLiteAsnDatabase.INSTANCE.updateIfNecessary(globalConfig);    result = GeoLiteAsnDatabase.INSTANCE.get(IP_ADDR);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedAsnMessage, result.get());}
public static void metron_f4760_0() throws ParseException
{    JSONParser jsonParser = new JSONParser();    expectedMessage = (JSONObject) jsonParser.parse(expectedMessageString);    String baseDir = UnitTestHelper.findDir("GeoLite");    geoHdfsFile = new File(new File(baseDir), "GeoLite2-City.mmdb.gz");    geo = new GeoAdapter();    geo.initializeAdapter(ImmutableMap.of(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath()));}
public void metron_f4761_0() throws Exception
{    JSONObject actualMessage = geo.enrich(new CacheKey("dummy", IP, null));    Assert.assertNotNull(actualMessage.get("locID"));    Assert.assertEquals(expectedMessage, actualMessage);}
public void metron_f4762_0() throws Exception
{    JSONObject actualMessage = geo.enrich(new CacheKey("dummy", 10L, null));    Assert.assertEquals(new JSONObject(), actualMessage);}
public static void metron_f4763_0() throws ParseException, IOException
{    JSONParser jsonParser = new JSONParser();    expectedNoDmaMessage = (JSONObject) jsonParser.parse(expectedNoDmaMessageString);    expectedDmaMessage = (JSONObject) jsonParser.parse(expectedDmaMessageString);    expectedMessageTarGz = (JSONObject) jsonParser.parse(expectedMessageStringTarGz);    String baseDir = UnitTestHelper.findDir("GeoLite");    geoHdfsFile = new File(new File(baseDir), GEO_CITY_FILE_NAME);    geoHdfsFile_update = new File(new File(baseDir), GEO_CITY_COPY_FILE_NAME);    FileUtils.copyFile(geoHdfsFile, geoHdfsFile_update);    geoHdfsFileTarGz = new File(new File(baseDir), GEO_CITY + EXTENSION_TAR_GZ);    Configuration config = new Configuration();    fs = FileSystem.get(config);}
public static void metron_f4764_0()
{    FileUtils.deleteQuietly(geoHdfsFile_update);}
public void metron_f4765_0() throws Exception
{    testFolder.create();    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> ImmutableMap.of(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath())).build();}
public void metron_f4766_0()
{    GeoLiteCityDatabase.INSTANCE.update(geoHdfsFile.getAbsolutePath());    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get("192.168.0.1");    Assert.assertFalse("Local address result should be empty", result.isPresent());}
public void metron_f4767_0()
{    GeoLiteCityDatabase.INSTANCE.update(geoHdfsFile.getAbsolutePath());        Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get("203.0.113.1");    Assert.assertFalse("External address not found", result.isPresent());}
public void metron_f4768_0()
{    GeoLiteCityDatabase.INSTANCE.update(geoHdfsFile.getAbsolutePath());    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(IP_WITH_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedDmaMessage, result.get());}
public void metron_f4769_0()
{    GeoLiteCityDatabase.INSTANCE.update(geoHdfsFileTarGz.getAbsolutePath());    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(IP_WITH_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedMessageTarGz, result.get());}
public void metron_f4770_0()
{    GeoLiteCityDatabase.INSTANCE.update(geoHdfsFile.getAbsolutePath());    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(IP_NO_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedNoDmaMessage, result.get());}
public void metron_f4771_0()
{    GeoLiteCityDatabase.INSTANCE.update(geoHdfsFile.getAbsolutePath());    GeoLiteCityDatabase.INSTANCE.update(geoHdfsFile.getAbsolutePath());    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(IP_NO_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedNoDmaMessage, result.get());}
public void metron_f4772_0()
{    HashMap<String, Object> globalConfig = new HashMap<>();    globalConfig.put(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath());    GeoLiteCityDatabase.INSTANCE.updateIfNecessary(globalConfig);    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(IP_NO_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedNoDmaMessage, result.get());}
public void metron_f4773_0()
{    HashMap<String, Object> globalConfig = new HashMap<>();    globalConfig.put(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath());    GeoLiteCityDatabase.INSTANCE.updateIfNecessary(globalConfig);    GeoLiteCityDatabase.INSTANCE.updateIfNecessary(globalConfig);    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(IP_NO_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedNoDmaMessage, result.get());}
public void metron_f4774_0()
{    HashMap<String, Object> globalConfig = new HashMap<>();    globalConfig.put(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath());    GeoLiteCityDatabase.INSTANCE.updateIfNecessary(globalConfig);    Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(IP_NO_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedNoDmaMessage, result.get());    globalConfig.put(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile_update.getAbsolutePath());    GeoLiteCityDatabase.INSTANCE.updateIfNecessary(globalConfig);    result = GeoLiteCityDatabase.INSTANCE.get(IP_NO_DMA);    Assert.assertEquals("Remote Local IP should return result based on DB", expectedNoDmaMessage, result.get());}
public void metron_f4775_0()
{    String fakeFile = "fakefile.geolitecitydbtest";    Map<String, Object> globalConfig = Collections.singletonMap(GeoLiteCityDatabase.GEO_HDFS_FILE, fakeFile);    Assert.assertEquals(GeoLiteCityDatabase.INSTANCE.determineHdfsDirWithFallback(globalConfig, fakeFile, ""), fakeFile);}
public void metron_f4776_0()
{    String defaultFile = GeoLiteCityDatabase.GEO_HDFS_FILE_DEFAULT;    Map<String, Object> globalConfig = Collections.singletonMap(GeoLiteCityDatabase.GEO_HDFS_FILE, defaultFile);    Assert.assertEquals(GeoLiteCityDatabase.INSTANCE.determineHdfsDirWithFallback(globalConfig, defaultFile, ""), defaultFile);}
public void metron_f4777_0()
{    String defaultFile = GeoLiteCityDatabase.GEO_HDFS_FILE_DEFAULT;    Assert.assertEquals(GeoLiteCityDatabase.INSTANCE.determineHdfsDirWithFallback(Collections.emptyMap(), defaultFile, "fallback"), defaultFile);}
public void metron_f4778_0() throws IOException
{    String fakeFile = "fakefile.geolitecitydbtest";    File file = File.createTempFile(this.getClass().getSimpleName(), "testfile");    file.deleteOnExit();    String fileName = file.getAbsolutePath();    Assert.assertEquals(GeoLiteCityDatabase.INSTANCE.determineHdfsDirWithFallback(Collections.emptyMap(), fakeFile, fileName), fileName);}
public void metron_f4779_0() throws Exception
{    final MockHTable trackerTable = (MockHTable) MockHBaseTableProvider.addToCache(atTableName, cf);    final MockHTable hbaseTable = (MockHTable) MockHBaseTableProvider.addToCache(hbaseTableName, cf);    EnrichmentHelper.INSTANCE.load(hbaseTable, cf, new ArrayList<LookupKV<EnrichmentKey, EnrichmentValue>>() {        {            add(new LookupKV<>(new EnrichmentKey(PLAYFUL_CLASSIFICATION_TYPE, "10.0.2.3"), new EnrichmentValue(PLAYFUL_ENRICHMENT)));        }    });    EnrichmentHelper.INSTANCE.load(hbaseTable, cf1, new ArrayList<LookupKV<EnrichmentKey, EnrichmentValue>>() {        {            add(new LookupKV<>(new EnrichmentKey(CF1_CLASSIFICATION_TYPE, "10.0.2.4"), new EnrichmentValue(CF1_ENRICHMENT)));        }    });    BloomAccessTracker bat = new BloomAccessTracker(hbaseTableName, 100, 0.03);    PersistentAccessTracker pat = new PersistentAccessTracker(hbaseTableName, "0", trackerTable, cf, bat, 0L);    lookup = new EnrichmentLookup(hbaseTable, cf, pat);    JSONParser jsonParser = new JSONParser();    expectedMessage = (JSONObject) jsonParser.parse(expectedMessageString);}
public void metron_f4780_0() throws Exception
{    SimpleHBaseAdapter sha = new SimpleHBaseAdapter();    sha.lookup = lookup;    SensorEnrichmentConfig broSc = JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    JSONObject actualMessage = sha.enrich(new CacheKey("test", "test", broSc));    Assert.assertEquals(actualMessage, new JSONObject());    actualMessage = sha.enrich(new CacheKey("ip_dst_addr", "10.0.2.3", broSc));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(expectedMessage, actualMessage);}
public void metron_f4781_0() throws Exception
{    SimpleHBaseAdapter sha = new SimpleHBaseAdapter();    sha.lookup = lookup;    SensorEnrichmentConfig broSc = JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    JSONObject actualMessage = sha.enrich(new CacheKey("test", "test", broSc));    Assert.assertEquals(actualMessage, new JSONObject());    actualMessage = sha.enrich(new CacheKey("ip_dst_addr", 10L, broSc));    Assert.assertEquals(actualMessage, new JSONObject());}
public void metron_f4782_0() throws Exception
{    SimpleHBaseAdapter sha = new SimpleHBaseAdapter();    sha.lookup = lookup;    SensorEnrichmentConfig broSc = JSONUtils.INSTANCE.load(sourceConfigWithCFStr, SensorEnrichmentConfig.class);    JSONObject actualMessage = sha.enrich(new CacheKey("test", "test", broSc));    Assert.assertEquals(actualMessage, new JSONObject());    actualMessage = sha.enrich(new CacheKey("ip_dst_addr", "10.0.2.4", broSc));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(new JSONObject(ImmutableMap.of("cf1.key", "value")), actualMessage);}
public void metron_f4783_0() throws Exception
{    SimpleHBaseAdapter sha = new SimpleHBaseAdapter();    sha.lookup = lookup;    SensorEnrichmentConfig broSc = JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    JSONObject actualMessage = sha.enrich(new CacheKey("test", "test", broSc));    Assert.assertEquals(actualMessage, new JSONObject());    actualMessage = sha.enrich(new CacheKey("ip_dst_addr", "10.0.2.4", broSc));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(new JSONObject(new HashMap<String, Object>()), actualMessage);}
public void metron_f4784_0()
{    SimpleHBaseConfig config = new SimpleHBaseConfig();    SimpleHBaseAdapter sha = new SimpleHBaseAdapter(config);    sha.initializeAdapter(null);}
public void metron_f4785_0()
{    SimpleHBaseConfig shc = new SimpleHBaseConfig();    shc.withHBaseCF(cf);    shc.withHBaseTable(table);    provider = new HTableProvider();    Assert.assertEquals(cf, shc.getHBaseCF());    Assert.assertEquals(table, shc.getHBaseTable());}
private JSONObject metron_f4786_0(JSONObject message, String field, ConfigHandler handler)
{    VariableResolver resolver = new MapVariableResolver(message);    return StellarAdapter.process(message, handler, field, 1000L, processor, resolver, Context.EMPTY_CONTEXT());}
public void metron_f4787_0() throws Exception
{    for (String c : DEFAULT_CONFIGS) {        JSONObject message = getMessage();        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        JSONObject enriched = enrich(message, "", handler);        Assert.assertEquals("STELLAR_TEST", enriched.get("stmt1"));        Assert.assertEquals("stellar_test", enriched.get("stmt2"));        Assert.assertEquals("foo", enriched.get("stmt3"));        Assert.assertEquals(3, enriched.size());    }}
public void metron_f4788_0() throws Exception
{    for (String c : GROUPED_CONFIGS) {        JSONObject message = getMessage();        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        {            JSONObject enriched = enrich(message, "group1", handler);            Assert.assertEquals("STELLAR_TEST", enriched.get("stmt1"));            Assert.assertEquals("stellar_test", enriched.get("stmt2"));            Assert.assertEquals(2, enriched.size());        }        {            JSONObject enriched = enrich(message, "group2", handler);            Assert.assertEquals("foo", enriched.get("stmt3"));            Assert.assertEquals(1, enriched.size());        }    }}
public void metron_f4789_0() throws Exception
{    for (String c : MIXED_CONFIGS) {        JSONObject message = getMessage();        EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(c, EnrichmentConfig.class);        Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));        ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");        {            JSONObject enriched = enrich(message, "group1", handler);            Assert.assertEquals("STELLAR_TEST", enriched.get("stmt1"));            Assert.assertEquals("stellar_test", enriched.get("stmt2"));            Assert.assertEquals(2, enriched.size());        }        {            JSONObject enriched = enrich(message, "group2", handler);            Assert.assertEquals("foo", enriched.get("stmt3"));            Assert.assertEquals(1, enriched.size());        }        {            JSONObject enriched = enrich(message, "", handler);            Assert.assertEquals(2, enriched.get("stmt4"));            Assert.assertEquals("stellar_test", enriched.get("stmt5"));            Assert.assertEquals(2, enriched.size());        }    }}
public void metron_f4790_0() throws Exception
{    JSONObject message = getMessage();    EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(tempVarStellarConfig_list, EnrichmentConfig.class);    Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));    ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");    {        JSONObject enriched = enrich(message, "group1", handler);        Assert.assertEquals("stellar_test", enriched.get("stmt2"));        Assert.assertEquals(1, enriched.size());    }    {        JSONObject enriched = enrich(message, "group2", handler);        Assert.assertEquals("foo", enriched.get("stmt3"));        Assert.assertEquals(1, enriched.size());    }    {        JSONObject enriched = enrich(message, "", handler);        Assert.assertEquals(2, enriched.get("stmt4"));        Assert.assertEquals("stellar_test", enriched.get("stmt5"));        Assert.assertEquals(2, enriched.size());    }}
private void metron_f4791_0(String config, String field) throws Exception
{    JSONObject message = getMessage();    EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(config, EnrichmentConfig.class);    Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));    ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");    JSONObject enriched = enrich(message, field, handler);    Assert.assertEquals(2, enriched.size());    Assert.assertEquals("stellar_test", enriched.get("stmt2.foo"));    Assert.assertEquals("stellar_test".toUpperCase(), enriched.get("stmt1"));}
public void metron_f4792_0() throws Exception
{    testMapEnrichment(mapConfig_subgroup, "group1");}
public void metron_f4793_0() throws Exception
{    testMapEnrichment(mapConfig_default, "");}
public void metron_f4794_0() throws Exception
{    JSONObject message = getMessage();    EnrichmentConfig enrichmentConfig = JSONUtils.INSTANCE.load(allVariableConfig, EnrichmentConfig.class);    Assert.assertNotNull(enrichmentConfig.getEnrichmentConfigs().get("stellar"));    ConfigHandler handler = enrichmentConfig.getEnrichmentConfigs().get("stellar");    JSONObject enriched = enrich(message, "", handler);    Assert.assertEquals("stellar_test", enriched.get("stmt1"));}
public Table metron_f4795_0(Configuration config, String tableName) throws IOException
{    throw new IOException();}
public void metron_f4796_0() throws Exception
{    final MockHTable trackerTable = (MockHTable) MockHBaseTableProvider.addToCache(atTableName, cf);    final MockHTable threatIntelTable = (MockHTable) MockHBaseTableProvider.addToCache(threatIntelTableName, cf);    EnrichmentHelper.INSTANCE.load(threatIntelTable, cf, new ArrayList<LookupKV<EnrichmentKey, EnrichmentValue>>() {        {            add(new LookupKV<>(new EnrichmentKey("10.0.2.3", "10.0.2.3"), new EnrichmentValue(new HashMap<>())));        }    });    BloomAccessTracker bat = new BloomAccessTracker(threatIntelTableName, 100, 0.03);    PersistentAccessTracker pat = new PersistentAccessTracker(threatIntelTableName, "0", trackerTable, cf, bat, 0L);    lookup = new EnrichmentLookup(threatIntelTable, cf, pat);    JSONParser jsonParser = new JSONParser();    expectedMessage = (JSONObject) jsonParser.parse(expectedMessageString);}
public void metron_f4797_0() throws Exception
{    ThreatIntelAdapter tia = new ThreatIntelAdapter();    tia.lookup = lookup;    SensorEnrichmentConfig broSc = JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    JSONObject actualMessage = tia.enrich(new CacheKey("ip_dst_addr", "10.0.2.3", broSc));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(expectedMessage, actualMessage);}
public void metron_f4798_0() throws Exception
{    ThreatIntelAdapter tia = new ThreatIntelAdapter();    tia.lookup = lookup;    SensorEnrichmentConfig broSc = JSONUtils.INSTANCE.load(sourceConfigStr, SensorEnrichmentConfig.class);    JSONObject actualMessage = tia.enrich(new CacheKey("ip_dst_addr", "10.0.2.3", broSc));    Assert.assertNotNull(actualMessage);    Assert.assertEquals(expectedMessage, actualMessage);    actualMessage = tia.enrich(new CacheKey("ip_dst_addr", 10L, broSc));    Assert.assertEquals(actualMessage, new JSONObject());}
public void metron_f4799_0()
{    String cf = "cf";    String table = "threatintel";    String trackCf = "cf";    String trackTable = "Track";    double falsePositive = 0.03;    int expectedInsertion = 1;    long millionseconds = (long) 0.1;    ThreatIntelConfig config = new ThreatIntelConfig();    config.withHBaseCF(cf);    config.withHBaseTable(table);    config.withExpectedInsertions(expectedInsertion);    config.withFalsePositiveRate(falsePositive);    config.withMillisecondsBetweenPersists(millionseconds);    config.withTrackerHBaseCF(trackCf);    config.withTrackerHBaseTable(trackTable);    config.withProviderImpl(ExceptionProvider.class.getName());    ThreatIntelAdapter tia = new ThreatIntelAdapter(config);    UnitTestHelper.setLog4jLevel(ThreatIntelAdapter.class, Level.FATAL);    tia.initializeAdapter(null);    UnitTestHelper.setLog4jLevel(ThreatIntelAdapter.class, Level.ERROR);    Assert.assertFalse(tia.isInitialized());}
public void metron_f4800_0()
{    ThreatIntelConfig tic = new ThreatIntelConfig();    tic.withHBaseCF(cf);    tic.withHBaseTable(table);    tic.withExpectedInsertions(expectedInsertion);    tic.withFalsePositiveRate(falsePositive);    tic.withMillisecondsBetweenPersists(millionseconds);    tic.withTrackerHBaseCF(trackCf);    tic.withTrackerHBaseTable(trackTable);    Assert.assertEquals(cf, tic.getHBaseCF());    Assert.assertEquals(table, tic.getHBaseTable());    Assert.assertEquals(trackCf, tic.getTrackerHBaseCF());    Assert.assertEquals(trackTable, tic.getTrackerHBaseTable());    Assert.assertEquals(expectedInsertion, tic.getExpectedInsertions());    Assert.assertEquals(millionseconds, tic.getMillisecondsBetweenPersists());}
public void metron_f4801_0() throws IOException
{    fs = FileSystem.get(new Configuration());    data = new ArrayList<>();    {        data.add("apache");        data.add("metron");        data.add("is");        data.add("great");    }    cache = new ObjectCache();    tempDir = TestUtils.createTempDir(this.getClass().getName());}
public void metron_f4802_0() throws Exception
{    String filename = "test.ser";    Assert.assertTrue(cache.isEmpty() || !cache.containsKey(filename));    assertDataIsReadCorrectly(filename);}
public void metron_f4803_0(String filename) throws IOException
{    File file = new File(tempDir, filename);    try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file))) {        IOUtils.write(SerDeUtils.toBytes(data), bos);    }    cache.initialize(new ObjectCacheConfig(new HashMap<>()));    List<String> readData = (List<String>) cache.get(file.getAbsolutePath());    Assert.assertEquals(readData, data);    Assert.assertTrue(cache.containsKey(file.getAbsolutePath()));}
public void metron_f4804_0() throws Exception
{    String filename = "testmulti.ser";    Assert.assertTrue(cache.isEmpty() || !cache.containsKey(filename));    Thread[] ts = new Thread[10];    for (int i = 0; i < ts.length; ++i) {        ts[i] = new Thread(() -> {            try {                assertDataIsReadCorrectly(filename);            } catch (Exception e) {                throw new IllegalStateException(e.getMessage(), e);            }        });        ts[i].start();    }    for (Thread t : ts) {        t.join();    }}
public void metron_f4805_0() throws Exception
{    String filename = "maxSizeException.ser";    File file = new File(tempDir, filename);    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage(String.format("File at path '%s' is larger than the configured max file size of 1", file.getAbsolutePath()));    try (BufferedOutputStream bos = new BufferedOutputStream(fs.create(new Path(file.getAbsolutePath()), true))) {        IOUtils.write(SerDeUtils.toBytes(data), bos);    }    ObjectCacheConfig objectCacheConfig = new ObjectCacheConfig(new HashMap<>());    objectCacheConfig.setMaxFileSize(1);    cache.initialize(objectCacheConfig);    cache.get(file.getAbsolutePath());}
public void metron_f4806_0()
{    EnrichmentKey k1 = new EnrichmentKey("type", "indicator1");    byte[] serialized = k1.toBytes();    EnrichmentKey k2 = new EnrichmentKey();    k2.fromBytes(serialized);    Assert.assertEquals(k1, k2);}
public void metron_f4807_0() throws IOException
{    EnrichmentConverter converter = new EnrichmentConverter();    EnrichmentKey k1 = new EnrichmentKey("type", "indicator");    EnrichmentValue v1 = new EnrichmentValue(new HashMap<String, Object>() {        {            put("k1", "v1");            put("k2", "v2");        }    });    Put serialized = converter.toPut("cf", k1, v1);    LookupKV<EnrichmentKey, EnrichmentValue> kv = converter.fromPut(serialized, "cf");    Assert.assertEquals(k1, kv.getKey());    Assert.assertEquals(v1, kv.getValue());}
public void metron_f4808_0(CacheKey value)
{}
public JSONObject metron_f4809_0(CacheKey value)
{    return null;}
public boolean metron_f4810_0(Map<String, Object> config)
{    return false;}
public void metron_f4811_0(Map<String, Object> config)
{}
public void metron_f4812_0()
{}
public String metron_f4813_0(CacheKey value)
{    return null;}
public void metron_f4814_0(CacheKey value)
{    numAccesses.incrementAndGet();}
public static void metron_f4815_0()
{    ConcurrencyContext infrastructure = new ConcurrencyContext();    infrastructure.initialize(5, 100, 10, null, null, false);    stellarContext = new Context.Builder().build();    StellarFunctions.initialize(stellarContext);    StellarAdapter adapter = new AccessLoggingStellarAdapter().ofType("ENRICHMENT");    adapter.initializeAdapter(new HashMap<>());    EnrichmentAdapter<CacheKey> dummy = new DummyEnrichmentAdapter();    enrichmentsByType = ImmutableMap.of("stellar", adapter, "dummy", dummy);    enricher = new ParallelEnricher(enrichmentsByType, infrastructure, false);}
public void metron_f4816_0() throws Exception
{    numAccesses.set(0);    JSONObject message = new JSONObject() {        {            put(Constants.SENSOR_TYPE, "test");        }    };    for (int i = 0; i < 10; ++i) {        SensorEnrichmentConfig config = JSONUtils.INSTANCE.load(goodConfig, SensorEnrichmentConfig.class);        config.getConfiguration().putIfAbsent("stellarContext", stellarContext);        ParallelEnricher.EnrichmentResult result = enricher.apply(message, EnrichmentStrategies.ENRICHMENT, config, null);    }        Assert.assertTrue(2 >= numAccesses.get());}
public void metron_f4817_0() throws Exception
{    SensorEnrichmentConfig config = JSONUtils.INSTANCE.load(goodConfig, SensorEnrichmentConfig.class);    config.getConfiguration().putIfAbsent("stellarContext", stellarContext);    JSONObject message = new JSONObject() {        {            put(Constants.SENSOR_TYPE, "test");        }    };    ParallelEnricher.EnrichmentResult result = enricher.apply(message, EnrichmentStrategies.ENRICHMENT, config, null);    JSONObject ret = result.getResult();    Assert.assertEquals("Got the wrong result count: " + ret, 11, ret.size());    Assert.assertEquals(1, ret.get("map.blah"));    Assert.assertEquals("test", ret.get("source.type"));    Assert.assertEquals(1, ret.get("one"));    Assert.assertEquals(2, ret.get("foo"));    Assert.assertEquals("TEST", ret.get("ALL_CAPS"));    Assert.assertEquals(0, result.getEnrichmentErrors().size());    Assert.assertTrue(result.getResult().containsKey("adapter.accessloggingstellaradapter.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("adapter.accessloggingstellaradapter.end.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.splitter.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.splitter.end.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.enrich.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.enrich.end.ts"));}
public void metron_f4818_0() throws Exception
{    SensorEnrichmentConfig config = JSONUtils.INSTANCE.load(nullConfig, SensorEnrichmentConfig.class);    config.getConfiguration().putIfAbsent("stellarContext", stellarContext);    JSONObject message = new JSONObject() {        {            put(Constants.SENSOR_TYPE, "test");        }    };    ParallelEnricher.EnrichmentResult result = enricher.apply(message, EnrichmentStrategies.ENRICHMENT, config, null);    JSONObject ret = result.getResult();    Assert.assertEquals("Got the wrong result count: " + ret, 7, ret.size());    Assert.assertTrue(result.getResult().containsKey("adapter.dummyenrichmentadapter.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("adapter.dummyenrichmentadapter.end.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.splitter.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.splitter.end.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.enrich.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.enrich.end.ts"));}
public void metron_f4819_0() throws Exception
{    SensorEnrichmentConfig config = JSONUtils.INSTANCE.load(badConfig, SensorEnrichmentConfig.class);    config.getConfiguration().putIfAbsent("stellarContext", stellarContext);    JSONObject message = new JSONObject() {        {            put(Constants.SENSOR_TYPE, "test");        }    };    ParallelEnricher.EnrichmentResult result = enricher.apply(message, EnrichmentStrategies.ENRICHMENT, config, null);    JSONObject ret = result.getResult();    Assert.assertEquals(ret + " is not what I expected", 11, ret.size());    Assert.assertEquals(1, ret.get("map.blah"));    Assert.assertEquals("test", ret.get("source.type"));    Assert.assertEquals(1, ret.get("one"));    Assert.assertEquals(2, ret.get("foo"));    Assert.assertEquals("TEST", ret.get("ALL_CAPS"));    Assert.assertEquals(1, result.getEnrichmentErrors().size());    Assert.assertTrue(result.getResult().containsKey("adapter.accessloggingstellaradapter.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("adapter.accessloggingstellaradapter.end.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.splitter.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.splitter.end.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.enrich.begin.ts"));    Assert.assertTrue(result.getResult().containsKey("parallelenricher.enrich.end.ts"));}
public void metron_f4820_0() throws Exception
{    SensorEnrichmentConfig config = JSONUtils.INSTANCE.load(badConfigWrongEnrichmentType, SensorEnrichmentConfig.class);    config.getConfiguration().putIfAbsent("stellarContext", stellarContext);    JSONObject message = new JSONObject() {        {            put(Constants.SENSOR_TYPE, "test");        }    };    try {        enricher.apply(message, EnrichmentStrategies.ENRICHMENT, config, null);        Assert.fail("This is an invalid config, we should have failed.");    } catch (IllegalStateException ise) {        Assert.assertEquals(ise.getMessage(), "Unable to find an adapter for hbaseThreatIntel, possible adapters are: " + Joiner.on(",").join(enrichmentsByType.keySet()));    }}
public static void metron_f4821_0()
{        expectedMessage.put("autonomous_system_organization", "Google LLC");    expectedMessage.put("autonomous_system_number", 15169);    expectedMessage.put("network", "8.8.4.0");    expectedSubsetMessage.put("autonomous_system_organization", "Google LLC");    expectedSubsetMessage.put("autonomous_system_number", 15169);    String baseDir = UnitTestHelper.findDir("GeoLite");    asnHdfsFile = new File(new File(baseDir), "GeoLite2-ASN.tar.gz");}
public void metron_f4822_0() throws Exception
{    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> ImmutableMap.of(GeoLiteAsnDatabase.ASN_HDFS_FILE, asnHdfsFile.getAbsolutePath())).build();}
public Object metron_f4823_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    Assert.assertTrue(rule + " not valid.", processor.validate(rule, context));    return processor.parse(rule, new DefaultVariableResolver(variables::get, variables::containsKey), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f4824_0()
{    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> ImmutableMap.of(GeoLiteAsnDatabase.ASN_HDFS_FILE, "./fakefile.mmdb")).build();    String stellar = "ASN_GET()";    try {        run(stellar, ImmutableMap.of());    } catch (Exception expected) {        Assert.assertTrue(expected.getMessage().contains("File fakefile.mmdb does not exist"));    }}
public void metron_f4825_0()
{    String stellar = "ASN_GET()";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Null IP should return null", result);    try {        GeoLiteAsnDatabase.INSTANCE.updateIfNecessary(Collections.singletonMap(GeoLiteAsnDatabase.ASN_HDFS_FILE, "./fakefile.mmdb"));    } catch (IllegalStateException e) {        }        result = run(stellar, ImmutableMap.of());    Assert.assertNull("Null IP should return null", result);}
public void metron_f4826_0()
{    String stellar = "ASN_GET()";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Empty IP should return null", result);}
public void metron_f4827_0()
{    String stellar = "ASN_GET(null)";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Null IP should return null", result);}
public void metron_f4828_0()
{    String stellar = "ASN_GET(undefined)";    run(stellar, ImmutableMap.of());}
public void metron_f4829_0()
{    String stellar = "ASN_GET('  ')";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Empty IP should return null", result);}
public void metron_f4830_0()
{    String stellar = "ASN_GET('192.168.0.1')";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Local IP should return empty map", new HashMap<String, String>(), result);}
public void metron_f4831_0() throws Exception
{    String stellar = "ASN_GET('8.8.4.0')";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Remote IP should return result based on DB", expectedMessage, result);}
public void metron_f4832_0() throws Exception
{    String stellar = "ASN_GET('8.8.4.0', ['autonomous_system_organization'])";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Remote IP should return country result based on DB", "Google LLC", result);}
public void metron_f4833_0() throws Exception
{    String stellar = "ASN_GET('8.8.4.0', ['autonomous_system_number'])";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Remote IP should return country result based on DB", 15169, result);}
public void metron_f4834_0() throws Exception
{    String stellar = "ASN_GET('8.8.4.0', ['autonomous_system_organization', 'autonomous_system_number'])";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Remote IP should return country result based on DB", expectedSubsetMessage, result);}
public void metron_f4835_0() throws Exception
{    String stellar = "ASN_GET('8.8.4.0', ['autonomous_system_organization', 'autonomous_system_number', 'network'], 'garbage')";    run(stellar, ImmutableMap.of());}
public static void metron_f4836_0(String... argv)
{    List<StellarFunctionInfo> functions = Lists.newArrayList(SingletonFunctionResolver.getInstance().getFunctionInfo());    Collections.sort(functions, (o1, o2) -> o1.getName().compareTo(o2.getName()));    for (StellarFunctionInfo info : functions) {        System.out.println("### `" + info.getName() + "`");        System.out.println("  * Description: " + info.getDescription());        System.out.println("  * Input:");        for (String param : info.getParams()) {            System.out.println("    * " + param);        }        System.out.println("  * Returns: " + info.getReturns());        System.out.println("");    }}
public void metron_f4837_0() throws Exception
{    File tempDir = TestUtils.createTempDir(this.getClass().getName());    file = new File(tempDir, "enrichment.ser");    try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file))) {        IOUtils.write(SerDeUtils.toBytes(new HashMap<String, Object>() {            {                put("key", "value");            }        }), bos);    }}
public void metron_f4838_0()
{    String expression = String.format("ENRICHMENT_OBJECT_GET('%s', '%s')", file.getAbsolutePath(), "key");    String value = (String) StellarProcessorUtils.run(expression, new HashMap<>());    assertEquals("value", value);}
public void metron_f4839_0()
{    thrown.expect(ParseException.class);    thrown.expectMessage("Unable to parse ENRICHMENT_OBJECT_GET('/some/path', 'key'): Unable to parse: ENRICHMENT_OBJECT_GET('/some/path', 'key') due to: Path '/some/path' could not be found in HDFS");    String expression = String.format("ENRICHMENT_OBJECT_GET('%s', '%s')", "/some/path", "key");    StellarProcessorUtils.run(expression, new HashMap<>());}
public void metron_f4840_0() throws Exception
{    enrichmentObjectGet = new EnrichmentObjectGet();    objectCache = mock(ObjectCache.class);    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, HashMap::new).build();    whenNew(ObjectCache.class).withNoArguments().thenReturn(objectCache);}
public void metron_f4841_0() throws Exception
{    when(objectCache.isInitialized()).thenReturn(true);    enrichmentObjectGet.initialize(context);    ObjectCacheConfig expectedConfig = new ObjectCacheConfig(new HashMap<>());    verify(objectCache, times(1)).initialize(expectedConfig);    assertTrue(enrichmentObjectGet.isInitialized());}
public void metron_f4842_0() throws Exception
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(ENRICHMENT_OBJECT_GET_SETTINGS, new HashMap<String, Object>() {                {                    put(OBJECT_CACHE_SIZE_KEY, 1);                    put(OBJECT_CACHE_EXPIRATION_KEY, 2);                    put(OBJECT_CACHE_TIME_UNIT_KEY, "SECONDS");                    put(OBJECT_CACHE_MAX_FILE_SIZE_KEY, 3);                }            });        }    };    when(objectCache.isInitialized()).thenReturn(true);    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig).build();    assertFalse(enrichmentObjectGet.isInitialized());    enrichmentObjectGet.initialize(context);    ObjectCacheConfig expectedConfig = new ObjectCacheConfig(new HashMap<>());    expectedConfig.setCacheSize(1);    expectedConfig.setCacheExpiration(2);    expectedConfig.setTimeUnit(TimeUnit.SECONDS);    expectedConfig.setMaxFileSize(3);    verify(objectCache, times(1)).initialize(expectedConfig);    assertTrue(enrichmentObjectGet.isInitialized());}
public void metron_f4843_0()
{    Map<String, Object> enrichment = new HashMap<String, Object>() {        {            put("key", "value");        }    };    when(objectCache.get("/path")).thenReturn(enrichment);    assertNull(enrichmentObjectGet.apply(Arrays.asList("/path", "key"), context));    when(objectCache.isInitialized()).thenReturn(true);    enrichmentObjectGet.initialize(context);    assertNull(enrichmentObjectGet.apply(Arrays.asList(null, null), context));    assertEquals("value", enrichmentObjectGet.apply(Arrays.asList("/path", "key"), context));}
public void metron_f4844_0()
{    thrown.expect(ClassCastException.class);    thrown.expectMessage("The object stored in HDFS at '/path' must be serialized in JSON format.");    when(objectCache.get("/path")).thenReturn("incorrect format");    when(objectCache.isInitialized()).thenReturn(true);    enrichmentObjectGet.initialize(context);    enrichmentObjectGet.apply(Arrays.asList("/path", "key"), context);}
public void metron_f4845_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage("All parameters are mandatory, submit 'hdfs path', 'indicator'");    enrichmentObjectGet.apply(new ArrayList<>(), context);}
public static void metron_f4846_0() throws ParseException
{    JSONParser jsonParser = new JSONParser();    expectedMessage = (JSONObject) jsonParser.parse(expectedMessageString);    expectedSubsetMessage = (JSONObject) jsonParser.parse(expectedSubsetString);    String baseDir = UnitTestHelper.findDir("GeoLite");    geoHdfsFile = new File(new File(baseDir), "GeoLite2-City.mmdb.gz");}
public void metron_f4847_0() throws Exception
{    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> ImmutableMap.of(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath())).build();}
public Object metron_f4848_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    Assert.assertTrue(rule + " not valid.", processor.validate(rule, context));    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f4849_0()
{    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> ImmutableMap.of(GeoLiteCityDatabase.GEO_HDFS_FILE, "./fakefile.mmdb")).build();    String stellar = "GEO_GET()";    try {        run(stellar, ImmutableMap.of());    } catch (Exception expected) {        Assert.assertTrue(expected.getMessage().contains("File fakefile.mmdb does not exist"));    }}
public void metron_f4850_0()
{    String stellar = "GEO_GET()";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Null IP should return null", result);    try {        GeoLiteCityDatabase.INSTANCE.updateIfNecessary(Collections.singletonMap(GeoLiteCityDatabase.GEO_HDFS_FILE, "./fakefile.mmdb"));    } catch (IllegalStateException e) {        }        result = run(stellar, ImmutableMap.of());    Assert.assertNull("Null IP should return null", result);}
public void metron_f4851_0()
{    String stellar = "GEO_GET()";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Empty IP should return null", result);}
public void metron_f4852_0()
{    String stellar = "GEO_GET(null)";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Null IP should return null", result);}
public void metron_f4853_0()
{    String stellar = "GEO_GET(undefined)";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Null IP should return null", result);}
public void metron_f4854_0()
{    String stellar = "GEO_GET('  ')";    Object result = run(stellar, ImmutableMap.of());    Assert.assertNull("Empty IP should return null", result);}
public void metron_f4855_0()
{    String stellar = "GEO_GET('192.168.0.1')";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Local IP should return empty map", new HashMap<String, String>(), result);}
public void metron_f4856_0()
{    String stellar = "GEO_GET('216.160.83.56')";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Remote IP should return result based on DB", expectedMessage, result);}
public void metron_f4857_0()
{    String stellar = "GEO_GET('216.160.83.56', ['country'])";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Remote IP should return country result based on DB", "US", result);}
public void metron_f4858_0()
{    String stellar = "GEO_GET('216.160.83.56', ['country', 'city', 'dmaCode', 'location_point'])";    Object result = run(stellar, ImmutableMap.of());    Assert.assertEquals("Remote IP should return country result based on DB", expectedSubsetMessage, result);}
public void metron_f4859_0()
{    String stellar = "GEO_GET('216.160.83.56', ['country', 'city', 'dmaCode', 'location_point'], 'garbage')";    run(stellar, ImmutableMap.of());}
public void metron_f4860_0() throws Exception
{    Map<String, Object> latLong = (Map<String, Object>) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(hash)", ImmutableMap.of("hash", explicitJutlandHash));    Assert.assertEquals(jutlandPoint.getLatitude(), (double) latLong.get("latitude"), 1e-3);    Assert.assertEquals(jutlandPoint.getLongitude(), (double) latLong.get("longitude"), 1e-3);}
public void metron_f4861_0() throws Exception
{    {        Map<String, Object> latLong = (Map<String, Object>) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(hash)", ImmutableMap.of("hash", "u"));        Assert.assertFalse(Double.isNaN((double) latLong.get("latitude")));        Assert.assertFalse(Double.isNaN((double) latLong.get("longitude")));    }    {        Map<String, Object> latLong = (Map<String, Object>) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(hash)", ImmutableMap.of("hash", ""));        Assert.assertEquals(0d, (double) latLong.get("latitude"), 1e-3);        Assert.assertEquals(0d, (double) latLong.get("longitude"), 1e-3);    }    {        Map<String, Object> latLong = (Map<String, Object>) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(null)", new HashMap<>());        Assert.assertNull(latLong);    }}
public void metron_f4862_0() throws Exception
{    Assert.assertEquals("u4pruydqmv", StellarProcessorUtils.run("GEOHASH_FROM_LATLONG(lat, long, 10)", ImmutableMap.of("lat", jutlandPoint.getLatitude(), "long", jutlandPoint.getLongitude())));    Assert.assertEquals("u4pruydqmvpb", StellarProcessorUtils.run("GEOHASH_FROM_LATLONG(lat, long)", ImmutableMap.of("lat", jutlandPoint.getLatitude(), "long", jutlandPoint.getLongitude())));    Assert.assertEquals("u4pruydqmv".substring(0, 6), StellarProcessorUtils.run("GEOHASH_FROM_LATLONG(lat, long, 6)", ImmutableMap.of("lat", jutlandPoint.getLatitude(), "long", jutlandPoint.getLongitude())));    Assert.assertNull(StellarProcessorUtils.run("GEOHASH_FROM_LATLONG(lat)", ImmutableMap.of("lat", jutlandPoint.getLatitude())));    Assert.assertNull(StellarProcessorUtils.run("GEOHASH_FROM_LATLONG(lat, long, 10)", ImmutableMap.of("lat", "blah", "long", jutlandPoint.getLongitude())));}
public void metron_f4863_0() throws Exception
{    Map<String, String> loc = ImmutableMap.of("latitude", "" + jutlandPoint.getLatitude(), "longitude", "" + jutlandPoint.getLongitude());    Assert.assertEquals("u4pruydqmv", StellarProcessorUtils.run("GEOHASH_FROM_LOC(loc, 10)", ImmutableMap.of("loc", loc)));    Assert.assertEquals("u4pruydqmv".substring(0, 6), StellarProcessorUtils.run("GEOHASH_FROM_LOC(loc, 6)", ImmutableMap.of("loc", loc)));    Assert.assertEquals("u4pruydqmvpb", StellarProcessorUtils.run("GEOHASH_FROM_LOC(loc)", ImmutableMap.of("loc", loc)));    Assert.assertNull(StellarProcessorUtils.run("GEOHASH_FROM_LOC(loc)", ImmutableMap.of("loc", ImmutableMap.of("latitude", "57.64911"))));    Assert.assertNull(StellarProcessorUtils.run("GEOHASH_FROM_LOC(loc, 10)", ImmutableMap.of("loc", ImmutableMap.of("latitude", "blah", "longitude", "10.40740"))));}
public void metron_f4864_0() throws Exception
{    testDistance(Optional.empty());    testDistance(Optional.of("HAVERSINE"));}
public void metron_f4865_0() throws Exception
{    testDistance(Optional.of("LAW_OF_COSINES"));}
public void metron_f4866_0() throws Exception
{    testDistance(Optional.of("VICENTY"));}
public void metron_f4867_0() throws Exception
{    Double maxDistance = (double) StellarProcessorUtils.run("GEOHASH_MAX_DIST([empireState, mosconeCenter, jutland])", ImmutableMap.of("empireState", empireStateHash, "mosconeCenter", mosconeCenterHash, "jutland", jutlandHash));    double expectedDistance = 8528;    Assert.assertEquals(expectedDistance, maxDistance, 1d);}
public void metron_f4868_0() throws Exception
{    Double maxDistance = (double) StellarProcessorUtils.run("GEOHASH_MAX_DIST([jutland, mosconeCenter, empireState])", ImmutableMap.of("empireState", empireStateHash, "mosconeCenter", mosconeCenterHash, "jutland", jutlandHash));    double expectedDistance = 8528;    Assert.assertEquals(expectedDistance, maxDistance, 1d);}
public void metron_f4869_0() throws Exception
{    Double maxDistance = (double) StellarProcessorUtils.run("GEOHASH_MAX_DIST([jutland, mosconeCenter, empireState, null])", ImmutableMap.of("empireState", empireStateHash, "mosconeCenter", mosconeCenterHash, "jutland", jutlandHash));    double expectedDistance = 8528;    Assert.assertEquals(expectedDistance, maxDistance, 1d);}
public void metron_f4870_0() throws Exception
{    Double maxDistance = (double) StellarProcessorUtils.run("GEOHASH_MAX_DIST([jutland, jutland, jutland])", ImmutableMap.of("jutland", jutlandHash));    Assert.assertEquals(0, maxDistance, 1e-6d);}
public void metron_f4871_0() throws Exception
{    Double maxDistance = (double) StellarProcessorUtils.run("GEOHASH_MAX_DIST([])", new HashMap<>());    Assert.assertTrue(Double.isNaN(maxDistance));}
public void metron_f4872_0() throws Exception
{    Double maxDistance = (Double) StellarProcessorUtils.run("GEOHASH_MAX_DIST(null)", new HashMap<>());    Assert.assertNull(maxDistance);}
public void metron_f4873_0() throws Exception
{    Double maxDistance = (Double) StellarProcessorUtils.run("GEOHASH_MAX_DIST()", new HashMap<>());    Assert.assertNull(maxDistance);}
public void metron_f4874_0(Optional<String> method) throws Exception
{        double expectedDistance = 4128;    Map<String, Object> vars = ImmutableMap.of("empireState", empireStateHash, "mosconeCenter", mosconeCenterHash);        {        String stellarStatement = getDistStellarStatement(ImmutableList.of("mosconeCenter", "empireState"), method);        Assert.assertEquals(expectedDistance, (double) StellarProcessorUtils.run(stellarStatement, vars), 1D);    }    {        String stellarStatement = getDistStellarStatement(ImmutableList.of("empireState", "mosconeCenter"), method);        Assert.assertEquals(expectedDistance, (double) StellarProcessorUtils.run(stellarStatement, vars), 1D);    }}
private static String metron_f4875_0(List<String> hashVariables, Optional<String> method)
{    if (method.isPresent()) {        List<String> vars = new ArrayList<>();        vars.addAll(hashVariables);        vars.add("\'" + method.get() + "\'");        return "GEOHASH_DIST(" + Joiner.on(",").skipNulls().join(vars) + ")";    } else {        return "GEOHASH_DIST(" + Joiner.on(",").skipNulls().join(hashVariables) + ")";    }}
public void metron_f4876_0() throws Exception
{        {        double         expectedLong = -98.740087, expectedLat = 41.86921;        Map<String, Double> centroid = (Map) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(GEOHASH_CENTROID([empireState, mosconeCenter]))", ImmutableMap.of("empireState", empireStateHash, "mosconeCenter", mosconeCenterHash));        Assert.assertEquals(expectedLong, centroid.get("longitude"), 1e-3);        Assert.assertEquals(expectedLat, centroid.get("latitude"), 1e-3);    }        {        double expectedLong = empireStatePoint.getLongitude(), expectedLat = empireStatePoint.getLatitude();        Map<String, Double> centroid = (Map) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(GEOHASH_CENTROID([empireState, empireState]))", ImmutableMap.of("empireState", empireStateHash));        Assert.assertEquals(expectedLong, centroid.get("longitude"), 1e-3);        Assert.assertEquals(expectedLat, centroid.get("latitude"), 1e-3);    }        {        double expectedLong = empireStatePoint.getLongitude(), expectedLat = empireStatePoint.getLatitude();        Map<String, Double> centroid = (Map) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(GEOHASH_CENTROID([empireState]))", ImmutableMap.of("empireState", empireStateHash));        Assert.assertEquals(expectedLong, centroid.get("longitude"), 1e-3);        Assert.assertEquals(expectedLat, centroid.get("latitude"), 1e-3);    }        {        Map<String, Double> centroid = (Map) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(GEOHASH_CENTROID([]))", new HashMap<>());        Assert.assertNull(centroid);    }}
public void metron_f4877_0() throws Exception
{        {        double         expectedLong = -98.740087, expectedLat = 41.86921;        for (int weight = 1; weight < 10; ++weight) {            Map<Object, Integer> weightedPoints = ImmutableMap.of(empireStateHash, weight, mosconeCenterHash, weight);            Map<String, Double> centroid = (Map) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(GEOHASH_CENTROID(weightedPoints))", ImmutableMap.of("weightedPoints", weightedPoints));            Assert.assertEquals(expectedLong, centroid.get("longitude"), 1e-3);            Assert.assertEquals(expectedLat, centroid.get("latitude"), 1e-3);        }    }        {        double expectedLong = empireStatePoint.getLongitude(), expectedLat = empireStatePoint.getLatitude();        for (int weight = 1; weight < 10; ++weight) {            Map<Object, Integer> weightedPoints = ImmutableMap.of(empireStateHash, weight);            Map<String, Double> centroid = (Map) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(GEOHASH_CENTROID(weightedPoints))", ImmutableMap.of("weightedPoints", weightedPoints));            Assert.assertEquals(expectedLong, centroid.get("longitude"), 1e-3);            Assert.assertEquals(expectedLat, centroid.get("latitude"), 1e-3);        }    }        {        Map<Object, Integer> weightedPoints = new HashMap<>();        Map<String, Double> centroid = (Map) StellarProcessorUtils.run("GEOHASH_TO_LATLONG(GEOHASH_CENTROID(weightedPoints))", ImmutableMap.of("weightedPoints", weightedPoints));        Assert.assertNull(centroid);    }}
public void metron_f4878_0() throws Exception
{    File tempDir = TestUtils.createTempDir(this.getClass().getName());    file = new File(tempDir, "object.ser");    try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file))) {        IOUtils.write(SerDeUtils.toBytes("object get data"), bos);    }}
public void metron_f4879_0()
{    String expression = String.format("OBJECT_GET('%s')", file.getAbsolutePath());    String value = (String) StellarProcessorUtils.run(expression, new HashMap<>());    assertEquals("object get data", value);}
public void metron_f4880_0()
{    thrown.expect(ParseException.class);    thrown.expectMessage("Unable to parse OBJECT_GET('/some/path'): Unable to parse: OBJECT_GET('/some/path') due to: Path '/some/path' could not be found in HDFS");    String expression = String.format("OBJECT_GET('%s')", "/some/path");    StellarProcessorUtils.run(expression, new HashMap<>());}
public void metron_f4881_0() throws Exception
{    objectGet = new ObjectGet();    objectCache = mock(ObjectCache.class);    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, HashMap::new).build();    whenNew(ObjectCache.class).withNoArguments().thenReturn(objectCache);}
public void metron_f4882_0() throws Exception
{    when(objectCache.isInitialized()).thenReturn(true);    assertFalse(objectGet.isInitialized());    objectGet.initialize(context);    ObjectCacheConfig expectedConfig = new ObjectCacheConfig(new HashMap<>());    verify(objectCache, times(1)).initialize(expectedConfig);    assertTrue(objectGet.isInitialized());}
public void metron_f4883_0()
{    Object object = mock(Object.class);    when(objectCache.get("/path")).thenReturn(object);    assertNull(objectGet.apply(Collections.singletonList("/path"), context));    when(objectCache.isInitialized()).thenReturn(true);    objectGet.initialize(context);    assertNull(objectGet.apply(new ArrayList<>(), context));    assertNull(objectGet.apply(Collections.singletonList(null), context));    assertEquals(object, objectGet.apply(Collections.singletonList("/path"), context));}
public void metron_f4884_0()
{    thrown.expect(IllegalStateException.class);    thrown.expectMessage("Unable to retrieve 1 as it is not a path");    when(objectCache.isInitialized()).thenReturn(true);    objectGet.initialize(context);    objectGet.apply(Collections.singletonList(1), context);}
public void metron_f4885_0() throws Exception
{    final MockHTable hbaseTable = (MockHTable) MockHBaseTableProvider.addToCache(hbaseTableName, cf);    EnrichmentHelper.INSTANCE.load(hbaseTable, cf, new ArrayList<LookupKV<EnrichmentKey, EnrichmentValue>>() {        {            for (int i = 0; i < 5; ++i) {                add(new LookupKV<>(new EnrichmentKey(ENRICHMENT_TYPE, "indicator" + i), new EnrichmentValue(ImmutableMap.of("key" + i, "value" + i))));            }        }    });    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> ImmutableMap.of(SimpleHBaseEnrichmentFunctions.TABLE_PROVIDER_TYPE_CONF, MockHBaseTableProvider.class.getName())).build();}
public Object metron_f4886_0(String rule, Map<String, Object> variables) throws Exception
{    StellarProcessor processor = new StellarProcessor();    Assert.assertTrue(rule + " not valid.", processor.validate(rule, context));    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f4887_0() throws Exception
{    String stellar = "ENRICHMENT_EXISTS('et', indicator, 'enrichments', 'cf')";    Object result = run(stellar, ImmutableMap.of("indicator", "indicator0"));    Assert.assertTrue(result instanceof Boolean);    Assert.assertTrue((Boolean) result);}
public void metron_f4888_0() throws Exception
{    String stellar = "ENRICHMENT_EXISTS('et', indicator, 'enrichments', 'cf')";    Object result = run(stellar, ImmutableMap.of("indicator", "indicator7"));    Assert.assertTrue(result instanceof Boolean);    Assert.assertFalse((Boolean) result);}
public void metron_f4889_0() throws Exception
{    String stellar = "ENRICHMENT_GET('et', indicator, 'enrichments', 'cf')";    Object result = run(stellar, ImmutableMap.of("indicator", "indicator0"));    Assert.assertTrue(result instanceof Map);    Map<String, Object> out = (Map<String, Object>) result;    Assert.assertEquals("value0", out.get("key0"));}
public void metron_f4890_0() throws Exception
{    String stellar = "MAP([ 'indicator0', 'indicator1' ], indicator -> ENRICHMENT_GET('et', indicator, 'enrichments', 'cf') )";    Object result = run(stellar, new HashMap<>());    Assert.assertTrue(result instanceof List);    List<Map<String, Object>> out = (List<Map<String, Object>>) result;    Assert.assertEquals(2, out.size());    for (int i = 0; i < 2; ++i) {        Map<String, Object> map = out.get(i);        Assert.assertEquals("value" + i, map.get("key" + i));    }}
public void metron_f4891_0() throws Exception
{    String stellar = "ENRICHMENT_GET('et', indicator, 'enrichments', 'cf')";    Object result = run(stellar, ImmutableMap.of("indicator", "indicator7"));    Assert.assertTrue(result instanceof Map);    Map<String, Object> out = (Map<String, Object>) result;    Assert.assertTrue(out.isEmpty());}
public void metron_f4892_0() throws Exception
{    String stellar = "ENRICHMENT_GET('et', indicator)";    Object result = run(stellar, ImmutableMap.of("indicator", "indicator7"));}
public void metron_f4893_0() throws Exception
{    ThreatTriageProcessor threatTriageProcessor = getProcessor(smokeTestProcessorConfig);    Assert.assertEquals("Expected a score of 0", 0d, new ThreatTriageProcessor(new SensorEnrichmentConfig(), StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT()).apply(new HashMap<Object, Object>() {        {            put("user.type", "admin");            put("asset.type", "web");        }    }).getScore(), 1e-10);    Assert.assertEquals("Expected a score of 10", 10d, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("user.type", "admin");            put("asset.type", "web");        }    }).getScore(), 1e-10);    Assert.assertEquals("Expected a score of 5", 5d, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("user.type", "normal");            put("asset.type", "web");        }    }).getScore(), 1e-10);    Assert.assertEquals("Expected a score of 0", 0d, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("user.type", "foo");            put("asset.type", "bar");        }    }).getScore(), 1e-10);    Assert.assertEquals("Expected a score of -Inf", Double.NEGATIVE_INFINITY, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("user.type", "abnormal");            put("asset.type", "bar");        }    }).getScore(), 1e-10);}
public void metron_f4894_0() throws Exception
{    Map<Object, Object> message = new HashMap<Object, Object>() {        {            put("user.type", "admin");            put("asset.type", "web");        }    };    ThreatScore score = getProcessor(smokeTestProcessorConfig).apply(message);        List<String> expectedNames = ImmutableList.of("rule 1", "rule 2");    Assert.assertEquals(2, score.getRuleScores().size());    score.getRuleScores().forEach(ruleScore -> Assert.assertTrue(expectedNames.contains(ruleScore.getRule().getName())));}
public void metron_f4895_0() throws Exception
{    Map<Object, Object> message = new HashMap<Object, Object>() {        {            put("user.type", "abnormal");            put("asset.type", "invalid");        }    };    ThreatScore score = getProcessor(smokeTestProcessorConfig).apply(message);        List<String> expectedNames = ImmutableList.of("rule 4");    Assert.assertEquals(1, score.getRuleScores().size());    score.getRuleScores().forEach(ruleScore -> Assert.assertTrue(expectedNames.contains(ruleScore.getRule().getName())));}
public void metron_f4896_0() throws Exception
{    Map<Object, Object> message = new HashMap<Object, Object>() {        {            put("user.type", "foo");            put("asset.type", "bar");        }    };    ThreatScore score = getProcessor(smokeTestProcessorConfig).apply(message);        Assert.assertEquals(0, score.getRuleScores().size());}
public void metron_f4897_0() throws Exception
{    ThreatTriageProcessor threatTriageProcessor = getProcessor(positiveMeanProcessorConfig);    Assert.assertEquals("Expected a score of 0", 5d, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("user.type", "normal");            put("asset.type", "web");        }    }).getScore(), 1e-10);    Assert.assertEquals("Expected a score of 7.5", (10 + 5) / 2.0, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("user.type", "admin");            put("asset.type", "web");        }    }).getScore(), 1e-10);    Assert.assertEquals("Expected a score of 0", 0d, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("user.type", "foo");            put("asset.type", "bar");        }    }).getScore(), 1e-10);}
public void metron_f4898_0() throws Exception
{    ThreatTriageProcessor threatTriageProcessor = getProcessor(testWithStellarFunction);    Assert.assertEquals(10d, threatTriageProcessor.apply(new HashMap<Object, Object>() {        {            put("ip_dst_addr", "172.2.2.2");        }    }).getScore(), 1e-10);}
public void metron_f4899_0() throws Exception
{    Map<Object, Object> message = new HashMap<Object, Object>() {        {            put("variable.name", "variable.value");        }    };    ThreatScore score = getProcessor(testReasonConfig).apply(message);    assertEquals(1, score.getRuleScores().size());    for (RuleScore ruleScore : score.getRuleScores()) {                assertEquals("variable.value", ruleScore.getReason());    }}
public void metron_f4900_0() throws Exception
{    Map<Object, Object> message = new HashMap<Object, Object>() {        {                }    };    ThreatScore score = getProcessor(testReasonConfig).apply(message);    assertEquals(1, score.getRuleScores().size());    for (RuleScore ruleScore : score.getRuleScores()) {                assertEquals(null, ruleScore.getReason());    }}
public void metron_f4901_0() throws Exception
{    Map<String, Object> message = new HashMap<>();    ThreatTriageProcessor threatTriageProcessor = getProcessor(shouldAllowNumericRuleScore);    Assert.assertEquals(10d, threatTriageProcessor.apply(message).getScore(), 1e-10);}
public void metron_f4902_0() throws Exception
{        Map<Object, Object> message = new HashMap<Object, Object>() {        {            put("priority", 100);        }    };    ThreatTriageProcessor threatTriageProcessor = getProcessor(shouldAllowScoreAsStellarExpression);    Assert.assertEquals(1010.0d, threatTriageProcessor.apply(message).getScore(), 1e-10);}
private static ThreatTriageProcessor metron_f4903_0(String config) throws IOException
{    SensorEnrichmentConfig c = JSONUtils.INSTANCE.load(config, SensorEnrichmentConfig.class);    return new ThreatTriageProcessor(c, StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());}
public GenericEnrichmentBolt metron_f4904_0(Enrichment enrichment)
{    this.enrichmentType = enrichment.getType();    this.adapter = enrichment.getAdapter();    return this;}
public GenericEnrichmentBolt metron_f4905_0(long maxCacheSize)
{    this.maxCacheSize = maxCacheSize;    return this;}
public GenericEnrichmentBolt metron_f4906_0(long maxTimeRetain)
{    this.maxTimeRetain = maxTimeRetain;    return this;}
public GenericEnrichmentBolt metron_f4907_0(boolean cacheInvalidationOnReload)
{    this.invalidateCacheOnReload = cacheInvalidationOnReload;    return this;}
public void metron_f4908_0(String name, ConfigurationType type)
{    if (invalidateCacheOnReload) {        if (cache != null) {            cache.invalidateAll();        }    }    if (type == ConfigurationType.GLOBAL) {        adapter.updateAdapter(getConfigurations().getGlobalConfig());    }}
public void metron_f4909_1(Map conf, TopologyContext topologyContext, OutputCollector collector)
{    super.prepare(conf, topologyContext, collector);    this.collector = collector;    if (this.maxCacheSize == null)        throw new IllegalStateException("MAX_CACHE_SIZE_OBJECTS_NUM must be specified");    if (this.maxTimeRetain == null)        throw new IllegalStateException("MAX_TIME_RETAIN_MINUTES must be specified");    if (this.adapter == null)        throw new IllegalStateException("Adapter must be specified");    loader = key -> adapter.enrich(key);    cache = Caffeine.newBuilder().maximumSize(maxCacheSize).expireAfterWrite(maxTimeRetain, TimeUnit.MINUTES).build(loader);    boolean success = adapter.initializeAdapter(getConfigurations().getGlobalConfig());    if (!success) {                throw new IllegalStateException("Could not initialize adapter...");    }    perfLog = new PerformanceLogger(() -> getConfigurations().getGlobalConfig(), GenericEnrichmentBolt.Perf.class.getName());    initializeStellar();}
protected void metron_f4910_0()
{    stellarContext = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).with(Context.Capabilities.GLOBAL_CONFIG, () -> getConfigurations().getGlobalConfig()).with(Context.Capabilities.STELLAR_CONFIG, () -> getConfigurations().getGlobalConfig()).build();    StellarFunctions.initialize(stellarContext);}
public void metron_f4911_0(OutputFieldsDeclarer declarer)
{    declarer.declareStream(enrichmentType, new Fields("key", "message", "subgroup"));    declarer.declareStream(ERROR_STREAM, new Fields("message"));}
public void metron_f4912_1(Tuple tuple)
{    perfLog.mark("execute");    String key = tuple.getStringByField("key");    JSONObject rawMessage = (JSONObject) tuple.getValueByField("message");    String subGroup = "";    JSONObject enrichedMessage = new JSONObject();    enrichedMessage.put("adapter." + adapter.getClass().getSimpleName().toLowerCase() + ".begin.ts", "" + System.currentTimeMillis());    try {        if (rawMessage == null || rawMessage.isEmpty())            throw new Exception("Could not parse binary stream to JSON");        if (key == null)            throw new Exception("Key is not valid");        String sourceType = null;        if (rawMessage.containsKey(Constants.SENSOR_TYPE)) {            sourceType = rawMessage.get(Constants.SENSOR_TYPE).toString();        } else {            throw new RuntimeException("Source type is missing from enrichment fragment: " + rawMessage.toJSONString());        }        String prefix = null;        for (Object o : rawMessage.keySet()) {            String field = (String) o;            Object value = rawMessage.get(field);            if (field.equals(Constants.SENSOR_TYPE)) {                enrichedMessage.put(Constants.SENSOR_TYPE, value);            } else {                JSONObject enrichedField = new JSONObject();                if (value != null) {                    SensorEnrichmentConfig config = getConfigurations().getSensorEnrichmentConfig(sourceType);                    if (config == null) {                                                MetronError metronError = new MetronError().withErrorType(Constants.ErrorType.ENRICHMENT_ERROR).withMessage("Unable to find SensorEnrichmentConfig for sourceType: " + sourceType).addRawMessage(rawMessage);                        StormErrorUtils.handleError(collector, metronError);                        continue;                    }                    config.getConfiguration().putIfAbsent(STELLAR_CONTEXT_CONF, stellarContext);                    CacheKey cacheKey = new CacheKey(field, value, config);                    try {                        adapter.logAccess(cacheKey);                        prefix = adapter.getOutputPrefix(cacheKey);                        subGroup = adapter.getStreamSubGroup(enrichmentType, field);                        perfLog.mark("enrich");                        enrichedField = cache.get(cacheKey);                        perfLog.log("enrich", "key={}, time to run enrichment type={}", key, enrichmentType);                        if (enrichedField == null)                            throw new Exception("[Metron] Could not enrich string: " + value);                    } catch (Exception e) {                                                MetronError metronError = new MetronError().withErrorType(Constants.ErrorType.ENRICHMENT_ERROR).withThrowable(e).withErrorFields(new HashSet() {                            {                                add(field);                            }                        }).addRawMessage(rawMessage);                        StormErrorUtils.handleError(collector, metronError);                        continue;                    }                }                enrichedMessage = EnrichmentUtils.adjustKeys(enrichedMessage, enrichedField, field, prefix);            }        }        enrichedMessage.put("adapter." + adapter.getClass().getSimpleName().toLowerCase() + ".end.ts", "" + System.currentTimeMillis());        if (!enrichedMessage.isEmpty()) {            collector.emit(enrichmentType, new Values(key, enrichedMessage, subGroup));        }    } catch (Exception e) {        handleError(key, rawMessage, subGroup, enrichedMessage, e);    }    perfLog.log("execute", "key={}, elapsed time to run execute", key);}
protected void metron_f4913_1(String key, JSONObject rawMessage, String subGroup, JSONObject enrichedMessage, Exception e)
{        if (key != null) {        collector.emit(enrichmentType, new Values(key, enrichedMessage, subGroup));    }    MetronError error = new MetronError().withErrorType(Constants.ErrorType.ENRICHMENT_ERROR).withThrowable(e).addRawMessage(rawMessage);    StormErrorUtils.handleError(collector, error);}
public void metron_f4914_0()
{    super.cleanup();    adapter.cleanup();}
public Context metron_f4915_0()
{    return stellarContext;}
public UnifiedEnrichmentBolt metron_f4916_0(List<Enrichment> enrichments)
{    for (Enrichment e : enrichments) {        enrichmentsByType.put(e.getType(), e.getAdapter());    }    return this;}
public UnifiedEnrichmentBolt metron_f4917_0(boolean captureCacheStats)
{    this.captureCacheStats = captureCacheStats;    return this;}
public UnifiedEnrichmentBolt metron_f4918_0(String getter)
{    this.getterStrategy = MessageGetters.valueOf(getter);    return this;}
private static int metron_f4919_0(Object numThreads)
{    if (numThreads instanceof Number) {        return ((Number) numThreads).intValue();    } else if (numThreads instanceof String) {        String numThreadsStr = ((String) numThreads).trim().toUpperCase();        if (numThreadsStr.endsWith("C")) {            Integer factor = Integer.parseInt(numThreadsStr.replace("C", ""));            return factor * Runtime.getRuntime().availableProcessors();        } else {            return Integer.parseInt(numThreadsStr);        }    }    return 2 * Runtime.getRuntime().availableProcessors();}
public UnifiedEnrichmentBolt metron_f4920_0(String strategy)
{    this.strategy = EnrichmentStrategies.valueOf(strategy);    return this;}
public UnifiedEnrichmentBolt metron_f4921_0(long maxCacheSize)
{    this.maxCacheSize = maxCacheSize;    return this;}
public UnifiedEnrichmentBolt metron_f4922_0(long maxTimeRetain)
{    this.maxTimeRetain = maxTimeRetain;    return this;}
public UnifiedEnrichmentBolt metron_f4923_0(boolean cacheInvalidationOnReload)
{    this.invalidateCacheOnReload = cacheInvalidationOnReload;    return this;}
public void metron_f4924_0(String name, ConfigurationType type)
{    if (invalidateCacheOnReload) {        if (strategy != null && ConcurrencyContext.get(strategy).getCache() != null) {            ConcurrencyContext.get(strategy).getCache().invalidateAll();        }    }    if (type == ConfigurationType.GLOBAL && enrichmentsByType != null) {        for (EnrichmentAdapter adapter : enrichmentsByType.values()) {            adapter.updateAdapter(getConfigurations().getGlobalConfig());        }    }}
public void metron_f4925_1(Tuple input)
{    JSONObject message = generateMessage(input);    try {        String sourceType = MessageUtils.getSensorType(message);        SensorEnrichmentConfig config = getConfigurations().getSensorEnrichmentConfig(sourceType);        if (config == null) {                        config = new SensorEnrichmentConfig();        }                        config.getConfiguration().putIfAbsent(STELLAR_CONTEXT_CONF, stellarContext);        String guid = getGUID(input, message);                ParallelEnricher.EnrichmentResult result = enricher.apply(message, strategy, config, perfLog);        JSONObject enriched = result.getResult();        enriched = strategy.postProcess(enriched, config, enrichmentContext);                collector.emit("message", input, new Values(guid, enriched));                for (Map.Entry<Object, Throwable> t : result.getEnrichmentErrors()) {                        MetronError error = new MetronError().withErrorType(strategy.getErrorType()).withMessage(t.getValue().getMessage()).withThrowable(t.getValue()).addRawMessage(t.getKey());            StormErrorUtils.handleError(collector, error);        }    } catch (Exception e) {                                MetronError error = new MetronError().withErrorType(strategy.getErrorType()).withMessage(e.getMessage()).withThrowable(e).addRawMessage(message);        StormErrorUtils.handleError(collector, error);    } finally {        collector.ack(input);    }}
public UnifiedEnrichmentBolt metron_f4926_0(String messageFieldName)
{    this.messageFieldName = messageFieldName;    return this;}
public JSONObject metron_f4927_0(Tuple tuple)
{    return (JSONObject) messageGetter.get(tuple);}
public final void metron_f4928_1(Map map, TopologyContext topologyContext, OutputCollector outputCollector)
{    super.prepare(map, topologyContext, outputCollector);    collector = outputCollector;    if (this.maxCacheSize == null) {        throw new IllegalStateException("MAX_CACHE_SIZE_OBJECTS_NUM must be specified");    }    if (this.maxTimeRetain == null) {        throw new IllegalStateException("MAX_TIME_RETAIN_MINUTES must be specified");    }    if (this.enrichmentsByType.isEmpty()) {        throw new IllegalStateException("Adapter must be specified");    }    for (Map.Entry<String, EnrichmentAdapter<CacheKey>> adapterKv : enrichmentsByType.entrySet()) {        boolean success = adapterKv.getValue().initializeAdapter(getConfigurations().getGlobalConfig());        if (!success) {                        throw new IllegalStateException("Could not initialize adapter: " + adapterKv.getKey());        }    }    WorkerPoolStrategies workerPoolStrategy = WorkerPoolStrategies.FIXED;    if (map.containsKey(THREADPOOL_TYPE_TOPOLOGY_CONF)) {        workerPoolStrategy = WorkerPoolStrategies.valueOf(map.get(THREADPOOL_TYPE_TOPOLOGY_CONF) + "");    }    if (map.containsKey(THREADPOOL_NUM_THREADS_TOPOLOGY_CONF)) {        int numThreads = getNumThreads(map.get(THREADPOOL_NUM_THREADS_TOPOLOGY_CONF));        ConcurrencyContext.get(strategy).initialize(numThreads, maxCacheSize, maxTimeRetain, workerPoolStrategy, LOG, captureCacheStats);    } else {        throw new IllegalStateException("You must pass " + THREADPOOL_NUM_THREADS_TOPOLOGY_CONF + " via storm config.");    }    messageGetter = this.getterStrategy.get(messageFieldName);    enricher = new ParallelEnricher(enrichmentsByType, ConcurrencyContext.get(strategy), captureCacheStats);    perfLog = new PerformanceLogger(() -> getConfigurations().getGlobalConfig(), Perf.class.getName());    GeoLiteCityDatabase.INSTANCE.update((String) getConfigurations().getGlobalConfig().get(GeoLiteCityDatabase.GEO_HDFS_FILE));    GeoLiteAsnDatabase.INSTANCE.update((String) getConfigurations().getGlobalConfig().get(GeoLiteAsnDatabase.ASN_HDFS_FILE));    initializeStellar();    enrichmentContext = new EnrichmentContext(StellarFunctions.FUNCTION_RESOLVER(), stellarContext);}
protected void metron_f4929_0()
{    stellarContext = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).with(Context.Capabilities.GLOBAL_CONFIG, () -> getConfigurations().getGlobalConfig()).with(Context.Capabilities.STELLAR_CONFIG, () -> getConfigurations().getGlobalConfig()).build();    StellarFunctions.initialize(stellarContext);}
public String metron_f4930_0(Tuple tuple, JSONObject message)
{    String key = null, guid = null;    try {        key = tuple.getStringByField("key");        guid = (String) message.get(Constants.GUID);    } catch (Throwable t) {        }    if (key != null) {        return key;    } else if (guid != null) {        return guid;    } else {        return UUID.randomUUID().toString();    }}
public void metron_f4931_0(OutputFieldsDeclarer declarer)
{    declarer.declareStream("message", new Fields("key", "message"));    declarer.declareStream("error", new Fields("message"));}
public boolean metron_f4932_0(Object o)
{    Values values = (Values) o;    String actualKey = (String) values.get(0);    JSONObject actualMessage = (JSONObject) values.get(1);    removeTimingFields(actualMessage);    return expectedKey.equals(actualKey) && expectedMessage.equals(actualMessage);}
public void metron_f4933_0(Description description)
{    description.appendText(String.format("[%s]", expectedMessage));}
public void metron_f4934_0() throws ParseException
{    JSONParser parser = new JSONParser();    originalMessage = (JSONObject) parser.parse(originalMessageString);    enrichedField1 = (JSONObject) parser.parse(enrichedField1String);    enrichedField2 = (JSONObject) parser.parse(enrichedField2String);    enrichedMessage = (JSONObject) parser.parse(enrichedMessageString);}
public void metron_f4935_0()
{    MockitoAnnotations.initMocks(this);}
public void metron_f4936_0() throws IOException
{    when(tuple.getSourceComponent()).thenReturn("unit test component");    when(tuple.getSourceStreamId()).thenReturn("unit test stream");    String key = "someKey";    String enrichmentType = "enrichmentType";    Enrichment<EnrichmentAdapter<CacheKey>> testEnrichment = new Enrichment<>();    testEnrichment.setType(enrichmentType);    testEnrichment.setAdapter(enrichmentAdapter);    GenericEnrichmentBolt genericEnrichmentBolt = new GenericEnrichmentBolt("zookeeperUrl") {        @Override        protected void initializeStellar() {                }    };    genericEnrichmentBolt.setCuratorFramework(client);    genericEnrichmentBolt.setZKCache(cache);    genericEnrichmentBolt.getConfigurations().updateSensorEnrichmentConfig(sensorType, new FileInputStream(enrichmentConfigPath));    HashMap<String, Object> globalConfig = new HashMap<>();    String baseDir = UnitTestHelper.findDir(new File("../metron-enrichment-common"), "GeoLite");    File geoHdfsFile = new File(new File(baseDir), "GeoLite2-City.mmdb.gz");    globalConfig.put(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath());    genericEnrichmentBolt.getConfigurations().updateGlobalConfig(globalConfig);    try {        genericEnrichmentBolt.prepare(new HashMap(), topologyContext, outputCollector);        fail("Should fail if a maxCacheSize property is not set");    } catch (IllegalStateException e) {    }    genericEnrichmentBolt.withMaxCacheSize(100);    try {        genericEnrichmentBolt.prepare(new HashMap(), topologyContext, outputCollector);        fail("Should fail if a maxTimeRetain property is not set");    } catch (IllegalStateException e) {    }    genericEnrichmentBolt.withMaxTimeRetain(10000);    try {        genericEnrichmentBolt.prepare(new HashMap(), topologyContext, outputCollector);        fail("Should fail if an adapter is not set");    } catch (IllegalStateException e) {    }    genericEnrichmentBolt.withEnrichment(testEnrichment);    when(enrichmentAdapter.initializeAdapter(globalConfig)).thenReturn(true);    genericEnrichmentBolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(enrichmentAdapter, times(1)).initializeAdapter(globalConfig);    when(enrichmentAdapter.initializeAdapter(globalConfig)).thenReturn(false);    UnitTestHelper.setLog4jLevel(GenericEnrichmentBolt.class, Level.FATAL);    try {        genericEnrichmentBolt.prepare(new HashMap(), topologyContext, outputCollector);        fail("An exception should be thrown if enrichment adapter initialization fails");    } catch (IllegalStateException e) {    }    UnitTestHelper.setLog4jLevel(GenericEnrichmentBolt.class, Level.ERROR);    genericEnrichmentBolt.declareOutputFields(declarer);    verify(declarer, times(1)).declareStream(eq(enrichmentType), argThat(new FieldsMatcher("key", "message", "subgroup")));    verify(declarer, times(1)).declareStream(eq("error"), argThat(new FieldsMatcher("message")));    when(tuple.getStringByField("key")).thenReturn(null);    UnitTestHelper.setLog4jLevel(GenericEnrichmentBolt.class, Level.FATAL);    genericEnrichmentBolt.execute(tuple);    UnitTestHelper.setLog4jLevel(GenericEnrichmentBolt.class, Level.ERROR);    MetronError error = new MetronError().withErrorType(Constants.ErrorType.ENRICHMENT_ERROR).withThrowable(new Exception("Could not parse binary stream to JSON"));    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    when(tuple.getStringByField("key")).thenReturn(key);    when(tuple.getValueByField("message")).thenReturn(originalMessage);    when(enrichmentAdapter.enrich(any())).thenReturn(new JSONObject());    genericEnrichmentBolt.execute(tuple);    verify(outputCollector, times(1)).emit(eq(enrichmentType), argThat(new EnrichedMessageMatcher(key, new JSONObject(ImmutableMap.of("source.type", "test")))));    reset(enrichmentAdapter);    SensorEnrichmentConfig sensorEnrichmentConfig = SensorEnrichmentConfig.fromBytes(ConfigurationsUtils.readSensorEnrichmentConfigsFromFile(sampleConfigPath).get(sensorType));    sensorEnrichmentConfig.getConfiguration().put(STELLAR_CONTEXT_CONF, genericEnrichmentBolt.getStellarContext());    CacheKey cacheKey1 = new CacheKey("field1", "value1", sensorEnrichmentConfig);    CacheKey cacheKey2 = new CacheKey("field2", "value2", sensorEnrichmentConfig);    genericEnrichmentBolt.cache.invalidateAll();    when(enrichmentAdapter.getOutputPrefix(cacheKey1)).thenReturn("field1");    when(enrichmentAdapter.getOutputPrefix(cacheKey2)).thenReturn("field2");    when(enrichmentAdapter.enrich(cacheKey1)).thenReturn(enrichedField1);    when(enrichmentAdapter.enrich(cacheKey2)).thenReturn(enrichedField2);    genericEnrichmentBolt.execute(tuple);    verify(enrichmentAdapter, times(1)).logAccess(cacheKey1);    verify(enrichmentAdapter, times(1)).logAccess(cacheKey2);    verify(outputCollector, times(1)).emit(eq(enrichmentType), argThat(new EnrichedMessageMatcher(key, enrichedMessage)));    reset(outputCollector);    genericEnrichmentBolt.cache.invalidateAll();    when(enrichmentAdapter.enrich(cacheKey1)).thenReturn(null);    genericEnrichmentBolt.execute(tuple);    error = new MetronError().withErrorType(Constants.ErrorType.ENRICHMENT_ERROR).withErrorFields(new HashSet<String>() {        {            add("field1");        }    }).addRawMessage(new JSONObject() {        {            put("field1", "value1");            put("field2", "value2");            put("source.type", "test");        }    }).withThrowable(new Exception("[Metron] Could not enrich string: value1"));    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));}
protected void metron_f4937_0()
{}
private static List<byte[]> metron_f4938_0(String path)
{    try {        List<byte[]> ret = TestUtils.readSampleData(path);        {                        Map<String, Object> sansDestinationIp = JSONUtils.INSTANCE.load(new String(ret.get(ret.size() - 1), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);            sansDestinationIp.remove(Constants.Fields.DST_ADDR.getName());            ret.add(JSONUtils.INSTANCE.toJSONPretty(sansDestinationIp));        }        return ret;    } catch (IOException ioe) {        return null;    }}
public static void metron_f4939_0() throws ParseException
{    String baseDir = UnitTestHelper.findDir(new File("../metron-enrichment-common"), "GeoLite");    geoHdfsFile = new File(new File(baseDir), "GeoLite2-City.mmdb.gz");    asnHdfsFile = new File(new File(baseDir), "GeoLite2-ASN.tar.gz");}
public String metron_f4940_0()
{    return "src/main/config/enrichment.properties.j2";}
public String metron_f4941_0()
{    return "src/main/flux/enrichment/remote.yaml";}
public Properties metron_f4942_0()
{    return new Properties() {        {                        setProperty("enrichment_workers", "1");            setProperty("enrichment_acker_executors", "0");            setProperty("enrichment_topology_worker_childopts", "");            setProperty("topology_auto_credentials", "[]");            setProperty("enrichment_topology_max_spout_pending", "500");                        setProperty("kafka_security_protocol", "PLAINTEXT");            setProperty("enrichment_kafka_start", "UNCOMMITTED_EARLIEST");            setProperty("enrichment_input_topic", Constants.ENRICHMENT_TOPIC);            setProperty("enrichment_output_topic", Constants.INDEXING_TOPIC);            setProperty("enrichment_error_topic", ERROR_TOPIC);            setProperty("threatintel_error_topic", ERROR_TOPIC);                        setProperty("enrichment_hbase_provider_impl", "" + MockHBaseTableProvider.class.getName());            setProperty("enrichment_hbase_table", enrichmentsTableName);            setProperty("enrichment_hbase_cf", cf);            setProperty("enrichment_host_known_hosts", "[{\"ip\":\"10.1.128.236\", \"local\":\"YES\", \"type\":\"webserver\", \"asset_value\" : \"important\"}," + "{\"ip\":\"10.1.128.237\", \"local\":\"UNKNOWN\", \"type\":\"unknown\", \"asset_value\" : \"important\"}," + "{\"ip\":\"10.60.10.254\", \"local\":\"YES\", \"type\":\"printer\", \"asset_value\" : \"important\"}," + "{\"ip\":\"10.0.2.15\", \"local\":\"YES\", \"type\":\"printer\", \"asset_value\" : \"important\"}]");                        setProperty("threatintel_hbase_table", threatIntelTableName);            setProperty("threatintel_hbase_cf", cf);                        setProperty("unified_kafka_spout_parallelism", "1");            setProperty("unified_enrichment_parallelism", "1");            setProperty("unified_threat_intel_parallelism", "1");            setProperty("unified_kafka_writer_parallelism", "1");                        setProperty("unified_enrichment_cache_size", "1000");            setProperty("unified_threat_intel_cache_size", "1000");                        setProperty("unified_enrichment_threadpool_size", "1");            setProperty("unified_enrichment_threadpool_type", "FIXED");        }    };}
public void metron_f4943_0() throws Exception
{    final Properties topologyProperties = getTopologyProperties();    final ZKServerComponent zkServerComponent = getZKServerComponent(topologyProperties);    final KafkaComponent kafkaComponent = getKafkaComponent(topologyProperties, new ArrayList<KafkaComponent.Topic>() {        {            add(new KafkaComponent.Topic(Constants.ENRICHMENT_TOPIC, 1));            add(new KafkaComponent.Topic(Constants.INDEXING_TOPIC, 1));            add(new KafkaComponent.Topic(ERROR_TOPIC, 1));        }    });    String globalConfigStr = null;    {        File globalConfig = new File(enrichmentConfigPath, "global.json");        Map<String, Object> config = JSONUtils.INSTANCE.load(globalConfig, JSONUtils.MAP_SUPPLIER);        config.put(SimpleHBaseEnrichmentFunctions.TABLE_PROVIDER_TYPE_CONF, MockHBaseTableProvider.class.getName());        config.put(SimpleHBaseEnrichmentFunctions.ACCESS_TRACKER_TYPE_CONF, "PERSISTENT_BLOOM");        config.put(PersistentBloomTrackerCreator.Config.PERSISTENT_BLOOM_TABLE, trackerHBaseTableName);        config.put(PersistentBloomTrackerCreator.Config.PERSISTENT_BLOOM_CF, cf);        config.put(GeoLiteCityDatabase.GEO_HDFS_FILE, geoHdfsFile.getAbsolutePath());        config.put(GeoLiteAsnDatabase.ASN_HDFS_FILE, asnHdfsFile.getAbsolutePath());        globalConfigStr = JSONUtils.INSTANCE.toJSON(config, true);    }    ConfigUploadComponent configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties).withGlobalConfig(globalConfigStr).withEnrichmentConfigsPath(enrichmentConfigPath);        final MockHTable trackerTable = (MockHTable) MockHBaseTableProvider.addToCache(trackerHBaseTableName, cf);    final MockHTable threatIntelTable = (MockHTable) MockHBaseTableProvider.addToCache(threatIntelTableName, cf);    EnrichmentHelper.INSTANCE.load(threatIntelTable, cf, new ArrayList<LookupKV<EnrichmentKey, EnrichmentValue>>() {        {            add(new LookupKV<>(new EnrichmentKey(MALICIOUS_IP_TYPE, "10.0.2.3"), new EnrichmentValue(new HashMap<>())));        }    });    final MockHTable enrichmentTable = (MockHTable) MockHBaseTableProvider.addToCache(enrichmentsTableName, cf);    EnrichmentHelper.INSTANCE.load(enrichmentTable, cf, new ArrayList<LookupKV<EnrichmentKey, EnrichmentValue>>() {        {            add(new LookupKV<>(new EnrichmentKey(PLAYFUL_CLASSIFICATION_TYPE, "10.0.2.3"), new EnrichmentValue(PLAYFUL_ENRICHMENT)));        }    });    FluxTopologyComponent fluxComponent = new FluxTopologyComponent.Builder().withTopologyLocation(new File(fluxPath())).withTopologyName("test").withTemplateLocation(new File(getTemplatePath())).withTopologyProperties(topologyProperties).build();        ComponentRunner runner = new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("storm", fluxComponent).withMillisecondsBetweenAttempts(15000).withCustomShutdownOrder(new String[] { "storm", "config", "kafka", "zk" }).withNumRetries(10).build();    try {        runner.start();        fluxComponent.submitTopology();        kafkaComponent.writeMessages(Constants.ENRICHMENT_TOPIC, inputMessages);        ProcessorResult<Map<String, List<Map<String, Object>>>> result = runner.process(getProcessor());        Map<String, List<Map<String, Object>>> outputMessages = result.getResult();        List<Map<String, Object>> docs = outputMessages.get(Constants.INDEXING_TOPIC);        Assert.assertEquals(inputMessages.size(), docs.size());        validateAll(docs);        List<Map<String, Object>> errors = outputMessages.get(ERROR_TOPIC);        Assert.assertEquals(inputMessages.size(), errors.size());        validateErrors(errors);    } finally {        runner.stop();    }}
public void metron_f4944_0(List<Map<String, Object>> outputMessages, StringBuffer buffer)
{    for (Map<String, Object> map : outputMessages) {        for (String json : map.keySet()) {            buffer.append(json).append("\n");        }    }}
public static void metron_f4945_0(List<Map<String, Object>> docs)
{    for (Map<String, Object> doc : docs) {        baseValidation(doc);        hostEnrichmentValidation(doc);        geoEnrichmentValidation(doc);        threatIntelValidation(doc);        simpleEnrichmentValidation(doc);    }}
protected void metron_f4946_0(List<Map<String, Object>> errors)
{    for (Map<String, Object> error : errors) {        Assert.assertTrue(error.get(Constants.ErrorFields.MESSAGE.getName()).toString(), error.get(Constants.ErrorFields.MESSAGE.getName()).toString().contains("/ by zero"));        Assert.assertTrue(error.get(Constants.ErrorFields.EXCEPTION.getName()).toString().contains("/ by zero"));        Assert.assertEquals(Constants.ErrorType.ENRICHMENT_ERROR.getType(), error.get(Constants.ErrorFields.ERROR_TYPE.getName()));        Assert.assertEquals("{\"error_test\":{},\"source.type\":\"test\"}", error.get(Constants.ErrorFields.RAW_MESSAGE.getName()));    }}
public static void metron_f4947_0(Map<String, Object> jsonDoc)
{    assertEnrichmentsExists("threatintels.", setOf("hbaseThreatIntel"), jsonDoc.keySet());    assertEnrichmentsExists("enrichments.", setOf("geo", "host", "hbaseEnrichment"), jsonDoc.keySet());        for (Map.Entry<String, Object> kv : jsonDoc.entrySet()) {        String actual = Objects.toString(kv.getValue(), "");        Assert.assertTrue(String.format("Value of '%s' is empty: '%s'", kv.getKey(), actual), StringUtils.isNotEmpty(actual));    }        Assert.assertNotNull(jsonDoc.get(SRC_IP));    Assert.assertNotNull(jsonDoc.get("ALL_CAPS"));    Assert.assertNotNull(jsonDoc.get("map.blah"));    Assert.assertNull(jsonDoc.get("map"));    Assert.assertNotNull(jsonDoc.get("one"));    Assert.assertEquals(1, jsonDoc.get("one"));    Assert.assertEquals(1, jsonDoc.get("map.blah"));    Assert.assertNotNull(jsonDoc.get("foo"));    Assert.assertNotNull(jsonDoc.get("alt_src_type"));    Assert.assertEquals("test", jsonDoc.get("alt_src_type"));    Assert.assertEquals("TEST", jsonDoc.get("ALL_CAPS"));    Assert.assertNotNull(jsonDoc.get("bar"));    Assert.assertEquals("TEST", jsonDoc.get("bar"));}
public boolean metron_f4948_0(EvaluationPayload payload)
{    return _predicate.apply(payload);}
public boolean metron_f4949_0(@Nullable EvaluationPayload evaluationPayload)
{    return evaluationPayload.indexedDoc.getOrDefault("enrichments.host." + evaluationPayload.key + ".known_info.local", "").equals("YES");}
public boolean metron_f4950_0(@Nullable EvaluationPayload evaluationPayload)
{    return evaluationPayload.indexedDoc.getOrDefault("enrichments.host." + evaluationPayload.key + ".known_info.local", "").equals("UNKNOWN");}
public boolean metron_f4951_0(@Nullable EvaluationPayload evaluationPayload)
{    return evaluationPayload.indexedDoc.getOrDefault("enrichments.host." + evaluationPayload.key + ".known_info.asset_value", "").equals("important");}
public boolean metron_f4952_0(@Nullable EvaluationPayload evaluationPayload)
{    return evaluationPayload.indexedDoc.getOrDefault("enrichments.host." + evaluationPayload.key + ".known_info.type", "").equals("printer");}
public boolean metron_f4953_0(@Nullable EvaluationPayload evaluationPayload)
{    return evaluationPayload.indexedDoc.getOrDefault("enrichments.host." + evaluationPayload.key + ".known_info.type", "").equals("webserver");}
public boolean metron_f4954_0(@Nullable EvaluationPayload evaluationPayload)
{    return evaluationPayload.indexedDoc.getOrDefault("enrichments.host." + evaluationPayload.key + ".known_info.type", "").equals("unknown");}
private static void metron_f4955_0(String topLevel, Set<String> expectedEnrichments, Set<String> keys)
{    for (String key : keys) {        if (key.startsWith(topLevel)) {            String secondLevel = Iterables.get(Splitter.on(".").split(key), 1);            String message = "Found an enrichment/threat intel (" + secondLevel + ") that I didn't expect (expected enrichments :" + Joiner.on(",").join(expectedEnrichments) + "), but it was not there.  If you've created a new" + " enrichment, then please add a validation method to this unit test.  Otherwise, it's a solid error" + " and should be investigated.";            Assert.assertTrue(message, expectedEnrichments.contains(secondLevel));        }    }}
private static void metron_f4956_0(Map<String, Object> indexedDoc)
{    if (indexedDoc.getOrDefault(SRC_IP, "").equals("10.0.2.3") || indexedDoc.getOrDefault(DST_IP, "").equals("10.0.2.3")) {        Assert.assertTrue(keyPatternExists("enrichments.hbaseEnrichment", indexedDoc));        if (indexedDoc.getOrDefault(SRC_IP, "").equals("10.0.2.3")) {            Assert.assertEquals(indexedDoc.get("enrichments.hbaseEnrichment." + SRC_IP + "." + PLAYFUL_CLASSIFICATION_TYPE + ".orientation"), PLAYFUL_ENRICHMENT.get("orientation"));            Assert.assertEquals(indexedDoc.get("src_classification.orientation"), PLAYFUL_ENRICHMENT.get("orientation"));            Assert.assertEquals(indexedDoc.get("is_src_malicious"), true);        } else if (indexedDoc.getOrDefault(DST_IP, "").equals("10.0.2.3")) {            Assert.assertEquals(indexedDoc.get("enrichments.hbaseEnrichment." + DST_IP + "." + PLAYFUL_CLASSIFICATION_TYPE + ".orientation"), PLAYFUL_ENRICHMENT.get("orientation"));            Assert.assertEquals(indexedDoc.get("dst_classification.orientation"), PLAYFUL_ENRICHMENT.get("orientation"));        }        if (!indexedDoc.getOrDefault(SRC_IP, "").equals("10.0.2.3")) {            Assert.assertEquals(indexedDoc.get("is_src_malicious"), false);        }    } else {        Assert.assertEquals(indexedDoc.get("is_src_malicious"), false);    }}
private static void metron_f4957_0(Map<String, Object> indexedDoc)
{    if (indexedDoc.getOrDefault(SRC_IP, "").equals("10.0.2.3") || indexedDoc.getOrDefault(DST_IP, "").equals("10.0.2.3")) {                Assert.assertTrue(keyPatternExists("threatintels.", indexedDoc));        Assert.assertEquals(indexedDoc.getOrDefault("is_alert", ""), "true");                Assert.assertTrue(indexedDoc.containsKey(ThreatIntelUtils.THREAT_TRIAGE_SCORE_KEY));        Double score = (Double) indexedDoc.get(ThreatIntelUtils.THREAT_TRIAGE_SCORE_KEY);        Assert.assertEquals(score, 10d, 1e-7);                Joiner joiner = Joiner.on(".");        Stream.of(joiner.join(ThreatIntelUtils.THREAT_TRIAGE_RULES_KEY, 0, ThreatIntelUtils.THREAT_TRIAGE_RULE_NAME), joiner.join(ThreatIntelUtils.THREAT_TRIAGE_RULES_KEY, 0, ThreatIntelUtils.THREAT_TRIAGE_RULE_COMMENT), joiner.join(ThreatIntelUtils.THREAT_TRIAGE_RULES_KEY, 0, ThreatIntelUtils.THREAT_TRIAGE_RULE_REASON), joiner.join(ThreatIntelUtils.THREAT_TRIAGE_RULES_KEY, 0, ThreatIntelUtils.THREAT_TRIAGE_RULE_SCORE)).forEach(key -> Assert.assertTrue(String.format("Missing expected key: '%s'", key), indexedDoc.containsKey(key)));    } else {                Assert.assertNull(indexedDoc.get("is_alert"));        Assert.assertFalse(keyPatternExists("threatintels.", indexedDoc));    }        if (keyPatternExists("threatintels.hbaseThreatIntel.", indexedDoc)) {        if (indexedDoc.getOrDefault(SRC_IP, "").equals("10.0.2.3")) {            Assert.assertEquals(indexedDoc.get("threatintels.hbaseThreatIntel." + SRC_IP + "." + MALICIOUS_IP_TYPE), "alert");        } else if (indexedDoc.getOrDefault(DST_IP, "").equals("10.0.2.3")) {            Assert.assertEquals(indexedDoc.get("threatintels.hbaseThreatIntel." + DST_IP + "." + MALICIOUS_IP_TYPE), "alert");        } else {            Assert.fail("There was a threat intels that I did not expect: " + indexedDoc);        }    }}
private static void metron_f4958_0(Map<String, Object> indexedDoc)
{        if (indexedDoc.containsKey("enrichments.geo." + DST_IP + ".location_point")) {        Assert.assertEquals(DEFAULT_LOCATION_POINT, indexedDoc.get("enrichments.geo." + DST_IP + ".location_point"));        Assert.assertEquals(DEFAULT_LONGITUDE, indexedDoc.get("enrichments.geo." + DST_IP + ".longitude"));        Assert.assertEquals(DEFAULT_CITY, indexedDoc.get("enrichments.geo." + DST_IP + ".city"));        Assert.assertEquals(DEFAULT_LATITUDE, indexedDoc.get("enrichments.geo." + DST_IP + ".latitude"));        Assert.assertEquals(DEFAULT_COUNTRY, indexedDoc.get("enrichments.geo." + DST_IP + ".country"));        Assert.assertEquals(DEFAULT_DMACODE, indexedDoc.get("enrichments.geo." + DST_IP + ".dmaCode"));        Assert.assertEquals(DEFAULT_POSTAL_CODE, indexedDoc.get("enrichments.geo." + DST_IP + ".postalCode"));    }    if (indexedDoc.containsKey("enrichments.geo." + SRC_IP + ".location_point")) {        Assert.assertEquals(DEFAULT_LOCATION_POINT, indexedDoc.get("enrichments.geo." + SRC_IP + ".location_point"));        Assert.assertEquals(DEFAULT_LONGITUDE, indexedDoc.get("enrichments.geo." + SRC_IP + ".longitude"));        Assert.assertEquals(DEFAULT_CITY, indexedDoc.get("enrichments.geo." + SRC_IP + ".city"));        Assert.assertEquals(DEFAULT_LATITUDE, indexedDoc.get("enrichments.geo." + SRC_IP + ".latitude"));        Assert.assertEquals(DEFAULT_COUNTRY, indexedDoc.get("enrichments.geo." + SRC_IP + ".country"));        Assert.assertEquals(DEFAULT_DMACODE, indexedDoc.get("enrichments.geo." + SRC_IP + ".dmaCode"));        Assert.assertEquals(DEFAULT_POSTAL_CODE, indexedDoc.get("enrichments.geo." + SRC_IP + ".postalCode"));    }}
private static void metron_f4959_0(Map<String, Object> indexedDoc)
{    boolean enriched = false;        {        Set<String> ips = setOf("10.0.2.15", "10.60.10.254");        if (ips.contains(indexedDoc.get(SRC_IP))) {                        Assert.assertTrue(Predicates.and(HostEnrichments.LOCAL_LOCATION, HostEnrichments.IMPORTANT, HostEnrichments.PRINTER_TYPE).apply(new EvaluationPayload(indexedDoc, SRC_IP)));            enriched = true;        }        if (ips.contains(indexedDoc.get(DST_IP))) {            boolean isEnriched = Predicates.and(HostEnrichments.LOCAL_LOCATION, HostEnrichments.IMPORTANT, HostEnrichments.PRINTER_TYPE).apply(new EvaluationPayload(indexedDoc, DST_IP));            Assert.assertTrue(isEnriched);            enriched = true;        }    }        {        Set<String> ips = setOf("10.1.128.236");        if (ips.contains(indexedDoc.get(SRC_IP))) {                        Assert.assertTrue(Predicates.and(HostEnrichments.LOCAL_LOCATION, HostEnrichments.IMPORTANT, HostEnrichments.WEBSERVER_TYPE).apply(new EvaluationPayload(indexedDoc, SRC_IP)));            enriched = true;        }        if (ips.contains(indexedDoc.get(DST_IP))) {            boolean isEnriched = Predicates.and(HostEnrichments.LOCAL_LOCATION, HostEnrichments.IMPORTANT, HostEnrichments.WEBSERVER_TYPE).apply(new EvaluationPayload(indexedDoc, DST_IP));            Assert.assertTrue(isEnriched);            enriched = true;        }    }    if (!enriched) {        Assert.assertFalse(keyPatternExists("enrichments.host", indexedDoc));    }}
private static boolean metron_f4960_0(String pattern, Map<String, Object> indexedObj)
{    for (String k : indexedObj.keySet()) {        if (k.startsWith(pattern)) {            return true;        }    }    return false;}
private static Set<String> metron_f4961_0(String... items)
{    Set<String> ret = new HashSet<>();    for (String item : items) {        ret.add(item);    }    return ret;}
private static List<Map<String, Object>> metron_f4962_0(List<byte[]> outputMessages)
{    List<Map<String, Object>> tmp = new ArrayList<>();    Iterables.addAll(tmp, Iterables.transform(outputMessages, message -> {        try {            return new HashMap<>(JSONUtils.INSTANCE.load(new String(message, StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER));        } catch (Exception ex) {            throw new IllegalStateException(ex);        }    }));    return tmp;}
private KafkaProcessor<Map<String, List<Map<String, Object>>>> metron_f4963_0()
{    return new KafkaProcessor<>().withKafkaComponentName("kafka").withReadTopic(Constants.INDEXING_TOPIC).withErrorTopic(ERROR_TOPIC).withValidateReadMessages(new Function<KafkaMessageSet, Boolean>() {        @Nullable        @Override        public Boolean apply(@Nullable KafkaMessageSet messageSet) {            return (messageSet.getMessages().size() == inputMessages.size()) && (messageSet.getErrors().size() == inputMessages.size());        }    }).withProvideResult(new Function<KafkaMessageSet, Map<String, List<Map<String, Object>>>>() {        @Nullable        @Override        public Map<String, List<Map<String, Object>>> apply(@Nullable KafkaMessageSet messageSet) {            return new HashMap<String, List<Map<String, Object>>>() {                {                    put(Constants.INDEXING_TOPIC, loadMessages(messageSet.getMessages()));                    put(ERROR_TOPIC, loadMessages(messageSet.getErrors()));                }            };        }    });}
public Boolean metron_f4964_0(@Nullable KafkaMessageSet messageSet)
{    return (messageSet.getMessages().size() == inputMessages.size()) && (messageSet.getErrors().size() == inputMessages.size());}
public Map<String, List<Map<String, Object>>> metron_f4965_0(@Nullable KafkaMessageSet messageSet)
{    return new HashMap<String, List<Map<String, Object>>>() {        {            put(Constants.INDEXING_TOPIC, loadMessages(messageSet.getMessages()));            put(ERROR_TOPIC, loadMessages(messageSet.getErrors()));        }    };}
public void metron_f4966_0(byte[] rowKey, ColumnList cols, Durability durability)
{    if (cols.hasColumns()) {        Put put = createPut(rowKey, cols, durability);        mutations.add(put);    }    if (cols.hasCounters()) {        Increment inc = createIncrement(rowKey, cols, durability);        mutations.add(inc);    }    if (mutations.isEmpty()) {        mutations.add(new Put(rowKey));    }}
public void metron_f4967_0(byte[] rowKey, ColumnList cols, Durability durability, Long timeToLiveMillis)
{    if (cols.hasColumns()) {        Put put = createPut(rowKey, cols, durability, timeToLiveMillis);        mutations.add(put);    }    if (cols.hasCounters()) {        Increment inc = createIncrement(rowKey, cols, durability, timeToLiveMillis);        mutations.add(inc);    }    if (mutations.isEmpty()) {        Put put = new Put(rowKey);        put.setTTL(timeToLiveMillis);        mutations.add(put);    }}
public void metron_f4968_0()
{    mutations.clear();}
public int metron_f4969_1()
{    int mutationCount = mutations.size();    Object[] result = new Object[mutationCount];    try {        table.batch(mutations, result);        mutations.clear();    } catch (Exception e) {        String msg = String.format("'%d' HBase write(s) failed on table '%s'", size(mutations), tableName(table));                throw new RuntimeException(msg, e);    }    return mutationCount;}
public void metron_f4970_0(byte[] rowKey, HBaseProjectionCriteria criteria)
{    Get get = new Get(rowKey);    if (criteria != null) {        criteria.getColumnFamilies().forEach(cf -> get.addFamily(cf));        criteria.getColumns().forEach(col -> get.addColumn(col.getColumnFamily(), col.getQualifier()));    }        this.gets.add(get);}
public void metron_f4971_0()
{    gets.clear();}
public Result[] metron_f4972_1()
{    try {        Result[] results = table.get(gets);        gets.clear();        return results;    } catch (Exception e) {        String msg = String.format("'%d' HBase read(s) failed on table '%s'", size(gets), tableName(table));                throw new RuntimeException(msg, e);    }}
public void metron_f4973_0() throws IOException
{    if (table != null) {        table.close();    }}
private Put metron_f4974_0(byte[] rowKey, ColumnList cols, Durability durability)
{    Put put = new Put(rowKey);    put.setDurability(durability);    addColumns(cols, put);    return put;}
private Put metron_f4975_0(byte[] rowKey, ColumnList cols, Durability durability, long timeToLiveMillis)
{    Put put = new Put(rowKey);    put.setDurability(durability);    put.setTTL(timeToLiveMillis);    addColumns(cols, put);    return put;}
private void metron_f4976_0(ColumnList cols, Put put)
{    for (ColumnList.Column col : cols.getColumns()) {        if (col.getTs() > 0) {            put.add(col.getFamily(), col.getQualifier(), col.getTs(), col.getValue());        } else {            put.add(col.getFamily(), col.getQualifier(), col.getValue());        }    }}
private Increment metron_f4977_0(byte[] rowKey, ColumnList cols, Durability durability)
{    Increment inc = new Increment(rowKey);    inc.setDurability(durability);    cols.getCounters().forEach(cnt -> inc.addColumn(cnt.getFamily(), cnt.getQualifier(), cnt.getIncrement()));    return inc;}
private Increment metron_f4978_0(byte[] rowKey, ColumnList cols, Durability durability, long timeToLiveMillis)
{    Increment inc = new Increment(rowKey);    inc.setDurability(durability);    inc.setTTL(timeToLiveMillis);    cols.getCounters().forEach(cnt -> inc.addColumn(cnt.getFamily(), cnt.getQualifier(), cnt.getIncrement()));    return inc;}
private static String metron_f4979_0(Table table)
{    String tableName = "null";    if (table != null) {        if (table.getName() != null) {            tableName = table.getName().getNameAsString();        }    }    return tableName;}
public void metron_f4980_0(String rowKey, String columnFamily, String columnQualifier, String value) throws IOException
{    Put put = new Put(Bytes.toBytes(rowKey));    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnQualifier), Bytes.toBytes(value));    table.put(put);}
public List<String> metron_f4981_0() throws IOException
{    Scan scan = new Scan();    ResultScanner scanner = table.getScanner(scan);    List<String> rows = new ArrayList<>();    for (Result r = scanner.next(); r != null; r = scanner.next()) {        rows.add(Bytes.toString(r.getRow()));    }    return rows;}
public byte[] metron_f4982_0()
{    return family;}
public byte[] metron_f4983_0()
{    return qualifier;}
public byte[] metron_f4984_0()
{    return value;}
public long metron_f4985_0()
{    return ts;}
public long metron_f4986_0()
{    return incr;}
private ArrayList<Column> metron_f4987_0()
{    if (this.columns == null) {        this.columns = new ArrayList<>();    }    return this.columns;}
private ArrayList<Counter> metron_f4988_0()
{    if (this.counters == null) {        this.counters = new ArrayList<>();    }    return this.counters;}
public ColumnList metron_f4989_0(byte[] family, byte[] qualifier, long ts, byte[] value)
{    columns().add(new Column(family, qualifier, ts, value));    return this;}
public ColumnList metron_f4990_0(byte[] family, byte[] qualifier, byte[] value)
{    columns().add(new Column(family, qualifier, -1, value));    return this;}
public ColumnList metron_f4991_0(IColumn column)
{    return this.addColumn(column.family(), column.qualifier(), column.timestamp(), column.value());}
public ColumnList metron_f4992_0(byte[] family, byte[] qualifier, long incr)
{    counters().add(new Counter(family, qualifier, incr));    return this;}
public ColumnList metron_f4993_0(ICounter counter)
{    return this.addCounter(counter.family(), counter.qualifier(), counter.increment());}
public boolean metron_f4994_0()
{    return this.columns != null;}
public boolean metron_f4995_0()
{    return this.counters != null;}
public List<Column> metron_f4996_0()
{    return this.columns;}
public List<Counter> metron_f4997_0()
{    return this.counters;}
public byte[] metron_f4998_0()
{    return columnFamily;}
public byte[] metron_f4999_0()
{    return qualifier;}
public HBaseProjectionCriteria metron_f5000_0(String columnFamily)
{    this.columnFamilies.add(columnFamily.getBytes(StandardCharsets.UTF_8));    return this;}
public HBaseProjectionCriteria metron_f5001_0(ColumnMetaData column)
{    this.columns.add(column);    return this;}
public List<ColumnMetaData> metron_f5002_0()
{    return columns;}
public List<byte[]> metron_f5003_0()
{    return columnFamilies;}
public Connection metron_f5004_0() throws IOException
{    if (conn == null || conn.isClosed()) {        conn = ConnectionFactory.createConnection(config);    }    return conn;}
public Table metron_f5005_0(Configuration config, String tableName) throws IOException
{    return getConnection(config).getTable(TableName.valueOf(tableName));}
private Connection metron_f5006_0(Configuration config) throws IOException
{    ThreadLocal<RetryingConnection> threadLocal = connMap.computeIfAbsent(config, c -> ThreadLocal.withInitial(() -> new RetryingConnection(config)));    return threadLocal.get().getUnderlying();}
public String metron_f5007_0()
{    return tableName;}
public TableConfig metron_f5008_0(String impl)
{    connectorImpl = impl;    return this;}
public TableConfig metron_f5009_0(String table)
{    this.tableName = table;    return this;}
public TableConfig metron_f5010_0(Boolean isBatch)
{    this.batch = isBatch;    return this;}
public String metron_f5011_0()
{    return connectorImpl;}
public boolean metron_f5012_0()
{    return batch;}
public void metron_f5013_0(boolean batch)
{    this.batch = batch;}
public void metron_f5014_0(long writeBufferSize)
{    this.writeBufferSize = writeBufferSize;}
public long metron_f5015_0()
{    return writeBufferSize;}
public Set<String> metron_f5016_0()
{    return this.columnFamilies.keySet();}
 static TableProvider metron_f5017_0(String impl, Supplier<TableProvider> defaultSupplier) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException
{    if (impl == null) {        return defaultSupplier.get();    }    Class<? extends TableProvider> clazz = (Class<? extends TableProvider>) Class.forName(impl);    return clazz.getConstructor().newInstance();}
public static void metron_f5018_0() throws Exception
{    Configuration config = HBaseConfiguration.create();    config.set("hbase.master.hostname", "localhost");    config.set("hbase.regionserver.hostname", "localhost");    util = new HBaseTestingUtility(config);    util.startMiniCluster();    admin = util.getHBaseAdmin();        table = util.createTable(Bytes.toBytes(tableName), cf);    util.waitTableEnabled(table.getName());        client = new HBaseClient((c, t) -> table, table.getConfiguration(), tableName);}
public static void metron_f5019_0() throws Exception
{    util.deleteTable(tableName);    util.shutdownMiniCluster();    util.cleanupTestDir();}
public void metron_f5020_0() throws Exception
{    List<Delete> deletions = new ArrayList<>();    for (Result r : table.getScanner(new Scan())) {        deletions.add(new Delete(r.getRow()));    }    table.delete(deletions);}
public void metron_f5021_0() throws Exception
{    rowKey1 = Bytes.toBytes("rowKey1");    cols1 = new ColumnList();    cols1.addColumn(cf, column, value1);    rowKey2 = Bytes.toBytes("rowKey2");    cols2 = new ColumnList();    cols2.addColumn(cf, column, value2);}
public void metron_f5022_0() throws Exception
{        client.addMutation(rowKey1, cols1, Durability.SYNC_WAL);    client.mutate();    HBaseProjectionCriteria criteria = new HBaseProjectionCriteria();    criteria.addColumnFamily(Bytes.toString(cf));        client.addGet(rowKey1, criteria);    Result[] results = client.getAll();    Assert.assertEquals(1, results.length);        assertEquals(1, results.length);    assertArrayEquals(rowKey1, results[0].getRow());    assertArrayEquals(value1, results[0].getValue(cf, column));}
public void metron_f5023_0() throws Exception
{        client.addMutation(rowKey1, cols1, Durability.SYNC_WAL);    client.addMutation(rowKey2, cols2, Durability.SYNC_WAL);    int count = client.mutate();        Assert.assertEquals(2, count);    HBaseProjectionCriteria criteria = new HBaseProjectionCriteria();    criteria.addColumnFamily(Bytes.toString(cf));        client.addGet(rowKey1, criteria);    client.addGet(rowKey2, criteria);    Result[] results = client.getAll();        assertEquals(2, results.length);    assertArrayEquals(rowKey1, results[0].getRow());    assertArrayEquals(value1, results[0].getValue(cf, column));    assertArrayEquals(rowKey1, results[0].getRow());    assertArrayEquals(value2, results[1].getValue(cf, column));}
public void metron_f5024_0() throws Exception
{        int count = client.mutate();    Assert.assertEquals(0, count);    HBaseProjectionCriteria criteria = new HBaseProjectionCriteria();    criteria.addColumnFamily(Bytes.toString(cf));        client.addGet(rowKey1, criteria);    client.addGet(rowKey2, criteria);    Result[] results = client.getAll();        assertEquals(2, results.length);    for (Result result : results) {        Assert.assertTrue(result.isEmpty());    }}
public void metron_f5025_0() throws Exception
{    long timeToLive = TimeUnit.DAYS.toMillis(30);        client.addMutation(rowKey1, cols1, Durability.SYNC_WAL, timeToLive);    client.addMutation(rowKey2, cols2, Durability.SYNC_WAL, timeToLive);    client.mutate();    HBaseProjectionCriteria criteria = new HBaseProjectionCriteria();    criteria.addColumnFamily(Bytes.toString(cf));        client.addGet(rowKey1, criteria);    client.addGet(rowKey2, criteria);    Result[] results = client.getAll();        assertEquals(2, results.length);    assertArrayEquals(rowKey1, results[0].getRow());    assertArrayEquals(value1, results[0].getValue(cf, column));    assertArrayEquals(rowKey1, results[0].getRow());    assertArrayEquals(value2, results[1].getValue(cf, column));}
public void metron_f5026_0() throws Exception
{    long timeToLive = TimeUnit.MILLISECONDS.toMillis(1);        client.addMutation(rowKey1, cols1, Durability.SYNC_WAL, timeToLive);    client.addMutation(rowKey2, cols2, Durability.SYNC_WAL, timeToLive);    client.mutate();    HBaseProjectionCriteria criteria = new HBaseProjectionCriteria();    criteria.addColumnFamily(Bytes.toString(cf));        Thread.sleep(TimeUnit.SECONDS.toMillis(2));        client.addGet(rowKey1, criteria);    client.addGet(rowKey2, criteria);    Result[] results = client.getAll();        assertEquals(2, results.length);    assertTrue(results[0].isEmpty());    assertTrue(results[1].isEmpty());}
public void metron_f5027_0() throws IOException
{        TableProvider tableProvider = mock(TableProvider.class);    when(tableProvider.getTable(any(), any())).thenThrow(new IllegalArgumentException("test exception"));    client = new HBaseClient(tableProvider, HBaseConfiguration.create(), tableName);}
public void metron_f5028_0() throws IOException, InterruptedException
{        Table table = mock(Table.class);    doThrow(new IOException("exception!")).when(table).batch(any(), any());    TableProvider tableProvider = mock(TableProvider.class);    when(tableProvider.getTable(any(), any())).thenReturn(table);    client = new HBaseClient(tableProvider, HBaseConfiguration.create(), tableName);    client.addMutation(rowKey1, cols1, Durability.SYNC_WAL);    client.mutate();}
public void metron_f5029_0() throws IOException
{        Table table = mock(Table.class);    when(table.get(anyListOf(Get.class))).thenThrow(new IOException("exception!"));    TableProvider tableProvider = mock(TableProvider.class);    when(tableProvider.getTable(any(), any())).thenReturn(table);    HBaseProjectionCriteria criteria = new HBaseProjectionCriteria();    criteria.addColumnFamily(Bytes.toString(cf));    client = new HBaseClient(tableProvider, HBaseConfiguration.create(), tableName);    client.addGet(rowKey1, criteria);    client.addGet(rowKey2, criteria);    client.getAll();}
public Table metron_f5030_0(Configuration configuration, String tableName) throws IOException
{    Table ret = _cache.get(tableName);    return ret;}
public static Table metron_f5031_0(String tableName)
{    return _cache.get(tableName);}
public static Table metron_f5032_0(String tableName, String... columnFamilies)
{    MockHTable ret = new MockHTable(tableName, columnFamilies);    _cache.put(tableName, ret);    return ret;}
public static void metron_f5033_0()
{    _cache.clear();}
private static List<KeyValue> metron_f5034_0(byte[] row, NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> rowdata, int maxVersions)
{    return toKeyValue(row, rowdata, 0, Long.MAX_VALUE, maxVersions);}
private static List<KeyValue> metron_f5035_0(byte[] row, NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> rowdata, long timestampStart, long timestampEnd, int maxVersions)
{    List<KeyValue> ret = new ArrayList<KeyValue>();    for (byte[] family : rowdata.keySet()) for (byte[] qualifier : rowdata.get(family).keySet()) {        int versionsAdded = 0;        for (Map.Entry<Long, byte[]> tsToVal : rowdata.get(family).get(qualifier).descendingMap().entrySet()) {            if (versionsAdded++ == maxVersions)                break;            Long timestamp = tsToVal.getKey();            if (timestamp < timestampStart)                continue;            if (timestamp > timestampEnd)                continue;            byte[] value = tsToVal.getValue();            ret.add(new KeyValue(row, family, qualifier, timestamp, value));        }    }    return ret;}
public int metron_f5036_0()
{    return data.size();}
public void metron_f5037_0(String columnFamily)
{    this.columnFamilies.add(columnFamily);    descriptors = new HColumnDescriptor[columnFamilies.size()];    int i = 0;    for (String cf : columnFamilies) {        descriptors[i++] = new HColumnDescriptor(cf);    }}
public byte[] metron_f5038_0()
{    return Bytes.toBytes(tableName);}
public TableName metron_f5039_0()
{    return TableName.valueOf(tableName);}
public Configuration metron_f5040_0()
{    return HBaseConfiguration.create();}
public HTableDescriptor metron_f5041_0() throws IOException
{    HTableDescriptor ret = new HTableDescriptor(tableName);    for (HColumnDescriptor c : descriptors) {        ret.addFamily(c);    }    return ret;}
public boolean metron_f5042_0(Get get) throws IOException
{    if (get.getFamilyMap() == null || get.getFamilyMap().size() == 0) {        return data.containsKey(get.getRow());    } else {        byte[] row = get.getRow();        if (!data.containsKey(row)) {            return false;        }        for (byte[] family : get.getFamilyMap().keySet()) {            if (!data.get(row).containsKey(family)) {                return false;            } else {                return true;            }        }        return true;    }}
public boolean[] metron_f5043_0(List<Get> gets) throws IOException
{    boolean[] ret = new boolean[gets.size()];    int i = 0;    for (boolean b : exists(gets)) {        ret[i++] = b;    }    return ret;}
public Boolean[] metron_f5044_0(List<Get> list) throws IOException
{    Boolean[] ret = new Boolean[list.size()];    int i = 0;    for (Get g : list) {        ret[i++] = exists(g);    }    return ret;}
public void metron_f5045_0(List<? extends Row> list, Object[] objects) throws IOException, InterruptedException
{    Object[] results = batch(list);    System.arraycopy(results, 0, objects, 0, results.length);}
public Object[] metron_f5046_0(List<? extends Row> actions) throws IOException, InterruptedException
{    List<Result> results = new ArrayList<Result>();    for (Row r : actions) {        if (r instanceof Delete) {            delete((Delete) r);            continue;        }        if (r instanceof Put) {            put((Put) r);            continue;        }        if (r instanceof Get) {            results.add(get((Get) r));        }    }    return results.toArray();}
public void metron_f5047_0(List<? extends Row> list, Object[] objects, Batch.Callback<R> callback) throws IOException, InterruptedException
{    throw new UnsupportedOperationException();}
public Object[] metron_f5048_0(List<? extends Row> list, Batch.Callback<R> callback) throws IOException, InterruptedException
{    throw new UnsupportedOperationException();}
public Result metron_f5049_0(Get get) throws IOException
{    if (!data.containsKey(get.getRow()))        return new Result();    byte[] row = get.getRow();    List<KeyValue> kvs = new ArrayList<KeyValue>();    if (!get.hasFamilies()) {        kvs = toKeyValue(row, data.get(row), get.getMaxVersions());    } else {        for (byte[] family : get.getFamilyMap().keySet()) {            if (data.get(row).get(family) == null)                continue;            NavigableSet<byte[]> qualifiers = get.getFamilyMap().get(family);            if (qualifiers == null || qualifiers.isEmpty())                qualifiers = data.get(row).get(family).navigableKeySet();            for (byte[] qualifier : qualifiers) {                if (qualifier == null)                    qualifier = "".getBytes(StandardCharsets.UTF_8);                if (!data.get(row).containsKey(family) || !data.get(row).get(family).containsKey(qualifier) || data.get(row).get(family).get(qualifier).isEmpty())                    continue;                Map.Entry<Long, byte[]> timestampAndValue = data.get(row).get(family).get(qualifier).lastEntry();                kvs.add(new KeyValue(row, family, qualifier, timestampAndValue.getKey(), timestampAndValue.getValue()));            }        }    }    Filter filter = get.getFilter();    if (filter != null) {        filter.reset();        List<KeyValue> nkvs = new ArrayList<KeyValue>(kvs.size());        for (KeyValue kv : kvs) {            if (filter.filterAllRemaining()) {                break;            }            if (filter.filterRowKey(kv.getBuffer(), kv.getRowOffset(), kv.getRowLength())) {                continue;            }            if (filter.filterKeyValue(kv) == Filter.ReturnCode.INCLUDE) {                nkvs.add(kv);            }                }        if (filter.hasFilterRow()) {            filter.filterRow();        }        kvs = nkvs;    }    return new Result(kvs);}
public Result[] metron_f5050_0(List<Get> list) throws IOException
{    Result[] ret = new Result[list.size()];    int i = 0;    for (Get g : list) {        ret[i++] = get(g);    }    return ret;}
public Result metron_f5051_0(byte[] bytes, byte[] bytes1) throws IOException
{    throw new UnsupportedOperationException();}
public ResultScanner metron_f5052_0(Scan scan) throws IOException
{    final List<Result> ret = new ArrayList<Result>();    byte[] st = scan.getStartRow();    byte[] sp = scan.getStopRow();    Filter filter = scan.getFilter();    for (byte[] row : data.keySet()) {                if (st != null && st.length > 0 && Bytes.BYTES_COMPARATOR.compare(st, row) != 0) {                        if (st != null && st.length > 0 && Bytes.BYTES_COMPARATOR.compare(st, row) > 0)                continue;                        if (sp != null && sp.length > 0 && Bytes.BYTES_COMPARATOR.compare(sp, row) <= 0)                break;        }        List<KeyValue> kvs = null;        if (!scan.hasFamilies()) {            kvs = toKeyValue(row, data.get(row), scan.getTimeRange().getMin(), scan.getTimeRange().getMax(), scan.getMaxVersions());        } else {            kvs = new ArrayList<KeyValue>();            for (byte[] family : scan.getFamilyMap().keySet()) {                if (data.get(row).get(family) == null)                    continue;                NavigableSet<byte[]> qualifiers = scan.getFamilyMap().get(family);                if (qualifiers == null || qualifiers.isEmpty())                    qualifiers = data.get(row).get(family).navigableKeySet();                for (byte[] qualifier : qualifiers) {                    if (data.get(row).get(family).get(qualifier) == null)                        continue;                    for (Long timestamp : data.get(row).get(family).get(qualifier).descendingKeySet()) {                        if (timestamp < scan.getTimeRange().getMin())                            continue;                        if (timestamp > scan.getTimeRange().getMax())                            continue;                        byte[] value = data.get(row).get(family).get(qualifier).get(timestamp);                        kvs.add(new KeyValue(row, family, qualifier, timestamp, value));                        if (kvs.size() == scan.getMaxVersions()) {                            break;                        }                    }                }            }        }        if (filter != null) {            filter.reset();            List<KeyValue> nkvs = new ArrayList<KeyValue>(kvs.size());            for (KeyValue kv : kvs) {                if (filter.filterAllRemaining()) {                    break;                }                if (filter.filterRowKey(kv.getBuffer(), kv.getRowOffset(), kv.getRowLength())) {                    continue;                }                Filter.ReturnCode filterResult = filter.filterKeyValue(kv);                if (filterResult == Filter.ReturnCode.INCLUDE) {                    nkvs.add(kv);                } else if (filterResult == Filter.ReturnCode.NEXT_ROW) {                    break;                }                        }            if (filter.hasFilterRow()) {                filter.filterRow();            }            kvs = nkvs;        }        if (!kvs.isEmpty()) {            ret.add(new Result(kvs));        }    }    return new ResultScanner() {        private final Iterator<Result> iterator = ret.iterator();        @Override        public Iterator<Result> iterator() {            return iterator;        }        @Override        public Result[] next(int nbRows) throws IOException {            ArrayList<Result> resultSets = new ArrayList<Result>(nbRows);            for (int i = 0; i < nbRows; i++) {                Result next = next();                if (next != null) {                    resultSets.add(next);                } else {                    break;                }            }            return resultSets.toArray(new Result[resultSets.size()]);        }        @Override        public Result next() throws IOException {            try {                return iterator().next();            } catch (NoSuchElementException e) {                return null;            }        }        @Override        public void close() {        }    };}
public Iterator<Result> metron_f5053_0()
{    return iterator;}
public Result[] metron_f5054_0(int nbRows) throws IOException
{    ArrayList<Result> resultSets = new ArrayList<Result>(nbRows);    for (int i = 0; i < nbRows; i++) {        Result next = next();        if (next != null) {            resultSets.add(next);        } else {            break;        }    }    return resultSets.toArray(new Result[resultSets.size()]);}
public Result metron_f5055_0() throws IOException
{    try {        return iterator().next();    } catch (NoSuchElementException e) {        return null;    }}
public void metron_f5056_0()
{}
public ResultScanner metron_f5057_0(byte[] family) throws IOException
{    Scan scan = new Scan();    scan.addFamily(family);    return getScanner(scan);}
public ResultScanner metron_f5058_0(byte[] family, byte[] qualifier) throws IOException
{    Scan scan = new Scan();    scan.addColumn(family, qualifier);    return getScanner(scan);}
public List<Put> metron_f5059_0()
{    synchronized (putLog) {        return ImmutableList.copyOf(putLog);    }}
public void metron_f5060_0(Put put)
{    synchronized (putLog) {        putLog.add(put);    }}
public void metron_f5061_0()
{    synchronized (putLog) {        putLog.clear();    }    data.clear();}
public void metron_f5062_0(Put put) throws IOException
{    addToPutLog(put);    byte[] row = put.getRow();    NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> rowData = forceFind(data, row, new TreeMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>>(Bytes.BYTES_COMPARATOR));    for (byte[] family : put.getFamilyMap().keySet()) {        NavigableMap<byte[], NavigableMap<Long, byte[]>> familyData = forceFind(rowData, family, new TreeMap<byte[], NavigableMap<Long, byte[]>>(Bytes.BYTES_COMPARATOR));        for (KeyValue kv : put.getFamilyMap().get(family)) {            kv.updateLatestStamp(Bytes.toBytes(System.currentTimeMillis()));            byte[] qualifier = kv.getQualifier();            NavigableMap<Long, byte[]> qualifierData = forceFind(familyData, qualifier, new TreeMap<Long, byte[]>());            qualifierData.put(kv.getTimestamp(), kv.getValue());        }    }}
private V metron_f5063_0(NavigableMap<K, V> map, K key, V newObject)
{    V data = map.get(key);    if (data == null) {        data = newObject;        map.put(key, data);    }    return data;}
public void metron_f5064_0(List<Put> puts) throws IOException
{    for (Put put : puts) put(put);}
public boolean metron_f5065_0(byte[] bytes, byte[] bytes1, byte[] bytes2, byte[] bytes3, Put put) throws IOException
{    throw new UnsupportedOperationException();}
public boolean metron_f5066_0(byte[] row, byte[] family, byte[] qualifier, CompareFilter.CompareOp compareOp, byte[] value, Put put) throws IOException
{    return false;}
public void metron_f5067_0(Delete delete) throws IOException
{    byte[] row = delete.getRow();    if (data.containsKey(row)) {        data.remove(row);    } else {        throw new IOException();    }}
public void metron_f5068_0(List<Delete> list) throws IOException
{    throw new UnsupportedOperationException();}
public boolean metron_f5069_0(byte[] bytes, byte[] bytes1, byte[] bytes2, byte[] bytes3, Delete delete) throws IOException
{    throw new UnsupportedOperationException();}
public boolean metron_f5070_0(byte[] row, byte[] family, byte[] qualifier, CompareFilter.CompareOp compareOp, byte[] value, Delete delete) throws IOException
{    return false;}
public void metron_f5071_0(RowMutations rowMutations) throws IOException
{    throw new UnsupportedOperationException();}
public Result metron_f5072_0(Append append) throws IOException
{    throw new UnsupportedOperationException();}
public Result metron_f5073_0(Increment increment) throws IOException
{    throw new UnsupportedOperationException();}
public long metron_f5074_0(byte[] bytes, byte[] bytes1, byte[] bytes2, long l) throws IOException
{    throw new UnsupportedOperationException();}
public long metron_f5075_0(byte[] bytes, byte[] bytes1, byte[] bytes2, long l, Durability durability) throws IOException
{    throw new UnsupportedOperationException();}
public long metron_f5076_0(byte[] bytes, byte[] bytes1, byte[] bytes2, long l, boolean b) throws IOException
{    throw new UnsupportedOperationException();}
public boolean metron_f5077_0()
{    return autoflush;}
public void metron_f5078_0() throws IOException
{}
public void metron_f5079_0() throws IOException
{}
public CoprocessorRpcChannel metron_f5080_0(byte[] bytes)
{    throw new UnsupportedOperationException();}
public Map<byte[], R> metron_f5081_0(Class<T> aClass, byte[] bytes, byte[] bytes1, Batch.Call<T, R> call) throws ServiceException, Throwable
{    throw new UnsupportedOperationException();}
public void metron_f5082_0(Class<T> aClass, byte[] bytes, byte[] bytes1, Batch.Call<T, R> call, Batch.Callback<R> callback) throws ServiceException, Throwable
{    throw new UnsupportedOperationException();}
public void metron_f5083_0(boolean b)
{    autoflush = b;}
public void metron_f5084_0(boolean b, boolean b1)
{    autoflush = b;}
public void metron_f5085_0(boolean b)
{    autoflush = b;}
public long metron_f5086_0()
{    return writeBufferSize;}
public void metron_f5087_0(long l) throws IOException
{    writeBufferSize = l;}
public Map<byte[], R> metron_f5088_0(Descriptors.MethodDescriptor methodDescriptor, Message message, byte[] bytes, byte[] bytes1, R r) throws ServiceException, Throwable
{    throw new UnsupportedOperationException();}
public void metron_f5089_0(Descriptors.MethodDescriptor methodDescriptor, Message message, byte[] bytes, byte[] bytes1, R r, Batch.Callback<R> callback) throws ServiceException, Throwable
{    throw new UnsupportedOperationException();}
public boolean metron_f5090_0(byte[] row, byte[] family, byte[] qualifier, CompareFilter.CompareOp compareOp, byte[] value, RowMutations mutation) throws IOException
{    return false;}
public void metron_f5091_1(CoprocessorEnvironment ce) throws IOException
{        if (ce instanceof RegionCoprocessorEnvironment) {        this.coprocessorEnv = (RegionCoprocessorEnvironment) ce;    } else {        throw new CoprocessorException("Enrichment coprocessor must be loaded on a table region.");    }        if (null == this.cache) {                        String zkUrl = getZookeeperUrl(this.coprocessorEnv.getConfiguration());        if (null == globalConfigService) {            globalConfigService = getGlobalConfigService(zkUrl);        }        globalConfig = globalConfigService.get();        Configuration config = this.coprocessorEnv.getConfiguration();        CacheWriter<String, String> cacheWriter = null;        try {            String hbaseTableProviderName = (String) globalConfig.get(EnrichmentConfigurations.TABLE_PROVIDER);            String tableName = (String) globalConfig.get(EnrichmentConfigurations.TABLE_NAME);            String columnFamily = (String) globalConfig.get(EnrichmentConfigurations.COLUMN_FAMILY);            cacheWriter = new HBaseCacheWriter(config, TableProvider.create(hbaseTableProviderName, HTableProvider::new), tableName, columnFamily, COLUMN_QUALIFIER);        } catch (ClassNotFoundException | InstantiationException | InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {            throw new IOException("Unable to instantiate cache writer", e);        }        this.cache = Caffeine.newBuilder().writer(cacheWriter).build();            }    }
private String metron_f5092_0(Configuration config)
{    String zkUrl = config.get(ZOOKEEPER_URL);    if (null == zkUrl) {        throw new IllegalStateException("Enrichment coprocessor requires property '" + ZOOKEEPER_URL + "' to be provided at startup.");    }    return zkUrl;}
private GlobalConfigService metron_f5093_0(String zkUrl)
{    return new GlobalConfigService() {        @Override        public Map<String, Object> get() {            try (CuratorFramework client = ConfigurationsUtils.getClient(zkUrl)) {                client.start();                return ConfigurationsUtils.readGlobalConfigFromZookeeper(client);            } catch (Exception e) {                throw new IllegalStateException("Unable to read global configuration from zookeeper", e);            }        }    };}
public Map<String, Object> metron_f5094_0()
{    try (CuratorFramework client = ConfigurationsUtils.getClient(zkUrl)) {        client.start();        return ConfigurationsUtils.readGlobalConfigFromZookeeper(client);    } catch (Exception e) {        throw new IllegalStateException("Unable to read global configuration from zookeeper", e);    }}
public void metron_f5095_1(ObserverContext<RegionCoprocessorEnvironment> e, Put put, WALEdit edit, Durability durability) throws IOException
{    LOG.trace("enrichment coprocessor postPut call begin");    try {        LOG.trace("Extracting enrichment type from rowkey");        String type = getEnrichmentType(put);                final String metadata = "{}";        LOG.trace("Enrichment type '{}' extracted from rowkey", type);        addToCache(type, metadata);    } catch (Throwable t) {                        throw new IOException("Error occurred while processing enrichment Put.", t);    }    LOG.trace("enrichment coprocessor postPut call complete");}
private String metron_f5096_0(Put put)
{    EnrichmentKey key = new EnrichmentKey();    key.fromBytes(put.getRow());    return key.type;}
private void metron_f5097_0(String cacheKey, String value)
{    LOG.trace("Checking if cacheKey '{}'present in cache", cacheKey);        if (null == cache.getIfPresent(cacheKey)) {        LOG.trace("cacheKey '{}' not present, adding with value='{}' to cache", cacheKey, value);        cache.put(cacheKey, value);        LOG.trace("Done adding cacheKey '{}' to cache with value='{}'", cacheKey, value);    }}
public void metron_f5098_1(@Nonnull String key, @Nonnull String value)
{        try (HBaseClient hbClient = new HBaseClient(this.tableProvider, this.config, this.tableName)) {                hbClient.put(key, columnFamily, columnQualifier, value);            } catch (IOException e) {        throw new RuntimeException("Error writing to HBase table", e);    }    }
public void metron_f5099_0(@Nonnull String key, @Nullable String value, @Nonnull RemovalCause cause)
{}
public static void metron_f5100_0() throws Exception
{    silenceLogging();        startZookeeper(new Properties());    globalConfig = globalConfig.replace("%TABLE_NAME%", ENRICHMENT_LIST_TABLE).replace("%COLUMN_FAMILY%", COLUMN_FAMILY).replace("%PROVIDER_NAME%", HTableProvider.class.getName());    uploadGlobalConfigToZK(globalConfig);    configureAndStartHBase();    addCoprocessor(enrichmentTable.getName());}
private static void metron_f5101_0()
{    originalLog4jRootLoggerLevel = UnitTestHelper.getLog4jLevel();    originalJavaLoggerLevel = UnitTestHelper.getJavaLoggingLevel();    UnitTestHelper.setLog4jLevel(Level.ERROR);        /*    UnitTestHelper.setLog4jLevel(EnrichmentCoprocessor.class, Level.DEBUG);    UnitTestHelper.setLog4jLevel(HBaseCacheWriter.class, Level.DEBUG);    */    UnitTestHelper.setJavaLoggingLevel(java.util.logging.Level.SEVERE);}
private static void metron_f5102_0(Properties properties) throws UnableToStartException
{    zookeeperComponent = getZKServerComponent(properties);    componentRunner = new ComponentRunner.Builder().withComponent("zk", zookeeperComponent).withMillisecondsBetweenAttempts(15000).withNumRetries(10).build();    componentRunner.start();}
private static void metron_f5103_0(String config) throws Exception
{    ConfigurationsUtils.writeGlobalConfigToZookeeper(config.getBytes(StandardCharsets.UTF_8), zookeeperComponent.getConnectionString());}
private static void metron_f5104_0() throws Exception
{    Configuration extraConfig = new Configuration();    extraConfig.set(EnrichmentCoprocessor.ZOOKEEPER_URL, zookeeperComponent.getConnectionString());    Map.Entry<HBaseTestingUtility, Configuration> kv = HBaseUtil.INSTANCE.create(true, extraConfig);    testUtil = kv.getKey();    hBaseConfig = kv.getValue();    enrichmentTable = testUtil.createTable(Bytes.toBytes(ENRICHMENT_TABLE), Bytes.toBytes(COLUMN_FAMILY));    enrichmentListTable = testUtil.createTable(Bytes.toBytes(ENRICHMENT_LIST_TABLE), Bytes.toBytes(COLUMN_FAMILY));    for (Result r : enrichmentTable.getScanner(Bytes.toBytes(COLUMN_FAMILY))) {        Delete d = new Delete(r.getRow());        enrichmentTable.delete(d);    }    for (Result r : enrichmentListTable.getScanner(Bytes.toBytes(COLUMN_FAMILY))) {        Delete d = new Delete(r.getRow());        enrichmentListTable.delete(d);    }}
private static void metron_f5105_0(TableName tableName) throws IOException
{        Admin hbaseAdmin = testUtil.getConnection().getAdmin();    hbaseAdmin.disableTable(tableName);    HTableDescriptor htd = new HTableDescriptor(tableName);    htd.addFamily(new HColumnDescriptor(COLUMN_FAMILY));    htd.addCoprocessor(EnrichmentCoprocessor.class.getCanonicalName());    hbaseAdmin.modifyTable(tableName, htd);    hbaseAdmin.enableTable(tableName);}
public static void metron_f5106_0() throws Exception
{    HBaseUtil.INSTANCE.teardown(testUtil);    componentRunner.stop();    resetLogging();}
private static void metron_f5107_0()
{    UnitTestHelper.setLog4jLevel(originalLog4jRootLoggerLevel);    UnitTestHelper.setJavaLoggingLevel(originalJavaLoggerLevel);}
public void metron_f5108_0() throws Exception
{        Map<String, String> enrichments = new HashMap<String, String>() {        {            put("111", "foo");            put("222", "foo");            put("333", "bar");            put("444", "bar");            put("555", "baz");            put("666", "baz");        }    };    Set<String> expectedEnrichmentTypes = new HashSet<>();    for (Map.Entry<String, String> enrichKV : enrichments.entrySet()) {        String indicator = enrichKV.getKey();        String type = enrichKV.getValue();        expectedEnrichmentTypes.add(type);        HelperDao.insertRecord(enrichmentTable, new EnrichmentKey(type, indicator), COLUMN_FAMILY, "{ \"apache\" : \"metron\" }");    }    List<String> enrichmentsList = HelperDao.readRecords(enrichmentListTable);    assertThat(new HashSet<String>(enrichmentsList), equalTo(expectedEnrichmentTypes));}
public void metron_f5109_0()
{    MockitoAnnotations.initMocks(this);    cop = new EnrichmentCoprocessor(cacheWriter, globalConfigService);    config = HBaseConfiguration.create();    config.set(EnrichmentCoprocessor.ZOOKEEPER_URL, "foobar");    when(copEnv.getConfiguration()).thenReturn(config);    instantiatedCustomTableProvider = false;}
public void metron_f5110_0() throws Exception
{    cop.start(copEnv);    String[] enrichTypes = new String[] { "foo", "bar", "baz", "metron" };    final int putsPerType = 3;    Map<String, List<Put>> putsByType = simulateMultiplePutsPerType(putsPerType, enrichTypes);    int totalPuts = 0;    for (Map.Entry<String, List<Put>> entry : putsByType.entrySet()) {        String type = entry.getKey();        List<Put> puts = entry.getValue();        for (Put put : puts) {            cop.postPut(observerContext, put, null, null);            verify(cacheWriter, times(1)).write(eq(type), eq("{}"));            totalPuts++;        }    }    assertThat(totalPuts, equalTo(enrichTypes.length * putsPerType));}
private Map<String, List<Put>> metron_f5111_0(int count, String... types)
{    Map<String, List<Put>> putsByType = new HashMap<>();    for (String type : types) {        List<Put> puts = putsByType.getOrDefault(type, new ArrayList<>());        for (int i = 0; i < count; i++) {            EnrichmentKey ek = new EnrichmentKey(type, String.valueOf(i));            puts.add(new Put(ek.toBytes()));            putsByType.put(type, puts);        }    }    return putsByType;}
public Table metron_f5112_0(Configuration config, String tableName) throws IOException
{        return null;}
public void metron_f5113_0() throws Exception
{    cop = new EnrichmentCoprocessor(globalConfigService);    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(EnrichmentConfigurations.TABLE_PROVIDER, TestTableProvider.class.getName());        }    };    when(globalConfigService.get()).thenReturn(globalConfig);    cop.start(copEnv);    assertThat(instantiatedCustomTableProvider, equalTo(true));}
public void metron_f5114_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Error occurred while processing enrichment Put.");    thrown.expectCause(instanceOf(RuntimeException.class));    cop.start(copEnv);    cop.postPut(observerContext, new Put("foo".getBytes(StandardCharsets.UTF_8)), null, null);}
public void metron_f5115_0() throws Exception
{    Throwable cause = new Throwable("Bad things happened.");    thrown.expect(IOException.class);    thrown.expectMessage("Error occurred while processing enrichment Put.");    thrown.expectCause(equalTo(cause));            willAnswer(i -> {        throw cause;    }).given(cacheWriter).write(any(), any());    cop.start(copEnv);    EnrichmentKey ek = new EnrichmentKey("foo", "bar");    cop.postPut(observerContext, new Put(ek.toBytes()), null, null);}
public static void metron_f5116_0(Table table, EnrichmentKey key, String cf, String value) throws IOException
{    Put put = createPut(key, cf, value);    table.put(put);}
private static Put metron_f5117_0(EnrichmentKey rowKey, String cf, String value) throws IOException
{    return new EnrichmentConverter().toPut(cf, rowKey, new EnrichmentValue(JSONUtils.INSTANCE.load(value, JSONUtils.MAP_SUPPLIER)));}
public static List<String> metron_f5118_0(Table table) throws Exception
{    Scan scan = new Scan();    ResultScanner scanner = table.getScanner(scan);    List<String> rows = new ArrayList<>();    for (Result r = scanner.next(); r != null; r = scanner.next()) {        rows.add(Bytes.toString(r.getRow()));    }    return rows;}
public Supplier<Map<String, Object>> metron_f5119_0()
{    return globalConfigSupplier;}
public void metron_f5120_0(Supplier<Map<String, Object>> globalConfigSupplier)
{    this.globalConfigSupplier = globalConfigSupplier;}
public Function<String, String> metron_f5121_0()
{    return indexSupplier;}
public void metron_f5122_0(Function<String, String> indexSupplier)
{    this.indexSupplier = indexSupplier;}
public Integer metron_f5123_0()
{    return maxSearchResults;}
public void metron_f5124_0(Integer maxSearchResults)
{    this.maxSearchResults = maxSearchResults;}
public Integer metron_f5125_0()
{    return maxSearchGroups;}
public void metron_f5126_0(Integer maxSearchGroups)
{    this.maxSearchGroups = maxSearchGroups;}
public Map<String, String> metron_f5127_0()
{    return optionalSettings;}
public void metron_f5128_0(Map<String, String> optionalSettings)
{    this.optionalSettings = optionalSettings;}
public TableProvider metron_f5129_0()
{    return tableProvider;}
public void metron_f5130_0(TableProvider tableProvider)
{    this.tableProvider = tableProvider;}
public Boolean metron_f5131_0()
{    return isKerberosEnabled;}
public void metron_f5132_0(Boolean kerberosEnabled)
{    isKerberosEnabled = kerberosEnabled;}
public String metron_f5133_0()
{    return guid;}
public String metron_f5134_0()
{    return sensorType;}
public static Key metron_f5135_0(byte[] buffer) throws IOException
{    ByteArrayInputStream baos = new ByteArrayInputStream(buffer);    DataInputStream w = new DataInputStream(baos);    baos.skip(KeyUtil.HASH_PREFIX_SIZE);    return new Key(w.readUTF(), w.readUTF());}
public byte[] metron_f5136_0() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    if (getGuid() == null || getSensorType() == null) {        throw new IllegalStateException("Guid and sensor type must not be null: guid = " + getGuid() + ", sensorType = " + getSensorType());    }    DataOutputStream w = new DataOutputStream(baos);    w.writeUTF(getGuid());    w.writeUTF(getSensorType());    w.flush();    byte[] key = baos.toByteArray();    byte[] prefix = KeyUtil.INSTANCE.getPrefix(key);    return KeyUtil.INSTANCE.merge(prefix, key);}
public static byte[] metron_f5137_0(Key k) throws IOException
{    return k.toBytes();}
public boolean metron_f5138_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Key key = (Key) o;    if (getGuid() != null ? !getGuid().equals(key.getGuid()) : key.getGuid() != null)        return false;    return getSensorType() != null ? getSensorType().equals(key.getSensorType()) : key.getSensorType() == null;}
public int metron_f5139_0()
{    int result = getGuid() != null ? getGuid().hashCode() : 0;    result = 31 * result + (getSensorType() != null ? getSensorType().hashCode() : 0);    return result;}
public synchronized SearchResponse metron_f5140_0(SearchRequest searchRequest) throws InvalidSearchException
{    return null;}
public GroupResponse metron_f5141_0(GroupRequest groupRequest) throws InvalidSearchException
{    return null;}
public synchronized void metron_f5142_0(AccessConfig config)
{    if (this.tableInterface == null) {        this.config = config;        Map<String, Object> globalConfig = config.getGlobalConfigSupplier().get();        if (globalConfig == null) {            throw new IllegalStateException("Cannot find the global config.");        }        String table = (String) globalConfig.get(HBASE_TABLE);        String cf = (String) config.getGlobalConfigSupplier().get().get(HBASE_CF);        if (table == null || cf == null) {            throw new IllegalStateException("You must configure " + HBASE_TABLE + " and " + HBASE_CF + " in the global config.");        }        try {            tableInterface = config.getTableProvider().getTable(HBaseConfiguration.create(), table);            this.cf = cf.getBytes(StandardCharsets.UTF_8);        } catch (IOException e) {            throw new IllegalStateException("Unable to initialize HBaseDao: " + e.getMessage(), e);        }    }}
public Table metron_f5143_0()
{    if (tableInterface == null) {        init(config);    }    return tableInterface;}
public synchronized Document metron_f5144_0(String guid, String sensorType) throws IOException
{    Key k = new Key(guid, sensorType);    Get get = new Get(Key.toBytes(k));    get.addFamily(cf);    Result result = getTableInterface().get(get);    return getDocumentFromResult(result);}
public Iterable<Document> metron_f5145_0(List<GetRequest> getRequests) throws IOException
{    List<Get> gets = new ArrayList<>();    for (GetRequest getRequest : getRequests) {        gets.add(buildGet(getRequest));    }    Result[] results = getTableInterface().get(gets);    List<Document> allLatest = new ArrayList<>();    for (Result result : results) {        Document d = getDocumentFromResult(result);        if (d != null) {            allLatest.add(d);        }    }    return allLatest;}
private Document metron_f5146_0(Result result) throws IOException
{    NavigableMap<byte[], byte[]> columns = result.getFamilyMap(cf);    if (columns == null || columns.size() == 0) {        return null;    }    Map.Entry<byte[], byte[]> entry = columns.lastEntry();    Long ts = Bytes.toLong(entry.getKey());    if (entry.getValue() != null) {        Map<String, Object> json = JSONUtils.INSTANCE.load(new String(entry.getValue(), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);                @SuppressWarnings("unchecked")        List<Map<String, Object>> commentsMap = (List<Map<String, Object>>) json.get(COMMENTS_FIELD);        try {            if (commentsMap != null) {                List<AlertComment> comments = new ArrayList<>();                for (Map<String, Object> commentMap : commentsMap) {                    comments.add(new AlertComment(commentMap));                }                if (comments.size() > 0) {                    json.put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));                }            }            Key k = Key.fromBytes(result.getRow());            return new Document(json, k.getGuid(), k.getSensorType(), ts);        } catch (IOException e) {            throw new RuntimeException("Unable to convert row key to a document", e);        }    } else {        return null;    }}
public synchronized Document metron_f5147_0(Document update, Optional<String> index) throws IOException
{    Put put = buildPut(update);    getTableInterface().put(put);    return update;}
public Map<Document, Optional<String>> metron_f5148_0(Map<Document, Optional<String>> updates) throws IOException
{    List<Put> puts = new ArrayList<>();    for (Map.Entry<Document, Optional<String>> updateEntry : updates.entrySet()) {        Document update = updateEntry.getKey();        Put put = buildPut(update);        puts.add(put);    }    getTableInterface().put(puts);    return updates;}
protected Get metron_f5149_0(GetRequest getRequest) throws IOException
{    Key k = new Key(getRequest.getGuid(), getRequest.getSensorType());    Get get = new Get(Key.toBytes(k));    get.addFamily(cf);    return get;}
protected Put metron_f5150_0(Document update) throws IOException
{    Key k = new Key(update.getGuid(), update.getSensorType());    Put put = new Put(Key.toBytes(k));    long ts = update.getTimestamp() == null || update.getTimestamp() == 0 ? System.currentTimeMillis() : update.getTimestamp();    byte[] columnQualifier = Bytes.toBytes(ts);    byte[] doc = JSONUtils.INSTANCE.toJSONPretty(update.getDocument());    put.addColumn(cf, columnQualifier, doc);    return put;}
public Map<String, FieldType> metron_f5151_0(List<String> indices) throws IOException
{    return null;}
public Document metron_f5152_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = getLatest(request.getGuid(), request.getSensorType());    return addCommentToAlert(request, latest);}
public Document metron_f5153_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    if (latest == null || latest.getDocument() == null) {        throw new IOException(String.format("Unable to add comment. Document with guid %s cannot be found.", request.getGuid()));    }    List<Map<String, Object>> comments = (List<Map<String, Object>>) latest.getDocument().getOrDefault(COMMENTS_FIELD, new ArrayList<>());    List<Map<String, Object>> originalComments = new ArrayList<>(comments);        List<Map<String, Object>> commentsMap = new ArrayList<>();    for (Map<String, Object> comment : originalComments) {        commentsMap.add(new AlertComment(comment).asMap());    }    commentsMap.add(new AlertComment(request.getComment(), request.getUsername(), request.getTimestamp()).asMap());    Document newVersion = new Document(latest);    newVersion.getDocument().put(COMMENTS_FIELD, commentsMap);    return update(newVersion, Optional.empty());}
public Document metron_f5154_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = getLatest(request.getGuid(), request.getSensorType());    return removeCommentFromAlert(request, latest);}
public Document metron_f5155_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    if (latest == null || latest.getDocument() == null) {        throw new IOException(String.format("Unable to remove comment. Document with guid %s cannot be found.", request.getGuid()));    }    List<Map<String, Object>> commentMap = (List<Map<String, Object>>) latest.getDocument().get(COMMENTS_FIELD);        if (commentMap == null) {        throw new IOException(String.format("Unable to remove comment. Document with guid %s has no comments.", request.getGuid()));    }    List<Map<String, Object>> originalComments = new ArrayList<>(commentMap);    List<AlertComment> comments = new ArrayList<>();    for (Map<String, Object> commentStr : originalComments) {        comments.add(new AlertComment(commentStr));    }    comments.remove(new AlertComment(request.getComment(), request.getUsername(), request.getTimestamp()));    Document newVersion = new Document(latest);    if (comments.size() > 0) {        List<Map<String, Object>> commentsAsMap = comments.stream().map(AlertComment::asMap).collect(Collectors.toList());        newVersion.getDocument().put(COMMENTS_FIELD, commentsAsMap);        update(newVersion, Optional.empty());    } else {        newVersion.getDocument().remove(COMMENTS_FIELD);    }    return update(newVersion, Optional.empty());}
public static List<IndexDao> metron_f5156_0(String daoImpls, AccessConfig config) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException
{    List<IndexDao> ret = new ArrayList<>();    for (String daoImpl : Splitter.on(",").split(daoImpls)) {        Class<? extends IndexDao> clazz = (Class<? extends IndexDao>) Class.forName(daoImpl);        IndexDao instance = clazz.getConstructor().newInstance();        instance.init(config);        ret.add(instance);    }    return ret;}
public static IndexDao metron_f5157_0(Iterable<IndexDao> daos) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException
{    return combine(daos, x -> x);}
public static IndexDao metron_f5158_0(Iterable<IndexDao> daos, Function<IndexDao, IndexDao> daoTransformation) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException
{    int numDaos = Iterables.size(daos);    if (numDaos == 0) {        throw new IllegalArgumentException("Trying to combine 0 dao's into a DAO is not a supported configuration.");    }    if (numDaos == 1) {        return daoTransformation.apply(Iterables.getFirst(daos, null));    }    return new MultiIndexDao(daos, daoTransformation);}
 String metron_f5159_0()
{    return MetaAlertConstants.THREAT_FIELD_DEFAULT;}
 String metron_f5160_0()
{    return MetaAlertConstants.THREAT_SORT_DEFAULT;}
public UpdateDao metron_f5161_0()
{    return updateDao;}
public MetaAlertRetrieveLatestDao metron_f5162_0()
{    return retrieveLatestDao;}
public MetaAlertConfig metron_f5163_0()
{    return config;}
public Document metron_f5164_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    if (isPatchAllowed(request)) {        return updateDao.patch(retrieveLatestDao, request, timestamp);    } else {        throw new IllegalArgumentException("Meta alert patches are not allowed for /alert or /status paths.  " + "Please use the add/remove alert or update status functions instead.");    }}
public Map<Document, Optional<String>> metron_f5165_0(Map<Document, Optional<String>> updates)
{    throw new UnsupportedOperationException("Meta alerts do not allow for bulk updates");}
protected Document metron_f5166_0(Iterable<Document> alerts, List<String> groups, String alertField)
{        Map<String, Object> metaSource = new HashMap<>();    List<Map<String, Object>> alertList = new ArrayList<>();    for (Document alert : alerts) {        alertList.add(alert.getDocument());    }    metaSource.put(alertField, alertList);        String guid = UUID.randomUUID().toString();    metaSource.put(GUID, guid);    metaSource.put(Constants.Fields.TIMESTAMP.getName(), System.currentTimeMillis());    metaSource.put(MetaAlertConstants.GROUPS_FIELD, groups);    metaSource.put(MetaAlertConstants.STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());    return new Document(metaSource, guid, MetaAlertConstants.METAALERT_TYPE, System.currentTimeMillis());}
protected Map<Document, Optional<String>> metron_f5167_0(Document metaAlert, Iterable<Document> alerts) throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<>();    List<String> alertGuids = new ArrayList<>();    for (Document alert : alerts) {        alertGuids.add(alert.getGuid());    }    List<Map<String, Object>> alertsBefore = new ArrayList<>();    Map<String, Object> documentBefore = metaAlert.getDocument();    if (documentBefore.containsKey(MetaAlertConstants.ALERT_FIELD)) {        alertsBefore.addAll((List<Map<String, Object>>) documentBefore.get(MetaAlertConstants.ALERT_FIELD));    }    boolean metaAlertUpdated = removeAlertsFromMetaAlert(metaAlert, alertGuids);    if (metaAlertUpdated) {        List<Map<String, Object>> alertsAfter = (List<Map<String, Object>>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD);        if (alertsAfter.size() < alertsBefore.size() && alertsAfter.size() == 0) {            throw new IllegalStateException("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.");        }        MetaScores.calculateMetaScores(metaAlert, config.getThreatTriageField(), config.getThreatSort());        updates.put(metaAlert, Optional.of(config.getMetaAlertIndex()));        for (Document alert : alerts) {            if (removeMetaAlertFromAlert(metaAlert.getGuid(), alert)) {                updates.put(alert, Optional.empty());            }        }    }    return updates;}
public Document metron_f5168_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    Document metaAlert = retrieveLatestDao.getLatest(metaAlertGuid, MetaAlertConstants.METAALERT_TYPE);    if (metaAlert == null) {        throw new IOException(String.format("Unable to add alerts to meta alert.  Meta alert with guid %s cannot be found.", metaAlertGuid));    }    if (MetaAlertStatus.ACTIVE.getStatusString().equals(metaAlert.getDocument().get(MetaAlertConstants.STATUS_FIELD))) {        Iterable<Document> alerts = retrieveLatestDao.getAllLatest(alertRequests);        Set<String> missingAlerts = getMissingAlerts(alertRequests, alerts);        if (!missingAlerts.isEmpty()) {            throw new IOException(String.format("Unable to add alerts to meta alert.  Alert with guid %s cannot be found.", missingAlerts.iterator().next()));        }        Map<Document, Optional<String>> updates = buildAddAlertToMetaAlertUpdates(metaAlert, alerts);        update(updates);        return metaAlert;    } else {        throw new IllegalStateException("Adding alerts to an INACTIVE meta alert is not allowed");    }}
public Document metron_f5169_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException, IllegalStateException
{    Document metaAlert = retrieveLatestDao.getLatest(metaAlertGuid, MetaAlertConstants.METAALERT_TYPE);    if (metaAlert == null) {        throw new IOException(String.format("Unable to remove alerts from meta alert.  Meta alert with guid %s cannot be found.", metaAlertGuid));    }    if (MetaAlertStatus.ACTIVE.getStatusString().equals(metaAlert.getDocument().get(MetaAlertConstants.STATUS_FIELD))) {        Iterable<Document> alerts = retrieveLatestDao.getAllLatest(alertRequests);        Set<String> missingAlerts = getMissingAlerts(alertRequests, alerts);        if (!missingAlerts.isEmpty()) {            throw new IOException(String.format("Unable to remove alerts from meta alert.  Alert with guid %s cannot be found.", missingAlerts.iterator().next()));        }        Map<Document, Optional<String>> updates = buildRemoveAlertsFromMetaAlert(metaAlert, alerts);        update(updates);        return metaAlert;    } else {        throw new IllegalStateException("Removing alerts from an INACTIVE meta alert is not allowed");    }}
protected boolean metron_f5170_0(Document metaAlert, Collection<String> alertGuids)
{        if (!metaAlert.getDocument().containsKey(MetaAlertConstants.ALERT_FIELD) || alertGuids.size() == 0) {        return false;    }    @SuppressWarnings("unchecked")    List<Map<String, Object>> currentAlerts = (List<Map<String, Object>>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD);    int previousSize = currentAlerts.size();        currentAlerts.removeIf(currentAlert -> alertGuids.contains(currentAlert.get(GUID)));    return currentAlerts.size() != previousSize;}
public Document metron_f5171_0(String metaAlertGuid, MetaAlertStatus status) throws IOException
{    Document metaAlert = retrieveLatestDao.getLatest(metaAlertGuid, MetaAlertConstants.METAALERT_TYPE);    if (metaAlert == null) {        throw new IOException(String.format("Unable to update meta alert status.  Meta alert with guid %s cannot be found.", metaAlertGuid));    }    String currentStatus = (String) metaAlert.getDocument().get(MetaAlertConstants.STATUS_FIELD);    boolean metaAlertUpdated = !status.getStatusString().equals(currentStatus);    if (metaAlertUpdated) {        List<GetRequest> getRequests = new ArrayList<>();        @SuppressWarnings("unchecked")        List<Map<String, Object>> currentAlerts = (List<Map<String, Object>>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD);        currentAlerts.stream().forEach(currentAlert -> getRequests.add(new GetRequest((String) currentAlert.get(GUID), (String) currentAlert.get(config.getSourceTypeField()))));        Iterable<Document> alerts = retrieveLatestDao.getAllLatest(getRequests);        Map<Document, Optional<String>> updates = buildStatusChangeUpdates(metaAlert, alerts, status);        update(updates);    }    return metaAlert;}
protected Map<Document, Optional<String>> metron_f5172_0(Document metaAlert, Iterable<Document> alerts, MetaAlertStatus status)
{    metaAlert.getDocument().put(MetaAlertConstants.STATUS_FIELD, status.getStatusString());    Map<Document, Optional<String>> updates = new HashMap<>();    updates.put(metaAlert, Optional.of(config.getMetaAlertIndex()));    for (Document alert : alerts) {        boolean metaAlertAdded = false;        boolean metaAlertRemoved = false;                if (MetaAlertStatus.ACTIVE.equals(status)) {            metaAlertAdded = addMetaAlertToAlert(metaAlert.getGuid(), alert);        }                if (MetaAlertStatus.INACTIVE.equals(status)) {            metaAlertRemoved = removeMetaAlertFromAlert(metaAlert.getGuid(), alert);        }        if (metaAlertAdded || metaAlertRemoved) {            updates.put(alert, Optional.empty());        }    }    return updates;}
protected Map<Document, Optional<String>> metron_f5173_0(Document metaAlert, Iterable<Document> alerts)
{    Map<Document, Optional<String>> updates = new HashMap<>();    boolean metaAlertUpdated = addAlertsToMetaAlert(metaAlert, alerts);    if (metaAlertUpdated) {        MetaScores.calculateMetaScores(metaAlert, config.getThreatTriageField(), config.getThreatSort());        updates.put(metaAlert, Optional.of(config.getMetaAlertIndex()));        for (Document alert : alerts) {            if (addMetaAlertToAlert(metaAlert.getGuid(), alert)) {                updates.put(alert, Optional.empty());            }        }    }    return updates;}
protected boolean metron_f5174_0(Document metaAlert, Iterable<Document> alerts)
{    boolean alertAdded = false;    @SuppressWarnings("unchecked")    List<Map<String, Object>> currentAlerts = (List<Map<String, Object>>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD);    if (currentAlerts == null) {        currentAlerts = new ArrayList<>();        metaAlert.getDocument().put(MetaAlertConstants.ALERT_FIELD, currentAlerts);    }    Set<String> currentAlertGuids = currentAlerts.stream().map(currentAlert -> (String) currentAlert.get(GUID)).collect(Collectors.toSet());    for (Document alert : alerts) {        String alertGuid = alert.getGuid();                if (!currentAlertGuids.contains(alertGuid)) {            currentAlerts.add(alert.getDocument());            alertAdded = true;        }    }    return alertAdded;}
protected void metron_f5175_0(Map<Document, Optional<String>> updates) throws IOException
{    if (updates.size() == 1) {        Entry<Document, Optional<String>> singleUpdate = updates.entrySet().iterator().next();        updateDao.update(singleUpdate.getKey(), singleUpdate.getValue());    } else if (updates.size() > 1) {        updateDao.batchUpdate(updates);    }}
protected Set<String> metron_f5176_0(List<GetRequest> alertRequests, Iterable<Document> results) throws IOException
{    Set<String> requestGuids = alertRequests.stream().map(GetRequest::getGuid).collect(Collectors.toSet());    Set<String> resultGuids = StreamSupport.stream(results.spliterator(), false).map(Document::getGuid).collect(Collectors.toSet());    Set<String> missingGuids = new HashSet<>(requestGuids);    missingGuids.removeAll(resultGuids);    return missingGuids;}
public String metron_f5177_0()
{    return metaAlertGuid;}
public void metron_f5178_0(String metaAlertGuid)
{    this.metaAlertGuid = metaAlertGuid;}
public List<GetRequest> metron_f5179_0()
{    return alerts;}
public void metron_f5180_0(List<GetRequest> alerts)
{    this.alerts = alerts;}
public String metron_f5181_0()
{    return metaAlertIndex;}
public void metron_f5182_0(String metaAlertIndex)
{    this.metaAlertIndex = metaAlertIndex;}
public String metron_f5183_0()
{    Optional<Map<String, Object>> globalConfig = Optional.ofNullable(globalConfigSupplier.get());    if (!globalConfig.isPresent()) {        return getDefaultThreatTriageField();    }    return ConfigurationsUtils.getFieldName(globalConfig.get(), Constants.THREAT_SCORE_FIELD_PROPERTY, getDefaultThreatTriageField());}
public String metron_f5184_0()
{    return threatSort;}
public void metron_f5185_0(String threatSort)
{    this.threatSort = threatSort;}
public String metron_f5186_0()
{    Optional<Map<String, Object>> globalConfig = Optional.ofNullable(globalConfigSupplier.get());    if (!globalConfig.isPresent()) {        return getDefaultSourceTypeField();    }    return ConfigurationsUtils.getFieldName(globalConfig.get(), Constants.SENSOR_TYPE_FIELD_PROPERTY, getDefaultSourceTypeField());}
public List<GetRequest> metron_f5187_0()
{    return alerts;}
public void metron_f5188_0(List<GetRequest> alerts)
{    this.alerts = alerts;}
public List<String> metron_f5189_0()
{    return groups;}
public void metron_f5190_0(List<String> groups)
{    this.groups = groups;}
 void metron_f5191_0(IndexDao indexDao)
{    init(indexDao, Optional.empty());}
public String metron_f5192_0()
{    return statusString;}
 boolean metron_f5193_0(PatchRequest request)
{    if (request.getPatch() != null && !request.getPatch().isEmpty()) {        for (Map<String, Object> patch : request.getPatch()) {            Object pathObj = patch.get("path");            if (pathObj != null && pathObj instanceof String) {                String path = (String) pathObj;                if (STATUS_PATH.equals(path) || ALERT_PATH.equals(path)) {                    return false;                }            }        }    }    return true;}
 boolean metron_f5194_0(String metaAlertGuid, Document alert)
{    List<String> metaAlertField = new ArrayList<>();    @SuppressWarnings("unchecked")    List<String> alertField = (List<String>) alert.getDocument().get(MetaAlertConstants.METAALERT_FIELD);    if (alertField != null) {        metaAlertField.addAll(alertField);    }    boolean metaAlertRemoved = metaAlertField.remove(metaAlertGuid);    if (metaAlertRemoved) {        alert.getDocument().put(MetaAlertConstants.METAALERT_FIELD, metaAlertField);    }    return metaAlertRemoved;}
 boolean metron_f5195_0(String metaAlertGuid, Document alert)
{    List<String> metaAlertField = new ArrayList<>();    @SuppressWarnings("unchecked")    List<String> alertField = (List<String>) alert.getDocument().get(MetaAlertConstants.METAALERT_FIELD);    if (alertField != null) {        metaAlertField.addAll(alertField);    }    boolean metaAlertAdded = !metaAlertField.contains(metaAlertGuid);    if (metaAlertAdded) {        metaAlertField.add(metaAlertGuid);        alert.getDocument().put(MetaAlertConstants.METAALERT_FIELD, metaAlertField);    }    return metaAlertAdded;}
public Map<String, Object> metron_f5196_0()
{    return metaScores;}
public static void metron_f5197_0(Document metaAlert, String threatTriageField, String threatSort)
{    MetaScores metaScores = new MetaScores(new ArrayList<>());    List<Object> alertsRaw = ((List<Object>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD));    if (alertsRaw != null && !alertsRaw.isEmpty()) {        ArrayList<Double> scores = new ArrayList<>();        for (Object alertRaw : alertsRaw) {            Map<String, Object> alert = (Map<String, Object>) alertRaw;            Double scoreNum = parseThreatField(alert.get(threatTriageField));            if (scoreNum != null) {                scores.add(scoreNum);            }        }        metaScores = new MetaScores(scores);    }        metaAlert.getDocument().putAll(metaScores.getMetaScores());            Object threatScore = metaScores.getMetaScores().get(threatSort);            metaAlert.getDocument().put(threatTriageField, ConversionUtils.convert(threatScore, Float.class));}
protected static Double metron_f5198_0(Object threatRaw)
{    Double threat = null;    if (threatRaw instanceof Number) {        threat = ((Number) threatRaw).doubleValue();    } else if (threatRaw instanceof String) {        threat = Double.parseDouble((String) threatRaw);    }    return threat;}
public Document metron_f5199_0(final Document update, Optional<String> index) throws IOException
{    List<String> exceptions = indices.parallelStream().map(dao -> {        try {            dao.update(update, index);            return null;        } catch (Throwable e) {            return dao.getClass() + ": " + e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e);        }    }).filter(e -> e != null).collect(Collectors.toList());    if (exceptions.size() > 0) {        throw new IOException(Joiner.on("\n").join(exceptions));    }    return update;}
public Map<Document, Optional<String>> metron_f5200_0(Map<Document, Optional<String>> updates) throws IOException
{    List<String> exceptions = indices.parallelStream().map(dao -> {        try {            dao.batchUpdate(updates);            return null;        } catch (Throwable e) {            return dao.getClass() + ": " + e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e);        }    }).filter(e -> e != null).collect(Collectors.toList());    if (exceptions.size() > 0) {        throw new IOException(Joiner.on("\n").join(exceptions));    }    return updates;}
public Map<String, FieldType> metron_f5201_0(List<String> in) throws IOException
{    for (IndexDao dao : indices) {        Map<String, FieldType> r = dao.getColumnMetadata(in);        if (r != null) {            return r;        }    }    return null;}
public Document metron_f5202_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = getLatest(request.getGuid(), request.getSensorType());    return addCommentToAlert(request, latest);}
public Document metron_f5203_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    List<DocumentContainer> output = indices.parallelStream().map(dao -> addCommentToAlert(dao, request, latest)).collect(Collectors.toList());    return getLatestDocument(output);}
public Document metron_f5205_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = getLatest(request.getGuid(), request.getSensorType());    return removeCommentFromAlert(request, latest);}
public Document metron_f5206_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    List<DocumentContainer> output = indices.parallelStream().map(dao -> removeCommentFromAlert(dao, request, latest)).collect(Collectors.toList());    return getLatestDocument(output);}
public Optional<Document> metron_f5208_0()
{    return d;}
public Optional<Throwable> metron_f5209_0()
{    return t;}
public Optional<Iterable<Document>> metron_f5210_0()
{    return d;}
public Optional<Throwable> metron_f5211_0()
{    return t;}
public SearchResponse metron_f5212_0(SearchRequest searchRequest) throws InvalidSearchException
{    for (IndexDao dao : indices) {        SearchResponse s = dao.search(searchRequest);        if (s != null) {            return s;        }    }    return null;}
public GroupResponse metron_f5213_0(GroupRequest groupRequest) throws InvalidSearchException
{    for (IndexDao dao : indices) {        GroupResponse s = dao.group(groupRequest);        if (s != null) {            return s;        }    }    return null;}
public void metron_f5214_0(AccessConfig config)
{    for (IndexDao dao : indices) {        dao.init(config);    }}
public Document metron_f5215_0(final String guid, String sensorType) throws IOException
{    List<DocumentContainer> output = indices.parallelStream().map(dao -> getLatest(dao, guid, sensorType)).collect(Collectors.toList());    return getLatestDocument(output);}
public Iterable<Document> metron_f5217_0(List<GetRequest> getRequests) throws IOException
{    Iterable<Document> ret = null;    List<DocumentIterableContainer> output = indices.parallelStream().map(dao -> {        try {            return new DocumentIterableContainer(dao.getAllLatest(getRequests));        } catch (Throwable e) {            return new DocumentIterableContainer(e);        }    }).collect(Collectors.toList());    List<String> error = new ArrayList<>();    for (DocumentIterableContainer dc : output) {        if (dc.getException().isPresent()) {            Throwable e = dc.getException().get();            error.add(e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e));        } else {            if (dc.getDocumentIterable().isPresent()) {                Iterable<Document> documents = dc.getDocumentIterable().get();                if (ret == null) {                    ret = documents;                }            }        }    }    if (error.size() > 0) {        throw new IOException(Joiner.on("\n").join(error));    }    return ret;}
public List<IndexDao> metron_f5218_0()
{    return indices;}
private Document metron_f5219_0(List<DocumentContainer> documentContainers) throws IOException
{    Document latestDocument = null;    List<String> error = new ArrayList<>();    for (DocumentContainer dc : documentContainers) {        if (dc.getException().isPresent()) {                        Throwable e = dc.getException().get();            error.add(e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e));        } else if (dc.getDocument().isPresent()) {            Document d = dc.getDocument().get();                        if (latestDocument == null || latestDocument.getTimestamp() < d.getTimestamp()) {                latestDocument = d;            }        } else {                }    }    if (error.size() > 0) {                throw new IOException(Joiner.on("\n").join(error));    }    return latestDocument;}
 Optional<Map<String, Object>> metron_f5220_0(GetRequest request) throws IOException
{    Document ret = getLatest(request.getGuid(), request.getSensorType());    if (ret == null) {        return Optional.empty();    } else {        return Optional.ofNullable(ret.getDocument());    }}
public String metron_f5221_0()
{    return comment;}
public String metron_f5222_0()
{    return username;}
public long metron_f5223_0()
{    return timestamp;}
public String metron_f5224_0()
{    return asJSONObject().toJSONString();}
public Map<String, Object> metron_f5225_0()
{    Map<String, Object> map = new HashMap<>();    map.put(COMMENT_FIELD, comment);    map.put(COMMENT_USERNAME_FIELD, username);    map.put(COMMENT_TIMESTAMP_FIELD, timestamp);    return map;}
public JSONObject metron_f5226_0()
{    JSONObject json = new JSONObject();    json.put(COMMENT_FIELD, comment);    json.put(COMMENT_USERNAME_FIELD, username);    json.put(COMMENT_TIMESTAMP_FIELD, timestamp);    return json;}
public boolean metron_f5227_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    AlertComment that = (AlertComment) o;    if (getTimestamp() != that.getTimestamp()) {        return false;    }    if (getComment() != null ? !getComment().equals(that.getComment()) : that.getComment() != null) {        return false;    }    return getUsername() != null ? getUsername().equals(that.getUsername()) : that.getUsername() == null;}
public int metron_f5228_0()
{    int result = getComment() != null ? getComment().hashCode() : 0;    result = 31 * result + (getUsername() != null ? getUsername().hashCode() : 0);    result = 31 * result + (int) (getTimestamp() ^ (getTimestamp() >>> 32));    return result;}
public String metron_f5229_0()
{    return "AlertComment{" + "comment='" + comment + '\'' + ", username='" + username + '\'' + ", timestamp=" + timestamp + '}';}
public String metron_f5230_0()
{    return fieldType;}
public String metron_f5231_0()
{    return guid;}
public void metron_f5232_0(String guid)
{    this.guid = guid;}
public String metron_f5233_0()
{    return sensorType;}
public void metron_f5234_0(String sensorType)
{    this.sensorType = sensorType;}
public Optional<String> metron_f5235_0()
{    return index != null ? Optional.of(this.index) : Optional.empty();}
public String metron_f5236_0()
{    return index;}
public void metron_f5237_0(String index)
{    this.index = index;}
public GroupOrder metron_f5238_0()
{    return order;}
public void metron_f5239_0(GroupOrder order)
{    this.order = order;}
public String metron_f5240_0()
{    return field;}
public void metron_f5241_0(String field)
{    this.field = field;}
public SortOrder metron_f5242_0()
{    return sortOrder;}
public void metron_f5243_0(String sortOrder)
{    this.sortOrder = SortOrder.fromString(sortOrder);}
public GroupOrderType metron_f5244_0()
{    return groupOrderType;}
public void metron_f5245_0(String groupOrderType)
{    this.groupOrderType = GroupOrderType.fromString(groupOrderType);}
public String metron_f5246_0()
{    return groupOrderType;}
public static GroupOrderType metron_f5247_0(String groupOrderType)
{    return GroupOrderType.valueOf(groupOrderType.toUpperCase());}
public List<String> metron_f5248_0()
{    return indices;}
public void metron_f5249_0(List<String> indices)
{    this.indices = indices;}
public String metron_f5250_0()
{    return query;}
public void metron_f5251_0(String query)
{    this.query = query;}
public Optional<String> metron_f5252_0()
{    return scoreField == null ? Optional.empty() : Optional.of(scoreField);}
public void metron_f5253_0(String scoreField)
{    this.scoreField = scoreField;}
public List<Group> metron_f5254_0()
{    return groups;}
public void metron_f5255_0(List<Group> groups)
{    this.groups = groups;}
public String metron_f5256_0()
{    return groupedBy;}
public void metron_f5257_0(String groupedBy)
{    this.groupedBy = groupedBy;}
public List<GroupResult> metron_f5258_0()
{    return groupResults;}
public void metron_f5259_0(List<GroupResult> groupResults)
{    this.groupResults = groupResults;}
public String metron_f5260_0()
{    return key;}
public void metron_f5261_0(String key)
{    this.key = key;}
public long metron_f5262_0()
{    return total;}
public void metron_f5263_0(long total)
{    this.total = total;}
public Double metron_f5264_0()
{    return score;}
public void metron_f5265_0(Double score)
{    this.score = score;}
public String metron_f5266_0()
{    return groupedBy;}
public void metron_f5267_0(String groupedBy)
{    this.groupedBy = groupedBy;}
public List<GroupResult> metron_f5268_0()
{    return groupResults;}
public void metron_f5269_0(List<GroupResult> groups)
{    this.groupResults = groups;}
public List<String> metron_f5270_0()
{    return indices;}
public void metron_f5271_0(List<String> indices)
{    this.indices = indices;}
public String metron_f5272_0()
{    return query;}
public void metron_f5273_0(String query)
{    this.query = query;}
public int metron_f5274_0()
{    return size;}
public void metron_f5275_0(int size)
{    this.size = size;}
public int metron_f5276_0()
{    return from;}
public void metron_f5277_0(int from)
{    this.from = from;}
public List<SortField> metron_f5278_0()
{    return sort;}
public void metron_f5279_0(List<SortField> sort)
{    this.sort = sort;}
public List<String> metron_f5280_0()
{    return fields;}
public void metron_f5281_0(List<String> fields)
{    this.fields = fields;}
public List<String> metron_f5282_0()
{    return facetFields;}
public void metron_f5283_0(List<String> facetFields)
{    this.facetFields = facetFields;}
public boolean metron_f5284_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SearchRequest that = (SearchRequest) o;    return (indices != null ? indices.equals(that.indices) : that.indices == null) && (query != null ? query.equals(that.query) : that.query == null) && size == that.size && from == that.from && (sort != null ? sort.equals(that.sort) : that.sort == null) && (fields != null ? fields.equals(that.fields) : that.fields == null) && (facetFields != null ? facetFields.equals(that.facetFields) : that.facetFields == null);}
public int metron_f5285_0()
{    int result = indices != null ? indices.hashCode() : 0;    result = 31 * result + (query != null ? query.hashCode() : 0);    result = 31 * result + getSize();    result = 31 * result + getFrom();    result = 31 * result + (sort != null ? sort.hashCode() : 0);    result = 31 * result + (fields != null ? fields.hashCode() : 0);    result = 31 * result + (facetFields != null ? facetFields.hashCode() : 0);    return result;}
public long metron_f5286_0()
{    return total;}
public void metron_f5287_0(long total)
{    this.total = total;}
public List<SearchResult> metron_f5288_0()
{    return results;}
public void metron_f5289_0(List<SearchResult> results)
{    this.results = results;}
public Map<String, Map<String, Long>> metron_f5290_0()
{    return facetCounts;}
public void metron_f5291_0(Map<String, Map<String, Long>> facetCounts)
{    this.facetCounts = facetCounts;}
public boolean metron_f5292_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SearchResponse that = (SearchResponse) o;    return getTotal() == that.getTotal() && (getResults() != null ? getResults().equals(that.getResults()) : that.getResults() != null) && (getFacetCounts() != null ? getFacetCounts().equals(that.getFacetCounts()) : that.getFacetCounts() != null);}
public int metron_f5293_0()
{    int result = 31 * (int) getTotal() + (getResults() != null ? getResults().hashCode() : 0);    result = 31 * result + (getFacetCounts() != null ? getFacetCounts().hashCode() : 0);    return result;}
public String metron_f5294_0()
{    return "SearchResponse{" + "total=" + total + ", results=" + results + ", facetCounts=" + facetCounts + '}';}
public String metron_f5295_0()
{    return index;}
public void metron_f5296_0(String index)
{    this.index = index;}
public String metron_f5297_0()
{    return id;}
public void metron_f5298_0(String id)
{    this.id = id;}
public Map<String, Object> metron_f5299_0()
{    return source;}
public void metron_f5300_0(Map<String, Object> source)
{    this.source = source;}
public float metron_f5301_0()
{    return score;}
public void metron_f5302_0(float score)
{    this.score = score;}
public String metron_f5303_0()
{    return "SearchResult{" + "id='" + id + '\'' + ", source=" + source + ", score=" + score + ", index='" + index + '\'' + '}';}
public boolean metron_f5304_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SearchResult that = (SearchResult) o;    if (Float.compare(that.getScore(), getScore()) != 0) {        return false;    }    if (getId() != null ? !getId().equals(that.getId()) : that.getId() != null) {        return false;    }    if (getSource() != null ? !getSource().equals(that.getSource()) : that.getSource() != null) {        return false;    }    return getIndex() != null ? getIndex().equals(that.getIndex()) : that.getIndex() == null;}
public int metron_f5305_0()
{    int result = getId() != null ? getId().hashCode() : 0;    result = 31 * result + (getSource() != null ? getSource().hashCode() : 0);    result = 31 * result + (getScore() != +0.0f ? Float.floatToIntBits(getScore()) : 0);    result = 31 * result + (getIndex() != null ? getIndex().hashCode() : 0);    return result;}
public String metron_f5306_0()
{    return field;}
public void metron_f5307_0(String field)
{    this.field = field;}
public SortOrder metron_f5308_0()
{    return sortOrder;}
public void metron_f5309_0(String sortOrder)
{    this.sortOrder = SortOrder.fromString(sortOrder);}
public boolean metron_f5310_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SortField that = (SortField) o;    return (field != null ? field.equals(that.field) : that.field == null) && (sortOrder != null ? sortOrder.equals(that.sortOrder) : that.sortOrder == null);}
public String metron_f5311_0()
{    return sortOrder;}
public static SortOrder metron_f5312_0(String order)
{    return SortOrder.valueOf(order.toUpperCase());}
public String metron_f5313_0()
{    return guid;}
public void metron_f5314_0(String guid)
{    this.guid = guid;}
public String metron_f5315_0()
{    return sensorType;}
public void metron_f5316_0(String sensorType)
{    this.sensorType = sensorType;}
public String metron_f5317_0()
{    return comment;}
public void metron_f5318_0(String comment)
{    this.comment = comment;}
public String metron_f5319_0()
{    return username;}
public void metron_f5320_0(String username)
{    this.username = username;}
public long metron_f5321_0()
{    return timestamp;}
public void metron_f5322_0(long timestamp)
{    this.timestamp = timestamp;}
public String metron_f5323_0()
{    return "CommentAddRemoveRequest{" + "guid='" + guid + '\'' + ", sensorType='" + sensorType + '\'' + ", comment='" + comment + '\'' + ", username='" + username + '\'' + ", timestamp=" + timestamp + '}';}
public static Document metron_f5324_0(Map<String, Object> json)
{    String guid = getGUID(json);    Long timestamp = getTimestamp(json).orElse(0L);    String sensorType = getSensorType(json);    return new Document(json, guid, sensorType, timestamp);}
private static Map<String, Object> metron_f5325_0(String document) throws IOException
{    return JSONUtils.INSTANCE.load(document, JSONUtils.MAP_SUPPLIER);}
public String metron_f5326_0()
{    return sensorType;}
public void metron_f5327_0(String sensorType)
{    this.sensorType = sensorType;}
public Long metron_f5328_0()
{    return timestamp;}
public void metron_f5329_0(Long timestamp)
{    this.timestamp = timestamp != null ? timestamp : System.currentTimeMillis();}
public Map<String, Object> metron_f5330_0()
{    return document;}
public void metron_f5331_0(Map<String, Object> document)
{    this.document = document;}
public String metron_f5332_0()
{    return guid;}
public void metron_f5333_0(String guid)
{    this.guid = guid;}
public Optional<String> metron_f5334_0()
{    return Optional.ofNullable(documentID);}
public void metron_f5335_0(Optional<String> documentID)
{    this.documentID = documentID.orElse(null);}
public void metron_f5336_0(String documentID)
{    this.documentID = documentID;}
private static Optional<Long> metron_f5337_0(Map<String, Object> document)
{    Object value = document.get(TIMESTAMP.getName());    if (value != null && value instanceof Long) {        return Optional.of(Long.class.cast(value));    }    return Optional.empty();}
private static String metron_f5338_0(Map<String, Object> document)
{    Object value = document.get(GUID);    if (value != null && value instanceof String) {        return String.class.cast(value);    }    throw new IllegalStateException(String.format("Missing '%s' field", GUID));}
private static String metron_f5339_0(Map<String, Object> document)
{    Object value = document.get(SENSOR_TYPE);    if (value != null && value instanceof String) {        return String.class.cast(value);    }    value = document.get(SENSOR_TYPE.replace(".", ":"));    if (value != null && value instanceof String) {        return String.class.cast(value);    }    throw new IllegalStateException(String.format("Missing '%s' field", SENSOR_TYPE));}
public boolean metron_f5340_0(Object o)
{    if (this == o)        return true;    if (!(o instanceof Document))        return false;    Document document1 = (Document) o;    return Objects.equals(timestamp, document1.timestamp) && Objects.equals(document, document1.document) && Objects.equals(guid, document1.guid) && Objects.equals(sensorType, document1.sensorType) && Objects.equals(documentID, document1.documentID);}
public int metron_f5341_0()
{    return Objects.hash(timestamp, document, guid, sensorType, documentID);}
public String metron_f5342_0()
{    return "Document{" + "timestamp=" + timestamp + ", document=" + document + ", guid='" + guid + '\'' + ", sensorType='" + sensorType + '\'' + ", documentID=" + documentID + '}';}
public String metron_f5343_0()
{    return index;}
public void metron_f5344_0(String index)
{    this.index = index;}
public List<Map<String, Object>> metron_f5345_0()
{    return patch;}
public void metron_f5346_0(List<Map<String, Object>> patch)
{    this.patch = patch;}
public Map<String, Object> metron_f5347_0()
{    return source;}
public void metron_f5348_0(Map<String, Object> source)
{    this.source = source;}
public String metron_f5349_0()
{    return guid;}
public void metron_f5350_0(String guid)
{    this.guid = guid;}
public String metron_f5351_0()
{    return sensorType;}
public void metron_f5352_0(String sensorType)
{    this.sensorType = sensorType;}
public Map<String, Object> metron_f5353_0(List<Map<String, Object>> patches, Map<String, Object> source)
{    Map<String, Object> patchedObject = new HashMap<>(source);    for (Map<String, Object> patch : patches) {                String operation = (String) patch.get(OP);        PatchOperation patchOperation;        try {            patchOperation = PatchOperation.valueOf(operation.toUpperCase());        } catch (IllegalArgumentException e) {            throw new UnsupportedOperationException(String.format("The %s operation is not supported", operation));        }        Object value = patch.get(VALUE);        String path = (String) patch.get(PATH);                List<String> fieldNames = getFieldNames(path);        String nestedFieldName = fieldNames.get(fieldNames.size() - 1);        Map<String, Object> nestedObject = getNestedObject(fieldNames, patchedObject);                if (ADD.equals(patchOperation) || REPLACE.equals(patchOperation)) {            nestedObject.put(nestedFieldName, value);        } else if (REMOVE.equals(patchOperation)) {            nestedObject.remove(nestedFieldName);        } else if (COPY.equals(patchOperation) || MOVE.equals(patchOperation)) {                        String from = (String) patch.get(FROM);            List<String> fromFieldNames = getFieldNames(from);            String fromNestedFieldName = fromFieldNames.get(fromFieldNames.size() - 1);            Map<String, Object> fromNestedObject = getNestedObject(fromFieldNames, patchedObject);                        Object copyValue = fromNestedObject.get(fromNestedFieldName);            nestedObject.put(nestedFieldName, copyValue);            if (MOVE.equals(patchOperation)) {                                nestedObject.remove(fromNestedFieldName);            }        } else if (TEST.equals(patchOperation)) {            Object testValue = nestedObject.get(nestedFieldName);            if (!Objects.equals(value, testValue)) {                throw new PatchException(String.format("TEST operation failed: supplied value [%s] != target value [%s]", value, testValue));            }        }    }    return patchedObject;}
private List<String> metron_f5354_0(String path)
{    String[] parts = path.split(PATH_SEPARATOR);    return new ArrayList<>(Arrays.asList(parts).subList(1, parts.length));}
private Map<String, Object> metron_f5355_0(List<String> fieldNames, Map<String, Object> patchedObject)
{    Map<String, Object> nestedObject = patchedObject;    for (int i = 0; i < fieldNames.size() - 1; i++) {        Object object = nestedObject.get(fieldNames.get(i));        if (object == null || !(object instanceof Map)) {            throw new IllegalArgumentException(String.format("Invalid path: /%s", String.join(PATH_SEPARATOR, fieldNames)));        } else {            nestedObject = (Map<String, Object>) object;        }    }    return nestedObject;}
 Document metron_f5356_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    Document d = getPatchedDocument(retrieveLatestDao, request, timestamp);    return update(d, Optional.ofNullable(request.getIndex()));}
 Document metron_f5357_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> optionalTimestamp) throws OriginalNotFoundException, IOException
{    String guid = request.getGuid();    String sensorType = request.getSensorType();    String documentID = null;    Long timestamp = optionalTimestamp.orElse(System.currentTimeMillis());    Map<String, Object> originalSource = request.getSource();    if (originalSource == null) {                Document toPatch = retrieveLatestDao.getLatest(guid, sensorType);        if (toPatch != null && toPatch.getDocument() != null) {            originalSource = toPatch.getDocument();            documentID = toPatch.getDocumentID().orElse(null);        } else {            String error = format("Document does not exist, but is required; guid=%s, sensorType=%s", guid, sensorType);            throw new OriginalNotFoundException(error);        }    }    Map<String, Object> patchedSource = PatchUtils.INSTANCE.applyPatch(request.getPatch(), originalSource);    return new Document(patchedSource, guid, sensorType, timestamp, documentID);}
public static Function<String, String> metron_f5358_0(ConfigurationsCache cache, String writerName)
{    return sensorType -> {        String indexingTopic = sensorType;        IndexingConfigurations indexingConfigs = cache.get(IndexingConfigurations.class);        Map<String, Object> indexingSensorConfigs = indexingConfigs.getSensorIndexingConfig(sensorType);        if (indexingSensorConfigs != null) {            Map<String, Object> writerConfigs = (Map<String, Object>) indexingSensorConfigs.get(writerName);            if (writerConfigs != null) {                indexingTopic = (String) writerConfigs.getOrDefault(IndexingConfigurations.INDEX_CONF, indexingTopic);            }        }        return indexingTopic;    };}
public void metron_f5359_0()
{    dao = new HBaseDao();}
public UpdateDao metron_f5360_0()
{    return dao;}
public SearchResponse metron_f5361_0(SearchRequest searchRequest) throws InvalidSearchException
{    if (config.getMaxSearchResults() != null && searchRequest.getSize() > config.getMaxSearchResults()) {        throw new InvalidSearchException("Search result size must be less than " + config.getMaxSearchResults());    }    List<SearchResult> response = new ArrayList<>();    for (String index : searchRequest.getIndices()) {        String i = null;        for (String storedIdx : BACKING_STORE.keySet()) {            if (storedIdx.equals(index) || storedIdx.startsWith(index + "_")) {                i = storedIdx;            }        }        if (i == null) {            continue;        }        for (String doc : BACKING_STORE.get(i)) {            Map<String, Object> docParsed = parse(doc);            if (isMatch(searchRequest.getQuery(), docParsed)) {                SearchResult result = new SearchResult();                result.setSource(docParsed);                result.setScore((float) Math.random());                result.setId(docParsed.getOrDefault(Constants.GUID, UUID.randomUUID()).toString());                response.add(result);            }        }    }    if (searchRequest.getSort().size() != 0) {        Collections.sort(response, sorted(searchRequest.getSort()));    }    SearchResponse ret = new SearchResponse();    List<SearchResult> finalResp = new ArrayList<>();    int maxSize = config.getMaxSearchResults() == null ? searchRequest.getSize() : config.getMaxSearchResults();    for (int i = searchRequest.getFrom(); i < response.size() && finalResp.size() <= maxSize; ++i) {        finalResp.add(response.get(i));    }    ret.setTotal(response.size());    ret.setResults(finalResp);    Map<String, Map<String, Long>> facetCounts = new HashMap<>();    List<String> facetFields = searchRequest.getFacetFields();    if (facetFields != null) {        for (String facet : facetFields) {            facetCounts.put(facet, FACET_COUNTS.get(facet));        }        ret.setFacetCounts(facetCounts);    }    return ret;}
public GroupResponse metron_f5362_0(GroupRequest groupRequest) throws InvalidSearchException
{    GroupResponse groupResponse = new GroupResponse();    groupResponse.setGroupedBy(groupRequest.getGroups().get(0).getField());    groupResponse.setGroupResults(getGroupResults(groupRequest.getGroups(), 0));    return groupResponse;}
private List<GroupResult> metron_f5363_0(List<Group> groups, int index)
{    Group group = groups.get(index);    GroupResult groupResult = new GroupResult();    groupResult.setKey(group.getField() + "_value");    if (index < groups.size() - 1) {        groupResult.setGroupedBy(groups.get(index + 1).getField());        groupResult.setGroupResults(getGroupResults(groups, index + 1));    } else {        groupResult.setScore(50.0);    }    groupResult.setTotal(10);    return Collections.singletonList(groupResult);}
public int metron_f5364_0(Comparable o1, Comparable o2)
{    int result = ComparisonChain.start().compare(o1, o2, Ordering.natural().nullsLast()).result();    return order == SortOrder.ASC ? result : -1 * result;}
private static Comparator<SearchResult> metron_f5365_0(final List<SortField> fields)
{    return (o1, o2) -> {        ComparisonChain chain = ComparisonChain.start();        for (SortField field : fields) {            Comparable f1 = (Comparable) o1.getSource().get(field.getField());            Comparable f2 = (Comparable) o2.getSource().get(field.getField());            chain = chain.compare(f1, f2, new ComparableComparator(field.getSortOrder()));        }        return chain.result();    };}
private static boolean metron_f5366_0(String query, Map<String, Object> doc)
{    if (query == null) {        return false;    }    if (query.equals("*")) {        return true;    }    if (query.contains(":")) {        Iterable<String> splits = Splitter.on(":").split(query.trim());        String field = Iterables.getFirst(splits, "");        String val = Iterables.getLast(splits, "");                if (val == null) {            return false;        }                String nestingField = null;        if (field.contains("|")) {            Iterable<String> fieldSplits = Splitter.on('|').split(field);            nestingField = Iterables.getFirst(fieldSplits, null);            field = Iterables.getLast(fieldSplits, null);        }        if (nestingField == null) {                        Object o = doc.get(field);            return val.equals(o);        } else {                        @SuppressWarnings("unchecked")            List<Map<String, Object>> nestedList = (List<Map<String, Object>>) doc.get(nestingField);            if (nestedList == null) {                return false;            } else {                for (Map<String, Object> nestedEntry : nestedList) {                    if (val.equals(nestedEntry.get(field))) {                        return true;                    }                }            }        }    }    return false;}
public static Map<String, Object> metron_f5367_0(String doc)
{    try {        return JSONUtils.INSTANCE.load(doc, JSONUtils.MAP_SUPPLIER);    } catch (IOException e) {        throw new IllegalStateException(e.getMessage(), e);    }}
public void metron_f5368_0(AccessConfig config)
{    this.config = config;}
public Document metron_f5369_0(String guid, String sensorType) throws IOException
{    for (Map.Entry<String, List<String>> kv : BACKING_STORE.entrySet()) {        if (kv.getKey().startsWith(sensorType)) {            for (String doc : kv.getValue()) {                Map<String, Object> docParsed = parse(doc);                if (docParsed.getOrDefault(Constants.GUID, "").equals(guid)) {                    return new Document(doc, guid, sensorType, 0L);                }            }        }    }    return null;}
public Iterable<Document> metron_f5370_0(List<GetRequest> getRequests) throws IOException
{    List<Document> documents = new ArrayList<>();    for (Map.Entry<String, List<String>> kv : BACKING_STORE.entrySet()) {        for (String doc : kv.getValue()) {            Map<String, Object> docParsed = parse(doc);            String guid = (String) docParsed.getOrDefault(Constants.GUID, "");            for (GetRequest getRequest : getRequests) {                if (getRequest.getGuid().equals(guid)) {                    documents.add(new Document(doc, guid, getRequest.getSensorType(), 0L));                }            }        }    }    return documents;}
public Document metron_f5371_0(Document update, Optional<String> index) throws IOException
{    for (Map.Entry<String, List<String>> kv : BACKING_STORE.entrySet()) {        if (kv.getKey().startsWith(update.getSensorType())) {            for (Iterator<String> it = kv.getValue().iterator(); it.hasNext(); ) {                String doc = it.next();                Map<String, Object> docParsed = parse(doc);                if (docParsed.getOrDefault(Constants.GUID, "").equals(update.getGuid())) {                    it.remove();                }            }            kv.getValue().add(JSONUtils.INSTANCE.toJSON(update.getDocument(), true));        }    }    return update;}
public Map<Document, Optional<String>> metron_f5372_0(Map<Document, Optional<String>> updates) throws IOException
{    for (Map.Entry<Document, Optional<String>> update : updates.entrySet()) {        update(update.getKey(), update.getValue());    }    return updates;}
public Map<String, FieldType> metron_f5373_0(List<String> indices) throws IOException
{    Map<String, FieldType> indexColumnMetadata = new HashMap<>();    for (String index : indices) {        if (COLUMN_METADATA.containsKey(index)) {            Map<String, FieldType> columnMetadata = COLUMN_METADATA.get(index);            for (Entry entry : columnMetadata.entrySet()) {                String field = (String) entry.getKey();                FieldType type = (FieldType) entry.getValue();                if (indexColumnMetadata.containsKey(field)) {                    if (!type.equals(indexColumnMetadata.get(field))) {                        indexColumnMetadata.put(field, FieldType.OTHER);                    }                } else {                    indexColumnMetadata.put(field, type);                }            }        }    }    return indexColumnMetadata;}
public Document metron_f5374_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5375_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5376_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5377_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public static void metron_f5378_0(Map<String, Map<String, FieldType>> columnMetadata)
{    Map<String, Map<String, FieldType>> columnMetadataMap = new HashMap<>();    for (Map.Entry<String, Map<String, FieldType>> e : columnMetadata.entrySet()) {        columnMetadataMap.put(e.getKey(), Collections.unmodifiableMap(e.getValue()));    }    COLUMN_METADATA = columnMetadataMap;}
public static void metron_f5379_0(Map<String, Map<String, Long>> facetCounts)
{    Map<String, Map<String, Long>> facetCountsMap = new HashMap<>();    for (Map.Entry<String, Map<String, Long>> e : facetCounts.entrySet()) {        facetCountsMap.put(e.getKey(), Collections.unmodifiableMap(e.getValue()));    }    FACET_COUNTS = facetCountsMap;}
public static void metron_f5380_0(Map<String, List<String>> backingStore)
{    BACKING_STORE = backingStore;}
public static void metron_f5381_0()
{    BACKING_STORE.clear();    COLUMN_METADATA.clear();    FACET_COUNTS.clear();}
public SearchResponse metron_f5382_0(SearchRequest searchRequest) throws InvalidSearchException
{    return indexDao.search(searchRequest);}
public GroupResponse metron_f5383_0(GroupRequest groupRequest) throws InvalidSearchException
{    return indexDao.group(groupRequest);}
public void metron_f5384_0(AccessConfig config)
{}
public void metron_f5385_0(IndexDao indexDao, Optional<String> threatSort)
{    this.indexDao = indexDao;    this.metaAlertRetrieveLatestDao = new InMemoryMetaAlertRetrieveLatestDao(indexDao);    Supplier<Map<String, Object>> globalConfigSupplier = () -> new HashMap<>();    MetaAlertConfig config = new MetaAlertConfig(METAALERT_INDEX, null, globalConfigSupplier) {        @Override        protected String getDefaultThreatTriageField() {            return MetaAlertConstants.THREAT_FIELD_DEFAULT;        }        @Override        protected String getDefaultSourceTypeField() {            return SENSOR_TYPE;        }    };    this.metaAlertUpdateDao = new InMemoryMetaAlertUpdateDao(indexDao, metaAlertRetrieveLatestDao, config, -1);}
protected String metron_f5386_0()
{    return MetaAlertConstants.THREAT_FIELD_DEFAULT;}
protected String metron_f5387_0()
{    return SENSOR_TYPE;}
public Document metron_f5388_0(String guid, String sensorType) throws IOException
{    return indexDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f5389_0(List<GetRequest> getRequests) throws IOException
{    return indexDao.getAllLatest(getRequests);}
public Document metron_f5390_0(Document update, Optional<String> index) throws IOException
{    return indexDao.update(update, index);}
public Map<Document, Optional<String>> metron_f5391_0(Map<Document, Optional<String>> updates)
{    throw new UnsupportedOperationException("InMemoryMetaAlertDao can't do bulk updates");}
public Map<String, FieldType> metron_f5392_0(List<String> indices) throws IOException
{    return indexDao.getColumnMetadata(indices);}
public Document metron_f5393_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5394_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5395_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5396_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Optional<Map<String, Object>> metron_f5397_0(GetRequest request) throws IOException
{    return indexDao.getLatestResult(request);}
public Document metron_f5398_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    return indexDao.patch(retrieveLatestDao, request, timestamp);}
public SearchResponse metron_f5399_0(String guid) throws InvalidSearchException
{    SearchRequest request;    try {        String replacedQuery = metaAlertsForAlertQuery.replace("${GUID}", guid);        request = JSONUtils.INSTANCE.load(replacedQuery, SearchRequest.class);    } catch (IOException e) {        throw new InvalidSearchException("Unable to process query:", e);    }    return search(request);}
public Document metron_f5400_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    return metaAlertUpdateDao.createMetaAlert(request);}
public Document metron_f5401_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.addAlertsToMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f5402_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.removeAlertsFromMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f5403_0(String metaAlertGuid, MetaAlertStatus status) throws IOException
{    return metaAlertUpdateDao.updateMetaAlertStatus(metaAlertGuid, status);}
public static void metron_f5404_0()
{    InMemoryDao.clear();}
public Document metron_f5405_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    List<GetRequest> alertRequests = request.getAlerts();    if (alertRequests.isEmpty()) {        return null;    }        Iterable<Document> alerts = indexDao.getAllLatest(alertRequests);    Document metaAlert = buildCreateDocument(alerts, request.getGroups(), MetaAlertConstants.ALERT_FIELD);    metaAlert.getDocument().put(getConfig().getSourceTypeField(), MetaAlertConstants.METAALERT_TYPE);    return metaAlert;}
public Document metron_f5406_0(Document update, Optional<String> index) throws IOException
{    return indexDao.update(update, index);}
public Document metron_f5407_0(CommentAddRemoveRequest request) throws IOException
{    return null;}
public Document metron_f5408_0(CommentAddRemoveRequest request) throws IOException
{    return null;}
public Document metron_f5409_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return null;}
public Document metron_f5410_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return null;}
public void metron_f5411_0()
{    dao = new TestLuceneMetaAlertUpdateDao();}
protected String metron_f5412_0()
{    return THREAT_FIELD_DEFAULT.replace(':', '.');}
protected String metron_f5413_0()
{    return Constants.SENSOR_TYPE;}
public Document metron_f5414_0(String guid, String sensorType)
{    return documents.get(guid);}
public Iterable<Document> metron_f5415_0(List<GetRequest> getRequests)
{    return null;}
public Document metron_f5416_0(Document update, Optional<String> index)
{    return null;}
public Document metron_f5417_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5418_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5419_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5420_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5421_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp)
{    return null;}
public Document metron_f5422_0(MetaAlertCreateRequest request)
{    return null;}
public void metron_f5423_0()
{    dao.batchUpdate(null);}
public void metron_f5424_0() throws ParseException
{    PatchRequest pr = new PatchRequest();    Map<String, Object> patch = (JSONObject) new JSONParser().parse(alertPatchRequest);    pr.setPatch(Collections.singletonList((JSONObject) ((JSONArray) patch.get("patch")).get(0)));    assertFalse(dao.isPatchAllowed(pr));}
public void metron_f5425_0() throws ParseException
{    PatchRequest pr = new PatchRequest();    Map<String, Object> patch = (JSONObject) new JSONParser().parse(statusPatchRequest);    pr.setPatch(Collections.singletonList((JSONObject) ((JSONArray) patch.get("patch")).get(0)));    assertFalse(dao.isPatchAllowed(pr));}
public void metron_f5426_0() throws ParseException
{    PatchRequest pr = new PatchRequest();    Map<String, Object> patch = (JSONObject) new JSONParser().parse(namePatchRequest);    pr.setPatch(Collections.singletonList((JSONObject) ((JSONArray) patch.get("patch")).get(0)));    assertTrue(dao.isPatchAllowed(pr));}
public void metron_f5427_0() throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<>();    Document document = new Document(new HashMap<>(), "guid", "sensor", 0L);    updates.put(document, Optional.empty());    dao.update(updates);    verify(indexDao, times(1)).update(document, Optional.empty());}
public void metron_f5428_0() throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<>();    Document documentOne = new Document(new HashMap<>(), "guid", "sensor", 0L);    updates.put(documentOne, Optional.empty());    Document documentTwo = new Document(new HashMap<>(), "guid2", "sensor", 0L);    updates.put(documentTwo, Optional.empty());    dao.update(updates);    verify(indexDao, times(1)).batchUpdate(updates);}
public void metron_f5429_0()
{    Document metaDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metaDoc.getDocument().put(ALERT_FIELD, getRawMaps(buildChildAlerts(1, METAALERT_GUID, null)));    Map<Document, Optional<String>> actual = dao.buildAddAlertToMetaAlertUpdates(metaDoc, new ArrayList<>());    assertEquals(0, actual.size());}
public void metron_f5430_0()
{    List<Document> alerts = buildChildAlerts(1, METAALERT_GUID, null);    Document metaDoc = buildMetaAlert(alerts);    List<Document> newAlerts = buildChildAlerts(2, null, "new_");    Map<Document, Optional<String>> actual = dao.buildAddAlertToMetaAlertUpdates(metaDoc, newAlerts);    assertEquals(3, actual.size());    HashMap<String, Object> expectedExistingAlert = new HashMap<>();    expectedExistingAlert.put(Constants.GUID, "child_0");    expectedExistingAlert.put(METAALERT_FIELD, Collections.singletonList(METAALERT_GUID));    expectedExistingAlert.put(THREAT_FIELD_DEFAULT, 0.0f);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(expectedExistingAlert);    expectedAlerts.addAll(getRawMaps(newAlerts));    List<Double> scores = new ArrayList<>();    scores.add(0.0d);    scores.add(0.0d);    scores.add(0.0d);    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedMetaAlertMap.putAll(new MetaScores(scores).getMetaScores());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    expected.put(newAlerts.get(0), Optional.empty());    expected.put(newAlerts.get(1), Optional.empty());    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5431_0() throws IOException
{    List<Document> alerts = buildChildAlerts(3, METAALERT_GUID, null);    Document metaDoc = buildMetaAlert(alerts);    List<Document> deletedAlerts = new ArrayList<>();    deletedAlerts.add(alerts.get(0));    deletedAlerts.add(alerts.get(2));    Map<Document, Optional<String>> actual = dao.buildRemoveAlertsFromMetaAlert(metaDoc, deletedAlerts);    assertEquals(3, actual.size());    Map<String, Object> expectedDeletedAlert = new HashMap<>();    expectedDeletedAlert.put(Constants.GUID, "child_0");    expectedDeletedAlert.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedDeletedAlert.put(MetaAlertConstants.METAALERT_FIELD, new ArrayList<>());    Document expectedDeletedDocument = new Document(expectedDeletedAlert, "child_0", "test", 0L);    Map<String, Object> expectedDeletedAlert3 = new HashMap<>();    expectedDeletedAlert3.put(Constants.GUID, "child_2");    expectedDeletedAlert3.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedDeletedAlert3.put(MetaAlertConstants.METAALERT_FIELD, new ArrayList<>());    Document expectedDeletedDocument2 = new Document(expectedDeletedAlert3, "child_2", "test", 0L);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(alerts.get(1).getDocument());    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedMetaAlertMap.putAll(new MetaScores(Collections.singletonList(0.0d)).getMetaScores());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedDeletedDocument, Optional.empty());    expected.put(expectedDeletedDocument2, Optional.empty());    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5432_0() throws Exception
{    thrown.expect(IllegalStateException.class);    thrown.expectMessage("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.");    List<Document> alerts = buildChildAlerts(1, METAALERT_GUID, null);    Document metaDoc = buildMetaAlert(alerts);    dao.buildRemoveAlertsFromMetaAlert(metaDoc, alerts);}
public void metron_f5433_0()
{    Document empty = new Document(new HashMap<>(), "empty", METAALERT_TYPE, 0L);    boolean actual = dao.removeAlertsFromMetaAlert(empty, Collections.singletonList("child"));    assertFalse(actual);}
public void metron_f5434_0()
{    Document metaDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metaDoc.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    metaDoc.getDocument().put(ALERT_FIELD, new HashMap<String, Object>() {        {            put(Constants.GUID, "child_0");        }    });    boolean actual = dao.removeAlertsFromMetaAlert(metaDoc, new ArrayList<>());    assertFalse(actual);}
public void metron_f5435_0()
{    Document metaDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metaDoc.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    List<Map<String, Object>> alerts = new ArrayList<>();    alerts.add(new HashMap<String, Object>() {        {            put(Constants.GUID, "child_0");        }    });    metaDoc.getDocument().put(ALERT_FIELD, alerts);    boolean actual = dao.removeAlertsFromMetaAlert(metaDoc, Collections.singletonList("child_0"));    Document expected = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    expected.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    expected.getDocument().put(ALERT_FIELD, new ArrayList<>());    assertTrue(actual);    assertEquals(expected, metaDoc);}
public void metron_f5436_0()
{    List<Document> alerts = buildChildAlerts(2, METAALERT_GUID, null);    Map<String, Object> metaAlertMap = new HashMap<>();    metaAlertMap.put(ALERT_FIELD, getRawMaps(alerts));    metaAlertMap.put(Constants.GUID, METAALERT_GUID);    metaAlertMap.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());    Document metaDoc = new Document(metaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> actual = dao.buildStatusChangeUpdates(metaDoc, alerts, MetaAlertStatus.INACTIVE);    assertEquals(3, actual.size());    List<Document> expectedDeletedAlerts = buildChildAlerts(2, null, null);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(alerts.get(0).getDocument());    expectedAlerts.add(alerts.get(1).getDocument());    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(STATUS_FIELD, MetaAlertStatus.INACTIVE.getStatusString());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    expected.put(expectedDeletedAlerts.get(0), Optional.empty());    expected.put(expectedDeletedAlerts.get(1), Optional.empty());    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5437_0()
{    List<Document> alerts = buildChildAlerts(2, METAALERT_GUID, null);    Map<String, Object> metaAlertMap = new HashMap<>();    metaAlertMap.put(ALERT_FIELD, getRawMaps(alerts));    metaAlertMap.put(Constants.GUID, METAALERT_GUID);    metaAlertMap.put(STATUS_FIELD, MetaAlertStatus.INACTIVE.getStatusString());    Document metaDoc = new Document(metaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> actual = dao.buildStatusChangeUpdates(metaDoc, alerts, MetaAlertStatus.ACTIVE);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(alerts.get(0).getDocument());    expectedAlerts.add(alerts.get(1).getDocument());    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5438_0()
{    Document metDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metDoc.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    List<Document> alerts = buildChildAlerts(3, null, null);    metDoc.getDocument().put(ALERT_FIELD, getRawMaps(alerts));    List<String> removeGuids = new ArrayList<>();    removeGuids.add("child_0");    removeGuids.add("child_2");    removeGuids.add("child_doesn't_exist");    boolean actual = dao.removeAlertsFromMetaAlert(metDoc, removeGuids);        Document expected = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    expected.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    List<Map<String, Object>> alertsExpected = new ArrayList<>();    alertsExpected.add(new HashMap<String, Object>() {        {            put(METAALERT_FIELD, new ArrayList<>());            put(Constants.GUID, "child_1");            put(THREAT_FIELD_DEFAULT, 0.0f);        }    });    expected.getDocument().put(ALERT_FIELD, alertsExpected);    assertEquals(expected, metDoc);    assertTrue(actual);}
public void metron_f5439_0() throws IOException
{    dao.removeAlertsFromMetaAlert(INACTIVE.getStatusString(), null);}
public void metron_f5440_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    metaAlertGuids.add("metaalert2");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    Document expected = new Document(new HashMap<>(), "alert", "test", 0L);    List<String> expectedMetaAlertGuids = new ArrayList<>();    expectedMetaAlertGuids.add("metaalert2");    expected.getDocument().put(METAALERT_FIELD, expectedMetaAlertGuids);    boolean actual = dao.removeMetaAlertFromAlert("metaalert1", alert);    assertTrue(actual);    assertEquals(expected, alert);}
public void metron_f5441_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    metaAlertGuids.add("metaalert2");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    boolean actual = dao.removeMetaAlertFromAlert("metaalert3", alert);    assertFalse(actual);}
public void metron_f5442_0()
{    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, new ArrayList<>());    Document alert = new Document(alertFields, "alert", "test", 0L);    Document expected = new Document(new HashMap<>(), "alert", "test", 0L);    List<String> expectedMetaAlertGuids = new ArrayList<>();    expectedMetaAlertGuids.add("metaalert1");    expected.getDocument().put(METAALERT_FIELD, expectedMetaAlertGuids);    boolean actual = dao.addMetaAlertToAlert("metaalert1", alert);    assertTrue(actual);    assertEquals(expected, alert);}
public void metron_f5443_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    Document expected = new Document(new HashMap<>(), "alert", "test", 0L);    List<String> expectedMetaAlertGuids = new ArrayList<>();    expectedMetaAlertGuids.add("metaalert1");    expectedMetaAlertGuids.add("metaalert2");    expected.getDocument().put(METAALERT_FIELD, expectedMetaAlertGuids);    boolean actual = dao.addMetaAlertToAlert("metaalert2", alert);    assertTrue(actual);    assertEquals(expected, alert);}
public void metron_f5444_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    boolean actual = dao.addMetaAlertToAlert("metaalert1", alert);    assertFalse(actual);}
public void metron_f5445_0()
{    List<String> groups = new ArrayList<>();    groups.add("group_one");    groups.add("group_two");        Map<String, Object> alertOne = new HashMap<>();    alertOne.put(Constants.GUID, "alert_one");    alertOne.put(THREAT_FIELD_DEFAULT, 10.0d);    List<Document> alerts = new ArrayList<Document>() {        {            add(new Document(alertOne, "", "", 0L));        }    };        Document actual = dao.buildCreateDocument(alerts, groups, ALERT_FIELD);    ArrayList<Map<String, Object>> alertList = new ArrayList<>();    alertList.add(alertOne);    Map<String, Object> actualDocument = actual.getDocument();    assertEquals(MetaAlertStatus.ACTIVE.getStatusString(), actualDocument.get(STATUS_FIELD));    assertEquals(alertList, actualDocument.get(ALERT_FIELD));    assertEquals(groups, actualDocument.get(GROUPS_FIELD));        UUID.fromString((String) actualDocument.get(Constants.GUID));}
public void metron_f5446_0()
{    List<String> groups = new ArrayList<>();    groups.add("group_one");    groups.add("group_two");        Map<String, Object> alertOne = new HashMap<>();    alertOne.put(Constants.GUID, "alert_one");    alertOne.put(THREAT_FIELD_DEFAULT, 10.0d);        Map<String, Object> alertTwo = new HashMap<>();    alertTwo.put(Constants.GUID, "alert_one");    alertTwo.put(THREAT_FIELD_DEFAULT, 5.0d);    List<Document> alerts = new ArrayList<>();    alerts.add(new Document(alertOne, "", "", 0L));    alerts.add(new Document(alertTwo, "", "", 0L));        Document actual = dao.buildCreateDocument(alerts, groups, ALERT_FIELD);    ArrayList<Map<String, Object>> alertList = new ArrayList<>();    alertList.add(alertOne);    alertList.add(alertTwo);    Map<String, Object> actualDocument = actual.getDocument();    assertNotNull(actualDocument.get(Fields.TIMESTAMP.getName()));    assertEquals(alertList, actualDocument.get(ALERT_FIELD));    assertEquals(groups, actualDocument.get(GROUPS_FIELD));        UUID.fromString((String) actualDocument.get(Constants.GUID));}
public void metron_f5447_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Unable to add alerts to meta alert.  Meta alert with guid some_guid cannot be found.");    dao.addAlertsToMetaAlert("some_guid", new ArrayList<>());}
public void metron_f5448_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Unable to remove alerts from meta alert.  Meta alert with guid some_guid cannot be found.");    dao.removeAlertsFromMetaAlert("some_guid", new ArrayList<>());}
public void metron_f5449_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Unable to update meta alert status.  Meta alert with guid some_guid cannot be found.");    dao.updateMetaAlertStatus("some_guid", MetaAlertStatus.INACTIVE);}
protected boolean metron_f5450_0(Map<Document, Optional<String>> expected, Map<Document, Optional<String>> actual)
{    Entry<Document, Optional<String>> expectedMetaEntry;    Entry<Document, Optional<String>> actualMetaEntry;    expectedMetaEntry = findMetaEntry(expected);    actualMetaEntry = findMetaEntry(actual);        if (!metaAlertDocumentEquals(expectedMetaEntry.getKey(), actualMetaEntry.getKey())) {        return false;    } else {                return removeMetaEntry(expected).equals(removeMetaEntry(actual));    }}
protected Entry<Document, Optional<String>> metron_f5451_0(Map<Document, Optional<String>> expected)
{    for (Entry<Document, Optional<String>> entry : expected.entrySet()) {        if (entry.getKey().getSensorType().equals(METAALERT_TYPE)) {            return entry;        }    }    return null;}
protected Map<Document, Optional<String>> metron_f5452_0(Map<Document, Optional<String>> updates)
{    Map<Document, Optional<String>> filteredUpdates = new HashMap<>();    for (Entry<Document, Optional<String>> entry : updates.entrySet()) {        if (!(entry.getKey().getSensorType().equals(METAALERT_TYPE))) {            filteredUpdates.put(entry.getKey(), entry.getValue());        }    }    return filteredUpdates;}
private boolean metron_f5453_0(Document expected, Document actual)
{    if (!expected.getGuid().equals(actual.getGuid())) {        return false;    }    if (!expected.getSensorType().equals(actual.getSensorType())) {        return false;    }    if (!expected.getTimestamp().equals(actual.getTimestamp())) {        return false;    }        Map<String, Object> expectedDocument = expected.getDocument();    Map<String, Object> actualDocument = actual.getDocument();    if (expectedDocument.size() != actualDocument.size()) {        return false;    }    for (Entry<String, Object> entry : expectedDocument.entrySet()) {        Object value = entry.getValue();        Object actualValue = actual.getDocument().get(entry.getKey());        if (value instanceof Float) {            if (!MathUtils.equals((Float) value, (Float) actualValue, EPS)) {                return false;            }        } else if (value instanceof Double) {            if (!MathUtils.equals((Double) value, (Double) actualValue, EPS)) {                return false;            }        } else {            if (!value.equals(actual.getDocument().get(entry.getKey()))) {                return false;            }        }    }    return true;}
protected List<Document> metron_f5454_0(int num, String parent, String guidPrefix)
{    String prefix = guidPrefix != null ? guidPrefix : DEFAULT_PREFIX;    List<Document> alerts = new ArrayList<>();    for (int i = 0; i < num; i++) {        HashMap<String, Object> fields = new HashMap<>();        fields.put(Constants.GUID, prefix + i);        fields.put(THREAT_FIELD_DEFAULT, 0.0f);        if (parent != null) {            fields.put(METAALERT_FIELD, Collections.singletonList(parent));        } else {            fields.put(METAALERT_FIELD, new ArrayList<>());        }        alerts.add(new Document(fields, prefix + i, "test", 0L));    }    return alerts;}
protected List<Map<String, Object>> metron_f5455_0(List<Document> documents)
{    List<Map<String, Object>> rawMaps = new ArrayList<>();    for (Document document : documents) {        rawMaps.add(document.getDocument());    }    return rawMaps;}
protected Document metron_f5456_0(List<Document> alerts)
{    Map<String, Object> metaAlertMap = new HashMap<>();    metaAlertMap.put(ALERT_FIELD, getRawMaps(alerts));    metaAlertMap.put(Constants.GUID, METAALERT_GUID);    return new Document(metaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);}
public void metron_f5457_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(3);    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        List<Map<String, Object>> metaAlerts = buildMetaAlerts(12, MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    metaAlerts.add(buildMetaAlert("meta_active_12", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(2)))));    metaAlerts.add(buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(2)))));        addRecords(metaAlerts, getMetaAlertIndex(), METAALERT_TYPE);        List<GetRequest> createdDocs = metaAlerts.stream().map(metaAlert -> new GetRequest((String) metaAlert.get(Constants.GUID), METAALERT_TYPE)).collect(Collectors.toList());    createdDocs.addAll(alerts.stream().map(alert -> new GetRequest((String) alert.get(Constants.GUID), SENSOR_NAME)).collect(Collectors.toList()));    findCreatedDocs(createdDocs);    {                SearchResponse searchResponse0 = metaDao.getAllMetaAlertsForAlert("message_0");        List<SearchResult> searchResults0 = searchResponse0.getResults();        Assert.assertEquals(13, searchResults0.size());        Set<Map<String, Object>> resultSet = new HashSet<>();        Iterables.addAll(resultSet, Iterables.transform(searchResults0, r -> r.getSource()));        StringBuffer reason = new StringBuffer("Unable to find " + metaAlerts.get(0) + "\n");        reason.append(Joiner.on("\n").join(resultSet));        Assert.assertTrue(reason.toString(), resultSet.contains(metaAlerts.get(0)));                SearchResponse searchResponse1 = metaDao.getAllMetaAlertsForAlert("message_1");        List<SearchResult> searchResults1 = searchResponse1.getResults();        Assert.assertEquals(0, searchResults1.size());                SearchResponse searchResponse2 = metaDao.getAllMetaAlertsForAlert("message_2");        List<SearchResult> searchResults2 = searchResponse2.getResults();        Assert.assertEquals(1, searchResults2.size());        Assert.assertEquals(metaAlerts.get(12), searchResults2.get(0).getSource());    }}
public void metron_f5458_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, "meta_active_0");    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        List<Map<String, Object>> metaAlerts = buildMetaAlerts(1, MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));        addRecords(metaAlerts, getMetaAlertIndex(), METAALERT_TYPE);        List<GetRequest> createdDocs = metaAlerts.stream().map(metaAlert -> new GetRequest((String) metaAlert.get(Constants.GUID), METAALERT_TYPE)).collect(Collectors.toList());    createdDocs.addAll(alerts.stream().map(alert -> new GetRequest((String) alert.get(Constants.GUID), SENSOR_NAME)).collect(Collectors.toList()));    findCreatedDocs(createdDocs);        SortField sf = new SortField();    sf.setField(getThreatTriageField());    sf.setSortOrder(SortOrder.DESC.getSortOrder());    SearchRequest sr = new SearchRequest();    sr.setQuery("*:*");    sr.setSize(5);    sr.setIndices(Arrays.asList(getTestIndexName(), METAALERT_TYPE));    sr.setSort(Collections.singletonList(sf));    SearchResponse result = metaDao.search(sr);    List<SearchResult> results = result.getResults();    Assert.assertEquals(2, results.size());    Assert.assertEquals("meta_active_0", results.get((0)).getSource().get(Constants.GUID));    Assert.assertEquals("message_1", results.get((1)).getSource().get(Constants.GUID));        SortField sfAsc = new SortField();    sfAsc.setField(getThreatTriageField());    sfAsc.setSortOrder(SortOrder.ASC.getSortOrder());    SearchRequest srAsc = new SearchRequest();    srAsc.setQuery("*:*");    srAsc.setSize(2);    srAsc.setIndices(Arrays.asList(getTestIndexName(), METAALERT_TYPE));    srAsc.setSort(Collections.singletonList(sfAsc));    result = metaDao.search(srAsc);    results = result.getResults();    Assert.assertEquals("message_1", results.get((0)).getSource().get(Constants.GUID));    Assert.assertEquals("meta_active_0", results.get((1)).getSource().get(Constants.GUID));    Assert.assertEquals(2, results.size());}
public void metron_f5459_0() throws Exception
{    try {        metaDao.getAllMetaAlertsForAlert("");        Assert.fail("An exception should be thrown for empty guid");    } catch (InvalidSearchException ise) {        Assert.assertEquals("Guid cannot be empty", ise.getMessage());    }}
public void metron_f5460_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(3);    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME)));    {        MetaAlertCreateRequest metaAlertCreateRequest = new MetaAlertCreateRequest() {            {                setAlerts(new ArrayList<GetRequest>() {                    {                        add(new GetRequest("message_1", SENSOR_NAME));                        add(new GetRequest("message_2", SENSOR_NAME, getTestIndexFullName()));                    }                });                setGroups(Collections.singletonList("group"));            }        };        Document actualMetaAlert = metaDao.createMetaAlert(metaAlertCreateRequest);                Map<String, Object> expectedMetaAlert = new HashMap<>();        expectedMetaAlert.put(Constants.GUID, actualMetaAlert.getGuid());        expectedMetaAlert.put(getSourceTypeField(), METAALERT_TYPE);        expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());                @SuppressWarnings("unchecked")        List<Map<String, Object>> metaAlertAlerts = new ArrayList<>();                Map<String, Object> expectedAlert1 = alerts.get(1);        expectedAlert1.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));        metaAlertAlerts.add(expectedAlert1);        Map<String, Object> expectedAlert2 = alerts.get(2);        expectedAlert2.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));        metaAlertAlerts.add(expectedAlert2);        expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);                expectedMetaAlert.put("average", 1.5d);        expectedMetaAlert.put("min", 1.0d);        expectedMetaAlert.put("median", 1.5d);        expectedMetaAlert.put("max", 2.0d);        expectedMetaAlert.put("count", 2);        expectedMetaAlert.put("sum", 3.0d);        expectedMetaAlert.put(getThreatTriageField(), 3.0d);        {                        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());            findCreatedDoc(actualMetaAlert.getGuid(), METAALERT_TYPE);        }        {                        Document alert = metaDao.getLatest("message_0", SENSOR_NAME);            Assert.assertEquals(4, alert.getDocument().size());            Assert.assertNull(alert.getDocument().get(METAALERT_FIELD));        }        {                        Map<String, Object> expectedAlert = new HashMap<>(alerts.get(1));            expectedAlert.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));            findUpdatedDoc(expectedAlert, "message_1", SENSOR_NAME);        }        {                        Map<String, Object> expectedAlert = new HashMap<>(alerts.get(2));            expectedAlert.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));            findUpdatedDoc(expectedAlert, "message_2", SENSOR_NAME);        }    }}
public void metron_f5461_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(4);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        @SuppressWarnings("unchecked")    List<Map<String, Object>> metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));        Map<String, Object> expectedAlert1 = alerts.get(1);    expectedAlert1.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    metaAlertAlerts.add(expectedAlert1);    Map<String, Object> expectedAlert2 = alerts.get(2);    expectedAlert2.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    metaAlertAlerts.add(expectedAlert2);    expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 1.0d);    expectedMetaAlert.put("min", 0.0d);    expectedMetaAlert.put("median", 1.0d);    expectedMetaAlert.put("max", 2.0d);    expectedMetaAlert.put("count", 3);    expectedMetaAlert.put("sum", 3.0d);    expectedMetaAlert.put(getThreatTriageField(), 3.0d);    {                Document actualMetaAlert = metaDao.addAlertsToMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                Document actualMetaAlert = metaDao.addAlertsToMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                metaAlertAlerts = (List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD);        Map<String, Object> expectedAlert3 = alerts.get(3);        expectedAlert3.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));        metaAlertAlerts.add(expectedAlert3);        expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 1.5d);        expectedMetaAlert.put("min", 0.0d);        expectedMetaAlert.put("median", 1.5d);        expectedMetaAlert.put("max", 3.0d);        expectedMetaAlert.put("count", 4);        expectedMetaAlert.put("sum", 6.0d);        expectedMetaAlert.put(getThreatTriageField(), 6.0d);        Document actualMetaAlert = metaDao.addAlertsToMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }}
public void metron_f5462_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(4);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    alerts.get(2).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    alerts.get(3).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1), alerts.get(2), alerts.get(3))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        List<Map<String, Object>> metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));    metaAlertAlerts.remove(0);    metaAlertAlerts.remove(0);    expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 2.5d);    expectedMetaAlert.put("min", 2.0d);    expectedMetaAlert.put("median", 2.5d);    expectedMetaAlert.put("max", 3.0d);    expectedMetaAlert.put("count", 2);    expectedMetaAlert.put("sum", 5.0d);    expectedMetaAlert.put(getThreatTriageField(), 5.0d);    {                Document actualMetaAlert = metaDao.removeAlertsFromMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                Document actualMetaAlert = metaDao.removeAlertsFromMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));        metaAlertAlerts.remove(0);        expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 3.0d);        expectedMetaAlert.put("min", 3.0d);        expectedMetaAlert.put("median", 3.0d);        expectedMetaAlert.put("max", 3.0d);        expectedMetaAlert.put("count", 1);        expectedMetaAlert.put("sum", 3.0d);        expectedMetaAlert.put(getThreatTriageField(), 3.0d);        Document actualMetaAlert = metaDao.removeAlertsFromMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));        metaAlertAlerts.remove(0);        if (isEmptyMetaAlertList()) {            expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        } else {            expectedMetaAlert.remove(ALERT_FIELD);        }        expectedMetaAlert.put("average", 0.0d);        expectedMetaAlert.put("count", 0);        expectedMetaAlert.put("sum", 0.0d);        expectedMetaAlert.put(getThreatTriageField(), 0.0d);                if (isFiniteDoubleOnly()) {            expectedMetaAlert.put("min", String.valueOf(Double.POSITIVE_INFINITY));            expectedMetaAlert.put("median", String.valueOf(Double.NaN));            expectedMetaAlert.put("max", String.valueOf(Double.NEGATIVE_INFINITY));        } else {            expectedMetaAlert.put("min", Double.POSITIVE_INFINITY);            expectedMetaAlert.put("median", Double.NaN);            expectedMetaAlert.put("max", Double.NEGATIVE_INFINITY);        }                try {            metaDao.removeAlertsFromMetaAlert("meta_alert", Collections.singletonList(new GetRequest("message_3", SENSOR_NAME)));            Assert.fail("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.");        } catch (IllegalStateException ise) {            Assert.assertEquals("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.", ise.getMessage());        }    }}
public void metron_f5463_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.INACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));    {                try {            metaDao.addAlertsToMetaAlert("meta_alert", Collections.singletonList(new GetRequest("message_1", SENSOR_NAME)));            Assert.fail("Adding alerts to an inactive meta alert should throw an exception");        } catch (IllegalStateException ise) {            Assert.assertEquals("Adding alerts to an INACTIVE meta alert is not allowed", ise.getMessage());        }    }    {                try {            metaDao.removeAlertsFromMetaAlert("meta_alert", Collections.singletonList(new GetRequest("message_0", SENSOR_NAME)));            Assert.fail("Removing alerts from an inactive meta alert should throw an exception");        } catch (IllegalStateException ise) {            Assert.assertEquals("Removing alerts from an INACTIVE meta alert is not allowed", ise.getMessage());        }    }}
public void metron_f5464_0() throws Exception
{    int numChildAlerts = 25;    int numUnrelatedAlerts = 25;    int totalAlerts = numChildAlerts + numUnrelatedAlerts;        List<Map<String, Object>> alerts = buildAlerts(totalAlerts);    List<Map<String, Object>> childAlerts = alerts.subList(0, numChildAlerts);    List<Map<String, Object>> unrelatedAlerts = alerts.subList(numChildAlerts, totalAlerts);    for (Map<String, Object> alert : childAlerts) {        alert.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    }    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(childAlerts));        addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);    List<GetRequest> requests = new ArrayList<>();    for (int i = 0; i < numChildAlerts; ++i) {        requests.add(new GetRequest("message_" + i, SENSOR_NAME));    }    requests.add(new GetRequest("meta_alert", METAALERT_TYPE));        findCreatedDocs(requests);    {                Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.INACTIVE.getStatusString());        Document actualMetaAlert = metaDao.updateMetaAlertStatus("meta_alert", MetaAlertStatus.INACTIVE);        Assert.assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);        for (int i = 0; i < numChildAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(childAlerts.get(i));            setEmptiedMetaAlertField(expectedAlert);            findUpdatedDoc(expectedAlert, "message_" + i, SENSOR_NAME);        }                for (int i = 0; i < numUnrelatedAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(unrelatedAlerts.get(i));                        findUpdatedDoc(expectedAlert, "message_" + (i + numChildAlerts), SENSOR_NAME);        }    }    {                Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());        Document actualMetaAlert = metaDao.updateMetaAlertStatus("meta_alert", MetaAlertStatus.ACTIVE);        Assert.assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);        for (int i = 0; i < numChildAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(alerts.get(i));            expectedAlert.put("metaalerts", Collections.singletonList("meta_alert"));            findUpdatedDoc(expectedAlert, "message_" + i, SENSOR_NAME);        }                for (int i = 0; i < numUnrelatedAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(unrelatedAlerts.get(i));                        findUpdatedDoc(expectedAlert, "message_" + (i + numChildAlerts), SENSOR_NAME);        }    }    {        {                        Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);            expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());            Document actualMetaAlert = metaDao.updateMetaAlertStatus("meta_alert", MetaAlertStatus.ACTIVE);            Assert.assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());            findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);            for (int i = 0; i < numChildAlerts; ++i) {                Map<String, Object> expectedAlert = new HashMap<>(alerts.get(i));                expectedAlert.put("metaalerts", Collections.singletonList("meta_alert"));                findUpdatedDoc(expectedAlert, "message_" + i, SENSOR_NAME);            }                        for (int i = 0; i < numUnrelatedAlerts; ++i) {                Map<String, Object> expectedAlert = new HashMap<>(unrelatedAlerts.get(i));                                findUpdatedDoc(expectedAlert, "message_" + (i + numChildAlerts), SENSOR_NAME);            }        }    }}
public void metron_f5465_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(1);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(0).put("ip_src_addr", "192.168.1.1");    alerts.get(0).put("ip_src_port", 8010);        Map<String, Object> activeMetaAlert = buildMetaAlert("meta_active", MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    Map<String, Object> inactiveMetaAlert = buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.empty());        addRecords(Arrays.asList(activeMetaAlert, inactiveMetaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("meta_active", METAALERT_TYPE), new GetRequest("meta_inactive", METAALERT_TYPE)));    SearchResponse searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("*:*");            setIndices(Collections.singletonList(METAALERT_TYPE));            setFrom(0);            setSize(5);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());    Assert.assertEquals(MetaAlertStatus.ACTIVE.getStatusString(), searchResponse.getResults().get(0).getSource().get(STATUS_FIELD));}
public void metron_f5466_0() throws Exception
{    final String guid = "meta_alert";    setupTypings();        SortField sortField = new SortField();    sortField.setField("alert_status");    sortField.setSortOrder("asc");        Assert.assertEquals(0, searchForSortedMetaAlerts(sortField).getTotal());        createMetaAlert(guid);    Assert.assertEquals(1, searchForSortedMetaAlerts(sortField).getTotal());        escalateMetaAlert(guid);    Assert.assertEquals(1, searchForSortedMetaAlerts(sortField).getTotal());}
private Map<String, Object> metron_f5467_0(String guid) throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList(guid));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList(guid));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert(guid, MetaAlertStatus.ACTIVE, Optional.of(alerts));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));    return metaAlert;}
private void metron_f5468_0(String guid) throws Exception
{        Map<String, Object> patch = new HashMap<>();    patch.put("op", "add");    patch.put("path", "/alert_status");    patch.put("value", "escalate");        PatchRequest patchRequest = new PatchRequest();    patchRequest.setGuid(guid);    patchRequest.setIndex(getMetaAlertIndex());    patchRequest.setSensorType(METAALERT_TYPE);    patchRequest.setPatch(Collections.singletonList(patch));    metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        assertEventually(() -> {        Document updated = metaDao.getLatest(guid, METAALERT_TYPE);        Assert.assertEquals("escalate", updated.getDocument().get("alert_status"));    });}
private SearchResponse metron_f5469_0(SortField sortBy) throws InvalidSearchException
{    SearchRequest searchRequest = new SearchRequest();    searchRequest.setFrom(0);    searchRequest.setSize(10);    searchRequest.setIndices(Arrays.asList(getTestIndexName(), METAALERT_TYPE));    searchRequest.setQuery("*:*");    searchRequest.setSort(Collections.singletonList(sortBy));    return metaDao.search(searchRequest);}
public void metron_f5470_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(0).put("ip_src_addr", "192.168.1.1");    alerts.get(0).put("score", 1);    alerts.get(1).put("ip_src_addr", "192.168.1.1");    alerts.get(1).put("score", 10);    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        setupTypings();            findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        Group searchGroup = new Group();    searchGroup.setField("ip_src_addr");    List<Group> groupList = new ArrayList<>();    groupList.add(searchGroup);    GroupResponse groupResponse = metaDao.group(new GroupRequest() {        {            setQuery("ip_src_addr:192.168.1.1");            setIndices(queryIndices);            setScoreField("score");            setGroups(groupList);        }    });        GroupResult result = groupResponse.getGroupResults().get(0);    Assert.assertEquals(1, result.getTotal());    Assert.assertEquals("192.168.1.1", result.getKey());        Assert.assertEquals(10.0d, result.getScore(), 0.0d);}
public void metron_f5471_0() throws Exception
{    final String expectedFieldValue = "metron";    {                List<Map<String, Object>> alerts = buildAlerts(2);        alerts.get(0).put(METAALERT_FIELD, Arrays.asList("meta_active", "meta_inactive"));        addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);                Map<String, Object> activeMetaAlert = buildMetaAlert("meta_active", MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));                Map<String, Object> inactiveMetaAlert = buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));                addRecords(Arrays.asList(activeMetaAlert, inactiveMetaAlert), getMetaAlertIndex(), METAALERT_TYPE);                findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_active", METAALERT_TYPE), new GetRequest("meta_inactive", METAALERT_TYPE)));    }    {                Document message0 = metaDao.getLatest("message_0", SENSOR_NAME);        message0.getDocument().put(NEW_FIELD, expectedFieldValue);        message0.getDocument().put(THREAT_FIELD_DEFAULT, 10.0d);        metaDao.update(message0, Optional.of(getTestIndexFullName()));    }        assertEventually(() -> {        Document message0 = metaDao.getLatest("message_0", SENSOR_NAME);        Assert.assertNotNull(message0);        Assert.assertEquals(expectedFieldValue, message0.getDocument().get(NEW_FIELD));    });        assertEventually(() -> {        Document active = metaDao.getLatest("meta_active", METAALERT_TYPE);        Object value = active.getDocument().get(ALERT_FIELD);        List<Map<String, Object>> children = List.class.cast(value);        Assert.assertNotNull(children);        Assert.assertEquals(1, children.size());        Assert.assertEquals(expectedFieldValue, children.get(0).get(NEW_FIELD));    });        assertEventually(() -> {        Document inactive = metaDao.getLatest("meta_inactive", METAALERT_TYPE);        Object value = inactive.getDocument().get(ALERT_FIELD);        List<Map<String, Object>> children = List.class.cast(value);        Assert.assertNotNull(children);        Assert.assertEquals(1, children.size());        Assert.assertFalse(children.get(0).containsKey(NEW_FIELD));    });}
public void metron_f5472_0() throws Exception
{    Document metaAlert = new Document(new HashMap<>(), "meta_alert", METAALERT_TYPE, 0L);    try {                metaDao.update(metaAlert, Optional.empty());        Assert.fail("Direct meta alert update should throw an exception");    } catch (UnsupportedOperationException uoe) {        Assert.assertEquals("Meta alerts cannot be directly updated", uoe.getMessage());    }}
public void metron_f5473_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        setupTypings();        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));        addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        String namePatch = namePatchRequest.replace(META_INDEX_FLAG, getMetaAlertIndex());    PatchRequest patchRequest = JSONUtils.INSTANCE.load(namePatch, PatchRequest.class);    metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        assertEventually(() -> {        Document updated = metaDao.getLatest("meta_alert", METAALERT_TYPE);        Assert.assertEquals("New Meta Alert", updated.getDocument().get(NAME_FIELD));    });}
public void metron_f5474_0() throws Exception
{    setupTypings();        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        try {        String alertPatch = alertPatchRequest.replace(META_INDEX_FLAG, getMetaAlertIndex());        PatchRequest patchRequest = JSONUtils.INSTANCE.load(alertPatch, PatchRequest.class);        metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        Assert.fail("A patch on the alert field should throw an exception");    } catch (IllegalArgumentException iae) {        Assert.assertEquals("Meta alert patches are not allowed for /alert or /status paths.  " + "Please use the add/remove alert or update status functions instead.", iae.getMessage());    }        assertEventually(() -> {        Document updated = metaDao.getLatest("meta_alert", METAALERT_TYPE);        Assert.assertEquals(metaAlert.get(ALERT_FIELD), updated.getDocument().get(ALERT_FIELD));    });}
public void metron_f5475_0() throws Exception
{    setupTypings();        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        try {        String statusPatch = statusPatchRequest.replace(META_INDEX_FLAG, getMetaAlertIndex());        PatchRequest patchRequest = JSONUtils.INSTANCE.load(statusPatch, PatchRequest.class);        metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        Assert.fail("A patch on the status field should throw an exception");    } catch (IllegalArgumentException iae) {        Assert.assertEquals("Meta alert patches are not allowed for /alert or /status paths.  " + "Please use the add/remove alert or update status functions instead.", iae.getMessage());    }        assertEventually(() -> {        Document updated = metaDao.getLatest("meta_alert", METAALERT_TYPE);        Assert.assertEquals(metaAlert.get(STATUS_FIELD), updated.getDocument().get(STATUS_FIELD));    });}
protected void metron_f5476_0(Map<String, Object> message0, String guid, String sensorType) throws InterruptedException, IOException, OriginalNotFoundException
{    commit();    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Document doc = metaDao.getLatest(guid, sensorType);                convertAlertsFieldToSet(doc.getDocument());        convertAlertsFieldToSet(message0);        if (doc.getDocument() != null && message0.equals(doc.getDocument())) {            convertAlertsFieldToList(doc.getDocument());            convertAlertsFieldToList(message0);            return;        }    }    throw new OriginalNotFoundException("Count not find " + guid + " after " + MAX_RETRIES + " tries");}
protected void metron_f5477_0(Map<String, Object> document)
{    if (document.get(ALERT_FIELD) instanceof List) {        @SuppressWarnings("unchecked")        List<Map<String, Object>> message0AlertField = (List<Map<String, Object>>) document.get(ALERT_FIELD);        Set<Map<String, Object>> message0AlertSet = new HashSet<>(message0AlertField);        document.put(ALERT_FIELD, message0AlertSet);    }}
protected void metron_f5478_0(Map<String, Object> document)
{    if (document.get(ALERT_FIELD) instanceof Set) {        @SuppressWarnings("unchecked")        Set<Map<String, Object>> message0AlertField = (Set<Map<String, Object>>) document.get(ALERT_FIELD);        List<Map<String, Object>> message0AlertList = new ArrayList<>(message0AlertField);        message0AlertList.sort(Comparator.comparing(o -> ((String) o.get(Constants.GUID))));        document.put(ALERT_FIELD, message0AlertList);    }}
protected boolean metron_f5479_0(String guid, String sensorType) throws InterruptedException, IOException, OriginalNotFoundException
{    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Document doc = metaDao.getLatest(guid, sensorType);        if (doc != null) {            return true;        }    }    throw new OriginalNotFoundException("Count not find " + guid + " after " + MAX_RETRIES + "tries");}
protected boolean metron_f5480_0(List<GetRequest> getRequests) throws InterruptedException, IOException, OriginalNotFoundException
{    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Iterable<Document> docs = metaDao.getAllLatest(getRequests);        if (docs != null) {            int docCount = 0;            for (Document doc : docs) {                docCount++;            }            if (getRequests.size() == docCount) {                return true;            }        }    }    throw new OriginalNotFoundException("Count not find guids after " + MAX_RETRIES + "tries");}
protected void metron_f5481_0(Map<String, Object> expected, Map<String, Object> actual)
{    Assert.assertEquals(expected.get(Constants.GUID), actual.get(Constants.GUID));    Assert.assertEquals(expected.get(getSourceTypeField()), actual.get(getSourceTypeField()));    Double actualThreatTriageField = actual.get(getThreatTriageField()) instanceof Float ? ((Float) actual.get(getThreatTriageField())).doubleValue() : (Double) actual.get(getThreatTriageField());    Assert.assertEquals(expected.get(getThreatTriageField()), actualThreatTriageField);    List<Map<String, Object>> expectedAlerts = (List<Map<String, Object>>) expected.get(ALERT_FIELD);    List<Map<String, Object>> actualAlerts = (List<Map<String, Object>>) actual.get(ALERT_FIELD);    expectedAlerts.sort(Comparator.comparing(o -> ((String) o.get(Constants.GUID))));    actualAlerts.sort(Comparator.comparing(o -> ((String) o.get(Constants.GUID))));    Assert.assertEquals(expectedAlerts, actualAlerts);    Assert.assertEquals(expected.get(STATUS_FIELD), actual.get(STATUS_FIELD));    Assert.assertEquals(expected.get("average"), actual.get("average"));    Assert.assertEquals(expected.get("min"), actual.get("min"));    Assert.assertEquals(expected.get("median"), actual.get("median"));    Assert.assertEquals(expected.get("max"), actual.get("max"));    Integer actualCountField = actual.get("count") instanceof Long ? ((Long) actual.get("count")).intValue() : (Integer) actual.get("count");    Assert.assertEquals(expected.get("count"), actualCountField);    Assert.assertEquals(expected.get("sum"), actual.get("sum"));}
protected List<Map<String, Object>> metron_f5482_0(int count)
{    List<Map<String, Object>> inputData = new ArrayList<>();    for (int i = 0; i < count; ++i) {        final String guid = "message_" + i;        Map<String, Object> alerts = new HashMap<>();        alerts.put(Constants.GUID, guid);        alerts.put(getSourceTypeField(), SENSOR_NAME);        alerts.put(THREAT_FIELD_DEFAULT, (double) i);        alerts.put("timestamp", System.currentTimeMillis());        inputData.add(alerts);    }    return inputData;}
protected List<Map<String, Object>> metron_f5483_0(int count, MetaAlertStatus status, Optional<List<Map<String, Object>>> alerts)
{    List<Map<String, Object>> inputData = new ArrayList<>();    for (int i = 0; i < count; ++i) {        final String guid = "meta_" + status.getStatusString() + "_" + i;        inputData.add(buildMetaAlert(guid, status, alerts));    }    return inputData;}
protected Map<String, Object> metron_f5484_0(String guid, MetaAlertStatus status, Optional<List<Map<String, Object>>> alerts)
{    Map<String, Object> metaAlert = new HashMap<>();    metaAlert.put(Constants.GUID, guid);    metaAlert.put(getSourceTypeField(), METAALERT_TYPE);    metaAlert.put(STATUS_FIELD, status.getStatusString());    metaAlert.put(getThreatTriageField(), 100.0d);    if (alerts.isPresent()) {        List<Map<String, Object>> alertsList = alerts.get();        metaAlert.put(ALERT_FIELD, alertsList);    }    return metaAlert;}
protected String metron_f5485_0()
{    return getTestIndexName();}
protected String metron_f5486_0()
{    return THREAT_FIELD_DEFAULT;}
protected void metron_f5487_0() throws IOException
{}
public void metron_f5488_0()
{    final double delta = 0.001;    List<Map<String, Object>> alertList = new ArrayList<>();        alertList.add(Collections.singletonMap(THREAT_FIELD_DEFAULT, 10.0f));        alertList.add(Collections.singletonMap(THREAT_FIELD_DEFAULT, 20.0f));        alertList.add(Collections.singletonMap("alert3", "has no threat score"));        Map<String, Object> docMap = new HashMap<>();    docMap.put(ALERT_FIELD, alertList);    Document metaalert = new Document(docMap, "guid", METAALERT_TYPE, 0L);        MetaScores.calculateMetaScores(metaalert, THREAT_FIELD_DEFAULT, THREAT_SORT_DEFAULT);        assertEquals(20D, (Double) metaalert.getDocument().get("max"), delta);    assertEquals(10D, (Double) metaalert.getDocument().get("min"), delta);    assertEquals(15D, (Double) metaalert.getDocument().get("average"), delta);    assertEquals(2L, metaalert.getDocument().get("count"));    assertEquals(30D, (Double) metaalert.getDocument().get("sum"), delta);    assertEquals(15D, (Double) metaalert.getDocument().get("median"), delta);            Object threatScore = metaalert.getDocument().get(THREAT_FIELD_DEFAULT);    assertTrue(threatScore instanceof Float);        assertEquals(30.0F, threatScore);}
public void metron_f5489_0()
{    List<Map<String, Object>> alertList = new ArrayList<>();        alertList.add(Collections.singletonMap(MetaAlertConstants.THREAT_FIELD_DEFAULT, 10.0f));        Map<String, Object> docMap = new HashMap<>();    docMap.put(MetaAlertConstants.ALERT_FIELD, alertList);    Document metaalert = new Document(docMap, "guid", MetaAlertConstants.METAALERT_TYPE, 0L);        AccessConfig accessConfig = new AccessConfig();    accessConfig.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(Constants.THREAT_SCORE_FIELD_PROPERTY, MetaAlertConstants.THREAT_FIELD_DEFAULT);        }    });    MetaScores.calculateMetaScores(metaalert, MetaAlertConstants.THREAT_FIELD_DEFAULT, MetaAlertConstants.THREAT_SORT_DEFAULT);    assertNotNull(metaalert.getDocument().get(MetaAlertConstants.THREAT_FIELD_DEFAULT));}
public void metron_f5490_0()
{    dao1 = mock(IndexDao.class);    dao2 = mock(IndexDao.class);    multiIndexDao = new MultiIndexDao(dao1, dao2);    document1 = new Document(new HashMap<>(), "guid", "bro", 1L);    document2 = new Document(new HashMap<>(), "guid", "bro", 2L);}
public void metron_f5491_0() throws IOException
{    Document actual = multiIndexDao.update(document1, Optional.of("bro"));    Assert.assertEquals(document1, actual);        verify(dao1).update(eq(document1), eq(Optional.of("bro")));    verify(dao2).update(eq(document1), eq(Optional.of("bro")));}
public void metron_f5492_0() throws IOException
{        when(dao2.update(any(), any())).thenThrow(new IllegalStateException());    multiIndexDao.update(document1, Optional.of("bro"));}
public void metron_f5493_0() throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<Document, Optional<String>>() {        {            put(document1, Optional.of("bro"));            put(document2, Optional.of("bro"));        }    };    Map<Document, Optional<String>> actual = multiIndexDao.batchUpdate(updates);    Assert.assertEquals(updates, actual);        verify(dao1).batchUpdate(eq(updates));    verify(dao2).batchUpdate(eq(updates));}
public void metron_f5494_0() throws IOException
{        when(dao2.batchUpdate(any())).thenThrow(new IllegalStateException());    Map<Document, Optional<String>> updates = new HashMap<Document, Optional<String>>() {        {            put(document1, Optional.of("bro"));            put(document2, Optional.of("bro"));        }    };    multiIndexDao.batchUpdate(updates);}
public void metron_f5495_0() throws Exception
{    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    when(dao1.getLatest("guid", "bro")).thenReturn(document1);    when(dao2.getLatest("guid", "bro")).thenReturn(document2);    Document expected = new Document(new HashMap<>(), "guid", "bro", 2L);    Assert.assertEquals(expected, multiIndexDao.getLatest("guid", "bro"));}
public void metron_f5496_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    when(dao1.addCommentToAlert(request, latest)).thenReturn(document1);    when(dao2.addCommentToAlert(request, latest)).thenReturn(document2);    Document expected = new Document(new HashMap<>(), "guid", "bro", 2L);    Assert.assertEquals(expected, multiIndexDao.addCommentToAlert(request, latest));}
public void metron_f5497_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");        when(dao1.addCommentToAlert(request, latest)).thenReturn(document1);    when(dao2.addCommentToAlert(request, latest)).thenThrow(new IllegalStateException());    multiIndexDao.addCommentToAlert(request, latest);}
public void metron_f5498_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    when(dao1.removeCommentFromAlert(request, latest)).thenReturn(document1);    when(dao2.removeCommentFromAlert(request, latest)).thenReturn(document2);    Document expected = new Document(new HashMap<>(), "guid", "bro", 2L);    Assert.assertEquals(expected, multiIndexDao.removeCommentFromAlert(request, latest));}
public void metron_f5499_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");        when(dao1.removeCommentFromAlert(request, latest)).thenReturn(document1);    when(dao2.removeCommentFromAlert(request, latest)).thenThrow(new IllegalStateException());    multiIndexDao.removeCommentFromAlert(request, latest);}
public void metron_f5500_0() throws Exception
{    List<String> indices = Arrays.asList("bro");    Map<String, FieldType> expected = new HashMap<String, FieldType>() {        {            put("bro", FieldType.TEXT);        }    };    when(dao1.getColumnMetadata(eq(indices))).thenReturn(null);    when(dao2.getColumnMetadata(eq(indices))).thenReturn(expected);    Map<String, FieldType> actual = multiIndexDao.getColumnMetadata(indices);    Assert.assertEquals(expected, actual);}
public void metron_f5501_0() throws Exception
{    List<String> indices = Arrays.asList("bro");        when(dao1.getColumnMetadata(eq(indices))).thenReturn(null);    when(dao2.getColumnMetadata(eq(indices))).thenReturn(null);    Map<String, FieldType> actual = multiIndexDao.getColumnMetadata(indices);    Assert.assertNull(actual);}
public void metron_f5502_0() throws Exception
{    SearchRequest request = new SearchRequest();    SearchResponse expected = new SearchResponse();    when(dao1.search(eq(request))).thenReturn(null);    when(dao2.search(eq(request))).thenReturn(expected);    SearchResponse actual = multiIndexDao.search(request);    Assert.assertEquals(expected, actual);}
public void metron_f5503_0() throws Exception
{    SearchRequest request = new SearchRequest();    when(dao1.search(eq(request))).thenReturn(null);    when(dao2.search(eq(request))).thenReturn(null);    SearchResponse actual = multiIndexDao.search(request);    Assert.assertNull(actual);}
public void metron_f5504_0() throws Exception
{    GroupRequest request = new GroupRequest();    GroupResponse expected = new GroupResponse();    when(dao1.group(eq(request))).thenReturn(null);    when(dao2.group(eq(request))).thenReturn(expected);    GroupResponse actual = multiIndexDao.group(request);    Assert.assertEquals(expected, actual);}
public void metron_f5505_0() throws Exception
{    GroupRequest request = new GroupRequest();    when(dao1.group(eq(request))).thenReturn(null);    when(dao2.group(eq(request))).thenReturn(null);    GroupResponse actual = multiIndexDao.group(request);    Assert.assertNull(actual);}
public void metron_f5506_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(allQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(10, results.size());    for (int i = 0; i < 5; ++i) {        Assert.assertEquals("snort", results.get(i).getSource().get(getSourceTypeField()));        Assert.assertEquals(getIndexName("snort"), results.get(i).getIndex());        Assert.assertEquals(10 - i + "", results.get(i).getSource().get("timestamp").toString());    }    for (int i = 5; i < 10; ++i) {        Assert.assertEquals("bro", results.get(i).getSource().get(getSourceTypeField()));        Assert.assertEquals(getIndexName("bro"), results.get(i).getIndex());        Assert.assertEquals(10 - i + "", results.get(i).getSource().get("timestamp").toString());    }}
public void metron_f5507_0() throws Exception
{    GetRequest request = JSONUtils.INSTANCE.load(findOneGuidQuery, GetRequest.class);    Optional<Map<String, Object>> response = getIndexDao().getLatestResult(request);    Assert.assertTrue(response.isPresent());    Map<String, Object> doc = response.get();    Assert.assertEquals("bro", doc.get(getSourceTypeField()));    Assert.assertEquals("3", doc.get("timestamp").toString());}
public void metron_f5508_0() throws Exception
{    List<GetRequest> request = JSONUtils.INSTANCE.load(getAllLatestQuery, new JSONUtils.ReferenceSupplier<List<GetRequest>>() {    });    Map<String, Document> docs = new HashMap<>();    for (Document doc : getIndexDao().getAllLatest(request)) {        docs.put(doc.getGuid(), doc);    }    Assert.assertEquals(2, docs.size());    Assert.assertTrue(docs.keySet().contains("bro_1"));    Assert.assertTrue(docs.keySet().contains("snort_2"));    Assert.assertEquals("bro", docs.get("bro_1").getDocument().get(getSourceTypeField()));    Assert.assertEquals("snort", docs.get("snort_2").getDocument().get(getSourceTypeField()));}
public void metron_f5509_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(filterQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(3, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals("snort", results.get(0).getSource().get(getSourceTypeField()));    Assert.assertEquals("9", results.get(0).getSource().get("timestamp").toString());    Assert.assertEquals("snort", results.get(1).getSource().get(getSourceTypeField()));    Assert.assertEquals("7", results.get(1).getSource().get("timestamp").toString());    Assert.assertEquals("bro", results.get(2).getSource().get(getSourceTypeField()));    Assert.assertEquals("1", results.get(2).getSource().get("timestamp").toString());}
public void metron_f5510_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 8001; i < 8011; ++i) {        Assert.assertEquals(i, results.get(i - 8001).getSource().get("ip_src_port"));    }}
public void metron_f5511_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortAscendingWithMissingFields, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(10, results.size());        for (int i = 0; i < 8; i++) {        Assert.assertFalse(results.get(i).getSource().containsKey("threat:triage:score"));    }        Assert.assertEquals("10.0", results.get(8).getSource().get("threat:triage:score").toString());    Assert.assertEquals("20.0", results.get(9).getSource().get("threat:triage:score").toString());}
public void metron_f5512_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortDescendingWithMissingFields, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(10, results.size());        Assert.assertEquals("20.0", results.get(0).getSource().get("threat:triage:score").toString());    Assert.assertEquals("10.0", results.get(1).getSource().get("threat:triage:score").toString());        for (int i = 2; i < 10; i++) {        Assert.assertFalse(results.get(i).getSource().containsKey("threat:triage:score"));    }}
public void metron_f5513_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(paginationQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(3, results.size());    Assert.assertEquals("snort", results.get(0).getSource().get(getSourceTypeField()));    Assert.assertEquals("6", results.get(0).getSource().get("timestamp").toString());    Assert.assertEquals("bro", results.get(1).getSource().get(getSourceTypeField()));    Assert.assertEquals("5", results.get(1).getSource().get("timestamp").toString());    Assert.assertEquals("bro", results.get(2).getSource().get(getSourceTypeField()));    Assert.assertEquals("4", results.get(2).getSource().get("timestamp").toString());}
public void metron_f5514_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(indexQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(5, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 5, j = 0; i > 0; i--, j++) {        Assert.assertEquals("bro", results.get(j).getSource().get(getSourceTypeField()));        Assert.assertEquals(i + "", results.get(j).getSource().get("timestamp").toString());    }}
public void metron_f5515_0() throws Exception
{    String facetQuery = facetQueryRaw.replace("source:type", getSourceTypeField());    SearchRequest request = JSONUtils.INSTANCE.load(facetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    Map<String, Map<String, Long>> facetCounts = response.getFacetCounts();    Assert.assertEquals(8, facetCounts.size());    Map<String, Long> sourceTypeCounts = facetCounts.get(getSourceTypeField());    Assert.assertEquals(2, sourceTypeCounts.size());    Assert.assertEquals(new Long(5), sourceTypeCounts.get("bro"));    Assert.assertEquals(new Long(5), sourceTypeCounts.get("snort"));    Map<String, Long> ipSrcAddrCounts = facetCounts.get("ip_src_addr");    Assert.assertEquals(8, ipSrcAddrCounts.size());    Assert.assertEquals(new Long(3), ipSrcAddrCounts.get("192.168.1.1"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.2"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.3"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.4"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.5"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.6"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.7"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.8"));    Map<String, Long> ipSrcPortCounts = facetCounts.get("ip_src_port");    Assert.assertEquals(10, ipSrcPortCounts.size());    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8001"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8002"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8003"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8004"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8005"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8006"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8007"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8008"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8009"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8010"));    Map<String, Long> longFieldCounts = facetCounts.get("long_field");    Assert.assertEquals(2, longFieldCounts.size());    Assert.assertEquals(new Long(8), longFieldCounts.get("10000"));    Assert.assertEquals(new Long(2), longFieldCounts.get("20000"));    Map<String, Long> timestampCounts = facetCounts.get("timestamp");    Assert.assertEquals(10, timestampCounts.size());    Assert.assertEquals(new Long(1), timestampCounts.get("1"));    Assert.assertEquals(new Long(1), timestampCounts.get("2"));    Assert.assertEquals(new Long(1), timestampCounts.get("3"));    Assert.assertEquals(new Long(1), timestampCounts.get("4"));    Assert.assertEquals(new Long(1), timestampCounts.get("5"));    Assert.assertEquals(new Long(1), timestampCounts.get("6"));    Assert.assertEquals(new Long(1), timestampCounts.get("7"));    Assert.assertEquals(new Long(1), timestampCounts.get("8"));    Assert.assertEquals(new Long(1), timestampCounts.get("9"));    Assert.assertEquals(new Long(1), timestampCounts.get("10"));    Map<String, Long> latitudeCounts = facetCounts.get("latitude");    Assert.assertEquals(2, latitudeCounts.size());    List<String> latitudeKeys = new ArrayList<>(latitudeCounts.keySet());    Collections.sort(latitudeKeys);    Assert.assertEquals(48.0001, Double.parseDouble(latitudeKeys.get(0)), 0.00001);    Assert.assertEquals(48.5839, Double.parseDouble(latitudeKeys.get(1)), 0.00001);    Assert.assertEquals(new Long(2), latitudeCounts.get(latitudeKeys.get(0)));    Assert.assertEquals(new Long(8), latitudeCounts.get(latitudeKeys.get(1)));    Map<String, Long> scoreFieldCounts = facetCounts.get("score");    Assert.assertEquals(4, scoreFieldCounts.size());    List<String> scoreFieldKeys = new ArrayList<>(scoreFieldCounts.keySet());    Collections.sort(scoreFieldKeys);    Assert.assertEquals(10.0, Double.parseDouble(scoreFieldKeys.get(0)), 0.00001);    Assert.assertEquals(20.0, Double.parseDouble(scoreFieldKeys.get(1)), 0.00001);    Assert.assertEquals(50.0, Double.parseDouble(scoreFieldKeys.get(2)), 0.00001);    Assert.assertEquals(98.0, Double.parseDouble(scoreFieldKeys.get(3)), 0.00001);    Assert.assertEquals(new Long(4), scoreFieldCounts.get(scoreFieldKeys.get(0)));    Assert.assertEquals(new Long(2), scoreFieldCounts.get(scoreFieldKeys.get(1)));    Assert.assertEquals(new Long(3), scoreFieldCounts.get(scoreFieldKeys.get(2)));    Assert.assertEquals(new Long(1), scoreFieldCounts.get(scoreFieldKeys.get(3)));    Map<String, Long> isAlertCounts = facetCounts.get("is_alert");    Assert.assertEquals(2, isAlertCounts.size());    Assert.assertEquals(new Long(6), isAlertCounts.get("true"));    Assert.assertEquals(new Long(4), isAlertCounts.get("false"));}
public void metron_f5516_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(disabledFacetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertNull(response.getFacetCounts());}
public void metron_f5517_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(missingTypeFacetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    Map<String, Map<String, Long>> facetCounts = response.getFacetCounts();    Assert.assertEquals(1, facetCounts.size());    Map<String, Long> snortFieldCounts = facetCounts.get("sig_generator");    Assert.assertEquals(5, snortFieldCounts.size());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 5").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 4").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 3").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 2").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 1").longValue());    response.getFacetCounts();}
public void metron_f5518_0() throws Exception
{    thrown.expect(Exception.class);    SearchRequest request = JSONUtils.INSTANCE.load(differentTypeFacetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(3, response.getTotal());}
public void metron_f5519_0() throws Exception
{    thrown.expect(InvalidSearchException.class);    thrown.expectMessage("Search result size must be less than 100");    SearchRequest request = JSONUtils.INSTANCE.load(exceededMaxResultsQuery, SearchRequest.class);    getIndexDao().search(request);}
public void metron_f5520_0() throws Exception
{        {        Map<String, FieldType> fieldTypes = getIndexDao().getColumnMetadata(Collections.singletonList("someindex"));        Assert.assertEquals(0, fieldTypes.size());    }}
public void metron_f5521_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(noResultsFieldsQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(0, response.getTotal());}
public void metron_f5522_0() throws Exception
{    GroupRequest request = JSONUtils.INSTANCE.load(groupByIpQuery, GroupRequest.class);    GroupResponse response = getIndexDao().group(request);        Assert.assertEquals("ip_src_addr", response.getGroupedBy());        List<GroupResult> groups = response.getGroupResults();    Assert.assertEquals(8, groups.size());        Assert.assertEquals("192.168.1.8", groups.get(0).getKey());    Assert.assertEquals("192.168.1.7", groups.get(1).getKey());    Assert.assertEquals("192.168.1.6", groups.get(2).getKey());    Assert.assertEquals("192.168.1.5", groups.get(3).getKey());    Assert.assertEquals("192.168.1.4", groups.get(4).getKey());    Assert.assertEquals("192.168.1.3", groups.get(5).getKey());    Assert.assertEquals("192.168.1.2", groups.get(6).getKey());    Assert.assertEquals("192.168.1.1", groups.get(7).getKey());}
public void metron_f5523_0() throws Exception
{        GroupRequest request = JSONUtils.INSTANCE.load(groupByQuery, GroupRequest.class);    GroupResponse response = getIndexDao().group(request);    Assert.assertEquals("is_alert", response.getGroupedBy());    List<GroupResult> isAlertGroups = response.getGroupResults();    Assert.assertEquals(2, isAlertGroups.size());        GroupResult trueGroup = isAlertGroups.get(0);    Assert.assertEquals("true", trueGroup.getKey());    Assert.assertEquals(6, trueGroup.getTotal());    Assert.assertEquals("latitude", trueGroup.getGroupedBy());    Assert.assertEquals(198.0, trueGroup.getScore(), 0.00001);    List<GroupResult> trueLatitudeGroups = trueGroup.getGroupResults();    Assert.assertEquals(2, trueLatitudeGroups.size());        GroupResult trueLatitudeGroup2 = trueLatitudeGroups.get(0);    Assert.assertEquals(48.5839, Double.parseDouble(trueLatitudeGroup2.getKey()), 0.00001);    Assert.assertEquals(5, trueLatitudeGroup2.getTotal());    Assert.assertEquals(148.0, trueLatitudeGroup2.getScore(), 0.00001);        GroupResult trueLatitudeGroup1 = trueLatitudeGroups.get(1);    Assert.assertEquals(48.0001, Double.parseDouble(trueLatitudeGroup1.getKey()), 0.00001);    Assert.assertEquals(1, trueLatitudeGroup1.getTotal());    Assert.assertEquals(50.0, trueLatitudeGroup1.getScore(), 0.00001);        GroupResult falseGroup = isAlertGroups.get(1);    Assert.assertEquals("false", falseGroup.getKey());    Assert.assertEquals("latitude", falseGroup.getGroupedBy());    Assert.assertEquals(130.0, falseGroup.getScore(), 0.00001);    List<GroupResult> falseLatitudeGroups = falseGroup.getGroupResults();    Assert.assertEquals(2, falseLatitudeGroups.size());        GroupResult falseLatitudeGroup2 = falseLatitudeGroups.get(0);    Assert.assertEquals(48.5839, Double.parseDouble(falseLatitudeGroup2.getKey()), 0.00001);    Assert.assertEquals(3, falseLatitudeGroup2.getTotal());    Assert.assertEquals(80.0, falseLatitudeGroup2.getScore(), 0.00001);        GroupResult falseLatitudeGroup1 = falseLatitudeGroups.get(1);    Assert.assertEquals(48.0001, Double.parseDouble(falseLatitudeGroup1.getKey()), 0.00001);    Assert.assertEquals(1, falseLatitudeGroup1.getTotal());    Assert.assertEquals(50.0, falseLatitudeGroup1.getScore(), 0.00001);}
public void metron_f5524_0() throws Exception
{        GroupRequest request = JSONUtils.INSTANCE.load(sortedGroupByQuery, GroupRequest.class);    GroupResponse response = getIndexDao().group(request);    Assert.assertEquals("is_alert", response.getGroupedBy());    List<GroupResult> isAlertGroups = response.getGroupResults();    Assert.assertEquals(2, isAlertGroups.size());        GroupResult falseGroup = isAlertGroups.get(0);    Assert.assertEquals(4, falseGroup.getTotal());    Assert.assertEquals("ip_src_addr", falseGroup.getGroupedBy());    List<GroupResult> falseIpSrcAddrGroups = falseGroup.getGroupResults();    Assert.assertEquals(4, falseIpSrcAddrGroups.size());        GroupResult falseIpSrcAddrGroup1 = falseIpSrcAddrGroups.get(0);    Assert.assertEquals("192.168.1.8", falseIpSrcAddrGroup1.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup1.getTotal());    Assert.assertNull(falseIpSrcAddrGroup1.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup1.getGroupResults());        GroupResult falseIpSrcAddrGroup2 = falseIpSrcAddrGroups.get(1);    Assert.assertEquals("192.168.1.7", falseIpSrcAddrGroup2.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup2.getTotal());    Assert.assertNull(falseIpSrcAddrGroup2.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup2.getGroupResults());        GroupResult falseIpSrcAddrGroup3 = falseIpSrcAddrGroups.get(2);    Assert.assertEquals("192.168.1.6", falseIpSrcAddrGroup3.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup3.getTotal());    Assert.assertNull(falseIpSrcAddrGroup3.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup3.getGroupResults());        GroupResult falseIpSrcAddrGroup4 = falseIpSrcAddrGroups.get(3);    Assert.assertEquals("192.168.1.2", falseIpSrcAddrGroup4.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup4.getTotal());    Assert.assertNull(falseIpSrcAddrGroup4.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup4.getGroupResults());        GroupResult trueGroup = isAlertGroups.get(1);    Assert.assertEquals(6, trueGroup.getTotal());    Assert.assertEquals("ip_src_addr", trueGroup.getGroupedBy());    List<GroupResult> trueIpSrcAddrGroups = trueGroup.getGroupResults();    Assert.assertEquals(4, trueIpSrcAddrGroups.size());        GroupResult trueIpSrcAddrGroup1 = trueIpSrcAddrGroups.get(0);    Assert.assertEquals("192.168.1.5", trueIpSrcAddrGroup1.getKey());    Assert.assertEquals(1, trueIpSrcAddrGroup1.getTotal());    Assert.assertNull(trueIpSrcAddrGroup1.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup1.getGroupResults());        GroupResult trueIpSrcAddrGroup2 = trueIpSrcAddrGroups.get(1);    Assert.assertEquals("192.168.1.4", trueIpSrcAddrGroup2.getKey());    Assert.assertEquals(1, trueIpSrcAddrGroup2.getTotal());    Assert.assertNull(trueIpSrcAddrGroup2.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup2.getGroupResults());        GroupResult trueIpSrcAddrGroup3 = trueIpSrcAddrGroups.get(2);    Assert.assertEquals("192.168.1.3", trueIpSrcAddrGroup3.getKey());    Assert.assertEquals(1, trueIpSrcAddrGroup3.getTotal());    Assert.assertNull(trueIpSrcAddrGroup3.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup3.getGroupResults());        GroupResult trueIpSrcAddrGroup4 = trueIpSrcAddrGroups.get(3);    Assert.assertEquals("192.168.1.1", trueIpSrcAddrGroup4.getKey());    Assert.assertEquals(3, trueIpSrcAddrGroup4.getTotal());    Assert.assertNull(trueIpSrcAddrGroup4.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup4.getGroupResults());}
public void metron_f5525_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(fieldsQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 0; i < 5; ++i) {        Map<String, Object> source = results.get(i).getSource();        Assert.assertEquals(1, source.size());        Assert.assertNotNull(source.get("ip_src_addr"));    }    for (int i = 5; i < 10; ++i) {        Map<String, Object> source = results.get(i).getSource();        Assert.assertEquals(1, source.size());        Assert.assertNotNull(source.get("ip_src_addr"));    }}
public void metron_f5526_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortByGuidQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(5, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 0; i < 5; ++i) {        Map<String, Object> source = results.get(i).getSource();        Assert.assertEquals(1, source.size());        Assert.assertEquals(source.get("guid"), "bro_" + (i + 1));    }}
public static void metron_f5527_0()
{    indexComponent.stop();}
public void metron_f5528_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.ADD.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, "value");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<>()));}
public void metron_f5529_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.REMOVE.name());            put(PatchUtils.PATH, "/remove/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");            put("remove", new HashMap<>());        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");            put("remove", new HashMap<String, Object>() {                {                    put("path", "removeValue");                }            });        }    }));}
public void metron_f5530_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.COPY.name());            put(PatchUtils.FROM, "/from");            put(PatchUtils.PATH, "/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("from", "value");            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("from", "value");        }    }));}
public void metron_f5531_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.COPY.name());            put(PatchUtils.FROM, "/nested/from");            put(PatchUtils.PATH, "/nested/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("nested", new HashMap<String, Object>() {                {                    put("from", "value");                    put("path", "value");                }            });        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("nested", new HashMap<String, Object>() {                {                    put("from", "value");                }            });        }    }));}
public void metron_f5532_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.MOVE.name());            put(PatchUtils.FROM, "/from");            put(PatchUtils.PATH, "/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("from", "value");        }    }));}
public void metron_f5533_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, "value");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");        }    }));}
public void metron_f5534_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, 100);        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", 100);        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", 100);        }    }));}
public void metron_f5535_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, Arrays.asList(1, 2, 3));        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", Arrays.asList(1, 2, 3));        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", Arrays.asList(1, 2, 3));        }    }));}
public void metron_f5536_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, new HashMap<String, Object>() {                {                    put("key", "value");                }            });        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", new HashMap<String, Object>() {                {                    put("key", "value");                }            });        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", new HashMap<String, Object>() {                {                    put("key", "value");                }            });        }    }));}
public void metron_f5537_0()
{    exception.expect(PatchException.class);    exception.expectMessage("TEST operation failed: supplied value [value1] != target value [value2]");    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, "value1");        }    });    PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value2");        }    });}
public void metron_f5538_0()
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("Invalid path: /missing/path");    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.REMOVE.name());            put(PatchUtils.PATH, "/missing/path");        }    });    PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");        }    });}
public void metron_f5539_0()
{    exception.expect(UnsupportedOperationException.class);    exception.expectMessage("The invalid operation is not supported");    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, "invalid");            put(PatchUtils.PATH, "/path");        }    });    PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");        }    });}
public void metron_f5540_0() throws Exception
{    exception.expect(IOException.class);    exception.expectMessage("Unable to add comment. Document with guid guid cannot be found.");    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    getUpdateDao().addCommentToAlert(request, null);}
public void metron_f5541_0() throws Exception
{    exception.expect(IOException.class);    exception.expectMessage("Unable to remove comment. Document with guid guid cannot be found.");    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    getUpdateDao().removeCommentFromAlert(request, null);}
public void metron_f5542_0() throws Exception
{    exception.expect(IOException.class);    exception.expectMessage("Unable to remove comment. Document with guid guid has no comments.");    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    Document latest = new Document(new HashMap<>(), "guid", "bro", System.currentTimeMillis());    getUpdateDao().removeCommentFromAlert(request, latest);}
public void metron_f5543_0() throws Exception
{        final String guid = UUID.randomUUID().toString();    final Long timestamp = 1526306463050L;    Document toUpdate = createDocument(guid, timestamp);        Document updated = getDao().update(toUpdate, Optional.of(SENSOR_NAME));    Assert.assertEquals(toUpdate, updated);        assertDocumentIndexed(toUpdate);}
public void metron_f5544_0() throws Exception
{    Map<Document, Optional<String>> toUpdate = new HashMap<>();        final String guid1 = UUID.randomUUID().toString();    final Long timestamp1 = 1526306463050L;    Document document1 = createDocument(guid1, timestamp1);    toUpdate.put(document1, Optional.of(SENSOR_NAME));        final String guid2 = UUID.randomUUID().toString();    final Long timestamp2 = 1526306463100L;    Document document2 = createDocument(guid2, timestamp2);    toUpdate.put(document2, Optional.of(SENSOR_NAME));        final String guid3 = UUID.randomUUID().toString();    final Long timestamp3 = 1526306463300L;    Document document3 = createDocument(guid3, timestamp3);    toUpdate.put(document3, Optional.of(SENSOR_NAME));        Map<Document, Optional<String>> updated = getDao().batchUpdate(toUpdate);    Assert.assertThat(updated.keySet(), hasItem(document1));    Assert.assertThat(updated.keySet(), hasItem(document2));    Assert.assertThat(updated.keySet(), hasItem(document3));        assertDocumentIndexed(document1);    assertDocumentIndexed(document2);    assertDocumentIndexed(document3);}
public void metron_f5545_0() throws Exception
{    Document document = createAndIndexDocument("testAddCommentAndPatch");        String commentText = "New Comment";    String commentUser = "test_user";    long commentTimestamp = 152630493050L;    Document withComment = addAlertComment(document.getGuid(), commentText, commentUser, commentTimestamp);    {                List<AlertComment> comments = getComments(withComment);        Assert.assertEquals(1, comments.size());        Assert.assertEquals(commentText, comments.get(0).getComment());        Assert.assertEquals(commentUser, comments.get(0).getUsername());        Assert.assertEquals(commentTimestamp, comments.get(0).getTimestamp());    }    {                Document indexed = findUpdatedDoc(withComment.getDocument(), withComment.getGuid(), SENSOR_NAME);        List<AlertComment> comments = getComments(indexed);        Assert.assertEquals(1, comments.size());        Assert.assertEquals(commentText, comments.get(0).getComment());        Assert.assertEquals(commentUser, comments.get(0).getUsername());        Assert.assertEquals(commentTimestamp, comments.get(0).getTimestamp());    }}
public void metron_f5546_0() throws Exception
{    Document document = createAndIndexDocument("testPatchDocumentWithComment");        String commentText = "New Comment";    String commentUser = "test_user";    long commentTimestamp = 152630493050L;    Document withComment = addAlertComment(document.getGuid(), commentText, commentUser, commentTimestamp);        List<Map<String, Object>> patches = new ArrayList<>();    Map<String, Object> patch = new HashMap<>();    patch.put("op", "add");    patch.put("path", "/project");    patch.put("value", "metron");    patches.add(patch);    PatchRequest pr = new PatchRequest();    pr.setGuid(withComment.getGuid());    pr.setIndex(SENSOR_NAME);    pr.setSensorType(SENSOR_NAME);    pr.setPatch(patches);        Document patched = getDao().patch(getDao(), pr, Optional.of(withComment.getTimestamp()));    Assert.assertEquals("metron", patched.getDocument().get("project"));        Document indexed = findUpdatedDoc(patched.getDocument(), patched.getGuid(), SENSOR_NAME);    Assert.assertEquals("metron", indexed.getDocument().get("project"));}
public void metron_f5547_0() throws Exception
{    String guid = "testRemoveComments";    createAndIndexDocument(guid);        Document withComments = addAlertComment(guid, "comment", "user1", 1526401584951L);    Assert.assertEquals(1, getComments(withComments).size());        Document indexedWithComments = findUpdatedDoc(withComments.getDocument(), withComments.getGuid(), withComments.getSensorType());    Assert.assertEquals(1, getComments(indexedWithComments).size());        AlertComment toRemove = getComments(withComments).get(0);    Document noComments = removeAlertComment(guid, toRemove.getComment(), toRemove.getUsername(), toRemove.getTimestamp());    Assert.assertEquals(0, getComments(noComments).size());        Document indexedNoComments = findUpdatedDoc(noComments.getDocument(), withComments.getGuid(), withComments.getSensorType());    Assert.assertEquals(0, getComments(indexedNoComments).size());}
protected Document metron_f5548_0(String guid, String comment, String username, long timestamp) throws IOException
{    CommentAddRemoveRequest request = buildAlertRequest(guid, comment, username, timestamp);    return getDao().addCommentToAlert(request);}
protected Document metron_f5549_0(String guid, String comment, String username, long timestamp) throws IOException
{    CommentAddRemoveRequest request = buildAlertRequest(guid, comment, username, timestamp);    return getDao().removeCommentFromAlert(request);}
private CommentAddRemoveRequest metron_f5550_0(String guid, String comment, String username, long timestamp)
{    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid(guid);    request.setComment(comment);    request.setUsername(username);    request.setTimestamp(timestamp);    request.setSensorType(SENSOR_NAME);    return request;}
private Document metron_f5551_0(Document expected) throws Exception
{        Document actual = findUpdatedDoc(expected.getDocument(), expected.getGuid(), expected.getSensorType());        Assert.assertEquals(expected.getGuid(), actual.getGuid());    Assert.assertEquals(expected.getTimestamp(), actual.getTimestamp());    Assert.assertEquals(expected.getSensorType(), actual.getSensorType());    Assert.assertEquals(expected.getDocument(), actual.getDocument());    if (expected.getDocumentID().isPresent()) {                Assert.assertEquals(expected.getDocumentID().get(), actual.getDocumentID());    } else {                Assert.assertNotNull(expected.getDocumentID());    }    return actual;}
private Document metron_f5552_0(String guid) throws Exception
{        Long timestamp = 1526306463050L;    Document toCreate = createDocument(guid, timestamp);        Document created = getDao().update(toCreate, Optional.of(SENSOR_NAME));    Assert.assertEquals(toCreate, created);        return assertDocumentIndexed(created);}
protected Document metron_f5553_0(String guid, Long timestamp)
{    Map<String, Object> message1 = new HashMap<>();    message1.put(Constants.GUID, guid);    message1.put(Constants.SENSOR_TYPE, SENSOR_NAME);    message1.put(Constants.Fields.TIMESTAMP.getName(), timestamp);    return new Document(message1, guid, SENSOR_NAME, timestamp);}
private static List<AlertComment> metron_f5554_0(Document withComment) throws ParseException
{    return getComments(withComment.getDocument());}
private static List<AlertComment> metron_f5555_0(Map<String, Object> fields) throws ParseException
{    List<AlertComment> comments = new ArrayList<>();    boolean hasComments = fields.containsKey(COMMENTS_FIELD);    if (hasComments) {        List<Object> commentsField = List.class.cast(fields.get(COMMENTS_FIELD));        for (Object commentObject : commentsField) {            if (commentObject instanceof Map) {                                Map<String, Object> commentAsMap = (Map<String, Object>) commentObject;                comments.add(new AlertComment(commentAsMap));            } else if (commentObject instanceof String) {                                String commentAsString = (String) commentObject;                comments.add(new AlertComment(commentAsString));            } else {                throw new IllegalArgumentException(String.format("Unexpected comment value; %s", commentObject));            }        }    }    return comments;}
protected static void metron_f5556_0(Map<String, Object> fields)
{    @SuppressWarnings("unchecked")    List<Object> commentValues = (List<Object>) fields.get(COMMENTS_FIELD);    if (commentValues != null) {        try {            List<AlertComment> comments = getComments(fields);            if (comments.size() > 0) {                                List<Map<String, Object>> serializedComments = comments.stream().map(AlertComment::asMap).collect(Collectors.toList());                fields.put(COMMENTS_FIELD, serializedComments);            } else {                                fields.remove(COMMENTS_FIELD);            }        } catch (ParseException e) {            throw new IllegalStateException("Unable to parse comment", e);        }    }}
protected Document metron_f5557_0(Map<String, Object> expected, String guid, String sensorType) throws InterruptedException, IOException, OriginalNotFoundException
{        normalizeCommentsAsMap(expected);    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Document found = getDao().getLatest(guid, sensorType);        if (found != null && expected.equals(found.getDocument())) {            return found;        }        if (t == MAX_RETRIES - 1) {            MapUtils.debugPrint(System.out, "Expected", expected);            MapUtils.debugPrint(System.out, "Actual", found.getDocument());        }    }    throw new OriginalNotFoundException("Count not find " + guid + " after " + MAX_RETRIES + " tries");}
protected IndexDao metron_f5558_0()
{    return dao;}
protected void metron_f5559_0(IndexDao dao)
{    this.dao = dao;}
public Document metron_f5560_0(String guid, String sensorType) throws IOException
{    return indexDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f5561_0(List<GetRequest> getRequests) throws IOException
{    return indexDao.getAllLatest(getRequests);}
public void metron_f5562_0() throws Exception
{    AccessConfig accessConfig = new AccessConfig();    accessConfig.setMaxSearchResults(1000);    accessConfig.setMaxSearchGroups(1000);    accessConfig.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(HBASE_TABLE, TABLE_NAME);            put(HBASE_CF, COLUMN_FAMILY);        }    });    MockHBaseTableProvider.addToCache(TABLE_NAME, COLUMN_FAMILY);    accessConfig.setTableProvider(new MockHBaseTableProvider());    hbaseDao = new HBaseDao();    hbaseDao.init(accessConfig);}
public void metron_f5563_0() throws Exception
{    MockHBaseTableProvider.clear();}
public void metron_f5564_0() throws IOException
{    HBaseDao.Key k = new HBaseDao.Key("guid", "sensorType");    byte[] raw = k.toBytes();    Assert.assertArrayEquals(raw, expectedKeySerialization);}
public void metron_f5565_0() throws Exception
{    HBaseDao.Key k = new HBaseDao.Key("guid", "sensorType");    Assert.assertEquals(k, HBaseDao.Key.fromBytes(HBaseDao.Key.toBytes(k)));}
public void metron_f5566_0() throws Exception
{    HBaseDao.Key k = new HBaseDao.Key(null, "sensorType");    Assert.assertEquals(k, HBaseDao.Key.fromBytes(HBaseDao.Key.toBytes(k)));}
public void metron_f5567_0() throws Exception
{    HBaseDao.Key k = new HBaseDao.Key("guid", null);    Assert.assertEquals(k, HBaseDao.Key.fromBytes(HBaseDao.Key.toBytes(k)));}
public void metron_f5568_0() throws Exception
{        List<Document> alerts = buildAlerts(3);    Map<Document, Optional<String>> updates = alerts.stream().collect(Collectors.toMap(document -> document, document -> Optional.empty()));    hbaseDao.batchUpdate(updates);    Document actualDocument = hbaseDao.getLatest("message_1", SENSOR_TYPE);    Document expectedDocument = alerts.get(1);    Assert.assertEquals(expectedDocument, actualDocument);}
public void metron_f5569_0() throws Exception
{        Document alert = buildAlerts(1).get(0);    hbaseDao.update(alert, Optional.empty());    Document actualDocument = hbaseDao.getLatest("message_0", SENSOR_TYPE);    Assert.assertEquals(alert, actualDocument);    alert.getDocument().put("field", "value");    alert.setTimestamp(0L);    hbaseDao.update(alert, Optional.empty());    actualDocument = hbaseDao.getLatest("message_0", SENSOR_TYPE);    Assert.assertEquals(alert.getDocument(), actualDocument.getDocument());}
public void metron_f5570_0() throws Exception
{        List<Document> alerts = buildAlerts(15);    alerts.stream().collect(Collectors.toMap(Document::getGuid, document -> Optional.empty()));    Map<Document, Optional<String>> updates = alerts.stream().collect(Collectors.toMap(document -> document, document -> Optional.empty()));    hbaseDao.batchUpdate(updates);    int expectedCount = 12;    List<GetRequest> getRequests = new ArrayList<>();    for (int i = 1; i < expectedCount + 1; i++) {        getRequests.add(new GetRequest("message_" + i, SENSOR_TYPE));    }    Iterator<Document> results = hbaseDao.getAllLatest(getRequests).iterator();    for (int i = 0; i < expectedCount; i++) {        Document expectedDocument = alerts.get(i + 1);        Document actualDocument = results.next();        Assert.assertEquals(expectedDocument, actualDocument);    }    Assert.assertFalse("Result size should be 12 but was greater", results.hasNext());}
protected List<Document> metron_f5571_0(int count) throws IOException
{    List<Document> alerts = new ArrayList<>();    for (int i = 0; i < count; ++i) {        String guid = "message_" + i;        String json = "{\"guid\":\"message_" + i + "\", \"source:type\":\"test\"}";        Document alert = new Document(json, guid, SENSOR_TYPE, System.currentTimeMillis());        alerts.add(alert);    }    return alerts;}
public void metron_f5572_0() throws Exception
{    Map<String, Object> fields = new HashMap<>();    fields.put("guid", "add_comment");    fields.put("source.type", SENSOR_NAME);    Document document = new Document(fields, "add_comment", SENSOR_NAME, 1526401584951L);    hbaseDao.update(document, Optional.of(SENSOR_NAME));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    addAlertComment("add_comment", "New Comment", "test_user", 1526401584951L);        ArrayList<AlertComment> comments = new ArrayList<>();    comments.add(new AlertComment("New Comment", "test_user", 1526401584951L));    document.getDocument().put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    addAlertComment("add_comment", "New Comment 2", "test_user_2", 1526401584952L);        comments.add(new AlertComment("New Comment 2", "test_user_2", 1526401584952L));    document.getDocument().put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    removeAlertComment("add_comment", "New Comment 2", "test_user_2", 1526401584952L);        comments = new ArrayList<>();    comments.add(new AlertComment(commentOne));    document.getDocument().put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    removeAlertComment("add_comment", "New Comment", "test_user", 1526401584951L);        document.getDocument().remove(COMMENTS_FIELD);    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);}
protected IndexDao metron_f5573_0()
{    return hbaseDao;}
protected String metron_f5574_0()
{    return null;}
protected void metron_f5575_0(String indexName, String sensorType, List<Map<String, Object>> docs)
{}
protected List<Map<String, Object>> metron_f5576_0(String indexName, String sensorType)
{    return null;}
public void metron_f5577_0()
{    IndexingConfigurations indexingConfigs = mock(IndexingConfigurations.class);    ConfigurationsCache cache = mock(ConfigurationsCache.class);    Map<String, Object> broIndexingConfig = new HashMap<String, Object>() {        {            put("writer", new HashMap<String, Object>() {                {                    put("index", "bro_index");                }            });        }    };    when(indexingConfigs.getSensorIndexingConfig("bro")).thenReturn(broIndexingConfig);    when(cache.get(IndexingConfigurations.class)).thenReturn(indexingConfigs);    assertEquals("bro_index", IndexingCacheUtil.getIndexLookupFunction(cache, "writer").apply("bro"));}
public void metron_f5578_0()
{    IndexingConfigurations indexingConfigs = mock(IndexingConfigurations.class);    ConfigurationsCache cache = mock(ConfigurationsCache.class);    Map<String, Object> broIndexingConfig = new HashMap<String, Object>() {        {            put("writer", new HashMap<String, Object>() {                {                    put("index", "bro_index");                }            });        }    };    when(indexingConfigs.getSensorIndexingConfig("bro")).thenReturn(broIndexingConfig);    when(cache.get(IndexingConfigurations.class)).thenReturn(indexingConfigs);    assertEquals("Should default to sensor type on missing sensor config", "snort", IndexingCacheUtil.getIndexLookupFunction(cache, "writer").apply("snort"));    assertEquals("Should default to sensor type on missing writer config", "bro", IndexingCacheUtil.getIndexLookupFunction(cache, "someWriter").apply("bro"));}
public static void metron_f5579_0(String hdfsDirStr)
{    File hdfsDir = new File(hdfsDirStr);    Stack<File> fs = new Stack<>();    if (hdfsDir.exists()) {        fs.push(hdfsDir);        while (!fs.empty()) {            File f = fs.pop();            if (f.isDirectory()) {                for (File child : f.listFiles()) {                    fs.push(child);                }            } else {                if (f.getName().startsWith("enrichment") || f.getName().endsWith(".json")) {                    f.delete();                }            }        }    }}
public static List<Map<String, Object>> metron_f5580_0(String hdfsDirStr) throws IOException
{    List<Map<String, Object>> ret = new ArrayList<>();    File hdfsDir = new File(hdfsDirStr);    Stack<File> fs = new Stack<>();    if (hdfsDir.exists()) {        fs.push(hdfsDir);        while (!fs.empty()) {            File f = fs.pop();            if (f.isDirectory()) {                for (File child : f.listFiles()) {                    fs.push(child);                }            } else {                System.out.println("Processed " + f);                if (f.getName().startsWith("enrichment") || f.getName().endsWith(".json")) {                    List<byte[]> data = TestUtils.readSampleData(f.getPath());                    Iterables.addAll(ret, Iterables.transform(data, bytes -> {                        String s = new String(bytes, StandardCharsets.UTF_8);                        try {                            return JSONUtils.INSTANCE.load(s, JSONUtils.MAP_SUPPLIER);                        } catch (IOException e) {                            throw new RuntimeException(e);                        }                    }));                }            }        }    }    return ret;}
protected void metron_f5581_0()
{    cleanHdfsDir(hdfsDir);}
public Processor<List<Map<String, Object>>> metron_f5582_0(List<byte[]> inputMessages)
{    return new Processor<List<Map<String, Object>>>() {        List<Map<String, Object>> docs = null;        List<byte[]> errors = null;        @Override        public ReadinessState process(ComponentRunner runner) {            KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);            try {                docs = readDocsFromDisk(hdfsDir);            } catch (IOException e) {                throw new IllegalStateException("Unable to retrieve indexed documents.", e);            }            if (docs.size() < inputMessages.size()) {                errors = kafkaComponent.readMessages(IndexingIntegrationTest.ERROR_TOPIC);                if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {                    return ReadinessState.READY;                }                return ReadinessState.NOT_READY;            } else {                return ReadinessState.READY;            }        }        @Override        public ProcessorResult<List<Map<String, Object>>> getResult() {            ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();            return builder.withResult(docs).withProcessErrors(errors).build();        }    };}
public ReadinessState metron_f5583_0(ComponentRunner runner)
{    KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);    try {        docs = readDocsFromDisk(hdfsDir);    } catch (IOException e) {        throw new IllegalStateException("Unable to retrieve indexed documents.", e);    }    if (docs.size() < inputMessages.size()) {        errors = kafkaComponent.readMessages(IndexingIntegrationTest.ERROR_TOPIC);        if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {            return ReadinessState.READY;        }        return ReadinessState.NOT_READY;    } else {        return ReadinessState.READY;    }}
public ProcessorResult<List<Map<String, Object>>> metron_f5584_0()
{    ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();    return builder.withResult(docs).withProcessErrors(errors).build();}
public FieldNameConverter metron_f5585_0()
{    return originalField -> originalField;}
public InMemoryComponent metron_f5586_0(Properties topologyProperties) throws Exception
{    return null;}
public void metron_f5587_0(Properties topologyProperties)
{    topologyProperties.setProperty("batch_indexing_kafka_start", "UNCOMMITTED_EARLIEST");    topologyProperties.setProperty("batch_indexing_workers", "1");    topologyProperties.setProperty("batch_indexing_acker_executors", "0");    topologyProperties.setProperty("batch_indexing_topology_max_spout_pending", "");    topologyProperties.setProperty("batch_indexing_kafka_spout_parallelism", "1");    topologyProperties.setProperty("bolt_hdfs_rotation_policy", "org.apache.storm.hdfs.bolt.rotation.TimedRotationPolicy");    topologyProperties.setProperty("bolt_hdfs_rotation_policy_count", "1");    topologyProperties.setProperty("bolt_hdfs_rotation_policy_units", "DAYS");    topologyProperties.setProperty("metron_apps_indexed_hdfs_dir", hdfsDir);    topologyProperties.setProperty("hdfs_writer_parallelism", "1");}
public String metron_f5588_0(String field)
{    return field;}
public String metron_f5589_0()
{    return "../metron-indexing-storm/src/main/config/hdfs.properties.j2";}
public String metron_f5590_0()
{    return "../metron-indexing-storm/src/main/flux/indexing/batch/remote.yaml";}
protected void metron_f5591_0()
{}
public void metron_f5592_0() throws Exception
{    final List<byte[]> inputMessages = TestUtils.readSampleData(sampleParsedPath);    final Properties topologyProperties = new Properties() {        {            setProperty("indexing_kafka_start", "UNCOMMITTED_EARLIEST");            setProperty("kafka_security_protocol", "PLAINTEXT");            setProperty("topology_auto_credentials", "[]");            setProperty("indexing_workers", "1");            setProperty("indexing_acker_executors", "0");            setProperty("indexing_topology_worker_childopts", "");            setProperty("indexing_topology_max_spout_pending", "");            setProperty("indexing_input_topic", Constants.INDEXING_TOPIC);            setProperty("indexing_error_topic", ERROR_TOPIC);            setProperty("indexing_kafka_spout_parallelism", "1");            setProperty("indexing_writer_parallelism", "1");        }    };    setAdditionalProperties(topologyProperties);    final ZKServerComponent zkServerComponent = getZKServerComponent(topologyProperties);    final KafkaComponent kafkaComponent = getKafkaComponent(topologyProperties, new ArrayList<KafkaComponent.Topic>() {        {            add(new KafkaComponent.Topic(Constants.INDEXING_TOPIC, 1));            add(new KafkaComponent.Topic(ERROR_TOPIC, 1));        }    });    List<Map<String, Object>> inputDocs = new ArrayList<>();    for (byte[] b : inputMessages) {        Map<String, Object> m = JSONUtils.INSTANCE.load(new String(b, StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);        inputDocs.add(m);    }    final AtomicBoolean isLoaded = new AtomicBoolean(false);    ConfigUploadComponent configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties).withGlobalConfigsPath(sampleConfigPath).withEnrichmentConfigsPath(sampleConfigPath).withIndexingConfigsPath(sampleConfigPath).withPostStartCallback(component -> {        try {            waitForIndex(component.getTopologyProperties().getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY));        } catch (Exception e) {            e.printStackTrace();        }        isLoaded.set(true);    });    FluxTopologyComponent fluxComponent = new FluxTopologyComponent.Builder().withTopologyLocation(new File(getFluxPath())).withTopologyName("test").withTemplateLocation(new File(getTemplatePath())).withTopologyProperties(topologyProperties).build();    ComponentRunner runner = null;    InMemoryComponent searchComponent = getSearchComponent(topologyProperties);    ComponentRunner.Builder componentBuilder = new ComponentRunner.Builder();    componentBuilder = componentBuilder.withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("storm", fluxComponent).withMillisecondsBetweenAttempts(1500).withNumRetries(NUM_RETRIES).withMaxTimeMS(TOTAL_TIME_MS);    if (searchComponent != null) {        componentBuilder = componentBuilder.withComponent("search", getSearchComponent(topologyProperties)).withCustomShutdownOrder(new String[] { "search", "storm", "config", "kafka", "zk" });    } else {        componentBuilder = componentBuilder.withCustomShutdownOrder(new String[] { "storm", "config", "kafka", "zk" });    }    runner = componentBuilder.build();    try {        runner.start();        while (!isLoaded.get()) {            Thread.sleep(100);        }        fluxComponent.submitTopology();        kafkaComponent.writeMessages(Constants.INDEXING_TOPIC, inputMessages);        List<Map<String, Object>> docs = cleanDocs(runner.process(getProcessor(inputMessages)));        Assert.assertEquals(docs.size(), inputMessages.size());                        assertInputDocsMatchOutputs(inputDocs, docs, getFieldNameConverter());    } finally {        if (runner != null) {            runner.stop();        }    }}
private void metron_f5593_0(String zookeeperQuorum) throws Exception
{    try (CuratorFramework client = getClient(zookeeperQuorum)) {        client.start();        System.out.println("Waiting for zookeeper...");        byte[] bytes = null;        do {            try {                bytes = ConfigurationsUtils.readSensorIndexingConfigBytesFromZookeeper(testSensorType, client);                Thread.sleep(1000);            } catch (KeeperException.NoNodeException nne) {                        }        } while (bytes == null || bytes.length == 0);        System.out.println("Found index config in zookeeper...");    }}
public List<Map<String, Object>> metron_f5594_0(ProcessorResult<List<Map<String, Object>>> result)
{    List<Map<String, Object>> docs = result.getResult();    StringBuffer buffer = new StringBuffer();    boolean failed = false;    List<Map<String, Object>> ret = new ArrayList<>();    if (result.failed()) {        failed = true;        result.getBadResults(buffer);        buffer.append(String.format("%d Valid messages processed", docs.size())).append("\n");        for (Map<String, Object> doc : docs) {            Map<String, Object> msg = new HashMap<>();            for (Map.Entry<String, Object> kv : doc.entrySet()) {                                buffer.append(cleanField(kv.getKey())).append(kv.getValue().toString()).append("\n");            }        }        Assert.fail(buffer.toString());    } else {        for (Map<String, Object> doc : docs) {            Map<String, Object> msg = new HashMap<>();            for (Map.Entry<String, Object> kv : doc.entrySet()) {                                msg.put(cleanField(kv.getKey()), kv.getValue());            }            ret.add(msg);        }    }    return ret;}
public void metron_f5595_0(List<Map<String, Object>> inputDocs, List<Map<String, Object>> indexDocs, FieldNameConverter converter)
{    for (Map<String, Object> indexDoc : indexDocs) {        boolean foundMatch = false;        for (Map<String, Object> doc : inputDocs) {            if (docMatches(indexDoc, doc, converter)) {                foundMatch = true;                break;            }        }        if (!foundMatch) {            System.err.println("Unable to find: ");            printMessage(indexDoc);            dumpMessages("INPUT DOCS:", inputDocs);        }        Assert.assertTrue(foundMatch);    }}
private void metron_f5596_0(Map<String, Object> doc)
{    TreeMap<String, Object> d = new TreeMap<>(doc);    for (Map.Entry<String, Object> kv : d.entrySet()) {        System.err.println("  " + kv.getKey() + " -> " + kv.getValue());    }}
private void metron_f5597_0(String title, List<Map<String, Object>> docs)
{    System.err.println(title);    int cnt = 0;    for (Map<String, Object> doc : docs) {        System.err.println("MESSAGE " + cnt++);        printMessage(doc);    }}
 boolean metron_f5598_0(Map<String, Object> indexedDoc, Map<String, Object> inputDoc, FieldNameConverter converter)
{    String key = "original_string";    String indexKey = converter.convert(key);    String originalString = inputDoc.get(key).toString();    return originalString.equals(indexedDoc.get(indexKey).toString());}
protected static KafkaComponent metron_f5599_0(final Properties topologyProperties, List<KafkaComponent.Topic> topics)
{    return new KafkaComponent().withTopics(topics).withTopologyProperties(topologyProperties);}
protected static ZKServerComponent metron_f5600_0(final Properties topologyProperties)
{    return new ZKServerComponent().withPostStartCallback((zkComponent) -> {        topologyProperties.setProperty(ZKServerComponent.ZOOKEEPER_PROPERTY, zkComponent.getConnectionString());        topologyProperties.setProperty("kafka.zk", zkComponent.getConnectionString());    });}
public Builder metron_f5601_0(int numRetries)
{    this.numRetries = numRetries;    return this;}
public Builder metron_f5602_0(long maxTimeMS)
{    this.maxTimeMS = maxTimeMS;    return this;}
public Builder metron_f5603_0(String name, InMemoryComponent component)
{    components.put(name, component);    return this;}
public Builder metron_f5604_0(String[] startupOrder)
{    this.startupOrder = startupOrder;    return this;}
public Builder metron_f5605_0(String[] shutdownOrder)
{    this.shutdownOrder = shutdownOrder;    return this;}
public Builder metron_f5606_0(String[] resetOrder)
{    this.resetOrder = resetOrder;    return this;}
public Builder metron_f5607_0(long timeBetweenAttempts)
{    this.timeBetweenAttempts = timeBetweenAttempts;    return this;}
private static String[] metron_f5608_0(Map<String, InMemoryComponent> components)
{    String[] ret = new String[components.size()];    int i = 0;    for (String component : components.keySet()) {        ret[i++] = component;    }    return ret;}
public ComponentRunner metron_f5609_0()
{    if (shutdownOrder == null) {        shutdownOrder = toOrderedList(components);    }    if (startupOrder == null) {        startupOrder = toOrderedList(components);    }    if (resetOrder == null) {                if (shutdownOrder != null) {            resetOrder = shutdownOrder;        } else {            resetOrder = toOrderedList(components);        }    }    return new ComponentRunner(components, startupOrder, shutdownOrder, resetOrder, timeBetweenAttempts, numRetries, maxTimeMS);}
public T metron_f5610_0(String name, Class<T> clazz)
{    return clazz.cast(getComponents().get(name));}
public LinkedHashMap<String, InMemoryComponent> metron_f5611_0()
{    return components;}
public void metron_f5612_0() throws UnableToStartException
{    for (String componentName : startupOrder) {        components.get(componentName).start();    }}
public void metron_f5613_0()
{    for (String componentName : shutdownOrder) {        components.get(componentName).stop();    }}
public void metron_f5614_0()
{    for (String componentName : resetOrder) {        components.get(componentName).reset();    }}
public ProcessorResult<T> metron_f5615_0(Processor<T> successState)
{    int retryCount = 0;    long start = System.currentTimeMillis();    while (true) {        long duration = System.currentTimeMillis() - start;        if (maxTimeMS > 0 && duration > maxTimeMS) {            throw new RuntimeException("Took too long to complete: " + duration + " > " + maxTimeMS);        }        ReadinessState state = successState.process(this);        if (state == ReadinessState.READY) {            return successState.getResult();        } else if (state == ReadinessState.NOT_READY) {            retryCount++;            if (numRetries > 0 && retryCount > numRetries) {                throw new RuntimeException("Too many retries: " + retryCount);            }        }        try {            Thread.sleep(timeBetweenAttempts);        } catch (InterruptedException e) {            throw new RuntimeException("Unable to sleep", e);        }    }}
public Builder metron_f5616_0(String name)
{    this.topologyName = name;    return this;}
public Builder metron_f5617_0(File location)
{    this.topologyLocation = location;    return this;}
public Builder metron_f5618_0(File location)
{    this.templateLocation = location;    return this;}
public Builder metron_f5619_0(Properties properties)
{    this.topologyProperties = properties;    this.topologyProperties.put("storm.home", "target");    return this;}
public FluxTopologyComponent metron_f5620_0()
{    return new FluxTopologyComponent(topologyName, topologyLocation, templateLocation, topologyProperties);}
public LocalCluster metron_f5621_0()
{    return stormCluster;}
public String metron_f5622_0()
{    return topologyName;}
public File metron_f5623_0()
{    return topologyLocation;}
public File metron_f5624_0()
{    return templateLocation;}
public Properties metron_f5625_0()
{    return topologyProperties;}
public String metron_f5626_0()
{    return "localhost:2000";}
public void metron_f5627_1() throws UnableToStartException
{    try {        stormCluster = new LocalCluster();        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        try (CuratorFramework client = CuratorFrameworkFactory.newClient(getZookeeperConnectString(), retryPolicy)) {            client.start();            String root = "/storm/leader-lock";            Stat exists = client.checkExists().forPath(root);            if (exists == null) {                client.create().creatingParentsIfNeeded().forPath(root);            }        } catch (Exception e) {                    } finally {        }    } catch (Exception e) {        throw new UnableToStartException("Unable to start flux topology: " + getTopologyLocation(), e);    }}
public static void metron_f5628_0()
{    if (new File("logs/workers-artifacts").exists()) {        Path rootPath = Paths.get("logs");        Path destPath = Paths.get("target/logs");        try {            Files.move(rootPath, destPath);            Files.walk(destPath).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);        } catch (IOException e) {            throw new IllegalStateException(e.getMessage(), e);        }    }}
public void metron_f5629_1()
{    if (stormCluster != null) {        try {            try {                                killTopology();                stormCluster.shutdown();            } catch (IllegalStateException ise) {                if (!(ise.getMessage().contains("It took over") && ise.getMessage().contains("to shut down slot"))) {                    throw ise;                } else {                                        assassinateSlots();                                    }            } catch (RuntimeException re) {                if (re.getCause() instanceof TProtocolException) {                                } else {                    throw re;                }            }        } catch (Throwable t) {                    } finally {            cleanupWorkerDir();        }    }}
public void metron_f5630_0()
{    if (stormCluster != null) {        killTopology();    }}
protected void metron_f5631_0()
{    KillOptions ko = new KillOptions();    ko.set_wait_secs(0);    stormCluster.killTopologyWithOpts(topologyName, ko);    try {                Thread.sleep(2000);    } catch (InterruptedException e) {        }}
public static void metron_f5632_1()
{    /*    You might be wondering why I'm not just casting to slot here, but that's because the Slot class moved locations    and we're supporting multiple versions of storm.     */        Thread.getAllStackTraces().keySet().stream().filter(t -> t instanceof AutoCloseable && t.getName().toLowerCase().contains("slot")).forEach(t -> {                        try {            t.stop();                    } catch (Exception e) {                }    });}
public void metron_f5633_0() throws NoSuchMethodException, IOException, InstantiationException, TException, IllegalAccessException, InvocationTargetException, ClassNotFoundException, NoSuchFieldException
{    startTopology(getTopologyName(), getTopologyLocation(), getTemplateLocation(), getTopologyProperties());}
private void metron_f5634_0(String topologyName, File topologyLoc, File templateFile, Properties properties) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, TException, NoSuchFieldException
{    TopologyDef topologyDef = loadYaml(topologyName, topologyLoc, templateFile, properties);    Config conf = FluxBuilder.buildConfig(topologyDef);    ExecutionContext context = new ExecutionContext(topologyDef, conf);    StormTopology topology = FluxBuilder.buildTopology(context);    Assert.assertNotNull(topology);    topology.validate();    try {        stormCluster.submitTopology(topologyName, conf, topology);    } catch (Exception nne) {        try {            Thread.sleep(2000);        } catch (InterruptedException e) {        }        stormCluster.submitTopology(topologyName, conf, topology);    }}
private static TopologyDef metron_f5635_0(String topologyName, File yamlFile, File templateFile, Properties properties) throws IOException
{    File tmpFile = File.createTempFile(topologyName, "props");    tmpFile.deleteOnExit();    if (templateFile != null) {        try (Writer propWriter = new OutputStreamWriter(new FileOutputStream(tmpFile), StandardCharsets.UTF_8)) {            String templateContents = FileUtils.readFileToString(templateFile);            for (Map.Entry prop : properties.entrySet()) {                String replacePattern = String.format("{{%s}}", prop.getKey());                templateContents = templateContents.replaceAll(Pattern.quote(replacePattern), (String) prop.getValue());            }            propWriter.write(templateContents);            propWriter.flush();            return FluxParser.parseFile(yamlFile.getAbsolutePath(), false, true, tmpFile.getAbsolutePath(), false);        }    } else {        try (Writer propWriter = new OutputStreamWriter(new FileOutputStream(tmpFile), StandardCharsets.UTF_8)) {            properties.store(propWriter, topologyName + " properties");            return FluxParser.parseFile(yamlFile.getAbsolutePath(), false, true, tmpFile.getAbsolutePath(), false);        }    }}
public KafkaComponent metron_f5636_0(Function<KafkaComponent, Void> f)
{    postStartCallback = f;    return this;}
public KafkaComponent metron_f5637_0(String zookeeperConnectString)
{    this.zookeeperConnectString = zookeeperConnectString;    return this;}
public KafkaComponent metron_f5638_0(Properties properties)
{    this.topologyProperties = properties;    return this;}
public KafkaComponent metron_f5639_0(int brokerPort)
{    if (brokerPort <= 0) {        brokerPort = TestUtils.RandomPort();    }    this.brokerPort = brokerPort;    return this;}
public KafkaComponent metron_f5640_0(List<Topic> topics)
{    this.topics = topics;    return this;}
public List<Topic> metron_f5641_0()
{    return topics;}
public int metron_f5642_0()
{    return brokerPort;}
public String metron_f5643_0()
{    return "localhost:" + brokerPort;}
public KafkaProducer<K, V> metron_f5644_0(Class<K> keyClass, Class<V> valueClass)
{    return createProducer(new HashMap<>(), keyClass, valueClass);}
public KafkaProducer<String, byte[]> metron_f5645_0()
{    return createProducer(String.class, byte[].class);}
public KafkaProducer<K, V> metron_f5646_0(Map<String, Object> properties, Class<K> keyClass, Class<V> valueClass)
{    Map<String, Object> producerConfig = new HashMap<>();    producerConfig.put("bootstrap.servers", getBrokerList());    producerConfig.put("key.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");    producerConfig.put("value.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");    producerConfig.put("request.required.acks", "-1");    producerConfig.put("fetch.message.max.bytes", "" + 1024 * 1024 * 10);    producerConfig.put("replica.fetch.max.bytes", "" + 1024 * 1024 * 10);    producerConfig.put("message.max.bytes", "" + 1024 * 1024 * 10);    producerConfig.put("message.send.max.retries", "10");    producerConfig.putAll(properties);    KafkaProducer<K, V> ret = new KafkaProducer<>(producerConfig);    producersCreated.add(ret);    return ret;}
public void metron_f5647_0()
{        zookeeperConnectString = topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY);    zkClient = new ZkClient(zookeeperConnectString, ZK_SESSION_TIMEOUT_MS, ZK_CONNECTION_TIMEOUT_MS, ZKStringSerializer$.MODULE$);        Properties props = TestUtilsWrapper.createBrokerConfig(0, zookeeperConnectString, brokerPort);    props.setProperty("zookeeper.connection.timeout.ms", Integer.toString(KAFKA_ZOOKEEPER_TIMEOUT_MS));    KafkaConfig config = new KafkaConfig(props);    Time mock = new MockTime();    kafkaServer = TestUtils.createServer(config, mock);    org.apache.log4j.Level oldLevel = UnitTestHelper.getLog4jLevel(KafkaServer.class);    UnitTestHelper.setLog4jLevel(KafkaServer.class, org.apache.log4j.Level.OFF);        TestUtilsWrapper.waitUntilBrokerIsRunning(kafkaServer, "Timed out waiting for RunningAsBroker State", 100000);    for (Topic topic : getTopics()) {        try {            createTopic(topic.name, topic.numPartitions, KAFKA_PROPAGATE_TIMEOUT_MS);        } catch (InterruptedException e) {            throw new RuntimeException("Unable to create topic", e);        }    }    UnitTestHelper.setLog4jLevel(KafkaServer.class, oldLevel);    if (postStartCallback != null) {        postStartCallback.apply(this);    }}
public String metron_f5648_0()
{    return zookeeperConnectString;}
public void metron_f5649_0()
{    shutdownConsumer();    shutdownProducers();    if (kafkaServer != null) {        try {            kafkaServer.shutdown();            kafkaServer.awaitShutdown();        } catch (Throwable fnf) {            if (!fnf.getMessage().contains("Error writing to highwatermark file")) {                throw fnf;            }        }    }    if (zkClient != null) {                for (Topic topic : topics) {            zkClient.deleteRecursive(ZkUtils.getTopicPath(topic.name));        }        zkClient.deleteRecursive(ZkUtils.BrokerIdsPath());        zkClient.deleteRecursive(ZkUtils.BrokerTopicsPath());        zkClient.deleteRecursive(ZkUtils.ConsumersPath());        zkClient.deleteRecursive(ZkUtils.ControllerPath());        zkClient.deleteRecursive(ZkUtils.ControllerEpochPath());        zkClient.deleteRecursive(ZkUtils.ReassignPartitionsPath());        zkClient.deleteRecursive(ZkUtils.DeleteTopicsPath());        zkClient.deleteRecursive(ZkUtils.PreferredReplicaLeaderElectionPath());        zkClient.deleteRecursive(ZkUtils.BrokerSequenceIdPath());        zkClient.deleteRecursive(ZkUtils.IsrChangeNotificationPath());        zkClient.deleteRecursive(ZkUtils.EntityConfigPath());        zkClient.deleteRecursive(ZkUtils.EntityConfigChangesPath());        zkClient.close();    }}
public void metron_f5650_0()
{            stop();    start();}
public List<byte[]> metron_f5651_0(String topic)
{    SimpleConsumer consumer = new SimpleConsumer("localhost", 6667, 100000, 64 * 1024, "consumer");    FetchRequest req = new FetchRequestBuilder().clientId("consumer").addFetch(topic, 0, 0, 100000).build();    FetchResponse fetchResponse = consumer.fetch(req);    Iterator<MessageAndOffset> results = fetchResponse.messageSet(topic, 0).iterator();    List<byte[]> messages = new ArrayList<>();    while (results.hasNext()) {        ByteBuffer payload = results.next().message().payload();        byte[] bytes = new byte[payload.limit()];        payload.get(bytes);        messages.add(bytes);    }    consumer.close();    return messages;}
public ConsumerIterator<byte[], byte[]> metron_f5652_0(String topic)
{    return getStreamIterator(topic, "group0", "consumer0");}
public ConsumerIterator<byte[], byte[]> metron_f5653_0(String topic, String group, String consumerName)
{        Properties consumerProperties = TestUtils.createConsumerProperties(zookeeperConnectString, group, consumerName, -1);    consumer = kafka.consumer.Consumer.createJavaConsumerConnector(new ConsumerConfig(consumerProperties));    Map<String, Integer> topicCountMap = new HashMap<String, Integer>();    topicCountMap.put(topic, 1);    Map<String, List<KafkaStream<byte[], byte[]>>> consumerMap = consumer.createMessageStreams(topicCountMap);    KafkaStream<byte[], byte[]> stream = consumerMap.get(topic).get(0);    ConsumerIterator<byte[], byte[]> iterator = stream.iterator();    return iterator;}
public void metron_f5654_0()
{    if (consumer != null) {        consumer.shutdown();    }}
public void metron_f5655_1()
{    for (KafkaProducer kp : producersCreated) {        try {            kp.close();        } catch (Exception ex) {                    }    }}
public void metron_f5656_0(String name) throws InterruptedException
{    createTopic(name, 1, KAFKA_PROPAGATE_TIMEOUT_MS);}
public void metron_f5657_0(String topic, int numPartitions, long timeOutMS)
{    List<KafkaServer> servers = new ArrayList<>();    servers.add(kafkaServer);    for (int part = 0; part < numPartitions; ++part) {        TestUtils.waitUntilMetadataIsPropagated(scala.collection.JavaConversions.asScalaBuffer(servers), topic, part, timeOutMS);    }}
public void metron_f5658_0(String name, int numPartitions, long waitThisLongForMetadataToPropagate) throws InterruptedException
{    ZkUtils zkUtils = null;    Level oldLevel = UnitTestHelper.getJavaLoggingLevel();    try {        UnitTestHelper.setJavaLoggingLevel(Level.OFF);        zkUtils = ZkUtils.apply(zookeeperConnectString, 30000, 30000, false);        AdminUtilsWrapper.createTopic(zkUtils, name, numPartitions, 1, new Properties());        if (waitThisLongForMetadataToPropagate > 0) {            waitUntilMetadataIsPropagated(name, numPartitions, waitThisLongForMetadataToPropagate);        }    } catch (TopicExistsException tee) {    } finally {        if (zkUtils != null) {            zkUtils.close();        }        UnitTestHelper.setJavaLoggingLevel(oldLevel);    }}
public void metron_f5659_0(String topic, Collection<byte[]> messages)
{    try (KafkaProducer<String, byte[]> kafkaProducer = createProducer()) {        for (byte[] message : messages) {            kafkaProducer.send(new ProducerRecord<>(topic, message));        }    }}
public void metron_f5660_0(String topic, String... messages)
{        List<byte[]> messagesAsBytes = Stream.of(messages).map(Bytes::toBytes).collect(Collectors.toList());    writeMessages(topic, messagesAsBytes);}
public void metron_f5661_0(String topic, List<String> messages)
{    writeMessages(topic, messages.toArray(new String[] {}));}
public MRComponent metron_f5662_0(String path)
{    basePath = new Path(path);    return this;}
public Configuration metron_f5663_0()
{    return configuration;}
public Path metron_f5664_0()
{    return basePath;}
public void metron_f5665_0()
{    configuration = new Configuration();    System.clearProperty(MiniDFSCluster.PROP_TEST_BUILD_DATA);    configuration.set(YarnConfiguration.YARN_MINICLUSTER_FIXED_PORTS, "true");    if (basePath == null) {        throw new RuntimeException("Unable to start cluster: You must specify the basepath");    }    configuration.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, basePath.toString());    try {        cluster = new MiniDFSCluster.Builder(configuration).build();    } catch (IOException e) {        throw new RuntimeException("Unable to start cluster", e);    }}
public void metron_f5666_0()
{    cluster.shutdown();}
public YarnComponent metron_f5667_0(Class clazz)
{    appmasterJar = JarFinder.getJar(clazz);    return this;}
public YarnComponent metron_f5668_0(String name)
{    this.testName = name;    return this;}
public String metron_f5669_0()
{    return appmasterJar;}
public YarnConfiguration metron_f5670_0()
{    return conf;}
public MiniYARNCluster metron_f5671_0()
{    return yarnCluster;}
public void metron_f5672_0() throws UnableToStartException
{    conf = new YarnConfiguration();    conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB, 128);    conf.set("yarn.log.dir", "target");    conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, true);    conf.set(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class.getName());    conf.setBoolean(YarnConfiguration.NODE_LABELS_ENABLED, true);    try {        yarnCluster = new MiniYARNCluster(testName, 1, NUM_NMS, 1, 1, true);        yarnCluster.init(conf);        yarnCluster.start();        waitForNMsToRegister();        URL url = Thread.currentThread().getContextClassLoader().getResource("yarn-site.xml");        if (url == null) {            throw new RuntimeException("Could not find 'yarn-site.xml' dummy file in classpath");        }        Configuration yarnClusterConfig = yarnCluster.getConfig();        yarnClusterConfig.set("yarn.application.classpath", new File(url.getPath()).getParent());                        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();        yarnClusterConfig.writeXml(bytesOut);        bytesOut.close();                OutputStream os = new FileOutputStream(new File(url.getPath()));        os.write(bytesOut.toByteArray());        os.close();        FileContext fsContext = FileContext.getLocalFSFileContext();        fsContext.delete(new Path(conf.get("yarn.timeline-service.leveldb-timeline-store.path")), true);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {        }    } catch (Exception e) {        throw new UnableToStartException("Exception setting up yarn cluster", e);    }}
public void metron_f5673_0()
{    if (yarnCluster != null) {        try {            yarnCluster.stop();        } finally {            yarnCluster = null;        }    }    try {        FileContext fsContext = FileContext.getLocalFSFileContext();        fsContext.delete(new Path(conf.get("yarn.timeline-service.leveldb-timeline-store.path")), true);    } catch (Exception e) {    }}
protected void metron_f5674_0() throws Exception
{    int sec = 60;    while (sec >= 0) {        if (yarnCluster.getResourceManager().getRMContext().getRMNodes().size() >= NUM_NMS) {            break;        }        Thread.sleep(1000);        sec--;    }}
public String metron_f5675_0()
{    return this.zookeeperUrl;}
public ZKServerComponent metron_f5676_0(Consumer<ZKServerComponent> f)
{    postStartCallback = Optional.ofNullable(f);    return this;}
public void metron_f5677_0() throws UnableToStartException
{    try {        testZkServer = new TestingServer(true);        zookeeperUrl = testZkServer.getConnectString();        if (postStartCallback.isPresent()) {            postStartCallback.get().accept(this);        }    } catch (Exception e) {        throw new UnableToStartException("Unable to start TestingServer", e);    }}
public void metron_f5678_0()
{    try {        if (testZkServer != null) {            testZkServer.close();        }    } catch (Exception e) {        }}
public void metron_f5679_0()
{    if (testZkServer != null) {        try {            FileUtils.deleteDirectory(testZkServer.getTempDirectory());        } catch (IOException e) {                }    }}
 void metron_f5680_0()
{}
public Builder metron_f5681_0(T result)
{    this.result = result;    return this;}
public Builder metron_f5682_0(List<byte[]> processErrors)
{    this.processErrors = processErrors;    return this;}
public ProcessorResult<T> metron_f5683_0()
{    return new ProcessorResult<T>(result, processErrors);}
public T metron_f5684_0()
{    return result;}
public List<byte[]> metron_f5685_0()
{    return processErrors;}
public boolean metron_f5686_0()
{    return processErrors.size() > 0;}
public void metron_f5687_0(StringBuffer buffer)
{    if (buffer == null) {        return;    }    buffer.append(String.format("%d Errors", processErrors.size()));    for (byte[] outputMessage : processErrors) {        buffer.append(new String(outputMessage, StandardCharsets.UTF_8));    }    buffer.append("\n");}
public List<byte[]> metron_f5688_0()
{    return messages;}
public List<byte[]> metron_f5689_0()
{    return errors;}
public KafkaProcessor metron_f5690_0(String name)
{    this.kafkaComponentName = name;    return this;}
public KafkaProcessor metron_f5691_0(String topicName)
{    this.readTopic = topicName;    return this;}
public KafkaProcessor metron_f5692_0(String topicName)
{    this.errorTopic = topicName;    return this;}
public KafkaProcessor metron_f5693_0(Function<KafkaMessageSet, Boolean> validate)
{    this.validateReadMessages = validate;    return this;}
public KafkaProcessor metron_f5694_0(Function<KafkaMessageSet, T> provide)
{    this.provideResult = provide;    return this;}
public ReadinessState metron_f5695_0(ComponentRunner runner)
{    KafkaComponent kafkaComponent = runner.getComponent(kafkaComponentName, KafkaComponent.class);    LinkedList<byte[]> outputMessages = new LinkedList<>(kafkaComponent.readMessages(readTopic));    LinkedList<byte[]> outputErrors = null;    if (errorTopic != null) {        outputErrors = new LinkedList<>(kafkaComponent.readMessages(errorTopic));    }    Boolean validated = validateReadMessages.apply(new KafkaMessageSet(outputMessages, outputErrors));    if (validated == null) {        validated = false;    }    if (validated) {        messages.addAll(outputMessages);        errors.addAll(outputErrors);        outputMessages.clear();        outputErrors.clear();        return ReadinessState.READY;    }    return ReadinessState.NOT_READY;}
public ProcessorResult<T> metron_f5696_0()
{    ProcessorResult.Builder<T> builder = new ProcessorResult.Builder();    return builder.withResult(provideResult.apply(new KafkaMessageSet(messages, errors))).withProcessErrors(errors).build();}
public static void metron_f5697_0()
{    component = new MRComponent().withBasePath("target");    component.start();    configuration = component.getConfiguration();    try {        FileSystem fs = FileSystem.newInstance(configuration);        fs.mkdirs(new Path("/classpath-resources"));        fs.copyFromLocalFile(new Path("src/test/classpath-resources/custom-1.0-SNAPSHOT.jar"), new Path("/classpath-resources"));    } catch (IOException e) {        throw new RuntimeException("Unable to start cluster", e);    }}
public static void metron_f5698_0()
{    component.stop();}
public static ClasspathFunctionResolver metron_f5699_0(Properties config)
{    ClasspathFunctionResolver resolver = new ClasspathFunctionResolver();    Context context = new Context.Builder().with(Context.Capabilities.STELLAR_CONFIG, () -> config).build();    resolver.initialize(context);    return resolver;}
public void metron_f5700_0() throws Exception
{    Properties config = new Properties();    config.put(STELLAR_VFS_PATHS.param(), configuration.get("fs.defaultFS") + "/classpath-resources/.*.jar");    ClasspathFunctionResolver resolver = create(config);    HashSet<String> functions = new HashSet<>(Lists.newArrayList(resolver.getFunctions()));    Assert.assertTrue(functions.contains("NOW"));}
public static void metron_f5701_0(ThrowingBiConsumer<TestZKServer, CuratorFramework> testFunc) throws Exception
{    try (TestZKServer zkServer = new TestZKServer();        CuratorFramework zkClient = zkServer.newClient()) {        zkClient.start();        testFunc.accept(zkServer, zkClient);    }}
public String metron_f5702_0()
{    return zookeeperUrl;}
public CuratorFramework metron_f5703_0()
{    return ConfigurationsUtils.getClient(zookeeperUrl);}
public void metron_f5704_0()
{    testZkServer.stop();    testZkServer.reset();}
public static void metron_f5705_0(Producer<K, V> producer, K key, V value, String topic)
{    ProducerRecord<K, V> record = new ProducerRecord<K, V>(topic, key, value);    producer.send(record);}
public static void metron_f5706_0(Producer<K, V> producer, Iterable<Map.Entry<K, V>> messages, String topic, long sleepBetween) throws InterruptedException
{    for (Map.Entry<K, V> kv : messages) {        send(producer, kv.getKey(), kv.getValue(), topic);        if (sleepBetween > 0) {            Thread.sleep(sleepBetween);        }    }}
public static void metron_f5707_0(Assertion assertion) throws Exception
{    assertEventually(assertion, MAX_ASSERT_WAIT_MS);}
public static void metron_f5708_0(Assertion assertion, long msToWait) throws Exception
{    long delta = msToWait / 10;    for (int i = 0; i < 10; ++i) {        try {            assertion.apply();            return;        } catch (AssertionError t) {        }        Thread.sleep(delta);    }    assertion.apply();}
public static List<byte[]> metron_f5709_0(String samplePath) throws IOException
{    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(samplePath), StandardCharsets.UTF_8));    List<byte[]> ret = new ArrayList<>();    for (String line = null; (line = br.readLine()) != null; ) {        ret.add(line.getBytes(StandardCharsets.UTF_8));    }    br.close();    return ret;}
public static void metron_f5710_0(File file, String[] contents) throws IOException
{    StringBuilder b = new StringBuilder();    for (String line : contents) {        b.append(line);        b.append(System.lineSeparator());    }    write(file, b.toString());}
public static File metron_f5711_0(File file, String contents) throws IOException
{    com.google.common.io.Files.createParentDirs(file);    com.google.common.io.Files.write(contents, file, StandardCharsets.UTF_8);    return file;}
public static String metron_f5712_0(File in) throws IOException
{    return read(in, StandardCharsets.UTF_8);}
public static String metron_f5713_0(File in, Charset charset) throws IOException
{    byte[] bytes = Files.readAllBytes(Paths.get(in.getPath()));    return new String(bytes, charset);}
public static File metron_f5714_0(String prefix) throws IOException
{    final Path tmpDir = Files.createTempDirectory(prefix);    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            try {                cleanDir(tmpDir);            } catch (IOException e) {                System.out.println("Warning: Unable to clean tmp folder.");            }        }    });    return tmpDir.toFile();}
public void metron_f5715_0()
{    try {        cleanDir(tmpDir);    } catch (IOException e) {        System.out.println("Warning: Unable to clean tmp folder.");    }}
public static void metron_f5716_0(Path dir) throws IOException
{    Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {            if (exc == null) {                return FileVisitResult.CONTINUE;            } else {                throw exc;            }        }    });}
public FileVisitResult metron_f5717_0(Path file, BasicFileAttributes attrs) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f5718_0(Path file, IOException exc) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f5719_0(Path dir, IOException exc) throws IOException
{    if (exc == null) {        return FileVisitResult.CONTINUE;    } else {        throw exc;    }}
public static File metron_f5720_0(File parent, String child)
{    File newDir = new File(parent, child);    newDir.mkdirs();    return newDir;}
public JobStatus metron_f5721_0(String jobId)
{    this.jobId = jobId;    return this;}
public JobStatus metron_f5722_0(State state)
{    this.state = state;    return this;}
public JobStatus metron_f5723_0(double percentComplete)
{    this.percentComplete = percentComplete;    return this;}
public JobStatus metron_f5724_0(String description)
{    this.description = description;    return this;}
public JobStatus metron_f5725_0(long completionTime)
{    this.completionTime = completionTime;    return this;}
public JobStatus metron_f5726_0(Throwable failureReason)
{    this.failureReason = failureReason;    return this;}
public String metron_f5727_0()
{    return jobId;}
public State metron_f5728_0()
{    return state;}
public double metron_f5729_0()
{    return percentComplete;}
public String metron_f5730_0()
{    return description;}
public long metron_f5731_0()
{    return completionTime;}
public Throwable metron_f5732_0()
{    return failureReason;}
public JobStatus metron_f5733_0(Supplier<Statusable<PAGE_T>> jobSupplier, String username) throws JobException
{    Map<String, Statusable<PAGE_T>> userJobs = getUserJobs(username);    Statusable<PAGE_T> job = jobSupplier.get();    userJobs.put(job.getStatus().getJobId(), job);    jobs.put(username, userJobs);    return job.getStatus();}
public JobStatus metron_f5734_0(String username, String jobId) throws JobException
{    return getJob(username, jobId).getStatus();}
public boolean metron_f5735_0(String username, String jobId) throws JobException
{    return getJob(username, jobId).isDone();}
public void metron_f5736_0(String username, String jobId) throws JobException
{    getJob(username, jobId).kill();}
public Statusable<PAGE_T> metron_f5737_0(String username, String jobId) throws JobException
{    Map<String, Statusable<PAGE_T>> jobStatusables = getUserJobs(username);    if (jobStatusables.size() > 0 && jobStatusables.containsKey(jobId)) {        return jobStatusables.get(jobId);    }    throw new JobNotFoundException("Could not find job " + jobId + " for user " + username);}
private Map<String, Statusable<PAGE_T>> metron_f5738_0(String username)
{    return jobs.getOrDefault(username, Collections.synchronizedMap(new HashMap<>()));}
public List<Statusable<PAGE_T>> metron_f5739_0(String username) throws JobException
{    return new ArrayList<>(getUserJobs(username).values());}
public void metron_f5740_0()
{    jobs.clear();}
public void metron_f5741_0()
{    JobStatus original = new JobStatus().withState(State.SUCCEEDED).withCompletionTime(5000).withJobId("abc123").withDescription("All done").withPercentComplete(100.0);    JobStatus copied = new JobStatus(original);    assertThat(copied.getState(), equalTo(State.SUCCEEDED));    assertThat(copied.getCompletionTime(), equalTo(5000L));    assertThat(copied.getJobId(), equalTo("abc123"));    assertThat(copied.getDescription(), equalTo("All done"));    assertThat(copied.getPercentComplete(), equalTo(100.0));}
public void metron_f5742_0()
{    JobException e = new JobException("The job blew up.");    JobStatus original = new JobStatus().withState(State.FAILED).withDescription("Failed").withFailureException(e);    assertThat(original.getFailureReason(), equalTo(e));}
public void metron_f5743_0() throws JobException
{    MockitoAnnotations.initMocks(this);    jm = new InMemoryJobManager<Path>();    config = new HashMap<>();    username1 = "user123";    username2 = "user456";    jobId1 = "job_abc_123";    jobId2 = "job_def_456";    jobId3 = "job_ghi_789";    emptyJobId = "";    basePath = tempDir.getRoot().getAbsolutePath();    when(job1.getJobType()).thenReturn(JobType.MAP_REDUCE);    when(job2.getJobType()).thenReturn(JobType.MAP_REDUCE);    when(job3.getJobType()).thenReturn(JobType.MAP_REDUCE);    when(job1.submit(finalizer, config)).thenReturn(job1);    when(job2.submit(finalizer, config)).thenReturn(job2);    when(job3.submit(finalizer, config)).thenReturn(job3);    when(finalizer.finalizeJob(any())).thenReturn(results);}
public void metron_f5744_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId1));    JobStatus status = jm.submit(newSupplier(job1), username1);    assertThat(status.getState(), equalTo(State.RUNNING));    assertThat(status.getJobId(), equalTo(jobId1));    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1));    status = jm.getStatus(username1, status.getJobId());    assertThat(status.getState(), equalTo(State.SUCCEEDED));    assertThat(status.getJobId(), equalTo(jobId1));}
public void metron_f5745_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId1));    when(job2.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId2));    when(job3.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId3));        jm.submit(newSupplier(job1), username1);    assertThat(jm.getJob(username1, jobId1), equalTo(job1));        jm.submit(newSupplier(job2), username1);    assertThat(jm.getJob(username1, jobId1), equalTo(job1));    assertThat(jm.getJob(username1, jobId2), equalTo(job2));        jm.submit(newSupplier(job3), username1);    assertThat(jm.getJob(username1, jobId1), equalTo(job1));    assertThat(jm.getJob(username1, jobId2), equalTo(job2));    assertThat(jm.getJob(username1, jobId3), equalTo(job3));        jm.submit(newSupplier(job1), username2);    jm.submit(newSupplier(job2), username2);    jm.submit(newSupplier(job3), username2);        assertThat(jm.getJob(username1, jobId1), equalTo(job1));    assertThat(jm.getJob(username1, jobId2), equalTo(job2));    assertThat(jm.getJob(username1, jobId3), equalTo(job3));        assertThat(jm.getJob(username2, jobId1), equalTo(job1));    assertThat(jm.getJob(username2, jobId2), equalTo(job2));    assertThat(jm.getJob(username2, jobId3), equalTo(job3));}
public void metron_f5746_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(emptyJobId));        jm.submit(newSupplier(job1), username1);    assertThat(jm.getJob(username1, emptyJobId), equalTo(job1));        when(job2.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(emptyJobId));    jm.submit(newSupplier(job2), username1);    assertThat(jm.getJob(username1, emptyJobId), equalTo(job2));}
public void metron_f5747_0() throws JobException
{    JobStatus expected = new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1);    when(job1.getStatus()).thenReturn(expected);    jm.submit(newSupplier(job1), username1);    JobStatus status = jm.getStatus(username1, jobId1);    assertThat(status, equalTo(expected));}
public void metron_f5748_0() throws JobException
{    JobStatus expected = new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1);    when(job1.getStatus()).thenReturn(expected);    when(job1.isDone()).thenReturn(true);    jm.submit(newSupplier(job1), username1);    boolean done = jm.done(username1, jobId1);    assertThat(done, equalTo(true));}
public void metron_f5749_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1));    jm.submit(newSupplier(job1), username1);    jm.killJob(username1, jobId1);    verify(job1).kill();}
public void metron_f5750_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId1));    when(job2.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId2));    when(job3.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId3));    jm.submit(newSupplier(job1), username1);    jm.submit(newSupplier(job2), username1);    jm.submit(newSupplier(job3), username1);    jm.submit(newSupplier(job1), username2);    jm.submit(newSupplier(job2), username2);    jm.submit(newSupplier(job3), username2);    List<Statusable<Path>> jobsUser1 = jm.getJobs(username1);    List<Statusable<Path>> jobsUser2 = jm.getJobs(username2);    assertThat("Wrong size", jobsUser1.size(), equalTo(3));    assertThat("Wrong size", jobsUser2.size(), equalTo(3));    assertThat("", jobsUser1.containsAll(Arrays.asList(job1, job2, job3)), equalTo(true));    assertThat("", jobsUser2.containsAll(Arrays.asList(job1, job2, job3)), equalTo(true));}
private Supplier<Statusable<Path>> metron_f5751_0(Statusable<Path> job)
{    return () -> {        try {            return job.submit(finalizer, config);        } catch (JobException e) {            throw new RuntimeException("Something went wrong", e);        }    };}
private static CuratorFramework metron_f5752_0(Context context)
{    Optional<Object> clientOpt = context.getCapability(Context.Capabilities.ZOOKEEPER_CLIENT, true);    if (clientOpt.isPresent()) {        return (CuratorFramework) clientOpt.get();    } else {        throw new IllegalStateException("Missing ZOOKEEPER_CLIENT; zookeeper connection required");    }}
public static T metron_f5753_0(int index, Class<T> clazz, List<Object> args)
{    if (index >= args.size()) {        throw new IllegalArgumentException(format("expected at least %d argument(s), found %d", index + 1, args.size()));    }    return ConversionUtils.convert(args.get(index), clazz);}
private static String metron_f5754_0(Object object)
{    if (object == null) {        return null;    }    try {        return JSONUtils.INSTANCE.toJSON(object, true);    } catch (JsonProcessingException e) {        throw new RuntimeException(e);    }}
public Object metron_f5755_0(List<Object> args, Context context) throws ParseException
{    String result;        String arg0 = getArg(0, String.class, args);    ConfigurationType type = ConfigurationType.valueOf(arg0);    try {        if (GLOBAL == type) {            result = getGlobalConfig(args);        } else if (PROFILER == type) {            result = getProfilerConfig(args);        } else if (ENRICHMENT == type) {            result = getEnrichmentConfig(args);        } else if (INDEXING == type) {            result = getIndexingConfig(args);        } else if (PARSER == type) {            result = getParserConfig(args);        } else {            throw new IllegalArgumentException("Unexpected configuration type: " + type);        }    } catch (Exception e) {        throw new RuntimeException(e);    }    return result;}
private String metron_f5756_0(List<Object> args) throws Exception
{    Map<String, Object> globals = readGlobalConfigFromZookeeper(zkClient);        if (globals == null && emptyIfNotPresent(args)) {        globals = new HashMap<>();    }    return toJSON(globals);}
private String metron_f5757_0(List<Object> args) throws Exception
{        String sensor = getArg(1, String.class, args);    SensorParserConfig sensorConfig = readSensorParserConfigFromZookeeper(sensor, zkClient);        if (sensorConfig == null && emptyIfNotPresent(args)) {        sensorConfig = new SensorParserConfig();    }    return toJSON(sensorConfig);}
private String metron_f5758_0(List<Object> args) throws Exception
{        String sensor = getArg(1, String.class, args);    SensorEnrichmentConfig sensorConfig = readSensorEnrichmentConfigFromZookeeper(sensor, zkClient);        if (sensorConfig == null && emptyIfNotPresent(args)) {        sensorConfig = new SensorEnrichmentConfig();    }    return toJSON(sensorConfig);}
private String metron_f5759_0(List<Object> args) throws Exception
{        String sensor = getArg(1, String.class, args);    Map<String, Object> sensorConfig = readSensorIndexingConfigFromZookeeper(sensor, zkClient);        if (sensorConfig == null && emptyIfNotPresent(args)) {        sensorConfig = Collections.emptyMap();    }    return toJSON(sensorConfig);}
private String metron_f5760_0(List<Object> args) throws Exception
{    ProfilerConfig profilerConfig = readProfilerConfigFromZookeeper(zkClient);        if (profilerConfig == null && emptyIfNotPresent(args)) {        profilerConfig = new ProfilerConfig();    }    return toJSON(profilerConfig);}
private boolean metron_f5761_0(List<Object> args)
{    boolean emptyIfNotPresent = true;    int lastIndex = args.size() - 1;        if (args.size() >= 2 && args.get(lastIndex) instanceof Boolean) {        emptyIfNotPresent = getArg(lastIndex, Boolean.class, args);    }    return emptyIfNotPresent;}
public void metron_f5762_0(Context context)
{    zkClient = getZookeeperClient(context);}
public boolean metron_f5763_0()
{    return initialized;}
public Object metron_f5764_1(List<Object> args, Context context) throws ParseException
{        String arg0 = getArg(0, String.class, args);    ConfigurationType type = ConfigurationType.valueOf(arg0);        String value = getArg(1, String.class, args);    if (value != null) {        CuratorFramework client = getZookeeperClient(context);        try {            if (GLOBAL == type) {                writeGlobalConfigToZookeeper(value.getBytes(StandardCharsets.UTF_8), client);            } else if (PROFILER == type) {                writeProfilerConfigToZookeeper(value.getBytes(StandardCharsets.UTF_8), client);            } else if (ENRICHMENT == type) {                String sensor = getArg(2, String.class, args);                writeSensorEnrichmentConfigToZookeeper(sensor, value.getBytes(StandardCharsets.UTF_8), client);            } else if (INDEXING == type) {                String sensor = getArg(2, String.class, args);                writeSensorIndexingConfigToZookeeper(sensor, value.getBytes(StandardCharsets.UTF_8), client);            } else if (PARSER == type) {                String sensor = getArg(2, String.class, args);                writeSensorParserConfigToZookeeper(sensor, value.getBytes(StandardCharsets.UTF_8), client);            }        } catch (Exception e) {                        throw new ParseException(e.getMessage());        }    }    return null;}
public void metron_f5765_0(Context context)
{}
public boolean metron_f5766_0()
{    return true;}
public static Map<String, Object> metron_f5767_0(EnrichmentConfig enrichmentConfig)
{    Map<String, Object> fieldMap = enrichmentConfig.getFieldMap();    Map<String, Object> stellarHandler = (Map<String, Object>) fieldMap.getOrDefault("stellar", new HashMap<>());    fieldMap.put("stellar", stellarHandler);    stellarHandler.putIfAbsent("config", new LinkedHashMap<String, Object>());    return stellarHandler;}
public static EnrichmentConfig metron_f5768_0(SensorEnrichmentConfig sensorConfig, Type type)
{    EnrichmentConfig enrichmentConfig = null;    switch(type) {        case ENRICHMENT:            enrichmentConfig = sensorConfig.getEnrichment();            break;        case THREAT_INTEL:        case THREATINTEL:            enrichmentConfig = sensorConfig.getThreatIntel();    }    return enrichmentConfig;}
public Object metron_f5769_0(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    SensorEnrichmentConfig configObj;    String[] headers = new String[] { "Group", "Field", "Transformation" };    if (config == null || config.isEmpty()) {        return FlipTable.of(headers, new String[0][3]);    } else {        configObj = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    }    Type type = Type.valueOf((String) args.get(1));    EnrichmentConfig enrichmentConfig = getConfig(configObj, type);    Map<String, Object> stellarHandler = getStellarHandler(enrichmentConfig);    Map<String, Object> transforms = (Map<String, Object>) stellarHandler.get("config");    List<String[]> objs = new ArrayList<>();    for (Map.Entry<String, Object> kv : transforms.entrySet()) {        if (kv.getValue() instanceof Map) {            Map<String, String> groupMap = (Map<String, String>) kv.getValue();            for (Map.Entry<String, String> groupKv : groupMap.entrySet()) {                objs.add(new String[] { kv.getKey(), groupKv.getKey(), groupKv.getValue().toString() });            }        } else {            objs.add(new String[] { "(default)", kv.getKey(), kv.getValue().toString() });        }    }    String[][] data = new String[objs.size()][3];    for (int i = 0; i < objs.size(); ++i) {        data[i] = objs.get(i);    }    return FlipTable.of(headers, data);}
public void metron_f5770_0(Context context)
{}
public boolean metron_f5771_0()
{    return true;}
public Object metron_f5772_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    SensorEnrichmentConfig configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    }    Type type = Type.valueOf((String) args.get(i++));    EnrichmentConfig enrichmentConfig = getConfig(configObj, type);    Map<String, Object> stellarHandler = getStellarHandler(enrichmentConfig);    Map<String, String> transformsToAdd = (Map<String, String>) args.get(i++);    String group = null;    if (i < args.size()) {        group = (String) args.get(i++);    }    Map<String, Object> baseTransforms = (Map<String, Object>) stellarHandler.get("config");    Map<String, Object> groupMap = baseTransforms;    if (group != null) {        groupMap = (Map<String, Object>) baseTransforms.getOrDefault(group, new LinkedHashMap<>());        baseTransforms.put(group, groupMap);    }    for (Map.Entry<String, String> kv : transformsToAdd.entrySet()) {        groupMap.put(kv.getKey(), kv.getValue());    }    if (group != null && groupMap.isEmpty()) {        baseTransforms.remove(group);    }    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public void metron_f5773_0(Context context)
{}
public boolean metron_f5774_0()
{    return true;}
public Object metron_f5775_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    SensorEnrichmentConfig configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    }    Type type = Type.valueOf((String) args.get(i++));    EnrichmentConfig enrichmentConfig = getConfig(configObj, type);    Map<String, Object> stellarHandler = getStellarHandler(enrichmentConfig);    List<String> removals = (List<String>) args.get(i++);    String group = null;    if (i < args.size()) {        group = (String) args.get(i++);    }    Map<String, Object> baseTransforms = (Map<String, Object>) stellarHandler.get("config");    Map<String, Object> groupMap = baseTransforms;    if (group != null) {        groupMap = (Map<String, Object>) baseTransforms.getOrDefault(group, new LinkedHashMap<>());        baseTransforms.put(group, groupMap);    }    for (String remove : removals) {        groupMap.remove(remove);    }    if (group != null && groupMap.isEmpty()) {        baseTransforms.remove(group);    }    if (baseTransforms.isEmpty()) {        enrichmentConfig.getFieldMap().remove("stellar");    }    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public void metron_f5776_0(Context context)
{}
public boolean metron_f5777_0()
{    return true;}
public FileSystem metron_f5778_0() throws IOException
{    return _func.getSystem();}
public void metron_f5779_1(Context context)
{    try {        fs = getter.getSystem();    } catch (IOException e) {        String message = "Unable to get FileSystem: " + e.getMessage();                throw new IllegalStateException(message, e);    }}
public boolean metron_f5780_0()
{    return fs != null;}
public Object metron_f5781_1(List<Object> args, Context context) throws ParseException
{    String path = (String) args.get(0);    if (path == null) {        return null;    }    try (FSDataInputStream is = fs.open(new Path(path))) {        return IOUtils.readLines(is);    } catch (IOException e) {        String message = "Unable to read " + path + ": " + e.getMessage();                return null;    }}
public Object metron_f5782_1(List<Object> args, Context context) throws ParseException
{    String path = (String) args.get(0);    if (path == null) {        return null;    }    try (FSDataInputStream is = fs.open(new Path(path))) {        return IOUtils.toString(is);    } catch (IOException e) {        String message = "Unable to read " + path + ": " + e.getMessage();                return null;    }}
public Object metron_f5783_1(List<Object> args, Context context) throws ParseException
{    String path = (String) args.get(0);    if (path == null) {        return false;    }    boolean recursive = false;    if (args.size() > 1) {        recursive = ConversionUtils.convert(args.get(1), Boolean.class);    }    try {        fs.delete(new Path(path), recursive);        return true;    } catch (IOException e) {        String message = "Unable to remove " + path + (recursive ? " recursively" : "") + ": " + e.getMessage();                return false;    }}
public Object metron_f5784_1(List<Object> args, Context context) throws ParseException
{    String content = (String) args.get(0);    if (content == null) {        return false;    }    String path = (String) args.get(1);    if (path == null) {        return false;    }    try (FSDataOutputStream os = fs.create(new Path(path))) {        os.writeBytes(content);        os.flush();        return true;    } catch (IOException e) {        String message = "Unable to write " + path + ": " + e.getMessage();                return false;    }}
protected DateFormat metron_f5785_0()
{    return DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.getDefault());}
public Object metron_f5786_1(List<Object> args, Context context) throws ParseException
{    Path path = null;    String[] headers = new String[] { "PERMISSION", "OWNER", "GROUP", "SIZE", "LAST MOD TIME", "NAME" };    if (args.size() == 0) {        path = fs.getHomeDirectory();    } else {        String pathStr = (String) args.get(0);        if (pathStr == null) {            return FlipTable.of(headers, new String[][] {});        } else {            try {                path = new Path(pathStr);            } catch (IllegalArgumentException iae) {                                return FlipTable.of(headers, new String[][] {});            }        }    }    try {        List<String[]> dataList = new ArrayList<>();        for (FileStatus status : fs.listStatus(path)) {            dataList.add(new String[] { status.getPermission().toString(), status.getOwner(), status.getGroup(), status.getLen() + "", dateFormat.get().format(new Date(status.getModificationTime())), status.getPath().getName() });        }        Collections.sort(dataList, (o1, o2) -> {            try {                Date left = dateFormat.get().parse(o1[4]);                Date right = dateFormat.get().parse(o2[4]);                int ret = left.compareTo(right);                                if (ret == 0) {                    return o1[5].compareTo(o2[5]);                } else {                    return ret;                }            } catch (java.text.ParseException e) {                String message = "Unable to parse " + Arrays.toString(o1) + " or " + Arrays.toString(o2) + " : " + e.getMessage();                                throw new IllegalStateException(message, e);            }        });        String[][] data = new String[dataList.size()][headers.length];        for (int i = 0; i < dataList.size(); ++i) {            data[i] = dataList.get(i);        }        return FlipTable.of(headers, data);    } catch (IOException e) {        String message = "Unable to list" + path + " : " + e.getMessage();                return FlipTable.of(headers, new String[][] {});    }}
public static T metron_f5787_0(String argName, int index, Class<T> clazz, List<Object> args) throws ParseException
{    if (index >= args.size()) {        String msg = format("missing '%s'; expected at least %d argument(s), found %d", argName, index + 1, args.size());        throw new ParseException(msg);    }    return ConversionUtils.convert(args.get(index), clazz);}
public static boolean metron_f5788_0(String argName, int index, Class<T> clazz, List<Object> args)
{    boolean result = false;    if (args.size() > index) {        if (clazz.isAssignableFrom(args.get(index).getClass())) {            return true;        }    }    return result;}
public static CuratorFramework metron_f5789_0(Context context) throws ParseException
{    return context.getCapability(ZOOKEEPER_CLIENT, false).filter(CuratorFramework.class::isInstance).map(CuratorFramework.class::cast).orElseThrow(() -> new ParseException("Missing ZOOKEEPER_CLIENT; zookeeper connection required"));}
private static Grok metron_f5790_0(String grokExpr) throws GrokException
{    Grok grok = new Grok();    InputStream input = GrokFunctions.class.getResourceAsStream("/patterns/common");    if (input != null) {        grok.addPatternFromReader(new InputStreamReader(input, StandardCharsets.UTF_8));    }    if (grokExpr != null) {        grok.addPatternFromReader(new StringReader("pattern " + grokExpr));        grok.compile("%{pattern}");    }    return grok;}
public Object metron_f5791_1(List<Object> args, Context context) throws ParseException
{    String grokExpression = (String) args.get(0);    Object arg = args.get(1);    if (grokExpression == null || arg == null) {        return null;    }    List<String> strs = null;    if (arg instanceof List) {        strs = (List<String>) arg;    } else if (arg instanceof String) {        strs = new ArrayList<>();        strs.add((String) arg);    } else {        return null;    }    Grok grok = null;    try {        grok = getGrok(grokExpression);    } catch (GrokException e) {                return null;    }    List<Map<String, Object>> outputMap = new ArrayList<>();    Set<String> keys = new TreeSet<>();    for (String str : strs) {        Match m = grok.match(str);        m.captures();        Map<String, Object> ret = m.toMap();        if (ret != null && ret.isEmpty()) {            outputMap.add(new HashMap<>());        } else {            ret.remove("pattern");            keys.addAll(ret.keySet());            outputMap.add(ret);        }    }    if (keys.isEmpty()) {        return "NO MATCH";    }    String[] headers = new String[keys.size()];    String[][] data = new String[outputMap.size()][keys.size()];    {        int i = 0;        for (String key : keys) {            headers[i++] = key;        }    }    int rowNum = 0;    for (Map<String, Object> output : outputMap) {        String[] row = new String[keys.size()];        int colNum = 0;        for (String key : keys) {            row[colNum++] = "" + output.getOrDefault(key, "MISSING");        }        data[rowNum++] = row;    }    return FlipTable.of(headers, data);}
public void metron_f5792_0(Context context)
{}
public boolean metron_f5793_0()
{    return true;}
public Object metron_f5794_1(List<Object> args, Context context) throws ParseException
{    String str = (String) args.get(0);    if (str == null) {        return null;    }    Grok grok = null;    try {        grok = getGrok(null);    } catch (GrokException e) {                return null;    }    return grok.discover(str);}
public void metron_f5795_0(Context context)
{}
public boolean metron_f5796_0()
{    return true;}
public Object metron_f5797_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    Map<String, Object> configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (Map<String, Object>) INDEXING.deserialize(config);    }    String writer = null;    if (args.size() > 1) {        writer = ConversionUtils.convert(args.get(i++), String.class);        if (!configObj.containsKey(writer)) {            configObj.put(writer, new HashMap<String, Object>());        }    }    if (writer == null) {        throw new IllegalStateException("Invalid writer name: " + config);    }    int batchSize = 1;    if (args.size() > 2) {        batchSize = ConversionUtils.convert(args.get(i++), Integer.class);        if (batchSize < 1) {            throw new IllegalArgumentException("Invalid batch size must be >= 1 : " + Integer.toString(batchSize));        }    }    configObj.put(writer, IndexingConfigurations.setBatchSize((Map<String, Object>) configObj.get(writer), batchSize));    int batchTimeout = 0;    if (args.size() > 3) {        batchTimeout = ConversionUtils.convert(args.get(i++), Integer.class);    }    configObj.put(writer, IndexingConfigurations.setBatchTimeout((Map<String, Object>) configObj.get(writer), batchTimeout));    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public void metron_f5798_0(Context context)
{}
public boolean metron_f5799_0()
{    return true;}
public Object metron_f5800_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    Map<String, Object> configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (Map<String, Object>) INDEXING.deserialize(config);    }    String writer = null;    if (args.size() > 1) {        writer = ConversionUtils.convert(args.get(i++), String.class);        if (!configObj.containsKey(writer)) {            configObj.put(writer, new HashMap<String, Object>());        }    }    if (writer == null) {        throw new IllegalStateException("Invalid writer name: " + config);    }    boolean enabled = true;    if (args.size() > 2) {        enabled = ConversionUtils.convert(args.get(i++), Boolean.class);    }    configObj.put(writer, IndexingConfigurations.setEnabled((Map<String, Object>) configObj.get(writer), enabled));    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public void metron_f5801_0(Context context)
{}
public boolean metron_f5802_0()
{    return true;}
public Object metron_f5803_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    Map<String, Object> configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (Map<String, Object>) INDEXING.deserialize(config);    }    String writer = null;    if (args.size() > 1) {        writer = ConversionUtils.convert(args.get(i++), String.class);        if (!configObj.containsKey(writer)) {            configObj.put(writer, new HashMap<String, Object>());        }    }    if (writer == null) {        throw new IllegalStateException("Invalid writer name: " + config);    }    String sensorName = ConversionUtils.convert(args.get(i++), String.class);    if (sensorName == null) {        throw new IllegalStateException("Invalid sensor name: " + config);    }    configObj.put(writer, IndexingConfigurations.setIndex((Map<String, Object>) configObj.get(writer), sensorName));    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public void metron_f5804_0(Context context)
{}
public boolean metron_f5805_0()
{    return true;}
public Object metron_f5806_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);        int count = 1;    if (args.size() > 1) {        count = getArg("count", 1, Integer.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 2) {        overrides = getArg("overrides", 2, Map.class, args);    }        Properties properties = buildKafkaProperties(overrides, context);    properties.put("max.poll.records", count);    return getMessages(topic, count, properties);}
public void metron_f5808_0(Context context)
{}
public boolean metron_f5809_0()
{        return true;}
public Object metron_f5810_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);        int count = 1;    if (args.size() > 1) {        count = getArg("count", 1, Integer.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 2) {        overrides = getArg("overrides", 2, Map.class, args);    }    Properties properties = buildKafkaProperties(overrides, context);    properties.put("max.poll.records", count);    return tailMessages(topic, count, properties);}
public void metron_f5812_0(Context context)
{}
public boolean metron_f5813_0()
{        return true;}
public Object metron_f5814_0(List<Object> args, Context context) throws ParseException
{    String topic = ConversionUtils.convert(args.get(0), String.class);    List<String> messages;    if (args.get(1) instanceof String) {                String msg = getArg("message(s)", 1, String.class, args);        messages = Collections.singletonList(msg);    } else {                messages = getArg("message(s)", 1, List.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 2) {        overrides = getArg("overrides", 2, Map.class, args);    }        Properties properties = buildKafkaProperties(overrides, context);    List<RecordMetadata> records = putMessages(topic, messages, properties);        Object view = render(records, properties);    return view;}
private Object metron_f5815_0(List<RecordMetadata> records, Properties properties)
{    Object view;    if (MESSAGE_VIEW_RICH.equals(getMessageView(properties))) {                List<Object> responses = new ArrayList<>();        for (RecordMetadata record : records) {                        Map<String, Object> richView = new HashMap<>();            richView.put("topic", record.topic());            richView.put("partition", record.partition());            richView.put("offset", record.offset());            richView.put("timestamp", record.timestamp());            responses.add(richView);        }                view = responses;    } else {                view = CollectionUtils.size(records);    }    return view;}
public void metron_f5818_0(Context context)
{}
public boolean metron_f5819_0()
{        return true;}
public Object metron_f5820_0(List<Object> args, Context context) throws ParseException
{        Map<String, String> overrides = new HashMap<>();    if (args.size() > 0) {        overrides = getArg("overrides", 0, Map.class, args);    }    return buildKafkaProperties(overrides, context);}
public void metron_f5821_0(Context context)
{}
public boolean metron_f5822_0()
{        return true;}
public Object metron_f5823_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);        LambdaExpression filter = getArg("filter", 1, LambdaExpression.class, args);        int count = 1;    if (args.size() > 2) {        count = getArg("count", 2, Integer.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 3) {        overrides = getArg("overrides", 3, Map.class, args);    }    Properties properties = buildKafkaProperties(overrides, context);    properties.put("max.poll.records", 10 * count);    return findMessages(topic, filter, count, properties);}
public boolean metron_f5825_1(LambdaExpression expr, String message)
{    boolean result = false;    Map<String, Object> messageAsMap;    try {                messageAsMap = JSONUtils.INSTANCE.load(message, JSONUtils.MAP_SUPPLIER);                Object out = expr.apply(Collections.singletonList(messageAsMap));        if (out instanceof Boolean) {            result = (Boolean) out;        } else {                    }    } catch (IOException e) {            }    return result;}
public void metron_f5826_0(Context context)
{}
public boolean metron_f5827_0()
{        return true;}
public Object metron_f5828_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);    int partition = getArg("partition", 1, Integer.class, args);    int offset = getArg("offset", 2, Integer.class, args);        Map<String, String> overrides = new HashMap<>();    if (args.size() > 3) {        overrides = getArg("overrides", 3, Map.class, args);    }    Properties properties = buildKafkaProperties(overrides, context);    return seek(topic, partition, offset, properties);}
public void metron_f5830_0(Context context)
{}
public boolean metron_f5831_0()
{        return true;}
private static Set<TopicPartition> metron_f5833_0(String topic, KafkaConsumer<String, String> consumer)
{        Set<TopicPartition> partitions = new HashSet<>();    for (PartitionInfo partition : consumer.partitionsFor(topic)) {        partitions.add(new TopicPartition(topic, partition.partition()));    }    if (partitions.size() == 0) {        throw new IllegalStateException(format("No partitions available for consumer assignment; topic=%s", topic));    }        consumer.assign(partitions);    return partitions;}
private static Properties metron_f5834_0(Map<String, String> overrides, Context context)
{        Properties properties = new Properties();    properties.putAll(defaultProperties);        Optional<Object> globalCapability = context.getCapability(GLOBAL_CONFIG, false);    if (globalCapability.isPresent()) {        Map<String, Object> global = (Map<String, Object>) globalCapability.get();        properties.putAll(global);    }        properties.putAll(overrides);    return properties;}
private static int metron_f5835_0(Properties properties)
{    int maxWait = DEFAULT_MAX_WAIT;    Object value = properties.get(MAX_WAIT_PROPERTY);    if (value != null) {        maxWait = ConversionUtils.convert(value, Integer.class);    }    return maxWait;}
private static int metron_f5836_0(Properties properties)
{    int pollTimeout = DEFAULT_POLL_TIMEOUT;    Object value = properties.get(POLL_TIMEOUT_PROPERTY);    if (value != null) {        pollTimeout = ConversionUtils.convert(value, Integer.class);    }    return pollTimeout;}
private static String metron_f5837_0(Properties properties)
{        String messageView = MESSAGE_VIEW_SIMPLE;    if (properties.containsKey(MESSAGE_VIEW_PROPERTY)) {        messageView = ConversionUtils.convert(properties.get(MESSAGE_VIEW_PROPERTY), String.class);    }    return messageView;}
private static Properties metron_f5838_0()
{    Properties properties = new Properties();    properties.put("bootstrap.servers", "localhost:9092");    properties.put("group.id", "kafka-functions-stellar");    /*     * What to do when there is no initial offset in Kafka or if the current     * offset does not exist any more on the server (e.g. because that data has been deleted):     *     *  "earliest": automatically reset the offset to the earliest offset     *  "latest": automatically reset the offset to the latest offset     *  "none": throw exception to the consumer if no previous offset is found or the consumer's group     *  anything else: throw exception to the consumer.     */    properties.put("auto.offset.reset", "latest");        properties.put("max.poll.records", 1);        properties.put("key.deserializer", StringDeserializer.class.getName());    properties.put("value.deserializer", StringDeserializer.class.getName());        properties.put("key.serializer", StringSerializer.class.getName());    properties.put("value.serializer", StringSerializer.class.getName());        properties.put(MAX_WAIT_PROPERTY, DEFAULT_MAX_WAIT);        properties.put(POLL_TIMEOUT_PROPERTY, DEFAULT_POLL_TIMEOUT);        properties.put(MESSAGE_VIEW_PROPERTY, MESSAGE_VIEW_SIMPLE);    return properties;}
private static void metron_f5839_0(SensorParserConfig config)
{    List<FieldTransformer> toRemove = new ArrayList<>();    List<FieldTransformer> fieldTransformations = config.getFieldTransformations();    for (FieldTransformer transformer : fieldTransformations) {        if (transformer.getFieldTransformation().getClass().getName().equals(FieldTransformations.STELLAR.getMappingClass().getName()) && transformer.getConfig().isEmpty()) {            toRemove.add(transformer);        }    }    for (FieldTransformer t : toRemove) {        fieldTransformations.remove(t);    }}
private static FieldTransformer metron_f5840_0(SensorParserConfig config)
{    List<FieldTransformer> fieldTransformations = config.getFieldTransformations();    FieldTransformer stellarTransformer = null;    for (FieldTransformer transformer : fieldTransformations) {        if (transformer.getFieldTransformation().getClass().getName().equals(FieldTransformations.STELLAR.getMappingClass().getName())) {            stellarTransformer = transformer;        }    }    if (stellarTransformer == null) {        stellarTransformer = new FieldTransformer();        stellarTransformer.setConfig(new LinkedHashMap<>());        stellarTransformer.setTransformation(FieldTransformations.STELLAR.toString());        fieldTransformations.add(stellarTransformer);    }    return stellarTransformer;}
public Object metron_f5841_0(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    if (config == null) {        return null;    }    SensorParserConfig configObj = (SensorParserConfig) PARSER.deserialize(config);    FieldTransformer stellarTransformer = getStellarTransformer(configObj);    String[] headers = new String[] { "Field", "Transformation" };    String[][] data = new String[stellarTransformer.getConfig().size()][2];    int i = 0;    for (Map.Entry<String, Object> kv : stellarTransformer.getConfig().entrySet()) {        data[i++] = new String[] { kv.getKey(), kv.getValue().toString() };    }    return FlipTable.of(headers, data);}
public void metron_f5842_0(Context context)
{}
public boolean metron_f5843_0()
{    return true;}
public Object metron_f5844_1(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    if (config == null) {        return null;    }    SensorParserConfig configObj = (SensorParserConfig) PARSER.deserialize(config);    FieldTransformer stellarTransformer = getStellarTransformer(configObj);    List<String> removals = (List<String>) args.get(1);    if (removals == null || removals.isEmpty()) {        return config;    }    for (String removal : removals) {        stellarTransformer.getConfig().remove(removal);    }    List<String> output = new ArrayList<>();    output.addAll(stellarTransformer.getConfig().keySet());    stellarTransformer.setOutput(output);    pruneEmptyStellarTransformers(configObj);    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public void metron_f5845_0(Context context)
{}
public boolean metron_f5846_0()
{    return true;}
public Object metron_f5847_1(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    if (config == null) {        return null;    }    SensorParserConfig configObj = (SensorParserConfig) PARSER.deserialize(config);    FieldTransformer stellarTransformer = getStellarTransformer(configObj);    Map<String, String> additionalTransforms = (Map<String, String>) args.get(1);    if (additionalTransforms == null || additionalTransforms.isEmpty()) {        return config;    }    for (Map.Entry<String, String> kv : additionalTransforms.entrySet()) {        stellarTransformer.getConfig().put(kv.getKey(), kv.getValue());    }    List<String> output = new ArrayList<>();    output.addAll(stellarTransformer.getConfig().keySet());    stellarTransformer.setOutput(output);    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public void metron_f5848_0(Context context)
{}
public boolean metron_f5849_0()
{    return true;}
public Object metron_f5850_0(List<Object> args, Context context) throws ParseException
{    String sensorType = getArg("sensorType", 0, String.class, args);    StellarParserRunner parser = new StellarParserRunner(sensorType);        String configArgName = "config";    if (args.size() == 1) {                SensorParserConfig config = readFromZookeeper(context, sensorType);        parser.withParserConfiguration(sensorType, config);    } else if (hasArg(configArgName, 1, String.class, args)) {                String arg = getArg(configArgName, 1, String.class, args);        parser.withParserConfiguration(arg);    } else if (hasArg(configArgName, 1, Map.class, args)) {                Map<String, Object> arg = getArg(configArgName, 1, Map.class, args);        parser.withParserConfiguration(arg);    } else {        throw new ParseException(format("unexpected '%s' argument; expected string or map", configArgName));    }        if (hasArg("globals", 1, Map.class, args)) {        Map<String, Object> globals = getArg("globals", 1, Map.class, args);        parser.withGlobals(globals);    }    return parser;}
private SensorParserConfig metron_f5851_0(Context context, String sensorType) throws ParseException
{    SensorParserConfig config;    try {        CuratorFramework zkClient = getZookeeperClient(context);        config = readSensorParserConfigFromZookeeper(sensorType, zkClient);    } catch (Exception e) {        throw new ParseException(ExceptionUtils.getRootCauseMessage(e), e);    }    if (config == null) {        throw new ParseException("Unable to read configuration from Zookeeper; sensorType = " + sensorType);    }    return config;}
public void metron_f5852_0(Context context)
{}
public boolean metron_f5853_0()
{    return true;}
public Object metron_f5854_0(List<Object> args, Context context) throws ParseException
{    StellarParserRunner parser = getArg("parser", 0, StellarParserRunner.class, args);    parser.withContext(context);    List<String> messages = getMessages(args);    return parser.parse(messages);}
private List<String> metron_f5855_0(List<Object> args)
{    String inputArgName = "input";    List<String> messages = new ArrayList<>();    if (hasArg(inputArgName, 1, String.class, args)) {                String msg = getArg(inputArgName, 1, String.class, args);        messages.add(msg);    } else if (hasArg(inputArgName, 1, List.class, args)) {                List<Object> arg1 = getArg(inputArgName, 1, List.class, args);        for (Object object : arg1) {            String msg = String.class.cast(object);            messages.add(msg);        }    } else {        throw new IllegalArgumentException(format("Expected a string or list of strings to parse."));    }    return messages;}
public void metron_f5856_0(Context context)
{}
public boolean metron_f5857_0()
{    return true;}
public Object metron_f5858_0(List<Object> args)
{    StellarParserRunner parser = getArg("parser", 0, StellarParserRunner.class, args);    return parser.toJSON();}
public List<JSONObject> metron_f5859_0(List<String> messages)
{    if (parserConfigurations == null) {        throw new IllegalArgumentException("Missing required parser configuration");    }    if (context == null) {        throw new IllegalArgumentException("Missing required context");    }    return doParse(messages);}
private List<JSONObject> metron_f5860_0(List<String> messages)
{        HashSet<String> sensorTypes = new HashSet<>();    sensorTypes.add(sensorType);    ParserRunnerImpl runner = new ParserRunnerImpl(sensorTypes);    runner.init(() -> parserConfigurations, context);        List<ParserRunnerResults<JSONObject>> results = messages.stream().map(str -> str.getBytes(StandardCharsets.UTF_8)).map(bytes -> DEFAULT.get(emptyMap(), bytes, false, emptyMap())).map(msg -> runner.execute(sensorType, msg, parserConfigurations)).collect(Collectors.toList());        List<JSONObject> successes = results.stream().flatMap(result -> result.getMessages().stream()).collect(Collectors.toList());    successCount += successes.size();    List<JSONObject> errors = results.stream().flatMap(result -> result.getErrors().stream()).map(err -> err.getJSONObject()).collect(Collectors.toList());    errorCount += errors.size();        successes.addAll(errors);    return successes;}
public StellarParserRunner metron_f5861_0(String sensorConfig)
{    parserConfigurations = create(sensorConfig.getBytes(StandardCharsets.UTF_8));    return this;}
public StellarParserRunner metron_f5862_0(Map<String, Object> config)
{    parserConfigurations = create(new JSONObject(config).toJSONString().getBytes(StandardCharsets.UTF_8));    return this;}
public StellarParserRunner metron_f5863_0(String sensorType, SensorParserConfig config)
{    parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig(sensorType, config);    return this;}
public StellarParserRunner metron_f5864_0(Context context)
{    this.context = context;    return this;}
public StellarParserRunner metron_f5865_0(Map<String, Object> globals)
{    parserConfigurations.updateGlobalConfig(globals);    return this;}
public String metron_f5866_0()
{    try {        return parserConfigurations.getSensorParserConfig(sensorType).toJSON();    } catch (JsonProcessingException e) {        throw new RuntimeException(e);    }}
public ParserConfigurations metron_f5867_0()
{    return parserConfigurations;}
private ParserConfigurations metron_f5868_0(byte[] sensorConfig)
{    try {        ParserConfigurations result = new ParserConfigurations();        result.updateSensorParserConfig(sensorType, SensorParserConfig.fromBytes(sensorConfig));        return result;    } catch (IOException e) {        throw new IllegalArgumentException(e);    }}
public String metron_f5869_0()
{        return String.format("Parser{%d successful, %d error(s)}", successCount, errorCount);}
public Object metron_f5870_0(List<Object> args, Context context) throws ParseException
{    ThreatTriageProcessor processor;    SensorEnrichmentConfig config = new SensorEnrichmentConfig();        if (args.size() > 0) {        String json = Util.getArg(0, String.class, args);        if (json != null) {            config = (SensorEnrichmentConfig) ENRICHMENT.deserialize(json);        } else {            throw new IllegalArgumentException(format("Invalid configuration: unable to deserialize '%s'", json));        }    }    processor = new ThreatTriageProcessor(config, new ClasspathFunctionResolver(), context);    return processor;}
public void metron_f5871_0(Context context)
{}
public boolean metron_f5872_0()
{    return true;}
public Object metron_f5873_0(List<Object> args, Context context) throws ParseException
{        String arg0 = Util.getArg(0, String.class, args);    if (arg0 == null) {        throw new IllegalArgumentException(format("expected string, got null"));    }        JSONObject message;    try {        message = (JSONObject) parser.parse(arg0);    } catch (org.json.simple.parser.ParseException e) {        throw new IllegalArgumentException("invalid message", e);    }        ThreatTriageProcessor processor = Util.getArg(1, ThreatTriageProcessor.class, args);    if (processor == null) {        throw new IllegalArgumentException(format("expected threat triage engine; got null"));    }    ThreatScore score = processor.apply(message);    return transform(score, processor.getSensorConfig());}
private Map<String, Object> metron_f5874_0(ThreatScore score, SensorEnrichmentConfig config)
{    List<Map<String, Object>> scores = new ArrayList<>();    for (RuleScore ruleScore : score.getRuleScores()) {                Map<String, Object> map = new HashMap<>();        if (ruleScore.getRule().getName() != null) {            map.put(RULE_NAME_KEY, ruleScore.getRule().getName());        }        if (ruleScore.getRule().getRule() != null) {            map.put(RULE_EXPR_KEY, ruleScore.getRule().getRule());        }        if (ruleScore.getRule().getScoreExpression() != null) {            map.put(RULE_SCORE_KEY, ruleScore.getRule().getScoreExpression());        }        if (ruleScore.getReason() != null) {            map.put(RULE_REASON_KEY, ruleScore.getReason());        }        if (ruleScore.getRule().getComment() != null) {            map.put(RULE_COMMENT_KEY, ruleScore.getRule().getComment());        }        scores.add(map);    }        Map<String, Object> result = new HashMap<>();    result.put(SCORE_KEY, score.getScore());    result.put(RULES_KEY, scores);    result.put(AGG_KEY, config.getThreatIntel().getTriageConfig().getAggregator().toString());    return result;}
public void metron_f5875_0(Context context)
{    parser = new JSONParser();}
public boolean metron_f5876_0()
{    return parser != null;}
public Object metron_f5877_0(List<Object> args, Context context) throws ParseException
{        ThreatTriageProcessor processor = Util.getArg(0, ThreatTriageProcessor.class, args);    if (processor == null) {        throw new IllegalArgumentException(format("expected threat triage engine; got null"));    }        SensorEnrichmentConfig config = processor.getSensorConfig();    return toJSON(config);}
public void metron_f5878_0(Context context)
{}
public boolean metron_f5879_0()
{    return true;}
public Object metron_f5880_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        return "";    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        return "";    }        List<RiskLevelRule> triageRules = ListUtils.emptyIfNull(triageConfig.getRiskLevelRules());    String[] headers = new String[] { "Name", "Comment", "Triage Rule", "Score", "Reason" };    String[][] data = new String[triageRules.size()][5];    int i = 0;    for (RiskLevelRule rule : triageRules) {        String score = rule.getScoreExpression();        String name = Optional.ofNullable(rule.getName()).orElse("");        String comment = Optional.ofNullable(rule.getComment()).orElse("");        String reason = Optional.ofNullable(rule.getReason()).orElse("");        data[i++] = new String[] { name, comment, rule.getRule(), score, reason };    }    String ret = FlipTable.of(headers, data);        if (!triageRules.isEmpty()) {        ret += "Aggregation: " + triageConfig.getAggregator().name();    }    return ret;}
public void metron_f5881_0(Context context)
{}
public boolean metron_f5882_0()
{    return true;}
public Object metron_f5883_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        tiConfig = new ThreatIntelConfig();        config.setThreatIntel(tiConfig);    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        triageConfig = new org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig();        tiConfig.setTriageConfig(triageConfig);    }        List<RiskLevelRule> newRules = new ArrayList<>();    for (Map<String, Object> newRule : getNewRuleDefinitions(args)) {        if (newRule != null && newRule.containsKey("rule") && newRule.containsKey("score")) {                        RiskLevelRule ruleToAdd = new RiskLevelRule();            ruleToAdd.setRule((String) newRule.get(RULE_EXPR_KEY));            ruleToAdd.setScoreExpression(newRule.get(RULE_SCORE_KEY));                        if (newRule.containsKey(RULE_NAME_KEY)) {                ruleToAdd.setName((String) newRule.get(RULE_NAME_KEY));            }            if (newRule.containsKey(RULE_COMMENT_KEY)) {                ruleToAdd.setComment((String) newRule.get(RULE_COMMENT_KEY));            }            if (newRule.containsKey(RULE_REASON_KEY)) {                ruleToAdd.setReason((String) newRule.get(RULE_REASON_KEY));            }            newRules.add(ruleToAdd);        }    }        List<RiskLevelRule> allRules = ListUtils.union(triageConfig.getRiskLevelRules(), newRules);    triageConfig.setRiskLevelRules(allRules);    return toJSON(config);}
private List<Map<String, Object>> metron_f5884_0(List<Object> args)
{    List<Map<String, Object>> newRules = new ArrayList<>();    Object arg1 = Util.getArg(1, Object.class, args);    if (arg1 instanceof Map) {        newRules.add((Map<String, Object>) arg1);    } else if (arg1 instanceof List) {        newRules.addAll((List<Map<String, Object>>) arg1);    } else {        throw new IllegalArgumentException(String.format("triage rule expected to be map or list, got %s", ClassUtils.getShortClassName(arg1, "null")));    }    return newRules;}
public void metron_f5885_0(Context context)
{}
public boolean metron_f5886_0()
{    return true;}
public Object metron_f5887_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        tiConfig = new ThreatIntelConfig();        config.setThreatIntel(tiConfig);    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        triageConfig = new org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig();        tiConfig.setTriageConfig(triageConfig);    }    List<RiskLevelRule> triageRules = triageConfig.getRiskLevelRules();    if (triageRules == null) {        triageRules = new ArrayList<>();        triageConfig.setRiskLevelRules(triageRules);    }    Set<String> toRemove = new HashSet<>(Optional.ofNullable((List<String>) args.get(1)).orElse(new ArrayList<>()));    for (Iterator<RiskLevelRule> it = triageRules.iterator(); it.hasNext(); ) {        RiskLevelRule rule = it.next();        boolean remove = toRemove.contains(rule.getRule());        if (!remove && rule.getName() != null) {            remove = toRemove.contains(rule.getName());        }        if (remove) {            it.remove();        }    }    return toJSON(config);}
public void metron_f5888_0(Context context)
{}
public boolean metron_f5889_0()
{    return true;}
public Object metron_f5890_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        tiConfig = new ThreatIntelConfig();        config.setThreatIntel(tiConfig);    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        triageConfig = new org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig();        tiConfig.setTriageConfig(triageConfig);    }    List<RiskLevelRule> triageRules = triageConfig.getRiskLevelRules();    if (triageRules == null) {        triageRules = new ArrayList<>();        triageConfig.setRiskLevelRules(triageRules);    }    String aggregator = (String) args.get(1);    triageConfig.setAggregator(aggregator);    if (args.size() > 2) {        Map<String, Object> aggConfig = (Map<String, Object>) args.get(2);        triageConfig.setAggregationConfig(aggConfig);    }    return toJSON(config);}
public void metron_f5891_0(Context context)
{}
public boolean metron_f5892_0()
{    return true;}
private static String metron_f5893_0(SensorEnrichmentConfig enrichmentConfig)
{    try {        return JSONUtils.INSTANCE.toJSON(enrichmentConfig, true);    } catch (JsonProcessingException e) {        throw new IllegalArgumentException("Unable to serialize enrichment config to JSON", e);    }}
private static SensorEnrichmentConfig metron_f5894_0(List<Object> args, int position)
{    Object arg0 = Util.getArg(position, Object.class, args);    SensorEnrichmentConfig config = new SensorEnrichmentConfig();    if (arg0 instanceof String) {                String json = Util.getArg(0, String.class, args);        if (json != null) {            config = (SensorEnrichmentConfig) ENRICHMENT.deserialize(json);        }    } else if (arg0 instanceof ThreatTriageProcessor) {                ThreatTriageProcessor engine = Util.getArg(0, ThreatTriageProcessor.class, args);        config = engine.getSensorConfig();    } else {                throw new IllegalArgumentException(String.format("Unexpected type: got '%s'", ClassUtils.getShortClassName(arg0, "null")));    }    return config;}
public static void metron_f5895_0() throws Exception
{        testZkServer = new TestingServer(true);    zookeeperUrl = testZkServer.getConnectString();        client = ConfigurationsUtils.getClient(zookeeperUrl);    client.start();}
public void metron_f5896_0() throws Exception
{    context = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).build();    parser = new JSONParser();        pushConfigs(SAMPLE_CONFIG_PATH, zookeeperUrl);    pushConfigs(PARSER_CONFIGS_PATH, zookeeperUrl);    writeProfilerConfigToZookeeper(goodProfilerConfig.getBytes(StandardCharsets.UTF_8), client);}
private void metron_f5897_0(String path) throws Exception
{    client.delete().forPath(path);}
private JSONObject metron_f5898_0(String input) throws org.json.simple.parser.ParseException
{    if (input == null) {        return null;    }    return (JSONObject) parser.parse(input.trim());}
private static void metron_f5899_0(String inputPath, String zookeeperUrl) throws Exception
{    String[] args = new String[] { "-z", zookeeperUrl, "--mode", "PUSH", "--input_dir", inputPath };    CommandLine cli = ConfigurationManager.ConfigurationOptions.parse(new PosixParser(), args);    ConfigurationManager manager = new ConfigurationManager();    manager.run(cli);}
public void metron_f5900_0() throws Exception
{    String out = (String) run("CONFIG_GET('PARSER', 'bro')", context);    SensorParserConfig actual = SensorParserConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));    SensorParserConfig expected = SensorParserConfig.fromBytes(goodBroParserConfig.getBytes(StandardCharsets.UTF_8));    assertEquals(expected, actual);}
public void metron_f5901_0()
{        Object out = run("CONFIG_GET('PARSER', 'sensor', false)", context);    assertNull(out);}
public void metron_f5902_0() throws Exception
{    SensorParserConfig expected = new SensorParserConfig();    {        Object out = run("CONFIG_GET('PARSER', 'sensor')", context);        SensorParserConfig actual = SensorParserConfig.fromBytes(out.toString().getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }    {        Object out = run("CONFIG_GET('PARSER', 'sensor', true)", context);        SensorParserConfig actual = SensorParserConfig.fromBytes(out.toString().getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }}
public void metron_f5903_0() throws Exception
{    String out = (String) run("CONFIG_GET('ENRICHMENT', 'test')", context);    SensorEnrichmentConfig actual = SensorEnrichmentConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));    SensorEnrichmentConfig expected = SensorEnrichmentConfig.fromBytes(goodTestEnrichmentConfig.getBytes(StandardCharsets.UTF_8));    assertEquals(expected, actual);}
public void metron_f5904_0()
{        Object out = run("CONFIG_GET('ENRICHMENT', 'sense', false)", context);    assertNull(out);}
public void metron_f5905_0() throws Exception
{        SensorEnrichmentConfig expected = new SensorEnrichmentConfig();    {        String out = (String) run("CONFIG_GET('ENRICHMENT', 'missing-sensor')", context);        SensorEnrichmentConfig actual = SensorEnrichmentConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('ENRICHMENT', 'missing-sensor', true)", context);        SensorEnrichmentConfig actual = SensorEnrichmentConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }}
public void metron_f5906_0() throws Exception
{    String out = (String) run("CONFIG_GET('INDEXING', 'test')", context);    Map<String, Object> actual = toJSONObject(out);    Map<String, Object> expected = toJSONObject(goodTestIndexingConfig);    assertEquals(expected, actual);}
public void metron_f5907_0()
{        Object out = run("CONFIG_GET('INDEXING', 'sense', false)", context);    assertNull(out);}
public void metron_f5908_0() throws Exception
{        Map<String, Object> expected = Collections.emptyMap();    {        String out = (String) run("CONFIG_GET('INDEXING', 'missing-sensor')", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('INDEXING', 'missing-sensor', true)", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }}
public void metron_f5909_0() throws Exception
{    String out = (String) run("CONFIG_GET('PROFILER')", context);    ProfilerConfig actual = ProfilerConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));    ProfilerConfig expected = ProfilerConfig.fromBytes(goodProfilerConfig.getBytes(StandardCharsets.UTF_8));    assertEquals(expected, actual);}
public void metron_f5910_0() throws Exception
{    deletePath(PROFILER.getZookeeperRoot());        String out = (String) run("CONFIG_GET('PROFILER', false)", context);    assertNull(out);}
public void metron_f5911_0() throws Exception
{        deletePath(PROFILER.getZookeeperRoot());        ProfilerConfig expected = new ProfilerConfig();    {        String out = (String) run("CONFIG_GET('PROFILER', true)", context);        ProfilerConfig actual = ProfilerConfig.fromJSON(out);        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('PROFILER')", context);        ProfilerConfig actual = ProfilerConfig.fromJSON(out);        assertEquals(expected, actual);    }}
public void metron_f5912_0() throws Exception
{    String out = (String) run("CONFIG_GET('GLOBAL')", context);    Map<String, Object> actual = toJSONObject(out);    Map<String, Object> expected = toJSONObject(goodGlobalConfig);    assertEquals(expected, actual);}
public void metron_f5913_0() throws Exception
{        deletePath(GLOBAL.getZookeeperRoot());        Object out = run("CONFIG_GET('GLOBAL', false)", context);    assertNull(out);}
public void metron_f5914_0() throws Exception
{        deletePath(GLOBAL.getZookeeperRoot());        Map<String, Object> expected = Collections.emptyMap();    {        String out = (String) run("CONFIG_GET('GLOBAL')", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('GLOBAL', true)", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }}
public void metron_f5915_0() throws Exception
{    String out = (String) run("CONFIG_GET('GLOBAL')", context);    Map<String, Object> actual = toJSONObject(out);    Map<String, Object> expected = toJSONObject(goodGlobalConfig);    assertEquals(expected, actual);}
public void metron_f5916_0()
{    {        UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);        try {            run("CONFIG_PUT('GLOBAL', 'foo bar')", context);        } catch (ParseException e) {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);            throw e;        }    }}
public void metron_f5917_0() throws InterruptedException
{    String brop = (String) run("CONFIG_GET('INDEXING', 'testIndexingPut')", context);    run("CONFIG_PUT('INDEXING', config, 'testIndexingPut')", ImmutableMap.of("config", brop), context);    boolean foundMatch = false;    for (int i = 0; i < 10 && !foundMatch; ++i) {        String bropNew = (String) run("CONFIG_GET('INDEXING', 'testIndexingPut', false)", context);        foundMatch = brop.equals(bropNew);        if (foundMatch) {            break;        }        Thread.sleep(2000);    }    assertTrue(foundMatch);}
public void metron_f5918_0() throws InterruptedException
{    {        {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);            try {                run("CONFIG_PUT('INDEXING', config, 'brop')", ImmutableMap.of("config", "foo bar"), context);            } catch (ParseException e) {                UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);                throw e;            }        }    }}
public void metron_f5919_0() throws InterruptedException
{    String config = (String) run("CONFIG_GET('ENRICHMENT', 'sensor')", context);    assertNotNull(config);    run("CONFIG_PUT('ENRICHMENT', config, 'sensor')", ImmutableMap.of("config", config), context);    boolean foundMatch = false;    for (int i = 0; i < 10 && !foundMatch; ++i) {        String newConfig = (String) run("CONFIG_GET('ENRICHMENT', 'sensor', false)", context);        foundMatch = config.equals(newConfig);        if (foundMatch) {            break;        }        Thread.sleep(2000);    }    assertTrue(foundMatch);}
public void metron_f5920_0() throws InterruptedException
{    {        {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);            try {                run("CONFIG_PUT('ENRICHMENT', config, 'brop')", ImmutableMap.of("config", "foo bar"), context);            } catch (ParseException e) {                UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);                throw e;            }        }    }}
public void metron_f5921_0() throws InterruptedException
{    String brop = (String) run("CONFIG_GET('PARSER', 'testParserPut')", context);    run("CONFIG_PUT('PARSER', config, 'testParserPut')", ImmutableMap.of("config", brop), context);    boolean foundMatch = false;    for (int i = 0; i < 10 && !foundMatch; ++i) {        String bropNew = (String) run("CONFIG_GET('PARSER', 'testParserPut', false)", context);        foundMatch = brop.equals(bropNew);        if (foundMatch) {            break;        }        Thread.sleep(2000);    }    assertTrue(foundMatch);}
public void metron_f5922_0() throws InterruptedException
{    {        UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);        try {            run("CONFIG_PUT('PARSER', config, 'brop')", ImmutableMap.of("config", "foo bar"), context);        } catch (ParseException e) {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);            throw e;        }    }}
public static String metron_f5923_0()
{    SensorEnrichmentConfig config = new SensorEnrichmentConfig();    try {        return JSONUtils.INSTANCE.toJSON(config, true);    } catch (JsonProcessingException e) {        throw new IllegalStateException(e);    }}
public static Collection<Object[]> metron_f5924_0()
{        return Arrays.asList(new Object[][] { { "ENRICHMENT", "group" }, { "ENRICHMENT", null }, { "THREAT_INTEL", "group" }, { "THREAT_INTEL", null } });}
public void metron_f5925_0()
{    variables = ImmutableMap.of("upper", VariableResult.withExpression("FOO", "TO_UPPER('foo')"), "lower", VariableResult.withExpression("foo", "TO_LOWER('FOO')"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
 static Map<String, Object> metron_f5926_0(String... k)
{    Map<String, Object> ret = new HashMap<>();    for (int i = 0; i < k.length; i += 2) {        ret.put(k[i], k[i + 1]);    }    return ret;}
private int metron_f5927_0(Map<String, Object> stellarFunctions)
{    if (group == null) {        return stellarFunctions.size();    } else {        return ((Map<String, Object>) stellarFunctions.getOrDefault(group, new HashMap<>())).size();    }}
private Object metron_f5928_0(Map<String, Object> stellarFunctions, String key)
{    if (group == null) {        return stellarFunctions.get(key);    } else {        return ((Map<String, Object>) stellarFunctions.get(group)).get(key);    }}
private EnrichmentConfig metron_f5929_0(String configStr)
{    SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(configStr);    switch(enrichmentType) {        case "ENRICHMENT":            return sensorConfig.getEnrichment();        case "THREAT_INTEL":            return sensorConfig.getThreatIntel();    }    return null;}
private static Map<String, Object> metron_f5930_0(EnrichmentConfig config)
{    Map<String, Object> fieldMap = config.getFieldMap();    if (fieldMap == null) {        return new HashMap<>();    }    Map<String, Object> stellarMap = (Map<String, Object>) fieldMap.get("stellar");    if (stellarMap == null) {        return new HashMap<>();    }    return (Map<String, Object>) stellarMap.get("config");}
private Object metron_f5931_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f5932_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("upper").getExpression().get(), get(stellarFunctions, "upper"));}
public void metron_f5933_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('lower'), group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(2, size(stellarFunctions));    Assert.assertEquals(variables.get("upper").getExpression().get(), get(stellarFunctions, "upper"));    Assert.assertEquals(variables.get("lower").getExpression().get(), get(stellarFunctions, "lower"));}
public void metron_f5934_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('foo'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(0, size(stellarFunctions));}
public void metron_f5935_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("upper").getExpression().get(), get(stellarFunctions, "upper"));}
public void metron_f5936_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper', 'lower'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_REMOVE(config, type, ['upper'], group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("lower").getExpression().get(), get(stellarFunctions, "lower"));}
public void metron_f5937_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper', 'lower'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_REMOVE(config, type, ['upper', 'lower'], group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(0, size(stellarFunctions));}
public void metron_f5938_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('lower'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_REMOVE(config, type, ['upper'], group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("lower").getExpression().get(), get(stellarFunctions, "lower"));}
public void metron_f5939_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    String out = (String) run("ENRICHMENT_STELLAR_TRANSFORM_PRINT(config, type)", toMap("config", newConfig, "type", enrichmentType));    if (group == null) {        Assert.assertEquals(testPrintExpectedWithoutGroup, out);    } else {        Assert.assertEquals(testPrintExpectedWithGroup, out);    }}
public void metron_f5940_0()
{    String out = (String) run("ENRICHMENT_STELLAR_TRANSFORM_PRINT(config, type)", toMap("config", configStr, "type", enrichmentType));    Assert.assertEquals(testPrintEmptyExpected, out);}
public void metron_f5941_0()
{    String out = (String) run("ENRICHMENT_STELLAR_TRANSFORM_PRINT(config, type)", toMap("config", configStr, "type", enrichmentType));    Assert.assertEquals(testPrintEmptyExpected, out);}
public static Collection<Object[]> metron_f5942_0()
{    return Arrays.asList(new Object[][] { { FileSystemFunctions.FS_TYPE.HDFS }, { FileSystemFunctions.FS_TYPE.LOCAL } });}
public static void metron_f5943_0() throws IOException
{    {        hdfsBaseDir = Files.createTempDirectory("test_hdfs").toFile().getAbsoluteFile();        Configuration conf = new Configuration();        conf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, hdfsBaseDir.getAbsolutePath());        MiniDFSCluster.Builder builder = new MiniDFSCluster.Builder(conf);        hdfsCluster = builder.build();        hdfsPrefix = "/";    }    {        localPrefix = "target/fsTest/";        if (new File(localPrefix).exists()) {            new File(localPrefix).delete();        }        new File(localPrefix).mkdirs();    }}
public void metron_f5944_0() throws IOException
{    if (type == FileSystemFunctions.FS_TYPE.HDFS) {        prefix = hdfsPrefix;        fsGetter = () -> hdfsCluster.getFileSystem();    } else {        prefix = localPrefix;        fsGetter = FileSystemFunctions.FS_TYPE.LOCAL;    }    get = new FileSystemFunctions.FileSystemGet(fsGetter);    get.initialize(null);    getList = new FileSystemFunctions.FileSystemGetList(fsGetter);    getList.initialize(null);    ls = new FileSystemFunctions.FileSystemLs(fsGetter);    ls.initialize(null);    put = new FileSystemFunctions.FileSystemPut(fsGetter);    put.initialize(null);    rm = new FileSystemFunctions.FileSystemRm(fsGetter);    rm.initialize(null);}
public static void metron_f5945_0()
{    {        hdfsCluster.shutdown();        FileUtil.fullyDelete(hdfsBaseDir);    }    {        new File(localPrefix).delete();    }}
public void metron_f5946_0()
{    Object putOut = put.apply(Arrays.asList("foo", prefix + "testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    String getOut = (String) get.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertEquals("foo", getOut);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertFalse(lsOut.contains("(empty)"));    Boolean rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertTrue(rmRet);    lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5947_0()
{    Object putOut = put.apply(Arrays.asList("foo\nbar", prefix + "testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    String getOut = (String) get.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertEquals("foo\nbar", getOut);    List<String> list = (List<String>) getList.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertEquals(2, list.size());    Assert.assertEquals("foo", list.get(0));    Assert.assertEquals("bar", list.get(1));}
public void metron_f5948_0()
{    Object o = put.apply(Arrays.asList("foo", null), null);    Assert.assertFalse((Boolean) o);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5949_0()
{    Object putOut = put.apply(Arrays.asList("foo", prefix + "testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    Boolean rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertTrue(rmRet);    rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertTrue(rmRet);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5950_0()
{    Object putOut = put.apply(Arrays.asList("foo", prefix + "blah/testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    putOut = put.apply(Arrays.asList("grok", prefix + "blah/testPut2.dat"), null);    Assert.assertTrue((Boolean) putOut);    Assert.assertEquals("foo", (String) get.apply(Arrays.asList(prefix + "blah/testPut.dat"), null));    Assert.assertEquals("grok", (String) get.apply(Arrays.asList(prefix + "blah/testPut2.dat"), null));    boolean rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "blah", true), null);    Assert.assertTrue(rmRet);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5951_0()
{    String message = "1474583120.343    142 127.0.0.1 TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, messages )", ImmutableMap.of("messages", ImmutableList.of(message), "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertTrue(out.contains("TCP_MISS"));    Assert.assertTrue(out.contains(" 494 "));    Assert.assertTrue(out.contains("157.166.226.26"));}
public void metron_f5952_0()
{    String message = "1474583120.343    142 127.0.0.1 TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String message2 = "1474583120.343    142 127.0.0.1 TCP_MISS/404 494 GET http://google.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, messages )", ImmutableMap.of("messages", ImmutableList.of(message, message2), "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertTrue(out.contains("TCP_MISS"));    Assert.assertTrue(out.contains(" 494 "));    Assert.assertTrue(out.contains("157.166.226.26"));    Assert.assertTrue(out.contains("404"));}
public void metron_f5953_0()
{    String message = "1474583120.343    142 foo TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, message )", ImmutableMap.of("message", message, "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertEquals("NO MATCH", out);}
public void metron_f5954_0()
{    String message = "1474583120.343    142 foo TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String message2 = "1474583120.343    142 127.0.0.1 TCP_MISS/404 494 GET http://google.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, messages )", ImmutableMap.of("messages", ImmutableList.of(message, message2), "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertTrue(out.contains("MISSING"));    Assert.assertTrue(out.contains("404"));}
public void metron_f5955_0()
{    String out = (String) run("GROK_PREDICT( '1474583120.343    142 127.0.0.1 TCP_MISS/301')", new HashMap<>(), Context.EMPTY_CONTEXT());    Assert.assertEquals("%{BASE10NUM}    142 %{IP} TCP_MISS%{PATH}", out);}
private Object metron_f5956_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f5957_0()
{    variables = ImmutableMap.of("upper", VariableResult.withExpression("FOO", "TO_UPPER('foo')"), "lower", VariableResult.withExpression("foo", "TO_LOWER('FOO')"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
public void metron_f5958_0()
{    String out = (String) run("INDEXING_SET_BATCH(config, 'hdfs', 10)", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertEquals(10, IndexingConfigurations.getBatchSize((Map<String, Object>) config.get("hdfs")));}
public void metron_f5959_0()
{    String out = (String) run("INDEXING_SET_BATCH(config, 'hdfs', 10, 2)", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertEquals(10, IndexingConfigurations.getBatchSize((Map<String, Object>) config.get("hdfs")));    Assert.assertEquals(2, IndexingConfigurations.getBatchTimeout((Map<String, Object>) config.get("hdfs")));}
public void metron_f5960_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    run("INDEXING_SET_BATCH(config, 'hdfs', 10)", variables);}
public void metron_f5961_0()
{    String out = (String) run("INDEXING_SET_ENABLED(config, 'hdfs', true)", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertTrue(IndexingConfigurations.isEnabled((Map<String, Object>) config.get("hdfs")));}
public void metron_f5962_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    run("INDEXING_SET_ENABLED(config, 'hdfs', 10)", variables);}
public void metron_f5963_0()
{    String out = (String) run("INDEXING_SET_INDEX(config, 'hdfs', 'foo')", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertEquals("foo", IndexingConfigurations.getIndex((Map<String, Object>) config.get("hdfs"), null));}
public void metron_f5964_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    run("INDEXING_SET_INDEX(config, 'hdfs', NULL)", variables);}
public static void metron_f5965_0()
{    executor = Executors.newFixedThreadPool(2);}
public static void metron_f5966_0()
{    if (executor != null && !executor.isShutdown()) {        executor.shutdown();    }}
public static void metron_f5967_0() throws Exception
{    Properties properties = new Properties();    zkServerComponent = getZKServerComponent(properties);    kafkaComponent = getKafkaComponent(properties, new ArrayList<>());    runner = new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withMillisecondsBetweenAttempts(5000).withNumRetries(5).withCustomShutdownOrder(new String[] { "kafka", "zk" }).build();    runner.start();}
public static void metron_f5968_0()
{        functionResolver = new SimpleFunctionResolver().withClass(KafkaFunctions.KafkaGet.class).withClass(KafkaFunctions.KafkaPut.class).withClass(KafkaFunctions.KafkaProps.class).withClass(KafkaFunctions.KafkaTail.class).withClass(KafkaFunctions.KafkaFind.class).withClass(KafkaFunctions.KafkaSeek.class).withClass(MapFunctions.MapGet.class);}
public void metron_f5969_0()
{        variables = new HashMap<>();    variables.put("message1", message1);    variables.put("message2", message2);    variables.put("message3", message3);        global = new Properties();    global.put("bootstrap.servers", kafkaComponent.getBrokerList());        global.put("auto.offset.reset", "earliest");}
public static void metron_f5970_0() throws Exception
{    runner.stop();}
public void metron_f5971_0()
{    runner.reset();}
public void metron_f5972_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        assertEquals(1, run("KAFKA_PUT(topic, [message1])"));        assertEquals(Collections.singletonList(message1), run("KAFKA_GET(topic)"));}
public void metron_f5973_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        assertEquals(2, run("KAFKA_PUT(topic, [message1, message2])"));        List<String> expected = new ArrayList<String>() {        {            add(message1);            add(message2);        }    };    assertEquals(expected, run("KAFKA_GET(topic, 2)"));}
public void metron_f5974_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, message1)");        Object actual = run("KAFKA_GET(topic)");        assertEquals(Collections.singletonList(message1), actual);}
public void metron_f5975_0()
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Object actual = run("KAFKA_PUT(topic, message1)");        assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertEquals(topicName, view.get("topic"));    assertEquals(0, view.get("partition"));    assertEquals(0L, view.get("offset"));    assertNotNull(view.get("timestamp"));}
public void metron_f5976_0()
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, message1)");        Object actual = run("KAFKA_GET(topic)");        assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertNull(view.get("key"));    assertEquals(0L, view.get("offset"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message1, view.get("value"));}
public void metron_f5977_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        Object actual = run("KAFKA_GET(topic, 3)");        List<String> expected = new ArrayList<String>() {        {            add(message1);            add(message2);            add(message3);        }    };    assertEquals(expected, actual);}
public void metron_f5978_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        assertEquals(Collections.singletonList(message1), run("KAFKA_GET(topic, 1)"));        assertEquals(Collections.singletonList(message2), run("KAFKA_GET(topic, 1)"));        assertEquals(Collections.singletonList(message3), run("KAFKA_GET(topic, 1)"));        assertEquals(Collections.emptyList(), run("KAFKA_GET(topic, 1)"));}
public void metron_f5979_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        assertEquals(Collections.emptyList(), run("KAFKA_GET(topic, 1)"));}
public void metron_f5980_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message2, message2, message2])");        Future<Object> tailFuture = runAsync("KAFKA_TAIL(topic, 1)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message1])"));        Object actual = tailFuture.get(10, TimeUnit.SECONDS);    List<String> expected = Collections.singletonList(message1);    assertEquals(expected, actual);}
public void metron_f5981_0()
{        global.put(KafkaFunctions.MAX_WAIT_PROPERTY, 2000);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        assertEquals(Collections.emptyList(), run("KAFKA_TAIL(topic, 1)"));}
public void metron_f5982_0() throws Exception
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message2, message2, message2])");        Future<Object> tailFuture = runAsync("KAFKA_TAIL(topic, 1)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message1])"));        Object actual = tailFuture.get(10, TimeUnit.SECONDS);        assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertNull(view.get("key"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message1, view.get("value"));    assertNotNull(view.get("offset"));}
public void metron_f5983_0()
{        final String overriddenKey = "bootstrap.servers";    final String expected = "foo.global.override.com:9092";    global.setProperty(overriddenKey, expected);        Map<String, String> properties = (Map<String, String>) run("KAFKA_PROPS()");    assertEquals(expected, properties.get(overriddenKey));}
public void metron_f5984_0()
{        final String overriddenKey = "bootstrap.servers";    global.setProperty(overriddenKey, "foo.global.override.com:9092");        final String expected = "foo.user.override.com:9092";    String expression = String.format("KAFKA_PROPS({ '%s' : '%s' })", overriddenKey, expected);        Map<String, String> properties = (Map<String, String>) run(expression);    assertEquals(expected, properties.get(overriddenKey));}
public void metron_f5985_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> MAP_GET('value', m) == 23)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message2])"));        Object actual = future.get(10, TimeUnit.SECONDS);    List<String> expected = Collections.singletonList(message2);    assertEquals(expected, actual);}
public void metron_f5986_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> false)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message1])"));        Object actual = future.get(10, TimeUnit.SECONDS);    List<String> expected = Collections.emptyList();    assertEquals(expected, actual);}
public void metron_f5987_0() throws Exception
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> MAP_GET('value', m) == 23)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message2])"));        Object actual = future.get(10, TimeUnit.SECONDS);    assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertNull(view.get("key"));    assertNotNull(view.get("offset"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message2, view.get("value"));}
public void metron_f5988_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> true, 2)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message2])"));        List<String> expected = new ArrayList<String>() {        {            add(message2);            add(message2);        }    };    Object actual = future.get(10, TimeUnit.SECONDS);    assertEquals(expected, actual);}
public void metron_f5989_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        long before = System.currentTimeMillis();    Object actual = run("KAFKA_FIND(topic, m -> false, 10, { 'stellar.kafka.max.wait.millis': 1000 })");        long wait = System.currentTimeMillis() - before;    assertTrue("Expected wait not to exceed max wait; actual wait = " + wait, wait < 2 * 1000);        List<String> expected = Collections.emptyList();    assertEquals(expected, actual);}
public void metron_f5990_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [ message1, message2, message3 ])");    {                Object actual = run("KAFKA_SEEK(topic, 0, 2)");        assertEquals(message3, actual);    }    {                Object actual = run("KAFKA_SEEK(topic, 0, 1)");        assertEquals(message2, actual);    }    {                Object actual = run("KAFKA_SEEK(topic, 0, 0)");        assertEquals(message1, actual);    }}
public void metron_f5991_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [ message1, message2, message3 ])");        Object actual = run("KAFKA_SEEK(topic, 0, 9999)");    assertNull(actual);}
public void metron_f5992_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [ message1, message2, message3 ])");        Object actual = run("KAFKA_SEEK(topic, 99999, 0)");    assertNull(actual);}
public void metron_f5993_0() throws Exception
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);    run("KAFKA_PUT(topic, [ message1, message2, message3 ])");    Object actual = run("KAFKA_SEEK(topic, 0, 0)");        assertTrue(actual instanceof Map);    Map<String, Object> view = (Map) actual;    assertNull(view.get("key"));    assertNotNull(view.get("offset"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message1, view.get("value"));}
private Object metron_f5994_0(String expression)
{        Context context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> global).build();        StellarProcessor processor = new StellarProcessor();    return processor.parse(expression, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), functionResolver, context);}
private Future<Object> metron_f5995_0(String expression)
{    return executor.submit(() -> run(expression));}
private void metron_f5996_0(Iterable<String> expressions) throws Exception
{        List<Future<Object>> putFutures = new ArrayList<>();    for (String expression : expressions) {        Future<Object> future = runAsync(expression);        putFutures.add(future);    }        for (Future<Object> future : putFutures) {        future.get(5, TimeUnit.SECONDS);    }}
public void metron_f5997_0()
{    variables = ImmutableMap.of("upper", VariableResult.withExpression("FOO", "TO_UPPER('foo')"), "lower", VariableResult.withExpression("foo", "TO_LOWER('FOO'"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
public Map<String, Object> metron_f5998_0(String parserConfig)
{    return transform(parserConfig, new HashMap<>());}
public Map<String, Object> metron_f5999_0(String parserConfig, Map<String, Object> variables)
{    JSONObject ret = new JSONObject(variables);    SensorParserConfig sensorParserConfig = (SensorParserConfig) PARSER.deserialize(parserConfig);    sensorParserConfig.init();    for (FieldTransformer handler : sensorParserConfig.getFieldTransformations()) {        if (handler != null) {            handler.transformAndUpdate(ret, context, sensorParserConfig.getParserConfig());        }    }    return ret;}
public void metron_f6000_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(1, transformations.size());    Assert.assertEquals("FOO", transformations.get("upper"));}
public void metron_f6001_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", existingTransformationsConfig), context);    Map<String, Object> transformations = transform(newConfig, ImmutableMap.of("url", "http://www.google.com"));        Assert.assertEquals(4, transformations.size());    Assert.assertEquals("FOO", transformations.get("upper"));}
public void metron_f6002_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('blah'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(0, transformations.size());}
public void metron_f6003_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", newConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(1, transformations.size());    Assert.assertEquals("FOO", transformations.get("upper"));}
public void metron_f6004_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, ['upper'])", ImmutableMap.of("config", newConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(0, transformations.size());}
public void metron_f6005_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper', 'lower'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, ['upper', 'lower'])", ImmutableMap.of("config", newConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(0, transformations.size());}
public void metron_f6006_0()
{    {        String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);        newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, ['lower'])", ImmutableMap.of("config", newConfig), context);        Map<String, Object> transformations = transform(newConfig);        Assert.assertEquals(1, transformations.size());        Assert.assertEquals("FOO", transformations.get("upper"));    }    {        String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);        newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, [''])", ImmutableMap.of("config", newConfig), context);        Map<String, Object> transformations = transform(newConfig);        Assert.assertEquals(1, transformations.size());        Assert.assertEquals("FOO", transformations.get("upper"));    }}
public void metron_f6007_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    String out = (String) run("PARSER_STELLAR_TRANSFORM_PRINT(config )", ImmutableMap.of("config", newConfig), context);    Assert.assertEquals(testPrintExpected, out);}
public void metron_f6008_0()
{    String out = (String) run("PARSER_STELLAR_TRANSFORM_PRINT(config )", ImmutableMap.of("config", emptyTransformationsConfig), context);    Assert.assertEquals(testPrintEmptyExpected, out);}
public void metron_f6009_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    String out = (String) run("PARSER_STELLAR_TRANSFORM_PRINT(config )", variables, context);    Assert.assertNull(out);}
public void metron_f6010_0()
{    variables = new HashMap<>();    functionResolver = new SimpleFunctionResolver().withClass(ParserFunctions.ParseFunction.class).withClass(ParserFunctions.InitializeFunction.class).withClass(ParserFunctions.ConfigFunction.class);    context = new Context.Builder().build();    executor = new DefaultStellarStatefulExecutor(functionResolver, context);}
public void metron_f6011_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        set("message", broMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, message)", List.class);        Assert.assertEquals(1, messages.size());    JSONObject message = messages.get(0);    Assert.assertEquals("bro", message.get(Constants.SENSOR_TYPE));    Assert.assertEquals("10.122.196.204", message.get(SRC_ADDR.getName()));    Assert.assertEquals(33976L, message.get(SRC_PORT.getName()));    Assert.assertEquals("144.254.71.184", message.get(DST_ADDR.getName()));    Assert.assertEquals(53L, message.get(DST_PORT.getName()));    Assert.assertEquals("dns", message.get("protocol"));}
public void metron_f6012_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        set("msg1", broMessage);    set("msg2", broMessage);    set("msg3", broMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, [msg1, msg2, msg3])", List.class);        Assert.assertEquals(3, messages.size());    for (JSONObject message : messages) {        Assert.assertEquals("bro", message.get(Constants.SENSOR_TYPE));        Assert.assertTrue(message.containsKey(Constants.GUID));        Assert.assertEquals("10.122.196.204", message.get(SRC_ADDR.getName()));        Assert.assertEquals(33976L, message.get(SRC_PORT.getName()));        Assert.assertEquals("144.254.71.184", message.get(DST_ADDR.getName()));        Assert.assertEquals(53L, message.get(DST_PORT.getName()));        Assert.assertEquals("dns", message.get("protocol"));    }}
public void metron_f6013_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        String invalidMessage = "{ this is an invalid message }}";    set("message", invalidMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, message)", List.class);        Assert.assertEquals(1, messages.size());        JSONObject error = messages.get(0);    Assert.assertEquals(invalidMessage, error.get("raw_message"));    Assert.assertEquals(Constants.ERROR_TYPE, error.get(Constants.SENSOR_TYPE));    Assert.assertEquals("parser_error", error.get(ERROR_TYPE.getName()));    Assert.assertTrue(error.containsKey(MESSAGE.getName()));    Assert.assertTrue(error.containsKey(EXCEPTION.getName()));    Assert.assertTrue(error.containsKey(STACK.getName()));    Assert.assertTrue(error.containsKey(ERROR_HASH.getName()));    Assert.assertTrue(error.containsKey(Constants.GUID));}
public void metron_f6014_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        String invalidMessage = "{ this is an invalid message }}";    set("msg1", broMessage);    set("msg2", invalidMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, [msg1, msg2])", List.class);        Assert.assertEquals(2, messages.size());    Assert.assertEquals(1, messages.stream().filter(msg -> isBro(msg)).count());    Assert.assertEquals(1, messages.stream().filter(msg -> isError(msg)).count());}
public void metron_f6015_0() throws Exception
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");    String config = execute("PARSER_CONFIG(parser)", String.class);    Assert.assertNotNull(config);    Assert.assertNotNull(SensorParserConfig.fromBytes(config.getBytes(StandardCharsets.UTF_8)));}
public void metron_f6016_0() throws Exception
{    set("configAsString", broParserConfig);    StellarParserRunner runner = execute("PARSER_INIT('bro', configAsString)", StellarParserRunner.class);    Assert.assertNotNull(runner);    SensorParserConfig actual = runner.getParserConfigurations().getSensorParserConfig("bro");    SensorParserConfig expected = SensorParserConfig.fromBytes(broParserConfig.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(expected, actual);}
public void metron_f6017_0() throws Exception
{    Map<String, Object> configAsMap = (JSONObject) new JSONParser().parse(broParserConfig);    set("configAsMap", configAsMap);    StellarParserRunner runner = execute("PARSER_INIT('bro', configAsMap)", StellarParserRunner.class);    Assert.assertNotNull(runner);    SensorParserConfig actual = runner.getParserConfigurations().getSensorParserConfig("bro");    SensorParserConfig expected = SensorParserConfig.fromBytes(broParserConfig.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(expected, actual);}
public void metron_f6018_0() throws Exception
{    execute("PARSER_INIT('bro', 22)", StellarParserRunner.class);    Assert.fail("expected exception");}
public void metron_f6019_0() throws Exception
{    byte[] configAsBytes = broParserConfig.getBytes(StandardCharsets.UTF_8);    CuratorFramework zkClient = zkClientForPath("/metron/topology/parsers/bro", configAsBytes);    context.addCapability(Context.Capabilities.ZOOKEEPER_CLIENT, () -> zkClient);    StellarParserRunner runner = execute("PARSER_INIT('bro')", StellarParserRunner.class);    Assert.assertNotNull(runner);    SensorParserConfig actual = runner.getParserConfigurations().getSensorParserConfig("bro");    SensorParserConfig expected = SensorParserConfig.fromBytes(broParserConfig.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(expected, actual);}
public void metron_f6020_0() throws Exception
{        CuratorFramework zkClient = zkClientMissingPath("/metron/topology/parsers/bro");    context.addCapability(Context.Capabilities.ZOOKEEPER_CLIENT, () -> zkClient);    execute("PARSER_INIT('bro')", StellarParserRunner.class);    Assert.fail("expected exception");}
private CuratorFramework metron_f6021_0(String path, byte[] value) throws Exception
{    GetDataBuilder getDataBuilder = mock(GetDataBuilder.class);    when(getDataBuilder.forPath(path)).thenReturn(value);    CuratorFramework zkClient = mock(CuratorFramework.class);    when(zkClient.getData()).thenReturn(getDataBuilder);    return zkClient;}
private CuratorFramework metron_f6022_0(String path) throws Exception
{    GetDataBuilder getDataBuilder = mock(GetDataBuilder.class);    when(getDataBuilder.forPath(path)).thenThrow(new KeeperException.NoNodeException(path));    CuratorFramework zkClient = mock(CuratorFramework.class);    when(zkClient.getData()).thenReturn(getDataBuilder);    return zkClient;}
private boolean metron_f6023_0(JSONObject message)
{    String sensorType = String.class.cast(message.get(Constants.SENSOR_TYPE));    return Constants.ERROR_TYPE.equals(sensorType);}
private boolean metron_f6024_0(JSONObject message)
{    String sensorType = String.class.cast(message.get(Constants.SENSOR_TYPE));    return "bro".equals(sensorType);}
private void metron_f6025_0(String var, Object value)
{    executor.assign(var, value);}
private Object metron_f6026_0(String var, String expression)
{    executor.assign(var, expression, Collections.emptyMap());    return executor.getState().get(var);}
private T metron_f6027_1(String expression, Class<T> clazz)
{    T results = executor.execute(expression, Collections.emptyMap(), clazz);        return results;}
public void metron_f6028_0()
{    List<String> toParse = new ArrayList<>();    toParse.add(broMessage);    toParse.add(broMessage);    toParse.add(broMessage);        StellarParserRunner runner = new StellarParserRunner("bro").withParserConfiguration(broParserConfig).withContext(Context.EMPTY_CONTEXT());    List<JSONObject> messages = runner.parse(toParse);        Assert.assertEquals(3, messages.size());    for (JSONObject message : messages) {        Assert.assertEquals("bro", message.get(Constants.SENSOR_TYPE));        Assert.assertTrue(message.containsKey(Constants.GUID));        Assert.assertEquals("10.122.196.204", message.get(SRC_ADDR.getName()));        Assert.assertEquals(33976L, message.get(SRC_PORT.getName()));        Assert.assertEquals("144.254.71.184", message.get(DST_ADDR.getName()));        Assert.assertEquals(53L, message.get(DST_PORT.getName()));        Assert.assertEquals("dns", message.get("protocol"));    }}
public void metron_f6029_0()
{    List<String> toParse = new ArrayList<>();    toParse.add("{DAS}");        StellarParserRunner runner = new StellarParserRunner("bro").withParserConfiguration(broParserConfig).withContext(Context.EMPTY_CONTEXT());    List<JSONObject> messages = runner.parse(toParse);        JSONObject error = messages.get(0);    Assert.assertEquals(toParse.get(0), error.get("raw_message"));    Assert.assertEquals(Constants.ERROR_TYPE, error.get(Constants.SENSOR_TYPE));    Assert.assertEquals("parser_error", error.get(ERROR_TYPE.getName()));    Assert.assertTrue(error.containsKey(MESSAGE.getName()));    Assert.assertTrue(error.containsKey(EXCEPTION.getName()));    Assert.assertTrue(error.containsKey(STACK.getName()));    Assert.assertTrue(error.containsKey(ERROR_HASH.getName()));    Assert.assertTrue(error.containsKey(Constants.GUID));}
public void metron_f6030_0()
{    List<String> toParse = new ArrayList<>();    toParse.add(broMessage);    toParse.add("{DAS}");        StellarParserRunner runner = new StellarParserRunner("bro").withParserConfiguration(broParserConfig).withContext(Context.EMPTY_CONTEXT());    List<JSONObject> messages = runner.parse(toParse);        Assert.assertEquals("Parser{1 successful, 1 error(s)}", runner.toString());}
public void metron_f6031_0()
{    variables = ImmutableMap.of("less", VariableResult.withExpression(true, "1 < 2"), "greater", VariableResult.withExpression(false, "1 > 2"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
public static List<RiskLevelRule> metron_f6032_0(String config)
{    SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    return sensorConfig.getThreatIntel().getTriageConfig().getRiskLevelRules();}
private Object metron_f6033_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
private Object metron_f6034_0(String rule)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new MapVariableResolver(Collections.emptyMap()), StellarFunctions.FUNCTION_RESOLVER(), context);}
private Object metron_f6035_0(String... expressions)
{    Object result = null;    for (String expression : expressions) {        result = run(expression);    }    return result;}
public void metron_f6036_0()
{    String newConfig = (String) run("THREAT_TRIAGE_SET_AGGREGATOR(config, 'MIN' )", toMap("config", configStr));    SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(newConfig);    Assert.assertEquals("MIN", sensorConfig.getThreatIntel().getTriageConfig().getAggregator().toString());}
public void metron_f6037_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        String newConfig = (String) run("THREAT_TRIAGE_SET_AGGREGATOR(engine, 'MIN')", vars);        SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(newConfig);    Assert.assertEquals("MIN", sensorConfig.getThreatIntel().getTriageConfig().getAggregator().toString());        Assert.assertEquals("MIN", engine.getSensorConfig().getThreatIntel().getTriageConfig().getAggregator().toString());}
public void metron_f6038_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", toMap("config", configStr));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6039_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    String newConfig = (String) run("THREAT_TRIAGE_ADD(engine, {'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", vars);        List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());        Assert.assertEquals(1, engine.getSensorConfig().getThreatIntel().getTriageConfig().getRiskLevelRules().size());}
public void metron_f6040_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10, 'reason' : '2 + 2' } )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(2, triageRules.size());    RiskLevelRule less = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), less.getRule());    Assert.assertEquals("10", less.getScoreExpression());    RiskLevelRule greater = triageRules.get(1);    Assert.assertEquals(variables.get("greater").getExpression().get(), greater.getRule());    Assert.assertEquals("20", greater.getScoreExpression());}
public void metron_f6041_0()
{    Object o = run("THREAT_TRIAGE_ADD(config, { 'rule': SHELL_GET_EXPRESSION('foo'), 'score' : 10 } )", toMap("config", configStr));    Assert.assertEquals(configStr, o);}
public void metron_f6042_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6043_0()
{        String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'name':'rule1', 'rule':'value < 2', 'score':10 } )", toMap("config", configStr));        newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'name':'rule2', 'rule':'value < 4', 'score':10 } )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(2, triageRules.size());}
public void metron_f6044_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        run("THREAT_TRIAGE_ADD(engine, { 'name':'rule1', 'rule':'value < 2', 'score':10 } )", vars);        run("THREAT_TRIAGE_ADD(engine, { 'name':'rule2', 'rule':'value < 4', 'score':10 } )", vars);    List<RiskLevelRule> triageRules = engine.getRiskLevelRules();    Assert.assertEquals(2, triageRules.size());}
public void metron_f6045_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_REMOVE(config, [ SHELL_GET_EXPRESSION('greater')] )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6046_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");        Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        String newConfig = (String) run("THREAT_TRIAGE_ADD(engine, [" + "{ 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, " + "{ 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", vars);        newConfig = (String) run("THREAT_TRIAGE_REMOVE(engine, [ " + "SHELL_GET_EXPRESSION('greater')] )", vars);    List<RiskLevelRule> triageRules = engine.getRiskLevelRules();    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6047_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_REMOVE(config, [ SHELL_GET_EXPRESSION('less'), SHELL_GET_EXPRESSION('greater')] )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(0, triageRules.size());}
public void metron_f6048_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_REMOVE(config, [ SHELL_GET_EXPRESSION('foo'), SHELL_GET_EXPRESSION('bar')] )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(2, triageRules.size());    RiskLevelRule less = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), less.getRule());    Assert.assertEquals("10", less.getScoreExpression());    RiskLevelRule greater = triageRules.get(1);    Assert.assertEquals(variables.get("greater").getExpression().get(), greater.getRule());    Assert.assertEquals("20", greater.getScoreExpression());}
public void metron_f6049_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ " + "{ 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10, 'reason' : '2 + 2' }, " + "{ 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    String out = (String) run("THREAT_TRIAGE_PRINT(config)", toMap("config", newConfig));    Assert.assertEquals(testPrintExpected, out);}
public void metron_f6050_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        run("THREAT_TRIAGE_ADD(engine, [ " + "{ 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10, 'reason' : '2 + 2' }, " + "{ 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", vars);        String out = (String) run("THREAT_TRIAGE_PRINT(engine)", vars);    Assert.assertEquals(testPrintExpected, out);}
public void metron_f6051_0()
{    String out = (String) run("THREAT_TRIAGE_PRINT(config)", toMap("config", configStr));    Assert.assertEquals(testPrintEmptyExpected, out);}
public void metron_f6052_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    String out = (String) run("THREAT_TRIAGE_PRINT(config)", variables);    Assert.assertEquals(out, testPrintEmptyExpected);}
public void metron_f6053_0()
{    Object result = run("THREAT_TRIAGE_INIT()");    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof ThreatTriageProcessor);        ThreatTriageProcessor engine = (ThreatTriageProcessor) result;    Assert.assertEquals(0, engine.getRiskLevelRules().size());}
public void metron_f6054_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 10 } ])", toMap("conf", configStr));        Object result = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof ThreatTriageProcessor);        ThreatTriageProcessor engine = (ThreatTriageProcessor) result;    Assert.assertEquals(1, engine.getRiskLevelRules().size());}
public void metron_f6055_0()
{    run("THREAT_TRIAGE_INIT(missing)");}
public void metron_f6056_0()
{        Object engine = run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    vars.put("msg", message);        Object result = run("THREAT_TRIAGE_SCORE(msg, engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof Map);        Map<String, Object> score = (Map) result;    Assert.assertEquals(0, ((List) score.get(ThreatTriageFunctions.RULES_KEY)).size());        Object totalScore = score.get(ThreatTriageFunctions.SCORE_KEY);    Assert.assertTrue(totalScore instanceof Double);    Assert.assertEquals(0.0, (Double) totalScore, 0.001);}
public void metron_f6057_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 10 }])", toMap("conf", configStr));        Object engine = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    vars.put("msg", message);        Object result = run("THREAT_TRIAGE_SCORE(msg, engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof Map);        Map<String, Object> score = (Map) result;    Assert.assertEquals(1, ((List) score.get(ThreatTriageFunctions.RULES_KEY)).size());        Object totalScore = score.get(ThreatTriageFunctions.SCORE_KEY);    Assert.assertTrue(totalScore instanceof Double);    Assert.assertEquals(10.0, (Double) totalScore, 0.001);        Assert.assertEquals("MAX", score.get(ThreatTriageFunctions.AGG_KEY));}
public void metron_f6058_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 'value * 10' }])", toMap("conf", configStr));        Object engine = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    vars.put("msg", message);        Object result = run("THREAT_TRIAGE_SCORE(msg, engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof Map);        Map<String, Object> score = (Map) result;    Assert.assertEquals(1, ((List) score.get(ThreatTriageFunctions.RULES_KEY)).size());        Object totalScore = score.get(ThreatTriageFunctions.SCORE_KEY);    Assert.assertTrue(totalScore instanceof Double);    Assert.assertEquals(220.0, (Double) totalScore, 0.001);        Assert.assertEquals("MAX", score.get(ThreatTriageFunctions.AGG_KEY));}
public void metron_f6059_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 10 }])", toMap("conf", configStr));        Object engine = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        run("THREAT_TRIAGE_SCORE(11, engine)", vars);}
public void metron_f6060_0()
{        Object engine = run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        Object result = run("THREAT_TRIAGE_CONFIG(engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof String);        String json = (String) result;    Assert.assertEquals(emptyTransformationsConfig(), json);}
public static String metron_f6061_0(String loc)
{    try {        return Joiner.on("\n").join(Files.readLines(new File(loc), Charset.defaultCharset())).trim();    } catch (IOException e) {        throw new IllegalStateException(e);    }}
private void metron_f6063_0(String key, String pattern) throws GrokException
{    Grok grok = new Grok();    InputStream patternStream = this.getClass().getResourceAsStream("/patterns/asa");    grok.addPatternFromReader(new InputStreamReader(patternStream, StandardCharsets.UTF_8));    grok.compile("%{" + pattern + "}");    grokers.put(key, grok);}
public void metron_f6064_1()
{    syslogGrok = new Grok();    InputStream syslogStream = this.getClass().getResourceAsStream("/patterns/asa");    try {        syslogGrok.addPatternFromReader(new InputStreamReader(syslogStream, StandardCharsets.UTF_8));        syslogGrok.compile(syslogPattern);    } catch (GrokException e) {                throw new RuntimeException(e.getMessage(), e);    }    for (Entry<String, String> pattern : patternMap.entrySet()) {        try {            addGrok(pattern.getKey(), pattern.getValue());        } catch (GrokException e) {                    }    }    }
protected NumberFormat metron_f6066_0()
{    return new DecimalFormat("0.0#####");}
public void metron_f6067_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public void metron_f6068_0()
{}
private Long metron_f6070_0(Double timestampSeconds)
{    return ((Double) (timestampSeconds * 1000)).longValue();}
private boolean metron_f6071_0(JSONObject payload, String toKey, String[] fromKeys)
{    for (String fromKey : fromKeys) {        if (payload.containsKey(fromKey)) {            Object value = payload.remove(fromKey);            payload.put(toKey, value);            _LOG.trace("[Metron] Added {} to {}", toKey, payload);            return true;        }    }    return false;}
private boolean metron_f6072_0(JSONObject payload, String toKey, String[] fromKeys)
{    for (String fromKey : fromKeys) {        if (payload.containsKey(fromKey)) {            JSONArray value = (JSONArray) payload.remove(fromKey);            if (value != null && !value.isEmpty()) {                payload.put(toKey, value.get(0));                _LOG.trace("[Metron] Added {} to {}", toKey, payload);                return true;            }        }    }    return false;}
public JSONObject metron_f6073_0(String jsonString) throws ParseException
{    JSONParser parser = new JSONParser();    Map json = (Map) parser.parse(jsonString);    JSONObject output = new JSONObject();    Iterator iter = json.entrySet().iterator();    while (iter.hasNext()) {        Map.Entry entry = (Map.Entry) iter.next();        String key = ((String) entry.getKey()).replaceAll("[^\\._a-zA-Z0-9]+", "");        output.put(key, entry.getValue());    }    return output;}
public static void metron_f6074_0(String[] args)
{    String jsonText = "{\"first_1\": 123, \"second\": [4, 5, 6], \"third\": 789}";    JSONCleaner cleaner = new JSONCleaner();    try {                Map obj = new HashMap();        obj.put("name", "foo");        obj.put("num", 100);        obj.put("balance", 1000.21);        obj.put("is_vip", true);        obj.put("nickname", null);        Map obj1 = new HashMap();        obj1.put("sourcefile", obj);        JSONObject json = new JSONObject(obj1);        System.out.println(json);        System.out.print(jsonText);    } catch (Exception e) {        e.printStackTrace();    }}
public void metron_f6075_0()
{            String syslogTime = "(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\\b +(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]) (?!<[0-9])(?:2[0123]|[01]?[0-9]):(?:[0-5][0-9])(?::(?:(?:[0-5]?[0-9]|60)(?:[:.,][0-9]+)?))(?![0-9])?";    String syslogTime5424 = "(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2}))";    String syslogPriority = "<(?:[0-9]+)>";    String syslogHost = "[a-z0-9\\.\\\\-_]+";    StringBuilder sb = new StringBuilder("");    sb.append("(?<syslogPriority>");    sb.append(syslogPriority);    sb.append(")?");    sb.append("(?<syslogTime>");    sb.append(syslogTime);    sb.append("|");    sb.append(syslogTime5424);    sb.append(")?");    sb.append("(?<syslogHost>");    sb.append(syslogHost);    sb.append(")?");    sb.append(".*");    sb.append("CEF: ?0\\|");    headerBlock("DeviceVendor", sb);    sb.append("\\|");    headerBlock("DeviceProduct", sb);    sb.append("\\|");    headerBlock("DeviceVersion", sb);    sb.append("\\|");    headerBlock("DeviceEvent", sb);    sb.append("\\|");    headerBlock("Name", sb);    sb.append("\\|");    headerBlock("Severity", sb);    sb.append("\\|");        sb.append("(?<extensions>.*)");    String pattern = sb.toString();    p = Pattern.compile(pattern);}
public static void metron_f6076_0(String ext, JSONObject obj)
{    Matcher m = patternExtensions.matcher(ext);    int index = 0;    String key = null;    String value = null;    Map<String, String> labelMap = new HashMap<String, String>();    while (m.find()) {        if (key == null) {            key = ext.substring(index, m.start());            index = m.end();            if (!m.find()) {                break;            }        }        value = ext.substring(index, m.start());        index = m.end();        int v = value.lastIndexOf(" ");        if (v > 0) {            String temp = value.substring(0, v).trim();            if (key.endsWith("Label")) {                labelMap.put(key.substring(0, key.length() - 5), temp);            } else {                obj.put(key, temp);            }            key = value.substring(v).trim();        }    }    value = ext.substring(index);        if (key.endsWith("Label")) {        labelMap.put(key.substring(0, key.length() - 5), value);    } else {        obj.put(key, value);    }        for (Entry<String, String> label : labelMap.entrySet()) {        mutate(obj, label.getKey(), label.getValue());    }}
public List<JSONObject> metron_f6077_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    String cefString = new String(rawMessage, getReadCharset());    Matcher matcher = p.matcher(cefString);    while (matcher.find()) {        JSONObject obj = new JSONObject();        if (matcher.matches()) {                        obj.put("DeviceVendor", matcher.group("DeviceVendor"));            obj.put("DeviceProduct", matcher.group("DeviceProduct"));            obj.put("DeviceVersion", matcher.group("DeviceVersion"));            obj.put("DeviceEvent", matcher.group("DeviceEvent"));            obj.put("Name", matcher.group("Name"));            obj.put("Severity", standardizeSeverity(matcher.group("Severity")));        }        parseExtensions(matcher.group("extensions"), obj);                obj = mutate(obj, "dst", "ip_dst_addr");        obj = mutate(obj, "dpt", "ip_dst_port");        obj = convertToInt(obj, "ip_dst_port");        obj = mutate(obj, "src", "ip_src_addr");        obj = mutate(obj, "spt", "ip_src_port");        obj = convertToInt(obj, "ip_src_port");        obj = mutate(obj, "act", "deviceAction");                obj = mutate(obj, "app", "protocol");        obj.put("original_string", cefString);        if (obj.containsKey("rt")) {            String rt = (String) obj.get("rt");            try {                obj.put("timestamp", DateUtils.parseMultiformat(rt, DateUtils.DATE_FORMATS_CEF));            } catch (java.text.ParseException e) {                throw new IllegalStateException("rt field present in CEF but cannot be parsed", e);            }        } else {            String logTimestamp = matcher.group("syslogTime");            if (!(logTimestamp == null || logTimestamp.isEmpty())) {                try {                    obj.put("timestamp", SyslogUtils.parseTimestampToEpochMillis(logTimestamp, Clock.systemUTC()));                } catch (ParseException e) {                    throw new IllegalStateException("Cannot parse syslog timestamp", e);                }            } else {                obj.put("timestamp", System.currentTimeMillis());            }        }                String host = matcher.group("syslogHost");        if (!(host == null || host.isEmpty())) {            obj.put("host", host);        }        messages.add(obj);    }    return messages;}
private JSONObject metron_f6078_0(JSONObject obj, String key)
{    if (obj.containsKey(key)) {        obj.put(key, Integer.valueOf((String) obj.get(key)));    }    return obj;}
private void metron_f6079_0(String name, StringBuilder sb)
{    sb.append("(?<").append(name).append(">").append(HEADER_CAPTURE_PATTERN).append(")");}
private Integer metron_f6080_0(String severity)
{    if (severity.length() < 3) {                return Integer.valueOf(severity);    } else {        switch(severity) {            case "Low":                return 2;            case "Medium":                return 5;            case "High":                return 8;            case "Very-High":                return 10;            default:                return 0;        }    }}
public void metron_f6081_0(Map<String, Object> config)
{    setReadCharset(config);}
private static JSONObject metron_f6082_0(JSONObject json, String oldKey, String newKey)
{    if (json.containsKey(oldKey)) {        json.put(newKey, json.remove(oldKey));    }    return json;}
public void metron_f6083_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public void metron_f6084_0()
{}
public List<JSONObject> metron_f6085_1(byte[] rawMessage)
{    String toParse;    List<JSONObject> messages = new ArrayList<>();    try {        toParse = new String(rawMessage, getReadCharset());                                Matcher m = syslogPriorityPattern.matcher(toParse);        String delimiter = "";        while (m.find()) {            delimiter = m.group();        }        if (!StringUtils.isBlank(delimiter)) {            String[] tokens = toParse.split(delimiter);            if (tokens.length > 1) {                toParse = delimiter + tokens[1];            }        }                JSONObject toReturn = parseMessage(toParse);        toReturn.put("timestamp", getTimeStamp(toParse));        messages.add(toReturn);        return messages;    } catch (Exception e) {        String message = "Unable to parse " + new String(rawMessage, StandardCharsets.UTF_8) + ": " + e.getMessage();                throw new IllegalStateException(message, e);    }}
private long metron_f6086_1(String toParse) throws ParseException
{    long timestamp = 0;    String month;    String day;    String time;    Matcher tsMatcher = tsPattern.matcher(toParse);    if (tsMatcher.find()) {        month = tsMatcher.group(1);        day = tsMatcher.group(2);        time = tsMatcher.group(3);        timestamp = ParserUtils.convertToEpoch(month, day, time, true);    } else {            }    return timestamp;}
private JSONObject metron_f6087_0(String toParse)
{    JSONObject toReturn = new JSONObject();    String[] messageTokens = toParse.split("\\s+");    String id = messageTokens[4];                    String[] tokens = id.split("\\.");    if (tokens.length == 2) {        String[] array = Arrays.copyOfRange(messageTokens, 1, messageTokens.length - 1);        String syslog = Joiner.on(" ").join(array);        Multimap<String, String> multiMap = formatMain(syslog);        for (String key : multiMap.keySet()) {            String value = Joiner.on(",").join(multiMap.get(key));            toReturn.put(key, value.trim());        }    }    toReturn.put("original_string", toParse);    final String ipSrcAddr = (String) toReturn.get("dvc");    final String ipSrcPort = (String) toReturn.get("src_port");    final String ipDstDddr = (String) toReturn.get("dst_ip");    final String ipDstPort = (String) toReturn.get("dst_port");    if (ipSrcAddr != null) {        toReturn.put("ip_src_addr", ipSrcAddr);    }    if (ipSrcPort != null) {        toReturn.put("ip_src_port", ipSrcPort);    }    if (ipDstDddr != null) {        toReturn.put("ip_dst_addr", ipDstDddr);    }    if (ipDstPort != null) {        toReturn.put("ip_dst_port", ipDstPort);    }    return toReturn;}
private Multimap<String, String> metron_f6088_0(String in)
{    Multimap<String, String> multiMap = ArrayListMultimap.create();    String input = in.replaceAll("cn3", "dst_port").replaceAll("cs5", "cncHost").replaceAll("proto", "protocol").replaceAll("rt=", "timestamp=").replaceAll("cs1", "malware").replaceAll("dst=", "dst_ip=").replaceAll("shost", "src_hostname").replaceAll("dmac", "dst_mac").replaceAll("smac", "src_mac").replaceAll("spt", "src_port").replaceAll("\\bsrc\\b", "src_ip");    String[] tokens = input.split("\\|");    if (tokens.length > 0) {        String message = tokens[tokens.length - 1];        Matcher m = nvPattern.matcher(message);        while (m.find()) {            String[] str = m.group().split("=");            multiMap.put(str[0], str[1]);        }    }    return multiMap;}
public void metron_f6089_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public void metron_f6090_0()
{}
public boolean metron_f6092_0(JSONObject message)
{    return true;}
public JSONObject metron_f6093_0() throws ParseException
{    JSONObject toReturn = object();    if (!ensureEOF())        throw new IllegalStateException("Expected EOF, but still had content to parse");    return toReturn;}
public final boolean metron_f6094_0() throws ParseException
{    switch(jj_nt.kind) {        case COMMA:            jj_consume_token(COMMA);            break;        default:            jj_la1[0] = jj_gen;            ;    }    jj_consume_token(0);    {        if (true)            return true;    }    throw new Error("Missing return statement in function");}
public final JSONObject metron_f6095_0() throws ParseException
{    final JSONObject json = new JSONObject();    String key;    Object value;    key = objectKey();    jj_consume_token(EQUALS);    value = value();    json.put(key, value);    key = null;    value = null;    label_1: while (true) {        switch(jj_nt.kind) {            case SLASH:                ;                break;            default:                jj_la1[1] = jj_gen;                break label_1;        }        jj_consume_token(SLASH);        jj_consume_token(COMMA);        key = objectKey();        jj_consume_token(EQUALS);        value = value();        json.put(key, value);        key = null;        value = null;    }    {        if (true)            return json;    }    throw new Error("Missing return statement in function");}
public final JSONObject metron_f6096_0() throws ParseException
{    final JSONObject json = new JSONObject();    String key;    Object value;    key = objectKey();    jj_consume_token(EQUALS);    value = value();    json.put(key, value);    key = null;    value = null;    label_2: while (true) {        if (jj_2_1(2)) {            ;        } else {            break label_2;        }        jj_consume_token(COMMA);        key = objectKey();        jj_consume_token(EQUALS);        value = value();        json.put(key, value);        key = null;        value = null;    }    {        if (true)            return json;    }    throw new Error("Missing return statement in function");}
public final String metron_f6097_0() throws ParseException
{    String k;    k = string();        {        if (true)            return k.trim();    }    throw new Error("Missing return statement in function");}
public final Object metron_f6098_0() throws ParseException
{    Object x;    String eof = "EOF";    Map m = null;    if (jj_2_2(2147483647)) {        x = nullValue();    } else if (jj_2_3(2147483647)) {        x = innerMap();    } else {        switch(jj_nt.kind) {            case TAG:                x = tagString();                break;            default:                jj_la1[2] = jj_gen;                if (jj_2_4(2147483647)) {                    x = blankValue();                } else if (jj_2_5(2147483647)) {                    x = braced_string();                } else if (jj_2_6(2)) {                    x = string();                } else {                    jj_consume_token(-1);                    throw new ParseException();                }        }    }                {        if (true)            return x;    }    throw new Error("Missing return statement in function");}
public final String metron_f6099_0() throws ParseException
{    {        if (true)            return null;    }    throw new Error("Missing return statement in function");}
public final String metron_f6100_0() throws ParseException
{    String output = "(tag=0)";    jj_consume_token(TAG);    jj_consume_token(STRING_BODY);    {        if (true)            return output + token.image;    }    throw new Error("Missing return statement in function");}
public final String metron_f6101_0() throws ParseException
{    {        if (true)            return null;    }    throw new Error("Missing return statement in function");}
public final String metron_f6102_0() throws ParseException
{    String s;    jj_consume_token(STRING_BODY);    {        if (true)            return token.image.trim();    }    throw new Error("Missing return statement in function");}
public final String metron_f6103_0() throws ParseException
{    String s;    jj_consume_token(BRACED_STRING);        s = token.image;    jj_consume_token(COMMA);    {        if (true)            return s.trim();    }    throw new Error("Missing return statement in function");}
private boolean metron_f6104_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_1();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(0, xla);    }}
private boolean metron_f6105_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_2();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(1, xla);    }}
private boolean metron_f6106_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_3();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(2, xla);    }}
private boolean metron_f6107_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_4();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(3, xla);    }}
private boolean metron_f6108_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_5();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(4, xla);    }}
private boolean metron_f6109_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_6();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(5, xla);    }}
private boolean metron_f6110_0()
{    if (jj_3R_5())        return true;    return false;}
private boolean metron_f6111_0()
{    if (jj_scan_token(0))        return true;    return false;}
private boolean metron_f6112_0()
{    if (jj_scan_token(BRACED_STRING))        return true;    if (jj_scan_token(COMMA))        return true;    return false;}
private boolean metron_f6113_0()
{    if (jj_3R_4())        return true;    return false;}
private boolean metron_f6114_0()
{    if (jj_3R_3())        return true;    if (jj_scan_token(EQUALS))        return true;    if (jj_3R_7())        return true;    Token xsp;    while (true) {        xsp = jj_scanpos;        if (jj_3R_8()) {            jj_scanpos = xsp;            break;        }    }    return false;}
private boolean metron_f6115_0()
{    if (jj_scan_token(COMMA))        return true;    return false;}
private boolean metron_f6116_0()
{    if (jj_3R_6())        return true;    return false;}
private boolean metron_f6117_0()
{    if (jj_scan_token(COMMA))        return true;    if (jj_3R_3())        return true;    return false;}
private boolean metron_f6118_0()
{    if (jj_3R_5())        return true;    return false;}
private boolean metron_f6119_0()
{    if (jj_3R_16())        return true;    return false;}
private boolean metron_f6120_0()
{    if (jj_3R_15())        return true;    return false;}
private boolean metron_f6121_0()
{    if (jj_scan_token(STRING_BODY))        return true;    return false;}
private boolean metron_f6122_0()
{    if (jj_3R_4())        return true;    return false;}
private boolean metron_f6123_0()
{    if (jj_3R_14())        return true;    return false;}
private boolean metron_f6124_0()
{    Token xsp;    xsp = jj_scanpos;    if (jj_3R_9()) {        jj_scanpos = xsp;        if (jj_3R_10()) {            jj_scanpos = xsp;            if (jj_3R_11()) {                jj_scanpos = xsp;                if (jj_3R_12()) {                    jj_scanpos = xsp;                    if (jj_3R_13()) {                        jj_scanpos = xsp;                        if (jj_3_6())                            return true;                    }                }            }        }    }    return false;}
private boolean metron_f6125_0()
{    return false;}
private boolean metron_f6126_0()
{    if (jj_scan_token(TAG))        return true;    if (jj_scan_token(STRING_BODY))        return true;    return false;}
private boolean metron_f6127_0()
{    if (jj_3R_6())        return true;    return false;}
private boolean metron_f6128_0()
{    if (jj_scan_token(SLASH))        return true;    if (jj_scan_token(COMMA))        return true;    if (jj_3R_3())        return true;    if (jj_scan_token(EQUALS))        return true;    if (jj_3R_7())        return true;    return false;}
private boolean metron_f6129_0()
{    return false;}
private static void metron_f6130_0()
{    jj_la1_0 = new int[] { 0x20, 0x80, 0x100 };}
public void metron_f6131_0(java.io.InputStream stream)
{    ReInit(stream, null);}
public void metron_f6132_0(java.io.InputStream stream, String encoding)
{    try {        jj_input_stream.ReInit(stream, encoding, 1, 1);    } catch (java.io.UnsupportedEncodingException e) {        throw new RuntimeException(e);    }    token_source.ReInit(jj_input_stream);    token = new Token();    token.next = jj_nt = token_source.getNextToken();    jj_gen = 0;    for (int i = 0; i < 3; i++) jj_la1[i] = -1;    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();}
public void metron_f6133_0(java.io.Reader stream)
{    jj_input_stream.ReInit(stream, 1, 1);    token_source.ReInit(jj_input_stream);    token = new Token();    token.next = jj_nt = token_source.getNextToken();    jj_gen = 0;    for (int i = 0; i < 3; i++) jj_la1[i] = -1;    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();}
public void metron_f6134_0(ISEParserTokenManager tm)
{    token_source = tm;    token = new Token();    token.next = jj_nt = token_source.getNextToken();    jj_gen = 0;    for (int i = 0; i < 3; i++) jj_la1[i] = -1;    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();}
private Token metron_f6135_0(int kind) throws ParseException
{    Token oldToken = token;    if ((token = jj_nt).next != null)        jj_nt = jj_nt.next;    else        jj_nt = jj_nt.next = token_source.getNextToken();    if (token.kind == kind) {        jj_gen++;        if (++jj_gc > 100) {            jj_gc = 0;            for (int i = 0; i < jj_2_rtns.length; i++) {                JJCalls c = jj_2_rtns[i];                while (c != null) {                    if (c.gen < jj_gen)                        c.first = null;                    c = c.next;                }            }        }        return token;    }    jj_nt = token;    token = oldToken;    jj_kind = kind;    throw generateParseException();}
private boolean metron_f6136_0(int kind)
{    if (jj_scanpos == jj_lastpos) {        jj_la--;        if (jj_scanpos.next == null) {            jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();        } else {            jj_lastpos = jj_scanpos = jj_scanpos.next;        }    } else {        jj_scanpos = jj_scanpos.next;    }    if (jj_rescan) {        int i = 0;        Token tok = token;        while (tok != null && tok != jj_scanpos) {            i++;            tok = tok.next;        }        if (tok != null)            jj_add_error_token(kind, i);    }    if (jj_scanpos.kind != kind)        return true;    if (jj_la == 0 && jj_scanpos == jj_lastpos)        throw jj_ls;    return false;}
public final Token metron_f6137_0()
{    if ((token = jj_nt).next != null)        jj_nt = jj_nt.next;    else        jj_nt = jj_nt.next = token_source.getNextToken();    jj_gen++;    return token;}
public final Token metron_f6138_0(int index)
{    Token t = token;    for (int i = 0; i < index; i++) {        if (t.next != null)            t = t.next;        else            t = t.next = token_source.getNextToken();    }    return t;}
private void metron_f6139_0(int kind, int pos)
{    if (pos >= 100)        return;    if (pos == jj_endpos + 1) {        jj_lasttokens[jj_endpos++] = kind;    } else if (jj_endpos != 0) {        jj_expentry = new int[jj_endpos];        for (int i = 0; i < jj_endpos; i++) {            jj_expentry[i] = jj_lasttokens[i];        }        jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext(); ) {            int[] oldentry = (int[]) (it.next());            if (oldentry.length == jj_expentry.length) {                for (int i = 0; i < jj_expentry.length; i++) {                    if (oldentry[i] != jj_expentry[i]) {                        continue jj_entries_loop;                    }                }                jj_expentries.add(jj_expentry);                break jj_entries_loop;            }        }        if (pos != 0)            jj_lasttokens[(jj_endpos = pos) - 1] = kind;    }}
public ParseException metron_f6140_0()
{    jj_expentries.clear();    boolean[] la1tokens = new boolean[11];    if (jj_kind >= 0) {        la1tokens[jj_kind] = true;        jj_kind = -1;    }    for (int i = 0; i < 3; i++) {        if (jj_la1[i] == jj_gen) {            for (int j = 0; j < 32; j++) {                if ((jj_la1_0[i] & (1 << j)) != 0) {                    la1tokens[j] = true;                }            }        }    }    for (int i = 0; i < 11; i++) {        if (la1tokens[i]) {            jj_expentry = new int[1];            jj_expentry[0] = i;            jj_expentries.add(jj_expentry);        }    }    jj_endpos = 0;    jj_rescan_token();    jj_add_error_token(0, 0);    int[][] exptokseq = new int[jj_expentries.size()][];    for (int i = 0; i < jj_expentries.size(); i++) {        exptokseq[i] = jj_expentries.get(i);    }    return new ParseException(token, exptokseq, tokenImage);}
public final void metron_f6141_0()
{}
public final void metron_f6142_0()
{}
private void metron_f6143_0()
{    jj_rescan = true;    for (int i = 0; i < 6; i++) {        try {            JJCalls p = jj_2_rtns[i];            do {                if (p.gen > jj_gen) {                    jj_la = p.arg;                    jj_lastpos = jj_scanpos = p.first;                    switch(i) {                        case 0:                            jj_3_1();                            break;                        case 1:                            jj_3_2();                            break;                        case 2:                            jj_3_3();                            break;                        case 3:                            jj_3_4();                            break;                        case 4:                            jj_3_5();                            break;                        case 5:                            jj_3_6();                            break;                    }                }                p = p.next;            } while (p != null);        } catch (LookaheadSuccess ls) {        }    }    jj_rescan = false;}
private void metron_f6144_0(int index, int xla)
{    JJCalls p = jj_2_rtns[index];    while (p.gen > jj_gen) {        if (p.next == null) {            p = p.next = new JJCalls();            break;        }        p = p.next;    }    p.gen = jj_gen + xla - jj_la;    p.first = token;    p.arg = xla;}
public void metron_f6145_0(java.io.PrintStream ds)
{    debugStream = ds;}
private final int metron_f6146_0(int pos, long active0)
{    switch(pos) {        case 0:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                return 18;            }            if ((active0 & 0x80L) != 0L)                return 6;            return -1;        case 1:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                jjmatchedPos = 1;                return 18;            }            return -1;        case 2:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                jjmatchedPos = 2;                return 18;            }            return -1;        case 3:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                jjmatchedPos = 3;                return 18;            }            return -1;        case 4:            if ((active0 & 0x100L) != 0L) {                if (jjmatchedPos < 3) {                    jjmatchedKind = 9;                    jjmatchedPos = 3;                }                return -1;            }            return -1;        case 5:            if ((active0 & 0x100L) != 0L) {                if (jjmatchedPos < 3) {                    jjmatchedKind = 9;                    jjmatchedPos = 3;                }                return -1;            }            return -1;        default:            return -1;    }}
private final int metron_f6147_0(int pos, long active0)
{    return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);}
private int metron_f6148_0(int pos, int kind)
{    jjmatchedKind = kind;    jjmatchedPos = pos;    return pos + 1;}
private int metron_f6149_0()
{    switch(curChar) {        case 40:            return jjMoveStringLiteralDfa1_0(0x100L);        case 44:            return jjStopAtPos(0, 5);        case 61:            return jjStopAtPos(0, 6);        case 92:            return jjStartNfaWithStates_0(0, 7, 6);        default:            return jjMoveNfa_0(0, 0);    }}
private int metron_f6150_0(long active0)
{    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(0, active0);        return 1;    }    switch(curChar) {        case 84:        case 116:            return jjMoveStringLiteralDfa2_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(0, active0);}
private int metron_f6151_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(0, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(1, active0);        return 2;    }    switch(curChar) {        case 65:        case 97:            return jjMoveStringLiteralDfa3_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(1, active0);}
private int metron_f6152_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(1, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(2, active0);        return 3;    }    switch(curChar) {        case 71:        case 103:            return jjMoveStringLiteralDfa4_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(2, active0);}
private int metron_f6153_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(2, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(3, active0);        return 4;    }    switch(curChar) {        case 61:            return jjMoveStringLiteralDfa5_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(3, active0);}
private int metron_f6154_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(3, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(4, active0);        return 5;    }    switch(curChar) {        case 48:            return jjMoveStringLiteralDfa6_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(4, active0);}
private int metron_f6155_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(4, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(5, active0);        return 6;    }    switch(curChar) {        case 41:            if ((active0 & 0x100L) != 0L)                return jjStopAtPos(6, 8);            break;        default:            break;    }    return jjStartNfa_0(5, active0);}
private int metron_f6156_0(int pos, int kind, int state)
{    jjmatchedKind = kind;    jjmatchedPos = pos;    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        return pos + 1;    }    return jjMoveNfa_0(state, pos + 1);}
private int metron_f6157_0(int startState, int curPos)
{    int startsAt = 0;    jjnewStateCnt = 18;    int i = 1;    jjstateSet[0] = startState;    int kind = 0x7fffffff;    for (; ; ) {        if (++jjround == 0x7fffffff)            ReInitRounds();        if (curChar < 64) {            long l = 1L << curChar;            do {                switch(jjstateSet[--i]) {                    case 18:                    case 4:                        if ((0xdfffeffbffffc9ffL & l) == 0L)                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 0:                        if ((0xdfffeffbffffc9ffL & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        } else if ((0x3400L & l) != 0L) {                            if (kind > 4)                                kind = 4;                        }                        if (curChar == 47)                            jjAddStates(0, 1);                        else if (curChar == 35)                            jjCheckNAddTwoStates(1, 2);                        break;                    case 6:                        if ((0xdfffeffbffffc9ffL & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        }                        if ((0x900400000000L & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        }                        break;                    case 1:                        if ((0xffffffffffffcbffL & l) != 0L)                            jjCheckNAddTwoStates(1, 2);                        break;                    case 2:                        if ((0x3400L & l) != 0L && kind > 3)                            kind = 3;                        break;                    case 3:                        if ((0x3400L & l) != 0L && kind > 4)                            kind = 4;                        break;                    case 8:                        jjAddStates(2, 3);                        break;                    case 10:                        if (curChar == 47)                            jjAddStates(0, 1);                        break;                    case 11:                        if (curChar == 47)                            jjCheckNAddTwoStates(12, 13);                        break;                    case 12:                        if ((0xffffffffffffcbffL & l) != 0L)                            jjCheckNAddTwoStates(12, 13);                        break;                    case 13:                        if ((0x3400L & l) != 0L && kind > 1)                            kind = 1;                        break;                    case 14:                        if (curChar == 42)                            jjCheckNAddTwoStates(15, 17);                        break;                    case 15:                        jjCheckNAddTwoStates(15, 17);                        break;                    case 16:                        if (curChar == 47 && kind > 2)                            kind = 2;                        break;                    case 17:                        if (curChar == 42)                            jjstateSet[jjnewStateCnt++] = 16;                        break;                    default:                        break;                }            } while (i != startsAt);        } else if (curChar < 128) {            long l = 1L << (curChar & 077);            do {                switch(jjstateSet[--i]) {                    case 18:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 0:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        if (curChar == 123)                            jjCheckNAdd(8);                        else if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 6:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        if ((0x14404410144044L & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        }                        if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 1:                        jjAddStates(4, 5);                        break;                    case 4:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 5:                        if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 7:                        if (curChar == 123)                            jjCheckNAdd(8);                        break;                    case 8:                        if ((0xd7ffffffffffffffL & l) != 0L)                            jjCheckNAddTwoStates(8, 9);                        break;                    case 9:                        if (curChar == 125 && kind > 10)                            kind = 10;                        break;                    case 12:                        jjAddStates(6, 7);                        break;                    case 15:                        jjAddStates(8, 9);                        break;                    default:                        break;                }            } while (i != startsAt);        } else {            int hiByte = (int) (curChar >> 8);            int i1 = hiByte >> 6;            long l1 = 1L << (hiByte & 077);            int i2 = (curChar & 0xff) >> 6;            long l2 = 1L << (curChar & 077);            do {                switch(jjstateSet[--i]) {                    case 18:                    case 4:                        if (!jjCanMove_0(hiByte, i1, i2, l1, l2))                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 0:                        if (!jjCanMove_0(hiByte, i1, i2, l1, l2))                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 6:                        if (!jjCanMove_0(hiByte, i1, i2, l1, l2))                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 1:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(4, 5);                        break;                    case 8:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(2, 3);                        break;                    case 12:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(6, 7);                        break;                    case 15:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(8, 9);                        break;                    default:                        break;                }            } while (i != startsAt);        }        if (kind != 0x7fffffff) {            jjmatchedKind = kind;            jjmatchedPos = curPos;            kind = 0x7fffffff;        }        ++curPos;        if ((i = jjnewStateCnt) == (startsAt = 18 - (jjnewStateCnt = startsAt)))            return curPos;        try {            curChar = input_stream.readChar();        } catch (java.io.IOException e) {            return curPos;        }    }}
private static final boolean metron_f6158_0(int hiByte, int i1, int i2, long l1, long l2)
{    switch(hiByte) {        case 0:            return ((jjbitVec2[i2] & l2) != 0L);        default:            if ((jjbitVec0[i1] & l1) != 0L)                return true;            return false;    }}
public void metron_f6159_0(JavaCharStream stream)
{    jjmatchedPos = jjnewStateCnt = 0;    curLexState = defaultLexState;    input_stream = stream;    ReInitRounds();}
private void metron_f6160_0()
{    int i;    jjround = 0x80000001;    for (i = 18; i-- > 0; ) jjrounds[i] = 0x80000000;}
public void metron_f6161_0(JavaCharStream stream, int lexState)
{    ReInit(stream);    SwitchTo(lexState);}
public void metron_f6162_0(int lexState)
{    if (lexState >= 1 || lexState < 0)        throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);    else        curLexState = lexState;}
protected Token metron_f6163_0()
{    final Token t;    final String curTokenImage;    final int beginLine;    final int endLine;    final int beginColumn;    final int endColumn;    String im = jjstrLiteralImages[jjmatchedKind];    curTokenImage = (im == null) ? input_stream.GetImage() : im;    beginLine = input_stream.getBeginLine();    beginColumn = input_stream.getBeginColumn();    endLine = input_stream.getEndLine();    endColumn = input_stream.getEndColumn();    t = Token.newToken(jjmatchedKind, curTokenImage);    t.beginLine = beginLine;    t.endLine = endLine;    t.beginColumn = beginColumn;    t.endColumn = endColumn;    return t;}
public Token metron_f6164_0()
{    Token matchedToken;    int curPos = 0;    EOFLoop: for (; ; ) {        try {            curChar = input_stream.BeginToken();        } catch (java.io.IOException e) {            jjmatchedKind = 0;            matchedToken = jjFillToken();            return matchedToken;        }        jjmatchedKind = 0x7fffffff;        jjmatchedPos = 0;        curPos = jjMoveStringLiteralDfa0_0();        if (jjmatchedKind != 0x7fffffff) {            if (jjmatchedPos + 1 < curPos)                input_stream.backup(curPos - jjmatchedPos - 1);            if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {                matchedToken = jjFillToken();                return matchedToken;            } else {                continue EOFLoop;            }        }        int error_line = input_stream.getEndLine();        int error_column = input_stream.getEndColumn();        String error_after = null;        boolean EOFSeen = false;        try {            input_stream.readChar();            input_stream.backup(1);        } catch (java.io.IOException e1) {            EOFSeen = true;            error_after = curPos <= 1 ? "" : input_stream.GetImage();            if (curChar == '\n' || curChar == '\r') {                error_line++;                error_column = 0;            } else                error_column++;        }        if (!EOFSeen) {            input_stream.backup(1);            error_after = curPos <= 1 ? "" : input_stream.GetImage();        }        throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);    }}
private void metron_f6165_0(int state)
{    if (jjrounds[state] != jjround) {        jjstateSet[jjnewStateCnt++] = state;        jjrounds[state] = jjround;    }}
private void metron_f6166_0(int start, int end)
{    do {        jjstateSet[jjnewStateCnt++] = jjnextStates[start];    } while (start++ != end);}
private void metron_f6167_0(int state1, int state2)
{    jjCheckNAdd(state1);    jjCheckNAdd(state2);}
 static final int metron_f6168_0(char c) throws java.io.IOException
{    switch(c) {        case '0':            return 0;        case '1':            return 1;        case '2':            return 2;        case '3':            return 3;        case '4':            return 4;        case '5':            return 5;        case '6':            return 6;        case '7':            return 7;        case '8':            return 8;        case '9':            return 9;        case 'a':        case 'A':            return 10;        case 'b':        case 'B':            return 11;        case 'c':        case 'C':            return 12;        case 'd':        case 'D':            return 13;        case 'e':        case 'E':            return 14;        case 'f':        case 'F':            return 15;    }        throw new java.io.IOException();}
protected void metron_f6169_0(int i)
{    tabSize = i;}
protected int metron_f6170_0(int i)
{    return tabSize;}
protected void metron_f6171_0(boolean wrapAround)
{    char[] newbuffer = new char[bufsize + 2048];    int[] newbufline = new int[bufsize + 2048];    int[] newbufcolumn = new int[bufsize + 2048];    try {        if (wrapAround) {            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);            System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);            buffer = newbuffer;            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);            bufline = newbufline;            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);            bufcolumn = newbufcolumn;            bufpos += (bufsize - tokenBegin);        } else {            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);            buffer = newbuffer;            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);            bufline = newbufline;            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);            bufcolumn = newbufcolumn;            bufpos -= tokenBegin;        }    } catch (Throwable t) {        throw new Error(t.getMessage());    }    available = (bufsize += 2048);    tokenBegin = 0;}
protected void metron_f6172_0() throws java.io.IOException
{    int i;    if (maxNextCharInd == 4096)        maxNextCharInd = nextCharInd = 0;    try {        if ((i = inputStream.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd)) == -1) {            inputStream.close();            throw new java.io.IOException();        } else            maxNextCharInd += i;        return;    } catch (java.io.IOException e) {        if (bufpos != 0) {            --bufpos;            backup(0);        } else {            bufline[bufpos] = line;            bufcolumn[bufpos] = column;        }        throw e;    }}
protected char metron_f6173_0() throws java.io.IOException
{    if (++nextCharInd >= maxNextCharInd)        FillBuff();    return nextCharBuf[nextCharInd];}
public char metron_f6174_0() throws java.io.IOException
{    if (inBuf > 0) {        --inBuf;        if (++bufpos == bufsize)            bufpos = 0;        tokenBegin = bufpos;        return buffer[bufpos];    }    tokenBegin = 0;    bufpos = -1;    return readChar();}
protected void metron_f6175_0()
{    if (available == bufsize) {        if (tokenBegin > 2048) {            bufpos = 0;            available = tokenBegin;        } else            ExpandBuff(false);    } else if (available > tokenBegin)        available = bufsize;    else if ((tokenBegin - available) < 2048)        ExpandBuff(true);    else        available = tokenBegin;}
protected void metron_f6176_0(char c)
{    column++;    if (prevCharIsLF) {        prevCharIsLF = false;        line += (column = 1);    } else if (prevCharIsCR) {        prevCharIsCR = false;        if (c == '\n') {            prevCharIsLF = true;        } else            line += (column = 1);    }    switch(c) {        case '\r':            prevCharIsCR = true;            break;        case '\n':            prevCharIsLF = true;            break;        case '\t':            column--;            column += (tabSize - (column % tabSize));            break;        default:            break;    }    bufline[bufpos] = line;    bufcolumn[bufpos] = column;}
public char metron_f6177_0() throws java.io.IOException
{    if (inBuf > 0) {        --inBuf;        if (++bufpos == bufsize)            bufpos = 0;        return buffer[bufpos];    }    char c;    if (++bufpos == available)        AdjustBuffSize();    if ((buffer[bufpos] = c = ReadByte()) == '\\') {        UpdateLineColumn(c);        int backSlashCnt = 1;        for (; ; )         {            if (++bufpos == available)                AdjustBuffSize();            try {                if ((buffer[bufpos] = c = ReadByte()) != '\\') {                    UpdateLineColumn(c);                                        if ((c == 'u') && ((backSlashCnt & 1) == 1)) {                        if (--bufpos < 0)                            bufpos = bufsize - 1;                        break;                    }                    backup(backSlashCnt);                    return '\\';                }            } catch (java.io.IOException e) {                                if (backSlashCnt > 1)                    backup(backSlashCnt - 1);                return '\\';            }            UpdateLineColumn(c);            backSlashCnt++;        }                try {            while ((c = ReadByte()) == 'u') ++column;            buffer[bufpos] = c = (char) (hexval(c) << 12 | hexval(ReadByte()) << 8 | hexval(ReadByte()) << 4 | hexval(ReadByte()));            column += 4;        } catch (java.io.IOException e) {            throw new Error("Invalid escape character at line " + line + " column " + column + ".");        }        if (backSlashCnt == 1)            return c;        else {            backup(backSlashCnt - 1);            return '\\';        }    } else {        UpdateLineColumn(c);        return c;    }}
public int metron_f6178_0()
{    return bufcolumn[bufpos];}
public int metron_f6179_0()
{    return bufline[bufpos];}
public int metron_f6180_0()
{    return bufcolumn[bufpos];}
public int metron_f6181_0()
{    return bufline[bufpos];}
public int metron_f6182_0()
{    return bufcolumn[tokenBegin];}
public int metron_f6183_0()
{    return bufline[tokenBegin];}
public void metron_f6184_0(int amount)
{    inBuf += amount;    if ((bufpos -= amount) < 0)        bufpos += bufsize;}
public void metron_f6185_0(java.io.Reader dstream, int startline, int startcolumn, int buffersize)
{    inputStream = dstream;    line = startline;    column = startcolumn - 1;    if (buffer == null || buffersize != buffer.length) {        available = bufsize = buffersize;        buffer = new char[buffersize];        bufline = new int[buffersize];        bufcolumn = new int[buffersize];        nextCharBuf = new char[4096];    }    prevCharIsLF = prevCharIsCR = false;    tokenBegin = inBuf = maxNextCharInd = 0;    nextCharInd = bufpos = -1;}
public void metron_f6186_0(java.io.Reader dstream, int startline, int startcolumn)
{    ReInit(dstream, startline, startcolumn, 4096);}
public void metron_f6187_0(java.io.Reader dstream)
{    ReInit(dstream, 1, 1, 4096);}
public void metron_f6188_0(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
{    ReInit(encoding == null ? new java.io.InputStreamReader(dstream, StandardCharsets.UTF_8) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);}
public void metron_f6189_0(java.io.InputStream dstream, int startline, int startcolumn, int buffersize)
{    ReInit(new java.io.InputStreamReader(dstream, StandardCharsets.UTF_8), startline, startcolumn, buffersize);}
public void metron_f6190_0(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException
{    ReInit(dstream, encoding, startline, startcolumn, 4096);}
public void metron_f6191_0(java.io.InputStream dstream, int startline, int startcolumn)
{    ReInit(dstream, startline, startcolumn, 4096);}
public void metron_f6192_0(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
{    ReInit(dstream, encoding, 1, 1, 4096);}
public void metron_f6193_0(java.io.InputStream dstream)
{    ReInit(dstream, 1, 1, 4096);}
public String metron_f6194_0()
{    if (bufpos >= tokenBegin)        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);    else        return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);}
public char[] metron_f6195_0(int len)
{    char[] ret = new char[len];    if ((bufpos + 1) >= len)        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);    else {        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);    }    return ret;}
public void metron_f6196_0()
{    nextCharBuf = null;    buffer = null;    bufline = null;    bufcolumn = null;}
public void metron_f6197_0(int newLine, int newCol)
{    int start = tokenBegin;    int len;    if (bufpos >= tokenBegin) {        len = bufpos - tokenBegin + inBuf + 1;    } else {        len = bufsize - tokenBegin + bufpos + 1 + inBuf;    }    int i = 0, j = 0, k = 0;    int nextColDiff = 0, columnDiff = 0;    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {        bufline[j] = newLine;        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];        bufcolumn[j] = newCol + columnDiff;        columnDiff = nextColDiff;        i++;    }    if (i < len) {        bufline[j] = newLine++;        bufcolumn[j] = newCol + columnDiff;        while (i++ < len) {            if (bufline[j = start % bufsize] != bufline[++start % bufsize])                bufline[j] = newLine++;            else                bufline[j] = newLine;        }    }    line = bufline[j];    column = bufcolumn[j];}
private static String metron_f6198_0(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage)
{    String eol = System.getProperty("line.separator", "\n");    StringBuffer expected = new StringBuffer();    int maxSize = 0;    for (int i = 0; i < expectedTokenSequences.length; i++) {        if (maxSize < expectedTokenSequences[i].length) {            maxSize = expectedTokenSequences[i].length;        }        for (int j = 0; j < expectedTokenSequences[i].length; j++) {            expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');        }        if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {            expected.append("...");        }        expected.append(eol).append("    ");    }    String retval = "Encountered \"";    Token tok = currentToken.next;    for (int i = 0; i < maxSize; i++) {        if (i != 0)            retval += " ";        if (tok.kind == 0) {            retval += tokenImage[0];            break;        }        retval += " " + tokenImage[tok.kind];        retval += " \"";        retval += add_escapes(tok.image);        retval += " \"";        tok = tok.next;    }    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;    retval += "." + eol;    if (expectedTokenSequences.length == 1) {        retval += "Was expecting:" + eol + "    ";    } else {        retval += "Was expecting one of:" + eol + "    ";    }    retval += expected.toString();    return retval;}
 static String metron_f6199_0(String str)
{    StringBuffer retval = new StringBuffer();    char ch;    for (int i = 0; i < str.length(); i++) {        switch(str.charAt(i)) {            case 0:                continue;            case '\b':                retval.append("\\b");                continue;            case '\t':                retval.append("\\t");                continue;            case '\n':                retval.append("\\n");                continue;            case '\f':                retval.append("\\f");                continue;            case '\r':                retval.append("\\r");                continue;            case '\"':                retval.append("\\\"");                continue;            case '\'':                retval.append("\\\'");                continue;            case '\\':                retval.append("\\\\");                continue;            default:                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {                    String s = "0000" + Integer.toString(ch, 16);                    retval.append("\\u" + s.substring(s.length() - 4, s.length()));                } else {                    retval.append(ch);                }                continue;        }    }    return retval.toString();}
public Object metron_f6200_0()
{    return null;}
public String metron_f6201_0()
{    return image;}
public static Token metron_f6202_0(int ofKind, String image)
{    switch(ofKind) {        default:            return new Token(ofKind, image);    }}
public static Token metron_f6203_0(int ofKind)
{    return newToken(ofKind, null);}
protected static final String metron_f6204_0(String str)
{    StringBuffer retval = new StringBuffer();    char ch;    for (int i = 0; i < str.length(); i++) {        switch(str.charAt(i)) {            case 0:                continue;            case '\b':                retval.append("\\b");                continue;            case '\t':                retval.append("\\t");                continue;            case '\n':                retval.append("\\n");                continue;            case '\f':                retval.append("\\f");                continue;            case '\r':                retval.append("\\r");                continue;            case '\"':                retval.append("\\\"");                continue;            case '\'':                retval.append("\\\'");                continue;            case '\\':                retval.append("\\\\");                continue;            default:                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {                    String s = "0000" + Integer.toString(ch, 16);                    retval.append("\\u" + s.substring(s.length() - 4, s.length()));                } else {                    retval.append(ch);                }                continue;        }    }    return retval.toString();}
protected static String metron_f6205_0(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)
{    return ("Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int) curChar + "), ") + "after : \"" + addEscapes(errorAfter) + "\"");}
public String metron_f6206_0()
{    return super.getMessage();}
public void metron_f6207_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public void metron_f6208_0()
{}
public String metron_f6210_0()
{    return name;}
public void metron_f6211_0()
{        String syslogTime = "(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\\b +(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]) (?!<[0-9])(?:2[0123]|[01]?[0-9]):(?:[0-5][0-9])(?::(?:(?:[0-5]?[0-9]|60)(?:[:.,][0-9]+)?))(?![0-9])?";    String syslogTime5424 = "(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2}))";    String syslogPriority = "<(?:[0-9]+)>";    String syslogHost = "[a-z0-9\\.\\\\-_]+";    StringBuilder sb = new StringBuilder("");    sb.append("(?<syslogPriority>");    sb.append(syslogPriority);    sb.append(")?");    sb.append("(?<syslogTime>");    sb.append(syslogTime);    sb.append("|");    sb.append(syslogTime5424);    sb.append(")?");    sb.append("(?<syslogHost>");    sb.append(syslogHost);    sb.append(")?");    sb.append(".*");    sb.append("LEEF:(?<");    sb.append(HeaderFields.VERSION.getName());    sb.append(">1.0|2.0|0)?\\|");    headerBlock(HeaderFields.DEVICE_VENDOR.getName(), sb);    sb.append("\\|");    headerBlock(HeaderFields.DEVICE_PRODUCT.getName(), sb);    sb.append("\\|");    headerBlock(HeaderFields.DEVICE_VERSION.getName(), sb);    sb.append("\\|");    headerBlock(HeaderFields.DEVICE_EVENT.getName(), sb);    sb.append("\\|");        sb.append("(");    headerBlock(HeaderFields.DELIMITER.getName(), sb);    sb.append("\\|");    sb.append(")?");        sb.append(" ?(?<extensions>.*)");    pattern = Pattern.compile(sb.toString());}
public Optional<MessageParserResult<JSONObject>> metron_f6212_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    Map<Object, Throwable> errors = new HashMap<>();    String originalMessage = null;    try (BufferedReader reader = new BufferedReader(new StringReader(new String(rawMessage, getReadCharset())))) {        while ((originalMessage = reader.readLine()) != null) {            Matcher matcher = pattern.matcher(originalMessage);            while (matcher.find()) {                JSONObject obj = new JSONObject();                if (!matcher.matches()) {                    break;                }                                obj.put(HeaderFields.DEVICE_VENDOR.getName(), matcher.group(HeaderFields.DEVICE_VENDOR.getName()));                obj.put(HeaderFields.DEVICE_PRODUCT.getName(), matcher.group(HeaderFields.DEVICE_PRODUCT.getName()));                obj.put(HeaderFields.DEVICE_VERSION.getName(), matcher.group(HeaderFields.DEVICE_VERSION.getName()));                obj.put(HeaderFields.DEVICE_EVENT.getName(), matcher.group(HeaderFields.DEVICE_EVENT.getName()));                String ext = matcher.group("extensions");                                String version = matcher.group(HeaderFields.VERSION.getName());                if (version.equals("2.0")) {                    String delimiter = matcher.group(HeaderFields.DELIMITER.getName());                    if (delimiter == null || delimiter.length() == 0) {                        delimiter = "\\t";                    }                    delimiter = "(?<!\\\\)[" + delimiter.replace("^", "\\^").replace("\t", "\\t") + "]";                    String[] kvs = ext.split(delimiter);                    for (String kv : kvs) {                        String[] a = kv.split("=");                        obj.put(a[0], a[1]);                    }                } else if (version.equals("1.0") || version.isEmpty()) {                    String delimiter = "\t";                    String[] kvs = ext.split(delimiter);                    for (String kv : kvs) {                        String[] a = kv.split("=");                        obj.put(a[0], a[1]);                    }                } else {                                                                                CEFParser.parseExtensions(ext, obj);                }                                obj = mutate(obj, "dst", Fields.DST_ADDR.getName());                obj = mutate(obj, "dstPort", Fields.DST_PORT.getName());                obj = convertToInt(obj, Fields.DST_PORT.getName());                obj = mutate(obj, "src", Fields.SRC_ADDR.getName());                obj = mutate(obj, "srcPort", Fields.SRC_PORT.getName());                obj = convertToInt(obj, Fields.SRC_PORT.getName());                obj.put(Fields.ORIGINAL.getName(), originalMessage);                                String host = matcher.group("syslogHost");                if (!(host == null || host.isEmpty())) {                    obj.put("host", host);                }                                if (obj.containsKey(DEV_TIME)) {                    String devTime = (String) obj.get(DEV_TIME);                    try {                                                                                                                                                                        final String devTimeFormat = (String) obj.get(DEV_TIME_FORMAT);                        List<SimpleDateFormat> formats = (obj.containsKey(DEV_TIME_FORMAT)) ? new ArrayList<SimpleDateFormat>() {                            {                                add(new SimpleDateFormat(devTimeFormat));                            }                        } : DateUtils.DATE_FORMATS_LEEF;                        obj.put(Fields.TIMESTAMP.getName(), DateUtils.parseMultiformat(devTime, formats));                    } catch (java.text.ParseException e) {                        errors.put(originalMessage, new IllegalStateException("devTime field present in LEEF but cannot be parsed", e));                        continue;                    }                } else {                    String logTimestamp = matcher.group("syslogTime");                    if (!(logTimestamp == null || logTimestamp.isEmpty())) {                        try {                            obj.put(Fields.TIMESTAMP.getName(), SyslogUtils.parseTimestampToEpochMillis(logTimestamp, Clock.systemUTC()));                        } catch (ParseException e) {                            errors.put(originalMessage, new IllegalStateException("Cannot parse syslog timestamp", e));                            continue;                        }                    } else {                        obj.put(Fields.TIMESTAMP.getName(), System.currentTimeMillis());                    }                }                messages.add(obj);            }        }    } catch (IOException e) {                Exception innerException = new IllegalStateException("LEEF parser Error: " + e.getMessage() + " on " + originalMessage, e);        return Optional.of(new DefaultMessageParserResult<>(innerException));    }    return Optional.of(new DefaultMessageParserResult<>(messages, errors));}
private JSONObject metron_f6213_0(JSONObject obj, String key)
{    if (obj.containsKey(key)) {        obj.put(key, Integer.valueOf((String) obj.get(key)));    }    return obj;}
private void metron_f6214_0(String name, StringBuilder sb)
{    sb.append("(?<").append(name).append(">").append(HEADER_CAPTURE_PATTERN).append(")");}
public void metron_f6215_0(Map<String, Object> config)
{    setReadCharset(config);}
private JSONObject metron_f6216_0(JSONObject json, String oldKey, String newKey)
{    if (json.containsKey(oldKey)) {        json.put(newKey, json.remove(oldKey));    }    return json;}
public void metron_f6217_0(Map<String, Object> parserConfig)
{}
public void metron_f6218_0()
{}
public List<JSONObject> metron_f6219_0(byte[] raw_message)
{    List<JSONObject> messages = new ArrayList<>();    try {        /*			 * We need to create a new JSONParser each time because its 			 * not serializable and the parser is created on the storm nimbus			 * node, then transfered to the workers.			 */        JSONParser jsonParser = new JSONParser();        String rawString = new String(raw_message, StandardCharsets.UTF_8);        JSONObject rawJson = (JSONObject) jsonParser.parse(rawString);                rawJson.remove("@version");        rawJson.remove("type");        rawJson.remove("host");        rawJson.remove("tags");                rawJson = mutate(rawJson, "message", "original_string");        rawJson = mutate(rawJson, "src_ip", "ip_src_addr");        rawJson = mutate(rawJson, "dst_ip", "ip_dst_addr");        rawJson = mutate(rawJson, "src_port", "ip_src_port");        rawJson = mutate(rawJson, "dst_port", "ip_dst_port");        rawJson = mutate(rawJson, "src_ip", "ip_src_addr");                long timestamp = LogstashToEpoch((String) rawJson.remove("@timestamp"));        rawJson.put("timestamp", timestamp);        messages.add(rawJson);        return messages;    } catch (Exception e) {        e.printStackTrace();        return null;    }}
private JSONObject metron_f6220_0(JSONObject json, String oldKey, String newKey)
{    if (json.containsKey(oldKey)) {        json.put(newKey, json.remove(oldKey));    }    return json;}
private long metron_f6221_0(String timestamp) throws java.text.ParseException
{    SimpleDateFormat logstashDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");    return logstashDateFormat.parse(timestamp).getTime();}
private static boolean metron_f6222_0(final String s)
{    return s == null || s.trim().isEmpty() || s.equals("\"\"");}
private static String metron_f6223_0(String s)
{    s = s.trim();    if (s.startsWith("\"") && s.endsWith("\""))        return s.substring(1, s.length() - 1);    return s;}
public void metron_f6224_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public void metron_f6225_0()
{}
private void metron_f6227_0(String message, JSONObject outputMessage)
{    String[] tokens = Iterables.toArray(Splitter.on(Pattern.compile(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)")).split(message), String.class);    int parser_version = 0;    String type = tokens[3].trim();        if (!type.equals(LogTypeConfig) && !type.equals(LogTypeThreat) && !type.equals(LogTypeTraffic) && !type.equals(LogTypeSystem)) {        throw new UnsupportedOperationException("Unsupported log type.");    }        if (!empty_attribute(tokens[0]))        outputMessage.put(PaloAltoDomain, tokens[0].trim());    if (!empty_attribute(tokens[1]))        outputMessage.put(ReceiveTime, tokens[1].trim());    if (!empty_attribute(tokens[2]))        outputMessage.put(SerialNum, tokens[2].trim());    outputMessage.put(Type, type);    if (!empty_attribute(tokens[4]))        outputMessage.put(ThreatContentType, unquoted_attribute(tokens[4]));    if (!empty_attribute(tokens[5]))        outputMessage.put(ConfigVersion, tokens[5].trim());    if (!empty_attribute(tokens[6]))        outputMessage.put(GenerateTime, tokens[6].trim());    if (LogTypeConfig.equals(type.toUpperCase())) {                if (tokens.length == 16 || tokens.length == 18)            parser_version = 61;        else if (tokens.length == 22 || tokens.length == 24)            parser_version = 80;        if (parser_version >= 61) {            if (!empty_attribute(tokens[7]))                outputMessage.put(HOST, tokens[7].trim());            if (!empty_attribute(tokens[8]))                outputMessage.put(VirtualSystem, tokens[8].trim());            if (!empty_attribute(tokens[9]))                outputMessage.put(Command, tokens[9].trim());            if (!empty_attribute(tokens[10]))                outputMessage.put(Admin, tokens[10].trim());            if (!empty_attribute(tokens[11]))                outputMessage.put(Client, unquoted_attribute(tokens[11]));            if (!empty_attribute(tokens[12]))                outputMessage.put(Result, unquoted_attribute(tokens[12]));            if (!empty_attribute(tokens[13]))                outputMessage.put(ConfigurationPath, unquoted_attribute(tokens[13]));        }        if (parser_version == 61) {            if (!empty_attribute(tokens[14]))                outputMessage.put(Seqno, unquoted_attribute(tokens[14]));            if (!empty_attribute(tokens[15]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[15]));            if (tokens.length == 18) {                if (!empty_attribute(tokens[16]))                    outputMessage.put(BeforeChangeDetail, unquoted_attribute(tokens[16]));                if (!empty_attribute(tokens[17]))                    outputMessage.put(AfterChangeDetail, unquoted_attribute(tokens[17]));            }        }        if (parser_version >= 70) {            int custom_fields_offset = 0;            if (tokens.length == 24) {                if (!empty_attribute(tokens[14])) {                    outputMessage.put(BeforeChangeDetail, unquoted_attribute(tokens[14 + custom_fields_offset]));                }                if (!empty_attribute(tokens[15])) {                    outputMessage.put(AfterChangeDetail, unquoted_attribute(tokens[15 + custom_fields_offset]));                }                custom_fields_offset = 2;            }            if (!empty_attribute(tokens[14 + custom_fields_offset])) {                outputMessage.put(Seqno, unquoted_attribute(tokens[14 + custom_fields_offset]));            }            if (!empty_attribute(tokens[15 + custom_fields_offset])) {                outputMessage.put(ActionFlags, unquoted_attribute(tokens[15 + custom_fields_offset]));            }            if (!empty_attribute(tokens[16 + custom_fields_offset])) {                outputMessage.put(DGH1, unquoted_attribute(tokens[16 + custom_fields_offset]));            }            if (!empty_attribute(tokens[17 + custom_fields_offset])) {                outputMessage.put(DGH2, unquoted_attribute(tokens[17 + custom_fields_offset]));            }            if (!empty_attribute(tokens[18 + custom_fields_offset])) {                outputMessage.put(DGH3, unquoted_attribute(tokens[18 + custom_fields_offset]));            }            if (!empty_attribute(tokens[19 + custom_fields_offset])) {                outputMessage.put(DGH4, unquoted_attribute(tokens[19 + custom_fields_offset]));            }            if (!empty_attribute(tokens[20 + custom_fields_offset])) {                outputMessage.put(VSYSName, unquoted_attribute(tokens[20 + custom_fields_offset]));            }            if (!empty_attribute(tokens[21 + custom_fields_offset])) {                outputMessage.put(DeviceName, unquoted_attribute(tokens[21 + custom_fields_offset]));            }        }    } else if (LogTypeSystem.equals(type.toUpperCase())) {        if (tokens.length == 17)            parser_version = 61;        else if (tokens.length == 23)            parser_version = 80;        if (parser_version >= 61) {            if (!empty_attribute(tokens[7]))                outputMessage.put(VirtualSystem, tokens[7].trim());            if (!empty_attribute(tokens[8]))                outputMessage.put(EventId, tokens[8].trim());            if (!empty_attribute(tokens[9]))                outputMessage.put(Object, tokens[9].trim());            if (!empty_attribute(tokens[12]))                outputMessage.put(Module, tokens[12].trim());            if (!empty_attribute(tokens[13]))                outputMessage.put(Severity, unquoted_attribute(tokens[13]));            if (!empty_attribute(tokens[14]))                outputMessage.put(Description, unquoted_attribute(tokens[14]));            if (!empty_attribute(tokens[15]))                outputMessage.put(Seqno, unquoted_attribute(tokens[15]));            if (!empty_attribute(tokens[16]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[16]));        }        if (parser_version == 80) {            if (!empty_attribute(tokens[17]))                outputMessage.put(DGH1, tokens[17].trim());            if (!empty_attribute(tokens[18]))                outputMessage.put(DGH2, tokens[18].trim());            if (!empty_attribute(tokens[19]))                outputMessage.put(DGH3, tokens[19].trim());            if (!empty_attribute(tokens[20]))                outputMessage.put(DGH4, tokens[20].trim());            if (!empty_attribute(tokens[21]))                outputMessage.put(VSYSName, unquoted_attribute(tokens[21]));            if (!empty_attribute(tokens[22]))                outputMessage.put(DeviceName, unquoted_attribute(tokens[22]));        }    } else if (LogTypeThreat.equals(type.toUpperCase()) || LogTypeTraffic.equals(type.toUpperCase())) {        if (!empty_attribute(tokens[7]))            outputMessage.put(SourceAddress, tokens[7].trim());        if (!empty_attribute(tokens[8]))            outputMessage.put(DestinationAddress, tokens[8].trim());        if (!empty_attribute(tokens[9]))            outputMessage.put(NATSourceIP, tokens[9].trim());        if (!empty_attribute(tokens[10]))            outputMessage.put(NATDestinationIP, tokens[10].trim());        if (!empty_attribute(tokens[11]))            outputMessage.put(Rule, unquoted_attribute(tokens[11]));        if (!empty_attribute(tokens[12]))            outputMessage.put(SourceUser, unquoted_attribute(tokens[12]));        if (!empty_attribute(tokens[13]))            outputMessage.put(DestinationUser, unquoted_attribute(tokens[13]));        if (!empty_attribute(tokens[14]))            outputMessage.put(Application, unquoted_attribute(tokens[14]));        if (!empty_attribute(tokens[15]))            outputMessage.put(VirtualSystem, unquoted_attribute(tokens[15]));        if (!empty_attribute(tokens[16]))            outputMessage.put(SourceZone, unquoted_attribute(tokens[16]));        if (!empty_attribute(tokens[17]))            outputMessage.put(DestinationZone, unquoted_attribute(tokens[17]));        if (!empty_attribute(tokens[18]))            outputMessage.put(InboundInterface, unquoted_attribute(tokens[18]));        if (!empty_attribute(tokens[19]))            outputMessage.put(OutboundInterface, unquoted_attribute(tokens[19]));        if (!empty_attribute(tokens[20]))            outputMessage.put(LogAction, unquoted_attribute(tokens[20]));        if (!empty_attribute(tokens[21]))            outputMessage.put(TimeLogged, tokens[21].trim());        if (!empty_attribute(tokens[22]))            outputMessage.put(SessionID, tokens[22].trim());        if (!empty_attribute(tokens[23]))            outputMessage.put(RepeatCount, tokens[23].trim());        if (!empty_attribute(tokens[24]))            outputMessage.put(SourcePort, tokens[24].trim());        if (!empty_attribute(tokens[25]))            outputMessage.put(DestinationPort, tokens[25].trim());        if (!empty_attribute(tokens[26]))            outputMessage.put(NATSourcePort, tokens[26].trim());        if (!empty_attribute(tokens[27]))            outputMessage.put(NATDestinationPort, tokens[27].trim());        if (!empty_attribute(tokens[28]))            outputMessage.put(Flags, tokens[28].trim());        if (!empty_attribute(tokens[29]))            outputMessage.put(IPProtocol, unquoted_attribute(tokens[29]));        if (!empty_attribute(tokens[30]))            outputMessage.put(Action, unquoted_attribute(tokens[30]));        if (LogTypeThreat.equals(type.toUpperCase())) {            int p1_offset = 0;            if (tokens.length == 45)                parser_version = 60;            else if (tokens.length == 53)                parser_version = 61;            else if (tokens.length == 61) {                parser_version = 70;                p1_offset = 1;            } else if (tokens.length == 72) {                parser_version = 80;                p1_offset = 1;            }            if (!empty_attribute(tokens[31])) {                outputMessage.put(URL, unquoted_attribute(tokens[31]));                try {                    URL url = new URL(unquoted_attribute(tokens[31]));                    outputMessage.put(HOST, url.getHost());                } catch (MalformedURLException e) {                }            }            if (!empty_attribute(tokens[32]))                outputMessage.put(ThreatID, tokens[32].trim());            if (!empty_attribute(tokens[33]))                outputMessage.put(Category, unquoted_attribute(tokens[33]));            if (!empty_attribute(tokens[34]))                outputMessage.put(Severity, unquoted_attribute(tokens[34]));            if (!empty_attribute(tokens[35]))                outputMessage.put(Direction, unquoted_attribute(tokens[35]));            if (!empty_attribute(tokens[36]))                outputMessage.put(Seqno, tokens[36].trim());            if (!empty_attribute(tokens[37]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[37]));            if (!empty_attribute(tokens[38]))                outputMessage.put(SourceLocation, unquoted_attribute(tokens[38]));            if (!empty_attribute(tokens[39]))                outputMessage.put(DestinationLocation, unquoted_attribute(tokens[39]));            if (!empty_attribute(tokens[41]))                outputMessage.put(ContentType, unquoted_attribute(tokens[41]));            if (!empty_attribute(tokens[42]))                outputMessage.put(PCAPID, tokens[42].trim());            if (!empty_attribute(tokens[43]))                outputMessage.put(WFFileDigest, unquoted_attribute(tokens[43]));            if (!empty_attribute(tokens[44]))                outputMessage.put(WFCloud, unquoted_attribute(tokens[44]));            if (parser_version >= 61) {                if (!empty_attribute(tokens[(45 + p1_offset)]))                    outputMessage.put(UserAgent, unquoted_attribute(tokens[(45 + p1_offset)]));                if (!empty_attribute(tokens[(46 + p1_offset)]))                    outputMessage.put(WFFileType, unquoted_attribute(tokens[(46 + p1_offset)]));                if (!empty_attribute(tokens[(47 + p1_offset)]))                    outputMessage.put(XForwardedFor, unquoted_attribute(tokens[(47 + p1_offset)]));                if (!empty_attribute(tokens[(48 + p1_offset)]))                    outputMessage.put(Referer, unquoted_attribute(tokens[(48 + p1_offset)]));                if (!empty_attribute(tokens[(49 + p1_offset)]))                    outputMessage.put(WFSender, unquoted_attribute(tokens[(49 + p1_offset)]));                if (!empty_attribute(tokens[(50 + p1_offset)]))                    outputMessage.put(WFSubject, unquoted_attribute(tokens[(50 + p1_offset)]));                if (!empty_attribute(tokens[(51 + p1_offset)]))                    outputMessage.put(WFRecipient, unquoted_attribute(tokens[(51 + p1_offset)]));                if (!empty_attribute(tokens[(52 + p1_offset)]))                    outputMessage.put(WFReportID, unquoted_attribute(tokens[(52 + p1_offset)]));            }            if (parser_version >= 70) {                if (!empty_attribute(tokens[45]))                    outputMessage.put(URLIndex, tokens[45].trim());                if (!empty_attribute(tokens[54]))                    outputMessage.put(DGH1, tokens[54].trim());                if (!empty_attribute(tokens[55]))                    outputMessage.put(DGH2, tokens[55].trim());                if (!empty_attribute(tokens[56]))                    outputMessage.put(DGH3, tokens[56].trim());                if (!empty_attribute(tokens[57]))                    outputMessage.put(DGH4, tokens[57].trim());                if (!empty_attribute(tokens[58]))                    outputMessage.put(VSYSName, unquoted_attribute(tokens[58]));                if (!empty_attribute(tokens[59]))                    outputMessage.put(DeviceName, unquoted_attribute(tokens[59]));            }            if (parser_version >= 80) {                if (!empty_attribute(tokens[61]))                    outputMessage.put(SourceVmUuid, tokens[61].trim());                if (!empty_attribute(tokens[62]))                    outputMessage.put(DestinationVmUuid, tokens[62].trim());                if (!empty_attribute(tokens[63]))                    outputMessage.put(HTTPMethod, tokens[63].trim());                if (!empty_attribute(tokens[64]))                    outputMessage.put(TunnelId, tokens[64].trim());                if (!empty_attribute(tokens[65]))                    outputMessage.put(MonitorTag, tokens[65].trim());                if (!empty_attribute(tokens[66]))                    outputMessage.put(ParentSessionId, tokens[66].trim());                if (!empty_attribute(tokens[67]))                    outputMessage.put(ParentSessionStartTime, tokens[67].trim());                if (!empty_attribute(tokens[68]))                    outputMessage.put(TunnelType, tokens[68].trim());                if (!empty_attribute(tokens[69]))                    outputMessage.put(ThreatCategory, tokens[69].trim());                if (!empty_attribute(tokens[70]))                    outputMessage.put(ContentVersion, tokens[70].trim());            }        } else if (LogTypeTraffic.equals(type.toUpperCase())) {            if (tokens.length == 46)                parser_version = 60;            else if (tokens.length == 47)                parser_version = 61;            else if (tokens.length == 54)                parser_version = 70;            else if (tokens.length == 61)                parser_version = 80;            if (!empty_attribute(tokens[31]))                outputMessage.put(Bytes, tokens[31].trim());            if (!empty_attribute(tokens[32]))                outputMessage.put(BytesSent, tokens[32].trim());            if (!empty_attribute(tokens[33]))                outputMessage.put(BytesReceived, tokens[33].trim());            if (!empty_attribute(tokens[34]))                outputMessage.put(Packets, tokens[34].trim());            if (!empty_attribute(tokens[35]))                outputMessage.put(StartTime, tokens[35].trim());            if (!empty_attribute(tokens[36]))                outputMessage.put(ElapsedTimeInSec, tokens[36].trim());            if (!empty_attribute(tokens[37]))                outputMessage.put(Category, unquoted_attribute(tokens[37]));            if (!empty_attribute(tokens[39]))                outputMessage.put(Seqno, tokens[39].trim());            if (!empty_attribute(tokens[40]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[40]));            if (!empty_attribute(tokens[41]))                outputMessage.put(SourceLocation, unquoted_attribute(tokens[41]));            if (!empty_attribute(tokens[42]))                outputMessage.put(DestinationLocation, unquoted_attribute(tokens[42]));            if (!empty_attribute(tokens[44]))                outputMessage.put(PktsSent, tokens[44].trim());            if (!empty_attribute(tokens[45]))                outputMessage.put(PktsReceived, tokens[45].trim());            if (parser_version >= 61) {                if (!empty_attribute(tokens[46]))                    outputMessage.put(EndReason, unquoted_attribute(tokens[46]));            }            if (parser_version >= 70) {                if (!empty_attribute(tokens[47]))                    outputMessage.put(DGH1, tokens[47].trim());                if (!empty_attribute(tokens[48]))                    outputMessage.put(DGH2, tokens[48].trim());                if (!empty_attribute(tokens[49]))                    outputMessage.put(DGH3, tokens[49].trim());                if (!empty_attribute(tokens[50]))                    outputMessage.put(DGH4, tokens[50].trim());                if (!empty_attribute(tokens[51]))                    outputMessage.put(VSYSName, unquoted_attribute(tokens[51]));                if (!empty_attribute(tokens[52]))                    outputMessage.put(DeviceName, unquoted_attribute(tokens[52]));                if (!empty_attribute(tokens[53]))                    outputMessage.put(ActionSource, unquoted_attribute(tokens[53]));            }            if (parser_version >= 80) {                if (!empty_attribute(tokens[54]))                    outputMessage.put(SourceVmUuid, tokens[54].trim());                if (!empty_attribute(tokens[55]))                    outputMessage.put(DestinationVmUuid, tokens[55].trim());                if (!empty_attribute(tokens[56]))                    outputMessage.put(TunnelId, tokens[56].trim());                if (!empty_attribute(tokens[57]))                    outputMessage.put(MonitorTag, tokens[57].trim());                if (!empty_attribute(tokens[58]))                    outputMessage.put(ParentSessionId, tokens[58].trim());                if (!empty_attribute(tokens[59]))                    outputMessage.put(ParentSessionStartTime, tokens[59].trim());                if (!empty_attribute(tokens[60]))                    outputMessage.put(TunnelType, tokens[60].trim());            }        }    }    outputMessage.put(ParserVersion, parser_version);    if (parser_version == 0) {        outputMessage.put(Tokens, tokens.length);    }}
public void metron_f6228_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    dateTimeFormatter = getDateFormatter(parserConfig);    dateTimeFormatter = getDateFormatterWithZone(dateTimeFormatter, parserConfig);    init();}
public void metron_f6231_0()
{    if (converter == null) {        converter = new CSVConverter();        Map<String, Object> config = new HashMap<>();        config.put(CSVConverter.SEPARATOR_KEY, recordDelimiter);        config.put(CSVConverter.COLUMNS_KEY, Lists.newArrayList(fieldNames));        converter.initialize(config);    }}
private long metron_f6233_0(String snortDatetime) throws ParseException
{    ZonedDateTime zonedDateTime = ZonedDateTime.parse(snortDatetime.trim(), dateTimeFormatter);    return zonedDateTime.toInstant().toEpochMilli();}
public String metron_f6234_0()
{    return this.recordDelimiter;}
public void metron_f6235_0(String recordDelimiter)
{    this.recordDelimiter = recordDelimiter;}
public String[] metron_f6236_0()
{    return this.fieldNames;}
public void metron_f6237_0(String[] fieldNames)
{    this.fieldNames = fieldNames;}
public void metron_f6238_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public void metron_f6239_0()
{}
protected long metron_f6241_0(Object value)
{    long epochTimestamp = System.currentTimeMillis();    if (value != null) {        try {            epochTimestamp = toEpoch(Calendar.getInstance().get(Calendar.YEAR) + " " + value);        } catch (ParseException e) {                }    }    return epochTimestamp;}
protected void metron_f6242_0(JSONObject message)
{    removeEmptyFields(message);    message.remove("timestamp_string");    if (message.containsKey("message")) {        String messageValue = (String) message.get("message");        if (messageValue.contains("logged into")) {            parseLoginMessage(message);        } else if (messageValue.contains("logged out")) {            parseLogoutMessage(message);        } else if (messageValue.contains("rbm(")) {            parseRBMMessage(message);        } else {            parseOtherMessage(message);        }    }}
private void metron_f6243_0(JSONObject json)
{    Iterator<Object> keyIter = json.keySet().iterator();    while (keyIter.hasNext()) {        Object key = keyIter.next();        Object value = json.get(key);        if (null == value || "".equals(value.toString())) {            keyIter.remove();        }    }}
private void metron_f6244_0(JSONObject json)
{    json.put("event_subtype", "login");    String message = (String) json.get("message");    if (message.contains(":")) {        String[] parts = message.split(":");        String user = parts[0];        String ip_src_addr = parts[1];        if (user.contains("user(") && user.contains(")")) {            user = user.substring(user.indexOf("user(") + "user(".length());            user = user.substring(0, user.indexOf(")"));            json.put("username", user);        }        if (ip_src_addr.contains("[") && ip_src_addr.contains("]")) {            ip_src_addr = ip_src_addr.substring(ip_src_addr.indexOf("[") + 1);            ip_src_addr = ip_src_addr.substring(0, ip_src_addr.indexOf("]"));            json.put("ip_src_addr", ip_src_addr);        }        json.remove("message");    }}
private void metron_f6245_0(JSONObject json)
{    json.put("event_subtype", "logout");    String message = (String) json.get("message");    if (message.matches(".*'.*'.*'.*'.*")) {        String[] parts = message.split("'");        String ip_src_addr = parts[0];        if (ip_src_addr.contains("[") && ip_src_addr.contains("]")) {            ip_src_addr = ip_src_addr.substring(ip_src_addr.indexOf("[") + 1);            ip_src_addr = ip_src_addr.substring(0, ip_src_addr.indexOf("]"));            json.put("ip_src_addr", ip_src_addr);        }        json.put("username", parts[1]);        json.put("security_domain", parts[3]);        json.remove("message");    }}
private void metron_f6246_0(JSONObject json)
{    String message = (String) json.get("message");    if (message.contains("(")) {        json.put("process", message.substring(0, message.indexOf("(")));        if (message.contains(":")) {            json.put("message", message.substring(message.indexOf(":") + 2));        }    }}
private void metron_f6247_0(JSONObject json)
{    String message = (String) json.get("message");    if (message.contains("(")) {        json.put("process", message.substring(0, message.indexOf("(")));        if (message.contains(":")) {            json.put("message", message.substring(message.indexOf(":") + 2));        }    }}
public void metron_f6248_0()
{    Assert.assertNull(Filters.get("DEFAULT", null));}
public void metron_f6249_0() throws Exception
{    {        Map<String, Object> config = new HashMap<String, Object>() {            {                put("filter.query", "exists(foo)");            }        };        MessageFilter<JSONObject> filter = Filters.get(Filters.STELLAR.name(), config);        Assert.assertTrue(filter.emit(new JSONObject(ImmutableMap.of("foo", 1)), Context.EMPTY_CONTEXT()));        Assert.assertFalse(filter.emit(new JSONObject(ImmutableMap.of("bar", 1)), Context.EMPTY_CONTEXT()));    }}
public void metron_f6250_0() throws Exception
{    parserConfig = new HashMap<>();    asaParser = new BasicAsaParser();    asaParser.configure(parserConfig);    asaParser.init();}
public void metron_f6251_0()
{    BasicAsaParser testParser = new BasicAsaParser();    testParser.configure(parserConfig);    testParser.init();    assertTrue(testParser.deviceClock.getZone().equals(ZoneOffset.UTC));}
public void metron_f6252_0()
{    parserConfig.put("deviceTimeZone", "UTC-05:00");    BasicAsaParser testParser = new BasicAsaParser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6253_0()
{    parserConfig.put("deviceTimeZone", "America/New_York");    BasicAsaParser testParser = new BasicAsaParser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6254_0()
{    String rawMessage = "<164>Aug 05 2016 01:01:34: %ASA-4-106023: Deny tcp src Inside:10.30.9.121/54580 dst Outside:192.168.135.51/42028 by access-group \"Inside_access_in\" [0x962df600, 0x0]";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue(asaJson.get("ip_src_addr").equals("10.30.9.121"));    assertTrue(asaJson.get("ip_dst_addr").equals("192.168.135.51"));    assertTrue(asaJson.get("ip_src_port").equals(54580));    assertTrue(asaJson.get("ip_dst_port").equals(42028));    assertTrue((long) asaJson.get("timestamp") == 1470358894000L);}
public void metron_f6255_0()
{    String rawMessage = "<162>Aug 05 2016 01:02:25: %ASA-2-106006: Deny inbound UDP from 10.25.177.164/63279 to 10.2.52.71/161 on interface Inside";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue(asaJson.get("ip_src_addr").equals("10.25.177.164"));    assertTrue(asaJson.get("ip_dst_addr").equals("10.2.52.71"));    assertTrue(asaJson.get("ip_src_port").equals(63279));    assertTrue(asaJson.get("ip_dst_port").equals(161));    assertTrue((long) asaJson.get("timestamp") == 1470358945000L);}
public void metron_f6256_0()
{    String rawMessage = "<174>Jan  5 14:52:35 10.22.8.212 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    ZonedDateTime fixedInstant = ZonedDateTime.of(2016, 1, 6, 1, 30, 30, 0, ZoneOffset.UTC);    Clock fixedClock = Clock.fixed(fixedInstant.toInstant(), fixedInstant.getZone());    BasicAsaParser fixedClockParser = new BasicAsaParser();    fixedClockParser.deviceClock = fixedClock;    fixedClockParser.init();    JSONObject asaJson = fixedClockParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue(asaJson.get("ip_src_addr").equals("10.22.8.110"));    assertTrue(asaJson.get("ip_dst_addr").equals("192.111.72.8"));    assertTrue(asaJson.get("ip_src_port").equals(49886));    assertTrue(asaJson.get("ip_dst_port").equals(8612));    assertTrue((long) asaJson.get("timestamp") == 1452005555000L);}
public void metron_f6257_0()
{    String rawMessage = "<165>Aug 16 2016 04:08:36: %ASA-5-713049: Group = 172.22.136.20, IP = 172.22.136.20, Security negotiation complete for LAN-to-LAN Group (172.22.136.20)  Initiator, Inbound SPI = 0x891fb03f, Outbound SPI = 0xbe4b5d8d";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue((long) asaJson.get("timestamp") == 1471320516000L);}
public void metron_f6258_0()
{    String rawMessage = "<164>Aug 05 2016 01:01:34: %ASA-4-106023: Deny tcp src Inside:10.30.9.121/54580 dst Outside:192.168.256.51/42028 by access-group \"Inside_access_in\" [0x962df600, 0x0]";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue((long) asaJson.get("timestamp") == 1470358894000L);    assertNull(asaJson.get("ip_dst_addr"));}
public void metron_f6259_0()
{    String rawMessage = "<174>Jan 05 2016 14:52:35 10.22.8.212 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:2001:db8:85a3::8a2e:370:7334/49886 (10.22.8.110/49886) to inside:2001:0db8:85a3:0000:0000:8a2e:0370:7334/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(rawMessage, asaJson.get("original_string"));    assertEquals("2001:db8:85a3::8a2e:370:7334", asaJson.get("ip_src_addr"));    assertEquals("2001:0db8:85a3:0000:0000:8a2e:0370:7334", asaJson.get("ip_dst_addr"));    assertEquals(49886, asaJson.get("ip_src_port"));    assertEquals(8612, asaJson.get("ip_dst_port"));    assertEquals(1452005555000L, asaJson.get("timestamp"));}
public void metron_f6260_0()
{    String rawMessage = "<174>Jan  5 14:52:35 10.22.8.212 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals("10.22.8.212", asaJson.get("syslog_host"));}
public void metron_f6261_0()
{    String rawMessage = "<174>Jan  5 14:52:35 hostname-2 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals("hostname-2", asaJson.get("syslog_host"));}
public void metron_f6262_0()
{    String rawMessage = "<174>Jan  5 14:52:35 hostname-2 progName-2 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals("hostname-2", asaJson.get("syslog_host"));    assertEquals("progName-2", asaJson.get("syslog_prog"));}
public void metron_f6263_0()
{    String rawMessage = "-- MARK --";    UnitTestHelper.setLog4jLevel(BasicAsaParser.class, Level.FATAL);    thrown.expect(RuntimeException.class);    thrown.expectMessage(startsWith("[Metron] Message '-- MARK --'"));    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    UnitTestHelper.setLog4jLevel(BasicAsaParser.class, Level.ERROR);}
public void metron_f6264_0()
{    parserConfig.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    asaParser.configure(parserConfig);    assertThat(asaParser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6265_0()
{    asaParser.configure(parserConfig);    assertThat(asaParser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public static void metron_f6266_0()
{    UnitTestHelper.setLog4jLevel(BasicBroParser.class, Level.FATAL);}
public static void metron_f6267_0()
{    UnitTestHelper.setLog4jLevel(BasicBroParser.class, Level.ERROR);}
public void metron_f6268_0()
{    Pair[] pairs = { Pair.of(12345678d, "12345678.0"), Pair.of(12345678.0d, "12345678.0"), Pair.of(12345678.1d, "12345678.1"), Pair.of(12345678.11d, "12345678.11"), Pair.of(12345678.111d, "12345678.111"), Pair.of(12345678.1111d, "12345678.1111"), Pair.of(12345678.11111d, "12345678.11111"), Pair.of(12345678.111111d, "12345678.111111") };    for (Pair pair : pairs) {        Assert.assertEquals("Format did not match", pair.getRight(), BasicBroParser.DECIMAL_FORMAT.get().format(pair.getLeft()));    }}
public void metron_f6269_0() throws ParseException
{    JSONObject rawJson = (JSONObject) jsonParser.parse(unwrappedBroMessage);    JSONObject broJson = broParser.parse(unwrappedBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1449511228.474";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1449511228474";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port"), rawJson.get("id.orig_p"));    Assert.assertEquals(broJson.get("ip_dst_port"), rawJson.get("id.resp_p"));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("trans_id").toString(), rawJson.get("trans_id").toString());    Assert.assertEquals(broJson.get("sensor").toString(), rawJson.get("sensor").toString());    Assert.assertEquals(broJson.get("type").toString(), rawJson.get("type").toString());    Assert.assertEquals(broJson.get("rcode").toString(), rawJson.get("rcode").toString());    Assert.assertEquals(broJson.get("rcode_name").toString(), rawJson.get("rcode_name").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DNS"));}
public void metron_f6270_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(httpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(httpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1402307733.473";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1402307733473";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("method").toString(), rawJson.get("method").toString());    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("resp_mime_types").toString(), rawJson.get("resp_mime_types").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("HTTP"));}
public void metron_f6271_0() throws ParseException
{    {        String rawMessage = "{\"http\": {\"ts\":1467657279,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279000";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.0";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }    {        String rawMessage = "{\"http\": {\"ts\":1467657279.0,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279000";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.0";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }    {        String rawMessage = "{\"http\": {\"ts\":1467657279.1,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279100";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.1";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }    {        String rawMessage = "{\"http\": {\"ts\":1467657279.11,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279110";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.11";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }}
public void metron_f6272_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(httpBroDecimalMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(httpBroDecimalMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1457149494.166991";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1457149494166";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("method").toString(), rawJson.get("method").toString());    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("resp_mime_types").toString(), rawJson.get("resp_mime_types").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("HTTP"));}
public void metron_f6273_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(dnsBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(dnsBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1402308259.609";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1402308259609";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("qtype").toString(), rawJson.get("qtype").toString());    Assert.assertEquals(broJson.get("trans_id").toString(), rawJson.get("trans_id").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DNS"));}
public void metron_f6274_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(filesBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(filesBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1425845251.334";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1425845251334";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), ((JSONArray) rawJson.get("tx_hosts")).get(0).toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), ((JSONArray) rawJson.get("rx_hosts")).get(0).toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("fuid").toString(), rawJson.get("fuid").toString());    Assert.assertEquals(broJson.get("md5").toString(), rawJson.get("md5").toString());    Assert.assertEquals(broJson.get("analyzers").toString(), rawJson.get("analyzers").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("FILES"));}
public void metron_f6275_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(connBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(connBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1166289883.163553";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1166289883163";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("proto").toString(), rawJson.get("proto").toString());    Assert.assertEquals(broJson.get("service").toString(), rawJson.get("service").toString());    Assert.assertEquals(broJson.get("duration").toString(), rawJson.get("duration").toString());    Assert.assertEquals(broJson.get("orig_bytes").toString(), rawJson.get("orig_bytes").toString());    Assert.assertEquals(broJson.get("resp_bytes").toString(), rawJson.get("resp_bytes").toString());    Assert.assertEquals(broJson.get("conn_state").toString(), rawJson.get("conn_state").toString());    Assert.assertEquals(broJson.get("missed_bytes").toString(), rawJson.get("missed_bytes").toString());    Assert.assertEquals(broJson.get("history").toString(), rawJson.get("history").toString());    Assert.assertEquals(broJson.get("orig_pkts").toString(), rawJson.get("orig_pkts").toString());    Assert.assertEquals(broJson.get("orig_ip_bytes").toString(), rawJson.get("orig_ip_bytes").toString());    Assert.assertEquals(broJson.get("resp_pkts").toString(), rawJson.get("resp_pkts").toString());    Assert.assertEquals(broJson.get("resp_ip_bytes").toString(), rawJson.get("resp_ip_bytes").toString());    Assert.assertEquals(broJson.get("tunnel_parents").toString(), rawJson.get("tunnel_parents").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("CONN"));}
public void metron_f6276_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(dpdBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(dpdBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216704078.712276";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216704078712";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("proto").toString(), rawJson.get("proto").toString());    Assert.assertEquals(broJson.get("analyzer").toString(), rawJson.get("analyzer").toString());    Assert.assertEquals(broJson.get("failure_reason").toString(), rawJson.get("failure_reason").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DPD"));}
public void metron_f6277_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(ftpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(ftpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1166289883.164645";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1166289883164";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("user").toString(), rawJson.get("user").toString());    Assert.assertEquals(broJson.get("password").toString(), rawJson.get("password").toString());    Assert.assertEquals(broJson.get("command").toString(), rawJson.get("command").toString());    Assert.assertEquals(broJson.get("arg").toString(), rawJson.get("arg").toString());    Assert.assertEquals(broJson.get("mime_type").toString(), rawJson.get("mime_type").toString());    Assert.assertEquals(broJson.get("file_size").toString(), rawJson.get("file_size").toString());    Assert.assertEquals(broJson.get("reply_code").toString(), rawJson.get("reply_code").toString());    Assert.assertEquals(broJson.get("reply_msg").toString(), rawJson.get("reply_msg").toString());    Assert.assertEquals(broJson.get("fuid").toString(), rawJson.get("fuid").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("FTP"));}
public void metron_f6278_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(knownCertsBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(knownCertsBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706999.896836";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706999896";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("port_num").toString(), rawJson.get("port_num").toString());    Assert.assertEquals(broJson.get("subject").toString(), rawJson.get("subject").toString());    Assert.assertEquals(broJson.get("issuer_subject").toString(), rawJson.get("issuer_subject").toString());    Assert.assertEquals(broJson.get("serial").toString(), rawJson.get("serial").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("KNOWN_CERTS"));}
public void metron_f6279_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(smtpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(smtpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1258568059.130219";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1258568059130";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("trans_depth").toString(), rawJson.get("trans_depth").toString());    Assert.assertEquals(broJson.get("helo").toString(), rawJson.get("helo").toString());    Assert.assertEquals(broJson.get("last_reply").toString(), rawJson.get("last_reply").toString());    Assert.assertEquals(broJson.get("path").toString(), rawJson.get("path").toString());    Assert.assertEquals(broJson.get("tls").toString(), rawJson.get("tls").toString());    Assert.assertEquals(broJson.get("fuids").toString(), rawJson.get("fuids").toString());    Assert.assertEquals(broJson.get("is_webmail").toString(), rawJson.get("is_webmail").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SMTP"));}
public void metron_f6280_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(sslBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(sslBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706999.444925";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706999444";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("version").toString(), rawJson.get("version").toString());    Assert.assertEquals(broJson.get("cipher").toString(), rawJson.get("cipher").toString());    Assert.assertEquals(broJson.get("server_name").toString(), rawJson.get("server_name").toString());    Assert.assertEquals(broJson.get("resumed").toString(), rawJson.get("resumed").toString());    Assert.assertEquals(broJson.get("established").toString(), rawJson.get("established").toString());    Assert.assertEquals(broJson.get("cert_chain_fuids").toString(), rawJson.get("cert_chain_fuids").toString());    Assert.assertEquals(broJson.get("client_cert_chain_fuids").toString(), rawJson.get("client_cert_chain_fuids").toString());    Assert.assertEquals(broJson.get("subject").toString(), rawJson.get("subject").toString());    Assert.assertEquals(broJson.get("issuer").toString(), rawJson.get("issuer").toString());    Assert.assertEquals(broJson.get("validation_status").toString(), rawJson.get("validation_status").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SSL"));}
public void metron_f6281_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(weirdBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(weirdBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706886.239896";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706886239";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("name").toString(), rawJson.get("name").toString());    Assert.assertEquals(broJson.get("notice").toString(), rawJson.get("notice").toString());    Assert.assertEquals(broJson.get("peer").toString(), rawJson.get("peer").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("WEIRD"));}
public void metron_f6282_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(noticeBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(noticeBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706377.196728";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706377196";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("proto").toString(), rawJson.get("proto").toString());    Assert.assertEquals(broJson.get("note").toString(), rawJson.get("note").toString());    Assert.assertEquals(broJson.get("msg").toString(), rawJson.get("msg").toString());    Assert.assertEquals(broJson.get("sub").toString(), rawJson.get("sub").toString());    Assert.assertEquals(broJson.get("src").toString(), rawJson.get("src").toString());    Assert.assertEquals(broJson.get("dst").toString(), rawJson.get("dst").toString());    Assert.assertEquals(broJson.get("p").toString(), rawJson.get("p").toString());    Assert.assertEquals(broJson.get("peer_descr").toString(), rawJson.get("peer_descr").toString());    Assert.assertEquals(broJson.get("actions").toString(), rawJson.get("actions").toString());    Assert.assertEquals(broJson.get("suppress_for").toString(), rawJson.get("suppress_for").toString());    Assert.assertEquals(broJson.get("dropped").toString(), rawJson.get("dropped").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("NOTICE"));}
public void metron_f6283_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(dhcpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(dhcpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1258567562.944638";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1258567562944";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("mac").toString(), rawJson.get("mac").toString());    Assert.assertEquals(broJson.get("assigned_ip").toString(), rawJson.get("assigned_ip").toString());    Assert.assertEquals(broJson.get("lease_time").toString(), rawJson.get("lease_time").toString());    Assert.assertEquals(broJson.get("trans_id").toString(), rawJson.get("trans_id").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DHCP"));}
public void metron_f6284_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(sshBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(sshBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1320435870.747967";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1320435870747";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("version").toString(), rawJson.get("version").toString());    Assert.assertEquals(broJson.get("auth_success").toString(), rawJson.get("auth_success").toString());    Assert.assertEquals(broJson.get("client").toString(), rawJson.get("client").toString());    Assert.assertEquals(broJson.get("server").toString(), rawJson.get("server").toString());    Assert.assertEquals(broJson.get("cipher_alg").toString(), rawJson.get("cipher_alg").toString());    Assert.assertEquals(broJson.get("mac_alg").toString(), rawJson.get("mac_alg").toString());    Assert.assertEquals(broJson.get("compression_alg").toString(), rawJson.get("compression_alg").toString());    Assert.assertEquals(broJson.get("kex_alg").toString(), rawJson.get("kex_alg").toString());    Assert.assertEquals(broJson.get("host_key_alg").toString(), rawJson.get("host_key_alg").toString());    Assert.assertEquals(broJson.get("host_key").toString(), rawJson.get("host_key").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SSH"));}
public void metron_f6285_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(softwareBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(softwareBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216707079.49066";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216707079490";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("host_p").toString(), rawJson.get("host_p").toString());    Assert.assertEquals(broJson.get("software_type").toString(), rawJson.get("software_type").toString());    Assert.assertEquals(broJson.get("name").toString(), rawJson.get("name").toString());    Assert.assertEquals(broJson.get("version.major").toString(), rawJson.get("version.major").toString());    Assert.assertEquals(broJson.get("version.minor").toString(), rawJson.get("version.minor").toString());    Assert.assertEquals(broJson.get("version.minor2").toString(), rawJson.get("version.minor2").toString());    Assert.assertEquals(broJson.get("unparsed_version").toString(), rawJson.get("unparsed_version").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SOFTWARE"));}
public void metron_f6286_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(softwareBroMessage2);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(softwareBroMessage2.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216707079.518447";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216707079518";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("host_p").toString(), rawJson.get("host_p").toString());    Assert.assertEquals(broJson.get("software_type").toString(), rawJson.get("software_type").toString());    Assert.assertEquals(broJson.get("name").toString(), rawJson.get("name").toString());    Assert.assertEquals(broJson.get("unparsed_version").toString(), rawJson.get("unparsed_version").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SOFTWARE"));}
public void metron_f6287_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(radiusBroMessageFailed);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(radiusBroMessageFailed.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1440447766.441298";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1440447766441";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("username").toString(), rawJson.get("username").toString());    Assert.assertEquals(broJson.get("result").toString(), rawJson.get("result").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("RADIUS"));}
public void metron_f6288_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(radiusBroMessageSuccess);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(radiusBroMessageSuccess.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1440447839.947956";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1440447839947";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("username").toString(), rawJson.get("username").toString());    Assert.assertEquals(broJson.get("result").toString(), rawJson.get("result").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("RADIUS"));}
public void metron_f6289_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(x509BroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(x509BroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706999.661483";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706999661";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("id").toString(), rawJson.get("id").toString());    Assert.assertEquals(broJson.get("certificate.version").toString(), rawJson.get("certificate.version").toString());    Assert.assertEquals(broJson.get("certificate.serial").toString(), rawJson.get("certificate.serial").toString());    Assert.assertEquals(broJson.get("certificate.subject").toString(), rawJson.get("certificate.subject").toString());    Assert.assertEquals(broJson.get("certificate.issuer").toString(), rawJson.get("certificate.issuer").toString());    Assert.assertEquals(broJson.get("certificate.not_valid_before").toString(), rawJson.get("certificate.not_valid_before").toString());    Assert.assertEquals(broJson.get("certificate.not_valid_after").toString(), rawJson.get("certificate.not_valid_after").toString());    Assert.assertEquals(broJson.get("certificate.key_alg").toString(), rawJson.get("certificate.key_alg").toString());    Assert.assertEquals(broJson.get("certificate.sig_alg").toString(), rawJson.get("certificate.sig_alg").toString());    Assert.assertEquals(broJson.get("certificate.key_type").toString(), rawJson.get("certificate.key_type").toString());    Assert.assertEquals(broJson.get("certificate.key_length").toString(), rawJson.get("certificate.key_length").toString());    Assert.assertEquals(broJson.get("certificate.exponent").toString(), rawJson.get("certificate.exponent").toString());    Assert.assertEquals(broJson.get("basic_constraints.ca").toString(), rawJson.get("basic_constraints.ca").toString());    Assert.assertEquals(broJson.get("basic_constraints.path_len").toString(), rawJson.get("basic_constraints.path_len").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("X509"));}
public void metron_f6290_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(knownDevicesBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(knownDevicesBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1258532046.693816";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1258532046693";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("mac").toString(), rawJson.get("mac").toString());    Assert.assertEquals(broJson.get("dhcp_host_name").toString(), rawJson.get("dhcp_host_name").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("KNOWN_DEVICES"));}
public void metron_f6291_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(rfbBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(rfbBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1328634261.675248";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1328634261675";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertEquals(broJson.get("client_major_version").toString(), rawJson.get("client_major_version").toString());    Assert.assertEquals(broJson.get("client_minor_version").toString(), rawJson.get("client_minor_version").toString());    Assert.assertEquals(broJson.get("server_major_version").toString(), rawJson.get("server_major_version").toString());    Assert.assertEquals(broJson.get("server_minor_version").toString(), rawJson.get("server_minor_version").toString());    Assert.assertEquals(broJson.get("authentication_method").toString(), rawJson.get("authentication_method").toString());    Assert.assertEquals(broJson.get("auth").toString(), rawJson.get("auth").toString());    Assert.assertEquals(broJson.get("share_flag").toString(), rawJson.get("share_flag").toString());    Assert.assertEquals(broJson.get("desktop_name").toString(), rawJson.get("desktop_name").toString());    Assert.assertEquals(broJson.get("width").toString(), rawJson.get("width").toString());    Assert.assertEquals(broJson.get("height").toString(), rawJson.get("height").toString());}
public void metron_f6292_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(statsBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(statsBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1440447766.440305";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1440447766440";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("peer").toString(), rawJson.get("peer").toString());    Assert.assertEquals(broJson.get("mem").toString(), rawJson.get("mem").toString());    Assert.assertEquals(broJson.get("pkts_proc").toString(), rawJson.get("pkts_proc").toString());    Assert.assertEquals(broJson.get("bytes_recv").toString(), rawJson.get("bytes_recv").toString());    Assert.assertEquals(broJson.get("events_proc").toString(), rawJson.get("events_proc").toString());    Assert.assertEquals(broJson.get("events_queued").toString(), rawJson.get("events_queued").toString());    Assert.assertEquals(broJson.get("active_tcp_conns").toString(), rawJson.get("active_tcp_conns").toString());    Assert.assertEquals(broJson.get("active_udp_conns").toString(), rawJson.get("active_udp_conns").toString());    Assert.assertEquals(broJson.get("active_icmp_conns").toString(), rawJson.get("active_icmp_conns").toString());    Assert.assertEquals(broJson.get("tcp_conns").toString(), rawJson.get("tcp_conns").toString());    Assert.assertEquals(broJson.get("udp_conns").toString(), rawJson.get("udp_conns").toString());    Assert.assertEquals(broJson.get("icmp_conns").toString(), rawJson.get("icmp_conns").toString());    Assert.assertEquals(broJson.get("timers").toString(), rawJson.get("timers").toString());    Assert.assertEquals(broJson.get("active_timers").toString(), rawJson.get("active_timers").toString());    Assert.assertEquals(broJson.get("files").toString(), rawJson.get("files").toString());    Assert.assertEquals(broJson.get("active_files").toString(), rawJson.get("active_files").toString());    Assert.assertEquals(broJson.get("dns_requests").toString(), rawJson.get("dns_requests").toString());    Assert.assertEquals(broJson.get("active_dns_requests").toString(), rawJson.get("active_dns_requests").toString());    Assert.assertEquals(broJson.get("reassem_tcp_size").toString(), rawJson.get("reassem_tcp_size").toString());    Assert.assertEquals(broJson.get("reassem_file_size").toString(), rawJson.get("reassem_file_size").toString());    Assert.assertEquals(broJson.get("reassem_frag_size").toString(), rawJson.get("reassem_frag_size").toString());    Assert.assertEquals(broJson.get("reassem_unknown_size").toString(), rawJson.get("reassem_unknown_size").toString());}
public void metron_f6293_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(captureLossBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(captureLossBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1320435958.419451";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1320435958419";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("ts_delta").toString(), rawJson.get("ts_delta").toString());    Assert.assertEquals(broJson.get("peer").toString(), rawJson.get("peer").toString());    Assert.assertEquals(broJson.get("gaps").toString(), rawJson.get("gaps").toString());    Assert.assertEquals(broJson.get("acks").toString(), rawJson.get("acks").toString());    Assert.assertEquals(broJson.get("percent_lost").toString(), rawJson.get("percent_lost").toString());}
public void metron_f6294_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(sipBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(sipBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216698441.346819";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216698441346";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertEquals(broJson.get("trans_depth").toString(), rawJson.get("trans_depth").toString());    Assert.assertEquals(broJson.get("method").toString(), rawJson.get("method").toString());    Assert.assertEquals(broJson.get("uri").toString(), rawJson.get("uri").toString());    Assert.assertEquals(broJson.get("request_from").toString(), rawJson.get("request_from").toString());    Assert.assertEquals(broJson.get("request_to").toString(), rawJson.get("request_to").toString());    Assert.assertEquals(broJson.get("response_from").toString(), rawJson.get("response_from").toString());    Assert.assertEquals(broJson.get("response_to").toString(), rawJson.get("response_to").toString());    Assert.assertEquals(broJson.get("call_id").toString(), rawJson.get("call_id").toString());    Assert.assertEquals(broJson.get("seq").toString(), rawJson.get("seq").toString());    Assert.assertEquals(broJson.get("request_path").toString(), rawJson.get("request_path").toString());    Assert.assertEquals(broJson.get("response_path").toString(), rawJson.get("response_path").toString());    Assert.assertEquals(broJson.get("user_agent").toString(), rawJson.get("user_agent").toString());    Assert.assertEquals(broJson.get("status_code").toString(), rawJson.get("status_code").toString());    Assert.assertEquals(broJson.get("status_msg").toString(), rawJson.get("status_msg").toString());    Assert.assertEquals(broJson.get("request_body_len").toString(), rawJson.get("request_body_len").toString());    Assert.assertEquals(broJson.get("response_body_len").toString(), rawJson.get("response_body_len").toString());}
public void metron_f6295_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(protocolKeyCleanedUp);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(protocolKeyCleanedUp.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1402307733.473";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1402307733473";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("HTTP"));}
public void metron_f6296_0() throws ParseException
{    broParser.parse("{ \"foo\" : \"bar\"}".getBytes(StandardCharsets.UTF_8));}
public void metron_f6297_0()
{    broParser.parse("foo bar".getBytes(StandardCharsets.UTF_8));}
public void metron_f6298_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    broParser.configure(config);    assertThat(broParser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6299_0()
{    Map<String, Object> config = new HashMap<>();    broParser.configure(config);    assertThat(broParser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6300_0()
{    parser = new CEFParser();    parser.init();}
public void metron_f6301_0()
{    List<JSONObject> obj = parse("test test test nonsense\n");    Assert.assertEquals(0, obj.size());}
public void metron_f6302_0()
{    for (JSONObject obj : parse("Sep 19 08:26:10 host CEF:0|security|threatmanager|1.0|100|detected a \\ in packet|10|src=10.0.0.1 act=blocked a \\ dst=1.1.1.1")) {        Assert.assertEquals("10.0.0.1", obj.get(Fields.SRC_ADDR.getName()));        Assert.assertEquals("blocked a \\", obj.get("deviceAction"));        Assert.assertEquals("1.1.1.1", obj.get(Fields.DST_ADDR.getName()));    }}
public void metron_f6303_0()
{    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals("Security", obj.get("DeviceVendor"));        Assert.assertEquals("threatmanager", obj.get("DeviceProduct"));        Assert.assertEquals("1.0", obj.get("DeviceVersion"));        Assert.assertEquals("100", obj.get("DeviceEvent"));        Assert.assertEquals("worm successfully stopped", obj.get("Name"));        Assert.assertEquals(10, obj.get("Severity"));    }}
public void metron_f6304_0()
{    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals("10.0.0.1", obj.get(Fields.SRC_ADDR.getName()));        Assert.assertEquals("2.1.2.2", obj.get(Fields.DST_ADDR.getName()));        Assert.assertEquals(1232, obj.get(Fields.SRC_PORT.getName()));    }}
public void metron_f6305_0()
{    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232 custom=Text with space customLabel=Label with space")) {        Assert.assertEquals(true, obj.containsKey("Label with space"));        Assert.assertEquals("Text with space", obj.get("Label with space"));    }}
public void metron_f6306_0() throws java.text.ParseException
{    long correctTime = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz").parse("2016-05-01T09:29:11.356-0400").getTime();    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz");    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=May 1 2016 09:29:11.356 -0400 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-06-01T09:29:11.356-04:00 host CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=May 1 2016 09:29:11.356 -0400 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-05-01T09:29:11.356-04:00 host CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertNotNull(obj.get(Fields.TIMESTAMP.getName()));    }}
public void metron_f6307_0() throws java.text.ParseException
{    long correctTime = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz").parse("2016-05-01T09:29:11.356-0400").getTime();    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=" + String.valueOf(correctTime) + " dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }}
private void metron_f6308_0(Calendar expected, Calendar input)
{    SimpleDateFormat sdf = new SimpleDateFormat("MMM dd HH:mm:ss.SSS");    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=" + sdf.format(input.getTime()) + " dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(expected.getTimeInMillis(), obj.get(Fields.TIMESTAMP.getName()));        Assert.assertEquals(expected.getTime(), new Date((long) obj.get(Fields.TIMESTAMP.getName())));    }}
public void metron_f6309_0() throws java.text.ParseException
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    correct.setTimeInMillis(current.getTimeInMillis());    runMissingYear(correct, current);}
public void metron_f6310_0()
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    current.add(Calendar.DAY_OF_MONTH, 5);        correct.setTimeInMillis(current.getTimeInMillis());    correct.add(Calendar.YEAR, -1);    runMissingYear(correct, current);}
public void metron_f6311_0() throws Exception
{    runTest("adallom", Resources.readLines(Resources.getResource(getClass(), "adallom.cef"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "adallom.schema"), StandardCharsets.UTF_8));}
public void metron_f6312_0() throws Exception
{    runTest("cyberark", Resources.readLines(Resources.getResource(getClass(), "cyberark.cef"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "cyberark.schema"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "cyberark.json"), StandardCharsets.UTF_8));}
public void metron_f6313_0() throws Exception
{    URL waf_url = Resources.getResource(getClass(), "waf.cef");    runTest("waf", Resources.readLines(waf_url, StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "waf.schema"), StandardCharsets.UTF_8));}
public void metron_f6314_0() throws Exception
{    URL palo_url = Resources.getResource(getClass(), "palo.cef");    runTest("palo", Resources.readLines(palo_url, StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "palo.schema"), StandardCharsets.UTF_8));}
private void metron_f6315_0(String name, List<String> lines, String schema) throws Exception
{    runTest(name, lines, schema, "");}
private void metron_f6316_0(String name, List<String> lines, String schema, String targetJson) throws Exception
{    for (String inputString : lines) {        JSONObject parsed = parse(inputString).get(0);        Assert.assertNotNull(parsed);        Assert.assertNotNull(parsed.get(Fields.TIMESTAMP.getName()));        Assert.assertTrue((long) parsed.get(Fields.TIMESTAMP.getName()) > 0);        JSONParser parser = new JSONParser();        Map<?, ?> json = null;        json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertEquals(true, validateJsonData(schema, json.toString()));    }}
public void metron_f6317_0() throws JsonProcessingException, IOException
{    List<JSONObject> parse = parse(sample);    JSONObject obj = parse.get(0);    Assert.assertEquals("TestVendor", obj.get("DeviceVendor"));    Assert.assertEquals(1423441663000L, obj.get(Fields.TIMESTAMP.getName()));    Assert.assertEquals("9223372036854775807", obj.get("Test Long"));    Assert.assertEquals(obj.get("Test FP Number"), String.valueOf(1.234F));    Assert.assertEquals("00:00:0c:07:ac:00", obj.get("smac"));    Assert.assertEquals("2001:cdba::3257:9652", obj.get("Test IPv6"));    Assert.assertEquals("test test test chocolate", obj.get("Test String"));    Assert.assertEquals("123.123.123.123", obj.get("destinationTranslatedAddress"));    JsonNode inner = new ObjectMapper().readTree((String) obj.get("JSON payload"));    Assert.assertEquals("chocolate!", inner.get("test_test_test").asText());}
protected boolean metron_f6318_0(final String jsonSchema, final String jsonData) throws Exception
{    final JsonNode d = JsonLoader.fromString(jsonData);    final JsonNode s = JsonLoader.fromString(jsonSchema);    final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();    JsonValidator v = factory.getValidator();    ProcessingReport report = v.validate(s, d);    return report.toString().contains("success");}
private List<JSONObject> metron_f6319_0(String string)
{    List<JSONObject> parse = parser.parse(string.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(parse);    return parse;}
public void metron_f6320_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6321_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6322_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/FireEyeParserTest.txt");    parser = new BasicFireEyeParser();}
public void metron_f6323_0() throws ParseException
{    for (String inputString : inputStrings) {        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map json = (Map) parser.parse(parsed.toJSONString());        Assert.assertNotNull(json);        Assert.assertFalse(json.isEmpty());        for (Object o : json.entrySet()) {            Entry entry = (Entry) o;            String key = (String) entry.getKey();            String value = json.get(key).toString();            Assert.assertNotNull(value);        }    }}
public void metron_f6324_0() throws ParseException
{    JSONObject parsed = parser.parse(fireeyeMessage.getBytes(StandardCharsets.UTF_8)).get(0);    JSONParser parser = new JSONParser();    Map json = (Map) parser.parse(parsed.toJSONString());    long expectedTimestamp = ZonedDateTime.of(Year.now(ZoneOffset.UTC).getValue(), 3, 19, 5, 24, 39, 0, ZoneOffset.UTC).toInstant().toEpochMilli();    Assert.assertEquals(expectedTimestamp, json.get("timestamp"));}
public void metron_f6325_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6326_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6327_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/IseParserTest.txt");    parser = new BasicIseParser();    URL schema_url = getClass().getClassLoader().getResource("TestSchemas/IseSchema.json");    super.setSchemaJsonString(super.readSchemaFromFile(schema_url));}
public void metron_f6328_0() throws org.json.simple.parser.ParseException, IOException, ProcessingException
{    for (String inputString : inputStrings) {        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map<?, ?> json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertTrue(validateJsonData(getSchemaJsonString(), json.toString()));    }}
public void metron_f6329_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6330_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6331_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/LancopeParserTest.txt");    parser = new BasicLancopeParser();    URL schema_url = getClass().getClassLoader().getResource("TestSchemas/LancopeSchema.json");    super.setSchemaJsonString(super.readSchemaFromFile(schema_url));}
public void metron_f6332_0() throws ParseException, IOException, ProcessingException
{    for (String inputString : inputStrings) {        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map<?, ?> json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertTrue(validateJsonData(getSchemaJsonString(), json.toString()));    }}
public void metron_f6333_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6334_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6335_0()
{    parser = new LEEFParser();    parser.init();}
public void metron_f6336_0()
{    List<JSONObject> obj = parse("test test test nonsense\n");    Assert.assertEquals(0, obj.size());}
public void metron_f6337_0() throws java.text.ParseException
{    long correctTime = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz").parse("2016-05-01T09:29:11.356-0400").getTime();    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz");    for (JSONObject obj : parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-06-01T09:29:11.356-04:00 host LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-05-01T09:29:11.356-04:00 host LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertNotNull(obj.get(Fields.TIMESTAMP.getName()));    }}
private void metron_f6338_0(Calendar expected, Calendar input)
{    SimpleDateFormat sdf = new SimpleDateFormat("MMM dd HH:mm:ss.SSS");    for (JSONObject obj : parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|\t|src=10.0.0.1\tdevTime=" + sdf.format(input.getTime()) + "\tdevTimeFormat=MMM dd HH:mm:ss.SSS" + "\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(expected.getTime(), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(expected.getTimeInMillis(), obj.get(Fields.TIMESTAMP.getName()));    }}
public void metron_f6339_0() throws java.text.ParseException
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    correct.setTimeInMillis(current.getTimeInMillis());    runMissingYear(correct, current);}
public void metron_f6340_0()
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    current.add(Calendar.DAY_OF_MONTH, 5);        correct.setTimeInMillis(current.getTimeInMillis());    correct.add(Calendar.YEAR, -1);    runMissingYear(correct, current);}
public void metron_f6341_0()
{    List<JSONObject> parse = parse("LEEF:0|Incapsula|SIEMintegration|0|SQL Injection| fileId=3412364560000000008 sourceServiceName=test56111115.incaptest.co siteid=1333546 suid=300656 requestClientApplication=Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0 popName=mia cs2=true cs2Label=Javascript Support cs3=true cs3Label=CO Support cs1=NA cs1Label=Cap Support cs4=936e64c2-bdd1-4719-9bd0-2d882a72f30d cs4Label=VID cs5=bab1712be85b00ab21d20bf0d7b5db82701f27f53fbac19a4252efc722ac9131fdc60c0da620282b02dfb8051e7a60f9 cs5Label=clappsig dproc=Browser cs6=Firefox cs6Label=clapp calCountryOrRegion=IL cicode=Rehovot cs7=31.8969 cs7Label=latitude cs8=34.8186 cs8Label=longitude Customer=siemtest start=1460303291788 url=test56111115.incaptest.co/ requestMethod=GET qstr=keywords\\=3%29%29%29%20AND%203434%3d%28%27%3amvc%3a%27%7c%7c%28SELECT%20CASE%203434%20WHEN%203434%20THEN%201%20ELSE%200%20END%20FROM%20RDB%24DATABASE%29%7c%7c%27%3aqvi%3a%27%29%20AND%20%28%28%283793%3d3793 cn1=200 proto=HTTP cat=REQ_PASSED deviceExternalId=2323800832649 dst=54.195.35.43 dstPort=80 in=406 xff=127.0.0.1 srcPort=443 src=127.0.0.1 protoVer=TLSv1.2 ECDHE-RSA-AES128-GCM-SHA256 fileType=12999,50999,50037,50044, filePermission=37,20,1,1, cs9=,High Risk SQL Expressions,,SQL SELECT Expression, cs9Label=Rule name");    JSONObject obj = parse.get(0);    Assert.assertNotNull(obj);    Assert.assertEquals("3412364560000000008", obj.get("fileId"));    Assert.assertEquals("Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0", obj.get("requestClientApplication"));    Assert.assertTrue(obj.containsKey("longitude"));    Assert.assertFalse(obj.containsKey("cs8"));    Assert.assertFalse(obj.containsKey("cs8Label"));}
public void metron_f6342_0() throws Exception
{    runTest("sample", Resources.readLines(Resources.getResource(getClass(), "sample.leef"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "sample.schema"), StandardCharsets.UTF_8));}
private void metron_f6343_0(String name, List<String> lines, String schema) throws Exception
{    runTest(name, lines, schema, "");}
private void metron_f6344_0(String name, List<String> lines, String schema, String targetJson) throws Exception
{    for (String inputString : lines) {        JSONObject parsed = parse(inputString).get(0);        Assert.assertNotNull(parsed);        Assert.assertNotNull(parsed.get(Fields.TIMESTAMP.getName()));        Assert.assertTrue((long) parsed.get(Fields.TIMESTAMP.getName()) > 0);        JSONParser parser = new JSONParser();        Map<?, ?> json = null;        json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertEquals(true, validateJsonData(schema, json.toString()));    }}
private void metron_f6345_0(List<JSONObject> parse)
{    JSONObject obj = parse.get(0);    Assert.assertNotNull(obj);    Assert.assertTrue(obj.containsKey(Fields.SRC_ADDR.getName()));    Assert.assertEquals("192.0.2.0", obj.get(Fields.SRC_ADDR.getName()));}
public void metron_f6346_0()
{    List<JSONObject> parse = parse("LEEF:1.0|Microsoft|MSExchange|4.0 SP1|15345| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=joe.black");    assertSimpleSample(parse);}
public void metron_f6347_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Vendor|Product|Version|EventID| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=joe.black");    assertSimpleSample(parse);}
public void metron_f6348_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0^dst=172.50.123.1^sev=5^cat=anomaly^srcPort=81^dstPort=21^usrName=joe.black");    assertSimpleSample(parse);}
public void metron_f6349_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=joe.black");    assertFalse(parse.get(0).containsKey(Fields.DST_ADDR));}
public void metron_f6350_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Vendor|Product|Version|EventID| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=line1" + "\nLEEF:2.0|Vendor|Product|Version|EventID| src=192.0.2.1\tdst=172.50.123.2\tsev=6\tcat=anomaly\tsrcPort=82\tdstPort=22\tusrName=line2");    assertSimpleSample(parse);    assertEquals(2, parse.size());}
public void metron_f6351_0()
{    String customFormat = "yyyy-MM-dd HH:mm:ss.SSS zzz";    Date customDate = new Date();    DateFormat customFormatter = new SimpleDateFormat(customFormat);    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0^dst=172.50.123.1^sev=5^cat=anomaly^srcPort=81^dstPort=21^usrName=joe.black^devTime=" + customFormatter.format(customDate) + "^devTimeFormat=" + customFormat);    JSONObject obj = parse.get(0);    assertEquals(obj.get(Fields.TIMESTAMP.getName()), customDate.getTime());}
public void metron_f6352_0()
{    String standardFormat = "MMM dd yyyy HH:mm:ss.SSS zzz";    Date customDate = new Date();    long expected = customDate.getTime();    DateFormat customFormatter = new SimpleDateFormat(standardFormat);    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0^dst=172.50.123.1^sev=5^cat=anomaly^srcPort=81^dstPort=21^usrName=joe.black^devTime=" + customFormatter.format(customDate));    JSONObject obj = parse.get(0);    assertEquals(obj.get(Fields.TIMESTAMP.getName()), expected);}
protected boolean metron_f6353_0(final String jsonSchema, final String jsonData) throws Exception
{    final JsonNode d = JsonLoader.fromString(jsonData);    final JsonNode s = JsonLoader.fromString(jsonSchema);    final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();    JsonValidator v = factory.getValidator();    ProcessingReport report = v.validate(s, d);    return report.toString().contains("success");}
private List<JSONObject> metron_f6354_0(String string)
{    Optional<MessageParserResult<JSONObject>> parse = parser.parseOptionalResult(string.getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(parse.isPresent());    return parse.get().getMessages();}
public void metron_f6355_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6356_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6357_0() throws Exception
{    parser = new BasicPaloAltoFirewallParser();}
public void metron_f6358_0() throws ParseException
{    final String SYSTEM_61 = "1,2017/08/11 12:37:58,008900008659,SYSTEM,general,1,2017/08/11 11:37:58,vsys1,eventId_test,object_test,Futureuse1_test,futureuse2_test,management,high,Description_test,1354,0x0";    JSONObject actual = parser.parse(SYSTEM_61.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "SYSTEM");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "general");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.EventId, "eventId_test");    expected.put(BasicPaloAltoFirewallParser.Object, "object_test");    expected.put(BasicPaloAltoFirewallParser.Module, "management");    expected.put(BasicPaloAltoFirewallParser.Severity, "high");    expected.put(BasicPaloAltoFirewallParser.Description, "Description_test");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 61);    expected.put("original_string", SYSTEM_61);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6359_0() throws ParseException
{    final String SYSTEM_80 = "1,2017/08/11 12:37:58,008900008659,SYSTEM,general,1,2017/08/11 11:37:58,vsys1,eventId_test,object_test,Futureuse1_test,futureuse2_test,management,high,Description_test,1354,0x0,12,34,45,0,virSys1,dev-something200-01";    JSONObject actual = parser.parse(SYSTEM_80.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "SYSTEM");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "general");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.EventId, "eventId_test");    expected.put(BasicPaloAltoFirewallParser.Object, "object_test");    expected.put(BasicPaloAltoFirewallParser.Module, "management");    expected.put(BasicPaloAltoFirewallParser.Severity, "high");    expected.put(BasicPaloAltoFirewallParser.Description, "Description_test");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "12");    expected.put(BasicPaloAltoFirewallParser.DGH2, "34");    expected.put(BasicPaloAltoFirewallParser.DGH3, "45");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.VSYSName, "virSys1");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "dev-something200-01");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put("original_string", SYSTEM_80);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6360_0() throws ParseException
{    final String CONFIG_61_customFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0";    JSONObject actual = parser.parse(CONFIG_61_customFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 61);    expected.put("original_string", CONFIG_61_customFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6361_0() throws ParseException
{    final String CONFIG_61_noCustomFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0,/FatherNode/KidNode/GrandsonNode1,/FatherNode/KidNode/GrandsonNode2";    JSONObject actual = parser.parse(CONFIG_61_noCustomFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.BeforeChangeDetail, "/FatherNode/KidNode/GrandsonNode1");    expected.put(BasicPaloAltoFirewallParser.AfterChangeDetail, "/FatherNode/KidNode/GrandsonNode2");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 61);    expected.put("original_string", CONFIG_61_noCustomFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6362_0() throws ParseException
{    final String CONFIG_70_80_noCustomFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0,12,34,45,0,virSys1,dev-something200-01";    JSONObject actual = parser.parse(CONFIG_70_80_noCustomFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "12");    expected.put(BasicPaloAltoFirewallParser.DGH2, "34");    expected.put(BasicPaloAltoFirewallParser.DGH3, "45");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.VSYSName, "virSys1");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "dev-something200-01");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put("original_string", CONFIG_70_80_noCustomFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6363_0() throws ParseException
{    final String CONFIG_70_80_customFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded,config shared log-settings config,/FatherNode/KidNode/GrandsonNode1,/FatherNode/KidNode/GrandsonNode2,1354,0x0,12,34,45,0,virSys1,dev-something200-01";    JSONObject actual = parser.parse(CONFIG_70_80_customFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.BeforeChangeDetail, "/FatherNode/KidNode/GrandsonNode1");    expected.put(BasicPaloAltoFirewallParser.AfterChangeDetail, "/FatherNode/KidNode/GrandsonNode2");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "12");    expected.put(BasicPaloAltoFirewallParser.DGH2, "34");    expected.put(BasicPaloAltoFirewallParser.DGH3, "45");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.VSYSName, "virSys1");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "dev-something200-01");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put("original_string", CONFIG_70_80_customFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6364_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_60.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "reset-both");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "web-browsing");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.Direction, "client-to-server");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "US");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x80004000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "internal");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/2");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "216.0.10.198");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "80");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "10.0.0.115");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "54180");    expected.put(BasicPaloAltoFirewallParser.LogAction, "LOG-Default");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", THREAT_60);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 60);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "1200568889751109656");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2015/01/05 05:38:58");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "EX-Allow");    expected.put(BasicPaloAltoFirewallParser.Seqno, "347368099");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0006C110285");    expected.put(BasicPaloAltoFirewallParser.SessionID, "12031");    expected.put(BasicPaloAltoFirewallParser.Severity, "high");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.SourceUser, "example\\user.name");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2015/01/05 05:38:58");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "vulnerability");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "HTTP: IIS Denial Of Service Attempt(40019)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2015/01/05 05:38:58");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "external");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "ad.aspx?f=300x250&id=12;tile=1;ord=67AF705D60B1119C0F18BEA336F9");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    assertEquals(expected, actual);}
public void metron_f6365_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_60.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "allow");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "ms-ds-smb");    expected.put(BasicPaloAltoFirewallParser.Bytes, "2229");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "942");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "1287");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.DestinationUser, "example\\\\user.name");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "30");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x401a");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "v_external");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/2");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "10.1.0.163");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "445");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "10.0.0.39");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "52688");    expected.put(BasicPaloAltoFirewallParser.LogAction, "LOG-Default");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", TRAFFIC_60);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.Packets, "10");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 60);    expected.put(BasicPaloAltoFirewallParser.PktsSent, "6");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2015/01/05 12:51:33");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "EX-Allow");    expected.put(BasicPaloAltoFirewallParser.Seqno, "17754932062");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0011C103117");    expected.put(BasicPaloAltoFirewallParser.SessionID, "33760927");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2015/01/05 12:51:01");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "end");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2015/01/05 12:51:33");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "v_internal");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    assertEquals(expected, actual);}
public void metron_f6366_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_70.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "reset-both");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "web-browsing");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "0");    expected.put(BasicPaloAltoFirewallParser.Direction, "server-to-client");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.DestinationUser, "user");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x400000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "Untrust");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "10.1.8.7");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "51787");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "217.1.2.3");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Std-Log-Forward");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "25025");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "214.123.1.2");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "217.1.2.3");    expected.put("original_string", THREAT_70);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "0");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/24 09:53:10");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "WLAN-Internet");    expected.put(BasicPaloAltoFirewallParser.Seqno, "329423829");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001801000001");    expected.put(BasicPaloAltoFirewallParser.SessionID, "49567");    expected.put(BasicPaloAltoFirewallParser.Severity, "medium");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "DE");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/24 09:53:10");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "virus");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "Virus/Win32.WGeneric.lumeo(2457399)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/24 09:53:10");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "wifi_zone");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "abcdef310.exe");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.URLIndex, "1");    expected.put(BasicPaloAltoFirewallParser.WFReportID, "0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "19");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6367_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_70.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "deny");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ActionSource, "from-policy");    expected.put(BasicPaloAltoFirewallParser.Application, "not-applicable");    expected.put(BasicPaloAltoFirewallParser.Bytes, "114");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "0");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "114");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "DE");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "0");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x0");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "intern");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "192.168.1.10");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "137");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "10.2.1.8");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "137");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Std-Log-Forward");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", TRAFFIC_70);    expected.put(BasicPaloAltoFirewallParser.Packets, "1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PktsReceived, "0");    expected.put(BasicPaloAltoFirewallParser.PktsSent, "1");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "udp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/25 21:38:13");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "DropLog");    expected.put(BasicPaloAltoFirewallParser.Seqno, "9953744");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001606000003");    expected.put(BasicPaloAltoFirewallParser.EndReason, "policy-deny");    expected.put(BasicPaloAltoFirewallParser.SessionID, "0");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "192.168.0.0-192.168.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/25 21:38:12");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "drop");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/25 21:38:13");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "VPN");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.DGH1, "19");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6368_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_71.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "deny");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ActionSource, "from-policy");    expected.put(BasicPaloAltoFirewallParser.Application, "not-applicable");    expected.put(BasicPaloAltoFirewallParser.Bytes, "60");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "0");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "60");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "0");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "DE");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "0");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x0");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "untrust");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "201.1.4.5");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "123");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "185.94.1.1");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "59836");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Standard-Syslog");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", TRAFFIC_71);    expected.put(BasicPaloAltoFirewallParser.Packets, "1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PktsReceived, "0");    expected.put(BasicPaloAltoFirewallParser.PktsSent, "1");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "udp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/31 23:59:57");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "DropLog");    expected.put(BasicPaloAltoFirewallParser.Seqno, "3433072193");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0006C000005");    expected.put(BasicPaloAltoFirewallParser.EndReason, "policy-deny");    expected.put(BasicPaloAltoFirewallParser.SessionID, "0");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "RU");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/31 23:59:57");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "drop");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/31 23:59:57");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "untrust");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.DGH1, "16");    expected.put(BasicPaloAltoFirewallParser.DGH2, "11");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6369_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_71.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "alert");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "ssl");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "0");    expected.put(BasicPaloAltoFirewallParser.Direction, "client-to-server");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "IE");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x40b000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "mgmt");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "vlan.199");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "140.177.26.29");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "192.168.1.7");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "56059");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Standard-Syslog");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "140.177.26.29");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "14810");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "201.1.4.5");    expected.put("original_string", THREAT_71);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "0");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/25 19:31:13");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "ms_out");    expected.put(BasicPaloAltoFirewallParser.Seqno, "10030265");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0006C000005");    expected.put(BasicPaloAltoFirewallParser.SessionID, "50556");    expected.put(BasicPaloAltoFirewallParser.Severity, "informational");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "192.168.0.0-192.168.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/25 19:31:13");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "url");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "(9999)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/25 19:31:13");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "untrust");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "settings-win.data.microsoft.com/");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.URLIndex, "0");    expected.put(BasicPaloAltoFirewallParser.WFReportID, "0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "16");    expected.put(BasicPaloAltoFirewallParser.DGH2, "11");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6370_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_80.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "reset-server");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "web-browsing");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.ContentVersion, "AppThreat-771-4450");    expected.put(BasicPaloAltoFirewallParser.Direction, "server-to-client");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "172.16.0.0-172.31.255.255");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x402000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "internet");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "172.16.2.6");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "53161");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "213.211.198.62");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.LogAction, "test");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "32812");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "192.168.178.202");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "213.211.198.62");    expected.put("original_string", THREAT_80);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/2.2");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParentSessionId, "0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "0");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2018/02/01 21:29:03");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "Outgoing");    expected.put(BasicPaloAltoFirewallParser.Seqno, "27438839");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001606000007");    expected.put(BasicPaloAltoFirewallParser.SessionID, "18720");    expected.put(BasicPaloAltoFirewallParser.Severity, "medium");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "Germany");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2018/02/01 21:29:03");    expected.put(BasicPaloAltoFirewallParser.ThreatCategory, "code-execution");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "vulnerability");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "Eicar File Detected(39040)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2018/02/01 21:29:03");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "guest");    expected.put(BasicPaloAltoFirewallParser.TunnelId, "0");    expected.put(BasicPaloAltoFirewallParser.TunnelType, "N/A");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "www.eicar.org/download/eicar.com");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.URLIndex, "9");    expected.put(BasicPaloAltoFirewallParser.WFReportID, "0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "0");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6371_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_80.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "allow");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ActionSource, "from-policy");    expected.put(BasicPaloAltoFirewallParser.Application, "ssl");    expected.put(BasicPaloAltoFirewallParser.Bytes, "7936");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "6205");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "1731");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "United States");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "1395");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x40001c");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "guest");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/2.2");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "134.19.6.22");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "172.16.2.31");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "41537");    expected.put(BasicPaloAltoFirewallParser.LogAction, "test");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "134.19.6.22");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "12211");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "192.168.18.2");    expected.put("original_string", TRAFFIC_80);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.Packets, "24");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParentSessionId, "0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put(BasicPaloAltoFirewallParser.PktsReceived, "10");    expected.put(BasicPaloAltoFirewallParser.PktsSent, "14");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2018/02/01 21:24:11");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "Outgoing");    expected.put(BasicPaloAltoFirewallParser.Seqno, "62977478");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001606000007");    expected.put(BasicPaloAltoFirewallParser.EndReason, "tcp-rst-from-client");    expected.put(BasicPaloAltoFirewallParser.SessionID, "19468");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "172.16.0.0-172.31.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2018/02/01 21:00:42");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "end");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2018/02/01 21:24:11");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "internet");    expected.put(BasicPaloAltoFirewallParser.TunnelId, "0");    expected.put(BasicPaloAltoFirewallParser.TunnelType, "N/A");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.DGH1, "0");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6372_0() throws ParseException
{    final String unsupportedLogTypeMessage = "1,2017/08/11 12:37:58,008900008659,INVALIDlogType,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0";    List<JSONObject> actual = parser.parse(unsupportedLogTypeMessage.getBytes(StandardCharsets.UTF_8));    assertNull(actual);}
public void metron_f6373_0() throws ParseException
{    final String invalidLengthMessage = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config";    JSONObject actual = parser.parse(invalidLengthMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedParserVersion = actual.get(BasicPaloAltoFirewallParser.ParserVersion).toString();    assertEquals(expectedParserVersion, "0");}
public void metron_f6374_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6375_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6376_0()
{    BasicSnortParser parser = new BasicSnortParser();    parser.configure(new HashMap());    Map out = parser.parse(goodMessage.getBytes(StandardCharsets.UTF_8)).get(0);    Assert.assertEquals(out.get("msg"), "Consecutive TCP small segments, exceeding threshold");    Assert.assertEquals(out.get("sig_rev"), "1");    Assert.assertEquals(out.get("ip_dst_addr"), "10.0.2.15");    Assert.assertEquals(out.get("ip_dst_port"), "22");    Assert.assertEquals(out.get("ethsrc"), "52:54:00:12:35:02");    Assert.assertEquals(out.get("tcpseq"), "0x9AFF3D7");    Assert.assertEquals(out.get("dgmlen"), "64");    Assert.assertEquals(out.get("icmpid"), "");    Assert.assertEquals(out.get("tcplen"), "");    Assert.assertEquals(out.get("tcpwindow"), "0xFFFF");    Assert.assertEquals(out.get("icmpseq").toString().trim(), "");    Assert.assertEquals(out.get("tcpack"), "0xC8761D52");    Assert.assertEquals(out.get("icmpcode"), "");    Assert.assertEquals(out.get("tos"), "0");    Assert.assertEquals(out.get("id"), "59677");    Assert.assertEquals(out.get("ethdst"), "08:00:27:7F:93:2D");    Assert.assertEquals(out.get("ip_src_addr"), "10.0.2.2");    Assert.assertEquals(out.get("ttl"), "64");    Assert.assertEquals(out.get("ethlen"), "0x4E");    Assert.assertEquals(out.get("iplen"), "65536");    Assert.assertEquals(out.get("icmptype"), "");    Assert.assertEquals(out.get("protocol"), "TCP");    Assert.assertEquals(out.get("ip_src_port"), "56642");    Assert.assertEquals(out.get("tcpflags"), "***AP***");    Assert.assertEquals(out.get("sig_id"), "12");    Assert.assertEquals(out.get("sig_generator"), "129");    Assert.assertEquals(out.get("is_alert"), "true");}
public void metron_f6377_0()
{    thrown.expect(IllegalStateException.class);    BasicSnortParser parser = new BasicSnortParser();    parser.init();    UnitTestHelper.setLog4jLevel(BasicSnortParser.class, Level.FATAL);    parser.parse("foo bar".getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicSnortParser.class, Level.ERROR);}
public void metron_f6378_0()
{        TimeZone defaultTimeZone = TimeZone.getDefault();    try {        TimeZone.setDefault(TimeZone.getTimeZone(ZoneId.of("America/New_York")));        BasicSnortParser parser = new BasicSnortParser();        parser.configure(new HashMap());        Map out = parser.parse(goodMessage.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertEquals(out.get("timestamp"), 1453928464877L);    } finally {                TimeZone.setDefault(defaultTimeZone);    }}
public void metron_f6379_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("dateFormat", "MM/dd/yyyy-HH:mm:ss.SSSSSS");    parserConfig.put("timeZone", "America/New_York");    BasicSnortParser parser = new BasicSnortParser();    parser.configure(parserConfig);    Map result = parser.parse(dateFormattedMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertThat("timestamp should match", result.get(Constants.Fields.TIMESTAMP.getName()), equalTo(1453928464877L));}
public void metron_f6380_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage(startsWith("Unable to find ZoneId"));    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("dateFormat", "MM/dd/yyyy-HH:mm:ss.SSSSSS");    parserConfig.put("timeZone", "blahblahBADZONE");    BasicSnortParser parser = new BasicSnortParser();    parser.configure(parserConfig);}
public void metron_f6381_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage(startsWith("Unknown pattern letter:"));    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("dateFormat", "BADFORMAT");    BasicSnortParser parser = new BasicSnortParser();    parser.configure(parserConfig);}
public void metron_f6382_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    BasicSnortParser parser = new BasicSnortParser();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6383_0()
{    Map<String, Object> config = new HashMap<>();    BasicSnortParser parser = new BasicSnortParser();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6384_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/SourcefireParserTest.txt");    parser = new BasicSourcefireParser();}
public void metron_f6385_0() throws ParseException
{    for (String inputString : inputStrings) {        byte[] srcBytes = inputString.getBytes(StandardCharsets.UTF_8);        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map json = (Map) parser.parse(parsed.toJSONString());        for (Object o : json.entrySet()) {            Entry entry = (Entry) o;            String key = (String) entry.getKey();            String value = json.get("original_string").toString();            Assert.assertNotNull(value);        }    }}
public void metron_f6386_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6387_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public Map<String, String> metron_f6388_0()
{    String input1 = "1461576382.642    161 127.0.0.1 TCP_MISS/200 103701 GET http://www.cnn.com/ - DIRECT/199.27.79.73 text/html";    String input2 = "1469539185.270      0 139.196.181.68 TCP_DENIED/403 3617 CONNECT search.yahoo.com:443 - NONE/- text/html";    HashMap testData = new HashMap<String, String>();    testData.put(input1, result1);    testData.put(input2, result2);    return testData;}
public String metron_f6389_0()
{    return "false";}
public String metron_f6390_0()
{    return "../metron-parsers/src/main/resources/patterns/squid";}
public String metron_f6391_0()
{    return "SQUID_DELIMITED";}
public List<String> metron_f6392_0()
{    return new ArrayList<>();}
public String metron_f6393_0()
{    return null;}
public String metron_f6394_0()
{    return "timestamp";}
public void metron_f6395_0()
{    parserConfig = new HashMap<>();    parserConfig.put("grokPath", "src/main/resources/patterns/websphere");    parserConfig.put("patternLabel", "WEBSPHERE");    parserConfig.put("timestampField", "timestamp_string");    parserConfig.put("dateFormat", "yyyy MMM dd HH:mm:ss");    parser = new GrokWebSphereParser();    parser.configure(parserConfig);}
public void metron_f6396_0() throws Exception
{    String testString = "<133>Apr 15 17:47:28 ABCXML1413 [rojOut][0x81000033][auth][notice] user(rick007): " + "[120.43.200.6]: User logged into 'cohlOut'.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 47, 28, 0, UTC).toInstant().toEpochMilli();        assertEquals(133, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ABCXML1413", parsedJSON.get("hostname"));    assertEquals("rojOut", parsedJSON.get("security_domain"));    assertEquals("0x81000033", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("notice", parsedJSON.get("severity"));    assertEquals("login", parsedJSON.get("event_subtype"));    assertEquals("rick007", parsedJSON.get("username"));    assertEquals("120.43.200.6", parsedJSON.get("ip_src_addr"));}
public void metron_f6397_0() throws Exception
{    String testString = "<134>Apr 15 18:02:27 PHIXML3RWD [0x81000019][auth][info] [14.122.2.201]: " + "User 'hjpotter' logged out from 'default'.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 18, 2, 27, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("PHIXML3RWD", parsedJSON.get("hostname"));    assertEquals("0x81000019", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals("14.122.2.201", parsedJSON.get("ip_src_addr"));    assertEquals("hjpotter", parsedJSON.get("username"));    assertEquals("default", parsedJSON.get("security_domain"));}
public void metron_f6398_0() throws Exception
{    String testString = "<131>Apr 15 17:36:35 ROBXML3QRS [0x80800018][auth][error] rbm(RBM-Settings): " + "trans(3502888135)[request] gtid(3502888135): RBM: Resource access denied.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 36, 35, 0, UTC).toInstant().toEpochMilli();        assertEquals(131, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ROBXML3QRS", parsedJSON.get("hostname"));    assertEquals("0x80800018", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("error", parsedJSON.get("severity"));    assertEquals("rbm", parsedJSON.get("process"));    assertEquals("trans(3502888135)[request] gtid(3502888135): RBM: Resource access denied.", parsedJSON.get("message"));}
public void metron_f6399_0() throws Exception
{    String testString = "<134>Apr 15 17:17:34 SAGPXMLQA333 [0x8240001c][audit][info] trans(191): (admin:default:system:*): " + "ntp-service 'NTP Service' - Operational state down";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 17, 34, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("SAGPXMLQA333", parsedJSON.get("hostname"));    assertEquals("0x8240001c", parsedJSON.get("event_code"));    assertEquals("audit", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals("trans", parsedJSON.get("process"));    assertEquals("(admin:default:system:*): ntp-service 'NTP Service' - Operational state down", parsedJSON.get("message"));}
public void metron_f6400_0() throws Exception
{    String testString = "<133>Apr 15 17:47:28 ABCXML1413 [rojOut][0x81000033][auth][notice] rick007): " + "[120.43.200. User logged into 'cohlOut'.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 47, 28, 0, UTC).toInstant().toEpochMilli();        assertEquals(133, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ABCXML1413", parsedJSON.get("hostname"));    assertEquals("rojOut", parsedJSON.get("security_domain"));    assertEquals("0x81000033", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("notice", parsedJSON.get("severity"));    assertEquals("login", parsedJSON.get("event_subtype"));    assertEquals(null, parsedJSON.get("username"));    assertEquals(null, parsedJSON.get("ip_src_addr"));}
public void metron_f6401_0() throws Exception
{    String testString = "<134>Apr 15 18:02:27 PHIXML3RWD [0x81000019][auth][info] [14.122.2.201: " + "User 'hjpotter' logged out from 'default.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 18, 2, 27, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("PHIXML3RWD", parsedJSON.get("hostname"));    assertEquals("0x81000019", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals(null, parsedJSON.get("ip_src_addr"));    assertEquals(null, parsedJSON.get("username"));    assertEquals(null, parsedJSON.get("security_domain"));}
public void metron_f6402_0() throws Exception
{    String testString = "<131>Apr 15 17:36:35 ROBXML3QRS [0x80800018][auth][error] rbmRBM-Settings): " + "trans3502888135)[request] gtid3502888135) RBM: Resource access denied.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 36, 35, 0, UTC).toInstant().toEpochMilli();        assertEquals(131, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ROBXML3QRS", parsedJSON.get("hostname"));    assertEquals("0x80800018", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("error", parsedJSON.get("severity"));    assertEquals(null, parsedJSON.get("process"));    assertEquals("rbmRBM-Settings): trans3502888135)[request] gtid3502888135) RBM: Resource access denied.", parsedJSON.get("message"));}
public void metron_f6403_0() throws Exception
{    String testString = "<134>Apr 15 17:17:34 SAGPXMLQA333 [0x8240001c][audit][info] trans 191)  admindefaultsystem*): " + "ntp-service 'NTP Service' - Operational state down:";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 17, 34, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("SAGPXMLQA333", parsedJSON.get("hostname"));    assertEquals("0x8240001c", parsedJSON.get("event_code"));    assertEquals("audit", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals(null, parsedJSON.get("process"));    assertEquals("trans 191)  admindefaultsystem*): ntp-service 'NTP Service' - Operational state down:", parsedJSON.get("message"));}
public void metron_f6404_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6405_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public Map metron_f6406_0()
{    Map testData = new HashMap<String, String>();    String input = "2016-01-28 15:29:48.512|2016-01-28 15:29:48.512|   0.000|   0.000|  6|                          216.21.170.221|   80|                               10.0.2.15|39468|      AS|       0|       0|       0|22efa001|00000000|000|000|       1|      44|       0|       0|    0|idle";    testData.put(input, result);    return testData;}
public String metron_f6407_0()
{    return "false";}
public String metron_f6408_0()
{    return "../metron-parsers/src/main/resources/patterns/yaf";}
public String metron_f6409_0()
{    return "YAF_DELIMITED";}
public List<String> metron_f6410_0()
{    return new ArrayList<String>() {        {            add("start_time");            add("end_time");        }    };}
public String metron_f6411_0()
{    return "yyyy-MM-dd HH:mm:ss.S";}
public String metron_f6412_0()
{    return "start_time";}
public boolean metron_f6413_0(JSONObject message)
{    JSONObject value = message;    final String invalidMessageTemplate = "[Metron] Message does not have {}: {}";    if (!(value.containsKey(ORIGINAL.getName()))) {        LOG.trace(invalidMessageTemplate, ORIGINAL.getName(), message);        return false;    } else if (!(value.containsKey(TIMESTAMP.getName()))) {        LOG.trace(invalidMessageTemplate, TIMESTAMP.getName(), message);        return false;    } else {        LOG.trace("[Metron] Message conforms to schema: {}", message);        return true;    }}
public String metron_f6414_0(JSONObject value)
{    try {        String ipSrcAddr = null;        String ipDstAddr = null;        if (value.containsKey(SRC_ADDR.getName()))            ipSrcAddr = value.get(SRC_ADDR.getName()).toString();        if (value.containsKey(DST_ADDR.getName()))            ipDstAddr = value.get(DST_ADDR.getName()).toString();        if (ipSrcAddr == null && ipDstAddr == null)            return "0";        if (ipSrcAddr == null || ipSrcAddr.length() == 0)            return ipDstAddr;        if (ipDstAddr == null || ipDstAddr.length() == 0)            return ipSrcAddr;        double ip1 = Double.parseDouble(ipSrcAddr.replace(".", ""));        double ip2 = Double.parseDouble(ipDstAddr.replace(".", ""));        return String.valueOf(ip1 + ip2);    } catch (Exception e) {        return "0";    }}
public void metron_f6415_0(Map<String, Object> config)
{    if (config.containsKey(READ_CHARSET)) {        readCharset = Charset.forName((String) config.get(READ_CHARSET));    } else {        readCharset = MessageParser.super.getReadCharset();    }}
public Charset metron_f6416_0()
{    return null == this.readCharset ? MessageParser.super.getReadCharset() : this.readCharset;}
public void metron_f6417_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    converter = new CSVConverter();    converter.initialize(parserConfig);    Object tsFormatObj = parserConfig.get(TIMESTAMP_FORMAT_CONF);    if (tsFormatObj != null) {        timestampFormat = new SimpleDateFormat(tsFormatObj.toString());    }}
public void metron_f6418_0()
{}
public List<JSONObject> metron_f6419_1(byte[] rawMessage)
{    try {        String msg = new String(rawMessage, getReadCharset());        Map<String, String> value = converter.toMap(msg);        if (value != null) {            value.put("original_string", msg);            Object timestampObj = value.get("timestamp");            Long timestamp = null;            if (timestampObj == null) {                timestamp = System.currentTimeMillis();            } else {                if (timestampFormat == null) {                    timestamp = ConversionUtils.convert(timestampObj, Long.class);                } else {                    try {                        timestamp = timestampFormat.parse(timestampObj.toString()).getTime();                    } catch (Exception e) {                                            }                }            }            JSONObject jsonVal = new JSONObject(value);            if (timestamp != null) {                jsonVal.put("timestamp", timestamp);            }            return ImmutableList.of(jsonVal);        } else {            return Collections.emptyList();        }    } catch (Throwable e) {        String message = "Unable to parse " + new String(rawMessage, getReadCharset()) + ": " + e.getMessage();                throw new IllegalStateException(message, e);    }}
public void metron_f6420_0(T message)
{    messages.add(message);}
public void metron_f6421_0(Object message, Throwable throwable)
{    errors.put(message, throwable);}
public List<T> metron_f6422_0()
{    return messages;}
public Map<Object, Throwable> metron_f6423_0()
{    return errors;}
public Optional<Throwable> metron_f6424_0()
{    return Optional.ofNullable(masterThrowable);}
public List<JSONObject> metron_f6425_0()
{    return messages;}
public List<MetronError> metron_f6426_0()
{    return errors;}
public void metron_f6427_0(JSONObject message)
{    this.messages.add(message);}
public void metron_f6428_0(MetronError error)
{    this.errors.add(error);}
public void metron_f6429_0(List<MetronError> errors)
{    this.errors.addAll(errors);}
public boolean metron_f6430_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ParserRunnerResults parserResult = (ParserRunnerResults) o;    return Objects.equals(messages, parserResult.getMessages()) && Objects.equals(errors, parserResult.getErrors());}
public int metron_f6431_0()
{    int result = messages != null ? messages.hashCode() : 0;    result = 31 * result + (errors != null ? errors.hashCode() : 0);    return result;}
public void metron_f6432_0(Map<String, Object> config)
{    Object protocolsObj = config.get("bro.filter.source.known.protocols");    Object keyObj = config.get("bro.filter.source.key");    if (keyObj != null) {        _key = keyObj.toString();    }    if (protocolsObj != null) {        if (protocolsObj instanceof String) {            _known_protocols.clear();            _known_protocols.add(protocolsObj.toString());        } else if (protocolsObj instanceof List) {            _known_protocols.clear();            for (Object o : (List) protocolsObj) {                _known_protocols.add(o.toString());            }        }    }}
public boolean metron_f6433_0(JSONObject message, Context context)
{    String protocol = (String) message.get(_key);    return _known_protocols.contains(protocol);}
public static MessageFilter<JSONObject> metron_f6434_0(String filterName, Map<String, Object> config)
{    if (filterName == null || filterName.trim().isEmpty()) {        return null;    }    Class<? extends MessageFilter> filterClass;    try {        Filters f = Filters.valueOf(filterName);        filterClass = f.clazz;    } catch (Exception ex) {        try {            filterClass = (Class<? extends MessageFilter>) Class.forName(filterName);        } catch (ClassNotFoundException e) {            throw new IllegalStateException("Unable to find class " + filterName, e);        }    }    if (filterClass != null) {        MessageFilter<JSONObject> filter = ReflectionUtils.createInstance(filterClass);        filter.configure(config);        return filter;    }    return null;}
public void metron_f6435_0(Map<String, Object> config)
{    Object o = config.get(QUERY_STRING_CONF);    if (o instanceof String) {        query = o.toString();    }    Context stellarContext = (Context) config.get("stellarContext");    if (stellarContext == null) {        stellarContext = Context.EMPTY_CONTEXT();    }    processor.validate(query, true, stellarContext);}
public boolean metron_f6436_0(JSONObject message, Context context)
{    VariableResolver resolver = new MapVariableResolver(message);    return processor.parse(query, resolver, functionResolver, context);}
public void metron_f6437_1(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    this.grokPath = (String) parserConfig.get("grokPath");    String multiLineString = (String) parserConfig.get("multiLine");    if (!StringUtils.isBlank(multiLineString)) {        multiLine = Boolean.parseBoolean(multiLineString);    }    this.patternLabel = (String) parserConfig.get("patternLabel");    this.timestampField = (String) parserConfig.get("timestampField");    List<String> timeFieldsParam = (List<String>) parserConfig.get("timeFields");    if (timeFieldsParam != null) {        this.timeFields = timeFieldsParam;    }    String dateFormatParam = (String) parserConfig.get("dateFormat");    if (dateFormatParam != null) {        this.dateFormat = new SimpleDateFormat(dateFormatParam);    }    String timeZoneParam = (String) parserConfig.get("timeZone");    if (timeZoneParam != null) {        dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneParam));            } else {        dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));            }}
public InputStream metron_f6438_1(String streamName) throws IOException
{    FileSystem fs = FileSystem.get(new Configuration());    Path path = new Path(streamName);    if (fs.exists(path)) {                return fs.open(path);    } else {                return getClass().getResourceAsStream(streamName);    }}
public void metron_f6439_1()
{    grok = new Grok();    try {        InputStream commonInputStream = openInputStream(patternsCommonDir);                if (commonInputStream == null) {            throw new RuntimeException("Unable to initialize grok parser: Unable to load " + patternsCommonDir + " from either classpath or HDFS");        }        grok.addPatternFromReader(new InputStreamReader(commonInputStream, getReadCharset()));                InputStream patterInputStream = openInputStream(grokPath);        if (patterInputStream == null) {            throw new RuntimeException("Grok parser unable to initialize grok parser: Unable to load " + grokPath + " from either classpath or HDFS");        }        grok.addPatternFromReader(new InputStreamReader(patterInputStream, getReadCharset()));                String grokPattern = "%{" + patternLabel + "}";        grok.compile(grokPattern);            } catch (Throwable e) {                throw new RuntimeException("Grok parser Error: " + e.getMessage(), e);    }}
public Optional<MessageParserResult<JSONObject>> metron_f6440_0(byte[] rawMessage)
{    if (grok == null) {        init();    }    if (multiLine) {        return parseMultiLine(rawMessage);    }    return parseSingleLine(rawMessage);}
private Optional<MessageParserResult<JSONObject>> metron_f6441_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    Map<Object, Throwable> errors = new HashMap<>();    String originalMessage = null;        try (BufferedReader reader = new BufferedReader(new StringReader(new String(rawMessage, getReadCharset())))) {        while ((originalMessage = reader.readLine()) != null) {                        try {                Match gm = grok.match(originalMessage);                gm.captures();                JSONObject message = new JSONObject();                message.putAll(gm.toMap());                if (message.size() == 0) {                    Throwable rte = new RuntimeException("Grok statement produced a null message. Original message was: " + originalMessage + " and the parsed message was: " + message + " . Check the pattern at: " + grokPath);                    errors.put(originalMessage, rte);                    continue;                }                message.put("original_string", originalMessage);                for (String timeField : timeFields) {                    String fieldValue = (String) message.get(timeField);                    if (fieldValue != null) {                        message.put(timeField, toEpoch(fieldValue));                    }                }                if (timestampField != null) {                    message.put(Constants.Fields.TIMESTAMP.getName(), formatTimestamp(message.get(timestampField)));                }                message.remove(patternLabel);                postParse(message);                messages.add(message);                            } catch (Exception e) {                                errors.put(originalMessage, e);            }        }    } catch (IOException e) {                Exception innerException = new IllegalStateException("Grok parser Error: " + e.getMessage() + " on " + originalMessage, e);        return Optional.of(new DefaultMessageParserResult<>(innerException));    }    return Optional.of(new DefaultMessageParserResult<>(messages, errors));}
private Optional<MessageParserResult<JSONObject>> metron_f6442_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    Map<Object, Throwable> errors = new HashMap<>();    String originalMessage = null;    try {        originalMessage = new String(rawMessage, StandardCharsets.UTF_8);                Match gm = grok.match(originalMessage);        gm.captures();        JSONObject message = new JSONObject();        message.putAll(gm.toMap());        if (message.size() == 0) {            Throwable rte = new RuntimeException("Grok statement produced a null message. Original message was: " + originalMessage + " and the parsed message was: " + message + " . Check the pattern at: " + grokPath);            errors.put(originalMessage, rte);        } else {            message.put("original_string", originalMessage);            for (String timeField : timeFields) {                String fieldValue = (String) message.get(timeField);                if (fieldValue != null) {                    message.put(timeField, toEpoch(fieldValue));                }            }            if (timestampField != null) {                message.put(Constants.Fields.TIMESTAMP.getName(), formatTimestamp(message.get(timestampField)));            }            message.remove(patternLabel);            postParse(message);            messages.add(message);                    }    } catch (Exception e) {                Exception innerException = new IllegalStateException("Grok parser Error: " + e.getMessage() + " on " + originalMessage, e);        return Optional.of(new DefaultMessageParserResult<>(innerException));    }    return Optional.of(new DefaultMessageParserResult<JSONObject>(messages, errors));}
public boolean metron_f6443_1(JSONObject message)
{        Object timestampObject = message.get(Constants.Fields.TIMESTAMP.getName());    if (timestampObject instanceof Long) {        Long timestamp = (Long) timestampObject;        if (timestamp > 0) {                        return true;        }    }        return false;}
protected void metron_f6444_0(JSONObject message)
{}
protected long metron_f6445_1(String datetime) throws ParseException
{            Date date = dateFormat.parse(datetime);        return date.getTime();}
protected long metron_f6446_1(Object value)
{        if (value == null) {        throw new RuntimeException(patternLabel + " pattern does not include field " + timestampField);    }    if (value instanceof Number) {        return ((Number) value).longValue();    } else {        return Long.parseLong(Joiner.on("").join(Splitter.on('.').split(value + "")));    }}
public void metron_f6447_0(Map<String, Object> config)
{    if (config.containsKey(READ_CHARSET)) {        readCharset = Charset.forName((String) config.get(READ_CHARSET));    } else {        readCharset = MessageParser.super.getReadCharset();    }}
public Charset metron_f6448_0()
{    return null == this.readCharset ? MessageParser.super.getReadCharset() : this.readCharset;}
 List<T> metron_f6449_0(byte[] rawMessage)
{    throw new NotImplementedException("parse is not implemented");}
 Optional<List<T>> metron_f6450_0(byte[] parseMessage)
{    return Optional.ofNullable(parse(parseMessage));}
 Optional<MessageParserResult<T>> metron_f6451_0(byte[] parseMessage)
{    Optional<MessageParserResult<T>> result = Optional.empty();    try {        Optional<List<T>> optionalMessages = parseOptional(parseMessage);        if (optionalMessages.isPresent()) {            result = Optional.of(new DefaultMessageParserResult<>(optionalMessages.get()));        }    } catch (Throwable t) {        return Optional.of(new DefaultMessageParserResult<>(t));    }    return result;}
 Charset metron_f6452_0()
{    return StandardCharsets.UTF_8;}
private static JSONObject metron_f6453_0(String key, Map value, JSONObject obj)
{    Set<Map.Entry<Object, Object>> entrySet = value.entrySet();    for (Map.Entry<Object, Object> kv : entrySet) {        String newKey = Joiner.on(".").join(key, kv.getKey().toString());        if (kv.getValue() instanceof Map) {            recursiveUnfold(newKey, (Map) kv.getValue(), obj);        } else {            obj.put(newKey, kv.getValue());        }    }    return obj;}
public JSONObject metron_f6454_0(String key, Map value, JSONObject obj)
{    return handler.handle(key, value, obj);}
public void metron_f6455_0(Map<String, Object> config)
{    setReadCharset(config);    String strategyStr = (String) config.getOrDefault(MAP_STRATEGY_CONFIG, MapStrategy.DROP.name());    mapStrategy = MapStrategy.valueOf(strategyStr);    overrideOriginalString = (Boolean) config.getOrDefault(OVERRIDE_ORIGINAL_STRING, false);    if (config.containsKey(JSONP_QUERY)) {        typeRef = new TypeRef<List<Map<String, Object>>>() {        };        jsonpQuery = (String) config.get(JSONP_QUERY);        if (!StringUtils.isBlank(jsonpQuery) && config.containsKey(WRAP_JSON)) {            Object wrapObject = config.get(WRAP_JSON);            if (wrapObject instanceof String) {                wrapJson = Boolean.valueOf((String) wrapObject);            } else if (wrapObject instanceof Boolean) {                wrapJson = (Boolean) config.get(WRAP_JSON);            }            String entityName = (String) config.get(WRAP_ENTITY_NAME);            if (!StringUtils.isBlank(entityName)) {                wrapEntityName = entityName;            }        }        Configuration.setDefaults(new Configuration.Defaults() {            private final JsonProvider jsonProvider = new JacksonJsonProvider();            private final MappingProvider mappingProvider = new JacksonMappingProvider();            @Override            public JsonProvider jsonProvider() {                return jsonProvider;            }            @Override            public MappingProvider mappingProvider() {                return mappingProvider;            }            @Override            public Set<Option> options() {                return EnumSet.of(Option.SUPPRESS_EXCEPTIONS);            }        });        if (CacheProvider.getCache() == null) {            CacheProvider.setCache(new LRUCache(100));        }    }}
public JsonProvider metron_f6456_0()
{    return jsonProvider;}
public MappingProvider metron_f6457_0()
{    return mappingProvider;}
public Set<Option> metron_f6458_0()
{    return EnumSet.of(Option.SUPPRESS_EXCEPTIONS);}
public void metron_f6459_0()
{}
public List<JSONObject> metron_f6460_1(byte[] rawMessage)
{    try {        String rawString = new String(rawMessage, getReadCharset());        List<Map<String, Object>> messages = new ArrayList<>();                if (wrapJson) {            rawString = wrapMessageJson(rawString);        }        if (!StringUtils.isEmpty(jsonpQuery)) {            Object parsedObject = JsonPath.parse(rawString).read(jsonpQuery, typeRef);            if (parsedObject != null) {                messages.addAll((List<Map<String, Object>>) parsedObject);            }        } else {            messages.add(JSONUtils.INSTANCE.load(rawString, JSONUtils.MAP_SUPPLIER));        }        ArrayList<JSONObject> parsedMessages = new ArrayList<>();        for (Map<String, Object> rawMessageMap : messages) {            JSONObject ret = normalizeJson(rawMessageMap);            if (overrideOriginalString) {                                                JSONObject originalJsonObject = new JSONObject(rawMessageMap);                ret.put("original_string", originalJsonObject.toJSONString());            }            if (!ret.containsKey("timestamp")) {                ret.put("timestamp", System.currentTimeMillis());            }            parsedMessages.add(ret);        }        return Collections.unmodifiableList(parsedMessages);    } catch (Throwable e) {        String message = "Unable to parse " + new String(rawMessage, getReadCharset()) + ": " + e.getMessage();                throw new IllegalStateException(message, e);    }}
private JSONObject metron_f6461_0(Map<String, Object> map)
{    JSONObject ret = new JSONObject();    for (Map.Entry<String, Object> kv : map.entrySet()) {        if (kv.getValue() instanceof Map) {            mapStrategy.handle(kv.getKey(), (Map) kv.getValue(), ret);        } else {            ret.put(kv.getKey(), kv.getValue());        }    }    return ret;}
private String metron_f6462_0(String jsonMessage)
{    String base = new StringBuilder(String.format(WRAP_START_FMT, wrapEntityName)).append(jsonMessage).toString().trim();    if (base.endsWith(",")) {        base = base.substring(0, base.length() - 1);    }    return base + WRAP_END;}
public MessageParser<JSONObject> metron_f6463_0()
{    return messageParser;}
public MessageFilter<JSONObject> metron_f6464_0()
{    return filter;}
public void metron_f6465_0(MessageParser<JSONObject> messageParser)
{    this.messageParser = messageParser;}
public void metron_f6466_0(MessageFilter<JSONObject> filter)
{    this.filter = filter;}
public JSONObject metron_f6467_0()
{    return message;}
public MetronError metron_f6468_0()
{    return error;}
public boolean metron_f6469_0()
{    return error != null;}
public Map<String, ParserComponent> metron_f6470_0()
{    return sensorToParserComponentMap;}
public void metron_f6471_0(Map<String, ParserComponent> sensorToParserComponentMap)
{    this.sensorToParserComponentMap = sensorToParserComponentMap;}
public Context metron_f6472_0()
{    return stellarContext;}
public Set<String> metron_f6473_0()
{    return sensorTypes;}
public void metron_f6474_0(Supplier<ParserConfigurations> parserConfigSupplier, Context stellarContext)
{    if (parserConfigSupplier == null) {        throw new IllegalStateException("A parser config supplier must be set before initializing the ParserRunner.");    }    if (stellarContext == null) {        throw new IllegalStateException("A stellar context must be set before initializing the ParserRunner.");    }    this.stellarContext = stellarContext;    initializeParsers(parserConfigSupplier);}
public ParserRunnerResults<JSONObject> metron_f6475_0(String sensorType, RawMessage rawMessage, ParserConfigurations parserConfigurations)
{    DefaultParserRunnerResults parserRunnerResults = new DefaultParserRunnerResults();    SensorParserConfig sensorParserConfig = parserConfigurations.getSensorParserConfig(sensorType);    if (sensorParserConfig != null) {        MessageParser<JSONObject> parser = sensorToParserComponentMap.get(sensorType).getMessageParser();        Optional<MessageParserResult<JSONObject>> optionalMessageParserResult = parser.parseOptionalResult(rawMessage.getMessage());        if (optionalMessageParserResult.isPresent()) {            MessageParserResult<JSONObject> messageParserResult = optionalMessageParserResult.get();                        messageParserResult.getMessages().forEach(message -> {                Optional<ProcessResult> processResult = processMessage(sensorType, message, rawMessage, parser, parserConfigurations);                if (processResult.isPresent()) {                    if (processResult.get().isError()) {                        parserRunnerResults.addError(processResult.get().getError());                    } else {                        parserRunnerResults.addMessage(processResult.get().getMessage());                    }                }            });                        messageParserResult.getMasterThrowable().ifPresent(throwable -> parserRunnerResults.addError(new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(throwable).withSensorType(Collections.singleton(sensorType)).withMetadata(rawMessage.getMetadata()).addRawMessage(rawMessage.getMessage())));                        parserRunnerResults.addErrors(messageParserResult.getMessageThrowables().entrySet().stream().map(entry -> new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(entry.getValue()).withSensorType(Collections.singleton(sensorType)).withMetadata(rawMessage.getMetadata()).addRawMessage(entry.getKey())).collect(Collectors.toList()));        }    } else {        throw new IllegalStateException(String.format("Could not execute parser.  Cannot find configuration for sensor %s.", sensorType));    }    return parserRunnerResults;}
private void metron_f6476_1(Supplier<ParserConfigurations> parserConfigSupplier)
{        sensorToParserComponentMap = new HashMap<>();    for (String sensorType : sensorTypes) {        if (parserConfigSupplier.get().getSensorParserConfig(sensorType) == null) {            throw new IllegalStateException(String.format("Could not initialize parsers.  Cannot find configuration for sensor %s.", sensorType));        }        SensorParserConfig parserConfig = parserConfigSupplier.get().getSensorParserConfig(sensorType);                        MessageParser<JSONObject> parser = ReflectionUtils.createInstance(parserConfig.getParserClassName());                MessageFilter<JSONObject> filter = null;        parserConfig.getParserConfig().putIfAbsent("stellarContext", stellarContext);        if (!StringUtils.isEmpty(parserConfig.getFilterClassName())) {            filter = Filters.get(parserConfig.getFilterClassName(), parserConfig.getParserConfig());        }        parser.configure(parserConfig.getParserConfig());        parser.init();        sensorToParserComponentMap.put(sensorType, new ParserComponent(parser, filter));    }}
protected Optional<ProcessResult> metron_f6477_0(String sensorType, JSONObject message, RawMessage rawMessage, MessageParser<JSONObject> parser, ParserConfigurations parserConfigurations)
{    Optional<ProcessResult> processResult = Optional.empty();    SensorParserConfig sensorParserConfig = parserConfigurations.getSensorParserConfig(sensorType);    sensorParserConfig.getRawMessageStrategy().mergeMetadata(message, rawMessage.getMetadata(), sensorParserConfig.getMergeMetadata(), sensorParserConfig.getRawMessageStrategyConfig());    message.put(Constants.SENSOR_TYPE, sensorType);    applyFieldTransformations(message, rawMessage, sensorParserConfig);    if (!message.containsKey(Constants.GUID)) {        message.put(Constants.GUID, UUID.randomUUID().toString());    }    message.putIfAbsent(Fields.ORIGINAL.getName(), new String(rawMessage.getMessage(), parser.getReadCharset()));    MessageFilter<JSONObject> filter = sensorToParserComponentMap.get(sensorType).getFilter();    if (filter == null || filter.emit(message, stellarContext)) {        boolean isInvalid = !parser.validate(message);        List<FieldValidator> failedValidators = null;        if (!isInvalid) {            failedValidators = getFailedValidators(message, parserConfigurations);            isInvalid = !failedValidators.isEmpty();        }        if (isInvalid) {            MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton(sensorType)).withMetadata(rawMessage.getMetadata()).addRawMessage(message);            Set<String> errorFields = failedValidators == null ? null : failedValidators.stream().flatMap(fieldValidator -> fieldValidator.getInput().stream()).collect(Collectors.toSet());            if (errorFields != null && !errorFields.isEmpty()) {                error.withErrorFields(errorFields);            }            processResult = Optional.of(new ProcessResult(error));        } else {            processResult = Optional.of(new ProcessResult(message));        }    }    return processResult;}
private void metron_f6478_0(JSONObject message, RawMessage rawMessage, SensorParserConfig sensorParserConfig)
{    for (FieldTransformer handler : sensorParserConfig.getFieldTransformations()) {        if (handler != null) {            if (!sensorParserConfig.getMergeMetadata()) {                                handler.transformAndUpdate(message, stellarContext, sensorParserConfig.getParserConfig(), rawMessage.getMetadata());            } else {                handler.transformAndUpdate(message, stellarContext, sensorParserConfig.getParserConfig());            }        }    }}
private List<FieldValidator> metron_f6479_0(JSONObject message, ParserConfigurations parserConfigurations)
{    List<FieldValidator> fieldValidations = parserConfigurations.getFieldValidations();    List<FieldValidator> failedValidators = new ArrayList<>();    for (FieldValidator validator : fieldValidations) {        if (!validator.isValid(message, parserConfigurations.getGlobalConfig(), stellarContext)) {            failedValidators.add(validator);        }    }    return failedValidators;}
public List<JSONObject> metron_f6480_1(byte[] rawMessage)
{    String originalMessage = null;    try {        originalMessage = new String(rawMessage, getReadCharset()).trim();                if (originalMessage.isEmpty()) {                        return Arrays.asList(new JSONObject());        }    } catch (Exception e) {                throw new RuntimeException(e.getMessage(), e);    }    JSONObject parsedJson = new JSONObject();    if (messageHeaderPatternsMap.size() > 0) {        parsedJson.putAll(extractHeaderFields(originalMessage));    }    parsedJson.putAll(parse(originalMessage));    parsedJson.put(Constants.Fields.ORIGINAL.getName(), originalMessage);    /**     * Populate the output json with default timestamp.     */    parsedJson.put(Constants.Fields.TIMESTAMP.getName(), System.currentTimeMillis());    applyFieldTransformations(parsedJson);    return Arrays.asList(parsedJson);}
private void metron_f6481_0(JSONObject parsedJson)
{    if (getParserConfig().get(ParserConfigConstants.CONVERT_CAMELCASE_TO_UNDERSCORE.getName()) != null && (Boolean) getParserConfig().get(ParserConfigConstants.CONVERT_CAMELCASE_TO_UNDERSCORE.getName())) {        convertCamelCaseToUnderScore(parsedJson);    }}
public void metron_f6482_1(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    setParserConfig(parserConfig);    setFields((List<Map<String, Object>>) getParserConfig().get(ParserConfigConstants.FIELDS.getName()));    String recordTypeRegex = (String) getParserConfig().get(ParserConfigConstants.RECORD_TYPE_REGEX.getName());    if (StringUtils.isBlank(recordTypeRegex)) {                throw new IllegalStateException("Invalid config :recordTypeRegex is missing in parserConfig");    }    setRecordTypePattern(recordTypeRegex);    recordTypePatternNamedGroups.addAll(getNamedGroups(recordTypeRegex));    List<Map<String, Object>> fields = (List<Map<String, Object>>) getParserConfig().get(ParserConfigConstants.FIELDS.getName());    try {        configureRecordTypePatterns(fields);        configureMessageHeaderPattern();    } catch (PatternSyntaxException e) {                throw new IllegalStateException("Invalid config : " + e.getMessage());    }    validateConfig();}
private void metron_f6483_0()
{    if (getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName()) != null) {        if (getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName()) instanceof List) {            List<String> messageHeaderPatternList = (List<String>) getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName());            for (String messageHeaderPatternStr : messageHeaderPatternList) {                messageHeaderPatternsMap.put(Pattern.compile(messageHeaderPatternStr), getNamedGroups(messageHeaderPatternStr));            }        } else if (getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName()) instanceof String) {            String messageHeaderPatternStr = (String) getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName());            if (StringUtils.isNotBlank(messageHeaderPatternStr)) {                messageHeaderPatternsMap.put(Pattern.compile(messageHeaderPatternStr), getNamedGroups(messageHeaderPatternStr));            }        }    }}
private void metron_f6484_0(List<Map<String, Object>> fields)
{    for (Map<String, Object> field : fields) {        if (field.get(ParserConfigConstants.RECORD_TYPE.getName()) != null && field.get(ParserConfigConstants.REGEX.getName()) != null) {            String recordType = ((String) field.get(ParserConfigConstants.RECORD_TYPE.getName())).toLowerCase();            recordTypePatternMap.put(recordType, new LinkedHashMap<>());            if (field.get(ParserConfigConstants.REGEX.getName()) instanceof List) {                List<String> regexList = (List<String>) field.get(ParserConfigConstants.REGEX.getName());                regexList.forEach(s -> {                    recordTypePatternMap.get(recordType).put(Pattern.compile(s), getNamedGroups(s));                });            } else if (field.get(ParserConfigConstants.REGEX.getName()) instanceof String) {                recordTypePatternMap.get(recordType).put(Pattern.compile((String) field.get(ParserConfigConstants.REGEX.getName())), getNamedGroups((String) field.get(ParserConfigConstants.REGEX.getName())));            }        }    }}
private void metron_f6485_0(String recordTypeRegex)
{    if (recordTypeRegex != null) {        recordTypePattern = Pattern.compile(recordTypeRegex);    }}
private JSONObject metron_f6486_0(String originalMessage)
{    JSONObject parsedJson = new JSONObject();    Optional<String> recordIdentifier = getField(recordTypePattern, originalMessage);    if (recordIdentifier.isPresent()) {        extractNamedGroups(parsedJson, recordIdentifier.get(), originalMessage);    }    /*         * Extract fields(named groups) from record type regular expression         */    Matcher matcher = recordTypePattern.matcher(originalMessage);    if (matcher.find()) {        for (String namedGroup : recordTypePatternNamedGroups) {            if (matcher.group(namedGroup) != null) {                parsedJson.put(namedGroup, matcher.group(namedGroup).trim());            }        }    }    return parsedJson;}
private void metron_f6487_1(Map<String, Object> json, String recordType, String originalMessage)
{    Map<Pattern, Set<String>> patternMap = recordTypePatternMap.get(recordType.toLowerCase());    if (patternMap != null) {        for (Map.Entry<Pattern, Set<String>> entry : patternMap.entrySet()) {            Pattern pattern = entry.getKey();            Set<String> namedGroups = entry.getValue();            if (pattern != null && namedGroups != null && namedGroups.size() > 0) {                Matcher m = pattern.matcher(originalMessage);                if (m.matches()) {                                        for (String namedGroup : namedGroups) {                        if (m.group(namedGroup) != null) {                            json.put(namedGroup, m.group(namedGroup).trim());                        }                    }                    break;                }            }        }    } else {            }}
public Optional<String> metron_f6488_0(Pattern pattern, String originalMessage)
{    Matcher matcher = pattern.matcher(originalMessage);    while (matcher.find()) {        return Optional.of(matcher.group());    }    return Optional.empty();}
private Set<String> metron_f6489_0(String regex)
{    Set<String> namedGroups = new TreeSet<>();    Matcher matcher = namedGroupPattern.matcher(regex);    while (matcher.find()) {        namedGroups.add(matcher.group(1));    }    return namedGroups;}
private Map<String, Object> metron_f6490_0(String originalMessage)
{    Map<String, Object> messageHeaderJson = new JSONObject();    for (Map.Entry<Pattern, Set<String>> syslogPatternEntry : messageHeaderPatternsMap.entrySet()) {        Matcher m = syslogPatternEntry.getKey().matcher(originalMessage);        if (m.find()) {            for (String namedGroup : syslogPatternEntry.getValue()) {                if (StringUtils.isNotBlank(m.group(namedGroup))) {                    messageHeaderJson.put(namedGroup, m.group(namedGroup).trim());                }            }            break;        }    }    return messageHeaderJson;}
public void metron_f6491_1()
{    }
public void metron_f6492_1()
{    if (getFields() == null) {                throw new IllegalStateException("Invalid config :fields is missing in parserConfig");    }}
private void metron_f6493_0(Map<String, Object> json)
{    Map<String, String> oldKeyNewKeyMap = new HashMap<>();    for (Map.Entry<String, Object> entry : json.entrySet()) {        if (capitalLettersPattern.matcher(entry.getKey()).matches()) {            oldKeyNewKeyMap.put(entry.getKey(), CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, entry.getKey()));        }    }    oldKeyNewKeyMap.forEach((oldKey, newKey) -> json.put(newKey, json.remove(oldKey)));}
public List<Map<String, Object>> metron_f6494_0()
{    return fields;}
public void metron_f6495_0(List<Map<String, Object>> fields)
{    this.fields = fields;}
public Map<String, Object> metron_f6496_0()
{    return parserConfig;}
public void metron_f6497_0(Map<String, Object> parserConfig)
{    this.parserConfig = parserConfig;}
public String metron_f6498_0()
{    return name;}
public static ParserConfigConstants metron_f6499_0(String fieldName)
{    return nameToField.get(fieldName);}
protected void metron_f6500_0(SyslogParser syslogParser)
{    this.syslogParser = syslogParser;}
protected void metron_f6501_0(Consumer<JSONObject> function)
{    this.messageProcessorOptional = Optional.of(function);}
public void metron_f6503_0()
{}
public boolean metron_f6504_0(JSONObject message)
{    if (!(message.containsKey("original_string"))) {        LOG.trace("[Metron] Message does not have original_string: {}", message);        return false;    } else if (!(message.containsKey("timestamp"))) {        LOG.trace("[Metron] Message does not have timestamp: {}", message);        return false;    } else {        LOG.trace("[Metron] Message conforms to schema: {}", message);        return true;    }}
public Optional<MessageParserResult<JSONObject>> metron_f6505_1(byte[] rawMessage)
{    try {        if (rawMessage == null || rawMessage.length == 0) {            return Optional.empty();        }        String originalString = new String(rawMessage, getReadCharset());        final List<JSONObject> returnList = new ArrayList<>();        Map<Object, Throwable> errorMap = new HashMap<>();        try (Reader reader = new BufferedReader(new StringReader(originalString))) {            syslogParser.parseLines(reader, (m) -> {                JSONObject jsonObject = new JSONObject(m);                                                jsonObject.put("original_string", originalString);                try {                    setTimestamp(jsonObject);                } catch (ParseException pe) {                    errorMap.put(originalString, pe);                    return;                }                messageProcessorOptional.ifPresent((c) -> c.accept(jsonObject));                returnList.add(jsonObject);            }, errorMap::put);            return Optional.of(new DefaultMessageParserResult<JSONObject>(returnList, errorMap));        }    } catch (IOException e) {        String message = "Unable to read buffer " + new String(rawMessage, StandardCharsets.UTF_8) + ": " + e.getMessage();                return Optional.of(new DefaultMessageParserResult<JSONObject>(new IllegalStateException(message, e)));    }}
private void metron_f6506_0(JSONObject message) throws ParseException
{    String timeStampString = (String) message.get(SyslogFieldKeys.HEADER_TIMESTAMP.getField());    if (!StringUtils.isBlank(timeStampString) && !timeStampString.equals("-")) {        message.put("timestamp", SyslogUtils.parseTimestampToEpochMillis(timeStampString, deviceClock));    } else {        message.put("timestamp", LocalDateTime.now().toEpochSecond(ZoneOffset.UTC));    }}
public void metron_f6507_0(Map<String, Object> config)
{    if (config.containsKey(READ_CHARSET)) {        readCharset = Charset.forName((String) config.get(READ_CHARSET));    } else {        readCharset = MessageParser.super.getReadCharset();    }}
public Charset metron_f6508_0()
{    return null == this.readCharset ? MessageParser.super.getReadCharset() : this.readCharset;}
public SyslogParser metron_f6509_0(Map<String, Object> config)
{    return new SyslogParserBuilder().forSpecification(SyslogSpecification.RFC_3164).withDeviations(EnumSet.of(AllowableDeviations.PRIORITY, AllowableDeviations.VERSION)).build();}
public SyslogParser metron_f6510_0(Map<String, Object> config)
{            String nilPolicyStr = (String) config.getOrDefault(NIL_POLICY_CONFIG, NilPolicy.OMIT.name());    NilPolicy nilPolicy = NilPolicy.valueOf(nilPolicyStr);    return new SyslogParserBuilder().forSpecification(SyslogSpecification.RFC_5424).withNilPolicy(nilPolicy).withDeviations(EnumSet.of(AllowableDeviations.PRIORITY, AllowableDeviations.VERSION)).build();}
public static long metron_f6511_0(String candidate, List<SimpleDateFormat> validPatterns) throws ParseException
{    if (StringUtils.isNumeric(candidate)) {        return Long.valueOf(candidate);    } else {        for (SimpleDateFormat pattern : validPatterns) {            try {                Calendar cal = Calendar.getInstance();                cal.setTime(pattern.parse(candidate));                Calendar current = Calendar.getInstance();                if (cal.get(Calendar.YEAR) == 1970) {                    cal.set(Calendar.YEAR, current.get(Calendar.YEAR));                }                current.add(Calendar.DAY_OF_MONTH, 4);                if (cal.after(current)) {                    cal.add(Calendar.YEAR, -1);                }                return cal.getTimeInMillis();            } catch (ParseException e) {                continue;            }        }        throw new ParseException("Failed to parse any of the given date formats", 0);    }}
public static File metron_f6512_0(InputStream in) throws IOException
{    final File tempFile = File.createTempFile(PREFIX, SUFFIX);    tempFile.deleteOnExit();    try (FileOutputStream out = new FileOutputStream(tempFile)) {        IOUtils.copy(in, out);    }    return tempFile;}
public static Long metron_f6513_0(String m, String d, String ts, boolean adjust_timezone) throws ParseException
{    d = d.trim();    if (d.length() <= 2) {        d = "0" + d;    }    Date date = new SimpleDateFormat("MMM", Locale.ENGLISH).parse(m);    Calendar cal = Calendar.getInstance();    cal.setTime(date);    String month = String.valueOf(cal.get(Calendar.MONTH) + 1);    int year = Calendar.getInstance().get(Calendar.YEAR);    if (month.length() <= 2) {        month = "0" + month;    }    String coglomerated_ts = year + "-" + month + "-" + d + " " + ts;    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    if (adjust_timezone) {        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));    }    date = sdf.parse(coglomerated_ts);    long timeInMillisSinceEpoch = date.getTime();    return timeInMillisSinceEpoch;}
public static long metron_f6514_0(String logTimestamp, Clock deviceClock) throws ParseException
{    ZoneId deviceTimeZone = deviceClock.getZone();        if (Pattern.matches("[A-Z][a-z]{2}(?:(?:\\s{2}\\d)|(?:\\s\\d{2}))\\s\\d{2}:\\d{2}:\\d{2}", logTimestamp)) {        DateTimeFormatter inputFormat = DateTimeFormatter.ofPattern("MMM ppd HH:mm:ss").withZone(deviceTimeZone);        TemporalAccessor inputDate = inputFormat.parse(logTimestamp);        int inputMonth = inputDate.get(MONTH_OF_YEAR);        int inputDay = inputDate.get(DAY_OF_MONTH);        int inputHour = inputDate.get(HOUR_OF_DAY);        int inputMinute = inputDate.get(MINUTE_OF_HOUR);        int inputSecond = inputDate.get(SECOND_OF_MINUTE);        ZonedDateTime currentDate = ZonedDateTime.now(deviceClock);        int currentYear = currentDate.getYear();        ZonedDateTime inputDateWithCurrentYear = ZonedDateTime.of(currentYear, inputMonth, inputDay, inputHour, inputMinute, inputSecond, 0, deviceTimeZone);                if (inputDateWithCurrentYear.isAfter(currentDate.plusDays(4L))) {            ZonedDateTime inputDateWithPreviousYear = ZonedDateTime.of(currentYear - 1, inputMonth, inputDay, inputHour, inputMinute, inputSecond, 0, deviceTimeZone);            return inputDateWithPreviousYear.toInstant().toEpochMilli();        } else            return inputDateWithCurrentYear.toInstant().toEpochMilli();    } else     if (Pattern.matches("[A-Z][a-z]{2}\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}", logTimestamp))        return convertToEpochMillis(logTimestamp, DateTimeFormatter.ofPattern("MMM dd yyyy HH:mm:ss").withZone(deviceTimeZone));    else     if (Pattern.matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})", logTimestamp))        return convertToEpochMillis(logTimestamp, DateTimeFormatter.ISO_OFFSET_DATE_TIME);    else        throw new ParseException(String.format("Unsupported date format: '%s'", logTimestamp));}
private static long metron_f6515_0(String logTimestamp, DateTimeFormatter logTimeFormat)
{    ZonedDateTime timestamp = ZonedDateTime.parse(logTimestamp, logTimeFormat);    return timestamp.toInstant().toEpochMilli();}
public static String metron_f6516_0(int priority)
{    int severity = priority & 0x07;    switch(severity) {        case 0:            return "emerg";        case 1:            return "alert";        case 2:            return "crit";        case 3:            return "err";        case 4:            return "warn";        case 5:            return "notice";        case 6:            return "info";        case 7:            return "debug";        default:            return "unknown";    }}
public static String metron_f6517_0(int priority)
{    int facility = priority >> 3;    switch(facility) {        case 0:            return "kern";        case 1:            return "user";        case 2:            return "mail";        case 3:            return "daemon";        case 4:            return "auth";        case 5:            return "syslog";        case 6:            return "lpr";        case 7:            return "news";        case 8:            return "uucp";                case 10:            return "authpriv";        case 11:            return "ftp";                case 15:            return "cron";        case 16:            return "local0";        case 17:            return "local1";        case 18:            return "local2";        case 19:            return "local3";        case 20:            return "local4";        case 21:            return "local5";        case 22:            return "local6";        case 23:            return "local7";        default:            return "unknown";    }}
public void metron_f6518_0()
{    Assert.assertNull(Filters.get("DEFAULT", null));}
public void metron_f6519_0() throws Exception
{    {        Map<String, Object> config = new HashMap<String, Object>() {            {                put("filter.query", "exists(foo)");            }        };        MessageFilter<JSONObject> filter = Filters.get(Filters.STELLAR.name(), config);        Assert.assertTrue(filter.emit(new JSONObject(ImmutableMap.of("foo", 1)), Context.EMPTY_CONTEXT()));        Assert.assertFalse(filter.emit(new JSONObject(ImmutableMap.of("bar", 1)), Context.EMPTY_CONTEXT()));    }}
protected boolean metron_f6520_0(final String jsonSchema, final String jsonData) throws IOException, ProcessingException
{    final JsonNode d = JsonLoader.fromString(jsonData);    final JsonNode s = JsonLoader.fromString(jsonSchema);    final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();    JsonValidator v = factory.getValidator();    ProcessingReport report = v.validate(s, d);    return report.toString().contains("success");}
protected String metron_f6521_0(URL schema_url) throws Exception
{    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(schema_url.getFile()), StandardCharsets.UTF_8));    String line;    StringBuilder sb = new StringBuilder();    while ((line = br.readLine()) != null) {        sb.append(line);    }    br.close();    String schema_string = sb.toString().replaceAll("\n", "");    schema_string = schema_string.replaceAll(" ", "");    return schema_string;}
protected String[] metron_f6522_0(String test_data_url) throws Exception
{    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(test_data_url), StandardCharsets.UTF_8));    ArrayList<String> inputDataLines = new ArrayList<>();    String line;    while ((line = br.readLine()) != null) {        inputDataLines.add(line.replaceAll("\n", ""));    }    br.close();    String[] inputData = new String[inputDataLines.size()];    inputData = inputDataLines.toArray(inputData);    return inputData;}
public void metron_f6523_0(String schemaJsonString)
{    this.schemaJsonString = schemaJsonString;}
public String metron_f6524_0()
{    return this.schemaJsonString;}
public void metron_f6525_0()
{}
public void metron_f6526_0(Map<String, Object> config)
{    setReadCharset(config);}
public Optional<MessageParserResult<JSONObject>> metron_f6527_0(byte[] parseMessage)
{    String message = new String(parseMessage, getReadCharset());    Map<String, Object> out = new HashMap<>();    out.put(KEY1, message);    MessageParserResult<JSONObject> result = new DefaultMessageParserResult<JSONObject>(Arrays.asList(new JSONObject(out)));    return Optional.of(result);}
public void metron_f6528_0(Map<String, Object> config)
{}
public void metron_f6529_0() throws IOException, InterruptedException
{    tempFolder.create();    parserWithCharset = new SomeParserWithCharset();    parserNoCharset = new SomeParserNoCharset();    parserConfig = new HashMap<>();    fileUTF_16 = new File(tempFolder.getRoot(), "fileUTF-16");    fileUTF_8 = new File(tempFolder.getRoot(), "fileUTF-8");    writeDataEncodedAs(fileUTF_16, SAMPLE_DATA, StandardCharsets.UTF_16);    writeDataEncodedAs(fileUTF_8, SAMPLE_DATA, StandardCharsets.UTF_8);}
private void metron_f6530_0(File file, String data, Charset charset) throws IOException
{    byte[] bytes = data.getBytes(charset);    FileUtils.writeByteArrayToFile(file, bytes);}
public void metron_f6531_0() throws IOException
{                String utf16_8 = readDataEncodedAs(fileUTF_16, StandardCharsets.UTF_8);    String utf16_16 = readDataEncodedAs(fileUTF_16, StandardCharsets.UTF_16);    File utf16_16_8 = new File(tempFolder.getRoot(), "outUTF-8");    writeDataEncodedAs(utf16_16_8, utf16_16, StandardCharsets.UTF_8);    String utf8_8 = readDataEncodedAs(utf16_16_8, StandardCharsets.UTF_8);    assertThat(utf8_8, equalTo(utf16_16));    assertThat(utf8_8, not(equalTo(utf16_8)));    assertThat(utf8_8, equalTo(utf16_16));    assertThat(utf8_8, not(equalTo(utf16_8)));}
private String metron_f6532_0(File file, Charset charset) throws IOException
{    return FileUtils.readFileToString(file, charset);}
public void metron_f6533_0()
{    parserConfig.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parserWithCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserWithCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_16));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), equalTo(SAMPLE_DATA));}
public void metron_f6534_0()
{    parserConfig.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_8.toString());    parserWithCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserWithCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_16));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), not(equalTo(SAMPLE_DATA)));}
public void metron_f6535_0()
{    parserWithCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserWithCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_8));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), equalTo(SAMPLE_DATA));}
public void metron_f6536_0()
{    parserNoCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserNoCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_8));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), equalTo(SAMPLE_DATA));}
public void metron_f6537_0() throws IOException
{    CSVParser parser = new CSVParser();    SensorParserConfig config = JSONUtils.INSTANCE.load(parserConfig, SensorParserConfig.class);    parser.init();    parser.configure(config.getParserConfig());    {        String line = "#foo,bar,grok";        Assert.assertEquals(0, parser.parse(Bytes.toBytes(line)).size());    }    {        String line = "";        Assert.assertEquals(0, parser.parse(Bytes.toBytes(line)).size());    }    {        String line = "foo,bar,grok";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));    }    {        String line = "\"foo\", \"bar\",\"grok\"";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));    }    {        String line = "foo, bar, grok";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));    }    {        String line = " foo , bar , grok ";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));        Assert.assertEquals(null, o.get(" col2"));        Assert.assertEquals(null, o.get("col3 "));    }    {        UnitTestHelper.setLog4jLevel(CSVParser.class, Level.FATAL);        String line = "foo";        try {            List<JSONObject> results = parser.parse(Bytes.toBytes(line));            Assert.fail("Expected exception");        } catch (IllegalStateException iae) {        }        UnitTestHelper.setLog4jLevel(CSVParser.class, Level.ERROR);    }}
public void metron_f6538_0() throws IOException
{    SensorParserConfig config = JSONUtils.INSTANCE.load(parserConfig, SensorParserConfig.class);    CSVParser parser = new CSVParser();    parser.init();    config.getParserConfig().put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config.getParserConfig());    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6539_0() throws IOException
{    SensorParserConfig config = JSONUtils.INSTANCE.load(parserConfig, SensorParserConfig.class);    CSVParser parser = new CSVParser();    parser.init();    parser.configure(config.getParserConfig());    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6540_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        JSONObject expected = (JSONObject) jsonParser.parse(e.getValue());        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertNotNull(resultOptional);        Assert.assertTrue(resultOptional.isPresent());        List<JSONObject> parsedList = resultOptional.get().getMessages();        Assert.assertEquals(1, parsedList.size());        compare(expected, parsedList.get(0));    }}
public boolean metron_f6541_0(JSONObject expected, JSONObject actual)
{    MapDifference mapDifferences = Maps.difference(expected, actual);    if (mapDifferences.entriesOnlyOnLeft().size() > 0)        Assert.fail("Expected JSON has extra parameters: " + mapDifferences.entriesOnlyOnLeft());    if (mapDifferences.entriesOnlyOnRight().size() > 0)        Assert.fail("Actual JSON has extra parameters: " + mapDifferences.entriesOnlyOnRight());    Map actualDifferences = new HashMap();    if (mapDifferences.entriesDiffering().size() > 0) {        Map differences = Collections.unmodifiableMap(mapDifferences.entriesDiffering());        for (Object key : differences.keySet()) {            Object expectedValueObject = expected.get(key);            Object actualValueObject = actual.get(key);            if (expectedValueObject instanceof Long || expectedValueObject instanceof Integer) {                Long expectedValue = Long.parseLong(expectedValueObject.toString());                Long actualValue = Long.parseLong(actualValueObject.toString());                if (!expectedValue.equals(actualValue)) {                    actualDifferences.put(key, differences.get(key));                }            } else {                actualDifferences.put(key, differences.get(key));            }        }    }    if (actualDifferences.size() > 0)        Assert.fail("Expected and Actual JSON values don't match: " + actualDifferences);    return true;}
public void metron_f6542_0(ParserDriver driver) throws IOException
{    Map<String, Object> inputRecord = new HashMap<String, Object>() {        {            put(Constants.Fields.ORIGINAL.getName(), "real_original_string");            put("data", "field1_val,100");            put("metadata_field", "metadata_val");        }    };    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(JSONUtils.INSTANCE.toJSONPretty(inputRecord)));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> outputRecord = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("field1_val", outputRecord.get("field1"));    Assert.assertEquals(inputRecord.get(Constants.Fields.ORIGINAL.getName()), outputRecord.get(Constants.Fields.ORIGINAL.getName()));    Assert.assertEquals(inputRecord.get(MetadataUtil.METADATA_PREFIX + ".metadata_field"), outputRecord.get("metadata_field"));}
public void metron_f6543_0(ParserDriver driver) throws IOException
{    Map<String, Object> inputRecord = new HashMap<String, Object>() {        {            put(Constants.Fields.ORIGINAL.getName(), "real_original_string");            put("data", "field1_val,100");            put("metadata_field", "metadata_val");        }    };    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(JSONUtils.INSTANCE.toJSONPretty(inputRecord)));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> outputRecord = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("field1_val", outputRecord.get("field1"));    Assert.assertEquals(inputRecord.get(Constants.Fields.ORIGINAL.getName()), outputRecord.get(Constants.Fields.ORIGINAL.getName()));    Assert.assertEquals(inputRecord.get("metadata_field"), outputRecord.get("metadata_field"));}
public void metron_f6544_0(ParserDriver driver) throws IOException
{    Map<String, Object> inputRecord = new HashMap<String, Object>() {        {            put(Constants.Fields.ORIGINAL.getName(), "real_original_string");            put("data", "field1_val,100");            put("metadata_field", "metadata_val");        }    };    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(JSONUtils.INSTANCE.toJSONPretty(inputRecord)));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> outputRecord = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("field1_val", outputRecord.get("field1"));    Assert.assertEquals(inputRecord.get(Constants.Fields.ORIGINAL.getName()), outputRecord.get(Constants.Fields.ORIGINAL.getName()));    Assert.assertFalse(outputRecord.containsKey(MetadataUtil.METADATA_PREFIX + ".metadata_field"));}
public void metron_f6545_0(ParserDriver syslogDriver, ParserDriver driver) throws Exception
{    byte[] envelopedData = null;    String inputRecord = "Mar 29 2004 09:54:18: %PIX-6-302005: Built UDP connection for faddr 198.207.223.240/53337 gaddr 10.0.0.187/53 laddr 192.168.0.2/53";    ProcessorResult<List<byte[]>> syslogResult = syslogDriver.run(ImmutableList.of(inputRecord.getBytes(StandardCharsets.UTF_8)));    Assert.assertFalse(syslogResult.failed());    List<byte[]> syslogResultList = syslogResult.getResult();    envelopedData = syslogResultList.get(0);    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(envelopedData));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> result = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("UDP", result.get("protocol"));    Assert.assertTrue((long) result.get("timestamp") > 1000);}
protected String metron_f6546_0() throws IOException
{    File configsRoot = new File("../" + TestConstants.SAMPLE_CONFIG_PATH);    return new String(Files.readAllBytes(new File(configsRoot, "global.json").toPath()), StandardCharsets.UTF_8);}
protected String metron_f6547_0(String sensorType) throws IOException
{        File configsRoot = new File("../" + TestConstants.PARSER_COMMON_CONFIGS_PATH);    File parsersRoot = new File(configsRoot, "parsers");    System.out.println("Workspace: " + System.getProperty("user.dir"));    System.out.println("Parsers root: " + parsersRoot);    if (!Files.exists(new File(parsersRoot, sensorType + ".json").toPath())) {                configsRoot = new File("../" + TestConstants.PARSER_CONFIGS_PATH);        parsersRoot = new File(configsRoot, "parsers");    }    return new String(Files.readAllBytes(new File(parsersRoot, sensorType + ".json").toPath()), StandardCharsets.UTF_8);}
public void metron_f6548_0(ParserDriver driver) throws Exception
{    String sensorType = driver.getSensorType();    inputMessages = TestUtils.readSampleData(SampleDataUtils.getSampleDataPath("..", sensorType, TestDataType.RAW));    ProcessorResult<List<byte[]>> result = driver.run(inputMessages);    List<byte[]> outputMessages = result.getResult();    StringBuffer buffer = new StringBuffer();    if (result.failed()) {        result.getBadResults(buffer);        buffer.append(String.format("%d Valid Messages Processed", outputMessages.size())).append("\n");        dumpParsedMessages(outputMessages, buffer);        Assert.fail(buffer.toString());    } else {        List<ParserValidation> validations = getValidations();        if (validations == null || validations.isEmpty()) {            buffer.append("No validations configured for sensorType ").append(sensorType).append(".  Dumping parsed messages").append("\n");            dumpParsedMessages(outputMessages, buffer);            Assert.fail(buffer.toString());        } else {            for (ParserValidation validation : validations) {                System.out.println("Running " + validation.getName() + " on sensorType " + sensorType);                validation.validate(sensorType, outputMessages);            }        }    }}
public void metron_f6549_0(List<byte[]> outputMessages, StringBuffer buffer)
{    for (byte[] outputMessage : outputMessages) {        buffer.append(new String(outputMessage, StandardCharsets.UTF_8)).append("\n");    }}
public String metron_f6550_0()
{    return sensorType;}
public String metron_f6551_0()
{    return "Sample Data Validation";}
public void metron_f6552_0(String sensorType, List<byte[]> actualMessages) throws Exception
{    List<byte[]> expectedMessages = TestUtils.readSampleData(SampleDataUtils.getSampleDataPath("..", sensorType, TestDataType.PARSED));    Assert.assertEquals(expectedMessages.size(), actualMessages.size());    for (int i = 0; i < actualMessages.size(); i++) {        String expectedMessage = new String(expectedMessages.get(i), StandardCharsets.UTF_8);        String actualMessage = new String(actualMessages.get(i), StandardCharsets.UTF_8);        try {            ValidationUtils.assertJsonEqual(expectedMessage, actualMessage);        } catch (Throwable t) {            System.out.println("expected: " + expectedMessage);            System.out.println("actual: " + actualMessage);            throw t;        }    }}
public void metron_f6553_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(2, output.size());    JSONObject message = output.get(0);        Assert.assertEquals(4, message.size());    Assert.assertEquals("foo1", message.get("name"));    Assert.assertEquals("bar", message.get("value"));    Assert.assertEquals(1.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should be handled external to the parser by default", message.containsKey(Fields.ORIGINAL.getName()), equalTo(false));    message = output.get(1);        Assert.assertEquals(4, message.size());    Assert.assertEquals("foo2", message.get("name"));    Assert.assertEquals("baz", message.get("value"));    Assert.assertEquals(2.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should be handled external to the parser by default", message.containsKey(Fields.ORIGINAL.getName()), equalTo(false));}
public void metron_f6554_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");            put(JSONMapParser.OVERRIDE_ORIGINAL_STRING, true);        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(2, output.size());    JSONObject message = output.get(0);        Assert.assertEquals(5, message.size());    Assert.assertEquals("foo1", message.get("name"));    Assert.assertEquals("bar", message.get("value"));    Assert.assertEquals(1.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should have been handled by the parser", message.get(Fields.ORIGINAL.getName()), equalTo("{\"name\":\"foo1\",\"number\":1.0,\"value\":\"bar\"}"));    message = output.get(1);        Assert.assertEquals(5, message.size());    Assert.assertEquals("foo2", message.get("name"));    Assert.assertEquals("baz", message.get("value"));    Assert.assertEquals(2.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should have been handled by the parser", message.get(Fields.ORIGINAL.getName()), equalTo("{\"name\":\"foo2\",\"number\":2.0,\"value\":\"baz\"}"));}
public void metron_f6555_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$$..$$SDSE$#$#.");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));}
public void metron_f6556_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_SINGLE.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(0, output.size());}
public void metron_f6557_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);        Assert.assertEquals(output.get(0).size(), 1);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6558_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ERROR.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.FATAL);    parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.ERROR);}
public void metron_f6559_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ALLOW.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 2);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 2);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6560_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 5);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.blah"), 7);    Assert.assertEquals(message.get("collection.blah2"), "foo");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "grey");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 5);    message = output.get(1);    Assert.assertEquals(message.get("collection.blah"), 8);    Assert.assertEquals(message.get("collection.blah2"), "bar");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz2");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "blue");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6561_0()
{    parser = new JSONMapParser();}
public void metron_f6562_0()
{    List<JSONObject> output = parser.parse(happyPathJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 4);    JSONObject message = output.get(0);    Assert.assertEquals("bar", message.get("foo"));    Assert.assertEquals("blah", message.get("blah"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);}
public void metron_f6563_0()
{    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 1);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6564_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ERROR.name()));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.FATAL);    parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.ERROR);}
public void metron_f6565_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ALLOW.name()));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 2);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6566_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name()));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 5);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.blah"), 7);    Assert.assertEquals(message.get("collection.blah2"), "foo");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "grey");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6567_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name()));    List<JSONObject> output = parser.parse(mixCollectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.get(0).size(), 3);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.key"), "value");    Assert.assertEquals(message.get("key"), "value");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6568_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6569_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6570_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.WRAP_JSON, true);            put(JSONMapParser.WRAP_ENTITY_NAME, "foo");            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);        Assert.assertEquals(output.get(0).size(), 4);    JSONObject message = output.get(0);    Assert.assertEquals("foo1", message.get("name"));    Assert.assertEquals("bar", message.get("value"));    Assert.assertEquals(1.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    message = output.get(1);    Assert.assertEquals("foo2", message.get("name"));    Assert.assertEquals("baz", message.get("value"));    Assert.assertEquals(2.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);}
public void metron_f6571_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$$..$$SDSE$#$#.");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));}
public void metron_f6572_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_SINGLE.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(0, output.size());}
public void metron_f6573_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);        Assert.assertEquals(output.get(0).size(), 1);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6574_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ERROR.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.FATAL);    parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.ERROR);}
public void metron_f6575_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ALLOW.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 2);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 2);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6576_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 5);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.blah"), 7);    Assert.assertEquals(message.get("collection.blah2"), "foo");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "grey");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 5);    message = output.get(1);    Assert.assertEquals(message.get("collection.blah"), 8);    Assert.assertEquals(message.get("collection.blah2"), "bar");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz2");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "blue");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6577_0()
{}
public boolean metron_f6578_0(JSONObject message)
{    return false;}
public void metron_f6579_0(Map<String, Object> config)
{}
public void metron_f6580_0() throws Exception
{    MessageParser parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            return null;        }    };    Assert.assertNotNull(parser.parseOptionalResult(null));    Assert.assertFalse(parser.parseOptionalResult(null).isPresent());}
public List<JSONObject> metron_f6581_0(byte[] rawMessage)
{    return null;}
public void metron_f6582_0() throws Exception
{    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            return new ArrayList<>();        }    };    Assert.assertNotNull(parser.parseOptionalResult(null));    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult(null);    Assert.assertTrue(ret.isPresent());    Assert.assertEquals(0, ret.get().getMessages().size());}
public List<JSONObject> metron_f6583_0(byte[] rawMessage)
{    return new ArrayList<>();}
public void metron_f6584_0()
{    JSONObject message = new JSONObject();    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            return Collections.singletonList(message);        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertEquals(1, ret.get().getMessages().size());    Assert.assertEquals(message, ret.get().getMessages().get(0));}
public List<JSONObject> metron_f6585_0(byte[] rawMessage)
{    return Collections.singletonList(message);}
public void metron_f6586_0()
{    JSONObject message = new JSONObject();    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public Optional<List<JSONObject>> parseOptional(byte[] rawMessage) {            return Optional.of(Collections.singletonList(message));        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertEquals(1, ret.get().getMessages().size());    Assert.assertEquals(message, ret.get().getMessages().get(0));}
public Optional<List<JSONObject>> metron_f6587_0(byte[] rawMessage)
{    return Optional.of(Collections.singletonList(message));}
public void metron_f6588_0()
{    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            throw new RuntimeException("parse exception");        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertTrue(ret.get().getMasterThrowable().isPresent());    Assert.assertEquals("parse exception", ret.get().getMasterThrowable().get().getMessage());}
public List<JSONObject> metron_f6589_0(byte[] rawMessage)
{    throw new RuntimeException("parse exception");}
public void metron_f6590_0()
{    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public Optional<List<JSONObject>> parseOptional(byte[] rawMessage) {            throw new RuntimeException("parse exception");        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertTrue(ret.get().getMasterThrowable().isPresent());    Assert.assertEquals("parse exception", ret.get().getMasterThrowable().get().getMessage());}
public Optional<List<JSONObject>> metron_f6591_0(byte[] rawMessage)
{    throw new RuntimeException("parse exception");}
public void metron_f6592_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertNotNull(resultOptional);        Assert.assertTrue(resultOptional.isPresent());        List<JSONObject> parsedList = resultOptional.get().getMessages();        Assert.assertEquals(10, parsedList.size());    }}
public void metron_f6593_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertTrue(resultOptional.isPresent());        Optional<Throwable> throwableOptional = resultOptional.get().getMasterThrowable();        List<JSONObject> resultList = resultOptional.get().getMessages();        Map<Object, Throwable> errorMap = resultOptional.get().getMessageThrowables();        Assert.assertFalse(throwableOptional.isPresent());        Assert.assertEquals(0, errorMap.size());        Assert.assertEquals(10, resultList.size());    }}
public Map metron_f6594_0()
{    Map testData = new HashMap<String, String>();    String input;    try (FileInputStream stream = new FileInputStream(new File("src/test/resources/logData/multi_elb_log.txt"))) {        input = IOUtils.toString(stream);    } catch (IOException ioe) {        throw new IllegalStateException("failed to open file", ioe);    }        testData.put(input, "");    return testData;}
public String metron_f6595_0()
{    return "true";}
public String metron_f6596_0()
{    return "../../metron-integration-test/src/main/sample/patterns/test";}
public String metron_f6597_0()
{    return "ELBACCESSLOGS";}
public List<String> metron_f6598_0()
{    return new ArrayList<String>() {        {            add("timestamp");        }    };}
public String metron_f6599_0()
{    return "yyyy-MM-dd'T'HH:mm:ss.S'Z'";}
public String metron_f6600_0()
{    return "timestamp";}
public void metron_f6601_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        List<JSONObject> parsedList = grokParser.parse(rawMessage);    }}
public void metron_f6602_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertTrue(resultOptional.isPresent());        Optional<Throwable> throwableOptional = resultOptional.get().getMasterThrowable();        List<JSONObject> resultList = resultOptional.get().getMessages();        Map<Object, Throwable> errorMap = resultOptional.get().getMessageThrowables();        Assert.assertFalse(throwableOptional.isPresent());        Assert.assertEquals(3, errorMap.size());        Assert.assertEquals(10, resultList.size());    }}
public Map metron_f6603_0()
{    Map testData = new HashMap<String, String>();    String input;    try (FileInputStream stream = new FileInputStream(new File("src/test/resources/logData/multi_elb_with_errors_log.txt"))) {        input = IOUtils.toString(stream);    } catch (IOException ioe) {        throw new IllegalStateException("failed to open file", ioe);    }        testData.put(input, "");    return testData;}
public String metron_f6604_0()
{    return "../../metron-integration-test/src/main/sample/patterns/test";}
public String metron_f6605_0()
{    return "ELBACCESSLOGS";}
public List<String> metron_f6606_0()
{    return new ArrayList<String>() {        {            add("timestamp");        }    };}
public String metron_f6607_0()
{    return "true";}
public String metron_f6608_0()
{    return "yyyy-MM-dd'T'HH:mm:ss.S'Z'";}
public String metron_f6609_0()
{    return "timestamp";}
public void metron_f6610_0() throws IOException
{    parserConfigurations = new ParserConfigurations();    SensorParserConfig broConfig = SensorParserConfig.fromBytes(broConfigString.getBytes(StandardCharsets.UTF_8));    SensorParserConfig snortConfig = SensorParserConfig.fromBytes(snortConfigString.getBytes(StandardCharsets.UTF_8));    parserConfigurations.updateSensorParserConfig("bro", broConfig);    parserConfigurations.updateSensorParserConfig("snort", snortConfig);    parserConfigurations.updateGlobalConfig(JSONUtils.INSTANCE.load(globalConfigString, JSONUtils.MAP_SUPPLIER));    parserRunner = new ParserRunnerImpl(new HashSet<>(Arrays.asList("bro", "snort")));    broParser = mock(MessageParser.class);    snortParser = mock(MessageParser.class);    stellarFilter = mock(StellarFilter.class);    mockStatic(ReflectionUtils.class);    mockStatic(Filters.class);    when(broParser.getReadCharset()).thenReturn(StandardCharsets.UTF_8);    when(ReflectionUtils.createInstance("org.apache.metron.parsers.bro.BasicBroParser")).thenReturn(broParser);    when(ReflectionUtils.createInstance("org.apache.metron.parsers.snort.BasicSnortParser")).thenReturn(snortParser);    when(Filters.get("org.apache.metron.parsers.filters.StellarFilter", broConfig.getParserConfig())).thenReturn(stellarFilter);}
public void metron_f6611_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("A parser config supplier must be set before initializing the ParserRunner.");    parserRunner.init(null, null);}
public void metron_f6612_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("A stellar context must be set before initializing the ParserRunner.");    parserRunner.init(() -> parserConfigurations, null);}
public void metron_f6613_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("Could not initialize parsers.  Cannot find configuration for sensor test.");    parserRunner = new ParserRunnerImpl(new HashSet<String>() {        {            add("test");        }    });    parserRunner.init(() -> parserConfigurations, mock(Context.class));}
public void metron_f6614_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("Could not execute parser.  Cannot find configuration for sensor test.");    parserRunner = new ParserRunnerImpl(new HashSet<String>() {        {            add("test");        }    });    parserRunner.execute("test", mock(RawMessage.class), parserConfigurations);}
public void metron_f6615_0() throws Exception
{    Context stellarContext = mock(Context.class);    Map<String, Object> broParserConfig = parserConfigurations.getSensorParserConfig("bro").getParserConfig();    Map<String, Object> snortParserConfig = parserConfigurations.getSensorParserConfig("snort").getParserConfig();    parserRunner.init(() -> parserConfigurations, stellarContext);    {                Assert.assertEquals(stellarContext, parserRunner.getStellarContext());    }    Map<String, ParserComponent> sensorToParserComponentMap = parserRunner.getSensorToParserComponentMap();    {                Assert.assertEquals(2, sensorToParserComponentMap.size());        ParserComponent broComponent = sensorToParserComponentMap.get("bro");        Assert.assertEquals(broParser, broComponent.getMessageParser());        Assert.assertEquals(stellarFilter, broComponent.getFilter());        verify(broParser, times(1)).init();        verify(broParser, times(1)).configure(broParserConfig);        verifyNoMoreInteractions(broParser);        verifyNoMoreInteractions(stellarFilter);    }    {                ParserComponent snortComponent = sensorToParserComponentMap.get("snort");        Assert.assertEquals(snortParser, snortComponent.getMessageParser());        Assert.assertNull(snortComponent.getFilter());        verify(snortParser, times(1)).init();        verify(snortParser, times(1)).configure(snortParserConfig);        verifyNoMoreInteractions(snortParser);    }}
public void metron_f6616_0()
{    parserRunner = spy(parserRunner);    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), new HashMap<>());    JSONObject parsedMessage1 = new JSONObject();    parsedMessage1.put("field", "parsedMessage1");    JSONObject parsedMessage2 = new JSONObject();    parsedMessage2.put("field", "parsedMessage2");    Object rawMessage1 = new RawMessage("raw_message1".getBytes(StandardCharsets.UTF_8), new HashMap<>());    Object rawMessage2 = new RawMessage("raw_message2".getBytes(StandardCharsets.UTF_8), new HashMap<>());    Throwable throwable1 = mock(Throwable.class);    Throwable throwable2 = mock(Throwable.class);    MessageParserResult<JSONObject> messageParserResult = new DefaultMessageParserResult<>(Arrays.asList(parsedMessage1, parsedMessage2), new HashMap<Object, Throwable>() {        {            put(rawMessage1, throwable1);            put(rawMessage2, throwable2);        }    });    JSONObject processedMessage = new JSONObject();    processedMessage.put("field", "processedMessage1");    MetronError processedError = new MetronError().withMessage("processedError");    ProcessResult processedMessageResult = mock(ProcessResult.class);    ProcessResult processedErrorResult = mock(ProcessResult.class);    when(broParser.parseOptionalResult(rawMessage.getMessage())).thenReturn(Optional.of(messageParserResult));    when(processedMessageResult.getMessage()).thenReturn(processedMessage);    when(processedErrorResult.isError()).thenReturn(true);    when(processedErrorResult.getError()).thenReturn(processedError);    doReturn(Optional.of(processedMessageResult)).when(parserRunner).processMessage("bro", parsedMessage1, rawMessage, broParser, parserConfigurations);    doReturn(Optional.of(processedErrorResult)).when(parserRunner).processMessage("bro", parsedMessage2, rawMessage, broParser, parserConfigurations);    MetronError expectedParseError1 = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(throwable1).withSensorType(Collections.singleton("bro")).addRawMessage(rawMessage1);    MetronError expectedParseError2 = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(throwable2).withSensorType(Collections.singleton("bro")).addRawMessage(rawMessage2);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    ParserRunnerResults<JSONObject> parserRunnerResults = parserRunner.execute("bro", rawMessage, parserConfigurations);    Assert.assertEquals(1, parserRunnerResults.getMessages().size());    Assert.assertTrue(parserRunnerResults.getMessages().contains(processedMessage));    Assert.assertEquals(3, parserRunnerResults.getErrors().size());    Assert.assertTrue(parserRunnerResults.getErrors().contains(processedError));    Assert.assertTrue(parserRunnerResults.getErrors().contains(expectedParseError1));    Assert.assertTrue(parserRunnerResults.getErrors().contains(expectedParseError2));}
public void metron_f6617_0()
{    parserRunner = spy(parserRunner);    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), new HashMap<>());    Throwable masterThrowable = mock(Throwable.class);    MessageParserResult<JSONObject> messageParserResult = new DefaultMessageParserResult<>(masterThrowable);    when(broParser.parseOptionalResult(rawMessage.getMessage())).thenReturn(Optional.of(messageParserResult));    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    ParserRunnerResults<JSONObject> parserRunnerResults = parserRunner.execute("bro", rawMessage, parserConfigurations);    verify(parserRunner, times(0)).processMessage(any(), any(), any(), any(), any());    MetronError expectedError = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(masterThrowable).withSensorType(Collections.singleton("bro")).addRawMessage(rawMessage.getMessage());    Assert.assertEquals(1, parserRunnerResults.getErrors().size());    Assert.assertTrue(parserRunnerResults.getErrors().contains(expectedError));}
public void metron_f6618_0()
{    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    inputMessage.put("ip_src_addr", "192.168.1.1");    inputMessage.put("ip_dst_addr", "192.168.1.2");    RawMessage rawMessage = new RawMessage("raw_message_for_testing".getBytes(StandardCharsets.UTF_8), new HashMap<>());    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("source.type", "bro");    expectedOutput.put("ip_src_addr", "192.168.1.1");    expectedOutput.put("ip_dst_addr", "192.168.1.2");    expectedOutput.put(Fields.ORIGINAL.getName(), "raw_message_for_testing");    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);    when(broParser.validate(expectedOutput)).thenReturn(true);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertFalse(processResult.get().isError());    Assert.assertEquals(expectedOutput, processResult.get().getMessage());}
public void metron_f6619_0()
{    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    inputMessage.put("ip_src_addr", "192.168.1.1");    inputMessage.put("ip_dst_addr", "192.168.1.2");    inputMessage.put(Fields.ORIGINAL.getName(), "original_string_added_by_parser");    RawMessage rawMessage = new RawMessage("raw_message_for_testing".getBytes(StandardCharsets.UTF_8), new HashMap<>());    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("source.type", "bro");    expectedOutput.put("ip_src_addr", "192.168.1.1");    expectedOutput.put("ip_dst_addr", "192.168.1.2");    expectedOutput.put(Fields.ORIGINAL.getName(), "original_string_added_by_parser");    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);    when(broParser.validate(expectedOutput)).thenReturn(true);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertFalse(processResult.get().isError());    Assert.assertEquals(expectedOutput, processResult.get().getMessage());}
public void metron_f6620_0()
{    Map<String, Object> metadata = new HashMap<>();    metadata.put("metron.metadata.topic", "bro");    metadata.put("metron.metadata.partition", 0);    metadata.put("metron.metadata.offset", 123);    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), metadata);    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("source.type", "bro");    expectedOutput.put(Fields.ORIGINAL.getName(), "raw_message");    MetronError expectedMetronError = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton("bro")).withMetadata(metadata).addRawMessage(inputMessage);    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);        when(broParser.validate(expectedOutput)).thenReturn(false);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertTrue(processResult.get().isError());    Assert.assertEquals(expectedMetronError, processResult.get().getError());}
public void metron_f6621_0()
{    Map<String, Object> metadata = new HashMap<>();    metadata.put("metron.metadata.topic", "bro");    metadata.put("metron.metadata.partition", 0);    metadata.put("metron.metadata.offset", 123);    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    inputMessage.put("ip_src_addr", "test");    inputMessage.put("ip_dst_addr", "test");    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), metadata);    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("ip_src_addr", "test");    expectedOutput.put("ip_dst_addr", "test");    expectedOutput.put("source.type", "bro");    expectedOutput.put(Fields.ORIGINAL.getName(), "raw_message");    MetronError expectedMetronError = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton("bro")).addRawMessage(inputMessage).withMetadata(metadata).withErrorFields(new HashSet<>(Arrays.asList("ip_src_addr", "ip_dst_addr")));    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);    when(broParser.validate(expectedOutput)).thenReturn(true);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertTrue(processResult.get().isError());    Assert.assertEquals(expectedMetronError, processResult.get().getError());}
public void metron_f6622_0() throws Exception
{    regularExpressionsParser = new RegularExpressionsParser();}
public void metron_f6623_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(parserConfig1);    regularExpressionsParser.configure(parserConfig);    JSONObject parsed = parse(message);        Map<String, Object> expectedJson = new HashMap<>();    Assert.assertEquals(parsed.get("device_name"), "deviceName");    Assert.assertEquals(parsed.get("dst_process_name"), "sshd");    Assert.assertEquals(parsed.get("dst_process_id"), "11672");    Assert.assertEquals(parsed.get("dst_user_id"), "prod");    Assert.assertEquals(parsed.get("ip_src_addr"), "22.22.22.22");    Assert.assertEquals(parsed.get("ip_src_port"), "55555");    Assert.assertEquals(parsed.get("app_protocol"), "ssh2");    Assert.assertEquals(parsed.get("original_string"), "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2");    Assert.assertTrue(parsed.containsKey("timestamp"));}
public void metron_f6624_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(parserConfigNoMessageHeader);    regularExpressionsParser.configure(parserConfig);    JSONObject parsed = parse(message);        Assert.assertEquals(parsed.get("dst_process_name"), "sshd");    Assert.assertEquals(parsed.get("dst_process_id"), "11672");    Assert.assertEquals(parsed.get("dst_user_id"), "prod");    Assert.assertEquals(parsed.get("ip_src_addr"), "22.22.22.22");    Assert.assertEquals(parsed.get("ip_src_port"), "55555");    Assert.assertEquals(parsed.get("app_protocol"), "ssh2");    Assert.assertEquals(parsed.get("original_string"), "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2");    Assert.assertTrue(parsed.containsKey("timestamp"));}
public void metron_f6625_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(invalidParserConfig);    regularExpressionsParser.configure(parserConfig);    parse(message);}
public void metron_f6626_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(noRecordTypeParserConfig);    regularExpressionsParser.configure(parserConfig);    parse(message);}
private JSONObject metron_f6627_0(String message) throws Exception
{    List<JSONObject> result = regularExpressionsParser.parse(message.getBytes(StandardCharsets.UTF_8));    if (result.size() > 0) {        return result.get(0);    }    throw new Exception("Could not parse : " + message);}
public void metron_f6628_0() throws ParseException
{    JSONObject config = (JSONObject) new JSONParser().parse(parserConfig1);    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    regularExpressionsParser.configure(config);    assertThat(regularExpressionsParser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6629_0() throws ParseException
{    JSONObject config = (JSONObject) new JSONParser().parse(parserConfig1);    regularExpressionsParser.configure(config);    assertThat(regularExpressionsParser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public Map metron_f6630_0()
{    Map testData = new HashMap<String, String>();    String input = "1453994987000|2016-01-28 15:29:48|   0.000|   0.000|  6|                          216.21.170.221|   80|                               10.0.2.15|39468|      AS|       0|       0|       0|22efa001|00000000|000|000|       1|      44|       0|       0|    0|idle";    testData.put(input, result);    return testData;}
public String metron_f6631_0()
{    return "false";}
public String metron_f6632_0()
{    return "../../metron-integration-test/src/main/sample/patterns/test";}
public String metron_f6633_0()
{    return "YAF_DELIMITED";}
public List<String> metron_f6634_0()
{    return new ArrayList<String>() {        {            add("end_time");        }    };}
public String metron_f6635_0()
{    return "yyyy-MM-dd HH:mm:ss";}
public String metron_f6636_0()
{    return "start_time";}
public void metron_f6637_0()
{    Map<String, Object> parserConfig = new HashMap<>();    Syslog3164Parser testParser = new Syslog3164Parser();    testParser.configure(parserConfig);    testParser.init();    assertTrue(testParser.deviceClock.getZone().equals(ZoneOffset.UTC));}
public void metron_f6638_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "UTC-05:00");    Syslog3164Parser testParser = new Syslog3164Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6639_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "America/New_York");    Syslog3164Parser testParser = new Syslog3164Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6640_0()
{    test(expectedMessage1, (message) -> Assert.assertEquals(expectedHostNameOne, message.get(SyslogFieldKeys.HEADER_HOSTNAME.getField())));}
public void metron_f6641_0()
{    test("not valid", (message) -> Assert.assertTrue(false));}
public void metron_f6642_0(String line, Consumer<JSONObject> msgIdChecker)
{    Syslog3164Parser parser = new Syslog3164Parser();    Map<String, Object> config = new HashMap<>();    parser.configure(config);    parser.parseOptionalResult(line.getBytes(StandardCharsets.UTF_8));}
public void metron_f6643_0() throws Exception
{    Syslog3164Parser parser = new Syslog3164Parser();    Map<String, Object> config = new HashMap<>();    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append(SYSLOG_LINE_ALL);    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> parsedList = resultOptional.get().getMessages();    Assert.assertEquals(3, parsedList.size());}
public void metron_f6644_0() throws Exception
{    Syslog3164Parser parser = new Syslog3164Parser();    Map<String, Object> config = new HashMap<>();    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append("HEREWEGO!!!!\n").append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append("BOOM!\n").append(SYSLOG_LINE_ALL).append("\nOHMY!");    Optional<MessageParserResult<JSONObject>> output = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(output.isPresent());    Assert.assertEquals(3, output.get().getMessages().size());    Assert.assertEquals(3, output.get().getMessageThrowables().size());}
public void metron_f6645_0()
{    Map<String, Object> parserConfig = new HashMap<>();    Syslog5424Parser testParser = new Syslog5424Parser();    testParser.configure(parserConfig);    testParser.init();    assertTrue(testParser.deviceClock.getZone().equals(ZoneOffset.UTC));}
public void metron_f6646_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "UTC-05:00");    Syslog5424Parser testParser = new Syslog5424Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6647_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "America/New_York");    Syslog5424Parser testParser = new Syslog5424Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6648_0()
{    test(null, SYSLOG_LINE_ALL, (message) -> Assert.assertEquals(expectedMessageId, message.get(SyslogFieldKeys.HEADER_MSGID.getField())));}
public void metron_f6649_0()
{    test(NilPolicy.OMIT, SYSLOG_LINE_MISSING, (message) -> Assert.assertFalse(message.containsKey(SyslogFieldKeys.HEADER_MSGID)));}
public void metron_f6650_0()
{    test(NilPolicy.DASH, SYSLOG_LINE_MISSING, (message) -> Assert.assertEquals("-", message.get(SyslogFieldKeys.HEADER_MSGID.getField())));}
public void metron_f6651_0()
{    test(NilPolicy.NULL, SYSLOG_LINE_MISSING, (message) -> {        Assert.assertTrue(message.containsKey(SyslogFieldKeys.HEADER_MSGID.getField()));        Assert.assertNull(message.get(SyslogFieldKeys.HEADER_MSGID.getField()));    });}
public void metron_f6652_0()
{    test(null, "not valid", (message) -> Assert.assertTrue(false));}
public void metron_f6653_0(NilPolicy nilPolicy, String line, Consumer<JSONObject> msgIdChecker)
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    if (nilPolicy != null) {        config.put(Syslog5424Parser.NIL_POLICY_CONFIG, nilPolicy.name());    }    parser.configure(config);    parser.parseOptionalResult(line.getBytes(StandardCharsets.UTF_8));}
public void metron_f6654_0() throws Exception
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.DASH.name());    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append(SYSLOG_LINE_ALL);    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> parsedList = resultOptional.get().getMessages();    Assert.assertEquals(3, parsedList.size());}
public void metron_f6655_0() throws Exception
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.DASH.name());    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append("HEREWEGO!!!!\n").append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append("BOOM!\n").append(SYSLOG_LINE_ALL).append("\nOHMY!");    Optional<MessageParserResult<JSONObject>> output = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(output.isPresent());    Assert.assertEquals(3, output.get().getMessages().size());    Assert.assertEquals(3, output.get().getMessageThrowables().size());}
public void metron_f6656_0()
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    String timeStampString = null;    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.DASH.name());    parser.configure(config);    Optional<MessageParserResult<JSONObject>> output = parser.parseOptionalResult(SYSLOG_LINE_MISSING_DATE.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(output);    Assert.assertTrue(output.isPresent());    Assert.assertNotNull(output.get().getMessages().get(0).get("timestamp").toString());    config.clear();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.NULL.name());    parser.configure(config);    output = parser.parseOptionalResult(SYSLOG_LINE_MISSING_DATE.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(output);    Assert.assertTrue(output.isPresent());    timeStampString = output.get().getMessages().get(0).get("timestamp").toString();    Assert.assertNotNull(timeStampString);    config.clear();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.OMIT.name());    parser.configure(config);    output = parser.parseOptionalResult(SYSLOG_LINE_MISSING_DATE.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(output);    Assert.assertTrue(output.isPresent());}
public void metron_f6657_0() throws ParseException
{    Boolean adjustTimezone = true;    String[] timeToTest = { "Mar", "2", "05:24:39" };    int year = Calendar.getInstance().get(Calendar.YEAR);    String timeToTestWithYear = String.valueOf(year) + " " + timeToTest[0] + " " + timeToTest[1] + " " + timeToTest[2];    SimpleDateFormat sdf = new SimpleDateFormat("yyyy MMM d HH:mm:ss", Locale.ENGLISH);    sdf.setTimeZone(TimeZone.getTimeZone("GMT"));    Date date = sdf.parse(timeToTestWithYear);    Long expectedTs = date.getTime();    Long ts = ParserUtils.convertToEpoch(timeToTest[0], timeToTest[1], timeToTest[2], adjustTimezone);    assertEquals(expectedTs, ts);}
public void metron_f6658_0() throws ParseException
{    String originalTimestamp = "Oct  9 13:42:11";        ZonedDateTime fixedInstant = ZonedDateTime.of(2016, 10, 8, 18, 30, 30, 0, ZoneOffset.UTC);    Clock fixedClock = Clock.fixed(fixedInstant.toInstant(), fixedInstant.getZone());    assertEquals(SyslogUtils.parseTimestampToEpochMillis(originalTimestamp, fixedClock), 1476020531000L);}
public void metron_f6659_0() throws ParseException
{    String originalTimestamp = "Oct  9 13:42:11";        ZonedDateTime fixedInstant = ZonedDateTime.of(2016, 10, 1, 18, 30, 30, 0, ZoneOffset.UTC);    Clock fixedClock = Clock.fixed(fixedInstant.toInstant(), fixedInstant.getZone());    assertEquals(SyslogUtils.parseTimestampToEpochMillis(originalTimestamp, fixedClock), 1444398131000L);}
public void metron_f6660_0() throws ParseException
{    String originalTimestamp = "Oct 09 2015 13:42:11";    assertEquals(getParsedEpochMillis(originalTimestamp), 1444398131000L);}
public void metron_f6661_0() throws ParseException
{    String originalTimestamp = "2015-10-09T13:42:11.52Z";    assertEquals(getParsedEpochMillis(originalTimestamp), 1444398131520L);}
public void metron_f6662_0() throws ParseException
{    String originalTimestamp = "2015-10-09T08:42:11.52-05:00";    assertEquals(getParsedEpochMillis(originalTimestamp), 1444398131520L);}
private long metron_f6663_0(String originalTimestamp) throws ParseException
{    return SyslogUtils.parseTimestampToEpochMillis(originalTimestamp, Clock.systemUTC());}
public ParserBolt metron_f6664_0(int batchTimeoutDivisor)
{    if (batchTimeoutDivisor <= 0) {        throw new IllegalArgumentException(String.format("batchTimeoutDivisor must be positive. Value provided was %s", batchTimeoutDivisor));    }    this.batchTimeoutDivisor = batchTimeoutDivisor;    return this;}
public int metron_f6665_0()
{    return batchTimeoutDivisor;}
protected void metron_f6666_0(Map<String, WriterHandler> sensorToWriterMap)
{    this.sensorToWriterMap = sensorToWriterMap;}
protected Map<String, String> metron_f6667_0()
{    return topicToSensorMap;}
protected void metron_f6668_0(Map<String, String> topicToSensorMap)
{    this.topicToSensorMap = topicToSensorMap;}
public void metron_f6669_0(MessageGetStrategy messageGetStrategy)
{    this.messageGetStrategy = messageGetStrategy;}
public void metron_f6670_0(OutputCollector collector)
{    this.collector = collector;}
public void metron_f6671_0(AckTuplesPolicy ackTuplesPolicy)
{    this.ackTuplesPolicy = ackTuplesPolicy;}
public Map<String, Object> metron_f6672_1()
{                Function<WriterConfiguration, WriterConfiguration> configurationXform;    WriterHandler writer = sensorToWriterMap.entrySet().iterator().next().getValue();    if (writer.isWriterToBulkWriter()) {        configurationXform = WriterToBulkWriter.TRANSFORMATION;    } else {        configurationXform = x -> x;    }    WriterConfiguration writerconf = configurationXform.apply(getConfigurationStrategy().createWriterConfig(writer.getBulkMessageWriter(), getConfigurations()));    BatchTimeoutHelper timeoutHelper = new BatchTimeoutHelper(writerconf::getAllConfiguredTimeouts, batchTimeoutDivisor);    this.requestedTickFreqSecs = timeoutHelper.getRecommendedTickInterval();        this.maxBatchTimeout = timeoutHelper.getMaxBatchTimeout();    Map<String, Object> conf = super.getComponentConfiguration();    if (conf == null) {        conf = new HashMap<>();    }    conf.put(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, requestedTickFreqSecs);        return conf;}
public void metron_f6673_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    super.prepare(stormConf, context, collector);    messageGetStrategy = MessageGetters.DEFAULT_BYTES_FROM_POSITION.get();    this.collector = collector;    this.parserRunner.init(this::getConfigurations, initializeStellar());    ackTuplesPolicy = new AckTuplesPolicy(collector, messageGetStrategy);        for (Map.Entry<String, WriterHandler> entry : sensorToWriterMap.entrySet()) {        String sensor = entry.getKey();        SensorParserConfig config = getSensorParserConfig(sensor);        if (config != null) {            config.init();            topicToSensorMap.put(config.getSensorTopic(), sensor);        } else {            throw new IllegalStateException("Unable to retrieve a parser config for " + sensor);        }        WriterHandler writer = sensorToWriterMap.get(sensor);        if (maxBatchTimeout == 0) {                                    WriterConfiguration writerConfig = getConfigurationStrategy().createWriterConfig(writer.getBulkMessageWriter(), getConfigurations());            BatchTimeoutHelper timeoutHelper = new BatchTimeoutHelper(writerConfig::getAllConfiguredTimeouts, batchTimeoutDivisor);            maxBatchTimeout = timeoutHelper.getMaxBatchTimeout();        }        writer.init(stormConf, context, collector, getConfigurations(), ackTuplesPolicy, maxBatchTimeout);    }}
public void metron_f6674_0(Tuple tuple)
{    if (TupleUtils.isTick(tuple)) {        handleTickTuple(tuple);        return;    }    byte[] originalMessage = (byte[]) messageGetStrategy.get(tuple);    String topic = tuple.getStringByField(FieldsConfiguration.TOPIC.getFieldName());    String sensorType = topicToSensorMap.get(topic);    try {        ParserConfigurations parserConfigurations = getConfigurations();        SensorParserConfig sensorParserConfig = parserConfigurations.getSensorParserConfig(sensorType);        RawMessage rawMessage = RawMessageUtil.INSTANCE.getRawMessage(sensorParserConfig.getRawMessageStrategy(), tuple, originalMessage, sensorParserConfig.getReadMetadata(), sensorParserConfig.getRawMessageStrategyConfig());        ParserRunnerResults<JSONObject> parserRunnerResults = parserRunner.execute(sensorType, rawMessage, parserConfigurations);        parserRunnerResults.getErrors().forEach(error -> handleError(collector, error));        WriterHandler writer = sensorToWriterMap.get(sensorType);        int numWritten = 0;        List<JSONObject> messages = parserRunnerResults.getMessages();        List<String> messageIds = messages.stream().map(MessageUtils::getGuid).collect(Collectors.toList());        ackTuplesPolicy.addTupleMessageIds(tuple, messageIds);        for (int i = 0; i < messages.size(); i++) {            String messageId = messageIds.get(i);            JSONObject message = messages.get(i);            try {                writer.write(sensorType, new BulkMessage<>(messageId, message), getConfigurations());                numWritten++;            } catch (Exception ex) {                handleError(sensorType, originalMessage, tuple, ex, collector);            }        }        if (numWritten == 0) {            collector.ack(tuple);        }    } catch (Throwable ex) {        handleError(sensorType, originalMessage, tuple, ex, collector);        collector.ack(tuple);    }}
protected Context metron_f6675_0()
{    Map<String, Object> cacheConfig = new HashMap<>();    for (String sensorType : this.parserRunner.getSensorTypes()) {        SensorParserConfig config = getSensorParserConfig(sensorType);        if (config != null) {            cacheConfig.putAll(config.getCacheConfig());        }    }    Cache<CachingStellarProcessor.Key, Object> cache = CachingStellarProcessor.createCache(cacheConfig);    Context.Builder builder = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).with(Context.Capabilities.GLOBAL_CONFIG, () -> getConfigurations().getGlobalConfig()).with(Context.Capabilities.STELLAR_CONFIG, () -> getConfigurations().getGlobalConfig());    if (cache != null) {        builder = builder.with(Context.Capabilities.CACHE, () -> cache);    }    Context stellarContext = builder.build();    StellarFunctions.initialize(stellarContext);    return stellarContext;}
protected void metron_f6676_0(Tuple tuple)
{    try {        for (Entry<String, WriterHandler> entry : sensorToWriterMap.entrySet()) {            entry.getValue().flush(getConfigurations(), messageGetStrategy);        }    } catch (Exception e) {        throw new RuntimeException("This should have been caught in the writerHandler.  If you see this, file a JIRA", e);    } finally {        collector.ack(tuple);    }}
protected void metron_f6677_0(String sensorType, byte[] originalMessage, Tuple tuple, Throwable ex, OutputCollector collector)
{    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(ex).withSensorType(Collections.singleton(sensorType)).addRawMessage(originalMessage);    handleError(collector, error);}
protected void metron_f6678_0(OutputCollector collector, MetronError error)
{    StormErrorUtils.handleError(collector, error);}
public void metron_f6679_0(OutputFieldsDeclarer declarer)
{    declarer.declareStream(Constants.ERROR_STREAM, new Fields("message"));}
public WriterBolt metron_f6680_0(Constants.ErrorType errorType)
{    this.errorType = errorType;    return this;}
public void metron_f6681_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    this.collector = collector;    messageGetStrategy = MessageGetters.DEFAULT_JSON_FROM_FIELD.get();    ackTuplesPolicy = new AckTuplesPolicy(collector, messageGetStrategy);    handler.init(stormConf, context, collector, configuration, ackTuplesPolicy, UNINITIALIZED_MAX_BATCH_TIMEOUT);}
private JSONObject metron_f6682_0(Tuple tuple)
{    Object ret = tuple.getValueByField("message");    if (ret != null) {        ret = tuple.getValue(0);    }    if (ret != null) {        return (JSONObject) ((JSONObject) ret).clone();    } else {        return null;    }}
public void metron_f6683_0(Tuple tuple)
{    JSONObject message = null;    try {        message = (JSONObject) messageGetStrategy.get(tuple);        String messageId = MessageUtils.getGuid(message);        ackTuplesPolicy.addTupleMessageIds(tuple, Collections.singleton(messageId));        handler.write(sensorType, new BulkMessage<>(messageId, message), configuration);    } catch (Throwable e) {        MetronError error = new MetronError().withErrorType(errorType).withThrowable(e).withSensorType(Collections.singleton(sensorType)).addRawMessage(message);        StormErrorUtils.handleError(collector, error);        collector.ack(tuple);    }}
public void metron_f6684_0(OutputFieldsDeclarer declarer)
{}
public boolean metron_f6685_0()
{    return messageWriter instanceof WriterToBulkWriter;}
public BulkMessageWriter metron_f6686_0()
{    return messageWriter;}
public void metron_f6687_0(Map stormConf, TopologyContext topologyContext, OutputCollector collector, ParserConfigurations configurations, AckTuplesPolicy ackTuplesPolicy, int maxBatchTimeout)
{    if (isBulk) {        writerTransformer = config -> configStrategy.createWriterConfig(messageWriter, config);    } else {        writerTransformer = config -> new SingleBatchConfigurationFacade(configStrategy.createWriterConfig(messageWriter, config));    }    try {        messageWriter.init(stormConf, writerTransformer.apply(configurations));    } catch (Exception e) {        throw new IllegalStateException("Unable to initialize message writer", e);    }    this.writerComponent = new BulkWriterComponent<>(maxBatchTimeout);    this.writerComponent.addFlushPolicy(ackTuplesPolicy);}
public void metron_f6688_0(String sensorType, BulkMessage<JSONObject> bulkWriterMessage, ParserConfigurations configurations) throws Exception
{    writerComponent.write(sensorType, bulkWriterMessage, messageWriter, writerTransformer.apply(configurations));}
public void metron_f6689_1(ParserConfigurations configurations, MessageGetStrategy messageGetStrategy) throws Exception
{    if (!(messageWriter instanceof WriterToBulkWriter)) {                        writerComponent.flushAll(messageWriter, writerTransformer.apply(configurations));    }}
public Config metron_f6690_0()
{    return config;}
public String metron_f6691_0()
{    return arg;}
public Config metron_f6692_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setNumWorkers(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6693_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setNumAckers(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6694_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setMaxTaskParallelism(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6695_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setMessageTimeoutSecs(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6696_0(Arg arg)
{    if (arg.getArg() != null) {        File inputFile = new File(arg.getArg());        String json = null;        if (inputFile.exists()) {            try {                json = FileUtils.readFileToString(inputFile);            } catch (IOException e) {                throw new IllegalStateException("Unable to process JSON file " + inputFile, e);            }        } else {            json = arg.getArg();        }        try {            arg.getConfig().putAll(JSONUtils.INSTANCE.load(json, JSONUtils.MAP_SUPPLIER));        } catch (IOException e) {            throw new IllegalStateException("Unable to process JSON snippet.", e);        }    }    return arg.getConfig();}
public void metron_f6697_1(InputStream input, OutputStream output) throws IOException
{    String extraJars = System.getenv().get(EXTRA_JARS_ENV);    if (extraJars == null || extraJars.length() == 0) {        underlyingTransformer.transform(input, output);        return;    }    File tmpFile = File.createTempFile("metron", "jar");    tmpFile.deleteOnExit();    Set<String> entries = new HashSet<>();    try (JarOutputStream jout = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(tmpFile)))) {        try (JarInputStream jin = new JarInputStream(new BufferedInputStream(input))) {            copy(jin, jout, entries);        }        for (String fileStr : Splitter.on(",").split(extraJars)) {            File f = new File(fileStr);            if (!f.exists()) {                continue;            }                        try (JarInputStream jin = new JarInputStream(new BufferedInputStream(new FileInputStream(f)))) {                copy(jin, jout, entries);            }        }    }    underlyingTransformer.transform(new BufferedInputStream(new FileInputStream(tmpFile)), output);}
private Set<String> metron_f6698_1(JarInputStream jin, JarOutputStream jout, Set<String> entries) throws IOException
{    byte[] buffer = new byte[1024];    for (JarEntry entry = jin.getNextJarEntry(); entry != null; entry = jin.getNextJarEntry()) {        if (entries.contains(entry.getName())) {            continue;        }                entries.add(entry.getName());        jout.putNextEntry(entry);        int len = 0;        while ((len = jin.read(buffer)) > 0) {            jout.write(buffer, 0, len);        }    }    return entries;}
public TopologyBuilder metron_f6699_0()
{    return builder;}
public Config metron_f6700_0()
{    return topologyConfig;}
public static ParserTopology metron_f6701_0(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorTypes, ValueSupplier<List> spoutParallelismSupplier, ValueSupplier<List> spoutNumTasksSupplier, ValueSupplier<Integer> parserParallelismSupplier, ValueSupplier<Integer> parserNumTasksSupplier, ValueSupplier<Integer> errorWriterParallelismSupplier, ValueSupplier<Integer> errorWriterNumTasksSupplier, ValueSupplier<List> kafkaSpoutConfigSupplier, ValueSupplier<String> securityProtocolSupplier, ValueSupplier<String> outputTopicSupplier, ValueSupplier<String> errorTopicSupplier, ValueSupplier<Config> stormConfigSupplier) throws Exception
{        ParserConfigurations configs = new ParserConfigurations();    Map<String, SensorParserConfig> sensorToParserConfigs = getSensorParserConfig(zookeeperUrl, sensorTypes, configs);    Collection<SensorParserConfig> parserConfigs = sensorToParserConfigs.values();    @SuppressWarnings("unchecked")    List<Integer> spoutParallelism = (List<Integer>) spoutParallelismSupplier.get(parserConfigs, List.class);    @SuppressWarnings("unchecked")    List<Integer> spoutNumTasks = (List<Integer>) spoutNumTasksSupplier.get(parserConfigs, List.class);    int parserParallelism = parserParallelismSupplier.get(parserConfigs, Integer.class);    int parserNumTasks = parserNumTasksSupplier.get(parserConfigs, Integer.class);    int errorWriterParallelism = errorWriterParallelismSupplier.get(parserConfigs, Integer.class);    int errorWriterNumTasks = errorWriterNumTasksSupplier.get(parserConfigs, Integer.class);    String outputTopic = outputTopicSupplier.get(parserConfigs, String.class);    List<Map<String, Object>> kafkaSpoutConfig = kafkaSpoutConfigSupplier.get(parserConfigs, List.class);    Optional<String> securityProtocol = Optional.ofNullable(securityProtocolSupplier.get(parserConfigs, String.class));        TopologyBuilder builder = new TopologyBuilder();    int i = 0;    List<String> spoutIds = new ArrayList<>();    for (Entry<String, SensorParserConfig> entry : sensorToParserConfigs.entrySet()) {        KafkaSpout kafkaSpout = createKafkaSpout(zookeeperUrl, entry.getKey(), securityProtocol, Optional.ofNullable(kafkaSpoutConfig.get(i)), entry.getValue());        String spoutId = sensorToParserConfigs.size() > 1 ? "kafkaSpout-" + entry.getKey() : "kafkaSpout";        builder.setSpout(spoutId, kafkaSpout, spoutParallelism.get(i)).setNumTasks(spoutNumTasks.get(i));        spoutIds.add(spoutId);        ++i;    }        ParserBolt parserBolt = createParserBolt(zookeeperUrl, brokerUrl, sensorToParserConfigs, securityProtocol, configs, Optional.ofNullable(outputTopic));    BoltDeclarer boltDeclarer = builder.setBolt("parserBolt", parserBolt, parserParallelism).setNumTasks(parserNumTasks);    for (String spoutId : spoutIds) {        boltDeclarer.localOrShuffleGrouping(spoutId);    }        if (errorWriterNumTasks > 0) {        String errorTopic = errorTopicSupplier.get(parserConfigs, String.class);        WriterBolt errorBolt = createErrorBolt(zookeeperUrl, brokerUrl, sensorTypes.get(0), securityProtocol, configs, parserConfigs.iterator().next(), errorTopic);        builder.setBolt("errorMessageWriter", errorBolt, errorWriterParallelism).setNumTasks(errorWriterNumTasks).localOrShuffleGrouping("parserBolt", Constants.ERROR_STREAM);    }    return new ParserTopology(builder, stormConfigSupplier.get(parserConfigs, Config.class));}
private static StormKafkaSpout<Object, Object> metron_f6702_0(String zkQuorum, String sensorType, Optional<String> securityProtocol, Optional<Map<String, Object>> kafkaConfigOptional, SensorParserConfig parserConfig)
{    Map<String, Object> kafkaSpoutConfigOptions = kafkaConfigOptional.orElse(new HashMap<>());    String inputTopic = parserConfig.getSensorTopic() != null ? parserConfig.getSensorTopic() : sensorType;    kafkaSpoutConfigOptions.putIfAbsent(SpoutConfiguration.FIRST_POLL_OFFSET_STRATEGY.key, KafkaSpoutConfig.FirstPollOffsetStrategy.UNCOMMITTED_EARLIEST.name());    kafkaSpoutConfigOptions.putIfAbsent(ConsumerConfig.GROUP_ID_CONFIG, inputTopic + "_parser");    if (securityProtocol.isPresent()) {        kafkaSpoutConfigOptions.putIfAbsent("security.protocol", KafkaUtils.INSTANCE.normalizeProtocol(securityProtocol.get()));    }    return SimpleStormKafkaBuilder.create(inputTopic, zkQuorum, Arrays.asList(SimpleStormKafkaBuilder.FieldsConfiguration.VALUE.getFieldName(), SimpleStormKafkaBuilder.FieldsConfiguration.KEY.getFieldName(), SimpleStormKafkaBuilder.FieldsConfiguration.TOPIC.getFieldName()), kafkaSpoutConfigOptions);}
protected static KafkaWriter metron_f6703_0(Optional<String> broker, String zkQuorum, Optional<String> securityProtocol)
{    KafkaWriter writer = new KafkaWriter();        if (broker.isPresent()) {        writer.withBrokerUrl(broker.get());    } else {        writer.withZkQuorum(zkQuorum);    }        if (securityProtocol.isPresent()) {        HashMap<String, Object> config = new HashMap<>();        config.put("security.protocol", securityProtocol.get());        writer.withProducerConfigs(config);    }    return writer;}
private static ParserBolt metron_f6704_0(String zookeeperUrl, Optional<String> brokerUrl, Map<String, SensorParserConfig> sensorTypeToParserConfig, Optional<String> securityProtocol, ParserConfigurations configs, Optional<String> outputTopic)
{    Map<String, WriterHandler> writerConfigs = createWriterConfigs(zookeeperUrl, brokerUrl, sensorTypeToParserConfig, securityProtocol, configs, outputTopic);    return new ParserBolt(zookeeperUrl, new ParserRunnerImpl(new HashSet<>(sensorTypeToParserConfig.keySet())), writerConfigs);}
protected static Map<String, WriterHandler> metron_f6705_0(String zookeeperUrl, Optional<String> brokerUrl, Map<String, SensorParserConfig> sensorTypeToParserConfig, Optional<String> securityProtocol, ParserConfigurations configs, Optional<String> outputTopic)
{    Map<String, WriterHandler> writerConfigs = new HashMap<>();    for (Entry<String, SensorParserConfig> entry : sensorTypeToParserConfig.entrySet()) {        String sensorType = entry.getKey();        SensorParserConfig parserConfig = entry.getValue();                AbstractWriter writer;        if (parserConfig.getWriterClassName() == null) {                        writer = createKafkaWriter(brokerUrl, zookeeperUrl, securityProtocol).withTopic(outputTopic.orElse(parserConfig.getOutputTopic() != null ? parserConfig.getOutputTopic() : Constants.ENRICHMENT_TOPIC));        } else {            writer = ReflectionUtils.createInstance(parserConfig.getWriterClassName());        }                writer.configure(sensorType, new ParserWriterConfiguration(configs));                WriterHandler writerHandler = createWriterHandler(writer);        writerConfigs.put(sensorType, writerHandler);    }    return writerConfigs;}
private static WriterBolt metron_f6706_0(String zookeeperUrl, Optional<String> brokerUrl, String sensorType, Optional<String> securityProtocol, ParserConfigurations configs, SensorParserConfig parserConfig, String errorTopic)
{        AbstractWriter writer;    if (parserConfig.getErrorWriterClassName() == null) {        if (errorTopic == null) {            errorTopic = (String) configs.getGlobalConfig().get(Constants.PARSER_ERROR_TOPIC_GLOBALS_KEY);        }                writer = createKafkaWriter(brokerUrl, zookeeperUrl, securityProtocol).withTopic(errorTopic).withConfigPrefix("error");    } else {        writer = ReflectionUtils.createInstance(parserConfig.getWriterClassName());    }        writer.configure(sensorType, new ParserWriterConfiguration(configs));        WriterHandler writerHandler = createWriterHandler(writer);    return new WriterBolt(writerHandler, configs, sensorType).withErrorType(Constants.ErrorType.PARSER_ERROR);}
private static Map<String, SensorParserConfig> metron_f6707_0(String zookeeperUrl, List<String> sensorTypes, ParserConfigurations configs) throws Exception
{    Map<String, SensorParserConfig> parserConfigs = new HashMap<>();    try (CuratorFramework client = ConfigurationsUtils.getClient(zookeeperUrl)) {        client.start();        ConfigurationsUtils.updateParserConfigsFromZookeeper(configs, client);        for (String sensorType : sensorTypes) {            SensorParserConfig parserConfig = configs.getSensorParserConfig(sensorType);            if (parserConfig == null) {                throw new IllegalStateException("Cannot find the parser configuration in zookeeper for " + sensorType + "." + "  Please check that it exists in zookeeper by using the 'zk_load_configs.sh -m DUMP' command.");            }            parserConfigs.put(sensorType, parserConfig);        }    }    return parserConfigs;}
private static WriterHandler metron_f6708_0(AbstractWriter writer)
{    if (writer instanceof BulkMessageWriter) {        return new WriterHandler((BulkMessageWriter<JSONObject>) writer);    } else if (writer instanceof MessageWriter) {        return new WriterHandler((MessageWriter<JSONObject>) writer);    } else {        throw new IllegalStateException("Unable to create parser bolt: writer must be a MessageWriter or a BulkMessageWriter");    }}
public boolean metron_f6709_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f6710_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f6711_0(CommandLine cli, String def)
{    return has(cli) ? cli.getOptionValue(shortCode) : def;}
public static Optional<Config> metron_f6712_0(CommandLine cli)
{    return getConfig(cli, new Config());}
public static Optional<Config> metron_f6713_0(CommandLine cli, Config config)
{    if (EXTRA_OPTIONS.has(cli)) {        Map<String, Object> extraOptions = readJSONMapFromFile(new File(EXTRA_OPTIONS.get(cli)));        config.putAll(extraOptions);    }    for (ParserOptions option : ParserOptions.values()) {        config = option.configHandler.apply(new Arg(config, option.get(cli)));    }    return config.isEmpty() ? Optional.empty() : Optional.of(config);}
public static CommandLine metron_f6714_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f6715_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("ParserTopologyCLI", getOptions());}
public static Options metron_f6716_0()
{    Options ret = new Options();    for (ParserOptions o : ParserOptions.values()) {        ret.addOption(o.option);    }    return ret;}
private static CommandLine metron_f6717_0(Options options, String[] args)
{    /*     * The general gist is that in order to pass args to storm jar,     * we have to disregard options that we don't know about in the CLI.     * Storm will ignore our args, we have to do the same.     */    CommandLineParser parser = new PosixParser() {        @Override        protected void processOption(String arg, ListIterator iter) throws ParseException {            if (getOptions().hasOption(arg)) {                super.processOption(arg, iter);            }        }    };    try {        return ParserOptions.parse(parser, args);    } catch (ParseException pe) {        pe.printStackTrace();        final HelpFormatter usageFormatter = new HelpFormatter();        usageFormatter.printHelp("ParserTopologyCLI", null, options, null, true);        System.exit(-1);        return null;    }}
protected void metron_f6718_0(String arg, ListIterator iter) throws ParseException
{    if (getOptions().hasOption(arg)) {        super.processOption(arg, iter);    }}
public ParserTopologyBuilder.ParserTopology metron_f6719_0(final CommandLine cmd) throws Exception
{    String zookeeperUrl = ParserOptions.ZK_QUORUM.get(cmd);    Optional<String> brokerUrl = ParserOptions.BROKER_URL.has(cmd) ? Optional.of(ParserOptions.BROKER_URL.get(cmd)) : Optional.empty();    String sensorTypeRaw = ParserOptions.SENSOR_TYPES.get(cmd);    List<String> sensorTypes = Arrays.stream(sensorTypeRaw.split(TOPOLOGY_OPTION_SEPARATOR)).map(String::trim).collect(Collectors.toList());    /*     * It bears mentioning why we're creating this ValueSupplier indirection here.     * As a separation of responsibilities, the CLI class defines the order of precedence     * for the various topological and structural properties for creating a parser.  This is     * desirable because there are now (i.e. integration tests)     * and may be in the future (i.e. a REST service to start parsers without using the CLI)     * other mechanisms to construct parser topologies.  It's sensible to split those concerns..     *     * Unfortunately, determining the structural parameters for a parser requires interacting with     * external services (e.g. zookeeper) that are set up well within the ParserTopology class.     * Rather than pulling the infrastructure to interact with those services out and moving it into the     * CLI class and breaking that separation of concerns, we've created a supplier     * indirection where are providing the logic as to how to create precedence in the CLI class     * without owning the responsibility of constructing the infrastructure where the values are     * necessarily supplied.     *     */        ValueSupplier<List> spoutParallelism = (parserConfigs, clazz) -> {        if (ParserOptions.SPOUT_PARALLELISM.has(cmd)) {                        if (parserConfigs.size() == 1) {                return Collections.singletonList(Integer.parseInt(ParserOptions.SPOUT_PARALLELISM.get(cmd, "1")));            }                        String parallelismRaw = ParserOptions.SPOUT_PARALLELISM.get(cmd, "1");            List<String> parallelisms = Arrays.stream(parallelismRaw.split(TOPOLOGY_OPTION_SEPARATOR)).map(String::trim).collect(Collectors.toList());            if (parallelisms.size() != parserConfigs.size()) {                throw new IllegalArgumentException("Spout parallelism should match number of sensors 1:1");            }            List<Integer> spoutParallelisms = new ArrayList<>();            for (String s : parallelisms) {                spoutParallelisms.add(Integer.parseInt(s));            }            return spoutParallelisms;        }        List<Integer> spoutParallelisms = new ArrayList<>();        for (SensorParserConfig parserConfig : parserConfigs) {            spoutParallelisms.add(parserConfig.getSpoutParallelism());        }        return spoutParallelisms;    };        ValueSupplier<List> spoutNumTasks = (parserConfigs, clazz) -> {        if (ParserOptions.SPOUT_NUM_TASKS.has(cmd)) {                        if (parserConfigs.size() == 1) {                return Collections.singletonList(Integer.parseInt(ParserOptions.SPOUT_NUM_TASKS.get(cmd, "1")));            }                        String numTasksRaw = ParserOptions.SPOUT_NUM_TASKS.get(cmd, "1");            List<String> numTasks = Arrays.stream(numTasksRaw.split(TOPOLOGY_OPTION_SEPARATOR)).map(String::trim).collect(Collectors.toList());            if (numTasks.size() != parserConfigs.size()) {                throw new IllegalArgumentException("Spout num tasks should match number of sensors 1:1");            }            List<Integer> spoutTasksList = new ArrayList<>();            for (String s : numTasks) {                spoutTasksList.add(Integer.parseInt(s));            }            return spoutTasksList;        }        List<Integer> numTasks = new ArrayList<>();        for (SensorParserConfig parserConfig : parserConfigs) {            numTasks.add(parserConfig.getSpoutNumTasks());        }        return numTasks;    };        ValueSupplier<Integer> parserParallelism = (parserConfigs, clazz) -> {        if (ParserOptions.PARSER_PARALLELISM.has(cmd)) {            return Integer.parseInt(ParserOptions.PARSER_PARALLELISM.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getParserParallelism();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<Integer> parserNumTasks = (parserConfigs, clazz) -> {        if (ParserOptions.PARSER_NUM_TASKS.has(cmd)) {            return Integer.parseInt(ParserOptions.PARSER_NUM_TASKS.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getParserNumTasks();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<Integer> errorParallelism = (parserConfigs, clazz) -> {        if (ParserOptions.ERROR_WRITER_PARALLELISM.has(cmd)) {            return Integer.parseInt(ParserOptions.ERROR_WRITER_PARALLELISM.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getErrorWriterParallelism();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<Integer> errorNumTasks = (parserConfigs, clazz) -> {        if (ParserOptions.ERROR_WRITER_NUM_TASKS.has(cmd)) {            return Integer.parseInt(ParserOptions.ERROR_WRITER_NUM_TASKS.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getErrorWriterNumTasks();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<List> spoutConfig = (parserConfigs, clazz) -> {        if (ParserOptions.SPOUT_CONFIG.has(cmd)) {            return Collections.singletonList(readJSONMapFromFile(new File(ParserOptions.SPOUT_CONFIG.get(cmd))));        }        List<Map<String, Object>> retValue = new ArrayList<>();        for (SensorParserConfig config : parserConfigs) {            retValue.add(config.getSpoutConfig());        }        return retValue;    };        ValueSupplier<String> securityProtocol = (parserConfigs, clazz) -> {        Optional<String> sp = Optional.empty();        if (ParserOptions.SECURITY_PROTOCOL.has(cmd)) {            sp = Optional.of(ParserOptions.SECURITY_PROTOCOL.get(cmd));        }                if (!sp.isPresent()) {            sp = getSecurityProtocol(sp, spoutConfig.get(parserConfigs, List.class));        }                String parserConfigSp = SecurityProtocol.PLAINTEXT.name;        for (SensorParserConfig config : parserConfigs) {            String configSp = config.getSecurityProtocol();            if (!SecurityProtocol.PLAINTEXT.name.equals(configSp)) {                                parserConfigSp = configSp;            }        }        return sp.orElse(Optional.ofNullable(parserConfigSp).orElse(null));    };        ValueSupplier<Config> stormConf = (parserConfigs, clazz) -> {                Config finalConfig = new Config();        for (SensorParserConfig parserConfig : parserConfigs) {            Map<String, Object> c = parserConfig.getStormConfig();            if (c != null && !c.isEmpty()) {                finalConfig.putAll(c);            }            if (parserConfig.getNumAckers() != null) {                Config.setNumAckers(finalConfig, parserConfig.getNumAckers());            }            if (parserConfig.getNumWorkers() != null) {                Config.setNumWorkers(finalConfig, parserConfig.getNumWorkers());            }        }        return ParserOptions.getConfig(cmd, finalConfig).orElse(finalConfig);    };        ValueSupplier<String> outputTopic = (parserConfigs, clazz) -> {        String topic = null;        if (ParserOptions.OUTPUT_TOPIC.has(cmd)) {            topic = ParserOptions.OUTPUT_TOPIC.get(cmd);        }        return topic;    };        ValueSupplier<String> errorTopic = (parserConfigs, clazz) -> {                String topic = null;        for (SensorParserConfig parserConfig : parserConfigs) {            String currentTopic = parserConfig.getErrorTopic();            if (topic != null && !topic.equals(currentTopic)) {                throw new IllegalArgumentException("Parser Aggregation specified with differing error topics");            }            topic = currentTopic;        }        return topic;    };    return getParserTopology(zookeeperUrl, brokerUrl, sensorTypes, spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, stormConf, outputTopic, errorTopic);}
protected ParserTopologyBuilder.ParserTopology metron_f6720_0(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorTypes, ValueSupplier<List> spoutParallelism, ValueSupplier<List> spoutNumTasks, ValueSupplier<Integer> parserParallelism, ValueSupplier<Integer> parserNumTasks, ValueSupplier<Integer> errorParallelism, ValueSupplier<Integer> errorNumTasks, ValueSupplier<List> spoutConfig, ValueSupplier<String> securityProtocol, ValueSupplier<Config> stormConf, ValueSupplier<String> outputTopic, ValueSupplier<String> errorTopic) throws Exception
{    return ParserTopologyBuilder.build(zookeeperUrl, brokerUrl, sensorTypes, spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, outputTopic, errorTopic, stormConf);}
public static void metron_f6721_0(String[] args)
{    try {        Options options = new Options();        final CommandLine cmd = parse(options, args);        if (cmd.hasOption("h")) {            final HelpFormatter usageFormatter = new HelpFormatter();            usageFormatter.printHelp("ParserTopologyCLI", null, options, null, true);            System.exit(0);        }        ParserTopologyCLI cli = new ParserTopologyCLI();        ParserTopologyBuilder.ParserTopology topology = cli.createParserTopology(cmd);        String sensorTypes = ParserOptions.SENSOR_TYPES.get(cmd);        String topologyName = sensorTypes.replaceAll(TOPOLOGY_OPTION_SEPARATOR, STORM_JOB_SEPARATOR);        if (ParserOptions.TEST.has(cmd)) {            topology.getTopologyConfig().put(Config.TOPOLOGY_DEBUG, true);            LocalCluster cluster = new LocalCluster();            cluster.submitTopology(topologyName, topology.getTopologyConfig(), topology.getBuilder().createTopology());            Utils.sleep(300000);            cluster.shutdown();        } else {            StormSubmitter.submitTopology(topologyName, topology.getTopologyConfig(), topology.getBuilder().createTopology());        }    } catch (Exception e) {        e.printStackTrace();        System.exit(-1);    }}
private static Optional<String> metron_f6722_0(Optional<String> protocol, List<Map<String, Object>> spoutConfig)
{    Optional<String> ret = protocol;    if (ret.isPresent() && protocol.get().equalsIgnoreCase(SecurityProtocol.PLAINTEXT.name)) {        ret = Optional.empty();    }    if (!ret.isPresent()) {                String spoutConfigSp = null;        for (Map<String, Object> config : spoutConfig) {            String configSp = (String) config.get(KafkaUtils.SECURITY_PROTOCOL);            if (configSp != null && !SecurityProtocol.PLAINTEXT.name.equals(configSp)) {                                spoutConfigSp = configSp;            } else if (configSp != null) {                                spoutConfigSp = configSp;            }        }        ret = Optional.ofNullable(spoutConfigSp);    }    if (ret.isPresent() && ret.get().equalsIgnoreCase(SecurityProtocol.PLAINTEXT.name)) {        ret = Optional.empty();    }    return ret;}
private static Map<String, Object> metron_f6723_0(File inputFile)
{    String json = null;    if (inputFile.exists()) {        try {            json = FileUtils.readFileToString(inputFile);        } catch (IOException e) {            throw new IllegalStateException("Unable to process JSON file " + inputFile, e);        }    } else {        throw new IllegalArgumentException("Unable to load JSON file at " + inputFile.getAbsolutePath());    }    try {        return JSONUtils.INSTANCE.load(json, JSONUtils.MAP_SUPPLIER);    } catch (IOException e) {        throw new IllegalStateException("Unable to process JSON.", e);    }}
public ParserRunnerResults<JSONObject> metron_f6724_0(String sensorType, RawMessage rawMessage, ParserConfigurations parserConfigurations)
{    DefaultParserRunnerResults parserRunnerResults = new DefaultParserRunnerResults();    this.rawMessage = rawMessage;    for (JSONObject message : messages) {        if (!isInvalid) {            parserRunnerResults.addMessage(message);        } else {            MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton(sensorType)).addRawMessage(message);            parserRunnerResults.addError(error);        }    }    return parserRunnerResults;}
protected void metron_f6725_0(boolean isInvalid)
{    this.isInvalid = isInvalid;}
protected void metron_f6726_0(List<JSONObject> messages)
{    this.messages = messages;}
protected RawMessage metron_f6727_0()
{    return rawMessage;}
public void metron_f6728_0()
{    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }).withBatchTimeoutDivisor(5);    Assert.assertEquals(5, parserBolt.getBatchTimeoutDivisor());}
public void metron_f6729_0()
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("batchTimeoutDivisor must be positive. Value provided was -1");    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }).withBatchTimeoutDivisor(-1);}
public void metron_f6730_0()
{    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            ParserConfigurations configurations = new ParserConfigurations();            SensorParserConfig sensorParserConfig = new SensorParserConfig();            sensorParserConfig.setParserConfig(new HashMap<String, Object>() {                {                    put(IndexingConfigurations.BATCH_SIZE_CONF, 10);                }            });            configurations.updateSensorParserConfig("yaf", sensorParserConfig);            return configurations;        }    };    Map<String, Object> componentConfiguration = parserBolt.getComponentConfiguration();    Assert.assertEquals(1, componentConfiguration.size());    Assert.assertEquals(14, componentConfiguration.get(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS));}
public ParserConfigurations metron_f6731_0()
{    ParserConfigurations configurations = new ParserConfigurations();    SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setParserConfig(new HashMap<String, Object>() {        {            put(IndexingConfigurations.BATCH_SIZE_CONF, 10);        }    });    configurations.updateSensorParserConfig("yaf", sensorParserConfig);    return configurations;}
public void metron_f6732_0()
{    Map stormConf = mock(Map.class);    SensorParserConfig yafConfig = mock(SensorParserConfig.class);    when(yafConfig.getSensorTopic()).thenReturn("yafTopic");    when(yafConfig.getParserConfig()).thenReturn(new HashMap<String, Object>() {        {            put(IndexingConfigurations.BATCH_SIZE_CONF, 10);        }    });    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        protected SensorParserConfig getSensorParserConfig(String sensorType) {            if ("yaf".equals(sensorType)) {                return yafConfig;            }            return null;        }        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    doReturn(stellarContext).when(parserBolt).initializeStellar();    parserBolt.setCuratorFramework(client);    parserBolt.setZKCache(cache);    parserBolt.prepare(stormConf, topologyContext, outputCollector);    verify(parserRunner, times(1)).init(any(Supplier.class), eq(stellarContext));    verify(yafConfig, times(1)).init();    Map<String, String> topicToSensorMap = parserBolt.getTopicToSensorMap();    Assert.assertEquals(1, topicToSensorMap.size());    Assert.assertEquals("yaf", topicToSensorMap.get("yafTopic"));    verify(writerHandler).init(eq(stormConf), eq(topologyContext), eq(outputCollector), eq(parserConfigurations), any(AckTuplesPolicy.class), eq(14));}
protected SensorParserConfig metron_f6733_0(String sensorType)
{    if ("yaf".equals(sensorType)) {        return yafConfig;    }    return null;}
public ParserConfigurations metron_f6734_0()
{    return parserConfigurations;}
public void metron_f6735_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("Unable to retrieve a parser config for yaf");    Map stormConf = mock(Map.class);    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    });    parserBolt.setCuratorFramework(client);    parserBolt.setZKCache(cache);    parserBolt.prepare(stormConf, topologyContext, outputCollector);}
public void metron_f6736_0() throws Exception
{    when(t1.getSourceComponent()).thenReturn("__system");    when(t1.getSourceStreamId()).thenReturn("__tick");    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    };    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.execute(t1);    verify(writerHandler, times(1)).flush(parserConfigurations, messageGetStrategy);    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6737_0()
{    return parserConfigurations;}
public void metron_f6738_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    parserBolt.setAckTuplesPolicy(bulkWriterResponseHandler);    JSONObject message = new JSONObject();    message.put(Constants.GUID, "messageId");    message.put("field", "value");    mockParserRunner.setMessages(Collections.singletonList(message));    RawMessage expectedRawMessage = new RawMessage("originalMessage".getBytes(StandardCharsets.UTF_8), new HashMap<>());    {        parserBolt.execute(t1);        Assert.assertEquals(expectedRawMessage, mockParserRunner.getRawMessage());        verify(bulkWriterResponseHandler).addTupleMessageIds(t1, Collections.singletonList("messageId"));        verify(writerHandler, times(1)).write("yaf", new BulkMessage<>("messageId", message), parserConfigurations);    }}
public ParserConfigurations metron_f6739_0()
{    return parserConfigurations;}
public void metron_f6740_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    parserBolt.setAckTuplesPolicy(bulkWriterResponseHandler);    List<BulkMessage<JSONObject>> messages = new ArrayList<>();    for (int i = 0; i < 5; i++) {        String messageId = String.format("messageId%s", i + 1);        JSONObject message = new JSONObject();        message.put(Constants.GUID, messageId);        message.put("field", String.format("value%s", i + 1));        messages.add(new BulkMessage<>(messageId, message));    }    mockParserRunner.setMessages(messages.stream().map(BulkMessage::getMessage).collect(Collectors.toList()));    RawMessage expectedRawMessage = new RawMessage("originalMessage".getBytes(StandardCharsets.UTF_8), new HashMap<>());    {                parserBolt.execute(t1);        Assert.assertEquals(expectedRawMessage, mockParserRunner.getRawMessage());        InOrder inOrder = inOrder(bulkWriterResponseHandler, writerHandler);        inOrder.verify(bulkWriterResponseHandler).addTupleMessageIds(t1, Arrays.asList("messageId1", "messageId2", "messageId3", "messageId4", "messageId5"));        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(0), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(1), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(2), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(3), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(4), parserConfigurations);    }    verifyNoMoreInteractions(writerHandler, bulkWriterResponseHandler, outputCollector);}
public ParserConfigurations metron_f6741_0()
{    return parserConfigurations;}
public void metron_f6742_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    mockParserRunner.setInvalid(true);    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    };    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    JSONObject message = new JSONObject();    message.put("field", "value");    mockParserRunner.setMessages(Collections.singletonList(message));    RawMessage expectedRawMessage = new RawMessage("originalMessage".getBytes(StandardCharsets.UTF_8), new HashMap<>());    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton("yaf")).addRawMessage(message);    parserBolt.execute(t1);    Assert.assertEquals(expectedRawMessage, mockParserRunner.getRawMessage());    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6743_0()
{    return parserConfigurations;}
public void metron_f6744_0()
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    doThrow(new IllegalStateException("parserRunner.execute failed")).when(parserRunner).execute(eq("yaf"), any(), eq(parserConfigurations));    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    };    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(new IllegalStateException("parserRunner.execute failed")).withSensorType(Collections.singleton("yaf")).addRawMessage("originalMessage".getBytes(StandardCharsets.UTF_8));    parserBolt.execute(t1);    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    verify(outputCollector, times(1)).reportError(any(IllegalStateException.class));    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6745_0()
{    return parserConfigurations;}
public void metron_f6746_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    doThrow(new IllegalStateException("write failed")).when(writerHandler).write(any(), any(), any());    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    parserBolt.setAckTuplesPolicy(bulkWriterResponseHandler);    JSONObject message = new JSONObject();    message.put(Constants.GUID, "messageId");    message.put("field", "value");    mockParserRunner.setMessages(Collections.singletonList(message));    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(new IllegalStateException("write failed")).withSensorType(Collections.singleton("yaf")).addRawMessage("originalMessage".getBytes(StandardCharsets.UTF_8));    parserBolt.execute(t1);    verify(bulkWriterResponseHandler, times(1)).addTupleMessageIds(t1, Collections.singletonList("messageId"));    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    verify(outputCollector, times(1)).reportError(any(IllegalStateException.class));    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6747_0()
{    return parserConfigurations;}
private ParserConfigurations metron_f6748_0(int batchSize)
{    return new ParserConfigurations() {        @Override        public SensorParserConfig getSensorParserConfig(String sensorType) {            return new SensorParserConfig() {                @Override                public Map<String, Object> getParserConfig() {                    return new HashMap<String, Object>() {                        {                            put(IndexingConfigurations.BATCH_SIZE_CONF, batchSize);                        }                    };                }            };        }    };}
public SensorParserConfig metron_f6749_0(String sensorType)
{    return new SensorParserConfig() {        @Override        public Map<String, Object> getParserConfig() {            return new HashMap<String, Object>() {                {                    put(IndexingConfigurations.BATCH_SIZE_CONF, batchSize);                }            };        }    };}
public Map<String, Object> metron_f6750_0()
{    return new HashMap<String, Object>() {        {            put(IndexingConfigurations.BATCH_SIZE_CONF, batchSize);        }    };}
public void metron_f6751_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(5);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<MessageId> messageIds = new ArrayList<>();    for (int i = 0; i < 5; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(new MessageId(messageId));        JSONObject message = new JSONObject();        message.put(Constants.GUID, messageId);        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }        BulkWriterResponse writerResponse = new BulkWriterResponse();    writerResponse.addAllSuccesses(messageIds);    when(batchWriter.write(any(), any(), any())).thenReturn(writerResponse);    bolt.execute(tuples.get(4));    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(0)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6752_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(1);    String sensorType = "test";    Tuple t = mock(Tuple.class);    when(t.getValueByField(eq("message"))).thenReturn(new JSONObject());    WriterBolt bolt = new WriterBolt(new WriterHandler(writer), configurations, sensorType);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(writer, times(1)).init();    bolt.execute(t);    verify(outputCollector, times(1)).ack(t);    verify(writer, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(0)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6753_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(1);    String sensorType = "test";    Tuple t = mock(Tuple.class);    when(t.getValueByField(eq("message"))).thenThrow(new IllegalStateException());    WriterBolt bolt = new WriterBolt(new WriterHandler(writer), configurations, sensorType);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(writer, times(1)).init();    bolt.execute(t);    verify(outputCollector, times(1)).ack(t);    verify(writer, times(0)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6754_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(1);    String sensorType = "test";    Tuple t = mock(Tuple.class);    when(t.toString()).thenReturn("tuple");    when(t.getValueByField(eq("message"))).thenReturn(new JSONObject());    WriterBolt bolt = new WriterBolt(new WriterHandler(writer), configurations, sensorType);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    doThrow(new Exception("write error")).when(writer).write(any(), any(), any());    verify(writer, times(1)).init();    bolt.execute(t);    verify(outputCollector, times(1)).ack(t);    verify(writer, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());    MetronError error = new MetronError().withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(new Exception("write error")).withSensorType(Collections.singleton(sensorType)).addRawMessage(new JSONObject());    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));}
public void metron_f6755_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(5);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<MessageId> messageIds = new ArrayList<>();    for (int i = 0; i < 4; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(new MessageId(messageId));        JSONObject message = new JSONObject();        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    Tuple errorTuple = mock(Tuple.class);    Tuple goodTuple = mock(Tuple.class);    when(goodTuple.getValueByField(eq("message"))).thenReturn(new JSONObject());    when(errorTuple.getValueByField(eq("message"))).thenThrow(new IllegalStateException());    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }        BulkWriterResponse writerResponse = new BulkWriterResponse();    writerResponse.addAllSuccesses(messageIds);    writerResponse.addSuccess(new MessageId("goodMessage"));    when(batchWriter.write(any(), any(), any())).thenReturn(writerResponse);    bolt.execute(errorTuple);    for (Tuple t : tuples) {        verify(outputCollector, times(0)).ack(t);    }    bolt.execute(goodTuple);    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(outputCollector, times(1)).ack(goodTuple);    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6756_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(6);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<MessageId> messageIds = new ArrayList<>();    for (int i = 0; i < 4; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(new MessageId(messageId));        JSONObject message = new JSONObject();        message.put(Constants.GUID, messageId);        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    Tuple errorTuple = mock(Tuple.class);    Tuple goodTuple = mock(Tuple.class);    JSONObject goodMessage = new JSONObject();    goodMessage.put(Constants.GUID, "goodMessageId");    goodMessage.put("value", "goodMessage");    JSONObject errorMessage = new JSONObject();    goodMessage.put(Constants.GUID, "errorMessageId");    errorMessage.put("value", "errorMessage");    when(goodTuple.getValueByField(eq("message"))).thenReturn(goodMessage);    when(errorTuple.getValueByField(eq("message"))).thenReturn(errorMessage);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }        BulkWriterResponse writerResponse = new BulkWriterResponse();    writerResponse.addAllSuccesses(messageIds);    writerResponse.addSuccess(new MessageId("goodMessageId"));    writerResponse.addError(new IllegalStateException(), new MessageId("errorMessageId"));    when(batchWriter.write(any(), any(), any())).thenReturn(writerResponse);    bolt.execute(errorTuple);    for (Tuple t : tuples) {        verify(outputCollector, times(0)).ack(t);    }    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.FATAL);    bolt.execute(goodTuple);    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.ERROR);    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(outputCollector, times(1)).ack(goodTuple);    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6757_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(5);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<String> messageIds = new ArrayList<>();    for (int i = 0; i < 4; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(messageId);        JSONObject message = new JSONObject();        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    Tuple goodTuple = mock(Tuple.class);    when(goodTuple.getValueByField(eq("message"))).thenReturn(new JSONObject());    bolt.prepare(new HashMap(), topologyContext, outputCollector);    doThrow(new Exception()).when(batchWriter).write(any(), any(), any());    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.FATAL);    bolt.execute(goodTuple);    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.ERROR);    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).ack(goodTuple);    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public Builder metron_f6758_0(Properties topologyProperties)
{    this.topologyProperties = topologyProperties;    return this;}
public Builder metron_f6759_0(String brokerUrl)
{    this.brokerUrl = brokerUrl;    return this;}
public Builder metron_f6760_0(List<String> sensorTypes)
{    this.sensorTypes = sensorTypes;    return this;}
public Builder metron_f6761_0(String topic)
{    this.outputTopic = topic;    return this;}
public Builder metron_f6762_0(String topic)
{    this.errorTopic = topic;    return this;}
public ParserTopologyComponent metron_f6763_0()
{    if (sensorTypes == null || sensorTypes.isEmpty()) {        throw new IllegalArgumentException("The sensor type must be defined.");    }    if (outputTopic == null) {        throw new IllegalArgumentException("The output topic must be defined.");    }    return new ParserTopologyComponent(topologyProperties, brokerUrl, sensorTypes, outputTopic, errorTopic);}
public void metron_f6764_0(List<String> sensorTypes)
{    this.sensorTypes = sensorTypes;}
public void metron_f6765_0() throws UnableToStartException
{    try {        final Map<String, Object> stormConf = new HashMap<>();        stormConf.put(Config.TOPOLOGY_DEBUG, true);        ParserTopologyBuilder.ParserTopology topologyBuilder = ParserTopologyBuilder.build(topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY), Optional.ofNullable(brokerUrl), sensorTypes, (x, y) -> Collections.nCopies(sensorTypes.size(), 1), (x, y) -> Collections.nCopies(sensorTypes.size(), 1), (x, y) -> 1, (x, y) -> 1, (x, y) -> 1, (x, y) -> 1, (x, y) -> Collections.nCopies(sensorTypes.size(), new HashMap<>()), (x, y) -> null, (x, y) -> outputTopic, (x, y) -> errorTopic, (x, y) -> {            Config c = new Config();            c.putAll(stormConf);            return c;        });        stormCluster = new LocalCluster();        stormCluster.submitTopology(getTopologyName(), stormConf, topologyBuilder.getBuilder().createTopology());    } catch (Exception e) {        throw new UnableToStartException("Unable to start parser topology for sensorTypes: " + sensorTypes, e);    }}
public void metron_f6766_1()
{    if (stormCluster != null) {        try {            try {                                killTopology();                stormCluster.shutdown();            } catch (IllegalStateException ise) {                if (!(ise.getMessage().contains("It took over") && ise.getMessage().contains("to shut down slot"))) {                    throw ise;                } else {                    assassinateSlots();                                    }            }        } catch (Throwable t) {                    } finally {            cleanupWorkerDir();        }    }}
public void metron_f6767_0()
{    if (stormCluster != null) {        killTopology();    }}
protected void metron_f6768_0()
{    KillOptions ko = new KillOptions();    ko.set_wait_secs(0);    stormCluster.killTopologyWithOpts(getTopologyName(), ko);    try {                Thread.sleep(2000);    } catch (InterruptedException e) {        }}
protected String metron_f6769_0()
{    return StringUtils.join(sensorTypes, "__");}
public static Iterable<String> metron_f6770_0()
{    return sensorTypes;}
public void metron_f6771_0() throws Exception
{    ParserDriver driver = new StormParserDriver(sensorType, readSensorConfig(sensorType), readGlobalConfig());    runTest(driver);}
 List<ParserValidation> metron_f6772_0()
{    return new ArrayList<ParserValidation>() {        {            add(new SampleDataValidation());        }    };}
public void metron_f6773_0(Map stormConf, WriterConfiguration config) throws Exception
{}
public BulkWriterResponse metron_f6774_0(String sensorType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages) throws Exception
{    messages.forEach(bulkWriterMessage -> output.add(bulkWriterMessage.getMessage().toJSONString().getBytes(StandardCharsets.UTF_8)));    Set<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toSet());    BulkWriterResponse bulkWriterResponse = new BulkWriterResponse();    bulkWriterResponse.addAllSuccesses(ids);    return bulkWriterResponse;}
public String metron_f6775_0()
{    return "collecting";}
public void metron_f6776_0() throws Exception
{}
public List<byte[]> metron_f6777_0()
{    return output;}
public ParserConfigurations metron_f6778_0()
{    config.getSensorParserConfig(sensorType).getParserConfig().putIfAbsent(IndexingConfigurations.BATCH_SIZE_CONF, 1);    return config;}
protected void metron_f6779_0()
{}
protected void metron_f6780_1(String sensorType, byte[] originalMessage, Tuple tuple, Throwable ex, OutputCollector collector)
{    errors.add(originalMessage);    }
protected void metron_f6781_1(OutputCollector collector, MetronError error)
{    for (Object rawMessage : error.getRawMessages()) {        errors.add((byte[]) rawMessage);    }    if (error.getThrowable().isPresent()) {        Throwable throwable = error.getThrowable().get();            }}
public ProcessorResult<List<byte[]>> metron_f6782_0()
{    return new ProcessorResult.Builder<List<byte[]>>().withProcessErrors(errors).withResult(output).build();}
public ProcessorResult<List<byte[]>> metron_f6783_0(Iterable<byte[]> in)
{    ShimParserBolt bolt = new ShimParserBolt(new ArrayList<>());    byte[] b = SerializationUtils.serialize(bolt);    ShimParserBolt b2 = (ShimParserBolt) SerializationUtils.deserialize(b);    OutputCollector collector = mock(OutputCollector.class);    bolt.prepare(null, null, collector);    for (byte[] record : in) {        Tuple tuple = toTuple(record);        bolt.execute(tuple);        verify(collector, times(1)).ack(tuple);    }    return bolt.getResults();}
public Tuple metron_f6784_0(byte[] record)
{    Tuple ret = mock(Tuple.class);    when(ret.getStringByField("topic")).thenReturn(sensorType);    when(ret.getBinary(eq(0))).thenReturn(record);    return ret;}
public void metron_f6785_0()
{    spy(ParserTopologyBuilder.class);    when(ParserTopologyBuilder.createKafkaWriter(Optional.of("brokerUrl"), "zookeeperUrl", Optional.of("securityProtocol"))).thenReturn(kafkaWriter);}
public void metron_f6786_0()
{    SensorParserConfig broConfig = new SensorParserConfig();    broConfig.setSensorTopic("bro");    when(configs.getSensorParserConfig("bro")).thenReturn(broConfig);    KafkaWriter enrichmentWriter = mock(KafkaWriter.class);    when(kafkaWriter.withTopic(Constants.ENRICHMENT_TOPIC)).thenReturn(enrichmentWriter);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("bro", broConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.empty());    assertEquals(1, writerConfigs.size());    assertEquals(enrichmentWriter, writerConfigs.get("bro").getBulkMessageWriter());    verify(enrichmentWriter, times(1)).configure(eq("bro"), any(ParserWriterConfiguration.class));    verifyNoMoreInteractions(enrichmentWriter);}
public void metron_f6787_0()
{    SensorParserConfig snortConfig = new SensorParserConfig();    snortConfig.setSensorTopic("snort");    snortConfig.setOutputTopic("snort_topic");    when(configs.getSensorParserConfig("snort")).thenReturn(snortConfig);    KafkaWriter snortTestWriter = mock(KafkaWriter.class);    when(kafkaWriter.withTopic("snort_topic")).thenReturn(snortTestWriter);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("snort", snortConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.empty());    assertEquals(1, writerConfigs.size());    assertEquals(snortTestWriter, writerConfigs.get("snort").getBulkMessageWriter());    verify(snortTestWriter, times(1)).configure(eq("snort"), any(ParserWriterConfiguration.class));    verifyNoMoreInteractions(snortTestWriter);}
public void metron_f6788_0()
{    SensorParserConfig snortConfig = new SensorParserConfig();    snortConfig.setSensorTopic("snort");    when(configs.getSensorParserConfig("snort")).thenReturn(snortConfig);    KafkaWriter suppliedTopicWriter = mock(KafkaWriter.class);    when(kafkaWriter.withTopic("supplied_topic")).thenReturn(suppliedTopicWriter);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("snort", snortConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.of("supplied_topic"));    assertEquals(1, writerConfigs.size());    assertEquals(suppliedTopicWriter, writerConfigs.get("snort").getBulkMessageWriter());    verify(suppliedTopicWriter, times(1)).configure(eq("snort"), any(ParserWriterConfiguration.class));    verifyNoMoreInteractions(suppliedTopicWriter);}
public void metron_f6789_0()
{    SensorParserConfig yafConfig = new SensorParserConfig();    yafConfig.setSensorTopic("yaf");    yafConfig.setWriterClassName("org.apache.metron.writer.NoopWriter");    when(configs.getSensorParserConfig("yaf")).thenReturn(yafConfig);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("yaf", yafConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.empty());    assertEquals(1, writerConfigs.size());    assertTrue(writerConfigs.get("yaf").getBulkMessageWriter() instanceof NoopWriter);}
public CLIBuilder metron_f6790_0(ParserTopologyCLI.ParserOptions option, String val)
{    map.put(option, val);    return this;}
public CLIBuilder metron_f6791_0(ParserTopologyCLI.ParserOptions option)
{    map.put(option, null);    return this;}
public CommandLine metron_f6792_0(boolean longOpt) throws ParseException
{    return getCLI(map, longOpt);}
private CommandLine metron_f6793_0(EnumMap<ParserTopologyCLI.ParserOptions, String> options, boolean longOpt) throws ParseException
{    ArrayList<String> args = new ArrayList<>();    for (Map.Entry<ParserTopologyCLI.ParserOptions, String> option : options.entrySet()) {        boolean hasLongOpt = option.getKey().option.hasLongOpt();        if (hasLongOpt && longOpt) {            args.add("--" + option.getKey().option.getLongOpt());            if (option.getKey().option.hasArg() && option.getValue() != null) {                args.add(option.getValue());            }        } else if (hasLongOpt && !longOpt) {            args.add("-" + option.getKey().shortCode);            if (option.getKey().option.hasArg() && option.getValue() != null) {                args.add(option.getValue());            }        }    }    return ParserTopologyCLI.ParserOptions.parse(new PosixParser(), args.toArray(new String[args.size()]));}
public void metron_f6794_0() throws Exception
{    Set<String> optionStrs = new HashSet<>();    for (ParserTopologyCLI.ParserOptions option : ParserTopologyCLI.ParserOptions.values()) {        if (optionStrs.contains(option.option.getLongOpt())) {            throw new IllegalStateException("Reused long option: " + option.option.getLongOpt());        }        if (optionStrs.contains(option.shortCode)) {            throw new IllegalStateException("Reused short option: " + option.shortCode);        }        optionStrs.add(option.option.getLongOpt());        optionStrs.add(option.shortCode);    }}
public void metron_f6795_0() throws ParseException
{    kafkaOffset(true);    kafkaOffset(false);}
public void metron_f6796_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").build(longOpt);    Assert.assertEquals("myzk", ParserTopologyCLI.ParserOptions.ZK_QUORUM.get(cli));    Assert.assertEquals("mybroker", ParserTopologyCLI.ParserOptions.BROKER_URL.get(cli));    Assert.assertEquals("mysensor", ParserTopologyCLI.ParserOptions.SENSOR_TYPES.get(cli));}
public void metron_f6797_0() throws ParseException
{    happyPath(true);    happyPath(false);}
public void metron_f6798_0() throws ParseException
{    UnitTestHelper.setLog4jLevel(Parser.class, Level.FATAL);    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").build(true);    UnitTestHelper.setLog4jLevel(Parser.class, Level.ERROR);}
public void metron_f6799_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").build(longOpt);    Assert.assertEquals("myzk", ParserTopologyCLI.ParserOptions.ZK_QUORUM.get(cli));    Assert.assertEquals("mybroker", ParserTopologyCLI.ParserOptions.BROKER_URL.get(cli));    Assert.assertEquals("mysensor", ParserTopologyCLI.ParserOptions.SENSOR_TYPES.get(cli));}
public void metron_f6800_0() throws ParseException
{    testConfig_noExtra(true);    testConfig_noExtra(false);}
public void metron_f6801_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").with(ParserTopologyCLI.ParserOptions.NUM_WORKERS, "1").with(ParserTopologyCLI.ParserOptions.NUM_ACKERS, "2").with(ParserTopologyCLI.ParserOptions.NUM_MAX_TASK_PARALLELISM, "3").with(ParserTopologyCLI.ParserOptions.MESSAGE_TIMEOUT, "4").build(longOpt);    Optional<Config> configOptional = ParserTopologyCLI.ParserOptions.getConfig(cli);    Config config = configOptional.get();    Assert.assertEquals(1, config.get(Config.TOPOLOGY_WORKERS));    Assert.assertEquals(2, config.get(Config.TOPOLOGY_ACKER_EXECUTORS));    Assert.assertEquals(3, config.get(Config.TOPOLOGY_MAX_TASK_PARALLELISM));    Assert.assertEquals(4, config.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS));}
public void metron_f6802_0() throws Exception
{    testOutputTopic(true);    testOutputTopic(false);}
public void metron_f6803_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").with(ParserTopologyCLI.ParserOptions.OUTPUT_TOPIC, "my_topic").build(longOpt);    Assert.assertEquals("my_topic", ParserTopologyCLI.ParserOptions.OUTPUT_TOPIC.get(cli));}
public void metron_f6804_0() throws Exception
{    testConfig_extra(true);    testConfig_extra(false);}
public void metron_f6805_0(boolean longOpt) throws IOException, ParseException
{    File extraFile = File.createTempFile("extra", "json");    try {        FileUtils.write(extraFile, extraConfig);        CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").with(ParserTopologyCLI.ParserOptions.MESSAGE_TIMEOUT, "4").with(ParserTopologyCLI.ParserOptions.EXTRA_OPTIONS, extraFile.getAbsolutePath()).build(longOpt);        Optional<Config> configOptional = ParserTopologyCLI.ParserOptions.getConfig(cli);        Config config = configOptional.get();        Assert.assertEquals(4, config.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS));        Assert.assertEquals("foo", config.get("string"));        Assert.assertEquals(1, config.get("integer"));    } finally {        extraFile.deleteOnExit();    }}
public List<Integer> metron_f6806_0()
{    return spoutParallelism;}
public List<Integer> metron_f6807_0()
{    return spoutNumTasks;}
public Integer metron_f6808_0()
{    return parserParallelism;}
public Integer metron_f6809_0()
{    return parserNumTasks;}
public Integer metron_f6810_0()
{    return errorParallelism;}
public Integer metron_f6811_0()
{    return errorNumTasks;}
public List<Map<String, Object>> metron_f6812_0()
{    return spoutConfig;}
public String metron_f6813_0()
{    return securityProtocol;}
public Config metron_f6814_0()
{    return stormConf;}
public String metron_f6815_0()
{    return outputTopic;}
public String metron_f6816_0()
{    return errorTopic;}
private static SensorParserConfig metron_f6817_0()
{    try {        return JSONUtils.INSTANCE.load(baseConfig, SensorParserConfig.class);    } catch (IOException e) {        throw new IllegalStateException(e.getMessage(), e);    }}
public void metron_f6818_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_PARALLELISM, "10", input -> input.getSpoutParallelism().equals(Collections.singletonList(10)), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutParallelism(20);        return Collections.singletonList(config);    }, input -> input.getSpoutParallelism().equals(Collections.singletonList(20)));}
public void metron_f6819_0() throws Exception
{            List<Integer> spoutParCli = new ArrayList<>();    spoutParCli.add(10);    spoutParCli.add(12);    List<Integer> spoutParConfig = new ArrayList<>();    spoutParConfig.add(20);    spoutParConfig.add(30);    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_PARALLELISM, "10,12", input -> input.getSpoutParallelism().equals(spoutParCli), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutParallelism(20);        SensorParserConfig config2 = getBaseConfig();        config2.setSpoutParallelism(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getSpoutParallelism().equals(spoutParConfig));}
public void metron_f6820_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_NUM_TASKS, "10", input -> input.getSpoutNumTasks().equals(Collections.singletonList(10)), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutNumTasks(20);        return Collections.singletonList(config);    }, input -> input.getSpoutNumTasks().equals(Collections.singletonList(20)));}
public void metron_f6821_0() throws Exception
{        List<Integer> numTasksCli = new ArrayList<>();    numTasksCli.add(10);    numTasksCli.add(12);    List<Integer> numTasksConfig = new ArrayList<>();    numTasksConfig.add(20);    numTasksConfig.add(30);    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_NUM_TASKS, "10,12", input -> input.getSpoutNumTasks().equals(numTasksCli), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutNumTasks(20);        SensorParserConfig config2 = getBaseConfig();        config2.setSpoutNumTasks(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getSpoutNumTasks().equals(numTasksConfig));}
public void metron_f6822_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_PARALLELISM, "10", input -> input.getParserParallelism().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserParallelism(20);        return Collections.singletonList(config);    }, input -> input.getParserParallelism().equals(20));}
public void metron_f6823_0() throws Exception
{        testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_PARALLELISM, "10", input -> input.getParserParallelism().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserParallelism(20);        SensorParserConfig config2 = getBaseConfig();        config2.setParserParallelism(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getParserParallelism().equals(30));}
public void metron_f6824_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_NUM_TASKS, "10", input -> input.getParserNumTasks().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserNumTasks(20);        SensorParserConfig config2 = getBaseConfig();        config2.setParserNumTasks(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getParserNumTasks().equals(30));}
public void metron_f6825_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_NUM_TASKS, "10", input -> input.getParserNumTasks().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserNumTasks(20);        return Collections.singletonList(config);    }, input -> input.getParserNumTasks().equals(20));}
public void metron_f6826_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.ERROR_WRITER_PARALLELISM, "10", input -> input.getErrorParallelism().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setErrorWriterParallelism(20);        return Collections.singletonList(config);    }, input -> input.getErrorParallelism().equals(20));}
public void metron_f6827_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.ERROR_WRITER_NUM_TASKS, "10", input -> input.getErrorNumTasks().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setErrorWriterNumTasks(20);        return Collections.singletonList(config);    }, input -> input.getErrorNumTasks().equals(20));}
public void metron_f6828_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT", input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {        SensorParserConfig config = getBaseConfig();        config.setSecurityProtocol("KERBEROS");        return Collections.singletonList(config);    }, input -> input.getSecurityProtocol().equals("KERBEROS"));}
public void metron_f6829_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT", input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {        SensorParserConfig config = getBaseConfig();        config.setSecurityProtocol("PLAINTEXT");        SensorParserConfig config2 = getBaseConfig();        config2.setSecurityProtocol("PLAINTEXT");        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getSecurityProtocol().equals("PLAINTEXT"));}
public void metron_f6830_0() throws Exception
{        testConfigOption(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT", input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {        SensorParserConfig config = getBaseConfig();        config.setSecurityProtocol("PLAINTEXT");        SensorParserConfig config2 = getBaseConfig();        config2.setSecurityProtocol("KERBEROS");        SensorParserConfig config3 = getBaseConfig();        config3.setSecurityProtocol("PLAINTEXT");        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        configs.add(config3);        return configs;    }, input -> input.getSecurityProtocol().equals("KERBEROS"));}
public void metron_f6831_0() throws Exception
{        File extraConfig = File.createTempFile("spoutConfig", "json");    extraConfig.deleteOnExit();    writeMap(extraConfig, new HashMap<String, Object>() {        {            put("security.protocol", "PLAINTEXTSASL");        }    });    {                testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {            {                put(ParserTopologyCLI.ParserOptions.SPOUT_CONFIG, extraConfig.getAbsolutePath());                put(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT");            }        }, input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {            SensorParserConfig config = getBaseConfig();            config.setSecurityProtocol("PLAINTEXTSASL_FROM_ZK");            return Collections.singletonList(config);        }, input -> input.getSecurityProtocol().equals("PLAINTEXTSASL_FROM_ZK"));    }    {                testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {            {                put(ParserTopologyCLI.ParserOptions.SPOUT_CONFIG, extraConfig.getAbsolutePath());            }        }, input -> input.getSecurityProtocol().equals("PLAINTEXTSASL"), () -> {            SensorParserConfig config = getBaseConfig();            config.setSecurityProtocol("PLAINTEXTSASL_FROM_ZK");            return Collections.singletonList(config);        }, input -> input.getSecurityProtocol().equals("PLAINTEXTSASL_FROM_ZK"));    }}
public void metron_f6832_0() throws Exception
{    testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(ParserTopologyCLI.ParserOptions.NUM_WORKERS, "10");            put(ParserTopologyCLI.ParserOptions.NUM_ACKERS, "20");        }    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 10 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 20;    }, () -> {        SensorParserConfig config = getBaseConfig();        config.setNumWorkers(100);        config.setNumAckers(200);        return Collections.singletonList(config);    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 100 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 200;    });}
public void metron_f6833_0() throws Exception
{    File extraConfig = File.createTempFile("topologyConfig", "json");    extraConfig.deleteOnExit();    writeMap(extraConfig, new HashMap<String, Object>() {        {            put(Config.TOPOLOGY_DEBUG, true);        }    });    testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(ParserTopologyCLI.ParserOptions.NUM_WORKERS, "10");            put(ParserTopologyCLI.ParserOptions.NUM_ACKERS, "20");            put(ParserTopologyCLI.ParserOptions.EXTRA_OPTIONS, extraConfig.getAbsolutePath());        }    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 10 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 20 && (boolean) c.get(Config.TOPOLOGY_DEBUG);    }, () -> {        SensorParserConfig config = getBaseConfig();        config.setStormConfig(new HashMap<String, Object>() {            {                put(Config.TOPOLOGY_WORKERS, 100);                put(Config.TOPOLOGY_ACKER_EXECUTORS, 200);            }        });        return Collections.singletonList(config);    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 100 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 200 && !c.containsKey(Config.TOPOLOGY_DEBUG);    });}
public void metron_f6834_0() throws Exception
{    File extraConfig = File.createTempFile("spoutConfig", "json");    extraConfig.deleteOnExit();    writeMap(extraConfig, new HashMap<String, Object>() {        {            put("extra_config", "from_file");        }    });    EnumMap<ParserTopologyCLI.ParserOptions, String> cliOptions = new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(ParserTopologyCLI.ParserOptions.SPOUT_CONFIG, extraConfig.getAbsolutePath());        }    };    Predicate<ParserInput> cliOverrideExpected = input -> {        return input.getSpoutConfig().get(0).get("extra_config").equals("from_file");    };    Predicate<ParserInput> configOverrideExpected = input -> {        return input.getSpoutConfig().get(0).get("extra_config").equals("from_zk");    };    Supplier<List<SensorParserConfig>> configSupplier = () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutConfig(new HashMap<String, Object>() {            {                put("extra_config", "from_zk");            }        });        return Collections.singletonList(config);    };    testConfigOption(cliOptions, cliOverrideExpected, configSupplier, configOverrideExpected);}
private void metron_f6835_0(File outFile, Map<String, Object> config) throws IOException
{    FileUtils.write(outFile, JSONUtils.INSTANCE.toJSON(config, true));}
private void metron_f6836_0(ParserTopologyCLI.ParserOptions option, String cliOverride, Predicate<ParserInput> cliOverrideCondition, Supplier<List<SensorParserConfig>> configSupplier, Predicate<ParserInput> configOverrideCondition) throws Exception
{    testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(option, cliOverride);        }    }, cliOverrideCondition, configSupplier, configOverrideCondition);}
private void metron_f6837_0(EnumMap<ParserTopologyCLI.ParserOptions, String> options, Predicate<ParserInput> cliOverrideCondition, Supplier<List<SensorParserConfig>> configSupplier, Predicate<ParserInput> configOverrideCondition) throws Exception
{        List<SensorParserConfig> configs = configSupplier.get();    {        CLIBuilder builder = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor");        for (Map.Entry<ParserTopologyCLI.ParserOptions, String> entry : options.entrySet()) {            builder.with(entry.getKey(), entry.getValue());        }        CommandLine cmd = builder.build(true);        ParserInput input = getInput(cmd, configs);        Assert.assertTrue(cliOverrideCondition.test(input));    }        {        CLIBuilder builder = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor");        CommandLine cmd = builder.build(true);        ParserInput input = getInput(cmd, configs);        Assert.assertTrue(configOverrideCondition.test(input));    }}
private static ParserInput metron_f6838_0(CommandLine cmd, List<SensorParserConfig> configs) throws Exception
{    final ParserInput[] parserInput = new ParserInput[] { null };    new ParserTopologyCLI() {        @Override        protected ParserTopologyBuilder.ParserTopology getParserTopology(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorType, ValueSupplier<List> spoutParallelism, ValueSupplier<List> spoutNumTasks, ValueSupplier<Integer> parserParallelism, ValueSupplier<Integer> parserNumTasks, ValueSupplier<Integer> errorParallelism, ValueSupplier<Integer> errorNumTasks, ValueSupplier<List> spoutConfig, ValueSupplier<String> securityProtocol, ValueSupplier<Config> stormConf, ValueSupplier<String> outputTopic, ValueSupplier<String> errorTopic) throws Exception {            parserInput[0] = new ParserInput(spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, stormConf, outputTopic, errorTopic, configs);            return null;        }    }.createParserTopology(cmd);    return parserInput[0];}
protected ParserTopologyBuilder.ParserTopology metron_f6839_0(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorType, ValueSupplier<List> spoutParallelism, ValueSupplier<List> spoutNumTasks, ValueSupplier<Integer> parserParallelism, ValueSupplier<Integer> parserNumTasks, ValueSupplier<Integer> errorParallelism, ValueSupplier<Integer> errorNumTasks, ValueSupplier<List> spoutConfig, ValueSupplier<String> securityProtocol, ValueSupplier<Config> stormConf, ValueSupplier<String> outputTopic, ValueSupplier<String> errorTopic) throws Exception
{    parserInput[0] = new ParserInput(spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, stormConf, outputTopic, errorTopic, configs);    return null;}
public void metron_f6840_0() throws UnableToStartException, IOException
{    final String sensorType = "dummy";        final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("col11,col12,col13"));            add(Bytes.toBytes("col21,col22,col23"));            add(Bytes.toBytes("col31,col32,col33"));        }    };        MockHBaseTableProvider.addToCache(sensorType, "cf");    final Properties topologyProperties = new Properties();    final ZKServerComponent zkServerComponent = getZKServerComponent(topologyProperties);    final KafkaComponent kafkaComponent = getKafkaComponent(topologyProperties, new ArrayList<KafkaComponent.Topic>() {        {            add(new KafkaComponent.Topic(sensorType, 1));        }    });    topologyProperties.setProperty("kafka.broker", kafkaComponent.getBrokerList());    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(parserConfigJSON, SensorParserConfig.class);    System.out.println("Workspace: " + System.getProperty("user.dir"));    System.out.println("Configs path: ../" + TestConstants.SAMPLE_CONFIG_PATH);    ConfigUploadComponent configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties).withGlobalConfigsPath("../" + TestConstants.SAMPLE_CONFIG_PATH).withParserSensorConfig(sensorType, parserConfig);    ParserTopologyComponent parserTopologyComponent = new ParserTopologyComponent.Builder().withSensorTypes(Collections.singletonList(sensorType)).withTopologyProperties(topologyProperties).withBrokerUrl(kafkaComponent.getBrokerList()).withOutputTopic(parserConfig.getOutputTopic()).build();    ComponentRunner runner = new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("org/apache/storm", parserTopologyComponent).withMillisecondsBetweenAttempts(5000).withCustomShutdownOrder(new String[] { "org/apache/storm", "config", "kafka", "zk" }).withNumRetries(10).build();    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        ProcessorResult<List<LookupKV<EnrichmentKey, EnrichmentValue>>> result = runner.process(new Processor<List<LookupKV<EnrichmentKey, EnrichmentValue>>>() {            List<LookupKV<EnrichmentKey, EnrichmentValue>> messages = null;            @Override            public ReadinessState process(ComponentRunner runner) {                MockHTable table = (MockHTable) MockHBaseTableProvider.getFromCache(sensorType);                if (table != null && table.size() == inputMessages.size()) {                    EnrichmentConverter converter = new EnrichmentConverter();                    messages = new ArrayList<>();                    try {                        for (Result r : table.getScanner(Bytes.toBytes("cf"))) {                            messages.add(converter.fromResult(r, "cf"));                        }                    } catch (IOException e) {                    }                    return ReadinessState.READY;                }                return ReadinessState.NOT_READY;            }            @Override            public ProcessorResult<List<LookupKV<EnrichmentKey, EnrichmentValue>>> getResult() {                ProcessorResult.Builder<List<LookupKV<EnrichmentKey, EnrichmentValue>>> builder = new ProcessorResult.Builder();                return builder.withResult(messages).build();            }        });        Set<String> validIndicators = new HashSet<>(ImmutableList.of("col12", "col22", "col32"));        Map<String, Map<String, String>> validMetadata = new HashMap<String, Map<String, String>>() {            {                put("col12", new HashMap<String, String>() {                    {                        put("col1", "col11");                        put("col3", "col13");                    }                });                put("col22", new HashMap<String, String>() {                    {                        put("col1", "col21");                        put("col3", "col23");                    }                });                put("col32", new HashMap<String, String>() {                    {                        put("col1", "col31");                        put("col3", "col33");                    }                });            }        };        for (LookupKV<EnrichmentKey, EnrichmentValue> kv : result.getResult()) {            Assert.assertTrue(validIndicators.contains(kv.getKey().indicator));            Assert.assertEquals(kv.getValue().getMetadata().get("source.type"), "dummy");            Assert.assertNotNull(kv.getValue().getMetadata().get("timestamp"));            Assert.assertNotNull(kv.getValue().getMetadata().get("original_string"));            Map<String, String> metadata = validMetadata.get(kv.getKey().indicator);            for (Map.Entry<String, String> x : metadata.entrySet()) {                Assert.assertEquals(kv.getValue().getMetadata().get(x.getKey()), x.getValue());            }            Assert.assertEquals(metadata.size() + 4, kv.getValue().getMetadata().size());        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public ReadinessState metron_f6841_0(ComponentRunner runner)
{    MockHTable table = (MockHTable) MockHBaseTableProvider.getFromCache(sensorType);    if (table != null && table.size() == inputMessages.size()) {        EnrichmentConverter converter = new EnrichmentConverter();        messages = new ArrayList<>();        try {            for (Result r : table.getScanner(Bytes.toBytes("cf"))) {                messages.add(converter.fromResult(r, "cf"));            }        } catch (IOException e) {        }        return ReadinessState.READY;    }    return ReadinessState.NOT_READY;}
public ProcessorResult<List<LookupKV<EnrichmentKey, EnrichmentValue>>> metron_f6842_0()
{    ProcessorResult.Builder<List<LookupKV<EnrichmentKey, EnrichmentValue>>> builder = new ProcessorResult.Builder();    return builder.withResult(messages).build();}
public void metron_f6843_0() throws IOException
{    ParserDriver driver = new StormParserDriver("test", parserConfig_default, "{}");    super.testEnvelopedData(driver);}
public void metron_f6844_0() throws IOException
{    ParserDriver driver = new StormParserDriver("test", parserConfig_withPrefix, "{}");    super.testEnvelopedData_withMetadataPrefix(driver);}
public void metron_f6845_0() throws IOException
{    ParserDriver driver = new StormParserDriver("test", parserConfig_nomerge, "{}");    super.testEnvelopedData_noMergeMetadata(driver);}
public void metron_f6846_0() throws Exception
{    ParserDriver syslogDriver = new StormParserDriver("ciscoPix", ciscoPixSyslogConfig, "{}");    ParserDriver driver = new StormParserDriver("cisco302020", cisco302020Config, "{}");    super.testCiscoPixEnvelopingCisco302020(syslogDriver, driver);}
public boolean metron_f6847_0(Map<String, Object> input, Map<String, Object> validationConfig, Map<String, Object> globalConfig, Context context)
{    if (input.get("action") != null && input.get("action").equals("invalid")) {        return false;    }    return true;}
public void metron_f6848_0(Map<String, Object> validationConfig, Map<String, Object> globalConfig)
{}
public void metron_f6849_0() throws Exception
{    final String sensorType = "dummy";    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(parserConfigJSONKafkaRedirection, SensorParserConfig.class);    final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("metron,foo"));            add(Bytes.toBytes("notmetron,foo"));            add(Bytes.toBytes("metron,bar"));            add(Bytes.toBytes("metron,baz"));        }    };    final Properties topologyProperties = new Properties();    ComponentRunner runner = setupTopologyComponents(topologyProperties, Collections.singletonList(sensorType), Collections.singletonList(parserConfig), globalConfigWithValidation);    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        KafkaProcessor<Map<String, List<JSONObject>>> kafkaProcessor = getKafkaProcessor(parserConfig.getOutputTopic(), parserConfig.getErrorTopic(), kafkaMessageSet -> kafkaMessageSet.getMessages().size() == 3 && kafkaMessageSet.getErrors().isEmpty());        ProcessorResult<Map<String, List<JSONObject>>> result = runner.process(kafkaProcessor);                Map<String, List<JSONObject>> outputMessages = result.getResult();        for (JSONObject j : outputMessages.get(Constants.ENRICHMENT_TOPIC)) {            Assert.assertEquals("metron", j.get("name"));            Assert.assertEquals("output", j.get("route_field"));            Assert.assertTrue(ImmutableSet.of("foo", "bar", "baz").contains(j.get("dummy")));        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public void metron_f6850_0() throws Exception
{    final String sensorType = "dummy";    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(parserConfigJSON, SensorParserConfig.class);    final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("valid,foo"));            add(Bytes.toBytes("invalid,foo"));            add(Bytes.toBytes("error"));        }    };    final Properties topologyProperties = new Properties();    ComponentRunner runner = setupTopologyComponents(topologyProperties, Collections.singletonList(sensorType), Collections.singletonList(parserConfig), globalConfigWithValidation);    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        KafkaProcessor<Map<String, List<JSONObject>>> kafkaProcessor = getKafkaProcessor(parserConfig.getOutputTopic(), parserConfig.getErrorTopic());        ProcessorResult<Map<String, List<JSONObject>>> result = runner.process(kafkaProcessor);                Map<String, List<JSONObject>> outputMessages = result.getResult();        Assert.assertEquals(2, outputMessages.size());        Assert.assertEquals(1, outputMessages.get(Constants.ENRICHMENT_TOPIC).size());        Assert.assertEquals("valid", outputMessages.get(Constants.ENRICHMENT_TOPIC).get(0).get("action"));        Assert.assertEquals(2, outputMessages.get(parserConfig.getErrorTopic()).size());                JSONObject invalidMessage = outputMessages.get(parserConfig.getErrorTopic()).get(0);        Assert.assertEquals(Constants.ErrorType.PARSER_INVALID.getType(), invalidMessage.get(Constants.ErrorFields.ERROR_TYPE.getName()));        JSONObject rawMessage = JSONUtils.INSTANCE.load((String) invalidMessage.get(Constants.ErrorFields.RAW_MESSAGE.getName()), JSONObject.class);        Assert.assertEquals("foo", rawMessage.get("dummy"));        Assert.assertEquals("invalid", rawMessage.get("action"));                JSONObject errorMessage = outputMessages.get(parserConfig.getErrorTopic()).get(1);        Assert.assertEquals(Constants.ErrorType.PARSER_ERROR.getType(), errorMessage.get(Constants.ErrorFields.ERROR_TYPE.getName()));        Assert.assertEquals("error", errorMessage.get(Constants.ErrorFields.RAW_MESSAGE.getName()));    } finally {        if (runner != null) {            runner.stop();        }    }}
public ComponentRunner metron_f6851_0(Properties topologyProperties, List<String> sensorTypes, List<SensorParserConfig> parserConfigs, String globalConfig)
{    zkServerComponent = getZKServerComponent(topologyProperties);    List<KafkaComponent.Topic> topics = new ArrayList<>();    for (String sensorType : sensorTypes) {        topics.add(new KafkaComponent.Topic(sensorType, 1));    }    topics.add(new KafkaComponent.Topic(Constants.ENRICHMENT_TOPIC, 1));    kafkaComponent = getKafkaComponent(topologyProperties, topics);    topologyProperties.setProperty("kafka.broker", kafkaComponent.getBrokerList());    configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties).withGlobalConfig(globalConfig);    for (int i = 0; i < sensorTypes.size(); ++i) {        configUploadComponent.withParserSensorConfig(sensorTypes.get(i), parserConfigs.get(i));    }    parserTopologyComponent = new ParserTopologyComponent.Builder().withSensorTypes(sensorTypes).withTopologyProperties(topologyProperties).withBrokerUrl(kafkaComponent.getBrokerList()).withErrorTopic(parserConfigs.get(0).getErrorTopic()).withOutputTopic(parserConfigs.get(0).getOutputTopic()).build();    return new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("org/apache/storm", parserTopologyComponent).withMillisecondsBetweenAttempts(5000).withNumRetries(10).withCustomShutdownOrder(new String[] { "org/apache/storm", "config", "kafka", "zk" }).build();}
private KafkaProcessor<Map<String, List<JSONObject>>> metron_f6852_0(String outputTopic, String errorTopic)
{    return getKafkaProcessor(outputTopic, errorTopic, messageSet -> (messageSet.getMessages().size() == 1) && (messageSet.getErrors().size() == 2));}
private KafkaProcessor<Map<String, List<JSONObject>>> metron_f6853_0(String outputTopic, String errorTopic, Predicate<KafkaMessageSet> predicate)
{    return new KafkaProcessor<>().withKafkaComponentName("kafka").withReadTopic(outputTopic).withErrorTopic(errorTopic).withValidateReadMessages(new Function<KafkaMessageSet, Boolean>() {        @Nullable        @Override        public Boolean apply(@Nullable KafkaMessageSet messageSet) {            return predicate.test(messageSet);        }    }).withProvideResult(new Function<KafkaMessageSet, Map<String, List<JSONObject>>>() {        @Nullable        @Override        public Map<String, List<JSONObject>> apply(@Nullable KafkaMessageSet messageSet) {            return new HashMap<String, List<JSONObject>>() {                {                    put(Constants.ENRICHMENT_TOPIC, loadMessages(messageSet.getMessages()));                    put(errorTopic, loadMessages(messageSet.getErrors()));                }            };        }    });}
public Boolean metron_f6854_0(@Nullable KafkaMessageSet messageSet)
{    return predicate.test(messageSet);}
public Map<String, List<JSONObject>> metron_f6855_0(@Nullable KafkaMessageSet messageSet)
{    return new HashMap<String, List<JSONObject>>() {        {            put(Constants.ENRICHMENT_TOPIC, loadMessages(messageSet.getMessages()));            put(errorTopic, loadMessages(messageSet.getErrors()));        }    };}
private static List<JSONObject> metron_f6856_0(List<byte[]> outputMessages)
{    List<JSONObject> tmp = new ArrayList<>();    Iterables.addAll(tmp, Iterables.transform(outputMessages, message -> {        try {            return new JSONObject(JSONUtils.INSTANCE.load(new String(message, StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER));        } catch (Exception ex) {            throw new IllegalStateException(ex);        }    }));    return tmp;}
public void metron_f6857_0() throws Exception
{    final String sensorType = "emptyobjectparser";    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(offsetParserConfigJSON, SensorParserConfig.class);    final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("foo"));            add(Bytes.toBytes("bar"));            add(Bytes.toBytes("baz"));        }    };    final Properties topologyProperties = new Properties();    ComponentRunner runner = setupTopologyComponents(topologyProperties, Collections.singletonList(sensorType), Collections.singletonList(parserConfig), globalConfigEmpty);    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        Processor allResultsProcessor = new AllResultsProcessor(inputMessages, Constants.ENRICHMENT_TOPIC);        ProcessorResult<Set<JSONObject>> result = runner.process(allResultsProcessor);                assertThat("size should match", result.getResult().size(), equalTo(inputMessages.size()));        for (JSONObject record : result.getResult()) {            assertThat("record should have a guid", record.containsKey("guid"), equalTo(true));            assertThat("record should have correct source.type", record.get("source.type"), equalTo(sensorType));        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public void metron_f6858_0() throws Exception
{        final String emptyObjectSensorType = "emptyobjectparser";    SensorParserConfig emptyObjectParserConfig = JSONUtils.INSTANCE.load(offsetParserConfigJSON, SensorParserConfig.class);    final List<byte[]> emptyObjectInputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("foo"));            add(Bytes.toBytes("bar"));            add(Bytes.toBytes("baz"));        }    };        final String dummySensorType = "dummyobjectparser";    SensorParserConfig dummyParserConfig = JSONUtils.INSTANCE.load(dummyParserConfigJSON, SensorParserConfig.class);    final List<byte[]> dummyInputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("dummy_foo"));            add(Bytes.toBytes("dummy_bar"));            add(Bytes.toBytes("dummy_baz"));        }    };    final Properties topologyProperties = new Properties();    List<String> sensorTypes = new ArrayList<>();    sensorTypes.add(emptyObjectSensorType);    sensorTypes.add(dummySensorType);    List<SensorParserConfig> parserConfigs = new ArrayList<>();    parserConfigs.add(emptyObjectParserConfig);    parserConfigs.add(dummyParserConfig);    ComponentRunner runner = setupTopologyComponents(topologyProperties, sensorTypes, parserConfigs, globalConfigEmpty);    try {        runner.start();        kafkaComponent.writeMessages(emptyObjectSensorType, emptyObjectInputMessages);        kafkaComponent.writeMessages(dummySensorType, dummyInputMessages);        final List<byte[]> allInputMessages = new ArrayList<>();        allInputMessages.addAll(emptyObjectInputMessages);        allInputMessages.addAll(dummyInputMessages);        Processor allResultsProcessor = new AllResultsProcessor(allInputMessages, Constants.ENRICHMENT_TOPIC);        @SuppressWarnings("unchecked")        ProcessorResult<Set<JSONObject>> result = runner.process(allResultsProcessor);                assertThat("size should match", result.getResult().size(), equalTo(allInputMessages.size()));        for (JSONObject record : result.getResult()) {            assertThat("record should have a guid", record.containsKey("guid"), equalTo(true));        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public void metron_f6859_0()
{}
public List<JSONObject> metron_f6860_0(byte[] bytes)
{    return ImmutableList.of(new JSONObject());}
public boolean metron_f6861_0(JSONObject message)
{    return true;}
public void metron_f6862_0(Map<String, Object> map)
{}
public void metron_f6863_0()
{}
public List<JSONObject> metron_f6864_0(byte[] bytes)
{    JSONObject dummy = new JSONObject();    dummy.put("dummy_key", "dummy_value");    return ImmutableList.of(dummy);}
public boolean metron_f6865_0(JSONObject message)
{    return true;}
public void metron_f6866_0(Map<String, Object> map)
{}
public ReadinessState metron_f6867_0(ComponentRunner runner)
{    KafkaComponent kc = runner.getComponent("kafka", KafkaComponent.class);    outputMessages.addAll(readMessagesFromKafka(kc, outputKafkaTopic));    return calcReadiness(inputMessages.size(), outputMessages.size());}
private Set<JSONObject> metron_f6868_0(KafkaComponent kc, String topic)
{    Set<JSONObject> out = new HashSet<>();    for (byte[] b : kc.readMessages(topic)) {        try {            JSONObject m = new JSONObject(JSONUtils.INSTANCE.load(new String(b, StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER));            out.add(m);        } catch (IOException e) {            throw new IllegalStateException(e);        }    }    return out;}
private ReadinessState metron_f6869_0(int in, int out)
{    return in == out ? ReadinessState.READY : ReadinessState.NOT_READY;}
public ProcessorResult<Set<JSONObject>> metron_f6870_0()
{    return new ProcessorResult<>(outputMessages, null);}
public Map<String, String> metron_f6871_0()
{    return PcapOptions.FIELDS.get(this, Map.class);}
public void metron_f6872_0(Map<String, String> fixedFields)
{    PcapOptions.FIELDS.put(this, fixedFields);}
public void metron_f6873_0(String key, String value)
{    Map<String, String> fixedFields = PcapOptions.FIELDS.get(this, Map.class);    String trimmedVal = value != null ? value.trim() : null;    if (!isNullOrEmpty(trimmedVal)) {        fixedFields.put(key, value);    }}
public Object metron_f6874_0(ConfigOption option)
{    Object o = get(option.getKey());    return option.transform().apply(option.getKey(), o);}
public String metron_f6875_0()
{    return PcapOptions.FINAL_FILENAME_PREFIX.get(this, String.class);}
public void metron_f6876_0(String prefix)
{    PcapOptions.FINAL_FILENAME_PREFIX.put(this, prefix);}
public int metron_f6877_0()
{    return PcapOptions.NUM_REDUCERS.get(this, Integer.class);}
public boolean metron_f6878_0()
{    return showHelp;}
public void metron_f6879_0(boolean showHelp)
{    this.showHelp = showHelp;}
public boolean metron_f6880_0()
{    return PcapOptions.PRINT_JOB_STATUS.get(this, Boolean.class);}
public void metron_f6881_0(boolean printJobStatus)
{    PcapOptions.PRINT_JOB_STATUS.put(this, printJobStatus);}
public String metron_f6882_0()
{    return PcapOptions.BASE_PATH.get(this, String.class);}
public String metron_f6883_0()
{    return PcapOptions.BASE_INTERIM_RESULT_PATH.get(this, String.class);}
public long metron_f6884_0()
{    return PcapOptions.START_TIME_MS.get(this, Long.class);}
public long metron_f6885_0()
{    return PcapOptions.END_TIME_MS.get(this, Long.class);}
public void metron_f6886_0(String basePath)
{    PcapOptions.BASE_PATH.put(this, basePath);}
public void metron_f6887_0(String baseOutputPath)
{    PcapOptions.BASE_INTERIM_RESULT_PATH.put(this, baseOutputPath);}
public void metron_f6888_0(long startTime)
{    PcapOptions.START_TIME_MS.put(this, startTime);}
public void metron_f6889_0(long endTime)
{    PcapOptions.END_TIME_MS.put(this, endTime);}
public boolean metron_f6890_0(String val)
{    return StringUtils.isEmpty(val);}
public void metron_f6891_0(String dateFormat)
{    this.dateFormat = new SimpleDateFormat(dateFormat);}
public DateFormat metron_f6892_0()
{    return dateFormat;}
public void metron_f6893_0(int numReducers)
{    PcapOptions.NUM_REDUCERS.put(this, numReducers);}
public int metron_f6894_0()
{    return PcapOptions.NUM_RECORDS_PER_FILE.get(this, Integer.class);}
public void metron_f6895_0(int numRecordsPerFile)
{    PcapOptions.NUM_RECORDS_PER_FILE.put(this, numRecordsPerFile);}
public void metron_f6896_0(String yarnQueue)
{    this.yarnQueue = yarnQueue;}
public Optional<String> metron_f6897_0()
{    return Optional.ofNullable(yarnQueue);}
public void metron_f6898_0(String numThreads)
{    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(this, numThreads);}
public String metron_f6899_0()
{    return key;}
public BiFunction<String, Object, Object> metron_f6900_0()
{    return transform;}
public String metron_f6901_0()
{    return PcapOptions.FIELDS.get(this, String.class);}
public void metron_f6902_0(String query)
{    PcapOptions.FIELDS.put(this, query);}
public void metron_f6903_0(Map<String, String> fields, Configuration conf)
{    for (Map.Entry<String, String> kv : fields.entrySet()) {        conf.set(kv.getKey(), kv.getValue());    }    conf.set(PCAP_FILTER_NAME_CONF, PcapFilters.FIXED.name());}
public String metron_f6904_0(Map<String, String> fields)
{    return (fields == null ? "" : Joiner.on("_").join(fields.values()).replaceAll("\\s", "_"));}
public void metron_f6905_0(Iterable<Map.Entry<String, String>> config)
{    for (Map.Entry<String, String> kv : config) {        if (kv.getKey().equals(Constants.Fields.DST_ADDR.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.dstAddr = kv.getValue();            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.SRC_ADDR.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.srcAddr = kv.getValue();            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.DST_PORT.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.dstPort = Integer.parseInt(kv.getValue());            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.SRC_PORT.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.srcPort = Integer.parseInt(kv.getValue());            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.PROTOCOL.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.protocol = kv.getValue();            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.includesReverseTraffic = Boolean.parseBoolean(kv.getValue());        }        if (kv.getKey().equals(PcapHelper.PacketFields.PACKET_FILTER.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.packetFilter = kv.getValue();        }    }}
public boolean metron_f6906_0(PacketInfo pi)
{    Map<String, Object> fields = packetToFields(pi);    VariableResolver resolver = new MapVariableResolver(fields);    String srcAddrIn = (String) resolver.resolve(Constants.Fields.SRC_ADDR.getName());    Integer srcPortIn = (Integer) resolver.resolve(Constants.Fields.SRC_PORT.getName());    String dstAddrIn = (String) resolver.resolve(Constants.Fields.DST_ADDR.getName());    Integer dstPortIn = (Integer) resolver.resolve(Constants.Fields.DST_PORT.getName());    String protocolIn = "" + resolver.resolve(Constants.Fields.PROTOCOL.getName());    if (!doHeaderFiltering || testHeader(srcAddrIn, srcPortIn, dstAddrIn, dstPortIn, protocolIn)) {                if (packetFilter != null) {                        byte[] data = (byte[]) resolver.resolve(PcapHelper.PacketFields.PACKET_DATA.getName());            try {                return ByteArrayMatchingUtil.INSTANCE.match(packetFilter, data);            } catch (ExecutionException e) {                throw new IllegalStateException("Unable to perform binary filter: " + packetFilter + " on " + DatatypeConverter.printHexBinary(data), e);            }        } else if (!doHeaderFiltering) {                        return true;        } else {                        return true;        }    } else {                return false;    }}
private boolean metron_f6907_0(String srcAddrIn, Integer srcPortIn, String dstAddrIn, Integer dstPortIn, String protocolIn)
{    if (areMatch(protocol, protocolIn)) {        if (matchesSourceAndDestination(srcAddrIn, srcPortIn, dstAddrIn, dstPortIn)) {            return true;        } else if (includesReverseTraffic) {            return matchesReverseSourceAndDestination(srcAddrIn, srcPortIn, dstAddrIn, dstPortIn);        }    }    return false;}
private boolean metron_f6908_0(Integer filter, Integer input)
{    return filter == null || areMatch(Integer.toUnsignedString(filter), input == null ? null : Integer.toUnsignedString(input));}
private boolean metron_f6909_0(String filter, String input)
{    if (filter != null) {        return input != null && input.equals(filter);    } else {        return true;    }}
protected Map<String, Object> metron_f6910_0(PacketInfo pi)
{    return PcapHelper.packetToFields(pi);}
private boolean metron_f6911_0(String srcAddrComp, Integer srcPortComp, String dstAddrComp, Integer dstPortComp)
{    boolean isMatch = true;    isMatch &= areMatch(this.srcAddr, srcAddrComp);    isMatch &= areMatch(this.srcPort, srcPortComp);    isMatch &= areMatch(this.dstAddr, dstAddrComp);    isMatch &= areMatch(this.dstPort, dstPortComp);    return isMatch;}
private boolean metron_f6912_0(String srcAddr, Integer srcPort, String dstAddr, Integer dstPort)
{    return matchesSourceAndDestination(dstAddr, dstPort, srcAddr, srcPort);}
public Object metron_f6913_0(String variable)
{    if (variable.equals(VariableResolver.ALL_FIELDS)) {        return new ConcatMap(ImmutableList.of(fieldsMap));    }    return fieldsMap.get(variable);}
public boolean metron_f6914_0(String variable)
{    return fieldsMap.containsKey(variable);}
public PcapFilter metron_f6915_0()
{    return creator.create();}
public PcapFilter metron_f6916_0()
{    return new FixedPcapFilter();}
public PcapFilter metron_f6917_0()
{    return new QueryPcapFilter();}
public void metron_f6918_0(String query, Configuration conf)
{    conf.set(QUERY_STR_CONFIG, query);    conf.set(PCAP_FILTER_NAME_CONF, PcapFilters.QUERY.name());}
public String metron_f6919_0(String fields)
{    return (fields == null ? "" : fields.trim().replaceAll("\\s", "_"));}
public void metron_f6920_0(Iterable<Map.Entry<String, String>> config)
{    for (Map.Entry<String, String> entry : config) {        if (entry.getKey().equals(QUERY_STR_CONFIG)) {            queryString = entry.getValue();        }    }    predicateProcessor.validate(queryString);}
public boolean metron_f6921_0(PacketInfo input)
{    Map<String, Object> fields = packetToFields(input);    VariableResolver resolver = new MapVariableResolver(fields);    return predicateProcessor.parse(queryString, resolver, StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());}
protected Map<String, Object> metron_f6922_0(PacketInfo pi)
{    return PcapHelper.packetToFields(pi);}
protected void metron_f6923_0(PcapResultsWriter resultsWriter, Configuration hadoopConfig, List<byte[]> data, Path outputPath) throws IOException
{    resultsWriter.writeLocal(data, outputPath.toString());}
protected Path metron_f6924_0(Map<String, Object> config, int partition)
{    Path finalOutputPath = PcapOptions.FINAL_OUTPUT_PATH.get(config, PcapOptions.STRING_TO_PATH, Path.class);    String prefix = PcapOptions.FINAL_FILENAME_PREFIX.get(config, String.class);    return new Path(String.format(PCAP_CLI_FILENAME_FORMAT, finalOutputPath, prefix, partition));}
protected PcapResultsWriter metron_f6925_0()
{    return resultsWriter;}
public Pageable<Path> metron_f6926_1(Map<String, Object> config) throws JobException
{    Configuration hadoopConfig = PcapOptions.HADOOP_CONF.get(config, Configuration.class);    int recPerFile = PcapOptions.NUM_RECORDS_PER_FILE.getOrDefault(config, Integer.class, NUM_RECORDS_PER_FILE_DEFAULT);    Path interimResultPath = PcapOptions.INTERIM_RESULT_PATH.get(config, PcapOptions.STRING_TO_PATH, Path.class);    FileSystem fs = PcapOptions.FILESYSTEM.get(config, FileSystem.class);    int parallelism = getNumThreads(PcapOptions.FINALIZER_THREADPOOL_SIZE.get(config, String.class));        SequenceFileIterable interimResults = null;    try {        interimResults = readInterimResults(interimResultPath, hadoopConfig, fs);    } catch (IOException e) {        throw new JobException("Unable to read interim job results while finalizing", e);    }    List<Path> outFiles = new ArrayList<>();    try {        Iterable<List<byte[]>> partitions = Iterables.partition(interimResults, recPerFile);        Map<Path, List<byte[]>> toWrite = new HashMap<>();        int part = 1;        if (partitions.iterator().hasNext()) {            for (List<byte[]> data : partitions) {                Path outputPath = getOutputPath(config, part++);                toWrite.put(outputPath, data);            }            outFiles = writeParallel(hadoopConfig, toWrite, parallelism);        } else {                    }    } catch (IOException e) {        throw new JobException("Failed to finalize results", e);    } finally {        try {            interimResults.cleanup();        } catch (IOException e) {                    }    }        return new PcapPages(outFiles);}
private static int metron_f6927_0(String numThreads) throws JobException
{    String numThreadsStr = ((String) numThreads).trim().toUpperCase();    try {        if (numThreadsStr.endsWith("C")) {            Integer factor = Integer.parseInt(numThreadsStr.replace("C", ""));            return factor * Runtime.getRuntime().availableProcessors();        } else {            return Integer.parseInt(numThreadsStr);        }    } catch (NumberFormatException e) {        throw new JobException(format("Unable to set number of threads for finalizing from property value '%s'", numThreads));    }}
protected List<Path> metron_f6928_0(Configuration hadoopConfig, Map<Path, List<byte[]>> toWrite, int parallelism) throws IOException
{    List<Path> outFiles = Collections.synchronizedList(new ArrayList<>());    ForkJoinPool tp = new ForkJoinPool(parallelism);    try {        tp.submit(() -> {            toWrite.entrySet().parallelStream().forEach(e -> {                Path path = e.getKey();                List<byte[]> data = e.getValue();                if (data.size() > 0) {                    try {                        write(getResultsWriter(), hadoopConfig, data, path);                    } catch (IOException ioe) {                        throw new RuntimeException(String.format("Failed to write results to path '%s'", path.toString()), ioe);                    }                    outFiles.add(path);                }            });        }).get();    } catch (InterruptedException | ExecutionException e) {        throw new IOException("Error finalizing results.", e);    } catch (RuntimeException e) {        throw new IOException(e.getMessage(), e.getCause());    }    outFiles.sort((o1, o2) -> o1.getName().compareTo(o2.getName()));    return outFiles;}
protected SequenceFileIterable metron_f6929_1(Path interimResultPath, Configuration config, FileSystem fs) throws IOException
{    List<Path> files = new ArrayList<>();    for (RemoteIterator<LocatedFileStatus> it = fs.listFiles(interimResultPath, false); it.hasNext(); ) {        Path p = it.next().getPath();        if (p.getName().equals("_SUCCESS")) {            fs.delete(p, false);            continue;        }        files.add(p);    }    if (files.size() == 0) {            } else {                Collections.sort(files, (o1, o2) -> o1.getName().compareTo(o2.getName()));    }    return new SequenceFileIterable(files, config);}
public Pageable<Path> metron_f6930_0(Map<String, Object> config) throws JobException
{    return finalizer.finalizeJob(config);}
protected void metron_f6931_0(PcapResultsWriter resultsWriter, Configuration hadoopConfig, List<byte[]> data, Path outputPath) throws IOException
{    resultsWriter.write(hadoopConfig, data, outputPath.toString());}
protected Path metron_f6932_0(Map<String, Object> config, int partition)
{    String finalOutputPath = PcapOptions.FINAL_OUTPUT_PATH.getOrDefault(config, String.class, FINAL_OUTPUT_PATH_DEFAULT);    String user = PcapOptions.USERNAME.get(config, String.class);    String jobId = PcapOptions.JOB_ID.get(config, String.class);    return new Path(String.format(PCAP_REST_FILEPATH_FORMAT, finalOutputPath, user, jobType, jobId, partition));}
public int metron_f6933_0()
{    return priorityCodePoint;}
public int metron_f6934_0()
{    return dropEligibleIndicator;}
public int metron_f6935_0()
{    return vLANIdentifier;}
public void metron_f6936_0(EthernetProcessor processor)
{    this.callbacks.add(processor);}
public void metron_f6937_0(int type, EthernetProcessor processor)
{    Set<EthernetProcessor> processors = typeCallbacks.get(type);    if (processors == null) {        processors = new HashSet<EthernetProcessor>();        typeCallbacks.put(type, processors);    }    processors.add(processor);}
public void metron_f6938_0(EthernetProcessor processor)
{    this.callbacks.remove(processor);}
public void metron_f6939_0(int type, EthernetProcessor processor)
{    Set<EthernetProcessor> processors = typeCallbacks.get(type);    if (processors == null)        return;    processors.remove(processor);}
public void metron_f6940_0(PcapPacket packet)
{        MacAddress destination = getMacAddress(packet.getPacketData());    MacAddress source = getMacAddress(packet.getPacketData());    int type = getEtherType(packet.getPacketData());    if (type == 0x8100) {                IEEE_802_1Q iee802_1qTag = get802_1qTag(packet.getPacketData());                type = getEtherType(packet.getPacketData());    }    Buffer buffer = packet.getPacketData();    buffer.discardReadBytes();    EthernetFrame frame = new EthernetFrame(source, destination, type, buffer);    frame.setPcapPacket(packet);    dispatch(frame);}
private MacAddress metron_f6941_0(Buffer data)
{    byte[] mac = new byte[6];    data.gets(mac, 0, 6);    return new MacAddress(mac);}
private int metron_f6942_0(Buffer data)
{    return ((int) data.getShort()) & 0x0000FFFF;}
private IEEE_802_1Q metron_f6943_0(Buffer data)
{            byte[] b802_1qTag = new byte[2];    data.gets(b802_1qTag, 0, 2);    BitSet bits = BitSet.valueOf(b802_1qTag);    int pcp = convertBitToInt(bits.get(0, 3));    int dei = convertBitToInt(bits.get(3, 4));    int vid = convertBitToInt(bits.get(4, 16));    return new IEEE_802_1Q(pcp, dei, vid);}
public static int metron_f6944_0(BitSet bits)
{    int value = 0;    for (int i = 0; i < bits.length(); ++i) {        value += bits.get(i) ? (1 << i) : 0;    }    return value;}
private void metron_f6945_0(EthernetFrame frame)
{    for (EthernetProcessor processor : callbacks) processor.process(frame);    Set<EthernetProcessor> processors = typeCallbacks.get(frame.getType());    if (processors == null)        return;    for (EthernetProcessor processor : processors) processor.process(frame.dup());}
public String metron_f6946_0(long beginNS, long endNS, String query)
{    return sanitize(Joiner.on("_").join(beginNS, endNS, query, UUID.randomUUID().toString()));}
private String metron_f6947_0(String path)
{    return path.replace(".", "-").replace("'", "").replace(":", "");}
public int metron_f6948_0(LongWritable longWritable, BytesWritable bytesWritable, int numPartitions)
{    if (start == null) {        initialize();    }    long x = longWritable.get();    int ret = (int) Long.divideUnsigned(x - start, width);    if (ret > numPartitions) {        throw new IllegalArgumentException(String.format("Bad partition: key=%s, width=%d, partition=%d, numPartitions=%d", Long.toUnsignedString(x), width, ret, numPartitions));    }    return ret;}
private void metron_f6949_0()
{    start = Long.parseUnsignedLong(configuration.get(START_TS_CONF));    end = Long.parseUnsignedLong(configuration.get(END_TS_CONF));    width = Long.parseLong(configuration.get(WIDTH_CONF));}
public void metron_f6950_0(Configuration conf)
{    this.configuration = conf;}
public Configuration metron_f6951_0()
{    return configuration;}
protected void metron_f6952_0(Context context) throws IOException, InterruptedException
{    super.setup(context);    filter = PcapFilters.valueOf(context.getConfiguration().get(PcapFilterConfigurator.PCAP_FILTER_NAME_CONF)).create();    filter.configure(context.getConfiguration());    start = Long.parseUnsignedLong(context.getConfiguration().get(START_TS_CONF));    end = Long.parseUnsignedLong(context.getConfiguration().get(END_TS_CONF));}
protected void metron_f6953_0(LongWritable key, BytesWritable value, Context context) throws IOException, InterruptedException
{    if (greaterThanOrEqualTo(key.get(), start) && lessThanOrEqualTo(key.get(), end)) {                                        List<PacketInfo> packetInfos;        try {            packetInfos = PcapHelper.toPacketInfo(value.copyBytes());        } catch (Exception e) {                        context.getCounter(PCAP_COUNTER.MALFORMED_PACKET_COUNT).increment(1);            return;        }        boolean send = filteredPacketInfo(packetInfos).findAny().isPresent();        if (send) {            context.write(key, value);        }    }}
private Stream<PacketInfo> metron_f6954_0(List<PacketInfo> packetInfos) throws IOException
{    return packetInfos.stream().filter(filter);}
protected void metron_f6955_0(LongWritable key, Iterable<BytesWritable> values, Context context) throws IOException, InterruptedException
{    for (BytesWritable value : values) {        context.write(key, value);    }}
public void metron_f6956_0(long interval)
{    statusInterval = interval;}
public void metron_f6957_0(long interval)
{    completeCheckInterval = interval;}
public Statusable<Path> metron_f6958_0(Finalizer<Path> finalizer, Map<String, Object> config) throws JobException
{    this.finalizer = finalizer;    this.configuration = config;    Optional<String> jobName = Optional.ofNullable(PcapOptions.JOB_NAME.get(configuration, String.class));    Configuration hadoopConf = PcapOptions.HADOOP_CONF.get(configuration, Configuration.class);    FileSystem fileSystem = PcapOptions.FILESYSTEM.get(configuration, FileSystem.class);    Path basePath = PcapOptions.BASE_PATH.getTransformed(configuration, Path.class);    Path baseInterimResultPath = PcapOptions.BASE_INTERIM_RESULT_PATH.getTransformedOrDefault(configuration, Path.class, new Path(PcapGlobalDefaults.BASE_INTERIM_RESULT_PATH_DEFAULT));    long startTimeNs;    if (configuration.containsKey(PcapOptions.START_TIME_NS.getKey())) {        startTimeNs = PcapOptions.START_TIME_NS.getOrDefault(configuration, Long.class, 0L);    } else {        startTimeNs = TimestampConverters.MILLISECONDS.toNanoseconds(PcapOptions.START_TIME_MS.getOrDefault(configuration, Long.class, 0L));    }    long endTimeNs;    if (configuration.containsKey(PcapOptions.END_TIME_NS.getKey())) {        endTimeNs = PcapOptions.END_TIME_NS.getOrDefault(configuration, Long.class, TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis()));    } else {        endTimeNs = TimestampConverters.MILLISECONDS.toNanoseconds(PcapOptions.END_TIME_MS.getOrDefault(configuration, Long.class, System.currentTimeMillis()));    }    int numReducers = PcapOptions.NUM_REDUCERS.getOrDefault(configuration, Integer.class, NUM_REDUCERS_DEFAULT);    T fields = (T) PcapOptions.FIELDS.get(configuration, Object.class);    PcapFilterConfigurator<T> filterImpl = PcapOptions.FILTER_IMPL.get(configuration, PcapFilterConfigurator.class);    try {        Statusable<Path> statusable = query(jobName, basePath, baseInterimResultPath, startTimeNs, endTimeNs, numReducers, fields,         new Configuration(hadoopConf), fileSystem, filterImpl);        PcapOptions.JOB_ID.put(configuration, statusable.getStatus().getJobId());        return statusable;    } catch (IOException | InterruptedException | ClassNotFoundException e) {        throw new JobException("Failed to run pcap query.", e);    }}
public Statusable<Path> metron_f6959_1(Optional<String> jobName, Path basePath, Path baseInterimResultPath, long beginNS, long endNS, int numReducers, T fields, Configuration conf, FileSystem fs, PcapFilterConfigurator<T> filterImpl) throws IOException, ClassNotFoundException, InterruptedException
{    String outputDirName = outputDirFormatter.format(beginNS, endNS, filterImpl.queryToString(fields));    if (LOG.isDebugEnabled()) {        DateFormat format = SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.LONG, SimpleDateFormat.LONG);        String from = format.format(new Date(Long.divideUnsigned(beginNS, 1000000)));        String to = format.format(new Date(Long.divideUnsigned(endNS, 1000000)));            }    Path interimResultPath = new Path(baseInterimResultPath, outputDirName);    PcapOptions.INTERIM_RESULT_PATH.put(configuration, interimResultPath);    mrJob = createJob(jobName, basePath, interimResultPath, beginNS, endNS, numReducers, fields, conf, fs, filterImpl);    if (mrJob == null) {                try {            setFinalResults(input -> new PcapPages(), configuration);            jobStatus.withState(State.SUCCEEDED).withDescription("No results in specified date range.").withPercentComplete(100.0);        } catch (JobException e) {                        jobStatus.withState(State.FAILED).withDescription("Unable to finalize empty job.").withFailureException(e);        }        return this;    }    synchronized (this) {                                        mrJob.submit();        jobStatus.withState(State.SUBMITTED).withDescription("Job submitted").withJobId(mrJob.getJobID().toString());    }    startJobStatusTimerThread(statusInterval);    return this;}
private void metron_f6960_0(long interval)
{    getTimer().scheduleAtFixedRate(new TimerTask() {        @Override        public void run() {            if (!updateStatus()) {                                cancel();            }        }    }, interval, interval);}
public void metron_f6961_0()
{    if (!updateStatus()) {                cancel();    }}
public void metron_f6962_0(Timer timer)
{    this.timer = timer;}
private Timer metron_f6963_0()
{    return timer;}
private boolean metron_f6964_0()
{    JobStatus tempStatus = null;        final float mrJobFraction = 0.75f;    synchronized (this) {        tempStatus = new JobStatus(jobStatus);    }    boolean keepUpdating = true;    try {        boolean mrJobComplete = false;        org.apache.hadoop.mapreduce.JobStatus.State mrJobState = null;        String mrJobFailureInfo = null;        float mapProg = 0.0f;        float reduceProg = 0.0f;        synchronized (this) {            mrJobComplete = mrJob.isComplete();            org.apache.hadoop.mapreduce.JobStatus mrJobStatus = mrJob.getStatus();            mrJobState = mrJobStatus.getState();            mrJobFailureInfo = mrJobStatus.getFailureInfo();            mapProg = mrJob.mapProgress();            reduceProg = mrJob.reduceProgress();        }        if (mrJobComplete) {            switch(mrJobState) {                case SUCCEEDED:                    tempStatus.withPercentComplete(100.0 * mrJobFraction).withState(State.FINALIZING).withDescription("Finalizing job.");                    try {                        synchronized (this) {                                                        jobStatus = new JobStatus(tempStatus);                        }                        setFinalResults(finalizer, configuration);                        tempStatus.withPercentComplete(100.0).withState(State.SUCCEEDED).withDescription("Job completed.");                    } catch (JobException je) {                        tempStatus.withPercentComplete(100.0).withState(State.FAILED).withDescription("Job finalize failed.").withFailureException(je);                    }                    break;                case FAILED:                    tempStatus.withPercentComplete(100.0).withState(State.FAILED).withDescription(mrJobFailureInfo);                    break;                case KILLED:                    tempStatus.withPercentComplete(100.0).withState(State.KILLED).withDescription(mrJobFailureInfo);                    break;            }            keepUpdating = false;        } else {            float mrJobProgress = ((mapProg / 2) + (reduceProg / 2)) * 100;            float totalProgress = mrJobProgress * mrJobFraction;            String description = String.format("map: %s%%, reduce: %s%%", mapProg * 100, reduceProg * 100);            tempStatus.withPercentComplete(totalProgress).withState(State.RUNNING).withDescription(description);        }    } catch (InterruptedException | IOException e) {        tempStatus.withPercentComplete(100.0).withState(State.FAILED).withFailureException(e);        keepUpdating = false;    }    synchronized (this) {        jobStatus = new JobStatus(tempStatus);    }    return keepUpdating;}
private void metron_f6965_0(Finalizer<Path> finalizer, Map<String, Object> configuration) throws JobException
{    Pageable<Path> results = finalizer.finalizeJob(configuration);    if (results == null) {        results = new PcapPages();    }    synchronized (this) {        finalResults = results;    }}
public Job metron_f6966_0(Optional<String> jobName, Path basePath, Path jobOutputPath, long beginNS, long endNS, int numReducers, T fields, Configuration conf, FileSystem fs, PcapFilterConfigurator<T> filterImpl) throws IOException
{    Iterable<String> filteredPaths = FileFilterUtil.getPathsInTimeRange(beginNS, endNS, listFiles(fs, basePath));    String inputPaths = Joiner.on(',').join(filteredPaths);    if (StringUtils.isEmpty(inputPaths)) {        return null;    }    conf.set(START_TS_CONF, Long.toUnsignedString(beginNS));    conf.set(END_TS_CONF, Long.toUnsignedString(endNS));    conf.set(WIDTH_CONF, "" + findWidth(beginNS, endNS, numReducers));    filterImpl.addToConfig(fields, conf);    Job job = Job.getInstance(conf);    jobName.ifPresent(job::setJobName);    job.setJarByClass(PcapJob.class);    job.setMapperClass(PcapJob.PcapMapper.class);    job.setMapOutputKeyClass(LongWritable.class);    job.setMapOutputValueClass(BytesWritable.class);    job.setNumReduceTasks(numReducers);    job.setReducerClass(PcapReducer.class);    job.setPartitionerClass(PcapPartitioner.class);    job.setOutputKeyClass(LongWritable.class);    job.setOutputValueClass(BytesWritable.class);    SequenceFileInputFormat.addInputPaths(job, inputPaths);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    SequenceFileOutputFormat.setOutputPath(job, jobOutputPath);    return job;}
public static long metron_f6967_0(long start, long end, int numReducers)
{    return Long.divideUnsigned(end - start, numReducers) + 1;}
protected Iterable<Path> metron_f6968_0(FileSystem fs, Path basePath) throws IOException
{    List<Path> ret = new ArrayList<>();    RemoteIterator<LocatedFileStatus> filesIt = fs.listFiles(basePath, true);    while (filesIt.hasNext()) {        ret.add(filesIt.next().getPath());    }    return ret;}
public JobType metron_f6969_0()
{    return JobType.MAP_REDUCE;}
public synchronized JobStatus metron_f6970_0() throws JobException
{    return new JobStatus(jobStatus);}
protected void metron_f6971_0(JobStatus jobStatus)
{    this.jobStatus = jobStatus;}
protected void metron_f6972_0(Job mrJob)
{    this.mrJob = mrJob;}
public Pageable<Path> metron_f6973_1() throws JobException, InterruptedException
{    if (PcapOptions.PRINT_JOB_STATUS.getOrDefault(configuration, Boolean.class, false) && mrJob != null) {        try {            mrJob.monitorAndPrintJob();        } catch (IOException e) {            throw new JobException("Could not monitor job status", e);        }    }    for (; ; ) {        JobStatus status = getStatus();        if (status.getState() == State.SUCCEEDED || status.getState() == State.KILLED || status.getState() == State.FAILED) {            return getFinalResults();        } else {                    }        Thread.sleep(completeCheckInterval);    }}
private synchronized Pageable<Path> metron_f6974_0()
{    return new PcapPages(finalResults);}
public boolean metron_f6975_0()
{    State jobState = null;    synchronized (this) {        jobState = jobStatus.getState();    }    return (jobState == State.SUCCEEDED || jobState == State.KILLED || jobState == State.FAILED);}
public void metron_f6976_0() throws JobException
{    try {        synchronized (this) {            mrJob.killJob();        }    } catch (IOException e) {        throw new JobException("Unable to kill pcap job.", e);    }}
public boolean metron_f6977_0(Map<String, Object> configuration)
{        return true;}
public Map<String, Object> metron_f6978_0()
{    return new HashMap<>(this.configuration);}
protected void metron_f6979_0(Map<String, Object> configuration)
{    this.configuration = configuration;}
public GlobalHeader metron_f6980_0()
{    return globalHeader;}
public byte[] metron_f6981_0()
{    return packetBytes;}
public PacketHeader metron_f6982_0()
{    return packetHeader;}
public PcapPacket metron_f6983_0()
{    return packet;}
public Ipv4Packet metron_f6984_0()
{    return ipv4Packet;}
public TcpPacket metron_f6985_0()
{    return tcpPacket;}
public UdpPacket metron_f6986_0()
{    return udpPacket;}
public String metron_f6987_0()
{    int sourcePort = 0;    int destinationPort = 0;    if (Constants.PROTOCOL_UDP == ipv4Packet.getProtocol()) {        sourcePort = udpPacket.getSourcePort();        destinationPort = udpPacket.getDestinationPort();    } else if (Constants.PROTOCOL_TCP == ipv4Packet.getProtocol()) {        sourcePort = tcpPacket.getSourcePort();        destinationPort = tcpPacket.getDestinationPort();    }    return PcapUtils.getSessionKey(ipv4Packet.getSourceAddress().getHostAddress(), ipv4Packet.getDestinationAddress().getHostAddress(), ipv4Packet.getProtocol(), sourcePort, destinationPort, ipv4Packet.getId(), ipv4Packet.getFragmentOffset());}
public String metron_f6988_0()
{    int sourcePort = 0;    int destinationPort = 0;    if (Constants.PROTOCOL_UDP == ipv4Packet.getProtocol()) {        sourcePort = udpPacket.getSourcePort();        destinationPort = udpPacket.getDestinationPort();    } else if (Constants.PROTOCOL_TCP == ipv4Packet.getProtocol()) {        sourcePort = tcpPacket.getSourcePort();        destinationPort = tcpPacket.getDestinationPort();    }    return PcapUtils.getShortSessionKey(ipv4Packet.getSourceAddress().getHostAddress(), ipv4Packet.getDestinationAddress().getHostAddress(), ipv4Packet.getProtocol(), sourcePort, destinationPort);}
public String metron_f6989_0()
{    return getJsonDocUsingSBAppend();}
public String metron_f6990_0()
{    return getJsonIndexDocUsingSBAppend();}
private String metron_f6991_0()
{    StringBuffer jsonSb = new StringBuffer(1024);        jsonSb.append("{\"global_header\":{\"pcap_id\":\"").append(getKey());    jsonSb.append("\",\"inc_len\":").append(packetHeader.getInclLen());    jsonSb.append(",\"orig_len\":").append(packetHeader.getOrigLen());    jsonSb.append(",\"ts_sec\":").append(packetHeader.getTsSec());    jsonSb.append(",\"ts_usec\":").append(packetHeader.getTsUsec());        jsonSb.append("},");        jsonSb.append("\"ipv4_header\":{");    jsonSb.append("\"ip_dst\":").append(ipv4Packet.getDestination());    jsonSb.append(",\"ip_dst_addr\":\"").append(ipv4Packet.getDestinationAddress().getHostAddress());    jsonSb.append("\",\"ip_flags\":").append(ipv4Packet.getFlags());    jsonSb.append(",\"ip_fragment_offset\":").append(ipv4Packet.getFragmentOffset());    jsonSb.append(",\"ip_header_checksum\":").append(ipv4Packet.getHeaderChecksum());    jsonSb.append(",\"ip_id\":").append(ipv4Packet.getId());    jsonSb.append(",\"ip_header_length\":").append(ipv4Packet.getIhl());    jsonSb.append(",\"ip_protocol\":").append(ipv4Packet.getProtocol());    jsonSb.append(",\"ip_src\":").append(ipv4Packet.getSource());    jsonSb.append(",\"ip_src_addr\":\"").append(ipv4Packet.getSourceAddress().getHostAddress());    jsonSb.append("\",\"ip_tos\":").append(ipv4Packet.getTos());    jsonSb.append(",\"ip_total_length\":").append(ipv4Packet.getTotalLength());    jsonSb.append(",\"ip_ttl\":").append(ipv4Packet.getTtl());    jsonSb.append(",\"ip_version\":").append(ipv4Packet.getVersion());    jsonSb.append('}');        if (tcpPacket != null) {        jsonSb.append(",\"tcp_header\":{\"ack\":").append(tcpPacket.getAck());        jsonSb.append(",\"checksum\":").append(tcpPacket.getChecksum());        jsonSb.append(",\"data_length\":").append(tcpPacket.getDataLength());        jsonSb.append(",\"data_offset\":").append(tcpPacket.getDataOffset());        jsonSb.append(",\"dst_addr\":\"").append(tcpPacket.getDestinationAddress().getHostAddress());        jsonSb.append("\",\"dst_port\":").append(tcpPacket.getDestinationPort());        jsonSb.append(",\"direction\":").append(tcpPacket.getDirection());        jsonSb.append(",\"flags\":").append(tcpPacket.getFlags());        jsonSb.append(",\"reassembled_length \":").append(tcpPacket.getReassembledLength());        jsonSb.append(",\"relative_ack\":").append(tcpPacket.getRelativeAck());        jsonSb.append(",\"relative_seq\":").append(tcpPacket.getRelativeSeq());        jsonSb.append(",\"seq\":").append(tcpPacket.getSeq());        jsonSb.append(",\"session_key\":\"").append(tcpPacket.getSessionKey());        jsonSb.append("\",\"src_addr\":\"").append(tcpPacket.getSourceAddress().getHostAddress());        jsonSb.append("\",\"src_port\":").append(tcpPacket.getSourcePort());        jsonSb.append(",\"total_length\":").append(tcpPacket.getTotalLength());        jsonSb.append(",\"urgent_pointer\":").append(tcpPacket.getUrgentPointer());        jsonSb.append(",\"window\":").append(tcpPacket.getWindow());        jsonSb.append('}');    }        if (udpPacket != null) {        jsonSb.append(",\"udp_header\":{\"checksum\":").append(udpPacket.getChecksum());        jsonSb.append(",\"dst_port\":").append(udpPacket.getDestinationPort());        jsonSb.append(",\"length\":").append(udpPacket.getLength());        jsonSb.append(",\"src_port\":").append(udpPacket.getSourcePort());        jsonSb.append(",\"dst_addr\":\"").append(udpPacket.getDestination().getAddress().getHostAddress());        jsonSb.append("\",\"src_addr\":\"").append(udpPacket.getSource().getAddress().getHostAddress());        jsonSb.append("\"}");    }    jsonSb.append('}');    return jsonSb.toString();}
private String metron_f6992_0()
{    StringBuffer jsonSb = new StringBuffer(600);    jsonSb.append(MessageFormat.format(globalHeaderJsonTemplateString, getKey(), packetHeader.getInclLen(), packetHeader.getOrigLen(), packetHeader.getTsSec(), packetHeader.getTsUsec()));    jsonSb.append(MessageFormat.format(ipv4HeaderJsonTemplateString, ipv4Packet.getDestination(), ipv4Packet.getDestinationAddress().getHostAddress(), ipv4Packet.getFlags(), ipv4Packet.getFragmentOffset(), ipv4Packet.getHeaderChecksum(), ipv4Packet.getId(), ipv4Packet.getIhl(), ipv4Packet.getProtocol(), ipv4Packet.getSource(), ipv4Packet.getSourceAddress().getHostAddress(), ipv4Packet.getTos(), ipv4Packet.getTotalLength(), ipv4Packet.getTtl(), ipv4Packet.getVersion()));        if (tcpPacket != null) {        jsonSb.append(MessageFormat.format(tcpHeaderJsonTemplateString, tcpPacket.getAck(), tcpPacket.getChecksum(), tcpPacket.getDataLength(), tcpPacket.getDataOffset(), tcpPacket.getDestinationAddress().getHostAddress(), tcpPacket.getDestinationPort(), tcpPacket.getDirection(), tcpPacket.getFlags(), tcpPacket.getReassembledLength(), tcpPacket.getRelativeAck(), tcpPacket.getRelativeSeq(), tcpPacket.getSeq(), tcpPacket.getSessionKey(), tcpPacket.getSourceAddress().getHostAddress(), tcpPacket.getSourcePort(), tcpPacket.getTotalLength(), tcpPacket.getUrgentPointer(), tcpPacket.getWindow()));    } else     if (udpPacket != null) {        jsonSb.append(MessageFormat.format(udpHeaderJsonTemplateString, udpPacket.getChecksum(), udpPacket.getDestinationPort(), udpPacket.getLength(), udpPacket.getSourcePort(), udpPacket.getDestination().getAddress().getHostAddress(), udpPacket.getSource().getAddress().getHostAddress()));    } else {        jsonSb.append('}');    }    return jsonSb.toString().replace('<', '{').replace('>', '}');}
private String metron_f6993_0()
{    Long ts_micro = getPacketTimeInNanos() / 1000L;    StringBuffer jsonSb = new StringBuffer(175);    jsonSb.append("{\"pcap_id\":\"").append(getShortKey());    jsonSb.append("\",\"ip_protocol\":").append(ipv4Packet.getProtocol());    jsonSb.append(",\"ip_id\":").append(ipv4Packet.getId());    jsonSb.append(",\"frag_offset\":").append(ipv4Packet.getFragmentOffset());    jsonSb.append(",\"ts_micro\":").append(ts_micro);        if (tcpPacket != null) {        jsonSb.append(",\"ip_src_addr\":\"").append(tcpPacket.getSourceAddress().getHostAddress());        jsonSb.append("\",\"ip_src_port\":").append(tcpPacket.getSourcePort());        jsonSb.append(",\"ip_dst_addr\":\"").append(tcpPacket.getDestinationAddress().getHostAddress());        jsonSb.append("\",\"ip_dst_port\":").append(tcpPacket.getDestinationPort());    }        if (udpPacket != null) {        jsonSb.append(",\"ip_src_addr\":\"").append(udpPacket.getSource().getAddress().getHostAddress());        jsonSb.append("\",\"ip_src_port\":").append(udpPacket.getSourcePort());        jsonSb.append(",\"ip_dst_addr\":\"").append(udpPacket.getDestination().getAddress().getHostAddress());        jsonSb.append("\",\"ip_dst_port\":").append(udpPacket.getDestinationPort());    }    jsonSb.append('}');    return jsonSb.toString();}
public long metron_f6994_1()
{    if (getGlobalHeader().getMagicNumber() == 0xa1b2c3d4 || getGlobalHeader().getMagicNumber() == 0xd4c3b2a1) {                        return getPacketHeader().getTsSec() * 1000000000L + getPacketHeader().getTsUsec() * 1000L;    } else if (getGlobalHeader().getMagicNumber() == 0xa1b23c4d || getGlobalHeader().getMagicNumber() == 0x4d3cb2a1) {                        return getPacketHeader().getTsSec() * 1000000000L + getPacketHeader().getTsUsec();    }            return getPacketHeader().getTsSec() * 1000000000L + getPacketHeader().getTsUsec() * 1000L;}
public Object metron_f6995_0(List<Object> args, Context context) throws ParseException
{    if (args.size() != 2) {        return new IllegalStateException("Expected 2 arguments: regex and data");    }    String regex = (String) args.get(0);    byte[] data = (byte[]) args.get(1);    try {        return ByteArrayMatchingUtil.INSTANCE.match(regex, data);    } catch (ExecutionException e) {        throw new IllegalStateException("Unable to process " + regex + " against " + DatatypeConverter.printHexBinary(data));    }}
public void metron_f6996_0(Context context)
{}
public boolean metron_f6997_0()
{    return true;}
public Searcher<SequenceMatcher> metron_f6998_0(String pattern) throws Exception
{    return new HorspoolFinalFlagSearcher(compile(pattern));}
private SequenceMatcher metron_f6999_0(String pattern) throws CompileException
{    return compiler.compile(pattern);}
public boolean metron_f7000_0(String pattern, byte[] data) throws ExecutionException
{    if (pattern == null) {        return false;    }    Searcher<SequenceMatcher> searcher = sequenceMatchers.get(pattern);    if (data == null) {        return false;    } else {        return !searcher.searchForwards(data).isEmpty();    }}
public PcapPacket metron_f7001_0() throws IOException
{    return readPacket(globalHeader.getMagicNumber());}
public GlobalHeader metron_f7002_0()
{    return globalHeader;}
private void metron_f7003_0() throws IOException
{    int magic = is.readInt();    short major = is.readShort();    short minor = is.readShort();    int tz = is.readInt();    int sigfigs = is.readInt();    int snaplen = is.readInt();    int network = is.readInt();    globalHeader = new GlobalHeader(magic, major, minor, tz, sigfigs, snaplen, network);    if (globalHeader.getMagicNumber() == 0xD4C3B2A1) {        globalHeader.swapByteOrder();    }}
private PcapPacket metron_f7004_0(int magicNumber) throws IOException
{    PacketHeader packetHeader = readPacketHeader(magicNumber);    Buffer packetData = readPacketData(packetHeader.getInclLen());    return new PcapPacket(packetHeader, packetData);}
private PacketHeader metron_f7005_0(int magicNumber) throws IOException
{    int tsSec = is.readInt();    int tsUsec = is.readInt();    int inclLen = is.readInt();    int origLen = is.readInt();    if (magicNumber == 0xD4C3B2A1) {        tsSec = ByteOrderConverter.swap(tsSec);        tsUsec = ByteOrderConverter.swap(tsUsec);        inclLen = ByteOrderConverter.swap(inclLen);        origLen = ByteOrderConverter.swap(origLen);    }    return new PacketHeader(tsSec, tsUsec, inclLen, origLen);}
private Buffer metron_f7006_0(int packetLength) throws IOException
{    byte[] packets = new byte[packetLength];    is.read(packets);    Buffer payload = new ChainBuffer();    payload.addLast(packets);    return payload;}
public void metron_f7007_0() throws IOException
{        is.close();}
private void metron_f7008_0()
{    /* magic number(swapped) */    list.add((byte) 0xd4);    list.add((byte) 0xc3);    list.add((byte) 0xb2);    list.add((byte) 0xa1);    /* major version number */    list.add((byte) 0x02);    list.add((byte) 0x00);    /* minor version number */    list.add((byte) 0x04);    list.add((byte) 0x00);    /* GMT to local correction */    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    /* accuracy of timestamps */    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    /* max length of captured packets, in octets */    list.add((byte) 0xff);    list.add((byte) 0xff);    list.add((byte) 0x00);    list.add((byte) 0x00);    /* data link type(ethernet) */    list.add((byte) 0x01);    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);}
private void metron_f7009_0(GlobalHeader header)
{    final byte[] magicNumber = intToByteArray(header.getMagicNumber());    final byte[] majorVersion = shortToByteArray(header.getMajorVersion());    final byte[] minorVersion = shortToByteArray(header.getMinorVersion());    final byte[] zone = intToByteArray(header.getThiszone());    final byte[] sigFigs = intToByteArray(header.getSigfigs());    final byte[] snapLen = intToByteArray(header.getSnaplen());    final byte[] network = intToByteArray(header.getNetwork());    list.add(magicNumber[0]);    list.add(magicNumber[1]);    list.add(magicNumber[2]);    list.add(magicNumber[3]);    list.add(majorVersion[1]);    list.add(majorVersion[0]);    list.add(minorVersion[1]);    list.add(minorVersion[0]);    list.add(zone[3]);    list.add(zone[2]);    list.add(zone[1]);    list.add(zone[0]);    list.add(sigFigs[3]);    list.add(sigFigs[2]);    list.add(sigFigs[1]);    list.add(sigFigs[0]);    list.add(snapLen[3]);    list.add(snapLen[2]);    list.add(snapLen[1]);    list.add(snapLen[0]);    list.add(network[3]);    list.add(network[2]);    list.add(network[1]);    list.add(network[0]);}
public void metron_f7010_0(PcapPacket packet) throws IOException
{    PacketHeader packetHeader = packet.getPacketHeader();    int tsSec = packetHeader.getTsSec();    int tsUsec = packetHeader.getTsUsec();    int inclLen = packetHeader.getInclLen();    int origLen = packetHeader.getOrigLen();    addInt(tsSec);    addInt(tsUsec);    addInt(inclLen);    addInt(origLen);    Buffer payload = packet.getPacketData();    try {        payload.mark();        while (true) {            list.add(payload.get());        }    } catch (BufferUnderflowException e) {                payload.reset();    }    cachedPacketNum++;    if (cachedPacketNum == MAX_CACHED_PACKET_NUMBER) {        flush();    }}
private void metron_f7011_0(int number)
{    list.add((byte) (number & 0xff));    list.add((byte) ((number & 0xff00) >> 8));    list.add((byte) ((number & 0xff0000) >> 16));    list.add((byte) ((number & 0xff000000) >> 24));}
private byte[] metron_f7012_0(int number)
{    return new byte[] { (byte) (number >>> 24), (byte) (number >>> 16), (byte) (number >>> 8), (byte) number };}
private byte[] metron_f7013_0(short number)
{    return new byte[] { (byte) (number >>> 8), (byte) number };}
public void metron_f7014_0() throws IOException
{    byte[] fileBinary = new byte[list.size()];    for (int i = 0; i < fileBinary.length; i++) {        fileBinary[i] = list.get(i);    }    list.clear();    baos.write(fileBinary);    cachedPacketNum = 0;}
public void metron_f7015_0() throws IOException
{    flush();        baos.close();}
public static String metron_f7016_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    return String.join("_", Arrays.copyOfRange(tokens, 0, tokens.length - 3));}
private static String metron_f7017_0(String s)
{    return s.substring(PREFIX.length());}
public static Long metron_f7018_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    try {        return Long.parseUnsignedLong(tokens[tokens.length - 3]);    } catch (NumberFormatException e) {        return null;    }}
public static Integer metron_f7019_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    try {        return Integer.parseInt(tokens[tokens.length - 2]);    } catch (NumberFormatException e) {        return null;    }}
public static String metron_f7020_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    return tokens[tokens.length - 1];}
public String metron_f7021_0()
{    return name;}
protected MetronEthernetDecoder metron_f7022_0()
{    return createDecoder();}
public static String metron_f7023_0(String topic, long timestamp, String partition, String uuid)
{    return Joiner.on("_").join("pcap", topic, Long.toUnsignedString(timestamp), partition, uuid);}
public static boolean metron_f7024_0(org.apache.metron.spout.pcap.Endianness endianness)
{    return endianness == org.apache.metron.spout.pcap.Endianness.LITTLE;}
public static byte[] metron_f7025_0(Endianness endianness)
{    if (swapBytes(endianness)) {                return new byte[] {         (byte) 0xd4,         (byte) 0xc3,         (byte) 0xb2,         (byte) 0xa1,         0x02,         0x00,         0x04,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         (byte) 0xff,         (byte) 0xff,         0x00,         0x00,         0x01,         0x00,         0x00,         0x00 };    } else {                return new byte[] {         (byte) 0xa1,         (byte) 0xb2,         (byte) 0xc3,         (byte) 0xd4,         0x00,         0x02,         0x00,         0x04,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         (byte) 0xff,         (byte) 0xff,         0x00,         0x00,         0x00,         0x01 };    }}
public static Long metron_f7026_0(byte[] pcap)
{    return getTimestamp(pcap, 0, pcap.length);}
public static Long metron_f7027_1(byte[] pcap, int offset, int length)
{    PcapByteInputStream pcapByteInputStream = null;    try {        pcapByteInputStream = new PcapByteInputStream(pcap, offset, length);        PcapPacket packet = pcapByteInputStream.getPacket();        GlobalHeader globalHeader = pcapByteInputStream.getGlobalHeader();        PacketHeader packetHeader = packet.getPacketHeader();        if (globalHeader.getMagicNumber() == 0xa1b2c3d4 || globalHeader.getMagicNumber() == 0xd4c3b2a1) {                                    return packetHeader.getTsSec() * 1000000000L + packetHeader.getTsUsec() * 1000L;        } else if (globalHeader.getMagicNumber() == 0xa1b23c4d || globalHeader.getMagicNumber() == 0x4d3cb2a1) {                                    return packetHeader.getTsSec() * 1000000000L + packetHeader.getTsUsec();        }                        return packetHeader.getTsSec() * 1000000000L + packetHeader.getTsUsec() * 1000L;    } catch (IOException ioe) {                    } finally {        if (pcapByteInputStream != null) {            try {                pcapByteInputStream.close();            } catch (IOException e) {                            }        }    }    return null;}
public static byte[] metron_f7028_0(long tsNano, byte[] packet, Endianness endianness)
{    byte[] ret = new byte[GLOBAL_HEADER_SIZE + PACKET_HEADER_SIZE + packet.length];    byte[] globalHeader = getPcapGlobalHeader(endianness);    int offset = 0;    System.arraycopy(globalHeader, 0, ret, offset, GLOBAL_HEADER_SIZE);    offset += globalHeader.length;    {        boolean swapBytes = swapBytes(endianness);        long micros = Long.divideUnsigned(tsNano, 1000);        int secs = (int) (micros / 1000000);        int usec = (int) (micros % 1000000);        int capLen = packet.length;        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(secs) : secs);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(usec) : usec);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }    }    System.arraycopy(packet, 0, ret, offset, packet.length);    return ret;}
public static byte[] metron_f7029_0(byte[] packet, Endianness endianness)
{    byte[] globalHeader = getPcapGlobalHeader(endianness);    byte[] ret = new byte[packet.length + GLOBAL_HEADER_SIZE];    int offset = 0;    System.arraycopy(globalHeader, 0, ret, offset, GLOBAL_HEADER_SIZE);    offset += globalHeader.length;    System.arraycopy(packet, 0, ret, offset, packet.length);    return ret;}
public static byte[] metron_f7030_0(long tsNano, byte[] packet, Endianness endianness)
{    boolean swapBytes = swapBytes(endianness);    long micros = Long.divideUnsigned(tsNano, 1000);    int secs = (int) (micros / 1000000);    int usec = (int) (micros % 1000000);    int capLen = packet.length;    byte[] ret = new byte[PACKET_HEADER_SIZE + packet.length];    int offset = 0;    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(secs) : secs);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(usec) : usec);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    System.arraycopy(packet, 0, ret, offset, packet.length);    return ret;}
public static Map<String, Object> metron_f7031_0(PacketInfo pi)
{    Map<String, Object> ret = new HashMap<>();    ret.put(PacketFields.PACKET_DATA.getName(), pi.getPacketBytes());    if (pi.getTcpPacket() != null) {        if (pi.getTcpPacket().getSourceAddress() != null) {            ret.put(org.apache.metron.common.Constants.Fields.SRC_ADDR.getName(), pi.getTcpPacket().getSourceAddress().getHostAddress());        }        if (pi.getTcpPacket().getSource() != null) {            ret.put(org.apache.metron.common.Constants.Fields.SRC_PORT.getName(), pi.getTcpPacket().getSource().getPort());        }        if (pi.getTcpPacket().getDestinationAddress() != null) {            ret.put(org.apache.metron.common.Constants.Fields.DST_ADDR.getName(), pi.getTcpPacket().getDestinationAddress().getHostAddress());        }        if (pi.getTcpPacket().getDestination() != null) {            ret.put(org.apache.metron.common.Constants.Fields.DST_PORT.getName(), pi.getTcpPacket().getDestination().getPort());        }    }    if (pi.getUdpPacket() != null) {        if (pi.getUdpPacket().getSource() != null) {            if (pi.getUdpPacket().getSource().getAddress() != null) {                ret.put(org.apache.metron.common.Constants.Fields.SRC_ADDR.getName(), pi.getUdpPacket().getSource().getAddress().getHostAddress());            }            ret.put(org.apache.metron.common.Constants.Fields.SRC_PORT.getName(), pi.getUdpPacket().getSource().getPort());        }        if (pi.getUdpPacket().getDestination() != null) {            if (pi.getUdpPacket().getDestination().getAddress() != null) {                ret.put(org.apache.metron.common.Constants.Fields.DST_ADDR.getName(), pi.getUdpPacket().getDestination().getAddress().getHostAddress());            }            ret.put(org.apache.metron.common.Constants.Fields.DST_PORT.getName(), pi.getUdpPacket().getDestination().getPort());        }    }    if (pi.getIpv4Packet() != null) {        ret.put(org.apache.metron.common.Constants.Fields.PROTOCOL.getName(), pi.getIpv4Packet().getProtocol());    }    return ret;}
public static List<PacketInfo> metron_f7032_0(byte[] packet) throws IOException
{    return toPacketInfo(ETHERNET_DECODER.get(), packet);}
public static MetronEthernetDecoder metron_f7033_0()
{    MetronEthernetDecoder ethernetDecoder = new MetronEthernetDecoder();    IpDecoder ipDecoder = new IpDecoder();    ethernetDecoder.register(EthernetType.IPV4, ipDecoder);    return ethernetDecoder;}
public static List<PacketInfo> metron_f7034_1(MetronEthernetDecoder decoder, byte[] pcap) throws IOException
{    List<PacketInfo> packetInfoList = new ArrayList<>();    PcapByteInputStream pcapByteInputStream = new PcapByteInputStream(pcap);    GlobalHeader globalHeader = pcapByteInputStream.getGlobalHeader();    while (true) {        try {            PcapPacket packet = pcapByteInputStream.getPacket();                                                TcpPacket tcpPacket = null;            UdpPacket udpPacket = null;                        int sourcePort = 0;            int destinationPort = 0;                                    decoder.decode(packet);            PacketHeader packetHeader = packet.getPacketHeader();            Ipv4Packet ipv4Packet = Ipv4Packet.parse(packet.getPacketData());            if (ipv4Packet.getProtocol() == Constants.PROTOCOL_TCP) {                tcpPacket = TcpPacket.parse(ipv4Packet);            }            if (ipv4Packet.getProtocol() == Constants.PROTOCOL_UDP) {                Buffer packetDataBuffer = ipv4Packet.getData();                sourcePort = packetDataBuffer.getUnsignedShort();                destinationPort = packetDataBuffer.getUnsignedShort();                udpPacket = new UdpPacket(ipv4Packet, sourcePort, destinationPort);                udpPacket.setLength(packetDataBuffer.getUnsignedShort());                udpPacket.setChecksum(packetDataBuffer.getUnsignedShort());                packetDataBuffer.discardReadBytes();                udpPacket.setData(packetDataBuffer);            }            packetInfoList.add(new PacketInfo(globalHeader, packetHeader, packet, ipv4Packet, tcpPacket, udpPacket, pcap));        } catch (NegativeArraySizeException ignored) {                    } catch (EOFException eof) {                        break;        }    }    return packetInfoList;}
public static List<JSONObject> metron_f7035_0(List<PacketInfo> packetInfoList)
{    List<JSONObject> messages = new ArrayList<>();    for (PacketInfo packetInfo : packetInfoList) {        JSONObject message = (JSONObject) JSONValue.parse(packetInfo.getJsonIndexDoc());        messages.add(message);    }    return messages;}
public static boolean metron_f7036_0(long a, long b)
{    return Long.compareUnsigned(a, b) >= 0;}
public static boolean metron_f7037_0(long a, long b)
{    return Long.compareUnsigned(a, b) <= 0;}
public static void metron_f7038_0(ByteArrayOutputStream baos, List<byte[]> pcaps) throws IOException
{    PcapByteInputStream is = null;    PcapByteOutputStream os = null;    ByteArrayOutputStream unsortedBaos = new ByteArrayOutputStream();    try {        int i = 1;        for (byte[] pcap : pcaps) {            is = new PcapByteInputStream(pcap);            if (i == 1) {                os = new PcapByteOutputStream(unsortedBaos, is.getGlobalHeader());            }            writePacket(is, os);            i++;            closeInput(is);        }    } finally {        if (unsortedBaos != null) {            unsortedBaos.close();        }        closeOutput(os);        sort(baos, unsortedBaos.toByteArray());    }}
public static void metron_f7039_0(ByteArrayOutputStream baos, byte[]... pcaps) throws IOException
{    merge(baos, Arrays.asList(pcaps));}
private static void metron_f7040_1(ByteArrayOutputStream baos, byte[] unsortedBytes) throws IOException
{    PcapByteInputStream pcapIs = new PcapByteInputStream(unsortedBytes);    PcapByteOutputStream pcapOs = new PcapByteOutputStream(baos, pcapIs.getGlobalHeader());    PcapPacket packet;    ArrayList<PcapPacket> packetList = new ArrayList<PcapPacket>();    try {        while (true) {            packet = pcapIs.getPacket();            if (packet == null)                break;            packetList.add(packet);                    }    } catch (EOFException e) {        }    Collections.sort(packetList, PCAP_PACKET_COMPARATOR);    for (PcapPacket p : packetList) {        pcapOs.write(p);            }    pcapOs.close();}
private static void metron_f7041_0(PcapByteInputStream is, PcapByteOutputStream os) throws IOException
{    PcapPacket packet = null;    try {        while (true) {            packet = is.getPacket();            if (packet == null) {                break;            }            os.write(packet);        }    } catch (EOFException e) {        }}
private static void metron_f7042_1(PcapByteInputStream is)
{    if (is == null) {        return;    }    try {                is.close();    } catch (IOException e) {            }}
private static void metron_f7043_1(PcapByteOutputStream os)
{    if (os == null) {        return;    }    try {        os.close();    } catch (IOException e) {            }}
public static void metron_f7044_0(String[] args) throws IOException
{    byte[] b1 = FileUtils.readFileToByteArray(new File("/Users/sheetal/Downloads/constructedTcpDump.1.pcap"));    byte[] b2 = FileUtils.readFileToByteArray(new File("/Users/sheetal/Downloads/constructedTcpDump.2.pcap"));    byte[] b3 = FileUtils.readFileToByteArray(new File("/Users/sheetal/Downloads/constructedTcpDump.3.pcap"));        ByteArrayOutputStream boas = new ByteArrayOutputStream();        PcapMerger.merge(boas, b1, b2, b3);    FileUtils.writeByteArrayToFile(new File("/Users/sheetal/Downloads/constructedTcpDump.automerged.1.2.pcap"), boas.toByteArray(), false);}
public int metron_f7045_1(PcapPacket p1, PcapPacket p2)
{    long p1time = p1.getPacketHeader().getTsSec() * 1000000L + p1.getPacketHeader().getTsUsec();    long p2time = p2.getPacketHeader().getTsSec() * 1000000L + p2.getPacketHeader().getTsUsec();        return Long.compare(p1time, p2time);}
public Path metron_f7046_0(int num)
{    return files.get(num);}
public int metron_f7047_0()
{    return files.size();}
public Iterator<Path> metron_f7048_0()
{    return new PcapIterator(files.iterator());}
public boolean metron_f7049_0()
{    return delegateIt.hasNext();}
public Path metron_f7050_0()
{    return delegateIt.next();}
public static Iterable<String> metron_f7051_1(long beginTs, long endTs, Iterable<Path> files)
{    Map<Integer, List<Path>> filesByPartition = getFilesByPartition(files);    List<String> filteredFiles = filterByTimestampLT(beginTs, endTs, filesByPartition);        return filteredFiles;}
public static Map<Integer, List<Path>> metron_f7052_0(Iterable<Path> files)
{    Iterator<Path> filesIt = files.iterator();    Map<Integer, List<Path>> filesByPartition = new HashMap<>();    while (filesIt.hasNext()) {        Path p = filesIt.next();        Integer partition = PcapFilenameHelper.getKafkaPartition(p.getName());        if (!filesByPartition.containsKey(partition)) {            filesByPartition.put(partition, new ArrayList<>());        }        filesByPartition.get(partition).add(p);    }    return filesByPartition;}
public static List<String> metron_f7053_0(long beginTs, long endTs, Map<Integer, List<Path>> filesByPartition)
{    List<String> filteredFiles = new ArrayList<>();    for (Integer key : filesByPartition.keySet()) {        List<Path> paths = filesByPartition.get(key);        filteredFiles.addAll(filterByTimestampLT(beginTs, endTs, paths));    }    return filteredFiles;}
public static List<String> metron_f7054_0(long beginTs, long endTs, List<Path> paths)
{    List<String> filteredFiles = new ArrayList<>();        Collections.sort(paths);    Iterator<Path> filesIt = paths.iterator();    Path leftTrailing = filesIt.hasNext() ? filesIt.next() : null;    if (leftTrailing == null) {        return filteredFiles;    }    boolean first = true;    Long fileTS = PcapFilenameHelper.getTimestamp(leftTrailing.getName());    if (fileTS != null && greaterThanOrEqualTo(fileTS, beginTs) && lessThanOrEqualTo(fileTS, endTs)) {        filteredFiles.add(leftTrailing.toString());        first = false;    }    if (first && !filesIt.hasNext()) {        filteredFiles.add(leftTrailing.toString());        return filteredFiles;    }    while (filesIt.hasNext()) {        Path p = filesIt.next();        fileTS = PcapFilenameHelper.getTimestamp(p.getName());        if (fileTS != null && greaterThanOrEqualTo(fileTS, beginTs) && lessThanOrEqualTo(fileTS, endTs)) {            if (first) {                filteredFiles.add(leftTrailing.toString());                first = false;            }            filteredFiles.add(p.toString());        } else {            leftTrailing = p;        }    }    return filteredFiles;}
public static String metron_f7055_0(String ipAddress)
{    StringBuffer hexIp = new StringBuffer(64);    String[] ipSegments = ipAddress.split("\\.");    for (String ipSegment : ipSegments) {        hexIp.append(convertIpSegmentToHex(ipSegment));    }    return hexIp.toString();}
public static String metron_f7056_0(String hex)
{    List<Integer> ipSegments = new ArrayList<>();    for (int i = 0; i < hex.length(); i += 2) {        String segment = hex.substring(i, i + 2);        ipSegments.add(Integer.parseInt(segment, 16));    }    return Joiner.on(".").join(ipSegments);}
public static String metron_f7057_0(String srcIp, String dstIp, String protocol, String srcPort, String dstPort)
{    return getSessionKey(srcIp, dstIp, protocol, srcPort, dstPort, null, null);}
public static String metron_f7058_0(String srcIp, String dstIp, String protocol, String srcPort, String dstPort, String ipId, String fragmentOffset)
{    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(SESSION_KEY_SEPERATOR).append(convertIpv4IpToHex(dstIp)).append(SESSION_KEY_SEPERATOR).append(protocol == null ? "0" : protocol).append(SESSION_KEY_SEPERATOR).append(srcPort == null ? "0" : srcPort).append(SESSION_KEY_SEPERATOR).append(dstPort == null ? "0" : dstPort).append(SESSION_KEY_SEPERATOR).append(ipId == null ? "0" : ipId).append(SESSION_KEY_SEPERATOR).append(fragmentOffset == null ? "0" : fragmentOffset);    return sb.toString();}
public static String metron_f7059_0(JSONObject message)
{    String srcIp = (String) message.get("ip_src_addr");    String dstIp = (String) message.get("ip_dst_addr");    Long protocol = (Long) message.get("ip_protocol");    Long srcPort = (Long) message.get("ip_src_port");    Long dstPort = (Long) message.get("ip_dst_port");    Long ipId = (Long) message.get("ip_id");    String ipIdString = ipId == null ? null : ipId.toString();    Long fragmentOffset = (Long) message.get("frag_offset");    String fragmentOffsetString = fragmentOffset == null ? null : fragmentOffset.toString();    return PcapUtils.getSessionKey(srcIp, dstIp, protocol.toString(), srcPort.toString(), dstPort.toString(), ipIdString, fragmentOffsetString);}
public static String metron_f7060_0(String srcIp, String dstIp, String protocol, String srcPort, String dstPort)
{    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(SESSION_KEY_SEPERATOR).append(convertIpv4IpToHex(dstIp)).append(SESSION_KEY_SEPERATOR).append(protocol == null ? "0" : protocol).append(SESSION_KEY_SEPERATOR).append(srcPort == null ? "0" : srcPort).append(SESSION_KEY_SEPERATOR).append(dstPort == null ? "0" : dstPort);    return sb.toString();}
public static String metron_f7061_0(String srcIp, String dstIp, int protocol, int srcPort, int dstPort, int ipId, int fragmentOffset)
{    String keySeperator = "-";    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(keySeperator).append(convertIpv4IpToHex(dstIp)).append(keySeperator).append(protocol).append(keySeperator).append(srcPort).append(keySeperator).append(dstPort).append(keySeperator).append(ipId).append(keySeperator).append(fragmentOffset);    return sb.toString();}
public static String metron_f7062_0(String srcIp, String dstIp, int protocol, int srcPort, int dstPort)
{    String keySeperator = "-";    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(keySeperator).append(convertIpv4IpToHex(dstIp)).append(keySeperator).append(protocol).append(keySeperator).append(srcPort).append(keySeperator).append(dstPort);    return sb.toString();}
public static String metron_f7063_0(String ipSegment)
{    return convertIpSegmentToHex(Integer.valueOf(ipSegment));}
public static String metron_f7064_0(int ipSegment)
{    return convertToHex(ipSegment, 2);}
public static String metron_f7065_0(int number, int length)
{    return StringUtils.leftPad(Integer.toHexString(number), length, '0');}
public static String metron_f7066_0(int protocolNumber)
{    String protocolName = protocolIdToNameMap.get(protocolNumber);    if (protocolName == null) {        protocolName = String.valueOf(protocolNumber);    }    return protocolName;}
public static int metron_f7067_0(String protocolName)
{    Integer protocolNumber = protocolNameToIdMap.get(protocolName.toUpperCase());    if (protocolNumber == null) {        protocolNumber = -1;    }    return protocolNumber;}
private static Map<V, K> metron_f7068_0(Map<K, V> map)
{    Map<V, K> inv = new HashMap<V, K>();    for (Entry<K, V> entry : map.entrySet()) inv.put(entry.getValue(), entry.getKey());    return inv;}
public void metron_f7069_0(Configuration config, List<byte[]> pcaps, String outPath) throws IOException
{    HDFSUtils.write(config, mergePcaps(pcaps), outPath);}
public void metron_f7070_0(List<byte[]> pcaps, String outPath) throws IOException
{    File out = new File(outPath);    try (FileOutputStream fos = new FileOutputStream(out)) {        fos.write(mergePcaps(pcaps));    }}
public byte[] metron_f7071_0(List<byte[]> pcaps) throws IOException
{    if (pcaps == null) {        return new byte[] {};    }    if (pcaps.size() == 1) {        return pcaps.get(0);    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PcapMerger.merge(baos, pcaps);    return baos.toByteArray();}
public static Endianness metron_f7072_0()
{    if (ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN)) {        return BIG;    } else {        return LITTLE;    }}
public void metron_f7073_0() throws Exception
{    final LinkedHashMap<String, String> fields = new LinkedHashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    String actual = new FixedPcapFilter.Configurator().queryToString(fields);    String expected = "src_ip_0_dst_ip_1_false";    Assert.assertThat("string representation did not match", actual, equalTo(expected));}
public void metron_f7074_0() throws Exception
{    {        final LinkedHashMap<String, String> fields = new LinkedHashMap<String, String>();        String actual = new FixedPcapFilter.Configurator().queryToString(fields);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        String actual = new FixedPcapFilter.Configurator().queryToString(null);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        final LinkedHashMap<String, String> fields = new LinkedHashMap<String, String>() {            {                put(Constants.Fields.SRC_ADDR.getName(), "");                put(Constants.Fields.SRC_PORT.getName(), "");            }        };        String actual = new FixedPcapFilter.Configurator().queryToString(fields);        String expected = "_";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }}
public void metron_f7075_0() throws Exception
{    Configuration config = new Configuration();    final Map<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected Map<String, Object> metron_f7076_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7077_0() throws Exception
{    Configuration config = new Configuration();    final Map<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "true");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");                        put(Constants.Fields.SRC_PORT.getName(), 1);                        put(Constants.Fields.DST_ADDR.getName(), "src_ip");                        put(Constants.Fields.DST_PORT.getName(), 0);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "src_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected Map<String, Object> metron_f7078_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected Map<String, Object> metron_f7079_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");            put(Constants.Fields.SRC_PORT.getName(), 1);            put(Constants.Fields.DST_ADDR.getName(), "src_ip");            put(Constants.Fields.DST_PORT.getName(), 0);        }    };}
protected Map<String, Object> metron_f7080_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "src_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7081_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip1");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7082_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7083_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip1");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7084_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7085_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7086_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
protected HashMap<String, Object> metron_f7087_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
public void metron_f7088_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7089_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7090_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7091_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7092_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7093_0() throws Exception
{    Assert.assertThat("filter type should be Fixed", PcapFilters.FIXED.create(), instanceOf(FixedPcapFilter.class));    Assert.assertThat("filter type should be Query", PcapFilters.QUERY.create(), instanceOf(QueryPcapFilter.class));}
public void metron_f7094_0() throws Exception
{    String query = "ip_src_addr == 'srcIp' and ip_src_port == '80' and ip_dst_addr == 'dstIp' and ip_dst_port == '100' and protocol == 'protocol'";    String actual = new QueryPcapFilter.Configurator().queryToString(query);    String expected = "ip_src_addr_==_'srcIp'_and_ip_src_port_==_'80'_and_ip_dst_addr_==_'dstIp'_and_ip_dst_port_==_'100'_and_protocol_==_'protocol'";    Assert.assertThat("string representation did not match", actual, equalTo(expected));}
public void metron_f7095_0() throws Exception
{    {        String query = "";        String actual = new QueryPcapFilter.Configurator().queryToString(query);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        String query = " ";        String actual = new QueryPcapFilter.Configurator().queryToString(query);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        String query = null;        String actual = new QueryPcapFilter.Configurator().queryToString(query);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }}
public void metron_f7096_0() throws Exception
{    Configuration config = new Configuration();    String query = "";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        PcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7097_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7098_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_src_port == 0 and ip_dst_addr == 'dst_ip' and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        PcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7099_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7100_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_src_port == 0 and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip_no_match");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7101_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7102_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip_no_match");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7103_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_src_port == 0 and ip_dst_addr == 'dst_ip'";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7104_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7105_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
protected HashMap<String, Object> metron_f7106_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
public void metron_f7107_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_port == 0 and ip_dst_addr == 'dst_ip' and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7108_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7109_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_dst_addr == 'dst_ip' and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7110_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7111_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7112_0()
{    filesIn = new ArrayList<>();    filesIn.add(new Path("/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910"));}
public void metron_f7113_0()
{    Map<Integer, List<Path>> filesByPartition = FileFilterUtil.getFilesByPartition(filesIn);    Map<Integer, List<Path>> expectedFilesPartitioned = new HashMap() {        {            put(0, toList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910"));            put(1, toList("/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910"));            put(2, toList("/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910"));            put(3, toList("/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910"));            put(4, toList("/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910"));        }    };    assertThat(filesByPartition, equalTo(expectedFilesPartitioned));}
private List<Path> metron_f7114_0(String... items)
{    return Arrays.asList(items).stream().map(i -> new Path(i)).collect(Collectors.toList());}
public void metron_f7115_0()
{    Map<Integer, List<Path>> filesByPartition = new HashMap() {        {            put(0, toList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910"));            put(1, toList("/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910"));            put(2, toList("/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910"));            put(3, toList("/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910"));            put(4, toList("/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910"));        }    };    List<String> lt = FileFilterUtil.filterByTimestampLT(1495135377055375000L, 1495135512124943000L, filesByPartition);    List<String> expectedFiles = Arrays.asList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910");    assertThat(lt, equalTo(expectedFiles));}
public void metron_f7116_0()
{    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(1495135377055375000L, 1495135512124943000L, filesIn);    List<String> expectedFiles = Arrays.asList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910");    assertThat(paths, equalTo(expectedFiles));}
public void metron_f7117_0() throws Exception
{    final List<Path> inputFiles = new ArrayList<Path>();    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(0, 1000, inputFiles);    Assert.assertTrue(Iterables.isEmpty(paths));}
public void metron_f7118_0() throws Exception
{    final long firstFileTSNanos = 1461589332993573000L;    final long secondFileTSNanos = 1561589332993573000L;    final List<Path> inputFiles = new ArrayList<Path>() {        {            add(new Path("/apps/metron/pcap/pcap_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            add(new Path("/apps/metron/pcap/pcap_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));        }    };    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(0, secondFileTSNanos - 1L, inputFiles);    Assert.assertEquals(1, Iterables.size(paths));}
public void metron_f7119_0() throws Exception
{    final long firstFileTSNanos = 1461589332993573000L;    final long secondFileTSNanos = 1461589333993573000L;    final long thirdFileTSNanos = 1461589334993573000L;    {        final List<Path> inputFiles = new ArrayList<Path>() {            {                add(new Path("/apps/metron/pcap/pcap0_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));                add(new Path("/apps/metron/pcap/pcap1_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            }        };        Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(secondFileTSNanos - 1L, secondFileTSNanos + 1L, inputFiles);        Assert.assertEquals(2, Iterables.size(paths));    }    {        final List<Path> inputFiles = new ArrayList<Path>() {            {                add(new Path("/apps/metron/pcap/pcap0_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));                add(new Path("/apps/metron/pcap/pcap1_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));                add(new Path("/apps/metron/pcap/pcap1_pcap_" + thirdFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            }        };        Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(thirdFileTSNanos - 1L, thirdFileTSNanos + 1L, inputFiles);        Assert.assertEquals(2, Iterables.size(paths));    }}
public void metron_f7120_0() throws Exception
{    final long firstFileTSNanos = 1461589332993573000L;    final long secondFileTSNanos = 1461589333993573000L;    final long thirdFileTSNanos = 1461589334993573000L;    final List<Path> inputFiles = new ArrayList<Path>() {        {            add(new Path("/apps/metron/pcap/pcap_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            add(new Path("/apps/metron/pcap/pcap_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            add(new Path("/apps/metron/pcap/pcap1_pcap_" + thirdFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));        }    };    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(0, thirdFileTSNanos + 1L, inputFiles);    Assert.assertEquals(3, Iterables.size(paths));}
public void metron_f7121_0() throws Exception
{    long beginNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    long endNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    String query = "ip_dst_addr == '207.28.210.1' and protocol == 'PROTOCOL: ICMP(1)";    String queryFilterString = new QueryPcapFilter.Configurator().queryToString(query);    OutputDirFormatter formatter = new OutputDirFormatter();    String actual = formatter.format(beginNS, endNS, queryFilterString);    assertThat("Formatted directory names did not match.", actual, containsString("_ip_dst_addr_==_207-28-210-1_and_protocol_==_PROTOCOL_ICMP(1)_"));        new Path(actual);}
public void metron_f7122_0() throws Exception
{    long beginNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    long endNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    Map<String, String> fields = new HashMap<>();    fields.put("ip_src_address", "207.28.210.1");    fields.put("protocol", "PROTOCOL: ICMP(1)");    String fixedFilterString = new FixedPcapFilter.Configurator().queryToString(fields);    OutputDirFormatter formatter = new OutputDirFormatter();    String actual = formatter.format(beginNS, endNS, fixedFilterString);    assertThat("Formatted directory names did not match.", actual, containsString("PROTOCOL_ICMP(1)_207-28-210-1"));        new Path(actual);}
public void metron_f7123_0() throws IOException
{    MockitoAnnotations.initMocks(this);    basePath = new Path("basepath");    baseOutPath = new Path("outpath");    startTime = 100;    endTime = 200;    numReducers = 5;    numRecordsPerFile = 5;    fixedFields = new HashMap<>();    fixedFields.put("ip_src_addr", "192.168.1.1");    hadoopConfig = new Configuration();    fileSystem = FileSystem.get(hadoopConfig);    finalOutputPath = new Path("finaloutpath");    when(jobId.toString()).thenReturn(jobIdVal);    when(mrStatus.getJobID()).thenReturn(jobId);    when(mrJob.getJobID()).thenReturn(jobId);    pageableResult = new PcapPages();    timer = new TestTimer();        config = new FixedPcapConfig(clock -> "clockprefix");    PcapOptions.HADOOP_CONF.put(config, hadoopConfig);    PcapOptions.FILESYSTEM.put(config, FileSystem.get(hadoopConfig));    PcapOptions.BASE_PATH.put(config, basePath);    PcapOptions.BASE_INTERIM_RESULT_PATH.put(config, baseOutPath);    PcapOptions.START_TIME_NS.put(config, startTime);    PcapOptions.END_TIME_NS.put(config, endTime);    PcapOptions.NUM_REDUCERS.put(config, numReducers);    PcapOptions.FIELDS.put(config, fixedFields);    PcapOptions.FILTER_IMPL.put(config, new FixedPcapFilter.Configurator());    PcapOptions.NUM_RECORDS_PER_FILE.put(config, numRecordsPerFile);    PcapOptions.FINAL_OUTPUT_PATH.put(config, finalOutputPath);    testJob = new TestJob<>(mrJob);    testJob.setStatusInterval(1);    testJob.setCompleteCheckInterval(1);    testJob.setTimer(timer);}
public Job metron_f7124_0(Optional<String> jobName, Path basePath, Path outputPath, long beginNS, long endNS, int numReducers, T fields, Configuration conf, FileSystem fs, PcapFilterConfigurator<T> filterImpl) throws IOException
{    return mrJob;}
public void metron_f7125_0(TimerTask task, long delay, long period)
{    this.task = task;}
public void metron_f7126_0()
{    task.run();}
public void metron_f7127_0() throws Exception
{    long start = 1473897600000000000L;    long end = TimestampConverters.MILLISECONDS.toNanoseconds(1473995927455L);    Configuration conf = new Configuration();    conf.set(PcapJob.START_TS_CONF, toUnsignedString(start));    conf.set(PcapJob.END_TS_CONF, toUnsignedString(end));    conf.set(PcapJob.WIDTH_CONF, "" + PcapJob.findWidth(start, end, 10));    PcapJob.PcapPartitioner partitioner = new PcapJob.PcapPartitioner();    partitioner.setConf(conf);    Assert.assertThat("Partition not in range", partitioner.getPartition(new LongWritable(1473978789181189000L), new BytesWritable(), 10), equalTo(8));}
public void metron_f7128_0() throws Exception
{    pageableResult = new PcapPages(Arrays.asList(new Path("1.txt"), new Path("2.txt"), new Path("3.txt")));    when(finalizer.finalizeJob(any())).thenReturn(pageableResult);    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    Assert.assertThat(results.getSize(), equalTo(3));    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.SUCCEEDED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(status.getJobId(), equalTo(jobIdVal));}
public void metron_f7129_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.FAILED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.FAILED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(results.getSize(), equalTo(0));}
public void metron_f7130_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.KILLED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.KILLED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(results.getSize(), equalTo(0));}
public void metron_f7131_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.SUCCEEDED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));}
public void metron_f7132_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(false);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.RUNNING);    when(mrJob.getStatus()).thenReturn(mrStatus);    when(mrJob.mapProgress()).thenReturn(0.5f);    when(mrJob.reduceProgress()).thenReturn(0f);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.RUNNING));    Assert.assertThat(status.getDescription(), equalTo("map: 50.0%, reduce: 0.0%"));    Assert.assertThat(status.getPercentComplete(), equalTo(25.0 * 0.75));    when(mrJob.mapProgress()).thenReturn(1.0f);    when(mrJob.reduceProgress()).thenReturn(0.5f);    timer.updateJobStatus();    status = statusable.getStatus();    Assert.assertThat(status.getDescription(), equalTo("map: 100.0%, reduce: 50.0%"));    Assert.assertThat(status.getPercentComplete(), equalTo(75.0 * 0.75));    when(mrJob.mapProgress()).thenReturn(1.0f);    when(mrJob.reduceProgress()).thenReturn(1.0f);    timer.updateJobStatus();    status = statusable.getStatus();    Assert.assertThat(status.getDescription(), equalTo("map: 100.0%, reduce: 100.0%"));    Assert.assertThat(status.getPercentComplete(), equalTo(75.0));    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.mapProgress()).thenReturn(1.0f);    when(mrJob.reduceProgress()).thenReturn(1.0f);    timer.updateJobStatus();    status = statusable.getStatus();    Assert.assertThat(status.getDescription(), equalTo("Job completed."));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));}
public void metron_f7133_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(false);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.RUNNING);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    statusable.kill();    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.KILLED);    timer.updateJobStatus();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.KILLED));}
public void metron_f7134_0() throws Exception
{    PcapOptions.START_TIME_NS.put(config, null);    PcapOptions.END_TIME_NS.put(config, null);    PcapOptions.NUM_REDUCERS.put(config, null);    PcapOptions.NUM_RECORDS_PER_FILE.put(config, null);    pageableResult = new PcapPages(Arrays.asList(new Path("1.txt"), new Path("2.txt"), new Path("3.txt")));    when(finalizer.finalizeJob(any())).thenReturn(pageableResult);    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    Assert.assertThat(results.getSize(), equalTo(3));    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.SUCCEEDED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(status.getJobId(), equalTo(jobIdVal));}
public void metron_f7135_0() throws Exception
{    Map<String, Object> configuration = new HashMap<>();    testJob.setConfiguration(configuration);    testJob.setMrJob(mrJob);    testJob.setJobStatus(new JobStatus().withState(State.SUCCEEDED));    testJob.get();    verify(mrJob, times(0)).monitorAndPrintJob();    PcapOptions.PRINT_JOB_STATUS.put(configuration, true);    testJob.get();    verify(mrJob, times(1)).monitorAndPrintJob();    verifyNoMoreInteractions(mrJob);}
public boolean metron_f7136_0(String pattern, byte[] data)
{    return evaluator.evaluate(pattern, data);}
public static Collection<Object[]> metron_f7137_0()
{    List<Object[]> strategies = new ArrayList<>();    for (EvaluationStrategy s : EvaluationStrategy.values()) {        strategies.add(new Object[] { s });    }    return strategies;}
public void metron_f7138_0() throws ExecutionException
{    Assert.assertTrue(strategy.evaluate("`metron`", "metron".getBytes(StandardCharsets.UTF_8)));    Assert.assertTrue(strategy.evaluate("`metron`", "metron example".getBytes(StandardCharsets.UTF_8)));    Assert.assertTrue(strategy.evaluate("`metron`", "edward metron example".getBytes(StandardCharsets.UTF_8)));    Assert.assertFalse(strategy.evaluate("`metron`", "apache".getBytes(StandardCharsets.UTF_8)));}
public void metron_f7139_0() throws ExecutionException
{    Assert.assertTrue(strategy.evaluate("2f56abd814bc56420489ca38e7faf8cec3d4", REALPACKET));    Assert.assertTrue(strategy.evaluate("2f56..14bc56420489ca38e7faf8cec3d4", REALPACKET));    Assert.assertTrue(strategy.evaluate("(2f56)(.){2}(14bc56420489ca38e7faf8cec3d4)", REALPACKET));    Assert.assertFalse(strategy.evaluate("(3f56)(.){2}(14bc56420489ca38e7faf8cec3d4)", REALPACKET));    Assert.assertFalse(strategy.evaluate("3f56abd814bc56420489ca38e7faf8cec3d4", REALPACKET));    Assert.assertTrue(strategy.evaluate("deadbeef", join(DEADBEEF, "metron".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef", join(DEADBEEF, "metron".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef `metron`", join(DEADBEEF, "metron".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef `metron`", join(DEADBEEF, "metronjones".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef `metron`", join(DEADBEEF, "metronjones".getBytes(StandardCharsets.UTF_8), DEADBEEF)));    Assert.assertTrue(strategy.evaluate("([ff]){4}", ALLFS));    Assert.assertFalse(strategy.evaluate("([ff]){6}", ALLFS));    Assert.assertTrue(strategy.evaluate("[^ff]", new byte[] { (byte) 0x00 }));    Assert.assertTrue(strategy.evaluate("&01", new byte[] { (byte) 0x07 }));    Assert.assertFalse(strategy.evaluate("&01", new byte[] { (byte) 0x00 }));    Assert.assertTrue(strategy.evaluate("&01", new byte[] { (byte) 0x00, (byte) 0x01 }));    Assert.assertTrue(strategy.evaluate("(dead).{2}(beef)", DEADBEEF_DONUTHOLE));}
public byte[] metron_f7140_0(byte[]... array)
{    byte[] ret;    int size = 0;    for (int i = 0; i < array.length; ++i) {        size += array[i].length;    }    ret = new byte[size];    int j = 0;    for (int i = 0; i < array.length; ++i) {        for (int k = 0; k < array[i].length; ++k, ++j) {            ret[j] = array[i][k];        }    }    return ret;}
public void metron_f7141_0()
{    {        String pcapFilename = "pcap_pcap128_1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap128"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));        assertThat(PcapFilenameHelper.getKafkaPartition(pcapFilename), equalTo(18));        assertThat(PcapFilenameHelper.getUUID(pcapFilename), equalTo("pcap-63-1495027314"));    }    {        String pcapFilename = "pcap_pcap-128_1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap-128"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }    {        String pcapFilename = "pcap_pcap_128_1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap_128"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }    {        String pcapFilename = "pcap_pcap___128___1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap___128__"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }    {        String pcapFilename = "pcap___pcap___128___1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("__pcap___128__"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }}
public void metron_f7142_0()
{    String pcapFilename = "pcap_pcap128_AAA4962815457986000_BB_pcap-63-1495027314";    assertThat(PcapFilenameHelper.getTimestamp(pcapFilename), equalTo(null));    assertThat(PcapFilenameHelper.getKafkaPartition(pcapFilename), equalTo(null));}
public static List<byte[]> metron_f7143_0(String pcapLoc) throws IOException
{    SequenceFile.Reader reader = new SequenceFile.Reader(new Configuration(), SequenceFile.Reader.file(new Path(pcapLoc)));    List<byte[]> ret = new ArrayList<>();    IntWritable key = new IntWritable();    BytesWritable value = new BytesWritable();    while (reader.next(key, value)) {        byte[] pcapWithHeader = value.copyBytes();        ret.add(pcapWithHeader);    }    return ret;}
public static byte[] metron_f7144_0(byte[] pcap)
{    byte[] ret = new byte[pcap.length - PcapHelper.GLOBAL_HEADER_SIZE - PcapHelper.PACKET_HEADER_SIZE];    int offset = PcapHelper.GLOBAL_HEADER_SIZE + PcapHelper.PACKET_HEADER_SIZE;    System.arraycopy(pcap, offset, ret, 0, ret.length);    return ret;}
public void metron_f7145_0() throws Exception
{    String pcapSampleFiles = "../metron-integration-test/src/main/sample/data/SampleInput/PCAPExampleOutput";    List<byte[]> pcaps = readSamplePackets(pcapSampleFiles);    for (byte[] pcap : pcaps) {        long ts = PcapHelper.getTimestamp(pcap);        byte[] stripped = stripHeaders(pcap);        byte[] reconstitutedPacket = PcapHelper.addGlobalHeader(PcapHelper.addPacketHeader(ts, stripped, Endianness.getNativeEndianness()), Endianness.getNativeEndianness());        if (!Arrays.equals(reconstitutedPacket, pcap)) {            int eSecs = Bytes.toInt(pcap, 25);            int rSec = Bytes.toInt(reconstitutedPacket, 25);            System.out.println(eSecs + " vs " + rSec);            for (int i = 0; i < reconstitutedPacket.length; ++i) {                System.out.println((i + 1) + ". " + String.format("%02X", pcap[i]) + " = " + String.format("%02X", reconstitutedPacket[i]));            }            Assert.assertArrayEquals(reconstitutedPacket, pcap);        }    }}
public void metron_f7146_0() throws Exception
{    PacketInfo packetInfo = mock(PacketInfo.class);    when(packetInfo.getPacketBytes()).thenReturn("packet bytes".getBytes(StandardCharsets.UTF_8));    TcpPacket tcpPacket = mock(TcpPacket.class);        InetAddress tcpSourceInetAddress = mock(InetAddress.class);    when(tcpSourceInetAddress.getHostAddress()).thenReturn("tcp source address");    when(tcpPacket.getSourceAddress()).thenReturn(tcpSourceInetAddress);    InetSocketAddress tcpSourceInetSocketAddress = new InetSocketAddress(22);    when(tcpPacket.getSource()).thenReturn(tcpSourceInetSocketAddress);        InetAddress tcpDestinationInetAddress = mock(InetAddress.class);    when(tcpDestinationInetAddress.getHostAddress()).thenReturn("tcp destination address");    when(tcpPacket.getDestinationAddress()).thenReturn(tcpDestinationInetAddress);    InetSocketAddress tcpDestinationInetSocketAddress = new InetSocketAddress(55791);    when(tcpPacket.getDestination()).thenReturn(tcpDestinationInetSocketAddress);    when(packetInfo.getTcpPacket()).thenReturn(tcpPacket);    Ipv4Packet ipv4Packet = mock(Ipv4Packet.class);    when(ipv4Packet.getProtocol()).thenReturn(6);    when(packetInfo.getIpv4Packet()).thenReturn(ipv4Packet);    Map<String, Object> actualFields = PcapHelper.packetToFields(packetInfo);    Assert.assertArrayEquals("packet bytes".getBytes(StandardCharsets.UTF_8), (byte[]) actualFields.get(PcapHelper.PacketFields.PACKET_DATA.getName()));    Assert.assertEquals("tcp source address", actualFields.get(Fields.SRC_ADDR.getName()));    Assert.assertEquals(22, actualFields.get(Fields.SRC_PORT.getName()));    Assert.assertEquals("tcp destination address", actualFields.get(Fields.DST_ADDR.getName()));    Assert.assertEquals(55791, actualFields.get(Fields.DST_PORT.getName()));    Assert.assertEquals(6, actualFields.get(Fields.PROTOCOL.getName()));}
public void metron_f7147_0() throws Exception
{    PacketInfo packetInfo = mock(PacketInfo.class);    when(packetInfo.getPacketBytes()).thenReturn("packet bytes".getBytes(StandardCharsets.UTF_8));    UdpPacket udpPacket = mock(UdpPacket.class);        InetAddress udpSourceInetAddress = mock(InetAddress.class);    when(udpSourceInetAddress.getHostAddress()).thenReturn("udp source address");    InetSocketAddress udpSourceInetSocketAddress = new InetSocketAddress(udpSourceInetAddress, 68);    when(udpPacket.getSource()).thenReturn(udpSourceInetSocketAddress);        InetAddress udpDestinationInetAddress = mock(InetAddress.class);    when(udpDestinationInetAddress.getHostAddress()).thenReturn("udp destination address");    InetSocketAddress udpDestinationInetSocketAddress = new InetSocketAddress(udpDestinationInetAddress, 67);    when(udpPacket.getDestination()).thenReturn(udpDestinationInetSocketAddress);    when(packetInfo.getUdpPacket()).thenReturn(udpPacket);    Ipv4Packet ipv4Packet = mock(Ipv4Packet.class);    when(ipv4Packet.getProtocol()).thenReturn(17);    when(packetInfo.getIpv4Packet()).thenReturn(ipv4Packet);    Map<String, Object> actualFields = PcapHelper.packetToFields(packetInfo);    Assert.assertArrayEquals("packet bytes".getBytes(StandardCharsets.UTF_8), (byte[]) actualFields.get(PcapHelper.PacketFields.PACKET_DATA.getName()));    Assert.assertEquals("udp source address", actualFields.get(Fields.SRC_ADDR.getName()));    Assert.assertEquals(68, actualFields.get(Fields.SRC_PORT.getName()));    Assert.assertEquals("udp destination address", actualFields.get(Fields.DST_ADDR.getName()));    Assert.assertEquals(67, actualFields.get(Fields.DST_PORT.getName()));    Assert.assertEquals(17, actualFields.get(Fields.PROTOCOL.getName()));}
public void metron_f7148_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket packet = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket packet2 = new PcapPacket(ph2, EMPTY_PAYLOAD);    assertEquals("Timestamps should be equal", comp.compare(packet, packet2), 0);    assertEquals("Timestamps should be equal", comp.compare(packet2, packet), 0);}
public void metron_f7149_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_PLUS_ONE_SECOND_SECONDS, 0, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7150_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_SECONDS, 1, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7151_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_PLUS_ONE_SECOND_SECONDS, 1, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7152_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_PLUS_TWENTY_YEARS_SECONDS, 999999, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7153_0()
{    Path path1 = new Path("/1.txt");    Path path2 = new Path("/2.txt");    Path path3 = new Path("/3.txt");    List<Path> paths = new ArrayList<>();    paths.add(path1);    paths.add(path2);    paths.add(path3);    PcapPages pages = new PcapPages(paths);    assertThat("Wrong num pages.", pages.getSize(), equalTo(3));    for (int i = 0; i < pages.getSize(); i++) {        assertThat("Page should be equal", pages.getPage(i).toString(), equalTo(paths.get(i).toString()));    }}
public void metron_f7154_0()
{    Path path1 = new Path("/1.txt");    Path path2 = new Path("/2.txt");    Path path3 = new Path("/3.txt");    List<Path> paths = new ArrayList<>();    paths.add(path1);    paths.add(path2);    paths.add(path3);    PcapPages pages = new PcapPages(paths);    PcapPages clonedPages = new PcapPages(pages);    assertThat(clonedPages, notNullValue());    assertThat(clonedPages.getSize(), equalTo(3));    assertThat(clonedPages, not(sameInstance(pages)));    for (int i = 0; i < pages.getSize(); i++) {        assertThat("Page should be different instance.", pages.getPage(i), not(sameInstance(clonedPages.getPage(i))));        assertThat("Page should be same path.", pages.getPage(i), equalTo(clonedPages.getPage(i)));    }}
public void metron_f7155_0()
{    String hex = "c0a88a9e";    String ipAddress = PcapUtils.convertHexToIpv4Ip(hex);    Assert.assertEquals("192.168.138.158", ipAddress);}
public Options metron_f7156_0()
{    Options options = new Options();    options.addOption(newOption("h", "help", false, "Display help"));    options.addOption(newOption("bp", "base_path", true, String.format("Base PCAP data path. Default is '%s'", BASE_INPUT_PATH_DEFAULT)));    options.addOption(newOption("bop", "base_output_path", true, String.format("Query result output path. Default is '%s'", BASE_INTERIM_RESULT_PATH_DEFAULT)));    options.addOption(newOption("st", "start_time", true, "(required) Packet start time range.", true));    options.addOption(newOption("nr", "num_reducers", true, String.format("Number of reducers to use (defaults to %s)", NUM_REDUCERS_DEFAULT)));    options.addOption(newOption("rpf", "records_per_file", true, String.format("Number of records to include in each output pcap file (defaults to %s)", NUM_RECORDS_PER_FILE_DEFAULT)));    options.addOption(newOption("et", "end_time", true, "Packet end time range. Default is current system time."));    options.addOption(newOption("df", "date_format", true, "Date format to use for parsing start_time and end_time. Default is to use time in millis since the epoch."));    options.addOption(newOption("yq", "yarn_queue", true, "Yarn queue this job will be submitted to"));    options.addOption(newOption("ft", "finalizer_threads", true, "Number of threads to use for the final output writing."));    return options;}
protected Option metron_f7157_0(String opt, String longOpt, boolean hasArg, String desc)
{    return newOption(opt, longOpt, hasArg, desc, false);}
protected Option metron_f7158_0(String opt, String longOpt, boolean hasArg, String desc, boolean required)
{    Option option = new Option(opt, longOpt, hasArg, desc);    option.setRequired(required);    return option;}
public void metron_f7159_0(CommandLine commandLine, PcapConfig config) throws java.text.ParseException
{    if (commandLine.hasOption("help")) {        config.setShowHelp(true);    }    if (commandLine.hasOption("date_format")) {        config.setDateFormat(commandLine.getOptionValue("date_format"));    }    if (commandLine.hasOption("base_path")) {        config.setBasePath(commandLine.getOptionValue("base_path"));    } else {        config.setBasePath(BASE_INPUT_PATH_DEFAULT);    }    if (commandLine.hasOption("base_output_path")) {        config.setBaseInterimResultPath(commandLine.getOptionValue("base_output_path"));    } else {        config.setBaseInterimResultPath(BASE_INTERIM_RESULT_PATH_DEFAULT);    }    if (commandLine.hasOption("start_time")) {        try {            if (commandLine.hasOption("date_format")) {                long startTime = config.getDateFormat().parse(commandLine.getOptionValue("start_time")).getTime();                config.setStartTimeMs(startTime);            } else {                long startTime = Long.parseLong(commandLine.getOptionValue("start_time"));                config.setStartTimeMs(startTime);            }        } catch (NumberFormatException nfe) {                }    }    if (commandLine.hasOption("num_reducers")) {        int numReducers = Integer.parseInt(commandLine.getOptionValue("num_reducers"));        config.setNumReducers(numReducers);    } else {        config.setNumReducers(NUM_REDUCERS_DEFAULT);    }    if (commandLine.hasOption("records_per_file")) {        int numRecordsPerFile = Integer.parseInt(commandLine.getOptionValue("records_per_file"));        config.setNumRecordsPerFile(numRecordsPerFile);    } else {        config.setNumRecordsPerFile(NUM_RECORDS_PER_FILE_DEFAULT);    }    if (commandLine.hasOption("end_time")) {        try {            if (commandLine.hasOption("date_format")) {                long endTime = config.getDateFormat().parse(commandLine.getOptionValue("end_time")).getTime();                config.setEndTimeMs(endTime);            } else {                long endTime = Long.parseLong(commandLine.getOptionValue("end_time"));                config.setEndTimeMs(endTime);            }        } catch (NumberFormatException nfe) {                }    }    if (commandLine.hasOption("yarn_queue")) {        config.setYarnQueue(commandLine.getOptionValue("yarn_queue"));    }    if (commandLine.hasOption("finalizer_threads")) {        String numThreads = commandLine.getOptionValue("finalizer_threads");        config.setFinalizerThreadpoolSize(numThreads);    } else {        config.setFinalizerThreadpoolSize(NUM_FINALIZER_THREADS_DEFAULT);    }}
public void metron_f7160_0(String msg, Options opts)
{    new HelpFormatter().printHelp(msg, opts);}
protected CommandLineParser metron_f7161_0()
{    return parser;}
private Options metron_f7162_0()
{    Options options = buildOptions();    options.addOption(newOption("sa", "ip_src_addr", true, "Source IP address"));    options.addOption(newOption("da", "ip_dst_addr", true, "Destination IP address"));    options.addOption(newOption("sp", "ip_src_port", true, "Source port"));    options.addOption(newOption("dp", "ip_dst_port", true, "Destination port"));    options.addOption(newOption("p", "protocol", true, "IP Protocol"));    options.addOption(newOption("pf", "packet_filter", true, "Packet Filter regex"));    options.addOption(newOption("pre", "prefix", true, "Result file prefix to use"));    options.addOption(newOption("ir", "include_reverse", false, "Indicates if filter should check swapped src/dest addresses and IPs"));    return options;}
public FixedPcapConfig metron_f7163_0(String[] args) throws ParseException, java.text.ParseException
{    CommandLine commandLine = getParser().parse(fixedOptions, args);    FixedPcapConfig config = new FixedPcapConfig(prefixStrategy);    super.parse(commandLine, config);    config.putFixedField(Constants.Fields.SRC_ADDR.getName(), commandLine.getOptionValue("ip_src_addr"));    config.putFixedField(Constants.Fields.DST_ADDR.getName(), commandLine.getOptionValue("ip_dst_addr"));    config.putFixedField(Constants.Fields.SRC_PORT.getName(), commandLine.getOptionValue("ip_src_port"));    config.putFixedField(Constants.Fields.DST_PORT.getName(), commandLine.getOptionValue("ip_dst_port"));    config.putFixedField(Constants.Fields.PROTOCOL.getName(), commandLine.getOptionValue("protocol"));    config.putFixedField(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), Boolean.toString(commandLine.hasOption("include_reverse")));    config.putFixedField(PcapHelper.PacketFields.PACKET_FILTER.getName(), commandLine.getOptionValue("packet_filter"));    if (commandLine.hasOption("prefix")) {        config.setFinalFilenamePrefix(commandLine.getOptionValue("prefix"));    }    return config;}
public void metron_f7164_0()
{    super.printHelp("Fixed filter options", fixedOptions);}
public static void metron_f7165_0(String[] args)
{    int status = new PcapCli(new PcapJob(), PREFIX_STRATEGY).run(args);    System.exit(status);}
public int metron_f7166_1(String[] args)
{    if (args.length < 1) {        printBasicHelp();        return -1;    }    String jobType = args[0];    String[] commandArgs = Arrays.copyOfRange(args, 1, args.length);    Configuration hadoopConf = new Configuration();    String[] otherArgs = null;    try {        otherArgs = new GenericOptionsParser(hadoopConf, commandArgs).getRemainingArgs();    } catch (IOException e) {                return -1;    }    PcapConfig commonConfig = null;    Pageable<Path> results;        String execDir = System.getProperty("user.dir");    if ("fixed".equals(jobType)) {        FixedCliParser fixedParser = new FixedCliParser(prefixStrategy);        FixedPcapConfig config = null;        try {            config = fixedParser.parse(otherArgs);            commonConfig = config;            PcapOptions.FINAL_OUTPUT_PATH.put(commonConfig, new Path(execDir));        } catch (ParseException | java.text.ParseException e) {            System.err.println(e.getMessage());            System.err.flush();            fixedParser.printHelp();            return -1;        }        if (config.showHelp()) {            fixedParser.printHelp();            return 0;        }        PcapOptions.FILTER_IMPL.put(commonConfig, new FixedPcapFilter.Configurator());        config.getYarnQueue().ifPresent(s -> hadoopConf.set(MRJobConfig.QUEUE_NAME, s));        PcapOptions.HADOOP_CONF.put(commonConfig, hadoopConf);        try {            PcapOptions.FILESYSTEM.put(commonConfig, FileSystem.get(hadoopConf));            results = jobRunner.submit(PcapFinalizerStrategies.CLI, commonConfig).get();        } catch (IOException | InterruptedException | JobException e) {                        return -1;        }    } else if ("query".equals(jobType)) {        QueryCliParser queryParser = new QueryCliParser(prefixStrategy);        QueryPcapConfig config = null;        try {            config = queryParser.parse(otherArgs);            commonConfig = config;            PcapOptions.FINAL_OUTPUT_PATH.put(commonConfig, new Path(execDir));        } catch (ParseException | java.text.ParseException e) {            System.err.println(e.getMessage());            queryParser.printHelp();            return -1;        }        if (config.showHelp()) {            queryParser.printHelp();            return 0;        }        PcapOptions.FILTER_IMPL.put(commonConfig, new FixedPcapFilter.Configurator());        config.getYarnQueue().ifPresent(s -> hadoopConf.set(MRJobConfig.QUEUE_NAME, s));        PcapOptions.HADOOP_CONF.put(commonConfig, hadoopConf);        try {            PcapOptions.FILESYSTEM.put(commonConfig, FileSystem.get(hadoopConf));            results = jobRunner.submit(PcapFinalizerStrategies.CLI, commonConfig).get();        } catch (IOException | InterruptedException | JobException e) {                        return -1;        }    } else {        printBasicHelp();        return -1;    }    return 0;}
private Pair<Long, Long> metron_f7167_0(long start, long end)
{    long revisedStart = start;    if (revisedStart < 0) {        revisedStart = 0L;    }    long revisedEnd = end;    if (revisedEnd < 0) {        revisedEnd = System.currentTimeMillis();    }        revisedStart = TimestampConverters.MILLISECONDS.toNanoseconds(revisedStart);    revisedEnd = TimestampConverters.MILLISECONDS.toNanoseconds(revisedEnd);    return Pair.of(revisedStart, revisedEnd);}
public void metron_f7168_0()
{    System.out.println("Usage: [fixed|query]");}
private Options metron_f7169_0()
{    Options options = buildOptions();    options.addOption(newOption("q", "query", true, "Query string to use as a filter"));    options.addOption(newOption("pre", "prefix", true, "Result file prefix to use"));    return options;}
public QueryPcapConfig metron_f7170_0(String[] args) throws ParseException, java.text.ParseException
{    CommandLine commandLine = getParser().parse(queryOptions, args);    QueryPcapConfig config = new QueryPcapConfig(prefixStrategy);    super.parse(commandLine, config);    if (commandLine.hasOption("query")) {        config.setQuery(commandLine.getOptionValue("query"));    }    if (commandLine.hasOption("prefix")) {        config.setFinalFilenamePrefix(commandLine.getOptionValue("prefix"));    }    return config;}
public void metron_f7171_0()
{    super.printHelp("Query filter options", queryOptions);}
public static KeyValueDeserializer metron_f7172_0(String scheme, TimestampConverter converter)
{    try {        Deserializers ts = Deserializers.valueOf(scheme.toUpperCase());        return ts.creator.apply(converter);    } catch (IllegalArgumentException iae) {        return Deserializers.FROM_KEY.creator.apply(converter);    }}
public static KeyValueDeserializer metron_f7173_0(String scheme, String converter)
{    return create(scheme, TimestampConverters.getConverter(converter));}
public Result metron_f7174_0(byte[] key, byte[] value)
{    if (key == null) {        throw new IllegalArgumentException("Expected a key but none provided");    }    long ts = converter.toNanoseconds(fromBytes(key));    return new Result(ts, PcapHelper.addHeaders(ts, value, endianness), true);}
private static long metron_f7175_0(byte[] data)
{    long value = 0L;    int len = data.length;    for (int i = 0; i < len; ++i) {        byte b = data[i];                value <<= 8;                value |= (long) (b & 255);    }    return value;}
public Result metron_f7176_0(byte[] key, byte[] value)
{    Long ts = PcapHelper.getTimestamp(value);    if (ts != null) {        return new Result(ts, value, true);    } else {        return new Result(ts, value, false);    }}
public boolean metron_f7177_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Partition partition1 = (Partition) o;    if (partition != partition1.partition)        return false;    return topic != null ? topic.equals(partition1.topic) : partition1.topic == null;}
public int metron_f7178_0()
{    int result = topic != null ? topic.hashCode() : 0;    result = 31 * result + partition;    return result;}
public String metron_f7179_0()
{    return "Partition{" + "topic='" + topic + '\'' + ", partition=" + partition + '}';}
public HDFSWriterCallback metron_f7180_1(HDFSWriterConfig config)
{        this.config = config;    return this;}
public List<Object> metron_f7181_1(List<Object> tuple, EmitContext context)
{    byte[] key = (byte[]) tuple.get(0);    byte[] value = (byte[]) tuple.get(1);    long tsDeserializeStart = System.nanoTime();    KeyValueDeserializer.Result result = config.getDeserializer().deserializeKeyValue(key, value);    long tsDeserializeEnd = System.nanoTime();    if (LOG.isDebugEnabled() && !result.foundTimestamp) {        List<String> debugStatements = new ArrayList<>();        if (key != null) {            debugStatements.add("Key length: " + key.length);            debugStatements.add("Key: " + DatatypeConverter.printHexBinary(key));        } else {            debugStatements.add("Key is null!");        }        if (value != null) {            debugStatements.add("Value length: " + value.length);            debugStatements.add("Value: " + DatatypeConverter.printHexBinary(value));        } else {            debugStatements.add("Value is null!");        }            }    long tsWriteStart = System.nanoTime();    try {        getWriter(new Partition(topic, context.get(EmitContext.Type.PARTITION))).handle(result.key, result.value);    } catch (IOException e) {                }    long tsWriteEnd = System.nanoTime();    if (LOG.isDebugEnabled() && (Math.random() < 0.001 || !inited)) {                    }    inited = true;    return tuple;}
private PartitionHDFSWriter metron_f7182_0(Partition partition)
{        if (lastWriter != null && lastWriter.getTopic().equals(partition.topic) && lastWriter.getPartition() == partition.partition) {        return lastWriter;    }    lastWriter = writers.get(partition);    if (lastWriter == null) {        lastWriter = new PartitionHDFSWriter(partition.topic, partition.partition, context.get(EmitContext.Type.UUID), config);        writers.put(partition, lastWriter);    }    return lastWriter;}
public void metron_f7183_0(EmitContext context)
{    this.context = context;    KafkaSpoutConfig spoutConfig = context.get(EmitContext.Type.SPOUT_CONFIG);    if (spoutConfig != null && spoutConfig.getSubscription() != null) {        this.topic = spoutConfig.getSubscription().getTopicsString();        if (this.topic.length() > 0) {            int len = this.topic.length();            if (this.topic.charAt(0) == '[' && this.topic.charAt(len - 1) == ']') {                this.topic = this.topic.substring(1, len - 1);            }        }    } else {        throw new IllegalStateException("Unable to initialize, because spout config is not correctly specified");    }}
public void metron_f7184_0() throws Exception
{    for (PartitionHDFSWriter writer : writers.values()) {        writer.close();    }}
public HDFSWriterConfig metron_f7185_0(String deserializer, String timestampConverter)
{    this.deserializer = Deserializers.create(deserializer, timestampConverter);    return this;}
public HDFSWriterConfig metron_f7186_0(String path)
{    outputPath = path;    return this;}
public HDFSWriterConfig metron_f7187_0(long n)
{    numPackets = n;    return this;}
public HDFSWriterConfig metron_f7188_0(int n)
{    syncEvery = n;    return this;}
public HDFSWriterConfig metron_f7189_0(Map<String, Object> config)
{    hdfsConfig = config;    return this;}
public HDFSWriterConfig metron_f7190_0(int n)
{    replicationFactor = n;    return this;}
public HDFSWriterConfig metron_f7191_0(long t)
{    maxTimeNS = TimestampConverters.MILLISECONDS.toNanoseconds(t);    return this;}
public HDFSWriterConfig metron_f7192_0(String zookeeperQuorum)
{    this.zookeeperQuorum = zookeeperQuorum;    return this;}
public List<String> metron_f7193_0()
{    List<String> out = new ArrayList<>();    if (zookeeperQuorum != null) {        for (String hostPort : Splitter.on(',').split(zookeeperQuorum)) {            Iterable<String> tokens = Splitter.on(':').split(hostPort);            String host = Iterables.getFirst(tokens, null);            if (host != null) {                out.add(host);            }        }    }    return out;}
public Map<String, Object> metron_f7194_0()
{    return hdfsConfig;}
public Integer metron_f7195_0()
{    if (zookeeperQuorum != null) {        String hostPort = Iterables.getFirst(Splitter.on(',').split(zookeeperQuorum), null);        String portStr = Iterables.getLast(Splitter.on(':').split(hostPort));        return Integer.parseInt(portStr);    }    return null;}
public int metron_f7196_0()
{    return syncEvery;}
public int metron_f7197_0()
{    return replicationFactor;}
public KeyValueDeserializer metron_f7198_0()
{    return deserializer;}
public String metron_f7199_0()
{    return outputPath;}
public long metron_f7200_0()
{    return numPackets;}
public long metron_f7201_0()
{    return maxTimeNS;}
public String metron_f7202_0()
{    return "HDFSWriterConfig{" + "numPackets=" + numPackets + ", maxTimeNS=" + maxTimeNS + ", outputPath='" + outputPath + '\'' + '}';}
protected List<Object> metron_f7203_0()
{    return new ArrayList<>();}
protected Callback metron_f7204_0(Class<? extends Callback> callbackClass)
{    return new HDFSWriterCallback().withConfig(config);}
private void metron_f7205_0()
{    for (Object messageId : messagesToBeAcked.get()) {        super.ack(messageId);    }    messagesToBeAcked.get().clear();}
public void metron_f7206_0()
{    /*    This bears some explanation; nextTuple for a spout-only topology sans ackers, will ack as part of the emit method.    The unfortunate part about this is that this will prevent the internal bookeeping of the KafkaSpout to keep add the     message ID to the offsets to commit.  This is because it thinks it is not emitted by the time it gets to ack (because     ack is called *within* emit).  The result is that no offsets are acked.     What we have here is a correction.  The ack method will add the message ID to a queue to be acked and then at the end     of nextTuple, we will clear the cache and ack.  The net result is that the contract is adhered to for spout-only topologies,     ack happens in nextTuple().     */    super.nextTuple();    clearMessagesToBeAcked();}
public void metron_f7207_0(Object messageId)
{    messagesToBeAcked.get().add(messageId);}
public void metron_f7208_0()
{    try {        clearMessagesToBeAcked();    } finally {        super.close();    }}
private SyncHandler metron_f7209_0()
{    return func;}
public void metron_f7210_1(FSDataOutputStream input)
{    try {        func.sync(input);    } catch (IOException ioe) {            }}
public void metron_f7211_0(FSDataOutputStream outputStream) throws IOException
{    outputStream.hflush();    outputStream.hsync();}
public void metron_f7212_0(FSDataOutputStream outputStream) throws IOException
{    outputStream.hflush();    outputStream.hsync();    ((HdfsDataOutputStream) outputStream).hsync(EnumSet.of(HdfsDataOutputStream.SyncFlag.UPDATE_LENGTH));}
public void metron_f7213_0(FSDataOutputStream outputStream) throws IOException
{    outputStream.getWrappedStream().flush();    outputStream.getWrappedStream();}
public String metron_f7214_0(long ts)
{    return Long.toUnsignedString(ts);}
public void metron_f7215_1(long ts, byte[] value) throws IOException
{    turnoverIfNecessary(ts);    BytesWritable bw = new BytesWritable(value);    try {        writer.append(new LongWritable(ts), bw);    } catch (ArrayIndexOutOfBoundsException aioobe) {            }    numWritten++;    if (numWritten % config.getSyncEvery() == 0) {        syncHandler.sync(outputStream);    }}
public String metron_f7216_0()
{    return topic;}
public int metron_f7217_0()
{    return partition;}
public void metron_f7218_0() throws IOException
{    if (writer != null) {        writer.close();    }    if (outputStream != null) {        outputStream.close();    }}
private Path metron_f7219_0(long ts)
{    String fileName = PcapHelper.toFilename(topic, ts, partition + "", uuid);    return new Path(config.getOutputPath(), fileName);}
private void metron_f7220_0(long ts) throws IOException
{    turnoverIfNecessary(ts, false);}
private void metron_f7221_1(long ts, boolean force) throws IOException
{    long duration = ts - batchStartTime;    boolean initial = outputStream == null;    boolean overDuration = config.getMaxTimeNS() <= 0 ? false : Long.compareUnsigned(duration, config.getMaxTimeNS()) >= 0;    boolean tooManyPackets = numWritten >= config.getNumPackets();    if (force || initial || overDuration || tooManyPackets) {                Path path = getPath(ts);        close();        if (fs instanceof LocalFileSystem) {            outputStream = new FSDataOutputStream(new FileOutputStream(new File(path.toString())));            syncHandler = SyncHandlers.LOCAL.getHandler();        } else {            outputStream = fs.create(path, true);            if (outputStream instanceof HdfsDataOutputStream) {                if (initial) {                                    }                syncHandler = SyncHandlers.HDFS.getHandler();            } else {                if (initial) {                                    }                syncHandler = SyncHandlers.DEFAULT.getHandler();            }        }        writer = SequenceFile.createWriter(this.fsConfig, SequenceFile.Writer.keyClass(LongWritable.class), SequenceFile.Writer.valueClass(BytesWritable.class), SequenceFile.Writer.stream(outputStream), SequenceFile.Writer.compression(SequenceFile.CompressionType.NONE));                        batchStartTime = ts;        numWritten = 0;    }}
public boolean metron_f7222_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f7223_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public static CommandLine metron_f7224_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (InspectorOptions.HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static void metron_f7225_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("PcapInspector", getOptions());}
public static Options metron_f7226_0()
{    Options ret = new Options();    for (InspectorOptions o : InspectorOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public Option metron_f7227_0(@Nullable String s)
{    return new Option(s, "help", false, "Generate Help screen");}
public Option metron_f7228_0(@Nullable String s)
{    Option o = new Option(s, "input", true, "Input sequence file on HDFS");    o.setArgName("SEQ_FILE");    o.setRequired(true);    return o;}
public Option metron_f7229_0(@Nullable String s)
{    Option o = new Option(s, "num_packets", true, "Number of packets to dump");    o.setArgName("N");    o.setRequired(false);    return o;}
public static void metron_f7230_0(String... argv) throws IOException
{    Configuration conf = new Configuration();    String[] otherArgs = new GenericOptionsParser(conf, argv).getRemainingArgs();    CommandLine cli = InspectorOptions.parse(new PosixParser(), otherArgs);    Path inputPath = new Path(InspectorOptions.INPUT.get(cli));    int n = -1;    if (InspectorOptions.NUM.has(cli)) {        n = Integer.parseInt(InspectorOptions.NUM.get(cli));    }    SequenceFile.Reader reader = new SequenceFile.Reader(new Configuration(), SequenceFile.Reader.file(inputPath));    LongWritable key = new LongWritable();    BytesWritable value = new BytesWritable();    for (int i = 0; (n < 0 || i < n) && reader.next(key, value); ++i) {        long millis = Long.divideUnsigned(key.get(), 1000000);        String ts = DATE_FORMAT.format(new Date(millis));        try {            for (PacketInfo pi : PcapHelper.toPacketInfo(value.copyBytes())) {                Map<String, Object> result = PcapHelper.packetToFields(pi);                List<String> fieldResults = new ArrayList<String>() {                    {                        add("TS: " + ts);                    }                };                for (Constants.Fields field : Constants.Fields.values()) {                    if (result.containsKey(field.getName())) {                        fieldResults.add(field.getName() + ": " + result.get(field.getName()));                    }                }                System.out.println(Joiner.on(",").join(fieldResults));            }        } catch (Exception e) {            System.out.println(String.format("Error: malformed packet #=%s, ts=%s, error msg=%s", i + 1, ts, e.getMessage()));        }    }}
private static void metron_f7231_0(File... dirs) throws IOException
{    for (File dir : dirs) {        for (File f : dir.listFiles()) {            if (f.isDirectory()) {                FileUtils.deleteDirectory(f);            } else {                f.delete();            }        }    }}
private static int metron_f7232_0(File outDir, Configuration config)
{    return outDir.list(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return !name.endsWith(".crc");        }    }).length;}
public boolean metron_f7233_0(File dir, String name)
{    return !name.endsWith(".crc");}
public void metron_f7234_0() throws Exception
{    setupTopology(new Function<Properties, Void>() {        @Nullable        @Override        public Void apply(@Nullable Properties input) {            input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_PACKET.toString());            return null;        }    }, (kafkaComponent, pcapEntries) -> kafkaComponent.writeMessages(KAFKA_TOPIC, Collections2.transform(pcapEntries, input -> input.getValue())), true);}
public Void metron_f7235_0(@Nullable Properties input)
{    input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_PACKET.toString());    return null;}
public static void metron_f7236_0() throws Exception
{    System.out.println("Setting up test components");    withHeaders = false;    setupTopology(new Function<Properties, Void>() {        @Nullable        @Override        public Void apply(@Nullable Properties input) {            input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_KEY.toString());            return null;        }    }, new SendEntries() {        @Override        public void send(KafkaComponent kafkaComponent, List<Map.Entry<byte[], byte[]>> pcapEntries) throws Exception {            Producer<byte[], byte[]> producer = kafkaComponent.createProducer(byte[].class, byte[].class);            KafkaUtil.send(producer, pcapEntries, KAFKA_TOPIC, 2);            System.out.println("Sent pcap data: " + pcapEntries.size());            {                int numMessages = 0;                ConsumerIterator<?, ?> it = kafkaComponent.getStreamIterator(KAFKA_TOPIC);                for (int i = 0; i < pcapEntries.size(); ++i, it.next()) {                    numMessages++;                }                Assert.assertEquals(pcapEntries.size(), numMessages);                System.out.println("Wrote " + pcapEntries.size() + " to kafka");            }        }    }, withHeaders);    System.out.println("Done with setup.");}
public Void metron_f7237_0(@Nullable Properties input)
{    input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_KEY.toString());    return null;}
public void metron_f7238_0(KafkaComponent kafkaComponent, List<Map.Entry<byte[], byte[]>> pcapEntries) throws Exception
{    Producer<byte[], byte[]> producer = kafkaComponent.createProducer(byte[].class, byte[].class);    KafkaUtil.send(producer, pcapEntries, KAFKA_TOPIC, 2);    System.out.println("Sent pcap data: " + pcapEntries.size());    {        int numMessages = 0;        ConsumerIterator<?, ?> it = kafkaComponent.getStreamIterator(KAFKA_TOPIC);        for (int i = 0; i < pcapEntries.size(); ++i, it.next()) {            numMessages++;        }        Assert.assertEquals(pcapEntries.size(), numMessages);        System.out.println("Wrote " + pcapEntries.size() + " to kafka");    }}
private static File metron_f7239_0(String targetDir, String childDir)
{    File directory = new File(new File(targetDir), childDir);    if (!directory.exists()) {        directory.mkdirs();    }    return directory;}
public static void metron_f7240_0() throws Exception
{    System.out.println("Tearing down test infrastructure");    System.out.println("Stopping runner");    runner.stop();    System.out.println("Done stopping runner");    System.out.println("Clearing output directories");    clearOutDirs(inputDir, interimResultDir, outputDir);    System.out.println("Finished");}
private static long metron_f7241_0(int offset, List<Map.Entry<byte[], byte[]>> entries)
{    return Bytes.toLong(entries.get(offset).getKey());}
public static void metron_f7242_0(Function<Properties, Void> updatePropertiesCallback, SendEntries sendPcapEntriesCallback, boolean withHeaders) throws Exception
{    if (!new File(topologiesDir).exists()) {        topologiesDir = UnitTestHelper.findDir("topologies");    }    targetDir = UnitTestHelper.findDir("target");    inputDir = getDir(targetDir, DATA_DIR);    interimResultDir = getDir(targetDir, INTERIM_RESULT);    outputDir = getDir(targetDir, OUTPUT_DIR);    clearOutDirs(inputDir, interimResultDir, outputDir);    File baseDir = new File(new File(targetDir), BASE_DIR);        Assert.assertNotNull(topologiesDir);    Assert.assertNotNull(targetDir);    Path pcapFile = new Path("../metron-integration-test/src/main/sample/data/SampleInput/PCAPExampleOutput");    pcapEntries = Lists.newArrayList(readPcaps(pcapFile, withHeaders));    Assert.assertTrue(Iterables.size(pcapEntries) > 0);    final Properties topologyProperties = new Properties() {        {            setProperty("topology.workers", "1");            setProperty("topology.worker.childopts", "");            setProperty("spout.kafka.topic.pcap", KAFKA_TOPIC);            setProperty("kafka.pcap.start", "EARLIEST");            setProperty("kafka.pcap.out", inputDir.getAbsolutePath());            setProperty("kafka.pcap.numPackets", "2");            setProperty("kafka.pcap.maxTimeMS", "200000000");            setProperty("kafka.pcap.ts_granularity", "NANOSECONDS");            setProperty("kafka.spout.parallelism", "1");            setProperty("topology.auto-credentials", "[]");            setProperty("kafka.security.protocol", "PLAINTEXT");            setProperty("hdfs.sync.every", "1");            setProperty("hdfs.replication.factor", "-1");        }    };    updatePropertiesCallback.apply(topologyProperties);    final ZKServerComponent zkServerComponent = getZKServerComponent(topologyProperties);    final KafkaComponent kafkaComponent = getKafkaComponent(topologyProperties, Collections.singletonList(new KafkaComponent.Topic(KAFKA_TOPIC, 1)));    final MRComponent mr = new MRComponent().withBasePath(baseDir.getAbsolutePath());    FluxTopologyComponent fluxComponent = new FluxTopologyComponent.Builder().withTopologyLocation(new File(topologiesDir + "/pcap/remote.yaml")).withTopologyName("pcap").withTopologyProperties(topologyProperties).build();        runner = new ComponentRunner.Builder().withComponent("mr", mr).withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("storm", fluxComponent).withMaxTimeMS(-1).withMillisecondsBetweenAttempts(2000).withNumRetries(10).withCustomShutdownOrder(new String[] { "storm", "kafka", "zk", "mr" }).build();    runner.start();    fluxComponent.submitTopology();    sendPcapEntriesCallback.send(kafkaComponent, pcapEntries);    runner.process(new Processor<Void>() {        @Override        public ReadinessState process(ComponentRunner runner) {            int numFiles = numFiles(inputDir, mr.getConfiguration());            int expectedNumFiles = pcapEntries.size() / 2;            if (numFiles == expectedNumFiles) {                return ReadinessState.READY;            } else {                return ReadinessState.NOT_READY;            }        }        @Override        public ProcessorResult<Void> getResult() {            return null;        }    });}
public ReadinessState metron_f7243_0(ComponentRunner runner)
{    int numFiles = numFiles(inputDir, mr.getConfiguration());    int expectedNumFiles = pcapEntries.size() / 2;    if (numFiles == expectedNumFiles) {        return ReadinessState.READY;    } else {        return ReadinessState.NOT_READY;    }}
public ProcessorResult<Void> metron_f7244_0()
{    return null;}
public void metron_f7245_0() throws IOException
{    configuration = new FixedPcapConfig(PcapCli.PREFIX_STRATEGY);    Configuration hadoopConf = new Configuration();    PcapOptions.JOB_NAME.put(configuration, "jobName");    PcapOptions.HADOOP_CONF.put(configuration, hadoopConf);    PcapOptions.FILESYSTEM.put(configuration, FileSystem.get(hadoopConf));    PcapOptions.BASE_PATH.put(configuration, new Path(inputDir.getAbsolutePath()));    PcapOptions.BASE_INTERIM_RESULT_PATH.put(configuration, new Path(interimResultDir.getAbsolutePath()));    PcapOptions.NUM_REDUCERS.put(configuration, 10);    PcapOptions.NUM_RECORDS_PER_FILE.put(configuration, 1);    PcapOptions.FINAL_OUTPUT_PATH.put(configuration, new Path(outputDir.getAbsolutePath()));    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(configuration, 4);}
public void metron_f7246_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(4, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(5, pcapEntries));    PcapOptions.FIELDS.put(configuration, new HashMap());    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals("Expected 2 records returned.", 2, resultPages.getSize());    Assert.assertEquals("Expected 1 record in first file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 0)).size());    Assert.assertEquals("Expected 1 record in second file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 1)).size());}
public void metron_f7247_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(4, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(5, pcapEntries));    PcapOptions.FIELDS.put(configuration, "");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals("Expected 2 records returned.", 2, resultPages.getSize());    Assert.assertEquals("Expected 1 record in first file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 0)).size());    Assert.assertEquals("Expected 1 record in second file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 1)).size());}
public void metron_f7248_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.FIELDS.put(configuration, new HashMap<>());    PcapOptions.START_TIME_NS.put(configuration, 0);    PcapOptions.END_TIME_NS.put(configuration, 1);    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(100.0, results.getStatus().getPercentComplete(), 0.0);    Assert.assertEquals("No results in specified date range.", results.getStatus().getDescription());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7249_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, new HashMap<String, String>() {        {            put(Constants.Fields.DST_ADDR.getName(), "207.28.210.1");        }    });    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7250_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, "ip_dst_addr == '207.28.210.1'");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7251_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, new HashMap<String, String>() {        {            put(Constants.Fields.PROTOCOL.getName(), "foo");        }    });    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7252_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, "protocol == 'foo'");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7253_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(pcapEntries.size() - 1, pcapEntries) + 1);    PcapOptions.FIELDS.put(configuration, new HashMap<>());    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals(pcapEntries.size(), resultPages.getSize());}
public void metron_f7254_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(pcapEntries.size() - 1, pcapEntries) + 1);    PcapOptions.FIELDS.put(configuration, "");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals(pcapEntries.size(), resultPages.getSize());}
public void metron_f7255_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(pcapEntries.size() - 1, pcapEntries) + 1);    PcapOptions.FIELDS.put(configuration, new HashMap<String, String>() {        {            put(Constants.Fields.DST_PORT.getName(), "22");        }    });    PcapOptions.NUM_RECORDS_PER_FILE.put(configuration, 1);    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertTrue(resultPages.getSize() > 0);    Assert.assertEquals(Iterables.size(filterPcaps(pcapEntries, new Predicate<JSONObject>() {        @Override        public boolean apply(@Nullable JSONObject input) {            Object prt = input.get(Constants.Fields.DST_PORT.getName());            return prt != null && prt.toString().equals("22");        }    }, withHeaders)), resultPages.getSize());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PcapMerger.merge(baos, HDFSUtils.readBytes(resultPages.getPage(0)));    Assert.assertTrue(baos.toByteArray().length > 0);}
public boolean metron_f7256_0(@Nullable JSONObject input)
{    Object prt = input.get(Constants.Fields.DST_PORT.getName());    return prt != null && prt.toString().equals("22");}
public void metron_f7257_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(pcapEntries.size() - 1, pcapEntries) + 1);    PcapOptions.FIELDS.put(configuration, "ip_dst_port == 22");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals(Iterables.size(filterPcaps(pcapEntries, new Predicate<JSONObject>() {        @Override        public boolean apply(@Nullable JSONObject input) {            Object prt = input.get(Constants.Fields.DST_PORT.getName());            return prt != null && prt.toString().equals("22");        }    }, withHeaders)), resultPages.getSize());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PcapMerger.merge(baos, HDFSUtils.readBytes(resultPages.getPage(0)));    Assert.assertTrue(baos.toByteArray().length > 0);}
public boolean metron_f7258_0(@Nullable JSONObject input)
{    Object prt = input.get(Constants.Fields.DST_PORT.getName());    return prt != null && prt.toString().equals("22");}
public void metron_f7259_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(pcapEntries.size() - 1, pcapEntries) + 1);    PcapOptions.FIELDS.put(configuration, "ip_dst_port > 20 and ip_dst_port < 55792");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(results.get(), path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals(Iterables.size(filterPcaps(pcapEntries, new Predicate<JSONObject>() {        @Override        public boolean apply(@Nullable JSONObject input) {            Object prt = input.get(Constants.Fields.DST_PORT.getName());            return prt != null && ((Long) prt > 20 && (Long) prt < 55792);        }    }, withHeaders)), resultPages.getSize());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PcapMerger.merge(baos, HDFSUtils.readBytes(resultPages.getPage(0)));    Assert.assertTrue(baos.toByteArray().length > 0);}
public boolean metron_f7260_0(@Nullable JSONObject input)
{    Object prt = input.get(Constants.Fields.DST_PORT.getName());    return prt != null && ((Long) prt > 20 && (Long) prt < 55792);}
public void metron_f7261_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(pcapEntries.size() - 1, pcapEntries) + 1);    PcapOptions.FIELDS.put(configuration, "ip_dst_port > 55790");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals(Iterables.size(filterPcaps(pcapEntries, new Predicate<JSONObject>() {        @Override        public boolean apply(@Nullable JSONObject input) {            Object prt = input.get(Constants.Fields.DST_PORT.getName());            return prt != null && (Long) prt > 55790;        }    }, withHeaders)), resultPages.getSize());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PcapMerger.merge(baos, HDFSUtils.readBytes(resultPages.getPage(0)));    Assert.assertTrue(baos.toByteArray().length > 0);}
public boolean metron_f7262_0(@Nullable JSONObject input)
{    Object prt = input.get(Constants.Fields.DST_PORT.getName());    return prt != null && (Long) prt > 55790;}
public void metron_f7263_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.FIELDS.put(configuration, "BYTEARRAY_MATCHER('2f56abd814bc56420489ca38e7faf8cec3d4', packet)");    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(pcapEntries.size() - 1, pcapEntries) + 1);    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Iterable<byte[]> bytes = Iterables.transform(results.get(), path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals(1, results.get().getSize());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PcapMerger.merge(baos, HDFSUtils.readBytes(results.get().getPage(0)));    Assert.assertTrue(baos.toByteArray().length > 0);}
private void metron_f7264_0(Statusable statusable) throws Exception
{    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        if (!statusable.getStatus().getState().equals(JobStatus.State.RUNNING)) {            if (statusable.isDone()) {                return;            }        }    }    throw new Exception("Job did not complete within " + (MAX_RETRIES * SLEEP_MS) + " seconds");}
private static Iterable<Map.Entry<byte[], byte[]>> metron_f7265_0(Path pcapFile, boolean withHeaders) throws IOException
{    SequenceFile.Reader reader = new SequenceFile.Reader(new Configuration(), SequenceFile.Reader.file(pcapFile));    List<Map.Entry<byte[], byte[]>> ret = new ArrayList<>();    IntWritable key = new IntWritable();    BytesWritable value = new BytesWritable();    while (reader.next(key, value)) {        byte[] pcapWithHeader = value.copyBytes();                                                long calculatedTs = PcapHelper.getTimestamp(pcapWithHeader);        {            List<PacketInfo> info = PcapHelper.toPacketInfo(pcapWithHeader);            for (PacketInfo pi : info) {                Assert.assertEquals(calculatedTs, pi.getPacketTimeInNanos());                                    }        }        if (withHeaders) {            ret.add(new AbstractMap.SimpleImmutableEntry<>(Bytes.toBytes(calculatedTs), pcapWithHeader));        } else {            byte[] pcapRaw = new byte[pcapWithHeader.length - PcapHelper.GLOBAL_HEADER_SIZE - PcapHelper.PACKET_HEADER_SIZE];            System.arraycopy(pcapWithHeader, PcapHelper.GLOBAL_HEADER_SIZE + PcapHelper.PACKET_HEADER_SIZE, pcapRaw, 0, pcapRaw.length);            ret.add(new AbstractMap.SimpleImmutableEntry<>(Bytes.toBytes(calculatedTs), pcapRaw));        }    }    return Iterables.limit(ret, 2 * (ret.size() / 2));}
public static void metron_f7266_0(Iterable<byte[]> packets)
{    long previous = 0;    for (byte[] packet : packets) {        for (JSONObject json : TO_JSONS.apply(packet)) {            Long current = Long.parseLong(json.get("ts_micro").toString());            Assert.assertNotNull(current);            Assert.assertTrue(Long.compareUnsigned(current, previous) >= 0);            previous = current;        }    }}
public Iterable<JSONObject> metron_f7267_0(@Nullable byte[] input)
{    try {        return PcapHelper.toJSON(PcapHelper.toPacketInfo(input));    } catch (IOException e) {        throw new RuntimeException(e.getMessage(), e);    }}
private Iterable<JSONObject> metron_f7268_0(Iterable<Map.Entry<byte[], byte[]>> pcaps, Predicate<JSONObject> predicate, boolean withHeaders)
{    Function<Map.Entry<byte[], byte[]>, byte[]> pcapTransform = null;    if (!withHeaders) {        final Endianness endianness = Endianness.getNativeEndianness();        pcapTransform = kv -> PcapHelper.addGlobalHeader(PcapHelper.addPacketHeader(Bytes.toLong(kv.getKey()), kv.getValue(), endianness), endianness);    } else {        pcapTransform = kv -> kv.getValue();    }    return Iterables.filter(Iterables.concat(Iterables.transform(Iterables.transform(pcaps, pcapTransform), TO_JSONS)), predicate);}
public void metron_f7269_0() throws IOException
{    MockitoAnnotations.initMocks(this);    execDir = System.getProperty("user.dir");    prefixStrategy = clock -> "random_prefix";}
public void metron_f7270_0() throws Exception
{    String[] args = { "fixed", "-start_time", "500", "-ip_src_addr", "192.168.1.1", "-ip_dst_addr", "192.168.1.2", "-ip_src_port", "8081", "-ip_dst_port", "8082", "-protocol", "6", "-packet_filter", "`casey`" };    HashMap<String, String> query = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "192.168.1.1");            put(Constants.Fields.DST_ADDR.getName(), "192.168.1.2");            put(Constants.Fields.SRC_PORT.getName(), "8081");            put(Constants.Fields.DST_PORT.getName(), "8082");            put(Constants.Fields.PROTOCOL.getName(), "6");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");            put(PcapHelper.PacketFields.PACKET_FILTER.getName(), "`casey`");        }    };    FixedPcapConfig config = new FixedPcapConfig(prefixStrategy);    PcapOptions.BASE_PATH.put(config, BASE_INPUT_PATH_DEFAULT);    PcapOptions.BASE_INTERIM_RESULT_PATH.put(config, BASE_INTERIM_RESULT_PATH_DEFAULT);    PcapOptions.FIELDS.put(config, query);    PcapOptions.NUM_REDUCERS.put(config, 10);    PcapOptions.START_TIME_MS.put(config, 500L);    when(jobRunner.submit(isA(Finalizer.class), argThat(mapContaining(config)))).thenReturn(jobRunner);    PcapCli cli = new PcapCli(jobRunner, prefixStrategy);    assertThat("Expect no errors on run", cli.run(args), equalTo(0));    verify(jobRunner).get();}
private Matcher<Map<K, V>> metron_f7271_0(Map<K, V> map)
{    return new TypeSafeMatcher<Map<K, V>>() {        @Override        protected boolean matchesSafely(Map<K, V> item) {            for (K key : map.keySet()) {                if (key.equals(PcapOptions.HADOOP_CONF.getKey())) {                    Configuration itemConfiguration = (Configuration) item.get(PcapOptions.HADOOP_CONF.getKey());                    Map<String, Object> mapConfiguration = (Map<String, Object>) map.get(PcapOptions.HADOOP_CONF.getKey());                    for (String setting : mapConfiguration.keySet()) {                        if (!mapConfiguration.get(setting).equals(itemConfiguration.get(setting, ""))) {                            return false;                        }                    }                } else {                    V itemValue = item.get(key);                    V mapValue = map.get(key);                    if (itemValue != null ? !itemValue.equals(mapValue) : mapValue != null) {                        return false;                    }                }            }            return true;        }        @Override        public void describeTo(Description description) {            description.appendText("Should contain items: ");            for (Entry<K, V> entry : map.entrySet()) {                StringBuilder sb = new StringBuilder();                sb.append("key=");                sb.append(entry.getKey());                sb.append(",value=");                sb.append(entry.getValue());                description.appendText(sb.toString());            }        }    };}
protected boolean metron_f7272_0(Map<K, V> item)
{    for (K key : map.keySet()) {        if (key.equals(PcapOptions.HADOOP_CONF.getKey())) {            Configuration itemConfiguration = (Configuration) item.get(PcapOptions.HADOOP_CONF.getKey());            Map<String, Object> mapConfiguration = (Map<String, Object>) map.get(PcapOptions.HADOOP_CONF.getKey());            for (String setting : mapConfiguration.keySet()) {                if (!mapConfiguration.get(setting).equals(itemConfiguration.get(setting, ""))) {                    return false;                }            }        } else {            V itemValue = item.get(key);            V mapValue = map.get(key);            if (itemValue != null ? !itemValue.equals(mapValue) : mapValue != null) {                return false;            }        }    }    return true;}
public void metron_f7273_0(Description description)
{    description.appendText("Should contain items: ");    for (Entry<K, V> entry : map.entrySet()) {        StringBuilder sb = new StringBuilder();        sb.append("key=");        sb.append(entry.getKey());        sb.append(",value=");        sb.append(entry.getValue());        description.appendText(sb.toString());    }}
public void metron_f7274_0() throws Exception
{    String[] args = { "fixed", "-start_time", "500", "-end_time", "1000", "-base_path", "/base/path", "-base_output_path", "/base/output/path", "-ip_src_addr", "192.168.1.1", "-ip_dst_addr", "192.168.1.2", "-ip_src_port", "8081", "-ip_dst_port", "8082", "-protocol", "6", "-include_reverse", "-num_reducers", "10", "-records_per_file", "1000", "-finalizer_threads", "10" };    Map<String, String> query = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "192.168.1.1");            put(Constants.Fields.DST_ADDR.getName(), "192.168.1.2");            put(Constants.Fields.SRC_PORT.getName(), "8081");            put(Constants.Fields.DST_PORT.getName(), "8082");            put(Constants.Fields.PROTOCOL.getName(), "6");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "true");        }    };    FixedPcapConfig config = new FixedPcapConfig(prefixStrategy);    PcapOptions.BASE_PATH.put(config, "/base/path");    PcapOptions.BASE_INTERIM_RESULT_PATH.put(config, "/base/output/path");    PcapOptions.FIELDS.put(config, query);    PcapOptions.NUM_REDUCERS.put(config, 10);    PcapOptions.START_TIME_MS.put(config, 500L);    PcapOptions.END_TIME_MS.put(config, 1000L);    PcapOptions.NUM_RECORDS_PER_FILE.put(config, 1000);    PcapOptions.PRINT_JOB_STATUS.put(config, true);    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(config, "10");    when(jobRunner.submit(isA(Finalizer.class), argThat(mapContaining(config)))).thenReturn(jobRunner);    PcapCli cli = new PcapCli(jobRunner, prefixStrategy);    assertThat("Expect no errors on run", cli.run(args), equalTo(0));    verify(jobRunner).get();}
public void metron_f7275_0() throws Exception
{    String[] args = { "fixed", "-start_time", "2016-06-13-18:35.00", "-end_time", "2016-06-15-18:35.00", "-date_format", "yyyy-MM-dd-HH:mm.ss", "-base_path", "/base/path", "-base_output_path", "/base/output/path", "-ip_src_addr", "192.168.1.1", "-ip_dst_addr", "192.168.1.2", "-ip_src_port", "8081", "-ip_dst_port", "8082", "-protocol", "6", "-include_reverse", "-num_reducers", "10", "-records_per_file", "1000", "-yq", "pcap", "-finalizer_threads", "10" };    Map<String, String> query = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "192.168.1.1");            put(Constants.Fields.DST_ADDR.getName(), "192.168.1.2");            put(Constants.Fields.SRC_PORT.getName(), "8081");            put(Constants.Fields.DST_PORT.getName(), "8082");            put(Constants.Fields.PROTOCOL.getName(), "6");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "true");        }    };    long startAsNanos = asNanos("2016-06-13-18:35.00", "yyyy-MM-dd-HH:mm.ss");    long endAsNanos = asNanos("2016-06-15-18:35.00", "yyyy-MM-dd-HH:mm.ss");    FixedPcapConfig config = new FixedPcapConfig(prefixStrategy);    PcapOptions.BASE_PATH.put(config, "/base/path");    PcapOptions.BASE_INTERIM_RESULT_PATH.put(config, "/base/output/path");    PcapOptions.FIELDS.put(config, query);    PcapOptions.NUM_REDUCERS.put(config, 10);        PcapOptions.START_TIME_MS.put(config, startAsNanos / 1000000L);        PcapOptions.END_TIME_MS.put(config, endAsNanos / 1000000L);    PcapOptions.NUM_RECORDS_PER_FILE.put(config, 1000);    PcapOptions.PRINT_JOB_STATUS.put(config, true);    PcapOptions.HADOOP_CONF.put(config, new HashMap<String, Object>() {        {            put(MRJobConfig.QUEUE_NAME, "pcap");        }    });    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(config, "10");    when(jobRunner.submit(isA(Finalizer.class), argThat(mapContaining(config)))).thenReturn(jobRunner);    PcapCli cli = new PcapCli(jobRunner, prefixStrategy);    assertThat("Expect no errors on run", cli.run(args), equalTo(0));    verify(jobRunner).get();}
private long metron_f7276_0(String inDate, String format) throws ParseException
{    SimpleDateFormat sdf = new SimpleDateFormat(format);    Date date = sdf.parse(inDate);    return TimestampConverters.MILLISECONDS.toNanoseconds(date.getTime());}
private byte[] metron_f7277_0(String val)
{    return val.getBytes(StandardCharsets.UTF_8);}
public void metron_f7278_0() throws Exception
{    String[] args = { "query", "-start_time", "500", "-query", "some query string" };    String query = "some query string";    FixedPcapConfig config = new FixedPcapConfig(prefixStrategy);    PcapOptions.BASE_PATH.put(config, BASE_INPUT_PATH_DEFAULT);    PcapOptions.BASE_INTERIM_RESULT_PATH.put(config, BASE_INTERIM_RESULT_PATH_DEFAULT);    PcapOptions.FIELDS.put(config, query);    PcapOptions.NUM_REDUCERS.put(config, 10);    PcapOptions.START_TIME_MS.put(config, 500L);    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(config, "1");    when(jobRunner.submit(isA(Finalizer.class), argThat(mapContaining(config)))).thenReturn(jobRunner);    PcapCli cli = new PcapCli(jobRunner, prefixStrategy);    assertThat("Expect no errors on run", cli.run(args), equalTo(0));    verify(jobRunner).get();}
public void metron_f7279_0() throws Exception
{    String[] args = { "query", "-start_time", "500", "-end_time", "1000", "-num_reducers", "10", "-base_path", "/base/path", "-base_output_path", "/base/output/path", "-query", "some query string", "-records_per_file", "1000", "-finalizer_threads", "10" };    String query = "some query string";    FixedPcapConfig config = new FixedPcapConfig(prefixStrategy);    PcapOptions.BASE_PATH.put(config, "/base/path");    PcapOptions.BASE_INTERIM_RESULT_PATH.put(config, "/base/output/path");    PcapOptions.FIELDS.put(config, query);    PcapOptions.NUM_REDUCERS.put(config, 10);        PcapOptions.START_TIME_MS.put(config, 500L);        PcapOptions.END_TIME_MS.put(config, 1000L);    PcapOptions.NUM_RECORDS_PER_FILE.put(config, 1000);    PcapOptions.PRINT_JOB_STATUS.put(config, true);    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(config, "10");    when(jobRunner.submit(isA(Finalizer.class), argThat(mapContaining(config)))).thenReturn(jobRunner);    PcapCli cli = new PcapCli(jobRunner, prefixStrategy);    assertThat("Expect no errors on run", cli.run(args), equalTo(0));    verify(jobRunner).get();}
public void metron_f7280_0() throws Exception
{    String[] args = { "fixed", "-start_time", "500", "-end_time", "1000", "-num_reducers", "10", "-base_path", "/base/path", "-base_output_path", "/base/output/path", "-query", "THIS IS AN ERROR" };    assertCliError(args, "Fixed", "Unrecognized option: -query");}
public void metron_f7281_0(String[] args, String type, String optMsg) throws UnsupportedEncodingException
{    PrintStream originalOutStream = System.out;    PrintStream originalErrOutStream = System.err;    try {        ByteArrayOutputStream bos = new ByteArrayOutputStream();        PrintStream outStream = new PrintStream(new BufferedOutputStream(bos), false, StandardCharsets.UTF_8.name());        System.setOut(outStream);        ByteArrayOutputStream ebos = new ByteArrayOutputStream();        PrintStream errOutStream = new PrintStream(new BufferedOutputStream(ebos), false, StandardCharsets.UTF_8.name());        System.setErr(errOutStream);        PcapCli cli = new PcapCli(jobRunner, clock -> "random_prefix");        assertThat("Expect errors on run", cli.run(args), equalTo(-1));        assertThat("Expect missing required option error: " + ebos.toString(), ebos.toString().contains(optMsg), equalTo(true));        assertThat("Expect usage to be printed: " + bos.toString(), bos.toString().contains("usage: " + type + " filter options"), equalTo(true));    } finally {        System.setOut(originalOutStream);        System.setErr(originalErrOutStream);    }}
public void metron_f7282_0() throws Exception
{    String[] args = { "query", "-start_time", "500", "-end_time", "1000", "-num_reducers", "10", "-base_path", "/base/path", "-base_output_path", "/base/output/path", "-ip_src_addr", "THIS IS AN ERROR" };    assertCliError(args, "Query", "");}
public void metron_f7283_0() throws Exception
{    String[] args = { "fixed", "-ip_src_addr", "192.168.1.1", "-ip_dst_addr", "192.168.1.2", "-ip_src_port", "8081", "-ip_dst_port", "8082", "-protocol", "6", "-num_reducers", "10" };    assertCliError(args, "Fixed", "Missing required option: st");}
public void metron_f7284_0()
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("Expected a key but none provided");    FromKeyDeserializer deserializer = new FromKeyDeserializer(TimestampConverters.NANOSECONDS);    deserializer.deserializeKeyValue(null, null);}
public static SolrClient metron_f7285_0(Map<String, Object> globalConfig)
{    if (solrClient == null) {        synchronized (SolrClientFactory.class) {            if (solrClient == null) {                solrClient = new CloudSolrClient.Builder().withZkHost(getZkHosts(globalConfig)).build();            }        }    }    return solrClient;}
public static void metron_f7286_1()
{    synchronized (SolrClientFactory.class) {        if (solrClient != null) {            try {                solrClient.close();            } catch (IOException e) {                            } finally {                solrClient = null;            }        }    }}
protected static List<String> metron_f7287_0(Map<String, Object> globalConfig)
{    return Splitter.on(',').trimResults().splitToList((String) globalConfig.getOrDefault(SOLR_ZOOKEEPER, ""));}
public Map<String, FieldType> metron_f7288_1(List<String> indices) throws IOException
{    Map<String, FieldType> indexColumnMetadata = new HashMap<>();    Map<String, String> previousIndices = new HashMap<>();    Set<String> fieldBlackList = Sets.newHashSet(SolrDao.ROOT_FIELD, SolrDao.VERSION_FIELD);    for (String index : indices) {        try {            getIndexFields(index).forEach(field -> {                String name = (String) field.get("name");                if (!fieldBlackList.contains(name)) {                    FieldType type = toFieldType((String) field.get("type"));                    if (!indexColumnMetadata.containsKey(name)) {                        indexColumnMetadata.put(name, type);                                                previousIndices.put(name, index);                    } else {                        FieldType previousType = indexColumnMetadata.get(name);                        if (!type.equals(previousType)) {                            String previousIndexName = previousIndices.get(name);                                                        indexColumnMetadata.put(name, FieldType.OTHER);                                                        fieldBlackList.add(name);                        }                    }                }            });        } catch (SolrServerException e) {            throw new IOException(e);        } catch (SolrException e) {                        if (e.code() != 400) {                throw new IOException(e);            }        }    }    return indexColumnMetadata;}
protected List<Map<String, Object>> metron_f7289_0(String index) throws IOException, SolrServerException
{    List<Map<String, Object>> indexFields = new ArrayList<>();        LukeRequest lukeRequest = new LukeRequest();    LukeResponse lukeResponse = lukeRequest.process(client, index);    for (Entry<String, LukeResponse.FieldInfo> field : lukeResponse.getFieldInfo().entrySet()) {        Map<String, Object> fieldData = new HashMap<>();        fieldData.put("name", field.getValue().getName());        fieldData.put("type", field.getValue().getType());        indexFields.add(fieldData);    }        SchemaRepresentation schemaRepresentation = new SchemaRequest().process(client, index).getSchemaRepresentation();    indexFields.addAll(schemaRepresentation.getFields());    return indexFields;}
private FieldType metron_f7290_0(String type)
{    return solrTypeMap.getOrDefault(type, FieldType.OTHER);}
public void metron_f7291_0(AccessConfig config)
{    if (config.getKerberosEnabled()) {        enableKerberos();    }    if (this.client == null) {        this.accessConfig = config;        this.client = SolrClientFactory.create(config.getGlobalConfigSupplier().get());        this.solrSearchDao = new SolrSearchDao(this.client, this.accessConfig);        this.solrRetrieveLatestDao = new SolrRetrieveLatestDao(this.client, this.accessConfig);        this.solrUpdateDao = new SolrUpdateDao(this.client, this.solrRetrieveLatestDao, this.accessConfig);        this.solrColumnMetadataDao = new SolrColumnMetadataDao(this.client);    }}
public Optional<String> metron_f7292_0(String sensorName, Optional<String> index)
{    if (index.isPresent()) {        return index;    } else {        String realIndex = accessConfig.getIndexSupplier().apply(sensorName);        return Optional.ofNullable(realIndex);    }}
public SearchResponse metron_f7293_0(SearchRequest searchRequest) throws InvalidSearchException
{    return this.solrSearchDao.search(searchRequest);}
public GroupResponse metron_f7294_0(GroupRequest groupRequest) throws InvalidSearchException
{    return this.solrSearchDao.group(groupRequest);}
public Document metron_f7295_0(String guid, String sensorType) throws IOException
{    return this.solrRetrieveLatestDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f7296_0(List<GetRequest> getRequests) throws IOException
{    return this.solrRetrieveLatestDao.getAllLatest(getRequests);}
public Document metron_f7297_0(Document update, Optional<String> index) throws IOException
{    return this.solrUpdateDao.update(update, index);}
public Map<Document, Optional<String>> metron_f7298_0(Map<Document, Optional<String>> updates) throws IOException
{    return this.solrUpdateDao.batchUpdate(updates);}
public Document metron_f7299_0(CommentAddRemoveRequest request) throws IOException
{    return this.solrUpdateDao.addCommentToAlert(request);}
public Document metron_f7300_0(CommentAddRemoveRequest request) throws IOException
{    return this.solrUpdateDao.removeCommentFromAlert(request);}
public Document metron_f7301_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    return solrUpdateDao.patch(retrieveLatestDao, request, timestamp);}
public Map<String, FieldType> metron_f7302_0(List<String> indices) throws IOException
{    return this.solrColumnMetadataDao.getColumnMetadata(indices);}
public Document metron_f7303_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return this.solrUpdateDao.addCommentToAlert(request, latest);}
public Document metron_f7304_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return this.solrUpdateDao.removeCommentFromAlert(request, latest);}
 void metron_f7305_0()
{    HttpClientUtil.addConfigurer(new Krb5HttpClientConfigurer());}
public SolrSearchDao metron_f7306_0()
{    return solrSearchDao;}
public SolrUpdateDao metron_f7307_0()
{    return solrUpdateDao;}
public void metron_f7308_0(IndexDao indexDao, Optional<String> threatSort)
{    if (indexDao instanceof MultiIndexDao) {        this.indexDao = indexDao;        MultiIndexDao multiIndexDao = (MultiIndexDao) indexDao;        for (IndexDao childDao : multiIndexDao.getIndices()) {            if (childDao instanceof SolrDao) {                this.solrDao = (SolrDao) childDao;            }        }    } else if (indexDao instanceof SolrDao) {        this.indexDao = indexDao;        this.solrDao = (SolrDao) indexDao;    } else {        throw new IllegalArgumentException("Need a SolrDao when using SolrMetaAlertDao");    }    Supplier<Map<String, Object>> globalConfigSupplier = () -> new HashMap<>();    if (metaAlertSearchDao != null && metaAlertSearchDao.solrSearchDao != null && metaAlertSearchDao.solrSearchDao.getAccessConfig() != null) {        globalConfigSupplier = metaAlertSearchDao.solrSearchDao.getAccessConfig().getGlobalConfigSupplier();    }    MetaAlertConfig config = new MetaAlertConfig(metaAlertsCollection, this.threatSort, globalConfigSupplier) {        @Override        protected String getDefaultThreatTriageField() {            return MetaAlertConstants.THREAT_FIELD_DEFAULT.replace(':', '.');        }        @Override        protected String getDefaultSourceTypeField() {            return Constants.SENSOR_TYPE;        }    };    SolrClient solrClient = SolrClientFactory.create(globalConfigSupplier.get());    this.metaAlertSearchDao = new SolrMetaAlertSearchDao(solrClient, solrDao.getSolrSearchDao(), config);    this.metaAlertRetrieveLatestDao = new SolrMetaAlertRetrieveLatestDao(solrClient, solrDao);    this.metaAlertUpdateDao = new SolrMetaAlertUpdateDao(solrClient, solrDao, metaAlertSearchDao, metaAlertRetrieveLatestDao, config);    if (threatSort.isPresent()) {        this.threatSort = threatSort.get();    }}
protected String metron_f7309_0()
{    return MetaAlertConstants.THREAT_FIELD_DEFAULT.replace(':', '.');}
protected String metron_f7310_0()
{    return Constants.SENSOR_TYPE;}
public void metron_f7311_0(AccessConfig config)
{}
public Map<String, FieldType> metron_f7312_0(List<String> indices) throws IOException
{    return indexDao.getColumnMetadata(indices);}
public Document metron_f7313_0(String guid, String sensorType) throws IOException
{    return metaAlertRetrieveLatestDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f7314_0(List<GetRequest> getRequests) throws IOException
{    return metaAlertRetrieveLatestDao.getAllLatest(getRequests);}
public SearchResponse metron_f7315_0(SearchRequest searchRequest) throws InvalidSearchException
{    return metaAlertSearchDao.search(searchRequest);}
public GroupResponse metron_f7316_0(GroupRequest groupRequest) throws InvalidSearchException
{    return metaAlertSearchDao.group(groupRequest);}
public Document metron_f7317_0(Document update, Optional<String> index) throws IOException
{    return metaAlertUpdateDao.update(update, index);}
public Map<Document, Optional<String>> metron_f7318_0(Map<Document, Optional<String>> updates)
{    return metaAlertUpdateDao.batchUpdate(updates);}
public Document metron_f7319_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    return metaAlertUpdateDao.patch(retrieveLatestDao, request, timestamp);}
public SearchResponse metron_f7320_0(String guid) throws InvalidSearchException
{    return metaAlertSearchDao.getAllMetaAlertsForAlert(guid);}
public Document metron_f7321_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    return metaAlertUpdateDao.createMetaAlert(request);}
public Document metron_f7322_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.addAlertsToMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f7323_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.removeAlertsFromMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f7324_0(String metaAlertGuid, MetaAlertStatus status) throws IOException
{    return metaAlertUpdateDao.updateMetaAlertStatus(metaAlertGuid, status);}
public Document metron_f7325_0(CommentAddRemoveRequest request) throws IOException
{    return solrDao.addCommentToAlert(request);}
public Document metron_f7326_0(CommentAddRemoveRequest request) throws IOException
{    return solrDao.removeCommentFromAlert(request);}
public Document metron_f7327_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return solrDao.addCommentToAlert(request, latest);}
public Document metron_f7328_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return solrDao.removeCommentFromAlert(request, latest);}
public Document metron_f7329_0(String guid, String sensorType) throws IOException
{    if (MetaAlertConstants.METAALERT_TYPE.equals(sensorType)) {                        String guidClause = Constants.GUID + ":" + guid;        SolrQuery query = new SolrQuery();        query.setQuery(guidClause).setFields("*", "[child parentFilter=" + guidClause + " limit=999]");        try {            QueryResponse response = solrClient.query(METAALERTS_COLLECTION, query);                        if (response.getResults().size() == 1) {                SolrDocument result = response.getResults().get(0);                return SolrUtilities.toDocument(result);            } else {                return null;            }        } catch (SolrServerException e) {            throw new IOException("Unable to retrieve metaalert", e);        }    } else {        return solrDao.getLatest(guid, sensorType);    }}
public Iterable<Document> metron_f7330_0(List<GetRequest> getRequests) throws IOException
{    return solrDao.getAllLatest(getRequests);}
public SearchResponse metron_f7331_0(String guid) throws InvalidSearchException
{    if (guid == null || guid.trim().isEmpty()) {        throw new InvalidSearchException("Guid cannot be empty");    }                String activeClause = MetaAlertConstants.STATUS_FIELD + ":" + MetaAlertStatus.ACTIVE.getStatusString();    String guidClause = Constants.GUID + ":" + guid;    String fullClause = "{!parent which=" + activeClause + "}" + guidClause;    String metaalertTypeClause = config.getSourceTypeField() + ":" + MetaAlertConstants.METAALERT_TYPE;    SolrQuery solrQuery = new SolrQuery().setQuery(fullClause).setFields("*", "[child parentFilter=" + metaalertTypeClause + " limit=999]").addSort(Constants.GUID,     SolrQuery.ORDER.asc);        List<SearchResult> allResults = new ArrayList<>();    try {        String cursorMark = CursorMarkParams.CURSOR_MARK_START;        boolean done = false;        while (!done) {            solrQuery.set(CursorMarkParams.CURSOR_MARK_PARAM, cursorMark);            QueryResponse rsp = solrClient.query(METAALERTS_COLLECTION, solrQuery);            String nextCursorMark = rsp.getNextCursorMark();            rsp.getResults().stream().map(solrDocument -> SolrUtilities.getSearchResult(solrDocument, null, solrSearchDao.getAccessConfig().getIndexSupplier())).forEachOrdered(allResults::add);            if (cursorMark.equals(nextCursorMark)) {                done = true;            }            cursorMark = nextCursorMark;        }    } catch (IOException | SolrServerException e) {        throw new InvalidSearchException("Unable to complete search", e);    }    SearchResponse searchResponse = new SearchResponse();    searchResponse.setResults(allResults);    searchResponse.setTotal(allResults.size());    return searchResponse;}
public SearchResponse metron_f7332_1(SearchRequest searchRequest) throws InvalidSearchException
{                String activeStatusClause = MetaAlertConstants.STATUS_FIELD + ":" + MetaAlertStatus.ACTIVE.getStatusString();    String metaalertTypeClause = config.getSourceTypeField() + ":" + MetaAlertConstants.METAALERT_TYPE;                    String parentChildQuery = "(+" + activeStatusClause + " +" + "{!parent which=" + metaalertTypeClause + " v='" + searchRequest.getQuery() + "'})";                    String fullQuery = "(" + searchRequest.getQuery() + " AND -" + MetaAlertConstants.METAALERT_FIELD + ":[* TO *]" + " AND " + "-" + metaalertTypeClause + ")" + " OR " + parentChildQuery;        searchRequest.setQuery(fullQuery);        List<String> fields = searchRequest.getFields();    String fieldList = "*";    if (fields != null) {        fieldList = StringUtils.join(fields, ",");    }        SearchResponse results = solrSearchDao.search(searchRequest, fieldList);            if (fieldList.contains("*") || fieldList.contains(config.getSourceTypeField())) {        List<String> metaalertGuids = new ArrayList<>();        for (SearchResult result : results.getResults()) {            if (result.getSource().get(config.getSourceTypeField()).equals(MetaAlertConstants.METAALERT_TYPE)) {                                metaalertGuids.add(result.getId());            }        }                        if (metaalertGuids.size() > 0) {            Map<String, String> params = new HashMap<>();            params.put("fl", fieldList + ",[child parentFilter=" + metaalertTypeClause + " limit=999]");            SolrParams solrParams = new MapSolrParams(params);            try {                SolrDocumentList solrDocumentList = solrClient.getById(METAALERTS_COLLECTION, metaalertGuids, solrParams);                Map<String, Document> guidToDocuments = new HashMap<>();                for (SolrDocument doc : solrDocumentList) {                    Document document = SolrUtilities.toDocument(doc);                    guidToDocuments.put(document.getGuid(), document);                }                                for (SearchResult result : results.getResults()) {                    Document fullDoc = guidToDocuments.get(result.getId());                    if (fullDoc != null) {                        result.setSource(fullDoc.getDocument());                    }                }            } catch (SolrServerException | IOException e) {                throw new InvalidSearchException("Error when retrieving child alerts for metaalerts", e);            }        }    }    return results;}
public GroupResponse metron_f7333_1(GroupRequest groupRequest) throws InvalidSearchException
{        String sourceType = ClientUtils.escapeQueryChars(config.getSourceTypeField());    String baseQuery = groupRequest.getQuery();    String adjustedQuery = baseQuery + " -" + MetaAlertConstants.METAALERT_FIELD + ":[* TO *]" + " -" + sourceType + ":" + MetaAlertConstants.METAALERT_TYPE;        groupRequest.setQuery(adjustedQuery);    return solrSearchDao.group(groupRequest);}
public Document metron_f7334_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    List<GetRequest> alertRequests = request.getAlerts();    if (request.getAlerts().isEmpty()) {        throw new InvalidCreateException("MetaAlertCreateRequest must contain alerts");    }    if (request.getGroups().isEmpty()) {        throw new InvalidCreateException("MetaAlertCreateRequest must contain UI groups");    }        Iterable<Document> alerts = getRetrieveLatestDao().getAllLatest(alertRequests);    Document metaAlert = buildCreateDocument(alerts, request.getGroups(), MetaAlertConstants.ALERT_FIELD);    MetaScores.calculateMetaScores(metaAlert, getConfig().getThreatTriageField(), getConfig().getThreatSort());        metaAlert.getDocument().put(getConfig().getSourceTypeField(), MetaAlertConstants.METAALERT_TYPE);        Map<Document, Optional<String>> updates = new HashMap<>();    updates.put(metaAlert, Optional.of(METAALERTS_COLLECTION));    try {                        Map<String, Optional<String>> guidToIndices = alertRequests.stream().collect(Collectors.toMap(GetRequest::getGuid, GetRequest::getIndex));        Map<String, String> guidToSensorTypes = alertRequests.stream().collect(Collectors.toMap(GetRequest::getGuid, GetRequest::getSensorType));        for (Document alert : alerts) {            if (addMetaAlertToAlert(metaAlert.getGuid(), alert)) {                                Optional<String> index = guidToIndices.get(alert.getGuid());                if (!index.isPresent()) {                    index = Optional.ofNullable(guidToSensorTypes.get(alert.getGuid()));                    if (!index.isPresent()) {                        throw new IllegalArgumentException("Could not find index for " + alert.getGuid());                    }                }                updates.put(alert, index);            }        }                update(updates);        solrClient.commit(METAALERTS_COLLECTION);        return metaAlert;    } catch (IOException | SolrServerException e) {        throw new InvalidCreateException("Unable to create meta alert", e);    }}
public Document metron_f7335_0(Document update, Optional<String> collection) throws IOException
{    if (MetaAlertConstants.METAALERT_TYPE.equals(update.getSensorType())) {                throw new UnsupportedOperationException("Meta alerts cannot be directly updated");    }        Map<Document, Optional<String>> updates = new HashMap<>();    updates.put(update, collection);            SearchResponse searchResponse;    try {        searchResponse = metaAlertSearchDao.getAllMetaAlertsForAlert(update.getGuid());    } catch (InvalidSearchException e) {        throw new IOException("Unable to retrieve metaalerts for alert", e);    }    ArrayList<Document> metaAlerts = new ArrayList<>();    for (SearchResult searchResult : searchResponse.getResults()) {        Document doc = new Document(searchResult.getSource(), searchResult.getId(), MetaAlertConstants.METAALERT_TYPE, 0L);        metaAlerts.add(doc);    }    for (Document metaAlert : metaAlerts) {        if (replaceAlertInMetaAlert(metaAlert, update)) {            updates.put(metaAlert, Optional.of(METAALERTS_COLLECTION));        }    }        getUpdateDao().batchUpdate(updates);    try {        solrClient.commit(METAALERTS_COLLECTION);        if (collection.isPresent()) {            solrClient.commit(collection.get());        }    } catch (SolrServerException e) {        throw new IOException("Unable to update document", e);    }    return update;}
public Document metron_f7336_0(CommentAddRemoveRequest request) throws IOException
{    return getUpdateDao().addCommentToAlert(request);}
public Document metron_f7337_0(CommentAddRemoveRequest request) throws IOException
{    return getUpdateDao().removeCommentFromAlert(request);}
public Document metron_f7338_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return getUpdateDao().addCommentToAlert(request, latest);}
public Document metron_f7339_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return getUpdateDao().removeCommentFromAlert(request, latest);}
protected boolean metron_f7340_0(Document metaAlert, Document alert)
{    boolean metaAlertUpdated = removeAlertsFromMetaAlert(metaAlert, Collections.singleton(alert.getGuid()));    if (metaAlertUpdated) {        addAlertsToMetaAlert(metaAlert, Collections.singleton(alert));    }    return metaAlertUpdated;}
public Document metron_f7341_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException, IllegalStateException
{    Document metaAlert = getRetrieveLatestDao().getLatest(metaAlertGuid, MetaAlertConstants.METAALERT_TYPE);    if (MetaAlertStatus.ACTIVE.getStatusString().equals(metaAlert.getDocument().get(MetaAlertConstants.STATUS_FIELD))) {        Iterable<Document> alerts = getRetrieveLatestDao().getAllLatest(alertRequests);        Map<Document, Optional<String>> updates = buildAddAlertToMetaAlertUpdates(metaAlert, alerts);        update(updates);    } else {        throw new IllegalStateException("Adding alerts to an INACTIVE meta alert is not allowed");    }    try {        solrClient.commit(METAALERTS_COLLECTION);    } catch (SolrServerException e) {        throw new IOException("Unable to commit alerts to metaalert: " + metaAlertGuid, e);    }    return metaAlert;}
public Document metron_f7342_1(String guid, String sensorType) throws IOException
{    try {        Optional<String> index = SolrUtilities.getIndex(config.getIndexSupplier(), sensorType, Optional.empty());        if (!index.isPresent()) {                        return null;        }        SolrDocument solrDocument = client.getById(index.get(), guid);        if (solrDocument == null) {                        return null;        }        return SolrUtilities.toDocument(solrDocument);    } catch (SolrServerException e) {        throw new IOException(e);    }}
public Iterable<Document> metron_f7343_1(List<GetRequest> getRequests) throws IOException
{    Map<String, Collection<String>> collectionIdMap = new HashMap<>();    for (GetRequest getRequest : getRequests) {        Optional<String> index = SolrUtilities.getIndex(config.getIndexSupplier(), getRequest.getSensorType(), getRequest.getIndex());        if (index.isPresent()) {            Collection<String> ids = collectionIdMap.getOrDefault(index.get(), new HashSet<>());            ids.add(getRequest.getGuid());            collectionIdMap.put(index.get(), ids);        } else {                    }    }    try {        List<Document> documents = new ArrayList<>();        for (String collection : collectionIdMap.keySet()) {            SolrDocumentList solrDocumentList = client.getById(collectionIdMap.get(collection), new SolrQuery().set("collection", collection));            documents.addAll(solrDocumentList.stream().map(SolrUtilities::toDocument).collect(Collectors.toList()));        }        return documents;    } catch (SolrServerException e) {        throw new IOException(e);    }}
protected AccessConfig metron_f7344_0()
{    return accessConfig;}
public SearchResponse metron_f7345_0(SearchRequest searchRequest) throws InvalidSearchException
{    return search(searchRequest, null);}
public SearchResponse metron_f7346_1(SearchRequest searchRequest, String fieldList) throws InvalidSearchException
{    validateSearchRequest(searchRequest);    try {        SolrQuery query = buildSearchRequest(searchRequest, fieldList);        QueryResponse response = client.query(query);        logQueryDebugDetail(query, response);        return buildSearchResponse(searchRequest, response);    } catch (SolrException | IOException | SolrServerException e) {        String msg = e.getMessage();                throw new InvalidSearchException(msg, e);    }}
private void metron_f7347_0(SearchRequest searchRequest) throws InvalidSearchException
{    if (searchRequest.getQuery() == null) {        throw new InvalidSearchException("Search query is invalid: null");    }    if (client == null) {        throw new InvalidSearchException("Uninitialized Dao!  You must call init() prior to use.");    }    if (searchRequest.getSize() > accessConfig.getMaxSearchResults()) {        throw new InvalidSearchException("Search result size must be less than " + accessConfig.getMaxSearchResults());    }}
private void metron_f7348_1(SolrQuery query, QueryResponse response)
{    if (LOG.isDebugEnabled()) {        final String ls = System.lineSeparator();            }}
public GroupResponse metron_f7349_1(GroupRequest groupRequest) throws InvalidSearchException
{    try {        validateGroupRequest(groupRequest);        String groupNames = groupRequest.getGroups().stream().map(Group::getField).collect(Collectors.joining(","));        SolrQuery query = new SolrQuery().setStart(0).setRows(0).setQuery(groupRequest.getQuery()).setShowDebugInfo(        LOG.isDebugEnabled());        query.set("collection", getCollections(groupRequest.getIndices()));        Optional<String> scoreField = groupRequest.getScoreField();        if (scoreField.isPresent()) {            query.set("stats", true);            query.set("stats.field", String.format("{!tag=piv1 sum=true}%s", scoreField.get()));        }        query.set("facet", true);        query.set("facet.pivot", String.format("{!stats=piv1}%s", groupNames));        QueryResponse response = client.query(query);        logQueryDebugDetail(query, response);        return buildGroupResponse(groupRequest, response);    } catch (IOException | SolrServerException e) {        String msg = e.getMessage();                throw new InvalidSearchException(msg, e);    }}
private void metron_f7350_0(GroupRequest groupRequest) throws InvalidSearchException
{    if (groupRequest.getGroups() == null || groupRequest.getGroups().size() == 0) {        throw new InvalidSearchException("At least 1 group must be provided.");    }}
protected SolrQuery metron_f7351_0(SearchRequest searchRequest, String fieldList) throws IOException, SolrServerException
{    SolrQuery query = new SolrQuery().setStart(searchRequest.getFrom()).setRows(searchRequest.getSize()).setQuery(searchRequest.getQuery()).setShowDebugInfo(    LOG.isDebugEnabled());        for (SortField sortField : searchRequest.getSort()) {        query.addSort(sortField.getField(), getSolrSortOrder(sortField.getSortOrder()));    }        List<String> fields = searchRequest.getFields();    if (fieldList == null) {        fieldList = "*";        if (fields != null) {            fieldList = StringUtils.join(fields, ",");        }    }    query.set("fl", fieldList);        List<String> facetFields = searchRequest.getFacetFields();    if (facetFields != null) {        facetFields.forEach(query::addFacetField);    }    query.set("collection", getCollections(searchRequest.getIndices()));    return query;}
private String metron_f7352_0(List<String> indices) throws IOException, SolrServerException
{    List<String> existingCollections = CollectionAdminRequest.listCollections(client);    return indices.stream().filter(existingCollections::contains).collect(Collectors.joining(","));}
private SolrQuery.ORDER metron_f7353_0(SortOrder sortOrder)
{    return sortOrder == SortOrder.DESC ? ORDER.desc : ORDER.asc;}
protected Map<String, Map<String, Long>> metron_f7355_0(List<String> fields, QueryResponse solrResponse)
{    Map<String, Map<String, Long>> fieldCounts = new HashMap<>();    for (String field : fields) {        Map<String, Long> valueCounts = new HashMap<>();        FacetField facetField = solrResponse.getFacetField(field);        for (Count facetCount : facetField.getValues()) {            valueCounts.put(facetCount.getName(), facetCount.getCount());        }        fieldCounts.put(field, valueCounts);    }    return fieldCounts;}
protected GroupResponse metron_f7356_0(GroupRequest groupRequest, QueryResponse response)
{    String groupNames = groupRequest.getGroups().stream().map(Group::getField).collect(Collectors.joining(","));    List<PivotField> pivotFields = response.getFacetPivot().get(groupNames);    GroupResponse groupResponse = new GroupResponse();    groupResponse.setGroupedBy(groupRequest.getGroups().get(0).getField());    groupResponse.setGroupResults(getGroupResults(groupRequest, 0, pivotFields));    return groupResponse;}
protected List<GroupResult> metron_f7357_0(GroupRequest groupRequest, int index, List<PivotField> pivotFields)
{    List<Group> groups = groupRequest.getGroups();    List<GroupResult> searchResultGroups = new ArrayList<>();    final GroupOrder groupOrder = groups.get(index).getOrder();    pivotFields.sort((o1, o2) -> {        String s1 = groupOrder.getGroupOrderType() == GroupOrderType.TERM ? o1.getValue().toString() : Integer.toString(o1.getCount());        String s2 = groupOrder.getGroupOrderType() == GroupOrderType.TERM ? o2.getValue().toString() : Integer.toString(o2.getCount());        if (groupOrder.getSortOrder() == SortOrder.ASC) {            return s1.compareTo(s2);        } else {            return s2.compareTo(s1);        }    });    for (PivotField pivotField : pivotFields) {        GroupResult groupResult = new GroupResult();        groupResult.setKey(pivotField.getValue().toString());        groupResult.setTotal(pivotField.getCount());        Optional<String> scoreField = groupRequest.getScoreField();        if (scoreField.isPresent()) {            groupResult.setScore((Double) pivotField.getFieldStatsInfo().get(scoreField.get()).getSum());        }        if (index < groups.size() - 1) {            groupResult.setGroupedBy(groups.get(index + 1).getField());            groupResult.setGroupResults(getGroupResults(groupRequest, index + 1, pivotField.getPivot()));        }        searchResultGroups.add(groupResult);    }    return searchResultGroups;}
public Document metron_f7358_0(Document update, Optional<String> rawIndex) throws IOException
{    Document newVersion = update;        Object commentsObj = update.getDocument().get(COMMENTS_FIELD);    if (commentsObj instanceof List && ((List<Object>) commentsObj).size() > 0 && ((List<Object>) commentsObj).get(0) instanceof Map) {        newVersion = new Document(update);        convertCommentsToRaw(newVersion.getDocument());    }    try {        SolrInputDocument solrInputDocument = SolrUtilities.toSolrInputDocument(newVersion);        Optional<String> index = SolrUtilities.getIndex(config.getIndexSupplier(), newVersion.getSensorType(), rawIndex);        if (index.isPresent()) {            this.client.add(index.get(), solrInputDocument);            this.client.commit(index.get());        } else {            throw new IllegalStateException("Index must be specified or inferred.");        }    } catch (SolrServerException e) {        throw new IOException(e);    }    return newVersion;}
public Map<Document, Optional<String>> metron_f7359_0(Map<Document, Optional<String>> updates) throws IOException
{        Map<String, Collection<SolrInputDocument>> solrCollectionUpdates = new HashMap<>();    Set<String> collectionsUpdated = new HashSet<>();    for (Entry<Document, Optional<String>> entry : updates.entrySet()) {        SolrInputDocument solrInputDocument = SolrUtilities.toSolrInputDocument(entry.getKey());        Optional<String> index = SolrUtilities.getIndex(config.getIndexSupplier(), entry.getKey().getSensorType(), entry.getValue());        if (index.isPresent()) {            Collection<SolrInputDocument> solrInputDocuments = solrCollectionUpdates.getOrDefault(index.get(), new ArrayList<>());            solrInputDocuments.add(solrInputDocument);            solrCollectionUpdates.put(index.get(), solrInputDocuments);            collectionsUpdated.add(index.get());        } else {            String lookupIndex = config.getIndexSupplier().apply(entry.getKey().getSensorType());            Collection<SolrInputDocument> solrInputDocuments = solrCollectionUpdates.getOrDefault(lookupIndex, new ArrayList<>());            solrInputDocuments.add(solrInputDocument);            solrCollectionUpdates.put(lookupIndex, solrInputDocuments);            collectionsUpdated.add(lookupIndex);        }    }    try {        for (Entry<String, Collection<SolrInputDocument>> entry : solrCollectionUpdates.entrySet()) {            this.client.add(entry.getKey(), entry.getValue());        }        for (String collection : collectionsUpdated) {            this.client.commit(collection);        }    } catch (SolrServerException e) {        throw new IOException(e);    }    return updates;}
public Document metron_f7360_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = retrieveLatestDao.getLatest(request.getGuid(), request.getSensorType());    return addCommentToAlert(request, latest);}
public Document metron_f7361_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    if (latest == null || latest.getDocument() == null) {        throw new IOException(String.format("Unable to add comment. Document with guid %s cannot be found.", request.getGuid()));    }    @SuppressWarnings("unchecked")    List<Map<String, Object>> comments = (List<Map<String, Object>>) latest.getDocument().getOrDefault(COMMENTS_FIELD, new ArrayList<>());    List<Map<String, Object>> originalComments = new ArrayList<>(comments);        List<String> commentStrs = new ArrayList<>();    for (Map<String, Object> comment : originalComments) {        commentStrs.add(new AlertComment(comment).asJson());    }    commentStrs.add(new AlertComment(request.getComment(), request.getUsername(), request.getTimestamp()).asJson());    Document newVersion = new Document(latest);    newVersion.getDocument().put(COMMENTS_FIELD, commentStrs);    return update(newVersion, Optional.empty());}
public Document metron_f7362_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = retrieveLatestDao.getLatest(request.getGuid(), request.getSensorType());    return removeCommentFromAlert(request, latest);}
public Document metron_f7363_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    if (latest == null || latest.getDocument() == null) {        throw new IOException(String.format("Unable to remove comment. Document with guid %s cannot be found.", request.getGuid()));    }    @SuppressWarnings("unchecked")    List<Map<String, Object>> commentMap = (List<Map<String, Object>>) latest.getDocument().get(COMMENTS_FIELD);        if (commentMap == null) {        throw new IOException(String.format("Unable to remove comment. Document with guid %s has no comments.", request.getGuid()));    }    List<Map<String, Object>> originalComments = new ArrayList<>(commentMap);    List<AlertComment> comments = new ArrayList<>();    for (Map<String, Object> commentStr : originalComments) {        comments.add(new AlertComment(commentStr));    }    comments.remove(new AlertComment(request.getComment(), request.getUsername(), request.getTimestamp()));    List<String> commentsAsJson = comments.stream().map(AlertComment::asJson).collect(Collectors.toList());    Document newVersion = new Document(latest);    newVersion.getDocument().put(COMMENTS_FIELD, commentsAsJson);    return update(newVersion, Optional.empty());}
public void metron_f7364_0(Map<String, Object> source)
{    @SuppressWarnings("unchecked")    List<Map<String, Object>> comments = (List<Map<String, Object>>) source.get(COMMENTS_FIELD);    if (comments == null || comments.isEmpty()) {        return;    }    List<String> asJson = new ArrayList<>();    for (Map<String, Object> comment : comments) {        asJson.add((new AlertComment(comment)).asJson());    }    source.put(COMMENTS_FIELD, asJson);}
public static SearchResult metron_f7365_0(SolrDocument solrDocument, List<String> fields, Function<String, String> indexSupplier)
{    SearchResult searchResult = new SearchResult();    searchResult.setId((String) solrDocument.getFieldValue(Constants.GUID));    searchResult.setIndex(indexSupplier.apply((String) solrDocument.getFieldValue(Constants.SENSOR_TYPE)));    Map<String, Object> docSource = toDocument(solrDocument).getDocument();    final Map<String, Object> source = new HashMap<>();    if (fields != null) {        fields.forEach(field -> source.put(field, docSource.get(field)));    } else {        source.putAll(docSource);    }    searchResult.setSource(source);    return searchResult;}
public static Document metron_f7366_0(SolrDocument solrDocument)
{    Map<String, Object> document = new HashMap<>();    solrDocument.getFieldNames().stream().filter(name -> !name.equals(SolrDao.VERSION_FIELD)).forEach(name -> document.put(name, solrDocument.getFieldValue(name)));    reformatComments(solrDocument, document);    insertChildAlerts(solrDocument, document);    return new Document(document, (String) solrDocument.getFieldValue(Constants.GUID), (String) solrDocument.getFieldValue(Constants.SENSOR_TYPE), (Long) solrDocument.getFieldValue(Constants.Fields.TIMESTAMP.getName()));}
protected static void metron_f7367_0(SolrDocument solrDocument, Map<String, Object> document)
{        @SuppressWarnings("unchecked")    List<String> commentStrs = (List<String>) solrDocument.get(COMMENTS_FIELD);    if (commentStrs != null) {        try {            List<AlertComment> comments = new ArrayList<>();            for (String commentStr : commentStrs) {                comments.add(new AlertComment(commentStr));            }            document.put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));        } catch (ParseException e) {            throw new IllegalStateException("Unable to parse comment", e);        }    }}
protected static void metron_f7368_0(SolrDocument solrDocument, Map<String, Object> document)
{        if (solrDocument.hasChildDocuments() && solrDocument.getFieldValue(Constants.SENSOR_TYPE).equals(MetaAlertConstants.METAALERT_TYPE)) {        List<Map<String, Object>> childDocuments = new ArrayList<>();        for (SolrDocument childDoc : solrDocument.getChildDocuments()) {            Map<String, Object> childDocMap = new HashMap<>();            childDoc.getFieldNames().stream().filter(name -> !name.equals(SolrDao.VERSION_FIELD)).forEach(name -> childDocMap.put(name, childDoc.getFieldValue(name)));            childDocuments.add(childDocMap);        }        document.put(MetaAlertConstants.ALERT_FIELD, childDocuments);    }}
public static SolrInputDocument metron_f7369_0(Document document)
{    SolrInputDocument solrInputDocument = new SolrInputDocument();    for (Map.Entry<String, Object> field : document.getDocument().entrySet()) {        if (field.getKey().equals(MetaAlertConstants.ALERT_FIELD)) {                        List<Map<String, Object>> alerts = (List<Map<String, Object>>) field.getValue();            for (Map<String, Object> alert : alerts) {                SolrInputDocument childDocument = new SolrInputDocument();                for (Map.Entry<String, Object> alertField : alert.entrySet()) {                    childDocument.addField(alertField.getKey(), alertField.getValue());                }                solrInputDocument.addChildDocument(childDocument);            }        } else {            solrInputDocument.addField(field.getKey(), field.getValue());        }    }    return solrInputDocument;}
public static Optional<String> metron_f7370_0(Function<String, String> indexSupplier, String sensorName, Optional<String> index)
{    if (index.isPresent()) {        return index;    } else {        String realIndex = indexSupplier.apply(sensorName);        return Optional.ofNullable(realIndex);    }}
public String metron_f7371_0()
{    return name;}
public FieldType metron_f7372_0()
{    this.sortMissingLast = true;    return this;}
public FieldType metron_f7373_0()
{    this.docValues = true;    return this;}
public FieldType metron_f7374_0()
{    this.multiValued = true;    return this;}
public FieldType metron_f7375_0()
{    this.indexed = true;    return this;}
public FieldType metron_f7376_0()
{    this.stored = true;    return this;}
public String metron_f7377_0()
{    return String.format("<fieldType name=\"%s\" " + "stored=\"%s\" " + "indexed=\"%s\" " + "multiValued=\"%s\" " + "class=\"%s\" " + "sortMissingLast=\"%s\" " + "docValues=\"%s\"" + "/>", name, stored + "", indexed + "", multiValued + "", solrClass + "", sortMissingLast + "", docValues + "");}
public String metron_f7378_0()
{    return solrType.toString();}
public static SolrFields metron_f7379_0(String type)
{    for (SolrFields f : values()) {        if (f.elasticsearchTypes.contains(type)) {            return f;        }    }    return null;}
public static void metron_f7380_0(PrintWriter pw)
{    for (SolrFields f : values()) {        pw.println(TAB + f.getTypeDeclaration());    }}
public static String metron_f7381_0(String fieldName)
{    return fieldName.replace(':', '.');}
public static void metron_f7382_0(PrintWriter pw, Map<String, Object> properties)
{    for (Map.Entry<String, Object> property : properties.entrySet()) {        String fieldName = normalizeField(property.getKey());        System.out.println("Processing property: " + fieldName);        if (fieldName.equals("guid")) {            pw.println(TAB + "<field name=\"guid\" type=\"" + SolrFields.STRING.solrType.getName() + "\" indexed=\"true\" stored=\"true\" required=\"true\" multiValued=\"false\" />");        } else {            String type = (String) ((Map<String, Object>) property.getValue()).get("type");            SolrFields solrField = SolrFields.byElasticsearchType(type);            if (solrField == null) {                System.out.println("Skipping " + fieldName + " because I can't find solr type for " + type);                continue;            }            pw.println(TAB + String.format("<field name=\"%s\" type=\"%s\" indexed=\"true\" stored=\"true\" />", fieldName, solrField.solrType.getName()));        }    }}
public static void metron_f7383_0(PrintWriter pw, List<Map<String, Object>> properties)
{    for (Map<String, Object> dynamicProperty : properties) {        for (Map.Entry<String, Object> dynamicFieldDef : dynamicProperty.entrySet()) {            System.out.println("Processing dynamic property: " + dynamicFieldDef.getKey());            Map<String, Object> def = (Map<String, Object>) dynamicFieldDef.getValue();            String match = (String) def.get("match");            if (match == null) {                match = (String) def.get("path_match");            }            match = normalizeField(match);            String type = (String) ((Map<String, Object>) def.get("mapping")).get("type");            SolrFields solrField = SolrFields.byElasticsearchType(type);            if (solrField == null) {                System.out.println("Skipping " + match + " because I can't find solr type for " + type);                continue;            }            if (solrField == null) {                throw new IllegalStateException("Unable to find associated solr type for " + type + " with dynamic property " + solrField);            }            pw.println(TAB + String.format("<dynamicField name=\"%s\" type=\"%s\" multiValued=\"false\" docValues=\"true\"/>", match, solrField.solrType.getName()));        }    }}
public static void metron_f7384_0(PrintWriter pw, Map<String, Object> template)
{    pw.println(PREAMBLE);    System.out.println("Processing " + template.getOrDefault(TEMPLATE_KEY, "unknown template"));    Map<String, Object> mappings = (Map<String, Object>) template.getOrDefault("mappings", new HashMap<>());    if (mappings.size() != 1) {        System.err.println("Unable to process mappings. We expect exactly 1 mapping, there are " + mappings.size() + " mappings specified");    }    String docName = Iterables.getFirst(mappings.keySet(), null);    pw.println(String.format(SCHEMA_FORMAT, docName));    pw.println(TAB + VERSION_FIELD);    pw.println(TAB + ROOT_FIELD);    for (Map.Entry<String, Object> docTypeToMapping : mappings.entrySet()) {        System.out.println("Processing " + docTypeToMapping.getKey() + " doc type");        Map<String, Object> actualMappings = (Map<String, Object>) docTypeToMapping.getValue();        Map<String, Object> properties = (Map<String, Object>) actualMappings.getOrDefault(PROPERTIES_KEY, new HashMap<>());        processProperties(pw, properties);        List<Map<String, Object>> dynamicMappings = (List<Map<String, Object>>) actualMappings.getOrDefault(DYNAMIC_TEMPLATES_KEY, new ArrayList<>());        processDynamicMappings(pw, dynamicMappings);        pw.println(TAB + DYNAMIC_FIELD_CATCHALL);        pw.println(TAB + UNIQUE_KEY);        SolrFields.printTypes(pw);    }    pw.println("</schema>");    pw.flush();}
public static void metron_f7385_0(String... argv) throws IOException
{    String templateFile = argv[0];    String schemaFile = argv[1];    Map<String, Object> template = JSONUtils.INSTANCE.load(new File(templateFile), JSONUtils.MAP_SUPPLIER);    try (PrintWriter pw = new PrintWriter(new File(schemaFile), StandardCharsets.UTF_8.name())) {        translate(pw, template);    }}
public static SolrParams metron_f7386_0(Map<String, Object> config)
{    if (config == null || config.isEmpty()) {        return null;    }    ModifiableSolrParams ret = new ModifiableSolrParams();    for (Map.Entry<String, Object> kv : config.entrySet()) {        Object v = kv.getValue();        if (v instanceof Boolean) {            ret.set(kv.getKey(), (Boolean) v);        } else if (v instanceof Integer) {            ret.set(kv.getKey(), (Integer) v);        } else if (v instanceof Iterable) {            Iterable vals = (Iterable) v;            String[] strVals = new String[Iterables.size(vals)];            int i = 0;            for (Object o : (Iterable) v) {                strVals[i++] = o.toString();            }        }    }    return ret;}
public void metron_f7387_0(String name, int numShards, int replicationFactor) throws IOException, SolrServerException
{    if (!listCollections().contains(name)) {        request(getCreateCollectionsRequest(name, numShards, replicationFactor));    }}
public QueryRequest metron_f7388_0(String name, int numShards, int replicationFactor)
{    ModifiableSolrParams params = new ModifiableSolrParams();    params.set(SolrConstants.REQUEST_ACTION, CollectionParams.CollectionAction.CREATE.name());    params.set(SolrConstants.REQUEST_NAME, name);    params.set(SolrConstants.REQUEST_NUM_SHARDS, numShards);    params.set(SolrConstants.REQUEST_REPLICATION_FACTOR, replicationFactor);    params.set(SolrConstants.REQUEST_COLLECTION_CONFIG_NAME, name);    QueryRequest request = new QueryRequest(params);    request.setPath(SolrConstants.REQUEST_COLLECTIONS_PATH);    return request;}
public List<String> metron_f7389_0() throws IOException, SolrServerException
{    NamedList<Object> response = request(getListCollectionsRequest(), null);    return (List<String>) response.get(SolrConstants.RESPONSE_COLLECTIONS);}
public QueryRequest metron_f7390_0()
{    ModifiableSolrParams params = new ModifiableSolrParams();    params.set(SolrConstants.REQUEST_ACTION, CollectionParams.CollectionAction.LIST.name());    QueryRequest request = new QueryRequest(params);    request.setPath(SolrConstants.REQUEST_COLLECTIONS_PATH);    return request;}
public Optional<T> metron_f7391_1(Map<String, Object> globalConfig, Class<T> clazz)
{    Object val = globalConfig.get(name);    if (val != null) {        T ret = null;        try {            ret = ConversionUtils.convert(val, clazz);        } catch (ClassCastException cce) {            ret = null;        }        if (ret == null) {                                    if (defaultValue.isPresent()) {                return Optional.ofNullable(ConversionUtils.convert(defaultValue.get(), clazz));            } else {                return Optional.empty();            }        } else {            return Optional.ofNullable(ret);        }    } else {        if (defaultValue.isPresent()) {            return Optional.ofNullable(ConversionUtils.convert(defaultValue.get(), clazz));        } else {            return Optional.empty();        }    }}
public Supplier<IllegalArgumentException> metron_f7392_0(Map<String, Object> globalConfig)
{    String message = "Unable to retrieve " + name + " from global config, value associated is " + globalConfig.get(name);    return () -> new IllegalArgumentException(message);}
public T metron_f7393_0(Map<String, Object> globalConfig, Class<T> clazz)
{    return this.coerceOrDefault(globalConfig, clazz).orElseThrow(this.errorOut(globalConfig));}
public SolrWriter metron_f7394_0(MetronSolrClient solr)
{    this.solr = solr;    return this;}
public void metron_f7395_0(Map<String, Object> globalConfiguration)
{    zookeeperUrl = SolrProperties.ZOOKEEPER_QUORUM.coerceOrDefaultOrExcept(globalConfiguration, String.class);    defaultCollection = SolrProperties.DEFAULT_COLLECTION.coerceOrDefaultOrExcept(globalConfiguration, String.class);    solrHttpConfig = SolrProperties.HTTP_CONFIG.coerceOrDefaultOrExcept(globalConfiguration, Map.class);    shouldCommit = SolrProperties.COMMIT_PER_BATCH.coerceOrDefaultOrExcept(globalConfiguration, Boolean.class);    softCommit = SolrProperties.COMMIT_SOFT.coerceOrDefaultOrExcept(globalConfiguration, Boolean.class);    waitSearcher = SolrProperties.COMMIT_WAIT_SEARCHER.coerceOrDefaultOrExcept(globalConfiguration, Boolean.class);    waitFlush = SolrProperties.COMMIT_WAIT_FLUSH.coerceOrDefaultOrExcept(globalConfiguration, Boolean.class);}
public void metron_f7396_1(Map stormConf, WriterConfiguration configurations) throws IOException, SolrServerException
{    Map<String, Object> globalConfiguration = configurations.getGlobalConfig();    initializeFromGlobalConfig(globalConfiguration);                            if (solr == null) {        if (isKerberosEnabled(stormConf)) {            HttpClientUtil.addConfigurer(new Krb5HttpClientConfigurer());        }        solr = new MetronSolrClient(zookeeperUrl, solrHttpConfig);    }    solr.setDefaultCollection(defaultCollection);}
public Collection<SolrInputDocument> metron_f7397_0(Iterable<BulkMessage<JSONObject>> messages)
{    Collection<SolrInputDocument> ret = new ArrayList<>();    for (BulkMessage<JSONObject> bulkWriterMessage : messages) {        SolrInputDocument document = new SolrInputDocument();        JSONObject message = bulkWriterMessage.getMessage();        for (Object key : message.keySet()) {            Object value = message.get(key);            if (value instanceof Iterable) {                for (Object v : (Iterable) value) {                    document.addField("" + key, v);                }            } else {                document.addField("" + key, value);            }        }        if (!document.containsKey(Constants.GUID)) {            document.addField(Constants.GUID, UUID.randomUUID().toString());        }        ret.add(document);    }    return ret;}
protected String metron_f7398_0(String sourceType, WriterConfiguration configurations)
{    String collection = configurations.getIndex(sourceType);    if (StringUtils.isEmpty(collection)) {        return solr.getDefaultCollection();    }    return collection;}
public BulkWriterResponse metron_f7399_0(String sourceType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages) throws Exception
{    String collection = getCollection(sourceType, configurations);    BulkWriterResponse bulkResponse = new BulkWriterResponse();    Collection<SolrInputDocument> docs = toDocs(messages);    Set<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toSet());    try {        Optional<SolrException> exceptionOptional = fromUpdateResponse(solr.add(collection, docs));                if (exceptionOptional.isPresent()) {            bulkResponse.addAllErrors(exceptionOptional.get(), ids);        } else {            if (shouldCommit) {                exceptionOptional = fromUpdateResponse(solr.commit(collection, waitFlush, waitSearcher, softCommit));                if (exceptionOptional.isPresent()) {                    bulkResponse.addAllErrors(exceptionOptional.get(), ids);                }            }            if (!exceptionOptional.isPresent()) {                bulkResponse.addAllSuccesses(ids);            }        }    } catch (HttpSolrClient.RemoteSolrException sse) {        bulkResponse.addAllErrors(sse, ids);    }    return bulkResponse;}
protected Optional<SolrException> metron_f7400_0(UpdateResponse response)
{    if (response != null && response.getStatus() > 0) {        String message = "Solr Update response: " + Joiner.on(",").join(response.getResponse());        return Optional.of(new SolrException(SolrException.ErrorCode.BAD_REQUEST, message));    }    return Optional.empty();}
public String metron_f7401_0()
{    return SOLR_WRITER_NAME;}
public void metron_f7402_0() throws Exception
{    if (solr != null) {        solr.close();    }}
private boolean metron_f7403_0(Map stormConfig)
{    if (stormConfig == null) {        return false;    }    String value = (String) stormConfig.get(JAVA_SECURITY_CONFIG_PROPERTY);    return value != null && !value.isEmpty();}
public static Configurations metron_f7404_0() throws IOException
{    Configurations configurations = new Configurations();    configurations.updateGlobalConfig(ConfigurationsUtils.readGlobalConfigFromFile("../" + TestConstants.SAMPLE_CONFIG_PATH));    return configurations;}
public static ParserConfigurations metron_f7405_0() throws IOException
{    ParserConfigurations configurations = new ParserConfigurations();    configurations.updateGlobalConfig(ConfigurationsUtils.readGlobalConfigFromFile(TestConstants.SAMPLE_CONFIG_PATH));    Map<String, byte[]> sensorParserConfigs = ConfigurationsUtils.readSensorParserConfigsFromFile(TestConstants.PARSER_CONFIGS_PATH);    for (String sensorType : sensorParserConfigs.keySet()) {        configurations.updateSensorParserConfig(sensorType, sensorParserConfigs.get(sensorType));    }    return configurations;}
public static EnrichmentConfigurations metron_f7406_0() throws IOException
{    EnrichmentConfigurations configurations = new EnrichmentConfigurations();    configurations.updateGlobalConfig(ConfigurationsUtils.readGlobalConfigFromFile(TestConstants.SAMPLE_CONFIG_PATH));    Map<String, byte[]> sensorEnrichmentConfigs = ConfigurationsUtils.readSensorEnrichmentConfigsFromFile(TestConstants.SAMPLE_CONFIG_PATH);    for (String sensorType : sensorEnrichmentConfigs.keySet()) {        configurations.updateSensorEnrichmentConfig(sensorType, sensorEnrichmentConfigs.get(sensorType));    }    return configurations;}
public static IndexingConfigurations metron_f7407_0() throws IOException
{    IndexingConfigurations configurations = new IndexingConfigurations();    configurations.updateGlobalConfig(ConfigurationsUtils.readGlobalConfigFromFile("../" + TestConstants.SAMPLE_CONFIG_PATH));    Map<String, byte[]> sensorIndexingConfigs = ConfigurationsUtils.readSensorIndexingConfigsFromFile("../" + TestConstants.SAMPLE_CONFIG_PATH);    for (String sensorType : sensorIndexingConfigs.keySet()) {        configurations.updateSensorIndexingConfig(sensorType, sensorIndexingConfigs.get(sensorType));    }    return configurations;}
public void metron_f7408_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(SOLR_ZOOKEEPER, "   zookeeper:2181   ");        }    };    List<String> actual = SolrClientFactory.getZkHosts(globalConfig);    List<String> expected = new ArrayList<>();    expected.add("zookeeper:2181");    assertEquals(expected, actual);}
public void metron_f7409_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(SOLR_ZOOKEEPER, "   zookeeper:2181    ,   zookeeper2:2181    ");        }    };    List<String> actual = SolrClientFactory.getZkHosts(globalConfig);    List<String> expected = new ArrayList<>();    expected.add("zookeeper:2181");    expected.add("zookeeper2:2181");    assertEquals(expected, actual);}
public void metron_f7410_0() throws Exception
{    solrColumnMetadataDao = new SolrColumnMetadataDao(null);}
public void metron_f7411_0() throws Exception
{    List<Map<String, Object>> broFields = new ArrayList<>();    broFields.add(new HashMap<String, Object>() {        {            put("name", "string");            put("type", "string");        }    });    broFields.add(new HashMap<String, Object>() {        {            put("name", "int");            put("type", "pint");        }    });    broFields.add(new HashMap<String, Object>() {        {            put("name", "float");            put("type", "pfloat");        }    });    broFields.add(new HashMap<String, Object>() {        {            put("name", "double");            put("type", "pdouble");        }    });    broFields.add(new HashMap<String, Object>() {        {            put("name", "boolean");            put("type", "boolean");        }    });    broFields.add(new HashMap<String, Object>() {        {            put("name", "broField");            put("type", "string");        }    });    broFields.add(new HashMap<String, Object>() {        {            put("name", "conflict");            put("type", "string");        }    });    List<Map<String, Object>> snortFields = new ArrayList<>();    snortFields.add(new HashMap<String, Object>() {        {            put("name", "long");            put("type", "plong");        }    });    snortFields.add(new HashMap<String, Object>() {        {            put("name", "snortField");            put("type", "plong");        }    });    snortFields.add(new HashMap<String, Object>() {        {            put("name", "unknown");            put("type", "unknown");        }    });    broFields.add(new HashMap<String, Object>() {        {            put("name", "conflict");            put("type", "plong");        }    });    solrColumnMetadataDao = spy(new SolrColumnMetadataDao(null));    doReturn(broFields).when(solrColumnMetadataDao).getIndexFields("bro");    doReturn(snortFields).when(solrColumnMetadataDao).getIndexFields("snort");    Map<String, FieldType> columnMetadata = solrColumnMetadataDao.getColumnMetadata(Arrays.asList("bro", "snort"));    assertEquals(FieldType.BOOLEAN, columnMetadata.get("boolean"));    assertEquals(FieldType.TEXT, columnMetadata.get("string"));    assertEquals(FieldType.TEXT, columnMetadata.get("broField"));    assertEquals(FieldType.DOUBLE, columnMetadata.get("double"));    assertEquals(FieldType.LONG, columnMetadata.get("long"));    assertEquals(FieldType.FLOAT, columnMetadata.get("float"));    assertEquals(FieldType.INTEGER, columnMetadata.get("int"));    assertEquals(FieldType.LONG, columnMetadata.get("snortField"));    assertEquals(FieldType.OTHER, columnMetadata.get("conflict"));    assertEquals(FieldType.OTHER, columnMetadata.get("unknown"));}
public void metron_f7412_0() throws Exception
{    exception.expect(IOException.class);    exception.expectMessage("solr exception");    solrColumnMetadataDao = spy(new SolrColumnMetadataDao(null));    doThrow(new SolrServerException("solr exception")).when(solrColumnMetadataDao).getIndexFields("bro");    solrColumnMetadataDao.getColumnMetadata(Arrays.asList("bro", "snort"));}
public void metron_f7413_0() throws Exception
{    solrColumnMetadataDao = spy(new SolrColumnMetadataDao(null));    SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, "solr exception");    doThrow(solrException).when(solrColumnMetadataDao).getIndexFields("bro");    Map<String, FieldType> columnMetadata = solrColumnMetadataDao.getColumnMetadata(Collections.singletonList("bro"));    assertNotNull(columnMetadata);}
public void metron_f7414_0()
{    client = mock(SolrClient.class);    solrSearchDao = mock(SolrSearchDao.class);    solrUpdateDao = mock(SolrUpdateDao.class);    solrRetrieveLatestDao = mock(SolrRetrieveLatestDao.class);    solrColumnMetadataDao = mock(SolrColumnMetadataDao.class);    mockStatic(SolrClientFactory.class);}
public void metron_f7415_0()
{    AccessConfig accessConfig = new AccessConfig();    solrDao = spy(new SolrDao(client, accessConfig, solrSearchDao, solrUpdateDao, solrRetrieveLatestDao, solrColumnMetadataDao));    doNothing().when(solrDao).enableKerberos();    solrDao.init(accessConfig);    verify(solrDao, times(0)).enableKerberos();    accessConfig.setKerberosEnabled(true);    solrDao.init(accessConfig);    verify(solrDao).enableKerberos();}
public void metron_f7416_0() throws Exception
{    AccessConfig accessConfig = new AccessConfig();    accessConfig.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(SOLR_ZOOKEEPER, "zookeeper:2181");        }    });    solrDao = spy(new SolrDao());    when(SolrClientFactory.create(accessConfig.getGlobalConfigSupplier().get())).thenReturn(client);    whenNew(SolrSearchDao.class).withArguments(client, accessConfig).thenReturn(solrSearchDao);    whenNew(SolrRetrieveLatestDao.class).withArguments(client, accessConfig).thenReturn(solrRetrieveLatestDao);    whenNew(SolrUpdateDao.class).withArguments(client, solrRetrieveLatestDao, accessConfig).thenReturn(solrUpdateDao);    whenNew(SolrColumnMetadataDao.class).withArguments(client).thenReturn(solrColumnMetadataDao);    solrDao.init(accessConfig);    SearchRequest searchRequest = mock(SearchRequest.class);    solrDao.search(searchRequest);    verify(solrSearchDao).search(searchRequest);    GroupRequest groupRequest = mock(GroupRequest.class);    solrDao.group(groupRequest);    verify(solrSearchDao).group(groupRequest);    solrDao.getLatest("guid", "collection");    verify(solrRetrieveLatestDao).getLatest("guid", "collection");    GetRequest getRequest1 = mock(GetRequest.class);    GetRequest getRequest2 = mock(GetRequest.class);    solrDao.getAllLatest(Arrays.asList(getRequest1, getRequest2));    verify(solrRetrieveLatestDao).getAllLatest(Arrays.asList(getRequest1, getRequest2));    Document document = mock(Document.class);    solrDao.update(document, Optional.of("bro"));    verify(solrUpdateDao).update(document, Optional.of("bro"));    Map<Document, Optional<String>> updates = new HashMap<Document, Optional<String>>() {        {            put(document, Optional.of("bro"));        }    };    solrDao.batchUpdate(updates);    verify(solrUpdateDao).batchUpdate(updates);    solrDao.getColumnMetadata(Arrays.asList("bro", "snort"));    verify(solrColumnMetadataDao).getColumnMetadata(Arrays.asList("bro", "snort"));}
public static void metron_f7417_0()
{    accessConfig.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(SOLR_ZOOKEEPER, "zookeeper:2181");        }    });}
public void metron_f7418_0()
{    client = mock(SolrClient.class);    mockStatic(SolrClientFactory.class);    when(SolrClientFactory.create(accessConfig.getGlobalConfigSupplier().get())).thenReturn(client);}
public void metron_f7419_0()
{    IndexDao dao = new IndexDao() {        @Override        public SearchResponse search(SearchRequest searchRequest) {            return null;        }        @Override        public GroupResponse group(GroupRequest groupRequest) {            return null;        }        @Override        public void init(AccessConfig config) {        }        @Override        public Document getLatest(String guid, String sensorType) {            return null;        }        @Override        public Iterable<Document> getAllLatest(List<GetRequest> getRequests) {            return null;        }        @Override        public Document update(Document update, Optional<String> index) {            return null;        }        @Override        public Map<Document, Optional<String>> batchUpdate(Map<Document, Optional<String>> updates) {            return null;        }        @Override        public Document addCommentToAlert(CommentAddRemoveRequest request) {            return null;        }        @Override        public Document removeCommentFromAlert(CommentAddRemoveRequest request) {            return null;        }        @Override        public Document addCommentToAlert(CommentAddRemoveRequest request, Document latest) {            return null;        }        @Override        public Document removeCommentFromAlert(CommentAddRemoveRequest request, Document latest) {            return null;        }        @Override        public Document patch(RetrieveLatestDao dao, PatchRequest request, Optional<Long> timestamp) {            return null;        }        @Override        public Map<String, FieldType> getColumnMetadata(List<String> indices) {            return null;        }    };    SolrMetaAlertDao metaAlertDao = new SolrMetaAlertDao();    metaAlertDao.init(dao);}
public SearchResponse metron_f7420_0(SearchRequest searchRequest)
{    return null;}
public GroupResponse metron_f7421_0(GroupRequest groupRequest)
{    return null;}
public void metron_f7422_0(AccessConfig config)
{}
public Document metron_f7423_0(String guid, String sensorType)
{    return null;}
public Iterable<Document> metron_f7424_0(List<GetRequest> getRequests)
{    return null;}
public Document metron_f7425_0(Document update, Optional<String> index)
{    return null;}
public Map<Document, Optional<String>> metron_f7426_0(Map<Document, Optional<String>> updates)
{    return null;}
public Document metron_f7427_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f7428_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f7429_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f7430_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f7431_0(RetrieveLatestDao dao, PatchRequest request, Optional<Long> timestamp)
{    return null;}
public Map<String, FieldType> metron_f7432_0(List<String> indices)
{    return null;}
public void metron_f7433_0()
{    HBaseDao dao = new HBaseDao();    SolrMetaAlertDao solrDao = new SolrMetaAlertDao();    solrDao.init(dao, Optional.empty());}
public void metron_f7434_0() throws InvalidCreateException, IOException
{    SolrDao solrDao = new SolrDao();    solrDao.init(accessConfig);    SolrMetaAlertDao emaDao = new SolrMetaAlertDao();    emaDao.init(solrDao);    MetaAlertCreateRequest createRequest = new MetaAlertCreateRequest();    emaDao.createMetaAlert(createRequest);}
public void metron_f7435_0() throws InvalidCreateException, IOException
{    SolrDao solrDao = new SolrDao();    solrDao.init(accessConfig);    MultiIndexDao miDao = new MultiIndexDao(solrDao);    SolrMetaAlertDao emaDao = new SolrMetaAlertDao();    emaDao.init(miDao);    MetaAlertCreateRequest createRequest = new MetaAlertCreateRequest();    createRequest.setAlerts(Collections.singletonList(new GetRequest("don't", "care")));    emaDao.createMetaAlert(createRequest);}
public void metron_f7436_0() throws Exception
{    client = mock(SolrClient.class);    accessConfig = mock(AccessConfig.class);    when(accessConfig.getIndexSupplier()).thenReturn(sensorType -> sensorType);    solrSearchDao = new SolrSearchDao(client, accessConfig);    solrRetrieveLatestDao = new SolrRetrieveLatestDao(client, accessConfig);    mockStatic(CollectionAdminRequest.class);    when(CollectionAdminRequest.listCollections(client)).thenReturn(Arrays.asList("bro", "snort"));}
public void metron_f7437_0() throws Exception
{    SearchRequest searchRequest = mock(SearchRequest.class);    SearchResponse searchResponse = mock(SearchResponse.class);    SolrQuery solrQuery = mock(SolrQuery.class);    QueryResponse queryResponse = mock(QueryResponse.class);    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    when(searchRequest.getQuery()).thenReturn("query");    doReturn(solrQuery).when(solrSearchDao).buildSearchRequest(searchRequest, "*");    when(client.query(solrQuery)).thenReturn(queryResponse);    doReturn(searchResponse).when(solrSearchDao).buildSearchResponse(searchRequest, queryResponse);    assertEquals(searchResponse, solrSearchDao.search(searchRequest, "*"));    verify(solrSearchDao).buildSearchRequest(searchRequest, "*");    verify(client).query(solrQuery);    verify(solrSearchDao).buildSearchResponse(searchRequest, queryResponse);    verifyNoMoreInteractions(client);}
public void metron_f7438_0() throws Exception
{    exception.expect(InvalidSearchException.class);    exception.expectMessage("Search query is invalid: null");    solrSearchDao.search(new SearchRequest());}
public void metron_f7439_0() throws Exception
{    exception.expect(InvalidSearchException.class);    exception.expectMessage("Uninitialized Dao!  You must call init() prior to use.");    SearchRequest searchRequest = new SearchRequest();    searchRequest.setQuery("query");    new SolrSearchDao(null, accessConfig).search(searchRequest);}
public void metron_f7440_0() throws Exception
{    exception.expect(InvalidSearchException.class);    exception.expectMessage("At least 1 group must be provided.");    GroupRequest groupRequest = mock(GroupRequest.class);    GroupResponse groupResponse = mock(GroupResponse.class);    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    when(groupRequest.getQuery()).thenReturn("query");    when(groupRequest.getGroups()).thenReturn(null);    when(groupRequest.getScoreField()).thenReturn(Optional.of("scoreField"));    when(groupRequest.getIndices()).thenReturn(Arrays.asList("bro", "snort"));    assertEquals(groupResponse, solrSearchDao.group(groupRequest));    verifyNoMoreInteractions(client);}
public void metron_f7441_0() throws Exception
{    exception.expect(InvalidSearchException.class);    exception.expectMessage("At least 1 group must be provided.");    GroupRequest groupRequest = mock(GroupRequest.class);    GroupResponse groupResponse = mock(GroupResponse.class);    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    when(groupRequest.getQuery()).thenReturn("query");    when(groupRequest.getGroups()).thenReturn(Collections.EMPTY_LIST);    when(groupRequest.getScoreField()).thenReturn(Optional.of("scoreField"));    when(groupRequest.getIndices()).thenReturn(Arrays.asList("bro", "snort"));    assertEquals(groupResponse, solrSearchDao.group(groupRequest));    verifyNoMoreInteractions(client);}
public void metron_f7442_0() throws Exception
{    exception.expect(InvalidSearchException.class);    exception.expectMessage("Search result size must be less than 100");    when(accessConfig.getMaxSearchResults()).thenReturn(100);    SearchRequest searchRequest = new SearchRequest();    searchRequest.setQuery("query");    searchRequest.setSize(200);    solrSearchDao.search(searchRequest);}
public void metron_f7443_0() throws Exception
{    GroupRequest groupRequest = mock(GroupRequest.class);    QueryResponse queryResponse = mock(QueryResponse.class);    GroupResponse groupResponse = mock(GroupResponse.class);    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    Group group1 = new Group();    group1.setField("field1");    Group group2 = new Group();    group2.setField("field2");    when(groupRequest.getQuery()).thenReturn("query");    when(groupRequest.getGroups()).thenReturn(Arrays.asList(group1, group2));    when(groupRequest.getScoreField()).thenReturn(Optional.of("scoreField"));    when(groupRequest.getIndices()).thenReturn(Arrays.asList("bro", "snort"));    when(client.query(any())).thenReturn(queryResponse);    doReturn(groupResponse).when(solrSearchDao).buildGroupResponse(groupRequest, queryResponse);    SolrQuery expectedSolrQuery = new SolrQuery().setStart(0).setRows(0).setQuery("query");    expectedSolrQuery.set("collection", "bro,snort");    expectedSolrQuery.set("stats", true);    expectedSolrQuery.set("stats.field", "{!tag=piv1 sum=true}scoreField");    expectedSolrQuery.set("facet", true);    expectedSolrQuery.set("facet.pivot", "{!stats=piv1}field1,field2");    assertEquals(groupResponse, solrSearchDao.group(groupRequest));    verify(client).query(argThat(new SolrQueryMatcher(expectedSolrQuery)));    verify(solrSearchDao).buildGroupResponse(groupRequest, queryResponse);    verifyNoMoreInteractions(client);}
public void metron_f7444_0() throws Exception
{    SolrDocument solrDocument = createSolrDocument("bro", 123456789L);    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    when(client.getById("collection", "guid")).thenReturn(solrDocument);    Document document = SolrUtilities.toDocument(solrDocument);    assertEquals(document, solrRetrieveLatestDao.getLatest("guid", "collection"));    verify(client).getById("collection", "guid");    verifyNoMoreInteractions(client);}
public void metron_f7445_0() throws Exception
{    GetRequest broRequest1 = new GetRequest("bro-1", "bro");    GetRequest broRequest2 = new GetRequest("bro-2", "bro");    GetRequest snortRequest1 = new GetRequest("snort-1", "snort");    GetRequest snortRequest2 = new GetRequest("snort-2", "snort");    SolrDocument broSolrDoc1 = createSolrDocument("bro", 12345L);    SolrDocument broSolrDoc2 = createSolrDocument("bro", 34567L);    SolrDocument snortSolrDoc1 = createSolrDocument("snort", 12345L);    SolrDocument snortSolrDoc2 = createSolrDocument("snort", 67890L);    Document broDoc1 = SolrUtilities.toDocument(broSolrDoc1);    Document broDoc2 = SolrUtilities.toDocument(broSolrDoc2);    Document snortDoc1 = SolrUtilities.toDocument(snortSolrDoc1);    Document snortDoc2 = SolrUtilities.toDocument(snortSolrDoc2);    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    SolrDocumentList broList = new SolrDocumentList();    broList.add(broSolrDoc1);    broList.add(broSolrDoc2);    SolrDocumentList snortList = new SolrDocumentList();    snortList.add(snortSolrDoc1);    snortList.add(snortSolrDoc2);    when(client.getById((Collection<String>) argThat(hasItems("bro-1", "bro-2")), argThat(new ModifiableSolrParamsMatcher(new ModifiableSolrParams().set("collection", "bro"))))).thenReturn(broList);    when(client.getById((Collection<String>) argThat(hasItems("snort-1", "snort-2")), argThat(new ModifiableSolrParamsMatcher(new ModifiableSolrParams().set("collection", "snort"))))).thenReturn(snortList);    assertEquals(Arrays.asList(broDoc1, broDoc2, snortDoc1, snortDoc2), solrRetrieveLatestDao.getAllLatest(Arrays.asList(broRequest1, broRequest2, snortRequest1, snortRequest2)));}
public void metron_f7446_0() throws Exception
{    SearchRequest searchRequest = new SearchRequest();    searchRequest.setIndices(Arrays.asList("bro", "snort"));    searchRequest.setSize(5);    searchRequest.setFrom(10);    searchRequest.setQuery("query");    SortField sortField = new SortField();    sortField.setField("sortField");    sortField.setSortOrder("ASC");    searchRequest.setSort(Collections.singletonList(sortField));    searchRequest.setFields(Arrays.asList("field1", "field2"));    searchRequest.setFacetFields(Arrays.asList("facetField1", "facetField2"));    SolrQuery exceptedSolrQuery = new SolrQuery().setStart(10).setRows(5).setQuery("query").addSort("sortField", SolrQuery.ORDER.asc).addField("field1").addField("field2").addFacetField("facetField1", "facetField2");    exceptedSolrQuery.set("collection", "bro,snort");    SolrQuery solrQuery = solrSearchDao.buildSearchRequest(searchRequest, "field1,field2");    assertThat(solrQuery, new SolrQueryMatcher(exceptedSolrQuery));}
public void metron_f7447_0()
{    SearchRequest searchRequest = new SearchRequest();    searchRequest.setFields(Collections.singletonList("id"));    searchRequest.setFacetFields(Collections.singletonList("facetField"));    QueryResponse queryResponse = mock(QueryResponse.class);    SolrDocument solrDocument1 = new SolrDocument();    solrDocument1.setField(Constants.GUID, "id1");    solrDocument1.setField("id", "id1");    SolrDocument solrDocument2 = new SolrDocument();    solrDocument2.setField(Constants.GUID, "id2");    solrDocument2.setField("id", "id2");    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    SolrDocumentList solrDocumentList = new SolrDocumentList();    solrDocumentList.add(solrDocument1);    solrDocumentList.add(solrDocument2);    solrDocumentList.setNumFound(100);    when(queryResponse.getResults()).thenReturn(solrDocumentList);    SearchResult searchResult1 = new SearchResult();    searchResult1.setId("id1");    HashMap<String, Object> source1 = new HashMap<>();    source1.put("id", "id1");    searchResult1.setSource(source1);    SearchResult searchResult2 = new SearchResult();    searchResult2.setId("id2");    HashMap<String, Object> source2 = new HashMap<>();    source2.put("id", "id2");    searchResult2.setSource(source2);    Map<String, Map<String, Long>> facetCounts = new HashMap<String, Map<String, Long>>() {        {            put("id", new HashMap<String, Long>() {                {                    put("id1", 1L);                    put("id2", 1L);                }            });        }    };    doReturn(facetCounts).when(solrSearchDao).getFacetCounts(Collections.singletonList("facetField"), queryResponse);    SearchResponse expectedSearchResponse = new SearchResponse();    SearchResult expectedSearchResult1 = new SearchResult();    expectedSearchResult1.setId("id1");    expectedSearchResult1.setSource(source1);    SearchResult expectedSearchResult2 = new SearchResult();    expectedSearchResult2.setId("id2");    expectedSearchResult2.setSource(source2);    expectedSearchResponse.setResults(Arrays.asList(expectedSearchResult1, expectedSearchResult2));    expectedSearchResponse.setTotal(100);    expectedSearchResponse.setFacetCounts(facetCounts);    assertEquals(expectedSearchResponse, solrSearchDao.buildSearchResponse(searchRequest, queryResponse));}
public void metron_f7448_0()
{    SolrDocument solrDocument = mock(SolrDocument.class);    when(solrDocument.getFieldValue(Constants.GUID)).thenReturn("guid");    when(solrDocument.getFieldValue(Constants.SENSOR_TYPE)).thenReturn("sensorType");    when(solrDocument.getFieldValue("field1")).thenReturn("value1");    when(solrDocument.getFieldValue("field2")).thenReturn("value2");    when(solrDocument.getFieldNames()).thenReturn(Arrays.asList("field1", "field2"));    SearchResult expectedSearchResult = new SearchResult();    expectedSearchResult.setId("guid");    expectedSearchResult.setIndex("sensorType");    expectedSearchResult.setSource(new HashMap<String, Object>() {        {            put("field1", "value1");        }    });    assertEquals(expectedSearchResult, SolrUtilities.getSearchResult(solrDocument, Collections.singletonList("field1"), solrSearchDao.getAccessConfig().getIndexSupplier()));    SearchResult expectedSearchResultAllFields = new SearchResult();    expectedSearchResultAllFields.setId("guid");    expectedSearchResultAllFields.setIndex("sensorType");    expectedSearchResultAllFields.setSource(new HashMap<String, Object>() {        {            put("field1", "value1");            put("field2", "value2");        }    });    assertEquals(expectedSearchResultAllFields, SolrUtilities.getSearchResult(solrDocument, null, solrSearchDao.getAccessConfig().getIndexSupplier()));}
public void metron_f7449_0()
{    QueryResponse queryResponse = mock(QueryResponse.class);    FacetField facetField1 = new FacetField("field1");    facetField1.add("value1", 1);    facetField1.add("value2", 2);    FacetField facetField2 = new FacetField("field2");    facetField2.add("value3", 3);    facetField2.add("value4", 4);    when(queryResponse.getFacetField("field1")).thenReturn(facetField1);    when(queryResponse.getFacetField("field2")).thenReturn(facetField2);    Map<String, Map<String, Long>> expectedFacetCounts = new HashMap<String, Map<String, Long>>() {        {            put("field1", new HashMap<String, Long>() {                {                    put("value1", 1L);                    put("value2", 2L);                }            });            put("field2", new HashMap<String, Long>() {                {                    put("value3", 3L);                    put("value4", 4L);                }            });        }    };    assertEquals(expectedFacetCounts, solrSearchDao.getFacetCounts(Arrays.asList("field1", "field2"), queryResponse));}
public void metron_f7450_0()
{    GroupRequest groupRequest = mock(GroupRequest.class);    QueryResponse queryResponse = mock(QueryResponse.class);    NamedList namedList = mock(NamedList.class);    List pivotFields = mock(List.class);    List groupResults = mock(List.class);    solrSearchDao = spy(new SolrSearchDao(client, accessConfig));    Group group1 = new Group();    group1.setField("field1");    Group group2 = new Group();    group2.setField("field2");    when(groupRequest.getGroups()).thenReturn(Arrays.asList(group1, group2));    when(queryResponse.getFacetPivot()).thenReturn(namedList);    when(namedList.get("field1,field2")).thenReturn(pivotFields);    doReturn(groupResults).when(solrSearchDao).getGroupResults(groupRequest, 0, pivotFields);    GroupResponse groupResponse = solrSearchDao.buildGroupResponse(groupRequest, queryResponse);    assertEquals("field1", groupResponse.getGroupedBy());    verify(namedList).get("field1,field2");    verify(solrSearchDao).getGroupResults(groupRequest, 0, pivotFields);}
public void metron_f7451_0()
{    GroupRequest groupRequest = new GroupRequest();    Group group1 = new Group();    group1.setField("field1");    GroupOrder groupOrder1 = new GroupOrder();    groupOrder1.setSortOrder("ASC");    groupOrder1.setGroupOrderType("TERM");    group1.setOrder(groupOrder1);    Group group2 = new Group();    group2.setField("field2");    GroupOrder groupOrder2 = new GroupOrder();    groupOrder2.setSortOrder("DESC");    groupOrder2.setGroupOrderType("COUNT");    group2.setOrder(groupOrder2);    groupRequest.setGroups(Arrays.asList(group1, group2));    groupRequest.setScoreField("score");    PivotField level1Pivot1 = mock(PivotField.class);    PivotField level1Pivot2 = mock(PivotField.class);    PivotField level2Pivot1 = mock(PivotField.class);    PivotField level2Pivot2 = mock(PivotField.class);    FieldStatsInfo level1Pivot1FieldStatsInfo = mock(FieldStatsInfo.class);    FieldStatsInfo level1Pivot2FieldStatsInfo = mock(FieldStatsInfo.class);    FieldStatsInfo level2Pivot1FieldStatsInfo = mock(FieldStatsInfo.class);    FieldStatsInfo level2Pivot2FieldStatsInfo = mock(FieldStatsInfo.class);    List<PivotField> level1Pivots = Arrays.asList(level1Pivot1, level1Pivot2);    List<PivotField> level2Pivots = Arrays.asList(level2Pivot1, level2Pivot2);    when(level1Pivot1.getValue()).thenReturn("field1value1");    when(level1Pivot1.getCount()).thenReturn(1);    when(level1Pivot1FieldStatsInfo.getSum()).thenReturn(1.0);    when(level1Pivot1.getFieldStatsInfo()).thenReturn(new HashMap<String, FieldStatsInfo>() {        {            put("score", level1Pivot1FieldStatsInfo);        }    });    when(level1Pivot2.getValue()).thenReturn("field1value2");    when(level1Pivot2.getCount()).thenReturn(2);    when(level1Pivot2FieldStatsInfo.getSum()).thenReturn(2.0);    when(level1Pivot2.getFieldStatsInfo()).thenReturn(new HashMap<String, FieldStatsInfo>() {        {            put("score", level1Pivot2FieldStatsInfo);        }    });    when(level2Pivot1.getValue()).thenReturn("field2value1");    when(level2Pivot1.getCount()).thenReturn(3);    when(level2Pivot1FieldStatsInfo.getSum()).thenReturn(3.0);    when(level2Pivot1.getFieldStatsInfo()).thenReturn(new HashMap<String, FieldStatsInfo>() {        {            put("score", level2Pivot1FieldStatsInfo);        }    });    when(level2Pivot2.getValue()).thenReturn("field2value2");    when(level2Pivot2.getCount()).thenReturn(4);    when(level2Pivot2FieldStatsInfo.getSum()).thenReturn(4.0);    when(level2Pivot2.getFieldStatsInfo()).thenReturn(new HashMap<String, FieldStatsInfo>() {        {            put("score", level2Pivot2FieldStatsInfo);        }    });    when(level1Pivot1.getPivot()).thenReturn(level2Pivots);    List<GroupResult> level1GroupResults = solrSearchDao.getGroupResults(groupRequest, 0, level1Pivots);    assertEquals("field1value1", level1GroupResults.get(0).getKey());    assertEquals(1, level1GroupResults.get(0).getTotal());    assertEquals(1.0, level1GroupResults.get(0).getScore(), 0.00001);    assertEquals("field2", level1GroupResults.get(0).getGroupedBy());    assertEquals("field1value2", level1GroupResults.get(1).getKey());    assertEquals(2, level1GroupResults.get(1).getTotal());    assertEquals(2.0, level1GroupResults.get(1).getScore(), 0.00001);    assertEquals("field2", level1GroupResults.get(1).getGroupedBy());    assertEquals(0, level1GroupResults.get(1).getGroupResults().size());    List<GroupResult> level2GroupResults = level1GroupResults.get(0).getGroupResults();    assertEquals("field2value2", level2GroupResults.get(0).getKey());    assertEquals(4, level2GroupResults.get(0).getTotal());    assertEquals(4.0, level2GroupResults.get(0).getScore(), 0.00001);    assertNull(level2GroupResults.get(0).getGroupedBy());    assertNull(level2GroupResults.get(0).getGroupResults());    assertEquals("field2value1", level2GroupResults.get(1).getKey());    assertEquals(3, level2GroupResults.get(1).getTotal());    assertEquals(3.0, level2GroupResults.get(1).getScore(), 0.00001);    assertNull(level2GroupResults.get(1).getGroupedBy());    assertNull(level2GroupResults.get(1).getGroupResults());}
private SolrDocument metron_f7452_0(String sensorType, Long timestamp)
{    SolrDocument solrDocument = new SolrDocument();    solrDocument.addField(SolrDao.VERSION_FIELD, 1.0);    solrDocument.addField(Constants.GUID, UUID.randomUUID().toString());    solrDocument.addField(Constants.SENSOR_TYPE, sensorType);    solrDocument.addField(Constants.Fields.TIMESTAMP.getName(), timestamp);    solrDocument.addField(Constants.Fields.SRC_ADDR.getName(), "192.168.1.1");    return solrDocument;}
public static void metron_f7453_0()
{    accessConfig.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(SOLR_ZOOKEEPER, "zookeeper:2181");        }    });    IndexingConfigurations indexingConfigs = mock(IndexingConfigurations.class);    ConfigurationsCache cache = mock(ConfigurationsCache.class);    Map<String, Object> broIndexingConfig = new HashMap<String, Object>() {        {            put("solr", new HashMap<String, Object>() {                {                }            });        }    };    when(indexingConfigs.getSensorIndexingConfig("bro")).thenReturn(broIndexingConfig);    when(cache.get(IndexingConfigurations.class)).thenReturn(indexingConfigs);    accessConfig.setIndexSupplier(IndexingCacheUtil.getIndexLookupFunction(cache, "solr"));}
public void metron_f7454_0() throws Exception
{    client = mock(SolrClient.class);    solrRetrieveLatestDao = new SolrRetrieveLatestDao(client, accessConfig);    solrUpdateDao = new SolrUpdateDao(client, solrRetrieveLatestDao, accessConfig);}
public void metron_f7455_0() throws Exception
{    Document document = new Document(new HashMap<String, Object>() {        {            put("field", "value");        }    }, "guid", "bro", 0L);    SolrInputDocument solrInputDocument = new SolrInputDocument();    solrInputDocument.addField("field", "value");    solrUpdateDao.update(document, Optional.empty());    verify(client).add(eq("bro"), argThat(new SolrInputDocumentMatcher(solrInputDocument)));}
public void metron_f7456_0() throws Exception
{    Document document = new Document(new HashMap<String, Object>() {        {            put("field", "value");        }    }, "guid", "bro", 0L);    SolrInputDocument solrInputDocument = new SolrInputDocument();    solrInputDocument.addField("field", "value");    solrUpdateDao.update(document, Optional.of("bro"));    verify(client).add(eq("bro"), argThat(new SolrInputDocumentMatcher(solrInputDocument)));}
public void metron_f7457_0() throws Exception
{    Document broDocument1 = new Document(new HashMap<String, Object>() {        {            put("broField1", "value");            put("guid", "broGuid1");        }    }, "broGuid1", "bro", 0L);    Document broDocument2 = new Document(new HashMap<String, Object>() {        {            put("broField2", "value");            put("guid", "broGuid2");        }    }, "broGuid2", "bro", 0L);    Map<Document, Optional<String>> updates = new HashMap<Document, Optional<String>>() {        {            put(broDocument1, Optional.of("bro"));            put(broDocument2, Optional.of("bro"));        }    };    SolrInputDocument broSolrInputDocument1 = new SolrInputDocument();    broSolrInputDocument1.addField("broField1", "value");    broSolrInputDocument1.addField("guid", "broGuid1");    SolrInputDocument broSolrInputDocument2 = new SolrInputDocument();    broSolrInputDocument2.addField("broField2", "value");    broSolrInputDocument2.addField("guid", "broGuid2");    solrUpdateDao.batchUpdate(updates);    verify(client).add(eq("bro"), argThat(new SolrInputDocumentListMatcher(Arrays.asList(broSolrInputDocument1, broSolrInputDocument2))));}
public void metron_f7458_0() throws Exception
{    Document snortDocument1 = new Document(new HashMap<String, Object>() {        {            put("snortField1", "value");            put("guid", "snortGuid1");        }    }, "snortGuid1", "snort", 0L);    Document snortDocument2 = new Document(new HashMap<String, Object>() {        {            put("snortField2", "value");            put("guid", "snortGuid2");        }    }, "snortGuid2", "snort", 0L);    Map<Document, Optional<String>> updates = new HashMap<Document, Optional<String>>() {        {            put(snortDocument1, Optional.empty());            put(snortDocument2, Optional.empty());        }    };    SolrInputDocument snortSolrInputDocument1 = new SolrInputDocument();    snortSolrInputDocument1.addField("snortField1", "value");    snortSolrInputDocument1.addField("guid", "snortGuid1");    SolrInputDocument snortSolrInputDocument2 = new SolrInputDocument();    snortSolrInputDocument2.addField("snortField2", "value");    snortSolrInputDocument2.addField("guid", "snortGuid2");    solrUpdateDao.batchUpdate(updates);    verify(client).add(eq("snort"), argThat(new SolrInputDocumentListMatcher(Arrays.asList(snortSolrInputDocument1, snortSolrInputDocument2))));}
public void metron_f7459_0()
{    List<Map<String, Object>> commentList = new ArrayList<>();    Map<String, Object> comments = new HashMap<>();    comments.put("comment", "test comment");    comments.put("username", "test username");    comments.put("timestamp", 1526424323279L);    commentList.add(comments);    Map<String, Object> document = new HashMap<>();    document.put("testField", "testValue");    document.put(COMMENTS_FIELD, commentList);    solrUpdateDao.convertCommentsToRaw(document);    @SuppressWarnings("unchecked")    List<String> actualComments = (List<String>) document.get(COMMENTS_FIELD);    String expectedComment = "{\"comment\":\"test comment\",\"username\":\"test username\",\"timestamp\":1526424323279}";    assertEquals(expectedComment, actualComments.get(0));    assertEquals(1, actualComments.size());    assertEquals("testValue", document.get("testField"));}
public void metron_f7460_0() throws IOException, OriginalNotFoundException
{        Map<String, Object> latestDoc = new HashMap<>();    latestDoc.put(Constants.GUID, "guid");    List<Map<String, Object>> comments = new ArrayList<>();    comments.add(new AlertComment("comment", "user", 0L).asMap());    comments.add(new AlertComment("comment_2", "user_2", 0L).asMap());    latestDoc.put(COMMENTS_FIELD, comments);    Document latest = new Document(latestDoc, "guid", "bro", 0L);    SolrRetrieveLatestDao retrieveLatestDao = spy(new SolrRetrieveLatestDao(null, accessConfig));    doReturn(latest).when(retrieveLatestDao).getLatest("guid", "bro");        PatchRequest request = new PatchRequest();    request.setIndex("bro");    request.setSensorType("bro");    request.setGuid("guid");    List<Map<String, Object>> patchList = new ArrayList<>();    Map<String, Object> patch = new HashMap<>();    patch.put("op", "add");    patch.put("path", "/project");    patch.put("value", "metron");    patchList.add(patch);    request.setPatch(patchList);    Document actual = solrUpdateDao.getPatchedDocument(retrieveLatestDao, request, Optional.of(0L));        latest.getDocument().put("project", "metron");    assertEquals(actual, latest);}
public UpdateDao metron_f7461_0()
{    return solrUpdateDao;}
public void metron_f7462_0() throws Exception
{    long expectedTimestamp = System.currentTimeMillis();    SolrDocument solrDocument = new SolrDocument();    solrDocument.addField(SolrDao.VERSION_FIELD, 1.0);    solrDocument.addField(Constants.GUID, "guid");    solrDocument.addField(Constants.SENSOR_TYPE, "bro");    solrDocument.addField(Constants.Fields.TIMESTAMP.getName(), expectedTimestamp);    solrDocument.addField("field", "value");    Document expectedDocument = new Document(new HashMap<String, Object>() {        {            put("field", "value");            put(Constants.GUID, "guid");            put(Constants.SENSOR_TYPE, "bro");            put(Constants.Fields.TIMESTAMP.getName(), expectedTimestamp);        }    }, "guid", "bro", expectedTimestamp);    Document actualDocument = SolrUtilities.toDocument(solrDocument);    assertEquals(expectedDocument, actualDocument);}
public Builder metron_f7463_0(int port)
{    this.port = port;    return this;}
public Builder metron_f7464_0(String solrXmlPath)
{    this.solrXmlPath = solrXmlPath;    return this;}
public Builder metron_f7465_0(String name, String configPath)
{    initialCollections.put(name, configPath);    return this;}
public Builder metron_f7466_0(Function<SolrComponent, Void> f)
{    postStartCallback = f;    return this;}
public SolrComponent metron_f7467_0()
{    return new SolrComponent(port, solrXmlPath, initialCollections, postStartCallback);}
public void metron_f7468_0() throws UnableToStartException
{    try {        File baseDir = Files.createTempDirectory("solrcomponent").toFile();        baseDir.deleteOnExit();        miniSolrCloudCluster = new MiniSolrCloudCluster(1, baseDir.toPath(), JettyConfig.builder().setPort(port).build());        for (String name : collections.keySet()) {            String configPath = collections.get(name);            miniSolrCloudCluster.uploadConfigSet(new File(configPath).toPath(), name);            CollectionAdminRequest.createCollection(name, 1, 1).process(miniSolrCloudCluster.getSolrClient());        }        if (postStartCallback != null) {            postStartCallback.apply(this);        }    } catch (Exception e) {        throw new UnableToStartException(e.getMessage(), e);    }}
public void metron_f7469_0()
{    try {        miniSolrCloudCluster.deleteAllCollections();        miniSolrCloudCluster.shutdown();    } catch (Exception e) {        }}
public void metron_f7470_0()
{    try {        miniSolrCloudCluster.deleteAllCollections();    } catch (Exception e) {        }}
public MetronSolrClient metron_f7471_0()
{    return new MetronSolrClient(getZookeeperUrl());}
public MiniSolrCloudCluster metron_f7472_0()
{    return this.miniSolrCloudCluster;}
public String metron_f7473_0()
{    return miniSolrCloudCluster.getZkServer().getZkAddress();}
public void metron_f7474_0(String name, String configPath) throws InterruptedException, IOException, KeeperException, SolrServerException
{    miniSolrCloudCluster.uploadConfigSet(new File(configPath).toPath(), name);    CollectionAdminRequest.createCollection(name, 1, 1).process(miniSolrCloudCluster.getSolrClient());}
public boolean metron_f7475_0(String collection)
{    MetronSolrClient solr = getSolrClient();    boolean collectionFound = false;    try {        collectionFound = solr.listCollections().contains(collection);    } catch (Exception e) {        e.printStackTrace();    }    return collectionFound;}
public List<Map<String, Object>> metron_f7476_0(String collection)
{    List<Map<String, Object>> docs = new ArrayList<>();    CloudSolrClient solr = miniSolrCloudCluster.getSolrClient();    solr.setDefaultCollection(collection);    SolrQuery parameters = new SolrQuery();        if (collection.equals("metaalert")) {        parameters.setQuery("source.type:metaalert").setFields("*", "[child parentFilter=source.type:metaalert limit=999]");    } else {        parameters.set("q", "*:*");    }    try {        solr.commit();        QueryResponse response = solr.query(parameters);        for (SolrDocument solrDocument : response.getResults()) {                        docs.add(SolrUtilities.toDocument(solrDocument).getDocument());        }    } catch (SolrServerException | IOException e) {        e.printStackTrace();    }    return docs;}
public void metron_f7477_0(String collection, List<Map<String, Object>> docs) throws IOException, SolrServerException
{    CloudSolrClient solr = miniSolrCloudCluster.getSolrClient();    solr.setDefaultCollection(collection);    Collection<SolrInputDocument> solrInputDocuments = docs.stream().map(doc -> {        SolrInputDocument solrInputDocument = new SolrInputDocument();        for (Entry<String, Object> entry : doc.entrySet()) {                        if (entry.getValue() instanceof List && !entry.getKey().equals(MetaAlertConstants.METAALERT_FIELD)) {                for (Object entryItem : (List) entry.getValue()) {                    if (entryItem instanceof Map) {                        @SuppressWarnings("unchecked")                        Map<String, Object> childDoc = (Map<String, Object>) entryItem;                        SolrInputDocument childInputDoc = new SolrInputDocument();                        for (Entry<String, Object> childEntry : childDoc.entrySet()) {                            childInputDoc.addField(childEntry.getKey(), childEntry.getValue());                        }                        solrInputDocument.addChildDocument(childInputDoc);                    }                }            } else {                solrInputDocument.addField(entry.getKey(), entry.getValue());            }        }        return solrInputDocument;    }).collect(Collectors.toList());    checkUpdateResponse(solr.add(collection, solrInputDocuments));        checkUpdateResponse(solr.commit(true, true));}
protected void metron_f7478_0(UpdateResponse result) throws IOException
{    if (result.getStatus() != 0) {        throw new IOException("Response error received while adding documents: " + result);    }}
public static Iterable<String> metron_f7479_0(String sensor) throws IOException
{    return Iterables.filter(Files.readLines(new File("src/test/resources/example_data/" + sensor), Charset.defaultCharset()), s -> !s.startsWith("#") && s.length() > 0);}
public static Map<String, Object> metron_f7480_0(String sensorType, SolrComponent component)
{    Map<String, Object> globalConfig = new HashMap<>();    globalConfig.put(SOLR_ZOOKEEPER, component.getZookeeperUrl());    return globalConfig;}
public static SolrComponent metron_f7481_0(String sensor) throws Exception
{    return new SolrComponent.Builder().build();}
public void metron_f7482_0() throws Exception
{    test("error");}
public void metron_f7483_0() throws Exception
{    test("bro");}
public void metron_f7484_0() throws Exception
{    test("snort");}
public void metron_f7485_0() throws Exception
{    test("yaf");}
public String metron_f7486_0(Map<String, Object> m)
{    if (m.containsKey("guid")) {        return (String) m.get("guid");    } else {        return (String) m.get("original_string");    }}
public void metron_f7487_0(String sensorType) throws Exception
{    SolrComponent component = null;    try {        component = createSolrComponent(sensorType);        component.start();        component.addCollection(String.format("%s", sensorType), String.format("src/main/config/schema/%s", sensorType));        Map<String, Object> globalConfig = getGlobalConfig(sensorType, component);        List<BulkMessage<JSONObject>> messages = new ArrayList<>();        Map<String, Map<String, Object>> index = new HashMap<>();        int i = 0;        for (String message : getData(sensorType)) {            if (message.trim().length() > 0) {                Map<String, Object> m = JSONUtils.INSTANCE.load(message.trim(), JSONUtils.MAP_SUPPLIER);                String guid = getGuid(m);                index.put(guid, m);                messages.add(new BulkMessage<>(String.format("message%d", ++i), new JSONObject(m)));            }        }        Assert.assertTrue(messages.size() > 0);        SolrWriter solrWriter = new SolrWriter();        WriterConfiguration writerConfig = new WriterConfiguration() {            @Override            public int getBatchSize(String sensorName) {                return messages.size();            }            @Override            public int getBatchTimeout(String sensorName) {                return 0;            }            @Override            public List<Integer> getAllConfiguredTimeouts() {                return new ArrayList<>();            }            @Override            public String getIndex(String sensorName) {                return sensorType;            }            @Override            public boolean isEnabled(String sensorName) {                return true;            }            @Override            public Map<String, Object> getSensorConfig(String sensorName) {                return new HashMap<String, Object>() {                    {                        put("index", sensorType);                        put("batchSize", messages.size());                        put("enabled", true);                    }                };            }            @Override            public Map<String, Object> getGlobalConfig() {                return globalConfig;            }            @Override            public boolean isDefault(String sensorName) {                return false;            }            @Override            public String getFieldNameConverter(String sensorName) {                return null;            }        };        solrWriter.init(null, writerConfig);        BulkWriterResponse response = solrWriter.write(sensorType, writerConfig, messages);        Assert.assertTrue(response.getErrors().isEmpty());        for (Map<String, Object> m : component.getAllIndexedDocs(sensorType)) {            Map<String, Object> expected = index.get(getGuid(m));            for (Map.Entry<String, Object> field : expected.entrySet()) {                if (field.getValue() instanceof Collection && ((Collection) field.getValue()).size() == 0) {                    continue;                }                if (m.get(field.getKey()) instanceof Number) {                    Number n1 = ConversionUtils.convert(field.getValue(), Double.class);                    Number n2 = (Number) m.get(field.getKey());                    boolean isSame = Math.abs(n1.doubleValue() - n2.doubleValue()) < 1e-3;                    if (!isSame) {                        String s1 = "" + n1.doubleValue();                        String s2 = "" + n2.doubleValue();                        isSame = s1.startsWith(s2) || s2.startsWith(s1);                    }                    Assert.assertTrue("Unable to validate " + field.getKey() + ": " + n1 + " != " + n2, isSame);                } else {                    Assert.assertEquals("Unable to find " + field.getKey(), "" + field.getValue(), "" + m.get(field.getKey()));                }            }        }    } finally {        if (component != null) {            component.stop();        }    }}
public int metron_f7488_0(String sensorName)
{    return messages.size();}
public int metron_f7489_0(String sensorName)
{    return 0;}
public List<Integer> metron_f7490_0()
{    return new ArrayList<>();}
public String metron_f7491_0(String sensorName)
{    return sensorType;}
public boolean metron_f7492_0(String sensorName)
{    return true;}
public Map<String, Object> metron_f7493_0(String sensorName)
{    return new HashMap<String, Object>() {        {            put("index", sensorType);            put("batchSize", messages.size());            put("enabled", true);        }    };}
public Map<String, Object> metron_f7494_0()
{    return globalConfig;}
public boolean metron_f7495_0(String sensorName)
{    return false;}
public String metron_f7496_0(String sensorName)
{    return null;}
public static void metron_f7497_0() throws Exception
{        MAX_RETRIES = 1;        solr = new SolrComponent.Builder().build();    solr.start();    AccessConfig accessConfig = new AccessConfig();    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put("solr.clustername", "metron");            put("solr.port", "9300");            put("solr.ip", "localhost");            put("solr.date.format", DATE_FORMAT);            put(SOLR_ZOOKEEPER, solr.getZookeeperUrl());        }    };    accessConfig.setMaxSearchResults(1000);    accessConfig.setGlobalConfigSupplier(() -> globalConfig);    accessConfig.setMaxSearchGroups(100);        accessConfig.setIndexSupplier(s -> s);    solrDao = new SolrDao();    solrDao.init(accessConfig);    MetaAlertConfig config = new MetaAlertConfig(METAALERTS_COLLECTION, THREAT_SORT_DEFAULT, () -> ImmutableMap.of(Constants.SENSOR_TYPE_FIELD_PROPERTY, Constants.SENSOR_TYPE, Constants.THREAT_SCORE_FIELD_PROPERTY, THREAT_FIELD_DEFAULT)) {        @Override        protected String getDefaultThreatTriageField() {            return THREAT_FIELD_DEFAULT.replace(':', '.');        }        @Override        protected String getDefaultSourceTypeField() {            return Constants.SENSOR_TYPE;        }    };    SolrClient solrClient = SolrClientFactory.create(globalConfig);    SolrMetaAlertSearchDao searchDao = new SolrMetaAlertSearchDao(solrClient, solrDao.getSolrSearchDao(), config);    SolrMetaAlertRetrieveLatestDao retrieveLatestDao = new SolrMetaAlertRetrieveLatestDao(solrClient, solrDao);    SolrMetaAlertUpdateDao updateDao = new SolrMetaAlertUpdateDao(solrClient, solrDao, searchDao, retrieveLatestDao, config);    metaDao = new SolrMetaAlertDao(solrDao, searchDao, updateDao, retrieveLatestDao);}
protected String metron_f7498_0()
{    return THREAT_FIELD_DEFAULT.replace(':', '.');}
protected String metron_f7499_0()
{    return Constants.SENSOR_TYPE;}
public void metron_f7500_0() throws IOException, InterruptedException, SolrServerException, KeeperException
{    solr.addCollection(METAALERTS_COLLECTION, "./src/main/config/schema//metaalert");    solr.addCollection(SENSOR_NAME, "./src/test/resources/config/test/conf");}
public static void metron_f7501_0()
{    SolrClientFactory.close();    if (solr != null) {        solr.stop();    }}
public void metron_f7502_0()
{    solr.reset();}
public void metron_f7503_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(4);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(0).put("ip_src_addr", "192.168.1.1");    alerts.get(0).put("ip_src_port", 8010);    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put("ip_src_addr", "192.168.1.2");    alerts.get(1).put("ip_src_port", 8009);    alerts.get(2).put("ip_src_addr", "192.168.1.3");    alerts.get(2).put("ip_src_port", 8008);    alerts.get(3).put("ip_src_addr", "192.168.1.4");    alerts.get(3).put("ip_src_port", 8007);    addRecords(alerts, getTestIndexName(), SENSOR_NAME);        setupTypings();        Map<String, Object> activeMetaAlert = buildMetaAlert("meta_active", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));    Map<String, Object> inactiveMetaAlert = buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.of(Arrays.asList(alerts.get(2), alerts.get(3))));        addRecords(Arrays.asList(activeMetaAlert, inactiveMetaAlert), METAALERTS_COLLECTION, METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME), new GetRequest("meta_active", METAALERT_TYPE), new GetRequest("meta_inactive", METAALERT_TYPE)));    SearchResponse searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("ip_src_addr:192.168.1.1 AND ip_src_port:8010");            setIndices(Collections.singletonList(METAALERT_TYPE));            setFrom(0);            setSize(5);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());        List<Map<String, Object>> actualAlerts = (List<Map<String, Object>>) searchResponse.getResults().get(0).getSource().get(MetaAlertConstants.ALERT_FIELD);    Assert.assertEquals(2, actualAlerts.size());    Assert.assertEquals("meta_active", searchResponse.getResults().get(0).getSource().get("guid"));            searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("ip_src_addr:192.168.1.1 AND ip_src_port:8010");            setIndices(queryIndices);            setFrom(0);            setSize(5);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());        actualAlerts = (List<Map<String, Object>>) searchResponse.getResults().get(0).getSource().get(MetaAlertConstants.ALERT_FIELD);    Assert.assertEquals(2, actualAlerts.size());    Assert.assertEquals("meta_active", searchResponse.getResults().get(0).getSource().get("guid"));            searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("ip_src_addr:192.168.1.3 AND ip_src_port:8008");            setIndices(queryIndices);            setFrom(0);            setSize(1);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());        actualAlerts = (List<Map<String, Object>>) searchResponse.getResults().get(0).getSource().get(MetaAlertConstants.ALERT_FIELD);    Assert.assertNull(actualAlerts);    Assert.assertEquals("message_2", searchResponse.getResults().get(0).getSource().get("guid"));}
public void metron_f7504_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(1);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(0).put("ip_src_addr", "192.168.1.1");    alerts.get(0).put("ip_src_port", 8010);    addRecords(alerts, getTestIndexName(), SENSOR_NAME);        setupTypings();        Map<String, Object> activeMetaAlert = buildMetaAlert("meta_active", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0))));        addRecords(Collections.singletonList(activeMetaAlert), METAALERTS_COLLECTION, METAALERT_TYPE);        findCreatedDocs(Collections.singletonList(new GetRequest("meta_active", METAALERT_TYPE)));    SearchResponse searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("ip_src_addr:192.168.1.1 AND ip_src_port:8010");            setIndices(Collections.singletonList(METAALERT_TYPE));            setFrom(0);            setSize(5);            setFields(Collections.singletonList(Constants.GUID));            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());        List<Map<String, Object>> actualAlerts = (List<Map<String, Object>>) searchResponse.getResults().get(0).getSource().get(MetaAlertConstants.ALERT_FIELD);    Assert.assertNull(actualAlerts);    Assert.assertEquals("meta_active", searchResponse.getResults().get(0).getSource().get("guid"));}
protected long metron_f7505_0(String fieldName, Object fieldValue) throws InterruptedException
{    long cnt = 0;    for (int t = 0; t < MAX_RETRIES && cnt == 0; ++t, Thread.sleep(SLEEP_MS)) {        List<Map<String, Object>> docs = solr.getAllIndexedDocs(getTestIndexName());        cnt = docs.stream().filter(d -> {            Object newfield = d.get(fieldName);            return newfield != null && newfield.equals(fieldValue);        }).count();    }    return cnt;}
protected long metron_f7506_0(String fieldName, String fieldValue) throws InterruptedException
{    long cnt = 0;    for (int t = 0; t < MAX_RETRIES && cnt == 0; ++t, Thread.sleep(SLEEP_MS)) {        List<Map<String, Object>> docs = solr.getAllIndexedDocs(METAALERTS_COLLECTION);        cnt = docs.stream().filter(d -> {            @SuppressWarnings("unchecked")            List<Map<String, Object>> alerts = (List<Map<String, Object>>) d.get(ALERT_FIELD);            for (Map<String, Object> alert : alerts) {                Object newField = alert.get(fieldName);                if (newField != null && newField.equals(fieldValue)) {                    return true;                }            }            return false;        }).count();    }    return cnt;}
protected void metron_f7507_0(List<Map<String, Object>> inputData, String index, String docType) throws IOException
{        try {        solr.addDocs(index, inputData);    } catch (SolrServerException e) {        throw new IOException("Unable to load Solr Docs", e);    }}
protected void metron_f7508_0()
{}
protected String metron_f7509_0()
{    return COLLECTION;}
protected String metron_f7510_0()
{    return METAALERTS_COLLECTION;}
protected String metron_f7511_0()
{    return Constants.SENSOR_TYPE;}
protected void metron_f7512_0() throws IOException
{    try {        List<String> collections = solr.getSolrClient().listCollections();        for (String collection : collections) {            solr.getSolrClient().commit(collection);        }    } catch (SolrServerException e) {        throw new IOException("Unable to commit", e);    }}
protected void metron_f7513_0(Map<String, Object> docMap)
{    docMap.remove(METAALERT_FIELD);}
protected boolean metron_f7514_0()
{    return false;}
protected boolean metron_f7515_0()
{    return false;}
public static void metron_f7516_0() throws Exception
{    solrComponent = new SolrComponent.Builder().build();    solrComponent.start();}
public void metron_f7517_0() throws Exception
{    solrComponent.addCollection(TEST_COLLECTION, "./src/test/resources/config/test/conf");    solrComponent.addCollection(BRO_SENSOR, "./src/main/config/schema/bro");    AccessConfig accessConfig = new AccessConfig();    Map<String, Object> globalConfig = new HashMap<>();    globalConfig.put(SOLR_ZOOKEEPER, solrComponent.getZookeeperUrl());    accessConfig.setGlobalConfigSupplier(() -> globalConfig);        accessConfig.setIndexSupplier(s -> s.equals(TEST_SENSOR) ? TEST_COLLECTION : s);    dao = new SolrDao();    dao.init(accessConfig);    addData(BRO_SENSOR, BRO_SENSOR, expectedTimestamp);    addData(TEST_COLLECTION, TEST_SENSOR, expectedTimestamp);}
public void metron_f7518_0()
{    solrComponent.reset();}
public static void metron_f7519_0()
{    SolrClientFactory.close();    solrComponent.stop();}
public void metron_f7520_0() throws IOException
{    Document actual = dao.getLatest("message_1_bro", BRO_SENSOR);    assertEquals(buildExpectedDocument(BRO_SENSOR, 1), actual);}
public void metron_f7521_0() throws IOException
{    Document actual = dao.getLatest("message_1_bro", TEST_SENSOR);    assertNull(actual);}
public void metron_f7522_0() throws IOException
{    AccessConfig accessConfig = new AccessConfig();    Map<String, Object> globalConfig = new HashMap<>();    globalConfig.put(SOLR_ZOOKEEPER, solrComponent.getZookeeperUrl());    accessConfig.setGlobalConfigSupplier(() -> globalConfig);        accessConfig.setIndexSupplier(s -> null);    dao = new SolrDao();    dao.init(accessConfig);    Document actual = dao.getLatest("message_1_bro", TEST_SENSOR);    assertNull(actual);}
public void metron_f7523_0() throws IOException
{    Document actual = dao.getLatest("message_1_test_sensor", TEST_SENSOR);    assertEquals(buildExpectedDocument(TEST_SENSOR, 1), actual);}
public void metron_f7524_0() throws IOException
{    List<GetRequest> requests = new ArrayList<>();    requests.add(buildGetRequest(BRO_SENSOR, 1));    requests.add(buildGetRequest(BRO_SENSOR, 2));    Iterable<Document> actual = dao.getAllLatest(requests);    Document expected1 = buildExpectedDocument(BRO_SENSOR, 1);    assertTrue(Iterables.contains(actual, expected1));    Document expected2 = buildExpectedDocument(BRO_SENSOR, 2);    assertTrue(Iterables.contains(actual, expected2));    assertEquals(2, Iterables.size(actual));}
public void metron_f7525_0() throws IOException
{    List<GetRequest> requests = new ArrayList<>();    GetRequest getRequestOne = buildGetRequest(TEST_SENSOR, 1);            getRequestOne.setIndex(BRO_SENSOR);    requests.add(getRequestOne);    Iterable<Document> actual = dao.getAllLatest(requests);        assertEquals(0, Iterables.size(actual));}
public void metron_f7526_0() throws IOException
{    List<GetRequest> requests = new ArrayList<>();    requests.add(buildGetRequest(TEST_SENSOR, 1));    requests.add(buildGetRequest(BRO_SENSOR, 2));    Iterable<Document> actual = dao.getAllLatest(requests);    assertTrue(Iterables.contains(actual, buildExpectedDocument(TEST_SENSOR, 1)));    assertTrue(Iterables.contains(actual, buildExpectedDocument(BRO_SENSOR, 2)));    assertEquals(2, Iterables.size(actual));}
public void metron_f7527_0() throws IOException
{    List<GetRequest> requests = new ArrayList<>();    requests.add(buildGetRequest(TEST_SENSOR, 1));    GetRequest brokenRequest = new GetRequest();    brokenRequest.setGuid(buildGuid(BRO_SENSOR, 2));    brokenRequest.setSensorType(TEST_SENSOR);    requests.add(brokenRequest);    Iterable<Document> actual = dao.getAllLatest(requests);    assertTrue(Iterables.contains(actual, buildExpectedDocument(TEST_SENSOR, 1)));    assertEquals(1, Iterables.size(actual));}
protected Document metron_f7528_0(String sensor, int i)
{    Map<String, Object> expectedMapOne = new HashMap<>();    expectedMapOne.put("source.type", sensor);    expectedMapOne.put(Constants.Fields.TIMESTAMP.getName(), expectedTimestamp);    expectedMapOne.put(Constants.GUID, buildGuid(sensor, i));    return new Document(expectedMapOne, buildGuid(sensor, i), sensor, expectedTimestamp);}
protected GetRequest metron_f7529_0(String sensor, int i)
{    GetRequest requestOne = new GetRequest();    requestOne.setGuid(buildGuid(sensor, i));    requestOne.setSensorType(sensor);    return requestOne;}
protected static void metron_f7530_0(String collection, String sensorName, Long timestamp) throws IOException, SolrServerException
{    List<Map<String, Object>> inputData = new ArrayList<>();    for (int i = 0; i < 3; ++i) {        final String name = buildGuid(sensorName, i);        HashMap<String, Object> inputMap = new HashMap<>();        inputMap.put("source.type", sensorName);        inputMap.put(Constants.GUID, name);        inputMap.put(Constants.Fields.TIMESTAMP.getName(), timestamp);        inputData.add(inputMap);    }    solrComponent.addDocs(collection, inputData);}
protected static String metron_f7531_0(String sensorName, int i)
{    return "message_" + i + "_" + sensorName;}
public static void metron_f7532_0() throws Exception
{    indexComponent = startIndex();    dao = createDao();        broData = SearchIntegrationTest.broData.replace("source:type", "source.type");    snortData = SearchIntegrationTest.snortData.replace("source:type", "source.type");    solrComponent.addCollection("bro", "./src/main/config/schema/bro");    solrComponent.addCollection("snort", "./src/main/config/schema/snort");    loadTestData();}
public static void metron_f7533_0()
{    SolrClientFactory.close();    if (solrComponent != null) {        solrComponent.stop();    }}
public IndexDao metron_f7534_0()
{    return dao;}
protected static IndexDao metron_f7535_0()
{    AccessConfig config = new AccessConfig();    config.setMaxSearchResults(100);    config.setMaxSearchGroups(100);    config.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(SOLR_ZOOKEEPER, solrComponent.getZookeeperUrl());        }    });    config.setIndexSupplier(sensorType -> sensorType);    IndexDao dao = new SolrDao();    dao.init(config);    return dao;}
protected static InMemoryComponent metron_f7536_0() throws Exception
{    solrComponent = new SolrComponent.Builder().build();    solrComponent.start();    return solrComponent;}
protected static void metron_f7537_0() throws ParseException, IOException, SolrServerException
{    JSONArray broArray = (JSONArray) new JSONParser().parse(broData);    solrComponent.addDocs("bro", broArray);    JSONArray snortArray = (JSONArray) new JSONParser().parse(snortData);    solrComponent.addDocs("snort", snortArray);}
public void metron_f7538_0() throws Exception
{        {        Map<String, FieldType> fieldTypes = dao.getColumnMetadata(Collections.singletonList("bro"));                Assert.assertEquals(263, fieldTypes.size());                Assert.assertEquals(FieldType.TEXT, fieldTypes.get("guid"));        Assert.assertEquals(FieldType.TEXT, fieldTypes.get("source.type"));        Assert.assertEquals(FieldType.IP, fieldTypes.get("ip_src_addr"));        Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ip_src_port"));        Assert.assertEquals(FieldType.BOOLEAN, fieldTypes.get("is_alert"));                Assert.assertEquals(FieldType.TEXT, fieldTypes.get("username"));                Assert.assertEquals(FieldType.FLOAT, fieldTypes.get("score"));                Assert.assertEquals(FieldType.OTHER, fieldTypes.get("location_point"));                Assert.assertEquals(FieldType.OTHER, fieldTypes.get("timestamp"));                Assert.assertEquals(FieldType.TEXT, fieldTypes.get("method"));                Assert.assertEquals(FieldType.TEXT, fieldTypes.get("ttl"));                Assert.assertEquals(null, fieldTypes.get("dgmlen"));                Assert.assertEquals(null, fieldTypes.get("fake.field"));    }        {        Map<String, FieldType> fieldTypes = dao.getColumnMetadata(Collections.singletonList("snort"));        Assert.assertEquals(33, fieldTypes.size());                Assert.assertEquals(FieldType.TEXT, fieldTypes.get("guid"));        Assert.assertEquals(FieldType.TEXT, fieldTypes.get("source.type"));        Assert.assertEquals(FieldType.IP, fieldTypes.get("ip_src_addr"));        Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ip_src_port"));        Assert.assertEquals(FieldType.BOOLEAN, fieldTypes.get("is_alert"));                Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("dgmlen"));                Assert.assertEquals(FieldType.FLOAT, fieldTypes.get("score"));                Assert.assertEquals(FieldType.OTHER, fieldTypes.get("location_point"));                Assert.assertEquals(FieldType.OTHER, fieldTypes.get("timestamp"));                Assert.assertEquals(FieldType.TEXT, fieldTypes.get("sig_generator"));                Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ttl"));                Assert.assertEquals(null, fieldTypes.get("username"));                Assert.assertEquals(null, fieldTypes.get("fake.field"));    }}
public void metron_f7539_0() throws Exception
{    Map<String, FieldType> fieldTypes = dao.getColumnMetadata(Arrays.asList("bro", "snort"));            Assert.assertEquals(FieldType.TEXT, fieldTypes.get("guid"));    Assert.assertEquals(FieldType.TEXT, fieldTypes.get("source.type"));    Assert.assertEquals(FieldType.IP, fieldTypes.get("ip_src_addr"));    Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("ip_src_port"));    Assert.assertEquals(FieldType.BOOLEAN, fieldTypes.get("is_alert"));        Assert.assertEquals(FieldType.TEXT, fieldTypes.get("username"));        Assert.assertEquals(FieldType.INTEGER, fieldTypes.get("dgmlen"));        Assert.assertEquals(FieldType.FLOAT, fieldTypes.get("score"));        Assert.assertEquals(FieldType.OTHER, fieldTypes.get("location_point"));        Assert.assertEquals(FieldType.OTHER, fieldTypes.get("timestamp"));        Assert.assertEquals(FieldType.TEXT, fieldTypes.get("method"));        Assert.assertEquals(FieldType.TEXT, fieldTypes.get("sig_generator"));        Assert.assertEquals(FieldType.OTHER, fieldTypes.get("ttl"));        Assert.assertEquals(null, fieldTypes.get("fake.field"));}
public void metron_f7540_0() throws Exception
{    thrown.expect(InvalidSearchException.class);    SearchRequest request = JSONUtils.INSTANCE.load(differentTypeFilterQuery, SearchRequest.class);    SearchResponse response = dao.search(request);}
protected String metron_f7541_0()
{    return Constants.SENSOR_TYPE;}
protected String metron_f7542_0(String sensorType)
{    return sensorType;}
public static void metron_f7543_0() throws Exception
{    solrComponent = new SolrComponent.Builder().build();    solrComponent.start();}
public void metron_f7544_0() throws Exception
{    solrComponent.addCollection(SENSOR_NAME, "./src/test/resources/config/test/conf");    solrComponent.addCollection("error", "./src/main/config/schema/error");    Map<String, Object> globalConfig = createGlobalConfig();    globalConfig.put(HBaseDao.HBASE_TABLE, TABLE_NAME);    globalConfig.put(HBaseDao.HBASE_CF, CF);    CuratorFramework client = ConfigurationsUtils.getClient(solrComponent.getZookeeperUrl());    client.start();    ZKConfigurationsCache cache = new ZKConfigurationsCache(client);    cache.start();    AccessConfig accessConfig = new AccessConfig();    accessConfig.setGlobalConfigSupplier(() -> globalConfig);    accessConfig.setIndexSupplier(s -> s);    accessConfig.setIndexSupplier(IndexingCacheUtil.getIndexLookupFunction(cache, "solr"));    SolrDao dao = new SolrDao();    dao.init(accessConfig);    setDao(dao);}
public void metron_f7545_0()
{    solrComponent.reset();}
public static void metron_f7546_0()
{    SolrClientFactory.close();    solrComponent.stop();}
protected String metron_f7547_0()
{    return SENSOR_NAME;}
private static Map<String, Object> metron_f7548_0()
{    return new HashMap<String, Object>() {        {            put(SOLR_ZOOKEEPER, solrComponent.getZookeeperUrl());        }    };}
protected void metron_f7549_0(String indexName, String sensorType, List<Map<String, Object>> docs) throws Exception
{    solrComponent.addDocs(indexName, docs);}
protected List<Map<String, Object>> metron_f7550_0(String indexName, String sensorType)
{    return solrComponent.getAllIndexedDocs(indexName);}
public void metron_f7551_0() throws Exception
{    Map<String, Object> fields = new HashMap<>();    fields.put("guid", "bro_1");    fields.put("source.type", SENSOR_NAME);    fields.put("ip_src_port", 8010);    fields.put("long_field", 10000);    fields.put("latitude", 48.5839);    fields.put("score", 10.0);    fields.put("is_alert", true);    fields.put("field.location_point", "48.5839,7.7455");    Document document = new Document(fields, "bro_1", SENSOR_NAME, 0L);    getDao().update(document, Optional.of(SENSOR_NAME));    Document indexedDocument = getDao().getLatest("bro_1", SENSOR_NAME);        assertEquals(8, indexedDocument.getDocument().size());}
public void metron_f7552_0() throws Exception
{    String hugeString = StringUtils.repeat("test ", 1_000_000);    String hugeStringTwo = hugeString + "-2";    Map<String, Object> documentMap = new HashMap<>();    documentMap.put("guid", "error_guid");        documentMap.put("raw_message", hugeString);    documentMap.put("raw_message_1", hugeStringTwo);    Document errorDoc = new Document(documentMap, "error", "error", 0L);    getDao().update(errorDoc, Optional.of("error"));        Document latest = getDao().getLatest("error_guid", "error");    @SuppressWarnings("unchecked")    String actual = (String) latest.getDocument().get("raw_message");    assertEquals(actual, hugeString);    String actualTwo = (String) latest.getDocument().get("raw_message_1");    assertEquals(actualTwo, hugeStringTwo);        documentMap.put("error_hash", hugeString);    errorDoc = new Document(documentMap, "error", "error", 0L);    exception.expect(SolrException.class);    exception.expectMessage("Document contains at least one immense term in field=\"error_hash\"");    getDao().update(errorDoc, Optional.of("error"));}
public boolean metron_f7553_0(Object o)
{    ModifiableSolrParams modifiableSolrParams = (ModifiableSolrParams) o;    for (String name : expectedModifiableSolrParams.getParameterNames()) {        String expectedValue = expectedModifiableSolrParams.get(name);        String value = modifiableSolrParams.get(name);        if (expectedValue == null) {            if (value != null) {                return false;            }        } else {            if (!expectedValue.equals(value)) {                return false;            }        }    }    return true;}
public void metron_f7554_0(Description description)
{    description.appendValue(expectedModifiableSolrParams);}
public boolean metron_f7555_0(Object o)
{    List<SolrInputDocument> solrInputDocuments = (List<SolrInputDocument>) o;    for (int i = 0; i < solrInputDocuments.size(); i++) {        SolrInputDocument solrInputDocument = solrInputDocuments.get(i);        for (int j = 0; j < expectedSolrInputDocuments.size(); j++) {            SolrInputDocument expectedSolrInputDocument = expectedSolrInputDocuments.get(j);            if (solrInputDocument.get("guid").equals(expectedSolrInputDocument.get("guid"))) {                for (String field : solrInputDocument.getFieldNames()) {                    Object expectedValue = expectedSolrInputDocument.getField(field).getValue();                    Object value = solrInputDocument.getField(field).getValue();                    boolean matches = expectedValue != null ? expectedValue.equals(value) : value == null;                    if (!matches) {                        return false;                    }                }            }        }    }    return true;}
public void metron_f7556_0(Description description)
{    description.appendValue(expectedSolrInputDocuments);}
public boolean metron_f7557_0(Object o)
{    SolrInputDocument solrInputDocument = (SolrInputDocument) o;    for (String field : solrInputDocument.getFieldNames()) {        Object expectedValue = expectedSolrInputDocument.getField(field).getValue();        Object value = solrInputDocument.getField(field).getValue();        boolean matches = expectedValue != null ? expectedValue.equals(value) : value == null;        if (!matches) {            return false;        }    }    return true;}
public void metron_f7558_0(Description description)
{    description.appendValue(expectedSolrInputDocument);}
public boolean metron_f7559_0(Object o)
{    SolrQuery solrQuery = (SolrQuery) o;    return Objects.equals(solrQuery.getStart(), expectedSolrQuery.getStart()) && Objects.equals(solrQuery.getRows(), expectedSolrQuery.getRows()) && Objects.equals(solrQuery.getQuery(), expectedSolrQuery.getQuery()) && Objects.equals(solrQuery.getSorts(), expectedSolrQuery.getSorts()) && Objects.equals(solrQuery.getFields(), expectedSolrQuery.getFields()) && Arrays.equals(solrQuery.getFacetFields(), expectedSolrQuery.getFacetFields()) && Objects.equals(solrQuery.get("collection"), expectedSolrQuery.get("collection")) && Objects.equals(solrQuery.get("stats"), expectedSolrQuery.get("stats")) && Objects.equals(solrQuery.get("stats.field"), expectedSolrQuery.get("stats.field")) && Objects.equals(solrQuery.get("facet"), expectedSolrQuery.get("facet")) && Objects.equals(solrQuery.get("facet.pivot"), expectedSolrQuery.get("facet.pivot"));}
public void metron_f7560_0(Description description)
{    description.appendValue(expectedSolrQuery);}
public boolean metron_f7561_0(Object o)
{    QueryRequest queryRequest = (QueryRequest) o;    return name.equals(queryRequest.getParams().get("action"));}
public void metron_f7562_0(Description description)
{    description.appendText(name);}
public void metron_f7563_0() throws Exception
{    final String collection = "metron";    String zookeeperUrl = "zookeeperUrl";    MetronSolrClient metronSolrClient = Mockito.spy(new MetronSolrClient(zookeeperUrl));    Mockito.doReturn(new NamedList<Object>() {        {            add("collections", new ArrayList<String>() {                {                    add(collection);                }            });        }    }).when(metronSolrClient).request(argThat(new CollectionRequestMatcher(CollectionParams.CollectionAction.LIST.name())), (String) isNull());    metronSolrClient.createCollection(collection, 1, 1);    verify(metronSolrClient, times(1)).request(argThat(new CollectionRequestMatcher(CollectionParams.CollectionAction.LIST.name())), (String) isNull());    verify(metronSolrClient, times(0)).request(argThat(new CollectionRequestMatcher(CollectionParams.CollectionAction.CREATE.name())), (String) isNull());    metronSolrClient = Mockito.spy(new MetronSolrClient(zookeeperUrl));    Mockito.doReturn(new NamedList<Object>() {        {            add("collections", new ArrayList<String>());        }    }).when(metronSolrClient).request(argThat(new CollectionRequestMatcher(CollectionParams.CollectionAction.LIST.name())), (String) isNull());    Mockito.doReturn(new NamedList<>()).when(metronSolrClient).request(argThat(new CollectionRequestMatcher(CollectionParams.CollectionAction.CREATE.name())), (String) isNull());    metronSolrClient.createCollection(collection, 1, 1);    verify(metronSolrClient, times(1)).request(argThat(new CollectionRequestMatcher(CollectionParams.CollectionAction.LIST.name())), (String) isNull());    verify(metronSolrClient, times(1)).request(argThat(new CollectionRequestMatcher(CollectionParams.CollectionAction.CREATE.name())), (String) isNull());}
public boolean metron_f7564_0(Object o)
{    QueryRequest queryRequest = (QueryRequest) o;    return name.equals(queryRequest.getParams().get("action"));}
public void metron_f7565_0(Description description)
{    description.appendText(name);}
public boolean metron_f7566_0(Object o)
{    List<SolrInputDocument> docs = (List<SolrInputDocument>) o;    int size = docs.size();    if (size != expectedDocs.size()) {        return false;    }    for (int i = 0; i < size; ++i) {        SolrInputDocument doc = docs.get(i);        Map<String, Object> expectedDoc = expectedDocs.get(i);        for (Map.Entry<String, Object> expectedKv : expectedDoc.entrySet()) {            if (!expectedKv.getValue().equals(doc.get(expectedKv.getKey()).getValue())) {                return false;            }        }    }    return true;}
public void metron_f7567_0(Description description)
{    description.appendText(expectedDocs.toString());}
public void metron_f7568_0() throws Exception
{    IndexingConfigurations configurations = SampleUtil.getSampleIndexingConfigs();    JSONObject message1 = new JSONObject();    message1.put(Constants.GUID, "guid-1");    message1.put(Constants.SENSOR_TYPE, "test");    message1.put("intField", 100);    message1.put("doubleField", 100.0);    JSONObject message2 = new JSONObject();    message2.put(Constants.GUID, "guid-2");    message2.put(Constants.SENSOR_TYPE, "test");    message2.put("intField", 200);    message2.put("doubleField", 200.0);    List<BulkMessage<JSONObject>> messages = new ArrayList<>();    messages.add(new BulkMessage<>("message1", message1));    messages.add(new BulkMessage<>("message2", message2));    String collection = "metron";    MetronSolrClient solr = Mockito.mock(MetronSolrClient.class);    SolrWriter writer = new SolrWriter().withMetronSolrClient(solr);    writer.init(null, new IndexingWriterConfiguration("solr", configurations));    verify(solr, times(1)).setDefaultCollection(collection);    collection = "metron2";    Map<String, Object> globalConfig = configurations.getGlobalConfig();    globalConfig.put("solr.collection", collection);    configurations.updateGlobalConfig(globalConfig);    writer = new SolrWriter().withMetronSolrClient(solr);    writer.init(null, new IndexingWriterConfiguration("solr", configurations));    verify(solr, times(1)).setDefaultCollection(collection);    writer.write("test", new IndexingWriterConfiguration("solr", configurations), messages);    verify(solr, times(1)).add(eq("yaf"), argThat(new SolrInputDocumentMatcher(ImmutableList.of(message1, message2))));    verify(solr, times(1)).commit("yaf", (boolean) SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.defaultValue.get(), (boolean) SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.defaultValue.get(), (boolean) SolrWriter.SolrProperties.COMMIT_SOFT.defaultValue.get());}
public void metron_f7569_0() throws Exception
{    String expected = "test";    Assert.assertEquals(expected, SolrWriter.SolrProperties.ZOOKEEPER_QUORUM.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.ZOOKEEPER_QUORUM.name, expected), String.class));}
public void metron_f7570_0() throws Exception
{    SolrWriter.SolrProperties.ZOOKEEPER_QUORUM.coerceOrDefaultOrExcept(new HashMap<>(), String.class);}
public void metron_f7571_0() throws Exception
{    Object expected = false;    Assert.assertEquals(expected, SolrWriter.SolrProperties.COMMIT_PER_BATCH.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_PER_BATCH.name, false), Boolean.class));}
public void metron_f7572_0() throws Exception
{    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_PER_BATCH.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_PER_BATCH.coerceOrDefaultOrExcept(new HashMap<>(), Boolean.class));    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_PER_BATCH.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_PER_BATCH.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_PER_BATCH.name, new DummyClass()), Boolean.class));}
public void metron_f7573_0() throws Exception
{    Object expected = true;    Assert.assertEquals(expected, SolrWriter.SolrProperties.COMMIT_SOFT.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_SOFT.name, expected), Boolean.class));}
public void metron_f7574_0() throws Exception
{    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_SOFT.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_SOFT.coerceOrDefaultOrExcept(new HashMap<>(), Boolean.class));    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_SOFT.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_SOFT.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_SOFT.name, new DummyClass()), Boolean.class));}
public void metron_f7575_0() throws Exception
{    Object expected = false;    Assert.assertEquals(expected, SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.name, expected), Boolean.class));}
public void metron_f7576_0() throws Exception
{    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.coerceOrDefaultOrExcept(new HashMap<>(), Boolean.class));    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_WAIT_FLUSH.name, new DummyClass()), Boolean.class));}
public void metron_f7577_0() throws Exception
{    Object expected = false;    Assert.assertEquals(expected, SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.name, expected), Boolean.class));}
public void metron_f7578_0() throws Exception
{    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.coerceOrDefaultOrExcept(new HashMap<>(), Boolean.class));    Assert.assertEquals(SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.defaultValue.get(), SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.COMMIT_WAIT_SEARCHER.name, new DummyClass()), Boolean.class));}
public void metron_f7579_0() throws Exception
{    Object expected = "mycollection";    Assert.assertEquals(expected, SolrWriter.SolrProperties.DEFAULT_COLLECTION.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.DEFAULT_COLLECTION.name, expected), String.class));}
public void metron_f7580_0() throws Exception
{    Assert.assertEquals(SolrWriter.SolrProperties.DEFAULT_COLLECTION.defaultValue.get(), SolrWriter.SolrProperties.DEFAULT_COLLECTION.coerceOrDefaultOrExcept(new HashMap<>(), String.class));}
public void metron_f7581_0() throws Exception
{    Object expected = new HashMap<String, Object>() {        {            put("name", "metron");        }    };    Assert.assertEquals(expected, SolrWriter.SolrProperties.HTTP_CONFIG.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.HTTP_CONFIG.name, expected), Map.class));}
public void metron_f7582_0() throws Exception
{    Assert.assertEquals(SolrWriter.SolrProperties.HTTP_CONFIG.defaultValue.get(), SolrWriter.SolrProperties.HTTP_CONFIG.coerceOrDefaultOrExcept(new HashMap<>(), Map.class));    Assert.assertEquals(SolrWriter.SolrProperties.HTTP_CONFIG.defaultValue.get(), SolrWriter.SolrProperties.HTTP_CONFIG.coerceOrDefaultOrExcept(ImmutableMap.of(SolrWriter.SolrProperties.HTTP_CONFIG.name, new DummyClass()), Map.class));}
public FieldNameConverter metron_f7583_0()
{    return fieldNameConverter;}
public InMemoryComponent metron_f7584_0(final Properties topologyProperties) throws Exception
{    SolrComponent solrComponent = new SolrComponent.Builder().addInitialCollection(collection, "../metron-solr-common/src/main/config/schema/yaf").withPostStartCallback(new Function<SolrComponent, Void>() {        @Nullable        @Override        public Void apply(@Nullable SolrComponent solrComponent) {            topologyProperties.setProperty("solr.zk", solrComponent.getZookeeperUrl());            try {                String testZookeeperUrl = topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY);                Configurations configurations = SampleUtil.getSampleConfigs();                Map<String, Object> globalConfig = configurations.getGlobalConfig();                globalConfig.put(SolrConstants.SOLR_ZOOKEEPER, solrComponent.getZookeeperUrl());                ConfigurationsUtils.writeGlobalConfigToZookeeper(JSONUtils.INSTANCE.toJSONPretty(globalConfig), testZookeeperUrl);            } catch (Exception e) {                e.printStackTrace();            }            return null;        }    }).build();    return solrComponent;}
public Void metron_f7585_0(@Nullable SolrComponent solrComponent)
{    topologyProperties.setProperty("solr.zk", solrComponent.getZookeeperUrl());    try {        String testZookeeperUrl = topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY);        Configurations configurations = SampleUtil.getSampleConfigs();        Map<String, Object> globalConfig = configurations.getGlobalConfig();        globalConfig.put(SolrConstants.SOLR_ZOOKEEPER, solrComponent.getZookeeperUrl());        ConfigurationsUtils.writeGlobalConfigToZookeeper(JSONUtils.INSTANCE.toJSONPretty(globalConfig), testZookeeperUrl);    } catch (Exception e) {        e.printStackTrace();    }    return null;}
public Processor<List<Map<String, Object>>> metron_f7586_0(final List<byte[]> inputMessages)
{    return new Processor<List<Map<String, Object>>>() {        List<Map<String, Object>> docs = null;        List<byte[]> errors = null;        @Override        public ReadinessState process(ComponentRunner runner) {            SolrComponent solrComponent = runner.getComponent("search", SolrComponent.class);            KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);            if (solrComponent.hasCollection(collection)) {                docs = solrComponent.getAllIndexedDocs(collection);                if (docs.size() < inputMessages.size()) {                    errors = kafkaComponent.readMessages(ERROR_TOPIC);                    if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {                        return ReadinessState.READY;                    }                    return ReadinessState.NOT_READY;                } else {                    return ReadinessState.READY;                }            } else {                return ReadinessState.NOT_READY;            }        }        @Override        public ProcessorResult<List<Map<String, Object>>> getResult() {            ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();            return builder.withResult(docs).withProcessErrors(errors).build();        }    };}
public ReadinessState metron_f7587_0(ComponentRunner runner)
{    SolrComponent solrComponent = runner.getComponent("search", SolrComponent.class);    KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);    if (solrComponent.hasCollection(collection)) {        docs = solrComponent.getAllIndexedDocs(collection);        if (docs.size() < inputMessages.size()) {            errors = kafkaComponent.readMessages(ERROR_TOPIC);            if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {                return ReadinessState.READY;            }            return ReadinessState.NOT_READY;        } else {            return ReadinessState.READY;        }    } else {        return ReadinessState.NOT_READY;    }}
public ProcessorResult<List<Map<String, Object>>> metron_f7588_0()
{    ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();    return builder.withResult(docs).withProcessErrors(errors).build();}
public void metron_f7589_0(Properties topologyProperties)
{    topologyProperties.setProperty("ra_indexing_writer_class_name", "org.apache.metron.solr.writer.SolrWriter");    topologyProperties.setProperty("ra_indexing_kafka_start", "UNCOMMITTED_EARLIEST");    topologyProperties.setProperty("ra_indexing_workers", "1");    topologyProperties.setProperty("ra_indexing_acker_executors", "0");    topologyProperties.setProperty("ra_indexing_topology_max_spout_pending", "");    topologyProperties.setProperty("ra_indexing_kafka_spout_parallelism", "1");    topologyProperties.setProperty("ra_indexing_writer_parallelism", "1");}
public String metron_f7590_0(String field)
{    return field.replaceFirst("_[dfils]$", "");}
public String metron_f7591_0()
{    return "./src/main/config/solr.properties.j2";}
public String metron_f7592_0()
{    return "../../metron-indexing/metron-indexing-storm/src/main/flux/indexing/random_access/remote.yaml";}
public String metron_f7593_0()
{    return fieldName;}
public static List<FieldsConfiguration> metron_f7594_0(String... configs)
{    List<FieldsConfiguration> ret = new ArrayList<>();    for (String config : configs) {        ret.add(FieldsConfiguration.valueOf(config.toUpperCase()));    }    return ret;}
public static List<FieldsConfiguration> metron_f7595_0(List<String> configs)
{    List<FieldsConfiguration> ret = new ArrayList<>();    for (String config : configs) {        ret.add(FieldsConfiguration.valueOf(config.toUpperCase()));    }    return ret;}
public static Fields metron_f7596_0(Iterable<FieldsConfiguration> configs)
{    List<String> fields = new ArrayList<>();    for (FieldsConfiguration config : configs) {        fields.add(config.fieldName);    }    return new Fields(fields);}
public List<Object> metron_f7597_0(ConsumerRecord<K, V> consumerRecord)
{    Values ret = new Values();    for (FieldsConfiguration config : configurations) {        ret.add(config.recordExtractor.apply(consumerRecord));    }    return ret;}
public Fields metron_f7598_0(String s)
{    return fields;}
public List<String> metron_f7599_0()
{    return DEFAULT_STREAM;}
private static Subscription metron_f7600_0(String topicOrSubscription)
{    if (StringUtils.isEmpty(topicOrSubscription)) {        throw new IllegalArgumentException("Topic name is invalid (empty or null): " + topicOrSubscription);    }    int length = topicOrSubscription.length();    if (topicOrSubscription.charAt(0) == '/' && topicOrSubscription.charAt(length - 1) == '/') {                String substr = topicOrSubscription.substring(1, length - 1);        return new PatternSubscription(Pattern.compile(substr));    } else {        return new NamedSubscription(topicOrSubscription);    }}
private static Class<Deserializer<T>> metron_f7601_0(Optional<String> deserializerClass, String defaultDeserializerClass)
{    try {        return (Class<Deserializer<T>>) Class.forName(deserializerClass.orElse(defaultDeserializerClass));    } catch (Exception e) {        throw new IllegalStateException("Unable to create a deserializer: " + deserializerClass.orElse(defaultDeserializerClass) + ": " + e.getMessage(), e);    }}
private static String metron_f7602_0(String zkQuorum, Map<String, Object> kafkaProps)
{    String brokers = (String) kafkaProps.get(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG);    if (brokers == null) {        try {            return Joiner.on(",").join(KafkaUtils.INSTANCE.getBrokersFromZookeeper(zkQuorum));        } catch (Exception e) {            throw new IllegalStateException("Unable to find the bootstrap servers: " + e.getMessage(), e);        }    }    return brokers;}
public static StormKafkaSpout<K, V> metron_f7603_0(String topic, String zkQuorum, List<String> fieldsConfiguration, Map<String, Object> kafkaProps)
{    Map<String, Object> spoutConfig = SpoutConfiguration.separate(kafkaProps);    SimpleStormKafkaBuilder<K, V> builder = new SimpleStormKafkaBuilder<>(kafkaProps, topic, zkQuorum, fieldsConfiguration);    SpoutConfiguration.configure(builder, spoutConfig);    return new StormKafkaSpout<>(builder);}
public static Map<String, Object> metron_f7604_0(Map<String, Object> config)
{    Map<String, Object> ret = new HashMap<>();    for (SpoutConfiguration spoutConfig : SpoutConfiguration.values()) {        if (config.containsKey(spoutConfig.key)) {            Object val = config.get(spoutConfig.key);            config.remove(spoutConfig.key);            ret.put(spoutConfig.key, val);        }    }    return ret;}
public static KafkaSpoutConfig.Builder metron_f7605_0(KafkaSpoutConfig.Builder<K, V> builder, Map<String, Object> config)
{    for (SpoutConfiguration spoutConfig : SpoutConfiguration.values()) {        if (config.containsKey(spoutConfig.key)) {            Container container = new Container(config, builder, config.get(spoutConfig.key));            spoutConfig.consumer.accept(container);        }    }    return builder;}
public static List<String> metron_f7606_0()
{    List<String> ret = new ArrayList<>();    for (SpoutConfiguration spoutConfig : SpoutConfiguration.values()) {        ret.add(spoutConfig.key);    }    ret.add(ConsumerConfig.GROUP_ID_CONFIG);    ret.add(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG);    ret.add(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG);    return ret;}
public void metron_f7607_1()
{    try {        super.deactivate();    } catch (WakeupException we) {                    } finally {        isShutdown.set(true);    }}
public void metron_f7608_1()
{    try {        if (!isShutdown.get()) {            super.close();            isShutdown.set(true);        }    } catch (WakeupException we) {                    } catch (IllegalStateException ise) {        if (ise.getMessage().contains("This consumer has already been closed")) {                    } else {            throw ise;        }    }}
public static int metron_f7609_0(Object messageIdObj)
{    KafkaSpoutMessageId messageId = (KafkaSpoutMessageId) messageIdObj;    return messageId.getTopicPartition().partition();}
public List<Integer> metron_f7610_0(String streamId, List<Object> tuple, Object messageId)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext().with(EmitContext.Type.PARTITION, getPartition(messageId)).with(EmitContext.Type.STREAM_ID, streamId));    return _delegate.emit(streamId, t, messageId);}
public List<Integer> metron_f7611_0(List<Object> tuple, Object messageId)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext().with(EmitContext.Type.PARTITION, getPartition(messageId)));    return _delegate.emit(t, messageId);}
public List<Integer> metron_f7612_0(List<Object> tuple)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext());    return _delegate.emit(t);}
public List<Integer> metron_f7613_0(String streamId, List<Object> tuple)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext().with(EmitContext.Type.STREAM_ID, streamId));    return _delegate.emit(streamId, t);}
public void metron_f7614_0(int taskId, String streamId, List<Object> tuple, Object messageId)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext().with(EmitContext.Type.STREAM_ID, streamId).with(EmitContext.Type.PARTITION, getPartition(messageId)).with(EmitContext.Type.TASK_ID, taskId));    _delegate.emitDirect(taskId, streamId, t, messageId);}
public void metron_f7615_0(int taskId, List<Object> tuple, Object messageId)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext().with(EmitContext.Type.PARTITION, getPartition(messageId)).with(EmitContext.Type.TASK_ID, taskId));    _delegate.emitDirect(taskId, t, messageId);}
public void metron_f7616_0(int taskId, String streamId, List<Object> tuple)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext().with(EmitContext.Type.STREAM_ID, streamId).with(EmitContext.Type.TASK_ID, taskId));    _delegate.emitDirect(taskId, streamId, t);}
public void metron_f7617_0(int taskId, List<Object> tuple)
{    List<Object> t = _callback.apply(tuple, _context.cloneContext().with(EmitContext.Type.TASK_ID, taskId));    _delegate.emitDirect(taskId, t);}
public void metron_f7618_0(TopologyContext context)
{    _callback = createCallback(callbackClazz);    _context = new EmitContext().with(EmitContext.Type.SPOUT_CONFIG, _spoutConfig).with(EmitContext.Type.UUID, context.getStormId());    _callback.initialize(_context);}
private static Class<? extends Callback> metron_f7619_0(String callbackClass)
{    try {        return (Class<? extends Callback>) Callback.class.forName(callbackClass);    } catch (ClassNotFoundException e) {        throw new RuntimeException(callbackClass + " not found", e);    }}
protected Callback metron_f7620_0(Class<? extends Callback> callbackClass)
{    try {        return callbackClass.getConstructor().newInstance();    } catch (InstantiationException | NoSuchMethodException | InvocationTargetException e) {        throw new RuntimeException("Unable to instantiate callback", e);    } catch (IllegalAccessException e) {        throw new RuntimeException("Illegal access", e);    }}
public void metron_f7621_0(Map conf, final TopologyContext context, final SpoutOutputCollector collector)
{    if (_callback == null) {        initialize(context);    }    super.open(conf, context, new CallbackCollector(_callback, collector, _context.cloneContext().with(EmitContext.Type.OPEN_CONFIG, conf).with(EmitContext.Type.TOPOLOGY_CONTEXT, context)));}
public void metron_f7622_0()
{    super.close();    if (_callback != null) {        try {            _callback.close();        } catch (Exception e) {            throw new IllegalStateException("Unable to close callback", e);        }    }}
public Class<?> metron_f7623_0()
{    return clazz;}
public EmitContext metron_f7624_0(Type t, T o)
{    _context.put(t, t.clazz().cast(o));    return this;}
public void metron_f7625_0(Type t, T o)
{    with(t, o);}
public T metron_f7626_0(Type t)
{    Object o = _context.get(t);    if (o == null) {        return null;    } else {        return (T) o;    }}
public EmitContext metron_f7627_0()
{    try {        return (EmitContext) this.clone();    } catch (CloneNotSupportedException e) {        throw new RuntimeException("Unable to clone emit context.", e);    }}
protected Object metron_f7628_0() throws CloneNotSupportedException
{    EmitContext context = new EmitContext(_context.clone());    return context;}
public void metron_f7629_0()
{    Map<String, Object> config = new HashMap<String, Object>() {        {            put(SpoutConfiguration.FIRST_POLL_OFFSET_STRATEGY.key, "UNCOMMITTED_EARLIEST");            put(SpoutConfiguration.OFFSET_COMMIT_PERIOD_MS.key, "1000");            put("group.id", "foobar");        }    };    Map<String, Object> spoutConfig = SpoutConfiguration.separate(config);    Assert.assertTrue(spoutConfig.containsKey(SpoutConfiguration.FIRST_POLL_OFFSET_STRATEGY.key));    Assert.assertEquals(spoutConfig.get(SpoutConfiguration.FIRST_POLL_OFFSET_STRATEGY.key), "UNCOMMITTED_EARLIEST");    Assert.assertTrue(spoutConfig.containsKey(SpoutConfiguration.OFFSET_COMMIT_PERIOD_MS.key));    Assert.assertEquals(spoutConfig.get(SpoutConfiguration.OFFSET_COMMIT_PERIOD_MS.key), "1000");    Assert.assertEquals(2, spoutConfig.size());    Assert.assertEquals(1, config.size());    Assert.assertEquals(config.get("group.id"), "foobar");}
public void metron_f7630_0()
{    Map<String, Object> config = new HashMap<String, Object>() {        {            put(SpoutConfiguration.OFFSET_COMMIT_PERIOD_MS.key, "1000");            put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "foo:1234");            put("group.id", "foobar");        }    };    Map<String, Object> spoutConfig = SpoutConfiguration.separate(config);    KafkaSpoutConfig.Builder<Object, Object> builder = new SimpleStormKafkaBuilder(config, "topic", null);    SpoutConfiguration.configure(builder, spoutConfig);    KafkaSpoutConfig c = builder.build();    Assert.assertEquals(1000, c.getOffsetsCommitPeriodMs());}
public long metron_f7631_0()
{    return this.period;}
public long metron_f7632_0()
{    return this.delay;}
public TimeUnit metron_f7633_0()
{    return this.timeUnit;}
public boolean metron_f7634_0()
{    boolean expired = System.nanoTime() - this.start >= this.periodNanos;    if (expired) {        this.start = System.nanoTime();    }    return expired;}
public int metron_f7635_0(RetrySchedule entry1, RetrySchedule entry2)
{    int result = Long.valueOf(entry1.nextRetryTimeNanos()).compareTo(entry2.nextRetryTimeNanos());    if (result == 0) {                        result = entry1.hashCode() - entry2.hashCode();    }    return result;}
public void metron_f7636_1()
{    nextRetryTimeNanos = nextTime(msgId);    }
public boolean metron_f7637_0(long currentTimeNanos)
{    return nextRetryTimeNanos <= currentTimeNanos;}
public String metron_f7638_0()
{    return "RetrySchedule{" + "msgId=" + msgId + ", nextRetryTimeNanos=" + nextRetryTimeNanos + '}';}
public KafkaSpoutMessageId metron_f7639_0()
{    return msgId;}
public long metron_f7640_0()
{    return nextRetryTimeNanos;}
public static TimeInterval metron_f7641_0(long length)
{    return new TimeInterval(length, TimeUnit.SECONDS);}
public static TimeInterval metron_f7642_0(long length)
{    return new TimeInterval(length, TimeUnit.MILLISECONDS);}
public static TimeInterval metron_f7643_0(long length)
{    return new TimeInterval(length, TimeUnit.MICROSECONDS);}
public long metron_f7644_0()
{    return lengthNanos;}
public TimeUnit metron_f7645_0()
{    return timeUnit;}
public String metron_f7646_0()
{    return "TimeInterval{" + "length=" + length + ", timeUnit=" + timeUnit + '}';}
public Map<TopicPartition, Long> metron_f7647_1()
{    final Map<TopicPartition, Long> tpToEarliestRetriableOffset = new HashMap<>();    final long currentTimeNanos = System.nanoTime();    for (RetrySchedule retrySchedule : retrySchedules) {        if (retrySchedule.retry(currentTimeNanos)) {            final KafkaSpoutMessageId msgId = retrySchedule.msgId;            final TopicPartition tpForMessage = new TopicPartition(msgId.topic(), msgId.partition());            final Long currentLowestOffset = tpToEarliestRetriableOffset.get(tpForMessage);            if (currentLowestOffset != null) {                tpToEarliestRetriableOffset.put(tpForMessage, Math.min(currentLowestOffset, msgId.offset()));            } else {                tpToEarliestRetriableOffset.put(tpForMessage, msgId.offset());            }        } else {                        break;        }    }        return tpToEarliestRetriableOffset;}
public boolean metron_f7648_1(KafkaSpoutMessageId msgId)
{    boolean retry = false;    if (isScheduled(msgId)) {        final long currentTimeNanos = System.nanoTime();        for (RetrySchedule retrySchedule : retrySchedules) {            if (retrySchedule.retry(currentTimeNanos)) {                if (retrySchedule.msgId.equals(msgId)) {                    retry = true;                                                            break;                }            } else {                                                break;            }        }    }    return retry;}
public boolean metron_f7649_0(KafkaSpoutMessageId msgId)
{    return toRetryMsgs.contains(msgId);}
public boolean metron_f7650_1(KafkaSpoutMessageId msgId)
{    boolean removed = false;    if (isScheduled(msgId)) {        toRetryMsgs.remove(msgId);        for (Iterator<RetrySchedule> iterator = retrySchedules.iterator(); iterator.hasNext(); ) {            final RetrySchedule retrySchedule = iterator.next();            if (retrySchedule.msgId().equals(msgId)) {                iterator.remove();                removed = true;                                break;            }        }    }        LOG.trace("Current state {}", retrySchedules);    return removed;}
public boolean metron_f7651_1(Collection<TopicPartition> topicPartitions)
{    boolean result = false;    for (Iterator<RetrySchedule> rsIterator = retrySchedules.iterator(); rsIterator.hasNext(); ) {        final RetrySchedule retrySchedule = rsIterator.next();        final KafkaSpoutMessageId msgId = retrySchedule.msgId;        final TopicPartition tpRetry = new TopicPartition(msgId.topic(), msgId.partition());        if (!topicPartitions.contains(tpRetry)) {            rsIterator.remove();            toRetryMsgs.remove(msgId);                        LOG.trace("Current state {}", retrySchedules);            result = true;        }    }    return result;}
public boolean metron_f7652_1(KafkaSpoutMessageId msgId)
{    if (msgId.numFails() > maxRetries) {                return false;    } else {                remove(msgId);        final RetrySchedule retrySchedule = new RetrySchedule(msgId, nextTime(msgId));        retrySchedules.add(retrySchedule);        toRetryMsgs.add(msgId);                LOG.trace("Current state {}", retrySchedules);        return true;    }}
public int metron_f7653_0()
{    int count = 0;    final long currentTimeNanos = System.nanoTime();    for (RetrySchedule retrySchedule : retrySchedules) {        if (retrySchedule.retry(currentTimeNanos)) {            ++count;        } else {                        break;        }    }    return count;}
public KafkaSpoutMessageId metron_f7654_0(ConsumerRecord<?, ?> record)
{    KafkaSpoutMessageId msgId = new KafkaSpoutMessageId(record);    if (isScheduled(msgId)) {        for (KafkaSpoutMessageId originalMsgId : toRetryMsgs) {            if (originalMsgId.equals(msgId)) {                return originalMsgId;            }        }    }    return msgId;}
private long metron_f7655_0(KafkaSpoutMessageId msgId)
{    Validate.isTrue(msgId.numFails() > 0, "nextTime assumes the message has failed at least once");    final long currentTimeNanos = System.nanoTime();    final long nextTimeNanos =     msgId.numFails() == 1 ? currentTimeNanos + initialDelay.lengthNanos : currentTimeNanos + delayPeriod.lengthNanos * (long) (Math.pow(2, msgId.numFails() - 1));    return Math.min(nextTimeNanos, currentTimeNanos + maxDelay.lengthNanos);}
public String metron_f7656_0()
{    return toStringImpl();}
private String metron_f7657_0()
{        return "KafkaSpoutRetryExponentialBackoff{" + "delay=" + initialDelay + ", ratio=" + delayPeriod + ", maxRetries=" + maxRetries + ", maxRetryDelay=" + maxDelay + '}';}
public void metron_f7658_0() throws InterruptedException
{    Timer t = new Timer(0, 2, TimeUnit.SECONDS);    Thread.sleep(1000);    Assert.assertFalse(t.isExpiredResetOnTrue());    Thread.sleep(1000);    Assert.assertTrue(t.isExpiredResetOnTrue());}
public void metron_f7659_0()
{    MockitoAnnotations.initMocks(this);}
public boolean metron_f7660_0(Object o)
{    Fields fields = (Fields) o;    return expectedFields.equals(fields.toList());}
public void metron_f7661_0(Description description)
{    description.appendText(String.format("[%s]", Joiner.on(",").join(expectedFields)));}
public void metron_f7662_0(JSONObject message)
{    ImmutableSet keys = ImmutableSet.copyOf(message.keySet());    for (Object key : keys) {        if (key.toString().endsWith(".ts")) {            message.remove(key);        }    }}
public void metron_f7663_0() throws ParseException
{    JSONParser parser = new JSONParser();    sampleMessage = (JSONObject) parser.parse(sampleMessageString);    geoMessage = (JSONObject) parser.parse(geoMessageString);    hostMessage = (JSONObject) parser.parse(hostMessageString);    hbaseEnrichmentMessage = (JSONObject) parser.parse(hbaseEnrichmentMessageString);    streamIds.add("geo");    streamIds.add("stellar");    streamIds.add("host");    streamIds.add("hbaseEnrichment");    joinStreamIds.add("geo:");    joinStreamIds.add("stellar:");    joinStreamIds.add("stellar:numeric");    joinStreamIds.add("stellar:dst_enrichment");    joinStreamIds.add("stellar:src_enrichment");    joinStreamIds.add("stellar:error_test");    joinStreamIds.add("host:");    joinStreamIds.add("hbaseEnrichment:");    joinStreamIds.add("message:");}
public void metron_f7664_0(Map stormConf, TopologyContext context, OutputCollector collector)
{}
public void metron_f7665_0(Tuple input)
{    System.out.println("---------[RECEIVED] " + input);}
public void metron_f7666_0(OutputFieldsDeclarer declarer)
{}
public byte[] metron_f7667_0(String s)
{    return _underlying.convert(s);}
public byte[] metron_f7668_0(String s)
{    int len = s.length();    byte[] data = new byte[len / 2];    for (int i = 0; i < len; i += 2) {        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));    }    return data;}
public boolean metron_f7669_0(Object o)
{    Values values = (Values) o;    JSONObject actual = (JSONObject) values.get(0);    actual.remove("timestamp");    expected.remove("timestamp");    actual.remove("stack");    expected.remove("stack");    actual.remove("guid");    expected.remove("guid");    return actual.equals(expected);}
public List<String> metron_f7670_0(String filename) throws IOException
{    System.out.println("Reading stream from " + filename);    List<String> lines = new LinkedList<String>();    InputStream stream = null;    if (new File(filename).exists()) {        stream = new FileInputStream(filename);    } else {        stream = Thread.currentThread().getContextClassLoader().getResourceAsStream(filename);    }    DataInputStream in = new DataInputStream(stream);    BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));    String strLine;    while ((strLine = br.readLine()) != null) {                lines.add(strLine);    }    return lines;}
public GenericInternalTestSpout metron_f7671_0(String filename)
{    if (filename != null && filename.length() > 0 && filename.charAt(0) == '$') {        filename = Iterables.getLast(Splitter.on("}").split(filename));    }    _filename = filename;    return this;}
public GenericInternalTestSpout metron_f7672_0(Integer delay)
{    _delay = delay;    return this;}
public GenericInternalTestSpout metron_f7673_0(Boolean repeating)
{    _repeating = repeating;    return this;}
public GenericInternalTestSpout metron_f7674_0(String converter)
{    if (converter == null) {        _converter = BinaryConverters.DEFAULT;    } else {        _converter = BinaryConverters.valueOf(converter);    }    return this;}
public void metron_f7675_0(Map conf, TopologyContext context, SpoutOutputCollector collector)
{    _collector = collector;    try {        Reader = new FileReader();        jsons = Reader.readFromFile(_filename);    } catch (Throwable e) {        System.out.println("Could not read sample JSONs");        e.printStackTrace();    }}
public void metron_f7676_0()
{    Utils.sleep(_delay);    if (cnt < jsons.size()) {        byte[] value;        if (_converter != null) {            value = _converter.convert(jsons.get(cnt));        } else {            value = jsons.get(cnt).getBytes(StandardCharsets.UTF_8);        }        _collector.emit(new Values(value));    }    cnt++;    if (_repeating && cnt == jsons.size() - 1)        cnt = 0;}
public void metron_f7677_0(Object id)
{}
public void metron_f7678_0(Object id)
{}
public void metron_f7679_0(OutputFieldsDeclarer declarer)
{    declarer.declare(new Fields("message"));}
public String metron_f7680_0()
{    return directoryName;}
public KafkaLoader metron_f7681_0(int delay)
{    this.delay = delay;    return this;}
public KafkaLoader metron_f7682_0(int iterations)
{    this.iterations = iterations;    return this;}
public void metron_f7683_0()
{    Map<String, Object> producerConfig = new HashMap<>();    producerConfig.put("bootstrap.servers", brokerUrl);    producerConfig.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");    producerConfig.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");    kafkaProducer = new KafkaProducer<>(producerConfig);    try {        while (iterations == -1 || iterations-- > 0) {            BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(samplePath), StandardCharsets.UTF_8));            String line;            while ((line = reader.readLine()) != null) {                kafkaProducer.send(new ProducerRecord<String, String>(topic, line));                Thread.sleep(delay);            }            reader.close();        }    } catch (Exception e) {        e.printStackTrace();    }}
public void metron_f7684_0()
{    kafkaProducer.close();}
public static void metron_f7685_0(String[] args)
{    KafkaLoader kafkaLoader = new KafkaLoader(args[0], args[1], args[2]);    if (args.length > 3)        kafkaLoader.withDelay(Integer.parseInt(args[3]));    if (args.length > 4)        kafkaLoader.withIterations(Integer.parseInt(args[4]));    kafkaLoader.start();    kafkaLoader.stop();}
public static String metron_f7686_0(String pathPrefix, String sensorType, TestDataType testDataType) throws FileNotFoundException
{    File sensorSampleDataPath = new File(pathPrefix + "/" + TestConstants.SAMPLE_DATA_PATH, sensorType);    if (sensorSampleDataPath.exists() && sensorSampleDataPath.isDirectory()) {        File sampleDataPath = new File(sensorSampleDataPath, testDataType.getDirectoryName());        if (sampleDataPath.exists() && sampleDataPath.isDirectory()) {            File[] children = sampleDataPath.listFiles();            if (children != null && children.length > 0) {                return children[0].getAbsolutePath();            }        }    }    throw new FileNotFoundException("Could not find data in " + TestConstants.SAMPLE_DATA_PATH + sensorType + "/" + testDataType.getDirectoryName());}
public static String metron_f7687_0(String sensorType, TestDataType testDataType) throws FileNotFoundException
{    return getSampleDataPath("", sensorType, testDataType);}
public static String metron_f7688_0(String name)
{    return findDir(new File("."), name);}
public static String metron_f7689_0(File startDir, String name)
{    Stack<File> s = new Stack<File>();    s.push(startDir);    while (!s.empty()) {        File parent = s.pop();        if (parent.getName().equalsIgnoreCase(name)) {            return parent.getAbsolutePath();        } else {            File[] children = parent.listFiles();            if (children != null) {                for (File child : children) {                    s.push(child);                }            }        }    }    return null;}
public static void metron_f7690_0(String type, Set<T> expectedPcapIds, Set<T> found)
{    boolean mismatch = false;    for (T f : found) {        if (!expectedPcapIds.contains(f)) {            mismatch = true;            System.out.println("Found " + type + " that I did not expect: " + f);        }    }    for (T expectedId : expectedPcapIds) {        if (!found.contains(expectedId)) {            mismatch = true;            System.out.println("Expected " + type + " that I did not index: " + expectedId);        }    }    Assert.assertFalse(mismatch);}
public static void metron_f7691_0()
{    verboseLogging("%d [%p|%c|%C{1}] %m%n", Level.ALL);}
public static void metron_f7692_0(String pattern, Level level)
{        ConsoleAppender console = new ConsoleAppender();        console.setLayout(new PatternLayout(pattern));    console.setThreshold(level);    console.activateOptions();        Logger.getRootLogger().addAppender(console);}
public static void metron_f7693_0(Class clazz, Level level)
{    Logger logger = Logger.getLogger(clazz);    logger.setLevel(level);}
public static void metron_f7694_0(Level level)
{    Logger logger = Logger.getRootLogger();    logger.setLevel(level);}
public static Level metron_f7695_0()
{    Logger rootLogger = Logger.getRootLogger();    return rootLogger.getLevel();}
public static Level metron_f7696_0(Class clazz)
{    Logger logger = Logger.getLogger(clazz);    return logger.getLevel();}
public static void metron_f7697_0(Class clazz, java.util.logging.Level level)
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger(clazz.getName());    logger.setLevel(level);}
public static java.util.logging.Level metron_f7698_0(Class clazz)
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger(clazz.getName());    return logger.getLevel();}
public static void metron_f7699_0(java.util.logging.Level level)
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger("");    logger.setLevel(level);}
public static java.util.logging.Level metron_f7700_0()
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger("");    return logger.getLevel();}
public static File metron_f7701_0(File dir) throws IOException
{    return createTempDir(dir, true);}
public static File metron_f7702_0(File dir, boolean cleanup) throws IOException
{    if (!dir.mkdirs() && !dir.exists()) {        throw new IOException(String.format("Failed to create directory structure '%s'", dir.toString()));    }    if (cleanup) {        addCleanupHook(dir.toPath());    }    return dir;}
public static File metron_f7703_0(String prefix) throws IOException
{    return createTempDir(prefix, true);}
public static File metron_f7704_0(String prefix, boolean cleanup) throws IOException
{    Path tmpDir = Files.createTempDirectory(prefix);    addCleanupHook(tmpDir);    return tmpDir.toFile();}
public static void metron_f7705_0(final Path dir)
{    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            try {                cleanDir(dir);            } catch (IOException e) {                System.out.println(format("Warning: Unable to clean folder '%s'", dir.toString()));            }        }    });}
public void metron_f7706_0()
{    try {        cleanDir(dir);    } catch (IOException e) {        System.out.println(format("Warning: Unable to clean folder '%s'", dir.toString()));    }}
public static void metron_f7707_0(Path dir) throws IOException
{    Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {            if (exc == null) {                return FileVisitResult.CONTINUE;            } else {                throw exc;            }        }    });    Files.delete(dir);}
public FileVisitResult metron_f7708_0(Path file, BasicFileAttributes attrs) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f7709_0(Path file, IOException exc) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f7710_0(Path dir, IOException exc) throws IOException
{    if (exc == null) {        return FileVisitResult.CONTINUE;    } else {        throw exc;    }}
public static File metron_f7711_0(File file, String contents) throws IOException
{    com.google.common.io.Files.createParentDirs(file);    com.google.common.io.Files.write(contents, file, StandardCharsets.UTF_8);    return file;}
public static void metron_f7712_0(String expected, String actual) throws IOException
{    ObjectMapper mapper = new ObjectMapper();    Map m1 = mapper.readValue(expected, Map.class);    Map m2 = mapper.readValue(actual, Map.class);    for (Object k : m1.keySet()) {        Object v1 = m1.get(k);        Object v2 = m2.get(k);        if (v2 == null) {            Assert.fail("Unable to find key: " + k + " in output");        }        if (k.equals("timestamp") || k.equals("guid")) {                        Assert.assertEquals(v1.toString().length(), v2.toString().length());        } else if (!v2.equals(v1)) {            boolean goodDeepDown = false;                        if (((String) k).equals("original_string")) {                try {                    mapper.readValue((String) v1, Map.class);                    assertJsonEqual((String) v1, (String) v2);                    goodDeepDown = true;                } catch (Exception e) {                                }            }            if (!goodDeepDown) {                Assert.assertEquals("value mismatch for " + k, v1, v2);            }        }    }    Assert.assertEquals(m1.size(), m2.size());}
public boolean metron_f7713_1(String sensorType, WriterConfiguration configurations, List<BulkMessage<MESSAGE_T>> messages)
{    boolean shouldFlush = false;    int batchSize = messages.size();    int configuredBatchSize = configurations.getBatchSize(sensorType);        if (batchSize >= configuredBatchSize) {                shouldFlush = true;    }    return shouldFlush;}
public void metron_f7714_0(String sensorType, BulkWriterResponse response)
{}
public boolean metron_f7715_1(String sensorType, WriterConfiguration configurations, List<BulkMessage<MESSAGE_T>> messages)
{    boolean shouldFlush = false;    long currentTimeMillis = clock.currentTimeMillis();    if (!timeouts.containsKey(sensorType)) {                                long batchTimeoutMs = getBatchTimeout(sensorType, configurations);                timeouts.put(sensorType, currentTimeMillis + batchTimeoutMs);    }    if (timeouts.get(sensorType) <= currentTimeMillis) {                shouldFlush = true;    }    return shouldFlush;}
public void metron_f7716_0(String sensorType, BulkWriterResponse response)
{    timeouts.remove(sensorType);}
protected long metron_f7717_1(String sensorType, WriterConfiguration configurations)
{    int batchTimeoutSecs = configurations.getBatchTimeout(sensorType);    if (batchTimeoutSecs <= 0 || batchTimeoutSecs > maxBatchTimeout) {                batchTimeoutSecs = maxBatchTimeout;    }    return TimeUnit.SECONDS.toMillis(batchTimeoutSecs);}
public void metron_f7718_0(String sensorType, BulkMessage<MESSAGE_T> bulkWriterMessage, BulkMessageWriter<MESSAGE_T> bulkMessageWriter, WriterConfiguration configurations)
{    List<BulkMessage<MESSAGE_T>> messages = sensorMessageCache.getOrDefault(sensorType, new ArrayList<>());    sensorMessageCache.put(sensorType, messages);        if (!configurations.isEnabled(sensorType)) {                flush(sensorType, bulkMessageWriter, configurations, messages);                BulkWriterResponse response = new BulkWriterResponse();        response.addSuccess(bulkWriterMessage.getId());        onFlush(sensorType, response);    } else {        messages.add(bulkWriterMessage);        applyShouldFlush(sensorType, bulkMessageWriter, configurations, sensorMessageCache.get(sensorType));    }}
public void metron_f7720_0(BulkMessageWriter<MESSAGE_T> bulkMessageWriter, WriterConfiguration configurations)
{        for (String sensorType : new HashSet<>(sensorMessageCache.keySet())) {        applyShouldFlush(sensorType, bulkMessageWriter, configurations, sensorMessageCache.get(sensorType));    }}
public void metron_f7721_0(FlushPolicy flushPolicy)
{    this.flushPolicies.add(flushPolicy);}
private void metron_f7722_0(String sensorType, BulkMessageWriter<MESSAGE_T> bulkMessageWriter, WriterConfiguration configurations, List<BulkMessage<MESSAGE_T>> messages)
{    if (messages.size() > 0) {                for (FlushPolicy<MESSAGE_T> flushPolicy : flushPolicies) {            if (flushPolicy.shouldFlush(sensorType, configurations, messages)) {                flush(sensorType, bulkMessageWriter, configurations, messages);                break;            }        }    }}
private void metron_f7723_0(String sensorType, BulkWriterResponse response)
{    sensorMessageCache.remove(sensorType);    for (FlushPolicy flushPolicy : flushPolicies) {        flushPolicy.onFlush(sensorType, response);    }}
public String metron_f7724_0()
{    return key;}
public Object metron_f7725_1(Map<String, Object> config)
{    Object o = config.get(key);    if (o == null) {            }    return o;}
public T metron_f7726_1(Map<String, Object> config, Class<T> clazz)
{    Object o = get(config);    if (o != null) {        return ConversionUtils.convert(o, clazz);    }        return null;}
public String metron_f7727_1(final JSONObject message)
{    String transformedMessage = keys.stream().map(x -> {        Object o = message.get(x);        return o == null ? "" : o.toString();    }).collect(Collectors.joining(delim));        return transformedMessage;}
public void metron_f7728_1(String sensorName, WriterConfiguration configuration)
{    validateEnrichmentType(sensorName, configuration);    validateKeyColumns(sensorName, configuration);    String hbaseProviderImpl = Configurations.HBASE_PROVIDER.getAndConvert(configuration.getSensorConfig(sensorName), String.class);    if (hbaseProviderImpl != null) {        provider = ReflectionUtils.createInstance(hbaseProviderImpl);    }    if (converter == null) {        converter = new EnrichmentConverter();    }    }
private void metron_f7729_0(String sensorName, WriterConfiguration configuration)
{    Map<String, Object> sensorConfig = configuration.getSensorConfig(sensorName);    Object enrichmentTypeObj = Configurations.ENRICHMENT_TYPE.get(sensorConfig);    if (enrichmentTypeObj == null) {        throw new IllegalArgumentException(String.format("%s must be provided", Configurations.ENRICHMENT_TYPE.getKey()));    }    if (!(enrichmentTypeObj instanceof String)) {        throw new IllegalArgumentException(String.format("%s must be a string", Configurations.ENRICHMENT_TYPE.getKey()));    }    String enrichmentType = enrichmentTypeObj.toString();    if (enrichmentType.trim().isEmpty()) {        throw new IllegalArgumentException(String.format("%s must not be an empty string", Configurations.ENRICHMENT_TYPE.getKey()));    }}
private void metron_f7730_0(String sensorName, WriterConfiguration configuration)
{    Map<String, Object> sensorConfig = configuration.getSensorConfig(sensorName);    Object keyColumnsObj = Configurations.KEY_COLUMNS.get(sensorConfig);    try {        List<String> keyColumns = getColumns(keyColumnsObj, true);        if (keyColumns == null || keyColumns.isEmpty()) {            throw new IllegalArgumentException(String.format("%s must be provided", Configurations.KEY_COLUMNS.getKey()));        }    } catch (RuntimeException ex) {        throw new IllegalArgumentException(ex.getMessage(), ex);    }}
private String metron_f7731_0(Object object)
{    return object == null ? "" : object.getClass().getName();}
public void metron_f7732_0(Map stormConf, WriterConfiguration configuration) throws Exception
{    if (converter == null) {        converter = new EnrichmentConverter();    }}
protected synchronized TableProvider metron_f7733_0()
{    if (provider == null) {        provider = new HTableProvider();    }    return provider;}
public Table metron_f7734_1(String tableName, String cf) throws IOException
{    synchronized (this) {        boolean isInitial = this.tableName == null || this.cf == null;        boolean isValid = tableName != null && cf != null;        if (isInitial || (isValid && (!this.tableName.equals(tableName) || !this.cf.equals(cf)))) {            Configuration conf = HBaseConfiguration.create();                        if (table != null) {                table.close();            }                        table = getProvider().getTable(conf, tableName);            this.tableName = tableName;            this.cf = cf;        }        return table;    }}
public Table metron_f7735_0(Map<String, Object> config) throws IOException
{    return getTable(Configurations.HBASE_TABLE.getAndConvert(config, String.class), Configurations.HBASE_CF.getAndConvert(config, String.class));}
private List<String> metron_f7736_1(Object keyColumnsObj, boolean allowNull)
{    Object o = keyColumnsObj;    if (allowNull && keyColumnsObj == null) {                return Collections.emptyList();    }    if (o instanceof String) {                return ImmutableList.of(o.toString());    } else if (o instanceof List) {        List<String> keyCols = new ArrayList<>();        for (Object key : (List) o) {            if (key == null) {                throw new IllegalArgumentException("Column name must not be null");            }            String columnName = key.toString();            if (columnName.trim().isEmpty()) {                throw new IllegalArgumentException("Column name must not be empty");            }            keyCols.add(columnName);        }                return keyCols;    } else {        throw new RuntimeException("Unable to get columns: " + o);    }}
private KeyTransformer metron_f7737_1(Map<String, Object> config)
{    Object o = Configurations.KEY_COLUMNS.get(config);    KeyTransformer transformer = null;    if (keyTransformer != null && keyTransformer.getKey() == o) {        transformer = keyTransformer.getValue();                return transformer;    } else {        List<String> keys = getColumns(o, false);        Object delimObj = Configurations.KEY_DELIM.get(config);        String delim = (delimObj == null || !(delimObj instanceof String)) ? null : delimObj.toString();        KeyTransformer newtransformer = new KeyTransformer(keys, delim);        keyTransformer = new AbstractMap.SimpleEntry<>(o, newtransformer);                return newtransformer;    }}
private EnrichmentValue metron_f7738_0(JSONObject message, Set<String> keyColumns, Set<String> valueColumns)
{    Map<String, Object> metadata = new HashMap<>();    if (valueColumns == null || valueColumns.isEmpty()) {        for (Object kv : message.entrySet()) {            Map.Entry<Object, Object> entry = (Map.Entry<Object, Object>) kv;            if (!keyColumns.contains(entry.getKey())) {                addMetadataEntry(metadata, entry);            }        }        return new EnrichmentValue(metadata);    } else {        for (Object kv : message.entrySet()) {            Map.Entry<Object, Object> entry = (Map.Entry<Object, Object>) kv;            if (valueColumns.contains(entry.getKey())) {                addMetadataEntry(metadata, entry);            }        }        return new EnrichmentValue(metadata);    }}
private void metron_f7739_1(Map<String, Object> metadata, Map.Entry<Object, Object> entry)
{    String key = entry.getKey().toString();    Object value = entry.getValue();        metadata.put(key, value);}
private EnrichmentKey metron_f7740_0(JSONObject message, KeyTransformer transformer, String enrichmentType)
{    if (enrichmentType != null) {        return new EnrichmentKey(enrichmentType, transformer.transform(message));    } else {        return null;    }}
public BulkWriterResponse metron_f7741_1(String sensorType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages) throws Exception
{    Map<String, Object> sensorConfig = configurations.getSensorConfig(sensorType);    Table table = getTable(sensorConfig);    KeyTransformer transformer = getTransformer(sensorConfig);    Object enrichmentTypeObj = Configurations.ENRICHMENT_TYPE.get(sensorConfig);    String enrichmentType = enrichmentTypeObj == null ? null : enrichmentTypeObj.toString();    Set<String> valueColumns = new HashSet<>(getColumns(Configurations.VALUE_COLUMNS.get(sensorConfig), true));    List<Put> puts = new ArrayList<>();    for (BulkMessage<JSONObject> bulkWriterMessage : messages) {        EnrichmentKey key = getKey(bulkWriterMessage.getMessage(), transformer, enrichmentType);        EnrichmentValue value = getValue(bulkWriterMessage.getMessage(), transformer.keySet, valueColumns);        if (key == null || value == null) {            continue;        }        Put put = converter.toPut(this.cf, key, value);        if (put != null) {                        puts.add(put);        }    }    Set<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toSet());    BulkWriterResponse response = new BulkWriterResponse();    try {        table.put(puts);    } catch (Exception e) {        response.addAllErrors(e, ids);        return response;    }        response.addAllSuccesses(ids);    return response;}
public String metron_f7742_0()
{    return "hbaseEnrichment";}
public void metron_f7743_0() throws Exception
{    synchronized (this) {        if (table != null) {            table.close();        }    }}
public Object metron_f7744_0(Optional<String> configPrefix, Map<String, Object> config)
{    return config.get(StringUtils.join(".", configPrefix, Optional.of(key)));}
public T metron_f7745_0(Optional<String> configPrefix, Map<String, Object> config, Class<T> clazz)
{    Object o = get(configPrefix, config);    if (o != null) {        return ConversionUtils.convert(o, clazz);    }    return null;}
public KafkaWriter metron_f7746_0(String brokerUrl)
{    this.brokerUrl = brokerUrl;    return this;}
public KafkaWriter metron_f7747_0(String zkQuorum)
{    this.zkQuorum = zkQuorum;    return this;}
public KafkaWriter metron_f7748_0(String keySerializer)
{    this.keySerializer = keySerializer;    return this;}
public KafkaWriter metron_f7749_0(String valueSerializer)
{    this.valueSerializer = valueSerializer;    return this;}
public KafkaWriter metron_f7750_0(Integer requiredAcks)
{    this.requiredAcks = requiredAcks;    return this;}
public KafkaWriter metron_f7751_0(String topic)
{    this.kafkaTopic = topic;    return this;}
public KafkaWriter metron_f7752_0(String topicField)
{    this.kafkaTopicField = topicField;    return this;}
public KafkaWriter metron_f7753_0(String prefix)
{    this.configPrefix = prefix;    return this;}
public KafkaWriter metron_f7754_0(Map<String, Object> extraConfigs)
{    if (producerConfigs == null) {        this.producerConfigs = extraConfigs;    } else if (extraConfigs != null) {        producerConfigs.putAll(extraConfigs);    }    return this;}
public Optional<String> metron_f7755_0()
{    return Optional.ofNullable(configPrefix);}
protected void metron_f7756_0(KafkaProducer kafkaProducer)
{    this.kafkaProducer = kafkaProducer;}
public void metron_f7757_0(String sensorName, WriterConfiguration configuration)
{    Map<String, Object> configMap = configuration.getSensorConfig(sensorName);    String brokerUrl = Configurations.BROKER.getAndConvert(getConfigPrefix(), configMap, String.class);    if (brokerUrl != null) {        this.brokerUrl = brokerUrl;    }    String zkQuorum = Configurations.ZK_QUORUM.getAndConvert(getConfigPrefix(), configMap, String.class);    if (zkQuorum != null) {        withZkQuorum(zkQuorum);    }    String keySerializer = Configurations.KEY_SERIALIZER.getAndConvert(getConfigPrefix(), configMap, String.class);    if (keySerializer != null) {        withKeySerializer(keySerializer);    }    String valueSerializer = Configurations.VALUE_SERIALIZER.getAndConvert(getConfigPrefix(), configMap, String.class);    if (valueSerializer != null) {        withValueSerializer(keySerializer);    }    Integer requiredAcks = Configurations.REQUIRED_ACKS.getAndConvert(getConfigPrefix(), configMap, Integer.class);    if (requiredAcks != null) {        withRequiredAcks(requiredAcks);    }    String topic = Configurations.TOPIC.getAndConvert(getConfigPrefix(), configMap, String.class);    if (topic != null) {        withTopic(topic);    }    String topicField = Configurations.TOPIC_FIELD.getAndConvert(getConfigPrefix(), configMap, String.class);    if (topicField != null) {        withTopicField(topicField);    }    Map<String, Object> producerConfigs = (Map) Configurations.PRODUCER_CONFIGS.get(getConfigPrefix(), configMap);    if (producerConfigs != null) {        withProducerConfigs(producerConfigs);    }}
public void metron_f7758_0(Map stormConf, WriterConfiguration config) throws Exception
{    if (this.zkQuorum != null && this.brokerUrl == null) {        try {            this.brokerUrl = Joiner.on(",").join(KafkaUtils.INSTANCE.getBrokersFromZookeeper(this.zkQuorum));        } catch (Exception e) {            throw new IllegalStateException("Cannot read kafka brokers from zookeeper and you didn't specify them, giving up!", e);        }    }    this.kafkaProducer = new KafkaProducer<>(createProducerConfigs());}
public Map<String, Object> metron_f7759_0()
{    Map<String, Object> producerConfig = new HashMap<>();    producerConfig.put("bootstrap.servers", brokerUrl);    producerConfig.put("key.serializer", keySerializer);    producerConfig.put("value.serializer", valueSerializer);    producerConfig.put("request.required.acks", requiredAcks);    producerConfig.put(ProducerConfig.BATCH_SIZE_CONFIG, DEFAULT_BATCH_SIZE);    producerConfig.putAll(producerConfigs == null ? new HashMap<>() : producerConfigs);    producerConfig = KafkaUtils.INSTANCE.normalizeProtocol(producerConfig);    return producerConfig;}
public Optional<String> metron_f7760_1(JSONObject message)
{    String t = null;    if (kafkaTopicField != null) {        t = (String) message.get(kafkaTopicField);            } else {        t = kafkaTopic;            }    return Optional.ofNullable(t);}
public BulkWriterResponse metron_f7761_1(String sensorType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages)
{    BulkWriterResponse writerResponse = new BulkWriterResponse();    List<Map.Entry<MessageId, Future>> results = new ArrayList<>();    for (BulkMessage<JSONObject> bulkWriterMessage : messages) {        MessageId messageId = bulkWriterMessage.getId();        JSONObject message = bulkWriterMessage.getMessage();        String jsonMessage;        try {            jsonMessage = message.toJSONString();        } catch (Throwable t) {            writerResponse.addError(t, messageId);            continue;        }        Optional<String> topic = getKafkaTopic(message);        if (topic.isPresent()) {            Future future = kafkaProducer.send(new ProducerRecord<String, String>(topic.get(), jsonMessage));                        results.add(new AbstractMap.SimpleEntry<>(messageId, future));        } else {                    }    }    Collection<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toList());    try {                kafkaProducer.flush();    } catch (InterruptException e) {        writerResponse.addAllErrors(e, ids);        return writerResponse;    }    for (Map.Entry<MessageId, Future> kv : results) {        try {            kv.getValue().get();            writerResponse.addSuccess(kv.getKey());        } catch (Exception e) {            writerResponse.addError(e, kv.getKey());        }    }    return writerResponse;}
public String metron_f7762_0()
{    return "kafka";}
public void metron_f7763_0() throws Exception
{    kafkaProducer.close();}
public int metron_f7764_0()
{    return min;}
public int metron_f7765_0()
{    return max;}
public Void metron_f7766_0(Void aVoid)
{    int sleepMs = ThreadLocalRandom.current().nextInt(min, max + 1);    try {        Thread.sleep(sleepMs);    } catch (InterruptedException e) {    }    return null;}
public int metron_f7767_0()
{    return latency;}
public Void metron_f7768_0(Void aVoid)
{    if (latency > 0) {        try {            Thread.sleep(latency);        } catch (InterruptedException e) {        }    }    return null;}
public NoopWriter metron_f7769_0(String sleepConfig)
{    sleepFunction = getSleepFunction(sleepConfig);    return this;}
private Function<Void, Void> metron_f7770_0(String sleepConfig)
{    String usageMessage = "Unexpected: " + sleepConfig + " Expected value: integer for a fixed sleep duration in milliseconds (e.g. 10) " + "or a range of latencies separated by a comma (e.g. \"10, 20\") to sleep a random amount in that range.";    try {        if (sleepConfig.contains(",")) {                        Iterable<String> it = Splitter.on(',').split(sleepConfig);            Integer min = ConversionUtils.convert(Iterables.getFirst(it, "").trim(), Integer.class);            Integer max = ConversionUtils.convert(Iterables.getLast(it, "").trim(), Integer.class);            if (min != null && max != null) {                return new RandomLatency(min, max);            }        } else {                        Integer latency = ConversionUtils.convert(sleepConfig.trim(), Integer.class);            if (latency != null) {                return new FixedLatency(latency);            }        }    } catch (Throwable t) {        throw new IllegalArgumentException(usageMessage, t);    }    throw new IllegalArgumentException(usageMessage);}
public void metron_f7771_0(String sensorName, WriterConfiguration configuration)
{    Map<String, Object> config = configuration.getSensorConfig(sensorName);    if (config != null) {        Object noopLatency = config.get("noopLatency");        if (noopLatency != null) {            sleepFunction = getSleepFunction(noopLatency.toString());        }    }}
public void metron_f7772_0(Map stormConf, WriterConfiguration config) throws Exception
{}
public BulkWriterResponse metron_f7773_0(String sensorType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages) throws Exception
{    if (sleepFunction != null) {        sleepFunction.apply(null);    }    Set<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toSet());    BulkWriterResponse response = new BulkWriterResponse();    response.addAllSuccesses(ids);    return response;}
public String metron_f7774_0()
{    return "noop";}
public void metron_f7775_0() throws Exception
{}
public void metron_f7776_0(Map stormConf, WriterConfiguration config) throws Exception
{    messageWriter.init();}
public BulkWriterResponse metron_f7777_0(String sensorType, WriterConfiguration configurations, List<BulkMessage<MESSAGE_T>> messages) throws Exception
{    Set<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toSet());    BulkWriterResponse response = new BulkWriterResponse();    if (messages.size() > 1) {        response.addAllErrors(new IllegalStateException("WriterToBulkWriter expects a batch of exactly 1"), ids);        return response;    }    try {        messageWriter.write(sensorType, configurations, Iterables.getFirst(messages, null));    } catch (Exception e) {        response.addAllErrors(e, ids);        return response;    }    response.addAllSuccesses(ids);    return response;}
public String metron_f7778_0()
{    return messageWriter.getName();}
public void metron_f7779_0() throws Exception
{    messageWriter.close();}
public void metron_f7780_0()
{    when(configurations.getBatchSize(sensorType)).thenReturn(2);}
public void metron_f7781_0()
{    BatchSizePolicy<JSONObject> batchSizePolicy = new BatchSizePolicy<>();    messages.add(new BulkMessage<>("message1", new JSONObject()));    messages.add(new BulkMessage<>("message2", new JSONObject()));    assertTrue(batchSizePolicy.shouldFlush(sensorType, configurations, messages));}
public void metron_f7782_0()
{    BatchSizePolicy<JSONObject> batchSizePolicy = new BatchSizePolicy<>();    messages.add(new BulkMessage<>("message1", new JSONObject()));    assertFalse(batchSizePolicy.shouldFlush(sensorType, configurations, messages));}
public void metron_f7783_0()
{    BatchSizePolicy<JSONObject> batchSizePolicy = new BatchSizePolicy<>();    messages.add(new BulkMessage<>("message1", new JSONObject()));    messages.add(new BulkMessage<>("message2", new JSONObject()));    messages.add(new BulkMessage<>("message3", new JSONObject()));    assertTrue(batchSizePolicy.shouldFlush(sensorType, configurations, messages));}
public void metron_f7784_0()
{    Clock clock = mock(Clock.class);    BatchTimeoutPolicy batchTimeoutPolicy = new BatchTimeoutPolicy<>(maxBatchTimeout, clock);    when(configurations.getBatchTimeout(sensor1)).thenReturn(1);    when(configurations.getBatchTimeout(sensor2)).thenReturn(2);        when(clock.currentTimeMillis()).thenReturn(0L);    assertFalse(batchTimeoutPolicy.shouldFlush(sensor1, configurations, messages));    assertFalse(batchTimeoutPolicy.shouldFlush(sensor2, configurations, messages));        when(clock.currentTimeMillis()).thenReturn(999L);    assertFalse(batchTimeoutPolicy.shouldFlush(sensor1, configurations, messages));    assertFalse(batchTimeoutPolicy.shouldFlush(sensor2, configurations, messages));        when(clock.currentTimeMillis()).thenReturn(1000L);    assertTrue(batchTimeoutPolicy.shouldFlush(sensor1, configurations, messages));    assertFalse(batchTimeoutPolicy.shouldFlush(sensor2, configurations, messages));        when(clock.currentTimeMillis()).thenReturn(2000L);    assertTrue(batchTimeoutPolicy.shouldFlush(sensor2, configurations, messages));}
public void metron_f7785_0()
{    Clock clock = mock(Clock.class);    BatchTimeoutPolicy batchTimeoutPolicy = new BatchTimeoutPolicy(maxBatchTimeout, clock);    when(configurations.getBatchTimeout(sensor1)).thenReturn(1);        when(clock.currentTimeMillis()).thenReturn(0L);    assertFalse(batchTimeoutPolicy.shouldFlush(sensor1, configurations, messages));    batchTimeoutPolicy.onFlush(sensor1, new BulkWriterResponse());        when(clock.currentTimeMillis()).thenReturn(1000L);    assertFalse(batchTimeoutPolicy.shouldFlush(sensor1, configurations, messages));        when(clock.currentTimeMillis()).thenReturn(2000L);    assertTrue(batchTimeoutPolicy.shouldFlush(sensor1, configurations, messages));}
public void metron_f7786_0()
{    BatchTimeoutPolicy batchTimeoutPolicy = new BatchTimeoutPolicy(maxBatchTimeout);    when(configurations.getBatchTimeout(sensor1)).thenReturn(5);    assertEquals(5000L, batchTimeoutPolicy.getBatchTimeout(sensor1, configurations));}
public void metron_f7787_0()
{    BatchTimeoutPolicy batchTimeoutPolicy = new BatchTimeoutPolicy(maxBatchTimeout);    when(configurations.getBatchTimeout(sensor1)).thenReturn(0);    assertEquals(maxBatchTimeout * 1000, batchTimeoutPolicy.getBatchTimeout(sensor1, configurations));}
public void metron_f7788_0()
{    MockitoAnnotations.initMocks(this);    message1.put("value", "message1");    message2.put("value", "message2");    messageIds = Arrays.asList(messageId1, messageId2);    messages = new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage<>(messageId1, message1));            add(new BulkMessage<>(messageId2, message2));        }    };    when(configurations.isEnabled(any())).thenReturn(true);}
public void metron_f7789_0() throws Exception
{    BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(Collections.singletonList(flushPolicy));    BulkWriterResponse response = new BulkWriterResponse();    response.addAllSuccesses(messageIds);    when(bulkMessageWriter.write(sensorType, configurations, messages)).thenReturn(response);    bulkWriterComponent.write(sensorType, messages.get(0), bulkMessageWriter, configurations);    verify(bulkMessageWriter, times(0)).write(eq(sensorType), eq(configurations), any());    verify(flushPolicy, times(1)).shouldFlush(sensorType, configurations, messages.subList(0, 1));    verify(flushPolicy, times(0)).onFlush(any(), any());    reset(flushPolicy);    when(flushPolicy.shouldFlush(sensorType, configurations, messages)).thenReturn(true);    bulkWriterComponent.write(sensorType, messages.get(1), bulkMessageWriter, configurations);    BulkWriterResponse expectedResponse = new BulkWriterResponse();    expectedResponse.addAllSuccesses(messageIds);    verify(bulkMessageWriter, times(1)).write(sensorType, configurations, Arrays.asList(new BulkMessage<>(messageId1, message1), new BulkMessage<>(messageId2, message2)));    verify(flushPolicy, times(1)).shouldFlush(sensorType, configurations, messages);    verify(flushPolicy, times(1)).onFlush(sensorType, expectedResponse);    verifyNoMoreInteractions(bulkMessageWriter, flushPolicy);}
public void metron_f7790_0() throws Exception
{    BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(Collections.singletonList(flushPolicy));    BulkMessage<JSONObject> beforeDisabledMessage = messages.get(0);    BulkMessage<JSONObject> afterDisabledMessage = messages.get(1);    BulkWriterResponse beforeDisabledResponse = new BulkWriterResponse();    beforeDisabledResponse.addSuccess(beforeDisabledMessage.getId());    BulkWriterResponse afterDisabledResponse = new BulkWriterResponse();    afterDisabledResponse.addSuccess(afterDisabledMessage.getId());    when(bulkMessageWriter.write(sensorType, configurations, Collections.singletonList(messages.get(0)))).thenReturn(beforeDisabledResponse);    bulkWriterComponent.write(sensorType, beforeDisabledMessage, bulkMessageWriter, configurations);    verify(bulkMessageWriter, times(0)).write(eq(sensorType), eq(configurations), any());    verify(flushPolicy, times(1)).shouldFlush(sensorType, configurations, messages.subList(0, 1));    verify(flushPolicy, times(0)).onFlush(any(), any());    when(configurations.isEnabled(sensorType)).thenReturn(false);    bulkWriterComponent.write(sensorType, messages.get(1), bulkMessageWriter, configurations);    verify(bulkMessageWriter, times(1)).write(sensorType, configurations, Collections.singletonList(messages.get(0)));    verify(flushPolicy, times(1)).onFlush(sensorType, beforeDisabledResponse);    verify(flushPolicy, times(1)).onFlush(sensorType, afterDisabledResponse);    verifyNoMoreInteractions(bulkMessageWriter, flushPolicy);}
public void metron_f7791_0() throws Exception
{    BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(Collections.singletonList(flushPolicy));    Throwable e = new Exception("test exception");    BulkWriterResponse response = new BulkWriterResponse();    response.addAllErrors(e, messageIds);    when(bulkMessageWriter.write(sensorType, configurations, messages)).thenReturn(response);    bulkWriterComponent.write(sensorType, messages.get(0), bulkMessageWriter, configurations);    verify(bulkMessageWriter, times(0)).write(eq(sensorType), eq(configurations), any());    verify(flushPolicy, times(1)).shouldFlush(sensorType, configurations, messages.subList(0, 1));    verify(flushPolicy, times(0)).onFlush(any(), any());    reset(flushPolicy);    when(flushPolicy.shouldFlush(sensorType, configurations, messages)).thenReturn(true);    bulkWriterComponent.write(sensorType, messages.get(1), bulkMessageWriter, configurations);    BulkWriterResponse expectedErrorResponse = new BulkWriterResponse();    expectedErrorResponse.addAllErrors(e, messageIds);    verify(bulkMessageWriter, times(1)).write(sensorType, configurations, messages);    verify(flushPolicy, times(1)).shouldFlush(sensorType, configurations, messages);    verify(flushPolicy, times(1)).onFlush(sensorType, expectedErrorResponse);    verifyNoMoreInteractions(bulkMessageWriter, flushPolicy);}
public void metron_f7792_0() throws Exception
{    BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(Collections.singletonList(flushPolicy));    Throwable e = new Exception("test exception");    BulkWriterResponse response = new BulkWriterResponse();    response.addAllErrors(e, messageIds);    when(bulkMessageWriter.write(sensorType, configurations, messages)).thenThrow(e);    bulkWriterComponent.write(sensorType, messages.get(0), bulkMessageWriter, configurations);    verify(bulkMessageWriter, times(0)).write(eq(sensorType), eq(configurations), any());    verify(flushPolicy, times(1)).shouldFlush(sensorType, configurations, messages.subList(0, 1));    verify(flushPolicy, times(0)).onFlush(any(), any());    reset(flushPolicy);    when(flushPolicy.shouldFlush(sensorType, configurations, messages)).thenReturn(true);    bulkWriterComponent.write(sensorType, messages.get(1), bulkMessageWriter, configurations);    BulkWriterResponse expectedErrorResponse = new BulkWriterResponse();    expectedErrorResponse.addAllErrors(e, messageIds);    verify(bulkMessageWriter, times(1)).write(sensorType, configurations, messages);    verify(flushPolicy, times(1)).shouldFlush(sensorType, configurations, messages);    verify(flushPolicy, times(1)).onFlush(sensorType, expectedErrorResponse);    verifyNoMoreInteractions(flushPolicy);}
public void metron_f7793_0() throws Exception
{    BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(Collections.singletonList(flushPolicy));    BulkMessageWriter<JSONObject> bulkMessageWriter = mock(BulkMessageWriter.class);    MessageId successId = new MessageId("successId");    MessageId errorId = new MessageId("errorId");    MessageId missingId = new MessageId("missingId");    JSONObject successMessage = new JSONObject();    successMessage.put("name", "success");    JSONObject errorMessage = new JSONObject();    errorMessage.put("name", "error");    JSONObject missingMessage = new JSONObject();    missingMessage.put("name", "missing");    List<BulkMessage<JSONObject>> allMessages = new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage<>(successId, successMessage));            add(new BulkMessage<>(errorId, errorMessage));            add(new BulkMessage<>(missingId, missingMessage));        }    };    BulkWriterResponse bulkWriterResponse = new BulkWriterResponse();    bulkWriterResponse.addSuccess(successId);    Throwable throwable = mock(Throwable.class);    bulkWriterResponse.addError(throwable, errorId);    when(bulkMessageWriter.write(sensorType, configurations, allMessages)).thenReturn(bulkWriterResponse);    bulkWriterComponent.flush(sensorType, bulkMessageWriter, configurations, allMessages);    BulkWriterResponse expectedResponse = new BulkWriterResponse();    expectedResponse.addSuccess(successId);    expectedResponse.addError(throwable, errorId);    expectedResponse.addSuccess(missingId);    verify(flushPolicy, times(1)).onFlush(sensorType, expectedResponse);    verifyNoMoreInteractions(flushPolicy);}
public void metron_f7794_0()
{    BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(Collections.singletonList(flushPolicy));    bulkWriterComponent.write("sensor1", messages.get(0), bulkMessageWriter, configurations);    bulkWriterComponent.write("sensor2", messages.get(1), bulkMessageWriter, configurations);    reset(flushPolicy);    bulkWriterComponent.flushAll(bulkMessageWriter, configurations);    verify(flushPolicy, times(1)).shouldFlush("sensor1", configurations, messages.subList(0, 1));    verify(flushPolicy, times(1)).shouldFlush("sensor2", configurations, messages.subList(1, 2));    verifyNoMoreInteractions(flushPolicy);}
public void metron_f7795_0()
{    MockHBaseTableProvider.addToCache(TABLE_NAME, TABLE_CF);}
public void metron_f7796_0() throws Exception
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>(BASE_WRITER_CONFIG) {        {            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), "ip");        }    });    writer.configure(sensorType, configuration);    writer.write(SENSOR_TYPE, configuration, new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage<>("messageId", new JSONObject(ImmutableMap.of("ip", "localhost", "user", "cstella", "foo", "bar"))));        }    });    List<LookupKV<EnrichmentKey, EnrichmentValue>> values = getValues();    Assert.assertEquals(1, values.size());    Assert.assertEquals("localhost", values.get(0).getKey().indicator);    Assert.assertEquals("cstella", values.get(0).getValue().getMetadata().get("user"));    Assert.assertEquals("bar", values.get(0).getValue().getMetadata().get("foo"));    Assert.assertEquals(2, values.get(0).getValue().getMetadata().size());}
public void metron_f7797_0() throws Exception
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>(BASE_WRITER_CONFIG) {        {            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), "ip");            put(SimpleHbaseEnrichmentWriter.Configurations.VALUE_COLUMNS.getKey(), "user");        }    });    writer.configure(sensorType, configuration);    writer.write(SENSOR_TYPE, configuration, new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage<>("messageId", new JSONObject(ImmutableMap.of("ip", "localhost", "user", "cstella", "foo", "bar"))));        }    });    List<LookupKV<EnrichmentKey, EnrichmentValue>> values = getValues();    Assert.assertEquals(1, values.size());    Assert.assertEquals("localhost", values.get(0).getKey().indicator);    Assert.assertEquals("cstella", values.get(0).getValue().getMetadata().get("user"));    Assert.assertNull(values.get(0).getValue().getMetadata().get("foo"));    Assert.assertEquals(1, values.get(0).getValue().getMetadata().size());}
public void metron_f7798_0() throws Exception
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>(BASE_WRITER_CONFIG) {        {            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), "ip");            put(SimpleHbaseEnrichmentWriter.Configurations.VALUE_COLUMNS.getKey(), ImmutableList.of("user", "ip"));        }    });    writer.configure(sensorType, configuration);    writer.write(SENSOR_TYPE, configuration, new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage<>("messageId", new JSONObject(ImmutableMap.of("ip", "localhost", "user", "cstella", "foo", "bar"))));        }    });    List<LookupKV<EnrichmentKey, EnrichmentValue>> values = getValues();    Assert.assertEquals(1, values.size());    Assert.assertEquals("localhost", values.get(0).getKey().indicator);    Assert.assertEquals("cstella", values.get(0).getValue().getMetadata().get("user"));    Assert.assertEquals("localhost", values.get(0).getValue().getMetadata().get("ip"));    Assert.assertNull(values.get(0).getValue().getMetadata().get("foo"));    Assert.assertEquals(2, values.get(0).getValue().getMetadata().size());}
public void metron_f7799_0()
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>() {        {            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), "ip");        }    });    try {        writer.configure(sensorType, configuration);    } catch (IllegalArgumentException ex) {        Assert.assertEquals(String.format("%s must be provided", SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey()), ex.getMessage());        throw ex;    }}
public void metron_f7800_0()
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>() {        {            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), "ip");            put(SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey(), 10);        }    });    try {        writer.configure(sensorType, configuration);    } catch (IllegalArgumentException ex) {        Assert.assertEquals(String.format("%s must be a string", SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey()), ex.getMessage());        throw ex;    }}
public void metron_f7801_0()
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>() {        {            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), "ip");            put(SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey(), "  ");        }    });    try {        writer.configure(sensorType, configuration);    } catch (IllegalArgumentException ex) {        Assert.assertEquals(String.format("%s must not be an empty string", SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey()), ex.getMessage());        throw ex;    }}
public void metron_f7802_0()
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>() {        {            put(SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey(), ENRICHMENT_TYPE);        }    });    try {        writer.configure(sensorType, configuration);    } catch (IllegalArgumentException ex) {        Assert.assertEquals(String.format("%s must be provided", SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey()), ex.getMessage());        throw ex;    }}
public void metron_f7803_0()
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>() {        {            put(SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey(), ENRICHMENT_TYPE);            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), Arrays.asList("ip", "  "));        }    });    try {        writer.configure(sensorType, configuration);    } catch (IllegalArgumentException ex) {        Assert.assertEquals("Column name must not be empty", ex.getMessage());        throw ex;    }}
public void metron_f7804_0()
{    final String sensorType = "dummy";    SimpleHbaseEnrichmentWriter writer = new SimpleHbaseEnrichmentWriter();    WriterConfiguration configuration = createConfig(1, new HashMap<String, Object>() {        {            put(SimpleHbaseEnrichmentWriter.Configurations.ENRICHMENT_TYPE.getKey(), ENRICHMENT_TYPE);            put(SimpleHbaseEnrichmentWriter.Configurations.KEY_COLUMNS.getKey(), Arrays.asList("ip", null));        }    });    try {        writer.configure(sensorType, configuration);    } catch (IllegalArgumentException ex) {        Assert.assertEquals("Column name must not be null", ex.getMessage());        throw ex;    }}
public static List<LookupKV<EnrichmentKey, EnrichmentValue>> metron_f7805_0() throws IOException
{    MockHTable table = (MockHTable) MockHBaseTableProvider.getFromCache(TABLE_NAME);    Assert.assertNotNull(table);    List<LookupKV<EnrichmentKey, EnrichmentValue>> ret = new ArrayList<>();    EnrichmentConverter converter = new EnrichmentConverter();    for (Result r : table.getScanner(Bytes.toBytes(TABLE_CF))) {        ret.add(converter.fromResult(r, TABLE_CF));    }    return ret;}
public static WriterConfiguration metron_f7806_0(final int batchSize, final Map<String, Object> sensorConfig)
{    return new WriterConfiguration() {        @Override        public int getBatchSize(String sensorName) {            return batchSize;        }        @Override        public int getBatchTimeout(String sensorName) {                        return 0;        }        @Override        public List<Integer> getAllConfiguredTimeouts() {                        return new ArrayList<>();        }        @Override        public String getIndex(String sensorName) {            return SENSOR_TYPE;        }        @Override        public boolean isEnabled(String sensorName) {            return true;        }        @Override        public Map<String, Object> getSensorConfig(String sensorName) {            return sensorConfig;        }        @Override        public Map<String, Object> getGlobalConfig() {            return null;        }        @Override        public boolean isDefault(String sensorName) {            return false;        }        @Override        public String getFieldNameConverter(String sensorName) {            return null;        }    };}
public int metron_f7807_0(String sensorName)
{    return batchSize;}
public int metron_f7808_0(String sensorName)
{        return 0;}
public List<Integer> metron_f7809_0()
{        return new ArrayList<>();}
public String metron_f7810_0(String sensorName)
{    return SENSOR_TYPE;}
public boolean metron_f7811_0(String sensorName)
{    return true;}
public Map<String, Object> metron_f7812_0(String sensorName)
{    return sensorConfig;}
public Map<String, Object> metron_f7813_0()
{    return null;}
public boolean metron_f7814_0(String sensorName)
{    return false;}
public String metron_f7815_0(String sensorName)
{    return null;}
public WriterConfiguration metron_f7816_0(final Map<String, Object> parserConfig)
{    ParserConfigurations configurations = new ParserConfigurations();    configurations.updateSensorParserConfig(SENSOR_TYPE, new SensorParserConfig() {        {            setParserConfig(parserConfig);        }    });    return new ParserWriterConfiguration(configurations);}
public void metron_f7817_0()
{    MockitoAnnotations.initMocks(this);}
public void metron_f7818_0() throws Exception
{    KafkaWriter writer = new KafkaWriter();    WriterConfiguration configuration = createConfiguration(new HashMap<String, Object>() {        {            put("kafka.brokerUrl", "localhost:6667");            put("kafka.topic", SENSOR_TYPE);            put("kafka.producerConfigs", ImmutableMap.of("key1", 1, "key2", "value2"));        }    });    writer.configure(SENSOR_TYPE, configuration);    Map<String, Object> producerConfigs = writer.createProducerConfigs();    assertEquals(producerConfigs.get("bootstrap.servers"), "localhost:6667");    assertEquals(producerConfigs.get("key.serializer"), "org.apache.kafka.common.serialization.StringSerializer");    assertEquals(producerConfigs.get("value.serializer"), "org.apache.kafka.common.serialization.StringSerializer");    assertEquals(producerConfigs.get("request.required.acks"), 1);    assertEquals(producerConfigs.get("key1"), 1);    assertEquals(producerConfigs.get("key2"), "value2");}
public void metron_f7819_0() throws Exception
{    KafkaWriter writer = new KafkaWriter();    writer.withConfigPrefix("prefix");    WriterConfiguration configuration = createConfiguration(new HashMap<String, Object>() {        {            put("prefix.kafka.brokerUrl", "localhost:6667");            put("prefix.kafka.topic", SENSOR_TYPE);            put("prefix.kafka.producerConfigs", ImmutableMap.of("key1", 1, "key2", "value2"));        }    });    writer.configure(SENSOR_TYPE, configuration);    Map<String, Object> producerConfigs = writer.createProducerConfigs();    assertEquals(producerConfigs.get("bootstrap.servers"), "localhost:6667");    assertEquals(producerConfigs.get("key.serializer"), "org.apache.kafka.common.serialization.StringSerializer");    assertEquals(producerConfigs.get("value.serializer"), "org.apache.kafka.common.serialization.StringSerializer");    assertEquals(producerConfigs.get("request.required.acks"), 1);    assertEquals(producerConfigs.get("key1"), 1);    assertEquals(producerConfigs.get("key2"), "value2");}
public void metron_f7820_0() throws Exception
{    KafkaWriter writer = new KafkaWriter();    WriterConfiguration configuration = createConfiguration(new HashMap<String, Object>() {        {            put("kafka.brokerUrl", "localhost:6667");            put("kafka.topic", SENSOR_TYPE);            put("kafka.topicField", "kafka_topic");            put("kafka.producerConfigs", ImmutableMap.of("key1", 1, "key2", "value2"));        }    });    writer.configure(SENSOR_TYPE, configuration);    assertEquals("metron", writer.getKafkaTopic(new JSONObject() {        {            put("kafka_topic", "metron");        }    }).get());    Assert.assertFalse(writer.getKafkaTopic(new JSONObject()).isPresent());}
public void metron_f7821_0() throws Exception
{    KafkaWriter writer = new KafkaWriter();    WriterConfiguration configuration = createConfiguration(new HashMap<String, Object>() {        {            put("kafka.brokerUrl", "localhost:6667");            put("kafka.topicField", "kafka_topic");            put("kafka.producerConfigs", ImmutableMap.of("key1", 1, "key2", "value2"));        }    });    writer.configure(SENSOR_TYPE, configuration);    assertEquals("metron", writer.getKafkaTopic(new JSONObject() {        {            put("kafka_topic", "metron");        }    }).get());    Assert.assertFalse(writer.getKafkaTopic(new JSONObject()).isPresent());}
public void metron_f7822_0() throws Exception
{    KafkaWriter writer = new KafkaWriter();    WriterConfiguration configuration = createConfiguration(new HashMap<String, Object>() {        {            put("kafka.brokerUrl", "localhost:6667");            put("kafka.producerConfigs", ImmutableMap.of("key1", 1, "key2", "value2"));        }    });    writer.configure(SENSOR_TYPE, configuration);    assertEquals(Constants.ENRICHMENT_TOPIC, writer.getKafkaTopic(new JSONObject() {        {            put("kafka_topic", "metron");        }    }).get());    Assert.assertTrue(writer.getKafkaTopic(new JSONObject()).isPresent());}
public void metron_f7823_0() throws Exception
{    KafkaWriter writer = spy(new KafkaWriter());    writer.setKafkaProducer(kafkaProducer);    List<BulkMessage<JSONObject>> messages = new ArrayList<>();    JSONObject successMessage = new JSONObject();    successMessage.put("value", "success");    JSONObject errorMessage = new JSONObject();    errorMessage.put("value", "error");    JSONObject droppedMessage = new JSONObject();    droppedMessage.put("value", "dropped");    messages.add(new BulkMessage<>("successId", successMessage));    messages.add(new BulkMessage<>("errorId", errorMessage));    messages.add(new BulkMessage<>("droppedId", droppedMessage));    doReturn(Optional.of("successTopic")).when(writer).getKafkaTopic(successMessage);    doReturn(Optional.of("errorTopic")).when(writer).getKafkaTopic(errorMessage);    doReturn(Optional.empty()).when(writer).getKafkaTopic(droppedMessage);    Future successFuture = mock(Future.class);    Future errorFuture = mock(Future.class);    ExecutionException throwable = new ExecutionException(new Exception("kafka error"));    when(kafkaProducer.send(new ProducerRecord<String, String>("errorTopic", "{\"value\":\"error\"}"))).thenReturn(errorFuture);    when(kafkaProducer.send(new ProducerRecord<String, String>("successTopic", "{\"value\":\"success\"}"))).thenReturn(successFuture);    when(errorFuture.get()).thenThrow(throwable);    BulkWriterResponse response = new BulkWriterResponse();    response.addSuccess(new MessageId("successId"));    response.addError(throwable, new MessageId("errorId"));    assertEquals(response, writer.write(SENSOR_TYPE, createConfiguration(new HashMap<>()), messages));    verify(kafkaProducer, times(1)).flush();    verify(kafkaProducer, times(1)).send(new ProducerRecord<String, String>("successTopic", "{\"value\":\"success\"}"));    verify(kafkaProducer, times(1)).send(new ProducerRecord<String, String>("errorTopic", "{\"value\":\"error\"}"));    verifyNoMoreInteractions(kafkaProducer);}
public void metron_f7824_0() throws Exception
{    KafkaWriter writer = spy(new KafkaWriter());    writer.setKafkaProducer(kafkaProducer);    List<BulkMessage<JSONObject>> messages = new ArrayList<>();    JSONObject message1 = new JSONObject();    message1.put("value", "message1");    JSONObject message2 = new JSONObject();    message2.put("value", "message2");    messages.add(new BulkMessage<>("messageId1", message1));    messages.add(new BulkMessage<>("messageId2", message2));    doReturn(Optional.of("topic1")).when(writer).getKafkaTopic(message1);    doReturn(Optional.of("topic2")).when(writer).getKafkaTopic(message2);    Future future1 = mock(Future.class);    Future future2 = mock(Future.class);    when(kafkaProducer.send(new ProducerRecord<String, String>("topic1", "{\"value\":\"message1\"}"))).thenReturn(future1);    when(kafkaProducer.send(new ProducerRecord<String, String>("topic2", "{\"value\":\"message2\"}"))).thenReturn(future2);    InterruptException throwable = new InterruptException("kafka flush exception");    doThrow(throwable).when(kafkaProducer).flush();    BulkWriterResponse response = new BulkWriterResponse();    response.addAllErrors(throwable, Arrays.asList(new MessageId("messageId1"), new MessageId("messageId2")));    assertEquals(response, writer.write(SENSOR_TYPE, createConfiguration(new HashMap<>()), messages));    verify(kafkaProducer, times(1)).flush();    verify(kafkaProducer, times(1)).send(new ProducerRecord<String, String>("topic1", "{\"value\":\"message1\"}"));    verify(kafkaProducer, times(1)).send(new ProducerRecord<String, String>("topic2", "{\"value\":\"message2\"}"));    verifyNoMoreInteractions(kafkaProducer);}
public void metron_f7825_0()
{    NoopWriter writer = new NoopWriter().withLatency("10");    Assert.assertTrue(writer.sleepFunction instanceof NoopWriter.FixedLatency);    NoopWriter.FixedLatency sleepFunction = (NoopWriter.FixedLatency) writer.sleepFunction;    Assert.assertEquals(10, sleepFunction.getLatency());}
private void metron_f7826_0(String latencyConfig, int min, int max)
{    NoopWriter writer = new NoopWriter().withLatency(latencyConfig);    Assert.assertTrue(writer.sleepFunction instanceof NoopWriter.RandomLatency);    NoopWriter.RandomLatency sleepFunction = (NoopWriter.RandomLatency) writer.sleepFunction;    Assert.assertEquals(min, sleepFunction.getMin());    Assert.assertEquals(max, sleepFunction.getMax());}
public void metron_f7827_0()
{    ensureRandomLatencyConfig("10,20", 10, 20);    ensureRandomLatencyConfig("10, 20", 10, 20);    ensureRandomLatencyConfig("10 ,20", 10, 20);    ensureRandomLatencyConfig("10 , 20", 10, 20);}
protected Map<Tuple, Collection<MessageId>> metron_f7828_0()
{    return tupleMessageMap;}
protected Map<Tuple, Set<Throwable>> metron_f7829_0()
{    return tupleErrorMap;}
public boolean metron_f7830_0(String sensorType, WriterConfiguration configurations, List<BulkMessage<MESSAGE_T>> messages)
{    return false;}
public void metron_f7831_1(String sensorType, BulkWriterResponse response)
{            Collection<Tuple> tuplesToAck = new ArrayList<>();    tupleMessageMap = tupleMessageMap.entrySet().stream().map(entry -> {        Tuple tuple = entry.getKey();        Collection<MessageId> ids = new ArrayList<>(entry.getValue());                ids.removeAll(response.getSuccesses());                response.getErrors().forEach((throwable, failedIds) -> {            if (ids.removeAll(failedIds)) {                                Set<Throwable> errorList = tupleErrorMap.getOrDefault(tuple, new HashSet<>());                tupleErrorMap.put(tuple, errorList);                errorList.add(throwable);                handleError(sensorType, throwable, tuple);            }        });        return new AbstractMap.SimpleEntry<>(tuple, ids);    }).filter(entry -> {                if (entry.getValue().isEmpty()) {            tuplesToAck.add(entry.getKey());                        return false;        }        return true;    }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));        tuplesToAck.forEach(tuple -> {        collector.ack(tuple);    });        Collection<Tuple> failedTuples = tuplesToAck.stream().filter(tuple -> tupleErrorMap.containsKey(tuple)).collect(Collectors.toList());        Set<Throwable> errorsToReport = new HashSet<>();    failedTuples.forEach(tuple -> {                errorsToReport.addAll(tupleErrorMap.remove(tuple));    });    errorsToReport.forEach(throwable -> {                collector.reportError(throwable);    });}
public void metron_f7832_1(Tuple tuple, Collection<String> messageIds)
{        tupleMessageMap.put(tuple, messageIds.stream().map(MessageId::new).collect(Collectors.toSet()));}
private void metron_f7833_0(String sensorType, Throwable e, Tuple tuple)
{    MetronError error = new MetronError().withSensorType(Collections.singleton(sensorType)).withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(e).addRawMessage(messageGetStrategy.get(tuple));    collector.emit(Constants.ERROR_STREAM, new Values(error.getJSONObject()));}
private synchronized void metron_f7834_0()
{    if (initialized)        return;    readGlobalTimeoutConfigs();    calcMaxBatchTimeoutAllowed();    readMinBatchTimeoutRequested();    calcRecommendedTickInterval();    initialized = true;}
private Map metron_f7835_0()
{    Map ret = Utils.readDefaultConfig();    String confFile = System.getProperty("storm.conf.file");    Map storm;    if (confFile == null || confFile.equals("")) {        storm = Utils.findAndReadConfigFile("storm.yaml", false);    } else {        storm = Utils.findAndReadConfigFile(confFile, true);    }    ret.putAll(storm);    return ret;}
private void metron_f7836_0()
{    Map stormConf = readStormConfigWithoutCLI();    Map cliConf = Utils.readCommandLineOpts();        baseMessageTimeoutSecs = (Integer) stormConf.getOrDefault(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS, 0);    cliMessageTimeoutSecs = (Integer) cliConf.getOrDefault(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS, 0);        Object scratch;    scratch = stormConf.getOrDefault(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, 0);    baseTickTupleFreqSecs = (scratch == null) ? 0 : (Integer) scratch;    scratch = cliConf.getOrDefault(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, 0);    cliTickTupleFreqSecs = (scratch == null) ? 0 : (Integer) scratch;}
private void metron_f7837_1()
{        effectiveMessageTimeoutSecs = (cliMessageTimeoutSecs == 0 ? baseMessageTimeoutSecs : cliMessageTimeoutSecs);    if (effectiveMessageTimeoutSecs == 0) {                maxBatchTimeoutAllowedSecs = Integer.MAX_VALUE;    } else {                                        maxBatchTimeoutAllowedSecs = effectiveMessageTimeoutSecs / 2 / batchTimeoutDivisor - 1;        if (maxBatchTimeoutAllowedSecs <= 0) {                        maxBatchTimeoutAllowedSecs = 1;        }    }}
public int metron_f7838_0()
{    if (!initialized) {        this.init();    }    return maxBatchTimeoutAllowedSecs;}
private void metron_f7839_0()
{            List<Integer> configuredTimeouts = listAllConfiguredTimeouts.get();        int minval = Integer.MAX_VALUE;    for (int k : configuredTimeouts) {        if (k < minval && k > 0)            minval = k;    }    minBatchTimeoutRequestedSecs = minval;}
private void metron_f7840_0()
{    recommendedTickIntervalSecs = Integer.min(minBatchTimeoutRequestedSecs, maxBatchTimeoutAllowedSecs);}
public int metron_f7841_1()
{    if (!initialized) {        this.init();    }        if (cliTickTupleFreqSecs > 0 && cliTickTupleFreqSecs > recommendedTickIntervalSecs) {            }    if (cliTickTupleFreqSecs > 0 && cliTickTupleFreqSecs < recommendedTickIntervalSecs) {            }    return recommendedTickIntervalSecs;}
public BulkMessageWriterBolt<CONFIG_T> metron_f7842_0(BulkMessageWriter<JSONObject> bulkMessageWriter)
{    this.bulkMessageWriter = bulkMessageWriter;    return this;}
public BulkMessageWriterBolt<CONFIG_T> metron_f7843_0(MessageWriter<JSONObject> messageWriter)
{    this.bulkMessageWriter = new WriterToBulkWriter<>(messageWriter);    return this;}
public BulkMessageWriterBolt<CONFIG_T> metron_f7844_0(String messageGetStrategyType)
{    this.messageGetStrategyType = messageGetStrategyType;    return this;}
public BulkMessageWriterBolt<CONFIG_T> metron_f7845_0(String messageGetField)
{    this.messageGetField = messageGetField;    return this;}
public BulkMessageWriterBolt<CONFIG_T> metron_f7846_0(int batchTimeoutDivisor)
{    if (batchTimeoutDivisor <= 0) {        throw new IllegalArgumentException(String.format("batchTimeoutDivisor must be positive. Value provided was %s", batchTimeoutDivisor));    }    this.batchTimeoutDivisor = batchTimeoutDivisor;    return this;}
protected void metron_f7847_0(int maxBatchTimeout)
{    this.maxBatchTimeout = maxBatchTimeout;}
public int metron_f7848_0()
{    return maxBatchTimeout;}
public BulkWriterComponent<JSONObject> metron_f7849_0()
{    return writerComponent;}
public void metron_f7850_0(BulkWriterComponent<JSONObject> component)
{    writerComponent = component;}
public Map<String, Object> metron_f7851_1()
{                Function<WriterConfiguration, WriterConfiguration> configurationXform;    if (bulkMessageWriter instanceof WriterToBulkWriter) {        configurationXform = WriterToBulkWriter.TRANSFORMATION;    } else {        configurationXform = x -> x;    }    WriterConfiguration writerconf = configurationXform.apply(getConfigurationStrategy().createWriterConfig(bulkMessageWriter, getConfigurations()));    BatchTimeoutHelper timeoutHelper = new BatchTimeoutHelper(writerconf::getAllConfiguredTimeouts, batchTimeoutDivisor);    this.requestedTickFreqSecs = timeoutHelper.getRecommendedTickInterval();        this.maxBatchTimeout = timeoutHelper.getMaxBatchTimeout();    Map<String, Object> conf = super.getComponentConfiguration();    if (conf == null) {        conf = new HashMap<String, Object>();    }    conf.put(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, requestedTickFreqSecs);        return conf;}
public void metron_f7852_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    this.collector = collector;    super.prepare(stormConf, context, collector);    if (messageGetField != null) {        messageGetStrategy = MessageGetters.valueOf(messageGetStrategyType).get(messageGetField);    } else {        messageGetStrategy = MessageGetters.valueOf(messageGetStrategyType).get();    }    if (bulkMessageWriter instanceof WriterToBulkWriter) {        configurationTransformation = WriterToBulkWriter.TRANSFORMATION;    } else {        configurationTransformation = x -> x;    }    ackTuplesPolicy = new AckTuplesPolicy(collector, messageGetStrategy);    try {        WriterConfiguration writerconf = configurationTransformation.apply(getConfigurationStrategy().createWriterConfig(bulkMessageWriter, getConfigurations()));        if (maxBatchTimeout == 0) {                                    BatchTimeoutHelper timeoutHelper = new BatchTimeoutHelper(writerconf::getAllConfiguredTimeouts, batchTimeoutDivisor);            maxBatchTimeout = timeoutHelper.getMaxBatchTimeout();        }        BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(maxBatchTimeout);        bulkWriterComponent.addFlushPolicy(ackTuplesPolicy);        setWriterComponent(bulkWriterComponent);        bulkMessageWriter.init(stormConf, writerconf);        if (bulkMessageWriter instanceof HdfsWriter) {            ((HdfsWriter) bulkMessageWriter).initFileNameFormat(context);        }    } catch (Exception e) {        throw new RuntimeException(e);    }}
public void metron_f7853_0(Map stormConf, TopologyContext context, OutputCollector collector, Clock clock)
{    prepare(stormConf, context, collector);    BulkWriterComponent<JSONObject> bulkWriterComponent = new BulkWriterComponent<>(maxBatchTimeout, clock);    bulkWriterComponent.addFlushPolicy(ackTuplesPolicy);    setWriterComponent(bulkWriterComponent);}
public void metron_f7854_1(Tuple tuple)
{    if (isTick(tuple)) {        try {            if (!(bulkMessageWriter instanceof WriterToBulkWriter)) {                                                getWriterComponent().flushAll(bulkMessageWriter, configurationTransformation.apply(getConfigurationStrategy().createWriterConfig(bulkMessageWriter, getConfigurations())));            }        } catch (Exception e) {            throw new RuntimeException("This should have been caught in the writerComponent.  If you see this, file a JIRA", e);        } finally {            collector.ack(tuple);        }        return;    }    try {        JSONObject message = getMessage(tuple);        if (message == null) {            handleMissingMessage(tuple);            return;        }        String sensorType = MessageUtils.getSensorType(message);        if (sensorType == null) {            handleMissingSensorType(tuple, message);            return;        }        LOG.trace("Writing enrichment message: {}", message);        WriterConfiguration writerConfiguration = configurationTransformation.apply(getConfigurationStrategy().createWriterConfig(bulkMessageWriter, getConfigurations()));        if (writerConfiguration.isDefault(sensorType)) {                        collector.reportError(new Exception("WARNING: Default and (likely) unoptimized writer config used for " + bulkMessageWriter.getName() + " writer and sensor " + sensorType));        }        String messagesId = MessageUtils.getGuid(message);        ackTuplesPolicy.addTupleMessageIds(tuple, Collections.singleton(messagesId));        getWriterComponent().write(sensorType, new BulkMessage<>(messagesId, message), bulkMessageWriter, writerConfiguration);    } catch (Exception e) {        throw new RuntimeException("This should have been caught in the writerComponent.  If you see this, file a JIRA", e);    }}
private JSONObject metron_f7855_1(Tuple tuple)
{    JSONObject message = null;    try {        message = (JSONObject) messageGetStrategy.get(tuple);    } catch (Throwable e) {            }    return message;}
public void metron_f7858_0(OutputFieldsDeclarer declarer)
{    declarer.declareStream(Constants.ERROR_STREAM, new Fields("message"));}
public SyncPolicy metron_f7859_0(String sensor, WriterConfiguration config)
{    try {                                                                        syncPolicy.reset();        byte[] serializedForm = SerDeUtils.toBytes(syncPolicy);        return SerDeUtils.fromBytes(serializedForm, SyncPolicy.class);    } catch (Exception e) {        throw new IllegalStateException(e.getMessage(), e);    }}
public HdfsWriter metron_f7860_0(FileNameFormat fileNameFormat)
{    this.fileNameFormat = fileNameFormat;    return this;}
public HdfsWriter metron_f7861_0(SyncPolicy syncPolicy)
{    this.syncPolicy = syncPolicy;    return this;}
public HdfsWriter metron_f7862_0(FileRotationPolicy rotationPolicy)
{    this.rotationPolicy = rotationPolicy;    return this;}
public HdfsWriter metron_f7863_0(RotationAction action)
{    this.rotationActions.add(action);    return this;}
public HdfsWriter metron_f7864_0(int maxOpenFiles)
{    this.maxOpenFiles = maxOpenFiles;    return this;}
public void metron_f7865_1(Map stormConfig, WriterConfiguration configurations)
{    this.stormConfig = stormConfig;    this.stellarProcessor = new StellarProcessor();    if (syncPolicy != null) {                        syncPolicyCreator = new ClonedSyncPolicyCreator(syncPolicy);    } else {                        syncPolicyCreator = (source, config) -> new CountSyncPolicy(config == null ? 1 : config.getBatchSize(source));    }}
public void metron_f7866_0(TopologyContext topologyContext)
{    this.fileNameFormat.prepare(stormConfig, topologyContext);}
public BulkWriterResponse metron_f7867_1(String sensorType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages) throws Exception
{    BulkWriterResponse response = new BulkWriterResponse();    Set<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toSet());        for (BulkMessage<JSONObject> bulkWriterMessage : messages) {        JSONObject message = bulkWriterMessage.getMessage();        String path = getHdfsPathExtension(sensorType, (String) configurations.getSensorConfig(sensorType).getOrDefault(IndexingConfigurations.OUTPUT_PATH_FUNCTION_CONF, ""), message);        try {            LOG.trace("Writing message {} to path: {}", () -> message.toJSONString(), () -> path);            SourceHandler handler = getSourceHandler(sensorType, path, configurations);            handler.handle(message, sensorType, configurations, syncPolicyCreator);        } catch (Exception e) {                        response.addAllErrors(e, ids);        }    }    response.addAllSuccesses(ids);    return response;}
public String metron_f7869_0()
{    return "hdfs";}
public void metron_f7870_1()
{    for (SourceHandler handler : sourceHandlerMap.values()) {                handler.close();    }        sourceHandlerMap.clear();}
 synchronized SourceHandler metron_f7871_1(String sourceType, String stellarResult, WriterConfiguration config) throws IOException
{    SourceHandlerKey key = new SourceHandlerKey(sourceType, stellarResult);    SourceHandler ret = sourceHandlerMap.get(key);    if (ret == null) {        if (sourceHandlerMap.size() >= maxOpenFiles) {            String errorMsg = "Too many HDFS files open! Maximum number of open files is: " + maxOpenFiles + ". Current number of open files is: " + sourceHandlerMap.size();                        throw new IllegalStateException(errorMsg);        }        ret = new SourceHandler(rotationActions, rotationPolicy, syncPolicyCreator.create(sourceType, config), new PathExtensionFileNameFormat(key.getStellarResult(), fileNameFormat), new SourceHandlerCallback(sourceHandlerMap, key));                sourceHandlerMap.put(key, ret);    }    return ret;}
public void metron_f7872_0(Map map, TopologyContext topologyContext)
{    this.delegate.prepare(map, topologyContext);}
public String metron_f7873_0(long rotation, long l1)
{    return delegate.getName(rotation, l1);}
public String metron_f7874_0()
{    return delegate.getPath() + "/" + pathExtension;}
public SourceAwareMoveAction metron_f7875_0(String destDir)
{    destination = destDir;    return this;}
private static String metron_f7876_0(Path filePath)
{    return filePath.getParent().getName();}
public void metron_f7877_1(FileSystem fileSystem, Path filePath) throws IOException
{    Path destPath = new Path(new Path(destination, getSource(filePath)), filePath.getName());        boolean success = fileSystem.rename(filePath, destPath);}
protected void metron_f7878_1(JSONObject message, String sensor, WriterConfiguration config, SyncPolicyCreator syncPolicyCreator) throws IOException
{    byte[] bytes = (message.toJSONString() + "\n").getBytes(StandardCharsets.UTF_8);    synchronized (this.writeLock) {        try {            out.write(bytes);        } catch (IOException writeException) {                                    if (writeException.getMessage().contains("Stream Closed")) {                                rotateOutputFile();                                out.write(bytes);            } else {                throw writeException;            }        }        this.offset += bytes.length;        if (this.syncPolicy.mark(null, this.offset)) {                        if (this.out instanceof HdfsDataOutputStream) {                ((HdfsDataOutputStream) this.out).hsync(EnumSet.of(HdfsDataOutputStream.SyncFlag.UPDATE_LENGTH));            } else {                this.out.hsync();            }                                                this.syncPolicy = syncPolicyCreator.create(sensor, config);        }    }    if (this.rotationPolicy.mark(null, this.offset)) {                        rotateOutputFile();        this.offset = 0;        this.rotationPolicy.reset();    }}
private void metron_f7879_1() throws IOException
{        this.fs = FileSystem.get(new Configuration());    this.currentFile = createOutputFile();        if (this.rotationPolicy instanceof TimedRotationPolicy) {        long interval = ((TimedRotationPolicy) this.rotationPolicy).getInterval();        this.rotationTimer = new Timer(true);        TimerTask task = new TimerTask() {            @Override            public void run() {                try {                                        rotateOutputFile();                } catch (IOException e) {                                    }            }        };        this.rotationTimer.scheduleAtFixedRate(task, interval, interval);    }}
public void metron_f7880_1()
{    try {                rotateOutputFile();    } catch (IOException e) {            }}
protected void metron_f7881_1() throws IOException
{        long start = System.currentTimeMillis();    synchronized (this.writeLock) {        closeOutputFile();                cleanupCallback();                for (RotationAction action : this.rotationActions) {            action.execute(this.fs, this.currentFile);        }    }    long time = System.currentTimeMillis() - start;    }
private Path metron_f7882_1() throws IOException
{                Path path = new Path(this.fileNameFormat.getPath(), this.fileNameFormat.getName(0, System.currentTimeMillis()));        if (fs.getScheme().equals("file")) {                fs.mkdirs(path.getParent());        this.out = new FSDataOutputStream(new FileOutputStream(path.toString()), null);    } else {        this.out = this.fs.create(path);    }    return path;}
protected void metron_f7883_0() throws IOException
{    this.out.close();}
private void metron_f7884_0()
{    this.cleanupCallback.removeKey();}
public void metron_f7885_0()
{    try {        closeOutputFile();        if (rotationTimer != null) {            rotationTimer.cancel();        }        } catch (IOException e) {        throw new RuntimeException("Unable to close output file.", e);    }}
public String metron_f7886_0()
{    return "SourceHandler{" + "rotationActions=" + rotationActions + ", rotationPolicy=" + rotationPolicy + ", syncPolicy=" + syncPolicy + ", fileNameFormat=" + fileNameFormat + ", offset=" + offset + ", out=" + out + ", writeLock=" + writeLock + ", rotationTimer=" + rotationTimer + ", fs=" + fs + ", currentFile=" + currentFile + '}';}
public void metron_f7887_1()
{    SourceHandler removed = sourceHandlerMap.remove(key);    if (removed != null) {        removed.close();    }    }
public String metron_f7888_0()
{    return sourceType;}
public String metron_f7889_0()
{    return stellarResult;}
public boolean metron_f7890_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SourceHandlerKey that = (SourceHandlerKey) o;    if (sourceType != null ? !sourceType.equals(that.sourceType) : that.sourceType != null) {        return false;    }    return stellarResult != null ? stellarResult.equals(that.stellarResult) : that.stellarResult == null;}
public int metron_f7891_0()
{    int result = sourceType != null ? sourceType.hashCode() : 0;    result = 31 * result + (stellarResult != null ? stellarResult.hashCode() : 0);    return result;}
public String metron_f7892_0()
{    return "SourceHandlerKey{" + "sourceType='" + sourceType + '\'' + ", stellarResult='" + stellarResult + '\'' + '}';}
public void metron_f7893_0()
{    MockitoAnnotations.initMocks(this);    ackTuplesPolicy = new AckTuplesPolicy(collector, messageGetStrategy);}
public void metron_f7894_0() throws Exception
{    String messageId1 = "messageId1";    String messageId2 = "messageId2";    String messageId3 = "messageId3";    JSONObject message1 = new JSONObject();    JSONObject message2 = new JSONObject();    JSONObject message3 = new JSONObject();    message1.put("value", "message1");    message2.put("value", "message2");    message3.put("value", "message3");    Tuple tuple3 = mock(Tuple.class);    Throwable e = new Exception("test exception");    MetronError expectedError1 = new MetronError().withSensorType(Collections.singleton(sensorType)).withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(e).withRawMessages(Collections.singletonList(message1));    MetronError expectedError2 = new MetronError().withSensorType(Collections.singleton(sensorType)).withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(e).withRawMessages(Collections.singletonList(message2));    BulkWriterResponse response = new BulkWriterResponse();    response.addAllErrors(e, Arrays.asList(new MessageId(messageId1), new MessageId(messageId2)));    response.addSuccess(new MessageId(messageId3));    when(messageGetStrategy.get(tuple1)).thenReturn(message1);    when(messageGetStrategy.get(tuple2)).thenReturn(message2);    ackTuplesPolicy.addTupleMessageIds(tuple1, Collections.singleton(messageId1));    ackTuplesPolicy.addTupleMessageIds(tuple2, Collections.singleton(messageId2));    ackTuplesPolicy.addTupleMessageIds(tuple3, Collections.singleton(messageId3));    ackTuplesPolicy.onFlush(sensorType, response);    Assert.assertEquals(0, ackTuplesPolicy.getTupleMessageMap().size());    Assert.assertEquals(0, ackTuplesPolicy.getTupleErrorMap().size());    verify(collector, times(1)).emit(eq(Constants.ERROR_STREAM), new Values(argThat(new MetronErrorJSONMatcher(expectedError1.getJSONObject()))));    verify(collector, times(1)).emit(eq(Constants.ERROR_STREAM), new Values(argThat(new MetronErrorJSONMatcher(expectedError2.getJSONObject()))));    verify(collector, times(1)).ack(tuple1);    verify(collector, times(1)).ack(tuple2);    verify(collector, times(1)).ack(tuple3);    verify(collector, times(1)).reportError(e);    verifyNoMoreInteractions(collector);}
public void metron_f7895_0()
{    AckTuplesPolicy ackTuplesPolicy = new AckTuplesPolicy(collector, messageGetStrategy);    JSONObject rawMessage1 = new JSONObject();    JSONObject rawMessage2 = new JSONObject();    rawMessage1.put("value", "rawMessage1");    rawMessage2.put("value", "rawMessage2");    String messageId1 = "messageId1";    String messageId2 = "messageId2";    String messageId3 = "messageId3";    JSONObject message1 = new JSONObject();    JSONObject message2 = new JSONObject();    JSONObject message3 = new JSONObject();    message1.put("value", "message1");    message2.put("value", "message2");    message3.put("value", "message3");    Throwable e1 = new Exception("test exception 1");    Throwable e2 = new Exception("test exception 2");    MetronError expectedError1 = new MetronError().withSensorType(Collections.singleton(sensorType)).withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(e1).withRawMessages(Collections.singletonList(rawMessage1));    MetronError expectedError2 = new MetronError().withSensorType(Collections.singleton(sensorType)).withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(e2).withRawMessages(Collections.singletonList(rawMessage1));    MetronError expectedError3 = new MetronError().withSensorType(Collections.singleton(sensorType)).withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(e1).withRawMessages(Collections.singletonList(rawMessage2));    when(messageGetStrategy.get(tuple1)).thenReturn(rawMessage1);    when(messageGetStrategy.get(tuple2)).thenReturn(rawMessage2);    ackTuplesPolicy.addTupleMessageIds(tuple1, Arrays.asList(messageId1, messageId2));    ackTuplesPolicy.addTupleMessageIds(tuple2, Collections.singletonList(messageId3));    BulkWriterResponse response = new BulkWriterResponse();    response.addError(e1, new MessageId(messageId1));    ackTuplesPolicy.onFlush(sensorType, response);    Assert.assertEquals(2, ackTuplesPolicy.getTupleMessageMap().size());    Assert.assertEquals(1, ackTuplesPolicy.getTupleErrorMap().size());    verify(collector, times(0)).ack(any());    verify(collector, times(0)).reportError(any());    verify(collector, times(1)).emit(eq(Constants.ERROR_STREAM), new Values(argThat(new MetronErrorJSONMatcher(expectedError1.getJSONObject()))));    response = new BulkWriterResponse();    response.addError(e2, new MessageId(messageId2));    response.addError(e1, new MessageId(messageId3));    ackTuplesPolicy.onFlush(sensorType, response);    Assert.assertEquals(0, ackTuplesPolicy.getTupleMessageMap().size());    Assert.assertEquals(0, ackTuplesPolicy.getTupleErrorMap().size());    verify(collector, times(1)).ack(tuple1);    verify(collector, times(1)).ack(tuple2);    verify(collector, times(1)).reportError(e1);    verify(collector, times(1)).reportError(e2);    verify(collector, times(1)).emit(eq(Constants.ERROR_STREAM), new Values(argThat(new MetronErrorJSONMatcher(expectedError2.getJSONObject()))));    verify(collector, times(1)).emit(eq(Constants.ERROR_STREAM), new Values(argThat(new MetronErrorJSONMatcher(expectedError3.getJSONObject()))));    verifyNoMoreInteractions(collector);}
public void metron_f7896_0()
{    ackTuplesPolicy.addTupleMessageIds(tuple1, Collections.singletonList("message1"));    ackTuplesPolicy.addTupleMessageIds(tuple2, Collections.singletonList("message2"));    BulkWriterResponse response = new BulkWriterResponse();    response.addSuccess(new MessageId("message1"));    response.addSuccess(new MessageId("message2"));    ackTuplesPolicy.onFlush(sensorType, response);    Assert.assertEquals(0, ackTuplesPolicy.getTupleMessageMap().size());    verify(collector, times(1)).ack(tuple1);    verify(collector, times(1)).ack(tuple2);    verifyNoMoreInteractions(collector);}
public void metron_f7897_0()
{    ackTuplesPolicy.addTupleMessageIds(tuple1, Arrays.asList("message1", "message2", "message3"));    BulkWriterResponse response = new BulkWriterResponse();    response.addSuccess(new MessageId("message1"));    response.addSuccess(new MessageId("message2"));    ackTuplesPolicy.onFlush(sensorType, response);    verify(collector, times(0)).ack(any());    response = new BulkWriterResponse();    response.addSuccess(new MessageId("message3"));    ackTuplesPolicy.onFlush(sensorType, response);    Assert.assertEquals(0, ackTuplesPolicy.getTupleMessageMap().size());    verify(collector, times(1)).ack(tuple1);    verifyNoMoreInteractions(collector);}
public void metron_f7898_0() throws Exception
{            assertEquals(30, Utils.readStormConfig().getOrDefault(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS, 0));    BatchTimeoutHelper bth;    bth = new BatchTimeoutHelper(defaultConfigList, 1);    assertEquals(14, bth.getMaxBatchTimeout());    bth = new BatchTimeoutHelper(defaultConfigList, 2);    assertEquals(6, bth.getMaxBatchTimeout());    bth = new BatchTimeoutHelper(defaultConfigList, 3);    assertEquals(4, bth.getMaxBatchTimeout());    bth = new BatchTimeoutHelper(defaultConfigList, 4);    assertEquals(2, bth.getMaxBatchTimeout());    bth = new BatchTimeoutHelper(defaultConfigList, 6);    assertEquals(1, bth.getMaxBatchTimeout());    bth = new BatchTimeoutHelper(defaultConfigList, 20);    assertEquals(1, bth.getMaxBatchTimeout());    bth = new BatchTimeoutHelper(disabledConfigList, 2);    assertEquals(6, bth.getMaxBatchTimeout());    bth = new BatchTimeoutHelper(smallTimeoutsList, 2);    assertEquals(6, bth.getMaxBatchTimeout());}
public void metron_f7899_0() throws Exception
{        BatchTimeoutHelper bth;    bth = new BatchTimeoutHelper(defaultConfigList, 2);    assertEquals(6, bth.getRecommendedTickInterval());    bth = new BatchTimeoutHelper(disabledConfigList, 2);    assertEquals(6, bth.getRecommendedTickInterval());    bth = new BatchTimeoutHelper(largeTimeoutsList, 2);    assertEquals(6, bth.getRecommendedTickInterval());    bth = new BatchTimeoutHelper(smallTimeoutsList, 2);    assertEquals(2, bth.getRecommendedTickInterval());    bth = new BatchTimeoutHelper(illegalTimeoutsList, 2);    assertEquals(2, bth.getRecommendedTickInterval());}
public List<Integer> metron_f7900_0()
{    return list;}
public void metron_f7901_0() throws ParseException
{    JSONParser parser = new JSONParser();    fullMessageList = new ArrayList<>();    sampleMessage = (JSONObject) parser.parse(sampleMessageString);    sampleMessage.put(Constants.GUID, "message1");    sampleMessage.put("field", "value1");    fullMessageList.add(((JSONObject) sampleMessage.clone()));    sampleMessage.put(Constants.GUID, "message2");    sampleMessage.put("field", "value2");    fullMessageList.add(((JSONObject) sampleMessage.clone()));    sampleMessage.put(Constants.GUID, "message3");    sampleMessage.put("field", "value3");    fullMessageList.add(((JSONObject) sampleMessage.clone()));    sampleMessage.put(Constants.GUID, "message4");    sampleMessage.put("field", "value4");    fullMessageList.add(((JSONObject) sampleMessage.clone()));    sampleMessage.put(Constants.GUID, "message5");    sampleMessage.put("field", "value5");    fullMessageList.add(((JSONObject) sampleMessage.clone()));    MockitoAnnotations.initMocks(this);    messageIdList = new ArrayList<>();    tupleList = new ArrayList<>();    messageList = new ArrayList<>();    bulkMessageWriterBolt = spy(new BulkMessageWriterBolt<IndexingConfigurations>("zookeeperUrl", "INDEXING").withBulkMessageWriter(bulkMessageWriter).withMessageGetter(MessageGetters.JSON_FROM_FIELD.name()).withMessageGetterField("message"));    for (int i = 0; i < 5; i++) {        String messageId = String.format("message%s", i + 1);        messageIdList.add(new MessageId(messageId));        JSONObject message = fullMessageList.get(i);        Tuple tuple = mock(Tuple.class);        when(tuple.getValueByField("message")).thenReturn(message);        tupleList.add(tuple);        messageList.add(new BulkMessage<>(messageId, message));    }}
public void metron_f7902_0() throws Exception
{        BulkMessageWriterBolt<IndexingConfigurations> bulkMessageWriterBolt = new BulkMessageWriterBolt<IndexingConfigurations>("zookeeperUrl", "INDEXING").withBulkMessageWriter(bulkMessageWriter).withMessageGetter(MessageGetters.JSON_FROM_FIELD.name()).withMessageGetterField("message");    bulkMessageWriterBolt.setCuratorFramework(client);    bulkMessageWriterBolt.setZKCache(cache);    bulkMessageWriterBolt.getConfigurations().updateSensorIndexingConfig(BaseEnrichmentBoltTest.sensorType, new FileInputStream("../" + BaseEnrichmentBoltTest.sampleSensorIndexingConfigPath));        bulkMessageWriterBolt.declareOutputFields(declarer);    Map stormConf = new HashMap();    bulkMessageWriterBolt.prepare(stormConf, topologyContext, outputCollector);        JSONObject message = (JSONObject) new JSONParser().parse(sampleMessageString);    message.remove("source.type");    when(tuple.getValueByField("message")).thenReturn(message);        bulkMessageWriterBolt.execute(tuple);    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), any());    verify(outputCollector, times(1)).ack(tuple);    verify(outputCollector, times(1)).reportError(any(Throwable.class));    Mockito.verifyNoMoreInteractions(outputCollector);}
public void metron_f7903_0() throws Exception
{    Map stormConf = new HashMap();    bulkMessageWriterBolt.setCuratorFramework(client);    bulkMessageWriterBolt.setZKCache(cache);    bulkMessageWriterBolt.getConfigurations().updateSensorIndexingConfig(BaseEnrichmentBoltTest.sensorType, new FileInputStream("../" + BaseEnrichmentBoltTest.sampleSensorIndexingConfigPath));    {        doThrow(new Exception()).when(bulkMessageWriter).init(eq(stormConf), any(WriterConfiguration.class));        try {            bulkMessageWriterBolt.prepare(stormConf, topologyContext, outputCollector);            fail("A runtime exception should be thrown when bulkMessageWriter.init throws an exception");        } catch (RuntimeException e) {        }        reset(bulkMessageWriter);    }    {        when(bulkMessageWriter.getName()).thenReturn("hdfs");        bulkMessageWriterBolt.prepare(stormConf, topologyContext, outputCollector);        verify(bulkMessageWriter, times(1)).init(eq(stormConf), any(WriterConfiguration.class));    }    {        for (int i = 0; i < 4; i++) {            bulkMessageWriterBolt.execute(tupleList.get(i));            verify(bulkMessageWriter, times(0)).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), anyList());        }        BulkWriterResponse response = new BulkWriterResponse();        response.addAllSuccesses(messageIdList);        when(bulkMessageWriter.write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), eq(messageList))).thenReturn(response);        bulkMessageWriterBolt.execute(tupleList.get(4));        verify(bulkMessageWriter, times(1)).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), eq(messageList));        tupleList.forEach(tuple -> verify(outputCollector, times(1)).ack(tuple));        reset(outputCollector);    }    {        doThrow(new Exception()).when(bulkMessageWriter).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), anyList());        UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.FATAL);        for (int i = 0; i < 5; i++) {            bulkMessageWriterBolt.execute(tupleList.get(i));        }        UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.ERROR);        tupleList.forEach(tuple -> verify(outputCollector, times(1)).ack(tuple));        verify(outputCollector, times(5)).emit(eq(Constants.ERROR_STREAM), any(Values.class));        verify(outputCollector, times(1)).reportError(any(Throwable.class));    }    Mockito.verifyNoMoreInteractions(outputCollector);}
public void metron_f7904_0() throws Exception
{    FakeClock clock = new FakeClock();    bulkMessageWriterBolt = bulkMessageWriterBolt.withBatchTimeoutDivisor(3);    bulkMessageWriterBolt.setCuratorFramework(client);    bulkMessageWriterBolt.setZKCache(cache);    bulkMessageWriterBolt.getConfigurations().updateSensorIndexingConfig(BaseEnrichmentBoltTest.sensorType, new FileInputStream("../" + BaseEnrichmentBoltTest.sampleSensorIndexingConfigPath));    {        bulkMessageWriterBolt.declareOutputFields(declarer);        verify(declarer, times(1)).declareStream(eq("error"), argThat(new FieldsMatcher("message")));    }    {        Map stormConf = new HashMap();        when(bulkMessageWriter.getName()).thenReturn("elasticsearch");        bulkMessageWriterBolt.prepare(stormConf, topologyContext, outputCollector, clock);        verify(bulkMessageWriter, times(1)).init(eq(stormConf), any(WriterConfiguration.class));    }    {        int batchTimeout = bulkMessageWriterBolt.getMaxBatchTimeout();        assertEquals(4, batchTimeout);        for (int i = 0; i < 4; i++) {            bulkMessageWriterBolt.execute(tupleList.get(i));            verify(bulkMessageWriter, times(0)).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), any(List.class));        }        clock.elapseSeconds(5);        BulkWriterResponse response = new BulkWriterResponse();        response.addAllSuccesses(messageIdList);        when(bulkMessageWriter.write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), eq(messageList))).thenReturn(response);        bulkMessageWriterBolt.execute(tupleList.get(4));        verify(bulkMessageWriter, times(1)).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), eq(messageList));        tupleList.forEach(tuple -> verify(outputCollector, times(1)).ack(tuple));    }    Mockito.verifyNoMoreInteractions(outputCollector);}
public void metron_f7905_0() throws Exception
{    FakeClock clock = new FakeClock();    bulkMessageWriterBolt.setCuratorFramework(client);    bulkMessageWriterBolt.setZKCache(cache);    bulkMessageWriterBolt.getConfigurations().updateSensorIndexingConfig(BaseEnrichmentBoltTest.sensorType, new FileInputStream("../" + BaseEnrichmentBoltTest.sampleSensorIndexingConfigPath));    {        bulkMessageWriterBolt.declareOutputFields(declarer);        verify(declarer, times(1)).declareStream(eq("error"), argThat(new FieldsMatcher("message")));    }    {        Map stormConf = new HashMap();        when(bulkMessageWriter.getName()).thenReturn("elasticsearch");        bulkMessageWriterBolt.prepare(stormConf, topologyContext, outputCollector, clock);        verify(bulkMessageWriter, times(1)).init(eq(stormConf), any(WriterConfiguration.class));    }    {        int batchTimeout = bulkMessageWriterBolt.getMaxBatchTimeout();        assertEquals(14, batchTimeout);        for (int i = 0; i < 5; i++) {            bulkMessageWriterBolt.execute(tupleList.get(i));            verify(bulkMessageWriter, times(0)).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), any());        }        Tuple tickTuple = mock(Tuple.class);        when(tickTuple.getValueByField("message")).thenReturn(null);                when(tickTuple.getSourceComponent()).thenReturn("__system");                when(tickTuple.getSourceStreamId()).thenReturn("__tick");        BulkWriterResponse response = new BulkWriterResponse();        response.addAllSuccesses(messageIdList);        when(bulkMessageWriter.write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), eq(messageList))).thenReturn(response);        clock.advanceToSeconds(2);        bulkMessageWriterBolt.execute(tickTuple);        verify(bulkMessageWriter, times(0)).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), eq(messageList));                verify(outputCollector, times(1)).ack(tickTuple);        clock.advanceToSeconds(9);        bulkMessageWriterBolt.execute(tickTuple);        verify(bulkMessageWriter, times(1)).write(eq(BaseEnrichmentBoltTest.sensorType), any(WriterConfiguration.class), eq(messageList));        assertEquals(5, tupleList.size());        tupleList.forEach(tuple -> verify(outputCollector, times(1)).ack(tuple));        verify(outputCollector, times(2)).ack(tickTuple);    }    Mockito.verifyNoMoreInteractions(outputCollector);}
public void metron_f7906_0() throws Exception
{    FakeClock clock = new FakeClock();        BulkMessageWriterBolt<IndexingConfigurations> bolt = new BulkMessageWriterBolt<IndexingConfigurations>("zookeeperUrl", "INDEXING").withBulkMessageWriter(bulkMessageWriter).withMessageGetter(MessageGetters.JSON_FROM_POSITION.name()).withMessageGetterField("message");    bolt.setCuratorFramework(client);    bolt.setZKCache(cache);    bolt.getConfigurations().updateSensorIndexingConfig(BaseEnrichmentBoltTest.sensorType, new FileInputStream("../" + BaseEnrichmentBoltTest.sampleSensorIndexingConfigPath));        bolt.declareOutputFields(declarer);    Map stormConf = new HashMap();    bolt.prepare(stormConf, topologyContext, outputCollector, clock);        byte[] invalidJSON = "this is not valid JSON".getBytes(StandardCharsets.UTF_8);    when(tuple.getBinary(0)).thenReturn(invalidJSON);    bolt.execute(tuple);        verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), any());    verify(outputCollector, times(1)).ack(tuple);    verify(outputCollector, times(1)).reportError(any(Throwable.class));    Mockito.verifyNoMoreInteractions(outputCollector);}
public void metron_f7907_0()
{    BulkMessageWriterBolt<IndexingConfigurations> bulkMessageWriterBolt = new BulkMessageWriterBolt<IndexingConfigurations>("zookeeperUrl", "INDEXING");    bulkMessageWriterBolt.declareOutputFields(declarer);    verify(declarer, times(1)).declareStream(eq("error"), argThat(new FieldsMatcher("message")));}
public void metron_f7908_0()
{    CountSyncPolicy basePolicy = new CountSyncPolicy(5);    ClonedSyncPolicyCreator creator = new ClonedSyncPolicyCreator(basePolicy);        SyncPolicy clonedPolicy = creator.create("blah", null);    for (int i = 0; i < 4; ++i) {        Assert.assertFalse(clonedPolicy.mark(null, i));    }    Assert.assertTrue(clonedPolicy.mark(null, 5));        clonedPolicy = creator.create("blah", null);    Assert.assertFalse(clonedPolicy.mark(null, 0));}
public static void metron_f7909_0() throws Exception
{            Thread.interrupted();}
public void metron_f7910_0() throws IOException
{        folder = tempFolder.newFolder();    testFormat = new DefaultFileNameFormat().withPath(folder.toString()).withExtension(".json").withPrefix("prefix-");}
public void metron_f7911_0()
{    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, new IndexingConfigurations());    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    Object result = writer.getHdfsPathExtension(SENSOR_NAME, null, message);    writer.close();    Assert.assertEquals(SENSOR_NAME, result);}
public void metron_f7912_0()
{    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, new IndexingConfigurations());    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    Object result = writer.getHdfsPathExtension(SENSOR_NAME, "", message);    writer.close();    Assert.assertEquals(SENSOR_NAME, result);}
public void metron_f7913_0()
{    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, new IndexingConfigurations());    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    Object result = writer.getHdfsPathExtension(SENSOR_NAME, "'new'", message);    writer.close();    Assert.assertEquals("new", result);}
public void metron_f7914_0()
{    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, new IndexingConfigurations());    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    message.put("test.key", "test.value");    Object result = writer.getHdfsPathExtension(SENSOR_NAME, "test.key", message);    writer.close();    Assert.assertEquals("test.value", result);}
public void metron_f7915_0()
{    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, new IndexingConfigurations());    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    Object result = writer.getHdfsPathExtension(SENSOR_NAME, "FORMAT('/test/folder/')", message);    writer.close();    Assert.assertEquals("/test/folder/", result);}
public void metron_f7916_0()
{    IndexingConfigurations indexingConfig = new IndexingConfigurations();    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    message.put("test.key", "test.value");    message.put("test.key.2", "test.value.2");    message.put("test.key.3", "test.value.3");    Object result = writer.getHdfsPathExtension(SENSOR_NAME, "FORMAT('%s/%s/%s', test.key, test.key.2, test.key.3)", message);    writer.close();    Assert.assertEquals("test.value/test.value.2/test.value.3", result);}
public void metron_f7917_0()
{    IndexingConfigurations indexingConfig = new IndexingConfigurations();    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    String filename = writer.fileNameFormat.getName(1, 1);    Assert.assertEquals("prefix-Xcom-7-1-1.json", filename);    writer.close();}
public void metron_f7918_0()
{    IndexingConfigurations indexingConfig = new IndexingConfigurations();    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    message.put("test.key", "test.value");    message.put("test.key.2", "test.value.2");    Object result = writer.getHdfsPathExtension(SENSOR_NAME, "FORMAT('%s', test.key)", message);    Assert.assertEquals("test.value", result);    result = writer.getHdfsPathExtension(SENSOR_NAME, "FORMAT('%s/%s', test.key, test.key.2)", message);    Assert.assertEquals("test.value/test.value.2", result);    result = writer.getHdfsPathExtension(SENSOR_NAME, "FORMAT('%s', test.key)", message);    writer.close();    Assert.assertEquals("test.value", result);}
public void metron_f7919_0()
{    IndexingConfigurations indexingConfig = new IndexingConfigurations();    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    message.put("test.key", "test.value");    Object result = writer.getHdfsPathExtension(SENSOR_NAME, "TO_UPPER(FORMAT(MAP_GET('key', {'key': 'AbC%s'}), test.key))", message);    writer.close();    Assert.assertEquals("ABCTEST.VALUE", result);}
public void metron_f7920_0()
{    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, new IndexingConfigurations());    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    writer.getHdfsPathExtension(SENSOR_NAME, "{'key':'value'}", message);    writer.close();}
public void metron_f7921_0() throws IOException
{    int maxFiles = 2;    IndexingConfigurations indexingConfig = new IndexingConfigurations();    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat).withMaxOpenFiles(maxFiles);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    for (int i = 0; i < maxFiles; i++) {        writer.getSourceHandler(SENSOR_NAME, Integer.toString(i), null);    }    writer.close();}
public void metron_f7922_0() throws IOException
{    int maxFiles = 2;    IndexingConfigurations indexingConfig = new IndexingConfigurations();    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat).withMaxOpenFiles(maxFiles);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    for (int i = 0; i < maxFiles + 1; i++) {        writer.getSourceHandler(SENSOR_NAME, Integer.toString(i), null);    }    writer.close();}
public void metron_f7923_0() throws Exception
{    FileNameFormat format = new DefaultFileNameFormat().withPath(folder.toString()).withExtension(".json").withPrefix("prefix-");    HdfsWriter writer = new HdfsWriter().withFileNameFormat(format);    IndexingConfigurations indexingConfig = new IndexingConfigurations();    WriterConfiguration config = new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    message.put("test.key", "test.value");    message.put("test.key2", "test.value2");    JSONObject message2 = new JSONObject();    message2.put("test.key", "test.value3");    message2.put("test.key2", "test.value2");    List<BulkMessage<JSONObject>> messages = new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage("message1", message));            add(new BulkMessage("message2", message2));        }    };    writer.write(SENSOR_NAME, config, messages);    writer.close();    ArrayList<String> expected = new ArrayList<>();    expected.add(message.toJSONString());    expected.add(message2.toJSONString());    Collections.sort(expected);        File outputFolder = new File(folder.getAbsolutePath() + "/" + SENSOR_NAME);    Assert.assertTrue(outputFolder.exists() && outputFolder.isDirectory());    Assert.assertEquals(1, outputFolder.listFiles().length);    for (File file : outputFolder.listFiles()) {        List<String> lines = Files.readAllLines(file.toPath());        Collections.sort(lines);        Assert.assertEquals(expected, lines);    }}
public void metron_f7924_0() throws Exception
{    String function = "FORMAT('test-%s/%s', test.key, test.key)";    WriterConfiguration config = buildWriterConfiguration(function);    FileNameFormat format = new DefaultFileNameFormat().withPath(folder.toString()).withExtension(".json").withPrefix("prefix-");    HdfsWriter writer = new HdfsWriter().withFileNameFormat(format);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());        JSONObject message = new JSONObject();    message.put("test.key", "test.value");    message.put("test.key2", "test.value2");    JSONObject message2 = new JSONObject();    message2.put("test.key", "test.value");    message2.put("test.key3", "test.value2");    List<BulkMessage<JSONObject>> messages = new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage<>("message1", message));            add(new BulkMessage<>("message2", message2));        }    };    writer.write(SENSOR_NAME, config, messages);    writer.close();    ArrayList<String> expected = new ArrayList<>();    expected.add(message.toJSONString());    expected.add(message2.toJSONString());    Collections.sort(expected);    File outputFolder = new File(folder.getAbsolutePath() + "/test-test.value/test.value/");    Assert.assertTrue(outputFolder.exists() && outputFolder.isDirectory());    Assert.assertEquals(1, outputFolder.listFiles().length);    for (File file : outputFolder.listFiles()) {        List<String> lines = Files.readAllLines(file.toPath());        Collections.sort(lines);        Assert.assertEquals(expected, lines);    }}
public void metron_f7925_0() throws Exception
{    String function = "FORMAT('test-%s/%s', test.key, test.key)";    WriterConfiguration config = buildWriterConfiguration(function);    FileNameFormat format = new DefaultFileNameFormat().withPath(folder.toString()).withExtension(".json").withPrefix("prefix-");    HdfsWriter writer = new HdfsWriter().withFileNameFormat(format);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());        JSONObject message = new JSONObject();    message.put("test.key", "test.value");    message.put("test.key2", "test.value2");    JSONObject message2 = new JSONObject();    message2.put("test.key", "test.value2");    message2.put("test.key3", "test.value3");    List<BulkMessage<JSONObject>> messages = new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage("message1", message));            add(new BulkMessage("message2", message2));        }    };    writer.write(SENSOR_NAME, config, messages);    writer.close();    ArrayList<String> expected1 = new ArrayList<>();    expected1.add(message.toJSONString());    Collections.sort(expected1);    File outputFolder1 = new File(folder.getAbsolutePath() + "/test-test.value/test.value/");    Assert.assertTrue(outputFolder1.exists() && outputFolder1.isDirectory());    Assert.assertEquals(1, outputFolder1.listFiles().length);    for (File file : outputFolder1.listFiles()) {        List<String> lines = Files.readAllLines(file.toPath());        Collections.sort(lines);        Assert.assertEquals(expected1, lines);    }    ArrayList<String> expected2 = new ArrayList<>();    expected2.add(message2.toJSONString());    Collections.sort(expected2);    File outputFolder2 = new File(folder.getAbsolutePath() + "/test-test.value2/test.value2/");    Assert.assertTrue(outputFolder2.exists() && outputFolder2.isDirectory());    Assert.assertEquals(1, outputFolder2.listFiles().length);    for (File file : outputFolder2.listFiles()) {        List<String> lines = Files.readAllLines(file.toPath());        Collections.sort(lines);        Assert.assertEquals(expected2, lines);    }}
public void metron_f7926_0() throws Exception
{    String function = "FORMAT('test-%s/%s', test.key, test.key)";    WriterConfiguration config = buildWriterConfiguration(function);    FileNameFormat format = new DefaultFileNameFormat().withPath(folder.toString()).withExtension(".json").withPrefix("prefix-");    HdfsWriter writer = new HdfsWriter().withFileNameFormat(format);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());        JSONObject message = new JSONObject();    message.put("test.key2", "test.value2");    List<BulkMessage<JSONObject>> messages = new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage("message1", message));        }    };    writer.write(SENSOR_NAME, config, messages);    writer.close();    ArrayList<String> expected = new ArrayList<>();    expected.add(message.toJSONString());    Collections.sort(expected);    File outputFolder = new File(folder.getAbsolutePath() + "/test-null/null/");    Assert.assertTrue(outputFolder.exists() && outputFolder.isDirectory());    Assert.assertEquals(1, outputFolder.listFiles().length);    for (File file : outputFolder.listFiles()) {        List<String> lines = Files.readAllLines(file.toPath());        Collections.sort(lines);        Assert.assertEquals(expected, lines);    }}
public void metron_f7927_0() throws Exception
{    String function = "FORMAT('test-%s/%s', test.key, test.key)";    WriterConfiguration config = buildWriterConfiguration(function);    HdfsWriter writer = new HdfsWriter().withFileNameFormat(testFormat);    writer.init(new HashMap<String, String>(), config);    writer.initFileNameFormat(createTopologyContext());    JSONObject message = new JSONObject();    message.put("test.key", "test.value");    List<BulkMessage<JSONObject>> messages = new ArrayList<BulkMessage<JSONObject>>() {        {            add(new BulkMessage("message1", message));        }    };    CountSyncPolicy basePolicy = new CountSyncPolicy(5);    ClonedSyncPolicyCreator creator = new ClonedSyncPolicyCreator(basePolicy);    writer.write(SENSOR_NAME, config, messages);    writer.write(SENSOR_NAME, config, messages);    writer.close();    File outputFolder = new File(folder.getAbsolutePath() + "/test-test.value/test.value/");        ArrayList<String> expected = new ArrayList<>();    expected.add(message.toJSONString());    expected.add(message.toJSONString());        Assert.assertEquals(1, outputFolder.listFiles().length);    for (File file : outputFolder.listFiles()) {        List<String> lines = Files.readAllLines(file.toPath());                Assert.assertEquals(2, lines.size());        Assert.assertEquals(expected, lines);    }}
protected WriterConfiguration metron_f7928_0(String function)
{    IndexingConfigurations indexingConfig = new IndexingConfigurations();    Map<String, Object> sensorIndexingConfig = new HashMap<>();    Map<String, Object> writerIndexingConfig = new HashMap<>();    writerIndexingConfig.put(IndexingConfigurations.OUTPUT_PATH_FUNCTION_CONF, function);    sensorIndexingConfig.put(WRITER_NAME, writerIndexingConfig);    indexingConfig.updateSensorIndexingConfig(SENSOR_NAME, sensorIndexingConfig);    return new IndexingWriterConfiguration(WRITER_NAME, indexingConfig);}
private TopologyContext metron_f7929_0()
{    Map<Integer, String> taskToComponent = new HashMap<Integer, String>();    taskToComponent.put(7, "Xcom");    return new TopologyContext(null, null, taskToComponent, null, null, null, null, null, 7, 6703, null, null, null, null, null, null);}
public void metron_f7930_0()
{    FileNameFormat delegate = new DefaultFileNameFormat().withExtension(EXTENSION).withPath(PATH);    FileNameFormat sourceFormat = new PathExtensionFileNameFormat(PATH_EXTENSION, delegate);    String actual = sourceFormat.getPath();    String expected = PATH + "/" + PATH_EXTENSION;    Assert.assertEquals(expected, actual);}
public void metron_f7931_0()
{    FileNameFormat delegate = new DefaultFileNameFormat().withExtension(EXTENSION).withPath(PATH);    FileNameFormat sourceFormat = new PathExtensionFileNameFormat("", delegate);    String actual = sourceFormat.getPath();    Assert.assertEquals(PATH + "/", actual);}
public void metron_f7932_0() throws IOException
{        folder = tempFolder.newFolder();    testFormat = new DefaultFileNameFormat().withPath(folder.toString()).withExtension(".json").withPrefix("prefix-");    rotActions = new ArrayList<>();    rotActions.add(rotAction1);    rotActions.add(rotAction2);}
public void metron_f7933_0() throws IOException
{    SourceHandler handler = new SourceHandler(rotActions,     new FileSizeRotationPolicy(10000, Units.MB), new CountSyncPolicy(1), testFormat, callback);    handler.rotateOutputFile();        verify(rotAction1).execute(any(), any());    verify(rotAction2).execute(any(), any());    verify(callback).removeKey();}
public Builder metron_f7934_0(Callback callback, TreeCacheEvent.Type... types)
{    return with(ImmutableList.of(callback), types);}
public Builder metron_f7935_0(Iterable<? extends Callback> callback, TreeCacheEvent.Type... types)
{    for (TreeCacheEvent.Type t : types) {        List<Callback> cbs = callbacks.get(t);        if (cbs == null) {            cbs = new ArrayList<>();        }        Iterables.addAll(cbs, callback);        callbacks.put(t, cbs);    }    return this;}
public SimpleEventListener metron_f7936_0()
{    return new SimpleEventListener(callbacks);}
public void metron_f7937_1(CuratorFramework client, TreeCacheEvent event) throws Exception
{    String path = null;    byte[] data = null;    if (event != null && event.getData() != null) {        path = event.getData().getPath();        data = event.getData().getData();    }        List<Callback> callback = callbacks.get(event.getType());    if (callback != null) {        for (Callback cb : callback) {            cb.apply(client, path, data);        }    }}
public Builder metron_f7938_0(CuratorFramework client)
{    this.client = Optional.ofNullable(client);    ownClient = false;    return this;}
public Builder metron_f7939_0(String zookeeperUrl)
{    this.client = Optional.ofNullable(createClient(zookeeperUrl, Optional.empty()));    ownClient = true;    return this;}
public Builder metron_f7940_0(String zookeeperUrl, RetryPolicy retryPolicy)
{    this.client = Optional.ofNullable(createClient(zookeeperUrl, Optional.ofNullable(retryPolicy)));    ownClient = true;    return this;}
public Builder metron_f7941_0(TreeCacheListener listener)
{    this.listener.add(listener);    return this;}
public Builder metron_f7942_0(String zkRoot)
{    this.zkRoot = zkRoot;    return this;}
public ZKCache metron_f7943_1()
{    if (!client.isPresent()) {        throw new IllegalArgumentException("Zookeeper client must be specified.");    }    if (listener.isEmpty()) {            }    if (zkRoot == null) {        throw new IllegalArgumentException("Zookeeper root must not be null.");    }    return new ZKCache(client.get(), listener, zkRoot, ownClient);}
public CuratorFramework metron_f7944_0()
{    return client;}
public void metron_f7945_0() throws Exception
{    if (cache == null) {        if (ownClient) {            client.start();        }        TreeCache.Builder builder = TreeCache.newBuilder(client, zkRoot);        builder.setCacheData(true);        cache = builder.build();        for (TreeCacheListener l : listeners) {            cache.getListenable().addListener(l);        }        cache.start();    }}
public void metron_f7946_0()
{    cache.close();    if (ownClient) {        client.close();    }}
public static CuratorFramework metron_f7947_0(String zookeeperUrl, Optional<RetryPolicy> retryPolicy)
{    return CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy.orElse(new ExponentialBackoffRetry(DEFAULT_CLIENT_SLEEP_MS, DEFAULT_MAX_RETRIES)));}
public Object metron_f7948_0(List<Object> list, Context context) throws ParseException
{    return System.currentTimeMillis();}
public void metron_f7949_0(Context context)
{}
public boolean metron_f7950_0()
{    return true;}
 static Cache<String, StellarCompiler.Expression> metron_f7951_0(int cacheSize, int expiryTime, TimeUnit expiryUnit)
{    CacheLoader<String, StellarCompiler.Expression> loader = key -> compile(key);    return Caffeine.newBuilder().maximumSize(cacheSize).expireAfterAccess(expiryTime, expiryUnit).build(loader);}
public Set<String> metron_f7952_0(final String rule)
{    if (rule == null || isEmpty(rule.trim())) {        return null;    }    StellarCompiler.Expression expression = null;    try {        expression = expressionCache.get(rule, r -> compile(r));    } catch (Throwable e) {        throw new ParseException("Unable to parse: " + rule + " due to: " + e.getMessage(), e);    }    return expression.variablesUsed;}
public T metron_f7953_0(final String rule, final VariableResolver variableResolver, final FunctionResolver functionResolver, final Context context)
{    StellarCompiler.Expression expression = null;    if (rule == null || isEmpty(rule.trim())) {        return null;    }    if (context.getActivityType() == null) {        context.setActivityType(ActivityType.PARSE_ACTIVITY);    }    try {        expression = expressionCache.get(rule, r -> compile(r));    } catch (Throwable e) {        throw createException(rule, variableResolver, e);    }    try {        return clazz.cast(expression.apply(new StellarCompiler.ExpressionState(context, functionResolver, variableResolver)));    } catch (Throwable e) {        throw createException(rule, variableResolver, e);    } finally {                context.setActivityType(null);    }}
private ParseException metron_f7954_0(String rule, VariableResolver resolver, Throwable t)
{    String message = "Unable to parse: " + rule + " due to: " + t.getMessage();    Set<String> variablesUsed = variablesUsed(rule);    if (variablesUsed.isEmpty()) {        return new ParseException(message, t);    }    List<Map.Entry<String, Object>> messagesUsed = new ArrayList<>(variablesUsed.size());    for (String v : variablesUsed) {        Optional<Object> resolved = Optional.ofNullable(resolver.resolve(v));        messagesUsed.add(new AbstractMap.SimpleEntry<>(v, resolved.orElse("missing")));    }    return new ParseException(message + " with relevant variables " + Joiner.on(",").join(messagesUsed), t);}
public static StellarCompiler.Expression metron_f7955_0(final String rule)
{    if (rule == null || isEmpty(rule.trim())) {        return null;    }    ANTLRInputStream input = new ANTLRInputStream(rule);    StellarLexer lexer = new StellarLexer(input);    lexer.removeErrorListeners();    lexer.addErrorListener(new ErrorListener());    TokenStream tokens = new CommonTokenStream(lexer);    StellarParser parser = new StellarParser(tokens);    StellarCompiler treeBuilder = new StellarCompiler(ArithmeticEvaluator.INSTANCE, NumberLiteralEvaluator.INSTANCE, ComparisonExpressionWithOperatorEvaluator.INSTANCE);    parser.addParseListener(treeBuilder);    parser.removeErrorListeners();    parser.addErrorListener(new ErrorListener());    parser.transformation();    return treeBuilder.getExpression();}
public boolean metron_f7956_0(final String rule) throws ParseException
{    return validate(rule, true, Context.EMPTY_CONTEXT());}
public boolean metron_f7957_0(final String rule, final Context context) throws ParseException
{    return validate(rule, true, context);}
public boolean metron_f7958_0(final String rule, final boolean throwException, final Context context) throws ParseException
{    if (rule == null || isEmpty(rule.trim())) {        return true;    }            context.setActivityType(ActivityType.VALIDATION_ACTIVITY);    try {        parse(rule, DefaultVariableResolver.NULL_RESOLVER(), StellarFunctions.FUNCTION_RESOLVER(), context);    } catch (Throwable t) {        if (throwException) {            throw new ParseException("Unable to parse " + rule + ": " + t.getMessage(), t);        } else {            return false;        }    }    return true;}
public static DescriptiveStatistics metron_f7959_0(StellarStatement statement, int warmupRounds, int benchmarkRounds)
{    run(warmupRounds, statement, ts -> {    });    final DescriptiveStatistics stats = new DescriptiveStatistics();    run(benchmarkRounds, statement, ts -> {        stats.addValue(ts);    });    return stats;}
private static void metron_f7960_0(int numTimes, StellarStatement statement, Consumer<Long> func)
{    StellarProcessor processor = new StellarProcessor();    for (int i = 0; i < numTimes; ++i) {        long start = System.nanoTime();        processor.parse(statement.expression, statement.variableResolver, statement.functionResolver, statement.context);        func.accept((System.nanoTime() - start) / 1000);    }}
public static String metron_f7961_0(DescriptiveStatistics stats, Double[] percentiles)
{    StringBuilder sb = new StringBuilder();    sb.append(String.format("round: mean of %dms [+-%d], measured %d rounds;\n", (long) stats.getMean(), (long) stats.getStandardDeviation(), stats.getN()));    sb.append("\tMin - " + (long) stats.getMin() + "\n");    for (double pctile : percentiles) {        sb.append("\t" + pctile + " - " + stats.getPercentile(pctile) + "\n");    }    sb.append("\tMax - " + (long) stats.getMax());    return sb.toString();}
public boolean metron_f7962_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f7963_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public static CommandLine metron_f7964_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (org.apache.commons.cli.ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static EnumMap<BenchmarkOptions, Optional<Object>> metron_f7965_0(CommandLine cli)
{    EnumMap<BenchmarkOptions, Optional<Object>> ret = new EnumMap<>(BenchmarkOptions.class);    for (BenchmarkOptions option : values()) {        ret.put(option, option.handler.getValue(option, cli));    }    return ret;}
public static void metron_f7966_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("StellarBenchmark", getOptions());}
public static Options metron_f7967_0()
{    Options ret = new Options();    for (BenchmarkOptions o : BenchmarkOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public Option metron_f7968_0(@Nullable String s)
{    return new Option(s, "help", false, "Generate Help screen");}
public Option metron_f7969_0(@Nullable String s)
{    Option o = new Option(s, "warmup", true, "Number of times for warmup per expression. Default: " + DEFAULT_WARMUP);    o.setArgName("NUM");    o.setRequired(false);    return o;}
public Optional<Object> metron_f7970_0(BenchmarkOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public Option metron_f7971_0(@Nullable String s)
{    Option o = new Option(s, "percentiles", true, "Percentiles to calculate per run. Default: " + Joiner.on(",").join(Arrays.asList(DEFAULT_PERCENTILES)));    o.setArgName("NUM");    o.setRequired(false);    return o;}
public Optional<Object> metron_f7972_0(BenchmarkOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public Option metron_f7973_0(@Nullable String s)
{    Option o = new Option(s, "num_times", true, "Number of times to run per expression (after warmup). Default: " + DEFAULT_NUM_TIMES);    o.setArgName("NUM");    o.setRequired(false);    return o;}
public Optional<Object> metron_f7974_0(BenchmarkOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public Option metron_f7975_0(@Nullable String s)
{    Option o = new Option(s, "expressions", true, "Stellar expressions");    o.setArgName("FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f7976_0(BenchmarkOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public Option metron_f7977_0(@Nullable String s)
{    Option o = new Option(s, "variables", true, "File containing a JSON Map of variables to use");    o.setArgName("FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f7978_0(BenchmarkOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public Option metron_f7979_0(@Nullable String s)
{    Option o = new Option(s, "output", true, "File to write output.");    o.setArgName("FILE");    o.setRequired(false);    return o;}
public Optional<Object> metron_f7980_0(BenchmarkOptions option, CommandLine cli)
{    return Optional.ofNullable(option.get(cli).trim());}
public static void metron_f7981_0(String... argv) throws IOException
{    CommandLine cli = BenchmarkOptions.parse(new PosixParser(), argv);    if (!BenchmarkOptions.EXPRESSIONS.has(cli)) {        throw new IllegalStateException("You must at least specify an expressions file.");    }    File expressionsFile = new File(BenchmarkOptions.EXPRESSIONS.get(cli));    Optional<File> variablesFile = Optional.ofNullable(!BenchmarkOptions.VARIABLES.has(cli) ? null : new File(BenchmarkOptions.VARIABLES.get(cli)));    Optional<File> output = Optional.ofNullable(!BenchmarkOptions.OUTPUT.has(cli) ? null : new File(BenchmarkOptions.OUTPUT.get(cli)));    List<String> lines = Files.readLines(expressionsFile, Charset.defaultCharset());    Map<String, Object> variables = new HashMap<>();    if (variablesFile.isPresent()) {        variables = JSONUtils.INSTANCE.load(new FileInputStream(variablesFile.get()), JSONUtils.MAP_SUPPLIER);    }    int numTimes = DEFAULT_NUM_TIMES;    if (BenchmarkOptions.NUM_TIMES.has(cli)) {        numTimes = Integer.parseInt(BenchmarkOptions.NUM_TIMES.get(cli));    }    int warmup = DEFAULT_WARMUP;    if (BenchmarkOptions.WARMUP.has(cli)) {        warmup = Integer.parseInt(BenchmarkOptions.WARMUP.get(cli));    }    Double[] percentiles = DEFAULT_PERCENTILES;    if (BenchmarkOptions.PERCENTILES.has(cli)) {        List<Double> percentileList = new ArrayList<>();        for (String token : Splitter.on(",").split(BenchmarkOptions.PERCENTILES.get(cli))) {            if (token.trim().isEmpty()) {                continue;            }            Double d = Double.parseDouble(token.trim());            percentileList.add(d);        }        percentiles = (Double[]) percentileList.toArray();    }    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out, StandardCharsets.UTF_8)));    if (output.isPresent()) {        out = new PrintWriter(output.get(), StandardCharsets.UTF_8.name());    }    for (String statement : lines) {        if (statement.trim().startsWith("#") || statement.trim().isEmpty()) {            continue;        }        Microbenchmark.StellarStatement s = new Microbenchmark.StellarStatement();        s.context = Context.EMPTY_CONTEXT();        s.expression = statement;        s.functionResolver = StellarFunctions.FUNCTION_RESOLVER();        s.variableResolver = new MapVariableResolver(variables);        DescriptiveStatistics stats = Microbenchmark.run(s, warmup, numTimes);        out.println("Expression: " + statement);        out.println(Microbenchmark.describe(stats, percentiles));    }    if (argv.length > 2) {        out.close();    }}
public String metron_f7982_0()
{    return expression;}
public Map<String, Object> metron_f7983_0()
{    return input;}
public boolean metron_f7984_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Key key = (Key) o;    return new EqualsBuilder().append(expression, key.expression).append(input, key.input).isEquals();}
public int metron_f7985_0()
{    return new HashCodeBuilder(17, 37).append(expression).append(input).toHashCode();}
public String metron_f7986_0()
{    return new ToStringBuilder(this).append("expression", expression).append("input", input).toString();}
public Object metron_f7987_1(String expression, VariableResolver variableResolver, FunctionResolver functionResolver, Context context)
{    Optional<Object> cacheOpt = context.getCapability(Context.Capabilities.CACHE, false);    if (cacheOpt.isPresent()) {                Cache<Key, Object> cache = (Cache<Key, Object>) cacheOpt.get();        Key k = toKey(expression, variableResolver);        return cache.get(k, x -> parseUncached(x.expression, variableResolver, functionResolver, context));    } else {                return parseUncached(expression, variableResolver, functionResolver, context);    }}
private static T metron_f7991_0(Map<String, Object> config, String key, T defaultVal, Class<T> clazz)
{    Object o = config.get(key);    if (o == null) {        return defaultVal;    }    T ret = ConversionUtils.convert(o, clazz);    return ret == null ? defaultVal : ret;}
public static CuratorFramework metron_f7992_0(String zookeeperUrl)
{    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    return CuratorFrameworkFactory.newClient(zookeeperUrl, retryPolicy);}
public static void metron_f7993_0(Map<String, Object> globalConfig, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeGlobalConfigToZookeeper(globalConfig, client);    }}
public static void metron_f7994_0(Map<String, Object> globalConfig, CuratorFramework client) throws Exception
{    writeGlobalConfigToZookeeper(JSONUtils.INSTANCE.toJSON(globalConfig), client);}
public static void metron_f7995_0(byte[] globalConfig, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeGlobalConfigToZookeeper(globalConfig, client);    }}
public static void metron_f7996_0(byte[] globalConfig, CuratorFramework client) throws Exception
{    GLOBAL.deserialize(new String(globalConfig, StandardCharsets.UTF_8));    writeToZookeeper(GLOBAL.getZookeeperRoot(), globalConfig, client);}
public static void metron_f7997_0(String name, Map<String, Object> config, String zookeeperUrl) throws Exception
{    writeConfigToZookeeper(name, JSONUtils.INSTANCE.toJSON(config), zookeeperUrl);}
public static void metron_f7998_0(String name, byte[] config, String zookeeperUrl) throws Exception
{    try (CuratorFramework client = getClient(zookeeperUrl)) {        client.start();        writeToZookeeper(Constants.ZOOKEEPER_TOPOLOGY_ROOT + "/" + name, config, client);    }}
public static void metron_f7999_0(String path, byte[] configData, CuratorFramework client) throws Exception
{    try {        client.setData().forPath(path, configData);    } catch (KeeperException.NoNodeException e) {        client.create().creatingParentsIfNeeded().forPath(path, configData);    }}
public static byte[] metron_f8000_0(CuratorFramework client) throws Exception
{    return readFromZookeeper(GLOBAL.getZookeeperRoot(), client);}
public static byte[] metron_f8001_0(String name, CuratorFramework client) throws Exception
{    return readFromZookeeper(Constants.ZOOKEEPER_TOPOLOGY_ROOT + "/" + name, client);}
public static byte[] metron_f8002_0(String path, CuratorFramework client) throws Exception
{    if (client != null && client.getData() != null && path != null) {        return client.getData().forPath(path);    }    return new byte[] {};}
public static void metron_f8003_0(CuratorFramework client) throws Exception
{    byte[] ret = null;    try {        ret = readGlobalConfigBytesFromZookeeper(client);    } catch (KeeperException.NoNodeException nne) {        }    if (ret == null || ret.length == 0) {        setupStellarStatically(client, Optional.empty());    } else {        setupStellarStatically(client, Optional.of(new String(ret, StandardCharsets.UTF_8)));    }}
public static void metron_f8004_0(CuratorFramework client, Optional<String> globalConfig)
{    /*      In order to validate stellar functions, the function resolver must be initialized.  Otherwise,      those utilities that require validation cannot validate the stellar expressions necessarily.    */    Context.Builder builder = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client);    if (globalConfig.isPresent()) {        builder = builder.with(Context.Capabilities.GLOBAL_CONFIG, () -> GLOBAL.deserialize(globalConfig.get())).with(Context.Capabilities.STELLAR_CONFIG, () -> GLOBAL.deserialize(globalConfig.get()));    } else {        builder = builder.with(Context.Capabilities.STELLAR_CONFIG, () -> new HashMap<>());    }    Context stellarContext = builder.build();    StellarFunctions.FUNCTION_RESOLVER().initialize(stellarContext);}
public static byte[] metron_f8005_0(String rootPath) throws IOException
{    byte[] globalConfig = new byte[0];    File configPath = new File(rootPath, GLOBAL.getName() + ".json");    if (configPath.exists()) {        globalConfig = Files.readAllBytes(configPath.toPath());    }    return globalConfig;}
public static void metron_f8006_0(CuratorFramework client, final ConfigurationVisitor callback) throws Exception
{    visitConfigs(client, (type, name, data) -> {        setupStellarStatically(client, Optional.ofNullable(data));        callback.visit(type, name, data);    }, GLOBAL);}
public static void metron_f8007_0(CuratorFramework client, ConfigurationVisitor callback, ConfigurationType configType) throws Exception
{    if (client.checkExists().forPath(configType.getZookeeperRoot()) != null) {        if (configType.equals(GLOBAL)) {            byte[] globalConfigData = client.getData().forPath(configType.getZookeeperRoot());            callback.visit(configType, "global", new String(globalConfigData, StandardCharsets.UTF_8));        }    }}
public static void metron_f8008_0(PrintStream out, CuratorFramework client) throws Exception
{    ConfigurationsUtils.visitConfigs(client, (type, name, data) -> {        type.deserialize(data);        out.println(type + " Config: " + name + "\n" + data);    });}
public String metron_f8009_0()
{    return name;}
public String metron_f8010_0()
{    return directory;}
public Object metron_f8011_0(String s)
{    return deserializer.apply(s);}
public Object metron_f8012_0(String s)
{    return deserialize(s);}
public String metron_f8013_0()
{    return zookeeperRoot;}
public String metron_f8014_0()
{    return name;}
public static Fields metron_f8015_0(String fieldName)
{    return nameToField.get(fieldName);}
public String metron_f8016_0()
{    return name;}
public String metron_f8017_0()
{    return type;}
public Map<String, Object> metron_f8018_0()
{    return ImmutableMap.copyOf(state);}
public void metron_f8019_0(String variable, String expression, Map<String, Object> transientState)
{    Object result = execute(expression, transientState);    if (result == null || variable == null) {        return;    }    state.put(variable, result);}
public void metron_f8020_0(String variable, Object value)
{    if (value == null || variable == null) {        return;    }    state.put(variable, value);}
public T metron_f8021_0(String expression, Map<String, Object> state, Class<T> clazz)
{    Object resultObject = execute(expression, state);        T result = ConversionUtils.convert(resultObject, clazz);    if (result == null) {        throw new IllegalArgumentException(String.format("Unexpected type: expected=%s, actual=%s, expression=%s", clazz.getSimpleName(), ClassUtils.getShortClassName(resultObject, "null"), expression));    }    return result;}
public void metron_f8022_0()
{    this.state = new HashMap<>();}
public void metron_f8023_0(Context context)
{    this.context = context;}
public void metron_f8024_0(FunctionResolver functionResolver)
{    this.functionResolver = functionResolver;}
private Object metron_f8025_0(String expression, Map<String, Object> transientState)
{    VariableResolver variableResolver = new MapVariableResolver(state, transientState);    StellarProcessor processor = new StellarProcessor();    return processor.parse(expression, variableResolver, functionResolver, context);}
public boolean metron_f8026_0(String possible)
{    return is.test(possible);}
public String metron_f8027_0(String encoded)
{    return decode(encoded, false);}
public String metron_f8028_0(String encoded, boolean verify)
{    if (verify) {        if (is.test(encoded)) {            return decode.apply(encoded);        } else {            return encoded;        }    }    return decode.apply(encoded);}
public String metron_f8029_0(String toEncode)
{    return encode.apply(toEncode);}
public Token<? extends Number> metron_f8030_0(BiFunction<Number, Number, Token<? extends Number>> function, Pair<Token<? extends Number>, Token<? extends Number>> p)
{    if (p == null || p.getKey() == null || p.getValue() == null) {        throw new IllegalArgumentException();    }    final Number l = p.getKey().getValue();    final Number r = p.getValue().getValue();    return function.apply(l == null ? 0 : l, r == null ? 0 : r);}
public static BiFunction<Number, Number, Token<? extends Number>> metron_f8031_0(final FrameContext.Context context)
{    return (Number l, Number r) -> {        if (l instanceof Double || r instanceof Double) {            return new Token<>(l.doubleValue() + r.doubleValue(), Double.class, context);        } else if (l instanceof Float || r instanceof Float) {            return new Token<>(l.floatValue() + r.floatValue(), Float.class, context);        } else if (l instanceof Long || r instanceof Long) {            return new Token<>(l.longValue() + r.longValue(), Long.class, context);        } else {            return new Token<>(l.intValue() + r.intValue(), Integer.class, context);        }    };}
public static BiFunction<Number, Number, Token<? extends Number>> metron_f8032_0(final FrameContext.Context context)
{    return (Number l, Number r) -> {        if (l instanceof Double || r instanceof Double) {            return new Token<>(l.doubleValue() * r.doubleValue(), Double.class, context);        } else if (l instanceof Float || r instanceof Float) {            return new Token<>(l.floatValue() * r.floatValue(), Float.class, context);        } else if (l instanceof Long || r instanceof Long) {            return new Token<>(l.longValue() * r.longValue(), Long.class, context);        } else {            return new Token<>(l.intValue() * r.intValue(), Integer.class, context);        }    };}
public static BiFunction<Number, Number, Token<? extends Number>> metron_f8033_0(final FrameContext.Context context)
{    return (Number l, Number r) -> {        if (l instanceof Double || r instanceof Double) {            return new Token<>(l.doubleValue() - r.doubleValue(), Double.class, context);        } else if (l instanceof Float || r instanceof Float) {            return new Token<>(l.floatValue() - r.floatValue(), Float.class, context);        } else if (l instanceof Long || r instanceof Long) {            return new Token<>(l.longValue() - r.longValue(), Long.class, context);        } else {            return new Token<>(l.intValue() - r.intValue(), Integer.class, context);        }    };}
public static BiFunction<Number, Number, Token<? extends Number>> metron_f8034_0(FrameContext.Context context)
{    return (Number l, Number r) -> {        if (l instanceof Double || r instanceof Double) {            return new Token<>(l.doubleValue() / r.doubleValue(), Double.class, context);        } else if (l instanceof Float || r instanceof Float) {            return new Token<>(l.floatValue() / r.floatValue(), Float.class, context);        } else if (l instanceof Long || r instanceof Long) {            return new Token<>(l.longValue() / r.longValue(), Long.class, context);        } else {            return new Token<>(l.intValue() / r.intValue(), Integer.class, context);        }    };}
public ComparisonExpressionEvaluator metron_f8035_0()
{    return evaluator;}
public Token<Boolean> metron_f8036_0(final Token<?> left, final Token<?> right, final StellarParser.ComparisonOpContext op, FrameContext.Context context)
{    if (op.EQ() != null) {        return new Token<>(Strategy.EQUALITY_OPERATORS.evaluator().evaluate(left, right, op), Boolean.class, context);    } else if (op.NEQ() != null) {        return new Token<>(!Strategy.EQUALITY_OPERATORS.evaluator().evaluate(left, right, op), Boolean.class, context);    } else if (op.LT() != null || op.GT() != null || op.LTE() != null || op.GTE() != null) {        return new Token<>(Strategy.COMPARISON_OPERATORS.evaluator().evaluate(left, right, op), Boolean.class, context);    }    throw new ParseException("Unsupported operations. The following expression is invalid: " + left.getValue() + op.getText() + right.getValue());}
public boolean metron_f8037_0(final Token<?> left, final Token<?> right, final StellarParser.ComparisonOpContext op)
{    if (left.getValue() == null || right.getValue() == null) {        return false;    } else if (left.getValue() instanceof Number && right.getValue() instanceof Number) {        return compareNumbers((Number) left.getValue(), (Number) right.getValue(), op);    } else if (left.getValue().getClass() == right.getValue().getClass() && left.getValue() instanceof Comparable && right.getValue() instanceof Comparable) {        return compare((Comparable<?>) left.getValue(), (Comparable<?>) right.getValue(), op);    }    throw new ParseException("Unsupported operations. The following expression is invalid: " + left.getValue() + op + right.getValue());}
private boolean metron_f8038_0(final T l, final T r, final StellarParser.ComparisonOpContext op)
{    int compareTo = l.compareTo(r);    if (op.LT() != null) {        return compareTo < 0;    } else if (op.LTE() != null) {        return compareTo <= 0;    } else if (op.GT() != null) {        return compareTo > 0;    } else if (op.GTE() != null) {        return compareTo >= 0;    }    throw new ParseException("Unsupported operator: " + op);}
private boolean metron_f8039_0(final Number l, final Number r, final StellarParser.ComparisonOpContext op)
{    if (op.LT() != null) {        return lessThan(l, r);    } else if (op.LTE() != null) {        return lessThanEqual(l, r);    } else if (op.GT() != null) {        return greaterThan(l, r);    } else if (op.GTE() != null) {        return greaterThanEqual(l, r);    }    throw new ParseException("Unsupported operator: " + op);}
private boolean metron_f8040_0(final Number l, final Number r)
{    if (l instanceof Double || r instanceof Double) {        return l.doubleValue() < r.doubleValue();    } else if (l instanceof Float || r instanceof Float) {        return l.floatValue() < r.floatValue();    } else if (l instanceof Long || r instanceof Long) {        return l.longValue() < r.longValue();    } else {        return l.intValue() < r.intValue();    }}
private boolean metron_f8041_0(final Number l, final Number r)
{    if (l instanceof Double || r instanceof Double) {        return l.doubleValue() <= r.doubleValue();    } else if (l instanceof Float || r instanceof Float) {        return l.floatValue() <= r.floatValue();    } else if (l instanceof Long || r instanceof Long) {        return l.longValue() <= r.longValue();    } else {        return l.intValue() <= r.intValue();    }}
private boolean metron_f8042_0(final Number l, final Number r)
{    if (l instanceof Double || r instanceof Double) {        return l.doubleValue() > r.doubleValue();    } else if (l instanceof Float || r instanceof Float) {        return l.floatValue() > r.floatValue();    } else if (l instanceof Long || r instanceof Long) {        return l.longValue() > r.longValue();    } else {        return l.intValue() > r.intValue();    }}
private boolean metron_f8043_0(final Number l, final Number r)
{    if (l instanceof Double || r instanceof Double) {        return l.doubleValue() >= r.doubleValue();    } else if (l instanceof Float || r instanceof Float) {        return l.floatValue() >= r.floatValue();    } else if (l instanceof Long || r instanceof Long) {        return l.longValue() >= r.longValue();    } else {        return l.intValue() >= r.intValue();    }}
public Token<Double> metron_f8044_0(StellarParser.DoubleLiteralContext context, FrameContext.Context contextVariety)
{    if (context == null) {        throw new IllegalArgumentException("Cannot evaluate a context that is null.");    }    return new Token<>(Double.parseDouble(context.getText()), Double.class, contextVariety);}
public boolean metron_f8045_0(final Token<?> left, final Token<?> right, final StellarParser.ComparisonOpContext op)
{    if (left.getValue() == null || right.getValue() == null) {        return left.getValue() == right.getValue();    } else if (left.getValue() instanceof Number && right.getValue() instanceof Number) {        return eq((Number) left.getValue(), (Number) right.getValue());    } else {        return left.getValue().equals(right.getValue());    }}
private boolean metron_f8046_0(final Number l, final Number r)
{    if (l instanceof Double || r instanceof Double) {        return l.doubleValue() == r.doubleValue();    } else if (l instanceof Float || r instanceof Float) {        return l.floatValue() == r.floatValue();    } else if (l instanceof Long || r instanceof Long) {        return l.longValue() == r.longValue();    } else {        return l.intValue() == r.intValue();    }}
public Token<Float> metron_f8047_0(StellarParser.FloatLiteralContext context, FrameContext.Context contextVariety)
{    if (context == null) {        throw new IllegalArgumentException("Cannot evaluate a context that is null.");    }    return new Token<>(Float.parseFloat(context.getText()), Float.class, contextVariety);}
public Token<Integer> metron_f8048_0(StellarParser.IntLiteralContext context, FrameContext.Context contextVariety)
{    if (context == null) {        throw new IllegalArgumentException("Cannot evaluate a context that is null.");    }    return new Token<>(Integer.parseInt(context.getText()), Integer.class, contextVariety);}
public Token<Long> metron_f8049_0(StellarParser.LongLiteralContext context, FrameContext.Context contextVariety)
{    if (context == null) {        throw new IllegalArgumentException("Cannot evaluate a context that is null.");    }    String value = context.getText();    if (value.endsWith("l") || value.endsWith("L")) {                value = value.substring(0, value.length() - 1);        return new Token<>(Long.parseLong(value), Long.class, contextVariety);    } else {                throw new ParseException("Invalid format for long. Failed trying to parse a long with the following value: " + value);    }}
 Token<? extends Number> metron_f8050_0(StellarParser.Arithmetic_operandsContext context, Map<Class<? extends StellarParser.Arithmetic_operandsContext>, NumberEvaluator> instanceMap, FrameContext.Context contextVariety)
{    NumberEvaluator evaluator = instanceMap.get(context.getClass());    if (evaluator == null) {        throw new ParseException("Does not support evaluation for type " + context.getClass());    }    return evaluator.evaluate(context, contextVariety);}
public Token<? extends Number> metron_f8051_0(StellarParser.Arithmetic_operandsContext context, FrameContext.Context contextVariety)
{    return evaluate(context, Strategy.strategyMap, contextVariety);}
public FrameContext metron_f8052_0()
{    return variety;}
public String metron_f8053_0()
{    return "Context{" + "variety=" + variety + '}';}
public Context metron_f8054_0()
{    return new Context(this);}
public void metron_f8055_0(StellarParser.TransformationContext ctx)
{}
public void metron_f8056_0(StellarParser.TransformationContext ctx)
{}
public void metron_f8057_0(StellarParser.ConditionalExprContext ctx)
{}
public void metron_f8058_0(StellarParser.ConditionalExprContext ctx)
{}
public void metron_f8059_0(StellarParser.TransformationExprContext ctx)
{}
public void metron_f8060_0(StellarParser.TransformationExprContext ctx)
{}
public void metron_f8061_0(StellarParser.ArithExpressionContext ctx)
{}
public void metron_f8062_0(StellarParser.ArithExpressionContext ctx)
{}
public void metron_f8063_0(StellarParser.TransformationEntityContext ctx)
{}
public void metron_f8064_0(StellarParser.TransformationEntityContext ctx)
{}
public void metron_f8065_0(StellarParser.ComparisonExpressionContext ctx)
{}
public void metron_f8066_0(StellarParser.ComparisonExpressionContext ctx)
{}
public void metron_f8067_0(StellarParser.LogicalExpressionContext ctx)
{}
public void metron_f8068_0(StellarParser.LogicalExpressionContext ctx)
{}
public void metron_f8069_0(StellarParser.InExpressionContext ctx)
{}
public void metron_f8070_0(StellarParser.InExpressionContext ctx)
{}
public void metron_f8071_0(StellarParser.MatchExprContext ctx)
{}
public void metron_f8072_0(StellarParser.MatchExprContext ctx)
{}
public void metron_f8073_0(StellarParser.If_exprContext ctx)
{}
public void metron_f8074_0(StellarParser.If_exprContext ctx)
{}
public void metron_f8075_0(StellarParser.Then_exprContext ctx)
{}
public void metron_f8076_0(StellarParser.Then_exprContext ctx)
{}
public void metron_f8077_0(StellarParser.Else_exprContext ctx)
{}
public void metron_f8078_0(StellarParser.Else_exprContext ctx)
{}
public void metron_f8079_0(StellarParser.TernaryFuncWithoutIfContext ctx)
{}
public void metron_f8080_0(StellarParser.TernaryFuncWithoutIfContext ctx)
{}
public void metron_f8081_0(StellarParser.TernaryFuncWithIfContext ctx)
{}
public void metron_f8082_0(StellarParser.TernaryFuncWithIfContext ctx)
{}
public void metron_f8083_0(StellarParser.LogicalExpressionAndContext ctx)
{}
public void metron_f8084_0(StellarParser.LogicalExpressionAndContext ctx)
{}
public void metron_f8085_0(StellarParser.LogicalExpressionOrContext ctx)
{}
public void metron_f8086_0(StellarParser.LogicalExpressionOrContext ctx)
{}
public void metron_f8087_0(StellarParser.BoleanExpressionContext ctx)
{}
public void metron_f8088_0(StellarParser.BoleanExpressionContext ctx)
{}
public void metron_f8089_0(StellarParser.B_exprContext ctx)
{}
public void metron_f8090_0(StellarParser.B_exprContext ctx)
{}
public void metron_f8091_0(StellarParser.InExpressionStatementContext ctx)
{}
public void metron_f8092_0(StellarParser.InExpressionStatementContext ctx)
{}
public void metron_f8093_0(StellarParser.NInExpressionStatementContext ctx)
{}
public void metron_f8094_0(StellarParser.NInExpressionStatementContext ctx)
{}
public void metron_f8095_0(StellarParser.NotFuncContext ctx)
{}
public void metron_f8096_0(StellarParser.NotFuncContext ctx)
{}
public void metron_f8097_0(StellarParser.ComparisonExpressionParensContext ctx)
{}
public void metron_f8098_0(StellarParser.ComparisonExpressionParensContext ctx)
{}
public void metron_f8099_0(StellarParser.ComparisonExpressionWithOperatorContext ctx)
{}
public void metron_f8100_0(StellarParser.ComparisonExpressionWithOperatorContext ctx)
{}
public void metron_f8101_0(StellarParser.OperandContext ctx)
{}
public void metron_f8102_0(StellarParser.OperandContext ctx)
{}
public void metron_f8103_0(StellarParser.Transformation_entityContext ctx)
{}
public void metron_f8104_0(StellarParser.Transformation_entityContext ctx)
{}
public void metron_f8105_0(StellarParser.ComparisonOpContext ctx)
{}
public void metron_f8106_0(StellarParser.ComparisonOpContext ctx)
{}
public void metron_f8107_0(StellarParser.Func_argsContext ctx)
{}
public void metron_f8108_0(StellarParser.Func_argsContext ctx)
{}
public void metron_f8109_0(StellarParser.Op_listContext ctx)
{}
public void metron_f8110_0(StellarParser.Op_listContext ctx)
{}
public void metron_f8111_0(StellarParser.List_entityContext ctx)
{}
public void metron_f8112_0(StellarParser.List_entityContext ctx)
{}
public void metron_f8113_0(StellarParser.Kv_listContext ctx)
{}
public void metron_f8114_0(StellarParser.Kv_listContext ctx)
{}
public void metron_f8115_0(StellarParser.Map_entityContext ctx)
{}
public void metron_f8116_0(StellarParser.Map_entityContext ctx)
{}
public void metron_f8117_0(StellarParser.ArithExpr_soloContext ctx)
{}
public void metron_f8118_0(StellarParser.ArithExpr_soloContext ctx)
{}
public void metron_f8119_0(StellarParser.ArithExpr_minusContext ctx)
{}
public void metron_f8120_0(StellarParser.ArithExpr_minusContext ctx)
{}
public void metron_f8121_0(StellarParser.ArithExpr_plusContext ctx)
{}
public void metron_f8122_0(StellarParser.ArithExpr_plusContext ctx)
{}
public void metron_f8123_0(StellarParser.ArithExpr_divContext ctx)
{}
public void metron_f8124_0(StellarParser.ArithExpr_divContext ctx)
{}
public void metron_f8125_0(StellarParser.ArithExpr_mul_soloContext ctx)
{}
public void metron_f8126_0(StellarParser.ArithExpr_mul_soloContext ctx)
{}
public void metron_f8127_0(StellarParser.ArithExpr_mulContext ctx)
{}
public void metron_f8128_0(StellarParser.ArithExpr_mulContext ctx)
{}
public void metron_f8129_0(StellarParser.TransformationFuncContext ctx)
{}
public void metron_f8130_0(StellarParser.TransformationFuncContext ctx)
{}
public void metron_f8131_0(StellarParser.NumericFunctionsContext ctx)
{}
public void metron_f8132_0(StellarParser.NumericFunctionsContext ctx)
{}
public void metron_f8133_0(StellarParser.DoubleLiteralContext ctx)
{}
public void metron_f8134_0(StellarParser.DoubleLiteralContext ctx)
{}
public void metron_f8135_0(StellarParser.IntLiteralContext ctx)
{}
public void metron_f8136_0(StellarParser.IntLiteralContext ctx)
{}
public void metron_f8137_0(StellarParser.LongLiteralContext ctx)
{}
public void metron_f8138_0(StellarParser.LongLiteralContext ctx)
{}
public void metron_f8139_0(StellarParser.FloatLiteralContext ctx)
{}
public void metron_f8140_0(StellarParser.FloatLiteralContext ctx)
{}
public void metron_f8141_0(StellarParser.VariableContext ctx)
{}
public void metron_f8142_0(StellarParser.VariableContext ctx)
{}
public void metron_f8143_0(StellarParser.NaNArithContext ctx)
{}
public void metron_f8144_0(StellarParser.NaNArithContext ctx)
{}
public void metron_f8145_0(StellarParser.ParenArithContext ctx)
{}
public void metron_f8146_0(StellarParser.ParenArithContext ctx)
{}
public void metron_f8147_0(StellarParser.CondExprContext ctx)
{}
public void metron_f8148_0(StellarParser.CondExprContext ctx)
{}
public void metron_f8149_0(StellarParser.LogicalConstContext ctx)
{}
public void metron_f8150_0(StellarParser.LogicalConstContext ctx)
{}
public void metron_f8151_0(StellarParser.LambdaWithArgsExprContext ctx)
{}
public void metron_f8152_0(StellarParser.LambdaWithArgsExprContext ctx)
{}
public void metron_f8153_0(StellarParser.LambdaWithoutArgsExprContext ctx)
{}
public void metron_f8154_0(StellarParser.LambdaWithoutArgsExprContext ctx)
{}
public void metron_f8155_0(StellarParser.ArithmeticOperandsContext ctx)
{}
public void metron_f8156_0(StellarParser.ArithmeticOperandsContext ctx)
{}
public void metron_f8157_0(StellarParser.StringLiteralContext ctx)
{}
public void metron_f8158_0(StellarParser.StringLiteralContext ctx)
{}
public void metron_f8159_0(StellarParser.ListContext ctx)
{}
public void metron_f8160_0(StellarParser.ListContext ctx)
{}
public void metron_f8161_0(StellarParser.MapConstContext ctx)
{}
public void metron_f8162_0(StellarParser.MapConstContext ctx)
{}
public void metron_f8163_0(StellarParser.NullConstContext ctx)
{}
public void metron_f8164_0(StellarParser.NullConstContext ctx)
{}
public void metron_f8165_0(StellarParser.ExistsFuncContext ctx)
{}
public void metron_f8166_0(StellarParser.ExistsFuncContext ctx)
{}
public void metron_f8167_0(StellarParser.CondExpr_parenContext ctx)
{}
public void metron_f8168_0(StellarParser.CondExpr_parenContext ctx)
{}
public void metron_f8169_0(StellarParser.FuncContext ctx)
{}
public void metron_f8170_0(StellarParser.FuncContext ctx)
{}
public void metron_f8171_0(StellarParser.DefaultContext ctx)
{}
public void metron_f8172_0(StellarParser.DefaultContext ctx)
{}
public void metron_f8173_0(StellarParser.Lambda_without_argsContext ctx)
{}
public void metron_f8174_0(StellarParser.Lambda_without_argsContext ctx)
{}
public void metron_f8175_0(StellarParser.Lambda_with_argsContext ctx)
{}
public void metron_f8176_0(StellarParser.Lambda_with_argsContext ctx)
{}
public void metron_f8177_0(StellarParser.Lambda_variablesContext ctx)
{}
public void metron_f8178_0(StellarParser.Lambda_variablesContext ctx)
{}
public void metron_f8179_0(StellarParser.Single_lambda_variableContext ctx)
{}
public void metron_f8180_0(StellarParser.Single_lambda_variableContext ctx)
{}
public void metron_f8181_0(StellarParser.Lambda_variableContext ctx)
{}
public void metron_f8182_0(StellarParser.Lambda_variableContext ctx)
{}
public void metron_f8183_0(StellarParser.MatchClausesContext ctx)
{}
public void metron_f8184_0(StellarParser.MatchClausesContext ctx)
{}
public void metron_f8185_0(StellarParser.Match_clausesContext ctx)
{}
public void metron_f8186_0(StellarParser.Match_clausesContext ctx)
{}
public void metron_f8187_0(StellarParser.Match_clauseContext ctx)
{}
public void metron_f8188_0(StellarParser.Match_clauseContext ctx)
{}
public void metron_f8189_0(StellarParser.MatchClauseActionContext ctx)
{}
public void metron_f8190_0(StellarParser.MatchClauseActionContext ctx)
{}
public void metron_f8191_0(StellarParser.MatchClauseCheckExprContext ctx)
{}
public void metron_f8192_0(StellarParser.MatchClauseCheckExprContext ctx)
{}
public void metron_f8193_0(ParserRuleContext ctx)
{}
public void metron_f8194_0(ParserRuleContext ctx)
{}
public void metron_f8195_0(TerminalNode node)
{}
public void metron_f8196_0(ErrorNode node)
{}
public String[] metron_f8197_0()
{    return tokenNames;}
public Vocabulary metron_f8198_0()
{    return VOCABULARY;}
public String metron_f8199_0()
{    return "Stellar.g4";}
public String[] metron_f8200_0()
{    return ruleNames;}
public String metron_f8201_0()
{    return _serializedATN;}
public String[] metron_f8202_0()
{    return modeNames;}
public ATN metron_f8203_0()
{    return _ATN;}
public String[] metron_f8204_0()
{    return tokenNames;}
public Vocabulary metron_f8205_0()
{    return VOCABULARY;}
public String metron_f8206_0()
{    return "Stellar.g4";}
public String[] metron_f8207_0()
{    return ruleNames;}
public String metron_f8208_0()
{    return _serializedATN;}
public ATN metron_f8209_0()
{    return _ATN;}
public Transformation_exprContext metron_f8210_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public TerminalNode metron_f8211_0()
{    return getToken(StellarParser.EOF, 0);}
public int metron_f8212_0()
{    return RULE_transformation;}
public void metron_f8213_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterTransformation(this);}
public void metron_f8214_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitTransformation(this);}
public final TransformationContext metron_f8215_0() throws RecognitionException
{    TransformationContext _localctx = new TransformationContext(_ctx, getState());    enterRule(_localctx, 0, RULE_transformation);    try {        enterOuterAlt(_localctx, 1);        {            setState(66);            transformation_expr();            setState(67);            match(EOF);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8216_0()
{    return RULE_transformation_expr;}
public void metron_f8217_0(Transformation_exprContext ctx)
{    super.copyFrom(ctx);}
public Comparison_exprContext metron_f8218_0()
{    return getRuleContext(Comparison_exprContext.class, 0);}
public void metron_f8219_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterComparisonExpression(this);}
public void metron_f8220_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitComparisonExpression(this);}
public Logical_exprContext metron_f8221_0()
{    return getRuleContext(Logical_exprContext.class, 0);}
public void metron_f8222_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLogicalExpression(this);}
public void metron_f8223_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLogicalExpression(this);}
public Transformation_entityContext metron_f8224_0()
{    return getRuleContext(Transformation_entityContext.class, 0);}
public void metron_f8225_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterTransformationEntity(this);}
public void metron_f8226_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitTransformationEntity(this);}
public In_exprContext metron_f8227_0()
{    return getRuleContext(In_exprContext.class, 0);}
public void metron_f8228_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterInExpression(this);}
public void metron_f8229_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitInExpression(this);}
public Arithmetic_exprContext metron_f8230_0()
{    return getRuleContext(Arithmetic_exprContext.class, 0);}
public void metron_f8231_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithExpression(this);}
public void metron_f8232_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithExpression(this);}
public TerminalNode metron_f8233_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Transformation_exprContext metron_f8234_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public TerminalNode metron_f8235_0()
{    return getToken(StellarParser.RPAREN, 0);}
public void metron_f8236_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterTransformationExpr(this);}
public void metron_f8237_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitTransformationExpr(this);}
public Conditional_exprContext metron_f8238_0()
{    return getRuleContext(Conditional_exprContext.class, 0);}
public void metron_f8239_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterConditionalExpr(this);}
public void metron_f8240_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitConditionalExpr(this);}
public Match_exprContext metron_f8241_0()
{    return getRuleContext(Match_exprContext.class, 0);}
public void metron_f8242_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMatchExpr(this);}
public void metron_f8243_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMatchExpr(this);}
public final Transformation_exprContext metron_f8244_0() throws RecognitionException
{    Transformation_exprContext _localctx = new Transformation_exprContext(_ctx, getState());    enterRule(_localctx, 2, RULE_transformation_expr);    try {        setState(80);        switch(getInterpreter().adaptivePredict(_input, 0, _ctx)) {            case 1:                _localctx = new ConditionalExprContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(69);                    conditional_expr();                }                break;            case 2:                _localctx = new TransformationExprContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(70);                    match(LPAREN);                    setState(71);                    transformation_expr();                    setState(72);                    match(RPAREN);                }                break;            case 3:                _localctx = new ArithExpressionContext(_localctx);                enterOuterAlt(_localctx, 3);                {                    setState(74);                    arithmetic_expr(0);                }                break;            case 4:                _localctx = new TransformationEntityContext(_localctx);                enterOuterAlt(_localctx, 4);                {                    setState(75);                    transformation_entity();                }                break;            case 5:                _localctx = new ComparisonExpressionContext(_localctx);                enterOuterAlt(_localctx, 5);                {                    setState(76);                    comparison_expr(0);                }                break;            case 6:                _localctx = new LogicalExpressionContext(_localctx);                enterOuterAlt(_localctx, 6);                {                    setState(77);                    logical_expr();                }                break;            case 7:                _localctx = new InExpressionContext(_localctx);                enterOuterAlt(_localctx, 7);                {                    setState(78);                    in_expr();                }                break;            case 8:                _localctx = new MatchExprContext(_localctx);                enterOuterAlt(_localctx, 8);                {                    setState(79);                    match_expr();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Logical_exprContext metron_f8245_0()
{    return getRuleContext(Logical_exprContext.class, 0);}
public int metron_f8246_0()
{    return RULE_if_expr;}
public void metron_f8247_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterIf_expr(this);}
public void metron_f8248_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitIf_expr(this);}
public final If_exprContext metron_f8249_0() throws RecognitionException
{    If_exprContext _localctx = new If_exprContext(_ctx, getState());    enterRule(_localctx, 4, RULE_if_expr);    try {        enterOuterAlt(_localctx, 1);        {            setState(82);            logical_expr();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Transformation_exprContext metron_f8250_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public int metron_f8251_0()
{    return RULE_then_expr;}
public void metron_f8252_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterThen_expr(this);}
public void metron_f8253_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitThen_expr(this);}
public final Then_exprContext metron_f8254_0() throws RecognitionException
{    Then_exprContext _localctx = new Then_exprContext(_ctx, getState());    enterRule(_localctx, 6, RULE_then_expr);    try {        enterOuterAlt(_localctx, 1);        {            setState(84);            transformation_expr();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Transformation_exprContext metron_f8255_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public int metron_f8256_0()
{    return RULE_else_expr;}
public void metron_f8257_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterElse_expr(this);}
public void metron_f8258_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitElse_expr(this);}
public final Else_exprContext metron_f8259_0() throws RecognitionException
{    Else_exprContext _localctx = new Else_exprContext(_ctx, getState());    enterRule(_localctx, 8, RULE_else_expr);    try {        enterOuterAlt(_localctx, 1);        {            setState(86);            transformation_expr();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8260_0()
{    return RULE_conditional_expr;}
public void metron_f8261_0(Conditional_exprContext ctx)
{    super.copyFrom(ctx);}
public If_exprContext metron_f8262_0()
{    return getRuleContext(If_exprContext.class, 0);}
public TerminalNode metron_f8263_0()
{    return getToken(StellarParser.QUESTION, 0);}
public Then_exprContext metron_f8264_0()
{    return getRuleContext(Then_exprContext.class, 0);}
public TerminalNode metron_f8265_0()
{    return getToken(StellarParser.COLON, 0);}
public Else_exprContext metron_f8266_0()
{    return getRuleContext(Else_exprContext.class, 0);}
public void metron_f8267_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterTernaryFuncWithoutIf(this);}
public void metron_f8268_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitTernaryFuncWithoutIf(this);}
public TerminalNode metron_f8269_0()
{    return getToken(StellarParser.IF, 0);}
public If_exprContext metron_f8270_0()
{    return getRuleContext(If_exprContext.class, 0);}
public TerminalNode metron_f8271_0()
{    return getToken(StellarParser.THEN, 0);}
public Then_exprContext metron_f8272_0()
{    return getRuleContext(Then_exprContext.class, 0);}
public TerminalNode metron_f8273_0()
{    return getToken(StellarParser.ELSE, 0);}
public Else_exprContext metron_f8274_0()
{    return getRuleContext(Else_exprContext.class, 0);}
public void metron_f8275_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterTernaryFuncWithIf(this);}
public void metron_f8276_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitTernaryFuncWithIf(this);}
public final Conditional_exprContext metron_f8277_0() throws RecognitionException
{    Conditional_exprContext _localctx = new Conditional_exprContext(_ctx, getState());    enterRule(_localctx, 10, RULE_conditional_expr);    try {        setState(101);        switch(_input.LA(1)) {            case NOT:            case TRUE:            case FALSE:            case NULL:            case NAN:            case LBRACE:            case LBRACKET:            case LPAREN:            case EXISTS:            case INT_LITERAL:            case DOUBLE_LITERAL:            case FLOAT_LITERAL:            case LONG_LITERAL:            case IDENTIFIER:            case STRING_LITERAL:                _localctx = new TernaryFuncWithoutIfContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(88);                    if_expr();                    setState(89);                    match(QUESTION);                    setState(90);                    then_expr();                    setState(91);                    match(COLON);                    setState(92);                    else_expr();                }                break;            case IF:                _localctx = new TernaryFuncWithIfContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(94);                    match(IF);                    setState(95);                    if_expr();                    setState(96);                    match(THEN);                    setState(97);                    then_expr();                    setState(98);                    match(ELSE);                    setState(99);                    else_expr();                }                break;            default:                throw new NoViableAltException(this);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8278_0()
{    return RULE_logical_expr;}
public void metron_f8279_0(Logical_exprContext ctx)
{    super.copyFrom(ctx);}
public B_exprContext metron_f8280_0()
{    return getRuleContext(B_exprContext.class, 0);}
public TerminalNode metron_f8281_0()
{    return getToken(StellarParser.AND, 0);}
public Logical_exprContext metron_f8282_0()
{    return getRuleContext(Logical_exprContext.class, 0);}
public void metron_f8283_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLogicalExpressionAnd(this);}
public void metron_f8284_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLogicalExpressionAnd(this);}
public B_exprContext metron_f8285_0()
{    return getRuleContext(B_exprContext.class, 0);}
public void metron_f8286_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterBoleanExpression(this);}
public void metron_f8287_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitBoleanExpression(this);}
public B_exprContext metron_f8288_0()
{    return getRuleContext(B_exprContext.class, 0);}
public TerminalNode metron_f8289_0()
{    return getToken(StellarParser.OR, 0);}
public Logical_exprContext metron_f8290_0()
{    return getRuleContext(Logical_exprContext.class, 0);}
public void metron_f8291_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLogicalExpressionOr(this);}
public void metron_f8292_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLogicalExpressionOr(this);}
public final Logical_exprContext metron_f8293_0() throws RecognitionException
{    Logical_exprContext _localctx = new Logical_exprContext(_ctx, getState());    enterRule(_localctx, 12, RULE_logical_expr);    try {        setState(112);        switch(getInterpreter().adaptivePredict(_input, 2, _ctx)) {            case 1:                _localctx = new LogicalExpressionAndContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(103);                    b_expr();                    setState(104);                    match(AND);                    setState(105);                    logical_expr();                }                break;            case 2:                _localctx = new LogicalExpressionOrContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(107);                    b_expr();                    setState(108);                    match(OR);                    setState(109);                    logical_expr();                }                break;            case 3:                _localctx = new BoleanExpressionContext(_localctx);                enterOuterAlt(_localctx, 3);                {                    setState(111);                    b_expr();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Comparison_exprContext metron_f8294_0()
{    return getRuleContext(Comparison_exprContext.class, 0);}
public In_exprContext metron_f8295_0()
{    return getRuleContext(In_exprContext.class, 0);}
public int metron_f8296_0()
{    return RULE_b_expr;}
public void metron_f8297_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterB_expr(this);}
public void metron_f8298_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitB_expr(this);}
public final B_exprContext metron_f8299_0() throws RecognitionException
{    B_exprContext _localctx = new B_exprContext(_ctx, getState());    enterRule(_localctx, 14, RULE_b_expr);    try {        setState(116);        switch(getInterpreter().adaptivePredict(_input, 3, _ctx)) {            case 1:                enterOuterAlt(_localctx, 1);                {                    setState(114);                    comparison_expr(0);                }                break;            case 2:                enterOuterAlt(_localctx, 2);                {                    setState(115);                    in_expr();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8300_0()
{    return RULE_in_expr;}
public void metron_f8301_0(In_exprContext ctx)
{    super.copyFrom(ctx);}
public Identifier_operandContext metron_f8302_0()
{    return getRuleContext(Identifier_operandContext.class, 0);}
public TerminalNode metron_f8303_0()
{    return getToken(StellarParser.NIN, 0);}
public B_exprContext metron_f8304_0()
{    return getRuleContext(B_exprContext.class, 0);}
public void metron_f8305_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterNInExpressionStatement(this);}
public void metron_f8306_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitNInExpressionStatement(this);}
public Identifier_operandContext metron_f8307_0()
{    return getRuleContext(Identifier_operandContext.class, 0);}
public TerminalNode metron_f8308_0()
{    return getToken(StellarParser.IN, 0);}
public B_exprContext metron_f8309_0()
{    return getRuleContext(B_exprContext.class, 0);}
public void metron_f8310_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterInExpressionStatement(this);}
public void metron_f8311_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitInExpressionStatement(this);}
public final In_exprContext metron_f8312_0() throws RecognitionException
{    In_exprContext _localctx = new In_exprContext(_ctx, getState());    enterRule(_localctx, 16, RULE_in_expr);    try {        setState(126);        switch(getInterpreter().adaptivePredict(_input, 4, _ctx)) {            case 1:                _localctx = new InExpressionStatementContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(118);                    identifier_operand();                    setState(119);                    match(IN);                    setState(120);                    b_expr();                }                break;            case 2:                _localctx = new NInExpressionStatementContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(122);                    identifier_operand();                    setState(123);                    match(NIN);                    setState(124);                    b_expr();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8313_0()
{    return RULE_comparison_expr;}
public void metron_f8314_0(Comparison_exprContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f8315_0()
{    return getToken(StellarParser.NOT, 0);}
public TerminalNode metron_f8316_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Logical_exprContext metron_f8317_0()
{    return getRuleContext(Logical_exprContext.class, 0);}
public TerminalNode metron_f8318_0()
{    return getToken(StellarParser.RPAREN, 0);}
public void metron_f8319_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterNotFunc(this);}
public void metron_f8320_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitNotFunc(this);}
public TerminalNode metron_f8321_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Logical_exprContext metron_f8322_0()
{    return getRuleContext(Logical_exprContext.class, 0);}
public TerminalNode metron_f8323_0()
{    return getToken(StellarParser.RPAREN, 0);}
public void metron_f8324_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterComparisonExpressionParens(this);}
public void metron_f8325_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitComparisonExpressionParens(this);}
public List<Comparison_exprContext> metron_f8326_0()
{    return getRuleContexts(Comparison_exprContext.class);}
public Comparison_exprContext metron_f8327_0(int i)
{    return getRuleContext(Comparison_exprContext.class, i);}
public Comp_operatorContext metron_f8328_0()
{    return getRuleContext(Comp_operatorContext.class, 0);}
public void metron_f8329_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterComparisonExpressionWithOperator(this);}
public void metron_f8330_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitComparisonExpressionWithOperator(this);}
public Identifier_operandContext metron_f8331_0()
{    return getRuleContext(Identifier_operandContext.class, 0);}
public void metron_f8332_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterOperand(this);}
public void metron_f8333_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitOperand(this);}
public final Comparison_exprContext metron_f8334_0() throws RecognitionException
{    return comparison_expr(0);}
private Comparison_exprContext metron_f8335_0(int _p) throws RecognitionException
{    ParserRuleContext _parentctx = _ctx;    int _parentState = getState();    Comparison_exprContext _localctx = new Comparison_exprContext(_ctx, _parentState);    Comparison_exprContext _prevctx = _localctx;    int _startState = 18;    enterRecursionRule(_localctx, 18, RULE_comparison_expr, _p);    try {        int _alt;        enterOuterAlt(_localctx, 1);        {            setState(139);            switch(getInterpreter().adaptivePredict(_input, 5, _ctx)) {                case 1:                    {                        _localctx = new NotFuncContext(_localctx);                        _ctx = _localctx;                        _prevctx = _localctx;                        setState(129);                        match(NOT);                        setState(130);                        match(LPAREN);                        setState(131);                        logical_expr();                        setState(132);                        match(RPAREN);                    }                    break;                case 2:                    {                        _localctx = new ComparisonExpressionParensContext(_localctx);                        _ctx = _localctx;                        _prevctx = _localctx;                        setState(134);                        match(LPAREN);                        setState(135);                        logical_expr();                        setState(136);                        match(RPAREN);                    }                    break;                case 3:                    {                        _localctx = new OperandContext(_localctx);                        _ctx = _localctx;                        _prevctx = _localctx;                        setState(138);                        identifier_operand();                    }                    break;            }            _ctx.stop = _input.LT(-1);            setState(147);            _errHandler.sync(this);            _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);            while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {                if (_alt == 1) {                    if (_parseListeners != null)                        triggerExitRuleEvent();                    _prevctx = _localctx;                    {                        {                            _localctx = new ComparisonExpressionWithOperatorContext(new Comparison_exprContext(_parentctx, _parentState));                            pushNewRecursionContext(_localctx, _startState, RULE_comparison_expr);                            setState(141);                            if (!(precpred(_ctx, 4)))                                throw new FailedPredicateException(this, "precpred(_ctx, 4)");                            setState(142);                            comp_operator();                            setState(143);                            comparison_expr(5);                        }                    }                }                setState(149);                _errHandler.sync(this);                _alt = getInterpreter().adaptivePredict(_input, 6, _ctx);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        unrollRecursionContexts(_parentctx);    }    return _localctx;}
public Identifier_operandContext metron_f8336_0()
{    return getRuleContext(Identifier_operandContext.class, 0);}
public int metron_f8337_0()
{    return RULE_transformation_entity;}
public void metron_f8338_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterTransformation_entity(this);}
public void metron_f8339_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitTransformation_entity(this);}
public final Transformation_entityContext metron_f8340_0() throws RecognitionException
{    Transformation_entityContext _localctx = new Transformation_entityContext(_ctx, getState());    enterRule(_localctx, 20, RULE_transformation_entity);    try {        enterOuterAlt(_localctx, 1);        {            setState(150);            identifier_operand();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8341_0()
{    return RULE_comp_operator;}
public void metron_f8342_0(Comp_operatorContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f8343_0()
{    return getToken(StellarParser.EQ, 0);}
public TerminalNode metron_f8344_0()
{    return getToken(StellarParser.NEQ, 0);}
public TerminalNode metron_f8345_0()
{    return getToken(StellarParser.LT, 0);}
public TerminalNode metron_f8346_0()
{    return getToken(StellarParser.LTE, 0);}
public TerminalNode metron_f8347_0()
{    return getToken(StellarParser.GT, 0);}
public TerminalNode metron_f8348_0()
{    return getToken(StellarParser.GTE, 0);}
public void metron_f8349_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterComparisonOp(this);}
public void metron_f8350_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitComparisonOp(this);}
public final Comp_operatorContext metron_f8351_0() throws RecognitionException
{    Comp_operatorContext _localctx = new Comp_operatorContext(_ctx, getState());    enterRule(_localctx, 22, RULE_comp_operator);    int _la;    try {        _localctx = new ComparisonOpContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(152);            _la = _input.LA(1);            if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQ) | (1L << NEQ) | (1L << LT) | (1L << LTE) | (1L << GT) | (1L << GTE))) != 0))) {                _errHandler.recoverInline(this);            } else {                consume();            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f8352_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Op_listContext metron_f8353_0()
{    return getRuleContext(Op_listContext.class, 0);}
public TerminalNode metron_f8354_0()
{    return getToken(StellarParser.RPAREN, 0);}
public int metron_f8355_0()
{    return RULE_func_args;}
public void metron_f8356_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterFunc_args(this);}
public void metron_f8357_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitFunc_args(this);}
public final Func_argsContext metron_f8358_0() throws RecognitionException
{    Func_argsContext _localctx = new Func_argsContext(_ctx, getState());    enterRule(_localctx, 24, RULE_func_args);    try {        setState(160);        switch(getInterpreter().adaptivePredict(_input, 7, _ctx)) {            case 1:                enterOuterAlt(_localctx, 1);                {                    setState(154);                    match(LPAREN);                    setState(155);                    op_list(0);                    setState(156);                    match(RPAREN);                }                break;            case 2:                enterOuterAlt(_localctx, 2);                {                    setState(158);                    match(LPAREN);                    setState(159);                    match(RPAREN);                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Identifier_operandContext metron_f8359_0()
{    return getRuleContext(Identifier_operandContext.class, 0);}
public Conditional_exprContext metron_f8360_0()
{    return getRuleContext(Conditional_exprContext.class, 0);}
public Comparison_exprContext metron_f8361_0()
{    return getRuleContext(Comparison_exprContext.class, 0);}
public Op_listContext metron_f8362_0()
{    return getRuleContext(Op_listContext.class, 0);}
public TerminalNode metron_f8363_0()
{    return getToken(StellarParser.COMMA, 0);}
public int metron_f8364_0()
{    return RULE_op_list;}
public void metron_f8365_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterOp_list(this);}
public void metron_f8366_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitOp_list(this);}
public final Op_listContext metron_f8367_0() throws RecognitionException
{    return op_list(0);}
private Op_listContext metron_f8368_0(int _p) throws RecognitionException
{    ParserRuleContext _parentctx = _ctx;    int _parentState = getState();    Op_listContext _localctx = new Op_listContext(_ctx, _parentState);    Op_listContext _prevctx = _localctx;    int _startState = 26;    enterRecursionRule(_localctx, 26, RULE_op_list, _p);    try {        int _alt;        enterOuterAlt(_localctx, 1);        {            setState(166);            switch(getInterpreter().adaptivePredict(_input, 8, _ctx)) {                case 1:                    {                        setState(163);                        identifier_operand();                    }                    break;                case 2:                    {                        setState(164);                        conditional_expr();                    }                    break;                case 3:                    {                        setState(165);                        comparison_expr(0);                    }                    break;            }            _ctx.stop = _input.LT(-1);            setState(179);            _errHandler.sync(this);            _alt = getInterpreter().adaptivePredict(_input, 10, _ctx);            while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {                if (_alt == 1) {                    if (_parseListeners != null)                        triggerExitRuleEvent();                    _prevctx = _localctx;                    {                        setState(177);                        switch(getInterpreter().adaptivePredict(_input, 9, _ctx)) {                            case 1:                                {                                    _localctx = new Op_listContext(_parentctx, _parentState);                                    pushNewRecursionContext(_localctx, _startState, RULE_op_list);                                    setState(168);                                    if (!(precpred(_ctx, 5)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 5)");                                    setState(169);                                    match(COMMA);                                    setState(170);                                    identifier_operand();                                }                                break;                            case 2:                                {                                    _localctx = new Op_listContext(_parentctx, _parentState);                                    pushNewRecursionContext(_localctx, _startState, RULE_op_list);                                    setState(171);                                    if (!(precpred(_ctx, 3)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 3)");                                    setState(172);                                    match(COMMA);                                    setState(173);                                    conditional_expr();                                }                                break;                            case 3:                                {                                    _localctx = new Op_listContext(_parentctx, _parentState);                                    pushNewRecursionContext(_localctx, _startState, RULE_op_list);                                    setState(174);                                    if (!(precpred(_ctx, 1)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 1)");                                    setState(175);                                    match(COMMA);                                    setState(176);                                    comparison_expr(0);                                }                                break;                        }                    }                }                setState(181);                _errHandler.sync(this);                _alt = getInterpreter().adaptivePredict(_input, 10, _ctx);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        unrollRecursionContexts(_parentctx);    }    return _localctx;}
public TerminalNode metron_f8369_0()
{    return getToken(StellarParser.LBRACKET, 0);}
public TerminalNode metron_f8370_0()
{    return getToken(StellarParser.RBRACKET, 0);}
public Op_listContext metron_f8371_0()
{    return getRuleContext(Op_listContext.class, 0);}
public int metron_f8372_0()
{    return RULE_list_entity;}
public void metron_f8373_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterList_entity(this);}
public void metron_f8374_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitList_entity(this);}
public final List_entityContext metron_f8375_0() throws RecognitionException
{    List_entityContext _localctx = new List_entityContext(_ctx, getState());    enterRule(_localctx, 28, RULE_list_entity);    try {        setState(188);        switch(getInterpreter().adaptivePredict(_input, 11, _ctx)) {            case 1:                enterOuterAlt(_localctx, 1);                {                    setState(182);                    match(LBRACKET);                    setState(183);                    match(RBRACKET);                }                break;            case 2:                enterOuterAlt(_localctx, 2);                {                    setState(184);                    match(LBRACKET);                    setState(185);                    op_list(0);                    setState(186);                    match(RBRACKET);                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Identifier_operandContext metron_f8376_0()
{    return getRuleContext(Identifier_operandContext.class, 0);}
public TerminalNode metron_f8377_0()
{    return getToken(StellarParser.COLON, 0);}
public Transformation_exprContext metron_f8378_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public Comparison_exprContext metron_f8379_0()
{    return getRuleContext(Comparison_exprContext.class, 0);}
public Kv_listContext metron_f8380_0()
{    return getRuleContext(Kv_listContext.class, 0);}
public TerminalNode metron_f8381_0()
{    return getToken(StellarParser.COMMA, 0);}
public int metron_f8382_0()
{    return RULE_kv_list;}
public void metron_f8383_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterKv_list(this);}
public void metron_f8384_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitKv_list(this);}
public final Kv_listContext metron_f8385_0() throws RecognitionException
{    return kv_list(0);}
private Kv_listContext metron_f8386_0(int _p) throws RecognitionException
{    ParserRuleContext _parentctx = _ctx;    int _parentState = getState();    Kv_listContext _localctx = new Kv_listContext(_ctx, _parentState);    Kv_listContext _prevctx = _localctx;    int _startState = 30;    enterRecursionRule(_localctx, 30, RULE_kv_list, _p);    try {        int _alt;        enterOuterAlt(_localctx, 1);        {            setState(199);            switch(getInterpreter().adaptivePredict(_input, 12, _ctx)) {                case 1:                    {                        setState(191);                        identifier_operand();                        setState(192);                        match(COLON);                        setState(193);                        transformation_expr();                    }                    break;                case 2:                    {                        setState(195);                        comparison_expr(0);                        setState(196);                        match(COLON);                        setState(197);                        transformation_expr();                    }                    break;            }            _ctx.stop = _input.LT(-1);            setState(215);            _errHandler.sync(this);            _alt = getInterpreter().adaptivePredict(_input, 14, _ctx);            while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {                if (_alt == 1) {                    if (_parseListeners != null)                        triggerExitRuleEvent();                    _prevctx = _localctx;                    {                        setState(213);                        switch(getInterpreter().adaptivePredict(_input, 13, _ctx)) {                            case 1:                                {                                    _localctx = new Kv_listContext(_parentctx, _parentState);                                    pushNewRecursionContext(_localctx, _startState, RULE_kv_list);                                    setState(201);                                    if (!(precpred(_ctx, 2)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 2)");                                    setState(202);                                    match(COMMA);                                    setState(203);                                    identifier_operand();                                    setState(204);                                    match(COLON);                                    setState(205);                                    transformation_expr();                                }                                break;                            case 2:                                {                                    _localctx = new Kv_listContext(_parentctx, _parentState);                                    pushNewRecursionContext(_localctx, _startState, RULE_kv_list);                                    setState(207);                                    if (!(precpred(_ctx, 1)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 1)");                                    setState(208);                                    match(COMMA);                                    setState(209);                                    comparison_expr(0);                                    setState(210);                                    match(COLON);                                    setState(211);                                    transformation_expr();                                }                                break;                        }                    }                }                setState(217);                _errHandler.sync(this);                _alt = getInterpreter().adaptivePredict(_input, 14, _ctx);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        unrollRecursionContexts(_parentctx);    }    return _localctx;}
public TerminalNode metron_f8387_0()
{    return getToken(StellarParser.LBRACE, 0);}
public Kv_listContext metron_f8388_0()
{    return getRuleContext(Kv_listContext.class, 0);}
public TerminalNode metron_f8389_0()
{    return getToken(StellarParser.RBRACE, 0);}
public int metron_f8390_0()
{    return RULE_map_entity;}
public void metron_f8391_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMap_entity(this);}
public void metron_f8392_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMap_entity(this);}
public final Map_entityContext metron_f8393_0() throws RecognitionException
{    Map_entityContext _localctx = new Map_entityContext(_ctx, getState());    enterRule(_localctx, 32, RULE_map_entity);    try {        setState(224);        switch(getInterpreter().adaptivePredict(_input, 15, _ctx)) {            case 1:                enterOuterAlt(_localctx, 1);                {                    setState(218);                    match(LBRACE);                    setState(219);                    kv_list(0);                    setState(220);                    match(RBRACE);                }                break;            case 2:                enterOuterAlt(_localctx, 2);                {                    setState(222);                    match(LBRACE);                    setState(223);                    match(RBRACE);                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8394_0()
{    return RULE_arithmetic_expr;}
public void metron_f8395_0(Arithmetic_exprContext ctx)
{    super.copyFrom(ctx);}
public Arithmetic_expr_mulContext metron_f8396_0()
{    return getRuleContext(Arithmetic_expr_mulContext.class, 0);}
public void metron_f8397_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithExpr_solo(this);}
public void metron_f8398_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithExpr_solo(this);}
public Arithmetic_exprContext metron_f8399_0()
{    return getRuleContext(Arithmetic_exprContext.class, 0);}
public TerminalNode metron_f8400_0()
{    return getToken(StellarParser.MINUS, 0);}
public Arithmetic_expr_mulContext metron_f8401_0()
{    return getRuleContext(Arithmetic_expr_mulContext.class, 0);}
public void metron_f8402_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithExpr_minus(this);}
public void metron_f8403_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithExpr_minus(this);}
public Arithmetic_exprContext metron_f8404_0()
{    return getRuleContext(Arithmetic_exprContext.class, 0);}
public TerminalNode metron_f8405_0()
{    return getToken(StellarParser.PLUS, 0);}
public Arithmetic_expr_mulContext metron_f8406_0()
{    return getRuleContext(Arithmetic_expr_mulContext.class, 0);}
public void metron_f8407_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithExpr_plus(this);}
public void metron_f8408_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithExpr_plus(this);}
public final Arithmetic_exprContext metron_f8409_0() throws RecognitionException
{    return arithmetic_expr(0);}
private Arithmetic_exprContext metron_f8410_0(int _p) throws RecognitionException
{    ParserRuleContext _parentctx = _ctx;    int _parentState = getState();    Arithmetic_exprContext _localctx = new Arithmetic_exprContext(_ctx, _parentState);    Arithmetic_exprContext _prevctx = _localctx;    int _startState = 34;    enterRecursionRule(_localctx, 34, RULE_arithmetic_expr, _p);    try {        int _alt;        enterOuterAlt(_localctx, 1);        {            {                _localctx = new ArithExpr_soloContext(_localctx);                _ctx = _localctx;                _prevctx = _localctx;                setState(227);                arithmetic_expr_mul(0);            }            _ctx.stop = _input.LT(-1);            setState(237);            _errHandler.sync(this);            _alt = getInterpreter().adaptivePredict(_input, 17, _ctx);            while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {                if (_alt == 1) {                    if (_parseListeners != null)                        triggerExitRuleEvent();                    _prevctx = _localctx;                    {                        setState(235);                        switch(getInterpreter().adaptivePredict(_input, 16, _ctx)) {                            case 1:                                {                                    _localctx = new ArithExpr_plusContext(new Arithmetic_exprContext(_parentctx, _parentState));                                    pushNewRecursionContext(_localctx, _startState, RULE_arithmetic_expr);                                    setState(229);                                    if (!(precpred(_ctx, 2)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 2)");                                    setState(230);                                    match(PLUS);                                    setState(231);                                    arithmetic_expr_mul(0);                                }                                break;                            case 2:                                {                                    _localctx = new ArithExpr_minusContext(new Arithmetic_exprContext(_parentctx, _parentState));                                    pushNewRecursionContext(_localctx, _startState, RULE_arithmetic_expr);                                    setState(232);                                    if (!(precpred(_ctx, 1)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 1)");                                    setState(233);                                    match(MINUS);                                    setState(234);                                    arithmetic_expr_mul(0);                                }                                break;                        }                    }                }                setState(239);                _errHandler.sync(this);                _alt = getInterpreter().adaptivePredict(_input, 17, _ctx);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        unrollRecursionContexts(_parentctx);    }    return _localctx;}
public int metron_f8411_0()
{    return RULE_arithmetic_expr_mul;}
public void metron_f8412_0(Arithmetic_expr_mulContext ctx)
{    super.copyFrom(ctx);}
public List<Arithmetic_expr_mulContext> metron_f8413_0()
{    return getRuleContexts(Arithmetic_expr_mulContext.class);}
public Arithmetic_expr_mulContext metron_f8414_0(int i)
{    return getRuleContext(Arithmetic_expr_mulContext.class, i);}
public TerminalNode metron_f8415_0()
{    return getToken(StellarParser.DIV, 0);}
public void metron_f8416_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithExpr_div(this);}
public void metron_f8417_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithExpr_div(this);}
public Arithmetic_operandsContext metron_f8418_0()
{    return getRuleContext(Arithmetic_operandsContext.class, 0);}
public void metron_f8419_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithExpr_mul_solo(this);}
public void metron_f8420_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithExpr_mul_solo(this);}
public List<Arithmetic_expr_mulContext> metron_f8421_0()
{    return getRuleContexts(Arithmetic_expr_mulContext.class);}
public Arithmetic_expr_mulContext metron_f8422_0(int i)
{    return getRuleContext(Arithmetic_expr_mulContext.class, i);}
public TerminalNode metron_f8423_0()
{    return getToken(StellarParser.MUL, 0);}
public void metron_f8424_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithExpr_mul(this);}
public void metron_f8425_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithExpr_mul(this);}
public final Arithmetic_expr_mulContext metron_f8426_0() throws RecognitionException
{    return arithmetic_expr_mul(0);}
private Arithmetic_expr_mulContext metron_f8427_0(int _p) throws RecognitionException
{    ParserRuleContext _parentctx = _ctx;    int _parentState = getState();    Arithmetic_expr_mulContext _localctx = new Arithmetic_expr_mulContext(_ctx, _parentState);    Arithmetic_expr_mulContext _prevctx = _localctx;    int _startState = 36;    enterRecursionRule(_localctx, 36, RULE_arithmetic_expr_mul, _p);    try {        int _alt;        enterOuterAlt(_localctx, 1);        {            {                _localctx = new ArithExpr_mul_soloContext(_localctx);                _ctx = _localctx;                _prevctx = _localctx;                setState(241);                arithmetic_operands();            }            _ctx.stop = _input.LT(-1);            setState(251);            _errHandler.sync(this);            _alt = getInterpreter().adaptivePredict(_input, 19, _ctx);            while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {                if (_alt == 1) {                    if (_parseListeners != null)                        triggerExitRuleEvent();                    _prevctx = _localctx;                    {                        setState(249);                        switch(getInterpreter().adaptivePredict(_input, 18, _ctx)) {                            case 1:                                {                                    _localctx = new ArithExpr_mulContext(new Arithmetic_expr_mulContext(_parentctx, _parentState));                                    pushNewRecursionContext(_localctx, _startState, RULE_arithmetic_expr_mul);                                    setState(243);                                    if (!(precpred(_ctx, 2)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 2)");                                    setState(244);                                    match(MUL);                                    setState(245);                                    arithmetic_expr_mul(3);                                }                                break;                            case 2:                                {                                    _localctx = new ArithExpr_divContext(new Arithmetic_expr_mulContext(_parentctx, _parentState));                                    pushNewRecursionContext(_localctx, _startState, RULE_arithmetic_expr_mul);                                    setState(246);                                    if (!(precpred(_ctx, 1)))                                        throw new FailedPredicateException(this, "precpred(_ctx, 1)");                                    setState(247);                                    match(DIV);                                    setState(248);                                    arithmetic_expr_mul(2);                                }                                break;                        }                    }                }                setState(253);                _errHandler.sync(this);                _alt = getInterpreter().adaptivePredict(_input, 19, _ctx);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        unrollRecursionContexts(_parentctx);    }    return _localctx;}
public int metron_f8428_0()
{    return RULE_functions;}
public void metron_f8429_0(FunctionsContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f8430_0()
{    return getToken(StellarParser.IDENTIFIER, 0);}
public Func_argsContext metron_f8431_0()
{    return getRuleContext(Func_argsContext.class, 0);}
public void metron_f8432_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterTransformationFunc(this);}
public void metron_f8433_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitTransformationFunc(this);}
public final FunctionsContext metron_f8434_0() throws RecognitionException
{    FunctionsContext _localctx = new FunctionsContext(_ctx, getState());    enterRule(_localctx, 38, RULE_functions);    try {        _localctx = new TransformationFuncContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(254);            match(IDENTIFIER);            setState(255);            func_args();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8435_0()
{    return RULE_arithmetic_operands;}
public void metron_f8436_0(Arithmetic_operandsContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f8437_0()
{    return getToken(StellarParser.IDENTIFIER, 0);}
public void metron_f8438_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterVariable(this);}
public void metron_f8439_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitVariable(this);}
public FunctionsContext metron_f8440_0()
{    return getRuleContext(FunctionsContext.class, 0);}
public void metron_f8441_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterNumericFunctions(this);}
public void metron_f8442_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitNumericFunctions(this);}
public TerminalNode metron_f8443_0()
{    return getToken(StellarParser.LONG_LITERAL, 0);}
public void metron_f8444_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLongLiteral(this);}
public void metron_f8445_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLongLiteral(this);}
public TerminalNode metron_f8446_0()
{    return getToken(StellarParser.FLOAT_LITERAL, 0);}
public void metron_f8447_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterFloatLiteral(this);}
public void metron_f8448_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitFloatLiteral(this);}
public TerminalNode metron_f8449_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Conditional_exprContext metron_f8450_0()
{    return getRuleContext(Conditional_exprContext.class, 0);}
public TerminalNode metron_f8451_0()
{    return getToken(StellarParser.RPAREN, 0);}
public void metron_f8452_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterCondExpr(this);}
public void metron_f8453_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitCondExpr(this);}
public TerminalNode metron_f8454_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Arithmetic_exprContext metron_f8455_0()
{    return getRuleContext(Arithmetic_exprContext.class, 0);}
public TerminalNode metron_f8456_0()
{    return getToken(StellarParser.RPAREN, 0);}
public void metron_f8457_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterParenArith(this);}
public void metron_f8458_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitParenArith(this);}
public TerminalNode metron_f8459_0()
{    return getToken(StellarParser.INT_LITERAL, 0);}
public void metron_f8460_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterIntLiteral(this);}
public void metron_f8461_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitIntLiteral(this);}
public TerminalNode metron_f8462_0()
{    return getToken(StellarParser.NAN, 0);}
public void metron_f8463_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterNaNArith(this);}
public void metron_f8464_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitNaNArith(this);}
public TerminalNode metron_f8465_0()
{    return getToken(StellarParser.DOUBLE_LITERAL, 0);}
public void metron_f8466_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterDoubleLiteral(this);}
public void metron_f8467_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitDoubleLiteral(this);}
public final Arithmetic_operandsContext metron_f8468_0() throws RecognitionException
{    Arithmetic_operandsContext _localctx = new Arithmetic_operandsContext(_ctx, getState());    enterRule(_localctx, 40, RULE_arithmetic_operands);    try {        setState(272);        switch(getInterpreter().adaptivePredict(_input, 20, _ctx)) {            case 1:                _localctx = new NumericFunctionsContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(257);                    functions();                }                break;            case 2:                _localctx = new DoubleLiteralContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(258);                    match(DOUBLE_LITERAL);                }                break;            case 3:                _localctx = new IntLiteralContext(_localctx);                enterOuterAlt(_localctx, 3);                {                    setState(259);                    match(INT_LITERAL);                }                break;            case 4:                _localctx = new LongLiteralContext(_localctx);                enterOuterAlt(_localctx, 4);                {                    setState(260);                    match(LONG_LITERAL);                }                break;            case 5:                _localctx = new FloatLiteralContext(_localctx);                enterOuterAlt(_localctx, 5);                {                    setState(261);                    match(FLOAT_LITERAL);                }                break;            case 6:                _localctx = new VariableContext(_localctx);                enterOuterAlt(_localctx, 6);                {                    setState(262);                    match(IDENTIFIER);                }                break;            case 7:                _localctx = new NaNArithContext(_localctx);                enterOuterAlt(_localctx, 7);                {                    setState(263);                    match(NAN);                }                break;            case 8:                _localctx = new ParenArithContext(_localctx);                enterOuterAlt(_localctx, 8);                {                    setState(264);                    match(LPAREN);                    setState(265);                    arithmetic_expr(0);                    setState(266);                    match(RPAREN);                }                break;            case 9:                _localctx = new CondExprContext(_localctx);                enterOuterAlt(_localctx, 9);                {                    setState(268);                    match(LPAREN);                    setState(269);                    conditional_expr();                    setState(270);                    match(RPAREN);                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8469_0()
{    return RULE_identifier_operand;}
public void metron_f8470_0(Identifier_operandContext ctx)
{    super.copyFrom(ctx);}
public Arithmetic_exprContext metron_f8471_0()
{    return getRuleContext(Arithmetic_exprContext.class, 0);}
public void metron_f8472_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterArithmeticOperands(this);}
public void metron_f8473_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitArithmeticOperands(this);}
public Lambda_with_argsContext metron_f8474_0()
{    return getRuleContext(Lambda_with_argsContext.class, 0);}
public void metron_f8475_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLambdaWithArgsExpr(this);}
public void metron_f8476_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLambdaWithArgsExpr(this);}
public TerminalNode metron_f8477_0()
{    return getToken(StellarParser.STRING_LITERAL, 0);}
public void metron_f8478_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterStringLiteral(this);}
public void metron_f8479_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitStringLiteral(this);}
public FunctionsContext metron_f8480_0()
{    return getRuleContext(FunctionsContext.class, 0);}
public void metron_f8481_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterFunc(this);}
public void metron_f8482_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitFunc(this);}
public Lambda_without_argsContext metron_f8483_0()
{    return getRuleContext(Lambda_without_argsContext.class, 0);}
public void metron_f8484_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLambdaWithoutArgsExpr(this);}
public void metron_f8485_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLambdaWithoutArgsExpr(this);}
public List_entityContext metron_f8486_0()
{    return getRuleContext(List_entityContext.class, 0);}
public void metron_f8487_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterList(this);}
public void metron_f8488_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitList(this);}
public Map_entityContext metron_f8489_0()
{    return getRuleContext(Map_entityContext.class, 0);}
public void metron_f8490_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMapConst(this);}
public void metron_f8491_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMapConst(this);}
public TerminalNode metron_f8492_0()
{    return getToken(StellarParser.TRUE, 0);}
public TerminalNode metron_f8493_0()
{    return getToken(StellarParser.FALSE, 0);}
public void metron_f8494_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLogicalConst(this);}
public void metron_f8495_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLogicalConst(this);}
public TerminalNode metron_f8496_0()
{    return getToken(StellarParser.NULL, 0);}
public void metron_f8497_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterNullConst(this);}
public void metron_f8498_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitNullConst(this);}
public TerminalNode metron_f8499_0()
{    return getToken(StellarParser.EXISTS, 0);}
public TerminalNode metron_f8500_0()
{    return getToken(StellarParser.LPAREN, 0);}
public TerminalNode metron_f8501_0()
{    return getToken(StellarParser.IDENTIFIER, 0);}
public TerminalNode metron_f8502_0()
{    return getToken(StellarParser.RPAREN, 0);}
public void metron_f8503_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterExistsFunc(this);}
public void metron_f8504_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitExistsFunc(this);}
public TerminalNode metron_f8505_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Conditional_exprContext metron_f8506_0()
{    return getRuleContext(Conditional_exprContext.class, 0);}
public TerminalNode metron_f8507_0()
{    return getToken(StellarParser.RPAREN, 0);}
public void metron_f8508_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterCondExpr_paren(this);}
public void metron_f8509_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitCondExpr_paren(this);}
public final Identifier_operandContext metron_f8510_0() throws RecognitionException
{    Identifier_operandContext _localctx = new Identifier_operandContext(_ctx, getState());    enterRule(_localctx, 42, RULE_identifier_operand);    int _la;    try {        setState(291);        switch(getInterpreter().adaptivePredict(_input, 21, _ctx)) {            case 1:                _localctx = new LogicalConstContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(274);                    _la = _input.LA(1);                    if (!(_la == TRUE || _la == FALSE)) {                        _errHandler.recoverInline(this);                    } else {                        consume();                    }                }                break;            case 2:                _localctx = new LambdaWithArgsExprContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(275);                    lambda_with_args();                }                break;            case 3:                _localctx = new LambdaWithoutArgsExprContext(_localctx);                enterOuterAlt(_localctx, 3);                {                    setState(276);                    lambda_without_args();                }                break;            case 4:                _localctx = new ArithmeticOperandsContext(_localctx);                enterOuterAlt(_localctx, 4);                {                    setState(277);                    arithmetic_expr(0);                }                break;            case 5:                _localctx = new StringLiteralContext(_localctx);                enterOuterAlt(_localctx, 5);                {                    setState(278);                    match(STRING_LITERAL);                }                break;            case 6:                _localctx = new ListContext(_localctx);                enterOuterAlt(_localctx, 6);                {                    setState(279);                    list_entity();                }                break;            case 7:                _localctx = new MapConstContext(_localctx);                enterOuterAlt(_localctx, 7);                {                    setState(280);                    map_entity();                }                break;            case 8:                _localctx = new NullConstContext(_localctx);                enterOuterAlt(_localctx, 8);                {                    setState(281);                    match(NULL);                }                break;            case 9:                _localctx = new ExistsFuncContext(_localctx);                enterOuterAlt(_localctx, 9);                {                    setState(282);                    match(EXISTS);                    setState(283);                    match(LPAREN);                    setState(284);                    match(IDENTIFIER);                    setState(285);                    match(RPAREN);                }                break;            case 10:                _localctx = new CondExpr_parenContext(_localctx);                enterOuterAlt(_localctx, 10);                {                    setState(286);                    match(LPAREN);                    setState(287);                    conditional_expr();                    setState(288);                    match(RPAREN);                }                break;            case 11:                _localctx = new FuncContext(_localctx);                enterOuterAlt(_localctx, 11);                {                    setState(290);                    functions();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8511_0()
{    return RULE_default_operand;}
public void metron_f8512_0(Default_operandContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f8513_0()
{    return getToken(StellarParser.DEFAULT, 0);}
public void metron_f8514_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterDefault(this);}
public void metron_f8515_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitDefault(this);}
public final Default_operandContext metron_f8516_0() throws RecognitionException
{    Default_operandContext _localctx = new Default_operandContext(_ctx, getState());    enterRule(_localctx, 44, RULE_default_operand);    try {        _localctx = new DefaultContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(293);            match(DEFAULT);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f8517_0()
{    return getToken(StellarParser.LPAREN, 0);}
public TerminalNode metron_f8518_0()
{    return getToken(StellarParser.RPAREN, 0);}
public TerminalNode metron_f8519_0()
{    return getToken(StellarParser.LAMBDA_OP, 0);}
public Transformation_exprContext metron_f8520_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public int metron_f8521_0()
{    return RULE_lambda_without_args;}
public void metron_f8522_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLambda_without_args(this);}
public void metron_f8523_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLambda_without_args(this);}
public final Lambda_without_argsContext metron_f8524_0() throws RecognitionException
{    Lambda_without_argsContext _localctx = new Lambda_without_argsContext(_ctx, getState());    enterRule(_localctx, 46, RULE_lambda_without_args);    try {        enterOuterAlt(_localctx, 1);        {            setState(295);            match(LPAREN);            setState(296);            match(RPAREN);            setState(297);            match(LAMBDA_OP);            setState(298);            transformation_expr();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f8525_0()
{    return getToken(StellarParser.LPAREN, 0);}
public Lambda_variablesContext metron_f8526_0()
{    return getRuleContext(Lambda_variablesContext.class, 0);}
public TerminalNode metron_f8527_0()
{    return getToken(StellarParser.RPAREN, 0);}
public TerminalNode metron_f8528_0()
{    return getToken(StellarParser.LAMBDA_OP, 0);}
public Transformation_exprContext metron_f8529_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public Single_lambda_variableContext metron_f8530_0()
{    return getRuleContext(Single_lambda_variableContext.class, 0);}
public int metron_f8531_0()
{    return RULE_lambda_with_args;}
public void metron_f8532_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLambda_with_args(this);}
public void metron_f8533_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLambda_with_args(this);}
public final Lambda_with_argsContext metron_f8534_0() throws RecognitionException
{    Lambda_with_argsContext _localctx = new Lambda_with_argsContext(_ctx, getState());    enterRule(_localctx, 48, RULE_lambda_with_args);    try {        setState(310);        switch(_input.LA(1)) {            case LPAREN:                enterOuterAlt(_localctx, 1);                {                    setState(300);                    match(LPAREN);                    setState(301);                    lambda_variables();                    setState(302);                    match(RPAREN);                    setState(303);                    match(LAMBDA_OP);                    setState(304);                    transformation_expr();                }                break;            case IDENTIFIER:                enterOuterAlt(_localctx, 2);                {                    setState(306);                    single_lambda_variable();                    setState(307);                    match(LAMBDA_OP);                    setState(308);                    transformation_expr();                }                break;            default:                throw new NoViableAltException(this);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public List<Lambda_variableContext> metron_f8535_0()
{    return getRuleContexts(Lambda_variableContext.class);}
public Lambda_variableContext metron_f8536_0(int i)
{    return getRuleContext(Lambda_variableContext.class, i);}
public List<TerminalNode> metron_f8537_0()
{    return getTokens(StellarParser.COMMA);}
public TerminalNode metron_f8538_0(int i)
{    return getToken(StellarParser.COMMA, i);}
public int metron_f8539_0()
{    return RULE_lambda_variables;}
public void metron_f8540_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLambda_variables(this);}
public void metron_f8541_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLambda_variables(this);}
public final Lambda_variablesContext metron_f8542_0() throws RecognitionException
{    Lambda_variablesContext _localctx = new Lambda_variablesContext(_ctx, getState());    enterRule(_localctx, 50, RULE_lambda_variables);    int _la;    try {        enterOuterAlt(_localctx, 1);        {            setState(312);            lambda_variable();            setState(317);            _errHandler.sync(this);            _la = _input.LA(1);            while (_la == COMMA) {                {                    {                        setState(313);                        match(COMMA);                        setState(314);                        lambda_variable();                    }                }                setState(319);                _errHandler.sync(this);                _la = _input.LA(1);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Lambda_variableContext metron_f8543_0()
{    return getRuleContext(Lambda_variableContext.class, 0);}
public int metron_f8544_0()
{    return RULE_single_lambda_variable;}
public void metron_f8545_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterSingle_lambda_variable(this);}
public void metron_f8546_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitSingle_lambda_variable(this);}
public final Single_lambda_variableContext metron_f8547_0() throws RecognitionException
{    Single_lambda_variableContext _localctx = new Single_lambda_variableContext(_ctx, getState());    enterRule(_localctx, 52, RULE_single_lambda_variable);    try {        enterOuterAlt(_localctx, 1);        {            setState(320);            lambda_variable();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public TerminalNode metron_f8548_0()
{    return getToken(StellarParser.IDENTIFIER, 0);}
public int metron_f8549_0()
{    return RULE_lambda_variable;}
public void metron_f8550_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterLambda_variable(this);}
public void metron_f8551_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitLambda_variable(this);}
public final Lambda_variableContext metron_f8552_0() throws RecognitionException
{    Lambda_variableContext _localctx = new Lambda_variableContext(_ctx, getState());    enterRule(_localctx, 54, RULE_lambda_variable);    try {        enterOuterAlt(_localctx, 1);        {            setState(322);            match(IDENTIFIER);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8553_0()
{    return RULE_match_expr;}
public void metron_f8554_0(Match_exprContext ctx)
{    super.copyFrom(ctx);}
public TerminalNode metron_f8555_0()
{    return getToken(StellarParser.MATCH, 0);}
public TerminalNode metron_f8556_0()
{    return getToken(StellarParser.LBRACE, 0);}
public Match_clausesContext metron_f8557_0()
{    return getRuleContext(Match_clausesContext.class, 0);}
public TerminalNode metron_f8558_0()
{    return getToken(StellarParser.COMMA, 0);}
public TerminalNode metron_f8559_0()
{    return getToken(StellarParser.DEFAULT, 0);}
public TerminalNode metron_f8560_0()
{    return getToken(StellarParser.MATCH_ACTION, 0);}
public Match_clause_actionContext metron_f8561_0()
{    return getRuleContext(Match_clause_actionContext.class, 0);}
public TerminalNode metron_f8562_0()
{    return getToken(StellarParser.RBRACE, 0);}
public void metron_f8563_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMatchClauses(this);}
public void metron_f8564_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMatchClauses(this);}
public final Match_exprContext metron_f8565_0() throws RecognitionException
{    Match_exprContext _localctx = new Match_exprContext(_ctx, getState());    enterRule(_localctx, 56, RULE_match_expr);    try {        _localctx = new MatchClausesContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(324);            match(MATCH);            setState(325);            match(LBRACE);            setState(326);            match_clauses();            setState(327);            match(COMMA);            setState(328);            match(DEFAULT);            setState(329);            match(MATCH_ACTION);            setState(330);            match_clause_action();            setState(331);            match(RBRACE);        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public List<Match_clauseContext> metron_f8566_0()
{    return getRuleContexts(Match_clauseContext.class);}
public Match_clauseContext metron_f8567_0(int i)
{    return getRuleContext(Match_clauseContext.class, i);}
public List<TerminalNode> metron_f8568_0()
{    return getTokens(StellarParser.COMMA);}
public TerminalNode metron_f8569_0(int i)
{    return getToken(StellarParser.COMMA, i);}
public int metron_f8570_0()
{    return RULE_match_clauses;}
public void metron_f8571_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMatch_clauses(this);}
public void metron_f8572_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMatch_clauses(this);}
public final Match_clausesContext metron_f8573_0() throws RecognitionException
{    Match_clausesContext _localctx = new Match_clausesContext(_ctx, getState());    enterRule(_localctx, 58, RULE_match_clauses);    try {        int _alt;        enterOuterAlt(_localctx, 1);        {            setState(333);            match_clause();            setState(338);            _errHandler.sync(this);            _alt = getInterpreter().adaptivePredict(_input, 24, _ctx);            while (_alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER) {                if (_alt == 1) {                    {                        {                            setState(334);                            match(COMMA);                            setState(335);                            match_clause();                        }                    }                }                setState(340);                _errHandler.sync(this);                _alt = getInterpreter().adaptivePredict(_input, 24, _ctx);            }        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public Match_clause_checkContext metron_f8574_0()
{    return getRuleContext(Match_clause_checkContext.class, 0);}
public TerminalNode metron_f8575_0()
{    return getToken(StellarParser.MATCH_ACTION, 0);}
public Match_clause_actionContext metron_f8576_0()
{    return getRuleContext(Match_clause_actionContext.class, 0);}
public int metron_f8577_0()
{    return RULE_match_clause;}
public void metron_f8578_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMatch_clause(this);}
public void metron_f8579_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMatch_clause(this);}
public final Match_clauseContext metron_f8580_0() throws RecognitionException
{    Match_clauseContext _localctx = new Match_clauseContext(_ctx, getState());    enterRule(_localctx, 60, RULE_match_clause);    try {        enterOuterAlt(_localctx, 1);        {            setState(341);            match_clause_check();            setState(342);            match(MATCH_ACTION);            setState(343);            match_clause_action();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8581_0()
{    return RULE_match_clause_action;}
public void metron_f8582_0(Match_clause_actionContext ctx)
{    super.copyFrom(ctx);}
public Transformation_exprContext metron_f8583_0()
{    return getRuleContext(Transformation_exprContext.class, 0);}
public void metron_f8584_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMatchClauseAction(this);}
public void metron_f8585_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMatchClauseAction(this);}
public final Match_clause_actionContext metron_f8586_0() throws RecognitionException
{    Match_clause_actionContext _localctx = new Match_clause_actionContext(_ctx, getState());    enterRule(_localctx, 62, RULE_match_clause_action);    try {        _localctx = new MatchClauseActionContext(_localctx);        enterOuterAlt(_localctx, 1);        {            setState(345);            transformation_expr();        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public int metron_f8587_0()
{    return RULE_match_clause_check;}
public void metron_f8588_0(Match_clause_checkContext ctx)
{    super.copyFrom(ctx);}
public Logical_exprContext metron_f8589_0()
{    return getRuleContext(Logical_exprContext.class, 0);}
public Conditional_exprContext metron_f8590_0()
{    return getRuleContext(Conditional_exprContext.class, 0);}
public void metron_f8591_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).enterMatchClauseCheckExpr(this);}
public void metron_f8592_0(ParseTreeListener listener)
{    if (listener instanceof StellarListener)        ((StellarListener) listener).exitMatchClauseCheckExpr(this);}
public final Match_clause_checkContext metron_f8593_0() throws RecognitionException
{    Match_clause_checkContext _localctx = new Match_clause_checkContext(_ctx, getState());    enterRule(_localctx, 64, RULE_match_clause_check);    try {        setState(349);        switch(getInterpreter().adaptivePredict(_input, 25, _ctx)) {            case 1:                _localctx = new MatchClauseCheckExprContext(_localctx);                enterOuterAlt(_localctx, 1);                {                    setState(347);                    logical_expr();                }                break;            case 2:                _localctx = new MatchClauseCheckExprContext(_localctx);                enterOuterAlt(_localctx, 2);                {                    setState(348);                    conditional_expr();                }                break;        }    } catch (RecognitionException re) {        _localctx.exception = re;        _errHandler.reportError(this, re);        _errHandler.recover(this, re);    } finally {        exitRule();    }    return _localctx;}
public boolean metron_f8594_0(RuleContext _localctx, int ruleIndex, int predIndex)
{    switch(ruleIndex) {        case 9:            return comparison_expr_sempred((Comparison_exprContext) _localctx, predIndex);        case 13:            return op_list_sempred((Op_listContext) _localctx, predIndex);        case 15:            return kv_list_sempred((Kv_listContext) _localctx, predIndex);        case 17:            return arithmetic_expr_sempred((Arithmetic_exprContext) _localctx, predIndex);        case 18:            return arithmetic_expr_mul_sempred((Arithmetic_expr_mulContext) _localctx, predIndex);    }    return true;}
private boolean metron_f8595_0(Comparison_exprContext _localctx, int predIndex)
{    switch(predIndex) {        case 0:            return precpred(_ctx, 4);    }    return true;}
private boolean metron_f8596_0(Op_listContext _localctx, int predIndex)
{    switch(predIndex) {        case 1:            return precpred(_ctx, 5);        case 2:            return precpred(_ctx, 3);        case 3:            return precpred(_ctx, 1);    }    return true;}
private boolean metron_f8597_0(Kv_listContext _localctx, int predIndex)
{    switch(predIndex) {        case 4:            return precpred(_ctx, 2);        case 5:            return precpred(_ctx, 1);    }    return true;}
private boolean metron_f8598_0(Arithmetic_exprContext _localctx, int predIndex)
{    switch(predIndex) {        case 6:            return precpred(_ctx, 2);        case 7:            return precpred(_ctx, 1);    }    return true;}
private boolean metron_f8599_0(Arithmetic_expr_mulContext _localctx, int predIndex)
{    switch(predIndex) {        case 8:            return precpred(_ctx, 2);        case 9:            return precpred(_ctx, 1);    }    return true;}
public Deque<Token<?>> metron_f8600_0()
{    Deque<Token<?>> ret = new ArrayDeque<>(super.getTokenDeque().size());    for (Token<?> token : super.getTokenDeque()) {        ret.add(token);    }    return ret;}
public Object metron_f8601_0(List<Object> variableArgs)
{    Map<String, Object> lambdaVariables = new HashMap<>();    int i = 0;    for (; i < Math.min(variables.size(), variableArgs.size()); ++i) {        lambdaVariables.put(variables.get(i), variableArgs.get(i));    }    for (; i < variables.size(); ++i) {        lambdaVariables.put(variables.get(i), null);    }    VariableResolver variableResolver = new DefaultVariableResolver(variable -> lambdaVariables.getOrDefault(variable, state.variableResolver.resolve(variable)), variable -> true);    StellarCompiler.ExpressionState localState = new StellarCompiler.ExpressionState(state.context, state.functionResolver, variableResolver);    return apply(localState);}
public void metron_f8602_0()
{    paused.set(true);}
public void metron_f8603_0() throws IOException
{    paused.set(false);}
public int metron_f8604_0() throws IOException
{    if (paused.get()) {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        return 0;    }    return in.read();}
public int metron_f8605_0(byte[] b) throws IOException
{    if (paused.get()) {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        return 0;    }    int ret = in.read(b);    return ret;}
public int metron_f8606_0(byte[] b, int off, int len) throws IOException
{    if (paused.get()) {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        return 0;    }    int ret = in.read(b, off, len);    return ret;}
public long metron_f8607_0(long n) throws IOException
{    return in.skip(n);}
public int metron_f8608_0() throws IOException
{    return in.available();}
public void metron_f8609_0() throws IOException
{    in.close();}
public synchronized void metron_f8610_0(int readlimit)
{    in.mark(readlimit);}
public synchronized void metron_f8611_0() throws IOException
{    in.reset();}
public boolean metron_f8612_0()
{    return in.markSupported();}
public static void metron_f8613_0(String[] args) throws Exception
{    StellarShell shell = new StellarShell(args);    shell.run();}
private Options metron_f8614_0()
{    Options options = new Options();    options.addOption("z", "zookeeper", true, "Zookeeper URL fragment in the form [HOSTNAME|IPADDRESS]:PORT");    options.addOption("v", "variables", true, "File containing a JSON Map of variables");    options.addOption("irc", "inputrc", true, "File containing the inputrc if not the default ~/.inputrc");    options.addOption("na", "no_ansi", false, "Make the input prompt not use ANSI colors.");    options.addOption("h", "help", false, "Print help");    options.addOption("p", "properties", true, "File containing Stellar properties");    Option log4j = new Option("l", "log4j", true, "The log4j properties file to load");    log4j.setArgName("FILE");    log4j.setRequired(false);    options.addOption(log4j);    return options;}
private static void metron_f8615_0(CommandLine commandLine, StellarShellExecutor executor) throws IOException
{    if (commandLine.hasOption("v")) {                String variablePath = commandLine.getOptionValue("v");        Map<String, Object> variables = JSONUtils.INSTANCE.load(new File(variablePath), JSONUtils.MAP_SUPPLIER);                for (Map.Entry<String, Object> kv : variables.entrySet()) {            String variable = kv.getKey();            Object value = kv.getValue();                        executor.assign(variable, value, Optional.empty());        }    }}
private StellarShellExecutor metron_f8616_0(CommandLine commandLine, Console console, Properties properties, StellarAutoCompleter autoCompleter) throws Exception
{        Optional<String> zookeeperUrl = Optional.empty();    if (commandLine.hasOption("z")) {        zookeeperUrl = Optional.of(commandLine.getOptionValue("z"));    }    StellarShellExecutor executor = new DefaultStellarShellExecutor(properties, zookeeperUrl);        executor.getContext().addCapability(CONSOLE, () -> console);        executor.getContext().addCapability(SHELL_VARIABLES, () -> executor.getState());        executor.addSpecialListener((special) -> autoCompleter.addCandidateFunction(special.getCommand()));    executor.addFunctionListener((function) -> autoCompleter.addCandidateFunction(function.getName()));    executor.addVariableListener((name, val) -> autoCompleter.addCandidateVariable(name));    executor.init();    return executor;}
private Console metron_f8617_0(CommandLine commandLine)
{        boolean useAnsi = !commandLine.hasOption("na");    SettingsBuilder settings = new SettingsBuilder().enableAlias(true).enableMan(true).ansi(useAnsi).parseOperators(false).inputStream(PausableInput.INSTANCE);    if (commandLine.hasOption("irc")) {        settings = settings.inputrc(new File(commandLine.getOptionValue("irc")));    }    return new Console(settings.create());}
private Properties metron_f8618_0(CommandLine commandLine) throws IOException
{    Properties properties = new Properties();    if (commandLine.hasOption("p")) {                try (InputStream in = new FileInputStream(commandLine.getOptionValue("p"))) {            if (in != null) {                properties.load(in);            }        }    } else {                try (InputStream in = getClass().getClassLoader().getResourceAsStream(STELLAR_PROPERTIES_FILENAME)) {            if (in != null) {                properties.load(in);            }        }    }    return properties;}
public void metron_f8619_0()
{        writeLine(WELCOME);        executor.getContext().getCapability(GLOBAL_CONFIG, false).ifPresent(conf -> writeLine(conf.toString()));    console.start();}
private void metron_f8620_0()
{    try {        console.stop();        StellarFunctions.close();    } catch (Throwable e) {        e.printStackTrace();    }}
private void metron_f8621_0(String out)
{    console.getShell().out().println(out);}
public int metron_f8622_0(ConsoleOperation output) throws InterruptedException
{        String expression = StringUtils.trimToEmpty(output.getBuffer());    if (StringUtils.isNotBlank(expression)) {                StellarResult result = executor.execute(expression);        if (result.isSuccess()) {                        result.getValue().ifPresent(v -> writeLine(v.toString()));        } else if (result.isError()) {                        result.getException().ifPresent(e -> writeLine(ERROR_PROMPT + e.getMessage()));            result.getException().ifPresent(e -> e.printStackTrace());        } else if (result.isTerminate()) {                        handleQuit();        } else {                        throw new IllegalStateException("An execution result is neither a success nor a failure. Please file a bug report.");        }    }    return 0;}
public void metron_f8623_0(CompleteOperation completeOperation)
{    String buffer = completeOperation.getBuffer();    final String lastToken = getLastToken(buffer);    Iterable<String> candidates = autoCompleter.autoComplete(buffer);        if (candidates != null && !Iterables.isEmpty(candidates)) {        for (String candidate : candidates) {            String completion = stripOff(buffer, lastToken) + candidate;            completeOperation.addCompletionCandidate(completion);        }    }}
private static String metron_f8624_0(String buffer)
{    String lastToken = Iterables.getLast(Splitter.on(" ").split(buffer), null);    return lastToken.trim();}
private static String metron_f8625_0(String baseString, String lastBit)
{    int index = baseString.lastIndexOf(lastBit);    if (index < 0) {        return baseString;    }    return baseString.substring(0, index);}
public StellarShellExecutor metron_f8626_0()
{    return executor;}
public Console metron_f8627_0()
{    return console;}
public static void metron_f8628_0(CommandLine commandLine) throws IllegalArgumentException
{    if (commandLine.hasOption('z')) {        validateZookeeperOption(commandLine.getOptionValue('z'));    }        if (commandLine.hasOption('v')) {        validateFileOption("v", commandLine.getOptionValue('v'));    }    if (commandLine.hasOption("irc")) {        validateFileOption("irc", commandLine.getOptionValue("irc"));    }    if (commandLine.hasOption('p')) {        validateFileOption("p", commandLine.getOptionValue('p'));    }}
private static void metron_f8629_0(String zMulti) throws IllegalArgumentException
{    for (String z : Splitter.on(",").split(zMulti)) {        Matcher matcher = validPortPattern.matcher(z);        boolean hasPort = z.contains(":");        if (hasPort && !matcher.matches()) {            throw new IllegalArgumentException(String.format("Zookeeper option must have valid port: %s", z));        }        if (hasPort && matcher.groupCount() != 2) {            throw new IllegalArgumentException(String.format("Zookeeper Option must be in the form of [HOST|IP]:PORT  %s", z));        }        String name = hasPort ? matcher.group(1) : z;        Integer port = hasPort ? Integer.parseInt(matcher.group(2)) : null;        if (!hostnameValidator.test(name) && !inetAddressValidator.isValid(name)) {            throw new IllegalArgumentException(String.format("Zookeeper Option %s is not a valid host name or ip address  %s", name, z));        }        if (hasPort && (port == 0 || port > 65535)) {            throw new IllegalArgumentException(String.format("Zookeeper Option %s port is not valid", z));        }    }}
private static void metron_f8630_0(String option, String fileName) throws IllegalArgumentException
{    File file = new File(fileName);    if (!file.exists()) {        throw new IllegalArgumentException(String.format("%s: File %s doesn't exist", option, fileName));    }    if (!file.canRead()) {        throw new IllegalArgumentException(String.format("%s: File %s is not readable", option, fileName));    }}
public String metron_f8631_0(OperationType type, String key)
{    return transform.transform(type, key);}
public Iterable<String> metron_f8632_0(String buffer)
{    Iterable<String> candidates = IterableUtils.emptyIterable();    final String lastToken = getLastToken(buffer);    if (StringUtils.isNotEmpty(lastToken)) {        if (isDoc(lastToken)) {            candidates = autoCompleteDoc(lastToken.substring(1));        } else if (isMagic(lastToken)) {            candidates = autoCompleteMagic(lastToken);        } else {            candidates = autoCompleteNormal(lastToken);        }    }    return candidates;}
private boolean metron_f8633_0(String expression)
{    return StringUtils.startsWith(expression, "%");}
private boolean metron_f8634_0(String expression)
{    return StringUtils.startsWith(expression, "?");}
private Iterable<String> metron_f8635_0(String buffer)
{    return autoComplete(buffer, OperationType.NORMAL);}
private Iterable<String> metron_f8636_0(String buffer)
{    return autoComplete(buffer, OperationType.DOC);}
private Iterable<String> metron_f8637_0(String buffer)
{    return autoComplete(buffer, OperationType.MAGIC);}
private Iterable<String> metron_f8638_0(String buffer, final OperationType opType)
{    indexLock.readLock().lock();    try {        SortedMap<String, AutoCompleteType> ret = autocompleteIndex.prefixMap(buffer);        if (ret.isEmpty()) {            return new ArrayList<>();        }        return Iterables.transform(ret.entrySet(), kv -> kv.getValue().transform(opType, kv.getKey()));    } finally {        indexLock.readLock().unlock();    }}
public void metron_f8639_0(String name)
{    add(name, AutoCompleteType.FUNCTION);}
public void metron_f8640_0(String name)
{    add(name, AutoCompleteType.VARIABLE);}
private void metron_f8641_0(String name, AutoCompleteType type)
{    if (StringUtils.isNotBlank(name)) {                indexLock.writeLock().lock();        try {            this.autocompleteIndex.put(name, type);        } finally {            indexLock.writeLock().unlock();        }    }}
private PatriciaTrie<AutoCompleteType> metron_f8642_0()
{    Map<String, AutoCompleteType> index = new HashMap<>();    index.put("==", AutoCompleteType.TOKEN);    index.put(">=", AutoCompleteType.TOKEN);    index.put("<=", AutoCompleteType.TOKEN);    return new PatriciaTrie<>(index);}
private static String metron_f8643_0(String buffer)
{    String lastToken = Iterables.getLast(Splitter.on(" ").split(buffer), null);    return lastToken.trim();}
public static List<SpecialCommand> metron_f8644_0()
{    return Arrays.asList(new AssignmentCommand(), new DocCommand(), new QuitCommand(), new Comment(), new MagicListFunctions(), new MagicListVariables(), new MagicDefineGlobal(), new MagicUndefineGlobal(), new MagicListGlobals());}
public void metron_f8645_0()
{    StellarFunctions.initialize(this.context);        for (SpecialCommand command : specials) {        notifySpecialListeners(command);    }        for (StellarFunctionInfo fn : functionResolver.getFunctionInfo()) {        notifyFunctionListeners(fn);    }}
public void metron_f8646_0(FunctionDefinedListener listener)
{    this.functionListeners.add(listener);}
private void metron_f8647_0(StellarFunctionInfo functionInfo)
{    for (FunctionDefinedListener listener : functionListeners) {        listener.whenFunctionDefined(functionInfo);    }}
public void metron_f8648_0(VariableDefinedListener listener)
{    this.variableListeners.add(listener);}
private void metron_f8649_0(String variableName, VariableResult result)
{    for (VariableDefinedListener listener : variableListeners) {        listener.whenVariableDefined(variableName, result);    }}
public void metron_f8650_0(SpecialDefinedListener listener)
{    this.specialListeners.add(listener);}
private void metron_f8651_0(SpecialCommand specialCommand)
{    for (SpecialDefinedListener listener : specialListeners) {        listener.whenSpecialDefined(specialCommand);    }}
public StellarResult metron_f8652_0(String expression)
{        expression = StringUtils.trimToEmpty(expression);    if (StringUtils.isBlank(expression)) {        return noop();    }        for (SpecialCommand command : specials) {        if (command.getMatcher().apply(expression)) {            return command.execute(expression, this);        }    }        return executeStellar(expression);}
public Map<String, Object> metron_f8653_0()
{    Map<String, Object> globals;    Optional<Object> capability = getContext().getCapability(GLOBAL_CONFIG, false);    if (capability.isPresent()) {        globals = (Map<String, Object>) capability.get();    } else {        throw new IllegalStateException("'GLOBAL_CONFIG' is missing");    }    return globals;}
public void metron_f8654_0(String variableName, Object value, Optional<String> expression)
{        VariableResult varResult = VariableResult.withExpression(value, expression);    this.variables.put(variableName, varResult);        notifyVariableListeners(variableName, varResult);}
public FunctionResolver metron_f8655_0()
{    return functionResolver;}
public Map<String, VariableResult> metron_f8656_0()
{    return UnmodifiableMap.decorate(variables);}
public Map<String, Object> metron_f8657_0()
{    return Maps.transformValues(variables, (v) -> v.getResult());}
public Context metron_f8658_0()
{    return context;}
private Map<String, Object> metron_f8661_0(CuratorFramework zkClient) throws Exception
{    byte[] raw = readGlobalConfigBytesFromZookeeper(zkClient);    return JSONUtils.INSTANCE.load(new ByteArrayInputStream(raw), JSONUtils.MAP_SUPPLIER);}
private Map<String, Object> metron_f8662_0(Map<String, Object> globalConfig, Properties props)
{    Map<String, Object> stellarConfig = new HashMap<>();    stellarConfig.putAll(globalConfig);    if (props != null) {        for (Map.Entry<Object, Object> kv : props.entrySet()) {            stellarConfig.put(kv.getKey().toString(), kv.getValue());        }    }    return stellarConfig;}
private StellarResult metron_f8663_0(String expression)
{    StellarResult result;    try {                VariableResolver variableResolver = new MapVariableResolver(getVariables());        Object exprResult = new StellarProcessor().parse(expression, variableResolver, functionResolver, context);        result = success(exprResult);    } catch (Throwable t) {        result = error(t);    }    return result;}
public Function<String, Boolean> metron_f8664_0()
{    return (input) -> StellarAssignment.isAssignment(input);}
public String metron_f8665_0()
{    return ASSIGNMENT_OP;}
public StellarResult metron_f8666_0(String input, StellarShellExecutor executor)
{    assert StellarAssignment.isAssignment(input);        StellarAssignment assignment = StellarAssignment.from(input);    String varName = assignment.getVariable();    String varExpr = assignment.getStatement();        StellarResult result = executor.execute(varExpr);    if (result.isSuccess()) {        Object value = null;        if (result.getValue().isPresent()) {            value = result.getValue().get();        } else if (result.isValueNull()) {            value = null;        }                executor.assign(varName, value, Optional.of(varExpr));        return result;    } else {        return result;    }}
public String metron_f8667_0()
{    return "#";}
public Function<String, Boolean> metron_f8668_0()
{    return (input) -> startsWith(trimToEmpty(input), COMMENT_PREFIX);}
public StellarResult metron_f8669_0(String expression, StellarShellExecutor executor)
{    return noop();}
public String metron_f8670_0()
{    return DOC_PREFIX;}
public Function<String, Boolean> metron_f8671_0()
{    return (input) -> StringUtils.startsWith(input, DOC_PREFIX);}
public StellarResult metron_f8672_0(String command, StellarShellExecutor executor)
{    StellarResult result;        String functionName = StringUtils.substring(command, 1);        Spliterator<StellarFunctionInfo> fnIterator = executor.getFunctionResolver().getFunctionInfo().spliterator();    Optional<StellarFunctionInfo> functionInfo = StreamSupport.stream(fnIterator, false).filter(info -> StringUtils.equals(functionName, info.getName())).findFirst();    if (functionInfo.isPresent()) {        result = success(docFormat(functionInfo.get()));    } else {        result = error(String.format("No docs available for function '%s'", functionName));    }    return result;}
private String metron_f8673_0(StellarFunctionInfo info)
{    StringBuffer docString = new StringBuffer();        docString.append(info.getName() + "\n");        docString.append(String.format("Description: %-60s\n\n", info.getDescription()));        if (info.getParams().length > 0) {        docString.append("Arguments:\n");        for (String param : info.getParams()) {            docString.append(String.format("\t%-60s\n", param));        }        docString.append("\n");    }        docString.append(String.format("Returns: %-60s\n", info.getReturns()));    return docString.toString();}
public String metron_f8674_0()
{    return MAGIC_DEFINE;}
public Function<String, Boolean> metron_f8675_0()
{    return (input) -> startsWith(trimToEmpty(input), MAGIC_DEFINE);}
public StellarResult metron_f8676_0(String command, StellarShellExecutor executor)
{        String assignExpr = StringUtils.trimToEmpty(command.substring(MAGIC_DEFINE.length()));    if (StringUtils.length(assignExpr) < 1) {        return error(MAGIC_DEFINE + " missing assignment expression");    }        if (!StellarAssignment.isAssignment(assignExpr)) {        return error(MAGIC_DEFINE + " expected assignment expression");    }        StellarAssignment expr = StellarAssignment.from(assignExpr);    StellarResult result = executor.execute(expr.getStatement());        if (!result.isSuccess()) {        return error(MAGIC_DEFINE + " expression execution failed");    }        if (!result.getValue().isPresent()) {        return error(MAGIC_DEFINE + " expression produced no result");    }        Object value = result.getValue().get();    executor.getGlobalConfig().put(expr.getVariable(), value);    return success(value);}
public String metron_f8677_0()
{    return MAGIC_FUNCTIONS;}
public Function<String, Boolean> metron_f8678_0()
{    return (input) -> startsWith(trimToEmpty(input), MAGIC_FUNCTIONS);}
public StellarResult metron_f8679_0(String command, StellarShellExecutor executor)
{        String startsWith = StringUtils.trimToEmpty(command.substring(MAGIC_FUNCTIONS.length()));    Predicate<String> nameFilter = (name -> true);    if (StringUtils.isNotBlank(startsWith)) {        nameFilter = (name -> name.contains(startsWith));    }        String functions = StreamSupport.stream(executor.getFunctionResolver().getFunctionInfo().spliterator(), false).map(info -> String.format("%s", info.getName())).filter(nameFilter).sorted().collect(Collectors.joining(", "));    return StellarResult.success(functions);}
public String metron_f8680_0()
{    return MAGIC_GLOBALS;}
public Function<String, Boolean> metron_f8681_0()
{    return (input) -> startsWith(trimToEmpty(input), MAGIC_GLOBALS);}
public StellarResult metron_f8682_0(String command, StellarShellExecutor executor)
{    Map<String, Object> globals = executor.getGlobalConfig();    return StellarResult.success(globals.toString());}
public String metron_f8683_0()
{    return MAGIC_VARS;}
public Function<String, Boolean> metron_f8684_0()
{    return (input) -> startsWith(trimToEmpty(input), MAGIC_VARS);}
public StellarResult metron_f8685_0(String command, StellarShellExecutor executor)
{        String vars = executor.getState().entrySet().stream().map(e -> format(e)).collect(Collectors.joining(", "));    return success(vars);}
private String metron_f8686_0(Map.Entry<String, VariableResult> var)
{        String out = String.format("%s = %s", var.getKey(), var.getValue().getResult());        if (var.getValue().getExpression().isPresent()) {        out += String.format(" via `%s`", var.getValue().getExpression().get());    }    return out;}
public String metron_f8687_0()
{    return MAGIC_UNDEFINE;}
public Function<String, Boolean> metron_f8688_0()
{    return (input) -> startsWith(trimToEmpty(input), MAGIC_UNDEFINE);}
public StellarResult metron_f8689_0(String command, StellarShellExecutor executor)
{    StellarResult result;    String variable = StringUtils.trimToEmpty(command.substring(MAGIC_UNDEFINE.length()));    if (StringUtils.isNotBlank(variable)) {                Map<String, Object> globals = executor.getGlobalConfig();        globals.remove(variable);        result = noop();    } else {        result = error(String.format("%s expected name of global, got '%s'", MAGIC_UNDEFINE, variable));    }    return result;}
public String metron_f8690_0()
{    return QUIT_COMMAND;}
public Function<String, Boolean> metron_f8691_0()
{    return (input) -> QUIT_COMMAND.equals(input);}
public StellarResult metron_f8692_0(String command, StellarShellExecutor executor)
{    return terminate();}
public static StellarResult metron_f8693_0(Object value)
{    return new StellarResult(Status.SUCCESS, value);}
public static StellarResult metron_f8694_0(Throwable exception)
{    return new StellarResult(Status.ERROR, exception);}
public static StellarResult metron_f8695_0(String errorMessage)
{    return new StellarResult(Status.ERROR, new IllegalArgumentException(errorMessage));}
public static StellarResult metron_f8696_0()
{    return new StellarResult(Status.SUCCESS, "");}
public static StellarResult metron_f8697_0()
{    return new StellarResult(Status.TERMINATE, "");}
public boolean metron_f8698_0()
{    return status == Status.SUCCESS;}
public boolean metron_f8699_0()
{    return status == Status.ERROR;}
public boolean metron_f8700_0()
{    return status == Status.TERMINATE;}
public boolean metron_f8701_0()
{    return isValueNull;}
public Status metron_f8702_0()
{    return status;}
public Optional<Object> metron_f8703_0()
{    return value;}
public Optional<Throwable> metron_f8704_0()
{    return exception;}
public String metron_f8705_0()
{    return "StellarResult{" + "status=" + status + ", value=" + value + ", exception=" + exception + ", isValueNull=" + isValueNull + '}';}
public static VariableResult metron_f8706_0(Object value, String expression)
{    return new VariableResult(Optional.of(expression), value);}
public static VariableResult metron_f8707_0(Object value, Optional<String> expression)
{    return new VariableResult(expression, value);}
public static VariableResult metron_f8708_0(Object value)
{    return new VariableResult(Optional.empty(), value);}
public Optional<String> metron_f8709_0()
{    return expression;}
public Object metron_f8710_0()
{    return result;}
public String metron_f8711_0()
{    String ret = "" + result;    if (getExpression().isPresent()) {        ret += " via " + expression.get();    }    return ret;}
public String metron_f8712_0()
{    return variable;}
public String metron_f8713_0()
{    return statement;}
public static boolean metron_f8714_0(String statement)
{    return statement != null &&     statement.contains(":=") &&     !statement.trim().startsWith("%");}
public static StellarAssignment metron_f8715_0(String statement)
{    if (statement == null || statement.length() == 0) {        return new StellarAssignment(null, null);    }    char prev = statement.charAt(0);    char curr;    String variable = "" + prev;    String s = null;    boolean isAssignment = false;    for (int i = 1; i < statement.length(); ++i, prev = curr) {        curr = statement.charAt(i);        if (prev == ':' && curr == '=') {            isAssignment = true;            variable = variable.substring(0, variable.length() - 1);            s = "";            continue;        }        if (!isAssignment) {            variable += curr;        } else {            s += curr;        }    }    if (!isAssignment) {        s = variable;        variable = null;    }    if (s != null) {        s = s.trim();    }    if (variable != null) {        variable = variable.trim();    }    return new StellarAssignment(variable, s);}
public String metron_f8716_0()
{    return variable;}
public Object metron_f8717_0()
{    return statement;}
public String metron_f8718_0(Object value)
{    throw new UnsupportedOperationException("Assignments are immutable.");}
public void metron_f8719_0()
{    tokenDeque.clear();    variablesUsed.clear();    multiArgumentState.clear();}
public Deque<Token<?>> metron_f8720_0()
{    return tokenDeque;}
private boolean metron_f8721_0(Class<?> tokenValueType)
{    return tokenValueType != null && (tokenValueType == BooleanArg.class || tokenValueType == IfExpr.class || tokenValueType == MatchClauseCheckExpr.class);}
private boolean metron_f8722_0(Token<?> token, Object value)
{    if (value != null && isConditionalContext(token.getUnderlyingType())) {        if (value instanceof Iterable) {            return Iterables.isEmpty((Iterable) value);        } else if (value instanceof Map) {            return ((Map) value).isEmpty();        } else {            return false;        }    } else {        return false;    }}
private boolean metron_f8723_0(Token<?> token, Object value)
{    if (token == null || token.getValue() == null) {        return false;    }    return value == null && isConditionalContext(token.getValue().getClass());}
public Object metron_f8724_0(ExpressionState state)
{    Deque<Token<?>> instanceDeque = new ArrayDeque<>();    {        int skipElseCount = 0;        boolean skipMatchClauses = false;        Token<?> token = null;        for (Iterator<Token<?>> it = getTokenDeque().descendingIterator(); it.hasNext(); ) {            token = it.next();                        if (skipElseCount > 0 && token.getUnderlyingType() == ElseExpr.class) {                while (it.hasNext()) {                    token = it.next();                    if (token.getUnderlyingType() == EndConditional.class) {                        break;                    }                }                                skipElseCount--;            }            if (skipMatchClauses && (token.getUnderlyingType() == MatchClauseEnd.class || token.getUnderlyingType() == MatchClauseCheckExpr.class)) {                while (it.hasNext()) {                    token = it.next();                    if (token.getUnderlyingType() == MatchClausesEnd.class) {                        break;                    }                }                skipMatchClauses = false;            }            /*          curr is the current value on the stack.  This is the non-deferred actual evaluation for this expression          and with the current context.           */            Token<?> curr = instanceDeque.peek();            boolean isFalsey = curr != null && (isBoolean(token, curr.getValue()) || isEmptyList(token, curr.getValue()));            if (isFalsey) {                                                                                curr = new Token<>(false, Boolean.class, curr.getMultiArgContext());                instanceDeque.removeFirst();                instanceDeque.addFirst(curr);            }            if (curr != null && curr.getValue() != null && curr.getValue() instanceof Boolean && ShortCircuitOp.class.isAssignableFrom(token.getUnderlyingType())) {                                if (token.getUnderlyingType() == BooleanArg.class) {                    if (token.getMultiArgContext() != null && token.getMultiArgContext().getVariety() == FrameContext.BOOLEAN_OR && (Boolean) (curr.getValue())) {                                                FrameContext.Context context = curr.getMultiArgContext();                        shortCircuit(it, context);                    } else if (token.getMultiArgContext() != null && token.getMultiArgContext().getVariety() == FrameContext.BOOLEAN_AND && !(Boolean) (curr.getValue())) {                                                FrameContext.Context context = curr.getMultiArgContext();                        shortCircuit(it, context);                    }                } else if (token.getUnderlyingType() == IfExpr.class) {                                        instanceDeque.pop();                    if ((Boolean) curr.getValue()) {                                                skipElseCount++;                    } else {                                                                        int innerIfCount = 0;                        while (it.hasNext()) {                            Token<?> t = it.next();                            if (t.getUnderlyingType() == IfExpr.class) {                                innerIfCount++;                            } else if (t.getUnderlyingType() == ElseExpr.class) {                                if (innerIfCount == 0) {                                    break;                                } else {                                    innerIfCount--;                                }                            }                        }                    }                } else if (token.getUnderlyingType() == MatchClauseCheckExpr.class) {                    instanceDeque.pop();                    if ((Boolean) curr.getValue()) {                                                skipMatchClauses = true;                    } else {                        while (it.hasNext()) {                            Token<?> t = it.next();                            if (t.getUnderlyingType() == MatchClauseEnd.class) {                                break;                            }                        }                    }                }            }            if (token.getUnderlyingType() == DeferredFunction.class) {                DeferredFunction func = (DeferredFunction) token.getValue();                func.apply(instanceDeque, state);            } else if (token.getUnderlyingType() != ShortCircuitFrame.class && !ShortCircuitOp.class.isAssignableFrom(token.getUnderlyingType())) {                instanceDeque.push(token);            }        }    }    if (instanceDeque.isEmpty()) {        throw new ParseException("Invalid predicate: Empty stack.");    }    Token<?> token = instanceDeque.pop();    if (instanceDeque.isEmpty()) {        return token.getValue();    }    if (instanceDeque.isEmpty()) {        throw new ParseException("Invalid parse, stack not empty: " + Joiner.on(',').join(instanceDeque));    } else {        throw new ParseException("Invalid parse, found " + token);    }}
public void metron_f8725_0(Iterator<Token<?>> it, FrameContext.Context context)
{    while (it.hasNext()) {        Token<?> token = it.next();        if (token.getUnderlyingType() == ShortCircuitFrame.class && token.getMultiArgContext() == context) {            break;        }    }}
public void metron_f8726_0(StellarParser.TransformationContext ctx)
{    expression.clear();}
private boolean metron_f8727_0(final Token<?> left, final Token<?> right)
{    Object key = right.getValue();    if (left.getValue() != null) {        if (left.getValue() instanceof String && key instanceof String) {            return ((String) left.getValue()).contains(key.toString());        } else if (left.getValue() instanceof Collection) {            return ((Collection) left.getValue()).contains(key);        } else if (left.getValue() instanceof Map) {            return ((Map) left.getValue()).containsKey(key);        } else {            if (key == null) {                return key == left.getValue();            } else {                return key.equals(left.getValue());            }        }    } else {        return false;    }}
public void metron_f8728_0(StellarParser.NullConstContext ctx)
{    expression.tokenDeque.push(new Token<>(null, Object.class, getArgContext()));}
public void metron_f8729_0(StellarParser.NaNArithContext ctx)
{    expression.tokenDeque.push(new Token<>(Double.NaN, Double.class, getArgContext()));}
public void metron_f8730_0(StellarParser.ArithExpr_plusContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Pair<Token<? extends Number>, Token<? extends Number>> p = getArithExpressionPair(tokenDeque);        tokenDeque.push(arithmeticEvaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(context), p));    }, DeferredFunction.class, context));}
public void metron_f8731_0(StellarParser.ArithExpr_minusContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Pair<Token<? extends Number>, Token<? extends Number>> p = getArithExpressionPair(tokenDeque);        tokenDeque.push(arithmeticEvaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.subtraction(context), p));    }, DeferredFunction.class, context));}
public void metron_f8732_0(StellarParser.ArithExpr_divContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Pair<Token<? extends Number>, Token<? extends Number>> p = getArithExpressionPair(tokenDeque);        tokenDeque.push(arithmeticEvaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(context), p));    }, DeferredFunction.class, context));}
public void metron_f8733_0(StellarParser.ArithExpr_mulContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Pair<Token<? extends Number>, Token<? extends Number>> p = getArithExpressionPair(tokenDeque);        tokenDeque.push(arithmeticEvaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.multiplication(context), p));    }, DeferredFunction.class, context));}
private Pair<Token<? extends Number>, Token<? extends Number>> metron_f8734_0(Deque<Token<?>> tokenDeque)
{    Token<? extends Number> right = (Token<? extends Number>) popDeque(tokenDeque);    Token<? extends Number> left = (Token<? extends Number>) popDeque(tokenDeque);    return Pair.of(left, right);}
public void metron_f8735_0(StellarParser.If_exprContext ctx)
{    expression.tokenDeque.push(new Token<>(new IfExpr(), IfExpr.class, getArgContext()));}
public void metron_f8736_0(StellarParser.Then_exprContext ctx)
{    expression.tokenDeque.push(new Token<>(new ThenExpr(), ThenExpr.class, getArgContext()));}
public void metron_f8737_0(StellarParser.Else_exprContext ctx)
{    expression.tokenDeque.push(new Token<>(new ElseExpr(), ElseExpr.class, getArgContext()));}
public void metron_f8738_0(StellarParser.Else_exprContext ctx)
{    expression.tokenDeque.push(new Token<>(new EndConditional(), EndConditional.class, getArgContext()));}
public void metron_f8739_0(StellarParser.InExpressionStatementContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Token<?> left = popDeque(tokenDeque);        Token<?> right = popDeque(tokenDeque);        tokenDeque.push(new Token<>(handleIn(left, right), Boolean.class, context));    }, DeferredFunction.class, context));}
public void metron_f8740_0(StellarParser.NInExpressionStatementContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Token<?> left = popDeque(tokenDeque);        Token<?> right = popDeque(tokenDeque);        tokenDeque.push(new Token<>(!handleIn(left, right), Boolean.class, context));    }, DeferredFunction.class, context));}
public void metron_f8741_0(StellarParser.NotFuncContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Token<Boolean> arg = (Token<Boolean>) popDeque(tokenDeque);        Boolean v = Optional.ofNullable(ConversionUtils.convert(arg.getValue(), Boolean.class)).orElse(false);        tokenDeque.push(new Token<>(!v, Boolean.class, context));    }, DeferredFunction.class, context));}
public void metron_f8742_0(StellarParser.VariableContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        String varName = ctx.getText();        if (state.context.getActivityType().equals(ActivityType.PARSE_ACTIVITY) && !state.variableResolver.exists(varName)) {                        throw new ParseException(String.format("variable: %s is not defined", varName));        }        Object resolved = state.variableResolver.resolve(varName);        tokenDeque.push(new Token<>(resolved, Object.class, context));    }, DeferredFunction.class, context));    expression.variablesUsed.add(ctx.getText());}
public void metron_f8743_0(StellarParser.StringLiteralContext ctx)
{    String rawToken = ctx.getText();    String literal = StringEscapeUtils.UNESCAPE_JSON.translate(rawToken);    expression.tokenDeque.push(new Token<>(literal.substring(1, literal.length() - 1), String.class, getArgContext()));}
public void metron_f8744_0(StellarParser.IntLiteralContext ctx)
{    expression.tokenDeque.push(numberLiteralEvaluator.evaluate(ctx, getArgContext()));}
public void metron_f8745_0(StellarParser.DoubleLiteralContext ctx)
{    expression.tokenDeque.push(numberLiteralEvaluator.evaluate(ctx, getArgContext()));}
public void metron_f8746_0(StellarParser.FloatLiteralContext ctx)
{    expression.tokenDeque.push(numberLiteralEvaluator.evaluate(ctx, getArgContext()));}
public void metron_f8747_0(StellarParser.LongLiteralContext ctx)
{    expression.tokenDeque.push(numberLiteralEvaluator.evaluate(ctx, getArgContext()));}
public void metron_f8748_0(StellarParser.B_exprContext ctx)
{        if (ctx.getParent() instanceof StellarParser.LogicalExpressionOrContext) {        expression.multiArgumentState.push(FrameContext.BOOLEAN_OR.create());    } else if (ctx.getParent() instanceof StellarParser.LogicalExpressionAndContext) {        expression.multiArgumentState.push(FrameContext.BOOLEAN_AND.create());    }}
public void metron_f8749_0(StellarParser.B_exprContext ctx)
{    if (ctx.getParent() instanceof StellarParser.LogicalExpressionOrContext || ctx.getParent() instanceof StellarParser.LogicalExpressionAndContext) {                expression.tokenDeque.push(new Token<>(new BooleanArg(), BooleanArg.class, getArgContext()));    }}
public void metron_f8750_0(StellarParser.LogicalExpressionAndContext ctx)
{    final FrameContext.Context context = getArgContext();    popArgContext();    final FrameContext.Context parentContext = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Token<?> left = popDeque(tokenDeque);        Token<?> right = popDeque(tokenDeque);        tokenDeque.push(new Token<>(booleanOp(left, right, (l, r) -> l && r, "&&"), Boolean.class, parentContext));    }, DeferredFunction.class, context));    expression.tokenDeque.push(new Token<>(new ShortCircuitFrame(), ShortCircuitFrame.class, context));}
public void metron_f8751_0(StellarParser.LogicalExpressionOrContext ctx)
{    final FrameContext.Context context = getArgContext();    popArgContext();    final FrameContext.Context parentContext = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Token<?> left = popDeque(tokenDeque);        Token<?> right = popDeque(tokenDeque);        tokenDeque.push(new Token<>(booleanOp(left, right, (l, r) -> l || r, "||"), Boolean.class, parentContext));    }, DeferredFunction.class, context));    expression.tokenDeque.push(new Token<>(new ShortCircuitFrame(), ShortCircuitFrame.class, context));}
public void metron_f8752_0(StellarParser.LogicalConstContext ctx)
{    Boolean b;    switch(ctx.getText().toUpperCase()) {        case "TRUE":            b = true;            break;        case "FALSE":            b = false;            break;        default:            throw new ParseException("Unable to process " + ctx.getText() + " as a boolean constant");    }    expression.tokenDeque.push(new Token<>(b, Boolean.class, getArgContext()));}
private boolean metron_f8753_0(final Token<?> left, final Token<?> right, final BooleanOp op, final String opName)
{    Boolean l = Optional.ofNullable(ConversionUtils.convert(left.getValue(), Boolean.class)).orElse(false);    Boolean r = Optional.ofNullable(ConversionUtils.convert(right.getValue(), Boolean.class)).orElse(false);    return op.op(l, r);}
public void metron_f8754_0(StellarParser.Single_lambda_variableContext ctx)
{    enterLambdaVariables();}
public void metron_f8755_0(StellarParser.Single_lambda_variableContext ctx)
{    exitLambdaVariables();}
public void metron_f8756_0(StellarParser.Lambda_variablesContext ctx)
{    enterLambdaVariables();}
public void metron_f8757_0(StellarParser.Lambda_variablesContext ctx)
{    exitLambdaVariables();}
public void metron_f8758_0(StellarParser.Lambda_variableContext ctx)
{    expression.tokenDeque.push(new Token<>(ctx.getText(), String.class, getArgContext()));}
private void metron_f8759_0()
{    expression.tokenDeque.push(LAMBDA_VARIABLES);}
private void metron_f8760_0()
{    Token<?> t = expression.tokenDeque.pop();    LinkedList<String> variables = new LinkedList<>();    for (; !expression.tokenDeque.isEmpty() && t != LAMBDA_VARIABLES; t = expression.tokenDeque.pop()) {        variables.addFirst(t.getValue().toString());    }    expression.tokenDeque.push(new Token<>(variables, List.class, getArgContext()));}
private void metron_f8761_0()
{    expression.tokenDeque.push(EXPRESSION_REFERENCE);}
private void metron_f8762_0(boolean hasArgs)
{    final FrameContext.Context context = getArgContext();    Token<?> t = expression.tokenDeque.pop();    final Deque<Token<?>> instanceDeque = new ArrayDeque<>();    for (; !expression.tokenDeque.isEmpty() && t != EXPRESSION_REFERENCE; t = expression.tokenDeque.pop()) {        instanceDeque.addLast(t);    }    final List<String> variables = hasArgs ? (List<String>) instanceDeque.removeLast().getValue() : new ArrayList<>();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        LambdaExpression expr = new LambdaExpression(variables, instanceDeque, state);        tokenDeque.push(new Token<>(expr, Object.class, context));    }, DeferredFunction.class, context));}
public void metron_f8763_0(StellarParser.Lambda_with_argsContext ctx)
{    enterLambda();}
public void metron_f8764_0(StellarParser.Lambda_with_argsContext ctx)
{    exitLambda(true);}
public void metron_f8765_0(StellarParser.Lambda_without_argsContext ctx)
{    enterLambda();}
public void metron_f8766_0(StellarParser.Lambda_without_argsContext ctx)
{    exitLambda(false);}
public void metron_f8767_0(StellarParser.TransformationFuncContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {                String functionName = ctx.getChild(0).getText();        StellarFunction function = resolveFunction(state.functionResolver, functionName);        initializeFunction(state.context, function, functionName);                List<Object> args = getFunctionArguments(popDeque(tokenDeque));        Object result = function.apply(args, state.context);        tokenDeque.push(new Token<>(result, Object.class, context));    }, DeferredFunction.class, context));}
private List<Object> metron_f8768_0(final Token<?> token)
{    if (token.getUnderlyingType().equals(List.class)) {        return (List<Object>) token.getValue();    } else {        throw new ParseException("Unable to process in clause because " + token.getValue() + " is not a set");    }}
private StellarFunction metron_f8769_0(FunctionResolver functionResolver, String funcName)
{    try {        return functionResolver.apply(funcName);    } catch (Exception e) {        String valid = Joiner.on(',').join(functionResolver.getFunctions());        String error = format("Unable to resolve function named '%s'.  Valid functions are %s", funcName, valid);        throw new ParseException(error, e);    }}
private void metron_f8770_0(Context context, StellarFunction function, String functionName)
{    try {        if (!function.isInitialized()) {            function.initialize(context);        }    } catch (Throwable t) {        String error = format("Unable to initialize function '%s'", functionName);        throw new ParseException(error, t);    }}
public void metron_f8771_0(StellarParser.ExistsFuncContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        String variable = ctx.getChild(2).getText();        boolean exists = state.variableResolver.resolve(variable) != null;        tokenDeque.push(new Token<>(exists, Boolean.class, context));    }, DeferredFunction.class, context));    String variable = ctx.getChild(2).getText();    expression.variablesUsed.add(variable);}
public void metron_f8772_0(StellarParser.Func_argsContext ctx)
{    expression.tokenDeque.push(new Token<>(new FunctionMarker(), FunctionMarker.class, getArgContext()));}
public void metron_f8773_0(StellarParser.Func_argsContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        LinkedList<Object> args = new LinkedList<>();        while (true) {            Token<?> token = popDeque(tokenDeque);            if (token.getUnderlyingType().equals(FunctionMarker.class)) {                break;            } else {                args.addFirst(token.getValue());            }        }        tokenDeque.push(new Token<>(args, List.class, context));    }, DeferredFunction.class, context));}
public void metron_f8774_0(StellarParser.Map_entityContext ctx)
{    expression.tokenDeque.push(new Token<>(new FunctionMarker(), FunctionMarker.class, getArgContext()));}
public void metron_f8775_0(StellarParser.Map_entityContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        HashMap<Object, Object> args = new HashMap<>();        Object value = null;        for (int i = 0; true; i++) {            Token<?> token = popDeque(tokenDeque);            if (token.getUnderlyingType().equals(FunctionMarker.class)) {                break;            } else {                if (i % 2 == 0) {                    value = token.getValue();                } else {                    args.put(token.getValue(), value);                }            }        }        tokenDeque.push(new Token<>(args, Map.class, context));    }, DeferredFunction.class, context));}
public void metron_f8776_0(StellarParser.List_entityContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        LinkedList<Object> args = new LinkedList<>();        while (true) {            Token<?> token = popDeque(tokenDeque);            if (token.getUnderlyingType().equals(FunctionMarker.class)) {                break;            } else {                args.addFirst(token.getValue());            }        }        tokenDeque.push(new Token<>(args, List.class, context));    }, DeferredFunction.class, context));}
public void metron_f8777_0(StellarParser.DefaultContext ctx)
{    expression.tokenDeque.push(new Token<>(true, Boolean.class, getArgContext()));}
public void metron_f8778_0(StellarParser.MatchClauseCheckExprContext ctx)
{    final FrameContext.Context context = getArgContext();        if (ctx.getStart() == ctx.getStop()) {        expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {            if (tokenDeque.size() == 1 && (tokenDeque.peek().getValue() == null || tokenDeque.peek().getUnderlyingType() == Boolean.class)) {                tokenDeque.pop();                tokenDeque.add(new Token<>(false, Boolean.class, getArgContext()));            }        }, DeferredFunction.class, context));    }    expression.tokenDeque.push(new Token<>(new MatchClauseCheckExpr(), MatchClauseCheckExpr.class, getArgContext()));}
public void metron_f8779_0(StellarParser.MatchClauseActionContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        Token<?> token = popDeque(tokenDeque);        Object value = token.getValue();        if (value != null && LambdaExpression.class.isAssignableFrom(value.getClass())) {            LambdaExpression expr = (LambdaExpression) value;                                                                        Object result = expr.apply(new ArrayList<>());            tokenDeque.push(new Token<>(result, Object.class, context));        } else {            tokenDeque.push(new Token<>(value, Object.class, context));        }    }, DeferredFunction.class, context));}
public void metron_f8780_0(StellarParser.Match_clauseContext ctx)
{    expression.tokenDeque.push(new Token<>(new MatchClauseEnd(), MatchClauseEnd.class, getArgContext()));}
public void metron_f8781_0(StellarParser.MatchClausesContext ctx)
{    expression.tokenDeque.push(new Token<>(new MatchClausesEnd(), MatchClausesEnd.class, getArgContext()));}
public void metron_f8782_0(StellarParser.ComparisonExpressionWithOperatorContext ctx)
{    final FrameContext.Context context = getArgContext();    expression.tokenDeque.push(new Token<>((tokenDeque, state) -> {        StellarParser.Comp_operatorContext op = ctx.comp_operator();        Token<?> right = popDeque(tokenDeque);        Token<?> left = popDeque(tokenDeque);        tokenDeque.push(comparisonExpressionWithOperatorEvaluator.evaluate(left, right, (StellarParser.ComparisonOpContext) op, context));    }, DeferredFunction.class, context));}
public void metron_f8783_0(StellarParser.List_entityContext ctx)
{    expression.tokenDeque.push(new Token<>(new FunctionMarker(), FunctionMarker.class, getArgContext()));}
private void metron_f8784_0()
{    if (!expression.multiArgumentState.isEmpty()) {        expression.multiArgumentState.pop();    }}
private FrameContext.Context metron_f8785_0()
{    return expression.multiArgumentState.isEmpty() ? null : expression.multiArgumentState.peek();}
private Token<?> metron_f8786_0(Deque<Token<?>> tokenDeque)
{    if (tokenDeque.isEmpty()) {        throw new ParseException("Unable to pop an empty stack");    }    return tokenDeque.pop();}
public Expression metron_f8787_0()
{    return expression;}
public Boolean metron_f8788_0(String rule, VariableResolver variableResolver, FunctionResolver functionResolver, Context context)
{    if (rule == null || isEmpty(rule.trim())) {        return true;    }    try {        return super.parse(rule, variableResolver, functionResolver, context);    } catch (ClassCastException e) {                throw new IllegalArgumentException(String.format("The rule '%s' does not return a boolean value.", rule), e);    } catch (Exception e) {        if (e.getCause() != null && e.getCause() instanceof ClassCastException) {            throw new IllegalArgumentException(String.format("The rule '%s' does not return a boolean value.", rule), e.getCause());        }        throw e;    }}
public long metron_f8789_0()
{    return System.currentTimeMillis();}
public String metron_f8790_0(String stdDateFormat)
{    SimpleDateFormat format = new SimpleDateFormat(stdDateFormat);    format.setTimeZone(TimeZone.getTimeZone(UTC));    return format.format(new Date(currentTimeMillis()));}
public String metron_f8791_0(String variable)
{    return System.getenv().get(variable);}
public void metron_f8792_0(T obj, PrimitiveSink primitiveSink)
{    primitiveSink.putBytes(serializer.apply(obj));}
public boolean metron_f8793_0(Object obj)
{    return this.getClass().equals(obj.getClass());}
public int metron_f8794_0()
{    return super.hashCode() * 31;}
public byte[] metron_f8795_0(T t)
{    return SerDeUtils.toBytes(t);}
public boolean metron_f8796_0(T key)
{    return filter.mightContain(key);}
public void metron_f8797_0(T key)
{    filter.put(key);}
public void metron_f8798_0(BloomFilter<T> filter2)
{    filter.putAll(filter2.filter);}
public boolean metron_f8799_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    BloomFilter<?> that = (BloomFilter<?>) o;    return filter != null ? filter.equals(that.filter) : that.filter == null;}
public int metron_f8800_0()
{    return filter != null ? filter.hashCode() : 0;}
public Optional<Object> metron_f8801_0(OPT_T option, CommandLine cli)
{    return Optional.empty();}
public int metron_f8802_0()
{    int size = 0;    for (Map m : variableMappings) {        size += m.size();    }    return size;}
public boolean metron_f8803_0()
{    boolean isEmpty = true;    for (Map m : variableMappings) {        isEmpty &= m.isEmpty();    }    return isEmpty;}
public boolean metron_f8804_0(Object key)
{    for (Map m : variableMappings) {        if (m.containsKey(key)) {            return true;        }    }    return false;}
public boolean metron_f8805_0(Object value)
{    for (Map m : variableMappings) {        if (m.containsValue(value)) {            return true;        }    }    return false;}
public Object metron_f8806_0(Object key)
{    Object ret = null;    for (Map m : variableMappings) {        ret = m.get(key);        if (ret != null) {            break;        }    }    return ret;}
public Object metron_f8807_0(String key, Object value)
{    throw new UnsupportedOperationException("Merged map is immutable.");}
public Object metron_f8808_0(Object key)
{    throw new UnsupportedOperationException("Merged map is immutable.");}
public void metron_f8809_0(Map<? extends String, ?> m)
{    throw new UnsupportedOperationException("Merged map is immutable.");}
public void metron_f8810_0()
{    throw new UnsupportedOperationException("Merged map is immutable.");}
public Set<String> metron_f8811_0()
{    Set<String> ret = null;    for (Map m : variableMappings) {        if (ret == null) {            ret = m.keySet();        } else {            ret = Sets.union(ret, m.keySet());        }    }    return ret;}
public Collection<Object> metron_f8812_0()
{    Collection<Object> ret = new ArrayList<>(size());    for (Map m : variableMappings) {        ret.addAll(m.values());    }    return ret;}
public Set<Entry<String, Object>> metron_f8813_0()
{    Set<Entry<String, Object>> ret = null;    for (Map m : variableMappings) {        if (ret == null) {            ret = m.entrySet();        } else {            ret = Sets.union(ret, m.entrySet());        }    }    return ret;}
public String metron_f8814_0()
{    Iterable<Iterable<Map.Entry<Object, Object>>> transformed = Iterables.transform(variableMappings, x -> x.entrySet());    Iterable<Map.Entry<Object, Object>> it = Iterables.filter(Iterables.concat(transformed), x -> x.getValue() != null);    return "{" + Joiner.on(", ").join(it) + "}";}
public boolean metron_f8815_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ConcatMap concatMap = (ConcatMap) o;    return variableMappings != null ? variableMappings.equals(concatMap.variableMappings) : concatMap.variableMappings == null;}
public int metron_f8816_0()
{    return variableMappings != null ? variableMappings.hashCode() : 0;}
public void metron_f8817_0(Kryo kryo, Output output)
{    int numVariableMappings = variableMappings.isEmpty() ? 0 : variableMappings.size();    output.writeShort(numVariableMappings);    for (Map m : variableMappings) {        byte[] b = m == null ? new byte[] {} : SerDeUtils.toBytes(m);        output.writeInt(b.length);        if (b.length > 0) {            output.writeBytes(b);        }    }}
public void metron_f8818_0(Kryo kryo, Input input)
{    int numVariableMappings = input.readShort();    variableMappings = new ArrayList<>(numVariableMappings);    for (int i = 0; i < numVariableMappings; ++i) {        int size = input.readInt();        if (size > 0) {            byte[] bytes = input.readBytes(size);            Map m = SerDeUtils.fromBytes(bytes, Map.class);            variableMappings.add(m);        }    }}
protected ConvertUtilsBean metron_f8819_0()
{    ConvertUtilsBean ret = BeanUtilsBean2.getInstance().getConvertUtils();    ret.deregister();    ret.register(false, true, 1);    return ret;}
public static T metron_f8820_0(Object o, Class<T> clazz)
{    if (o == null) {        return null;    }    return clazz.cast(UTILS_BEAN.get().convert(o, clazz));}
public static List<U> metron_f8821_0(List<T> from, Class<U> clazz)
{    return Lists.transform(from, s -> convert(s, clazz));}
public static Map<K, V2> metron_f8822_0(Map<K, V1> from, Class<V2> clazz)
{    return Maps.transformValues(from, s -> convert(s, clazz));}
public String metron_f8823_0()
{    return key;}
public String metron_f8824_0(final Object toHash) throws EncoderException, NoSuchAlgorithmException
{    final MessageDigest messageDigest = MessageDigest.getInstance(algorithm);    if (toHash == null) {        return StringUtils.repeat("00", messageDigest.getDigestLength());    } else if (toHash instanceof String) {        return getHash(messageDigest, toHash.toString().getBytes(charset));    } else if (toHash instanceof Serializable) {        final byte[] serialized = SerializationUtils.serialize((Serializable) toHash);        return getHash(messageDigest, serialized);    }    return null;}
private String metron_f8825_0(final MessageDigest messageDigest, final byte[] toHash) throws EncoderException
{    messageDigest.update(toHash);    final byte[] encode = encoder.encode(messageDigest.digest());    return new String(encode, charset);}
public void metron_f8826_0(Optional<Map<String, Object>> config)
{    if (config.isPresent() && !config.get().isEmpty()) {        charset = Config.CHARSET.get(config.get(), o -> {            String charset = ConversionUtils.convert(o, String.class);            if (charset != null) {                Charset set = Charset.forName(charset);                return set;            }            return null;        }).orElse(charset);    }}
public static final Set<String> metron_f8827_0()
{    return new HashSet<>(Security.getAlgorithms("MessageDigest"));}
 Optional<T> metron_f8828_0(Map<String, Object> config, Function<Object, T> converter)
{    Object o = config.get(getKey());    return o == null ? Optional.empty() : Optional.ofNullable(converter.apply(o));}
public static Hasher metron_f8829_0(String algorithm, Optional<Map<String, Object>> config)
{    Hasher h = null;    for (HashStrategy factory : HashStrategy.values()) {        if (factory.getSupportedHashes().contains(algorithm.toUpperCase())) {            h = factory.hasherCreator.apply(algorithm);            break;        }    }    if (h == null) {        throw new IllegalArgumentException("Unsupported hash function: " + algorithm + ".  Supported algorithms are " + Joiner.on(",").join(ALL_SUPPORTED_HASHES));    }    h.configure(config);    return h;}
public Set<String> metron_f8830_0()
{    return supportedHashes;}
public String metron_f8831_0(byte[] data, boolean force)
{    try {        creator.update(data);        return creator.getHash(force).getEncoded();    } finally {        creator.reset();    }}
public static int metron_f8832_0(String hash1, String hash2, Optional<Boolean> includeLength)
{    if (hash1 == null || hash2 == null) {        return -1;    }    if (hash1.equals(hash2)) {        return 0;    }    Tlsh t1 = Tlsh.fromTlshStr(hash1);    Tlsh t2 = Tlsh.fromTlshStr(hash2);    return t1.totalDiff(t2, includeLength.orElse(false));}
public TLSH metron_f8833_0(BucketOption bo, ChecksumOption co)
{    return cache.computeIfAbsent(new AbstractMap.SimpleEntry<>(bo, co), kv -> new TLSH(kv.getKey(), kv.getValue()));}
public String metron_f8834_0()
{    return key;}
public Object metron_f8835_0(Object o) throws EncoderException, NoSuchAlgorithmException
{    TLSH tlsh = TLSHCache.INSTANCE.get().getTLSH(bucketOption, checksumOption);    byte[] data = null;    if (o instanceof String) {        data = ((String) o).getBytes(StandardCharsets.UTF_8);    } else if (o instanceof byte[]) {        data = (byte[]) o;    } else {        data = SerDeUtils.toBytes(o);    }    try {        String hash = tlsh.apply(data, force);        if (hashes != null && hashes.size() > 0) {            Map<String, Object> ret = new HashMap<>();            ret.put(TLSH_KEY, hash);            ret.putAll(bin(hash));            return ret;        } else {            return hash;        }    } catch (Exception e) {        return null;    }}
public Map<String, String> metron_f8836_0(String hash) throws DecoderException
{    Random r = new Random(0);    byte[] h = Hex.decodeHex(hash.substring(2 * checksumOption.getChecksumLength()).toCharArray());    BitSet vector = BitSet.valueOf(h);    int n = vector.length();    Map<String, String> ret = new HashMap<>();    boolean singleHash = hashes.size() == 1;    for (int numHashes : hashes) {        BitSet projection = new BitSet();        for (int i = 0; i < numHashes; ++i) {            int index = r.nextInt(n);            projection.set(i, vector.get(index));        }        String outputHash = numHashes + Hex.encodeHexString(projection.toByteArray());        if (singleHash) {            ret.put(TLSH_BIN_KEY, outputHash);        } else {            ret.put(TLSH_BIN_KEY + "_" + numHashes, outputHash);        }    }    return ret;}
public void metron_f8837_0(Optional<Map<String, Object>> config)
{    if (config.isPresent() && !config.get().isEmpty()) {        bucketOption = Config.BUCKET_SIZE.get(config.get(), o -> {            Integer bucketSize = ConversionUtils.convert(o, Integer.class);            switch(bucketSize) {                case 128:                    return BucketOption.BUCKETS_128;                case 256:                    return BucketOption.BUCKETS_256;                default:                    return null;            }        }).orElse(bucketOption);        checksumOption = Config.CHECKSUM.get(config.get(), o -> {            Integer checksumBytes = ConversionUtils.convert(o, Integer.class);            switch(checksumBytes) {                case 1:                    return ChecksumOption.CHECKSUM_1B;                case 3:                    return ChecksumOption.CHECKSUM_3B;                default:                    return null;            }        }).orElse(checksumOption);        force = Config.FORCE.get(config.get(), o -> ConversionUtils.convert(o, Boolean.class)).orElse(force);        hashes = Config.HASHES.get(config.get(), o -> {            List<Integer> ret = new ArrayList<>();            if (o instanceof List) {                List<? extends Object> vals = (List<? extends Object>) o;                for (Object oVal : vals) {                    ret.add(ConversionUtils.convert(oVal, Integer.class));                }            } else {                ret.add(ConversionUtils.convert(o, Integer.class));            }            return ret;        }).orElse(hashes);    }}
public static final Set<String> metron_f8838_0()
{    return new HashSet<String>() {        {            add("TLSH");        }    };}
public TypeReference<T> metron_f8839_0()
{    return new TypeReference<T>() {        @Override        public Type getType() {            return type;        }    };}
public Type metron_f8840_0()
{    return type;}
public T metron_f8841_0(InputStream is, ReferenceSupplier<T> ref) throws IOException
{    return _mapper.get().readValue(is, (TypeReference<T>) ref.get());}
public T metron_f8842_0(String is, ReferenceSupplier<T> ref) throws IOException
{    return _mapper.get().readValue(is, (TypeReference<T>) ref.get());}
public T metron_f8843_0(File f, ReferenceSupplier<T> ref) throws IOException
{    try (InputStream is = new BufferedInputStream(new FileInputStream(f))) {        return _mapper.get().readValue(is, (TypeReference<T>) ref.get());    }}
public T metron_f8844_0(InputStream is, Class<T> clazz) throws IOException
{    return _mapper.get().readValue(is, clazz);}
public T metron_f8845_0(File f, Class<T> clazz) throws IOException
{    try (InputStream is = new BufferedInputStream(new FileInputStream(f))) {        return _mapper.get().readValue(is, clazz);    }}
public T metron_f8846_0(String is, Class<T> clazz) throws IOException
{    return _mapper.get().readValue(is, clazz);}
public String metron_f8847_0(Object o, boolean pretty) throws JsonProcessingException
{    if (pretty) {        return _mapper.get().writerWithDefaultPrettyPrinter().writeValueAsString(o);    } else {        return _mapper.get().writeValueAsString(o);    }}
public byte[] metron_f8848_0(Object config) throws JsonProcessingException
{    return _mapper.get().writeValueAsBytes(config);}
public JSONObject metron_f8849_0(Object o) throws JsonProcessingException, ParseException
{    return toJSONObject(toJSON(o, false));}
public JSONObject metron_f8850_0(String json) throws ParseException
{    return (JSONObject) _parser.get().parse(json);}
public int metron_f8851_0()
{    return maxArgs;}
public int metron_f8852_0()
{    return minArgs;}
public Function<Number[], Number> metron_f8853_0()
{    return operation;}
public Number metron_f8854_0(Number[] numbers)
{    return f.apply(numbers[0].doubleValue());}
public Number metron_f8855_0(Number[] numbers)
{    return f.apply(numbers[0].doubleValue(), numbers[1].doubleValue());}
public Number metron_f8856_0(Number[] in)
{    return op.getOperation().apply(in);}
public Object metron_f8857_0(List<Object> args, Context context) throws ParseException
{    if (args.size() < _func.getMinArgs()) {        return Double.NaN;    }    Number[] nums = new Number[_func.getMaxArgs()];    for (int i = 0; i < _func.getMaxArgs(); ++i) {        nums[i] = (Number) args.get(i);        if (nums[i] == null) {            return Double.NaN;        }    }    Object ret = _func.getOperation().apply(nums);    return ret;}
public void metron_f8858_0(Context context)
{}
public boolean metron_f8859_0()
{    return true;}
public Pattern metron_f8860_0(String patternString)
{    Pattern pattern = _cache.get().get(patternString);    if (pattern == null) {        pattern = Pattern.compile(patternString);        _cache.get().put(patternString, pattern);    }    return pattern;}
protected Kryo metron_f8861_0()
{    Kryo ret = new Kryo();    ret.setReferences(true);    ret.setInstantiatorStrategy(new DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));    ret.register(Arrays.asList("").getClass(), new ArraysAsListSerializer());    ret.register(Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer());    ret.register(Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer());    ret.register(Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer());    ret.register(Collections.singletonList("").getClass(), new CollectionsSingletonListSerializer());    ret.register(Collections.singleton("").getClass(), new CollectionsSingletonSetSerializer());    ret.register(Collections.singletonMap("", "").getClass(), new CollectionsSingletonMapSerializer());    ret.register(GregorianCalendar.class, new GregorianCalendarSerializer());    ret.register(InvocationHandler.class, new JdkProxySerializer());    UnmodifiableCollectionsSerializer.registerSerializers(ret);    SynchronizedCollectionsSerializer.registerSerializers(ret);            ret.register(CGLibProxySerializer.CGLibProxyMarker.class, new CGLibProxySerializer());        ret.register(LocalDate.class, new JodaLocalDateSerializer());    ret.register(LocalDateTime.class, new JodaLocalDateTimeSerializer());        ImmutableListSerializer.registerSerializers(ret);    ImmutableSetSerializer.registerSerializers(ret);    ImmutableMapSerializer.registerSerializers(ret);    ImmutableMultimapSerializer.registerSerializers(ret);    return ret;}
public void metron_f8862_0(final InstantiatorStrategy fallbackStrategy)
{    this.fallbackStrategy = fallbackStrategy;}
public InstantiatorStrategy metron_f8863_0()
{    return fallbackStrategy;}
public ObjectInstantiator metron_f8864_0(final Class type)
{    if (!Util.isAndroid) {                Class enclosingType = type.getEnclosingClass();        boolean isNonStaticMemberClass = enclosingType != null && type.isMemberClass() && !Modifier.isStatic(type.getModifiers());        if (!isNonStaticMemberClass) {            try {                final ConstructorAccess access = ConstructorAccess.get(type);                return new ObjectInstantiator() {                    @Override                    public Object newInstance() {                        try {                            return access.newInstance();                        } catch (Exception ex) {                            throw new KryoException("Error constructing instance of class: " + className(type), ex);                        }                    }                };            } catch (Exception ignored) {            }        }    }        try {        Constructor ctor;        try {            ctor = type.getConstructor((Class[]) null);        } catch (Exception ex) {            ctor = type.getDeclaredConstructor((Class[]) null);            ctor.setAccessible(true);        }        final Constructor constructor = ctor;        return new ObjectInstantiator() {            @Override            public Object newInstance() {                try {                    return constructor.newInstance();                } catch (Exception ex) {                    throw new KryoException("Error constructing instance of class: " + className(type), ex);                }            }        };    } catch (Exception ignored) {    }    if (fallbackStrategy == null) {        if (type.isMemberClass() && !Modifier.isStatic(type.getModifiers()))            throw new KryoException("Class cannot be created (non-static member class): " + className(type));        else            throw new KryoException("Class cannot be created (missing no-arg constructor): " + className(type));    }        return fallbackStrategy.newInstantiatorOf(type);}
public Object metron_f8865_0()
{    try {        return access.newInstance();    } catch (Exception ex) {        throw new KryoException("Error constructing instance of class: " + className(type), ex);    }}
public Object metron_f8866_0()
{    try {        return constructor.newInstance();    } catch (Exception ex) {        throw new KryoException("Error constructing instance of class: " + className(type), ex);    }}
public byte[] metron_f8867_0(Object o)
{    return toBytes(o);}
public T metron_f8868_0(byte[] bytes)
{    return fromBytes(bytes, clazz);}
public static byte[] metron_f8869_1(Object value)
{    try {        ByteArrayOutputStream bos = new ByteArrayOutputStream();        Output output = new Output(bos);        kryo.get().writeClassAndObject(output, value);        output.flush();        bos.flush();        return bos.toByteArray();    } catch (Throwable t) {                throw new IllegalStateException("Unable to serialize " + value + " because " + t.getMessage(), t);    }}
public static T metron_f8870_1(byte[] value, Class<T> clazz)
{    try {        Input input = new Input(new ByteArrayInputStream(value));        return clazz.cast(kryo.get().readClassAndObject(input));    } catch (Throwable t) {                throw t;    }}
public static Object metron_f8871_0(String expression, VariableResolver varResolver, Context context)
{    validate(expression, context);    Object result = execute(expression, varResolver, context);    ensureKryoSerializable(result, expression);    ensureJavaSerializable(result, expression);    return result;}
public static Object metron_f8872_0(String expression, Map<String, Object> variables, Context context)
{    VariableResolver varResolver = new DefaultVariableResolver(x -> {        if (x.equals(MapVariableResolver.ALL_FIELDS)) {            return variables;        }        return variables.get(x);    }, x -> x.equals(MapVariableResolver.ALL_FIELDS) || variables.containsKey(x));    return run(expression, varResolver, context);}
private static Object metron_f8873_0(String expression, VariableResolver variableResolver, Context context)
{    StellarProcessor processor = new StellarProcessor();    Object result = processor.parse(expression, variableResolver, StellarFunctions.FUNCTION_RESOLVER(), context);    return result;}
private static void metron_f8874_0(Object value, String expression)
{    String msg = String.format("Expression result is not Kryo serializable. It is highly recommended for all " + "functions to return a result that is Kryo serializable to allow for their broadest possible use. " + "expr=%s, value=%s", expression, value);    byte[] raw = SerDeUtils.toBytes(value);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    Assert.assertEquals(msg, value, actual);}
private static void metron_f8875_0(Object value, String expression)
{    String msg = String.format("Expression result is not Java serializable. It is highly recommended for all " + "functions to return a result that is Java serializable to allow for their broadest possible use. " + "expr=%s, value=%s", expression, value);    try {                ByteArrayOutputStream bytes = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(bytes);        out.writeObject(value);                byte[] raw = bytes.toByteArray();        assertTrue(raw.length > 0);                ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(raw));        Object actual = in.readObject();                assertEquals(msg, value, actual);    } catch (IOException | ClassNotFoundException e) {        String error = String.format("Expression result is not Java serializable. It is highly recommended for all " + "functions to return a result that is Java serializable to allow for their broadest possible use. " + "expr=%s, value=%s, error=%s", expression, value, ExceptionUtils.getRootCauseMessage(e));        fail(error);    }}
public static Object metron_f8876_0(String expression, Map<String, Object> variables)
{    return run(expression, variables, Context.EMPTY_CONTEXT());}
public static Object metron_f8877_0(String expression, VariableResolver variables)
{    return run(expression, variables, Context.EMPTY_CONTEXT());}
public static Object metron_f8878_0(String expression, Context context)
{    return run(expression, Collections.emptyMap(), context);}
public static void metron_f8879_0(String expression, Context context)
{    StellarProcessor processor = new StellarProcessor();    Assert.assertTrue("Invalid expression; expr=" + expression, processor.validate(expression, context));}
public static void metron_f8880_0(String rule)
{    validate(rule, Context.EMPTY_CONTEXT());}
public static boolean metron_f8881_0(String rule, Map resolver)
{    return runPredicate(rule, resolver, Context.EMPTY_CONTEXT());}
public static boolean metron_f8882_0(String rule, Map resolver, Context context)
{    return runPredicate(rule, new MapVariableResolver(resolver), context);}
public static boolean metron_f8883_0(String rule, VariableResolver resolver)
{    return runPredicate(rule, resolver, Context.EMPTY_CONTEXT());}
public static boolean metron_f8884_0(String rule, VariableResolver resolver, Context context)
{    StellarPredicateProcessor processor = new StellarPredicateProcessor();    Assert.assertTrue(rule + " not valid.", processor.validate(rule));    return processor.parse(rule, resolver, StellarFunctions.FUNCTION_RESOLVER(), context);}
public static void metron_f8885_0(String function, Object argument, Object expected)
{    runWithArguments(function, ImmutableList.of(argument), expected);}
public static void metron_f8886_0(String function, List<Object> arguments, Object expected)
{    Supplier<Stream<Map.Entry<String, Object>>> kvStream = () -> StreamSupport.stream(new XRange(arguments.size()), false).map(i -> new AbstractMap.SimpleImmutableEntry<>("var" + i, arguments.get(i)));    String args = kvStream.get().map(kv -> kv.getKey()).collect(Collectors.joining(","));    Map<String, Object> variables = kvStream.get().collect(Collectors.toMap(kv -> kv.getKey(), kv -> kv.getValue()));    String stellarStatement = function + "(" + args + ")";    String reason = stellarStatement + " != " + expected + " with variables: " + variables;    if (expected instanceof Double) {        Assert.assertEquals(reason, (Double) expected, (Double) run(stellarStatement, variables), 1e-6);    } else {        Assert.assertEquals(reason, expected, run(stellarStatement, variables));    }}
public boolean metron_f8887_0(IntConsumer action)
{    boolean isDone = i >= end;    if (isDone) {        return false;    } else {        action.accept(i);        i++;        return true;    }}
public boolean metron_f8888_0(Consumer<? super Integer> action)
{    boolean isDone = i >= end;    if (isDone) {        return false;    } else {        action.accept(i);        i++;        return true;    }}
public static FileSystemManager metron_f8889_0() throws FileSystemException
{    DefaultFileSystemManager vfs = new DefaultFileSystemManager();    vfs.addProvider("res", new org.apache.commons.vfs2.provider.res.ResourceFileProvider());    vfs.addProvider("zip", new org.apache.commons.vfs2.provider.zip.ZipFileProvider());    vfs.addProvider("gz", new org.apache.commons.vfs2.provider.gzip.GzipFileProvider());    vfs.addProvider("ram", new org.apache.commons.vfs2.provider.ram.RamFileProvider());    vfs.addProvider("file", new org.apache.commons.vfs2.provider.local.DefaultLocalFileProvider());    vfs.addProvider("jar", new org.apache.commons.vfs2.provider.jar.JarFileProvider());    vfs.addProvider("http", new org.apache.commons.vfs2.provider.http.HttpFileProvider());    vfs.addProvider("https", new org.apache.commons.vfs2.provider.https.HttpsFileProvider());    vfs.addProvider("ftp", new org.apache.commons.vfs2.provider.ftp.FtpFileProvider());    vfs.addProvider("ftps", new org.apache.commons.vfs2.provider.ftps.FtpsFileProvider());    vfs.addProvider("war", new org.apache.commons.vfs2.provider.jar.JarFileProvider());    vfs.addProvider("par", new org.apache.commons.vfs2.provider.jar.JarFileProvider());    vfs.addProvider("ear", new org.apache.commons.vfs2.provider.jar.JarFileProvider());    vfs.addProvider("sar", new org.apache.commons.vfs2.provider.jar.JarFileProvider());    vfs.addProvider("ejb3", new org.apache.commons.vfs2.provider.jar.JarFileProvider());    vfs.addProvider("tmp", new org.apache.commons.vfs2.provider.temp.TemporaryFileProvider());    vfs.addProvider("tar", new org.apache.commons.vfs2.provider.tar.TarFileProvider());    vfs.addProvider("tbz2", new org.apache.commons.vfs2.provider.tar.TarFileProvider());    vfs.addProvider("tgz", new org.apache.commons.vfs2.provider.tar.TarFileProvider());    vfs.addProvider("bz2", new org.apache.commons.vfs2.provider.bzip2.Bzip2FileProvider());    vfs.addProvider("hdfs", new HdfsFileProvider());    vfs.addExtensionMap("jar", "jar");    vfs.addExtensionMap("zip", "zip");    vfs.addExtensionMap("gz", "gz");    vfs.addExtensionMap("tar", "tar");    vfs.addExtensionMap("tbz2", "tar");    vfs.addExtensionMap("tgz", "tar");    vfs.addExtensionMap("bz2", "bz2");    vfs.addMimeTypeMap("application/x-tar", "tar");    vfs.addMimeTypeMap("application/x-gzip", "gz");    vfs.addMimeTypeMap("application/zip", "zip");    vfs.setFileContentInfoFactory(new FileContentInfoFilenameFactory());    vfs.setFilesCache(new SoftRefFilesCache());    vfs.setReplicator(new UniqueFileReplicator(new File(System.getProperty("java.io.tmpdir"))));    vfs.setCacheStrategy(CacheStrategy.ON_RESOLVE);    vfs.init();    return vfs;}
public static Optional<ClassLoader> metron_f8890_1(String paths) throws FileSystemException
{        if (paths.trim().isEmpty()) {                return Optional.empty();    }    FileSystemManager vfs = generateVfs();    FileObject[] objects = resolve(vfs, paths);    if (objects == null || objects.length == 0) {                return Optional.empty();    }        return Optional.of(new VFSClassLoader(objects, vfs, vfs.getClass().getClassLoader()));}
 static FileObject[] metron_f8891_1(FileSystemManager vfs, String uris) throws FileSystemException
{    if (uris == null) {        return new FileObject[0];    }    ArrayList<FileObject> classpath = new ArrayList<>();    for (String path : uris.split(",")) {        path = path.trim();        if (path.equals("")) {            continue;        }        FileObject fo = vfs.resolveFile(path);        switch(fo.getType()) {            case FILE:            case FOLDER:                classpath.add(fo);                break;            case IMAGINARY:                                String pattern = fo.getName().getBaseName();                if (fo.getParent() != null && fo.getParent().getType() == FileType.FOLDER) {                    FileObject[] children = fo.getParent().getChildren();                    for (FileObject child : children) {                        if (child.getType() == FileType.FILE && child.getName().getBaseName().matches(pattern)) {                            classpath.add(child);                        }                    }                } else {                                    }                break;            default:                                break;        }    }    return classpath.toArray(new FileObject[classpath.size()]);}
public Object metron_f8892_0(List<Object> args, Context context) throws ParseException
{    return apply(args);}
public void metron_f8893_0(Context context)
{}
public boolean metron_f8894_0()
{    return true;}
public Builder metron_f8895_0(String s, Capability capability)
{    capabilityMap.put(s, capability);    return this;}
public Builder metron_f8896_0(Enum<?> s, Capability capability)
{    capabilityMap.put(s.toString(), capability);    return this;}
public Builder metron_f8897_0(Map<String, Object> externalConfig)
{    for (Map.Entry<String, Object> entry : externalConfig.entrySet()) {        capabilityMap.put(entry.getKey(), () -> entry.getValue());    }    return this;}
public Context metron_f8898_0()
{    return new Context(capabilityMap);}
public static Context metron_f8899_0()
{    return new Context(new HashMap<>()) {    };}
public Optional<Object> metron_f8900_0(Enum<?> capability)
{    return getCapability(capability, true);}
public Optional<Object> metron_f8901_0(Enum<?> capability, boolean errorIfNotThere)
{    return getCapability(capability.toString(), errorIfNotThere);}
public Optional<Object> metron_f8902_0(String capability)
{    return getCapability(capability, true);}
public Optional<Object> metron_f8903_0(String capability, boolean errorIfNotThere)
{    Capability c = capabilities.get(capability);    if (c == null && errorIfNotThere) {        throw new IllegalStateException("Unable to find capability " + capability + "; it may not be available in your context.");    } else if (c == null) {        return Optional.empty();    }    return Optional.ofNullable(c.get());}
public void metron_f8904_0(String s, Capability capability)
{    this.capabilities.put(s, capability);}
public void metron_f8905_0(Enum<?> s, Capability capability)
{    this.capabilities.put(s.toString(), capability);}
public ActivityType metron_f8906_0()
{    return _activityType.get();}
public void metron_f8907_0(ActivityType activityType)
{    _activityType.set(activityType);}
public Object metron_f8908_0(String variable)
{    return resolveFunc.apply(variable);}
public boolean metron_f8909_0(String variable)
{    return existsFunc.apply(variable);}
public static DefaultVariableResolver metron_f8910_0()
{    return new DefaultVariableResolver(x -> null, x -> false);}
public void metron_f8911_0(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e)
{    throw new ParseException("Syntax error @ " + line + ":" + charPositionInLine + " " + msg, e);}
public void metron_f8912_0(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs)
{}
public void metron_f8913_0(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs)
{}
public void metron_f8914_0(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs)
{}
public Object metron_f8915_0(List<Object> strings)
{    return strings.get(0) == null ? null : ConversionUtils.convert(strings.get(0), clazz);}
public Object metron_f8916_0(List<Object> args)
{    BloomFilter<Object> filter = (BloomFilter) args.get(0);    for (int i = 1; i < args.size(); ++i) {        Object arg = args.get(i);        if (arg != null) {            filter.add(args.get(i));        }    }    return filter;}
public Object metron_f8917_0(List<Object> args)
{    if (args.size() == 0) {        return false;    }    BloomFilter<Object> filter = (BloomFilter) args.get(0);    if (args.size() > 1) {        Object arg = args.get(1);        if (arg == null) {            return false;        }        return filter.mightContain(arg);    }    return false;}
public Object metron_f8918_0(List<Object> args)
{    int expectedInsertions = 100000;    float falsePositiveRate = 0.01f;    if (args.size() > 1) {        expectedInsertions = ConversionUtils.convert(args.get(0), Integer.class);    }    if (args.size() > 2) {        falsePositiveRate = ConversionUtils.convert(args.get(1), Float.class);    }    return new BloomFilter<>(SerDeUtils.SERIALIZER, expectedInsertions, falsePositiveRate);}
public Object metron_f8919_0(List<Object> args)
{    if (args.size() > 0) {        Object firstArg = args.get(0);        if (firstArg instanceof List) {            BloomFilter ret = null;            for (Object bf : (List) firstArg) {                if (bf instanceof BloomFilter) {                    if (ret == null) {                        ret = (BloomFilter) bf;                    } else {                        ret.merge((BloomFilter) bf);                    }                }            }            return ret;        } else {            return null;        }    }    return null;}
public Object metron_f8920_0(List<Object> list)
{    if (null == list || list.size() == 0) {        return true;    }    Object o = list.get(0);    if (o instanceof Collection) {        return ((Collection) o).isEmpty();    } else if (o instanceof String) {        String val = (String) list.get(0);        return val == null || val.isEmpty() ? true : false;    } else if (o instanceof Map) {        return (((Map) o).isEmpty());    } else {        return o == null;    }}
public Object metron_f8921_0(List<Object> list)
{    if (list.size() == 0) {        return null;    }    Object o = list.get(0);    if (list.size() == 1) {        return o;    }    if (o instanceof List) {        List l = (List) o;        Object arg = list.get(1);        l.add(arg);        return l;    } else {        return o;    }}
public Object metron_f8922_0(List<Object> list)
{    if (list.size() == 0) {        return 0;    }    Object o = list.get(0);    if (o instanceof Collection) {        return ((Collection) o).size();    } else if (o instanceof Map) {        return ((Map) o).size();    } else if (o instanceof String) {        String val = (String) list.get(0);        return val == null || val.isEmpty() ? 0 : val.length();    } else {        return 0;    }}
public SimpleDateFormat metron_f8923_0()
{    return createFormat(format, timezone);}
public boolean metron_f8924_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    TimezonedFormat that = (TimezonedFormat) o;    if (format != null ? !format.equals(that.format) : that.format != null)        return false;    return timezone != null ? timezone.equals(that.timezone) : that.timezone == null;}
public int metron_f8925_0()
{    int result = format != null ? format.hashCode() : 0;    result = 31 * result + (timezone != null ? timezone.hashCode() : 0);    return result;}
public ThreadLocal<SimpleDateFormat> metron_f8926_0(final TimezonedFormat format) throws Exception
{    return new ThreadLocal<SimpleDateFormat>() {        @Override        public SimpleDateFormat initialValue() {            return format.toDateFormat();        }    };}
public SimpleDateFormat metron_f8927_0()
{    return format.toDateFormat();}
public static SimpleDateFormat metron_f8928_0(String format, Optional<String> timezone)
{    SimpleDateFormat sdf = new SimpleDateFormat(format);    if (timezone.isPresent()) {        sdf.setTimeZone(TimeZone.getTimeZone(timezone.get()));    }    return sdf;}
public static long metron_f8929_0(String date, String format, Optional<String> timezone) throws ExecutionException, ParseException
{    TimezonedFormat fmt;    if (timezone.isPresent()) {        fmt = new TimezonedFormat(format, timezone.get());    } else {        fmt = new TimezonedFormat(format);    }    SimpleDateFormat sdf = formatCache.get(fmt).get();    return sdf.parse(date).getTime();}
public static String metron_f8930_0(String format, Optional<Long> epochTime, Optional<String> timezone)
{    Long time = epochTime.orElseGet(System::currentTimeMillis);    TimezonedFormat fmt = timezone.map(s -> new TimezonedFormat(format, s)).orElseGet(() -> new TimezonedFormat(format));    SimpleDateFormat sdf = formatCache.get(fmt).get();    return sdf.format(new Date(time));}
public Object metron_f8931_0(List<Object> objects)
{    Object dateObj = objects.get(0);    Object formatObj = objects.get(1);    Object tzObj = null;    if (objects.size() >= 3) {        tzObj = objects.get(2);    }    if (dateObj != null && formatObj != null) {        try {            Optional<String> tz = (tzObj == null) ? Optional.empty() : Optional.of(tzObj.toString());            return getEpochTime(dateObj.toString(), formatObj.toString(), tz);        } catch (ExecutionException | ParseException e) {            return null;        }    }    return null;}
public Object metron_f8932_0(List<Object> objects)
{    int size = objects.size();    Optional<Object> formatObj = Optional.ofNullable(objects.get(0));    Optional<Long> epochObj = Optional.empty();    Optional<String> tzObj = Optional.empty();    if (size > 1) {        if (size == 2) {            if (objects.get(1) == null) {                return null;            }            epochObj = objects.get(1) instanceof Long ? Optional.of((Long) objects.get(1)) : Optional.empty();            tzObj = objects.get(1) instanceof String ? Optional.of((String) objects.get(1)) : Optional.empty();        } else {            epochObj = Optional.ofNullable((Long) objects.get(1));            tzObj = Optional.ofNullable((String) objects.get(2));        }    }    if (formatObj.isPresent()) {        return getDateFormat(formatObj.get().toString(), epochObj, tzObj);    } else {        return null;    }}
private static T metron_f8933_0(List<Object> args, int position, Class<T> clazz, T defaultValue)
{    T result = defaultValue;    if (args.size() > position) {        result = ConversionUtils.convert(args.get(position), clazz);    }    return result;}
public Object metron_f8934_0(List<Object> args)
{        Long epochMillis = getOrDefault(args, 0, Long.class, System.currentTimeMillis());    if (epochMillis == null) {                return null;    }        Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(epochMillis);    return calendar.get(Calendar.DAY_OF_WEEK);}
public Object metron_f8935_0(List<Object> args)
{        Long epochMillis = getOrDefault(args, 0, Long.class, System.currentTimeMillis());    if (epochMillis == null) {                return null;    }        Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(epochMillis);    return calendar.get(Calendar.DAY_OF_MONTH);}
public Object metron_f8936_0(List<Object> args)
{        Long epochMillis = getOrDefault(args, 0, Long.class, System.currentTimeMillis());    if (epochMillis == null) {                return null;    }        Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(epochMillis);    return calendar.get(Calendar.WEEK_OF_MONTH);}
public Object metron_f8937_0(List<Object> args)
{        Long epochMillis = getOrDefault(args, 0, Long.class, System.currentTimeMillis());    if (epochMillis == null) {                return null;    }        Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(epochMillis);    return calendar.get(Calendar.WEEK_OF_YEAR);}
public Object metron_f8938_0(List<Object> args)
{        Long epochMillis = getOrDefault(args, 0, Long.class, System.currentTimeMillis());    if (epochMillis == null) {                return null;    }        Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(epochMillis);    return calendar.get(Calendar.MONTH);}
public Object metron_f8939_0(List<Object> args)
{        Long epochMillis = getOrDefault(args, 0, Long.class, System.currentTimeMillis());    if (epochMillis == null) {                return null;    }        Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(epochMillis);    return calendar.get(Calendar.YEAR);}
public Object metron_f8940_0(List<Object> args)
{        Long epochMillis = getOrDefault(args, 0, Long.class, System.currentTimeMillis());    if (epochMillis == null) {                return null;    }        Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(epochMillis);    return calendar.get(Calendar.DAY_OF_YEAR);}
public Object metron_f8941_0(List<Object> list)
{    return Encodings.SUPPORTED_LIST;}
public Object metron_f8942_0(List<Object> list)
{    if (list.size() < 2) {        throw new IllegalStateException("IS_ENCODING expects two args: [string, encoding] where encoding is one from " + "the supported list");    }    String str = (String) list.get(0);    String encoding = (String) list.get(1);    if (StringUtils.isEmpty(str) || StringUtils.isEmpty(encoding)) {        return false;    }    Encodings enc = null;    try {        enc = Encodings.valueOf(encoding.toUpperCase());    } catch (IllegalArgumentException iae) {        throw new IllegalStateException(String.format("Encoding %s not supported", encoding), iae);    }    return enc.is(str);}
public Object metron_f8943_0(List<Object> list)
{    if (list.size() != 2 && list.size() != 3) {        throw new IllegalStateException("DECODE expects two or three args: [string, encoding] or " + "[string, encoding, verify] where encoding is one from " + "the supported list");    }    Boolean verify = false;    String str = (String) list.get(0);    String encoding = (String) list.get(1);    if (list.size() == 3) {        verify = (Boolean) list.get(2);    }    if (StringUtils.isEmpty(str) || StringUtils.isEmpty(encoding)) {        return null;    }    Encodings enc = null;    try {        enc = Encodings.valueOf(encoding.toUpperCase());    } catch (IllegalArgumentException iae) {        throw new IllegalStateException(String.format("Encoding %s not supported", encoding), iae);    }    return enc.decode(str, verify);}
public Object metron_f8944_0(List<Object> list)
{    if (list.size() != 2 && list.size() != 3) {        throw new IllegalStateException("ENCODE expects two or three args: [string, encoding] where encoding is one from " + "the supported list");    }    String str = (String) list.get(0);    String encoding = (String) list.get(1);    if (StringUtils.isEmpty(str) || StringUtils.isEmpty(encoding)) {        return null;    }    Encodings enc = null;    try {        enc = Encodings.valueOf(encoding.toUpperCase());    } catch (IllegalArgumentException iae) {        throw new IllegalStateException(String.format("Encoding %s not supported", encoding), iae);    }    return enc.encode(str);}
public Object metron_f8945_0(List<Object> args)
{    Iterable<? extends Object> input = getIterable(args.get(0));    LambdaExpression expression = (LambdaExpression) args.get(1);    if (input == null || expression == null) {        return input;    }    List<Object> ret = new ArrayList<>();    for (Object o : input) {        ret.add(expression.apply(listOf(o)));    }    return ret;}
public Object metron_f8946_0(List<Object> args)
{    Iterable<? extends Object> input = getIterable(args.get(0));    LambdaExpression expression = (LambdaExpression) args.get(1);    if (input == null || expression == null) {        return input;    }    List<Object> ret = new ArrayList<>();    for (Object o : input) {        Object result = expression.apply(listOf(o));        if (result != null && result instanceof Boolean && (Boolean) result) {            ret.add(o);        }    }    return ret;}
public Object metron_f8947_0(List<Object> args)
{    Iterable<? extends Object> input = getIterable(args.get(0));    if (input == null || args.size() < 3) {        return null;    }    LambdaExpression expression = (LambdaExpression) args.get(1);    Object runningResult = args.get(2);    if (expression == null || runningResult == null) {        return null;    }    for (Object rhs : input) {        runningResult = expression.apply(listOf(runningResult, rhs));    }    return runningResult;}
private static Iterable<? extends Object> metron_f8948_0(Object o)
{    if (o == null) {        return null;    }    if (o instanceof String) {        return Lists.charactersOf((String) o);    } else if (o instanceof Iterable) {        return (Iterable<Object>) o;    } else {        throw new IllegalArgumentException(o.getClass() + " is not an iterable, and therefore cannot be used.");    }}
public Object metron_f8949_0(List<Object> args)
{    if (args == null || args.size() == 0) {        return new ArrayList<>();    }    return zip(args, true);}
public Object metron_f8950_0(List<Object> args)
{    if (args == null || args.size() == 0) {        return new ArrayList<>();    }    return zip(args, false);}
private static List<List<Object>> metron_f8951_0(List<Object> args, boolean jagged)
{    List<List<Object>> lists = new ArrayList<>();    Integer resultSize = null;    for (Object o : args) {        if (o instanceof List) {            List<Object> l = (List<Object>) o;            if (resultSize == null) {                resultSize = l.size();            } else if (jagged) {                resultSize = Math.max(l.size(), resultSize);            } else {                resultSize = Math.min(l.size(), resultSize);            }            lists.add(l);        }    }    if (resultSize == null) {        return new ArrayList<>();    }    return IntStream.range(0, resultSize).mapToObj(i -> {        List<Object> o = new ArrayList<>();        for (List<Object> list : lists) {            o.add(i < list.size() ? list.get(i) : null);        }        return o;    }).collect(Collectors.toList());}
private static List<Object> metron_f8952_0(Object... vals)
{    List<Object> ret = new ArrayList<>(vals.length);    for (int i = 0; i < vals.length; ++i) {        ret.add(vals[i]);    }    return ret;}
public List<String> metron_f8953_0(final List<Object> args)
{    if (args == null || args.size() != 0) {        throw new IllegalArgumentException("Invalid call. This function does not expect any arguments.");    }    List<String> ret = new ArrayList<>();    ret.addAll(HashStrategy.ALL_SUPPORTED_HASHES);    return ret;}
public Object metron_f8954_0(final List<Object> args)
{    if (args == null || args.size() < 2) {        throw new IllegalArgumentException("Invalid number of arguments: " + (args == null ? 0 : args.size()));    }    final Object toHash = args.get(0);    final Object hashType = args.get(1);    if (hashType == null) {        return null;    }    Map<String, Object> config = null;    if (args.size() > 2) {        Object configObj = args.get(2);        if (configObj instanceof Map && configObj != null) {            config = (Map<String, Object>) configObj;        }    }    try {        return HashStrategy.getHasher(hashType.toString(), Optional.ofNullable(config)).getHash(toHash);    } catch (final EncoderException e) {        return null;    } catch (final NoSuchAlgorithmException e) {        throw new IllegalArgumentException("Invalid hash type: " + hashType.toString());    }}
public Integer metron_f8955_0(final List<Object> args)
{    if (args == null || args.size() < 2) {        throw new IllegalArgumentException("Invalid call. This function requires at least 2 arguments: the two TLSH hashes.");    }    Object h1Obj = args.get(0);    Object h2Obj = args.get(1);    if (h1Obj != null && !(h1Obj instanceof String)) {        throw new IllegalArgumentException(h1Obj + " must be strings");    }    if (h2Obj != null && !(h2Obj instanceof String)) {        throw new IllegalArgumentException(h2Obj + " must be strings");    }    Optional<Boolean> includeLength = Optional.empty();    if (args.size() > 2) {        Object includeLengthArg = args.get(2);        if (includeLengthArg != null) {            includeLength = Optional.ofNullable(ConversionUtils.convert(includeLengthArg, Boolean.class));        }    }    return TLSH.distance(h1Obj == null ? null : h1Obj.toString(), h2Obj == null ? null : h2Obj.toString(), includeLength);}
public Object metron_f8956_0(List<Object> list)
{    if (list.size() < 2) {        return false;    }    Object key = list.get(0);    Object mapObj = list.get(1);    if (key != null && mapObj != null && mapObj instanceof Map) {        return ((Map) mapObj).containsKey(key);    }    return false;}
public Object metron_f8957_0(List<Object> objects)
{    Object keyObj = objects.get(0);    Object mapObj = objects.get(1);    Object defaultObj = null;    if (objects.size() >= 3) {        defaultObj = objects.get(2);    }    if (keyObj == null || mapObj == null) {        return defaultObj;    }    Map<Object, Object> map = (Map) mapObj;    Object ret = map.get(keyObj);    if (ret == null && defaultObj != null) {        return defaultObj;    }    return ret;}
public Object metron_f8958_0(List<Object> objects)
{    if (objects.size() < 3) {        throw new IllegalArgumentException("Must pass a key, value, and map");    } else {        Object keyObj = objects.get(0);        Object valueObj = objects.get(1);        Object mapObj = objects.get(2);        if (mapObj == null) {            mapObj = new HashMap<>();        }        Map<Object, Object> map = (Map) mapObj;        map.put(keyObj, valueObj);        return map;    }}
public Object metron_f8959_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashMap<Object, Object> ret = new LinkedHashMap<>();    Object o = list.get(0);    if (o != null) {        if (!(o instanceof Iterable)) {            throw new IllegalArgumentException("Expected an Iterable, but " + o + " is of type " + o.getClass());        }        Iterable<? extends Map> maps = (Iterable<? extends Map>) o;        if (Iterables.size(maps) == 1) {            return Iterables.getFirst(maps, null);        }        for (Map m : maps) {            if (m != null) {                ret.putAll(m);            }        }    }    return ret;}
public Object metron_f8960_0(List<Object> args)
{    if (args == null || args.size() != 1) {        throw new IllegalStateException("IS_NAN expects one: [number] ");    }    Object obj = args.get(0);    if (obj instanceof Number) {        return Double.isNaN(((Number) obj).doubleValue());    } else {        throw new ParseException("IS_NAN() expects a number argument");    }}
public Object metron_f8961_0(List<Object> list)
{    if (list.size() < 2) {        throw new IllegalStateException("IN_SUBNET expects at least two args: [ip, cidr1, cidr2, ...]" + " where cidr is the subnet mask in cidr form");    }    String ip = (String) list.get(0);    if (ip == null) {        return false;    }    boolean inSubnet = false;    for (int i = 1; i < list.size() && !inSubnet; ++i) {        String cidr = (String) list.get(i);        if (cidr == null) {            continue;        }        inSubnet |= new SubnetUtils(cidr).getInfo().isInRange(ip);    }    return inSubnet;}
public Object metron_f8962_0(List<Object> objects)
{    if (objects.isEmpty()) {        return null;    }    Object dnObj = objects.get(0);    InternetDomainName idn = toDomainName(dnObj);    if (idn != null) {        String dn = dnObj.toString();        String tld = extractTld(idn, dn);        if (!StringUtils.isEmpty(dn)) {            String suffix = safeSubstring(dn, 0, dn.length() - tld.length());            String hostnameWithoutTLD = safeSubstring(suffix, 0, suffix.length() - 1);            if (hostnameWithoutTLD == null) {                return dn;            }            String hostnameWithoutSubsAndTLD = Iterables.getLast(Splitter.on(".").split(hostnameWithoutTLD), null);            if (hostnameWithoutSubsAndTLD == null) {                return null;            }            return hostnameWithoutSubsAndTLD + "." + tld;        }    }    return null;}
public Object metron_f8963_0(List<Object> objects)
{    Object dnObj = objects.get(0);    InternetDomainName idn = toDomainName(dnObj);    if (idn != null) {        String dn = dnObj.toString();        String tld = extractTld(idn, dn);        String suffix = safeSubstring(dn, 0, dn.length() - tld.length());        if (StringUtils.isEmpty(suffix)) {            return suffix;        } else {            return suffix.substring(0, suffix.length() - 1);        }    }    return null;}
public Object metron_f8964_0(List<Object> objects)
{    Object dnObj = objects.get(0);    InternetDomainName idn = toDomainName(dnObj);    return extractTld(idn, dnObj + "");}
public Object metron_f8965_0(List<Object> objects)
{    URL url = toUrl(objects.get(0));    if (url == null) {        return null;    }    int port = url.getPort();    return port >= 0 ? port : url.getDefaultPort();}
public Object metron_f8966_0(List<Object> objects)
{    URL url = toUrl(objects.get(0));    return url == null ? null : url.getPath();}
public Object metron_f8967_0(List<Object> objects)
{    URL url = toUrl(objects.get(0));    return url == null ? null : url.getHost();}
public Object metron_f8968_0(List<Object> objects)
{    URL url = toUrl(objects.get(0));    return url == null ? null : url.getProtocol();}
private static String metron_f8969_0(InternetDomainName idn, String dn)
{    if (idn != null && idn.hasPublicSuffix()) {        String ret = idn.publicSuffix().toString();        if (ret.startsWith("InternetDomainName")) {            return Joiner.on(".").join(idn.publicSuffix().parts());        } else {            return ret;        }    } else if (dn != null) {        StringBuffer tld = new StringBuffer("");        for (int idx = dn.length() - 1; idx >= 0; idx--) {            char c = dn.charAt(idx);            if (c == '.') {                break;            } else {                tld.append(dn.charAt(idx));            }        }        return tld.reverse().toString();    } else {        return null;    }}
private static String metron_f8970_0(String val, int start, int end)
{    if (!StringUtils.isEmpty(val)) {        return val.substring(start, end);    }    return null;}
private static InternetDomainName metron_f8971_0(Object dnObj)
{    if (dnObj != null) {        if (dnObj instanceof String) {            String dn = dnObj.toString();            try {                return InternetDomainName.from(dn);            } catch (IllegalArgumentException iae) {                return null;            }        } else {            throw new IllegalArgumentException(dnObj + " is not a string and therefore also not a domain.");        }    }    return null;}
private static URL metron_f8972_0(Object urlObj)
{    if (urlObj == null) {        return null;    }    if (urlObj instanceof String) {        String url = urlObj.toString();        try {            return new URL(url);        } catch (MalformedURLException e) {            return null;        }    } else {        throw new IllegalArgumentException(urlObj + " is not a string and therefore also not a URL.");    }}
public Object metron_f8973_0(List<Object> args)
{    if (args.size() < 1 || args.get(0) == null) {        throw new IllegalStateException("MAX function requires at least one argument");    }    Object firstArg = args.get(0);    if (firstArg instanceof Ordinal) {        Ordinal stats = convert(firstArg, Ordinal.class);        return stats.getMax();    } else if (firstArg instanceof Iterable) {        Iterable<Comparable> list = (Iterable<Comparable>) args.get(0);        return orderList(list, (ret, val) -> ret.compareTo(val) < 0, "MAX");    } else {        throw new IllegalStateException("MAX function expects either 'a StatisticsProvider object' or 'Stellar list of values'");    }}
public Object metron_f8974_0(List<Object> args)
{    if (args.size() < 1 || args.get(0) == null) {        throw new IllegalStateException("MIN function requires at least one argument");    }    Object firstArg = args.get(0);    if (firstArg instanceof Ordinal) {        Ordinal stats = convert(firstArg, Ordinal.class);        return stats.getMin();    } else if (firstArg instanceof Iterable) {        Iterable<Comparable> list = (Iterable<Comparable>) args.get(0);        return orderList(list, (ret, val) -> ret.compareTo(val) > 0, "MIN");    } else {        throw new IllegalStateException("MIN function expects either 'a StatisticsProvider object' or 'Stellar list of values' ");    }}
private static Comparable metron_f8975_0(Iterable<Comparable> list, BiFunction<Comparable, Comparable, Boolean> eval, String funcName)
{    if (Iterables.isEmpty(list)) {        return null;    }    Object o = Iterables.getFirst(list, null);    Comparable ret = null;    for (Object valueVal : list) {        if (valueVal == null) {            continue;        }        Comparable value = null;        if (!(valueVal instanceof Comparable)) {            throw new IllegalStateException("Noncomparable object type " + valueVal.getClass().getName() + " submitted to " + funcName);        } else {            value = (Comparable) valueVal;        }        try {            Comparable convertedRet = ConversionUtils.convert(ret, value.getClass());            if (convertedRet == null && ret != null) {                throw new IllegalStateException("Incomparable objects were submitted to " + funcName + ": " + ret.getClass() + " is incomparable to " + value.getClass());            }            if (ret == null || eval.apply(convertedRet, value)) {                ret = value;            }        } catch (ClassCastException cce) {            throw new IllegalStateException("Incomparable objects were submitted to " + funcName + ": " + cce.getMessage(), cce);        }    }    return ret;}
public Object metron_f8976_0(List<Object> list)
{    if (list.size() < 2) {        throw new IllegalStateException("REGEXP_MATCH expects two args: [string, pattern] where pattern is a regexp pattern or a list of regexp patterns");    }    Object patternObject = list.get(1);    String str = (String) list.get(0);    if (str == null || patternObject == null) {        return false;    }    if (patternObject instanceof String) {        return PatternCache.INSTANCE.getPattern((String) patternObject).matcher(str).matches();    } else if (patternObject instanceof Iterable) {        boolean matches = false;        for (Object thisPatternObject : (Iterable) patternObject) {            if (thisPatternObject == null) {                continue;            }            if (PatternCache.INSTANCE.getPattern(thisPatternObject.toString()).matcher(str).matches()) {                matches = true;                break;            }        }        return matches;    }    return false;}
public Object metron_f8977_0(List<Object> list)
{    if (list.size() != 3) {        throw new IllegalStateException("REGEXP_GROUP_VAL expects three args: [string, pattern, int]" + "" + "where pattern is a regexp pattern");    }    String stringPattern = (String) list.get(1);    String str = (String) list.get(0);    Integer groupNumber = ConversionUtils.convert(list.get(2), Integer.class);    if (groupNumber == null) {                return null;    }    if (groupNumber == 0) {                return str;    }    if (str == null || stringPattern == null) {        return null;    }    Pattern pattern = PatternCache.INSTANCE.getPattern(stringPattern);    Matcher matcher = pattern.matcher(str);    if (!matcher.matches()) {        return null;    }    int groupCount = matcher.groupCount();    if (groupCount == 0 || groupCount < groupNumber) {        return null;    }    return matcher.group(groupNumber);}
public Object metron_f8978_0(List<Object> list)
{    if (list.size() != 3) {        throw new IllegalStateException("REGEXP_REPLACE expects three args: [string, pattern, value]" + " where pattern is a regexp pattern");    }    String str = (String) list.get(0);    String stringPattern = (String) list.get(1);    String value = (String) list.get(2);    if (StringUtils.isEmpty(str)) {        return null;    }    if (StringUtils.isEmpty(stringPattern) || StringUtils.isEmpty(value)) {        return str;    }    Pattern pattern = PatternCache.INSTANCE.getPattern(stringPattern);    Matcher matcher = pattern.matcher(str);    return matcher.replaceAll(value);}
public Iterable<StellarFunctionInfo> metron_f8979_0()
{    return functions.get().values();}
public Iterable<String> metron_f8980_0()
{    return functions.get().keySet();}
public void metron_f8981_0(Context context)
{    this.context = context;}
public void metron_f8982_1() throws IOException
{    if (!closed) {                Map<String, Throwable> errors = new HashMap<>();        for (StellarFunctionInfo info : getFunctionInfo()) {            try {                info.getFunction().close();            } catch (Throwable t) {                errors.put(info.getName(), t);            }        }        if (!errors.isEmpty()) {            StringBuilder sb = new StringBuilder();            sb.append("Unable to close Stellar functions:");            for (Map.Entry<String, Throwable> e : errors.entrySet()) {                Throwable throwable = e.getValue();                String eText = String.format("Exception - Function: %s; Message: %s; Cause: %s", e.getKey(), throwable.getMessage(), throwable.getCause());                sb.append(System.lineSeparator());                sb.append(eText);            }            closed = true;            throw new IOException(sb.toString());        }        closed = true;    } else {            }}
public StellarFunction metron_f8983_0(String functionName)
{    StellarFunctionInfo info = functions.get().get(functionName);    if (info == null) {        throw new IllegalStateException(format("Unknown function: `%s`", functionName));    }    return info.getFunction();}
public static StellarFunctionInfo metron_f8985_0(Class<? extends StellarFunction> clazz)
{    StellarFunctionInfo info = null;        if (clazz.isAnnotationPresent(Stellar.class)) {        Stellar annotation = clazz.getAnnotation(Stellar.class);        String fullyQualifiedName = getNameFromAnnotation(annotation);        StellarFunction function = createFunction(clazz);        if (fullyQualifiedName != null && function != null) {            info = new StellarFunctionInfo(annotation.description(), fullyQualifiedName, annotation.params(), annotation.returns(), function);        }    }    return info;}
public static String metron_f8986_0(Stellar annotation)
{        String name = annotation.name();    if (name == null || name.trim().length() == 0) {        return null;    } else {        name = name.trim();    }        String namespace = annotation.namespace();    if (namespace == null || namespace.length() == 0) {        namespace = null;    } else {        namespace = namespace.trim();    }    return Joiner.on("_").skipNulls().join(Arrays.asList(namespace, name));}
public static StellarFunction metron_f8987_1(Class<? extends StellarFunction> clazz)
{    try {        return clazz.getConstructor().newInstance();    } catch (Exception e) {                return null;    }}
public String metron_f8988_0()
{    return param;}
public Object metron_f8989_0(Map<String, Object> config)
{    return config.getOrDefault(param, defaultValue);}
public T metron_f8990_0(Map<String, Object> config, Class<T> clazz)
{    return ConversionUtils.convert(get(config), clazz);}
public void metron_f8991_0(ClassLoader... classloaders)
{    classLoaders.clear();    Arrays.stream(classloaders).forEach(c -> classLoaders.add(c));}
public void metron_f8992_0(String... toInclude)
{    for (String incl : toInclude) {        includes.add(incl);    }}
public void metron_f8993_0(String... toExclude)
{    for (String excl : toExclude) {        excludes.add(excl);    }}
protected Iterable<Class<?>> metron_f8995_0(ClassLoader cl)
{    return ClassIndex.getAnnotated(Stellar.class, cl);}
protected boolean metron_f8996_0(Class<?> c, FilterBuilder filterBuilder)
{    boolean isAssignable = StellarFunction.class.isAssignableFrom(c);    boolean isFiltered = filterBuilder.apply(c.getCanonicalName());    return isAssignable && isFiltered;}
public Set<Class<? extends StellarFunction>> metron_f8997_1()
{    ClassLoader[] cls = null;    if (this.classLoaders.size() == 0) {                cls = new ClassLoader[] { getClass().getClassLoader() };    } else {        List<ClassLoader> classLoaderList = new ArrayList<>();        for (int i = 0; i < this.classLoaders.size(); ++i) {            ClassLoader cl = this.classLoaders.get(i);            if (null != cl) {                                classLoaderList.add(cl);            } else {                            }        }        cls = classLoaderList.toArray(new ClassLoader[0]);    }    FilterBuilder filterBuilder = new FilterBuilder();    excludes.forEach(excl -> {        if (excl != null) {            filterBuilder.exclude(excl);        }    });    includes.forEach(incl -> {        if (incl != null) {            filterBuilder.include(incl);        }    });    Set<String> classes = new HashSet<>();    Set<Class<? extends StellarFunction>> ret = new HashSet<>();    for (ClassLoader cl : cls) {        for (Class<?> c : getStellarClasses(cl)) {            try {                                if (includeClass(c, filterBuilder)) {                    String className = c.getName();                    if (!classes.contains(className)) {                                                ret.add((Class<? extends StellarFunction>) c);                        classes.add(className);                    }                }            } catch (Error le) {                                try {                                    } catch (Error ie) {                                                        }            }        }    }    return ret;}
 void metron_f8998_0() throws IOException
{}
public Set<Class<? extends StellarFunction>> metron_f8999_0()
{    return classesToResolve;}
public SimpleFunctionResolver metron_f9000_0(Class<? extends StellarFunction> clazz)
{    this.classesToResolve.add(clazz);    return this;}
public static FunctionResolver metron_f9001_0()
{    return INSTANCE;}
public String metron_f9002_0()
{    return (String) get(BASIC_AUTH_USER);}
public String metron_f9003_0()
{    return (String) get(BASIC_AUTH_PASSWORD_PATH);}
public String metron_f9004_0()
{    return (String) get(PROXY_HOST);}
public Integer metron_f9005_0()
{    return (Integer) get(PROXY_PORT);}
public String metron_f9006_0()
{    return (String) get(PROXY_BASIC_AUTH_USER);}
public String metron_f9007_0()
{    return (String) get(PROXY_BASIC_AUTH_PASSWORD_PATH);}
public Integer metron_f9008_0()
{    return (Integer) get(TIMEOUT);}
public Integer metron_f9009_0()
{    return (Integer) get(CONNECT_TIMEOUT);}
public Integer metron_f9010_0()
{    return (Integer) get(CONNECTION_REQUEST_TIMEOUT);}
public Integer metron_f9011_0()
{    return (Integer) get(SOCKET_TIMEOUT);}
public List<Integer> metron_f9012_0()
{    return (List<Integer>) get(RESPONSE_CODES_ALLOWED);}
public Object metron_f9013_0()
{    return get(EMPTY_CONTENT_OVERRIDE);}
public Object metron_f9014_0()
{    return get(ERROR_VALUE_OVERRIDE);}
public Integer metron_f9015_0()
{    return (Integer) get(POOLING_MAX_TOTAL);}
public Integer metron_f9016_0()
{    return (Integer) get(POOLING_DEFAULT_MAX_PER_RUOTE);}
public Boolean metron_f9017_0()
{    return (Boolean) get(VERIFY_CONTENT_LENGTH);}
public Boolean metron_f9018_0()
{    return (Boolean) get(ENFORCE_JSON);}
private static synchronized void metron_f9019_0(Context context)
{    if (closeableHttpClient == null) {        closeableHttpClient = getHttpClient(context);    }}
private static synchronized void metron_f9020_0() throws IOException
{    if (closeableHttpClient != null) {        closeableHttpClient.close();        closeableHttpClient = null;    }}
private static synchronized void metron_f9021_0()
{    if (scheduledExecutorService == null) {        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();    }}
private static synchronized void metron_f9022_0()
{    if (scheduledExecutorService != null) {        scheduledExecutorService.shutdown();        scheduledExecutorService = null;    }}
public void metron_f9023_0(Context context)
{    initializeExecutorService();    initializeHttpClient(context);    initialized = true;}
public boolean metron_f9024_0()
{    return initialized;}
public Object metron_f9025_1(List<Object> args, Context context) throws ParseException
{    String uriString = getArg(0, String.class, args);    Map<String, Object> functionRestConfig = null;    Map<String, Object> queryParameters = new HashMap<>();    if (args.size() > 1) {        functionRestConfig = getArg(1, Map.class, args);        if (args.size() == 3) {            queryParameters = getArg(2, Map.class, args);        }    }        Map<String, Object> globalRestConfig = (Map<String, Object>) getGlobalConfig(context).get(STELLAR_REST_SETTINGS);    Map<String, Object> getRestConfig = (Map<String, Object>) getGlobalConfig(context).get(STELLAR_REST_GET_SETTINGS);    RestConfig restConfig = buildRestConfig(globalRestConfig, getRestConfig, functionRestConfig);    try {        HttpGet httpGet = buildGetRequest(uriString, queryParameters);        return executeRequest(restConfig, httpGet);    } catch (URISyntaxException e) {        throw new IllegalArgumentException(e.getMessage(), e);    } catch (IOException e) {                return restConfig.getErrorValueOverride();    }}
public void metron_f9026_0() throws IOException
{    closeHttpClient();    closeExecutorService();}
private HttpGet metron_f9027_0(String uri, Map<String, Object> queryParameters) throws URISyntaxException
{    HttpGet httpGet = new HttpGet(getURI(uri, queryParameters));    httpGet.addHeader("Accept", "application/json");    return httpGet;}
public void metron_f9028_0(Context context)
{    initializeExecutorService();    initializeHttpClient(context);    initialized = true;}
public boolean metron_f9029_0()
{    return initialized;}
public Object metron_f9030_1(List<Object> args, Context context) throws ParseException
{    String uriString = getArg(0, String.class, args);    Object dataObject = getArg(1, Object.class, args);    Map<String, Object> functionRestConfig = null;    Map<String, Object> queryParameters = new HashMap<>();    if (args.size() > 2) {        functionRestConfig = getArg(2, Map.class, args);        if (args.size() == 4) {            queryParameters = getArg(3, Map.class, args);        }    }        Map<String, Object> globalRestConfig = (Map<String, Object>) getGlobalConfig(context).get(STELLAR_REST_SETTINGS);    Map<String, Object> postRestConfig = (Map<String, Object>) getGlobalConfig(context).get(STELLAR_REST_POST_SETTINGS);    RestConfig restConfig = buildRestConfig(globalRestConfig, postRestConfig, functionRestConfig);    try {        HttpPost httpPost = buildPostRequest(restConfig, uriString, dataObject, queryParameters);        return executeRequest(restConfig, httpPost);    } catch (URISyntaxException e) {        throw new IllegalArgumentException(e.getMessage(), e);    } catch (IOException e) {                return restConfig.getErrorValueOverride();    }}
public void metron_f9031_0() throws IOException
{    closeHttpClient();    closeExecutorService();}
private HttpPost metron_f9032_0(RestConfig restConfig, String uriString, Object dataObject, Map<String, Object> queryParameters) throws JsonProcessingException, URISyntaxException, UnsupportedEncodingException
{    String body = getPostData(restConfig, dataObject);    URI uri = getURI(uriString, queryParameters);    HttpPost httpPost = new HttpPost(uri);    httpPost.setEntity(new StringEntity(body));    httpPost.addHeader("Accept", "application/json");    httpPost.addHeader("Content-type", "application/json");    return httpPost;}
private String metron_f9033_0(RestConfig restConfig, Object arg) throws JsonProcessingException
{    String data = "";    if (arg == null) {        return data;    }    if (arg instanceof Map) {        data = JSONUtils.INSTANCE.toJSON(arg, false);    } else {        data = arg.toString();        if (restConfig.enforceJson()) {            try {                JSONUtils.INSTANCE.toJSONObject(data);            } catch (org.json.simple.parser.ParseException e) {                throw new IllegalArgumentException(String.format("POST data '%s' must be properly formatted JSON.  " + "Set the '%s' property to false to disable this check.", data, RestConfig.ENFORCE_JSON));            }        }    }    return data;}
public static T metron_f9034_0(int index, Class<T> clazz, List<Object> args)
{    if (index >= args.size()) {        throw new IllegalArgumentException(format("Expected at least %d argument(s), found %d", index + 1, args.size()));    }    return ConversionUtils.convert(args.get(index), clazz);}
protected static CloseableHttpClient metron_f9035_0(Context context)
{    RestConfig restConfig = buildRestConfig(getGlobalConfig(context));    PoolingHttpClientConnectionManager cm = getConnectionManager(restConfig);    return HttpClients.custom().setConnectionManager(cm).build();}
protected static PoolingHttpClientConnectionManager metron_f9036_0(RestConfig restConfig)
{    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();    if (restConfig.containsKey(POOLING_MAX_TOTAL)) {        cm.setMaxTotal(restConfig.getPoolingMaxTotal());    }    if (restConfig.containsKey(POOLING_DEFAULT_MAX_PER_RUOTE)) {        cm.setDefaultMaxPerRoute(restConfig.getPoolingDefaultMaxPerRoute());    }    return cm;}
private static Map<String, Object> metron_f9037_0(Context context)
{    Optional<Object> globalCapability = context.getCapability(GLOBAL_CONFIG, false);    return globalCapability.map(o -> (Map<String, Object>) o).orElseGet(HashMap::new);}
protected static RestConfig metron_f9038_0(Map<String, Object>... configs)
{    RestConfig restConfig = new RestConfig();        for (Map<String, Object> config : configs) {        if (config != null) {            restConfig.putAll(config);        }    }    return restConfig;}
private static URI metron_f9039_0(String uriString, Map<String, Object> queryParameters) throws URISyntaxException
{    URIBuilder uriBuilder = new URIBuilder(uriString);    if (queryParameters != null) {        for (Map.Entry<String, Object> entry : queryParameters.entrySet()) {            uriBuilder.setParameter(entry.getKey(), (String) entry.getValue());        }    }    return uriBuilder.build();}
protected static Optional<HttpHost> metron_f9040_0(RestConfig restConfig)
{    Optional<HttpHost> proxy = Optional.empty();    if (restConfig.getProxyHost() != null && restConfig.getProxyPort() != null) {        proxy = Optional.of(new HttpHost(restConfig.getProxyHost(), restConfig.getProxyPort(), "http"));    }    return proxy;}
protected static RequestConfig metron_f9041_0(RestConfig restConfig, Optional<HttpHost> proxy)
{    RequestConfig.Builder requestConfigBuilder = RequestConfig.custom();    if (restConfig.getConnectTimeout() != null) {        requestConfigBuilder.setConnectTimeout(restConfig.getConnectTimeout());    }    if (restConfig.getConnectionRequestTimeout() != null) {        requestConfigBuilder.setConnectionRequestTimeout(restConfig.getConnectionRequestTimeout());    }    if (restConfig.getSocketTimeout() != null) {        requestConfigBuilder.setSocketTimeout(restConfig.getSocketTimeout());    }    proxy.ifPresent(requestConfigBuilder::setProxy);    return requestConfigBuilder.build();}
protected static HttpClientContext metron_f9042_0(RestConfig restConfig, HttpHost target, Optional<HttpHost> proxy) throws IOException
{    HttpClientContext httpClientContext = HttpClientContext.create();    boolean credentialsAdded = false;    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();        if (restConfig.getBasicAuthUser() != null && restConfig.getBasicAuthPasswordPath() != null) {        String password = new String(readBytes(new Path(restConfig.getBasicAuthPasswordPath())), StandardCharsets.UTF_8);        credentialsProvider.setCredentials(new AuthScope(target), new UsernamePasswordCredentials(restConfig.getBasicAuthUser(), password));        credentialsAdded = true;    }        if (proxy.isPresent() && restConfig.getProxyBasicAuthUser() != null && restConfig.getProxyBasicAuthPasswordPath() != null) {        String password = new String(readBytes(new Path(restConfig.getProxyBasicAuthPasswordPath())), StandardCharsets.UTF_8);        credentialsProvider.setCredentials(new AuthScope(proxy.get()), new UsernamePasswordCredentials(restConfig.getProxyBasicAuthUser(), password));        credentialsAdded = true;    }    if (credentialsAdded) {        httpClientContext.setCredentialsProvider(credentialsProvider);    }    return httpClientContext;}
private static byte[] metron_f9043_0(Path inPath) throws IOException
{    FileSystem fs = FileSystem.get(inPath.toUri(), new Configuration());    try (FSDataInputStream inputStream = fs.open(inPath)) {        return IOUtils.toByteArray(inputStream);    }}
protected static Optional<Object> metron_f9045_0(RestConfig restConfig, HttpUriRequest httpUriRequest, HttpEntity httpEntity) throws IOException
{    Optional<Object> parsedResponse = Optional.empty();    if (httpEntity != null) {        int actualContentLength = 0;        String json = EntityUtils.toString(httpEntity);        if (json != null && !json.isEmpty()) {            actualContentLength = json.length();            parsedResponse = Optional.of(JSONUtils.INSTANCE.load(json, JSONUtils.MAP_SUPPLIER));        }        if (restConfig.verifyContentLength() && actualContentLength != httpEntity.getContentLength()) {            throw new IOException(String.format("Stellar REST request to %s returned incorrect or missing content length. " + "Content length in the response was %d but the actual body content length was %d.", httpUriRequest.getURI().toString(), httpEntity.getContentLength(), actualContentLength));        }    }    return parsedResponse;}
protected static void metron_f9046_0(CloseableHttpClient httpClient)
{    closeableHttpClient = httpClient;}
protected static void metron_f9047_0(ScheduledExecutorService executorService)
{    scheduledExecutorService = executorService;}
public Object metron_f9048_0(List<Object> list)
{    LinkedHashSet<Object> ret = new LinkedHashSet<>();    if (list.size() == 1) {        Object o = list.get(0);        if (o != null) {            if (o instanceof Iterable) {                Iterables.addAll(ret, (Iterable) o);            } else {                throw new IllegalArgumentException("Expected an Iterable, but " + o + " is of type " + o.getClass());            }        }    }    return ret;}
public Object metron_f9049_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashSet<Object> ret = (LinkedHashSet<Object>) list.get(0);    if (ret == null) {        ret = new LinkedHashSet<>();    }    for (int i = 1; i < list.size(); ++i) {        Object o = list.get(i);        if (o != null) {            ret.add(o);        }    }    return ret;}
public Object metron_f9050_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashSet<Object> ret = (LinkedHashSet<Object>) list.get(0);    if (ret == null) {        ret = new LinkedHashSet<>();    }    for (int i = 1; i < list.size(); ++i) {        Object o = list.get(i);        if (o != null) {            ret.remove(o);        }    }    return ret;}
public Object metron_f9051_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashSet<Object> ret = new LinkedHashSet<>();    Object o = list.get(0);    if (o != null) {        if (!(o instanceof Iterable)) {            throw new IllegalArgumentException("Expected an Iterable, but " + o + " is of type " + o.getClass());        }        Iterable<? extends Iterable> sets = (Iterable<? extends Iterable>) o;        for (Iterable s : sets) {            if (s != null) {                Iterables.addAll(ret, s);            }        }    }    return ret;}
public Object metron_f9052_0(List<Object> list)
{    LinkedHashMap<Object, Integer> ret = new LinkedHashMap<>();    if (list.size() >= 1) {        Object o = list.get(0);        if (o != null) {            if (!(o instanceof Iterable)) {                throw new IllegalArgumentException("Expected an Iterable, but " + o + " is of type " + o.getClass());            }            for (Object obj : (Iterable) o) {                ret.merge(obj, 1, (k, one) -> k + one);            }        }    }    return ret;}
public Object metron_f9053_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashMap<Object, Integer> ret = (LinkedHashMap<Object, Integer>) list.get(0);    if (ret == null) {        ret = new LinkedHashMap<>();    }    for (int i = 1; i < list.size(); ++i) {        Object o = list.get(i);        if (o != null) {            ret.merge(o, 1, (k, one) -> k + one);        }    }    return ret;}
public Object metron_f9054_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashMap<Object, Integer> ret = (LinkedHashMap<Object, Integer>) list.get(0);    if (ret == null) {        ret = new LinkedHashMap<>();    }    for (int i = 1; i < list.size(); ++i) {        Object o = list.get(i);        if (o != null) {            Integer cnt = ret.get(o);            if (cnt == null) {                continue;            }            if (cnt == 1) {                ret.remove(o);            } else {                ret.put(o, cnt - 1);            }        }    }    return ret;}
public Object metron_f9055_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashMap<Object, Integer> ret = new LinkedHashMap<>();    Iterable<Map<Object, Integer>> maps = (Iterable<Map<Object, Integer>>) list.get(0);    for (Map<Object, Integer> s : maps) {        if (s != null) {            for (Map.Entry<Object, Integer> kv : s.entrySet()) {                ret.merge(kv.getKey(), kv.getValue(), (k, cnt) -> k + cnt);            }        }    }    return ret;}
public Object metron_f9056_0(List<Object> list)
{    if (list.size() < 1) {        return null;    }    LinkedHashSet<Object> ret = new LinkedHashSet<>();    if (list.size() == 1) {        Map<Object, Integer> multiset = (Map<Object, Integer>) list.get(0);        if (multiset != null) {            ret.addAll(multiset.keySet());        }    }    return ret;}
private static Map<String, VariableResult> metron_f9057_0(Context context)
{    return (Map<String, VariableResult>) context.getCapability(Context.Capabilities.SHELL_VARIABLES).get();}
public Object metron_f9058_0(List<Object> args)
{    if (args.size() < 1) {        return null;    }    Map<Object, Object> map = (Map<Object, Object>) args.get(0);    if (map == null) {        map = new HashMap<>();    }    String[] headers = { "KEY", "VALUE" };    String[][] data = new String[map.size()][2];    int i = 0;    for (Map.Entry<Object, Object> kv : map.entrySet()) {        data[i++] = new String[] { kv.getKey().toString(), kv.getValue().toString() };    }    return FlipTable.of(headers, data);}
public Object metron_f9059_0(List<Object> args, Context context) throws ParseException
{    Map<String, VariableResult> variables = getVariables(context);    String[] headers = { "VARIABLE", "VALUE", "EXPRESSION" };    String[][] data = new String[variables.size()][3];    int wordWrap = -1;    if (args.size() > 0) {        wordWrap = ConversionUtils.convert(args.get(0), Integer.class);    }    int i = 0;    for (Map.Entry<String, VariableResult> kv : variables.entrySet()) {        VariableResult result = kv.getValue();        data[i++] = new String[] { toWrappedString(kv.getKey(), wordWrap), toWrappedString(result.getResult(), wordWrap), toWrappedString(result.getExpression().get(), wordWrap) };    }    return FlipTable.of(headers, data);}
private static String metron_f9060_0(Object o, int wrap)
{    String s = "" + o;    if (wrap <= 0) {        return s;    }    return WordUtils.wrap(s, wrap);}
public void metron_f9061_0(Context context)
{}
public boolean metron_f9062_0()
{    return true;}
public Object metron_f9063_0(List<Object> args, Context context) throws ParseException
{    Map<String, VariableResult> variables = getVariables(context);    LinkedHashMap<String, String> ret = new LinkedHashMap<>();    for (Object arg : args) {        if (arg == null) {            continue;        }        String variable = (String) arg;        VariableResult result = variables.get(variable);        if (result != null && result.getExpression().isPresent()) {            ret.put(variable, result.getExpression().orElseGet(() -> ""));        }    }    return ret;}
public void metron_f9064_0(Context context)
{}
public boolean metron_f9065_0()
{    return true;}
public Object metron_f9066_0(List<Object> args, Context context) throws ParseException
{    Map<String, VariableResult> variables = getVariables(context);    if (args.size() == 0) {        return null;    }    String variable = (String) args.get(0);    if (variable == null) {        return null;    }    VariableResult result = variables.get(variable);    if (result != null && result.getExpression().isPresent()) {        return result.getExpression().get();    }    return null;}
public void metron_f9067_0(Context context)
{}
public boolean metron_f9068_0()
{    return true;}
private String metron_f9069_0()
{            String editor = System.getProperty("EDITOR");    if (org.apache.commons.lang3.StringUtils.isEmpty(editor)) {        editor = System.getenv().get("EDITOR");    }    if (org.apache.commons.lang3.StringUtils.isEmpty(editor)) {        editor = System.getenv("VISUAL");    }    if (org.apache.commons.lang3.StringUtils.isEmpty(editor)) {        editor = "/bin/vi";    }    return editor;}
public Object metron_f9070_1(List<Object> args, Context context) throws ParseException
{    File outFile = null;    String editor = getEditor();    try {        outFile = File.createTempFile("stellar_shell", "out");        if (args.size() > 0) {            String arg = (String) args.get(0);            try (PrintWriter pw = new PrintWriter(outFile, StandardCharsets.UTF_8.name())) {                IOUtils.write(arg, pw);            }        }    } catch (IOException e) {        String message = "Unable to create temp file: " + e.getMessage();                throw new IllegalStateException(message, e);    }    Optional<Object> console = context.getCapability(CONSOLE, false);    try {        PausableInput.INSTANCE.pause();                ProcessBuilder processBuilder = new ProcessBuilder(editor, outFile.getAbsolutePath());        processBuilder.redirectInput(ProcessBuilder.Redirect.INHERIT);        processBuilder.redirectOutput(ProcessBuilder.Redirect.INHERIT);        processBuilder.redirectError(ProcessBuilder.Redirect.INHERIT);        try {            Process p = processBuilder.start();                        p.waitFor();            try (BufferedReader br = Files.newBufferedReader(outFile.toPath(), StandardCharsets.UTF_8)) {                return IOUtils.toString(br).trim();            }        } catch (Exception e) {            String message = "Unable to read output: " + e.getMessage();                        return null;        }    } finally {        try {            PausableInput.INSTANCE.unpause();            if (console.isPresent()) {                ((Console) console.get()).pushToInputStream("\b\n");            }        } catch (IOException e) {                    }        if (outFile.exists()) {            outFile.delete();        }    }}
public void metron_f9071_0(Context context)
{}
public boolean metron_f9072_0()
{    return true;}
public Object metron_f9073_0(List<Object> list)
{    if (list.size() < 2) {        throw new IllegalStateException("ENDS_WITH expects two args: [string, suffix] where suffix is the string fragment that the string should end with");    }    String prefix = (String) list.get(1);    String str = (String) list.get(0);    if (str == null || prefix == null) {        return false;    }    return str.endsWith(prefix);}
public Object metron_f9074_0(List<Object> list)
{    if (list.size() < 2) {        throw new IllegalStateException("STARTS_WITH expects two args: [string, prefix] where prefix is the string fragment that the string should start with");    }    String prefix = (String) list.get(1);    String str = (String) list.get(0);    if (str == null || prefix == null) {        return false;    }    return str.startsWith(prefix);}
public Object metron_f9075_0(List<Object> strings)
{    return strings.get(0) == null ? null : strings.get(0).toString().toLowerCase();}
public Object metron_f9076_0(List<Object> strings)
{    return strings.get(0) == null ? null : strings.get(0).toString().toUpperCase();}
public Object metron_f9077_0(List<Object> strings)
{    return strings.get(0) == null ? null : strings.get(0).toString();}
public Object metron_f9078_0(List<Object> strings)
{    return strings.get(0) == null ? null : strings.get(0).toString().trim();}
public Object metron_f9079_0(List<Object> args)
{    Iterable<Object> arg1 = (Iterable<Object>) args.get(0);    String delim = (String) args.get(1);    return Joiner.on(delim).join(Iterables.filter(arg1, x -> x != null));}
public Object metron_f9080_0(List<Object> args)
{    List ret = new ArrayList();    Object o1 = args.get(0);    if (o1 != null) {        String arg1 = o1.toString();        String delim = (String) args.get(1);        Iterables.addAll(ret, Splitter.on(delim).split(arg1));    }    return ret;}
public Object metron_f9081_0(List<Object> args)
{    List<Object> arg1 = (List<Object>) args.get(0);    return Iterables.getLast(arg1, null);}
public Object metron_f9082_0(List<Object> args)
{    List<Object> arg1 = (List<Object>) args.get(0);    return Iterables.getFirst(arg1, null);}
public Object metron_f9083_0(List<Object> args)
{    List<Object> arg1 = (List<Object>) args.get(0);    int offset = (Integer) args.get(1);    if (offset < arg1.size()) {        return Iterables.get(arg1, offset);    }    return null;}
public Object metron_f9084_0(List<Object> args)
{    if (args.size() < 3) {        throw new IllegalStateException("FILL_LEFT expects three args: [string,char,length] where char is the fill character string and length is the required length of the result");    }    return fill(FillDirection.LEFT, args.get(0), args.get(1), args.get(2));}
public Object metron_f9085_0(List<Object> args)
{    if (args.size() < 3) {        throw new IllegalStateException("FILL_RIGHT expects three args: [string,char,length] where char is the fill character string and length is the required length of the result");    }    return fill(FillDirection.RIGHT, args.get(0), args.get(1), args.get(2));}
private static Object metron_f9086_0(FillDirection direction, Object inputObject, Object fillObject, Object requiredLengthObject) throws ParseException
{    if (inputObject == null) {        return null;    }    String input = inputObject.toString();    if (requiredLengthObject == null || fillObject == null) {        throw new IllegalStateException("Required Length and Fill String are both required");    }    String fill = fillObject.toString();    if (org.apache.commons.lang.StringUtils.isEmpty(fill)) {        throw new IllegalStateException("The fill cannot be an empty string");    }    fill = fill.substring(0, 1);    Integer requiredLength = ConversionUtils.convert(requiredLengthObject, Integer.class);    if (requiredLength == null) {        throw new IllegalStateException("Required Length  not a valid Integer: " + requiredLengthObject.toString());    }    if (direction == FillDirection.LEFT) {        return org.apache.commons.lang.StringUtils.leftPad(input, requiredLength, fill);    }    return org.apache.commons.lang.StringUtils.rightPad(input, requiredLength, fill);}
public Object metron_f9087_0(List<Object> strings)
{    /*      Shannon entropy is defined as follows:      \Eta(X) = - \sum(p(x_i)*log_2(p(x_i)), i=0, n-1) where x_i are distinct characters in the string.       */    Map<Character, Integer> frequency = new HashMap<>();    if (strings.size() != 1) {        throw new IllegalArgumentException("STRING_ENTROPY expects exactly one argument which is a string.");    }    String input = ConversionUtils.convert(strings.get(0), String.class);    if (StringUtils.isEmpty(input)) {        return 0.0;    }    for (int i = 0; i < input.length(); ++i) {        char c = input.charAt(i);        frequency.put(c, frequency.getOrDefault(c, 0) + 1);    }    double ret = 0.0;    double log2 = Math.log(2);    for (Integer f : frequency.values()) {        double p = f.doubleValue() / input.length();        ret -= p * Math.log(p) / log2;    }    return ret;}
public Object metron_f9088_0(List<Object> args)
{    if (args.size() == 0) {        throw new IllegalArgumentException("[FORMAT] missing argument: format string");    }    String format = ConversionUtils.convert(args.get(0), String.class);    Object[] formatArgs = args.subList(1, args.size()).toArray();    return String.format(format, formatArgs);}
public Object metron_f9089_0(List<Object> strings)
{    if (strings == null || strings.size() < 2) {        throw new IllegalArgumentException("SUBSTRING requires (at least) 2 arguments: the input and the start position (inclusive)");    }    Object varObj = strings.get(0);    if (varObj != null && !(varObj instanceof String)) {        throw new IllegalArgumentException("SUBSTRING input must be a String");    }    String var = varObj == null ? null : (String) varObj;    Object startObj = strings.get(1);    if (startObj != null && !(startObj instanceof Number)) {        throw new IllegalArgumentException("SUBSTRING start must be an Number");    }    Integer start = startObj == null ? null : ((Number) startObj).intValue();    Integer end = null;    if (strings.size() > 2) {        Object endObj = strings.get(2);        if (endObj != null && !(endObj instanceof Number)) {            throw new IllegalArgumentException("SUBSTRING end must be an Number");        }        end = endObj == null ? null : ((Number) endObj).intValue();    }    if (var == null || start == null) {        return null;    } else if (var.length() == 0) {        return var;    } else {        if (end == null) {            return var.substring(start);        } else {            return var.substring(start, end);        }    }}
public Object metron_f9090_0(List<Object> strings)
{    if (strings == null || strings.size() == 0) {        throw new IllegalArgumentException("[CHOMP] missing argument: string to be chopped");    }    String var = strings.get(0) == null ? null : (String) strings.get(0);    if (var == null) {        return null;    } else if (var.length() == 0) {        return var;    } else {        return StringUtils.chomp(var);    }}
public Object metron_f9091_0(List<Object> strings)
{    if (strings == null || strings.size() == 0) {        throw new IllegalArgumentException("[CHOP] missing argument: string to be chopped");    }    String var = strings.get(0) == null ? null : (String) strings.get(0);    if (var == null) {        return null;    } else if (var.length() == 0) {        return var;    } else {        return StringUtils.chop(var);    }}
public Object metron_f9092_0(List<Object> strings)
{    String prefixed;    switch(strings.size()) {        case 2:            prefixed = StringUtils.prependIfMissing((String) strings.get(0), (String) strings.get(1));            break;        case 3:            prefixed = StringUtils.prependIfMissing((String) strings.get(0), (String) strings.get(1), (String) strings.get(2));            break;        default:            throw new IllegalArgumentException("[PREPEND_IF_MISSING] incorrect arguments: " + strings.toString() + "\nUsage: PREPEND_IF_MISSING <String> <prefix> [<prefix>...]");    }    return prefixed;}
public Object metron_f9093_0(List<Object> strings)
{    String suffixed;    switch(strings.size()) {        case 2:            suffixed = StringUtils.appendIfMissing((String) strings.get(0), (String) strings.get(1));            break;        case 3:            suffixed = StringUtils.appendIfMissing((String) strings.get(0), (String) strings.get(1), (String) strings.get(2));            break;        default:            throw new IllegalArgumentException("[APPEND_IF_MISSING] incorrect arguments. Usage: APPEND_IF_MISSING <String> <prefix> [<prefix>...]");    }    return suffixed;}
public Object metron_f9094_0(List<Object> strings)
{    if (strings.size() != 2) {        throw new IllegalArgumentException("[COUNT_MATCHES] incorrect arguments. Usage: COUNT_MATCHES <String> <substring>");    }    int matchcount;    matchcount = StringUtils.countMatches((String) strings.get(0), (String) strings.get(1));    return matchcount;}
public Object metron_f9095_0(List<Object> strings)
{    if (strings == null || strings.size() == 0) {        throw new IllegalArgumentException("[TO_JSON_OBJECT] incorrect arguments. Usage: TO_JSON_OBJECT <String>");    }    String var = (strings.get(0) == null) ? null : (String) strings.get(0);    if (var == null) {        return null;    } else if (var.length() == 0) {        return var;    } else {        if (!(strings.get(0) instanceof String)) {            throw new ParseException("Valid JSON string not supplied");        }                try {            return JSONUtils.INSTANCE.load((String) strings.get(0), Object.class);        } catch (JsonProcessingException ex) {            throw new ParseException("Valid JSON string not supplied", ex);        } catch (IOException e) {            e.printStackTrace();        }    }    return new ParseException("Unable to parse JSON string");}
public Object metron_f9096_0(List<Object> strings)
{    if (strings == null || strings.size() == 0) {        throw new IllegalArgumentException("[TO_JSON_MAP] incorrect arguments. Usage: TO_JSON_MAP <JSON String>");    }    String var = (strings.get(0) == null) ? null : (String) strings.get(0);    if (var == null) {        return null;    } else if (var.length() == 0) {        return var;    } else {        if (!(strings.get(0) instanceof String)) {            throw new ParseException("Valid JSON string not supplied");        }                String in = (String) strings.get(0);        try {            return (Map) JSONUtils.INSTANCE.load(in, JSONUtils.MAP_SUPPLIER);        } catch (JsonProcessingException ex) {            throw new ParseException(String.format("%s is not a valid JSON string", in), ex);        } catch (IOException ex) {            throw new ParseException(String.format("%s is not a valid JSON string", in), ex);        } catch (ClassCastException ex) {            throw new ParseException(String.format("%s is not a valid JSON string, expected a map", in), ex);        }    }}
public Object metron_f9097_0(List<Object> strings)
{    if (strings == null || strings.size() == 0) {        throw new IllegalArgumentException("[TO_JSON_LIST] incorrect arguments. Usage: TO_JSON_LIST <JSON String>");    }    String var = (strings.get(0) == null) ? null : (String) strings.get(0);    if (var == null) {        return null;    } else if (var.length() == 0) {        return var;    } else {        if (!(strings.get(0) instanceof String)) {            throw new ParseException("Valid JSON string not supplied");        }                String in = (String) strings.get(0);        try {            return (List) JSONUtils.INSTANCE.load(in, JSONUtils.LIST_SUPPLIER);        } catch (JsonProcessingException ex) {            throw new ParseException(String.format("%s is not a valid JSON string", in), ex);        } catch (IOException ex) {            throw new ParseException(String.format("%s is not a valid JSON string", in), ex);        } catch (ClassCastException ex) {            throw new ParseException(String.format("%s is not a valid JSON string, expected a list", in), ex);        }    }}
public Object metron_f9098_0(List<Object> args)
{    return extractTypeChecked(args, 0, String.class, x -> env.get((String) x.get(0)));}
public static Object metron_f9099_0(List<Object> args, int i, Class clazz, Function<List<Object>, Object> extractFunc)
{    if (args.size() < i + 1) {        return null;    } else if (clazz.isInstance(args.get(i))) {        return extractFunc.apply(args);    } else {        return null;    }}
public Object metron_f9100_0(List<Object> args)
{    return extractTypeChecked(args, 0, String.class, x -> System.getProperty((String) args.get(0)));}
public Object metron_f9101_0(List<Object> list)
{    return tagsList;}
public Object metron_f9102_0(List<Object> list)
{    if (list.size() < 3) {        throw new IllegalStateException("FUZZY_SCORE expects three args: [string, string, string]");    }    Object oterm = list.get(0);    Object oquery = list.get(1);    Object olang = list.get(2);        if (!(oterm instanceof String) || !(oquery instanceof String) || !(olang instanceof String)) {        return 0;    }    String term = (String) oterm;    String query = (String) oquery;    String lang = (String) olang;    if (!tagsList.contains(lang)) {        throw new ParseException("FUZZY_SCORE requires a valid IETF BCP47 language code see FUZZY_LANGS and https://tools.ietf.org/html/bcp47");    }    if (StringUtils.isEmpty(term) || StringUtils.isEmpty(query)) {        return 0;    }    Locale locale = Locale.forLanguageTag(lang);    FuzzyScore score = new FuzzyScore(locale);    return score.fuzzyScore(term, query);}
public static String metron_f9103_0(ParseTree tree)
{    return new AST(tree).toString();}
private Object metron_f9104_0(ParseTree tree)
{    if (tree.getChildCount() == 0) {        return tree.getPayload();    } else {        String ruleName = tree.getClass().getSimpleName().replace("Context", "");        return Character.toLowerCase(ruleName.charAt(0)) + ruleName.substring(1);    }}
private static void metron_f9105_0(ParseTree tree, AST ast)
{    if (tree.getChildCount() == 0) {        new AST(ast, tree);    } else if (tree.getChildCount() == 1) {        walk(tree.getChild(0), ast);    } else if (tree.getChildCount() > 1) {        for (int i = 0; i < tree.getChildCount(); i++) {            AST temp = new AST(ast, tree.getChild(i));            if (!(temp.payload instanceof Token)) {                walk(tree.getChild(i), temp);            }        }    }}
public String metron_f9106_0()
{    StringBuilder builder = new StringBuilder();    AST ast = this;    List<AST> firstStack = new ArrayList<>();    firstStack.add(ast);    List<List<AST>> childListStack = new ArrayList<>();    childListStack.add(firstStack);    while (!childListStack.isEmpty()) {        List<AST> childStack = childListStack.get(childListStack.size() - 1);        if (childStack.isEmpty()) {            childListStack.remove(childListStack.size() - 1);        } else {            ast = childStack.remove(0);            String caption;            if (ast.payload instanceof Token) {                Token token = (Token) ast.payload;                caption = String.format("TOKEN[type: %s, text: %s]", token.getType(), token.getText().replace("\n", "\\n"));            } else {                caption = String.valueOf(ast.payload);            }            String indent = "";            for (int i = 0; i < childListStack.size() - 1; i++) {                indent += (childListStack.get(i).size() > 0) ? "|  " : "   ";            }            builder.append(indent).append(childStack.isEmpty() ? "'- " : "|- ").append(caption).append("\n");            if (ast.children.size() > 0) {                List<AST> children = new ArrayList<>();                for (int i = 0; i < ast.children.size(); i++) {                    children.add(ast.children.get(i));                }                childListStack.add(children);            }        }    }    return builder.toString();}
public void metron_f9107_0(Map... ms)
{    if (ms != null) {        for (Map m : ms) {            if (m != null) {                this.variableMappings.add(m);            }        }    }}
public Object metron_f9108_0(String variable)
{    if (variable != null && variable.equals(VariableResolver.ALL_FIELDS)) {        return new ConcatMap(variableMappings);    }    for (Map variableMapping : variableMappings) {        Object o = variableMapping.get(variable);        if (o != null) {            return o;        }    }    return null;}
public boolean metron_f9109_0(String variable)
{    return true;}
public Object metron_f9110_0(List<Object> objects)
{    return pred.test(objects);}
 void metron_f9111_0() throws IOException
{}
public String metron_f9112_0()
{    return returns;}
public String metron_f9113_0()
{    return description;}
public String metron_f9114_0()
{    return name;}
public String[] metron_f9115_0()
{    return params;}
public StellarFunction metron_f9116_0()
{    return function;}
public boolean metron_f9117_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    StellarFunctionInfo that = (StellarFunctionInfo) o;    if (name != null ? !name.equals(that.name) : that.name != null)        return false;    if (description != null ? !description.equals(that.description) : that.description != null)        return false;    if (returns != null ? !returns.equals(that.returns) : that.returns != null)        return false;        if (!Arrays.equals(params, that.params))        return false;    return function != null ? function.equals(that.function) : that.function == null;}
public int metron_f9118_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (description != null ? description.hashCode() : 0);    result = 31 * result + (returns != null ? returns.hashCode() : 0);    result = 31 * result + Arrays.hashCode(params);    result = 31 * result + (function != null ? function.hashCode() : 0);    return result;}
public String metron_f9119_0()
{    return "StellarFunctionInfo{" + "name='" + name + '\'' + ", description='" + description + '\'' + ", returns='" + returns + '\'' + ", params=" + Arrays.toString(params) + ", function=" + function + '}';}
public static FunctionResolver metron_f9120_0()
{    return SingletonFunctionResolver.getInstance();}
public static void metron_f9121_0(Context context)
{    SingletonFunctionResolver.getInstance().initialize(context);}
public static void metron_f9122_0() throws IOException
{    SingletonFunctionResolver.getInstance().close();}
public FrameContext.Context metron_f9123_0()
{    return multiArgContext;}
public T metron_f9124_0()
{    return value;}
public Class<T> metron_f9125_0()
{    return underlyingType;}
public String metron_f9126_0()
{    return "" + value;}
public boolean metron_f9127_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Token<?> token = (Token<?>) o;    if (getValue() != null ? !getValue().equals(token.getValue()) : token.getValue() != null)        return false;    return getUnderlyingType() != null ? getUnderlyingType().equals(token.getUnderlyingType()) : token.getUnderlyingType() == null;}
public int metron_f9128_0()
{    int result = getValue() != null ? getValue().hashCode() : 0;    result = 31 * result + (getUnderlyingType() != null ? getUnderlyingType().hashCode() : 0);    return result;}
public void metron_f9129_0() throws Exception
{    processor = new BaseStellarProcessor<>(Object.class);}
public void metron_f9130_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage("Unable to parse ': ");    processor.validate("'", true, Context.EMPTY_CONTEXT());}
public void metron_f9131_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage("Unable to parse ': ");    processor.validate("'", Context.EMPTY_CONTEXT());}
public void metron_f9132_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage("Unable to parse ': ");    processor.validate("'");}
public void metron_f9133_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage(" Unable to resolve function named 'UNKNOWN_FUNCTION'.");    assertTrue(processor.validate("1 < UNKNOWN_FUNCTION(3)", Context.EMPTY_CONTEXT()));}
public void metron_f9134_0() throws Exception
{    assertTrue(processor.validate("unknown_variable\n\n"));    assertTrue(processor.validate("unknown_variable > 2", Context.EMPTY_CONTEXT()));}
public void metron_f9135_0() throws Exception
{    assertFalse(processor.validate("true †", false, Context.EMPTY_CONTEXT()));    assertFalse(processor.validate("¢ (1 + 2)", false, Context.EMPTY_CONTEXT()));}
public void metron_f9136_0() throws Exception
{        Map<String, Object> cacheConfig = ImmutableMap.of(CachingStellarProcessor.MAX_CACHE_SIZE_PARAM, 2, CachingStellarProcessor.MAX_TIME_RETAIN_PARAM, 10, CachingStellarProcessor.RECORD_STATS, true);    cache = CachingStellarProcessor.createCache(cacheConfig);    contextWithCache = new Context.Builder().with(Context.Capabilities.CACHE, () -> cache).build();        processor = new CachingStellarProcessor();}
public void metron_f9137_0()
{    Object result = execute("TO_UPPER(name)", contextWithCache);    assertEquals("BLAH", result);    assertEquals(1, cache.stats().requestCount());    assertEquals(1, cache.stats().missCount());    assertEquals(0, cache.stats().hitCount());    result = execute("TO_UPPER(name)", contextWithCache);    assertEquals("BLAH", result);    assertEquals(2, cache.stats().requestCount());    assertEquals(1, cache.stats().missCount());    assertEquals(1, cache.stats().hitCount());    result = execute("TO_UPPER(name)", contextWithCache);    assertEquals("BLAH", result);    assertEquals(3, cache.stats().requestCount());    assertEquals(1, cache.stats().missCount());    assertEquals(2, cache.stats().hitCount());}
public void metron_f9138_0() throws Exception
{        Context contextNoCache = Context.EMPTY_CONTEXT();    assertEquals("BLAH", execute("TO_UPPER(name)", contextNoCache));    assertEquals("BLAH", execute("TO_UPPER(name)", contextNoCache));}
public void metron_f9139_0()
{    Map<String, Object> cacheConfig = ImmutableMap.of(CachingStellarProcessor.MAX_CACHE_SIZE_PARAM, -1, CachingStellarProcessor.MAX_TIME_RETAIN_PARAM, 10);    cache = CachingStellarProcessor.createCache(cacheConfig);    assertNull(cache);}
public void metron_f9140_0()
{    Map<String, Object> cacheConfig = ImmutableMap.of(CachingStellarProcessor.MAX_TIME_RETAIN_PARAM, 10);    cache = CachingStellarProcessor.createCache(cacheConfig);    assertNull(cache);}
public void metron_f9141_0()
{    Map<String, Object> cacheConfig = ImmutableMap.of(CachingStellarProcessor.MAX_CACHE_SIZE_PARAM, 10, CachingStellarProcessor.MAX_TIME_RETAIN_PARAM, -2);    cache = CachingStellarProcessor.createCache(cacheConfig);    assertNull(cache);}
public void metron_f9142_0()
{    Map<String, Object> cacheConfig = ImmutableMap.of(CachingStellarProcessor.MAX_CACHE_SIZE_PARAM, 10);    cache = CachingStellarProcessor.createCache(cacheConfig);    assertNull(cache);}
public void metron_f9143_0()
{        Object result = execute("TO_UPPER(name)", contextWithCache);    assertEquals("BLAH", result);    assertEquals(1, cache.stats().requestCount());    assertEquals(1, cache.stats().missCount());    assertEquals(0, cache.stats().hitCount());        fields.put("unrelated_var_1", "true");    fields.put("unrelated_var_2", 22);        result = execute("TO_UPPER(name)", contextWithCache);    assertEquals("BLAH", result);    assertEquals(2, cache.stats().requestCount());    assertEquals(1, cache.stats().missCount());    assertEquals(1, cache.stats().hitCount());}
private Object metron_f9144_0(String expression, Context context)
{    Object result = processor.parse(expression, new MapVariableResolver(fields), StellarFunctions.FUNCTION_RESOLVER(), context);    return result;}
public void metron_f9145_0() throws ParseException
{        JSONParser parser = new JSONParser();    message = (JSONObject) parser.parse(input);        executor = new DefaultStellarStatefulExecutor();    executor.setContext(Context.EMPTY_CONTEXT());    ClasspathFunctionResolver resolver = new ClasspathFunctionResolver();    executor.setFunctionResolver(resolver);}
public void metron_f9146_0()
{    executor.assign("foo", "2", message);        Object var = executor.getState().get("foo");    assertThat(var, instanceOf(Integer.class));    assertThat(var, equalTo(2));}
public void metron_f9147_0()
{    executor.assign("foo", "ip_src_addr", message);        Object var = executor.getState().get("foo");    assertThat(var, instanceOf(String.class));    assertThat(var, equalTo("10.0.0.1"));}
public void metron_f9148_0()
{    executor.assign("two", "2", message);    executor.assign("four", "4", message);    executor.assign("sum", "two + four", message);        Object var = executor.getState().get("sum");    assertEquals(6, var);}
public void metron_f9149_0()
{    executor.assign("two", "2", message);    executor.clearState();        assertThat(executor.getState().containsKey("two"), equalTo(false));}
public void metron_f9150_0()
{    String actual = executor.execute("TO_UPPER('lowercase')", message, String.class);    assertThat(actual, equalTo("LOWERCASE"));}
public void metron_f9151_0()
{    boolean actual = executor.execute("IS_INTEGER(2)", message, Boolean.class);    assertThat(actual, equalTo(true));}
public void metron_f9152_0()
{    executor.execute("2 + 2", message, Boolean.class);}
public void metron_f9153_0()
{    executor.execute("2", message, Double.class);    executor.execute("2", message, Float.class);    executor.execute("2", message, Short.class);    executor.execute("2", message, Long.class);}
public void metron_f9154_0() throws Exception
{        ByteArrayOutputStream bytes = new ByteArrayOutputStream();    new ObjectOutputStream(bytes).writeObject(executor);        new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray())).readObject();}
public void metron_f9155_0() throws Exception
{        Assert.assertTrue(Encodings.BASE32.is(BASE32_FIXTURE));    Assert.assertFalse(Encodings.BASE32.is(STRING_FIXTURE));        Assert.assertTrue(Encodings.BASE32HEX.is(BASE32HEX_FIXTURE));    Assert.assertFalse(Encodings.BASE32HEX.is(STRING_FIXTURE));        Assert.assertTrue(Encodings.BASE64.is(BASE64_FIXTURE));    Assert.assertFalse(Encodings.BASE64.is(STRING_FIXTURE + "\0"));        Assert.assertTrue(Encodings.BINARY.is(BINARY_FIXTURE));    Assert.assertFalse(Encodings.BINARY.is(STRING_FIXTURE));        Assert.assertTrue(Encodings.HEX.is(HEX_FIXTURE));    Assert.assertFalse(Encodings.HEX.is("AAA"));}
public void metron_f9156_0() throws Exception
{    Assert.assertEquals(STRING_FIXTURE, Encodings.BASE32.decode(BASE32_FIXTURE));    Assert.assertEquals(STRING_FIXTURE, Encodings.BASE32HEX.decode(BASE32HEX_FIXTURE));    Assert.assertEquals(STRING_FIXTURE, Encodings.BASE64.decode(BASE64_FIXTURE));    Assert.assertEquals(STRING_FIXTURE, Encodings.BINARY.decode(BINARY_FIXTURE));    Assert.assertEquals(STRING_FIXTURE, Encodings.HEX.decode(HEX_FIXTURE));        Assert.assertNotEquals(STRING_FIXTURE, Encodings.BASE32.decode(STRING_FIXTURE));    Assert.assertNotEquals(STRING_FIXTURE, Encodings.BASE32HEX.decode(STRING_FIXTURE));    Assert.assertNotEquals(STRING_FIXTURE, Encodings.BASE64.decode(STRING_FIXTURE));            Assert.assertEquals(STRING_FIXTURE, Encodings.BINARY.decode(STRING_FIXTURE));    Assert.assertEquals(STRING_FIXTURE, Encodings.HEX.decode(STRING_FIXTURE));}
public void metron_f9157_0() throws Exception
{    Assert.assertEquals(STRING_FIXTURE, Encodings.BASE32.decode(BASE32_FIXTURE, true));    Assert.assertEquals(STRING_FIXTURE, Encodings.BASE32HEX.decode(BASE32HEX_FIXTURE, true));    Assert.assertEquals(STRING_FIXTURE, Encodings.BASE64.decode(BASE64_FIXTURE, true));    Assert.assertEquals(STRING_FIXTURE, Encodings.BINARY.decode(BINARY_FIXTURE, true));    Assert.assertEquals(STRING_FIXTURE, Encodings.HEX.decode(HEX_FIXTURE, true));        Assert.assertEquals(STRING_FIXTURE, Encodings.BASE32.decode(STRING_FIXTURE, true));    Assert.assertEquals(STRING_FIXTURE, Encodings.BASE32HEX.decode(STRING_FIXTURE, true));        Assert.assertNotEquals(STRING_FIXTURE, Encodings.BASE64.decode(STRING_FIXTURE, true));        Assert.assertEquals(STRING_FIXTURE + "\0", Encodings.BASE64.decode(STRING_FIXTURE + "\0", true));    Assert.assertEquals(STRING_FIXTURE, Encodings.BINARY.decode(STRING_FIXTURE, true));    Assert.assertEquals(STRING_FIXTURE, Encodings.HEX.decode(STRING_FIXTURE, true));}
public void metron_f9158_0() throws Exception
{    Assert.assertEquals(BASE32_FIXTURE, Encodings.BASE32.encode(STRING_FIXTURE));    Assert.assertEquals(BASE32HEX_FIXTURE, Encodings.BASE32HEX.encode(STRING_FIXTURE));    Assert.assertEquals(BASE64_FIXTURE, Encodings.BASE64.encode(STRING_FIXTURE));    Assert.assertEquals(BINARY_FIXTURE, Encodings.BINARY.encode(STRING_FIXTURE));    Assert.assertEquals(HEX_FIXTURE, Encodings.HEX.encode(STRING_FIXTURE));}
public void metron_f9159_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Double> r = mock(Token.class);    when(r.getValue()).thenReturn(2D);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), p);    assertTrue(evaluated.getValue() instanceof Double);    assertEquals(3.0D, evaluated.getValue());}
public void metron_f9160_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), p);    assertTrue(evaluated.getValue() instanceof Integer);    assertEquals(3, evaluated.getValue());}
public void metron_f9161_0() throws Exception
{    Token<Float> l = mock(Token.class);    when(l.getValue()).thenReturn(1F);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), p);    assertTrue(evaluated.getValue() instanceof Float);    assertEquals(3F, evaluated.getValue());}
public void metron_f9162_0() throws Exception
{    Token<Long> l = mock(Token.class);    when(l.getValue()).thenReturn(1L);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), p);    assertTrue(evaluated.getValue() instanceof Long);    assertEquals(3L, evaluated.getValue());}
public void metron_f9163_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Double> r = mock(Token.class);    when(r.getValue()).thenReturn(2D);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.multiplication(null), p);    assertTrue(evaluated.getValue() instanceof Double);    assertEquals(2.0D, evaluated.getValue());}
public void metron_f9164_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.multiplication(null), p);    assertTrue(evaluated.getValue() instanceof Integer);    assertEquals(2, evaluated.getValue());}
public void metron_f9165_0() throws Exception
{    Token<Float> l = mock(Token.class);    when(l.getValue()).thenReturn(1F);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.multiplication(null), p);    assertTrue(evaluated.getValue() instanceof Float);    assertEquals(2F, evaluated.getValue());}
public void metron_f9166_0() throws Exception
{    Token<Long> l = mock(Token.class);    when(l.getValue()).thenReturn(1L);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.multiplication(null), p);    assertTrue(evaluated.getValue() instanceof Long);    assertEquals(2L, evaluated.getValue());}
public void metron_f9167_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Double> r = mock(Token.class);    when(r.getValue()).thenReturn(2D);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.subtraction(null), p);    assertTrue(evaluated.getValue() instanceof Double);    assertEquals(-1.0D, evaluated.getValue());}
public void metron_f9168_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.subtraction(null), p);    assertTrue(evaluated.getValue() instanceof Integer);    assertEquals(-1, evaluated.getValue());}
public void metron_f9169_0() throws Exception
{    Token<Float> l = mock(Token.class);    when(l.getValue()).thenReturn(1F);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.subtraction(null), p);    assertTrue(evaluated.getValue() instanceof Float);    assertEquals(-1F, evaluated.getValue());}
public void metron_f9170_0() throws Exception
{    Token<Long> l = mock(Token.class);    when(l.getValue()).thenReturn(1L);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.subtraction(null), p);    assertTrue(evaluated.getValue() instanceof Long);    assertEquals(-1L, evaluated.getValue());}
public void metron_f9171_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Double> r = mock(Token.class);    when(r.getValue()).thenReturn(2D);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), p);    assertTrue(evaluated.getValue() instanceof Double);    assertEquals(1 / 2D, evaluated.getValue());}
public void metron_f9172_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), p);    assertTrue(evaluated.getValue() instanceof Integer);    assertEquals(1 / 2, evaluated.getValue());}
public void metron_f9173_0() throws Exception
{    Token<Float> l = mock(Token.class);    when(l.getValue()).thenReturn(1F);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), p);    assertTrue(evaluated.getValue() instanceof Float);    assertEquals(0.5F, evaluated.getValue());}
public void metron_f9174_0() throws Exception
{    Token<Long> l = mock(Token.class);    when(l.getValue()).thenReturn(1L);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), p);    assertTrue(evaluated.getValue() instanceof Long);    assertEquals(0L, evaluated.getValue());}
public void metron_f9175_0() throws Exception
{    evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), null);}
public void metron_f9176_0() throws Exception
{    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(null, mock(Token.class));    evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), p);}
public void metron_f9177_0() throws Exception
{    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(mock(Token.class), null);    evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), p);}
public void metron_f9178_0() throws Exception
{    Token<Short> l = mock(Token.class);    when(l.getValue()).thenReturn((short) 2);    Token<Short> r = mock(Token.class);    when(r.getValue()).thenReturn((short) 3);    Token<? extends Number> evaluated0 = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), Pair.of(l, r));    Token<? extends Number> evaluated1 = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.subtraction(null), Pair.of(l, r));    Token<? extends Number> evaluated2 = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.multiplication(null), Pair.of(l, r));    Token<? extends Number> evaluated3 = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), Pair.of(l, r));    assertTrue(evaluated0.getValue() instanceof Integer);    assertEquals(5, evaluated0.getValue());    assertTrue(evaluated1.getValue() instanceof Integer);    assertEquals(-1, evaluated1.getValue());    assertTrue(evaluated2.getValue() instanceof Integer);    assertEquals(6, evaluated2.getValue());    assertTrue(evaluated3.getValue() instanceof Integer);    assertEquals(0, evaluated3.getValue());}
public void metron_f9179_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(null);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(2);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), p);    assertTrue(evaluated.getValue() instanceof Integer);    assertEquals(2, evaluated.getValue());}
public void metron_f9180_0() throws Exception
{    Token<Integer> l = mock(Token.class);    when(l.getValue()).thenReturn(1);    Token<Integer> r = mock(Token.class);    when(r.getValue()).thenReturn(null);    Pair<Token<? extends Number>, Token<? extends Number>> p = Pair.of(l, r);    Token<? extends Number> evaluated = evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), p);    assertTrue(evaluated.getValue() instanceof Integer);    assertEquals(1, evaluated.getValue());}
public void metron_f9181_0() throws Exception
{    Token<Integer> integer = mock(Token.class);    when(integer.getValue()).thenReturn(1);    Token<Long> lng = mock(Token.class);    when(lng.getValue()).thenReturn(1L);    Token<Double> dbl = mock(Token.class);    when(dbl.getValue()).thenReturn(1.0D);    Token<Float> flt = mock(Token.class);    when(flt.getValue()).thenReturn(1.0F);    Map<Pair<Token<? extends Number>, Token<? extends Number>>, Class<? extends Number>> expectedReturnTypeMappings = new HashMap<Pair<Token<? extends Number>, Token<? extends Number>>, Class<? extends Number>>() {        {            put(Pair.of(flt, lng), Float.class);            put(Pair.of(flt, dbl), Double.class);            put(Pair.of(flt, flt), Float.class);            put(Pair.of(flt, integer), Float.class);            put(Pair.of(lng, lng), Long.class);            put(Pair.of(lng, dbl), Double.class);            put(Pair.of(lng, flt), Float.class);            put(Pair.of(lng, integer), Long.class);            put(Pair.of(dbl, lng), Double.class);            put(Pair.of(dbl, dbl), Double.class);            put(Pair.of(dbl, flt), Double.class);            put(Pair.of(dbl, integer), Double.class);            put(Pair.of(integer, lng), Long.class);            put(Pair.of(integer, dbl), Double.class);            put(Pair.of(integer, flt), Float.class);            put(Pair.of(integer, integer), Integer.class);        }    };    expectedReturnTypeMappings.forEach((pair, expectedClass) -> {        assertTrue(evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.addition(null), pair).getValue().getClass() == expectedClass);        assertTrue(evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.division(null), pair).getValue().getClass() == expectedClass);        assertTrue(evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.subtraction(null), pair).getValue().getClass() == expectedClass);        assertTrue(evaluator.evaluate(ArithmeticEvaluator.ArithmeticEvaluatorFunctions.multiplication(null), pair).getValue().getClass() == expectedClass);    });}
public void metron_f9182_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(1D);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    Token<Boolean> evaluated = evaluator.evaluate(left, right, op, null);    assertTrue(evaluated.getValue());}
public void metron_f9183_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(1D);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.NEQ()).thenReturn(mock(TerminalNode.class));    Token<Boolean> evaluated = evaluator.evaluate(left, right, op, null);    assertFalse(evaluated.getValue());}
public void metron_f9184_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(0D);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.LTE()).thenReturn(mock(TerminalNode.class));    Token<Boolean> evaluated = evaluator.evaluate(left, right, op, null);    assertTrue(evaluated.getValue());}
public void metron_f9185_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage("Unsupported operations. The following expression is invalid: ");    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(0D);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    evaluator.evaluate(left, right, op, null);}
public void metron_f9186_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage("Unsupported operations. The following expression is invalid: ");    Token<String> left = mock(Token.class);    when(left.getValue()).thenReturn("adsf");    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.LTE()).thenReturn(mock(TerminalNode.class));    evaluator.evaluate(left, right, op, null);}
public void metron_f9187_0() throws Exception
{    evaluator = new ComparisonOperatorsEvaluator();}
public void metron_f9188_0() throws Exception
{    Token<String> left = mock(Token.class);    when(left.getValue()).thenReturn("b");    Token<String> right = mock(Token.class);    when(right.getValue()).thenReturn("a");    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    exception.expect(ParseException.class);    exception.expectMessage("Unsupported operator: " + op);    evaluator.evaluate(left, right, op);}
public void metron_f9189_0() throws Exception
{    Token<Long> left = mock(Token.class);    when(left.getValue()).thenReturn(1L);    Token<Long> right = mock(Token.class);    when(right.getValue()).thenReturn(0L);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    exception.expect(ParseException.class);    exception.expectMessage("Unsupported operator: " + op);    evaluator.evaluate(left, right, op);}
public void metron_f9190_0() throws Exception
{    Token<Long> left = mock(Token.class);    Token<Long> right = mock(Token.class);    when(right.getValue()).thenReturn(1L);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.LT()).thenReturn(mock(TerminalNode.class));    assertFalse(evaluator.evaluate(left, right, op));}
public void metron_f9191_0() throws Exception
{    Token<Long> left = mock(Token.class);    when(left.getValue()).thenReturn(1L);    Token<Long> right = mock(Token.class);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.LT()).thenReturn(mock(TerminalNode.class));    assertFalse(evaluator.evaluate(left, right, op));}
public void metron_f9192_0() throws Exception
{    Token<Long> left = mock(Token.class);    Token<Long> right = mock(Token.class);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.LT()).thenReturn(mock(TerminalNode.class));    assertFalse(evaluator.evaluate(left, right, op));}
public void metron_f9193_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage("Unsupported operations. The following expression is invalid: ");    Token<Serializable> left = mock(Token.class);    when(left.getValue()).thenReturn(mock(Serializable.class));    Token<Serializable> right = mock(Token.class);    when(right.getValue()).thenReturn(mock(Serializable.class));    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.LT()).thenReturn(mock(TerminalNode.class));    evaluator.evaluate(left, right, op);}
public void metron_f9194_0() throws Exception
{    Token<Long> left = mock(Token.class);    when(left.getValue()).thenReturn(0L);    Token<Long> right = mock(Token.class);    when(right.getValue()).thenReturn(1L);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }}
public void metron_f9195_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(0D);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }}
public void metron_f9196_0() throws Exception
{    Token<Float> left = mock(Token.class);    when(left.getValue()).thenReturn(0F);    Token<Float> right = mock(Token.class);    when(right.getValue()).thenReturn(1F);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }}
public void metron_f9197_0() throws Exception
{    Token<Integer> left = mock(Token.class);    when(left.getValue()).thenReturn(0);    Token<Integer> right = mock(Token.class);    when(right.getValue()).thenReturn(1);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }}
public void metron_f9198_0() throws Exception
{    Token<Long> left = mock(Token.class);    when(left.getValue()).thenReturn(1L);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1.0000001D);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertTrue(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertFalse(evaluator.evaluate(left, right, op));    }}
public void metron_f9199_0() throws Exception
{    final double leftValue = 1.0000001D;    final float rightValue = 1.0000001F;    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(leftValue);    Token<Float> right = mock(Token.class);    when(right.getValue()).thenReturn(rightValue);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue < rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue <= rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue > rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue >= rightValue, evaluator.evaluate(left, right, op));    }}
public void metron_f9200_0() throws Exception
{    final int leftValue = 1;    final float rightValue = 1.0000001F;    Token<Integer> left = mock(Token.class);    when(left.getValue()).thenReturn(leftValue);    Token<Float> right = mock(Token.class);    when(right.getValue()).thenReturn(rightValue);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue < rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue <= rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue > rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue >= rightValue, evaluator.evaluate(left, right, op));    }}
public void metron_f9201_0() throws Exception
{    final int leftValue = 1;    final float rightValue = 1.00000001F;    Token<Integer> left = mock(Token.class);    when(left.getValue()).thenReturn(leftValue);    Token<Float> right = mock(Token.class);    when(right.getValue()).thenReturn(rightValue);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue < rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue <= rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue > rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue >= rightValue, evaluator.evaluate(left, right, op));    }}
public void metron_f9202_0() throws Exception
{    final int leftValue = 1;    final long rightValue = 3L;    Token<Integer> left = mock(Token.class);    when(left.getValue()).thenReturn(leftValue);    Token<Long> right = mock(Token.class);    when(right.getValue()).thenReturn(rightValue);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue < rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue <= rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue > rightValue, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue >= rightValue, evaluator.evaluate(left, right, op));    }}
public void metron_f9203_0() throws Exception
{    final String leftValue = "a";    final String rightValue = "b";    Token<String> left = mock(Token.class);    when(left.getValue()).thenReturn(leftValue);    Token<String> right = mock(Token.class);    when(right.getValue()).thenReturn(rightValue);    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue.compareTo(rightValue) < 0, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.LTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue.compareTo(rightValue) <= 0, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GT()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue.compareTo(rightValue) > 0, evaluator.evaluate(left, right, op));    }    {        StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);        when(op.GTE()).thenReturn(mock(TerminalNode.class));        assertEquals(leftValue.compareTo(rightValue) >= 0, evaluator.evaluate(left, right, op));    }}
public void metron_f9204_0() throws Exception
{    evaluator = new DoubleLiteralEvaluator();    context = mock(StellarParser.DoubleLiteralContext.class);}
public void metron_f9205_0() throws Exception
{    when(context.getText()).thenReturn("100D");    Token<? extends Number> evaluated = evaluator.evaluate(context, null);    assertEquals(new Token<>(100D, Double.class, null), evaluated);    verify(context).getText();    verifyNoMoreInteractions(context);}
public void metron_f9206_0() throws Exception
{    exception.expect(NumberFormatException.class);    when(context.getText()).thenReturn("");    evaluator.evaluate(context, null);}
public void metron_f9207_0() throws Exception
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("Cannot evaluate a context that is null.");    evaluator.evaluate(null, null);}
public void metron_f9208_0() throws Exception
{    evaluator = new EqualityOperatorsEvaluator();}
public void metron_f9209_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(null);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(null);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    boolean evaluated = evaluator.evaluate(left, right, op);    assertTrue(evaluated);}
public void metron_f9210_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(null);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    boolean evaluated = evaluator.evaluate(left, right, op);    assertFalse(evaluated);}
public void metron_f9211_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(1D);    Token<Long> right = mock(Token.class);    when(right.getValue()).thenReturn(null);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    boolean evaluated = evaluator.evaluate(left, right, op);    assertFalse(evaluated);}
public void metron_f9212_0() throws Exception
{    Token<Long> left = mock(Token.class);    when(left.getValue()).thenReturn(1L);    Token<Long> right = mock(Token.class);    when(right.getValue()).thenReturn(1L);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    assertTrue(evaluator.evaluate(left, right, op));}
public void metron_f9213_0() throws Exception
{    Token<Double> left = mock(Token.class);    when(left.getValue()).thenReturn(1D);    Token<Double> right = mock(Token.class);    when(right.getValue()).thenReturn(1D);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    assertTrue(evaluator.evaluate(left, right, op));}
public void metron_f9214_0() throws Exception
{    Token<Float> left = mock(Token.class);    when(left.getValue()).thenReturn(1F);    Token<Float> right = mock(Token.class);    when(right.getValue()).thenReturn(1F);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    assertTrue(evaluator.evaluate(left, right, op));}
public void metron_f9215_0() throws Exception
{    Token<Integer> left = mock(Token.class);    when(left.getValue()).thenReturn(1);    Token<Integer> right = mock(Token.class);    when(right.getValue()).thenReturn(1);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    assertTrue(evaluator.evaluate(left, right, op));}
public void metron_f9216_0() throws Exception
{    Token<String> left = mock(Token.class);    when(left.getValue()).thenReturn("1");    Token<String> right = mock(Token.class);    when(right.getValue()).thenReturn("1");    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    assertTrue(evaluator.evaluate(left, right, op));}
public void metron_f9217_0() throws Exception
{    Token<String> left = mock(Token.class);    when(left.getValue()).thenReturn("1");    Token<Long> right = mock(Token.class);    when(right.getValue()).thenReturn(1L);    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    assertFalse(evaluator.evaluate(left, right, op));}
public void metron_f9218_0() throws Exception
{    Token<Long> left = mock(Token.class);    when(left.getValue()).thenReturn(1L);    Token<String> right = mock(Token.class);    when(right.getValue()).thenReturn("1");    StellarParser.ComparisonOpContext op = mock(StellarParser.ComparisonOpContext.class);    when(op.EQ()).thenReturn(mock(TerminalNode.class));    assertFalse(evaluator.evaluate(left, right, op));}
public void metron_f9219_0() throws Exception
{    evaluator = new FloatLiteralEvaluator();    context = mock(StellarParser.FloatLiteralContext.class);}
public void metron_f9220_0() throws Exception
{    when(context.getText()).thenReturn("100f");    Token<? extends Number> evaluated = evaluator.evaluate(context, null);    assertEquals(new Token<>(100f, Float.class, null), evaluated);    verify(context).getText();    verifyNoMoreInteractions(context);}
public void metron_f9221_0() throws Exception
{    exception.expect(NumberFormatException.class);    when(context.getText()).thenReturn("");    evaluator.evaluate(context, null);}
public void metron_f9222_0() throws Exception
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("Cannot evaluate a context that is null.");    evaluator.evaluate(null, null);}
public void metron_f9223_0() throws Exception
{    evaluator = new IntLiteralEvaluator();    context = mock(StellarParser.IntLiteralContext.class);}
public void metron_f9224_0() throws Exception
{    when(context.getText()).thenReturn("100");    Token<? extends Number> evaluated = evaluator.evaluate(context, null);    assertEquals(new Token<>(100, Integer.class, null), evaluated);    verify(context).getText();    verifyNoMoreInteractions(context);}
public void metron_f9225_0() throws Exception
{    exception.expect(NumberFormatException.class);    when(context.getText()).thenReturn("");    evaluator.evaluate(context, null);}
public void metron_f9226_0() throws Exception
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("Cannot evaluate a context that is null.");    evaluator.evaluate(null, null);}
public void metron_f9227_0() throws Exception
{    evaluator = new LongLiteralEvaluator();    context = mock(StellarParser.LongLiteralContext.class);}
public void metron_f9228_0() throws Exception
{    when(context.getText()).thenReturn("100L");    Token<? extends Number> evaluated = evaluator.evaluate(context, null);    assertEquals(new Token<>(100L, Long.class, null), evaluated);    verify(context).getText();    verifyNoMoreInteractions(context);}
public void metron_f9229_0() throws Exception
{    exception.expect(ParseException.class);    exception.expectMessage("Invalid format for long. Failed trying to parse a long with the following value: ");    when(context.getText()).thenReturn("");    evaluator.evaluate(context, null);}
public void metron_f9230_0() throws Exception
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("Cannot evaluate a context that is null.");    evaluator.evaluate(null, null);}
public void metron_f9231_0() throws Exception
{    intLiteralContextNumberEvaluator = mock(IntLiteralEvaluator.class);    doubleLiteralContextNumberEvaluator = mock(DoubleLiteralEvaluator.class);    floatLiteralContextNumberEvaluator = mock(FloatLiteralEvaluator.class);    longLiteralContextNumberEvaluator = mock(LongLiteralEvaluator.class);    instanceMap = new HashMap<Class<? extends StellarParser.Arithmetic_operandsContext>, NumberEvaluator>() {        {            put(mock(StellarParser.IntLiteralContext.class).getClass(), intLiteralContextNumberEvaluator);            put(mock(StellarParser.DoubleLiteralContext.class).getClass(), doubleLiteralContextNumberEvaluator);            put(mock(StellarParser.FloatLiteralContext.class).getClass(), floatLiteralContextNumberEvaluator);            put(mock(StellarParser.LongLiteralContext.class).getClass(), longLiteralContextNumberEvaluator);        }    };}
public void metron_f9232_0() throws Exception
{    StellarParser.IntLiteralContext context = mock(StellarParser.IntLiteralContext.class);    NumberLiteralEvaluator.INSTANCE.evaluate(context, instanceMap, null);    verify(intLiteralContextNumberEvaluator).evaluate(context, null);    verifyZeroInteractions(doubleLiteralContextNumberEvaluator, floatLiteralContextNumberEvaluator, longLiteralContextNumberEvaluator);}
public void metron_f9233_0() throws Exception
{    StellarParser.DoubleLiteralContext context = mock(StellarParser.DoubleLiteralContext.class);    NumberLiteralEvaluator.INSTANCE.evaluate(context, instanceMap, null);    verify(doubleLiteralContextNumberEvaluator).evaluate(context, null);    verifyZeroInteractions(intLiteralContextNumberEvaluator, floatLiteralContextNumberEvaluator, longLiteralContextNumberEvaluator);}
public void metron_f9234_0() throws Exception
{    StellarParser.FloatLiteralContext context = mock(StellarParser.FloatLiteralContext.class);    NumberLiteralEvaluator.INSTANCE.evaluate(context, instanceMap, null);    verify(floatLiteralContextNumberEvaluator).evaluate(context, null);    verifyZeroInteractions(doubleLiteralContextNumberEvaluator, intLiteralContextNumberEvaluator, longLiteralContextNumberEvaluator);}
public void metron_f9235_0() throws Exception
{    StellarParser.LongLiteralContext context = mock(StellarParser.LongLiteralContext.class);    NumberLiteralEvaluator.INSTANCE.evaluate(context, instanceMap, null);    verify(longLiteralContextNumberEvaluator).evaluate(context, null);    verifyZeroInteractions(doubleLiteralContextNumberEvaluator, floatLiteralContextNumberEvaluator, intLiteralContextNumberEvaluator);}
public void metron_f9236_0() throws Exception
{    StellarParser.VariableContext context = mock(StellarParser.VariableContext.class);    exception.expect(ParseException.class);    exception.expectMessage("Does not support evaluation for type " + context.getClass());    NumberLiteralEvaluator.INSTANCE.evaluate(context, instanceMap, null);    verifyZeroInteractions(longLiteralContextNumberEvaluator, doubleLiteralContextNumberEvaluator, floatLiteralContextNumberEvaluator, intLiteralContextNumberEvaluator);}
public void metron_f9237_0()
{    runWithArguments("IN_SUBNET", ImmutableList.of("192.168.0.1", "192.168.0.0/24"), true);}
public void metron_f9238_0()
{    runWithArguments("IN_SUBNET", ImmutableList.of("192.168.1.1", "192.168.0.0/24"), false);}
public void metron_f9239_0()
{    runWithArguments("IN_SUBNET", ImmutableList.of("192.168.1.1", "192.168.0.0/24", "192.168.1.0/24"), true);}
public void metron_f9240_0()
{    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "www.google.co.uk", "google.co.uk");    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "www.google.com", "google.com");    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "com", "com");}
public void metron_f9241_0()
{    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "com.com", "com.com");    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "net.net", "net.net");    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "co.uk.co.uk", "uk.co.uk");    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "www.subdomain.com.com", "com.com");}
public void metron_f9242_0()
{    runWithArguments("DOMAIN_REMOVE_SUBDOMAINS", "www.subdomain.google.gmail", "google.gmail");}
public void metron_f9243_0()
{    runWithArguments("DOMAIN_TO_TLD", "www.google.co.uk", "co.uk");    runWithArguments("DOMAIN_TO_TLD", "www.google.com", "com");    runWithArguments("DOMAIN_TO_TLD", "com", "com");}
public void metron_f9244_0()
{    runWithArguments("DOMAIN_TO_TLD", "com.com", "com");    runWithArguments("DOMAIN_TO_TLD", "net.net", "net");    runWithArguments("DOMAIN_TO_TLD", "co.uk.co.uk", "co.uk");    runWithArguments("DOMAIN_TO_TLD", "www.subdomain.com.com", "com");}
public void metron_f9245_0()
{    runWithArguments("DOMAIN_TO_TLD", "www.subdomain.google.gmail", "gmail");}
public void metron_f9246_0()
{    runWithArguments("DOMAIN_REMOVE_TLD", "google.com", "google");    runWithArguments("DOMAIN_REMOVE_TLD", "www.google.co.uk", "www.google");    runWithArguments("DOMAIN_REMOVE_TLD", "www.google.com", "www.google");    runWithArguments("DOMAIN_REMOVE_TLD", "com", "");}
public void metron_f9247_0()
{    runWithArguments("DOMAIN_REMOVE_TLD", "com.com", "com");    runWithArguments("DOMAIN_REMOVE_TLD", "net.net", "net");    runWithArguments("DOMAIN_REMOVE_TLD", "co.uk.co.uk", "co.uk");    runWithArguments("DOMAIN_REMOVE_TLD", "www.subdomain.com.com", "www.subdomain.com");}
public void metron_f9248_0()
{    runWithArguments("DOMAIN_REMOVE_TLD", "www.subdomain.google.gmail", "www.subdomain.google");}
public void metron_f9249_0()
{    runWithArguments("URL_TO_PORT", "http://www.google.com/foo/bar", 80);    runWithArguments("URL_TO_PORT", "https://www.google.com/foo/bar", 443);    runWithArguments("URL_TO_PORT", "http://www.google.com:7979/foo/bar", 7979);}
public void metron_f9250_0()
{    runWithArguments("URL_TO_PORT", "http://www.google.gmail/foo/bar", 80);}
public void metron_f9251_0()
{    runWithArguments("URL_TO_HOST", "http://www.google.com/foo/bar", "www.google.com");    runWithArguments("URL_TO_HOST", "https://www.google.com/foo/bar", "www.google.com");    runWithArguments("URL_TO_HOST", "http://www.google.com:7979/foo/bar", "www.google.com");    runWithArguments("URL_TO_HOST", "http://localhost:8080/a", "localhost");}
public void metron_f9252_0()
{    runWithArguments("URL_TO_HOST", "http://www.google.gmail/foo/bar", "www.google.gmail");}
public void metron_f9253_0()
{    runWithArguments("URL_TO_PROTOCOL", "http://www.google.com/foo/bar", "http");    runWithArguments("URL_TO_PROTOCOL", "https://www.google.com/foo/bar", "https");}
public void metron_f9254_0()
{    runWithArguments("URL_TO_PROTOCOL", "http://www.google.gmail/foo/bar", "http");}
public void metron_f9255_0()
{    runWithArguments("URL_TO_PATH", "http://www.google.com/foo/bar", "/foo/bar");    runWithArguments("URL_TO_PATH", "https://www.google.com/foo/bar", "/foo/bar");}
public void metron_f9256_0()
{    runWithArguments("URL_TO_PATH", "http://www.google.gmail/foo/bar", "/foo/bar");}
public void metron_f9257_0() throws Exception
{    String[] validZHostArg = new String[] { "-z", "localhost:8888" };    String[] validZHostArgNoPort = new String[] { "-z", "localhost" };    String[] validZIPArgNoPort = new String[] { "-z", "10.10.10.3" };    String[] validZHostArgList = new String[] { "-z", "localhost:8888,localhost:2181,localhost" };    String[] validZIPArg = new String[] { "-z", "10.10.10.3:9999" };    String[] invalidZNameArg = new String[] { "-z", "!!!@!!@!:8882" };    String[] invalidZIPArg = new String[] { "-z", "11111.22222.10.3:3332" };    String[] invalidZMissingNameArg = new String[] { "-z", ":8882" };    String[] invalidZZeroPortArg = new String[] { "-z", "youtube.com:0" };    String[] invalidZHugePortArg = new String[] { "-z", "youtube.com:75565" };    String existingFileName = "./target/existsFile";    String nonExistentFile = "./target/doesNotExist";    String[] validVFileArg = new String[] { "-v", existingFileName };    String[] validIrcFileArg = new String[] { "-irc", existingFileName };    String[] validPFileArg = new String[] { "-p", existingFileName };    String[] invalidVFileArg = new String[] { "-v", nonExistentFile };    String[] invalidIrcFileArg = new String[] { "-irc", nonExistentFile };    String[] invalidPFileArg = new String[] { "-p", nonExistentFile };    File existingFile = new File(existingFileName);    if (!existingFile.exists()) {        existingFile.createNewFile();    }    Options options = new Options();    options.addOption("z", "zookeeper", true, "Zookeeper URL");    options.addOption("v", "variables", true, "File containing a JSON Map of variables");    options.addOption("irc", "inputrc", true, "File containing the inputrc if not the default ~/.inputrc");    options.addOption("na", "no_ansi", false, "Make the input prompt not use ANSI colors.");    options.addOption("h", "help", false, "Print help");    options.addOption("p", "properties", true, "File containing Stellar properties");    CommandLineParser parser = new PosixParser();        CommandLine commandLine = parser.parse(options, validZHostArg);    StellarShellOptionsValidator.validateOptions(commandLine);    commandLine = parser.parse(options, validZIPArg);    StellarShellOptionsValidator.validateOptions(commandLine);    commandLine = parser.parse(options, validVFileArg);    StellarShellOptionsValidator.validateOptions(commandLine);    commandLine = parser.parse(options, validIrcFileArg);    StellarShellOptionsValidator.validateOptions(commandLine);    commandLine = parser.parse(options, validPFileArg);    StellarShellOptionsValidator.validateOptions(commandLine);    commandLine = parser.parse(options, validZHostArgNoPort);    StellarShellOptionsValidator.validateOptions(commandLine);    commandLine = parser.parse(options, validZHostArgList);    StellarShellOptionsValidator.validateOptions(commandLine);    commandLine = parser.parse(options, validZIPArgNoPort);    StellarShellOptionsValidator.validateOptions(commandLine);        boolean thrown = false;    try {        commandLine = parser.parse(options, invalidZNameArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for providing invalid host name ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidZIPArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for providing invalid ip address ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidZMissingNameArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for only providing port ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidZZeroPortArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for 0 port ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidZHugePortArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for port out of range ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidVFileArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for passing non-existant file to -v ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidVFileArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for passing non-existant file to -v ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidIrcFileArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for passing non-existant file to -irc ", thrown);    thrown = false;    try {        commandLine = parser.parse(options, invalidPFileArg);        StellarShellOptionsValidator.validateOptions(commandLine);    } catch (IllegalArgumentException e) {        thrown = true;    }    Assert.assertTrue("Did not catch failure for passing non-existant file to -p ", thrown);    thrown = false;}
public void metron_f9258_0() throws Exception
{    out = new ByteArrayOutputStream();    err = new ByteArrayOutputStream();        System.setOut(new PrintStream(out, false, StandardCharsets.UTF_8.name()));    System.setErr(new PrintStream(err, false, StandardCharsets.UTF_8.name()));    String[] args = new String[0];    stellarShell = new StellarShell(args);}
public void metron_f9259_0()
{    System.setOut(null);    System.setErr(null);}
private String metron_f9260_0()
{    return out.toString().replace(System.lineSeparator(), "");}
private String metron_f9261_0()
{    return out.toString();}
private String metron_f9262_0()
{    return err.toString().replace(System.lineSeparator(), "");}
private ConsoleOperation metron_f9263_0(String buffer)
{    return new ConsoleOperation(ControlOperator.APPEND_OUT, buffer);}
public void metron_f9264_0() throws Exception
{    stellarShell.execute(createOp("2 + 2"));    assertEquals("4", stdout());}
public void metron_f9265_0() throws Exception
{    stellarShell.execute(createOp("SPLIT('foo\\\\bar', '\\\\')"));    assertEquals("[foo, bar]", stdout());}
public void metron_f9266_0() throws Exception
{    stellarShell.execute(createOp("[1,2,3,4,5]"));    assertEquals("[1, 2, 3, 4, 5]", stdout());}
public void metron_f9267_0() throws Exception
{    stellarShell.execute(createOp("{ 'foo':2, 'key':'val' }"));    assertEquals("{foo=2, key=val}", stdout());}
public void metron_f9268_0() throws Exception
{    stellarShell.execute(createOp("2 + "));    final String expected = "[!] Unable to parse: 2 + ";    assertTrue(stdout().startsWith(expected));}
public void metron_f9269_0() throws Exception
{    stellarShell.execute(createOp("x"));    assertEquals("", stdout());}
public void metron_f9270_0() throws Exception
{    stellarShell.execute(createOp("quit"));        assertFalse(stellarShell.getConsole().isRunning());}
public void metron_f9271_0() throws Exception
{    StellarShell.main(new String[0]);        assertTrue(stdoutWithNewlines().contains(StellarShell.WELCOME));}
public void metron_f9272_0() throws Exception
{        final String buffer = "TO_";        int cursor = buffer.length();        AeshContext context = new DefaultAeshContext();    CompleteOperation op = new CompleteOperation(context, buffer, cursor);    stellarShell.complete(op);        List<String> candidates = op.getFormattedCompletionCandidates();    assertTrue(candidates.size() > 0);        for (String candidate : candidates) {        String completion = buffer + candidate;                assertEquals("(", completion.substring(completion.length() - 1));                String function = completion.substring(0, completion.length() - 1);        Iterable<String> allFunctions = stellarShell.getExecutor().getFunctionResolver().getFunctions();        String definedFunction = Iterables.find(allFunctions, (fn) -> fn.equals(function));        assertEquals(function, definedFunction);    }}
public void metron_f9273_0()
{    completer = new DefaultStellarAutoCompleter();}
public void metron_f9274_0()
{        completer.addCandidateFunction("FREUD");    completer.addCandidateFunction("FRIEND");    completer.addCandidateFunction("FOE");        Iterable<String> result = completer.autoComplete("FR");        List<String> completes = Lists.newArrayList(result);    assertEquals(2, completes.size());        assertThat(completes, hasItem("FREUD("));    assertThat(completes, hasItem("FRIEND("));}
public void metron_f9275_0()
{        completer.addCandidateFunction("FREUD");    completer.addCandidateFunction("FRIEND");    completer.addCandidateFunction("FOE");        Iterable<String> result = completer.autoComplete("G");        List<String> completes = Lists.newArrayList(result);    assertEquals(0, completes.size());}
public void metron_f9276_0()
{        completer.addCandidateVariable("very");    completer.addCandidateVariable("vast");    completer.addCandidateVariable("vat");        Iterable<String> result = completer.autoComplete("va");        List<String> completes = Lists.newArrayList(result);    assertEquals(2, completes.size());    assertThat(completes, hasItem("vast"));    assertThat(completes, hasItem("vat"));}
public void metron_f9277_0()
{        completer.addCandidateVariable("very");    completer.addCandidateVariable("vast");    completer.addCandidateVariable("vat");        Iterable<String> result = completer.autoComplete("x");        List<String> completes = Lists.newArrayList(result);    assertEquals(0, completes.size());}
public void metron_f9278_0()
{        completer.addCandidateFunction("FREUD");    completer.addCandidateFunction("FRIEND");    completer.addCandidateFunction("FOE");        Iterable<String> result = completer.autoComplete("?FR");        List<String> completes = Lists.newArrayList(result);    assertEquals(2, completes.size());        assertThat(completes, hasItem("?FREUD"));    assertThat(completes, hasItem("?FRIEND"));}
public void metron_f9279_0()
{        completer.addCandidateFunction("FREUD");    completer.addCandidateFunction("FRIEND");    completer.addCandidateFunction("FOE");        Iterable<String> result = completer.autoComplete("?G");        List<String> completes = Lists.newArrayList(result);    assertEquals(0, completes.size());}
public void metron_f9280_0()
{        completer.addCandidateFunction("%vars");    completer.addCandidateFunction("%vast");    completer.addCandidateFunction("%verbotten");        Iterable<String> result = completer.autoComplete("%va");        List<String> completes = Lists.newArrayList(result);    assertEquals(2, completes.size());        assertThat(completes, hasItem("%vars"));    assertThat(completes, hasItem("%vast"));}
public void metron_f9281_0()
{        completer.addCandidateFunction("%vars");    completer.addCandidateFunction("%vast");    completer.addCandidateFunction("%verbotten");        Iterable<String> result = completer.autoComplete("%xy");        List<String> completes = Lists.newArrayList(result);    assertEquals(0, completes.size());}
public void metron_f9282_0() throws Exception
{    Properties props = new Properties();    executor = new DefaultStellarShellExecutor(props, Optional.empty());    executor.init();}
public void metron_f9283_0()
{        {        StellarResult result = executor.execute("x := 2 + 2");        assertTrue(result.isSuccess());        assertTrue(result.getValue().isPresent());        assertEquals(4, result.getValue().get());        assertEquals(4, executor.getVariables().get("x"));    }        {        StellarResult result = executor.execute("y := x + 2");        assertTrue(result.isSuccess());        assertTrue(result.getValue().isPresent());        assertEquals(6, result.getValue().get());        assertEquals(6, executor.getVariables().get("y"));    }        {        StellarResult result = executor.execute("z := x + y");        assertTrue(result.isSuccess());        assertTrue(result.getValue().isPresent());        assertEquals(10, result.getValue().get());        assertEquals(10, executor.getVariables().get("z"));    }}
public void metron_f9284_0()
{    List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);        StellarResult result = executor.execute("x := [1,2,3,4,5]");        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(expected, result.getValue().get());        List<Integer> variable = (List<Integer>) executor.getVariables().get("x");    assertEquals(expected, variable);}
public void metron_f9285_0()
{    Map<String, Integer> expected = ImmutableMap.<String, Integer>builder().put("a", 10).put("b", 20).build();        StellarResult result = executor.execute("x := {'a':10, 'b':20}");        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(expected, result.getValue().get());        Map<String, Integer> variable = (Map<String, Integer>) executor.getVariables().get("x");    assertEquals(expected, variable);}
public void metron_f9286_0()
{    StellarResult result = executor.execute("   x   :=    2 +      2      ");    assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(4, result.getValue().get());    assertEquals(4, executor.getVariables().get("x"));}
public void metron_f9287_0()
{    StellarResult result = executor.execute("x := 2 + ");    assertTrue(result.isError());    assertTrue(result.getException().isPresent());}
public void metron_f9288_0()
{    StellarResult result = executor.execute("2 + 2");    assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(4, result.getValue().get());}
public void metron_f9289_0()
{    StellarResult result = executor.execute("    2    +    2");    assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(4, result.getValue().get());}
public void metron_f9290_0()
{    StellarResult result = executor.execute("2 + ");    assertTrue(result.isError());    assertTrue(result.getException().isPresent());}
public void metron_f9291_0()
{        executor.execute("x := 2 + 2");        StellarResult result = executor.execute("%vars");    assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertNotNull(result.getValue().get());}
public void metron_f9292_0()
{        executor.execute("%define x := 2");    assertFalse(executor.getVariables().containsKey("x"));        assertEquals(2, executor.getGlobalConfig().get("x"));}
public void metron_f9293_0()
{    StellarResult result = executor.execute("%invalid");    assertTrue(result.isError());    assertTrue(result.getException().isPresent());}
public void metron_f9294_0()
{        StellarResult result = executor.execute("?TO_STRING");    assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertNotNull(result.getValue().get());}
public void metron_f9295_0()
{    StellarResult result = executor.execute("?INVALID");    assertTrue(result.isError());    assertTrue(result.getException().isPresent());}
public void metron_f9296_0()
{    StellarResult result = executor.execute("quit");    assertTrue(result.isTerminate());}
public void metron_f9297_0()
{    {                executor.assign("x", 10, Optional.empty());    }    {        StellarResult result = executor.execute("x + 2");        assertTrue(result.isSuccess());        assertTrue(result.getValue().isPresent());        assertEquals(12, result.getValue().get());    }}
public void metron_f9298_0()
{    notified = false;    executor.addVariableListener((var, value) -> {        assertEquals("x", var);        assertEquals(4, value.getResult());        notified = true;    });    executor.execute("x := 2 + 2");    assertTrue(notified);}
public void metron_f9299_0() throws Exception
{        notified = false;    Properties props = new Properties();    DefaultStellarShellExecutor executor = new DefaultStellarShellExecutor(props, Optional.empty());        notified = false;    executor.addSpecialListener((magic) -> {        assertNotNull(magic);        assertNotNull(magic.getCommand());        notified = true;    });        executor.init();    assertTrue(notified);}
public void metron_f9300_0() throws Exception
{        notified = false;    Properties props = new Properties();    DefaultStellarShellExecutor executor = new DefaultStellarShellExecutor(props, Optional.empty());        notified = false;    executor.addFunctionListener((fn) -> {        assertNotNull(fn);        assertNotNull(fn.getName());        assertNotNull(fn.getFunction());        notified = true;    });        executor.init();    assertTrue(notified);}
public void metron_f9301_0()
{    StellarResult result = executor.execute("");    assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals("", result.getValue().get());}
public void metron_f9302_0()
{    StellarResult result = executor.execute("# this is a comment");    assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals("", result.getValue().get());}
public void metron_f9303_0()
{    assertNotNull(executor.getGlobalConfig());    assertEquals(0, executor.getGlobalConfig().size());}
public void metron_f9304_0() throws Exception
{    command = new AssignmentCommand();        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(props, Optional.empty());    executor.init();}
public void metron_f9305_0()
{    assertEquals(":=", command.getCommand());}
public void metron_f9306_0()
{    List<String> inputs = Arrays.asList("x := 2 + 2", "   x      :=      2     +  2   ", "  x    :=    2", " x := ");    for (String in : inputs) {        assertTrue("failed: " + in, command.getMatcher().apply(in));    }}
public void metron_f9307_0()
{    List<String> inputs = Arrays.asList("2+2", " %define x := 2", "x");    for (String in : inputs) {        assertFalse("failed: " + in, command.getMatcher().apply(in));    }}
public void metron_f9308_0()
{    StellarResult result = command.execute("x := 2 + 2", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(4, result.getValue().get());        assertEquals(4, executor.getState().get("x").getResult());}
public void metron_f9309_0()
{        assertTrue(command.execute("x := 2 + 2", executor).isSuccess());    assertTrue(command.execute("y := 2 + x", executor).isSuccess());    assertTrue(command.execute("z := x + y", executor).isSuccess());        assertEquals(4, executor.getState().get("x").getResult());    assertEquals(6, executor.getState().get("y").getResult());    assertEquals(10, executor.getState().get("z").getResult());}
public void metron_f9310_0()
{        assertTrue(command.execute("x := 2 + 2", executor).isSuccess());    assertTrue(command.execute("x := 5 + 5", executor).isSuccess());        assertEquals(10, executor.getState().get("x").getResult());}
public void metron_f9311_0()
{        StellarResult result = command.execute("x := z", executor);        assertTrue(result.isSuccess());    assertTrue(result.isValueNull());    assertFalse(result.getValue().isPresent());        assertNull(executor.getState().get("x").getResult());}
public void metron_f9312_0()
{    StellarResult result = command.execute("x := 2 + ", executor);        assertTrue(result.isError());    assertTrue(result.getException().isPresent());        assertFalse(executor.getState().containsKey("x"));}
public void metron_f9313_0()
{    String stmt = "0/0";    StellarResult result = command.execute("x := " + stmt, executor);        assertTrue(result.isError());    assertTrue(result.getException().isPresent());    assertEquals(ParseException.class, result.getException().get().getClass());    assertTrue(result.getException().get().getMessage().contains(stmt));}
public void metron_f9314_0()
{    StellarResult result = command.execute("x := NULL", executor);        assertTrue(result.isSuccess());    assertTrue(result.isValueNull());        assertNull(executor.getState().get("x").getResult());}
public void metron_f9315_0()
{    StellarResult result = command.execute("x := ", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        assertEquals("", executor.getState().get("x").getResult());}
public void metron_f9316_0()
{        executor.assign("x", 10, Optional.empty());        StellarResult result = command.execute("y := x + 2", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(12, result.getValue().get());        assertEquals(10, executor.getState().get("x").getResult());    assertEquals(12, executor.getState().get("y").getResult());}
public void metron_f9317_0()
{    StellarResult result = command.execute("        x   :=    2 +      2", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals(4, result.getValue().get());        assertEquals(4, executor.getState().get("x").getResult());}
public void metron_f9318_0() throws Exception
{        magic = new Comment();        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(props, Optional.empty());    executor.init();}
public void metron_f9319_0()
{    assertEquals("#", magic.getCommand());}
public void metron_f9320_0()
{    List<String> inputs = Arrays.asList("#comment", "   #   comment   ", "      #comment");    for (String in : inputs) {        assertTrue("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9321_0()
{    List<String> inputs = Arrays.asList("foo", "  define ", "bar");    for (String in : inputs) {        assertFalse("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9322_0()
{    StellarResult result = magic.execute("#  this is a comment ", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    assertEquals("", result.getValue().get());}
public void metron_f9323_0() throws Exception
{        command = new DocCommand();        SimpleFunctionResolver functionResolver = new SimpleFunctionResolver().withClass(StringFunctions.ToString.class).withClass(StringFunctions.ToLower.class).withClass(StringFunctions.ToUpper.class);        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(functionResolver, props, Optional.empty());    executor.init();}
public void metron_f9324_0()
{    StellarResult result = command.execute("?TO_STRING", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        assertTrue(result.getValue().toString().length() > 0);}
public void metron_f9325_0()
{    StellarResult result = command.execute("?INVALID", executor);        assertTrue(result.isError());    assertTrue(result.getException().isPresent());}
public void metron_f9326_0()
{    StellarResult result = command.execute("?", executor);        assertTrue(result.isError());    assertTrue(result.getException().isPresent());}
public void metron_f9327_0() throws Exception
{        magic = new MagicDefineGlobal();        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(props, Optional.empty());    executor.init();}
public void metron_f9328_0()
{    assertEquals("%define", magic.getCommand());}
public void metron_f9329_0()
{    List<String> inputs = Arrays.asList("%define", "   %define   ", "%define x := 2", "    %define   x := 2 ");    for (String in : inputs) {        assertTrue("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9330_0()
{    List<String> inputs = Arrays.asList("foo", "  define ", "bar");    for (String in : inputs) {        assertFalse("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9331_0()
{    final int expected = 4;    {        StellarResult result = magic.execute("%define global := 2 + 2", executor);                assertTrue(result.isSuccess());        assertTrue(result.getValue().isPresent());        assertEquals(expected, result.getValue().get());                assertTrue(executor.getGlobalConfig().containsKey("global"));        assertEquals(expected, executor.getGlobalConfig().get("global"));    }        {                StellarResult result = executor.execute("%globals");                assertTrue(result.isSuccess());        assertTrue(result.getValue().isPresent());        String out = ConversionUtils.convert(result.getValue().get(), String.class);        assertEquals("{global=4}", out);    }}
public void metron_f9332_0()
{    StellarResult result = magic.execute("%define 2 + 2", executor);        assertTrue(result.isError());    assertFalse(result.getValue().isPresent());    assertTrue(result.getException().isPresent());        assertEquals(0, executor.getGlobalConfig().size());}
public void metron_f9333_0()
{    StellarResult result = magic.execute("%define", executor);        assertTrue(result.isError());    assertFalse(result.getValue().isPresent());    assertTrue(result.getException().isPresent());        assertEquals(0, executor.getGlobalConfig().size());}
public void metron_f9334_0() throws Exception
{        magic = new MagicListFunctions();        SimpleFunctionResolver functionResolver = new SimpleFunctionResolver().withClass(StringFunctions.ToString.class).withClass(StringFunctions.ToLower.class).withClass(StringFunctions.ToUpper.class);        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(functionResolver, props, Optional.empty());    executor.init();}
public void metron_f9335_0()
{    assertEquals("%functions", magic.getCommand());}
public void metron_f9336_0()
{    List<String> inputs = Arrays.asList("%functions", "   %functions   ", "%functions FOO", "    %functions    FOO ");    for (String in : inputs) {        assertTrue("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9337_0()
{    List<String> inputs = Arrays.asList("foo", "  functions ", "bar", "%define");    for (String in : inputs) {        assertFalse("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9338_0()
{    StellarResult result = magic.execute("%functions", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        String value = ConversionUtils.convert(result.getValue().get(), String.class);    String[] functions = value.split(", ");    assertEquals(3, functions.length);}
public void metron_f9339_0()
{    StellarResult result = magic.execute("%functions UPPER", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        String value = ConversionUtils.convert(result.getValue().get(), String.class);    String[] functions = value.split(", ");    assertEquals(1, functions.length);    assertEquals("TO_UPPER", functions[0]);}
public void metron_f9340_0()
{    StellarResult result = magic.execute("%functions NOMATCH", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        String value = ConversionUtils.convert(result.getValue().get(), String.class);    String[] functions = value.trim().split(", ");    assertEquals(1, functions.length);    assertEquals("", functions[0]);}
public void metron_f9341_0() throws Exception
{        magic = new MagicListGlobals();        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(props, Optional.empty());    executor.init();}
public void metron_f9342_0()
{    assertEquals("%globals", magic.getCommand());}
public void metron_f9343_0()
{    List<String> inputs = Arrays.asList("%globals", "   %globals   ", "%globals   FOO", "    %globals    FOO ");    for (String in : inputs) {        assertTrue("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9344_0()
{    List<String> inputs = Arrays.asList("foo", "  globals ", "bar", "%define");    for (String in : inputs) {        assertFalse("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9345_0()
{        executor.getGlobalConfig().put("x", 2);        StellarResult result = executor.execute("%globals");        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    String out = ConversionUtils.convert(result.getValue().get(), String.class);    assertEquals("{x=2}", out);}
public void metron_f9346_0()
{        StellarResult result = executor.execute("%globals");        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());    String out = ConversionUtils.convert(result.getValue().get(), String.class);    assertEquals("{}", out);}
public void metron_f9347_0() throws Exception
{        magic = new MagicListVariables();        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(props, Optional.empty());    executor.init();}
public void metron_f9348_0()
{    assertEquals("%vars", magic.getCommand());}
public void metron_f9349_0()
{    List<String> inputs = Arrays.asList("%vars", "   %vars   ", "%vars   FOO", "    %vars    FOO ");    for (String in : inputs) {        assertTrue("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9350_0()
{    List<String> inputs = Arrays.asList("foo", "  vars ", "bar", "%define");    for (String in : inputs) {        assertFalse("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9351_0()
{        executor.execute("x := 2 + 2");    StellarResult result = executor.execute("%vars");        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        String vars = ConversionUtils.convert(result.getValue().get(), String.class);    assertEquals("x = 4 via `2 + 2`", vars);}
public void metron_f9352_0()
{        StellarResult result = executor.execute("%vars");        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        String vars = ConversionUtils.convert(result.getValue().get(), String.class);    assertEquals("", vars);}
public void metron_f9353_0() throws Exception
{        magic = new MagicUndefineGlobal();        Properties props = new Properties();    executor = new DefaultStellarShellExecutor(props, Optional.empty());    executor.init();}
public void metron_f9354_0()
{    assertEquals("%undefine", magic.getCommand());}
public void metron_f9355_0()
{    List<String> inputs = Arrays.asList("%undefine", "   %undefine   ", "%undefine   FOO", "    %undefine    FOO ");    for (String in : inputs) {        assertTrue("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9356_0()
{    List<String> inputs = Arrays.asList("foo", "  undefine ", "bar", "%define");    for (String in : inputs) {        assertFalse("failed: " + in, magic.getMatcher().apply(in));    }}
public void metron_f9357_0()
{        executor.getGlobalConfig().put("global", 22);    assertEquals(1, executor.getGlobalConfig().size());        StellarResult result = magic.execute("%undefine global", executor);        assertTrue(result.isSuccess());    assertTrue(result.getValue().isPresent());        assertEquals(0, executor.getGlobalConfig().size());}
public void metron_f9358_0()
{        executor.getGlobalConfig().put("global", 22);    assertEquals(1, executor.getGlobalConfig().size());        StellarResult result = magic.execute("%undefine", executor);        assertTrue(result.isError());    assertTrue(result.getException().isPresent());        assertEquals(1, executor.getGlobalConfig().size());}
public void metron_f9359_0()
{    final int expected = 2;        StellarResult result = StellarResult.success(expected);    assertNotNull(result);        assertTrue(result.getValue().isPresent());    assertEquals(expected, result.getValue().get());        assertFalse(result.getException().isPresent());        assertEquals(StellarResult.Status.SUCCESS, result.getStatus());    assertTrue(result.isSuccess());    assertFalse(result.isError());    assertFalse(result.isTerminate());}
public void metron_f9360_0()
{    final String expected = "my error message";        StellarResult result = StellarResult.error(expected);    assertNotNull(result);        assertFalse(result.getValue().isPresent());        assertTrue(result.getException().isPresent());    assertEquals(expected, result.getException().get().getMessage());        assertEquals(StellarResult.Status.ERROR, result.getStatus());    assertFalse(result.isSuccess());    assertTrue(result.isError());    assertFalse(result.isTerminate());}
public void metron_f9361_0()
{        StellarResult result = StellarResult.terminate();    assertNotNull(result);        assertTrue(result.getValue().isPresent());        assertFalse(result.getException().isPresent());        assertEquals(StellarResult.Status.TERMINATE, result.getStatus());    assertFalse(result.isSuccess());    assertFalse(result.isError());    assertTrue(result.isTerminate());}
public void metron_f9362_0()
{        StellarResult result = StellarResult.noop();    assertNotNull(result);        assertTrue(result.getValue().isPresent());        assertFalse(result.getException().isPresent());        assertEquals(StellarResult.Status.SUCCESS, result.getStatus());    assertTrue(result.isSuccess());    assertFalse(result.isError());    assertFalse(result.isTerminate());}
public void metron_f9363_0()
{    final Object expected = null;        StellarResult result = StellarResult.success(expected);    assertNotNull(result);        assertTrue(result.isValueNull());        assertFalse(result.getException().isPresent());        assertEquals(StellarResult.Status.SUCCESS, result.getStatus());    assertTrue(result.isSuccess());    assertFalse(result.isError());    assertFalse(result.isTerminate());}
public void metron_f9364_0()
{    assertFalse(StellarResult.error(new Exception()).isValueNull());    assertFalse(StellarResult.error("error msg").isValueNull());    assertFalse(StellarResult.noop().isValueNull());    assertFalse(StellarResult.terminate().isValueNull());}
public void metron_f9365_0() throws Exception
{    final long timestamp = 1452013350000L;    String query = "TO_EPOCH_TIMESTAMP('2016-01-05 17:02:30', 'yyyy-MM-dd HH:mm:ss', 'UTC') + 2";    assertEquals(timestamp + 2, run(query, new HashMap<>()));}
public void metron_f9366_0() throws Exception
{    String query = "1 + 2";    assertEquals(3, run(query, new HashMap<>()));}
public void metron_f9367_0() throws Exception
{    String query = "1.0 + 2.0";    assertEquals(3.0, run(query, new HashMap<>()));}
public void metron_f9368_0() throws Exception
{    String query = "2.1 + 1";    assertEquals(3.1, run(query, new HashMap<>()));}
public void metron_f9369_0() throws Exception
{    String query = "1 + 2.1";    assertEquals(3.1, run(query, new HashMap<>()));}
public void metron_f9370_0()
{    assertEquals(3, run("1 + 2", new HashMap<>()));    assertEquals(3.2, run("1.2 + 2", new HashMap<>()));    assertEquals(1.2e-3 + 2, run("1.2e-3 + 2", new HashMap<>()));    assertEquals(1.2f + 3.7, run("1.2f + 3.7", new HashMap<>()));    assertEquals(12L * (1.2f + 7), run("12L*(1.2f + 7)", new HashMap<>()));    assertEquals(12.2f * (1.2f + 7L), run("TO_FLOAT(12.2) * (1.2f + 7L)", new HashMap<>()));}
public void metron_f9371_0()
{    {        String query = "TO_INTEGER(1 + 2*2 + 3 - 4 - 0.5)";        assertEquals(3, (Integer) run(query, new HashMap<>()), 1e-6);    }    {        String query = "1 + 2*2 + 3 - 4 - 0.5";        assertEquals(3.5, (Double) run(query, new HashMap<>()), 1e-6);    }    {        String query = "2*one*(1 + 2*2 + 3 - 4)";        assertEquals(8, run(query, ImmutableMap.of("one", 1)));    }    {        String query = "2*(1 + 2 + 3 - 4)";        assertEquals(4, (Integer) run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.000001)), 1e-6);    }    {        String query = "1 + 2 + 3 - 4 - 2";        assertEquals(0, (Integer) run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.000001)), 1e-6);    }    {        String query = "1 + 2 + 3 + 4";        assertEquals(10, (Integer) run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.000001)), 1e-6);    }    {        String query = "(one + 2)*3";        assertEquals(9, (Integer) run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.000001)), 1e-6);    }    {        String query = "TO_INTEGER((one + 2)*3.5)";        assertEquals(10, (Integer) run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.000001)), 1e-6);    }    {        String query = "1 + 2*3";        assertEquals(7, (Integer) run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.000001)), 1e-6);    }    {        String query = "TO_LONG(foo)";        Assert.assertNull(run(query, ImmutableMap.of("foo", "not a number")));    }    {        String query = "TO_LONG(foo)";        assertEquals(232321L, run(query, ImmutableMap.of("foo", "00232321")));    }    {        String query = "TO_LONG(foo)";        assertEquals(Long.MAX_VALUE, run(query, ImmutableMap.of("foo", Long.toString(Long.MAX_VALUE))));    }}
public void metron_f9372_0() throws Exception
{    Token<Integer> integer = mock(Token.class);    when(integer.getValue()).thenReturn(1);    Token<Long> lng = mock(Token.class);    when(lng.getValue()).thenReturn(1L);    Token<Double> dbl = mock(Token.class);    when(dbl.getValue()).thenReturn(1.0D);    Token<Float> flt = mock(Token.class);    when(flt.getValue()).thenReturn(1.0F);    Map<Pair<String, String>, Class<? extends Number>> expectedReturnTypeMappings = new HashMap<Pair<String, String>, Class<? extends Number>>() {        {            put(Pair.of("TO_FLOAT(3.0)", "TO_LONG(1)"), Float.class);            put(Pair.of("TO_FLOAT(3)", "3.0"), Double.class);            put(Pair.of("TO_FLOAT(3)", "TO_FLOAT(3)"), Float.class);            put(Pair.of("TO_FLOAT(3)", "3"), Float.class);            put(Pair.of("TO_LONG(1)", "TO_LONG(1)"), Long.class);            put(Pair.of("TO_LONG(1)", "3.0"), Double.class);            put(Pair.of("TO_LONG(1)", "TO_FLOAT(3)"), Float.class);            put(Pair.of("TO_LONG(1)", "3"), Long.class);            put(Pair.of("3.0", "TO_LONG(1)"), Double.class);            put(Pair.of("3.0", "3.0"), Double.class);            put(Pair.of("3.0", "TO_FLOAT(3)"), Double.class);            put(Pair.of("3.0", "3"), Double.class);            put(Pair.of("3", "TO_LONG(1)"), Long.class);            put(Pair.of("3", "3.0"), Double.class);            put(Pair.of("3", "TO_FLOAT(3)"), Float.class);            put(Pair.of("3", "3"), Integer.class);        }    };    expectedReturnTypeMappings.forEach((pair, expectedClass) -> {        assertTrue(run(pair.getLeft() + " * " + pair.getRight(), ImmutableMap.of()).getClass() == expectedClass);        assertTrue(run(pair.getLeft() + " + " + pair.getRight(), ImmutableMap.of()).getClass() == expectedClass);        assertTrue(run(pair.getLeft() + " - " + pair.getRight(), ImmutableMap.of()).getClass() == expectedClass);        assertTrue(run(pair.getLeft() + " / " + pair.getRight(), ImmutableMap.of()).getClass() == expectedClass);    });}
public void metron_f9373_0() throws Exception
{    Object run = run(".0f * 1", ImmutableMap.of());    assertEquals(.0f * 1, run);    assertEquals(Float.class, run.getClass());    Object run1 = run("0.f / 1F", ImmutableMap.of());    assertEquals(0.f / 1F, run1);    assertEquals(Float.class, run1.getClass());    Object run2 = run(".0F + 1.0f", ImmutableMap.of());    assertEquals(.0F + 1.0f, run2);    assertEquals(Float.class, run2.getClass());    Object run3 = run("0.0f - 0.1f", ImmutableMap.of());    assertEquals(0.0f - 0.1f, run3);    assertEquals(Float.class, run2.getClass());}
public void metron_f9374_0() throws Exception
{    assertEquals(0L * 1L, run("0L * 1L", ImmutableMap.of()));    assertEquals(0l / 1L, run("0l / 1L", ImmutableMap.of()));    assertEquals(1L - 1l, run("1L - 1l", ImmutableMap.of()));    assertEquals(2147483648L + 1L, run("2147483648L + 1L", ImmutableMap.of()));}
public void metron_f9375_0() throws Exception
{    assertEquals((((((1L) + .5d)))) * 6.f, run("(((((1L) + .5d)))) * 6.f", ImmutableMap.of()));    assertEquals((((((1L) + .5d)))) * 6.f / 0.f, run("(((((1L) + .5d)))) * 6.f / 0.f", ImmutableMap.of()));    assertEquals(Double.class, run("(((((1L) + .5d)))) * 6.f / 0.f", ImmutableMap.of()).getClass());}
public void metron_f9376_0() throws Exception
{    {        assertEquals(Float.class, run("6.f", ImmutableMap.of()).getClass());        assertEquals(Float.class, run(".0f", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("6.0F", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("6f", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("6e-6f", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("6e+6f", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("6e6f", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("TO_FLOAT(1231)", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("TO_FLOAT(12.31)", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("TO_FLOAT(12.31f)", ImmutableMap.of()).getClass());        assertEquals(Float.class, run("TO_FLOAT(12L)", ImmutableMap.of()).getClass());    }    {        assertEquals(Double.class, run("6.d", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("6.D", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("6.0d", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("6D", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("6e5D", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("6e-5D", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("6e+5D", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("TO_DOUBLE(1231)", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("TO_DOUBLE(12.31)", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("TO_DOUBLE(12.31f)", ImmutableMap.of()).getClass());        assertEquals(Double.class, run("TO_DOUBLE(12L)", ImmutableMap.of()).getClass());    }    {        assertEquals(Integer.class, run("6", ImmutableMap.of()).getClass());        assertEquals(Integer.class, run("60000000", ImmutableMap.of()).getClass());        assertEquals(Integer.class, run("-0", ImmutableMap.of()).getClass());        assertEquals(Integer.class, run("-60000000", ImmutableMap.of()).getClass());        assertEquals(Integer.class, run("TO_INTEGER(1231)", ImmutableMap.of()).getClass());        assertEquals(Integer.class, run("TO_INTEGER(12.31)", ImmutableMap.of()).getClass());        assertEquals(Integer.class, run("TO_INTEGER(12.31f)", ImmutableMap.of()).getClass());        assertEquals(Integer.class, run("TO_INTEGER(12L)", ImmutableMap.of()).getClass());    }    {        assertEquals(Long.class, run("12345678910l", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("0l", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("-0l", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("-60000000L", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("-60000000L", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("TO_LONG(1231)", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("TO_LONG(12.31)", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("TO_LONG(12.31f)", ImmutableMap.of()).getClass());        assertEquals(Long.class, run("TO_LONG(12L)", ImmutableMap.of()).getClass());    }}
public void metron_f9377_0() throws Exception
{    exception.expect(ParseException.class);    run("000000", ImmutableMap.of());}
public void metron_f9378_0() throws Exception
{    exception.expect(ParseException.class);    run("000000l", ImmutableMap.of());}
public void metron_f9379_0() throws Exception
{    exception.expect(ParseException.class);    run("000000d", ImmutableMap.of());}
public void metron_f9380_0() throws Exception
{    exception.expect(ParseException.class);    run("000000f", ImmutableMap.of());}
public void metron_f9381_0() throws Exception
{    exception.expect(ParseException.class);    run("--000000f", ImmutableMap.of());}
public void metron_f9382_0() throws Exception
{    exception.expect(ParseException.class);    run("--000000D", ImmutableMap.of());}
public void metron_f9383_0() throws Exception
{    exception.expect(ParseException.class);    run("--000000L", ImmutableMap.of());}
public void metron_f9384_0() throws Exception
{    run("0/0", ImmutableMap.of());}
public void metron_f9385_0() throws Exception
{    run("0L/0L", ImmutableMap.of());}
public void metron_f9386_0() throws Exception
{    assertEquals(0F / 0F, run("0F/0F", ImmutableMap.of()));    assertEquals(0D / 0D, run("0D/0D", ImmutableMap.of()));    assertEquals(0D / 0F, run("0D/0F", ImmutableMap.of()));    assertEquals(0F / 0D, run("0F/0D", ImmutableMap.of()));    assertEquals(0F / 0, run("0F/0", ImmutableMap.of()));    assertEquals(0D / 0, run("0D/0", ImmutableMap.of()));    assertEquals(0 / 0D, run("0/0D", ImmutableMap.of()));    assertEquals(0 / 0F, run("0/0F", ImmutableMap.of()));}
public void metron_f9387_0()
{    for (String statement : ImmutableList.of("foo := bar + grok", "foo   := bar + grok", "foo := bar + grok   ")) {        StellarAssignment assignment = StellarAssignment.from(statement);        Assert.assertEquals("foo", assignment.getKey());        Assert.assertEquals("foo", assignment.getVariable());        Assert.assertEquals("bar + grok", assignment.getStatement());        Assert.assertEquals("bar + grok", assignment.getValue());    }}
public void metron_f9388_0()
{    for (String statement : ImmutableList.of("bar + grok", "  bar + grok", "bar + grok   ")) {        StellarAssignment assignment = StellarAssignment.from(statement);        Assert.assertNull(assignment.getKey());        Assert.assertNull(assignment.getVariable());        Assert.assertEquals("bar + grok", assignment.getStatement());        Assert.assertEquals("bar + grok", assignment.getValue());    }}
public void metron_f9389_0()
{    StellarAssignment assignment = StellarAssignment.from("foo := bar");    assignment.setValue("myval");}
public void metron_f9390_0() throws Exception
{    assertEquals(1 < 2, run("1 < 2", ImmutableMap.of()));    assertEquals(1f < 2, run("1f < 2", ImmutableMap.of()));    assertEquals(1f < 2d, run("1f < 2d", ImmutableMap.of()));    assertEquals(1f < 2e-4d, run("1f < 2e-4d", ImmutableMap.of()));    assertEquals(1L < 2e-4d, run("1L < 2e-4d", ImmutableMap.of()));    assertEquals(1 < 2e-4d, run("1 < 2e-4d", ImmutableMap.of()));    assertEquals(1 < 2L, run("1 < 2L", ImmutableMap.of()));    assertEquals(1.0f < 2.0f, run("1.0f < 2.0f", ImmutableMap.of()));    assertEquals(1L < 3.0f, run("1L < 3.0f", ImmutableMap.of()));    assertEquals(1 < 3.0f, run("1 < 3.0f", ImmutableMap.of()));    assertEquals(1.0 < 3.0f, run("1.0 < 3.0f", ImmutableMap.of()));    boolean thrown = false;    try {        run("foo < 3.0f", ImmutableMap.of());    } catch (ParseException pe) {        thrown = true;    }    assertTrue(thrown);    thrown = false;    try {        run("foo < foo", ImmutableMap.of());    } catch (ParseException pe) {        thrown = true;    }    assertTrue(thrown);    assertEquals(1L < 3.0f ? true : false, run("if 1L < 3.0f then true else false", ImmutableMap.of()));}
public void metron_f9391_0() throws Exception
{    assertEquals(1f >= 2, run("TO_FLOAT(1) >= 2", ImmutableMap.of()));    assertEquals(1f <= 2, run("TO_FLOAT(1) <= TO_FLOAT(2)", ImmutableMap.of()));    assertEquals(1f == 2, run("TO_FLOAT(1) == TO_LONG(2)", ImmutableMap.of()));    assertEquals(12.31f == 10.2f, run("TO_FLOAT(12.31) < 10.2f", ImmutableMap.of()));}
public void metron_f9392_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("empty", "");            put("spaced", "metron is great");            put("foo.bar", "casey");        }    };    assertTrue(runPredicate("'casey' == foo.bar", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("'casey' == foo", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("'casey' != foo", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("'stella' == 'stella'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("'stella' == foo", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("foo== foo", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("empty== ''", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("spaced == 'metron is great'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate(null, new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate(" ", (new DefaultVariableResolver(variableMap::get, variableMap::containsKey))));}
public void metron_f9393_0() throws Exception
{    Map<String, String> variableMap = new HashMap<>();    assertFalse(runPredicate("1 == '1'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("'1' == 1", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9394_0() throws Exception
{    Map<String, String> variableMap = new HashMap<>();    assertFalse(runPredicate("null == '1'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("\"1\" == null", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("null == null", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9395_0() throws Exception
{    Map<String, String> variableMap = new HashMap<>();    assertTrue(runPredicate("\"1\" == '1'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("'1' == \"1\"", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("'1' == \"1\"", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9396_0() throws Exception
{    Map<String, String> variableMap = new HashMap<>();    assertFalse(runPredicate("55 == '7'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("97 == 'a'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9397_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<String, Object>() {        {            put("foo", "casey");            put("bar", "bar.casey.grok");            put("ip", "192.168.0.1");            put("num", 7);            put("num2", 8.5);            put("num3", 7);            put("num4", "8.5");            put("empty", "");            put("spaced", "metron is great");        }    };    assertTrue(runPredicate("num == 7", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("num < num2", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("num < TO_DOUBLE(num2)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("num < TO_DOUBLE(num4)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("num < 100", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("num == num3", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("num == num2", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("num == num2 || true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("num > num2", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("num == 7 && num > 2", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9398_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<String, Object>() {        {            put("num", -0);        }    };    Arrays.asList("!=", "==").forEach(op -> {        assertEquals("==".equals(op), runPredicate("num " + op + " 0", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("==".equals(op), runPredicate("0 " + op + " -0", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("==".equals(op), runPredicate("0 " + op + " -0d", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("==".equals(op), runPredicate("-0 " + op + " 0", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("==".equals(op), runPredicate("-0F " + op + " 0D", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("==".equals(op), runPredicate("-0.F " + op + " 0", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("==".equals(op), runPredicate("-0.F " + op + " 0F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("==".equals(op), runPredicate("-0.D " + op + " 0D", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    });}
public void metron_f9399_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    Arrays.asList("!=", "==").forEach(op -> {        assertEquals("!=".equals(op), runPredicate("(0f/0f) " + op + " (0f/0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(-0f/0f) " + op + " (0f/0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(-0f/-0f) " + op + " (0f/0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(-0f/-0f) " + op + " (-0f/0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(-0f/-0f) " + op + " (-0f/-0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(0f/-0f) " + op + " (0f/0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(0f/-0f) " + op + " (-0f/0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(0f/-0f) " + op + " (-0f/-0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(0f/0f) " + op + " (-0f/0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(0f/0d) " + op + " (-0f/-0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(0d/-0f) " + op + " (0f/-0f)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(-0f/0f) " + op + " (0f/-0d)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(-0d/-0d) " + op + " (0d/-0d)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals("!=".equals(op), runPredicate("(0d/0d) " + op + " (0d/0d)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    });}
public void metron_f9400_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<String, Object>() {        {            put("t", true);            put("f", false);        }    };    assertTrue(runPredicate("t != f", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("f != t", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("true != false", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("true != true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("false != true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("false != false", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("t == f", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("f == t", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("true == false", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("true == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("false == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("false == false", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("null == false", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("null == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("true == NULL", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("false == NULL", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9401_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    assertFalse(runPredicate("null == false", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("null == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("true == NULL", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("false == NULL", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("1 == NULL", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("'null' == NULL", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("'' == NULL", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertFalse(runPredicate("null == ''", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    assertTrue(runPredicate("NULL == null", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9402_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    assertEquals(0.1 + 0.2 == 0.3, runPredicate("0.1 + 0.2 == 0.3", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9403_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    runPredicate("1 < '1'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey));}
public void metron_f9404_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    runPredicate("'1' <= 1", new DefaultVariableResolver(variableMap::get, variableMap::containsKey));}
public void metron_f9405_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    runPredicate("1 > '1'", new DefaultVariableResolver(variableMap::get, variableMap::containsKey));}
public void metron_f9406_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    runPredicate("'1' >= 1", new DefaultVariableResolver(variableMap::get, variableMap::containsKey));}
public void metron_f9407_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    final Integer[] result = { 0 };    Stream.of("<", "<=", ">", ">=").forEach(op -> {        assertFalse(runPredicate("'1' " + op + " null", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    });}
public void metron_f9408_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<>();    {        assertEquals(1 == 1.00000001, runPredicate("1 == 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 < 1.00000001, runPredicate("1 < 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 <= 1.00000001, runPredicate("1 <= 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 > 1.00000001, runPredicate("1 > 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 >= 1.00000001, runPredicate("1 >= 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    }    {        assertEquals(1 == 1.00000001F, runPredicate("1 == 1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 < 1.00000001F, runPredicate("1 < 1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 <= 1.00000001F, runPredicate("1 <= 1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 > 1.00000001F, runPredicate("1 > 1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1 >= 1.00000001F, runPredicate("1 >= 1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    }    {        assertEquals(1.00000001F == 1.00000001, runPredicate("1.00000001F == 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1.00000001F < 1.00000001, runPredicate("1.00000001F < 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1.00000001F <= 1.00000001, runPredicate("1.00000001F <= 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1.00000001F > 1.00000001, runPredicate("1.00000001F > 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(1.00000001F >= 1.00000001, runPredicate("1.00000001F >= 1.00000001", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    }    {        assertEquals(-1L == -1.00000001F, runPredicate("-1L == -1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(-1L < -1.00000001F, runPredicate("-1L < -1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(-1L <= -1.00000001F, runPredicate("-1L <= -1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(-1L > -1.00000001F, runPredicate("-1L > -1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));        assertEquals(-1L >= -1.00000001F, runPredicate("-1L >= -1.00000001F", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    }}
public void metron_f9409_0() throws Exception
{    variableResolver = mock(VariableResolver.class);    functionResolver = mock(FunctionResolver.class);    context = mock(Context.class);    tokenStack = new ArrayDeque<>();    arithmeticEvaluator = mock(ArithmeticEvaluator.class);    numberLiteralEvaluator = mock(NumberLiteralEvaluator.class);    comparisonExpressionWithOperatorEvaluator = mock(ComparisonExpressionWithOperatorEvaluator.class);    expression = new StellarCompiler.Expression(tokenStack);    compiler = new StellarCompiler(expression, arithmeticEvaluator, numberLiteralEvaluator, comparisonExpressionWithOperatorEvaluator);}
public void metron_f9410_0() throws Exception
{    StellarParser.IntLiteralContext ctx = mock(StellarParser.IntLiteralContext.class);    Token result = mock(Token.class);    when(ctx.getText()).thenReturn("1000");    when(numberLiteralEvaluator.evaluate(ctx, null)).thenReturn(result);    compiler.exitIntLiteral(ctx);    verify(numberLiteralEvaluator).evaluate(ctx, null);    Assert.assertEquals(1, tokenStack.size());    Assert.assertEquals(tokenStack.getFirst(), result);    verifyZeroInteractions(variableResolver);    verifyZeroInteractions(functionResolver);    verifyZeroInteractions(context);    verifyZeroInteractions(arithmeticEvaluator);    verifyZeroInteractions(comparisonExpressionWithOperatorEvaluator);}
public void metron_f9411_0() throws Exception
{    StellarParser.DoubleLiteralContext ctx = mock(StellarParser.DoubleLiteralContext.class);    Token result = mock(Token.class);    when(numberLiteralEvaluator.evaluate(ctx, null)).thenReturn(result);    when(ctx.getText()).thenReturn("1000D");    compiler.exitDoubleLiteral(ctx);    verify(numberLiteralEvaluator).evaluate(ctx, null);    Assert.assertEquals(1, tokenStack.size());    Assert.assertEquals(tokenStack.getFirst(), result);    verifyZeroInteractions(variableResolver);    verifyZeroInteractions(functionResolver);    verifyZeroInteractions(context);    verifyZeroInteractions(arithmeticEvaluator);    verifyZeroInteractions(comparisonExpressionWithOperatorEvaluator);}
public void metron_f9412_0() throws Exception
{    StellarParser.FloatLiteralContext ctx = mock(StellarParser.FloatLiteralContext.class);    when(ctx.getText()).thenReturn("1000f");    Token result = mock(Token.class);    when(numberLiteralEvaluator.evaluate(ctx, null)).thenReturn(result);    compiler.exitFloatLiteral(ctx);    verify(numberLiteralEvaluator).evaluate(ctx, null);    Assert.assertEquals(1, tokenStack.size());    Assert.assertEquals(tokenStack.getFirst(), result);    verifyZeroInteractions(variableResolver);    verifyZeroInteractions(functionResolver);    verifyZeroInteractions(context);    verifyZeroInteractions(arithmeticEvaluator);    verifyZeroInteractions(comparisonExpressionWithOperatorEvaluator);}
public void metron_f9413_0() throws Exception
{    StellarParser.LongLiteralContext ctx = mock(StellarParser.LongLiteralContext.class);    when(ctx.getText()).thenReturn("1000l");    Token result = mock(Token.class);    when(numberLiteralEvaluator.evaluate(ctx, null)).thenReturn(result);    compiler.exitLongLiteral(ctx);    verify(numberLiteralEvaluator).evaluate(ctx, null);    Assert.assertEquals(1, tokenStack.size());    Assert.assertEquals(tokenStack.getFirst(), result);    verifyZeroInteractions(variableResolver);    verifyZeroInteractions(functionResolver);    verifyZeroInteractions(context);    verifyZeroInteractions(arithmeticEvaluator);    verifyZeroInteractions(comparisonExpressionWithOperatorEvaluator);}
public void metron_f9414_0() throws Exception
{    StellarParser.ComparisonExpressionWithOperatorContext ctx = mock(StellarParser.ComparisonExpressionWithOperatorContext.class);    StellarParser.ComparisonOpContext mockOp = mock(StellarParser.ComparisonOpContext.class);    when(ctx.comp_operator()).thenReturn(mockOp);    Token result = mock(Token.class);    when(comparisonExpressionWithOperatorEvaluator.evaluate(any(Token.class), any(Token.class), any(StellarParser.ComparisonOpContext.class), any())).thenReturn(result);    compiler.exitComparisonExpressionWithOperator(ctx);    Assert.assertEquals(1, tokenStack.size());    StellarCompiler.DeferredFunction func = (StellarCompiler.DeferredFunction) tokenStack.pop().getValue();    tokenStack.push(new Token<>(1000, Integer.class, null));    tokenStack.push(new Token<>(1500f, Float.class, null));    func.apply(tokenStack, new StellarCompiler.ExpressionState(context, functionResolver, variableResolver));    Assert.assertEquals(1, tokenStack.size());    Assert.assertEquals(tokenStack.getFirst(), result);    verify(comparisonExpressionWithOperatorEvaluator).evaluate(any(Token.class), any(Token.class), eq(mockOp), any());    verifyZeroInteractions(numberLiteralEvaluator);    verifyZeroInteractions(variableResolver);    verifyZeroInteractions(functionResolver);    verifyZeroInteractions(context);    verifyZeroInteractions(arithmeticEvaluator);}
public void metron_f9415_0() throws Exception
{    StellarPredicateProcessor processor = new StellarPredicateProcessor();    try {        processor.validate("enrichedField1 == 'enrichedValue1");        fail("Invalid rule found to be valid - unclosed single quotes.");    } catch (ParseException e) {    }}
public void metron_f9416_0() throws Exception
{    Clock clock = new Clock();    long t1 = clock.currentTimeMillis();    Thread.sleep(50);    long t2 = clock.currentTimeMillis();    Thread.sleep(50);    long t3 = clock.currentTimeMillis();    assertThat("t3 should be greater", t3 > t2, equalTo(true));    assertThat("t2 should be greater", t2 > t1, equalTo(true));}
public void metron_f9417_0() throws Exception
{    Clock clock = Mockito.spy(Clock.class);    SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmssSSSZ");    sdf.setTimeZone(TimeZone.getTimeZone("UTC"));    Date date = sdf.parse("20160615183527162+0000");    Mockito.when(clock.currentTimeMillis()).thenReturn(date.getTime());    assertThat("time not right", clock.currentTimeFormatted("yyyyMMddHHmmssSSSZ"), equalTo("20160615183527162+0000"));}
public void metron_f9418_0()
{    BloomFilter bloomString = (BloomFilter) run("BLOOM_ADD(BLOOM_INIT(), string)", variables);    BloomFilter bloomDouble = (BloomFilter) run("BLOOM_ADD(BLOOM_INIT(), double)", variables);    BloomFilter bloomInteger = (BloomFilter) run("BLOOM_ADD(BLOOM_INIT(), integer)", variables);    BloomFilter bloomMap = (BloomFilter) run("BLOOM_ADD(BLOOM_INIT(), map)", variables);    BloomFilter merged = (BloomFilter) run("BLOOM_MERGE([stringFilter, doubleFilter, integerFilter, mapFilter])", ImmutableMap.of("stringFilter", bloomString, "doubleFilter", bloomDouble, "integerFilter", bloomInteger, "mapFilter", bloomMap));    Assert.assertNotNull(merged);    for (Object val : variables.values()) {        Assert.assertTrue(merged.mightContain(val));    }}
public void metron_f9419_0()
{    BloomFilter result = (BloomFilter) run("BLOOM_ADD(BLOOM_INIT(), string, double, integer, map)", variables);    for (Object val : variables.values()) {        Assert.assertTrue(result.mightContain(val));    }    Assert.assertTrue(result.mightContain(ImmutableMap.of("key1", "value1", "key2", "value2")));}
public void metron_f9420_0()
{    {        Boolean result = (Boolean) run("BLOOM_EXISTS(BLOOM_ADD(BLOOM_INIT(), string, double, integer, map), 'casey')", variables);        Assert.assertTrue(result);    }    {        Boolean result = (Boolean) run("BLOOM_EXISTS(BLOOM_ADD(BLOOM_INIT(), string, double, integer, map), double)", variables);        Assert.assertTrue(result);    }    {        Boolean result = (Boolean) run("BLOOM_EXISTS(BLOOM_ADD(BLOOM_INIT(), string, double, integer, map), integer)", variables);        Assert.assertTrue(result);    }    {        Boolean result = (Boolean) run("BLOOM_EXISTS(BLOOM_ADD(BLOOM_INIT(), string, double, integer, map), map)", variables);        Assert.assertTrue(result);    }    {        Boolean result = (Boolean) run("BLOOM_EXISTS(BLOOM_ADD(BLOOM_INIT(), string, double, integer, map), 'samantha')", variables);        Assert.assertFalse(result);    }    {        boolean thrown = false;        try {            run("BLOOM_EXISTS(BLOOM_ADD(BLOOM_INIT(), string, double, integer, map), sam)", variables);        } catch (ParseException pe) {            thrown = true;        }        Assert.assertTrue(thrown);    }}
public void metron_f9421_0() throws Exception
{    Map<String, Object> v1 = new HashMap<>();    v1.put("k1", "v1");    Map<String, Object> v2 = new HashMap<>();    v2.put("k2", "v2");    v2.put("k3", null);    Map<String, Object> union = new HashMap<String, Object>() {        {            putAll(v1);            put("k2", "v2");        }    };    ConcatMap c = create(v1, v2);    Assert.assertEquals(c.toString(), union.toString());}
private ConcatMap metron_f9422_0(Map... ms)
{    List<Map> l = new ArrayList<>();    for (Map m : ms) {        l.add(m);    }    return new ConcatMap(l);}
private void metron_f9423_0(ConcatMap c)
{    byte[] serialized = SerDeUtils.toBytes(c);    ConcatMap deserialized = SerDeUtils.fromBytes(serialized, ConcatMap.class);    Assert.assertEquals(deserialized, c);}
public void metron_f9424_0()
{    Map<String, Object> v1 = new HashMap<>();    v1.put("k1", "v1");    Map<String, Object> v2 = new HashMap<>();    v2.put("k2", "v2");    v2.put("k3", null);    {                ConcatMap c = create(v1, v2);        assertKryoserializable(c);    }    {                ConcatMap c = create(v1);        assertKryoserializable(c);    }    {                ConcatMap c = create();        assertKryoserializable(c);    }}
public void metron_f9425_0()
{    Object o = 1;    Assert.assertEquals(Integer.valueOf(1), ConversionUtils.convert(o, Integer.class));    Assert.assertEquals(Integer.valueOf(1), ConversionUtils.convert("1", Integer.class));    Assert.assertNull(ConversionUtils.convert("foo", Integer.class));}
public void metron_f9426_0() throws Exception
{    assertEquals(StringUtils.repeat("00", 16), new DefaultHasher("md5", encoder).getHash(null));    assertEquals(StringUtils.repeat("00", 32), new DefaultHasher("sha-256", encoder).getHash(null));}
public void metron_f9427_0() throws Exception
{    assertNull(new DefaultHasher("md5", encoder, charset).getHash(new Object()));}
public void metron_f9428_0() throws Exception
{    assertEquals("d41d8cd98f00b204e9800998ecf8427e", new DefaultHasher("md5", encoder).getHash(""));}
public void metron_f9429_0() throws Exception
{    final Collection<String> serializable = Collections.emptyList();    assertEquals("ef5e8c8d27af3a953b4674065c99a52a", new DefaultHasher("md5", encoder, charset).getHash(serializable));}
public static void metron_f9430_0() throws Exception
{    tmpDir = UnitTestHelper.createTempDir(new File("target/jsonutilstest"));    configFile = UnitTestHelper.write(new File(tmpDir, "config.json"), config);}
public void metron_f9431_0() throws Exception
{    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("a", "hello");            put("b", "world");        }    };    Map<String, Object> actual = JSONUtils.INSTANCE.load(configFile, JSONUtils.MAP_SUPPLIER);    Assert.assertThat("config not equal", actual, equalTo(expected));}
public void metron_f9432_0() throws Exception
{    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("a", "hello");            put("b", "world");        }    };    Map<String, Object> actual = JSONUtils.INSTANCE.load(configFile, Map.class);    Assert.assertThat("config not equal", actual, equalTo(expected));}
public void metron_f9433_0() throws Exception
{    TestConfig expected = new TestConfig().setA("hello").setB("world");    TestConfig actual = JSONUtils.INSTANCE.load(configFile, TestConfig.class);    Assert.assertThat("a not equal", actual.getA(), equalTo(expected.getA()));    Assert.assertThat("b not equal", actual.getB(), equalTo(expected.getB()));}
public String metron_f9434_0()
{    return a;}
public TestConfig metron_f9435_0(String a)
{    this.a = a;    return this;}
public String metron_f9436_0()
{    return b;}
public TestConfig metron_f9437_0(String b)
{    this.b = b;    return this;}
public void metron_f9438_0()
{    final int expected = 2;    byte[] raw = SerDeUtils.toBytes(expected);    int actual = SerDeUtils.fromBytes(raw, Integer.class);    assertEquals(expected, actual);}
public void metron_f9439_0()
{    final double expected = 2.0;    byte[] raw = SerDeUtils.toBytes(expected);    {        double actual = SerDeUtils.fromBytes(raw, Double.class);        assertEquals(expected, actual, 0.01);    }    {        double actual = (double) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual, 0.01);    }}
public void metron_f9440_0()
{    final short expected = 2;    byte[] raw = SerDeUtils.toBytes(expected);    {        short actual = SerDeUtils.fromBytes(raw, Short.class);        assertEquals(expected, actual);    }    {        short actual = (short) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual);    }}
public void metron_f9441_0()
{    final long expected = 2L;    byte[] raw = SerDeUtils.toBytes(expected);    {        long actual = SerDeUtils.fromBytes(raw, Long.class);        assertEquals(expected, actual);    }    {        long actual = (Long) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual);    }}
public void metron_f9442_0()
{    final Float expected = 2.2F;    byte[] raw = SerDeUtils.toBytes(expected);    {        float actual = SerDeUtils.fromBytes(raw, Float.class);        assertEquals(expected, actual, 0.01);    }    {        float actual = (float) SerDeUtils.fromBytes(raw, Object.class);        assertEquals(expected, actual, 0.01);    }}
public void metron_f9443_0()
{    final Map<String, Object> expected = new HashMap<>();    expected.put("foo", "bar");    expected.put("bar", 1.0);    ;    byte[] raw = SerDeUtils.toBytes(expected);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    assertEquals(expected, actual);}
public void metron_f9444_0()
{    final List<String> expected = new ArrayList<String>();    expected.add("foo");    expected.add("bar");    byte[] raw = SerDeUtils.toBytes(expected);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    assertEquals(expected, actual);}
public void metron_f9445_0()
{    final BloomFilter<Object> expected = new BloomFilter<>(new BloomFilter.DefaultSerializer<>(), 10000, 0.01);    expected.add("foo");    expected.add("bar");    byte[] raw = SerDeUtils.toBytes(expected);    BloomFilter<Object> actual = (BloomFilter) SerDeUtils.fromBytes(raw, Object.class);    Assert.assertTrue(actual.mightContain("foo"));    Assert.assertFalse(actual.mightContain("timothy"));    assertEquals(expected, actual);}
public List<String> metron_f9446_0()
{    return list;}
public void metron_f9447_0(List<String> list)
{    this.list = list;}
public String metron_f9448_0()
{    return string;}
public void metron_f9449_0(String string)
{    this.string = string;}
public Double metron_f9450_0()
{    return d;}
public void metron_f9451_0(Double d)
{    this.d = d;}
public Map<String, String> metron_f9452_0()
{    return map;}
public void metron_f9453_0(Map<String, String> map)
{    this.map = map;}
public boolean metron_f9454_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ArbitraryPojo that = (ArbitraryPojo) o;    if (getList() != null ? !getList().equals(that.getList()) : that.getList() != null)        return false;    if (getString() != null ? !getString().equals(that.getString()) : that.getString() != null)        return false;    if (getD() != null ? !getD().equals(that.getD()) : that.getD() != null)        return false;    if (getMap() != null ? !getMap().equals(that.getMap()) : that.getMap() != null)        return false;    return immutableList != null ? immutableList.equals(that.immutableList) : that.immutableList == null;}
public int metron_f9455_0()
{    int result = getList() != null ? getList().hashCode() : 0;    result = 31 * result + (getString() != null ? getString().hashCode() : 0);    result = 31 * result + (getD() != null ? getD().hashCode() : 0);    result = 31 * result + (getMap() != null ? getMap().hashCode() : 0);    result = 31 * result + (immutableList != null ? immutableList.hashCode() : 0);    return result;}
public void metron_f9456_0()
{    final ArbitraryPojo expected = new ArbitraryPojo();    byte[] raw = SerDeUtils.toBytes(expected);    Object actual = SerDeUtils.fromBytes(raw, Object.class);    assertEquals(expected, actual);}
public static String metron_f9457_0(String name)
{    return findDir(new File("."), name);}
public static String metron_f9458_0(File startDir, String name)
{    Stack<File> s = new Stack<File>();    s.push(startDir);    while (!s.empty()) {        File parent = s.pop();        if (parent.getName().equalsIgnoreCase(name)) {            return parent.getAbsolutePath();        } else {            File[] children = parent.listFiles();            if (children != null) {                for (File child : children) {                    s.push(child);                }            }        }    }    return null;}
public static void metron_f9459_0(String type, Set<T> expectedPcapIds, Set<T> found)
{    boolean mismatch = false;    for (T f : found) {        if (!expectedPcapIds.contains(f)) {            mismatch = true;            System.out.println("Found " + type + " that I did not expect: " + f);        }    }    for (T expectedId : expectedPcapIds) {        if (!found.contains(expectedId)) {            mismatch = true;            System.out.println("Expected " + type + " that I did not index: " + expectedId);        }    }    Assert.assertFalse(mismatch);}
public static void metron_f9460_0()
{    verboseLogging("%d [%p|%c|%C{1}] %m%n", Level.ALL);}
public static void metron_f9461_0(String pattern, Level level)
{        ConsoleAppender console = new ConsoleAppender();        console.setLayout(new PatternLayout(pattern));    console.setThreshold(level);    console.activateOptions();        Logger.getRootLogger().addAppender(console);}
public static void metron_f9462_0(Class clazz, Level level)
{    Logger logger = Logger.getLogger(clazz);    logger.setLevel(level);}
public static Level metron_f9463_0(Class clazz)
{    Logger logger = Logger.getLogger(clazz);    return logger.getLevel();}
public static void metron_f9464_0(Class clazz, java.util.logging.Level level)
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger(clazz.getName());    logger.setLevel(level);}
public static java.util.logging.Level metron_f9465_0(Class clazz)
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger(clazz.getName());    return logger.getLevel();}
public static void metron_f9466_0(java.util.logging.Level level)
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger("");    logger.setLevel(level);}
public static java.util.logging.Level metron_f9467_0()
{    java.util.logging.Logger logger = java.util.logging.Logger.getLogger("");    return logger.getLevel();}
public static File metron_f9468_0(File dir) throws IOException
{    return createTempDir(dir, true);}
public static File metron_f9469_0(File dir, boolean cleanup) throws IOException
{    if (!dir.mkdirs() && !dir.exists()) {        throw new IOException(String.format("Failed to create directory structure '%s'", dir.toString()));    }    if (cleanup) {        addCleanupHook(dir.toPath());    }    return dir;}
public static File metron_f9470_0(String prefix) throws IOException
{    return createTempDir(prefix, true);}
public static File metron_f9471_0(String prefix, boolean cleanup) throws IOException
{    Path tmpDir = Files.createTempDirectory(prefix);    addCleanupHook(tmpDir);    return tmpDir.toFile();}
public static void metron_f9472_0(final Path dir)
{    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            try {                cleanDir(dir);            } catch (IOException e) {                System.out.println(format("Warning: Unable to clean folder '%s'", dir.toString()));            }        }    });}
public void metron_f9473_0()
{    try {        cleanDir(dir);    } catch (IOException e) {        System.out.println(format("Warning: Unable to clean folder '%s'", dir.toString()));    }}
public static void metron_f9474_0(Path dir) throws IOException
{    Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {            if (exc == null) {                return FileVisitResult.CONTINUE;            } else {                throw exc;            }        }    });    Files.delete(dir);}
public FileVisitResult metron_f9475_0(Path file, BasicFileAttributes attrs) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f9476_0(Path file, IOException exc) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f9477_0(Path dir, IOException exc) throws IOException
{    if (exc == null) {        return FileVisitResult.CONTINUE;    } else {        throw exc;    }}
public static File metron_f9478_0(File file, String contents) throws IOException
{    com.google.common.io.Files.createParentDirs(file);    com.google.common.io.Files.write(contents, file, StandardCharsets.UTF_8);    return file;}
public Object metron_f9479_0(List<Object> args, Context context) throws ParseException
{    throw new IllegalStateException(Joiner.on(" ").join(args));}
public void metron_f9480_0(Context context)
{}
public boolean metron_f9481_0()
{    return true;}
public Object metron_f9482_0(List<Object> args, Context context) throws ParseException
{    return true;}
public void metron_f9483_0(Context context)
{}
public boolean metron_f9484_0()
{    return true;}
public void metron_f9485_0()
{    ClassLoader classLoader = getClass().getClassLoader();    int numFound = 0;    for (Class<?> clazz : new ClasspathFunctionResolver().resolvables()) {        if (clazz.isAnnotationPresent(Stellar.class)) {            numFound++;            Stellar annotation = clazz.getAnnotation(Stellar.class);            Assert.assertFalse("Must specify a name for " + clazz.getName(), StringUtils.isEmpty(annotation.name()));            Assert.assertFalse("Must specify a description annotation for " + clazz.getName(), StringUtils.isEmpty(annotation.description()));            Assert.assertFalse("Must specify a returns annotation for " + clazz.getName(), StringUtils.isEmpty(annotation.returns()));        }    }    Assert.assertTrue(numFound > 0);}
public void metron_f9486_0()
{    Assert.assertEquals("'bar'", run("\"'bar'\"", new HashMap<>()));    Assert.assertEquals("'BAR'", run("TO_UPPER('\\'bar\\'')", new HashMap<>()));    Assert.assertEquals("\"bar\"", run("\"\\\"bar\\\"\"", new HashMap<>()));    Assert.assertEquals("\"bar\"", run("'\"bar\"'", new HashMap<>()));    Assert.assertEquals("\"BAR\"", run("TO_UPPER(\"\\\"bar\\\"\")", new HashMap<>()));    Assert.assertEquals("bar \\ foo", run("'bar \\\\ foo'", new HashMap<>()));    Assert.assertEquals("bar \\\\ foo", run("'bar \\\\\\\\ foo'", new HashMap<>()));    Assert.assertEquals("bar\nfoo", run("'bar\\nfoo'", new HashMap<>()));    Assert.assertEquals("bar\n\nfoo", run("'bar\\n\\nfoo'", new HashMap<>()));    Assert.assertEquals("bar\tfoo", run("'bar\\tfoo'", new HashMap<>()));    Assert.assertEquals("bar\t\tfoo", run("'bar\\t\\tfoo'", new HashMap<>()));    Assert.assertEquals("bar\rfoo", run("'bar\\rfoo'", new HashMap<>()));    Assert.assertEquals("'bar'", run("'\\'bar\\''", new HashMap<>()));}
public void metron_f9487_0()
{    {        String query = "bar:variable";        Assert.assertEquals("bar", run(query, ImmutableMap.of("bar:variable", "bar")));        Assert.assertEquals("grok", run(query, ImmutableMap.of("bar:variable", "grok")));    }    {        String query = "JOIN(['foo', bar:variable], '')";        Assert.assertEquals("foobar", run(query, ImmutableMap.of("bar:variable", "bar")));        Assert.assertEquals("foogrok", run(query, ImmutableMap.of("bar:variable", "grok")));    }    {        String query = "MAP_GET('bar', { 'foo' : 1, 'bar' : bar:variable})";        Assert.assertEquals("bar", run(query, ImmutableMap.of("bar:variable", "bar")));        Assert.assertEquals("grok", run(query, ImmutableMap.of("bar:variable", "grok")));    }}
public void metron_f9488_0()
{    String query = "someVar";    run(query, new HashMap<>());}
public void metron_f9489_0()
{    String query = "someVar";    validate(query);}
public void metron_f9490_0()
{    String query = "someVar";    Context context = Context.EMPTY_CONTEXT();    validate(query, context);    Assert.assertNull(context.getActivityType());    run(query, ImmutableMap.of("someVar", "someValue"), context);    Assert.assertNull(context.getActivityType());}
public void metron_f9491_0()
{    String query = "50 + (true == true ? 10 : 20)";    Assert.assertEquals(60, run(query, new HashMap<>()));}
public void metron_f9492_0()
{    String query = "50 + (true == false ? 10 : 20)";    Assert.assertEquals(70, run(query, new HashMap<>()));}
public void metron_f9493_0()
{    String query = "50 * (true == false ? 2 : 10) + 20";    Assert.assertEquals(520, run(query, new HashMap<>()));}
public void metron_f9494_0()
{    String query = "TO_INTEGER(true == true ? 10.0 : 20.0 )";    Assert.assertEquals(10, run(query, new HashMap<>()));}
public void metron_f9495_0()
{    StellarProcessor processor = new StellarProcessor();    {        Assert.assertEquals(new HashSet<>(), processor.variablesUsed("if 1 < 2 then 'one' else 'two'"));    }    {        Assert.assertEquals(ImmutableSet.of("one"), processor.variablesUsed("if 1 < 2 then one else 'two'"));    }    {        Assert.assertEquals(ImmutableSet.of("one", "two"), processor.variablesUsed("if 1 < 2 then one else two"));    }    {        Assert.assertEquals(ImmutableSet.of("bar"), processor.variablesUsed("MAP_GET('foo', { 'foo' : bar})"));    }}
public void metron_f9496_0()
{    {        String query = "{ ( RET_TRUE() && y < 50 ) : 'info', y >= 50 : 'warn'}";        Map<Boolean, String> ret = (Map) run(query, ImmutableMap.of("y", 50));        Assert.assertEquals(ret.size(), 2);        Assert.assertEquals("warn", ret.get(true));        Assert.assertEquals("info", ret.get(false));    }}
public void metron_f9497_0()
{    {        String query = "RET_TRUE(y < 10)";        Assert.assertTrue((boolean) run(query, ImmutableMap.of("y", 50)));    }}
public void metron_f9498_0()
{    {        String query = "STARTS_WITH(casey, 'case') or MAP_EXISTS()";        Assert.assertTrue((Boolean) run(query, ImmutableMap.of("casey", "casey")));    }    {        String query = "true or MAP_EXISTS()";        Assert.assertTrue((Boolean) run(query, new HashMap<>()));    }    {        String query = "MAP_EXISTS() or true";        Assert.assertTrue((Boolean) run(query, new HashMap<>()));    }}
public void metron_f9499_0()
{    {        String query = "if 1 < 2 then NULL else true";        Assert.assertNull(run(query, new HashMap<>()));    }    {        String query = "1 < 2 ? NULL : true";        Assert.assertNull(run(query, new HashMap<>()));    }    {        String query = "null == null ? true : false";        Assert.assertTrue((Boolean) run(query, new HashMap<>()));    }}
public void metron_f9500_0()
{            {        String query = "NaN == NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "5.0 == NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NULL == NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "'metron' == NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }        {        String query = "NaN != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "5 != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "'metron' != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }        {        String query = "NaN > 5";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN < 5";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN >= 5";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN <= 5";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN > NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN < NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN >= NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN <= NaN";        Assert.assertFalse(runPredicate(query, new HashMap<>()));    }        {        String query = "(5 + NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "5 + NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }    {        String query = "(5 - NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "5 - NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }    {        String query = "(5 / NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "5 / NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }    {        String query = "(5 * NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "5 * NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }    {        String query = "(NaN + NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN + NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }    {        String query = "(NaN - NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN - NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }    {        String query = "(NaN * NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN * NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }    {        String query = "(NaN / NaN) != NaN";        Assert.assertTrue(runPredicate(query, new HashMap<>()));    }    {        String query = "NaN / NaN";        Assert.assertTrue(run(query, new HashMap<>()).toString().equals("NaN"));    }}
public void metron_f9501_0()
{    {        String query = "MAP_GET('bar', { 'foo' : 1, 'bar' : 'bar'})";        Assert.assertEquals("bar", run(query, new HashMap<>()));    }    {        String query = "MAP_GET('blah', {  'blah' : 1 < 2 })";        Assert.assertEquals(true, run(query, new HashMap<>()));    }    {        String query = "MAP_GET('blah', {  'blah' : not(STARTS_WITH(casey, 'case')) })";        Assert.assertEquals(false, run(query, ImmutableMap.of("casey", "casey")));    }    {        String query = "MAP_GET('blah', {  'blah' : one })";        Assert.assertEquals(1, run(query, ImmutableMap.of("one", 1)));    }    {        String query = "MAP_GET('blah', {  'blah' : null })";        Assert.assertNull(run(query, new HashMap<>()));    }    {        String query = "MAP_GET('BLAH', {  TO_UPPER('blah') : null })";        Assert.assertNull(run(query, new HashMap<>()));    }    {        String query = "MAP_GET('BLAH', {  TO_UPPER('blah') : 1 < 2 })";        Assert.assertEquals(true, run(query, new HashMap<>()));    }}
public void metron_f9502_0()
{    {        String query = "if STARTS_WITH(casey, 'case') then 'one' else 'two'";        Assert.assertEquals("one", run(query, ImmutableMap.of("casey", "casey")));    }    {        String query = "if 1 < 2 then 'one' else 'two'";        Assert.assertEquals("one", run(query, new HashMap<>()));    }    {        String query = "if 1 + 1 < 2 then 'one' else 'two'";        Assert.assertEquals("two", run(query, new HashMap<>()));    }    {        String query = "if 1 + 1 <= 2 AND 1 + 2 in [3] then 'one' else 'two'";        Assert.assertEquals("one", run(query, new HashMap<>()));    }    {        String query = "if 1 + 1 <= 2 AND (1 + 2 in [3]) then 'one' else 'two'";        Assert.assertEquals("one", run(query, new HashMap<>()));    }    {        String query = "if not(1 < 2) then 'one' else 'two'";        Assert.assertEquals("two", run(query, new HashMap<>()));    }    {        String query = "if 1 == 1.0000001 then 'one' else 'two'";        Assert.assertEquals("two", run(query, new HashMap<>()));    }    {        String query = "if one < two then 'one' else 'two'";        Assert.assertEquals("one", run(query, ImmutableMap.of("one", 1, "two", 2)));    }    {        String query = "if one == very_nearly_one then 'one' else 'two'";        Assert.assertEquals("two", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "if one == very_nearly_one OR one == very_nearly_one then 'one' else 'two'";        Assert.assertEquals("two", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "if one == very_nearly_one OR one != very_nearly_one then 'one' else 'two'";        Assert.assertEquals("one", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "if one != very_nearly_one OR one == very_nearly_one then 'one' else 'two'";        Assert.assertEquals("one", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "if 'foo' in ['foo'] OR one == very_nearly_one then 'one' else 'two'";        Assert.assertEquals("one", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "if ('foo' in ['foo']) OR one == very_nearly_one then 'one' else 'two'";        Assert.assertEquals("one", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "if not('foo' in ['foo']) OR one == very_nearly_one then 'one' else 'two'";        Assert.assertEquals("two", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "if not('foo' in ['foo'] OR one == very_nearly_one) then 'one' else 'two'";        Assert.assertEquals("two", run(query, ImmutableMap.of("one", 1, "very_nearly_one", 1.0000001)));    }    {        String query = "1 < 2 ? 'one' : 'two'";        Assert.assertEquals("one", run(query, new HashMap<>()));    }    {        String query = "1 < 2 ? TO_UPPER('one') : 'two'";        Assert.assertEquals("ONE", run(query, new HashMap<>()));    }    {        String query = "1 < 2 ? one : 'two'";        Assert.assertEquals("one", run(query, ImmutableMap.of("one", "one")));    }    {        String query = "1 < 2 ? one*3 : 'two'";        Assert.assertTrue(Math.abs(3 - (int) run(query, ImmutableMap.of("one", 1))) < 1e-6);    }    {        String query = "1 < 2 AND 1 < 2 ? one*3 : 'two'";        Assert.assertTrue(Math.abs(3 - (int) run(query, ImmutableMap.of("one", 1))) < 1e-6);    }    {        String query = "1 < 2 AND 1 > 2 ? one*3 : 'two'";        Assert.assertEquals("two", run(query, ImmutableMap.of("one", 1)));    }    {        String query = "1 > 2 AND 1 < 2 ? one*3 : 'two'";        Assert.assertEquals("two", run(query, ImmutableMap.of("one", 1)));    }    {        String query = "1 < 2 AND 'foo' in ['', 'foo'] ? one*3 : 'two'";        Assert.assertEquals(3, run(query, ImmutableMap.of("one", 1)));    }    {        String query = "1 < 2 AND ('foo' in ['', 'foo']) ? one*3 : 'two'";        Assert.assertEquals(3, run(query, ImmutableMap.of("one", 1)));    }    {        String query = "'foo' in ['', 'foo'] ? one*3 : 'two'";        Assert.assertEquals(3, run(query, ImmutableMap.of("one", 1)));    }}
public void metron_f9503_0()
{    HashMap variables = new HashMap<>();    boolean thrown = false;    try {        Object o = run("in in ['','in']", variables);    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);    thrown = false;    try {        Assert.assertEquals(true, run("'in' in ['','in']", variables));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertFalse(thrown);}
public void metron_f9504_0()
{    String query = "TO_UPPER(TRIM(foo))";    Assert.assertEquals("CASEY", run(query, ImmutableMap.of("foo", "casey ")));}
public void metron_f9505_0()
{    String query = "LENGTH(foo)";    Assert.assertEquals(5, run(query, ImmutableMap.of("foo", "abcde")));}
public void metron_f9506_0()
{    String query = "LENGTH(foo)";    Collection c = Arrays.asList(1, 2, 3, 4, 5);    Assert.assertEquals(5, run(query, ImmutableMap.of("foo", c)));}
public void metron_f9507_0()
{    String query = "LENGTH(foo)";    Assert.assertEquals(0, run(query, ImmutableMap.of("foo", "")));}
public void metron_f9508_0()
{    String query = "LENGTH(foo)";    Collection c = new ArrayList();    Assert.assertEquals(0, run(query, ImmutableMap.of("foo", c)));}
public void metron_f9509_0()
{    String query = "LENGTH(foo)";    run(query, ImmutableMap.of());}
public void metron_f9510_0()
{    String query = "JOIN( [ TO_UPPER(TRIM(foo)), 'bar' ], ',')";    Assert.assertEquals("CASEY,bar", run(query, ImmutableMap.of("foo", "casey ")));    query = "JOIN( SET_INIT( [ 1, 2, 'buckle', 'my', 'shoe', 3 ] ), ',')";    Assert.assertEquals("1,2,buckle,my,shoe,3", run(query, new HashMap<>()));}
public void metron_f9511_0()
{    String query = "JOIN( SPLIT(foo, ':'), ',')";    Assert.assertEquals("casey,bar", run(query, ImmutableMap.of("foo", "casey:bar")));}
public void metron_f9512_0()
{    String query = "MAP_GET(dc, dc2tz, 'UTC')";    Assert.assertEquals("UTC", run(query, ImmutableMap.of("dc", "nyc", "dc2tz", ImmutableMap.of("la", "PST"))));    Assert.assertEquals("EST", run(query, ImmutableMap.of("dc", "nyc", "dc2tz", ImmutableMap.of("nyc", "EST"))));}
public void metron_f9513_0()
{    Map vars = ImmutableMap.of("mymap", new HashMap<String, String>());    String query = "MAP_PUT('foo','bar',mymap)";    assertThat(run(query, vars), instanceOf(Map.class));    query = "MAP_GET('foo', mymap)";    assertThat(run(query, vars), equalTo("bar"));}
public void metron_f9514_0()
{    Map vars = new HashMap() {        {            put("mymap", null);        }    };    String query = "MAP_PUT('foo','bar', mymap)";    Map result = (Map) run(query, vars);    assertThat(result, instanceOf(Map.class));    assertThat(result.size(), equalTo(1));    assertThat(result.get("foo"), equalTo("bar"));}
public void metron_f9515_0() throws Exception
{    Map s = (Map) run("MAP_PUT( 'foo', 'bar', [ 'baz' ] )", new HashMap<>());}
public void metron_f9516_0()
{    Map m = (Map) StellarProcessorUtils.run("MAP_MERGE([{}, null])", new HashMap<>());    Assert.assertEquals(0, m.size());}
public void metron_f9517_0()
{    Map vars = new HashMap() {        {            put("map1", ImmutableMap.of("a", 1, "b", 2));            put("map2", ImmutableMap.of("c", 3, "d", 4));            put("map3", ImmutableMap.of("e", 5, "f", 6));        }    };    String query = "MAP_MERGE([map1, map2, map3])";    Map result = (Map) run(query, vars);    assertThat(result, instanceOf(Map.class));    assertThat(result.size(), equalTo(6));    assertThat(result.get("a"), equalTo(1));    assertThat(result.get("b"), equalTo(2));    assertThat(result.get("c"), equalTo(3));    assertThat(result.get("d"), equalTo(4));    assertThat(result.get("e"), equalTo(5));    assertThat(result.get("f"), equalTo(6));}
public void metron_f9518_0()
{    String query = "MAP_MERGE( [ { 'a' : '1', 'b' : '2', 'c' : '3' } ] )";    Map result = (Map) run(query, new HashMap<>());    assertThat(result, instanceOf(Map.class));    assertThat(result.size(), equalTo(3));    assertThat(result.get("a"), equalTo("1"));    assertThat(result.get("b"), equalTo("2"));    assertThat(result.get("c"), equalTo("3"));}
public void metron_f9519_0()
{    String query = "MAP_MERGE( [ { 'a' : '1', 'b' : '2' }, { 'c' : '3', 'd' : '4' }, { 'e' : '5', 'f' : '6' } ] )";    Map result = (Map) run(query, new HashMap<>());    assertThat(result, instanceOf(Map.class));    assertThat(result.size(), equalTo(6));    assertThat(result.get("a"), equalTo("1"));    assertThat(result.get("b"), equalTo("2"));    assertThat(result.get("c"), equalTo("3"));    assertThat(result.get("d"), equalTo("4"));    assertThat(result.get("e"), equalTo("5"));    assertThat(result.get("f"), equalTo("6"));}
public void metron_f9520_0()
{    String query = "MAP_MERGE( [ { 'a' : '1', 'b' : 2, 'c' : '3' }, { 'c' : '3b', 'd' : '4' }, { 'd' : '4b', 'e' : 5, 'f' : '6' } ] )";    Map result = (Map) run(query, new HashMap<>());    assertThat(result, instanceOf(Map.class));    assertThat(result.size(), equalTo(6));    assertThat(result.get("a"), equalTo("1"));    assertThat(result.get("b"), equalTo(2));    assertThat(result.get("c"), equalTo("3b"));    assertThat(result.get("d"), equalTo("4b"));    assertThat(result.get("e"), equalTo(5));    assertThat(result.get("f"), equalTo("6"));}
public void metron_f9521_0() throws Exception
{    Map s = (Map) run("MAP_MERGE( [ 'foo', 'bar' ] )", new HashMap<>());}
public void metron_f9522_0()
{    String query = "DOMAIN_TO_TLD(foo)";    Assert.assertEquals("co.uk", run(query, ImmutableMap.of("foo", "www.google.co.uk")));}
public void metron_f9523_0()
{    String query = "DOMAIN_REMOVE_TLD(foo)";    Assert.assertEquals("www.google", run(query, ImmutableMap.of("foo", "www.google.co.uk")));}
public void metron_f9524_0()
{    String query = "DOMAIN_REMOVE_SUBDOMAINS(foo)";    Assert.assertEquals("google.co.uk", run(query, ImmutableMap.of("foo", "www.google.co.uk")));    Assert.assertEquals("google.com", run(query, ImmutableMap.of("foo", "www.google.com")));}
public void metron_f9525_0()
{    String query = "URL_TO_HOST(foo)";    Assert.assertEquals("www.google.co.uk", run(query, ImmutableMap.of("foo", "http://www.google.co.uk/my/path")));}
public void metron_f9526_0()
{    String query = "URL_TO_PORT(foo)";    Assert.assertEquals(80, run(query, ImmutableMap.of("foo", "http://www.google.co.uk/my/path")));}
public void metron_f9527_0()
{    String query = "URL_TO_PROTOCOL(foo)";    Assert.assertEquals("http", run(query, ImmutableMap.of("foo", "http://www.google.co.uk/my/path")));}
public void metron_f9528_0()
{    String query = "URL_TO_PATH(foo)";    Assert.assertEquals("/my/path", run(query, ImmutableMap.of("foo", "http://www.google.co.uk/my/path")));}
public void metron_f9529_0()
{    String query = "PROTOCOL_TO_NAME(protocol)";    Assert.assertEquals("TCP", run(query, ImmutableMap.of("protocol", "6")));    Assert.assertEquals("TCP", run(query, ImmutableMap.of("protocol", 6)));    Assert.assertEquals(null, run(query, ImmutableMap.of("foo", 6)));    Assert.assertEquals("chicken", run(query, ImmutableMap.of("protocol", "chicken")));}
public void metron_f9530_0()
{    long expected = 1452013350000L;    {        String query = "TO_EPOCH_TIMESTAMP(foo, 'yyyy-MM-dd HH:mm:ss', 'UTC')";        Assert.assertEquals(expected, run(query, ImmutableMap.of("foo", "2016-01-05 17:02:30")));    }    {        String query = "TO_EPOCH_TIMESTAMP(foo, 'yyyy-MM-dd HH:mm:ss')";        Long ts = (Long) run(query, ImmutableMap.of("foo", "2016-01-05 17:02:30"));                Assert.assertTrue(Math.abs(ts - expected) < 8.64e+7);    }}
public void metron_f9531_0()
{    Assert.assertEquals("5", run("TO_STRING(foo)", ImmutableMap.of("foo", 5)));}
public void metron_f9532_0()
{    Assert.assertEquals("null", run("TO_STRING(\"null\")", ImmutableMap.of("foo", "null")));}
public void metron_f9533_0()
{    Assert.assertEquals(5, run("TO_INTEGER(foo)", ImmutableMap.of("foo", "5")));    Assert.assertEquals(5, run("TO_INTEGER(foo)", ImmutableMap.of("foo", 5)));}
public void metron_f9534_0()
{    Assert.assertEquals(5.1d, run("TO_DOUBLE(foo)", ImmutableMap.of("foo", 5.1d)));    Assert.assertEquals(5.1d, run("TO_DOUBLE(foo)", ImmutableMap.of("foo", "5.1")));}
public void metron_f9535_0()
{    Map<String, Object> variables = ImmutableMap.of("foo", "www.google.co.uk");    Assert.assertEquals("www", run("GET_FIRST(SPLIT(DOMAIN_REMOVE_TLD(foo), '.'))", variables));    Assert.assertEquals("www", run("GET(SPLIT(DOMAIN_REMOVE_TLD(foo), '.'), 0)", variables));    Assert.assertEquals("google", run("GET_LAST(SPLIT(DOMAIN_REMOVE_TLD(foo), '.'))", variables));    Assert.assertEquals("google", run("GET(SPLIT(DOMAIN_REMOVE_TLD(foo), '.'), 1)", variables));}
public void metron_f9536_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("empty", "");            put("spaced", "metron is great");        }    };    Assert.assertFalse(runPredicate("not('casey' == foo and true)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("not(not('casey' == foo and true))", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("('casey' == foo) && ( false != true )", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("('casey' == foo) and (FALSE == TRUE)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("'casey' == foo and FALSE", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("'casey' == foo and true", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("true", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("TRUE", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9537_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("empty", "");        }    };    Assert.assertTrue(runPredicate("foo in [ 'casey', 'david' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("foo in [ ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in [ foo, 'david' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in [ 'casey', 'david' ] and 'casey' == foo", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in [ 'casey', 'david' ] and foo == 'casey'", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in [ 'casey' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("foo not in [ 'casey', 'david' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("foo not in [ 'casey', 'david' ] and 'casey' == foo", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("null in [ null, 'something' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("null not in [ null, 'something' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9538_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("empty", "");        }    };    Assert.assertTrue(runPredicate("'casey' in { foo : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("'casey' not in { foo : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in { foo : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("foo not in { foo : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("'foo' in { 'foo' : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("'foo' not in { 'foo' : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in { 'casey' : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("foo not in { 'casey' : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("empty in { foo : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("empty not in { foo : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("'foo' in { }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("null in { 'foo' : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("null not in { 'foo' : 5 }", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9539_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>();    Assert.assertTrue(runPredicate("(false && true) || true", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("(false && false) || true", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("(true || true) && false", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9540_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("empty", "");        }    };    Assert.assertTrue(runPredicate("'case' in foo", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("'case' not in foo", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("'case' in empty", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("'case' not in empty", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("'case' in [ foo ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("'case' not in [ foo ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("null in foo", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("null not in foo", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9541_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<>();    Assert.assertTrue(runPredicate("('grok' not in 'foobar') == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("'grok' not in ('foobar' == true)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertFalse(runPredicate("'grok' in 'grokbar' == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("false in 'grokbar' == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("('foo' in 'foobar') == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertFalse(runPredicate("'foo' in ('foobar' == true)", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("'grok' not in 'grokbar' == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("false in 'grokbar' == true", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("'foo' in ['foo'] AND 'bar' in ['bar']", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("('foo' in ['foo']) AND 'bar' in ['bar']", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("'foo' in ['foo'] AND ('bar' in ['bar'])", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("('foo' in ['foo']) AND ('bar' in ['bar'])", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));    Assert.assertTrue(runPredicate("('foo' in ['foo'] AND 'bar' in ['bar'])", new DefaultVariableResolver(variableMap::get, variableMap::containsKey)));}
public void metron_f9542_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("empty", "");            put("spaced", "metron is great");        }    };    Assert.assertTrue(runPredicate("exists(foo)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("exists(bar)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("exists(bar) or true", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9543_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<String, Object>() {        {            put("foo", "casey");            put("bar", "bar.casey.grok");            put("ip", "192.168.0.1");            put("empty", "");            put("spaced", "metron is great");            put("myMap", ImmutableMap.of("casey", "apple"));        }    };    Assert.assertTrue(runPredicate("MAP_EXISTS(foo, myMap)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9544_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("ip", "192.168.0.1");            put("ip_src_addr", "192.168.0.1");            put("ip_dst_addr", "10.0.0.1");            put("other_ip", "10.168.0.1");            put("empty", "");            put("spaced", "metron is great");        }    };    Assert.assertTrue(runPredicate("IN_SUBNET(ip, '192.168.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("IN_SUBNET(ip, '192.168.0.0/24', '11.0.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("IN_SUBNET(ip, '192.168.0.0/24', '11.0.0.0/24') in [true]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("true in IN_SUBNET(ip, '192.168.0.0/24', '11.0.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IN_SUBNET(ip_dst_addr, '192.168.0.0/24', '11.0.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IN_SUBNET(other_ip, '192.168.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    boolean thrown = false;    try {        runPredicate("IN_SUBNET(blah, '192.168.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v)));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);    Assert.assertTrue(runPredicate("true and STARTS_WITH(foo, 'ca')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("true and STARTS_WITH(TO_UPPER(foo), 'CA')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("(true and STARTS_WITH(TO_UPPER(foo), 'CA')) || true", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("true and ENDS_WITH(foo, 'sey')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("not(IN_SUBNET(ip_src_addr, '192.168.0.0/24') and IN_SUBNET(ip_dst_addr, '192.168.0.0/24'))", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("IN_SUBNET(ip_src_addr, '192.168.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("not(IN_SUBNET(ip_src_addr, '192.168.0.0/24'))", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IN_SUBNET(ip_dst_addr, '192.168.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("not(IN_SUBNET(ip_dst_addr, '192.168.0.0/24'))", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9545_0() throws Exception
{    Assert.assertEquals("foo", run("if true then 'foo' else (if false then 'bar' else 'grok')", new HashMap<>()));    Assert.assertEquals("foo", run("if true_var != null && true_var then 'foo' else (if false then 'bar' else 'grok')", ImmutableMap.of("true_var", true)));    Assert.assertEquals("foo", run("if true then 'foo' else THROW('expression')", new HashMap<>()));    Assert.assertEquals("foo", run("true ? 'foo' : THROW('expression')", new HashMap<>()));    Assert.assertEquals("foo", run("if false then THROW('exception') else 'foo'", new HashMap<>()));    Assert.assertEquals("foo", run("false ? THROW('exception') : 'foo'", new HashMap<>()));    Assert.assertEquals(true, run("RET_TRUE(if true then 'foo' else THROW('expression'))", new HashMap<>()));    Assert.assertEquals("foo", run("if true or (true or THROW('if exception')) then 'foo' else THROW('expression')", new HashMap<>()));    Assert.assertEquals("foo", run("if true or (false or THROW('if exception')) then 'foo' else THROW('expression')", new HashMap<>()));    Assert.assertEquals("foo", run("if NOT(true or (false or THROW('if exception'))) then THROW('expression') else 'foo'", new HashMap<>()));    Assert.assertEquals("foo", run("if NOT('metron' in [ 'metron', 'metronicus'] ) then THROW('expression') else 'foo'", new HashMap<>()));}
public void metron_f9546_0() throws Exception
{                            Assert.assertEquals("a", run("IF true THEN IF true THEN 'a' ELSE 'b' ELSE 'c'", new HashMap<>()));    Assert.assertEquals("b", run("IF true THEN IF false THEN 'a' ELSE 'b' ELSE 'c'", new HashMap<>()));    Assert.assertEquals("c", run("IF false THEN IF false THEN 'a' ELSE 'b' ELSE 'c'", new HashMap<>()));                                    Assert.assertEquals("a", run("IF true THEN IF true THEN IF true THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("b", run("IF true THEN IF true THEN IF false THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("c", run("IF true THEN IF false THEN IF true THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("c", run("IF true THEN IF false THEN IF false THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF true THEN IF true THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF true THEN IF false THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF false THEN IF true THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF false THEN IF false THEN 'a' ELSE 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));                                    Assert.assertEquals("a", run("IF true THEN IF true THEN 'a' ELSE IF true THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("a", run("IF true THEN IF true THEN 'a' ELSE IF false THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("b", run("IF true THEN IF false THEN 'a' ELSE IF true THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("c", run("IF true THEN IF false THEN 'a' ELSE IF false THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF true THEN 'a' ELSE IF true THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF true THEN 'a' ELSE IF false THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF false THEN 'a' ELSE IF true THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));    Assert.assertEquals("d", run("IF false THEN IF false THEN 'a' ELSE IF false THEN 'b' ELSE 'c' ELSE 'd'", new HashMap<>()));}
public void metron_f9547_0()
{                            Assert.assertEquals("less", run("IF TO_UPPER('foo') == 'FOO' THEN IF GET_FIRST(MAP(['test_true'], x -> TO_UPPER(x))) == 'TEST_TRUE' THEN match{ var1 < 10 => 'less', var1 >= 12 => 'more', default => 'default'} ELSE 'b' ELSE 'c'", Collections.singletonMap("var1", 1)));    Assert.assertEquals("default", run("IF TO_UPPER('foo') == 'FOO' THEN IF GET_FIRST(MAP(['test_true'], x -> TO_UPPER(x))) == 'TEST_TRUE' THEN match{ var1 < 10 => 'less', var1 >= 12 => 'more', default => 'default'} ELSE 'b' ELSE 'c'", Collections.singletonMap("var1", 11)));    Assert.assertEquals("more", run("IF TO_UPPER('foo') == 'FOO' THEN IF GET_FIRST(MAP(['test_true'], x -> TO_UPPER(x))) == 'TEST_TRUE' THEN match{ var1 < 10 => 'less', var1 >= 12 => 'more', default => 'default'} ELSE 'b' ELSE 'c'", Collections.singletonMap("var1", 100)));        Assert.assertEquals("c", run("IF TO_UPPER('bar') == 'FOO' THEN IF GET_FIRST(MAP(['test_true'], x -> TO_UPPER(x))) == 'TEST_TRUE' THEN match{ var1 < 10 => 'less', var1 >= 12 => 'more', default => 'default'} ELSE 'b' ELSE 'c'", Collections.singletonMap("var1", 1)));        Assert.assertEquals("b", run("IF TO_UPPER('foo') == 'FOO' THEN IF GET_FIRST(MAP(['test_false'], x -> TO_UPPER(x))) == 'TEST_TRUE' THEN match{ var1 < 10 => 'less', var1 >= 12 => 'more', default => 'default'} ELSE 'b' ELSE 'c'", Collections.singletonMap("var1", 1)));}
public void metron_f9548_0() throws Exception
{    Assert.assertTrue(runPredicate("'metron' in ['metron', 'metronicus', 'mortron'] or (true or THROW('exception'))", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("true or (true or THROW('exception'))", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("true or (false or THROW('exception'))", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("TO_UPPER('foo') == 'FOO' or (true or THROW('exception'))", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertFalse(runPredicate("false and (true or THROW('exception'))", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("true or false or false or true", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertFalse(runPredicate("false or (false and THROW('exception'))", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("'casey' == 'casey' or THROW('exception')", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("TO_UPPER('casey') == 'CASEY' or THROW('exception')", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("NOT(TO_UPPER('casey') != 'CASEY') or THROW('exception')", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("(TO_UPPER('casey') == 'CASEY') or THROW('exception')", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertFalse(runPredicate("NOT(NOT(TO_UPPER('casey') != 'CASEY') or THROW('exception'))", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertFalse(runPredicate("NOT(NOT(TO_UPPER('casey') != 'CASEY')) and THROW('exception')", new DefaultVariableResolver(x -> null, x -> false)));    Assert.assertTrue(runPredicate("RET_TRUE('foo') or THROW('exception')", new DefaultVariableResolver(x -> null, x -> false)));    boolean thrown = false;    try {        runPredicate("NOT(foo == null or THROW('exception')) and THROW('and exception')", new DefaultVariableResolver(x -> null, x -> false));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);    thrown = false;    try {        runPredicate("(foo == null or THROW('exception') ) or THROW('and exception')", new DefaultVariableResolver(x -> null, x -> false));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);    Assert.assertTrue(runPredicate("( RET_TRUE('foo', true, false) or ( foo == null or THROW('exception') ) or THROW('and exception')) or THROW('or exception')", new DefaultVariableResolver(x -> null, x -> false)));}
public void metron_f9549_0()
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("protocol", "http");        }    };    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage("The rule 'TO_UPPER(protocol)' does not return a boolean value.");    runPredicate("TO_UPPER(protocol)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v)));}
public void metron_f9550_0()
{    final Map<String, Object> varMap1 = new HashMap<String, Object>();    varMap1.put("field1", "val1");    final Map<String, Object> varMap2 = new HashMap<String, Object>();    varMap2.put("field2", "val2");    VariableResolver resolver = new MapVariableResolver(varMap1, varMap2);    Assert.assertTrue(runPredicate("MAP_GET('field1', _) == 'val1'", resolver));    Assert.assertTrue(runPredicate("MAP_GET('field2', _) == 'val2'", resolver));    Assert.assertTrue(runPredicate("LENGTH(_) == 2", resolver));    Map<String, Object> ret = (Map<String, Object>) run("_", resolver);    Assert.assertEquals(2, ret.size());    Assert.assertEquals("val1", ret.get("field1"));    Assert.assertEquals("val2", ret.get("field2"));}
public void metron_f9551_0()
{    checkFalsey("is_alert");}
private void metron_f9552_0(String falseyExpr)
{    VariableResolver resolver = new MapVariableResolver(new HashMap<>());    Assert.assertTrue(runPredicate(String.format(" %s || true", falseyExpr), resolver));    Assert.assertFalse(runPredicate(String.format("%s && EXCEPTION('blah')", falseyExpr), resolver));    Assert.assertTrue(runPredicate(String.format("NOT(%s)", falseyExpr), resolver));    Assert.assertFalse(runPredicate(String.format("if %s then true else false", falseyExpr), resolver));    Assert.assertFalse(runPredicate(String.format("if %s then true || %s else false", falseyExpr, falseyExpr), resolver));    Assert.assertFalse(runPredicate(String.format("if %s then true || %s else false && %s", falseyExpr, falseyExpr, falseyExpr), resolver));    Assert.assertFalse(runPredicate(String.format("if %s then true || %s else false && (%s || true)", falseyExpr, falseyExpr, falseyExpr), resolver));        Assert.assertNull(run(String.format("MAP_GET(%s, {false : 'blah'})", falseyExpr), resolver));}
public void metron_f9553_0()
{    checkFalsey("[]");    checkFalsey("{}");    checkFalsey("LIST_ADD([])");}
public void metron_f9554_0() throws Exception
{    assertEquals(1D, new ConversionFunctions.TO_DOUBLE().apply(Collections.singletonList(1)));    assertEquals(1F, new ConversionFunctions.TO_FLOAT().apply(Collections.singletonList(1.0D)));    assertEquals(1, new ConversionFunctions.TO_INTEGER().apply(Collections.singletonList(1.0D)));    assertEquals(1L, new ConversionFunctions.TO_LONG().apply(Collections.singletonList(1F)));}
public void metron_f9555_0() throws Exception
{    assertEquals(null, new ConversionFunctions.TO_DOUBLE().apply(Collections.singletonList(null)));    assertEquals(null, new ConversionFunctions.TO_FLOAT().apply(Collections.singletonList(null)));    assertEquals(null, new ConversionFunctions.TO_INTEGER().apply(Collections.singletonList(null)));    assertEquals(null, new ConversionFunctions.TO_LONG().apply(Collections.singletonList(null)));}
public void metron_f9556_0()
{    DataStructureFunctions.IsEmpty isEmpty = new DataStructureFunctions.IsEmpty();    {        boolean empty = (boolean) isEmpty.apply(ImmutableList.of("hello"));        Assert.assertThat("should be false", empty, CoreMatchers.equalTo(false));    }    {        boolean empty = (boolean) isEmpty.apply(ImmutableList.of(ImmutableList.of("hello", "world")));        Assert.assertThat("should be false", empty, CoreMatchers.equalTo(false));    }    {        boolean empty = (boolean) isEmpty.apply(ImmutableList.of(1));        Assert.assertThat("should be false", empty, CoreMatchers.equalTo(false));    }    {        boolean empty = (boolean) isEmpty.apply(ImmutableList.of(ImmutableMap.of("mykey", "myvalue")));        Assert.assertThat("should be false", empty, CoreMatchers.equalTo(false));    }}
public void metron_f9557_0()
{    DataStructureFunctions.IsEmpty isEmpty = new DataStructureFunctions.IsEmpty();    {        boolean empty = (boolean) isEmpty.apply(ImmutableList.of());        Assert.assertThat("should be true", empty, CoreMatchers.equalTo(true));    }    {        boolean empty = (boolean) isEmpty.apply(null);        Assert.assertThat("should be true", empty, CoreMatchers.equalTo(true));    }    {        boolean empty = (boolean) isEmpty.apply(ImmutableList.of(""));        Assert.assertThat("should be true", empty, CoreMatchers.equalTo(true));    }    {        boolean empty = (boolean) isEmpty.apply(ImmutableList.of(ImmutableMap.of()));        Assert.assertThat("should be true", empty, CoreMatchers.equalTo(true));    }}
public void metron_f9558_0()
{    for (String expr : ImmutableList.of("LIST_ADD(my_list, 1)", "LIST_ADD([], 1)", "LIST_ADD([], val)")) {        Object o = run(expr, ImmutableMap.of("my_list", new ArrayList<>(), "val", 1));        Assert.assertTrue(o instanceof List);        List<Number> result = (List<Number>) o;        Assert.assertEquals(1, result.size());        Assert.assertEquals(1, result.get(0));    }}
public void metron_f9559_0()
{    for (String expr : ImmutableList.of("LIST_ADD(my_list, 1)", "LIST_ADD(['foo'], 1)", "LIST_ADD(['foo'], val)")) {        ArrayList<Object> list = new ArrayList<>();        list.add("foo");        Object o = run(expr, ImmutableMap.of("my_list", list, "val", 1));        Assert.assertTrue(o instanceof List);        List<Object> result = (List<Object>) o;        Assert.assertEquals(2, result.size());        Assert.assertEquals("foo", result.get(0));        Assert.assertEquals(1, result.get(1));    }}
public void metron_f9560_0()
{    for (String expr : ImmutableList.of("LIST_ADD(my_list, 2)", "LIST_ADD([1], 2)", "LIST_ADD([1], val)")) {        ArrayList<Integer> list = new ArrayList<>();        list.add(1);        Object o = run(expr, ImmutableMap.of("my_list", list, "val", 2));        Assert.assertTrue(o instanceof List);        List<Number> result = (List<Number>) o;        Assert.assertEquals(2, result.size());        Assert.assertEquals(1, result.get(0));        Assert.assertEquals(2, result.get(1));    }}
private Object metron_f9561_0(String expr)
{    StellarProcessor processor = new StellarProcessor();    assertTrue(processor.validate(expr));    return processor.parse(expr, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());}
public void metron_f9562_0()
{    variables.put("test_datetime", AUG2016);    calendar = Calendar.getInstance();}
public void metron_f9563_0()
{    Object result = run("DAY_OF_WEEK(test_datetime)");    assertEquals(Calendar.THURSDAY, result);}
public void metron_f9564_0()
{    Object result = run("DAY_OF_WEEK()");    assertEquals(calendar.get(Calendar.DAY_OF_WEEK), result);}
public void metron_f9565_0()
{    Object result = run("DAY_OF_WEEK(nada)");}
public void metron_f9566_0()
{    Object result = run("WEEK_OF_MONTH(test_datetime)");    assertEquals(4, result);}
public void metron_f9567_0()
{    Object result = run("WEEK_OF_MONTH()");    assertEquals(calendar.get(Calendar.WEEK_OF_MONTH), result);}
public void metron_f9568_0()
{    Object result = run("WEEK_OF_MONTH(nada)");}
public void metron_f9569_0()
{    Object result = run("MONTH(test_datetime)");    assertEquals(Calendar.AUGUST, result);}
public void metron_f9570_0()
{    Object result = run("MONTH()");    assertEquals(calendar.get(Calendar.MONTH), result);}
public void metron_f9571_0()
{    Object result = run("MONTH(nada)");}
public void metron_f9572_0()
{    Object result = run("YEAR(test_datetime)");    assertEquals(2016, result);}
public void metron_f9573_0()
{    Object result = run("YEAR()");    assertEquals(calendar.get(Calendar.YEAR), result);}
public void metron_f9574_0()
{    Object result = run("YEAR(nada)");}
public void metron_f9575_0()
{    Object result = run("DAY_OF_MONTH(test_datetime)");    assertEquals(25, result);}
public void metron_f9576_0()
{    Object result = run("DAY_OF_MONTH()");    assertEquals(calendar.get(Calendar.DAY_OF_MONTH), result);}
public void metron_f9577_0()
{    Object result = run("DAY_OF_MONTH(nada)");}
public void metron_f9578_0()
{    Object result = run("WEEK_OF_YEAR(test_datetime)");    calendar.setTimeInMillis(AUG2016);    assertEquals(calendar.get(Calendar.WEEK_OF_YEAR), result);}
public void metron_f9579_0()
{    Object result = run("WEEK_OF_YEAR()");    assertEquals(calendar.get(Calendar.WEEK_OF_YEAR), result);}
public void metron_f9580_0()
{    Object result = run("WEEK_OF_YEAR(nada)");}
public void metron_f9581_0()
{    Object result = run("DAY_OF_YEAR(test_datetime)");    assertEquals(238, result);}
public void metron_f9582_0()
{    Object result = run("DAY_OF_YEAR()");    assertEquals(calendar.get(Calendar.DAY_OF_YEAR), result);}
public void metron_f9583_0()
{    Object result = run("DAY_OF_YEAR(nada)");}
public void metron_f9584_0()
{    Object result = run("DATE_FORMAT('EEE MMM dd yyyy hh:mm:ss zzz', test_datetime, 'EST')");    assertEquals("Thu Aug 25 2016 08:27:10 EST", result);}
public void metron_f9585_0() throws Exception
{    Object result = run("DATE_FORMAT('EEE MMM dd yyyy hh:mm:ss zzzz')");    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("EEE MMM dd yyyy hh:mm:ss zzzz");    LocalDate.parse(result.toString(), formatter);}
public void metron_f9586_0()
{    Object result = run("DATE_FORMAT('EEE MMM dd yyyy hh:mm:ss zzz', 'GMT')");    assertTrue(result.toString().endsWith("GMT"));}
public void metron_f9587_0()
{    Object result = run("DATE_FORMAT('EEE MMM dd yyyy hh:mm:ss zzzz', test_datetime)");    boolean inDaylightSavings = ZoneId.of(TimeZone.getDefault().getID()).getRules().isDaylightSavings(Instant.ofEpochMilli(AUG2016));    assertTrue(result.toString().endsWith(TimeZone.getDefault().getDisplayName(inDaylightSavings, 1)));}
public void metron_f9588_0()
{    Object result = run("DATE_FORMAT('EEE MMM dd yyyy hh:mm:ss zzz', nada, 'EST')");}
public void metron_f9589_0()
{    Object result = run("DATE_FORMAT('INVALID DATE FORMAT', test_datetime, 'EST')");}
public void metron_f9590_0() throws Exception
{    Object ret = run("GET_SUPPORTED_ENCODINGS()", new HashMap());    Assert.assertTrue(ret instanceof List);    List<String> list = (List<String>) ret;    List<String> expected = new ArrayList<>(Arrays.asList("BASE32", "BASE32HEX", "BASE64", "BINARY", "HEX"));    Assert.assertTrue(ListUtils.isEqualList(expected, list));}
public void metron_f9591_0() throws Exception
{    Assert.assertTrue(runPredicate("IS_ENCODING(BASE32_FIXTURE,'BASE32')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IS_ENCODING(STRING_FIXTURE,'BASE32')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("IS_ENCODING(BASE32HEX_FIXTURE,'BASE32HEX')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IS_ENCODING(STRING_FIXTURE,'BASE32HEX')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("IS_ENCODING(BASE64_FIXTURE,'BASE64')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IS_ENCODING(STRING_FIXTURE_PLUS_NULL,'BASE64')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("IS_ENCODING(BINARY_FIXTURE,'BINARY')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IS_ENCODING(STRING_FIXTURE,'BINARY')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("IS_ENCODING(HEX_FIXTURE,'HEX')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("IS_ENCODING(STRING_FIXTURE,'HEX')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9592_0() throws Exception
{    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BASE32_FIXTURE,'BASE32')", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BASE32HEX_FIXTURE,'BASE32HEX')", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BASE64_FIXTURE,'BASE64')", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BINARY_FIXTURE,'BINARY')", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(HEX_FIXTURE,'HEX')", variableMap));        Assert.assertNotEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BASE32')", variableMap));    Assert.assertNotEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BASE32HEX')", variableMap));    Assert.assertNotEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BASE64')", variableMap));            Assert.assertEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BINARY')", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE, 'HEX')", variableMap));}
public void metron_f9593_0() throws Exception
{    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BASE32_FIXTURE,'BASE32',true)", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BASE32HEX_FIXTURE,'BASE32HEX',true)", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BASE64_FIXTURE,'BASE64',true)", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(BINARY_FIXTURE,'BINARY',true)", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(HEX_FIXTURE,'HEX',true)", variableMap));        Assert.assertEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BASE32',true)", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BASE32HEX',true)", variableMap));        Assert.assertNotEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BASE64',true)", variableMap));        Assert.assertEquals(STRING_FIXTURE_PLUS_NULL, run("DECODE(STRING_FIXTURE_PLUS_NULL,'BASE64',true)", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'BINARY',true)", variableMap));    Assert.assertEquals(STRING_FIXTURE, run("DECODE(STRING_FIXTURE,'HEX',true)", variableMap));}
public void metron_f9594_0() throws Exception
{    Assert.assertEquals(BASE32_FIXTURE, run("ENCODE(STRING_FIXTURE,'BASE32')", variableMap));    Assert.assertEquals(BASE32HEX_FIXTURE, run("ENCODE(STRING_FIXTURE,'BASE32HEX')", variableMap));    Assert.assertEquals(BASE64_FIXTURE, run("ENCODE(STRING_FIXTURE,'BASE64')", variableMap));    Assert.assertEquals(BINARY_FIXTURE, run("ENCODE(STRING_FIXTURE,'BINARY')", variableMap));    Assert.assertEquals(HEX_FIXTURE, run("ENCODE(STRING_FIXTURE,'HEX')", variableMap));}
public void metron_f9595_0()
{    for (String expr : ImmutableList.of("ZIP_LONGEST()", "ZIP_LONGEST( null, null )", "ZIP_LONGEST( [], null )", "ZIP_LONGEST( [], [] )", "ZIP_LONGEST( null, [] )")) {        List<List<Object>> o = (List<List<Object>>) run(expr, new HashMap<>());        Assert.assertEquals(0, o.size());    }}
public void metron_f9596_0()
{    Map<String, Object> variables = ImmutableMap.of("list1", ImmutableList.of(1, 2, 3), "list2", ImmutableList.of(4, 5, 6, 7));    for (String expr : ImmutableList.of("ZIP_LONGEST(list1)", "ZIP_LONGEST( [1, 2, 3])")) {        List<List<Object>> o = (List<List<Object>>) run(expr, variables);        Assert.assertEquals(3, o.size());        for (int i = 0; i < 3; ++i) {            List l = o.get(i);            Assert.assertEquals(1, l.size());            Assert.assertEquals(i + 1, l.get(0));        }    }    for (String expr : ImmutableList.of("ZIP_LONGEST(list1, list2)", "ZIP_LONGEST( [1, 2, 3], [4, 5, 6, 7] )")) {        List<List<Object>> o = (List<List<Object>>) run(expr, variables);        Assert.assertEquals(4, o.size());        for (int i = 0; i < 3; ++i) {            List l = o.get(i);            Assert.assertEquals(2, l.size());            Assert.assertEquals(i + 1, l.get(0));            Assert.assertEquals(i + 4, l.get(1));        }        {            int i = 3;            List l = o.get(i);            Assert.assertEquals(2, l.size());            Assert.assertNull(l.get(0));            Assert.assertEquals(i + 4, l.get(1));        }    }    for (String expr : ImmutableList.of("REDUCE(ZIP_LONGEST(list2, list1), (s, x) -> s + GET_FIRST(x) * GET_LAST(x), 0)", "REDUCE(ZIP_LONGEST( [1, 2, 3], [4, 5, 6, 7] ), (s, x) -> s + GET_FIRST(x) * GET_LAST(x), 0)",     "REDUCE(ZIP_LONGEST(list1, list2), (s, x) -> s + GET_FIRST(x) * GET_LAST(x), 0)",     "REDUCE(ZIP_LONGEST(list1, list2), (s, x) -> s + (GET_FIRST(x) == null?0:GET_FIRST(x)) * (GET_LAST(x) == null?0:GET_LAST(x)), 0)")) {        int o = (int) run(expr, variables);        Assert.assertEquals(1 * 4 + 2 * 5 + 3 * 6, o, 1e-7);    }}
public void metron_f9597_0()
{    for (String expr : ImmutableList.of("ZIP()", "ZIP( null, null )", "ZIP( [], null )", "ZIP( [], [] )", "ZIP( null, [] )")) {        List<List<Object>> o = (List<List<Object>>) run(expr, new HashMap<>());        Assert.assertEquals(0, o.size());    }}
public void metron_f9598_0()
{    Map<String, Object> variables = ImmutableMap.of("list1", ImmutableList.of(1, 2, 3), "list2", ImmutableList.of(4, 5, 6));    for (String expr : ImmutableList.of("ZIP(list1)", "ZIP( [1, 2, 3])")) {        List<List<Object>> o = (List<List<Object>>) run(expr, variables);        Assert.assertEquals(3, o.size());        for (int i = 0; i < 3; ++i) {            List l = o.get(i);            Assert.assertEquals(1, l.size());            Assert.assertEquals(i + 1, l.get(0));        }    }    for (String expr : ImmutableList.of("ZIP(list1, list2)", "ZIP( [1, 2, 3], [4, 5, 6] )", "ZIP( [1, 2, 3], [4, 5, 6, 7] )")) {        List<List<Object>> o = (List<List<Object>>) run(expr, variables);        Assert.assertEquals(3, o.size());        for (int i = 0; i < 3; ++i) {            List l = o.get(i);            Assert.assertEquals(2, l.size());            Assert.assertEquals(i + 1, l.get(0));            Assert.assertEquals(i + 4, l.get(1));        }    }    for (String expr : ImmutableList.of("REDUCE(ZIP(list1, list2), (s, x) -> s + GET_FIRST(x) * GET_LAST(x), 0)", "REDUCE(ZIP( [1, 2, 3], [4, 5, 6] ), (s, x) -> s + GET_FIRST(x) * GET_LAST(x), 0)", "REDUCE(ZIP( [1, 2, 3], [4, 5, 6, 7] ), (s, x) -> s + GET_FIRST(x) * GET_LAST(x), 0)")) {        int o = (int) run(expr, variables);        Assert.assertEquals(1 * 4 + 2 * 5 + 3 * 6, o, 1e-7);    }}
public void metron_f9599_0()
{    for (String expr : ImmutableList.of("MAP(list, inner_list -> REDUCE(inner_list, (x, y) -> x + y, 0) )", "MAP(list, (inner_list) -> REDUCE(inner_list, (x, y) -> x + y, 0) )")) {        Object o = run(expr, ImmutableMap.of("list", ImmutableList.of(ImmutableList.of(1, 2, 3), ImmutableList.of(4, 5, 6))));        Assert.assertTrue(o instanceof List);        List<Number> result = (List<Number>) o;        Assert.assertEquals(2, result.size());        Assert.assertEquals(6, result.get(0));        Assert.assertEquals(15, result.get(1));    }}
public void metron_f9600_0()
{    for (String expr : ImmutableList.of("MAP([ 1, 2, null], x -> if x == null then 0 else 2*x )", "MAP([ 1, 2, null], x -> x == null ? 0 : 2*x )", "MAP([ 1, foo, baz], x -> x == null ? 0 : 2*x )")) {        Map<String, Object> variableMap = new HashMap<String, Object>() {            {                put("foo", 2);                put("bar", 3);                put("baz", null);            }        };        Object o = run(expr, variableMap);        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(3, result.size());        Assert.assertEquals(2, result.get(0));        Assert.assertEquals(4, result.get(1));        Assert.assertEquals(0, result.get(2));    }}
public void metron_f9601_0()
{    for (String expr : ImmutableList.of("MAP([ 'foo', 'bar'], (x) -> TO_UPPER(x) )", "MAP([ foo, 'bar'], (x) -> TO_UPPER(x) )", "MAP([ foo, bar], (x) -> TO_UPPER(x) )", "MAP([ foo, bar], x -> TO_UPPER(x) )", "MAP([ foo, bar], x -> true?TO_UPPER(x):THROW('error') )", "MAP([ foo, bar], x -> false?THROW('error'):TO_UPPER(x) )")) {        Object o = run(expr, ImmutableMap.of("foo", "foo", "bar", "bar"));        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(2, result.size());        Assert.assertEquals("FOO", result.get(0));        Assert.assertEquals("BAR", result.get(1));    }}
public void metron_f9602_0()
{    for (String expr : ImmutableList.of("MAP([ 'foo', 'bar'], (item) -> item == 'foo' )", "MAP([ foo, bar], (item) -> item == 'foo' )", "MAP([ foo, bar], (item) -> item == foo )", "MAP([ foo, bar], item -> item == foo )")) {        Object o = run(expr, ImmutableMap.of("foo", "foo", "bar", "bar"));        Assert.assertTrue(o instanceof List);        List<Boolean> result = (List<Boolean>) o;        Assert.assertEquals(2, result.size());        Assert.assertEquals(true, result.get(0));        Assert.assertEquals(false, result.get(1));    }}
public void metron_f9603_0()
{    for (String expr : ImmutableList.of("FILTER([ 'foo', 'bar'], (item) -> item == 'foo' )", "FILTER([ 'foo', bar], (item) -> item == 'foo' )", "FILTER([ foo, bar], (item) -> item == 'foo' )", "FILTER([ foo, bar], (item) -> (item == 'foo' && true) )", "FILTER([ foo, bar], (item) -> if item == 'foo' then true else false )", "FILTER([ foo, bar], item -> if item == 'foo' then true else false )")) {        Object o = run(expr, ImmutableMap.of("foo", "foo", "bar", "bar"));        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(1, result.size());        Assert.assertEquals("foo", result.get(0));    }}
public void metron_f9604_0()
{    for (String expr : ImmutableList.of("FILTER([ 'foo'], item -> item == 'foo' or THROW('exception') )", "FILTER([ 'foo'], (item) -> item == 'foo' or THROW('exception') )")) {        Object o = run(expr, ImmutableMap.of("foo", "foo", "bar", "bar"));        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(1, result.size());        Assert.assertEquals("foo", result.get(0));    }}
public void metron_f9605_0()
{    for (String expr : ImmutableList.of("FILTER([ 'foo', null], item -> item == null )", "FILTER([ 'foo', baz], (item) -> item == null )")) {        Map<String, Object> variableMap = new HashMap<String, Object>() {            {                put("foo", "foo");                put("bar", "bar");                put("baz", null);            }        };        Object o = run(expr, variableMap);        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(1, result.size());        Assert.assertEquals(null, result.get(0));    }}
public void metron_f9606_0()
{    for (String expr : ImmutableList.of("FILTER([ 'foo', null], item -> item != null )", "FILTER([ 'foo', baz], (item) -> item != null )", "FILTER([ foo, baz], (item) -> item != null )")) {        Map<String, Object> variableMap = new HashMap<String, Object>() {            {                put("foo", "foo");                put("bar", "bar");                put("baz", null);            }        };        Object o = run(expr, variableMap);        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(1, result.size());        Assert.assertEquals("foo", result.get(0));    }}
public void metron_f9607_0()
{    for (String expr : ImmutableList.of("FILTER([ foo, bar], () -> false  )", "FILTER([ 'foo', 'bar'], (item)-> false )", "FILTER([ 'foo', bar], (item ) -> false )", "FILTER([ foo, bar], (item) -> false )", "FILTER([ foo, bar], item -> false )")) {        Object o = run(expr, ImmutableMap.of("foo", "foo", "bar", "bar"));        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(0, result.size());    }}
public void metron_f9608_0()
{    for (String expr : ImmutableList.of("FILTER([ 'foo', 'bar'], (item) -> true )", "FILTER([ 'foo', bar], (item) -> true )", "FILTER([ foo, bar], (item) -> true )", "FILTER([ foo, bar], item -> true )", "FILTER([ foo, bar], ()-> true )")) {        Object o = run(expr, ImmutableMap.of("foo", "foo", "bar", "bar"));        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(2, result.size());        Assert.assertEquals("foo", result.get(0));        Assert.assertEquals("bar", result.get(1));    }}
public void metron_f9609_0()
{    for (String expr : ImmutableList.of("REDUCE([ 1, 2, 3, null], (x, y) -> if y != null then x + y else x , 0 )", "REDUCE([ foo, bar, 3, baz], (sum, y) -> if y != null then sum + y else sum, 0 )")) {        Map<String, Object> variableMap = new HashMap<String, Object>() {            {                put("foo", 1);                put("bar", 2);                put("baz", null);            }        };        Object o = run(expr, variableMap);        Assert.assertTrue(o instanceof Number);        Number result = (Number) o;        Assert.assertEquals(6, result.intValue());    }}
public void metron_f9610_0()
{    for (String expr : ImmutableList.of("REDUCE([ 1, 2, 3 ], (x, y) -> x + y , 0 )", "REDUCE([ foo, bar, 3 ], (x, y) -> x + y , 0 )")) {        Object o = run(expr, ImmutableMap.of("foo", 1, "bar", 2));        Assert.assertTrue(o instanceof Number);        Number result = (Number) o;        Assert.assertEquals(6, result.intValue());    }}
public void metron_f9611_0()
{    {        String expr = "REDUCE([ 1, 2, 3, 4 ], (x, y) -> x + y , 0 )";        Object o = run(expr, ImmutableMap.of());        Assert.assertTrue(o instanceof Number);        Number result = (Number) o;        Assert.assertEquals(10, result.intValue());    }    {        String expr = "REDUCE([ 1, 2 ], (x, y) -> x + y , 0 )";        Object o = run(expr, ImmutableMap.of());        Assert.assertTrue(o instanceof Number);        Number result = (Number) o;        Assert.assertEquals(3, result.intValue());    }    {        String expr = "REDUCE([ 1 ], (x, y) -> x + y , 0 )";        Object o = run(expr, ImmutableMap.of());        Assert.assertTrue(o instanceof Number);        Number result = (Number) o;        Assert.assertEquals(1, result.intValue());    }}
public void metron_f9612_0()
{    for (String expr : ImmutableList.of("REDUCE([ 'foo', 'bar', 'grok'], (x, y) -> LIST_ADD(x, y), [] )")) {        Object o = run(expr, ImmutableMap.of("foo", 1, "bar", 2, "x", 0, "y", 0));        Assert.assertTrue(o instanceof List);        List<String> result = (List<String>) o;        Assert.assertEquals(3, result.size());        Assert.assertEquals("foo", result.get(0));        Assert.assertEquals("bar", result.get(1));        Assert.assertEquals("grok", result.get(2));    }}
public void metron_f9613_0()
{    {        String expr = "REDUCE([ 1, 2, 3 ], (x, y) -> LIST_ADD(x, y))";        Assert.assertThat(run(expr, ImmutableMap.of()), CoreMatchers.equalTo(null));    }    {        String expr = "REDUCE([ 1, 2, 3 ])";        Assert.assertThat(run(expr, ImmutableMap.of()), CoreMatchers.equalTo(null));    }}
public void metron_f9614_0() throws Exception
{    listSupportedHashTypes.apply(null);}
public void metron_f9615_0() throws Exception
{    listSupportedHashTypes.apply(Collections.singletonList("bogus"));}
public void metron_f9616_0() throws Exception
{        final List<String> requiredAlgorithmsByJava = Arrays.asList("MD5", "SHA", "SHA-256");    final Collection<String> supportedHashes = listSupportedHashTypes.apply(Collections.emptyList());    requiredAlgorithmsByJava.forEach(a -> assertTrue(supportedHashes.contains(a)));}
public void metron_f9617_0() throws Exception
{    hash.apply(null);}
public void metron_f9618_0() throws Exception
{    hash.apply(Collections.emptyList());}
public void metron_f9619_0() throws Exception
{    hash.apply(Collections.singletonList("some value."));}
public void metron_f9620_0() throws Exception
{    hash.apply(Arrays.asList("1", "2", "3"));}
public void metron_f9621_0() throws Exception
{    hash.apply(Arrays.asList("1", "2", "3", "4"));}
public void metron_f9622_0() throws Exception
{    hash.apply(Arrays.asList("value to hash", "invalidAlgorithm"));}
public void metron_f9623_0() throws Exception
{    assertNull(hash.apply(Arrays.asList("value to hash", null)));}
public void metron_f9624_0() throws Exception
{    assertEquals(StringUtils.repeat('0', 32), hash.apply(Arrays.asList(null, "md5")));}
public void metron_f9625_0() throws Exception
{    final String algorithm = "'md5'";    final Map<String, Object> variables = new HashMap<>();    variables.put("toHash", null);    assertEquals(StringUtils.repeat('0', 32), run("HASH(toHash, " + algorithm + ")", variables));}
public void metron_f9626_0() throws Exception
{    final String valueToHash = "My value to hash";    final Set<String> algorithms = Security.getAlgorithms("MessageDigest");    algorithms.forEach(algorithm -> {        try {            final MessageDigest expected = MessageDigest.getInstance(algorithm);            expected.update(valueToHash.getBytes(StandardCharsets.UTF_8));            assertEquals(expectedHexString(expected), hash.apply(Arrays.asList(valueToHash, algorithm)));        } catch (NoSuchAlgorithmException e) {            throw new RuntimeException(e);        }    });}
public void metron_f9627_0() throws Exception
{    final String valueToHash = "My value to hash";    final Set<String> algorithms = Security.getAlgorithms("MessageDigest");    algorithms.forEach(algorithm -> {        try {            final Object actual = run("HASH('" + valueToHash + "', '" + algorithm + "')", Collections.emptyMap());            final MessageDigest expected = MessageDigest.getInstance(algorithm);            expected.update(valueToHash.getBytes(StandardCharsets.UTF_8));            assertEquals(expectedHexString(expected), actual);        } catch (NoSuchAlgorithmException e) {            throw new RuntimeException(e);        }    });}
public void metron_f9628_0() throws Exception
{    final String algorithm = "'md5'";    final String valueToHash = "'My value to hash'";    final Serializable input = (Serializable) Collections.singletonList(valueToHash);    final MessageDigest expected = MessageDigest.getInstance(algorithm.replace("'", ""));    expected.update(SerializationUtils.serialize(input));    final Map<String, Object> variables = new HashMap<>();    variables.put("toHash", input);    assertEquals(expectedHexString(expected), run("HASH(toHash, " + algorithm + ")", variables));}
public void metron_f9629_0() throws Exception
{    final String algorithm = "md5";    final String valueToHash = "'My value to hash'";    final Serializable input = (Serializable) Collections.singletonList(valueToHash);    final MessageDigest expected = MessageDigest.getInstance(algorithm);    expected.update(SerializationUtils.serialize(input));    final Map<String, Object> variables = new HashMap<>();    variables.put("toHash", input);    variables.put("hashType", algorithm);    assertEquals(expectedHexString(expected), run("HASH(toHash, hashType)", variables));}
public void metron_f9630_0() throws Exception
{    final String algorithm = "md5";    final String valueToHash = "'My value to hash'";    final MessageDigest expected = MessageDigest.getInstance(algorithm);    expected.update(valueToHash.replace("'", "").getBytes(StandardCharsets.UTF_8));    final Map<String, Object> variables = new HashMap<>();    variables.put("hashType", algorithm);    assertEquals(expectedHexString(expected), run("HASH(" + valueToHash + ", hashType)", variables));}
public void metron_f9631_0() throws Exception
{    final Map<String, Object> variables = new HashMap<>();    variables.put("toHash", new Object());    assertNull(run("HASH(toHash, 'md5')", variables));}
public void metron_f9632_0() throws Exception
{    final Map<String, Object> variables = new HashMap<>();    variables.put("toHash", TLSH_DATA);    variables.put("toHashBytes", TLSH_DATA.getBytes(StandardCharsets.UTF_8));        assertEquals(TLSH_EXPECTED, run("HASH(toHash, 'tlsh')", variables));    assertEquals(TLSH_EXPECTED, run("HASH(toHash, 'TLSH')", variables));    assertEquals(TLSH_EXPECTED, run("HASH(toHashBytes, 'tlsh')", variables));}
public void metron_f9633_0() throws Exception
{    final Map<String, Object> variables = new HashMap<>();    variables.put("toHash", TLSH_DATA);    Map<String, String> out = (Map<String, String>) run("HASH(toHash, 'tlsh', { 'hashes' : [ 8, 16, 32 ]} )", variables);    Assert.assertTrue(out.containsKey(TLSHHasher.TLSH_KEY));    for (int h : ImmutableList.of(8, 16, 32)) {        Assert.assertTrue(out.containsKey(TLSHHasher.TLSH_BIN_KEY + "_" + h));    }}
public void metron_f9634_0() throws Exception
{            Map<Map.Entry<byte[], Map<String, Object>>, String> hashes = new HashMap<>();    Random r = new Random(0);    for (int i = 0; i < 20; ++i) {        byte[] d = new byte[256];        r.nextBytes(d);        Map<String, Object> config = new HashMap<String, Object>() {            {                put(TLSHHasher.Config.BUCKET_SIZE.key, r.nextBoolean() ? 128 : 256);                put(TLSHHasher.Config.CHECKSUM.key, r.nextBoolean() ? 1 : 3);            }        };        String hash = (String) run("HASH(data, 'tlsh', config)", ImmutableMap.of("config", config, "data", d));        Assert.assertNotNull(hash);        hashes.put(new AbstractMap.SimpleEntry<>(d, config), hash);    }    ForkJoinPool forkJoinPool = new ForkJoinPool(5);    forkJoinPool.submit(() -> hashes.entrySet().parallelStream().forEach(kv -> {        Map<String, Object> config = kv.getKey().getValue();        byte[] data = kv.getKey().getKey();        String hash = (String) run("HASH(data, 'tlsh', config)", ImmutableMap.of("config", config, "data", data));        Assert.assertEquals(hash, kv.getValue());    }));}
public void metron_f9635_0() throws Exception
{    for (Map.Entry<String, String> kv : ImmutableMap.of("been", "ben", "document", "dokumant", "code", "cad").entrySet()) {        Map<String, Object> variables = ImmutableMap.of("toHash", TLSH_DATA, "toHashSimilar", TLSH_DATA.replace(kv.getKey(), kv.getValue()));        Map<String, Object> bin1 = (Map<String, Object>) run("HASH(toHashSimilar, 'tlsh', { 'hashes' : 4, 'bucketSize' : 128 })", variables);        Map<String, Object> bin2 = (Map<String, Object>) run("HASH(toHash, 'tlsh', { 'hashes' : [ 4 ], 'bucketSize' : 128 })", variables);        assertEquals(kv.getKey() + " != " + kv.getValue() + " because " + bin1.get("tlsh") + " != " + bin2.get("tlsh"), bin1.get("tlsh_bin"), bin2.get("tlsh_bin"));        assertNotEquals(bin1.get("tlsh"), bin2.get("tlsh"));        Map<String, Object> distVariables = ImmutableMap.of("hash1", bin1.get(TLSHHasher.TLSH_KEY), "hash2", bin2.get(TLSHHasher.TLSH_KEY));        {                        Integer diff = (Integer) run("TLSH_DIST( hash1, hash2)", distVariables);            Integer diffReflexive = (Integer) run("TLSH_DIST( hash2, hash1)", distVariables);            Assert.assertTrue("diff == " + diff, diff < 100);            Assert.assertEquals(diff, diffReflexive);        }        {                        Integer diff = (Integer) run("TLSH_DIST( hash1, hash1)", distVariables);            Assert.assertEquals((int) 0, (int) diff);        }    }}
public void metron_f9636_0() throws Exception
{    final Map<String, Object> variables = new HashMap<>();    variables.put("hash1", 1);    variables.put("hash2", TLSH_EXPECTED);    run("TLSH_DIST( hash1, hash1)", variables);}
public void metron_f9637_0() throws Exception
{    final Map<String, Object> variables = new HashMap<>();    String data = "Metron is the best";    variables.put("toHash", data);    assertNull(run("HASH(toHash, 'tlsh')", variables));}
public void metron_f9638_0() throws Exception
{    final Map<String, Object> variables = new HashMap<>();    String data = null;    variables.put("toHash", data);    assertNull(run("HASH(toHash, 'tlsh')", variables));}
private String metron_f9639_0(MessageDigest expected)
{    return new String(HEX.encode(expected.digest()), StandardCharsets.UTF_8);}
public void metron_f9640_0()
{    Assert.assertTrue(runPredicate("match{NOT(is_alert) => true, foo > 5 => false, foo > 10 => false, default => false}", new HashMap() {        {            put("foo", 100);        }    }));    Assert.assertFalse(runPredicate("match{is_alert => true, foo > 5 => false, foo > 10 => false, default => false}", new HashMap() {        {            put("foo", 100);        }    }));    Assert.assertFalse(runPredicate("match{foo > 5 => false, is_alert => true, foo > 10 => false, default => false}", new HashMap() {        {            put("foo", 100);        }    }));}
public void metron_f9641_0()
{    Assert.assertTrue(runPredicate("match{NOT([]) => true, foo > 5 => false, foo > 10 => false, default => false}", new HashMap() {        {            put("foo", 100);        }    }));    Assert.assertFalse(runPredicate("match{[] => true, foo > 5 => false, foo > 10 => false, default => false}", new HashMap() {        {            put("foo", 100);        }    }));}
public void metron_f9642_0()
{    Assert.assertTrue(runPredicate("match{foo > 0 => true, foo > 5 => false, foo > 10 => false, default => false}", new HashMap() {        {            put("foo", 100);        }    }));}
public void metron_f9643_0()
{    Assert.assertTrue(runPredicate("match{foo < 0 => false, foo < 500 => true, default => false}", new HashMap() {        {            put("foo", 100);        }    }));}
public void metron_f9644_0()
{    List<String> list = (List<String>) run("match{ foo > 100 => ['oops'], foo > 200 => ['oh no'], foo >= 500 => MAP(['ok', 'haha'], (a) -> TO_UPPER(a)), default => ['a']}", new HashMap() {        {            put("foo", 500);        }    });    Assert.assertTrue(list.size() == 1);    Assert.assertTrue(list.contains("oops"));}
public void metron_f9645_0()
{    Assert.assertEquals("ok", run("match{ foo > 100 => THROW('oops'), foo > 200 => THROW('oh no'), default => 'ok' }", new HashMap() {        {            put("foo", 50);        }    }));}
public void metron_f9646_0()
{    Assert.assertTrue(runPredicate("match { 1 >= 0 => ()-> true, default => ()->false }", new HashMap() {        {            put("foo", 0);        }    }));    Assert.assertTrue(runPredicate("match { foo == 0 => ()-> true, default => ()-> false }", new HashMap() {        {            put("foo", 0);        }    }));    Assert.assertFalse(runPredicate("match { foo == 0 => ()-> true, default => ()-> false }", new HashMap() {        {            put("foo", 1);        }    }));    Assert.assertTrue(runPredicate("match { foo == 0 => ()-> false, foo == 1 => ()-> true, default => ()-> false }", new HashMap() {        {            put("foo", 1);        }    }));    Assert.assertTrue(runPredicate("match { foo == 0 => ()-> bFalse, foo == 1 => ()-> bTrue, default => ()-> bFalse }", new HashMap() {        {            put("foo", 1);            put("bFalse", false);            put("bTrue", true);        }    }));    Assert.assertTrue(runPredicate("match { foo == 0 => ()-> bFalse, foo == 1 => ()-> bTrue, default => ()-> bFalse }", new HashMap() {        {            put("foo", 1);            put("bFalse", false);            put("bTrue", true);        }    }));}
public void metron_f9647_0()
{    String expr = "match{ var1 =>  MAP(['foo', 'bar'], (x) -> TO_UPPER(x)), default => null }";    Object o = run(expr, ImmutableMap.of("foo", "foo", "bar", "bar", "var1", true));    Assert.assertTrue(o instanceof List);    List<String> result = (List<String>) o;    Assert.assertEquals(2, result.size());    Assert.assertEquals("FOO", result.get(0));    Assert.assertEquals("BAR", result.get(1));}
public void metron_f9648_0()
{    Assert.assertEquals(Arrays.asList("OK", "HAHA"), run("match{ foo > 100 => THROW('oops'), foo > 200 => THROW('oh no'), foo >= 50 => MAP(['ok', 'haha'], (a) -> TO_UPPER(a)), default=> 'a' }", new HashMap() {        {            put("foo", 50);        }    }));}
public void metron_f9649_0()
{    List<String> ret = (List<String>) run("match{ foo < 100 => ['oops'], default => MAP(['ok', 'haha'], (a) -> TO_UPPER(a))}", new HashMap() {        {            put("foo", 500);        }    });    Assert.assertTrue(ret.size() == 2);    Assert.assertTrue(ret.contains("OK"));    Assert.assertTrue(ret.contains("HAHA"));}
public void metron_f9650_0()
{    run("match{ foo < 100 => ['oops'], foo < 200 => ['oh no'], foo >= 500 => MAP(['ok', 'haha'], (a) -> TO_UPPER(a)), default => ['a']}", new HashMap() {        {            put("foo", 500);        }    });}
public void metron_f9651_0()
{    final Map<String, String> variables = new HashMap<String, String>() {        {            put("numbers", "12345");            put("numberPattern", "\\d(\\d)(\\d).*");            put("letters", "abcde");            put("empty", "");        }    };    Assert.assertTrue(runPredicate("match{ REGEXP_MATCH(numbers,numberPattern)=> true, default => false}", new DefaultVariableResolver(variables::get, variables::containsKey)));    Assert.assertFalse(runPredicate("match{ REGEXP_MATCH(letters,numberPattern) => true, default =>false}", new DefaultVariableResolver(variables::get, variables::containsKey)));}
public void metron_f9652_0()
{    Assert.assertTrue(runPredicate("match { foo == 0 => bFalse, foo == 1 => bTrue, default => false }", new HashMap() {        {            put("foo", 1);            put("bFalse", false);            put("bTrue", true);        }    }));    Assert.assertEquals("warning", run("match{ threat.triage.level < 10 => 'info', threat.triage.level < 20 => 'warning', default => 'critical' }", new HashMap() {        {            put("threat.triage.level", 15);        }    }));}
public void metron_f9653_0()
{    Assert.assertEquals("WARNING", run("match{ threat.triage.level < 10 => 'info', threat.triage.level < 20 => TO_UPPER('warning'), default => 'critical' }", new HashMap() {        {            put("threat.triage.level", 15);        }    }));}
public void metron_f9654_0()
{    Assert.assertEquals("false", run("match{ threat.triage.level < 10 => 'info', threat.triage.level < 20 => TO_STRING(IS_ENCODING(other,'BASE32')), default => 'critical' }", new HashMap() {        {            put("threat.triage.level", 15);            put("other", "value");        }    }));    Assert.assertEquals(false, run("match{ threat.triage.level < 10 => 'info', threat.triage.level < 20 => IS_ENCODING(other,'BASE32'), default => 'critical' }", new HashMap() {        {            put("threat.triage.level", 15);            put("other", "value");        }    }));}
public void metron_f9655_0()
{    Assert.assertTrue(runPredicate("match { foo == 0  OR bar == 'yes' => ()-> true, default => ()-> false }", new HashMap() {        {            put("foo", 1);            put("bar", "yes");        }    }));    Assert.assertTrue(runPredicate("match { foo == 0  AND bar == 'yes' => ()-> true, default => ()-> false }", new HashMap() {        {            put("foo", 0);            put("bar", "yes");        }    }));}
public void metron_f9656_0()
{    Assert.assertEquals("a", run("match{ foo == 5 ? true : false => 'a', default => 'ok' }", new HashMap() {        {            put("foo", 5);        }    }));}
public void metron_f9657_0()
{    Assert.assertEquals(false, run("match{ threat.triage.level < 10 => 'info', threat.triage.level < 20 => IS_ENCODING(other,'BASE32')? true : false, default => 'critical' }", new HashMap() {        {            put("threat.triage.level", 15);            put("other", "value");        }    }));}
public void metron_f9658_0()
{    Assert.assertEquals("a", run("match{ IF foo == 5 THEN true ELSE false => 'a', default => 'ok' }", new HashMap() {        {            put("foo", 5);        }    }));}
public void metron_f9659_0()
{    Assert.assertEquals(2, run("match{ foo == true => IF bar THEN 1 ELSE 2, default => 0}", new HashMap() {        {            put("foo", true);            put("bar", false);        }    }));}
public void metron_f9660_0()
{    Assert.assertEquals("a", run("match{ foo => 'a', default => null}", new HashMap() {        {            put("foo", true);        }    }));}
public void metron_f9661_0()
{    Assert.assertEquals("a", run("match{ foo == 5 => 'a', default => 'ok' }", new HashMap() {        {            put("foo", 5);        }    }));}
public void metron_f9662_0()
{    Assert.assertEquals("a", run("match{ foo => 'a', default => 'b' }", new HashMap() {        {            put("foo", true);        }    }));}
public void metron_f9663_0()
{    Assert.assertEquals("a", run("match{ foo == true => 'a', default=> 'b' }", new HashMap() {        {            put("foo", true);        }    }));}
public void metron_f9664_0()
{    Assert.assertNull(run("match{ foo == null => null, foo == true => 'not that null', default => 'really not that null'}", new HashMap() {        {            put("foo", null);        }    }));}
public void metron_f9665_0()
{    run("match{ foo > 100 => 'greater than 100', foo > 200 => 'greater than 200' }", new HashMap() {        {            put("foo", 50);        }    });}
public void metron_f9666_0()
{        Assert.assertEquals(false, run("match{  x == 0 => match{ y == 10 => false, default => true}, default => true}", new HashMap() {        {            put("x", 0);            put("y", 10);        }    }));}
public void metron_f9667_0()
{    Object o = run("match{ foo > 100 => ['oops'],default => ['a']}", new HashMap() {        {            put("foo", 500);        }    });    List l = (List) o;    Assert.assertTrue(l.size() == 1);}
public static Object metron_f9668_0(String rule, Map<String, Object> variables)
{    Context context = Context.EMPTY_CONTEXT();    StellarProcessor processor = new StellarProcessor();    Assert.assertTrue(rule + " not valid.", processor.validate(rule, context));    return processor.parse(rule, new DefaultVariableResolver(v -> variables.get(v), v -> variables.containsKey(v)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f9669_0()
{    assertValues("ABS", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 0d);            put(10.5d, 10.5d);            put(-10.5d, 10.5d);        }    });}
public void metron_f9670_0()
{    assertValues("SQRT", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 0d);            put(25d, 5d);            put(-10.5d, Double.NaN);        }    });}
public void metron_f9671_0()
{    assertValues("CEILING", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 0d);            put(10.5d, 11d);            put(-10.5d, -10d);        }    });}
public void metron_f9672_0()
{    assertValues("FLOOR", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 0d);            put(10.5d, 10d);            put(-10.5d, -11d);        }    });}
public void metron_f9673_0()
{    assertValues("SIN", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 0d);            put(Math.PI / 6, 0.5);            put(Math.PI / 4, Math.sqrt(2) / 2.0);            put(Math.PI / 3, Math.sqrt(3) / 2.0);            put(Math.PI / 2, 1d);        }    });}
public void metron_f9674_0()
{    assertValues("COS", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 1d);            put(Math.PI / 6, Math.sqrt(3) / 2.0);            put(Math.PI / 4, Math.sqrt(2) / 2.0);            put(Math.PI / 3, 0.5d);            put(Math.PI / 2, 0d);        }    });}
public void metron_f9675_0()
{    assertValues("TAN", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 0d);            put(Math.PI / 6, Math.sqrt(3) / 3.0);            put(Math.PI / 4, 1d);            put(Math.PI / 3, Math.sqrt(3));            put(Math.PI / 2, Math.sin(Math.PI / 2) / Math.cos(Math.PI / 2));        }    });}
public void metron_f9676_0()
{    assertValues("EXP", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 1d);            put(0.5d, Math.sqrt(Math.E));            put(-0.5d, 1 / Math.sqrt(Math.E));            put(1d, Math.E);            put(2d, Math.E * Math.E);        }    });}
public void metron_f9677_0()
{    assertValues("ROUND", new HashMap<Double, Double>(baseExpectations) {        {            put(0d, 0d);            put(0.5d, 1d);            put(0.4d, 0d);            put(-0.5d, 0d);        }    });}
public void metron_f9678_0()
{    testLog("LN", Math.E);}
public void metron_f9679_0()
{    testLog("LOG2", 2);}
public void metron_f9680_0()
{    testLog("LOG10", 10);}
public void metron_f9681_0()
{    Assert.assertTrue(runPredicate("IS_NAN(NaN)", new HashMap<>()));    Assert.assertFalse(runPredicate("IS_NAN(1.0)", new HashMap<>()));    Assert.assertTrue(runPredicate("IS_NAN(0.0/0.0)", new HashMap<>()));}
public void metron_f9682_0()
{    runPredicate("IS_NAN('casey')", new HashMap<>());}
public void metron_f9683_0()
{    runPredicate("IS_NAN()", new HashMap<>());}
public void metron_f9684_0(String func, Map<Double, Double> expected)
{    for (Map.Entry<Double, Double> test : expected.entrySet()) {        for (String expr : ImmutableList.of(func + "(value)", func + "(" + test.getKey() + ")")) {            if (Double.isNaN(test.getValue())) {                Assert.assertTrue(expr + " != NaN, where value == " + test.getKey(), Double.isNaN(toDouble(run(expr, ImmutableMap.of("value", test.getKey())))));            } else {                Assert.assertEquals(expr + " != " + test.getValue() + " (where value == " + test.getKey() + ")", test.getValue(), toDouble(run(expr, ImmutableMap.of("value", test.getKey()))), EPSILON);            }        }    }}
public Double metron_f9685_0(Object n)
{    return ((Number) n).doubleValue();}
public void metron_f9686_0(String logExpr, double base)
{    Map<Double, Double> expectedValues = new HashMap<Double, Double>(baseExpectations) {        {            put(base, 1d);            put(0d, Double.NEGATIVE_INFINITY);        }    };    for (int i = 1; i <= 10; ++i) {        expectedValues.put(Math.pow(base, i), (double) i);    }    assertValues(logExpr, expectedValues);}
public void metron_f9687_0() throws Exception
{    context = new Context.Builder().build();}
public void metron_f9688_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(12L);            add(56.0);            add(56.3);        }    };    Object res = run("MAX(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNotNull(res);    Assert.assertEquals(56.3, res);}
public void metron_f9689_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(12L);            add(56.0);            add(457L);        }    };    Object res = run("MIN(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNotNull(res);    Assert.assertEquals(res, 12L);}
public void metron_f9690_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add("value3");            add("value1");            add("23");            add("value2");        }    };    Object res = run("MAX(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals("value3"));}
public void metron_f9691_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(12);            add(56);        }    };    Object res = run("MAX(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals(56));}
public void metron_f9692_0() throws Exception
{    Object res = run("MAX([string1,string2])", ImmutableMap.of("string1", "abc", "string2", "def"));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals("def"));}
public void metron_f9693_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(145);            add(null);        }    };    Object res = run("MIN(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals(145));}
public void metron_f9694_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(null);            add(null);        }    };    Object res = run("MAX(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNull(res);}
public void metron_f9695_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(56);            add(12);            add(23);            add(null);        }    };    Object res = run("MIN(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals(12));}
public void metron_f9696_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(12L);            add(56L);            add(457L);        }    };    Object res = run("MAX(input_list)", ImmutableMap.of("input_list", inputList));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals(457L));}
public void metron_f9697_0() throws Exception
{    List<Object> inputList = new ArrayList<Object>() {        {            add(12);            add("string");            add(457L);        }    };    Object res = null;    try {        res = run("MAX(input_list)", ImmutableMap.of("input_list", inputList));    } catch (ParseException e) {        Assert.assertTrue(e.getMessage().contains("Incomparable objects were submitted to MAX: class java.lang.String is incomparable to class java.lang.Long"));        Assert.assertNull(res);    }}
public void metron_f9698_0() throws Exception
{    Set<Object> inputSet = new HashSet<Object>() {        {            add(14L);            add(15.3d);            add(15);        }    };    Object res = run("MAX(input_set)", ImmutableMap.of("input_set", inputSet));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals(15.3d));}
public void metron_f9699_0() throws Exception
{    class TestObject {        private String arg;        public TestObject(String arg) {            this.arg = arg;        }    }    List<Object> inputList = new ArrayList<Object>() {        {            add(new TestObject("one"));            add(new TestObject("two"));            add(new TestObject("three"));        }    };    Object res = null;    try {        res = run("MIN(input_list)", ImmutableMap.of("input_list", inputList));    } catch (ParseException e) {        Assert.assertTrue(e.getMessage().contains("Noncomparable object type org.apache.metron.stellar.dsl.functions.OrdinalFunctionsTest$1TestObject submitted to MIN"));        Assert.assertNull(res);    }}
public void metron_f9700_0() throws Exception
{    Ordinal provider = new Ordinal() {        @Override        public double getMin() {            return 10;        }        @Override        public double getMax() {            return 100;        }    };    Object res = run("MAX(input_list)", ImmutableMap.of("input_list", provider));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals(100.0d));}
public double metron_f9701_0()
{    return 10;}
public double metron_f9702_0()
{    return 100;}
public void metron_f9703_0() throws Exception
{    Ordinal provider = new Ordinal() {        @Override        public double getMin() {            return 10;        }        @Override        public double getMax() {            return 100;        }    };    Object res = run("MIN(input_list)", ImmutableMap.of("input_list", provider));    Assert.assertNotNull(res);    Assert.assertTrue(res.equals(10.0d));}
public double metron_f9704_0()
{    return 10;}
public double metron_f9705_0()
{    return 100;}
public Object metron_f9706_0(String rule, Map<String, Object> variables) throws Exception
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f9707_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("numbers", "12345");            put("numberPattern", "\\d(\\d)(\\d).*");            put("letters", "abcde");            put("letterPattern", "[a-zA-Z]+");            put("empty", "");        }    };    Assert.assertTrue(runPredicate("REGEXP_MATCH(numbers,numberPattern)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("REGEXP_MATCH(letters,numberPattern)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_MATCH(letters,[numberPattern,letterPattern])", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("REGEXP_MATCH(letters,[numberPattern])", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("REGEXP_MATCH(letters,[numberPattern,numberPattern])", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("REGEXP_MATCH(null,[numberPattern])", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("REGEXP_MATCH(letters,null)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("REGEXP_MATCH(letters,[null])", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9708_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("numbers", "12345");            put("numberPattern", "\\d(\\d)(\\d).*");            put("numberPatternNoCaptures", "\\d\\d\\d.*");            put("letters", "abcde");            put("empty", "");        }    };    Assert.assertTrue(runPredicate("REGEXP_GROUP_VAL(numbers,numberPattern,2) == '3'", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_GROUP_VAL(letters,numberPattern,2) == null", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_GROUP_VAL(empty,numberPattern,2) == null", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_GROUP_VAL(numbers,numberPatternNoCaptures,2) == null", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    boolean thrown = false;    try {        runPredicate("REGEXP_GROUP_VAL(2) == null", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v)));    } catch (ParseException | IllegalStateException ise) {        thrown = true;    }    if (!thrown) {        Assert.assertTrue("Did not fail on wrong number of parameters", false);    }}
public void metron_f9709_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("numbers", "12345");            put("numberPattern", "\\d(\\d)(\\d).*");            put("letters", "abcde");            put("empty", "");        }    };    Assert.assertTrue(runPredicate("REGEXP_REPLACE(empty, numberPattern, letters) == null", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_REPLACE(numbers, empty, empty) == numbers", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_REPLACE(numbers, empty, letters) == numbers", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_REPLACE(numbers, numberPattern, empty) == numbers", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_REPLACE(numbers, numberPattern, letters) == letters", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("REGEXP_REPLACE(letters, numberPattern, numbers) == letters", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public Set<Class<? extends StellarFunction>> metron_f9710_0()
{    return classesToResolve;}
public TestResolver metron_f9711_0(Class<? extends StellarFunction> clazz)
{    this.classesToResolve.add(clazz);    return this;}
public Object metron_f9712_0(List<Object> args)
{    return null;}
public void metron_f9713_0() throws IOException
{    closeCallCount++;    if (throwException) {        Throwable cause = new Throwable("Some nasty nasty cause.");        throw new IOException("Bad things happened", cause);    }}
public Object metron_f9714_0(List<Object> args)
{    return null;}
public void metron_f9715_0() throws IOException
{    closeCallCount++;    if (throwException) {        throw new NullPointerException("A most annoying exception.");    }}
public void metron_f9716_0()
{    resolver = new TestResolver();    IAmAFunction.throwException = false;    IAmAnotherFunction.throwException = false;}
public void metron_f9717_0() throws IOException
{    resolver.withClass(IAmAFunction.class);    resolver.withClass(IAmAnotherFunction.class);    resolver.close();    assertThat(IAmAFunction.closeCallCount, equalTo(1));    assertThat(IAmAnotherFunction.closeCallCount, equalTo(1));}
public void metron_f9718_0() throws IOException
{    IAmAFunction.throwException = true;    IAmAnotherFunction.throwException = true;    resolver.withClass(IAmAFunction.class);    resolver.withClass(IAmAnotherFunction.class);    exception.expect(IOException.class);    resolver.close();}
public void metron_f9719_0() throws IOException
{    IAmAFunction.throwException = true;    IAmAnotherFunction.throwException = true;    resolver.withClass(IAmAFunction.class);    resolver.withClass(IAmAnotherFunction.class);    try {        resolver.close();        Assert.fail("Should have thrown an exception.");    } catch (IOException e) {        }    assertThat(IAmAFunction.closeCallCount, equalTo(1));    assertThat(IAmAnotherFunction.closeCallCount, equalTo(1));        resolver.close();    resolver.close();    resolver.close();    assertThat(IAmAFunction.closeCallCount, equalTo(1));    assertThat(IAmAnotherFunction.closeCallCount, equalTo(1));}
public static void metron_f9720_0()
{        Properties config = new Properties();        ClasspathFunctionResolver resolver = create(config);    expectedFunctions = Lists.newArrayList(resolver.getFunctions());}
public static ClasspathFunctionResolver metron_f9721_0(Properties config)
{    ClasspathFunctionResolver resolver = new ClasspathFunctionResolver();    Context context = new Context.Builder().with(Context.Capabilities.STELLAR_CONFIG, () -> config).build();    resolver.initialize(context);    return resolver;}
public void metron_f9722_0()
{        Properties config = new Properties();    config.put(STELLAR_SEARCH_INCLUDES_KEY.param(), "org.apache.metron.*");        ClasspathFunctionResolver resolver = create(config);    List<String> actual = Lists.newArrayList(resolver.getFunctions());        Assert.assertEquals(expectedFunctions, actual);}
public void metron_f9723_0()
{        Properties config = new Properties();    config.put(STELLAR_SEARCH_INCLUDES_KEY.param(), "org.apache.metron.common.*, org.apache.metron.management.*");        ClasspathFunctionResolver resolver = create(config);    List<String> actual = Lists.newArrayList(resolver.getFunctions());        Assert.assertTrue(actual.size() > 0);    Assert.assertTrue(actual.size() <= expectedFunctions.size());}
public void metron_f9724_0()
{        Properties config = new Properties();    config.put(STELLAR_SEARCH_EXCLUDES_KEY.param(), "org.apache.metron.*");        ClasspathFunctionResolver resolver = create(config);    List<String> actual = Lists.newArrayList(resolver.getFunctions());        Assert.assertEquals(0, actual.size());}
public void metron_f9725_0() throws FileSystemException, ClassNotFoundException
{    File jar = new File("src/test/classpath-resources");    Assert.assertTrue(jar.exists());    Properties config = new Properties();    config.put(STELLAR_VFS_PATHS.param(), jar.toURI() + "/.*.jar");    ClasspathFunctionResolver resolver = create(config);    HashSet<String> functions = new HashSet<>(Lists.newArrayList(resolver.getFunctions()));    Assert.assertTrue(functions.contains("NOW"));}
public void metron_f9726_0() throws Exception
{    StellarFunction goodFunc = mock(StellarFunction.class);    StellarFunction badFunc = mock(StellarFunction.class);    ClasspathFunctionResolver resolver = new ClasspathFunctionResolver() {        @Override        protected Iterable<Class<?>> getStellarClasses(ClassLoader cl) {            return ImmutableList.of(goodFunc.getClass(), badFunc.getClass());        }        @Override        protected boolean includeClass(Class<?> c, FilterBuilder filterBuilder) {            if (c != goodFunc.getClass()) {                throw new LinkageError("failed!");            }            return true;        }    };    Set<Class<? extends StellarFunction>> funcs = resolver.resolvables();    Assert.assertEquals(1, funcs.size());    Assert.assertEquals(goodFunc.getClass(), Iterables.getFirst(funcs, null));}
protected Iterable<Class<?>> metron_f9727_0(ClassLoader cl)
{    return ImmutableList.of(goodFunc.getClass(), badFunc.getClass());}
protected boolean metron_f9728_0(Class<?> c, FilterBuilder filterBuilder)
{    if (c != goodFunc.getClass()) {        throw new LinkageError("failed!");    }    return true;}
public void metron_f9729_0()
{    resolver = new SimpleFunctionResolver();}
public void metron_f9730_0()
{    resolver.withClass(IAmAFunction.class);    List<String> functions = Lists.newArrayList(resolver.getFunctions());    Assert.assertEquals(1, functions.size());    Assert.assertTrue(functions.contains("namespace_function"));}
public void metron_f9731_0()
{    resolver.withClass(IAmAFunction.class);    final String functionName = "namespace_function";    StellarFunction fn = resolver.apply(functionName);    Assert.assertTrue(fn instanceof IAmAFunction);}
public void metron_f9732_0()
{    resolver.withClass(MissingAnnotation.class);    List<String> functions = Lists.newArrayList(resolver.getFunctions());    Assert.assertEquals(0, functions.size());}
public void metron_f9733_0()
{    resolver.withClass(IAmAFunction.class);    resolver.withClass(IAmAFunction.class);    List<String> functions = Lists.newArrayList(resolver.getFunctions());    Assert.assertEquals(1, functions.size());}
public Object metron_f9734_0(List<Object> args)
{    return null;}
public Object metron_f9735_0(List<Object> args, Context context) throws ParseException
{    return null;}
public void metron_f9736_0(Context context)
{}
public boolean metron_f9737_0()
{    return false;}
public void metron_f9738_0() throws Exception
{    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, HashMap::new).build();        basicAuthPasswordFile = tempDir.newFile("basicAuth.txt");    FileUtils.writeStringToFile(basicAuthPasswordFile, basicAuthPassword, StandardCharsets.UTF_8);    proxyBasicAuthPasswordFile = tempDir.newFile("proxyBasicAuth.txt");    FileUtils.writeStringToFile(proxyBasicAuthPasswordFile, proxyAuthPassword, StandardCharsets.UTF_8);        baseUri = String.format("http://localhost:%d", mockServerRule.getPort());    getUri = baseUri + "/get";    emptyGetUri = baseUri + "/get/empty";    postUri = baseUri + "/post";    emptyPostUri = baseUri + "/post/empty";    mockServerClient.when(request().withMethod("GET").withPath("/get")).respond(response().withBody("{\"get\":\"success\"}"));    mockServerClient.when(request().withMethod("GET").withPath("/get/empty")).respond(response().withStatusCode(404));    mockServerClient.when(request().withMethod("POST").withPath("/post").withBody("{\"key\":\"value\"}")).respond(response().withBody("{\"post\":\"success\"}"));    mockServerClient.when(request().withMethod("POST").withPath("/post/empty")).respond(response().withStatusCode(404));}
public void metron_f9739_0() throws Exception
{    Map<String, Object> actual = (Map<String, Object>) run(String.format("REST_GET('%s')", getUri), context);    assertEquals(1, actual.size());    assertEquals("success", actual.get("get"));}
public void metron_f9740_0() throws Exception
{    mockServerClient.when(request().withMethod("GET").withPath("/get/with/query/parameters").withQueryStringParameter("key", "value")).respond(response().withBody("{\"get.with.query.parameters\":\"success\"}"));    Map<String, Object> variables = ImmutableMap.of("queryParameters", ImmutableMap.of("key", "value"));    Map<String, Object> actual = (Map<String, Object>) run(String.format("REST_GET('%s', {}, queryParameters)", baseUri + "/get/with/query/parameters"), variables, context);    assertEquals(1, actual.size());    assertEquals("success", actual.get("get.with.query.parameters"));}
public void metron_f9741_0()
{    mockServerClient.when(request().withMethod("GET").withPath("/get")).respond(response().withBody("{\"proxyGet\":\"success\"}"));    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> new HashMap<String, Object>() {        {            put(PROXY_HOST, "localhost");            put(PROXY_PORT, proxyRule.getHttpPort());        }    });    Map<String, Object> actual = (Map<String, Object>) run(String.format("REST_GET('%s')", getUri), context);    assertEquals(1, actual.size());    assertEquals("success", actual.get("proxyGet"));}
public void metron_f9742_0()
{    mockServerClient.when(request().withMethod("GET").withPath("/get")).respond(response().withStatusCode(403));    assertNull(run(String.format("REST_GET('%s')", getUri), context));}
public void metron_f9743_0()
{    assertEquals("function config override", run(String.format("REST_GET('%s', %s)", emptyGetUri, emptyContentOverride), context));}
public void metron_f9744_0()
{    mockServerClient.when(request().withMethod("GET").withPath("/get")).respond(response().withStatusCode(500));    Object result = run(String.format("REST_GET('%s', %s)", getUri, errorValueOverride), context);    assertEquals("error message", result);}
public void metron_f9745_0()
{    String uri = String.format("http://localhost:%d/get", mockServerRule.getPort());    mockServerClient.when(request().withMethod("GET").withPath("/get")).respond(response().withDelay(TimeUnit.MILLISECONDS, 1000).withBody("{\"get\":\"success\"}"));    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(STELLAR_REST_SETTINGS, new HashMap<String, Object>() {                {                    put(TIMEOUT, 10);                }            });        }    };    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    Map<String, Object> actual = (Map<String, Object>) run(String.format("REST_GET('%s')", uri), context);    assertNull(actual);}
public void metron_f9746_0()
{    String uri = String.format("http://localhost:%d/get", mockServerRule.getPort());    mockServerClient.when(request().withMethod("GET").withPath("/get")).respond(response().withDelay(TimeUnit.MILLISECONDS, 1000).withBody("{\"get\":\"success\"}"));    String expression = String.format("REST_GET('%s', %s)", uri, timeoutConfig);    Map<String, Object> actual = (Map<String, Object>) run(expression, context);    assertNull(actual);}
public void metron_f9747_0() throws IllegalArgumentException, IOException
{    thrown.expect(ParseException.class);    thrown.expectMessage("Unable to parse REST_GET('some invalid uri'): Unable to parse: REST_GET('some invalid uri') due to: Illegal character in path at index 4: some invalid uri");    run("REST_GET('some invalid uri')", context);}
public void metron_f9748_0()
{    thrown.expect(ParseException.class);    thrown.expectMessage("Unable to parse REST_GET(): Unable to parse: REST_GET() due to: Expected at least 1 argument(s), found 0");    run("REST_GET()", context);}
public void metron_f9749_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(STELLAR_REST_SETTINGS, new HashMap<String, Object>() {                {                    put(RESPONSE_CODES_ALLOWED, Arrays.asList(200, 404));                    put(EMPTY_CONTENT_OVERRIDE, "global config override");                }            });        }    };    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    assertEquals("global config override", run(String.format("REST_GET('%s')", emptyGetUri), context));}
public void metron_f9750_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(STELLAR_REST_SETTINGS, new HashMap<String, Object>() {                {                    put(RESPONSE_CODES_ALLOWED, Arrays.asList(200, 404));                    put(EMPTY_CONTENT_OVERRIDE, "global config override");                }            });            put(STELLAR_REST_GET_SETTINGS, new HashMap<String, Object>() {                {                    put(EMPTY_CONTENT_OVERRIDE, "get config override");                }            });        }    };    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    assertEquals("get config override", run(String.format("REST_GET('%s')", emptyGetUri), context));}
public void metron_f9751_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(STELLAR_REST_SETTINGS, new HashMap<String, Object>() {                {                    put(RESPONSE_CODES_ALLOWED, Arrays.asList(200, 404));                    put(EMPTY_CONTENT_OVERRIDE, "global config override");                }            });            put(STELLAR_REST_GET_SETTINGS, new HashMap<String, Object>() {                {                    put(EMPTY_CONTENT_OVERRIDE, "get config override");                }            });        }    };    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    assertEquals("function config override", run(String.format("REST_GET('%s', %s)", emptyGetUri, emptyContentOverride), context));}
public void metron_f9752_0() throws Exception
{    Map<String, Object> actual = (Map<String, Object>) run(String.format("REST_POST('%s', '{\"key\":\"value\"}')", postUri), context);    assertEquals(1, actual.size());    assertEquals("success", actual.get("post"));}
public void metron_f9753_0() throws Exception
{    mockServerClient.when(request().withMethod("POST").withPath("/post/with/query/parameters").withQueryStringParameter("key", "value")).respond(response().withBody("{\"post.with.query.parameters\":\"success\"}"));    Map<String, Object> variables = ImmutableMap.of("queryParameters", ImmutableMap.of("key", "value"));    Map<String, Object> actual = (Map<String, Object>) run(String.format("REST_POST('%s', {}, {}, queryParameters)", baseUri + "/post/with/query/parameters"), variables, context);    assertEquals(1, actual.size());    assertEquals("success", actual.get("post.with.query.parameters"));}
public void metron_f9754_0() throws Exception
{    Map<String, Object> variables = ImmutableMap.of("body", ImmutableMap.of("key", "value"));    Map<String, Object> actual = (Map<String, Object>) run(String.format("REST_POST('%s', body)", postUri), variables, context);    assertEquals(1, actual.size());    assertEquals("success", actual.get("post"));}
public void metron_f9755_0() throws IllegalArgumentException, IOException
{    thrown.expect(ParseException.class);    thrown.expectMessage("Unable to parse REST_POST('some invalid uri', {}): Unable to parse: REST_POST('some invalid uri', {}) due to: Illegal character in path at index 4: some invalid uri");    run("REST_POST('some invalid uri', {})", context);}
public void metron_f9756_0() throws IllegalArgumentException, IOException
{    thrown.expect(ParseException.class);    thrown.expectMessage(String.format("Unable to parse: REST_POST('%s', 'malformed json') due to: POST data 'malformed json' must be properly formatted JSON.  " + "Set the 'enforce.json' property to false to disable this check.", postUri));    run(String.format("REST_POST('%s', 'malformed json')", postUri), context);}
public void metron_f9757_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(STELLAR_REST_SETTINGS, new HashMap<String, Object>() {                {                    put(RESPONSE_CODES_ALLOWED, Arrays.asList(200, 404));                    put(EMPTY_CONTENT_OVERRIDE, "global config override");                }            });        }    };    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    assertEquals("global config override", run(String.format("REST_POST('%s', {})", emptyGetUri), context));}
public void metron_f9758_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(STELLAR_REST_SETTINGS, new HashMap<String, Object>() {                {                    put(RESPONSE_CODES_ALLOWED, Arrays.asList(200, 404));                    put(EMPTY_CONTENT_OVERRIDE, "global config override");                }            });            put(STELLAR_REST_POST_SETTINGS, new HashMap<String, Object>() {                {                    put(EMPTY_CONTENT_OVERRIDE, "post config override");                }            });        }    };    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    assertEquals("post config override", run(String.format("REST_POST('%s', {})", emptyGetUri), context));}
public void metron_f9759_0()
{    Map<String, Object> globalConfig = new HashMap<String, Object>() {        {            put(STELLAR_REST_SETTINGS, new HashMap<String, Object>() {                {                    put(RESPONSE_CODES_ALLOWED, Arrays.asList(200, 404));                    put(EMPTY_CONTENT_OVERRIDE, "global config override");                }            });            put(STELLAR_REST_POST_SETTINGS, new HashMap<String, Object>() {                {                    put(EMPTY_CONTENT_OVERRIDE, "post config override");                }            });        }    };    context.addCapability(Context.Capabilities.GLOBAL_CONFIG, () -> globalConfig);    assertEquals("function config override", run(String.format("REST_POST('%s', {}, %s)", emptyGetUri, emptyContentOverride), context));}
public void metron_f9760_0() throws Exception
{    context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, HashMap::new).build();        basicAuthPasswordFile = tempDir.newFile("basicAuth.txt");    FileUtils.writeStringToFile(basicAuthPasswordFile, basicAuthPassword, StandardCharsets.UTF_8);    proxyBasicAuthPasswordFile = tempDir.newFile("proxyBasicAuth.txt");    FileUtils.writeStringToFile(proxyBasicAuthPasswordFile, proxyAuthPassword, StandardCharsets.UTF_8);}
public void metron_f9761_0()
{    {        RestConfig restConfig = new RestConfig();        Optional<HttpHost> actual = RestFunctions.getProxy(restConfig);        assertEquals(Optional.empty(), actual);    }    {        RestConfig restConfig = new RestConfig();        restConfig.put(PROXY_HOST, "localhost");        Optional<HttpHost> actual = RestFunctions.getProxy(restConfig);        assertEquals(Optional.empty(), actual);    }    {        RestConfig restConfig = new RestConfig();        restConfig.put(PROXY_PORT, 3128);        Optional<HttpHost> actual = RestFunctions.getProxy(restConfig);        assertEquals(Optional.empty(), actual);    }    {        RestConfig restConfig = new RestConfig();        restConfig.put(PROXY_HOST, "localhost");        restConfig.put(PROXY_PORT, 3128);        Optional<HttpHost> actual = RestFunctions.getProxy(restConfig);        assertEquals(new HttpHost("localhost", 3128), actual.get());    }}
public void metron_f9762_0() throws Exception
{    Map<String, Object> config = new HashMap<String, Object>() {        {            put(BASIC_AUTH_USER, "user");            put(PROXY_BASIC_AUTH_USER, "proxyUser");        }    };    Map<String, Object> priorityConfig = new HashMap<String, Object>() {        {            put(BASIC_AUTH_USER, "priorityUser");        }    };    RestConfig restConfig = RestFunctions.buildRestConfig(config, priorityConfig);    assertEquals(6, restConfig.size());    assertEquals(Collections.singletonList(200), restConfig.getResponseCodesAllowed());    assertEquals("priorityUser", restConfig.getBasicAuthUser());    assertEquals("proxyUser", restConfig.getProxyBasicAuthUser());    assertTrue(restConfig.enforceJson());    assertEquals(1000, restConfig.getTimeout().intValue());    assertFalse(restConfig.verifyContentLength());}
public void metron_f9763_0()
{    {        RequestConfig actual = RestFunctions.getRequestConfig(new RestConfig(), Optional.empty());        RequestConfig expected = RequestConfig.custom().build();        assertEquals(expected.getConnectTimeout(), actual.getConnectTimeout());        assertEquals(expected.getConnectionRequestTimeout(), actual.getConnectionRequestTimeout());        assertEquals(expected.getSocketTimeout(), actual.getSocketTimeout());        assertEquals(expected.getProxy(), actual.getProxy());    }    {        RestConfig restConfig = new RestConfig();        restConfig.put(CONNECT_TIMEOUT, 1);        restConfig.put(CONNECTION_REQUEST_TIMEOUT, 2);        restConfig.put(SOCKET_TIMEOUT, 3);        HttpHost proxy = new HttpHost("localhost", 3128);        Optional<HttpHost> proxyOptional = Optional.of(proxy);        RequestConfig actual = RestFunctions.getRequestConfig(restConfig, proxyOptional);        RequestConfig expected = RequestConfig.custom().setConnectTimeout(1).setConnectionRequestTimeout(2).setSocketTimeout(3).setProxy(proxy).build();        assertEquals(expected.getConnectTimeout(), actual.getConnectTimeout());        assertEquals(expected.getConnectionRequestTimeout(), actual.getConnectionRequestTimeout());        assertEquals(expected.getSocketTimeout(), actual.getSocketTimeout());        assertEquals(expected.getProxy(), actual.getProxy());    }}
public void metron_f9764_0() throws Exception
{    HttpHost target = new HttpHost("localhost", 8080);    HttpHost proxy = new HttpHost("localhost", 3128);    {        RestConfig restConfig = new RestConfig();        HttpClientContext actual = RestFunctions.getHttpClientContext(restConfig, target, Optional.empty());        assertNull(actual.getCredentialsProvider());    }    {        RestConfig restConfig = new RestConfig();        restConfig.put(BASIC_AUTH_USER, "user");        restConfig.put(BASIC_AUTH_PASSWORD_PATH, basicAuthPasswordFile.getAbsolutePath());        HttpClientContext actual = RestFunctions.getHttpClientContext(restConfig, target, Optional.empty());        HttpClientContext expected = HttpClientContext.create();        CredentialsProvider expectedCredentialsProvider = new BasicCredentialsProvider();        expectedCredentialsProvider.setCredentials(new AuthScope(target), new UsernamePasswordCredentials(restConfig.getBasicAuthUser(), basicAuthPassword));        expected.setCredentialsProvider(expectedCredentialsProvider);        assertEquals(expected.getCredentialsProvider().getCredentials(new AuthScope(target)), actual.getCredentialsProvider().getCredentials(new AuthScope(target)));        assertEquals(expected.getCredentialsProvider().getCredentials(new AuthScope(proxy)), actual.getCredentialsProvider().getCredentials(new AuthScope(proxy)));    }    {        RestConfig restConfig = new RestConfig();        restConfig.put(PROXY_BASIC_AUTH_USER, "proxyUser");        restConfig.put(PROXY_BASIC_AUTH_PASSWORD_PATH, proxyBasicAuthPasswordFile.getAbsolutePath());        HttpClientContext actual = RestFunctions.getHttpClientContext(restConfig, target, Optional.of(proxy));        HttpClientContext expected = HttpClientContext.create();        CredentialsProvider expectedCredentialsProvider = new BasicCredentialsProvider();        expectedCredentialsProvider.setCredentials(new AuthScope(proxy), new UsernamePasswordCredentials(restConfig.getProxyBasicAuthUser(), proxyAuthPassword));        expected.setCredentialsProvider(expectedCredentialsProvider);        assertEquals(expected.getCredentialsProvider().getCredentials(new AuthScope(target)), actual.getCredentialsProvider().getCredentials(new AuthScope(target)));        assertEquals(expected.getCredentialsProvider().getCredentials(new AuthScope(proxy)), actual.getCredentialsProvider().getCredentials(new AuthScope(proxy)));    }    {        RestConfig restConfig = new RestConfig();        restConfig.put(BASIC_AUTH_USER, "user");        restConfig.put(BASIC_AUTH_PASSWORD_PATH, basicAuthPasswordFile.getAbsolutePath());        restConfig.put(PROXY_BASIC_AUTH_USER, "proxyUser");        restConfig.put(PROXY_BASIC_AUTH_PASSWORD_PATH, proxyBasicAuthPasswordFile.getAbsolutePath());        HttpClientContext actual = RestFunctions.getHttpClientContext(restConfig, target, Optional.of(proxy));        HttpClientContext expected = HttpClientContext.create();        CredentialsProvider expectedCredentialsProvider = new BasicCredentialsProvider();        expectedCredentialsProvider.setCredentials(new AuthScope(target), new UsernamePasswordCredentials(restConfig.getBasicAuthUser(), basicAuthPassword));        expectedCredentialsProvider.setCredentials(new AuthScope(proxy), new UsernamePasswordCredentials(restConfig.getProxyBasicAuthUser(), proxyAuthPassword));        expected.setCredentialsProvider(expectedCredentialsProvider);        assertEquals(expected.getCredentialsProvider().getCredentials(new AuthScope(target)), actual.getCredentialsProvider().getCredentials(new AuthScope(target)));        assertEquals(expected.getCredentialsProvider().getCredentials(new AuthScope(proxy)), actual.getCredentialsProvider().getCredentials(new AuthScope(proxy)));    }}
public void metron_f9765_0() throws IllegalArgumentException, IOException
{    RestFunctions.RestGet restGet = new RestFunctions.RestGet();    CloseableHttpClient httpClient = mock(CloseableHttpClient.class);    ScheduledExecutorService executorService = mock(ScheduledExecutorService.class);    RestFunctions.setCloseableHttpClient(httpClient);    RestFunctions.setScheduledExecutorService(executorService);    when(httpClient.execute(any(HttpRequestBase.class), any(HttpClientContext.class))).thenThrow(new IOException("io exception"));    Object result = restGet.apply(Collections.singletonList("http://www.host.com:8080/some/uri"), context);    Assert.assertNull(result);}
public void metron_f9766_0()
{    RestConfig restConfig = new RestConfig();    restConfig.put(POOLING_MAX_TOTAL, 5);    restConfig.put(POOLING_DEFAULT_MAX_PER_RUOTE, 2);    PoolingHttpClientConnectionManager cm = RestFunctions.getConnectionManager(restConfig);    assertEquals(5, cm.getMaxTotal());    assertEquals(2, cm.getDefaultMaxPerRoute());}
public void metron_f9767_0() throws Exception
{    RestFunctions.RestGet restGet = new RestFunctions.RestGet();    CloseableHttpClient httpClient = mock(CloseableHttpClient.class);    ScheduledExecutorService executorService = mock(ScheduledExecutorService.class);    RestFunctions.setCloseableHttpClient(httpClient);    RestFunctions.setScheduledExecutorService(executorService);    restGet.close();    verify(httpClient, times(1)).close();    verify(executorService, times(1)).shutdown();    verifyNoMoreInteractions(httpClient);}
public void metron_f9768_0() throws Exception
{    RestFunctions.RestPost restPost = new RestFunctions.RestPost();    CloseableHttpClient httpClient = mock(CloseableHttpClient.class);    ScheduledExecutorService executorService = mock(ScheduledExecutorService.class);    RestFunctions.setCloseableHttpClient(httpClient);    RestFunctions.setScheduledExecutorService(executorService);    restPost.close();    verify(httpClient, times(1)).close();    verify(executorService, times(1)).shutdown();    verifyNoMoreInteractions(httpClient);}
public void metron_f9769_0() throws Exception
{    RestConfig restConfig = new RestConfig();    HttpGet httpGet = mock(HttpGet.class);    HttpEntity httpEntity = mock(HttpEntity.class);        when(httpEntity.getContent()).thenReturn(new ByteArrayInputStream("{\"get\":\"success\"}".getBytes(StandardCharsets.UTF_8)));    Optional<Object> actual = RestFunctions.parseResponse(restConfig, httpGet, httpEntity);    assertTrue(actual.isPresent());    assertEquals("success", ((Map<String, Object>) actual.get()).get("get"));}
public void metron_f9770_0() throws Exception
{    RestConfig restConfig = new RestConfig();    HttpGet httpGet = mock(HttpGet.class);        assertEquals(Optional.empty(), RestFunctions.parseResponse(restConfig, httpGet, null));}
public void metron_f9771_0() throws Exception
{    RestConfig restConfig = new RestConfig();    HttpGet httpGet = mock(HttpGet.class);    HttpEntity httpEntity = mock(HttpEntity.class);        when(httpEntity.getContent()).thenReturn(null);    assertEquals(Optional.empty(), RestFunctions.parseResponse(restConfig, httpGet, httpEntity));}
public void metron_f9772_0() throws Exception
{    RestConfig restConfig = new RestConfig();    HttpGet httpGet = mock(HttpGet.class);    HttpEntity httpEntity = mock(HttpEntity.class);        when(httpEntity.getContent()).thenReturn(new ByteArrayInputStream("".getBytes(StandardCharsets.UTF_8)));    assertEquals(Optional.empty(), RestFunctions.parseResponse(restConfig, httpGet, httpEntity));}
public void metron_f9773_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Stellar REST request to uri returned incorrect or missing content length. Content length in the response was -1 but the actual body content length was 17.");    RestFunctions.RestGet restGet = new RestFunctions.RestGet();    RestConfig restConfig = new RestConfig();    HttpGet httpGet = mock(HttpGet.class);    HttpEntity httpEntity = mock(HttpEntity.class);    restConfig.put(VERIFY_CONTENT_LENGTH, true);    when(httpGet.getURI()).thenReturn(new URI("uri"));    when(httpEntity.getContent()).thenReturn(new ByteArrayInputStream("{\"get\":\"success\"}".getBytes(StandardCharsets.UTF_8)));    when(httpEntity.getContentLength()).thenReturn(-1L);    RestFunctions.parseResponse(restConfig, httpGet, httpEntity);}
public void metron_f9774_0() throws Exception
{    Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_INIT({ 'foo' : 'bar'})", new HashMap<>());}
public void metron_f9775_0() throws Exception
{    {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_INIT()", new HashMap<>());        Assert.assertEquals(0, s.size());    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_INIT([1,2,3,2])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.containsKey(1));        Assert.assertEquals(1, (int) s.get(1));        Assert.assertTrue(s.containsKey(2));        Assert.assertEquals(2, (int) s.get(2));        Assert.assertTrue(s.containsKey(3));        Assert.assertEquals(1, (int) s.get(3));    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_INIT(['one','two','three','two'])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.containsKey("one"));        Assert.assertEquals(1, (int) s.get("one"));        Assert.assertTrue(s.containsKey("two"));        Assert.assertEquals(2, (int) s.get("two"));        Assert.assertTrue(s.containsKey("three"));        Assert.assertEquals(1, (int) s.get("three"));    }}
public void metron_f9776_0() throws Exception
{    {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_ADD(MULTISET_INIT(), 1)", new HashMap<>());        Assert.assertEquals(1, s.size());        Assert.assertTrue(s.containsKey(1));        Assert.assertEquals(1, (int) s.get(1));    }    {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_ADD(null, 1)", new HashMap<>());        Assert.assertEquals(1, s.size());        Assert.assertTrue(s.containsKey(1));        Assert.assertEquals(1, (int) s.get(1));    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_ADD(MULTISET_INIT([1,2,3,4,4]), 4)", new HashMap<>());        Assert.assertEquals(4, s.size());        Assert.assertTrue(s.containsKey(1));        Assert.assertEquals(1, (int) s.get(1));        Assert.assertTrue(s.containsKey(2));        Assert.assertEquals(1, (int) s.get(2));        Assert.assertTrue(s.containsKey(3));        Assert.assertEquals(1, (int) s.get(3));        Assert.assertTrue(s.containsKey(4));        Assert.assertEquals(3, (int) s.get(4));    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_ADD(MULTISET_INIT(['one','two','three', 'four', 'four']), 'four')", new HashMap<>());        Assert.assertEquals(4, s.size());        Assert.assertTrue(s.containsKey("one"));        Assert.assertEquals(1, (int) s.get("one"));        Assert.assertTrue(s.containsKey("two"));        Assert.assertEquals(1, (int) s.get("two"));        Assert.assertTrue(s.containsKey("three"));        Assert.assertEquals(1, (int) s.get("three"));        Assert.assertTrue(s.containsKey("four"));        Assert.assertEquals(3, (int) s.get("four"));    }}
public void metron_f9777_0() throws Exception
{    {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_REMOVE(MULTISET_INIT([1]), 1)", new HashMap<>());        Assert.assertEquals(0, s.size());    }    {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_REMOVE(null, 1)", new HashMap<>());        Assert.assertEquals(0, s.size());    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_REMOVE(MULTISET_INIT([1,2,3,2]), 2)", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.containsKey(1));        Assert.assertEquals(1, (int) s.get(1));        Assert.assertTrue(s.containsKey(2));        Assert.assertEquals(1, (int) s.get(2));        Assert.assertTrue(s.containsKey(3));        Assert.assertEquals(1, (int) s.get(3));    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_REMOVE(MULTISET_INIT(['one','two','three', 'two']), 'two')", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.containsKey("one"));        Assert.assertEquals(1, (int) s.get("one"));        Assert.assertTrue(s.containsKey("two"));        Assert.assertEquals(1, (int) s.get("two"));        Assert.assertTrue(s.containsKey("three"));        Assert.assertEquals(1, (int) s.get("three"));    }}
public void metron_f9778_0() throws Exception
{    Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_MERGE({ 'bar' : 'foo' } )", new HashMap<>());}
public void metron_f9779_0() throws Exception
{    {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_MERGE([MULTISET_INIT(), MULTISET_INIT(null), null])", new HashMap<>());        Assert.assertEquals(0, s.size());    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_MERGE([MULTISET_INIT([1,2]), MULTISET_INIT([2,3]), null, MULTISET_INIT()])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.containsKey(1));        Assert.assertEquals(1, (int) s.get(1));        Assert.assertTrue(s.containsKey(2));        Assert.assertEquals(2, (int) s.get(2));        Assert.assertTrue(s.containsKey(3));        Assert.assertEquals(1, (int) s.get(3));    }        {        Map<Object, Integer> s = (Map<Object, Integer>) StellarProcessorUtils.run("MULTISET_MERGE([MULTISET_INIT(['one','two']), MULTISET_INIT(['two', 'three'])])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.containsKey("one"));        Assert.assertEquals(1, (int) s.get("one"));        Assert.assertTrue(s.containsKey("two"));        Assert.assertEquals(2, (int) s.get("two"));        Assert.assertTrue(s.containsKey("three"));        Assert.assertEquals(1, (int) s.get("three"));    }}
public void metron_f9780_0() throws Exception
{    Set s = (Set) StellarProcessorUtils.run("SET_INIT({ 'foo' : 2})", new HashMap<>());}
public void metron_f9781_0() throws Exception
{    {        Set s = (Set) StellarProcessorUtils.run("SET_INIT()", new HashMap<>());        Assert.assertEquals(0, s.size());    }        {        Set s = (Set) StellarProcessorUtils.run("SET_INIT([1,2,3])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.contains(1));        Assert.assertTrue(s.contains(2));        Assert.assertTrue(s.contains(3));    }        {        Set s = (Set) StellarProcessorUtils.run("SET_INIT(['one','two','three'])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.contains("one"));        Assert.assertTrue(s.contains("two"));        Assert.assertTrue(s.contains("three"));    }}
public void metron_f9782_0() throws Exception
{    {        Set s = (Set) StellarProcessorUtils.run("MULTISET_TO_SET(MULTISET_ADD(MULTISET_INIT(), 1))", new HashMap<>());        Assert.assertEquals(1, s.size());        Assert.assertTrue(s.contains(1));    }    {        Set s = (Set) StellarProcessorUtils.run("MULTISET_TO_SET(MULTISET_ADD(null, 1))", new HashMap<>());        Assert.assertEquals(1, s.size());        Assert.assertTrue(s.contains(1));    }        {        Set s = (Set) StellarProcessorUtils.run("MULTISET_TO_SET(MULTISET_ADD(MULTISET_INIT([1,2,3]), 4))", new HashMap<>());        Assert.assertEquals(4, s.size());        Assert.assertTrue(s.contains(1));        Assert.assertTrue(s.contains(2));        Assert.assertTrue(s.contains(3));        Assert.assertTrue(s.contains(4));    }        {        Set s = (Set) StellarProcessorUtils.run("MULTISET_TO_SET(MULTISET_ADD(MULTISET_INIT(['one','two','three']), 'four'))", new HashMap<>());        Assert.assertEquals(4, s.size());        Assert.assertTrue(s.contains("one"));        Assert.assertTrue(s.contains("two"));        Assert.assertTrue(s.contains("three"));        Assert.assertTrue(s.contains("four"));    }}
public void metron_f9783_0() throws Exception
{    {        Set s = (Set) StellarProcessorUtils.run("SET_ADD(SET_INIT(), 1)", new HashMap<>());        Assert.assertEquals(1, s.size());        Assert.assertTrue(s.contains(1));    }    {        Set s = (Set) StellarProcessorUtils.run("SET_ADD(null, 1)", new HashMap<>());        Assert.assertEquals(1, s.size());        Assert.assertTrue(s.contains(1));    }        {        Set s = (Set) StellarProcessorUtils.run("SET_ADD(SET_INIT([1,2,3]), 4)", new HashMap<>());        Assert.assertEquals(4, s.size());        Assert.assertTrue(s.contains(1));        Assert.assertTrue(s.contains(2));        Assert.assertTrue(s.contains(3));        Assert.assertTrue(s.contains(4));    }        {        Set s = (Set) StellarProcessorUtils.run("SET_ADD(SET_INIT(['one','two','three']), 'four')", new HashMap<>());        Assert.assertEquals(4, s.size());        Assert.assertTrue(s.contains("one"));        Assert.assertTrue(s.contains("two"));        Assert.assertTrue(s.contains("three"));        Assert.assertTrue(s.contains("four"));    }}
public void metron_f9784_0() throws Exception
{    {        Set s = (Set) StellarProcessorUtils.run("SET_REMOVE(SET_INIT([1]), 1)", new HashMap<>());        Assert.assertEquals(0, s.size());    }    {        Set s = (Set) StellarProcessorUtils.run("SET_REMOVE(null, 1)", new HashMap<>());        Assert.assertEquals(0, s.size());    }        {        Set s = (Set) StellarProcessorUtils.run("SET_REMOVE(SET_INIT([1,2,3]), 2)", new HashMap<>());        Assert.assertEquals(2, s.size());        Assert.assertTrue(s.contains(1));        Assert.assertTrue(s.contains(3));    }        {        Set s = (Set) StellarProcessorUtils.run("SET_REMOVE(SET_INIT(['one','two','three']), 'three')", new HashMap<>());        Assert.assertEquals(2, s.size());        Assert.assertTrue(s.contains("one"));        Assert.assertTrue(s.contains("two"));    }}
public void metron_f9785_0() throws Exception
{    Set s = (Set) StellarProcessorUtils.run("SET_MERGE({ 'foo' : 'bar'} )", new HashMap<>());}
public void metron_f9786_0() throws Exception
{    {        Set s = (Set) StellarProcessorUtils.run("SET_MERGE([SET_INIT(), SET_INIT(null), null])", new HashMap<>());        Assert.assertEquals(0, s.size());    }        {        Set s = (Set) StellarProcessorUtils.run("SET_MERGE([SET_INIT([1,2]), SET_INIT([3]), null, SET_INIT()])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.contains(1));        Assert.assertTrue(s.contains(2));        Assert.assertTrue(s.contains(3));    }        {        Set s = (Set) StellarProcessorUtils.run("SET_MERGE([SET_INIT(['one','two']), SET_INIT(['three'])])", new HashMap<>());        Assert.assertEquals(3, s.size());        Assert.assertTrue(s.contains("one"));        Assert.assertTrue(s.contains("two"));        Assert.assertTrue(s.contains("three"));    }}
public void metron_f9787_0()
{    Map<String, VariableResult> variables = ImmutableMap.of("foo", VariableResult.withExpression(2.0, "1 + 1"));    Context context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();    Object out = run("SHELL_LIST_VARS()", new HashMap<>(), context);    Assert.assertEquals(expectedListWithFoo, out);}
public void metron_f9788_0()
{    Context context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> new HashMap<>()).build();    Object out = run("SHELL_LIST_VARS()", new HashMap<>(), context);    Assert.assertEquals(expectedEmptyList, out);}
public void metron_f9789_0()
{    Map<String, Object> variables = ImmutableMap.of("map_field", ImmutableMap.of("field1", "val1", "field2", "val2"));    Context context = Context.EMPTY_CONTEXT();    Object out = run("SHELL_MAP2TABLE(map_field)", variables, context);    Assert.assertEquals(expectedMap2Table, out);}
public void metron_f9790_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("map_field", null);        }    };    Context context = Context.EMPTY_CONTEXT();    Object out = run("SHELL_MAP2TABLE(map_field)", variables, context);    Assert.assertEquals(expectedMap2TableNullInput, out);}
public void metron_f9791_0()
{    Map<String, Object> variables = new HashMap<>();    Context context = Context.EMPTY_CONTEXT();    Object out = run("SHELL_MAP2TABLE()", variables, context);    Assert.assertNull(out);}
public void metron_f9792_0()
{    Object out = run("SHELL_VARS2MAP('var1', 'var2')", new HashMap<>(), context);    Assert.assertTrue(out instanceof Map);    Map<String, String> mapOut = (Map<String, String>) out;        Assert.assertEquals(1, mapOut.size());    Assert.assertEquals("TO_UPPER('casey')", mapOut.get("var1"));}
public void metron_f9793_0()
{    Object out = run("SHELL_VARS2MAP()", new HashMap<>(), context);    Map<String, String> mapOut = (Map<String, String>) out;    Assert.assertEquals(0, mapOut.size());}
public void metron_f9794_0()
{    Object out = run("SHELL_GET_EXPRESSION('var1')", new HashMap<>(), context);    Assert.assertTrue(out instanceof String);    String expression = (String) out;        Assert.assertEquals("TO_UPPER('casey')", expression);}
public void metron_f9795_0()
{    Object out = run("SHELL_GET_EXPRESSION()", new HashMap<>(), context);    Assert.assertNull(out);}
public void metron_f9796_0() throws Exception
{    System.getProperties().put("EDITOR", "/bin/cat");    Object out = run("TO_UPPER(SHELL_EDIT(foo))", ImmutableMap.of("foo", "foo"), context);    Assert.assertEquals("FOO", out);}
public void metron_f9797_0() throws Exception
{    final Map<String, String> variableMap = new HashMap<String, String>() {        {            put("foo", "casey");            put("ip", "192.168.0.1");            put("empty", "");            put("spaced", "metron is great");        }    };    Assert.assertTrue(runPredicate("true and TO_UPPER(foo) == 'CASEY'", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in [ TO_LOWER('CASEY'), 'david' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("TO_UPPER(foo) in [ TO_UPPER('casey'), 'david' ] and IN_SUBNET(ip, '192.168.0.0/24')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("TO_LOWER(foo) in [ TO_UPPER('casey'), 'david' ]", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9798_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<String, Object>() {        {            put("foo", "casey");            put("bar", "bar.casey.grok");            put("ip", "192.168.0.1");            put("empty", "");            put("spaced", "metron is great");            put("myList", ImmutableList.of("casey", "apple", "orange"));        }    };    Assert.assertTrue(runPredicate("foo in SPLIT(bar, '.')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("foo in SPLIT(ip, '.')", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("foo in myList", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertFalse(runPredicate("foo not in myList", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9799_0() throws Exception
{    final Map<String, Object> variableMap = new HashMap<String, Object>() {        {            put("foo", null);            put("bar", null);            put("notInt", "oh my");        }    };        Object left = run("FILL_LEFT('123','X', 10)", new HashedMap());    Assert.assertNotNull(left);    Assert.assertEquals(10, ((String) left).length());    Assert.assertEquals("XXXXXXX123", (String) left);        Object right = run("FILL_RIGHT('123','X', 10)", new HashedMap());    Assert.assertNotNull(right);    Assert.assertEquals(10, ((String) right).length());    Assert.assertEquals("123XXXXXXX", (String) right);        Object same = run("FILL_RIGHT('123','X', 3)", new HashedMap());    Assert.assertEquals(3, ((String) same).length());    Assert.assertEquals("123", (String) same);        Object tooBig = run("FILL_RIGHT('1234567890','X', 3)", new HashedMap());    Assert.assertEquals(10, ((String) tooBig).length());    Assert.assertEquals("1234567890", (String) tooBig);        boolean thrown = false;    try {        run("FILL_RIGHT('123',foo,bar)", variableMap);    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("are both required"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("FILL_RIGHT('123','X',bar)", variableMap);    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("are both required"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("FILL_RIGHT('123',foo, 7)", variableMap);    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("are both required"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("FILL_RIGHT('123','X', 'z' )", new HashedMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("not a valid Integer"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        Object returnValue = run("FILL_RIGHT('123','', 10 )", new HashedMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("cannot be an empty"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("FILL_RIGHT('123',foo)", variableMap);    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("expects three"));    }    Assert.assertTrue(thrown);}
public void metron_f9800_0() throws Exception
{        Assert.assertEquals(0.0, (Double) run("STRING_ENTROPY('')", new HashMap<>()), 0.0);    Assert.assertEquals(0.0, (Double) run("STRING_ENTROPY(foo)", ImmutableMap.of("foo", "")), 0.0);    /*    Now consider the string aaaaaaaaaabbbbbccccc or 10 a's followed by 5 b's and 5 c's.    The probabilities of each character is as follows:    p(a) = 1/2    p(b) = 1/4    p(c) = 1/4    so the shannon entropy should be      -p(a)*log_2(p(a)) - p(b)*log_2(p(b)) - p(c)*log_2(p(c)) =      -0.5*-1 - 0.25*-2 - 0.25*-2 = 1.5     */    Assert.assertEquals(1.5, (Double) run("STRING_ENTROPY(foo)", ImmutableMap.of("foo", "aaaaaaaaaabbbbbccccc")), 0.0);}
public void metron_f9801_0() throws Exception
{    Map<String, Object> vars = ImmutableMap.of("cal", new Calendar.Builder().setDate(2017, 02, 02).build(), "x", 234, "y", 3);    Assert.assertEquals("no args", run("FORMAT('no args')", vars));    Assert.assertEquals("234.0", run("FORMAT('%.1f', TO_DOUBLE(234))", vars));    Assert.assertEquals("000234", run("FORMAT('%06d', 234)", vars));    Assert.assertEquals("03 2,2017", run("FORMAT('%1$tm %1$te,%1$tY', cal)", vars));    Assert.assertEquals("234 > 3", run("FORMAT('%d > %d', x, y)", vars));    boolean thrown = false;    try {        run("FORMAT('missing: %d', missing)", vars);    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);}
public void metron_f9802_0() throws Exception
{    run("FORMAT()", Collections.emptyMap());}
public void metron_f9803_0() throws Exception
{    run("FORMAT('missing arg: %d')", Collections.emptyMap());}
public void metron_f9804_0() throws Exception
{    Assert.assertEquals("abc", run("CHOMP('abc')", new HashedMap()));    Assert.assertEquals("abc", run("CHOMP(msg)", ImmutableMap.of("msg", "abc\r\n")));    Assert.assertEquals("", run("CHOMP(msg)", ImmutableMap.of("msg", "\n")));    Assert.assertEquals("", run("CHOMP('')", new HashedMap()));    Assert.assertEquals(null, run("CHOMP(null)", new HashedMap()));        boolean thrown = false;    try {        run("CHOMP()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("missing argument"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("CHOMP(msg)", new HashedMap());    } catch (ParseException pe) {        thrown = true;    }    thrown = false;        try {        run("CHOMP(123)", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("cannot be cast"));    }    Assert.assertTrue(thrown);}
public void metron_f9805_0() throws Exception
{    Assert.assertEquals("ab", run("CHOP('abc')", new HashedMap()));    Assert.assertEquals(null, run("CHOP(null)", new HashedMap()));    Assert.assertEquals("abc", run("CHOP(msg)", ImmutableMap.of("msg", "abc\r\n")));    Assert.assertEquals("", run("CHOP(msg)", ImmutableMap.of("msg", "")));    Assert.assertEquals("", run("CHOP(msg)", ImmutableMap.of("msg", "\n")));    Assert.assertEquals("", run("CHOP('')", new HashedMap()));        boolean thrown = false;    try {        run("CHOP()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("missing argument"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("CHOMP(msg)", new HashedMap());    } catch (ParseException pe) {        thrown = true;    }    thrown = false;        try {        run("CHOP(123)", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("cannot be cast"));    }    Assert.assertTrue(thrown);}
public void metron_f9806_0() throws Exception
{    Assert.assertEquals("xyzabc", run("PREPEND_IF_MISSING('abc', 'xyz')", new HashedMap()));    Assert.assertEquals("xyzXYZabc", run("PREPEND_IF_MISSING('XYZabc', 'xyz', 'mno')", new HashedMap()));    Assert.assertEquals("mnoXYZabc", run("PREPEND_IF_MISSING('mnoXYZabc', 'xyz', 'mno')", new HashedMap()));    Assert.assertEquals(null, run("PREPEND_IF_MISSING(null, null, null)", new HashedMap()));    Assert.assertEquals("xyz", run("PREPEND_IF_MISSING('', 'xyz', null)", new HashedMap()));        boolean thrown = false;    try {        run("PREPEND_IF_MISSING()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("PREPEND_IF_MISSING('abc')", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("PREPEND_IF_MISSING('abc', 'def', 'ghi', 'jkl')", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("PREPEND_IF_MISSING(123, 'abc')", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("cannot be cast"));    }    Assert.assertTrue(thrown);}
public void metron_f9807_0() throws Exception
{    Assert.assertEquals("apachemetron", run("APPEND_IF_MISSING('apache', 'metron')", new HashedMap()));    Assert.assertEquals("abcXYZxyz", run("APPEND_IF_MISSING('abcXYZ', 'xyz', 'mno')", new HashedMap()));    Assert.assertEquals(null, run("APPEND_IF_MISSING(null, null, null)", new HashedMap()));    Assert.assertEquals("xyz", run("APPEND_IF_MISSING('', 'xyz', null)", new HashedMap()));        boolean thrown = false;    try {        run("APPEND_IF_MISSING()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("APPEND_IF_MISSING('abc')", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("APPEND_IF_MISSING('abc', 'def', 'ghi', 'jkl')", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("APPEND_IF_MISSING(123, 'abc')", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("cannot be cast"));    }    Assert.assertTrue(thrown);}
public void metron_f9808_0() throws Exception
{    Map<String, Object> variables = ImmutableMap.of("s", "apache metron");    Assert.assertEquals("metron", run("SUBSTRING(s, 7)", variables));    Assert.assertEquals("me", run("SUBSTRING(s, 7, 9)", variables));    Assert.assertNull(run("SUBSTRING(null, 7, 9)", new HashMap<>()));    Assert.assertNull(run("SUBSTRING(null, null, 9)", new HashMap<>()));    Assert.assertNull(run("SUBSTRING(s, null, 9)", variables));    Assert.assertNull(run("SUBSTRING(null, null, null)", new HashMap<>()));    Assert.assertEquals("metron", run("SUBSTRING(s, 7, null)", variables));}
public void metron_f9809_0() throws Exception
{    Assert.assertEquals("metron", run("SUBSTRING()", new HashMap<>()));}
public void metron_f9810_0() throws Exception
{    Map<String, Object> variables = ImmutableMap.of("s", "apache metron");    Assert.assertEquals("metron", (String) run("SUBSTRING(s, '7')", variables));}
public void metron_f9811_0() throws Exception
{    Map<String, Object> variables = ImmutableMap.of("s", "apache metron");    Assert.assertEquals("metron", (String) run("SUBSTRING(s, 7, '9')", variables));}
public void metron_f9812_0() throws Exception
{    Map<String, Object> variables = ImmutableMap.of("s", 7);    Assert.assertEquals("metron", (String) run("SUBSTRING(s, 7, '9')", variables));}
public void metron_f9813_0() throws Exception
{    Assert.assertEquals(0, (int) run("COUNT_MATCHES(null, '*')", new HashedMap()));    Assert.assertEquals(2, (int) run("COUNT_MATCHES('apachemetron', 'e')", new HashedMap()));    Assert.assertEquals(2, (int) run("COUNT_MATCHES('anand', 'an')", new HashedMap()));    Assert.assertEquals(0, (int) run("COUNT_MATCHES('abcd', null)", new HashedMap()));        boolean thrown = false;    try {        run("COUNT_MATCHES()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("COUNT_MATCHES('abc')", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("incorrect arguments"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("COUNT_MATCHES(123, 456)", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("cannot be cast"));    }    Assert.assertTrue(thrown);}
public void metron_f9814_0() throws Exception
{        Object ret1 = run("TO_JSON_OBJECT(msg)", ImmutableMap.of("msg", string1));    Assert.assertNotNull(ret1);    Assert.assertTrue(ret1 instanceof HashMap);    Object ret2 = run("TO_JSON_OBJECT(msg)", ImmutableMap.of("msg", string2));    Assert.assertNotNull(ret2);    Assert.assertTrue(ret2 instanceof HashMap);    Assert.assertEquals("def", run("MAP_GET( 'bar', returnval)", ImmutableMap.of("returnval", ret2)));        Object ret3 = run("TO_JSON_OBJECT(msg)", ImmutableMap.of("msg", string3));    Assert.assertNotNull(ret3);    Assert.assertTrue(ret3 instanceof ArrayList);    List<Object> result3 = (List<Object>) ret3;    Assert.assertEquals(2, result3.get(1));    Object ret4 = run("TO_JSON_OBJECT(msg)", ImmutableMap.of("msg", string4));    Assert.assertNotNull(ret4);    Assert.assertTrue(ret4 instanceof ArrayList);    List<Object> result4 = (List<Object>) ret4;    Assert.assertEquals("car", result4.get(2));        Object ret5 = run("TO_JSON_OBJECT(msg)", ImmutableMap.of("msg", string5));    Assert.assertNotNull(ret5);    Assert.assertTrue(ret5 instanceof ArrayList);    List<List<Object>> result5 = (List<List<Object>>) ret5;    HashMap<String, String> results5Map1 = (HashMap) result5.get(0);    Assert.assertEquals("def", results5Map1.get("bar1"));    HashMap<String, String> results5Map2 = (HashMap) result5.get(1);    Assert.assertEquals("ghi", results5Map2.get("foo2"));        boolean thrown = false;    try {        run("TO_JSON_OBJECT()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("Unable to parse"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("TO_JSON_OBJECT('123, 456')", new HashedMap<>());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("Valid JSON string not supplied"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("TO_JSON_OBJECT('{\"foo\" : 2')", new HashedMap<>());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("Valid JSON string not supplied"));    }    Assert.assertTrue(thrown);    thrown = false;}
public void metron_f9815_0() throws Exception
{        Object ret1 = run("TO_JSON_MAP(msg)", ImmutableMap.of("msg", string1));    Assert.assertNotNull(ret1);    Assert.assertTrue(ret1 instanceof HashMap);    Object ret2 = run("TO_JSON_MAP(msg)", ImmutableMap.of("msg", string2));    Assert.assertNotNull(ret2);    Assert.assertTrue(ret2 instanceof HashMap);    Assert.assertEquals("def", run("MAP_GET( 'bar', returnval)", ImmutableMap.of("returnval", ret2)));        boolean thrown = false;    try {        Object o = run("TO_JSON_MAP(msg)", ImmutableMap.of("msg", string3));        System.out.println(string3 + " == " + o);    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);    thrown = false;    try {        run("TO_JSON_MAP(msg)", ImmutableMap.of("msg", string4));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);        thrown = false;    try {        run("TO_JSON_MAP(msg)", ImmutableMap.of("msg", string5));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);        try {        run("TO_JSON_MAP()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("Unable to parse"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("TO_JSON_MAP('123, 456')", new HashedMap<>());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("is not a valid JSON string"));    }    Assert.assertTrue(thrown);    thrown = false;        try {        run("TO_JSON_MAP('{\"foo\" : 2')", new HashedMap<>());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("is not a valid JSON string"));    }    Assert.assertTrue(thrown);    thrown = false;}
public void metron_f9816_0() throws Exception
{        Object ret3 = run("TO_JSON_LIST(msg)", ImmutableMap.of("msg", string3));    Assert.assertNotNull(ret3);    Assert.assertTrue(ret3 instanceof ArrayList);    List<Object> result3 = (List<Object>) ret3;    Assert.assertEquals(2, result3.get(1));    Object ret4 = run("TO_JSON_LIST(msg)", ImmutableMap.of("msg", string4));    Assert.assertNotNull(ret4);    Assert.assertTrue(ret4 instanceof ArrayList);    List<Object> result4 = (List<Object>) ret4;    Assert.assertEquals("car", result4.get(2));        Object ret5 = run("TO_JSON_LIST(msg)", ImmutableMap.of("msg", string5));    Assert.assertNotNull(ret5);    Assert.assertTrue(ret5 instanceof ArrayList);    List<List<Object>> result5 = (List<List<Object>>) ret5;    HashMap<String, String> results5Map1 = (HashMap) result5.get(0);    Assert.assertEquals("def", results5Map1.get("bar1"));    HashMap<String, String> results5Map2 = (HashMap) result5.get(1);    Assert.assertEquals("ghi", results5Map2.get("foo2"));        boolean thrown = false;    try {        run("TO_JSON_LIST(msg)", ImmutableMap.of("msg", string1));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);    thrown = false;    try {        run("TO_JSON_LIST(msg)", ImmutableMap.of("msg", string2));    } catch (ParseException pe) {        thrown = true;    }    Assert.assertTrue(thrown);        thrown = false;    try {        run("TO_JSON_LIST()", Collections.emptyMap());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("Unable to parse"));    }    Assert.assertTrue(thrown);        thrown = false;    try {        run("TO_JSON_LIST('123, 456')", new HashedMap<>());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("is not a valid JSON string"));    }    Assert.assertTrue(thrown);        thrown = false;    try {        run("TO_JSON_LIST('{\"foo\" : 2')", new HashedMap<>());    } catch (ParseException pe) {        thrown = true;        Assert.assertTrue(pe.getMessage().contains("is not a valid JSON string"));    }    Assert.assertTrue(thrown);}
public void metron_f9817_0()
{    SystemFunctions.EnvGet envGet = new SystemFunctions.EnvGet();    String envVal = (String) envGet.apply(ImmutableList.of("ENV_GET_VAR"));    assertThat("Value should not exist", envVal, equalTo(null));}
public void metron_f9818_0()
{    Environment env = mock(Environment.class);    when(env.get("ENV_GET_VAR")).thenReturn("ENV_GET_VALUE");    SystemFunctions.EnvGet envGet = new SystemFunctions.EnvGet(env);    String envVal = (String) envGet.apply(ImmutableList.of("ENV_GET_VAR"));    assertThat("Value should match", envVal, equalTo("ENV_GET_VALUE"));}
public void metron_f9819_0()
{    SystemFunctions.EnvGet envGet = new SystemFunctions.EnvGet();    String envVal = (String) envGet.apply(ImmutableList.of(new ArrayList()));    assertThat("Value should be null", envVal, equalTo(null));}
public void metron_f9820_0()
{    System.getProperties().put("ENV_GET_VAR", "ENV_GET_VALUE");    SystemFunctions.PropertyGet propertyGet = new SystemFunctions.PropertyGet();    String propertyVal = (String) propertyGet.apply(ImmutableList.of("ENV_GET_VAR"));    assertThat("Value should match", propertyVal, equalTo("ENV_GET_VALUE"));}
public void metron_f9821_0()
{    SystemFunctions.PropertyGet propertyGet = new SystemFunctions.PropertyGet();    String propertyVal = (String) propertyGet.apply(ImmutableList.of("PROPERTY_MISSING"));    assertThat("Value should not exist", propertyVal, equalTo(null));}
public void metron_f9822_0()
{    SystemFunctions.PropertyGet propertyGet = new SystemFunctions.PropertyGet();    String propertyVal = (String) propertyGet.apply(ImmutableList.of(new ArrayList()));    assertThat("Value should be null", propertyVal, equalTo(null));}
public void metron_f9823_0()
{    Object ret = run("FUZZY_LANGS()", new HashMap<>());    Assert.assertNotNull(ret);    Assert.assertTrue(ret instanceof List);    List<String> tags = (List<String>) ret;    Assert.assertTrue(tags.size() > 0);    Assert.assertTrue(tags.contains("en"));    Assert.assertTrue(tags.contains("fr"));}
public void metron_f9824_0() throws Exception
{    Assert.assertTrue(runPredicate("0 == FUZZY_SCORE(metron,'z',english)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9825_0() throws Exception
{    runPredicate("0 == FUZZY_SCORE(metron,'z',klingon)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v)));}
public void metron_f9826_0() throws Exception
{    Assert.assertTrue(runPredicate("0 == FUZZY_SCORE(empty,'z',english)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9827_0() throws Exception
{    Assert.assertTrue(runPredicate("0 == FUZZY_SCORE(empty,empty,english)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9828_0() throws Exception
{    runPredicate("0 == FUZZY_SCORE(empty,empty,empty)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v)));}
public void metron_f9829_0() throws Exception
{    runPredicate("0 == FUZZY_SCORE()", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v)));}
public void metron_f9830_0() throws Exception
{    Assert.assertTrue(runPredicate("1 == FUZZY_SCORE(metron,'m',english)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("16 == FUZZY_SCORE(metron,'metron',english)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));    Assert.assertTrue(runPredicate("3 == FUZZY_SCORE(asf,'asf',english)", new DefaultVariableResolver(v -> variableMap.get(v), v -> variableMap.containsKey(v))));}
public void metron_f9831_1()
{    try {                this.autoCompleter = new DefaultStellarAutoCompleter();                Properties props = getProperty();        this.executor = createExecutor(props);    } catch (Exception e) {                throw new RuntimeException(e);    }}
public void metron_f9832_0()
{}
public InterpreterResult metron_f9833_0(final String input, InterpreterContext context)
{    InterpreterResult result = new InterpreterResult(SUCCESS, TEXT, "");    try {                String[] expressions = input.split(System.lineSeparator());        for (String expression : expressions) {            result = execute(expression);        }    } catch (Throwable t) {                String message = getErrorMessage(Optional.of(t), input);        result = new InterpreterResult(ERROR, TEXT, message);    }        return result;}
private InterpreterResult metron_f9834_0(final String expression)
{    InterpreterResult result;        StellarResult stellarResult = executor.execute(expression);    if (stellarResult.isSuccess()) {                Object value = stellarResult.getValue().orElse("");        String text = value.toString();        result = new InterpreterResult(SUCCESS, TEXT, text);    } else if (stellarResult.isError()) {                Optional<Throwable> e = stellarResult.getException();        String message = getErrorMessage(e, expression);        result = new InterpreterResult(ERROR, TEXT, message);    } else {                throw new IllegalStateException("Unexpected error. result=" + stellarResult);    }    return result;}
public void metron_f9835_0(InterpreterContext context)
{}
public FormType metron_f9836_0()
{    return FormType.SIMPLE;}
public int metron_f9837_0(InterpreterContext context)
{        return 0;}
public List<InterpreterCompletion> metron_f9838_0(String buf, int cursor)
{        List<InterpreterCompletion> completes = new ArrayList<>();    for (String candidate : autoCompleter.autoComplete(buf)) {        completes.add(new InterpreterCompletion(candidate, candidate));    }    return completes;}
private String metron_f9839_0(Optional<Throwable> e, String input)
{    String message;    if (e.isPresent()) {                String error = ExceptionUtils.getRootCauseMessage(e.get());        String trace = ExceptionUtils.getStackTrace(e.get());        message = error + System.lineSeparator() + trace;    } else {                message = "Invalid expression: " + input;    }    return message;}
private StellarShellExecutor metron_f9840_0(Properties properties) throws Exception
{        String zookeeperURL = StellarInterpreterProperty.ZOOKEEPER_URL.get(properties, String.class);    StellarShellExecutor executor = new DefaultStellarShellExecutor(properties, Optional.ofNullable(zookeeperURL));        executor.addSpecialListener((magic) -> autoCompleter.addCandidateFunction(magic.getCommand()));    executor.addFunctionListener((fn) -> autoCompleter.addCandidateFunction(fn.getName()));    executor.addVariableListener((name, val) -> autoCompleter.addCandidateVariable(name));    executor.init();    return executor;}
public StellarShellExecutor metron_f9841_0()
{    return executor;}
public String metron_f9842_0()
{    return key;}
public T metron_f9843_0(Class<T> clazz)
{    return ConversionUtils.convert(defaultValue, clazz);}
public T metron_f9844_0(Map<Object, Object> properties, Class<T> clazz)
{    Object o = properties.getOrDefault(key, defaultValue);    return o == null ? null : ConversionUtils.convert(o, clazz);}
public String metron_f9845_0()
{    return key;}
public void metron_f9846_0() throws UnableToStartException
{    try {        upload();    } catch (Exception e) {        throw new UnableToStartException(e.getMessage(), e);    }}
public void metron_f9847_0()
{}
private void metron_f9848_0() throws Exception
{    assert zookeeperURL != null;    try (CuratorFramework client = getClient(zookeeperURL)) {        if (client.getState() != CuratorFrameworkState.STARTED) {            client.start();        }        if (globals != null) {            writeGlobalConfigToZookeeper(globals, client);        }    }}
public ConfigUploadComponent metron_f9849_0(String zookeeperURL)
{    this.zookeeperURL = zookeeperURL;    return this;}
public ConfigUploadComponent metron_f9850_0(Map<String, Object> globals)
{    this.globals = globals;    return this;}
public void metron_f9851_0() throws Exception
{        Map<String, Object> globals = new HashMap<>();    ConfigUploadComponent configUploader = new ConfigUploadComponent().withGlobals(globals);        properties = new Properties();    zkServer = getZKServerComponent(properties);        zkServer.withPostStartCallback((zk) -> {        zookeeperURL = zk.getConnectionString();        configUploader.withZookeeperURL(zookeeperURL);    });        runner = new ComponentRunner.Builder().withComponent("zk", zkServer).withComponent("config", configUploader).build();    runner.start();    context = mock(InterpreterContext.class);}
public void metron_f9852_0() throws Exception
{    runner.stop();}
public void metron_f9853_0()
{        Properties props = new Properties();    props.put(ZOOKEEPER_URL.toString(), zookeeperURL);        interpreter = new StellarInterpreter(props);    interpreter.open();        Optional<Object> zk = interpreter.getExecutor().getContext().getCapability(Context.Capabilities.ZOOKEEPER_CLIENT, false);    assertTrue(zk.isPresent());}
public void metron_f9854_0()
{        final String expected = "zookeeper:2181";    Map<Object, Object> props = Collections.singletonMap("zookeeper.url", expected);        String actual = ZOOKEEPER_URL.get(props, String.class);    assertEquals(expected, actual);}
public void metron_f9855_0()
{        Map<Object, Object> props = Collections.singletonMap("foo", "bar");    String actual = ZOOKEEPER_URL.get(props, String.class);        String expected = ZOOKEEPER_URL.getDefault(String.class);    assertEquals(expected, actual);}
public void metron_f9856_0()
{    Properties props = new Properties();    interpreter = new StellarInterpreter(props);    interpreter.open();    context = mock(InterpreterContext.class);}
public void metron_f9857_0()
{    InterpreterResult result = interpreter.interpret("2 + 2", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, result.message().size());        InterpreterResultMessage message = result.message().get(0);    assertEquals("4", message.getData());    assertEquals(InterpreterResult.Type.TEXT, message.getType());}
public void metron_f9858_0()
{    final String expected = "[1, 2, 3, 4, 5]";    InterpreterResult result = interpreter.interpret("[1,2,3,4,5]", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, result.message().size());        InterpreterResultMessage message = result.message().get(0);    assertEquals(expected, message.getData());    assertEquals(InterpreterResult.Type.TEXT, message.getType());}
public void metron_f9859_0()
{    final String expected = "{foo=2, key=val}";    InterpreterResult result = interpreter.interpret("{ 'foo':2, 'key':'val' }", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, result.message().size());        InterpreterResultMessage message = result.message().get(0);    assertEquals(expected, message.getData());    assertEquals(InterpreterResult.Type.TEXT, message.getType());}
public void metron_f9860_0()
{    InterpreterResult result = interpreter.interpret("2 + ", context);        assertEquals(InterpreterResult.Code.ERROR, result.code());    assertEquals(1, result.message().size());        InterpreterResultMessage message = result.message().get(0);    assertTrue(message.getData().length() > 0);    assertEquals(InterpreterResult.Type.TEXT, message.getType());}
public void metron_f9861_0()
{        InterpreterResult result = interpreter.interpret("x", context);        assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, result.message().size());        InterpreterResultMessage message = result.message().get(0);    assertEquals(0, message.getData().length());    assertEquals(InterpreterResult.Type.TEXT, message.getType());}
public void metron_f9862_0()
{        final String buffer = "TO_";        int cursor = buffer.length();    List<InterpreterCompletion> completions = interpreter.completion(buffer, cursor);        assertTrue(completions.size() > 0);    for (InterpreterCompletion iCompletion : completions) {        String completion = iCompletion.getValue();                assertEquals("(", completion.substring(completion.length() - 1));                String function = completion.substring(0, completion.length() - 1);        Iterable<String> allFunctions = interpreter.getExecutor().getFunctionResolver().getFunctions();        String definedFunction = Iterables.find(allFunctions, (fn) -> StringUtils.equals(fn, function));        assertEquals(function, definedFunction);    }}
public void metron_f9863_0()
{        final String buffer = "NOTHING_AUTOCOMPLETES_THIS_";        int cursor = buffer.length();        List<InterpreterCompletion> completions = interpreter.completion(buffer, cursor);        assertEquals(0, completions.size());}
public void metron_f9864_0()
{        Properties props = new Properties();        interpreter = new StellarInterpreter(props);    interpreter.open();        Optional<Object> zk = interpreter.getExecutor().getContext().getCapability(Context.Capabilities.ZOOKEEPER_CLIENT, false);    assertFalse(zk.isPresent());}
public void metron_f9865_0()
{        String input = "x := 2 + 2" + System.lineSeparator() + "y := 4 + 4";    InterpreterResult result = interpreter.interpret(input, context);        Map<String, VariableResult> vars = interpreter.getExecutor().getState();    assertEquals(4, vars.get("x").getResult());    assertEquals(8, vars.get("y").getResult());        assertEquals(InterpreterResult.Code.SUCCESS, result.code());    assertEquals(1, result.message().size());        InterpreterResultMessage message = result.message().get(0);    assertEquals("8", message.getData());    assertEquals(InterpreterResult.Type.TEXT, message.getType());}
