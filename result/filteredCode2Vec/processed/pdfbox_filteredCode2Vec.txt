public Component pdfbox_f0_0(JTable jTable, Object o, boolean b, boolean b2, int i, int i2)
{    JLabel colorBar = new JLabel();    colorBar.setOpaque(true);    colorBar.setBackground((Color) o);    return colorBar;}
private void pdfbox_f1_0()
{    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    panel.setPreferredSize(new Dimension(300, 500));    if (colorSpace == null) {        JLabel error = new JLabel(errmsg);        error.setAlignmentX(Component.CENTER_ALIGNMENT);        error.setFont(new Font(Font.MONOSPACED, Font.BOLD, 15));        panel.add(error);        return;    }    JLabel colorSpaceLabel = new JLabel(colorSpace.getName() + " colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    panel.add(colorSpaceLabel);    if (numberOfComponents > 0) {        JLabel colorCountLabel = new JLabel("Component Count: " + numberOfComponents);        colorCountLabel.setAlignmentX(Component.CENTER_ALIGNMENT);        colorCountLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));        panel.add(colorCountLabel);    }    if (colorSpace instanceof PDICCBased) {        PDICCBased icc = (PDICCBased) colorSpace;        int colorSpaceType = icc.getColorSpaceType();        String cs;        switch(colorSpaceType) {            case ColorSpace.CS_LINEAR_RGB:                cs = "linear RGB";                break;            case ColorSpace.CS_CIEXYZ:                cs = "CIEXYZ";                break;            case ColorSpace.CS_GRAY:                cs = "linear gray";                break;            case ColorSpace.CS_sRGB:                cs = "sRGB";                break;            case ColorSpace.TYPE_RGB:                cs = "RGB";                break;            case ColorSpace.TYPE_GRAY:                cs = "gray";                break;            case ColorSpace.TYPE_CMYK:                cs = "CMYK";                break;            default:                cs = "type " + colorSpaceType;                break;        }        JLabel otherLabel = new JLabel("Colorspace type: " + cs);        otherLabel.setAlignmentX(Component.CENTER_ALIGNMENT);        otherLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));        panel.add(otherLabel);    }}
public Component pdfbox_f2_0()
{    return panel;}
private DeviceNColorant[] pdfbox_f3_0() throws IOException
{    int componentCount = deviceN.getNumberOfComponents();    DeviceNColorant[] colorants = new DeviceNColorant[componentCount];    for (int i = 0; i < componentCount; i++) {        DeviceNColorant colorant = new DeviceNColorant();        colorant.setName(deviceN.getColorantNames().get(i));        float[] maximum = new float[componentCount];        Arrays.fill(maximum, 0);        float[] minimum = new float[componentCount];        Arrays.fill(minimum, 0);        maximum[i] = 1;        colorant.setMaximum(getColorObj(deviceN.toRGB(maximum)));        colorant.setMinimum(getColorObj(deviceN.toRGB(minimum)));        colorants[i] = colorant;    }    return colorants;}
private void pdfbox_f4_0(DeviceNColorant[] colorants)
{    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    panel.setPreferredSize(new Dimension(300, 500));    JLabel colorSpaceLabel = new JLabel("DeviceN colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    DeviceNTableModel tableModel = new DeviceNTableModel(colorants);    JTable table = new JTable(tableModel);    table.setDefaultRenderer(Color.class, new ColorBarCellRenderer());    table.setRowHeight(60);    JScrollPane scrollPane = new JScrollPane();    scrollPane.setViewportView(table);    panel.add(colorSpaceLabel);    panel.add(scrollPane);}
public Component pdfbox_f5_0()
{    return panel;}
private Color pdfbox_f6_0(float[] rgbValues)
{    return new Color(rgbValues[0], rgbValues[1], rgbValues[2]);}
private IndexedColorant[] pdfbox_f7_0()
{    IndexedColorant[] colorants = new IndexedColorant[colorCount];    for (int i = 0; i < colorCount; i++) {        IndexedColorant colorant = new IndexedColorant();        colorant.setIndex(i);        float[] rgbValues = indexed.toRGB(new float[] { i });        colorant.setRgbValues(rgbValues);        colorants[i] = colorant;    }    return colorants;}
private void pdfbox_f8_0(IndexedColorant[] colorants)
{    panel = new JPanel();    panel.setLayout(new GridBagLayout());    panel.setPreferredSize(new Dimension(300, 500));    JLabel colorSpaceLabel = new JLabel("Indexed colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    JPanel colorspaceLabelPanel = new JPanel();    colorspaceLabelPanel.setAlignmentX(Component.LEFT_ALIGNMENT);    colorspaceLabelPanel.add(colorSpaceLabel);    JLabel colorCountLabel = new JLabel(" Total Color Count: " + colorCount);    colorCountLabel.setAlignmentX(Component.LEFT_ALIGNMENT);    colorCountLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));    IndexedTableModel tableModel = new IndexedTableModel(colorants);    JTable table = new JTable(tableModel);    table.setDefaultRenderer(Color.class, new ColorBarCellRenderer());    table.setRowHeight(40);    table.getColumnModel().getColumn(0).setMinWidth(30);    table.getColumnModel().getColumn(0).setMaxWidth(50);    table.getColumnModel().getColumn(1).setMinWidth(100);    table.getColumnModel().getColumn(1).setMaxWidth(100);    JScrollPane scrollPane = new JScrollPane();    scrollPane.setViewportView(table);    scrollPane.setAlignmentX(Component.LEFT_ALIGNMENT);    Box box = Box.createVerticalBox();    box.add(colorCountLabel);    box.add(scrollPane);    box.setAlignmentX(Component.LEFT_ALIGNMENT);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weighty = 0.05;    gbc.fill = GridBagConstraints.HORIZONTAL;    gbc.anchor = GridBagConstraints.PAGE_START;    panel.add(colorspaceLabelPanel, gbc);    gbc.gridy = 2;    gbc.weighty = 0.9;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    gbc.anchor = GridBagConstraints.BELOW_BASELINE;    panel.add(box, gbc);}
public Component pdfbox_f9_0()
{    return panel;}
private int pdfbox_f10_0(COSArray array)
{    int hival = ((COSNumber) array.getObject(2).getCOSObject()).intValue();    return Math.min(hival, 255);}
private void pdfbox_f11_0()
{    Font boldFont = new Font(Font.MONOSPACED, Font.BOLD, 20);    GridBagConstraints gbc = new GridBagConstraints();    gbc.insets = new Insets(2, 2, 2, 2);    JPanel inputPanel = new JPanel(new GridBagLayout());    slider = new JSlider(0, 100, 50);    slider.setMajorTickSpacing(50);    slider.setPaintTicks(true);    @SuppressWarnings({ "squid:S1149" })    Dictionary<Integer, JLabel> labelTable = new Hashtable<>();    JLabel lightest = new JLabel("lightest");    lightest.setFont(new Font(Font.MONOSPACED, Font.BOLD, 10));    JLabel darkest = new JLabel("darkest");    darkest.setFont(new Font(Font.MONOSPACED, Font.BOLD, 10));    JLabel midPoint = new JLabel("0.5");    midPoint.setFont(new Font(Font.MONOSPACED, Font.BOLD, 10));    labelTable.put(0, lightest);    labelTable.put(50, midPoint);    labelTable.put(100, darkest);    slider.setPaintLabels(true);    slider.setLabelTable(labelTable);    slider.addChangeListener(this);    gbc.gridx = 0;    gbc.gridy = 0;    gbc.gridwidth = 10;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.HORIZONTAL;    inputPanel.add(slider, gbc);    JLabel tintLabel = new JLabel("Tint Value:");    tintLabel.setFont(boldFont);    gbc.gridx = 0;    gbc.gridy = 1;    gbc.weightx = 0.5;    gbc.gridwidth = 1;    gbc.fill = GridBagConstraints.HORIZONTAL;    inputPanel.add(tintLabel, gbc);    tintField = new JTextField();    tintField.addActionListener(this);    tintField.setPreferredSize(new Dimension(10, 30));    gbc.gridx = 1;    gbc.weightx = 0.5;    gbc.gridwidth = 1;    gbc.fill = GridBagConstraints.HORIZONTAL;    inputPanel.add(tintField, gbc);    JPanel contentPanel = new JPanel(new GridBagLayout());    GridBagConstraints gbc2 = new GridBagConstraints();    gbc2.gridx = 0;    gbc2.gridy = 0;    gbc2.gridwidth = 2;    gbc2.weightx = 0.3;    gbc2.weighty = 1;    gbc2.fill = GridBagConstraints.HORIZONTAL;    contentPanel.add(inputPanel, gbc2);    colorBar = new JLabel();    colorBar.setOpaque(true);    gbc2.gridx = 2;    gbc2.weightx = 0.7;    gbc2.gridwidth = 4;    gbc2.gridheight = 2;    gbc2.fill = GridBagConstraints.BOTH;    contentPanel.add(colorBar, gbc2);    setColorBarBorder();    JPanel mainpanel = new JPanel(new GridBagLayout());    JLabel colorantNameLabel = new JLabel("Colorant: " + separation.getColorantName());    colorantNameLabel.setFont(boldFont);    GridBagConstraints maingbc = new GridBagConstraints();    maingbc.gridx = 0;    maingbc.gridy = 0;    maingbc.weightx = 1;    maingbc.weighty = 0.03;    maingbc.anchor = GridBagConstraints.FIRST_LINE_START;    mainpanel.add(colorantNameLabel, maingbc);    maingbc.gridx = 0;    maingbc.gridy = 1;    maingbc.weighty = 0.97;    maingbc.gridwidth = 10;    maingbc.fill = GridBagConstraints.HORIZONTAL;    mainpanel.add(contentPanel, maingbc);    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    panel.setPreferredSize(new Dimension(300, 500));    JLabel colorSpaceLabel = new JLabel("Separation colorspace");    colorSpaceLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    colorSpaceLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    panel.add(colorSpaceLabel);    panel.add(mainpanel);}
private void pdfbox_f12_0()
{    slider.setValue(getIntRepresentation(tintValue));    tintField.setText(Float.toString(tintValue));}
public JPanel pdfbox_f13_0()
{    return panel;}
public void pdfbox_f14_0(ChangeEvent changeEvent)
{    int value = slider.getValue();    tintValue = getFloatRepresentation(value);    tintField.setText(Float.toString(tintValue));    updateColorBar();}
public void pdfbox_f15_0(ActionEvent actionEvent)
{    String input = tintField.getText();    try {        tintValue = Float.parseFloat(input);        slider.setValue(getIntRepresentation(tintValue));        updateColorBar();    } catch (NumberFormatException e) {        tintField.setText(Float.toString(tintValue));    }}
private void pdfbox_f16_0()
{    try {        float[] rgbValues = separation.toRGB(new float[] { tintValue });        colorBar.setBackground(new Color(rgbValues[0], rgbValues[1], rgbValues[2]));    } catch (IOException e) {        throw new RuntimeException(e);    }}
private void pdfbox_f17_0()
{    try {        float[] rgbValues = separation.toRGB(new float[] { 1 });        Color darkest = new Color(rgbValues[0], rgbValues[1], rgbValues[2]);        colorBar.setBorder(new BevelBorder(BevelBorder.LOWERED, darkest, darkest));    } catch (IOException e) {        throw new RuntimeException(e);    }}
private float pdfbox_f18_0(int value)
{    return (float) value / 100;}
private int pdfbox_f19_0(float value)
{    return (int) (value * 100);}
public String pdfbox_f20_0()
{    return name;}
public void pdfbox_f21_0(String name)
{    this.name = name;}
public Color pdfbox_f22_0()
{    return maximum;}
public void pdfbox_f23_0(Color maximum)
{    this.maximum = maximum;}
public Color pdfbox_f24_0()
{    return minimum;}
public void pdfbox_f25_0(Color minimum)
{    this.minimum = minimum;}
public int pdfbox_f26_0()
{    return data.length;}
public int pdfbox_f27_0()
{    return COLUMNNAMES.length;}
public Object pdfbox_f28_0(int row, int column)
{    switch(column) {        case 0:            return data[row].getName();        case 1:            return data[row].getMaximum();        case 2:            return data[row].getMinimum();        default:            return null;    }}
public String pdfbox_f29_0(int column)
{    return COLUMNNAMES[column];}
public Class<?> pdfbox_f30_0(int columnIndex)
{    switch(columnIndex) {        case 0:            return String.class;        case 1:        case 2:            return Color.class;        default:            return null;    }}
public int pdfbox_f31_0()
{    return index;}
public void pdfbox_f32_0(int index)
{    this.index = index;}
public void pdfbox_f33_0(float[] rgbValues)
{    this.rgbValues = rgbValues;}
public Color pdfbox_f34_0()
{    return new Color(rgbValues[0], rgbValues[1], rgbValues[2]);}
public String pdfbox_f35_0()
{    StringBuilder builder = new StringBuilder();    for (float i : rgbValues) {        builder.append((int) (i * 255));        builder.append(", ");    }    builder.deleteCharAt(builder.lastIndexOf(","));    return builder.toString();}
public int pdfbox_f36_0()
{    return data.length;}
public int pdfbox_f37_0()
{    return COLUMNSNAMES.length;}
public Object pdfbox_f38_0(int row, int column)
{    switch(column) {        case 0:            return data[row].getIndex();        case 1:            return data[row].getRGBValuesString();        case 2:            return data[row].getColor();        default:            return null;    }}
public String pdfbox_f39_0(int column)
{    return COLUMNSNAMES[column];}
public Class<?> pdfbox_f40_0(int columnIndex)
{    switch(columnIndex) {        case 0:            return Integer.class;        case 1:            return String.class;        case 2:            return Color.class;        default:            return null;    }}
 String pdfbox_f41_0()
{    return "Annot flag";}
 String pdfbox_f42_0()
{    return "Flag value: " + annotDictionary.getInt(COSName.F);}
 Object[][] pdfbox_f43_0()
{    PDAnnotation annotation = new PDAnnotation(annotDictionary) {    };    return new Object[][] { new Object[] { 1, "Invisible", annotation.isInvisible() }, new Object[] { 2, "Hidden", annotation.isHidden() }, new Object[] { 3, "Print", annotation.isPrinted() }, new Object[] { 4, "NoZoom", annotation.isNoZoom() }, new Object[] { 5, "NoRotate", annotation.isNoRotate() }, new Object[] { 6, "NoView", annotation.isNoView() }, new Object[] { 7, "ReadOnly", annotation.isReadOnly() }, new Object[] { 8, "Locked", annotation.isLocked() }, new Object[] { 9, "ToggleNoView", annotation.isToggleNoView() }, new Object[] { 10, "LockedContents", annotation.isLocked() } };}
 String pdfbox_f44_0()
{    return "Encrypt flag";}
 String pdfbox_f45_0()
{    return "Flag value:" + encryptDictionary.getInt(COSName.P);}
 Object[][] pdfbox_f46_0()
{    AccessPermission ap = new AccessPermission(encryptDictionary.getInt(COSName.P));    return new Object[][] { new Object[] { 3, "can print", ap.canPrint() }, new Object[] { 4, "can modify", ap.canModify() }, new Object[] { 5, "can extract content", ap.canExtractContent() }, new Object[] { 6, "can modify annotations", ap.canModifyAnnotations() }, new Object[] { 9, "can fill in form fields", ap.canFillInForm() }, new Object[] { 10, "can extract for accessibility", ap.canExtractForAccessibility() }, new Object[] { 11, "can assemble document", ap.canAssembleDocument() }, new Object[] { 12, "can print degraded", ap.canPrintDegraded() } };}
 String pdfbox_f47_0()
{    COSName fieldType = dictionary.getCOSName(COSName.FT);    if (COSName.TX.equals(fieldType)) {        return "Text field flag";    } else if (COSName.BTN.equals(fieldType)) {        return "Button field flag";    } else if (COSName.CH.equals(fieldType)) {        return "Choice field flag";    }    return null;}
 String pdfbox_f48_0()
{    return "Flag value: " + dictionary.getInt(COSName.FF);}
 Object[][] pdfbox_f49_0()
{    int flagValue = dictionary.getInt(COSName.FF);    COSName fieldType = dictionary.getCOSName(COSName.FT);    if (COSName.TX.equals(fieldType)) {        return getTextFieldFlagBits(flagValue);    } else if (COSName.BTN.equals(fieldType)) {        return getButtonFieldFlagBits(flagValue);    } else if (COSName.CH.equals(fieldType)) {        return getChoiceFieldFlagBits(flagValue);    }    return null;}
private Object[][] pdfbox_f50_0(final int flagValue)
{    return new Object[][] { new Object[] { 1, "ReadOnly", isFlagBitSet(flagValue, 1) }, new Object[] { 2, "Required", isFlagBitSet(flagValue, 2) }, new Object[] { 3, "NoExport", isFlagBitSet(flagValue, 3) }, new Object[] { 13, "Multiline", isFlagBitSet(flagValue, 13) }, new Object[] { 14, "Password", isFlagBitSet(flagValue, 14) }, new Object[] { 21, "FileSelect", isFlagBitSet(flagValue, 21) }, new Object[] { 23, "DoNotSpellCheck", isFlagBitSet(flagValue, 23) }, new Object[] { 24, "DoNotScroll", isFlagBitSet(flagValue, 24) }, new Object[] { 25, "Comb", isFlagBitSet(flagValue, 25) }, new Object[] { 26, "RichText", isFlagBitSet(flagValue, 26) } };}
private Object[][] pdfbox_f51_0(final int flagValue)
{    return new Object[][] { new Object[] { 1, "ReadOnly", isFlagBitSet(flagValue, 1) }, new Object[] { 2, "Required", isFlagBitSet(flagValue, 2) }, new Object[] { 3, "NoExport", isFlagBitSet(flagValue, 3) }, new Object[] { 15, "NoToggleToOff", isFlagBitSet(flagValue, 15) }, new Object[] { 16, "Radio", isFlagBitSet(flagValue, 16) }, new Object[] { 17, "Pushbutton", isFlagBitSet(flagValue, 17) }, new Object[] { 26, "RadiosInUnison", isFlagBitSet(flagValue, 26) } };}
private Object[][] pdfbox_f52_0(final int flagValue)
{    return new Object[][] { new Object[] { 1, "ReadOnly", isFlagBitSet(flagValue, 1) }, new Object[] { 2, "Required", isFlagBitSet(flagValue, 2) }, new Object[] { 3, "NoExport", isFlagBitSet(flagValue, 3) }, new Object[] { 18, "Combo", isFlagBitSet(flagValue, 18) }, new Object[] { 19, "Edit", isFlagBitSet(flagValue, 19) }, new Object[] { 20, "Sort", isFlagBitSet(flagValue, 20) }, new Object[] { 22, "MultiSelect", isFlagBitSet(flagValue, 22) }, new Object[] { 23, "DoNotSpellCheck", isFlagBitSet(flagValue, 23) }, new Object[] { 27, "CommitOnSelChange", isFlagBitSet(flagValue, 27) } };}
private Boolean pdfbox_f53_0(int flagValue, int bitPosition)
{    int binaryFormat = 1 << (bitPosition - 1);    return (flagValue & binaryFormat) == binaryFormat;}
 String[] pdfbox_f54_0()
{    return new String[] { "Bit Position", "Name", "Set" };}
private void pdfbox_f55_0(final COSDictionary dictionary, final COSName flagType)
{    Flag flag;    if (COSName.FLAGS.equals(flagType)) {        flag = new FontFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.F.equals(flagType)) {        flag = new AnnotFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.FF.equals(flagType)) {        flag = new FieldFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.PANOSE.equals(flagType)) {        flag = new PanoseFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.P.equals(flagType)) {        flag = new EncryptFlag(dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }    if (COSName.SIG_FLAGS.equals(flagType)) {        flag = new SigFlag(document, dictionary);        view = new FlagBitsPaneView(flag.getFlagType(), flag.getFlagValue(), flag.getFlagBits(), flag.getColumnNames());    }}
public JPanel pdfbox_f56_0()
{    return view.getPanel();}
private void pdfbox_f57_0()
{    panel.setLayout(new GridBagLayout());    panel.setPreferredSize(new Dimension(300, 500));    JLabel flagLabel = new JLabel(flagHeader);    flagLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    flagLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 30));    JPanel flagLabelPanel = new JPanel();    flagLabelPanel.setAlignmentX(Component.LEFT_ALIGNMENT);    flagLabelPanel.add(flagLabel);    JLabel flagValueLabel = new JLabel(flagValue);    flagValueLabel.setAlignmentX(Component.LEFT_ALIGNMENT);    flagValueLabel.setFont(new Font(Font.MONOSPACED, Font.BOLD, 20));    JTable table = new JTable(tableData, columnNames);    JScrollPane scrollPane = new JScrollPane(table);    table.setFillsViewportHeight(true);    scrollPane.setAlignmentX(Component.LEFT_ALIGNMENT);    Box box = Box.createVerticalBox();    box.add(flagValueLabel);    box.add(scrollPane);    box.setAlignmentX(Component.LEFT_ALIGNMENT);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weighty = 0.05;    gbc.fill = GridBagConstraints.HORIZONTAL;    gbc.anchor = GridBagConstraints.PAGE_START;    panel.add(flagLabelPanel, gbc);    gbc.gridy = 2;    gbc.weighty = 0.9;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    gbc.anchor = GridBagConstraints.BELOW_BASELINE;    panel.add(box, gbc);}
 JPanel pdfbox_f58_0()
{    return panel;}
 String pdfbox_f59_0()
{    return "Font flag";}
 String pdfbox_f60_0()
{    return "Flag value:" + fontDescriptor.getInt(COSName.FLAGS);}
 Object[][] pdfbox_f61_0()
{    PDFontDescriptor fontDesc = new PDFontDescriptor(fontDescriptor);    return new Object[][] { new Object[] { 1, "FixedPitch", fontDesc.isFixedPitch() }, new Object[] { 2, "Serif", fontDesc.isSerif() }, new Object[] { 3, "Symbolic", fontDesc.isSymbolic() }, new Object[] { 4, "Script", fontDesc.isScript() }, new Object[] { 6, "NonSymbolic", fontDesc.isNonSymbolic() }, new Object[] { 7, "Italic", fontDesc.isItalic() }, new Object[] { 17, "AllCap", fontDesc.isAllCap() }, new Object[] { 18, "SmallCap", fontDesc.isSmallCap() }, new Object[] { 19, "ForceBold", fontDesc.isForceBold() } };}
 String pdfbox_f62_0()
{    return "Panose classification";}
 String pdfbox_f63_0()
{    return "Panose byte :" + byteValue.toHexString();}
 Object[][] pdfbox_f64_0()
{    PDPanoseClassification pc = new PDPanose(bytes).getPanose();    return new Object[][] { { 2, "Family Kind", pc.getFamilyKind(), getFamilyKindValue(pc.getFamilyKind()) }, { 3, "Serif Style", pc.getSerifStyle(), getSerifStyleValue(pc.getSerifStyle()) }, { 4, "Weight", pc.getWeight(), getWeightValue(pc.getWeight()) }, { 5, "Proportion", pc.getProportion(), getProportionValue(pc.getProportion()) }, { 6, "Contrast", pc.getContrast(), getContrastValue(pc.getContrast()) }, { 7, "Stroke Variation", pc.getStrokeVariation(), getStrokeVariationValue(pc.getStrokeVariation()) }, { 8, "Arm Style", pc.getArmStyle(), getArmStyleValue(pc.getArmStyle()) }, { 9, "Letterform", pc.getLetterform(), getLetterformValue(pc.getLetterform()) }, { 10, "Midline", pc.getMidline(), getMidlineValue(pc.getMidline()) }, { 11, "X-height", pc.getXHeight(), getXHeightValue(pc.getXHeight()) } };}
 String[] pdfbox_f65_0()
{    return new String[] { "Byte Position", "Name", "Byte Value", "Value" };}
private String pdfbox_f66_0(int index)
{    return new String[] { "Any", "No Fit", "Latin Text", "Latin Hand Written", "Latin Decorative", "Latin Symbol" }[index];}
private String pdfbox_f67_0(int index)
{    return new String[] { "Any", "No Fit", "Cove", "Obtuse Cove", "Square Cove", "Obtuse Square Cove", "Square", "Thin", "Oval", "Exaggerated", "Triangle", "Normal Sans", "Obtuse Sans", "Perpendicular Sans", "Flared", "Rounded" }[index];}
private String pdfbox_f68_0(int index)
{    return new String[] { "Any", "No Fit", "Very Light", "Light", "Thin", "Book", "Medium", "Demi", "Bold", "Heavy", "Black", "Extra Black" }[index];}
private String pdfbox_f69_0(int index)
{    return new String[] { "Any", "No fit", "Old Style", "Modern", "Even Width", "Extended", "Condensed", "Very Extended", "Very Condensed", "Monospaced" }[index];}
private String pdfbox_f70_0(int index)
{    return new String[] { "Any", "No Fit", "None", "Very Low", "Low", "Medium Low", "Medium", "Medium High", "High", "Very High" }[index];}
private String pdfbox_f71_0(int index)
{    return new String[] { "Any", "No Fit", "No Variation", "Gradual/Diagonal", "Gradual/Transitional", "Gradual/Vertical", "Gradual/Horizontal", "Rapid/Vertical", "Rapid/Horizontal", "Instant/Vertical", "Instant/Horizontal" }[index];}
private String pdfbox_f72_0(int index)
{    return new String[] { "Any", "No Fit", "Straight Arms/Horizontal", "Straight Arms/Wedge", "Straight Arms/Vertical", "Straight Arms/Single Serif", "Straight Arms/Double Serif", "Non-Straight/Horizontal", "Non-Straight/Wedge", "Non-Straight/Vertical", "Non-Straight/Single Serif", "Non-Straight/Double Serif" }[index];}
private String pdfbox_f73_0(int index)
{    return new String[] { "Any", "No Fit", "Normal/Contact", "Normal/Weighted", "Normal/Boxed", "Normal/Flattened", "Normal/Rounded", "Normal/Off Center", "Normal/Square", "Oblique/Contact", "Oblique/Weighted", "Oblique/Boxed", "Oblique/Flattened", "Oblique/Rounded", "Oblique/Off Center", "Oblique/Square" }[index];}
private String pdfbox_f74_0(int index)
{    return new String[] { "Any", "No Fit", "Standard/Trimmed", "Standard/Pointed", "Standard/Serifed", "High/Trimmed", "High/Pointed", "High/Serifed", "Constant/Trimmed", "Constant/Pointed", "Constant/Serifed", "Low/Trimmed", "Low/Pointed", "Low/Serifed" }[index];}
private String pdfbox_f75_0(int index)
{    return new String[] { "Any", "No Fit", "Constant/Small", "Constant/Standard", "Constant/Large", "Ducking/Small", "Ducking/Standard", "Ducking/Large" }[index];}
public final byte[] pdfbox_f76_0(COSDictionary style)
{    if (style != null) {        COSString panose = (COSString) style.getDictionaryObject(COSName.PANOSE);        return panose.getBytes();    }    return null;}
 String pdfbox_f77_0()
{    return "Signature flag";}
 String pdfbox_f78_0()
{    return "Flag value: " + acroFormDictionary.getInt(COSName.SIG_FLAGS);}
 Object[][] pdfbox_f79_0()
{    PDAcroForm acroForm = new PDAcroForm(document, acroFormDictionary);    return new Object[][] { new Object[] { 1, "SignaturesExist", acroForm.isSignaturesExist() }, new Object[] { 2, "AppendOnly", acroForm.isAppendOnly() } };}
 double[] pdfbox_f80_0(Object[][] tableData, int glyphIndex)
{    double minY = 0;    double maxY = 0;    for (Object[] aTableData : tableData) {        GeneralPath path = (GeneralPath) aTableData[glyphIndex];        Rectangle2D bounds2D = path.getBounds2D();        if (bounds2D.isEmpty()) {            continue;        }        minY = Math.min(minY, bounds2D.getMinY());        maxY = Math.max(maxY, bounds2D.getMaxY());    }    return new double[] { minY, maxY };}
public JPanel pdfbox_f81_0()
{    if (fontPane != null) {        return fontPane.getPanel();    }    return null;}
private void pdfbox_f82_0(JPanel headerPanel, JTable table)
{    panel = new JPanel(new GridBagLayout());    panel.setPreferredSize(new Dimension(300, 500));    JScrollPane scrollPane = new JScrollPane(table);    table.setFillsViewportHeight(true);    scrollPane.setAlignmentX(Component.LEFT_ALIGNMENT);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weighty = 0.05;    gbc.fill = GridBagConstraints.HORIZONTAL;    gbc.anchor = GridBagConstraints.PAGE_START;    panel.add(headerPanel, gbc);    gbc.gridy = 2;    gbc.weighty = 0.9;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    gbc.anchor = GridBagConstraints.BELOW_BASELINE;    panel.add(scrollPane, gbc);}
private JTable pdfbox_f83_0(Object[][] tableData, String[] columnNames, double[] yBounds)
{    JTable table = new JTable(tableData, columnNames);    table.setRowHeight(40);    table.setDefaultRenderer(Object.class, new GlyphCellRenderer(yBounds));    return table;}
private JPanel pdfbox_f84_0(Map<String, String> attributes)
{    JPanel headerPanel = new JPanel(new GridBagLayout());    headerPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 5, 0));    if (attributes != null) {        Iterator<String> keys = attributes.keySet().iterator();        int row = 0;        while (keys.hasNext()) {            int fontSize = Integer.parseInt(PDFDebugger.configuration.getProperty("headerFontSize", Integer.toString(headerPanel.getFont().getSize())));            String key = keys.next();            JLabel encodingNameLabel = new JLabel(key + ": " + attributes.get(key));            encodingNameLabel.setFont(new Font(Font.DIALOG, Font.PLAIN, fontSize));            encodingNameLabel.setBorder(BorderFactory.createEmptyBorder(2, 0, 2, 0));            GridBagConstraints gbc = new GridBagConstraints();            gbc.gridx = 0;            gbc.gridy = row++;            gbc.weighty = 0.1;            gbc.anchor = GridBagConstraints.LINE_START;            headerPanel.add(encodingNameLabel, gbc);        }    }    return headerPanel;}
 JPanel pdfbox_f85_0()
{    return panel;}
public Component pdfbox_f86_0(JTable jTable, Object o, boolean b, boolean b1, int row, int col)
{    if (o instanceof GeneralPath) {        GeneralPath path = (GeneralPath) o;        Rectangle2D bounds2D = path.getBounds2D();        if (bounds2D.isEmpty()) {            JLabel label = new JLabel(SimpleFont.NO_GLYPH, SwingConstants.CENTER);            int fontSize = Integer.parseInt(PDFDebugger.configuration.getProperty("encodingFontSize", Integer.toString(label.getFont().getSize())));            label.setFont(new Font(Font.DIALOG, Font.PLAIN, fontSize));            label.setForeground(Color.GRAY);            return label;        }        Rectangle cellRect = jTable.getCellRect(row, col, false);        BufferedImage bim = renderGlyph(path, bounds2D, cellRect);        return new JLabel(new HighResolutionImageIcon(bim, (int) Math.ceil(bim.getWidth() / DEFAULT_TRANSFORM.getScaleX()), (int) Math.ceil(bim.getHeight() / DEFAULT_TRANSFORM.getScaleY())), SwingConstants.CENTER);    }    if (o instanceof BufferedImage) {        Rectangle cellRect = jTable.getCellRect(row, col, false);        BufferedImage glyphImage = (BufferedImage) o;        BufferedImage cellImage = new BufferedImage((int) (cellRect.getWidth() * DEFAULT_TRANSFORM.getScaleX()), (int) (cellRect.getHeight() * DEFAULT_TRANSFORM.getScaleY()), BufferedImage.TYPE_INT_RGB);        Graphics2D g = (Graphics2D) cellImage.getGraphics();        g.setBackground(Color.white);        g.clearRect(0, 0, cellImage.getWidth(), cellImage.getHeight());        double scale = 1 / (glyphImage.getHeight() / cellRect.getHeight());                g.translate((cellRect.getWidth() - glyphImage.getWidth() * scale) / 2 * DEFAULT_TRANSFORM.getScaleX(), 0);                g.scale(scale * DEFAULT_TRANSFORM.getScaleX(), scale * DEFAULT_TRANSFORM.getScaleY());        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);        g.drawImage(glyphImage, 0, 0, null);        g.dispose();        return new JLabel(new HighResolutionImageIcon(cellImage, (int) Math.ceil(cellImage.getWidth() / DEFAULT_TRANSFORM.getScaleX()), (int) Math.ceil(cellImage.getHeight() / DEFAULT_TRANSFORM.getScaleY())));    }    if (o != null) {        JLabel label = new JLabel(o.toString(), SwingConstants.CENTER);        int fontSize = Integer.parseInt(PDFDebugger.configuration.getProperty("encodingFontSize", Integer.toString(label.getFont().getSize())));        label.setFont(new Font(Font.DIALOG, Font.PLAIN, fontSize));        if (SimpleFont.NO_GLYPH.equals(o) || ".notdef".equals(o)) {            label.setText(o.toString());            label.setForeground(Color.GRAY);        }        return label;    }    return new JLabel();}
private BufferedImage pdfbox_f87_0(GeneralPath path, Rectangle2D bounds2D, Rectangle cellRect)
{    BufferedImage bim = new BufferedImage((int) (cellRect.getWidth() * DEFAULT_TRANSFORM.getScaleX()), (int) (cellRect.getHeight() * DEFAULT_TRANSFORM.getScaleY()), BufferedImage.TYPE_INT_RGB);    Graphics2D g = (Graphics2D) bim.getGraphics();    g.setBackground(Color.white);    g.clearRect(0, 0, bim.getWidth(), bim.getHeight());    double scale = 1 / ((yBounds[1] - yBounds[0]) / cellRect.getHeight());        g.scale(1, -1);    g.translate(0, -bim.getHeight());        g.translate((cellRect.getWidth() - bounds2D.getWidth() * scale) / 2 * DEFAULT_TRANSFORM.getScaleX(), 0);        g.scale(scale * DEFAULT_TRANSFORM.getScaleX(), scale * DEFAULT_TRANSFORM.getScaleY());        g.translate(0, -yBounds[0]);    g.setColor(Color.black);    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);    g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);    g.fill(path);    g.dispose();    return bim;}
private Object[][] pdfbox_f88_0(PDSimpleFont font) throws IOException
{    Object[][] glyphs = new Object[256][4];    for (int index = 0; index <= 255; index++) {        glyphs[index][0] = index;        if (font.getEncoding().contains(index) || font.toUnicode(index) != null) {            String glyphName = font.getEncoding().getName(index);            glyphs[index][1] = glyphName;            glyphs[index][2] = font.toUnicode(index);            if (font instanceof PDVectorFont) {                                glyphs[index][3] = ((PDVectorFont) font).getPath(index);            } else {                glyphs[index][3] = font.getPath(glyphName);            }            totalAvailableGlyph++;        } else {            glyphs[index][1] = NO_GLYPH;            glyphs[index][2] = NO_GLYPH;            glyphs[index][3] = font.getPath(".notdef");        }    }    return glyphs;}
private String pdfbox_f89_0(PDSimpleFont font)
{    return font.getEncoding().getClass().getSimpleName();}
public JPanel pdfbox_f90_0()
{    return view.getPanel();}
private Object[][] pdfbox_f91_0(PDCIDFont descendantFont, PDType0Font parentFont) throws IOException
{    int codes = 0;    for (int code = 0; code < 65535; ++code) {        if (descendantFont.hasGlyph(code)) {            ++codes;        }    }    Object[][] tab = new Object[codes][5];    int index = 0;    for (int code = 0; code < 65535; ++code) {        if (descendantFont.hasGlyph(code)) {            tab[index][0] = code;            tab[index][1] = descendantFont.codeToCID(code);            tab[index][2] = descendantFont.codeToGID(code);            tab[index][3] = parentFont.toUnicode(code);            GeneralPath path = descendantFont.getPath(code);            tab[index][4] = path;            if (!path.getBounds2D().isEmpty()) {                ++totalAvailableGlyph;            }            ++index;        }    }    return tab;}
private Object[][] pdfbox_f92_0(PDCIDFont font, PDFont parentFont) throws IOException
{    Object[][] cid2gid = null;    COSDictionary dict = font.getCOSObject();    COSBase map = dict.getDictionaryObject(COSName.CID_TO_GID_MAP);    if (map instanceof COSStream) {        COSStream stream = (COSStream) map;        InputStream is = stream.createInputStream();        byte[] mapAsBytes = IOUtils.toByteArray(is);        IOUtils.closeQuietly(is);        int numberOfInts = mapAsBytes.length / 2;        cid2gid = new Object[numberOfInts][4];        int offset = 0;        for (int index = 0; index < numberOfInts; index++) {            int gid = (mapAsBytes[offset] & 0xff) << 8 | mapAsBytes[offset + 1] & 0xff;            cid2gid[index][0] = index;            cid2gid[index][1] = gid;            if (gid != 0 && parentFont.toUnicode(index) != null) {                cid2gid[index][2] = parentFont.toUnicode(index);            }            GeneralPath path = font.getPath(index);            cid2gid[index][3] = path;            if (!path.getBounds2D().isEmpty()) {                ++totalAvailableGlyph;            }            offset += 2;        }    }    return cid2gid;}
public JPanel pdfbox_f93_0()
{    if (view != null) {        return view.getPanel();    }    JPanel panel = new JPanel();    panel.setPreferredSize(new Dimension(300, 500));    return panel;}
private void pdfbox_f94_0(PDType3Font font) throws IOException
{    double minX = 0;    double maxX = 0;    double minY = 0;    double maxY = 0;    for (int index = 0; index <= 255; ++index) {        PDType3CharProc charProc = font.getCharProc(index);        if (charProc == null) {            continue;        }        PDRectangle glyphBBox = charProc.getGlyphBBox();        if (glyphBBox == null) {            continue;        }        minX = Math.min(minX, glyphBBox.getLowerLeftX());        maxX = Math.max(maxX, glyphBBox.getUpperRightX());        minY = Math.min(minY, glyphBBox.getLowerLeftY());        maxY = Math.max(maxY, glyphBBox.getUpperRightY());    }    fontBBox = new PDRectangle((float) minX, (float) minY, (float) (maxX - minX), (float) (maxY - minY));    if (fontBBox.getWidth() <= 0 || fontBBox.getHeight() <= 0) {                BoundingBox boundingBox = font.getBoundingBox();        fontBBox = new PDRectangle(boundingBox.getLowerLeftX(), boundingBox.getLowerLeftY(), boundingBox.getWidth(), boundingBox.getHeight());    }}
private Object[][] pdfbox_f95_0(PDType3Font font) throws IOException
{    boolean isEmpty = fontBBox.toGeneralPath().getBounds2D().isEmpty();    Object[][] glyphs = new Object[256][4];            Map<String, BufferedImage> map = new HashMap<>();    for (int index = 0; index <= 255; index++) {        glyphs[index][0] = index;        if (font.getEncoding().contains(index) || font.toUnicode(index) != null) {            String name = font.getEncoding().getName(index);            glyphs[index][1] = name;            glyphs[index][2] = font.toUnicode(index);            if (isEmpty) {                glyphs[index][3] = NO_GLYPH;            } else if (map.containsKey(name)) {                glyphs[index][3] = map.get(name);            } else {                BufferedImage image = renderType3Glyph(font, index);                map.put(name, image);                glyphs[index][3] = image;            }            totalAvailableGlyph++;        } else {            glyphs[index][1] = NO_GLYPH;            glyphs[index][2] = NO_GLYPH;            glyphs[index][3] = NO_GLYPH;        }    }    return glyphs;}
private BufferedImage pdfbox_f96_0(PDType3Font font, int index) throws IOException
{    try (PDDocument doc = new PDDocument()) {        int scale = 1;        if (fontBBox.getWidth() < 72 || fontBBox.getHeight() < 72) {                        scale = (int) (72 / Math.min(fontBBox.getWidth(), fontBBox.getHeight()));        }        PDPage page = new PDPage(new PDRectangle(fontBBox.getWidth() * scale, fontBBox.getHeight() * scale));        page.setResources(resources);        try (PDPageContentStream cs = new PDPageContentStream(doc, page, AppendMode.APPEND, false)) {                                                                                    float scalingFactorX = font.getFontMatrix().getScalingFactorX();            float scalingFactorY = font.getFontMatrix().getScalingFactorY();            float translateX = scalingFactorX > 0 ? -fontBBox.getLowerLeftX() : fontBBox.getUpperRightX();            float translateY = scalingFactorY > 0 ? -fontBBox.getLowerLeftY() : fontBBox.getUpperRightY();            cs.transform(Matrix.getTranslateInstance(translateX * scale, translateY * scale));            cs.beginText();            cs.setFont(font, scale / Math.min(Math.abs(scalingFactorX), Math.abs(scalingFactorY)));                        cs.appendRawCommands(String.format("<%02X> Tj\n", index).getBytes(Charsets.ISO_8859_1));            cs.endText();        }        doc.addPage(page);                return new PDFRenderer(doc).renderImage(0);    }}
private String pdfbox_f97_0(PDSimpleFont font)
{    return font.getEncoding().getClass().getSimpleName();}
public JPanel pdfbox_f98_0()
{    return view.getPanel();}
protected void pdfbox_f99_0(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    Rectangle bound = getVisibleRect();    int x = HexView.LINE_INSET;    int y = bound.y;    if (y == 0 || y % HexView.CHAR_HEIGHT != 0) {        y += HexView.CHAR_HEIGHT - y % HexView.CHAR_HEIGHT;    }    int firstLine = y / HexView.CHAR_HEIGHT;    for (int line = firstLine; line < firstLine + bound.getHeight() / HexView.CHAR_HEIGHT; line++) {        if (line > totalLine) {            break;        }        if (line == selectedLine) {            paintSelected(g, x, y);        } else {            g.drawString(String.format("%08X", (line - 1) * 16), x, y);        }        x = HexView.LINE_INSET;        y += HexView.CHAR_HEIGHT;    }}
private void pdfbox_f100_0(Graphics g, int x, int y)
{    g.setColor(HexView.SELECTED_COLOR);    g.setFont(HexView.BOLD_FONT);    g.drawString(String.format("%08X", selectedIndex), x, y);    g.setColor(Color.black);    g.setFont(HexView.FONT);}
 void pdfbox_f101_0(int index)
{    if (index != selectedIndex) {        selectedLine = HexModel.lineNumber(index);        selectedIndex = index;        repaint();    }}
protected void pdfbox_f102_0(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    Rectangle bound = getVisibleRect();    int x = HexView.LINE_INSET;    int y = bound.y;    if (y == 0 || y % HexView.CHAR_HEIGHT != 0) {        y += HexView.CHAR_HEIGHT - y % HexView.CHAR_HEIGHT;    }    int firstLine = y / HexView.CHAR_HEIGHT;    for (int line = firstLine; line < firstLine + bound.getHeight() / HexView.CHAR_HEIGHT; line++) {        if (line > model.totalLine()) {            break;        }        if (line == selectedLine) {            paintInSelected(g, x, y);        } else {            char[] chars = model.getLineChars(line);            g.drawChars(chars, 0, chars.length, x, y);        }        x = HexView.LINE_INSET;        y += HexView.CHAR_HEIGHT;    }}
private void pdfbox_f103_0(Graphics g, int x, int y)
{    g.setFont(HexView.BOLD_FONT);    char[] content = model.getLineChars(selectedLine);    g.drawChars(content, 0, selectedIndexInLine - 0, x, y);    g.setColor(HexView.SELECTED_COLOR);    x += g.getFontMetrics().charsWidth(content, 0, selectedIndexInLine - 0);    g.drawChars(content, selectedIndexInLine, 1, x, y);    g.setColor(Color.black);    x += g.getFontMetrics().charWidth(content[selectedIndexInLine]);    g.drawChars(content, selectedIndexInLine + 1, (content.length - 1) - selectedIndexInLine, x, y);    g.setFont(HexView.FONT);}
public void pdfbox_f104_0(HexModelChangedEvent event)
{    repaint();}
 void pdfbox_f105_0(int index)
{    selectedLine = HexModel.lineNumber(index);    selectedIndexInLine = HexModel.elementIndexInLine(index);    repaint();}
public byte pdfbox_f106_0()
{    return newValue;}
public int pdfbox_f107_0()
{    return byteIndex;}
public void pdfbox_f108_0(ActionEvent actionEvent)
{    createJumpDialog().setVisible(true);}
private void pdfbox_f109_0()
{    setLayout(new GridBagLayout());    addressPane = new AddressPane(model.totalLine());    hexPane = new HexPane(model);    hexPane.addHexChangeListeners(model);    asciiPane = new ASCIIPane(model);    UpperPane upperPane = new UpperPane();    statusPane = new StatusPane();    model.addHexModelChangeListener(hexPane);    model.addHexModelChangeListener(asciiPane);    JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));    panel.setPreferredSize(new Dimension(HexView.TOTAL_WIDTH, HexView.CHAR_HEIGHT * (model.totalLine() + 1)));    panel.add(addressPane);    panel.add(hexPane);    panel.add(asciiPane);    JScrollPane scrollPane = getScrollPane();    scrollPane.setViewportView(panel);    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.anchor = GridBagConstraints.FIRST_LINE_START;    gbc.fill = GridBagConstraints.BOTH;    gbc.weighty = 0.02;    add(upperPane, gbc);    gbc.anchor = GridBagConstraints.LINE_START;    gbc.gridy = 1;    gbc.weighty = 1;    gbc.weightx = 1;    gbc.fill = GridBagConstraints.BOTH;    add(scrollPane, gbc);    gbc.gridy = 2;    gbc.weightx = 0.1;    gbc.weighty = 0.0;    gbc.anchor = GridBagConstraints.LAST_LINE_START;    gbc.fill = GridBagConstraints.HORIZONTAL;    add(statusPane, gbc);    hexPane.addSelectionChangeListener(this);    KeyStroke jumpKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_G, InputEvent.CTRL_DOWN_MASK);    this.getInputMap(WHEN_IN_FOCUSED_WINDOW).put(jumpKeyStroke, "jump");    this.getActionMap().put("jump", jumpToIndex);}
private JScrollPane pdfbox_f110_0()
{    JScrollPane scrollPane = new JScrollPane();    scrollPane.setBorder(new LineBorder(Color.LIGHT_GRAY));    Action blankAction = new AbstractAction() {        @Override        public void actionPerformed(ActionEvent actionEvent) {        }    };    scrollPane.getActionMap().put("unitScrollDown", blankAction);    scrollPane.getActionMap().put("unitScrollLeft", blankAction);    scrollPane.getActionMap().put("unitScrollRight", blankAction);    scrollPane.getActionMap().put("unitScrollUp", blankAction);    JScrollBar verticalScrollBar = scrollPane.createVerticalScrollBar();    verticalScrollBar.setUnitIncrement(HexView.CHAR_HEIGHT);    verticalScrollBar.setBlockIncrement(HexView.CHAR_HEIGHT * 20);    verticalScrollBar.setValues(0, 1, 0, HexView.CHAR_HEIGHT * (model.totalLine() + 1));    scrollPane.setVerticalScrollBar(verticalScrollBar);    return scrollPane;}
public void pdfbox_f111_0(ActionEvent actionEvent)
{}
public void pdfbox_f112_0(SelectEvent event)
{    int index = event.getHexIndex();    switch(event.getNavigation()) {        case SelectEvent.NEXT:            index += 1;            break;        case SelectEvent.PREVIOUS:            index -= 1;            break;        case SelectEvent.UP:            index -= 16;            break;        case SelectEvent.DOWN:            index += 16;            break;        default:            break;    }    if (index >= 0 && index <= model.size() - 1) {        hexPane.setSelected(index);        addressPane.setSelected(index);        asciiPane.setSelected(index);        statusPane.updateStatus(index);        selectedIndex = index;    }}
private JDialog pdfbox_f113_0()
{    final JDialog dialog = new JDialog(SwingUtilities.windowForComponent(this), "Jump to index");    dialog.setLocationRelativeTo(this);    final JLabel nowLabel = new JLabel("Present index: " + selectedIndex);    final JLabel label = new JLabel("Index to go:");    final JTextField field = new JFormattedTextField(NumberFormat.getIntegerInstance());    field.setPreferredSize(new Dimension(100, 20));    field.addActionListener(new AbstractAction() {        @Override        public void actionPerformed(ActionEvent actionEvent) {            int index = Integer.parseInt(field.getText(), 10);            if (index >= 0 && index <= model.size() - 1) {                selectionChanged(new SelectEvent(index, SelectEvent.IN));                dialog.dispose();            }        }    });    JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));    panel.add(nowLabel);    JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));    inputPanel.add(label);    inputPanel.add(field);    JPanel contentPanel = new JPanel();    contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));    contentPanel.add(panel);    contentPanel.add(inputPanel);    dialog.getContentPane().add(contentPanel);    dialog.pack();    return dialog;}
public void pdfbox_f114_0(ActionEvent actionEvent)
{    int index = Integer.parseInt(field.getText(), 10);    if (index >= 0 && index <= model.size() - 1) {        selectionChanged(new SelectEvent(index, SelectEvent.IN));        dialog.dispose();    }}
public byte pdfbox_f115_0(int index)
{    return data.get(index);}
public char[] pdfbox_f116_0(int lineNumber)
{    int start = (lineNumber - 1) * 16;    int length = data.size() - start < 16 ? data.size() - start : 16;    char[] chars = new char[length];    for (int i = 0; i < chars.length; i++) {        char c = Character.toChars(data.get(start) & 0XFF)[0];        if (!isAsciiPrintable(c)) {            c = '.';        }        chars[i] = c;        start++;    }    return chars;}
public byte[] pdfbox_f117_0(int lineNumber)
{    int index = (lineNumber - 1) * 16;    int length = Math.min(data.size() - index, 16);    byte[] bytes = new byte[length];    for (int i = 0; i < bytes.length; i++) {        bytes[i] = data.get(index);        index++;    }    return bytes;}
public int pdfbox_f118_0()
{    return data.size();}
public int pdfbox_f119_0()
{    return size() % 16 != 0 ? size() / 16 + 1 : size() / 16;}
public static int pdfbox_f120_0(int index)
{    int elementNo = index + 1;    return elementNo % 16 != 0 ? elementNo / 16 + 1 : elementNo / 16;}
public static int pdfbox_f121_0(int index)
{    return index % 16;}
private static boolean pdfbox_f122_0(char ch)
{    return ch >= 32 && ch < 127;}
public void pdfbox_f123_0(HexModelChangeListener listener)
{    modelChangeListeners.add(listener);}
public void pdfbox_f124_0(int index, byte value)
{    if (!data.get(index).equals(value)) {        data.set(index, value);        fireModelChanged(index);    }}
public void pdfbox_f125_0(HexChangedEvent event)
{    int index = event.getByteIndex();    if (index != -1 && getByte(index) != event.getNewValue()) {        data.set(index, event.getNewValue());    }    fireModelChanged(index);}
private void pdfbox_f126_0(int index)
{    modelChangeListeners.forEach(listener -> listener.hexModelChanged(new HexModelChangedEvent(index, HexModelChangedEvent.SINGLE_CHANGE)));}
 int pdfbox_f127_0()
{    return startIndex;}
 int pdfbox_f128_0()
{    return changeType;}
protected void pdfbox_f129_0(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    Rectangle bound = getVisibleRect();    g.clearRect(bound.x, bound.y, bound.width, bound.height);    g.setColor(Color.WHITE);    g.fillRect(bound.x, bound.y, bound.width, bound.height);    int x = HexView.LINE_INSET;    int y = bound.y;    if (y == 0 || y % HexView.CHAR_HEIGHT != 0) {        y += HexView.CHAR_HEIGHT - y % HexView.CHAR_HEIGHT;    }    int firstLine = y / HexView.CHAR_HEIGHT;    g.setColor(Color.BLACK);    for (int i = firstLine; i <= firstLine + bound.height / HexView.CHAR_HEIGHT; i++) {        if (i > model.totalLine()) {            break;        }        byte[] bytes = model.getBytesForLine(i);        int index = (i - 1) * 16;        for (byte by : bytes) {            String str = String.format("%02X", by);            if (selectedIndex == index && state == SELECTED) {                g.drawString(getSelectedString(str).getIterator(), x, y);            } else if (selectedIndex == index && state == EDIT) {                paintInEdit(g, by, x, y);            } else {                g.drawString(str, x, y);            }            x += HexView.CHAR_WIDTH;            index++;        }        x = HexView.LINE_INSET;        y += HexView.CHAR_HEIGHT;    }}
private void pdfbox_f130_0(Graphics g, byte content, int x, int y)
{    g.setFont(HexView.BOLD_FONT);    g.setColor(Color.white);    char[] chars = getChars(content);    if (selectedChar == 0) {        g.setColor(HexView.SELECTED_COLOR);        g.drawChars(chars, 0, 1, x, y);        g.setColor(Color.black);        g.drawChars(chars, 1, 1, x + g.getFontMetrics().charWidth(chars[0]), y);    } else {        g.setColor(Color.black);        g.drawChars(chars, 0, 1, x, y);        g.setColor(HexView.SELECTED_COLOR);        g.drawChars(chars, 1, 1, x + g.getFontMetrics().charWidth(chars[0]), y);    }    setDefault(g);}
private AttributedString pdfbox_f131_0(String str)
{    AttributedString string = new AttributedString(str);    string.addAttribute(TextAttribute.FONT, HexView.BOLD_FONT);    string.addAttribute(TextAttribute.FOREGROUND, HexView.SELECTED_COLOR);    return string;}
private void pdfbox_f132_0(Graphics g)
{    g.setColor(Color.black);    g.setFont(this.getFont());}
private int pdfbox_f133_0(Point point)
{    if (point.x <= 20 || point.x >= (16 * HexView.CHAR_WIDTH) + 20) {        return -1;    }    int y = point.y;    int lineNumber = (y + (HexView.CHAR_HEIGHT - (y % HexView.CHAR_HEIGHT))) / HexView.CHAR_HEIGHT;    int x = point.x - 20;    int elementNumber = x / HexView.CHAR_WIDTH;    return (lineNumber - 1) * 16 + elementNumber;}
private Point pdfbox_f134_0(int index)
{    int x = HexView.LINE_INSET + HexModel.elementIndexInLine(index) * HexView.CHAR_WIDTH;    int y = HexModel.lineNumber(index) * HexView.CHAR_HEIGHT;    return new Point(x, y);}
private void pdfbox_f135_0(int index)
{    state = SELECTED;    selectedChar = 0;    Point point = getPointForIndex(index);        if (index % 16 == 0) {        scrollRectToVisible(new Rectangle(0, HexModel.lineNumber(index) * HexView.CHAR_HEIGHT, 1, 1));    } else if (!getVisibleRect().intersects(point.x, point.y, HexView.CHAR_WIDTH, HexView.CHAR_HEIGHT)) {        scrollRectToVisible(new Rectangle(point.x, point.y, HexView.CHAR_WIDTH, HexView.CHAR_HEIGHT));    }    selectedIndex = index;    repaint();    requestFocusInWindow();}
private void pdfbox_f136_0(SelectEvent event)
{    selectionChangeListeners.forEach(listener -> listener.selectionChanged(event));}
private void pdfbox_f137_0(byte value, int index)
{    hexChangeListeners.forEach(listener -> listener.hexChanged(new HexChangedEvent(value, index)));}
public void pdfbox_f138_0(SelectionChangeListener listener)
{    selectionChangeListeners.add(listener);}
public void pdfbox_f139_0(HexChangeListener listener)
{    hexChangeListeners.add(listener);}
public void pdfbox_f140_0(KeyEvent keyEvent)
{    if (selectedIndex != -1) {        char c = keyEvent.getKeyChar();        if (isHexChar(c)) {            byte previousByte = model.getByte(selectedIndex);            char[] chars = getChars(previousByte);            chars[selectedChar] = c;            byte editByte = getByte(chars);            if (selectedChar == 0) {                state = EDIT;                selectedChar = 1;                fireHexValueChanged(editByte, selectedIndex);            } else {                fireHexValueChanged(editByte, selectedIndex);                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.NEXT));            }        }    }}
public void pdfbox_f141_0(KeyEvent keyEvent)
{    if (state == SELECTED || state == EDIT) {        switch(keyEvent.getKeyCode()) {            case 37:                if (state == EDIT && selectedChar == 1) {                    selectedChar = 0;                    repaint();                } else {                    fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.PREVIOUS));                }                break;            case 39:                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.NEXT));                break;            case 38:                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.UP));                break;            case 40:                fireSelectionChanged(new SelectEvent(selectedIndex, SelectEvent.DOWN));                break;            default:                break;        }    }}
public void pdfbox_f142_0(KeyEvent keyEvent)
{}
public void pdfbox_f143_0(MouseEvent mouseEvent)
{    int index = getIndexForPoint(mouseEvent.getPoint());    if (index == -1) {        fireSelectionChanged(new SelectEvent(-1, SelectEvent.NONE));        return;    }    fireSelectionChanged(new SelectEvent(index, SelectEvent.IN));}
public void pdfbox_f144_0(MouseEvent mouseEvent)
{}
public void pdfbox_f145_0(MouseEvent mouseEvent)
{}
public void pdfbox_f146_0(MouseEvent mouseEvent)
{}
public void pdfbox_f147_0(MouseEvent mouseEvent)
{}
public void pdfbox_f148_0(MouseEvent mouseEvent)
{}
public void pdfbox_f149_0(MouseEvent mouseEvent)
{}
private static boolean pdfbox_f150_0(char c)
{    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');}
private char[] pdfbox_f151_0(byte b)
{    return String.format("%02X", b & 0XFF).toCharArray();}
private byte pdfbox_f152_0(char[] chars)
{    return (byte) (Integer.parseInt(new String(chars), 16) & 0XFF);}
public void pdfbox_f153_0(int index)
{    if (index != selectedIndex) {        putInSelected(index);    }}
public void pdfbox_f154_0(HexModelChangedEvent event)
{    repaint();}
public void pdfbox_f155_0(byte[] bytes)
{    if (mainPane.getComponentCount() > 0) {        mainPane.removeAll();    }    HexModel model = new HexModel(bytes);    mainPane.add(new HexEditor(model));    mainPane.validate();}
public JComponent pdfbox_f156_0()
{    return mainPane;}
public int pdfbox_f157_0()
{    return hexIndex;}
public String pdfbox_f158_0()
{    return navigation;}
private void pdfbox_f159_0()
{    JLabel line = new JLabel("Line:");    JLabel column = new JLabel("Column:");    lineLabel = new JLabel("");    lineLabel.setPreferredSize(new Dimension(100, HEIGHT));    colLabel = new JLabel("");    colLabel.setPreferredSize(new Dimension(100, HEIGHT));    JLabel index = new JLabel("Index:");    indexLabel = new JLabel("");    add(line);    add(lineLabel);    add(column);    add(colLabel);    add(index);    add(indexLabel);}
 void pdfbox_f160_0(int index)
{    lineLabel.setText(String.valueOf(HexModel.lineNumber(index)));    colLabel.setText(String.valueOf(HexModel.elementIndexInLine(index) + 1));    indexLabel.setText(String.valueOf(index));}
protected void pdfbox_f161_0(Graphics g)
{    super.paintComponent(g);    Graphics2D g2d = (Graphics2D) g;    g2d.setRenderingHints(HexView.RENDERING_HINTS);    int x = HexView.LINE_INSET - 2;    int y = 16;    g.drawString("Offset", x, y);    x += HexView.ADDRESS_PANE_WIDTH + 2;    for (int i = 0; i <= 15; i++) {        g.drawString(String.format("%02X", i), x, y);        x += HexView.CHAR_WIDTH;    }    x += HexView.LINE_INSET * 2;    g.drawString("Text", x, y);}
protected void pdfbox_f162_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{        super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);    if (showGlyphBounds) {        Shape bbox;                if (font instanceof PDType3Font) {                        return;        } else {            AffineTransform at = textRenderingMatrix.createAffineTransform();            at.concatenate(font.getFontMatrix().createAffineTransform());                        PDVectorFont vectorFont = (PDVectorFont) font;            GeneralPath path = vectorFont.getNormalizedPath(code);            if (path == null) {                return;            }                        if (!font.isEmbedded() && !font.isVertical() && !font.isStandard14() && font.hasExplicitWidth(code)) {                float fontWidth = font.getWidthFromFont(code);                if (                fontWidth > 0 && Math.abs(fontWidth - displacement.getX() * 1000) > 0.0001) {                    float pdfWidth = displacement.getX() * 1000;                    at.scale(pdfWidth / fontWidth, 1);                }            }            Shape glyph = at.createTransformedShape(path);            bbox = glyph.getBounds2D();        }                Graphics2D graphics = getGraphics();        Color color = graphics.getColor();        Stroke stroke = graphics.getStroke();        Shape clip = graphics.getClip();                graphics.setClip(graphics.getDeviceConfiguration().getBounds());        graphics.setColor(Color.cyan);        graphics.setStroke(new BasicStroke(.5f));        graphics.draw(bbox);                graphics.setStroke(stroke);        graphics.setColor(color);        graphics.setClip(clip);    }}
protected PageDrawer pdfbox_f163_0(PageDrawerParameters parameters) throws IOException
{    return new DebugPageDrawer(parameters, this.showGlyphBounds);}
public void pdfbox_f164_0(PDDocument document, PDPage page, int pageIndex, float scale) throws IOException
{        PDRectangle cropBox = page.getCropBox();    this.flip = new AffineTransform();    flip.translate(0, cropBox.getHeight());    flip.scale(1, -1);        transform(graphics, page, scale);        graphics.setStroke(new BasicStroke(0.5f));    setStartPage(pageIndex + 1);    setEndPage(pageIndex + 1);    Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());    writeText(document, dummy);    if (DebugTextOverlay.this.showTextStripperBeads) {                List<PDThreadBead> pageArticles = page.getThreadBeads();        for (PDThreadBead bead : pageArticles) {            if (bead == null) {                continue;            }            PDRectangle r = bead.getRectangle();            GeneralPath p = r.transform(Matrix.getTranslateInstance(-cropBox.getLowerLeftX(), cropBox.getLowerLeftY()));            Shape s = flip.createTransformedShape(p);            graphics.setColor(Color.green);            graphics.draw(s);        }    }}
private void pdfbox_f165_0(Graphics2D graphics, PDPage page, float scale)
{    graphics.scale(scale, scale);    int rotationAngle = page.getRotation();    PDRectangle cropBox = page.getCropBox();    if (rotationAngle != 0) {        float translateX = 0;        float translateY = 0;        switch(rotationAngle) {            case 90:                translateX = cropBox.getHeight();                break;            case 270:                translateY = cropBox.getWidth();                break;            case 180:                translateX = cropBox.getWidth();                translateY = cropBox.getHeight();                break;            default:                break;        }        graphics.translate(translateX, translateY);        graphics.rotate((float) Math.toRadians(rotationAngle));    }}
protected void pdfbox_f166_0(String string, List<TextPosition> textPositions) throws IOException
{    for (TextPosition text : textPositions) {        if (DebugTextOverlay.this.showTextStripper) {            AffineTransform at = (AffineTransform) flip.clone();            at.concatenate(text.getTextMatrix().createAffineTransform());                                                Rectangle2D.Float rect = new Rectangle2D.Float(0, 0, text.getWidthDirAdj() / text.getTextMatrix().getScalingFactorX(), text.getHeightDir() / text.getTextMatrix().getScalingFactorY());            graphics.setColor(Color.red);            graphics.draw(at.createTransformedShape(rect));        }        if (DebugTextOverlay.this.showFontBBox) {                                                PDFont font = text.getFont();            BoundingBox bbox = font.getBoundingBox();                                    float xadvance = font.getWidth(text.getCharacterCodes()[0]);            Rectangle2D rect = new Rectangle2D.Float(0, bbox.getLowerLeftY(), xadvance, bbox.getHeight());                                    AffineTransform at = (AffineTransform) flip.clone();            at.concatenate(text.getTextMatrix().createAffineTransform());            if (font instanceof PDType3Font) {                                at.concatenate(font.getFontMatrix().createAffineTransform());            } else {                                at.scale(1 / 1000f, 1 / 1000f);            }            graphics.setColor(Color.blue);            graphics.draw(at.createTransformedShape(rect));        }    }}
public void pdfbox_f167_0(Graphics2D graphics) throws IOException
{    DebugTextStripper stripper = new DebugTextStripper(graphics);    stripper.stripPage(this.document, this.document.getPage(pageIndex), this.pageIndex, this.scale);}
private void pdfbox_f168_1()
{    try {        collectFieldLocations();        collectLinkLocations();    } catch (IOException ex) {            }}
private void pdfbox_f169_0() throws IOException
{    for (PDAnnotation annotation : page.getAnnotations()) {        if (annotation instanceof PDAnnotationLink) {            collectLinkLocation((PDAnnotationLink) annotation);        }    }}
private void pdfbox_f170_0(PDAnnotationLink linkAnnotation) throws IOException
{    PDAction action = linkAnnotation.getAction();    if (action instanceof PDActionURI) {        PDActionURI uriAction = (PDActionURI) action;        rectMap.put(linkAnnotation.getRectangle(), "URI: " + uriAction.getURI());        return;    }    PDDestination destination;    if (action instanceof PDActionGoTo) {        PDActionGoTo goToAction = (PDActionGoTo) action;        destination = goToAction.getDestination();    } else {        destination = linkAnnotation.getDestination();    }    if (destination instanceof PDNamedDestination) {        destination = document.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) destination);    }    if (destination instanceof PDPageDestination) {        PDPageDestination pageDestination = (PDPageDestination) destination;        int pageNum = pageDestination.retrievePageNumber();        if (pageNum != -1) {            rectMap.put(linkAnnotation.getRectangle(), "Page destination: " + (pageNum + 1));        }    }}
private void pdfbox_f171_0() throws IOException
{    PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();    if (acroForm == null) {        return;    }    Set<COSDictionary> dictionarySet = new HashSet<>();    for (PDAnnotation annotation : page.getAnnotations()) {        dictionarySet.add(annotation.getCOSObject());    }    for (PDField field : acroForm.getFieldTree()) {        for (PDAnnotationWidget widget : field.getWidgets()) {                        if (dictionarySet.contains(widget.getCOSObject())) {                rectMap.put(widget.getRectangle(), "Field name: " + field.getFullyQualifiedName());            }        }    }}
private void pdfbox_f172_0()
{    panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    String pageLabelText = pageIndex < 0 ? "Page number not found" : "Page " + (pageIndex + 1);        String lbl = PDFDebugger.getPageLabel(document, pageIndex);    if (lbl != null) {        pageLabelText += " - " + lbl;    }    JLabel pageLabel = new JLabel(pageLabelText);    pageLabel.setAlignmentX(Component.CENTER_ALIGNMENT);    pageLabel.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 20));    pageLabel.setBorder(BorderFactory.createEmptyBorder(5, 0, 10, 0));    panel.add(pageLabel);    label = new JLabel();    label.addMouseMotionListener(this);    label.addMouseListener(this);    label.setAlignmentX(Component.CENTER_ALIGNMENT);    panel.add(label);    panel.addAncestorListener(this);    zoomMenu = ZoomMenu.getInstance();    zoomMenu.changeZoomSelection(zoomMenu.getPageZoomScale());    startRendering();}
public Component pdfbox_f173_0()
{    return panel;}
public void pdfbox_f174_0(ActionEvent actionEvent)
{    String actionCommand = actionEvent.getActionCommand();    if (ZoomMenu.isZoomMenu(actionCommand) || RotationMenu.isRotationMenu(actionCommand) || ViewMenu.isRenderingOptions(actionCommand)) {        startRendering();    } else if (ViewMenu.isExtractText(actionEvent)) {        startExtracting();    }}
private void pdfbox_f175_1()
{    TextDialog textDialog = TextDialog.instance();    textDialog.setSize(800, 400);    textDialog.setVisible(true);    textDialog.setLocation(getPanel().getLocationOnScreen().x + getPanel().getWidth() / 2, getPanel().getLocationOnScreen().y + getPanel().getHeight() / 2);    try {        PDFTextStripper stripper = new PDFTextStripper();        stripper.setStartPage(pageIndex + 1);        stripper.setEndPage(pageIndex + 1);        textDialog.setText(stripper.getText(document));    } catch (IOException ex) {            }}
private void pdfbox_f176_0()
{            new RenderWorker(ZoomMenu.getZoomScale(), RotationMenu.getRotationDegrees(), ViewMenu.isShowTextStripper(), ViewMenu.isShowTextStripperBeads(), ViewMenu.isShowFontBBox(), ViewMenu.isShowGlyphBounds(), ViewMenu.isAllowSubsampling()).execute();    zoomMenu.setPageZoomScale(ZoomMenu.getZoomScale());}
public void pdfbox_f177_0(AncestorEvent ancestorEvent)
{    zoomMenu.addMenuListeners(this);    zoomMenu.setEnableMenu(true);    rotationMenu = RotationMenu.getInstance();    rotationMenu.addMenuListeners(this);    rotationMenu.setEnableMenu(true);    viewMenu = ViewMenu.getInstance(null);    JMenu menuInstance = viewMenu.getMenu();    int itemCount = menuInstance.getItemCount();    for (int i = 0; i < itemCount; i++) {        JMenuItem item = menuInstance.getItem(i);        if (item != null) {            item.setEnabled(true);            item.addActionListener(this);        }    }}
public void pdfbox_f178_0(AncestorEvent ancestorEvent)
{    boolean isFirstEntrySkipped = false;    zoomMenu.setEnableMenu(false);    rotationMenu.setEnableMenu(false);    JMenu menuInstance = viewMenu.getMenu();    int itemCount = menuInstance.getItemCount();    for (int i = 0; i < itemCount; i++) {        JMenuItem item = menuInstance.getItem(i);                if (item != null) {            if (!isFirstEntrySkipped) {                isFirstEntrySkipped = true;            } else {                item.setEnabled(false);                item.removeActionListener(this);            }        }    }}
public void pdfbox_f179_0(AncestorEvent ancestorEvent)
{}
public void pdfbox_f180_0(MouseEvent e)
{}
public void pdfbox_f181_0(MouseEvent e)
{    float height = page.getCropBox().getHeight();    float width = page.getCropBox().getWidth();    float offsetX = page.getCropBox().getLowerLeftX();    float offsetY = page.getCropBox().getLowerLeftY();    float zoomScale = zoomMenu.getPageZoomScale();    float x = e.getX() / zoomScale * (float) defaultTransform.getScaleX();    float y = e.getY() / zoomScale * (float) defaultTransform.getScaleY();    int x1;    int y1;    switch((RotationMenu.getRotationDegrees() + page.getRotation()) % 360) {        case 90:            x1 = (int) (y + offsetX);            y1 = (int) (x + offsetY);            break;        case 180:            x1 = (int) (width - x + offsetX);            y1 = (int) (y - offsetY);            break;        case 270:            x1 = (int) (width - y + offsetX);            y1 = (int) (height - x + offsetY);            break;        case 0:        default:            x1 = (int) (x + offsetX);            y1 = (int) (height - y + offsetY);            break;    }    String text = "x: " + x1 + ", y: " + y1;        for (Entry<PDRectangle, String> entry : rectMap.entrySet()) {        if (entry.getKey().contains(x1, y1)) {            text += ", " + rectMap.get(entry.getKey());            break;        }    }    statuslabel.setText(text);}
public void pdfbox_f182_0(MouseEvent e)
{}
public void pdfbox_f183_0(MouseEvent e)
{}
public void pdfbox_f184_0(MouseEvent e)
{}
public void pdfbox_f185_0(MouseEvent e)
{}
public void pdfbox_f186_0(MouseEvent e)
{    statuslabel.setText(labelText);}
protected BufferedImage pdfbox_f187_0() throws IOException
{    label.setIcon(null);    labelText = "Rendering...";    label.setText(labelText);    statuslabel.setText(labelText);    PDFRenderer renderer = new DebugPDFRenderer(document, this.showGlyphBounds);    renderer.setSubsamplingAllowed(allowSubsampling);    long t0 = System.nanoTime();    BufferedImage image = renderer.renderImage(pageIndex, scale);    long t1 = System.nanoTime();    long ms = TimeUnit.MILLISECONDS.convert(t1 - t0, TimeUnit.NANOSECONDS);    labelText = "Rendered in " + ms + " ms";    statuslabel.setText(labelText);        DebugTextOverlay debugText = new DebugTextOverlay(document, pageIndex, scale, showTextStripper, showTextStripperBeads, showFontBBox);    Graphics2D g = image.createGraphics();    debugText.renderTo(g);    g.dispose();    return ImageUtil.getRotatedImage(image, rotation);}
protected void pdfbox_f188_0()
{    try {        BufferedImage image = get();                                                label.setSize((int) Math.ceil(image.getWidth() / defaultTransform.getScaleX()), (int) Math.ceil(image.getHeight() / defaultTransform.getScaleY()));        label.setIcon(new HighResolutionImageIcon(image, label.getWidth(), label.getHeight()));        label.setText(null);    } catch (InterruptedException | ExecutionException e) {        label.setText(e.getMessage());        throw new RuntimeException(e);    }}
public static void pdfbox_f189_0(String[] args) throws Exception
{    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());    if (System.getProperty("apple.laf.useScreenMenuBar") == null) {        System.setProperty("apple.laf.useScreenMenuBar", "true");    }        Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> new ErrorDialog(throwable).setVisible(true));        String filename = null;    @SuppressWarnings({ "squid:S2068" })    String password = "";    boolean viewPages = true;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case VIEW_STRUCTURE:                viewPages = false;                break;            default:                filename = args[i];                break;        }    }    final PDFDebugger viewer = new PDFDebugger(viewPages);                    LogDialog.init(viewer, viewer.statusBar.getLogLabel());    System.setProperty("org.apache.commons.logging.Log", "org.apache.pdfbox.debugger.ui.DebugLog");    TextDialog.init(viewer);        if (PDType1Font.COURIER.isStandard14()) {                PDDeviceCMYK.INSTANCE.toRGB(new float[] { 0, 0, 0, 0 });        PDDeviceRGB.INSTANCE.toRGB(new float[] { 0, 0, 0 });        IIORegistry.getDefaultInstance();        FilterFactory.INSTANCE.getFilter(COSName.FLATE_DECODE);    }    if (filename != null) {        File file = new File(filename);        if (file.exists()) {            viewer.readPDFFile(filename, password);        }    }    viewer.setVisible(true);}
public boolean pdfbox_f190_0()
{    return this.isPageMode;}
public void pdfbox_f191_0(boolean isPageMode)
{    this.isPageMode = isPageMode;}
public boolean pdfbox_f192_0()
{    return document != null;}
private static void pdfbox_f193_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFDebugger [options] <inputfile>\n" + "\nOptions:\n" + "  -password <password> : Password to decrypt the document\n" + "  -viewstructure       : activate structure mode on startup\n" + "  <inputfile>          : The PDF document to be loaded\n";    System.err.println(message);    System.exit(1);}
private void pdfbox_f194_0()
{    File file = new File("config.properties");    if (file.exists()) {        try {            try (InputStream is = new FileInputStream(file)) {                configuration.load(is);            }        } catch (IOException e) {            throw new RuntimeException(e);        }    }}
private void pdfbox_f195_0()
{    jSplitPane1 = new javax.swing.JSplitPane();    jScrollPane1 = new JScrollPane();    tree = new Tree();    jScrollPane2 = new JScrollPane();    jTextPane1 = new javax.swing.JTextPane();    tree.setCellRenderer(new PDFTreeCellRenderer());    tree.setModel(null);    setTitle("Apache PDFBox Debugger");    addWindowListener(new java.awt.event.WindowAdapter() {        @Override        public void windowOpened(WindowEvent windowEvent) {            tree.requestFocusInWindow();            super.windowOpened(windowEvent);        }        @Override        public void windowClosing(WindowEvent evt) {            exitForm(evt);        }    });    windowPrefs = new WindowPrefs(this.getClass());    jScrollPane1.setBorder(new BevelBorder(BevelBorder.RAISED));    jSplitPane1.setDividerLocation(windowPrefs.getDividerLocation());    tree.addTreeSelectionListener(this::jTree1ValueChanged);    jScrollPane1.setViewportView(tree);    jSplitPane1.setRightComponent(jScrollPane2);    jSplitPane1.setDividerSize(3);    jScrollPane2.setViewportView(jTextPane1);    jSplitPane1.setLeftComponent(jScrollPane1);    JScrollPane documentScroller = new JScrollPane();    documentScroller.setViewportView(documentPanel);    statusPane = new TreeStatusPane(tree);    statusPane.getPanel().setBorder(new BevelBorder(BevelBorder.RAISED));    statusPane.getPanel().setPreferredSize(new Dimension(300, 25));    getContentPane().add(statusPane.getPanel(), BorderLayout.PAGE_START);    getContentPane().add(jSplitPane1, BorderLayout.CENTER);    statusBar = new ReaderBottomPanel();    getContentPane().add(statusBar, BorderLayout.SOUTH);        JMenuBar menuBar = new JMenuBar();    menuBar.add(createFileMenu());    menuBar.add(createEditMenu());    ViewMenu viewMenu = ViewMenu.getInstance(this);    menuBar.add(viewMenu.getMenu());    setJMenuBar(menuBar);    setExtendedState(windowPrefs.getExtendedState());    setBounds(windowPrefs.getBounds());        setTransferHandler(new TransferHandler() {        @Override        public boolean canImport(TransferSupport transferSupport) {            return transferSupport.isDataFlavorSupported(DataFlavor.javaFileListFlavor);        }        @Override        @SuppressWarnings("unchecked")        public boolean importData(TransferSupport transferSupport) {            try {                Transferable transferable = transferSupport.getTransferable();                List<File> files = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);                readPDFFile(files.get(0), "");                return true;            } catch (IOException e) {                new ErrorDialog(e).setVisible(true);                return true;            } catch (UnsupportedFlavorException e) {                throw new RuntimeException(e);            }        }    });    initGlobalEventHandlers();}
public void pdfbox_f196_0(WindowEvent windowEvent)
{    tree.requestFocusInWindow();    super.windowOpened(windowEvent);}
public void pdfbox_f197_0(WindowEvent evt)
{    exitForm(evt);}
public boolean pdfbox_f198_0(TransferSupport transferSupport)
{    return transferSupport.isDataFlavorSupported(DataFlavor.javaFileListFlavor);}
public boolean pdfbox_f199_0(TransferSupport transferSupport)
{    try {        Transferable transferable = transferSupport.getTransferable();        List<File> files = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);        readPDFFile(files.get(0), "");        return true;    } catch (IOException e) {        new ErrorDialog(e).setVisible(true);        return true;    } catch (UnsupportedFlavorException e) {        throw new RuntimeException(e);    }}
protected void pdfbox_f200_0()
{        if (IS_MAC_OS) {        try {            Method osxOpenFiles = getClass().getDeclaredMethod("osxOpenFiles", String.class);            osxOpenFiles.setAccessible(true);            OSXAdapter.setFileHandler(this, osxOpenFiles);            Method osxQuit = getClass().getDeclaredMethod("osxQuit");            osxQuit.setAccessible(true);            OSXAdapter.setQuitHandler(this, osxQuit);        } catch (NoSuchMethodException e) {            throw new RuntimeException(e);        }    }}
private JMenu pdfbox_f201_0()
{    JMenuItem openMenuItem = new JMenuItem("Open...");    openMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, SHORCUT_KEY_MASK));    openMenuItem.addActionListener(this::openMenuItemActionPerformed);    JMenu fileMenu = new JMenu("File");    fileMenu.add(openMenuItem);    fileMenu.setMnemonic('F');    JMenuItem openUrlMenuItem = new JMenuItem("Open URL...");    openUrlMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_U, SHORCUT_KEY_MASK));    openUrlMenuItem.addActionListener(evt -> {        String urlString = JOptionPane.showInputDialog("Enter an URL");        if (urlString == null || urlString.isEmpty()) {            return;        }        try {            readPDFurl(urlString, "");        } catch (IOException e) {            throw new RuntimeException(e);        }    });    fileMenu.add(openUrlMenuItem);    reopenMenuItem = new JMenuItem("Reopen");    reopenMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R, SHORCUT_KEY_MASK));    reopenMenuItem.addActionListener(evt -> {        try {            if (currentFilePath.startsWith("http")) {                readPDFurl(currentFilePath, "");            } else {                readPDFFile(currentFilePath, "");            }        } catch (IOException e) {            new ErrorDialog(e).setVisible(true);        }    });    reopenMenuItem.setEnabled(false);    fileMenu.add(reopenMenuItem);    try {        recentFiles = new RecentFiles(this.getClass(), 5);    } catch (Exception e) {        throw new RuntimeException(e);    }    recentFilesMenu = new JMenu("Open Recent");    recentFilesMenu.setEnabled(false);    addRecentFileItems();    fileMenu.add(recentFilesMenu);    printMenuItem = new JMenuItem("Print");    printMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_P, SHORCUT_KEY_MASK));    printMenuItem.setEnabled(false);    printMenuItem.addActionListener(this::printMenuItemActionPerformed);    fileMenu.addSeparator();    fileMenu.add(printMenuItem);    JMenuItem exitMenuItem = new JMenuItem("Exit");    exitMenuItem.setAccelerator(KeyStroke.getKeyStroke("alt F4"));    exitMenuItem.addActionListener(this::exitMenuItemActionPerformed);    if (!IS_MAC_OS) {        fileMenu.addSeparator();        fileMenu.add(exitMenuItem);    }    return fileMenu;}
private JMenu pdfbox_f202_0()
{    JMenu editMenu = new JMenu("Edit");    editMenu.setMnemonic('E');    JMenuItem cutMenuItem = new JMenuItem("Cut");    cutMenuItem.setEnabled(false);    editMenu.add(cutMenuItem);    JMenuItem copyMenuItem = new JMenuItem("Copy");    copyMenuItem.setEnabled(false);    editMenu.add(copyMenuItem);    JMenuItem pasteMenuItem = new JMenuItem("Paste");    pasteMenuItem.setEnabled(false);    editMenu.add(pasteMenuItem);    JMenuItem deleteMenuItem = new JMenuItem("Delete");    deleteMenuItem.setEnabled(false);    editMenu.add(deleteMenuItem);    editMenu.addSeparator();    editMenu.add(createFindMenu());    return editMenu;}
private JMenu pdfbox_f203_0()
{    findMenu = new JMenu("Find");    findMenu.setEnabled(false);    findMenuItem = new JMenuItem("Find...");    findMenuItem.setActionCommand("find");    findMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, SHORCUT_KEY_MASK));    findNextMenuItem = new JMenuItem("Find Next");    if (IS_MAC_OS) {        findNextMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, SHORCUT_KEY_MASK));    } else {        findNextMenuItem.setAccelerator(KeyStroke.getKeyStroke("F3"));    }    findPreviousMenuItem = new JMenuItem("Find Previous");    if (IS_MAC_OS) {        findPreviousMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, SHORCUT_KEY_MASK | InputEvent.SHIFT_DOWN_MASK));    } else {        findPreviousMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F3, InputEvent.SHIFT_DOWN_MASK));    }    findMenu.add(findMenuItem);    findMenu.add(findNextMenuItem);    findMenu.add(findPreviousMenuItem);    return findMenu;}
public JMenu pdfbox_f204_0()
{    return findMenu;}
public JMenuItem pdfbox_f205_0()
{    return findMenuItem;}
public JMenuItem pdfbox_f206_0()
{    return findNextMenuItem;}
public JMenuItem pdfbox_f207_0()
{    return findPreviousMenuItem;}
private void pdfbox_f208_0(String filename)
{    try {        readPDFFile(filename, "");    } catch (IOException e) {        throw new RuntimeException(e);    }}
private void pdfbox_f209_0()
{    exitMenuItemActionPerformed(null);}
private void pdfbox_f210_0(ActionEvent evt)
{    try {        if (IS_MAC_OS) {            FileDialog openDialog = new FileDialog(this, "Open");            openDialog.setFilenameFilter((dir, name) -> name.toLowerCase().endsWith(".pdf"));            openDialog.setVisible(true);            if (openDialog.getFile() != null) {                readPDFFile(new File(openDialog.getDirectory(), openDialog.getFile()), "");            }        } else {            String[] extensions = new String[] { "pdf", "PDF" };            FileFilter pdfFilter = new ExtensionFileFilter(extensions, "PDF Files (*.pdf)");            FileOpenSaveDialog openDialog = new FileOpenSaveDialog(this, pdfFilter);            File file = openDialog.openFile();            if (file != null) {                readPDFFile(file, "");            }        }    } catch (IOException e) {        throw new RuntimeException(e);    }}
private void pdfbox_f211_0(TreeSelectionEvent evt)
{    TreePath path = tree.getSelectionPath();    if (path != null) {        try {            Object selectedNode = path.getLastPathComponent();            statusBar.getStatusLabel().setText("");            if (isPage(selectedNode)) {                showPage(selectedNode);                return;            }            if (isSpecialColorSpace(selectedNode) || isOtherColorSpace(selectedNode)) {                showColorPane(selectedNode);                return;            }            if (path.getParentPath() != null && isFlagNode(selectedNode, path.getParentPath().getLastPathComponent())) {                Object parentNode = path.getParentPath().getLastPathComponent();                showFlagPane(parentNode, selectedNode);                return;            }            if (isStream(selectedNode)) {                showStream((COSStream) getUnderneathObject(selectedNode), path);                return;            }            if (isFont(selectedNode)) {                showFont(selectedNode, path);                return;            }            if (isString(selectedNode)) {                showString(selectedNode);                return;            }            if (jSplitPane1.getRightComponent() == null || !jSplitPane1.getRightComponent().equals(jScrollPane2)) {                replaceRightComponent(jScrollPane2);            }            jTextPane1.setText(convertToString(selectedNode));        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException(e);        }    }}
private boolean pdfbox_f212_0(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSArray && ((COSArray) selectedNode).size() > 0) {        COSBase arrayEntry = ((COSArray) selectedNode).get(0);        if (arrayEntry instanceof COSName) {            COSName name = (COSName) arrayEntry;            return SPECIALCOLORSPACES.contains(name);        }    }    return false;}
private boolean pdfbox_f213_0(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSArray && ((COSArray) selectedNode).size() > 0) {        COSBase arrayEntry = ((COSArray) selectedNode).get(0);        if (arrayEntry instanceof COSName) {            COSName name = (COSName) arrayEntry;            return OTHERCOLORSPACES.contains(name);        }    }    return false;}
private boolean pdfbox_f214_0(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) selectedNode;        COSBase typeItem = dict.getItem(COSName.TYPE);        if (COSName.PAGE.equals(typeItem)) {            return true;        }    } else if (selectedNode instanceof PageEntry) {        return true;    }    return false;}
private boolean pdfbox_f215_0(Object selectedNode, Object parentNode)
{    if (selectedNode instanceof MapEntry) {        Object key = ((MapEntry) selectedNode).getKey();        return (COSName.FLAGS.equals(key) && isFontDescriptor(parentNode)) || (COSName.F.equals(key) && isAnnot(parentNode)) || COSName.FF.equals(key) || COSName.PANOSE.equals(key) || COSName.SIG_FLAGS.equals(key) || (COSName.P.equals(key) && isEncrypt(parentNode));    }    return false;}
private boolean pdfbox_f216_0(Object obj)
{    if (obj instanceof MapEntry) {        MapEntry entry = (MapEntry) obj;        return COSName.ENCRYPT.equals(entry.getKey()) && entry.getValue() instanceof COSDictionary;    }    return false;}
private boolean pdfbox_f217_0(Object obj)
{    Object underneathObject = getUnderneathObject(obj);    return underneathObject instanceof COSDictionary && ((COSDictionary) underneathObject).containsKey(COSName.TYPE) && ((COSDictionary) underneathObject).getCOSName(COSName.TYPE).equals(COSName.FONT_DESC);}
private boolean pdfbox_f218_0(Object obj)
{    Object underneathObject = getUnderneathObject(obj);    return underneathObject instanceof COSDictionary && ((COSDictionary) underneathObject).containsKey(COSName.TYPE) && ((COSDictionary) underneathObject).getCOSName(COSName.TYPE).equals(COSName.ANNOT);}
private boolean pdfbox_f219_0(Object selectedNode)
{    return getUnderneathObject(selectedNode) instanceof COSStream;}
private boolean pdfbox_f220_0(Object selectedNode)
{    return getUnderneathObject(selectedNode) instanceof COSString;}
private boolean pdfbox_f221_0(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    if (selectedNode instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) selectedNode;        return dic.containsKey(COSName.TYPE) && dic.getCOSName(COSName.TYPE).equals(COSName.FONT) && !isCIDFont(dic);    }    return false;}
private boolean pdfbox_f222_0(COSDictionary dic)
{    return dic.containsKey(COSName.SUBTYPE) && (dic.getCOSName(COSName.SUBTYPE).equals(COSName.CID_FONT_TYPE0) || dic.getCOSName(COSName.SUBTYPE).equals(COSName.CID_FONT_TYPE2));}
private void pdfbox_f223_0(Object csNode)
{    csNode = getUnderneathObject(csNode);    if (csNode instanceof COSArray && ((COSArray) csNode).size() > 0) {        COSArray array = (COSArray) csNode;        COSBase arrayEntry = array.get(0);        if (arrayEntry instanceof COSName) {            COSName csName = (COSName) arrayEntry;            if (csName.equals(COSName.SEPARATION)) {                replaceRightComponent(new CSSeparation(array).getPanel());            } else if (csName.equals(COSName.DEVICEN)) {                replaceRightComponent(new CSDeviceN(array).getPanel());            } else if (csName.equals(COSName.INDEXED)) {                replaceRightComponent(new CSIndexed(array).getPanel());            } else if (OTHERCOLORSPACES.contains(csName)) {                replaceRightComponent(new CSArrayBased(array).getPanel());            }        }    }}
private void pdfbox_f224_0(Object selectedNode)
{    selectedNode = getUnderneathObject(selectedNode);    COSDictionary page;    if (selectedNode instanceof COSDictionary) {        page = (COSDictionary) selectedNode;    } else {        page = ((PageEntry) selectedNode).getDict();    }    COSBase typeItem = page.getItem(COSName.TYPE);    if (COSName.PAGE.equals(typeItem)) {        PagePane pagePane = new PagePane(document, page, statusBar.getStatusLabel());        replaceRightComponent(new JScrollPane(pagePane.getPanel()));    }}
private void pdfbox_f225_0(Object parentNode, Object selectedNode)
{    parentNode = getUnderneathObject(parentNode);    if (parentNode instanceof COSDictionary) {        selectedNode = ((MapEntry) selectedNode).getKey();        selectedNode = getUnderneathObject(selectedNode);        FlagBitsPane flagBitsPane = new FlagBitsPane(document, (COSDictionary) parentNode, (COSName) selectedNode);        replaceRightComponent(flagBitsPane.getPane());    }}
private void pdfbox_f226_0(COSStream stream, TreePath path) throws IOException
{    boolean isContentStream = false;    boolean isThumb = false;    COSName key = getNodeKey(path.getLastPathComponent());    COSName parentKey = getNodeKey(path.getParentPath().getLastPathComponent());    COSDictionary resourcesDic = null;    if (COSName.CONTENTS.equals(key)) {        Object pageObj = path.getParentPath().getLastPathComponent();        COSDictionary page = (COSDictionary) getUnderneathObject(pageObj);        resourcesDic = (COSDictionary) page.getDictionaryObject(COSName.RESOURCES);        isContentStream = true;    } else if (COSName.CONTENTS.equals(parentKey) || COSName.CHAR_PROCS.equals(parentKey)) {        Object pageObj = path.getParentPath().getParentPath().getLastPathComponent();        COSDictionary page = (COSDictionary) getUnderneathObject(pageObj);        resourcesDic = (COSDictionary) page.getDictionaryObject(COSName.RESOURCES);        isContentStream = true;    } else if (COSName.FORM.equals(stream.getCOSName(COSName.SUBTYPE)) || COSName.PATTERN.equals(stream.getCOSName(COSName.TYPE)) || stream.getInt(COSName.PATTERN_TYPE) == 1) {        if (stream.containsKey(COSName.RESOURCES)) {            resourcesDic = (COSDictionary) stream.getDictionaryObject(COSName.RESOURCES);        }        isContentStream = true;    } else if (COSName.THUMB.equals(key)) {        resourcesDic = null;        isThumb = true;    } else if (COSName.IMAGE.equals((stream).getCOSName(COSName.SUBTYPE))) {                Object resourcesObj = path.getParentPath().getParentPath().getLastPathComponent();        resourcesDic = (COSDictionary) getUnderneathObject(resourcesObj);    }    StreamPane streamPane = new StreamPane(stream, isContentStream, isThumb, resourcesDic);    replaceRightComponent(streamPane.getPanel());}
private void pdfbox_f227_0(Object selectedNode, TreePath path)
{    COSName fontName = getNodeKey(selectedNode);    COSDictionary resourceDic = (COSDictionary) getUnderneathObject(path.getParentPath().getParentPath().getLastPathComponent());    FontEncodingPaneController fontEncodingPaneController = new FontEncodingPaneController(fontName, resourceDic);    JPanel pane = fontEncodingPaneController.getPane();    if (pane == null) {                replaceRightComponent(jScrollPane2);        return;    }    replaceRightComponent(pane);}
private void pdfbox_f228_0(Component pane)
{    int div = jSplitPane1.getDividerLocation();    jSplitPane1.setRightComponent(pane);    jSplitPane1.setDividerLocation(div);}
private void pdfbox_f229_0(Object selectedNode)
{    COSString string = (COSString) getUnderneathObject(selectedNode);    replaceRightComponent(new StringPane(string).getPane());}
private COSName pdfbox_f230_0(Object selectedNode)
{    if (selectedNode instanceof MapEntry) {        return ((MapEntry) selectedNode).getKey();    }    return null;}
private Object pdfbox_f231_0(Object selectedNode)
{    if (selectedNode instanceof MapEntry) {        selectedNode = ((MapEntry) selectedNode).getValue();    } else if (selectedNode instanceof ArrayEntry) {        selectedNode = ((ArrayEntry) selectedNode).getValue();    } else if (selectedNode instanceof PageEntry) {        selectedNode = ((PageEntry) selectedNode).getDict();    }    if (selectedNode instanceof COSObject) {        selectedNode = ((COSObject) selectedNode).getObject();    }    return selectedNode;}
private String pdfbox_f232_0(Object selectedNode)
{    String data = null;    if (selectedNode instanceof COSBoolean) {        data = "" + ((COSBoolean) selectedNode).getValue();    } else if (selectedNode instanceof COSFloat) {        data = "" + ((COSFloat) selectedNode).floatValue();    } else if (selectedNode instanceof COSNull) {        data = "null";    } else if (selectedNode instanceof COSInteger) {        data = "" + ((COSInteger) selectedNode).intValue();    } else if (selectedNode instanceof COSName) {        data = "" + ((COSName) selectedNode).getName();    } else if (selectedNode instanceof COSString) {        String text = ((COSString) selectedNode).getString();                for (char c : text.toCharArray()) {            if (Character.isISOControl(c)) {                text = "<" + ((COSString) selectedNode).toHexString() + ">";                break;            }        }        data = "" + text;    } else if (selectedNode instanceof COSStream) {        try {            COSStream stream = (COSStream) selectedNode;            InputStream in = stream.createInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream();            IOUtils.copy(in, baos);            data = baos.toString();        } catch (IOException e) {            throw new RuntimeException(e);        }    } else if (selectedNode instanceof MapEntry) {        data = convertToString(((MapEntry) selectedNode).getValue());    } else if (selectedNode instanceof ArrayEntry) {        data = convertToString(((ArrayEntry) selectedNode).getValue());    }    return data;}
private void pdfbox_f233_0(ActionEvent ignored)
{    if (document != null) {        try {            document.close();            if (!currentFilePath.startsWith("http")) {                recentFiles.addFile(currentFilePath);            }            recentFiles.close();        } catch (IOException e) {            throw new RuntimeException(e);        }    }    windowPrefs.setExtendedState(getExtendedState());    this.setExtendedState(Frame.NORMAL);    windowPrefs.setBounds(getBounds());    windowPrefs.setDividerLocation(jSplitPane1.getDividerLocation());    performApplicationExit();}
protected void pdfbox_f234_0()
{    System.exit(0);}
private void pdfbox_f235_0(ActionEvent evt)
{    if (document == null) {        return;    }    AccessPermission ap = document.getCurrentAccessPermission();    if (!ap.canPrint()) {        JOptionPane.showMessageDialog(this, "You do not have permission to print");        return;    }    try {        PrinterJob job = PrinterJob.getPrinterJob();        job.setPageable(new PDFPageable(document));        PrintRequestAttributeSet pras = new HashPrintRequestAttributeSet();        PDViewerPreferences vp = document.getDocumentCatalog().getViewerPreferences();        if (vp != null && vp.getDuplex() != null) {            String dp = vp.getDuplex();            if (PDViewerPreferences.DUPLEX.DuplexFlipLongEdge.toString().equals(dp)) {                pras.add(Sides.TWO_SIDED_LONG_EDGE);            } else if (PDViewerPreferences.DUPLEX.DuplexFlipShortEdge.toString().equals(dp)) {                pras.add(Sides.TWO_SIDED_SHORT_EDGE);            } else if (PDViewerPreferences.DUPLEX.Simplex.toString().equals(dp)) {                pras.add(Sides.ONE_SIDED);            }        }        if (job.printDialog(pras)) {            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));            try {                job.print(pras);            } finally {                setCursor(Cursor.getDefaultCursor());            }        }    } catch (PrinterException e) {        throw new RuntimeException(e);    }}
private void pdfbox_f236_0(WindowEvent evt)
{    exitMenuItemActionPerformed(null);}
private void pdfbox_f237_0(String filePath, String password) throws IOException
{    File file = new File(filePath);    readPDFFile(file, password);}
private void pdfbox_f238_0(final File file, String password) throws IOException
{    if (document != null) {        document.close();        if (!currentFilePath.startsWith("http")) {            recentFiles.addFile(currentFilePath);        }    }    currentFilePath = file.getPath();    recentFiles.removeFile(file.getPath());    LogDialog.instance().clear();    DocumentOpener documentOpener = new DocumentOpener(password) {        @Override        PDDocument open() throws IOException {            return PDDocument.load(file, password);        }    };    document = documentOpener.parse();    printMenuItem.setEnabled(true);    reopenMenuItem.setEnabled(true);    initTree();    if (IS_MAC_OS) {        setTitle(file.getName());        getRootPane().putClientProperty("Window.documentFile", file);    } else {        setTitle("PDF Debugger - " + file.getAbsolutePath());    }    addRecentFileItems();}
 PDDocument pdfbox_f239_0() throws IOException
{    return PDDocument.load(file, password);}
private void pdfbox_f240_0(final String urlString, String password) throws IOException
{    if (document != null) {        document.close();        if (!currentFilePath.startsWith("http")) {            recentFiles.addFile(currentFilePath);        }    }    currentFilePath = urlString;    LogDialog.instance().clear();    DocumentOpener documentOpener = new DocumentOpener(password) {        @Override        PDDocument open() throws IOException {            return PDDocument.load(new URL(urlString).openStream(), password);        }    };    document = documentOpener.parse();    printMenuItem.setEnabled(true);    reopenMenuItem.setEnabled(true);    initTree();    if (IS_MAC_OS) {        setTitle(urlString);    } else {        setTitle("PDF Debugger - " + urlString);    }    addRecentFileItems();}
 PDDocument pdfbox_f241_0() throws IOException
{    return PDDocument.load(new URL(urlString).openStream(), password);}
public void pdfbox_f242_0()
{    TreeStatus treeStatus = new TreeStatus(document.getDocument().getTrailer());    statusPane.updateTreeStatus(treeStatus);    if (isPageMode) {        File file = new File(currentFilePath);        DocumentEntry documentEntry = new DocumentEntry(document, file.getName());        ZoomMenu.getInstance().resetZoom();        RotationMenu.getInstance().setRotationSelection(RotationMenu.ROTATE_0_DEGREES);        tree.setModel(new PDFTreeModel(documentEntry));                tree.setSelectionPath(tree.getPathForRow(1));    } else {        tree.setModel(new PDFTreeModel(document));        tree.setSelectionPath(treeStatus.getPathForString("Root"));    }}
 final PDDocument pdfbox_f243_0() throws IOException
{    while (true) {        try {            return open();        } catch (InvalidPasswordException ipe) {                        JPanel panel = new JPanel();            JLabel label = new JLabel("Password:");            JPasswordField pass = new JPasswordField(10);            panel.add(label);            panel.add(pass);            String[] options = new String[] { "OK", "Cancel" };            int option = JOptionPane.showOptionDialog(null, panel, "Enter password", JOptionPane.NO_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, "");            if (option == 0) {                password = new String(pass.getPassword());                continue;            }            throw ipe;        }    }}
private void pdfbox_f244_0()
{    Action recentMenuAction = new AbstractAction() {        @Override        public void actionPerformed(ActionEvent actionEvent) {            String filePath = (String) ((JComponent) actionEvent.getSource()).getClientProperty("path");            try {                readPDFFile(filePath, "");            } catch (Exception e) {                throw new RuntimeException(e);            }        }    };    if (!recentFiles.isEmpty()) {        recentFilesMenu.removeAll();        List<String> files = recentFiles.getFiles();        for (int i = files.size() - 1; i >= 0; i--) {            String path = files.get(i);            String name = new File(path).getName();            JMenuItem recentFileMenuItem = new JMenuItem(name);            recentFileMenuItem.putClientProperty("path", path);            recentFileMenuItem.addActionListener(recentMenuAction);            recentFilesMenu.add(recentFileMenuItem);        }        recentFilesMenu.setEnabled(true);    }}
public void pdfbox_f245_0(ActionEvent actionEvent)
{    String filePath = (String) ((JComponent) actionEvent.getSource()).getClientProperty("path");    try {        readPDFFile(filePath, "");    } catch (Exception e) {        throw new RuntimeException(e);    }}
public static String pdfbox_f246_0(PDDocument document, int pageIndex)
{    PDPageLabels pageLabels;    try {        pageLabels = document.getDocumentCatalog().getPageLabels();    } catch (IOException ex) {        return ex.getMessage();    }    if (pageLabels != null) {        String[] labels = pageLabels.getLabelsByPageIndices();        if (labels[pageIndex] != null) {            return labels[pageIndex];        }    }    return null;}
public static Style pdfbox_f247_0(String operator)
{    if (operatorStyleMap.containsKey(operator)) {        return operatorStyleMap.get(operator);    }    return null;}
public boolean pdfbox_f248_0()
{    return isImage;}
public boolean pdfbox_f249_0()
{    return isXmlMetadata;}
public List<String> pdfbox_f250_0()
{    return new ArrayList(filters.keySet());}
private String pdfbox_f251_0()
{    StringBuilder sb = new StringBuilder();    COSBase base = strm.getFilters();    if (base instanceof COSName) {        sb.append(((COSName) base).getName());    } else if (base instanceof COSArray) {        COSArray filterArray = (COSArray) base;        for (int i = 0; i < filterArray.size(); i++) {            if (i > 0) {                sb.append(", ");            }            sb.append(((COSName) filterArray.get(i)).getName());        }    }    return "Encoded (" + sb.toString() + ")";}
public InputStream pdfbox_f252_1(String key)
{    try {        if (DECODED.equals(key)) {            return strm.createInputStream();        } else if (getFilteredLabel().equals(key)) {            return strm.createRawInputStream();        } else {            return new PDStream(strm).createInputStream(filters.get(key));        }    } catch (IOException e) {            }    return null;}
public BufferedImage pdfbox_f253_1(PDResources resources)
{    try {        PDImageXObject imageXObject;        if (isThumb) {            imageXObject = PDImageXObject.createThumbnail(strm);        } else {            imageXObject = new PDImageXObject(new PDStream(strm), resources);        }        return imageXObject.getImage();    } catch (IOException e) {            }    return null;}
private Map<String, List<String>> pdfbox_f254_0(COSStream stream)
{    Map<String, List<String>> filterList = new LinkedHashMap<>();    if (isImage) {        filterList.put(IMAGE, null);    }    filterList.put(DECODED, null);    PDStream pdStream = new PDStream(stream);    if (pdStream.getFilters() != null) {        int filtersSize = pdStream.getFilters().size();        for (int i = filtersSize - 1; i >= 1; i--) {            filterList.put(getPartialStreamCommand(i), getStopFilterList(i));        }        filterList.put(getFilteredLabel(), null);    }    return filterList;}
private String pdfbox_f255_0(final int indexOfStopFilter)
{    List<COSName> availableFilters = new PDStream(strm).getFilters();    StringBuilder nameListBuilder = new StringBuilder();    for (int i = indexOfStopFilter; i < availableFilters.size(); i++) {        nameListBuilder.append(availableFilters.get(i).getName()).append(" & ");    }    nameListBuilder.delete(nameListBuilder.lastIndexOf("&"), nameListBuilder.length());    return "Keep " + nameListBuilder.toString() + "...";}
private List<String> pdfbox_f256_0(final int stopFilterIndex)
{    List<COSName> availableFilters = new PDStream(strm).getFilters();    final List<String> stopFilters = new ArrayList<>(1);    stopFilters.add(availableFilters.get(stopFilterIndex).getName());    return stopFilters;}
private boolean pdfbox_f257_0(COSDictionary dic, boolean isThumb)
{    if (isThumb) {        return true;    }    return dic.containsKey(COSName.SUBTYPE) && dic.getCOSName(COSName.SUBTYPE).equals(COSName.IMAGE);}
private boolean pdfbox_f258_0(COSDictionary dic)
{    return dic.containsKey(COSName.SUBTYPE) && dic.getCOSName(COSName.SUBTYPE).equals(COSName.getPDFName("XML"));}
private void pdfbox_f259_0()
{    JPanel panel = new JPanel();    panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));    zoomMenu = ZoomMenu.getInstance();    zoomMenu.changeZoomSelection(zoomMenu.getImageZoomScale());    label = new JLabel();    label.setBorder(new LineBorder(Color.BLACK));    label.setAlignmentX(Component.CENTER_ALIGNMENT);    addImage(zoomImage(image, zoomMenu.getImageZoomScale(), RotationMenu.getRotationDegrees()));    panel.add(Box.createVerticalGlue());    panel.add(label);    panel.add(Box.createVerticalGlue());    scrollPane = new JScrollPane();    scrollPane.setPreferredSize(new Dimension(300, 400));    scrollPane.addAncestorListener(this);    scrollPane.setViewportView(panel);}
 JComponent pdfbox_f260_0()
{    return scrollPane;}
private Image pdfbox_f261_0(BufferedImage origin, float scale, int rotation)
{    BufferedImage rotatedImage = ImageUtil.getRotatedImage(origin, rotation);    int resizedWidth = (int) (rotatedImage.getWidth() * scale);    int resizedHeight = (int) (rotatedImage.getHeight() * scale);    return rotatedImage.getScaledInstance(resizedWidth, resizedHeight, BufferedImage.SCALE_SMOOTH);}
public void pdfbox_f262_0(ActionEvent actionEvent)
{    String actionCommand = actionEvent.getActionCommand();    if (ZoomMenu.isZoomMenu(actionCommand) || RotationMenu.isRotationMenu(actionCommand)) {        addImage(zoomImage(image, ZoomMenu.getZoomScale(), RotationMenu.getRotationDegrees()));        zoomMenu.setImageZoomScale(ZoomMenu.getZoomScale());    }}
private void pdfbox_f263_0(Image img)
{        AffineTransform tx = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration().getDefaultTransform();    label.setSize((int) Math.ceil(img.getWidth(null) / tx.getScaleX()), (int) Math.ceil(img.getHeight(null) / tx.getScaleY()));    label.setIcon(new HighResolutionImageIcon(img, label.getWidth(), label.getHeight()));    label.revalidate();}
public void pdfbox_f264_0(AncestorEvent ancestorEvent)
{    zoomMenu.addMenuListeners(this);    zoomMenu.setEnableMenu(true);    rotationMenu = RotationMenu.getInstance();    rotationMenu.addMenuListeners(this);    rotationMenu.setRotationSelection(RotationMenu.ROTATE_0_DEGREES);    rotationMenu.setEnableMenu(true);}
public void pdfbox_f265_0(AncestorEvent ancestorEvent)
{    zoomMenu.setEnableMenu(false);    rotationMenu.setEnableMenu(false);}
public void pdfbox_f266_0(AncestorEvent ancestorEvent)
{}
public JComponent pdfbox_f267_0()
{    return panel;}
private JPanel pdfbox_f268_0(List<String> availableFilters, String i, ActionListener actionListener)
{    JComboBox<String> filters = new JComboBox<>(new Vector<>(availableFilters));    filters.setSelectedItem(i);    filters.addActionListener(actionListener);    JPanel headerPanel = new JPanel(new FlowLayout());    headerPanel.add(filters);    return headerPanel;}
public void pdfbox_f269_1(ActionEvent actionEvent)
{    if ("comboBoxChanged".equals(actionEvent.getActionCommand())) {        JComboBox comboBox = (JComboBox) actionEvent.getSource();        String currentFilter = (String) comboBox.getSelectedItem();        try {            if (currentFilter.equals(Stream.IMAGE)) {                requestImageShowing();                tabbedPane.removeAll();                tabbedPane.add("Image view", view.getStreamPanel());                return;            }            tabbedPane.removeAll();            tabbedPane.add("Text view", view.getStreamPanel());            tabbedPane.add("Hex view", hexView.getPane());            requestStreamText(currentFilter);        } catch (IOException e) {                    }    }}
private void pdfbox_f270_0() throws IOException
{    if (stream.isImage()) {        BufferedImage image;        synchronized (stream) {            image = stream.getImage(resources);        }        if (image == null) {            JOptionPane.showMessageDialog(panel, "image not available (filter missing?)");            return;        }        view.showStreamImage(image);    }}
private void pdfbox_f271_0(String command) throws IOException
{    new DocumentCreator(command).execute();    synchronized (stream) {        InputStream is = stream.getStream(command);        if (is == null) {            JOptionPane.showMessageDialog(panel, command + " text not available (filter missing?)");            return;        }        hexView.changeData(IOUtils.toByteArray(is));    }}
protected StyledDocument pdfbox_f272_0()
{        String encoding = "ISO-8859-1";    synchronized (stream) {        if (stream.isXmlMetadata()) {            encoding = "UTF-8";        }        InputStream inputStream = stream.getStream(filterKey);        if (isContentStream && Stream.DECODED.equals(filterKey)) {            StyledDocument document = getContentStreamDocument(inputStream);            if (document != null) {                return document;            }            return getDocument(stream.getStream(filterKey), encoding);        }        return getDocument(inputStream, encoding);    }}
protected void pdfbox_f273_1()
{    try {        view.showStreamText(get(), tTController);    } catch (InterruptedException | ExecutionException e) {            }}
private String pdfbox_f274_1(InputStream in, String encoding)
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try {        IOUtils.copy(in, baos);        return baos.toString(encoding);    } catch (IOException e) {                return null;    }}
private StyledDocument pdfbox_f275_1(InputStream inputStream, String encoding)
{    StyledDocument docu = new DefaultStyledDocument();    if (inputStream != null) {        String data = getStringOfStream(inputStream, encoding);        try {            docu.insertString(0, data, null);        } catch (BadLocationException e) {                    }    }    return docu;}
private StyledDocument pdfbox_f276_0(InputStream inputStream)
{    StyledDocument docu = new DefaultStyledDocument();    PDFStreamParser parser;    try {        parser = new PDFStreamParser(IOUtils.toByteArray(inputStream));        parser.parse();    } catch (IOException e) {        return null;    }    parser.getTokens().forEach(obj -> writeToken(obj, docu));    return docu;}
private void pdfbox_f277_1(Object obj, StyledDocument docu)
{    try {        if (obj instanceof Operator) {            addOperators(obj, docu);        } else {            writeOperand(obj, docu);        }    } catch (BadLocationException e) {            }}
private void pdfbox_f278_0(Object obj, StyledDocument docu) throws BadLocationException
{    writeIndent(docu);    if (obj instanceof COSName) {        String str = "/" + ((COSName) obj).getName();        docu.insertString(docu.getLength(), str + " ", NAME_STYLE);    } else if (obj instanceof COSBoolean) {        String str = obj.toString();        docu.insertString(docu.getLength(), str + " ", null);    } else if (obj instanceof COSArray) {        docu.insertString(docu.getLength(), "[ ", null);        for (COSBase elem : (COSArray) obj) {            writeOperand(elem, docu);        }        docu.insertString(docu.getLength(), "] ", null);    } else if (obj instanceof COSString) {        docu.insertString(docu.getLength(), "(", null);        byte[] bytes = ((COSString) obj).getBytes();        for (byte b : bytes) {            int chr = b & 0xff;            if (chr < 0x20 || chr > 0x7e) {                                String str = String.format("\\%03o", chr);                docu.insertString(docu.getLength(), str, ESCAPE_STYLE);            } else if (chr == '(' || chr == ')' || chr == '\n' || chr == '\r' || chr == '\t' || chr == '\b' || chr == '\f' || chr == '\\') {                                String str = "\\" + (char) chr;                docu.insertString(docu.getLength(), str, ESCAPE_STYLE);            } else {                String str = Character.toString((char) chr);                docu.insertString(docu.getLength(), str, STRING_STYLE);            }        }        docu.insertString(docu.getLength(), ") ", null);    } else if (obj instanceof COSNumber) {        String str;        if (obj instanceof COSFloat) {            str = Float.toString(((COSFloat) obj).floatValue());        } else {            str = Integer.toString(((COSNumber) obj).intValue());        }        docu.insertString(docu.getLength(), str + " ", NUMBER_STYLE);    } else if (obj instanceof COSDictionary) {        docu.insertString(docu.getLength(), "<< ", null);        COSDictionary dict = (COSDictionary) obj;        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {            writeOperand(entry.getKey(), docu);            writeOperand(entry.getValue(), docu);        }        docu.insertString(docu.getLength(), ">> ", null);    } else {        String str = obj.toString();        str = str.substring(str.indexOf('{') + 1, str.length() - 1);        docu.insertString(docu.getLength(), str + " ", null);    }}
private void pdfbox_f279_0(Object obj, StyledDocument docu) throws BadLocationException
{    Operator op = (Operator) obj;    if (op.getName().equals(OperatorName.END_TEXT) || op.getName().equals(OperatorName.RESTORE) || op.getName().equals(OperatorName.END_MARKED_CONTENT)) {        indent--;    }    writeIndent(docu);    if (op.getName().equals(OperatorName.BEGIN_INLINE_IMAGE)) {        docu.insertString(docu.getLength(), OperatorName.BEGIN_INLINE_IMAGE + "\n", OPERATOR_STYLE);        COSDictionary dic = op.getImageParameters();        for (COSName key : dic.keySet()) {            Object value = dic.getDictionaryObject(key);            docu.insertString(docu.getLength(), "/" + key.getName() + " ", null);            writeToken(value, docu);            docu.insertString(docu.getLength(), "\n", null);        }        String imageString = new String(op.getImageData(), Charsets.ISO_8859_1);        docu.insertString(docu.getLength(), OperatorName.BEGIN_INLINE_IMAGE_DATA + "\n", INLINE_IMAGE_STYLE);        docu.insertString(docu.getLength(), imageString, null);        docu.insertString(docu.getLength(), "\n", null);        docu.insertString(docu.getLength(), OperatorName.END_INLINE_IMAGE + "\n", OPERATOR_STYLE);    } else {        String operator = ((Operator) obj).getName();        docu.insertString(docu.getLength(), operator + "\n", OPERATOR_STYLE);                if (op.getName().equals(OperatorName.BEGIN_TEXT) || op.getName().equals(OperatorName.SAVE) || op.getName().equals(OperatorName.BEGIN_MARKED_CONTENT) || op.getName().equals(OperatorName.BEGIN_MARKED_CONTENT_SEQ)) {            indent++;        }    }    needIndent = true;}
 void pdfbox_f280_0(StyledDocument docu) throws BadLocationException
{    if (needIndent) {        for (int i = 0; i < indent; i++) {            docu.insertString(docu.getLength(), "  ", null);        }        needIndent = false;    }}
 void pdfbox_f281_0(StyledDocument document, ToolTipController toolTipController)
{    contentPanel.removeAll();    StreamTextView textView = new StreamTextView(document, toolTipController);    contentPanel.add(textView.getView(), BorderLayout.CENTER);    contentPanel.validate();}
 void pdfbox_f282_0(BufferedImage image)
{    contentPanel.removeAll();    contentPanel.add(new StreamImageView(image).getView(), BorderLayout.CENTER);    contentPanel.validate();}
public JPanel pdfbox_f283_0()
{    return contentPanel;}
private void pdfbox_f284_0(StyledDocument document)
{    mainPanel = new JPanel();    textPane = new JTextPane(document);    textPane.addMouseMotionListener(this);    textPane.setFont(new Font("monospaced", Font.PLAIN, 13));    searcher = new Searcher(textPane);    JScrollPane scrollPane = new JScrollPane(textPane);    BoxLayout boxLayout = new BoxLayout(mainPanel, BoxLayout.Y_AXIS);    mainPanel.setLayout(boxLayout);    mainPanel.add(searcher.getSearchPanel());    mainPanel.add(scrollPane);    searcher.getSearchPanel().setVisible(false);    mainPanel.addAncestorListener(this);}
 JComponent pdfbox_f285_0()
{    return mainPanel;}
public void pdfbox_f286_0(MouseEvent mouseEvent)
{}
public void pdfbox_f287_0(MouseEvent mouseEvent)
{    if (tTController != null) {        int offset = textPane.viewToModel(mouseEvent.getPoint());        textPane.setToolTipText(tTController.getToolTip(offset, textPane));    }}
public void pdfbox_f288_0(AncestorEvent ancestorEvent)
{    if (ancestorEvent.getAncestor().equals(mainPanel)) {        PDFDebugger debugger = (PDFDebugger) SwingUtilities.getRoot(mainPanel);        debugger.getFindMenu().setEnabled(true);        searcher.addMenuListeners(debugger);    }}
public void pdfbox_f289_0(AncestorEvent ancestorEvent)
{    if (ancestorEvent.getAncestor().equals(mainPanel)) {        PDFDebugger debugger = (PDFDebugger) SwingUtilities.getRoot(mainPanel);        debugger.getFindMenu().setEnabled(false);        searcher.removeMenuListeners(debugger);    }}
public void pdfbox_f290_0(AncestorEvent ancestorEvent)
{}
 static String pdfbox_f291_0(Color color)
{    return String.format("%02x", color.getRed()) + String.format("%02x", color.getGreen()) + String.format("%02x", color.getBlue());}
 float[] pdfbox_f292_0(String rowtext)
{    List<String> words = ToolTipController.getWords(rowtext);    words.remove(words.size() - 1);    float[] values = new float[words.size()];    int index = 0;    try {        for (String word : words) {            values[index++] = Float.parseFloat(word);        }    } catch (NumberFormatException e) {        return null;    }    return values;}
 String pdfbox_f293_0(String hexValue)
{    return "<html>\n" + "<body bgcolor=#ffffff>\n" + "<div style=\"width:50px;height:20px;border:1px; background-color:#" + hexValue + ";\"></div></body>\n" + "</html>";}
public void pdfbox_f294_0(String toolTip)
{    this.toolTipText = toolTip;}
public String pdfbox_f295_0()
{    return toolTipText;}
private void pdfbox_f296_1(String fontReferenceName, PDResources resources)
{    PDFont font = null;    for (COSName name : resources.getFontNames()) {        if (name.getName().equals(fontReferenceName)) {            try {                font = resources.getFont(name);            } catch (IOException e) {                            }        }    }    if (font != null) {        markup = "<html>" + font.getName() + "</html>";    }}
private String pdfbox_f297_0(String rowText)
{    return rowText.trim().split(" ")[0].substring(1);}
public String pdfbox_f298_0()
{    return markup;}
private void pdfbox_f299_0(String rowText)
{    float[] colorValues = extractColorValues(rowText);    if (colorValues != null) {        Color color = new Color(colorValues[0], colorValues[0], colorValues[0]);        setToolTipText(getMarkUp(colorHexValue(color)));    }}
private void pdfbox_f300_1(String rowText)
{    float[] colorValues = extractColorValues(rowText);    if (colorValues != null) {        try {            float[] rgbValues = getICCColorSpace().toRGB(colorValues);            setToolTipText(getMarkUp(colorHexValue(new Color(rgbValues[0], rgbValues[1], rgbValues[2]))));        } catch (IOException e) {                    }    }}
 ICC_ColorSpace pdfbox_f301_0() throws IOException
{        ICC_Profile iccProfile = getICCProfile();    if (iccProfile == null) {        throw new IOException("Default CMYK color profile could not be loaded");    }    return new ICC_ColorSpace(iccProfile);}
 ICC_Profile pdfbox_f302_0() throws IOException
{                    String name = "/org/apache/pdfbox/resources/icc/ISOcoated_v2_300_bas.icc";    URL url = PDDeviceCMYK.class.getResource(name);    if (url == null) {        throw new IOException("Error loading resource: " + name);    }    try (InputStream input = url.openStream()) {        return ICC_Profile.getInstance(input);    }}
private void pdfbox_f303_0(String rowText)
{    float[] rgbValues = extractColorValues(rowText);    if (rgbValues != null) {        Color color = new Color(rgbValues[0], rgbValues[1], rgbValues[2]);        setToolTipText(getMarkUp(colorHexValue(color)));    }}
private void pdfbox_f304_1(PDResources resources, String colorSpaceName, String rowText)
{    PDColorSpace colorSpace = null;    try {        colorSpace = resources.getColorSpace(COSName.getPDFName(colorSpaceName));    } catch (IOException e) {            }    if (colorSpace instanceof PDPattern) {        setToolTipText("<html>Pattern</html>");        return;    }    if (colorSpace != null) {        try {            float[] rgbValues = colorSpace.toRGB(extractColorValues(rowText));            if (rgbValues != null) {                Color color = new Color(rgbValues[0], rgbValues[1], rgbValues[2]);                setToolTipText(getMarkUp(colorHexValue(color)));            }        } catch (IOException e) {                    }    }}
 static List<String> pdfbox_f305_0(String str)
{    List<String> words = new ArrayList<>();    for (String string : str.trim().split(" ")) {        string = string.trim();        if (!string.isEmpty() && !string.equals("\n")) {            words.add(string);        }    }    return words;}
public String pdfbox_f306_0(int offset, JTextComponent textComponent)
{    this.textComponent = textComponent;    String word = getWord(offset);    String rowText = getRowText(offset);    if (word != null) {        ToolTip toolTip;        switch(word) {            case OperatorName.SET_FONT_AND_SIZE:                toolTip = new FontToolTip(resources, rowText);                return toolTip.getToolTipText();            case OperatorName.STROKING_COLOR_N:                {                    String colorSpaceName = findColorSpace(offset, OperatorName.STROKING_COLORSPACE);                    if (colorSpaceName != null) {                        toolTip = new SCNToolTip(resources, colorSpaceName, rowText);                        return toolTip.getToolTipText();                    }                    break;                }            case OperatorName.NON_STROKING_COLOR_N:                {                    String colorSpaceName = findColorSpace(offset, OperatorName.NON_STROKING_COLORSPACE);                    if (colorSpaceName != null) {                        toolTip = new SCNToolTip(resources, colorSpaceName, rowText);                        return toolTip.getToolTipText();                    }                    break;                }            case OperatorName.STROKING_COLOR_RGB:            case OperatorName.NON_STROKING_RGB:                toolTip = new RGToolTip(rowText);                return toolTip.getToolTipText();            case OperatorName.STROKING_COLOR_CMYK:            case OperatorName.NON_STROKING_CMYK:                toolTip = new KToolTip(rowText);                return toolTip.getToolTipText();            case OperatorName.STROKING_COLOR_GRAY:            case OperatorName.NON_STROKING_GRAY:                toolTip = new GToolTip(rowText);                return toolTip.getToolTipText();            default:                break;        }    }    return null;}
private String pdfbox_f307_1(int offset, String colorSpaceType)
{    try {        while (offset != -1) {            offset = Utilities.getPositionAbove(textComponent, offset, 0);            String previousRowText = getRowText(offset);            if (previousRowText == null) {                return null;            }            previousRowText = previousRowText.trim();            if (isColorSpace(colorSpaceType, previousRowText)) {                return previousRowText.split(" ")[0];            }        }    } catch (BadLocationException e) {            }    return null;}
private boolean pdfbox_f308_0(String colorSpaceType, String rowText)
{    List<String> words = getWords(rowText);    return words.size() == 2 && words.get(1).equals(colorSpaceType);}
private String pdfbox_f309_1(int offset)
{    try {        int start = Utilities.getWordStart(textComponent, offset);        int end = Utilities.getWordEnd(textComponent, offset);        return textComponent.getDocument().getText(start, end - start + 1).trim();    } catch (BadLocationException e) {            }    return null;}
private String pdfbox_f310_1(int offset)
{    try {        int rowStart = Utilities.getRowStart(textComponent, offset);        int rowEnd = Utilities.getRowEnd(textComponent, offset);        return textComponent.getDocument().getText(rowStart, rowEnd - rowStart + 1);    } catch (BadLocationException e) {            }    return null;}
private JTextPane pdfbox_f311_0(COSString cosString)
{    JTextPane textPane = new JTextPane();    textPane.setText(getTextString(cosString));    textPane.setEditable(false);    return textPane;}
private JComponent pdfbox_f312_0(COSString cosString)
{    HexView hexView = new HexView(cosString.getBytes());    return hexView.getPane();}
private String pdfbox_f313_0(COSString cosString)
{    String text = cosString.getString();    for (char c : text.toCharArray()) {        if (Character.isISOControl(c)) {            text = "<" + cosString.toHexString() + ">";            break;        }    }    return "" + text;}
public JTabbedPane pdfbox_f314_0()
{    return tabbedPane;}
public String pdfbox_f315_0(TreePath path)
{    return generatePathString(path);}
public TreePath pdfbox_f316_0(String statusString)
{    return generatePath(statusString);}
private String pdfbox_f317_0(TreePath path)
{    StringBuilder pathStringBuilder = new StringBuilder();    while (path.getParentPath() != null) {        Object object = path.getLastPathComponent();        pathStringBuilder.insert(0, "/" + getObjectName(object));        path = path.getParentPath();    }    pathStringBuilder.delete(0, 1);    return pathStringBuilder.toString();}
private TreePath pdfbox_f318_0(String pathString)
{    List<String> nodes = parsePathString(pathString);    if (nodes == null) {        return null;    }    Object obj = rootNode;    TreePath treePath = new TreePath(obj);    for (String node : nodes) {        obj = searchNode(obj, node);        if (obj == null) {            return null;        }        treePath = treePath.pathByAddingChild(obj);    }    return treePath;}
private String pdfbox_f319_0(Object treeNode)
{    if (treeNode instanceof MapEntry) {        MapEntry entry = (MapEntry) treeNode;        COSName key = entry.getKey();        return key.getName();    } else if (treeNode instanceof ArrayEntry) {        ArrayEntry entry = (ArrayEntry) treeNode;        return "[" + entry.getIndex() + "]";    } else if (treeNode instanceof PageEntry) {        PageEntry entry = (PageEntry) treeNode;        return entry.getPath();    }    throw new IllegalArgumentException("Unknown treeNode type: " + treeNode.getClass().getName());}
private List<String> pdfbox_f320_0(String path)
{    List<String> nodes = new ArrayList<>();    for (String node : path.split("/")) {        node = node.trim();        if (node.startsWith("[")) {            node = node.replace("]", "").replace("[", "");        }        node = node.trim();        if (node.isEmpty()) {            return null;        }        nodes.add(node);    }    return nodes;}
private Object pdfbox_f321_0(Object obj, String searchStr)
{    if (obj instanceof MapEntry) {        obj = ((MapEntry) obj).getValue();    } else if (obj instanceof ArrayEntry) {        obj = ((ArrayEntry) obj).getValue();    }    if (obj instanceof COSObject) {        obj = ((COSObject) obj).getObject();    }    if (obj instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) obj;        if (dic.containsKey(searchStr)) {            MapEntry entry = new MapEntry();            entry.setKey(COSName.getPDFName(searchStr));            entry.setValue(dic.getDictionaryObject(searchStr));            entry.setValue(dic.getItem(searchStr));            return entry;        }    } else if (obj instanceof COSArray) {        int index = Integer.parseInt(searchStr);        COSArray array = (COSArray) obj;        if (index <= array.size() - 1) {            ArrayEntry entry = new ArrayEntry();            entry.setIndex(index);            entry.setValue(array.getObject(index));            entry.setItem(array.get(index));            return entry;        }    }    return null;}
public void pdfbox_f322_0(ActionEvent actionEvent)
{    TreePath path = statusObj.getPathForString(statusField.getText());    if (path != null) {        tree.setSelectionPath(path);        tree.scrollPathToVisible(path);        tree.requestFocusInWindow();    } else {        statusField.setBorder(errorBorder);    }}
private void pdfbox_f323_0()
{    panel = new JPanel(new BorderLayout());    statusField = new JTextField();    statusField.setEditable(false);    panel.add(statusField);    defaultBorder = new BevelBorder(BevelBorder.LOWERED);    errorBorder = new BevelBorder(BevelBorder.LOWERED, Color.RED, Color.RED);    statusField.setAction(textInputAction);    tree.addTreeSelectionListener(this);}
public JPanel pdfbox_f324_0()
{    return panel;}
public void pdfbox_f325_0(TreeStatus statusObj)
{    statusField.setEditable(true);    this.statusObj = statusObj;    updateText(null);}
private void pdfbox_f326_0(String statusString)
{    statusField.setText(statusString);    if (!statusField.getBorder().equals(defaultBorder)) {        statusField.setBorder(defaultBorder);    }}
public void pdfbox_f327_0(TreeSelectionEvent treeSelectionEvent)
{    TreePath path = treeSelectionEvent.getPath();    updateText(statusObj.getStringForPath(path));}
public COSBase pdfbox_f328_0()
{    return value;}
public COSBase pdfbox_f329_0()
{    return item;}
public void pdfbox_f330_0(COSBase val)
{    this.value = val;}
public void pdfbox_f331_0(COSBase val)
{    this.item = val;}
public int pdfbox_f332_0()
{    return index;}
public void pdfbox_f333_0(int i)
{    index = i;}
public void pdfbox_f334_0(Object o)
{    if (DEBUG) {        LogDialog.instance().log(name, "debug", o, null);    }}
public void pdfbox_f335_0(Object o, Throwable throwable)
{    if (DEBUG) {        LogDialog.instance().log(name, "debug", o, throwable);    }}
public void pdfbox_f336_0(Object o)
{    LogDialog.instance().log(name, "error", o, null);}
public void pdfbox_f337_0(Object o, Throwable throwable)
{    LogDialog.instance().log(name, "error", o, throwable);}
public void pdfbox_f338_0(Object o)
{    LogDialog.instance().log(name, "fatal", o, null);}
public void pdfbox_f339_0(Object o, Throwable throwable)
{    LogDialog.instance().log(name, "fatal", o, throwable);}
public void pdfbox_f340_0(Object o)
{    if (INFO) {        LogDialog.instance().log(name, "info", o, null);    }}
public void pdfbox_f341_0(Object o, Throwable throwable)
{    if (INFO) {        LogDialog.instance().log(name, "info", o, throwable);    }}
public boolean pdfbox_f342_0()
{    return DEBUG;}
public boolean pdfbox_f343_0()
{    return true;}
public boolean pdfbox_f344_0()
{    return true;}
public boolean pdfbox_f345_0()
{    return INFO;}
public boolean pdfbox_f346_0()
{    return TRACE;}
public boolean pdfbox_f347_0()
{    return true;}
public void pdfbox_f348_0(Object o)
{    if (TRACE) {        LogDialog.instance().log(name, "trace", o, null);    }}
public void pdfbox_f349_0(Object o, Throwable throwable)
{    if (TRACE) {        LogDialog.instance().log(name, "trace", o, throwable);    }}
public void pdfbox_f350_0(Object o)
{    LogDialog.instance().log(name, "warn", o, null);}
public void pdfbox_f351_0(Object o, Throwable throwable)
{    LogDialog.instance().log(name, "warn", o, throwable);}
public int pdfbox_f352_0()
{    return doc.getPages().getCount();}
public PageEntry pdfbox_f353_0(int index)
{    PDPage page = doc.getPages().get(index);    String pageLabel = PDFDebugger.getPageLabel(doc, index);    return new PageEntry(page.getCOSObject(), index + 1, pageLabel);}
public int pdfbox_f354_0(PageEntry page)
{    return page.getPageNum() - 1;}
public String pdfbox_f355_0()
{    return filename;}
 static void pdfbox_f356_0(Component c, Component parent)
{    Dimension d = c.getPreferredSize();    if (parent == null) {        Dimension s = Toolkit.getDefaultToolkit().getScreenSize();        c.setLocation(s.width / 2 - d.width / 2, s.height / 2 - d.height / 2);    } else {        Point p = parent.getLocationOnScreen();        int pw = parent.getWidth();        int ph = parent.getHeight();        c.setLocation(p.x + pw / 2 - d.width / 2, p.y + ph / 2 - d.height / 2);    }}
 final JComponent pdfbox_f357_0()
{    final JButton showDetails = new JButton("Show Details >>");    showDetails.addActionListener(e -> {        if (showingDetails) {            main.remove(details);            main.validate();            main.setPreferredSize(MESSAGE_SIZE);        } else {            if (details == null) {                details = createDetailedMessage();                StringBuilder buffer = new StringBuilder();                stacktrace.setText(generateStackTrace(error, buffer).toString());                stacktrace.setCaretPosition(0);                stacktrace.setBackground(main.getBackground());                stacktrace.setPreferredSize(STACKTRACE_SIZE);            }            main.add(details, BorderLayout.CENTER);            main.validate();            main.setPreferredSize(TOTAL_SIZE);        }        showingDetails = !showingDetails;        showDetails.setText(showingDetails ? "<< Hide Details" : "Show Details >>");        ErrorDialog.this.pack();    });    JPanel messagePanel = new JPanel();    final JCheckBox filter = new JCheckBox("Filter stack traces");    filter.setSelected(isFiltering);    filter.addActionListener(e -> {        isFiltering = filter.isSelected();        StringBuilder buffer = new StringBuilder();        stacktrace.setText(generateStackTrace(error, buffer).toString());        stacktrace.setCaretPosition(0);        stacktrace.repaint();    });    message.setBackground(messagePanel.getBackground());    JPanel buttonPanel = new JPanel();    buttonPanel.add(Box.createHorizontalStrut(BORDER_SIZE));    buttonPanel.add(showDetails);    buttonPanel.add(filter);    buttonPanel.add(Box.createHorizontalGlue());    messagePanel.setLayout(new BorderLayout());    messagePanel.setBorder(BorderFactory.createEmptyBorder(BORDER_SIZE, BORDER_SIZE, BORDER_SIZE, BORDER_SIZE));    messagePanel.add(message, BorderLayout.CENTER);    messagePanel.add(buttonPanel, BorderLayout.SOUTH);    messagePanel.setPreferredSize(MESSAGE_SIZE);    JPanel panel = new JPanel();    panel.setLayout(new BorderLayout());    panel.add(messagePanel, BorderLayout.NORTH);        ActionListener actionListener = actionEvent -> dispose();    KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);    panel.registerKeyboardAction(actionListener, stroke, JComponent.WHEN_IN_FOCUSED_WINDOW);    return panel;}
 final JComponent pdfbox_f358_0(Throwable t)
{    String txt = t.getLocalizedMessage();    JEditorPane msg = new JEditorPane();    msg.setContentType("text/plain");    msg.setEditable(false);    msg.setText(txt);    return msg;}
 JScrollPane pdfbox_f359_0()
{    stacktrace = new JTextPane();    stacktrace.setEditable(false);    return new JScrollPane(stacktrace, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);}
 StringBuilder pdfbox_f360_0(Throwable t, StringBuilder buffer)
{    buffer.append(t.getClass().getName()).append(": ").append(t.getMessage()).append(NEWLINE);    buffer.append(toString(t.getStackTrace()));    Throwable cause = t.getCause();    if (cause != null && !cause.equals(t)) {        buffer.append("Caused by: ");        generateStackTrace(cause, buffer);    }    return buffer;}
 StringBuilder pdfbox_f361_0(StackTraceElement[] traces)
{    StringBuilder err = new StringBuilder();    for (StackTraceElement e : traces) {        if (!isFiltering || !isSuppressed(e.getClassName())) {            String str = e.toString();            err.append(INDENT).append(str).append(NEWLINE);        }    }    return err;}
private boolean pdfbox_f362_0(String className)
{    return FILTERS.stream().anyMatch(className::startsWith);}
public boolean pdfbox_f363_0(File pathname)
{    if (pathname.isDirectory()) {        return true;    }    boolean acceptable = false;    String name = pathname.getName().toUpperCase();    for (int i = 0; !acceptable && i < extensions.length; i++) {        if (name.endsWith(extensions[i].toUpperCase())) {            acceptable = true;        }    }    return acceptable;}
public String pdfbox_f364_0()
{    return desc;}
public void pdfbox_f365_0()
{    File selectedFile = getSelectedFile();    if (selectedFile.exists() && getDialogType() == JFileChooser.SAVE_DIALOG) {        int result = JOptionPane.showConfirmDialog(this, "Do you want to overwrite?", "File already exists", JOptionPane.YES_NO_OPTION);        if (result != JOptionPane.YES_OPTION) {            cancelSelection();            return;        }    }    super.approveSelection();}
public boolean pdfbox_f366_0(byte[] bytes, String extension) throws IOException
{    int result = fileChooser.showSaveDialog(mainUI);    if (result == JFileChooser.APPROVE_OPTION) {        String filename = fileChooser.getSelectedFile().getAbsolutePath();        if (extension != null && !filename.endsWith(extension)) {            filename += "." + extension;        }        try (FileOutputStream outputStream = new FileOutputStream(filename)) {            outputStream.write(bytes);        }        return true;    }    return false;}
public File pdfbox_f367_0() throws IOException
{    int result = fileChooser.showOpenDialog(mainUI);    if (result == JFileChooser.APPROVE_OPTION) {        return fileChooser.getSelectedFile();    }    return null;}
public void pdfbox_f368_0(Component c, Graphics g, int x, int y)
{    g.drawImage(image, x, y, getIconWidth(), getIconHeight(), null);}
public int pdfbox_f369_0()
{    return baseWidth;}
public int pdfbox_f370_0()
{    return baseHeight;}
public static BufferedImage pdfbox_f371_0(BufferedImage image, int rotation)
{    int width = image.getWidth();    int height = image.getHeight();    double x = 0;    double y = 0;    BufferedImage rotatedImage;    switch(rotation % 360) {        case 90:            x = height;            rotatedImage = new BufferedImage(height, width, BufferedImage.TYPE_INT_RGB);            break;        case 270:            y = width;            rotatedImage = new BufferedImage(height, width, BufferedImage.TYPE_INT_RGB);            break;        case 180:            x = width;            y = height;            rotatedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);            break;        default:            return image;    }    Graphics2D g = (Graphics2D) rotatedImage.getGraphics();    g.translate(x, y);    g.rotate(Math.toRadians(rotation));    g.drawImage(image, 0, 0, null);    g.dispose();    return rotatedImage;}
public static void pdfbox_f372_0(Frame owner, JLabel logLabel)
{    instance = new LogDialog(owner, logLabel);}
public static LogDialog pdfbox_f373_0()
{    return instance;}
public void pdfbox_f374_0(String name, String level, Object o, Throwable throwable)
{    StyledDocument doc = textPane.getStyledDocument();    String levelText;    SimpleAttributeSet levelStyle = new SimpleAttributeSet();    switch(level) {        case "fatal":            levelText = "Fatal";            StyleConstants.setForeground(levelStyle, Color.WHITE);            StyleConstants.setBackground(levelStyle, Color.BLACK);            fatalCount++;            break;        case "error":            levelText = "Error";            StyleConstants.setForeground(levelStyle, new Color(0xFF291F));            StyleConstants.setBackground(levelStyle, new Color(0xFFF0F0));            errorCount++;            break;        case "warn":            levelText = "Warning";            StyleConstants.setForeground(levelStyle, new Color(0x614201));            StyleConstants.setBackground(levelStyle, new Color(0xFFFCE5));            warnCount++;            break;        case "info":            levelText = "Info";            StyleConstants.setForeground(levelStyle, new Color(0x203261));            StyleConstants.setBackground(levelStyle, new Color(0xE2E8FF));            otherCount++;            break;        case "debug":            levelText = "Debug";            StyleConstants.setForeground(levelStyle, new Color(0x32612E));            StyleConstants.setBackground(levelStyle, new Color(0xF4FFEC));            otherCount++;            break;        case "trace":            levelText = "Trace";            StyleConstants.setForeground(levelStyle, new Color(0x64438D));            StyleConstants.setBackground(levelStyle, new Color(0xFEF3FF));            otherCount++;            break;        default:            throw new Error(level);    }    SimpleAttributeSet nameStyle = new SimpleAttributeSet();    StyleConstants.setForeground(nameStyle, new Color(0x6A6A6A));    String shortName = name.substring(name.lastIndexOf('.') + 1);    String message = o == null ? "(null)" : o.toString();    if (throwable != null) {        StringWriter sw = new StringWriter();        throwable.printStackTrace(new PrintWriter(sw));        message += "\n    " + sw.toString();        exceptionCount++;    }    try {        doc.insertString(doc.getLength(), " " + levelText + " ", levelStyle);        doc.insertString(doc.getLength(), " [" + shortName + "]", nameStyle);        doc.insertString(doc.getLength(), " " + message + "\n", null);    } catch (BadLocationException e) {        throw new Error(e);    }    textPane.setCaretPosition(doc.getLength());        updateStatusBar();}
private void pdfbox_f375_0()
{    List<String> infos = new ArrayList<>();    if (exceptionCount > 0) {        infos.add(exceptionCount + " exception" + (errorCount > 1 ? "s" : ""));    }    if (fatalCount > 0) {        infos.add(errorCount + " error" + (errorCount > 1 ? "s" : ""));    }    if (errorCount > 0) {        infos.add(errorCount + " error" + (errorCount > 1 ? "s" : ""));    }    if (warnCount > 0) {        infos.add(warnCount + " warning" + (warnCount > 1 ? "s" : ""));    }    if (otherCount > 0) {        infos.add(otherCount + " message" + (otherCount > 1 ? "s" : ""));    }    String info = "";    for (String str : infos) {        if (info.length() > 0) {            info += ", ";        }        info += str;    }    logLabel.setText(info);}
public void pdfbox_f376_0()
{    fatalCount = 0;    errorCount = 0;    warnCount = 0;    otherCount = 0;    exceptionCount = 0;    textPane.setText("");    logLabel.setText("");}
public final Container pdfbox_f377_0()
{    return super.getContentPane();}
public final void pdfbox_f378_0()
{    super.pack();}
public COSName pdfbox_f379_0()
{    return key;}
public void pdfbox_f380_0(COSName k)
{    key = k;}
public COSBase pdfbox_f381_0()
{    return value;}
public COSBase pdfbox_f382_0()
{    return item;}
public void pdfbox_f383_0(COSBase val)
{    this.value = val;}
public void pdfbox_f384_0(COSBase val)
{    this.item = val;}
public String pdfbox_f385_0()
{    if (key != null) {        return key.getName();    }    return "(null)";}
 final void pdfbox_f386_0(JMenu menu)
{    this.menu = menu;}
public JMenu pdfbox_f387_0()
{    return this.menu;}
public void pdfbox_f388_0(boolean isEnable)
{    menu.setEnabled(isEnable);}
public void pdfbox_f389_0(ActionListener listener)
{    for (Component comp : menu.getMenuComponents()) {        JMenuItem menuItem = (JMenuItem) comp;        removeActionListeners(menuItem);        menuItem.addActionListener(listener);    }}
private void pdfbox_f390_0(JMenuItem menuItem)
{    for (ActionListener listener : menuItem.getActionListeners()) {        menuItem.removeActionListener(listener);    }}
private static boolean pdfbox_f391_0()
{        String version = System.getProperty("java.specification.version");    final StringTokenizer st = new StringTokenizer(version, ".");    try {        int major = Integer.parseInt(st.nextToken());        int minor = 0;        if (st.hasMoreTokens()) {            minor = Integer.parseInt(st.nextToken());        }        return major > 1 || (major == 1 && minor >= 9);    } catch (NumberFormatException nfe) {                return true;    }}
public static void pdfbox_f392_0(final Object target, final Method quitHandler)
{    if (isMinJdk9()) {        try {            Desktop desktopObject = Desktop.getDesktop();            Class<?> filesHandlerClass = Class.forName("java.awt.desktop.QuitHandler");            final Method setQuitHandlerMethod = desktopObject.getClass().getMethod("setQuitHandler", filesHandlerClass);            Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[] { filesHandlerClass }, new InvocationHandler() {                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                    if ("handleQuitRequestWith".equals(method.getName())) {                                                quitHandler.invoke(target);                    }                    return null;                }            });            setQuitHandlerMethod.invoke(desktopObject, osxAdapterProxy);        } catch (Exception e) {            e.printStackTrace();        }        return;    }    setHandler(new OSXAdapter("handleQuit", target, quitHandler));}
public Object pdfbox_f393_0(Object proxy, Method method, Object[] args) throws Throwable
{    if ("handleQuitRequestWith".equals(method.getName())) {                quitHandler.invoke(target);    }    return null;}
public static void pdfbox_f394_0(Object target, Method aboutHandler)
{    boolean enableAboutMenu = (target != null && aboutHandler != null);    if (enableAboutMenu) {        setHandler(new OSXAdapter("handleAbout", target, aboutHandler));    }        try {        Method enableAboutMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledAboutMenu", boolean.class);        enableAboutMethod.invoke(macOSXApplication, Boolean.valueOf(enableAboutMenu));    } catch (Exception ex) {        System.err.println("OSXAdapter could not access the About Menu");        throw new RuntimeException(ex);    }}
public static void pdfbox_f395_0(Object target, Method prefsHandler)
{    boolean enablePrefsMenu = (target != null && prefsHandler != null);    if (enablePrefsMenu) {        setHandler(new OSXAdapter("handlePreferences", target, prefsHandler));    }        try {        Method enablePrefsMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledPreferencesMenu", boolean.class);        enablePrefsMethod.invoke(macOSXApplication, enablePrefsMenu);    } catch (Exception ex) {        System.err.println("OSXAdapter could not access the About Menu");        throw new RuntimeException(ex);    }}
public static void pdfbox_f396_0(Object target, Method fileHandler)
{    if (isMinJdk9()) {        try {            Desktop desktopObject = Desktop.getDesktop();            Class<?> filesHandlerClass = Class.forName("java.awt.desktop.OpenFilesHandler");            Method setOpenFileHandlerMethod = desktopObject.getClass().getMethod("setOpenFileHandler", filesHandlerClass);            Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[] { filesHandlerClass }, new OSXAdapter("openFiles", target, fileHandler) {                                                @Override                public boolean callTarget(Object openFilesEvent) {                    if (openFilesEvent != null) {                        try {                            Method getFilesMethod = openFilesEvent.getClass().getDeclaredMethod("getFiles", (Class[]) null);                            @SuppressWarnings("unchecked")                            List<File> files = (List<File>) getFilesMethod.invoke(openFilesEvent, (Object[]) null);                            this.targetMethod.invoke(this.targetObject, files.get(0).getAbsolutePath());                        } catch (Exception ex) {                            throw new RuntimeException(ex);                        }                    }                    return true;                }            });            setOpenFileHandlerMethod.invoke(desktopObject, osxAdapterProxy);        } catch (Exception e) {            e.printStackTrace();        }        return;    }    /* JDK <= 1.8, using Apple classes */    setHandler(new OSXAdapter("handleOpenFile", target, fileHandler) {                        @Override        public boolean callTarget(Object appleEvent) {            if (appleEvent != null) {                try {                    Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);                    String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);                    this.targetMethod.invoke(this.targetObject, filename);                } catch (Exception ex) {                    throw new RuntimeException(ex);                }            }            return true;        }    });}
public boolean pdfbox_f397_0(Object openFilesEvent)
{    if (openFilesEvent != null) {        try {            Method getFilesMethod = openFilesEvent.getClass().getDeclaredMethod("getFiles", (Class[]) null);            @SuppressWarnings("unchecked")            List<File> files = (List<File>) getFilesMethod.invoke(openFilesEvent, (Object[]) null);            this.targetMethod.invoke(this.targetObject, files.get(0).getAbsolutePath());        } catch (Exception ex) {            throw new RuntimeException(ex);        }    }    return true;}
public boolean pdfbox_f398_0(Object appleEvent)
{    if (appleEvent != null) {        try {            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);            this.targetMethod.invoke(this.targetObject, filename);        } catch (Exception ex) {            throw new RuntimeException(ex);        }    }    return true;}
public static void pdfbox_f399_0(OSXAdapter adapter)
{    try {        Class<?> applicationClass = Class.forName("com.apple.eawt.Application");        if (macOSXApplication == null) {            macOSXApplication = applicationClass.getDeclaredConstructor((Class[]) null).newInstance((Object[]) null);        }        Class<?> applicationListenerClass = Class.forName("com.apple.eawt.ApplicationListener");        Method addListenerMethod = applicationClass.getDeclaredMethod("addApplicationListener", applicationListenerClass);                Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[] { applicationListenerClass }, adapter);        addListenerMethod.invoke(macOSXApplication, osxAdapterProxy);    } catch (ClassNotFoundException cnfe) {        System.err.println("This version of Mac OS X does not support the Apple EAWT.  ApplicationEvent handling has been disabled (" + cnfe + ")");    } catch (Exception ex) {                System.err.println("Mac OS X Adapter could not talk to EAWT:");        throw new RuntimeException(ex);    }}
public boolean pdfbox_f400_0(Object appleEvent) throws InvocationTargetException, IllegalAccessException
{    Object result = targetMethod.invoke(targetObject, (Object[]) null);    if (result == null) {        return true;    }    return Boolean.valueOf(result.toString());}
public Object pdfbox_f401_0(Object proxy, Method method, Object[] args) throws Throwable
{    if (isCorrectMethod(method, args)) {        boolean handled = callTarget(args[0]);        setApplicationEventHandled(args[0], handled);    }        return null;}
protected boolean pdfbox_f402_0(Method method, Object[] args)
{    return (targetMethod != null && proxySignature.equals(method.getName()) && args.length == 1);}
protected void pdfbox_f403_0(Object event, boolean handled)
{    if (event != null) {        try {            Method setHandledMethod = event.getClass().getDeclaredMethod("setHandled", boolean.class);                        setHandledMethod.invoke(event, Boolean.valueOf(handled));        } catch (Exception ex) {            System.err.println("OSXAdapter was unable to handle an ApplicationEvent: " + event);            throw new RuntimeException(ex);        }    }}
public COSDictionary pdfbox_f404_0()
{    return dict;}
public int pdfbox_f405_0()
{    return pageNum;}
public String pdfbox_f406_0()
{    return "Page: " + pageNum + (pageLabel == null ? "" : " - " + pageLabel);}
public String pdfbox_f407_0()
{    StringBuilder sb = new StringBuilder();    sb.append("Root/Pages");    COSDictionary node = dict;    while (node.containsKey(COSName.PARENT)) {        COSBase base = node.getDictionaryObject(COSName.PARENT);        if (!(base instanceof COSDictionary)) {            return "";        }        COSDictionary parent = (COSDictionary) base;        base = parent.getDictionaryObject(COSName.KIDS);        if (!(base instanceof COSArray)) {            return "";        }        COSArray kids = (COSArray) base;        int idx = kids.indexOfObject(node);        sb.append("/Kids/[").append(idx).append("]");        node = parent;    }    return sb.toString();}
private static URL pdfbox_f408_0(String name)
{    String fullName = "/org/apache/pdfbox/debugger/" + name + ".png";    return PDFTreeCellRenderer.class.getResource(fullName);}
public Component pdfbox_f409_0(JTree tree, Object nodeValue, boolean isSelected, boolean expanded, boolean leaf, int row, boolean componentHasFocus)
{    Component component = super.getTreeCellRendererComponent(tree, toTreeObject(nodeValue), isSelected, expanded, leaf, row, componentHasFocus);    setIcon(lookupIconWithOverlay(nodeValue));    return component;}
private Object pdfbox_f410_0(Object nodeValue)
{    Object result = nodeValue;    if (nodeValue instanceof MapEntry || nodeValue instanceof ArrayEntry) {        String key;        Object object;        Object value;        COSBase item;        if (nodeValue instanceof MapEntry) {            MapEntry entry = (MapEntry) nodeValue;            key = entry.getKey().getName();            object = toTreeObject(entry.getValue());            value = entry.getValue();            item = entry.getItem();        } else {            ArrayEntry entry = (ArrayEntry) nodeValue;            key = Integer.toString(entry.getIndex());            object = toTreeObject(entry.getValue());            value = entry.getValue();            item = entry.getItem();        }        String stringResult = key;        if (object instanceof String && ((String) object).length() > 0) {            stringResult += ":  " + object;            if (item instanceof COSObject) {                COSObject indirect = (COSObject) item;                stringResult += " [" + indirect.getObjectNumber() + " " + indirect.getGenerationNumber() + " R]";            }            stringResult += toTreePostfix(value);        }        result = stringResult;    } else if (nodeValue instanceof COSBoolean) {        result = Boolean.toString(((COSBoolean) nodeValue).getValue());    } else if (nodeValue instanceof COSFloat) {        result = Float.toString(((COSFloat) nodeValue).floatValue());    } else if (nodeValue instanceof COSInteger) {        result = Integer.toString(((COSInteger) nodeValue).intValue());    } else if (nodeValue instanceof COSString) {        String text = ((COSString) nodeValue).getString();                for (char c : text.toCharArray()) {            if (Character.isISOControl(c)) {                text = "<" + ((COSString) nodeValue).toHexString() + ">";                break;            }        }        result = text;    } else if (nodeValue instanceof COSName) {        result = ((COSName) nodeValue).getName();    } else if (nodeValue instanceof COSNull || nodeValue == null) {        result = "";    } else if (nodeValue instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) nodeValue;        if (COSName.XREF.equals(dict.getCOSName(COSName.TYPE))) {            result = "";        } else {            result = "(" + dict.size() + ")";        }    } else if (nodeValue instanceof COSArray) {        COSArray array = (COSArray) nodeValue;        result = "(" + array.size() + ")";    } else if (nodeValue instanceof DocumentEntry) {        result = nodeValue.toString();    }    return result;}
private String pdfbox_f411_0(Object nodeValue)
{    if (nodeValue instanceof COSDictionary) {        StringBuilder sb = new StringBuilder();        COSDictionary dict = (COSDictionary) nodeValue;        if (COSName.ANNOT.equals(dict.getCOSName(COSName.TYPE)) && COSName.WIDGET.equals(dict.getCOSName(COSName.SUBTYPE)) || dict.containsKey(COSName.T) && dict.containsKey(COSName.KIDS)) {            String name = dict.getString(COSName.T);            if (name != null) {                sb.append("   Name: ");                sb.append(name);                sb.append(' ');            }        }        if (dict.containsKey(COSName.TYPE)) {            COSName type = dict.getCOSName(COSName.TYPE);            if (type != null) {                sb.append("   /T:").append(type.getName());            }        }        if (dict.containsKey(COSName.SUBTYPE)) {            COSName subtype = dict.getCOSName(COSName.SUBTYPE);            if (subtype != null) {                sb.append("  /S:").append(subtype.getName());            }        }        return sb.toString();    } else {        return "";    }}
private ImageIcon pdfbox_f412_0(Object nodeValue)
{    ImageIcon icon = lookupIcon(nodeValue);    boolean isIndirect = false;    boolean isStream = false;    if (nodeValue instanceof MapEntry) {        MapEntry entry = (MapEntry) nodeValue;        if (entry.getItem() instanceof COSObject) {            isIndirect = true;            isStream = entry.getValue() instanceof COSStream;        }    } else if (nodeValue instanceof ArrayEntry) {        ArrayEntry entry = (ArrayEntry) nodeValue;        if (entry.getItem() instanceof COSObject) {            isIndirect = true;            isStream = entry.getValue() instanceof COSStream;        }    }    if (isIndirect && !isStream) {        OverlayIcon overlay = new OverlayIcon(icon);        overlay.add(ICON_INDIRECT);        return overlay;    }    return icon;}
private ImageIcon pdfbox_f413_0(Object nodeValue)
{    if (nodeValue instanceof MapEntry) {        MapEntry entry = (MapEntry) nodeValue;        return lookupIcon(entry.getValue());    } else if (nodeValue instanceof ArrayEntry) {        ArrayEntry entry = (ArrayEntry) nodeValue;        return lookupIcon(entry.getValue());    } else if (nodeValue instanceof COSBoolean) {        return ICON_BOOLEAN;    } else if (nodeValue instanceof COSFloat) {        return ICON_REAL;    } else if (nodeValue instanceof COSInteger) {        return ICON_INTEGER;    } else if (nodeValue instanceof COSString) {        String text = ((COSString) nodeValue).getString();                for (char c : text.toCharArray()) {            if (Character.isISOControl(c)) {                return ICON_HEX;            }        }        return ICON_STRING;    } else if (nodeValue instanceof COSName) {        return ICON_NAME;    } else if (nodeValue instanceof COSNull || nodeValue == null) {        return ICON_NULL;    } else if (nodeValue instanceof COSStream) {        return ICON_STREAM_DICT;    } else if (nodeValue instanceof COSDictionary) {        return ICON_DICT;    } else if (nodeValue instanceof COSArray) {        return ICON_ARRAY;    } else if (nodeValue instanceof DocumentEntry) {        return ICON_PDF;    } else if (nodeValue instanceof PageEntry) {        return ICON_PAGE;    } else {        return null;    }}
 void pdfbox_f414_0(ImageIcon overlay)
{    overlays.add(overlay);}
public synchronized void pdfbox_f415_0(Component c, Graphics g, int x, int y)
{    base.paintIcon(c, g, x, y);    overlays.forEach(icon -> icon.paintIcon(c, g, x, y));}
public void pdfbox_f416_0(TreeModelListener l)
{}
public Object pdfbox_f417_0(Object parent, int index)
{    Object retval = null;    if (parent instanceof COSArray) {        ArrayEntry entry = new ArrayEntry();        entry.setIndex(index);        entry.setValue(((COSArray) parent).getObject(index));        entry.setItem(((COSArray) parent).get(index));        retval = entry;    } else if (parent instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) parent;        List<COSName> keys = new ArrayList<>(dict.keySet());        Collections.sort(keys);        COSName key = keys.get(index);        COSBase value = dict.getDictionaryObject(key);        MapEntry entry = new MapEntry();        entry.setKey(key);        entry.setValue(value);        entry.setItem(dict.getItem(key));        retval = entry;    } else if (parent instanceof MapEntry) {        retval = getChild(((MapEntry) parent).getValue(), index);    } else if (parent instanceof ArrayEntry) {        retval = getChild(((ArrayEntry) parent).getValue(), index);    } else if (parent instanceof COSDocument) {        retval = ((COSDocument) parent).getObjects().get(index);    } else if (parent instanceof DocumentEntry) {        retval = ((DocumentEntry) parent).getPage(index);    } else if (parent instanceof PageEntry) {        retval = getChild(((PageEntry) parent).getDict(), index);    } else if (parent instanceof COSObject) {        retval = ((COSObject) parent).getObject();    } else {        throw new IllegalArgumentException("Unknown COS type " + parent.getClass().getName());    }    return retval;}
public int pdfbox_f418_0(Object parent)
{    int retval = 0;    if (parent instanceof COSArray) {        retval = ((COSArray) parent).size();    } else if (parent instanceof COSDictionary) {        retval = ((COSDictionary) parent).size();    } else if (parent instanceof MapEntry) {        retval = getChildCount(((MapEntry) parent).getValue());    } else if (parent instanceof ArrayEntry) {        retval = getChildCount(((ArrayEntry) parent).getValue());    } else if (parent instanceof COSDocument) {        retval = ((COSDocument) parent).getObjects().size();    } else if (parent instanceof DocumentEntry) {        retval = ((DocumentEntry) parent).getPageCount();    } else if (parent instanceof PageEntry) {        retval = getChildCount(((PageEntry) parent).getDict());    } else if (parent instanceof COSObject) {        retval = 1;    }    return retval;}
public int pdfbox_f419_0(Object parent, Object child)
{    int retval = -1;    if (parent != null && child != null) {        if (parent instanceof COSArray) {            COSArray array = (COSArray) parent;            if (child instanceof ArrayEntry) {                ArrayEntry arrayEntry = (ArrayEntry) child;                retval = arrayEntry.getIndex();            } else {                retval = array.indexOf((COSBase) child);            }        } else if (parent instanceof COSDictionary) {            MapEntry entry = (MapEntry) child;            COSDictionary dict = (COSDictionary) parent;            List<COSName> keys = new ArrayList<>(dict.keySet());            Collections.sort(keys);            for (int i = 0; retval == -1 && i < keys.size(); i++) {                if (keys.get(i).equals(entry.getKey())) {                    retval = i;                }            }        } else if (parent instanceof MapEntry) {            retval = getIndexOfChild(((MapEntry) parent).getValue(), child);        } else if (parent instanceof ArrayEntry) {            retval = getIndexOfChild(((ArrayEntry) parent).getValue(), child);        } else if (parent instanceof COSDocument) {            retval = ((COSDocument) parent).getObjects().indexOf(child);        } else if (parent instanceof DocumentEntry) {            retval = ((DocumentEntry) parent).indexOf((PageEntry) child);        } else if (parent instanceof PageEntry) {            retval = getIndexOfChild(((PageEntry) parent).getDict(), child);        } else if (parent instanceof COSObject) {            retval = 0;        } else {            throw new IllegalArgumentException("Unknown COS type " + parent.getClass().getName());        }    }    return retval;}
public Object pdfbox_f420_0()
{    return root;}
public boolean pdfbox_f421_0(Object node)
{    boolean isLeaf = !(node instanceof COSDictionary || node instanceof COSArray || node instanceof COSDocument || node instanceof DocumentEntry || node instanceof PageEntry || node instanceof COSObject || (node instanceof MapEntry && !isLeaf(((MapEntry) node).getValue())) || (node instanceof ArrayEntry && !isLeaf(((ArrayEntry) node).getValue())));    return isLeaf;}
public void pdfbox_f422_0(TreeModelListener l)
{}
public void pdfbox_f423_0(TreePath path, Object newValue)
{}
public void pdfbox_f424_0(MouseEvent e)
{    Window viewer = LogDialog.instance().getOwner();        LogDialog.instance().setSize(800, 400);    LogDialog.instance().setVisible(true);    LogDialog.instance().setLocation(viewer.getLocationOnScreen().x + viewer.getWidth() / 2, viewer.getLocationOnScreen().y + viewer.getHeight() / 2);}
public JLabel pdfbox_f425_0()
{    return statusLabel;}
public JLabel pdfbox_f426_0()
{    return logLabel;}
public void pdfbox_f427_0()
{    filePaths.clear();}
public boolean pdfbox_f428_0()
{    return filePaths.isEmpty();}
public void pdfbox_f429_0(String path)
{    if (filePaths.size() >= maximum + 1 && path != null) {        filePaths.remove();    }    filePaths.add(path);}
public void pdfbox_f430_0(String path)
{    if (filePaths.contains(path)) {        filePaths.remove(path);    }}
public List<String> pdfbox_f431_0()
{    if (!isEmpty()) {        List<String> files = filePaths.stream().filter(path -> new File(path).exists()).collect(Collectors.toList());        if (files.size() > maximum) {            files.remove(0);        }        return files;    }    return null;}
public void pdfbox_f432_0() throws IOException
{    writeHistoryToPref(filePaths);}
private String[] pdfbox_f433_0(String fullPath)
{    int allowedStringLength = Preferences.MAX_VALUE_LENGTH;    List<String> pieces = new ArrayList<>();    int beginIndex = 0;    int remainingLength = fullPath.length();    int endIndex = 0;    while (remainingLength > 0) {        endIndex += remainingLength >= allowedStringLength ? allowedStringLength : remainingLength;        pieces.add(fullPath.substring(beginIndex, endIndex));        beginIndex = endIndex;        remainingLength = fullPath.length() - endIndex;    }    return pieces.toArray(new String[pieces.size()]);}
private void pdfbox_f434_0(Queue<String> filePaths)
{    if (filePaths.isEmpty()) {        return;    }    Preferences node = pref.node(KEY);    node.putInt(HISTORY_LENGTH, filePaths.size());    int fileCount = 1;    for (String path : filePaths) {        String[] pieces = breakString(path);        node.putInt(String.format(PIECES_LENGTH_KEY, fileCount), pieces.length);        for (int i = 0; i < pieces.length; i++) {            node.put(String.format(PATH_KEY, fileCount, i), pieces[i]);        }        fileCount++;    }}
private Queue<String> pdfbox_f435_0()
{    Preferences node = pref.node(KEY);    int historyLength = node.getInt(HISTORY_LENGTH, 0);    if (historyLength == 0) {        return null;    }    Queue<String> history = new ArrayDeque<>();    for (int i = 1; i <= historyLength; i++) {        int totalPieces = node.getInt(String.format(PIECES_LENGTH_KEY, i), 0);        StringBuilder stringBuilder = new StringBuilder();        for (int j = 0; j < totalPieces; j++) {            String piece = node.get(String.format(PATH_KEY, i, j), "");            stringBuilder.append(piece);        }        history.add(stringBuilder.toString());    }    return history;}
public static RotationMenu pdfbox_f436_0()
{    if (instance == null) {        instance = new RotationMenu();    }    return instance;}
public void pdfbox_f437_0(String selection)
{    if (ROTATE_0_DEGREES.equals(selection)) {        rotate0Item.setSelected(true);    } else if (ROTATE_90_DEGREES.equals(selection)) {        rotate90Item.setSelected(true);    } else if (ROTATE_180_DEGREES.equals(selection)) {        rotate180Item.setSelected(true);    } else if (ROTATE_270_DEGREES.equals(selection)) {        rotate270Item.setSelected(true);    } else {        throw new IllegalArgumentException();    }}
public static boolean pdfbox_f438_0(String actionCommand)
{    return ROTATE_0_DEGREES.equals(actionCommand) || ROTATE_90_DEGREES.equals(actionCommand) || ROTATE_180_DEGREES.equals(actionCommand) || ROTATE_270_DEGREES.equals(actionCommand);}
public static int pdfbox_f439_0()
{    if (instance.rotate90Item.isSelected()) {        return 90;    }    if (instance.rotate180Item.isSelected()) {        return 180;    }    if (instance.rotate270Item.isSelected()) {        return 270;    }    return 0;}
public static int pdfbox_f440_0(String actionCommand)
{    if (ROTATE_0_DEGREES.equals(actionCommand)) {        return 0;    } else if (ROTATE_90_DEGREES.equals(actionCommand)) {        return 90;    } else if (ROTATE_180_DEGREES.equals(actionCommand)) {        return 180;    } else if (ROTATE_270_DEGREES.equals(actionCommand)) {        return 270;    } else {        throw new IllegalArgumentException();    }}
private JMenu pdfbox_f441_0()
{    JMenu menu = new JMenu();    menu.setText("Rotation");    rotate0Item = new JRadioButtonMenuItem();    rotate90Item = new JRadioButtonMenuItem();    rotate180Item = new JRadioButtonMenuItem();    rotate270Item = new JRadioButtonMenuItem();    rotate0Item.setSelected(true);    ButtonGroup bg = new ButtonGroup();    bg.add(rotate0Item);    bg.add(rotate90Item);    bg.add(rotate180Item);    bg.add(rotate270Item);    rotate0Item.setText(ROTATE_0_DEGREES);    rotate90Item.setText(ROTATE_90_DEGREES);    rotate180Item.setText(ROTATE_180_DEGREES);    rotate270Item.setText(ROTATE_270_DEGREES);    menu.add(rotate0Item);    menu.add(rotate90Item);    menu.add(rotate180Item);    menu.add(rotate270Item);    return menu;}
public static void pdfbox_f442_0(Frame owner)
{    instance = new TextDialog(owner);}
public static TextDialog pdfbox_f443_0()
{    return instance;}
public void pdfbox_f444_0()
{    textPane.setText("");}
public void pdfbox_f445_0(String text)
{    textPane.setText(text);}
public final Container pdfbox_f446_0()
{    return super.getContentPane();}
public final void pdfbox_f447_0()
{    super.pack();}
public List<Highlighter.Highlight> pdfbox_f448_1(String searchKey, boolean isCaseSensitive)
{    List<Highlighter.Highlight> highlights = new ArrayList<>();    if (searchKey != null) {        highlighter.removeAllHighlights();        if ("".equals(searchKey)) {            return highlights;        }        String textContent;        try {            textContent = document.getText(0, document.getLength());        } catch (BadLocationException e) {                        return highlights;        }        if (!isCaseSensitive) {            textContent = textContent.toLowerCase();            searchKey = searchKey.toLowerCase();        }        int searchKeyLength = searchKey.length();        int startAt = 0;        int resultantOffset;        int indexOfHighLight = 0;        while ((resultantOffset = textContent.indexOf(searchKey, startAt)) != -1) {            try {                highlighter.addHighlight(resultantOffset, resultantOffset + searchKeyLength, painter);                highlights.add(highlighter.getHighlights()[indexOfHighLight++]);                startAt = resultantOffset + searchKeyLength;            } catch (BadLocationException e) {                            }        }    }    return highlights;}
public void pdfbox_f449_0(ActionEvent actionEvent)
{    if (totalMatch != 0 && currentMatch != 0) {        currentMatch = currentMatch - 1;        int offset = highlights.get(currentMatch).getStartOffset();        scrollToWord(offset);        updateHighLighter(currentMatch, currentMatch + 1);        updateNavigationButtons();    }}
public void pdfbox_f450_0(ActionEvent actionEvent)
{    if (totalMatch != 0 && currentMatch != totalMatch - 1) {        currentMatch = currentMatch + 1;        int offset = highlights.get(currentMatch).getStartOffset();        scrollToWord(offset);        updateHighLighter(currentMatch, currentMatch - 1);        updateNavigationButtons();    }}
public JPanel pdfbox_f451_0()
{    return searchPanel.getPanel();}
public void pdfbox_f452_0(DocumentEvent documentEvent)
{    search(documentEvent);}
public void pdfbox_f453_0(DocumentEvent documentEvent)
{    search(documentEvent);}
public void pdfbox_f454_0(DocumentEvent documentEvent)
{    search(documentEvent);}
private void pdfbox_f455_1(DocumentEvent documentEvent)
{    try {        String word = documentEvent.getDocument().getText(0, documentEvent.getDocument().getLength());        if (word.isEmpty()) {            nextAction.setEnabled(false);            previousAction.setEnabled(false);            searchPanel.reset();            textComponent.getHighlighter().removeAllHighlights();            return;        }        search(word);    } catch (BadLocationException e) {            }}
private void pdfbox_f456_0(String word)
{    highlights = searchEngine.search(word, searchPanel.isCaseSensitive());    if (!highlights.isEmpty()) {        totalMatch = highlights.size();        currentMatch = 0;        scrollToWord(highlights.get(0).getStartOffset());        updateHighLighter(currentMatch, currentMatch - 1);        updateNavigationButtons();    } else {        searchPanel.updateCounterLabel(0, 0);    }}
private void pdfbox_f457_0()
{    if (currentMatch == 0) {        previousAction.setEnabled(false);    } else if (currentMatch >= 1 && currentMatch <= (totalMatch - 1)) {        previousAction.setEnabled(true);    }    if (currentMatch == (totalMatch - 1)) {        nextAction.setEnabled(false);    } else if (currentMatch < (totalMatch - 1)) {        nextAction.setEnabled(true);    }    searchPanel.updateCounterLabel(currentMatch + 1, totalMatch);}
private void pdfbox_f458_1(int offset)
{    try {        textComponent.scrollRectToVisible(textComponent.modelToView(offset));    } catch (BadLocationException e) {            }}
private void pdfbox_f459_0(final int presentIndex, final int previousIndex)
{    if (previousIndex != -1) {        changeHighlighter(previousIndex, PAINTER);    }    changeHighlighter(presentIndex, SELECTION_PAINTER);}
private void pdfbox_f460_1(int index, Highlighter.HighlightPainter newPainter)
{    Highlighter highlighter = textComponent.getHighlighter();    Highlighter.Highlight highLight = highlights.get(index);    highlighter.removeHighlight(highLight);    try {        highlighter.addHighlight(highLight.getStartOffset(), highLight.getEndOffset(), newPainter);        highlights.set(index, highlighter.getHighlights()[highlighter.getHighlights().length - 1]);    } catch (BadLocationException e) {            }}
public void pdfbox_f461_0(ChangeEvent changeEvent)
{    if (changeEvent.getSource() instanceof JCheckBox) {        search(searchPanel.getSearchWord());    }}
public void pdfbox_f462_0(ComponentEvent componentEvent)
{}
public void pdfbox_f463_0(ComponentEvent componentEvent)
{}
public void pdfbox_f464_0(ComponentEvent componentEvent)
{    searchPanel.reFocus();}
public void pdfbox_f465_0(ComponentEvent componentEvent)
{    textComponent.getHighlighter().removeAllHighlights();}
public void pdfbox_f466_0(PDFDebugger frame)
{    searchPanel.addMenuListeners(frame);}
public void pdfbox_f467_0(PDFDebugger frame)
{    searchPanel.removeMenuListeners(frame);}
public void pdfbox_f468_0(ActionEvent actionEvent)
{    panel.setVisible(false);    closeAction.setEnabled(false);    panel.getParent().transferFocus();}
public void pdfbox_f469_0(ActionEvent actionEvent)
{    if (!panel.isVisible()) {        panel.setVisible(true);        panel.getParent().validate();        return;    }    reFocus();}
private void pdfbox_f470_0(DocumentListener documentListener, ChangeListener changeListener, ComponentListener compListener)
{    searchField = new JTextField();    searchField.getDocument().addDocumentListener(documentListener);    counterLabel = new JLabel();    counterLabel.setVisible(false);    JButton nextButton = new JButton();    nextButton.setAction(nextAction);    nextButton.setText("Next");    JButton previousButton = new JButton();    previousButton.setAction(previousAction);    previousButton.setText("Previous");    caseSensitive = new JCheckBox("Match case");    caseSensitive.setSelected(false);    caseSensitive.addChangeListener(changeListener);    caseSensitive.setToolTipText("Check for case sensitive search");    JButton crossButton = new JButton();    crossButton.setAction(closeAction);    crossButton.setText("Done");    closeAction.setEnabled(false);    panel = new JPanel();    panel.setBorder(BorderFactory.createMatteBorder(1, 0, 0, 0, Color.LIGHT_GRAY));    panel.setBackground(new Color(230, 230, 230));    panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));    panel.add(Box.createHorizontalGlue());    panel.add(searchField);    panel.add(counterLabel);    panel.add(previousButton);    panel.add(nextButton);    panel.add(caseSensitive);    panel.add(Box.createRigidArea(new Dimension(5, 0)));    panel.add(crossButton);    panel.addComponentListener(compListener);    searchField.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), closeAction);}
 boolean pdfbox_f471_0()
{    return caseSensitive.isSelected();}
 String pdfbox_f472_0()
{    return searchField.getText();}
 void pdfbox_f473_0()
{    counterLabel.setVisible(false);}
 void pdfbox_f474_0(int now, int total)
{    if (!counterLabel.isVisible()) {        counterLabel.setVisible(true);    }    if (total == 0) {        counterLabel.setText(" No match found ");        nextAction.setEnabled(false);        return;    }    counterLabel.setText(" " + now + " of " + total + " ");}
 JPanel pdfbox_f475_0()
{    return panel;}
public void pdfbox_f476_0()
{    searchField.requestFocus();    String searchKey = searchField.getText();    searchField.setText(searchKey);    searchField.setSelectionStart(0);    searchField.setSelectionEnd(searchField.getText().length());    closeAction.setEnabled(true);}
public void pdfbox_f477_0(PDFDebugger frame)
{    frame.getFindMenu().setEnabled(true);    frame.getFindMenuItem().addActionListener(findAction);    frame.getFindNextMenuItem().addActionListener(nextAction);    frame.getFindPreviousMenuItem().addActionListener(previousAction);}
public void pdfbox_f478_0(PDFDebugger frame)
{    frame.getFindMenu().setEnabled(false);    frame.getFindMenuItem().removeActionListener(findAction);    frame.getFindNextMenuItem().removeActionListener(nextAction);    frame.getFindPreviousMenuItem().removeActionListener(previousAction);}
public Point pdfbox_f479_0(MouseEvent event)
{    if (event != null) {        TreePath path = getClosestPathForLocation(event.getX(), event.getY());        if (path == null) {            return null;        }        setSelectionPath(path);        treePopupMenu.removeAll();        addPopupMenuItems(path);        return event.getPoint();    }    return null;}
private void pdfbox_f480_0(TreePath nodePath)
{    Object obj = nodePath.getLastPathComponent();    treePopupMenu.add(getTreePathMenuItem(nodePath));    if (obj instanceof MapEntry) {        obj = ((MapEntry) obj).getValue();    } else if (obj instanceof ArrayEntry) {        obj = ((ArrayEntry) obj).getValue();    }    if (!(obj instanceof COSStream)) {        return;    }    treePopupMenu.addSeparator();    COSStream stream = (COSStream) obj;    treePopupMenu.add(getStreamSaveMenu(stream, nodePath));    if (stream.getFilters() != null) {        if (stream.getFilters() instanceof COSArray && ((COSArray) stream.getFilters()).size() >= 2) {            getPartiallyDecodedStreamSaveMenu(stream).forEach(treePopupMenu::add);        }        treePopupMenu.add(getRawStreamSaveMenu(stream));    }    JMenuItem open = getFileOpenMenu(stream, nodePath);    if (open != null) {        treePopupMenu.addSeparator();        treePopupMenu.add(open);    }}
private JMenuItem pdfbox_f481_0(final TreePath path)
{    JMenuItem copyPathMenuItem = new JMenuItem("Copy Tree Path");    copyPathMenuItem.addActionListener(actionEvent -> {        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();        clipboard.setContents(new StringSelection(new TreeStatus(rootNode).getStringForPath(path)), null);    });    return copyPathMenuItem;}
private JMenuItem pdfbox_f482_0(final COSStream cosStream)
{    JMenuItem saveMenuItem = new JMenuItem("Save Raw Stream (" + getFilters(cosStream) + ") As...");    saveMenuItem.addActionListener(actionEvent -> {        try {            byte[] bytes = IOUtils.toByteArray(cosStream.createRawInputStream());            saveStream(bytes, null, null);        } catch (IOException e) {            e.printStackTrace();        }    });    return saveMenuItem;}
private String pdfbox_f483_0(COSStream cosStream)
{    StringBuilder sb = new StringBuilder();    COSBase filters = cosStream.getFilters();    if (filters instanceof COSName) {        sb.append(((COSName) filters).getName());    } else if (filters instanceof COSArray) {        COSArray filterArray = (COSArray) filters;        for (int i = 0; i < filterArray.size(); i++) {            if (i > 0) {                sb.append(", ");            }            sb.append(((COSName) filterArray.get(i)).getName());        }    }    return sb.toString();}
private JMenuItem pdfbox_f484_0(final COSStream cosStream, final TreePath nodePath)
{        final String extension = getFileExtensionForStream(cosStream, nodePath);    final FileFilter fileFilter;    final String format;    if (extension != null) {        switch(extension) {            case "pdb":                fileFilter = new FileNameExtensionFilter("Type 1 Font (*.pfb)", "pfb");                break;            case "ttf":                fileFilter = new FileNameExtensionFilter("TrueType Font (*.ttf)", "ttf");                break;            case "cff":                fileFilter = new FileNameExtensionFilter("Compact Font Format (*.cff)", "cff");                break;            case "otf":                fileFilter = new FileNameExtensionFilter("OpenType Font (*.otf)", "otf");                break;            default:                fileFilter = null;                break;        }        format = " " + extension.toUpperCase();    } else {        fileFilter = null;        format = "";    }    JMenuItem saveMenuItem = new JMenuItem("Save Stream As" + format + "...");    saveMenuItem.addActionListener(actionEvent -> {        try {            byte[] bytes = IOUtils.toByteArray(cosStream.createInputStream());            saveStream(bytes, fileFilter, extension);        } catch (IOException e) {            e.printStackTrace();        }    });    return saveMenuItem;}
private String pdfbox_f485_0(final COSStream cosStream, final TreePath nodePath)
{    String name = nodePath.getLastPathComponent().toString();    switch(name) {        case "FontFile":            return "pfb";        case "FontFile2":            return "ttf";        case "FontFile3":            return cosStream.getCOSName(COSName.SUBTYPE) == COSName.OPEN_TYPE ? "otf" : "cff";        default:            return null;    }}
private JMenuItem pdfbox_f486_0(final COSStream cosStream, final TreePath nodePath)
{        final String extension = getFileExtensionForStream(cosStream, nodePath);    if (extension == null) {        return null;    }    JMenuItem openMenuItem = new JMenuItem("Open with Default Application");    openMenuItem.addActionListener(actionEvent -> {        try {            File temp = File.createTempFile("pdfbox", "." + extension);            temp.deleteOnExit();            try (InputStream is = cosStream.createInputStream();                FileOutputStream os = new FileOutputStream(temp)) {                IOUtils.copy(is, os);            }            Desktop.getDesktop().open(temp);        } catch (IOException e) {            e.printStackTrace();        }    });    return openMenuItem;}
private List<JMenuItem> pdfbox_f487_0(final COSStream cosStream)
{    List<JMenuItem> menuItems = new ArrayList<>();    PDStream stream = new PDStream(cosStream);    List<COSName> filters = stream.getFilters();    for (int i = filters.size() - 1; i >= 1; i--) {        menuItems.add(getPartialStreamSavingMenuItem(i, stream));    }    return menuItems;}
private JMenuItem pdfbox_f488_0(final int indexOfStopFilter, final PDStream stream)
{    List<COSName> filters = stream.getFilters();    final List<String> stopFilters = new ArrayList<>(1);    stopFilters.add(filters.get(indexOfStopFilter).getName());    StringBuilder nameListBuilder = new StringBuilder();    for (int i = indexOfStopFilter; i < filters.size(); i++) {        nameListBuilder.append(filters.get(i).getName()).append(" & ");    }    nameListBuilder.delete(nameListBuilder.lastIndexOf("&"), nameListBuilder.length());    JMenuItem menuItem = new JMenuItem("Keep " + nameListBuilder.toString() + "...");    menuItem.addActionListener(actionEvent -> {        try {            InputStream data = stream.createInputStream(stopFilters);            saveStream(IOUtils.toByteArray(data), null, null);        } catch (IOException e) {            e.printStackTrace();        }    });    return menuItem;}
private void pdfbox_f489_0(byte[] bytes, FileFilter filter, String extension) throws IOException
{    FileOpenSaveDialog saveDialog = new FileOpenSaveDialog(getParent(), filter);    saveDialog.saveFile(bytes, extension);}
public static ViewMenu pdfbox_f490_0(PDFDebugger pdfDebugger)
{    if (instance == null) {        instance = new ViewMenu(pdfDebugger);    }    return instance;}
public static boolean pdfbox_f491_0(String actionCommand)
{    return SHOW_TEXT_STRIPPER.equals(actionCommand) || SHOW_TEXT_STRIPPER_BEADS.equals(actionCommand) || SHOW_FONT_BBOX.equals(actionCommand) || SHOW_GLYPH_BOUNDS.equals(actionCommand) || ALLOW_SUBSAMPLING.equals(actionCommand);}
public static boolean pdfbox_f492_0()
{    return instance.showTextStripper.isSelected();}
public static boolean pdfbox_f493_0()
{    return instance.showTextStripperBeads.isSelected();}
public static boolean pdfbox_f494_0()
{    return instance.showFontBBox.isSelected();}
public static boolean pdfbox_f495_0()
{    return instance.showGlyphBounds.isSelected();}
public static boolean pdfbox_f496_0(ActionEvent actionEvent)
{    return EXTRACT_TEXT.equals(actionEvent.getActionCommand());}
public static boolean pdfbox_f497_0()
{    return instance.allowSubsampling.isSelected();}
private JMenu pdfbox_f498_0()
{    JMenu viewMenu = new JMenu("View");    viewMenu.setMnemonic('V');    if (pdfDebugger.isPageMode()) {        viewModeItem = new JMenuItem("Show Internal Structure");    } else {        viewModeItem = new JMenuItem("Show Pages");    }    viewModeItem.addActionListener(actionEvent -> {        if (pdfDebugger.isPageMode()) {            viewModeItem.setText("Show Pages");            pdfDebugger.setPageMode(false);        } else {            viewModeItem.setText("Show Internal Structure");            pdfDebugger.setPageMode(true);        }        if (pdfDebugger.hasDocument()) {            pdfDebugger.initTree();        }    });    viewMenu.add(viewModeItem);    ZoomMenu zoomMenu = ZoomMenu.getInstance();    zoomMenu.setEnableMenu(false);    viewMenu.add(zoomMenu.getMenu());    RotationMenu rotationMenu = RotationMenu.getInstance();    rotationMenu.setEnableMenu(false);    viewMenu.add(rotationMenu.getMenu());    viewMenu.addSeparator();    showTextStripper = new JCheckBoxMenuItem(SHOW_TEXT_STRIPPER);    showTextStripper.setEnabled(false);    viewMenu.add(showTextStripper);    showTextStripperBeads = new JCheckBoxMenuItem(SHOW_TEXT_STRIPPER_BEADS);    showTextStripperBeads.setEnabled(false);    viewMenu.add(showTextStripperBeads);    showFontBBox = new JCheckBoxMenuItem(SHOW_FONT_BBOX);    showFontBBox.setEnabled(false);    viewMenu.add(showFontBBox);    showGlyphBounds = new JCheckBoxMenuItem(SHOW_GLYPH_BOUNDS);    showGlyphBounds.setEnabled(false);    viewMenu.add(showGlyphBounds);    viewMenu.addSeparator();    allowSubsampling = new JCheckBoxMenuItem(ALLOW_SUBSAMPLING);    allowSubsampling.setEnabled(false);    viewMenu.add(allowSubsampling);    viewMenu.addSeparator();    extractTextMenuItem = new JMenuItem(EXTRACT_TEXT);    extractTextMenuItem.setEnabled(false);    viewMenu.add(extractTextMenuItem);    return viewMenu;}
public void pdfbox_f499_0(Rectangle rect)
{    Preferences node = pref.node(KEY);    node.putInt("X", rect.x);    node.putInt("Y", rect.y);    node.putInt("W", rect.width);    node.putInt("H", rect.height);}
public Rectangle pdfbox_f500_0()
{    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();    Preferences node = pref.node(KEY);    int x = node.getInt("X", screenSize.width / 4);    int y = node.getInt("Y", screenSize.height / 4);    int w = node.getInt("W", screenSize.width / 2);    int h = node.getInt("H", screenSize.height / 2);    return new Rectangle(x, y, w, h);}
public void pdfbox_f501_0(int divider)
{    Preferences node = pref.node(KEY);    node.putInt("DIV", divider);}
public int pdfbox_f502_0()
{    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();    Preferences node = pref.node(KEY);    return node.getInt("DIV", screenSize.width / 8);}
public void pdfbox_f503_0(int extendedState)
{    Preferences node = pref.node(KEY);    node.putInt("EXTSTATE", extendedState);}
public int pdfbox_f504_0()
{    Preferences node = pref.node(KEY);    return node.getInt("EXTSTATE", Frame.NORMAL);}
public static ZoomMenu pdfbox_f505_0()
{    if (instance == null) {        instance = new ZoomMenu();    }    return instance;}
public void pdfbox_f506_0(float zoomValue)
{    String selection = (int) (zoomValue * 100) + "%";    for (Component comp : menu.getMenuComponents()) {        JRadioButtonMenuItem menuItem = (JRadioButtonMenuItem) comp;        if (menuItem.getText().equals(selection)) {            menuItem.setSelected(true);            return;        }    }    throw new IllegalArgumentException("no zoom menu item found for: " + selection);}
public static boolean pdfbox_f507_0(String actionCommand)
{    if (!actionCommand.matches("^\\d+%$")) {        return false;    }    int zoom = Integer.parseInt(actionCommand.substring(0, actionCommand.length() - 1));    return Arrays.binarySearch(ZOOMS, zoom) >= 0;}
public static float pdfbox_f508_0()
{    for (Component comp : instance.menu.getMenuComponents()) {        ZoomMenuItem menuItem = (ZoomMenuItem) comp;        if (menuItem.isSelected()) {            return menuItem.zoom / 100f;        }    }    throw new IllegalStateException("no zoom menu item is selected");}
public float pdfbox_f509_0()
{    return pageZoomScale;}
public void pdfbox_f510_0(float pageZoomValue)
{    pageZoomScale = pageZoomValue;}
public float pdfbox_f511_0()
{    return imageZoomScale;}
public void pdfbox_f512_0(float imageZoomValue)
{    imageZoomScale = imageZoomValue;}
public void pdfbox_f513_0()
{    setPageZoomScale(1);    setImageZoomScale(1);    changeZoomSelection(1);}
public void pdfbox_f514_0(FileSet set)
{    fileSets.add(set);}
public void pdfbox_f515_0()
{    log("PDFToTextTask executing");    for (FileSet fileSet : fileSets) {        DirectoryScanner dirScanner = fileSet.getDirectoryScanner(getProject());        dirScanner.scan();        String[] files = dirScanner.getIncludedFiles();        for (String file : files) {            File f = new File(dirScanner.getBasedir(), file);            log("processing: " + f.getAbsolutePath());            String pdfFile = f.getAbsolutePath();            if (pdfFile.toUpperCase().endsWith(".PDF")) {                String textFile = pdfFile.substring(0, pdfFile.length() - 3);                textFile = textFile + "txt";                try {                    ExtractText.main(new String[] { pdfFile, textFile });                } catch (Exception e) {                    log("Error processing " + pdfFile + e.getMessage());                }            }        }    }}
public static void pdfbox_f516_0(String[] args) throws IOException
{        try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();                        PDField field = acroForm.getField("SampleField");        PDAnnotationWidget widget = field.getWidgets().get(0);                PDAppearanceCharacteristicsDictionary fieldAppearance = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        PDColor green = new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE);        fieldAppearance.setBorderColour(green);                        widget.setAppearanceCharacteristics(fieldAppearance);        document.save("target/AddBorderToField.pdf");    }}
public static void pdfbox_f517_0(String[] args) throws IOException
{    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                                float x = 50;        float y = page.getMediaBox().getHeight() - 50;        PDRectangle rect = new PDRectangle(x, y, 20, 20);        PDCheckBox checkbox = new PDCheckBox(acroForm);        checkbox.setPartialName("MyCheckBox");        PDAnnotationWidget widget = checkbox.getWidgets().get(0);        widget.setPage(page);        widget.setRectangle(rect);        widget.setPrinted(true);        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        appearanceCharacteristics.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));        appearanceCharacteristics.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));                appearanceCharacteristics.setNormalCaption("4");        widget.setAppearanceCharacteristics(appearanceCharacteristics);        PDBorderStyleDictionary borderStyleDictionary = new PDBorderStyleDictionary();        borderStyleDictionary.setWidth(1);        borderStyleDictionary.setStyle(PDBorderStyleDictionary.STYLE_SOLID);        widget.setBorderStyle(borderStyleDictionary);        PDAppearanceDictionary ap = new PDAppearanceDictionary();        widget.setAppearance(ap);        PDAppearanceEntry normalAppearance = ap.getNormalAppearance();        COSDictionary normalAppearanceDict = normalAppearance.getCOSObject();        normalAppearanceDict.setItem(COSName.Off, createAppearanceStream(document, widget, false));        normalAppearanceDict.setItem(COSName.YES, createAppearanceStream(document, widget, true));                        page.getAnnotations().add(checkbox.getWidgets().get(0));        acroForm.getFields().add(checkbox);        checkbox.check();        document.save("CheckBoxSample.pdf");    }}
private static PDAppearanceStream pdfbox_f518_0(final PDDocument document, PDAnnotationWidget widget, boolean on) throws IOException
{    PDRectangle rect = widget.getRectangle();    PDAppearanceCharacteristicsDictionary appearanceCharacteristics;    PDAppearanceStream yesAP = new PDAppearanceStream(document);    yesAP.setBBox(new PDRectangle(rect.getWidth(), rect.getHeight()));    yesAP.setResources(new PDResources());    try (PDAppearanceContentStream yesAPCS = new PDAppearanceContentStream(yesAP)) {        appearanceCharacteristics = widget.getAppearanceCharacteristics();        PDColor backgroundColor = appearanceCharacteristics.getBackground();        PDColor borderColor = appearanceCharacteristics.getBorderColour();        float lineWidth = getLineWidth(widget);        yesAPCS.setBorderLine(lineWidth, widget.getBorderStyle(), widget.getBorder());        yesAPCS.setNonStrokingColor(backgroundColor);        yesAPCS.addRect(0, 0, rect.getWidth(), rect.getHeight());        yesAPCS.fill();        yesAPCS.setStrokingColor(borderColor);        yesAPCS.addRect(lineWidth / 2, lineWidth / 2, rect.getWidth() - lineWidth, rect.getHeight() - lineWidth);        yesAPCS.stroke();        if (!on) {            return yesAP;        }        yesAPCS.addRect(lineWidth, lineWidth, rect.getWidth() - lineWidth * 2, rect.getHeight() - lineWidth * 2);        yesAPCS.clip();        String normalCaption = appearanceCharacteristics.getNormalCaption();        if (normalCaption == null) {                        normalCaption = "4";        }        if ("8".equals(normalCaption)) {                        yesAPCS.setStrokingColor(0f);            yesAPCS.moveTo(lineWidth * 2, rect.getHeight() - lineWidth * 2);            yesAPCS.lineTo(rect.getWidth() - lineWidth * 2, lineWidth * 2);            yesAPCS.moveTo(rect.getWidth() - lineWidth * 2, rect.getHeight() - lineWidth * 2);            yesAPCS.lineTo(lineWidth * 2, lineWidth * 2);            yesAPCS.stroke();        } else {                                                String name = PDType1Font.ZAPF_DINGBATS.codeToName(normalCaption.codePointAt(0));            String unicode = PDType1Font.ZAPF_DINGBATS.getGlyphList().toUnicode(name);            Rectangle2D bounds = PDType1Font.ZAPF_DINGBATS.getPath(name).getBounds2D();            float size = (float) Math.min(bounds.getWidth(), bounds.getHeight()) / 1000;                                    float fontSize = (rect.getWidth() - lineWidth * 2) / size * 0.6666f;            float xOffset = (float) (rect.getWidth() - (bounds.getWidth()) / 1000 * fontSize) / 2;            xOffset -= bounds.getX() / 1000 * fontSize;            float yOffset = (float) (rect.getHeight() - (bounds.getHeight()) / 1000 * fontSize) / 2;            yOffset -= bounds.getY() / 1000 * fontSize;            yesAPCS.setNonStrokingColor(0);            yesAPCS.beginText();            yesAPCS.setFont(PDType1Font.ZAPF_DINGBATS, fontSize);            yesAPCS.newLineAtOffset(xOffset, yOffset);            yesAPCS.showText(unicode);            yesAPCS.endText();        }    }    return yesAP;}
 static float pdfbox_f519_0(PDAnnotationWidget widget)
{    PDBorderStyleDictionary bs = widget.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    return 1;}
public static void pdfbox_f520_0(String[] args) throws IOException
{        try (PDDocument document = new PDDocument()) {        PDPage page1 = new PDPage(PDRectangle.A4);        document.addPage(page1);        PDPage page2 = new PDPage(PDRectangle.A4);        document.addPage(page2);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                acroForm.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        acroForm.setDefaultAppearance(defaultAppearanceString);                PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");                                                defaultAppearanceString = "/Helv 12 Tf 0 0 1 rg";        textBox.setDefaultAppearance(defaultAppearanceString);                acroForm.getFields().add(textBox);                PDAnnotationWidget widget1 = new PDAnnotationWidget();        PDRectangle rect = new PDRectangle(50, 750, 250, 50);        widget1.setRectangle(rect);        widget1.setPage(page1);        widget1.setParent(textBox);                PDAnnotationWidget widget2 = new PDAnnotationWidget();        PDRectangle rect2 = new PDRectangle(200, 650, 100, 50);        widget2.setRectangle(rect2);        widget2.setPage(page2);        widget2.setParent(textBox);                        PDAppearanceCharacteristicsDictionary fieldAppearance1 = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        fieldAppearance1.setBorderColour(new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE));        fieldAppearance1.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));        widget1.setAppearanceCharacteristics(fieldAppearance1);                        PDAppearanceCharacteristicsDictionary fieldAppearance2 = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        fieldAppearance2.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));        fieldAppearance2.setBackground(new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE));        widget2.setAppearanceCharacteristics(fieldAppearance2);        List<PDAnnotationWidget> widgets = new ArrayList<>();        widgets.add(widget1);        widgets.add(widget2);        textBox.setWidgets(widgets);                widget1.setPrinted(true);        widget2.setPrinted(true);                page1.getAnnotations().add(widget1);        page2.getAnnotations().add(widget2);                textBox.setValue("Sample field");        document.save("MultiWidgetsForm.pdf");    }}
public static void pdfbox_f521_0(String[] args) throws IOException
{    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        PDAcroForm acroForm = new PDAcroForm(document);                                document.getDocumentCatalog().setAcroForm(acroForm);        List<String> options = Arrays.asList("a", "b", "c");        PDRadioButton radioButton = new PDRadioButton(acroForm);        radioButton.setPartialName("MyRadioButton");        radioButton.setExportValues(options);        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        appearanceCharacteristics.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));        appearanceCharacteristics.setBackground(new PDColor(new float[] { 0, 1, 0.3f }, PDDeviceRGB.INSTANCE));                        List<PDAnnotationWidget> widgets = new ArrayList<>();        for (int i = 0; i < options.size(); i++) {            PDAnnotationWidget widget = new PDAnnotationWidget();            widget.setRectangle(new PDRectangle(30, PDRectangle.A4.getHeight() - 40 - i * 35, 30, 30));            widget.setAppearanceCharacteristics(appearanceCharacteristics);            PDBorderStyleDictionary borderStyleDictionary = new PDBorderStyleDictionary();            borderStyleDictionary.setWidth(2);            borderStyleDictionary.setStyle(PDBorderStyleDictionary.STYLE_SOLID);            widget.setBorderStyle(borderStyleDictionary);            widget.setPage(page);            COSDictionary apNDict = new COSDictionary();            apNDict.setItem(COSName.Off, createAppearanceStream(document, widget, false));            apNDict.setItem(options.get(i), createAppearanceStream(document, widget, true));            PDAppearanceDictionary appearance = new PDAppearanceDictionary();            PDAppearanceEntry appearanceNEntry = new PDAppearanceEntry(apNDict);            appearance.setNormalAppearance(appearanceNEntry);            widget.setAppearance(appearance);                        widget.setAppearanceState("Off");            widgets.add(widget);            page.getAnnotations().add(widget);        }        radioButton.setWidgets(widgets);        acroForm.getFields().add(radioButton);                try (PDPageContentStream contents = new PDPageContentStream(document, page)) {            for (int i = 0; i < options.size(); i++) {                contents.beginText();                contents.setFont(PDType1Font.HELVETICA, 15);                contents.newLineAtOffset(70, PDRectangle.A4.getHeight() - 30 - i * 35);                contents.showText(options.get(i));                contents.endText();            }        }        radioButton.setValue("c");        document.save("RadioButtonsSample.pdf");    }}
private static PDAppearanceStream pdfbox_f522_0(final PDDocument document, PDAnnotationWidget widget, boolean on) throws IOException
{    PDRectangle rect = widget.getRectangle();    PDAppearanceStream onAP = new PDAppearanceStream(document);    onAP.setBBox(new PDRectangle(rect.getWidth(), rect.getHeight()));    try (PDAppearanceContentStream onAPCS = new PDAppearanceContentStream(onAP)) {        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();        PDColor backgroundColor = appearanceCharacteristics.getBackground();        PDColor borderColor = appearanceCharacteristics.getBorderColour();        float lineWidth = getLineWidth(widget);        onAPCS.setBorderLine(lineWidth, widget.getBorderStyle(), widget.getBorder());        onAPCS.setNonStrokingColor(backgroundColor);        float radius = Math.min(rect.getWidth() / 2, rect.getHeight() / 2);        drawCircle(onAPCS, rect.getWidth() / 2, rect.getHeight() / 2, radius);        onAPCS.fill();        onAPCS.setStrokingColor(borderColor);        drawCircle(onAPCS, rect.getWidth() / 2, rect.getHeight() / 2, radius - lineWidth / 2);        onAPCS.stroke();        if (on) {            onAPCS.setNonStrokingColor(0f);            drawCircle(onAPCS, rect.getWidth() / 2, rect.getHeight() / 2, (radius - lineWidth) / 2);            onAPCS.fill();        }    }    return onAP;}
 static float pdfbox_f523_0(PDAnnotationWidget widget)
{    PDBorderStyleDictionary bs = widget.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    return 1;}
 static void pdfbox_f524_0(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{        float magic = r * 0.551784f;    cs.moveTo(x, y + r);    cs.curveTo(x + magic, y + r, x + r, y + magic, x + r, y);    cs.curveTo(x + r, y - magic, x + magic, y - r, x, y - r);    cs.curveTo(x - magic, y - r, x - r, y - magic, x - r, y);    cs.curveTo(x - r, y + magic, x - magic, y + r, x, y + r);    cs.closePath();}
public static void pdfbox_f525_0(String[] args) throws IOException
{        try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                acroForm.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        acroForm.setDefaultAppearance(defaultAppearanceString);                PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");                                                defaultAppearanceString = "/Helv 12 Tf 0 0 1 rg";        textBox.setDefaultAppearance(defaultAppearanceString);                acroForm.getFields().add(textBox);                PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);                        PDAppearanceCharacteristicsDictionary fieldAppearance = new PDAppearanceCharacteristicsDictionary(new COSDictionary());        fieldAppearance.setBorderColour(new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE));        fieldAppearance.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));        widget.setAppearanceCharacteristics(fieldAppearance);                widget.setPrinted(true);                page.getAnnotations().add(widget);                textBox.setValue("Sample field");        document.save("target/SimpleForm.pdf");    }}
public static void pdfbox_f526_0(String[] args) throws IOException
{        try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(doc);        doc.getDocumentCatalog().setAcroForm(acroForm);                        PDFont formFont = PDType0Font.load(doc, CreateSimpleFormWithEmbeddedFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"), false);                final PDResources resources = new PDResources();        acroForm.setDefaultResources(resources);        final String fontName = resources.add(formFont).getName();                        acroForm.setDefaultResources(resources);        String defaultAppearanceString = "/" + fontName + " 0 Tf 0 g";        PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");        textBox.setDefaultAppearance(defaultAppearanceString);        acroForm.getFields().add(textBox);                PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 700, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);                        textBox.setValue("Sample field ");        doc.save("target/SimpleFormWithEmbeddedFont.pdf");    }}
public static void pdfbox_f527_0(String[] args) throws IOException
{    try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();                        PDField field = acroForm.getField("SampleField");        PDAnnotationWidget widget = field.getWidgets().get(0);                float widthOfField = widget.getRectangle().getWidth();                                                        String defaultAppearance = ((PDTextField) field).getDefaultAppearance();        String[] parts = defaultAppearance.split(" ");                COSName fontName = COSName.getPDFName(parts[0].substring(1));        float fontSize = Float.parseFloat(parts[1]);                                                PDFont font = null;        PDResources resources = widget.getNormalAppearanceStream().getResources();        if (resources != null) {            font = resources.getFont(fontName);        }        if (font == null) {            font = acroForm.getDefaultResources().getFont(fontName);        }        String willFit = "short string";        String willNotFit = "this is a very long string which will not fit the width of the widget";                float willFitWidth = font.getStringWidth(willFit) * fontSize / 1000;        float willNotFitWidth = font.getStringWidth(willNotFit) * fontSize / 1000;        assert willFitWidth < widthOfField;        assert willNotFitWidth > widthOfField;    }}
public static void pdfbox_f528_0(String[] args) throws IOException
{        try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();                        PDField field = acroForm.getField("SampleField");        PDAnnotationWidget widget = field.getWidgets().get(0);                                PDAnnotationAdditionalActions annotationActions = new PDAnnotationAdditionalActions();                PDActionJavaScript jsEnterAction = new PDActionJavaScript();        jsEnterAction.setAction("app.alert(\"On 'enter' action\")");        annotationActions.setE(jsEnterAction);                PDActionJavaScript jsExitAction = new PDActionJavaScript();        jsExitAction.setAction("app.alert(\"On 'exit' action\")");        annotationActions.setX(jsExitAction);                PDActionJavaScript jsMouseDownAction = new PDActionJavaScript();        jsMouseDownAction.setAction("app.alert(\"On 'mouse down' action\")");        annotationActions.setD(jsMouseDownAction);                PDActionJavaScript jsMouseUpAction = new PDActionJavaScript();        jsMouseUpAction.setAction("app.alert(\"On 'mouse up' action\")");        annotationActions.setU(jsMouseUpAction);                PDActionJavaScript jsFocusAction = new PDActionJavaScript();        jsFocusAction.setAction("app.alert(\"On 'focus' action\")");        annotationActions.setFo(jsFocusAction);                PDActionJavaScript jsBlurredAction = new PDActionJavaScript();        jsBlurredAction.setAction("app.alert(\"On 'blurred' action\")");        annotationActions.setBl(jsBlurredAction);        widget.setActions(annotationActions);                PDFormFieldAdditionalActions fieldActions = new PDFormFieldAdditionalActions();                PDActionJavaScript jsKeystrokeAction = new PDActionJavaScript();        jsKeystrokeAction.setAction("app.alert(\"On 'keystroke' action\")");        fieldActions.setK(jsKeystrokeAction);                PDActionJavaScript jsFormattedAction = new PDActionJavaScript();        jsFormattedAction.setAction("app.alert(\"On 'formatted' action\")");        fieldActions.setF(jsFormattedAction);                PDActionJavaScript jsChangedAction = new PDActionJavaScript();        jsChangedAction.setAction("app.alert(\"On 'change' action\")");                        PDActionJavaScript jsRecalculateAction = new PDActionJavaScript();        jsRecalculateAction.setAction("app.alert(\"On 'recalculate' action\")");        fieldActions.setC(jsRecalculateAction);                                                        field.getActions().getCOSObject().addAll(fieldActions.getCOSObject());        document.save("target/FieldTriggers.pdf");    }}
public static void pdfbox_f529_0(String[] args) throws IOException
{    String formTemplate = "src/main/resources/org/apache/pdfbox/examples/interactive/form/FillFormField.pdf";    try (PDDocument pdfDocument = PDDocument.load(new File(formTemplate))) {                PDAcroForm acroForm = pdfDocument.getDocumentCatalog().getAcroForm();                if (acroForm != null) {                        PDTextField field = (PDTextField) acroForm.getField("sampleField");            field.setValue("Text Entry");                                    field = (PDTextField) acroForm.getField("fieldsContainer.nestedSampleField");            field.setValue("Text Entry");        }                pdfDocument.save("target/FillFormField.pdf");    }}
public void pdfbox_f530_0(PDDocument pdfDocument) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    List<PDField> fields = acroForm.getFields();    System.out.println(fields.size() + " top-level fields were found on the form");    for (PDField field : fields) {        processField(field, "|--", field.getPartialName());    }}
private void pdfbox_f531_0(PDField field, String sLevel, String sParent) throws IOException
{    String partialName = field.getPartialName();    if (field instanceof PDNonTerminalField) {        if (!sParent.equals(field.getPartialName())) {            if (partialName != null) {                sParent = sParent + "." + partialName;            }        }        System.out.println(sLevel + sParent);        for (PDField child : ((PDNonTerminalField) field).getChildren()) {            processField(child, "|  " + sLevel, sParent);        }    } else {        String fieldValue = field.getValueAsString();        StringBuilder outputString = new StringBuilder(sLevel);        outputString.append(sParent);        if (partialName != null) {            outputString.append(".").append(partialName);        }        outputString.append(" = ").append(fieldValue);        outputString.append(",  type=").append(field.getClass().getName());        System.out.println(outputString);    }}
public static void pdfbox_f532_0(String[] args) throws IOException
{    PDDocument pdf = null;    try {        if (args.length != 1) {            usage();        } else {            pdf = PDDocument.load(new File(args[0]));            PrintFields exporter = new PrintFields();            exporter.printFields(pdf);        }    } finally {        if (pdf != null) {            pdf.close();        }    }}
private static void pdfbox_f533_0()
{    System.err.println("usage: org.apache.pdfbox.examples.interactive.form.PrintFields <pdf-file>");}
public void pdfbox_f534_0(PDDocument pdfDocument, String name, String value) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    PDField field = acroForm.getField(name);    if (field != null) {        if (field instanceof PDCheckBox) {            field.setValue("Yes");        } else if (field instanceof PDComboBox) {            field.setValue(value);        } else if (field instanceof PDListBox) {            field.setValue(value);        } else if (field instanceof PDRadioButton) {            field.setValue(value);        } else if (field instanceof PDTextField) {            field.setValue(value);        }    } else {        System.err.println("No field found with name:" + name);    }}
public static void pdfbox_f535_0(String[] args) throws IOException
{    SetField setter = new SetField();    setter.setField(args);}
private void pdfbox_f536_0(String[] args) throws IOException
{    PDDocument pdf = null;    try {        if (args.length != 3) {            usage();        } else {            SetField example = new SetField();            pdf = PDDocument.load(new File(args[0]));            example.setField(pdf, args[1], args[2]);            pdf.save(args[0]);        }    } finally {        if (pdf != null) {            pdf.close();        }    }}
private static void pdfbox_f537_0()
{    System.err.println("usage: org.apache.pdfbox.examples.interactive.form.SetField <pdf-file> <field-name> <field-value>");}
public static void pdfbox_f538_0(String[] args) throws IOException
{        try (PDDocument document = PDDocument.load(new File("target/SimpleForm.pdf"))) {                                String javaScript = "var now = util.printd('yyyy-mm-dd', new Date());" + "var oField = this.getField('SampleField');" + "oField.value = now;";                PDActionJavaScript jsAction = new PDActionJavaScript();        jsAction.setAction(javaScript);                document.getDocumentCatalog().setOpenAction(jsAction);        document.save("target/UpdateFieldOnDocumentOpen.pdf");    }}
public static void pdfbox_f539_0(String[] args)
{    String usage = "java org.apache.pdfbox.lucene.IndexPDFFiles" + " [-index INDEX_PATH] [-docs DOCS_PATH] [-update]\n\n" + "This indexes all PDF documents in DOCS_PATH, creating a Lucene index" + "in INDEX_PATH that can be searched with SearchFiles";    String indexPath = "index";    String docsPath = null;    boolean create = true;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case "-index":                indexPath = args[i + 1];                i++;                break;            case "-docs":                docsPath = args[i + 1];                i++;                break;            case "-update":                create = false;                break;            default:                break;        }    }    if (docsPath == null) {        System.err.println("Usage: " + usage);        System.exit(1);    }    final File docDir = new File(docsPath);    if (!docDir.exists() || !docDir.canRead()) {        System.out.println("Document directory '" + docDir.getAbsolutePath() + "' does not exist or is not readable, please check the path");        System.exit(1);    }    Date start = new Date();    try {        System.out.println("Indexing to directory '" + indexPath + "'...");        try (Directory dir = FSDirectory.open(new File(indexPath).toPath())) {            Analyzer analyzer = new StandardAnalyzer();            IndexWriterConfig iwc = new IndexWriterConfig(analyzer);            if (create) {                                                iwc.setOpenMode(OpenMode.CREATE);            } else {                                iwc.setOpenMode(OpenMode.CREATE_OR_APPEND);            }                        try (final IndexWriter writer = new IndexWriter(dir, iwc)) {                indexDocs(writer, docDir);                                                                                                }        }        Date end = new Date();        System.out.println(end.getTime() - start.getTime() + " total milliseconds");    } catch (IOException e) {        System.out.println(" caught a " + e.getClass() + "\n with message: " + e.getMessage());    }}
 static void pdfbox_f540_0(IndexWriter writer, File file) throws IOException
{        if (file.canRead()) {        if (file.isDirectory()) {            String[] files = file.list();                        if (files != null) {                for (String fileName : files) {                    indexDocs(writer, new File(file, fileName));                }            }        } else {            FileInputStream fis;            try {                fis = new FileInputStream(file);            } catch (FileNotFoundException fnfe) {                                return;            }            try {                String path = file.getName().toUpperCase();                Document doc;                if (path.toLowerCase().endsWith(".pdf")) {                    System.out.println("Indexing PDF document: " + file);                    doc = LucenePDFDocument.getDocument(file);                } else {                    System.out.println("Skipping " + file);                    return;                }                if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {                                        System.out.println("adding " + file);                    writer.addDocument(doc);                } else {                                                                                System.out.println("updating " + file);                    writer.updateDocument(new Term("uid", LucenePDFDocument.createUID(file)), doc);                }            } finally {                fis.close();            }        }    }}
public void pdfbox_f541_0(PDFTextStripper aStripper)
{    stripper = aStripper;}
private static String pdfbox_f542_0(long time)
{    return DateTools.timeToString(time, DATE_TIME_RES);}
private void pdfbox_f543_0(Document document, String name, String value)
{    if (value != null) {        document.add(new StringField(name, value, Field.Store.YES));    }}
private void pdfbox_f544_0(Document document, String name, Reader value)
{    if (value != null) {        document.add(new TextField(name, value));    }}
private void pdfbox_f545_0(Document document, String name, String value)
{    if (value != null) {        document.add(new TextField(name, value, Field.Store.YES));    }}
private void pdfbox_f546_0(Document document, String name, Date value)
{    if (value != null) {        addTextField(document, name, DateTools.dateToString(value, DATE_TIME_RES));    }}
private void pdfbox_f547_0(Document document, String name, Calendar value)
{    if (value != null) {        addTextField(document, name, value.getTime());    }}
private static void pdfbox_f548_0(Document document, String name, String value)
{    if (value != null) {        document.add(new Field(name, value, TYPE_STORED_NOT_INDEXED));    }}
private void pdfbox_f549_0(Document document, String name, String value)
{    if (value != null) {        document.add(new Field(name, value, TextField.TYPE_NOT_STORED));    }}
public Document pdfbox_f550_0(InputStream is) throws IOException
{    Document document = new Document();    addContent(document, is, "<inputstream>");    return document;}
public Document pdfbox_f551_0(File file) throws IOException
{    Document document = new Document();            addUnindexedField(document, "path", file.getPath());    addUnindexedField(document, "url", file.getPath().replace(FILE_SEPARATOR, '/'));                addKeywordField(document, "modified", timeToString(file.lastModified()));    String uid = createUID(file);                addUnstoredKeywordField(document, "uid", uid);    try (FileInputStream input = new FileInputStream(file)) {        addContent(document, input, file.getPath());    }    return document;}
public Document pdfbox_f552_0(URL url) throws IOException
{    Document document = new Document();    URLConnection connection = url.openConnection();    connection.connect();            addUnindexedField(document, "url", url.toExternalForm());                addKeywordField(document, "modified", timeToString(connection.getLastModified()));    String uid = createUID(url, connection.getLastModified());                addUnstoredKeywordField(document, "uid", uid);    try (InputStream input = connection.getInputStream()) {        addContent(document, input, url.toExternalForm());    }        return document;}
public static Document pdfbox_f553_0(InputStream is) throws IOException
{    LucenePDFDocument converter = new LucenePDFDocument();    return converter.convertDocument(is);}
public static Document pdfbox_f554_0(File file) throws IOException
{    LucenePDFDocument converter = new LucenePDFDocument();    return converter.convertDocument(file);}
public static Document pdfbox_f555_0(URL url) throws IOException
{    LucenePDFDocument converter = new LucenePDFDocument();    return converter.convertDocument(url);}
private void pdfbox_f556_0(Document document, InputStream is, String documentLocation) throws IOException
{    try (PDDocument pdfDocument = PDDocument.load(is)) {                StringWriter writer = new StringWriter();        if (stripper == null) {            stripper = new PDFTextStripper();        }        stripper.writeText(pdfDocument, writer);                                        String contents = writer.getBuffer().toString();        StringReader reader = new StringReader(contents);                        addTextField(document, "contents", reader);        PDDocumentInformation info = pdfDocument.getDocumentInformation();        if (info != null) {            addTextField(document, "Author", info.getAuthor());            addTextField(document, "CreationDate", info.getCreationDate());            addTextField(document, "Creator", info.getCreator());            addTextField(document, "Keywords", info.getKeywords());            addTextField(document, "ModificationDate", info.getModificationDate());            addTextField(document, "Producer", info.getProducer());            addTextField(document, "Subject", info.getSubject());            addTextField(document, "Title", info.getTitle());            addTextField(document, "Trapped", info.getTrapped());        }        int summarySize = Math.min(contents.length(), 500);        String summary = contents.substring(0, summarySize);                        addUnindexedField(document, "summary", summary);    } catch (InvalidPasswordException e) {                throw new IOException("Error: The document(" + documentLocation + ") is encrypted and will not be indexed.", e);    }}
public static String pdfbox_f557_0(URL url, long time)
{    return url.toExternalForm().replace(FILE_SEPARATOR, '\u0000') + "\u0000" + timeToString(time);}
public static String pdfbox_f558_0(File file)
{    return file.getPath().replace(FILE_SEPARATOR, '\u0000') + "\u0000" + timeToString(file.lastModified());}
public static void pdfbox_f559_0(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("Usage: " + AddAnnotations.class.getName() + " <output-pdf>");        System.exit(1);    }    try (PDDocument document = new PDDocument()) {        PDPage page1 = new PDPage();        PDPage page2 = new PDPage();        PDPage page3 = new PDPage();        document.addPage(page1);        document.addPage(page2);        document.addPage(page3);        List<PDAnnotation> annotations = page1.getAnnotations();                        PDColor red = new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE);        PDColor blue = new PDColor(new float[] { 0, 0, 1 }, PDDeviceRGB.INSTANCE);        PDColor green = new PDColor(new float[] { 0, 1, 0 }, PDDeviceRGB.INSTANCE);        PDColor black = new PDColor(new float[] { 0, 0, 0 }, PDDeviceRGB.INSTANCE);        PDBorderStyleDictionary borderThick = new PDBorderStyleDictionary();                borderThick.setWidth(INCH / 12);        PDBorderStyleDictionary borderThin = new PDBorderStyleDictionary();                borderThin.setWidth(INCH / 72);        PDBorderStyleDictionary borderULine = new PDBorderStyleDictionary();        borderULine.setStyle(PDBorderStyleDictionary.STYLE_UNDERLINE);                borderULine.setWidth(INCH / 72);        float pw = page1.getMediaBox().getUpperRightX();        float ph = page1.getMediaBox().getUpperRightY();                PDFont font = PDType1Font.HELVETICA_BOLD;        try (PDPageContentStream contents = new PDPageContentStream(document, page1)) {            contents.beginText();            contents.setFont(font, 18);            contents.newLineAtOffset(INCH, ph - INCH - 18);            contents.showText("PDFBox");            contents.newLineAtOffset(0, -(INCH / 2));            contents.showText("External URL");            contents.newLineAtOffset(0, -(INCH / 2));            contents.showText("Jump to page three");            contents.endText();        }                PDAnnotationHighlight txtHighlight = new PDAnnotationHighlight();        txtHighlight.setColor(new PDColor(new float[] { 0, 1, 1 }, PDDeviceRGB.INSTANCE));                txtHighlight.setConstantOpacity((float) 0.2);                float textWidth = font.getStringWidth("PDFBox") / 1000 * 18;        PDRectangle position = new PDRectangle();        position.setLowerLeftX(INCH);        position.setLowerLeftY(ph - INCH - 18);        position.setUpperRightX(INCH + textWidth);        position.setUpperRightY(ph - INCH);        txtHighlight.setRectangle(position);                                        float[] quads = new float[8];                quads[0] = position.getLowerLeftX();                quads[1] = position.getUpperRightY() - 2;                quads[2] = position.getUpperRightX();                quads[3] = quads[1];                quads[4] = quads[0];                quads[5] = position.getLowerLeftY() - 2;                quads[6] = quads[2];                quads[7] = quads[5];        txtHighlight.setQuadPoints(quads);        txtHighlight.setContents("Highlighted since it's important");        annotations.add(txtHighlight);                PDAnnotationLink txtLink = new PDAnnotationLink();        txtLink.setBorderStyle(borderULine);                textWidth = font.getStringWidth("External URL") / 1000 * 18;        position = new PDRectangle();        position.setLowerLeftX(INCH);                position.setLowerLeftY(ph - 1.5f * INCH - 20);        position.setUpperRightX(INCH + textWidth);        position.setUpperRightY(ph - 1.5f * INCH);        txtLink.setRectangle(position);                PDActionURI action = new PDActionURI();        action.setURI("http://pdfbox.apache.org");        txtLink.setAction(action);        annotations.add(txtLink);                PDAnnotationCircle aCircle = new PDAnnotationCircle();        aCircle.setContents("Circle Annotation");                aCircle.setInteriorColor(red);                aCircle.setColor(blue);        aCircle.setBorderStyle(borderThin);                        position = new PDRectangle();        position.setLowerLeftX(INCH);                position.setLowerLeftY(ph - 3 * INCH - INCH);                position.setUpperRightX(2 * INCH);                position.setUpperRightY(ph - 3 * INCH);        aCircle.setRectangle(position);        annotations.add(aCircle);                PDAnnotationSquare aSquare = new PDAnnotationSquare();        aSquare.setContents("Square Annotation");                aSquare.setColor(red);        aSquare.setBorderStyle(borderThick);                                position = new PDRectangle();                position.setLowerLeftX(pw - 2 * INCH);                position.setLowerLeftY(ph - 3.5f * INCH - INCH);                position.setUpperRightX(pw - INCH);                position.setUpperRightY(ph - 3.5f * INCH);        aSquare.setRectangle(position);        annotations.add(aSquare);                PDAnnotationLine aLine = new PDAnnotationLine();        aLine.setEndPointEndingStyle(PDAnnotationLine.LE_OPEN_ARROW);        aLine.setContents("Circle->Square");                aLine.setCaption(true);                        position = new PDRectangle();                position.setLowerLeftX(2 * INCH);                position.setLowerLeftY(ph - 3.5f * INCH - INCH);                position.setUpperRightX(pw - INCH - INCH);                position.setUpperRightY(ph - 3 * INCH);        aLine.setRectangle(position);                float[] linepos = new float[4];                linepos[0] = 2 * INCH;                linepos[1] = ph - 3.5f * INCH;                linepos[2] = pw - 2 * INCH;                linepos[3] = ph - 4 * INCH;        aLine.setLine(linepos);        aLine.setBorderStyle(borderThick);        aLine.setColor(black);        annotations.add(aLine);                PDAnnotationLink pageLink = new PDAnnotationLink();        pageLink.setBorderStyle(borderULine);                textWidth = font.getStringWidth("Jump to page three") / 1000 * 18;        position = new PDRectangle();        position.setLowerLeftX(INCH);                position.setLowerLeftY(ph - 2 * INCH - 20);        position.setUpperRightX(INCH + textWidth);        position.setUpperRightY(ph - 2 * INCH);        pageLink.setRectangle(position);                PDActionGoTo actionGoto = new PDActionGoTo();                PDPageDestination dest = new PDPageFitWidthDestination();                dest.setPage(page3);        actionGoto.setDestination(dest);        pageLink.setAction(actionGoto);        annotations.add(pageLink);        PDAnnotationFreeText freeTextAnnotation = new PDAnnotationFreeText();        PDColor yellow = new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE);                freeTextAnnotation.setColor(yellow);        position = new PDRectangle();        position.setLowerLeftX(1 * INCH);        position.setLowerLeftY(ph - 5f * INCH - 3 * INCH);        position.setUpperRightX(pw - INCH);        position.setUpperRightY(ph - 5f * INCH);        freeTextAnnotation.setRectangle(position);        freeTextAnnotation.setTitlePopup("Sophia Lorem");        freeTextAnnotation.setSubject("Lorem ipsum");        freeTextAnnotation.setContents("Lorem ipsum dolor sit amet, consetetur sadipscing elitr," + " sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam " + "erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea " + "rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum " + "dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, " + "sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam " + "erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea " + "rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum " + "dolor sit amet.");                freeTextAnnotation.setDefaultAppearance("0 0 1 rg /Helv 20 Tf");                freeTextAnnotation.setQ(PDVariableText.QUADDING_RIGHT);        freeTextAnnotation.setIntent(PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT);        freeTextAnnotation.setCallout(new float[] { 0, ph - 9 * INCH, 3 * INCH, ph - 9 * INCH, 4 * INCH, ph - 8 * INCH });        freeTextAnnotation.setLineEndingStyle(PDAnnotationLine.LE_OPEN_ARROW);        annotations.add(freeTextAnnotation);        PDAnnotationPolygon polygon = new PDAnnotationPolygon();        position = new PDRectangle();        position.setLowerLeftX(pw - INCH);        position.setLowerLeftY(ph - INCH);        position.setUpperRightX(pw - 2 * INCH);        position.setUpperRightY(ph - 2 * INCH);        polygon.setRectangle(position);        polygon.setColor(blue);        polygon.setInteriorColor(green);        float[] vertices = { pw - INCH, ph - 2 * INCH, pw - 1.5f * INCH, ph - INCH, pw - 2 * INCH, ph - 2 * INCH };        polygon.setVertices(vertices);        polygon.setBorderStyle(borderThick);        polygon.setContents("Polygon annotation");        annotations.add(polygon);                PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();        if (acroForm == null) {            acroForm = new PDAcroForm(document);            document.getDocumentCatalog().setAcroForm(acroForm);        }        PDResources dr = acroForm.getDefaultResources();        if (dr == null) {            dr = new PDResources();            acroForm.setDefaultResources(dr);        }        dr.put(COSName.getPDFName("Helv"), PDType1Font.HELVETICA);                                annotations.forEach(PDAnnotation::constructAppearances);        showPageNo(document, page1, "Page 1");        showPageNo(document, page2, "Page 2");        showPageNo(document, page3, "Page 3");                document.save(args[0]);    }}
private static void pdfbox_f560_0(PDDocument document, PDPage page, String pageText) throws IOException
{    int fontSize = 10;    try (PDPageContentStream contents = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.PREPEND, true)) {        float pageWidth = page.getMediaBox().getWidth();        float pageHeight = page.getMediaBox().getHeight();        PDFont font = PDType1Font.HELVETICA;        contents.setFont(font, fontSize);        float textWidth = font.getStringWidth(pageText) / 1000 * fontSize;        contents.beginText();        contents.newLineAtOffset(pageWidth / 2 - textWidth / 2, pageHeight - INCH / 2);        contents.showText(pageText);        contents.endText();    }}
public void pdfbox_f561_0(String inputFile, String imagePath, String outputFile) throws IOException
{    try (PDDocument doc = PDDocument.load(new File(inputFile))) {                PDPage page = doc.getPage(0);                                PDImageXObject pdImage = PDImageXObject.createFromFile(imagePath, doc);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {                                                float scale = 1f;            contentStream.drawImage(pdImage, 20, 20, pdImage.getWidth() * scale, pdImage.getHeight() * scale);        }        doc.save(outputFile);    }}
public static void pdfbox_f562_0(String[] args) throws IOException
{    AddImageToPDF app = new AddImageToPDF();    if (args.length != 3) {        app.usage();    } else {        app.createPDFFromImage(args[0], args[1], args[2]);    }}
private void pdfbox_f563_0()
{    System.err.println("usage: " + this.getClass().getName() + " <input-pdf> <image> <output-pdf>");}
public static void pdfbox_f564_0(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDActionJavaScript javascript = new PDActionJavaScript("app.alert( {cMsg: 'PDFBox rocks!', nIcon: 3, nType: 0, cTitle: 'PDFBox Javascript example' } );");            document.getDocumentCatalog().setOpenAction(javascript);            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            document.save(args[1]);        }    }}
private static void pdfbox_f565_0()
{    System.err.println("Usage: java " + AddJavascript.class.getName() + " <input-pdf> <output-pdf>");}
public void pdfbox_f566_0(String file, String message, String outfile) throws IOException
{    try (PDDocument doc = PDDocument.load(new File(file))) {        PDFont font = PDType1Font.HELVETICA_BOLD;        float fontSize = 36.0f;        for (PDPage page : doc.getPages()) {            PDRectangle pageSize = page.getMediaBox();            float stringWidth = font.getStringWidth(message) * fontSize / 1000f;                        int rotation = page.getRotation();            boolean rotate = rotation == 90 || rotation == 270;            float pageWidth = rotate ? pageSize.getHeight() : pageSize.getWidth();            float pageHeight = rotate ? pageSize.getWidth() : pageSize.getHeight();            float centerX = rotate ? pageHeight / 2f : (pageWidth - stringWidth) / 2f;            float centerY = rotate ? (pageWidth - stringWidth) / 2f : pageHeight / 2f;                        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {                contentStream.beginText();                                contentStream.setFont(font, fontSize);                                contentStream.setNonStrokingColor(255, 0, 0);                if (rotate) {                                        contentStream.setTextMatrix(Matrix.getRotateInstance(Math.PI / 2, centerX, centerY));                } else {                    contentStream.setTextMatrix(Matrix.getTranslateInstance(centerX, centerY));                }                contentStream.showText(message);                contentStream.endText();            }        }        doc.save(outfile);    }}
public static void pdfbox_f567_0(String[] args) throws IOException
{    AddMessageToEachPage app = new AddMessageToEachPage();    if (args.length != 3) {        app.usage();    } else {        app.doIt(args[0], args[1], args[2]);    }}
private void pdfbox_f568_0()
{    System.err.println("usage: " + this.getClass().getName() + " <input-file> <Message> <output-file>");}
public static void pdfbox_f569_0(String[] args) throws IOException, TransformerException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Cannot add metadata to encrypted document.");                System.exit(1);            }            PDDocumentCatalog catalog = document.getDocumentCatalog();            PDDocumentInformation info = document.getDocumentInformation();            XMPMetadata metadata = XMPMetadata.createXMPMetadata();            AdobePDFSchema pdfSchema = metadata.createAndAddAdobePDFSchema();            pdfSchema.setKeywords(info.getKeywords());            pdfSchema.setProducer(info.getProducer());            XMPBasicSchema basicSchema = metadata.createAndAddXMPBasicSchema();            basicSchema.setModifyDate(info.getModificationDate());            basicSchema.setCreateDate(info.getCreationDate());            basicSchema.setCreatorTool(info.getCreator());            basicSchema.setMetadataDate(new GregorianCalendar());            DublinCoreSchema dcSchema = metadata.createAndAddDublinCoreSchema();            dcSchema.setTitle(info.getTitle());            dcSchema.addCreator("PDFBox");            dcSchema.setDescription(info.getSubject());            PDMetadata metadataStream = new PDMetadata(document);            catalog.setMetadata(metadataStream);            XmpSerializer serializer = new XmpSerializer();            ByteArrayOutputStream baos = new ByteArrayOutputStream();            serializer.serialize(metadata, baos, false);            metadataStream.importXMPMetadata(baos.toByteArray());            document.save(args[1]);        }    }}
private static void pdfbox_f570_0()
{    System.err.println("Usage: java " + AddMetadataFromDocInfo.class.getName() + " <input-pdf> <output-pdf>");}
public static void pdfbox_f571_0(String[] args) throws IOException, URISyntaxException
{    if (args.length != 1) {        System.err.println("usage: " + BengaliPdfGenerationHelloWorld.class.getName() + " <output-file> ");        System.exit(1);    }    String filename = args[0];    System.out.println("The generated pdf filename is: " + filename);    try (PDDocument doc = new PDDocument()) {        PDFont font = PDType0Font.load(doc, BengaliPdfGenerationHelloWorld.class.getResourceAsStream(LOHIT_BENGALI_TTF), true);        PDRectangle rectangle = getPageSize();        float workablePageWidth = rectangle.getWidth() - 2 * MARGIN;        float workablePageHeight = rectangle.getHeight() - 2 * MARGIN;        List<List<String>> pagedTexts = getReAlignedTextBasedOnPageHeight(getReAlignedTextBasedOnPageWidth(getBengaliTextFromFile(), font, workablePageWidth), font, workablePageHeight);        for (List<String> linesForPage : pagedTexts) {            PDPage page = new PDPage(getPageSize());            doc.addPage(page);            try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                contents.beginText();                contents.setFont(font, FONT_SIZE);                contents.newLineAtOffset(rectangle.getLowerLeftX() + MARGIN, rectangle.getUpperRightY() - MARGIN);                for (String line : linesForPage) {                    contents.showText(line);                    contents.newLineAtOffset(0, -(FONT_SIZE + LINE_GAP));                }                contents.endText();            }        }        doc.save(filename);    }}
private static List<List<String>> pdfbox_f572_0(List<String> originalLines, PDFont font, float workablePageHeight)
{    final float newLineHeight = font.getFontDescriptor().getFontBoundingBox().getHeight() / 1000 * FONT_SIZE + LINE_GAP;    List<List<String>> realignedTexts = new ArrayList<>();    float consumedHeight = 0;    List<String> linesInAPage = new ArrayList<>();    for (String line : originalLines) {        if (newLineHeight + consumedHeight < workablePageHeight) {            consumedHeight += newLineHeight;        } else {            consumedHeight = newLineHeight;            realignedTexts.add(linesInAPage);            linesInAPage = new ArrayList<>();        }        linesInAPage.add(line);    }    realignedTexts.add(linesInAPage);    return realignedTexts;}
private static List<String> pdfbox_f573_0(List<String> originalLines, PDFont font, float workablePageWidth) throws IOException
{    List<String> uniformlyWideTexts = new ArrayList<>();    float consumedWidth = 0;    StringBuilder sb = new StringBuilder();    for (String line : originalLines) {        float newTokenWidth = 0;        StringTokenizer st = new StringTokenizer(line, " ", true);        while (st.hasMoreElements()) {            String token = st.nextToken();            newTokenWidth = font.getStringWidth(token) / 1000 * FONT_SIZE;            if (newTokenWidth + consumedWidth < workablePageWidth) {                consumedWidth += newTokenWidth;            } else {                                uniformlyWideTexts.add(sb.toString());                consumedWidth = newTokenWidth;                sb = new StringBuilder();            }            sb.append(token);        }                uniformlyWideTexts.add(sb.toString());        consumedWidth = newTokenWidth;        sb = new StringBuilder();    }    return uniformlyWideTexts;}
private static PDRectangle pdfbox_f574_0()
{    return PDRectangle.A4;}
private static List<String> pdfbox_f575_0() throws IOException
{    List<String> lines = new ArrayList<>();    try (BufferedReader br = new BufferedReader(new InputStreamReader(BengaliPdfGenerationHelloWorld.class.getResourceAsStream(TEXT_SOURCE_FILE), Charsets.UTF_8))) {        while (true) {            String line = br.readLine();            if (line == null) {                break;            }            if (!line.startsWith("#")) {                lines.add(line);            }        }    }    return lines;}
public static void pdfbox_f576_0(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("usage: " + CreateBlankPDF.class.getName() + " <outputfile.pdf>");        System.exit(1);    }    String filename = args[0];    try (PDDocument doc = new PDDocument()) {                PDPage blankPage = new PDPage();        doc.addPage(blankPage);        doc.save(filename);    }}
public static void pdfbox_f577_0(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Cannot add bookmarks to encrypted document.");                System.exit(1);            }            PDDocumentOutline outline = new PDDocumentOutline();            document.getDocumentCatalog().setDocumentOutline(outline);            PDOutlineItem pagesOutline = new PDOutlineItem();            pagesOutline.setTitle("All Pages");            outline.addLast(pagesOutline);            int pageNum = 0;            for (PDPage page : document.getPages()) {                pageNum++;                PDPageDestination dest = new PDPageFitWidthDestination();                                                dest.setPage(page);                PDOutlineItem bookmark = new PDOutlineItem();                bookmark.setDestination(dest);                bookmark.setTitle("Page " + pageNum);                pagesOutline.addLast(bookmark);            }            pagesOutline.openNode();            outline.openNode();                        document.getDocumentCatalog().setPageMode(PageMode.USE_OUTLINES);            document.save(args[1]);        }    }}
private static void pdfbox_f578_0()
{    System.err.println("Usage: java " + CreateBookmarks.class.getName() + " <input-pdf> <output-pdf>");}
public void pdfbox_f579_0(String file) throws IOException
{    PDDocument document = null;    try {        document = new PDDocument();        PDPage page = new PDPage();        document.addPage(page);                        COSDictionary fdict = new COSDictionary();        fdict.setInt(COSName.FUNCTION_TYPE, 2);        COSArray domain = new COSArray();        domain.add(COSInteger.get(0));        domain.add(COSInteger.get(1));        COSArray c0 = new COSArray();        c0.add(COSFloat.get("1"));        c0.add(COSFloat.get("0"));        c0.add(COSFloat.get("0"));        COSArray c1 = new COSArray();        c1.add(COSFloat.get("0.5"));        c1.add(COSFloat.get("1"));        c1.add(COSFloat.get("0.5"));        fdict.setItem(COSName.DOMAIN, domain);        fdict.setItem(COSName.C0, c0);        fdict.setItem(COSName.C1, c1);        fdict.setInt(COSName.N, 1);        PDFunctionType2 func = new PDFunctionType2(fdict);                PDShadingType2 axialShading = new PDShadingType2(new COSDictionary());        axialShading.setColorSpace(PDDeviceRGB.INSTANCE);        axialShading.setShadingType(PDShading.SHADING_TYPE2);        COSArray coords1 = new COSArray();        coords1.add(COSInteger.get(100));        coords1.add(COSInteger.get(400));        coords1.add(COSInteger.get(400));        coords1.add(COSInteger.get(600));        axialShading.setCoords(coords1);        axialShading.setFunction(func);                PDShadingType3 radialShading = new PDShadingType3(new COSDictionary());        radialShading.setColorSpace(PDDeviceRGB.INSTANCE);        radialShading.setShadingType(PDShading.SHADING_TYPE3);        COSArray coords2 = new COSArray();        coords2.add(COSInteger.get(100));        coords2.add(COSInteger.get(400));                coords2.add(COSInteger.get(50));        coords2.add(COSInteger.get(400));        coords2.add(COSInteger.get(600));                coords2.add(COSInteger.get(150));        radialShading.setCoords(coords2);        radialShading.setFunction(func);                                PDShadingType4 gouraudShading = new PDShadingType4(document.getDocument().createCOSStream());        gouraudShading.setShadingType(PDShading.SHADING_TYPE4);                gouraudShading.setBitsPerFlag(8);        gouraudShading.setBitsPerCoordinate(16);        gouraudShading.setBitsPerComponent(8);        COSArray decodeArray = new COSArray();                                                decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.get(0xFFFF));        decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.get(0xFFFF));                decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.ONE);        decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.ONE);        decodeArray.add(COSInteger.ZERO);        decodeArray.add(COSInteger.ONE);        gouraudShading.setDecodeValues(decodeArray);        gouraudShading.setColorSpace(PDDeviceRGB.INSTANCE);                try (OutputStream os = ((COSStream) gouraudShading.getCOSObject()).createOutputStream();            MemoryCacheImageOutputStream mcos = new MemoryCacheImageOutputStream(os)) {                                    mcos.writeByte(0);                        mcos.writeShort(0);            mcos.writeShort(0);                        mcos.writeByte(0xFF);            mcos.writeByte(0);            mcos.writeByte(0);                        mcos.writeByte(0);                        mcos.writeShort(100);            mcos.writeShort(100);                        mcos.writeByte(0);            mcos.writeByte(0xFF);            mcos.writeByte(0);                        mcos.writeByte(0);                        mcos.writeShort(200);            mcos.writeShort(0);                        mcos.writeByte(0);            mcos.writeByte(0);            mcos.writeByte(0xFF);        }                try (PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false)) {            contentStream.shadingFill(axialShading);            contentStream.shadingFill(radialShading);            contentStream.shadingFill(gouraudShading);        }        document.save(file);        document.close();                document = PDDocument.load(new File(file));        BufferedImage bim = new PDFRenderer(document).renderImageWithDPI(0, 100);        ImageIO.write(bim, "png", new File(file + ".png"));        document.close();    } finally {        if (document != null) {            document.close();        }    }}
public static void pdfbox_f580_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        CreateGradientShadingPDF creator = new CreateGradientShadingPDF();        creator.create(args[0]);    }}
private static void pdfbox_f581_0()
{    System.err.println("usage: java " + CreateGradientShadingPDF.class.getName() + " <outputfile.pdf>");}
public void pdfbox_f582_0(String message, String outfile) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDFont font = PDType1Font.HELVETICA;        PDPage page = new PDPage(PDRectangle.A4);        page.setRotation(90);        doc.addPage(page);        PDRectangle pageSize = page.getMediaBox();        float pageWidth = pageSize.getWidth();        float fontSize = 12;        float stringWidth = font.getStringWidth(message) * fontSize / 1000f;        float startX = 100;        float startY = 100;        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                                    contentStream.transform(new Matrix(0, 1, -1, 0, pageWidth, 0));            contentStream.setFont(font, fontSize);            contentStream.beginText();            contentStream.newLineAtOffset(startX, startY);            contentStream.showText(message);            contentStream.newLineAtOffset(0, 100);            contentStream.showText(message);            contentStream.newLineAtOffset(100, 100);            contentStream.showText(message);            contentStream.endText();            contentStream.moveTo(startX - 2, startY - 2);            contentStream.lineTo(startX - 2, startY + 200 + fontSize);            contentStream.stroke();            contentStream.moveTo(startX - 2, startY + 200 + fontSize);            contentStream.lineTo(startX + 100 + stringWidth + 2, startY + 200 + fontSize);            contentStream.stroke();            contentStream.moveTo(startX + 100 + stringWidth + 2, startY + 200 + fontSize);            contentStream.lineTo(startX + 100 + stringWidth + 2, startY - 2);            contentStream.stroke();            contentStream.moveTo(startX + 100 + stringWidth + 2, startY - 2);            contentStream.lineTo(startX - 2, startY - 2);            contentStream.stroke();        }        doc.save(outfile);    }}
public static void pdfbox_f583_0(String[] args) throws IOException
{    CreateLandscapePDF app = new CreateLandscapePDF();    if (args.length != 2) {        app.usage();    } else {        app.doIt(args[0], args[1]);    }}
private void pdfbox_f584_0()
{    System.err.println("usage: " + this.getClass().getName() + " <Message> <output-file>");}
public static void pdfbox_f585_0(String[] args) throws IOException
{    try (PDDocument doc = new PDDocument()) {        doc.addPage(new PDPage());        doc.addPage(new PDPage());        doc.addPage(new PDPage());        PDPageLabels pageLabels = new PDPageLabels(doc);        PDPageLabelRange pageLabelRange1 = new PDPageLabelRange();        pageLabelRange1.setPrefix("RO ");        pageLabelRange1.setStart(3);        pageLabelRange1.setStyle(PDPageLabelRange.STYLE_ROMAN_UPPER);        pageLabels.setLabelItem(0, pageLabelRange1);        PDPageLabelRange pageLabelRange2 = new PDPageLabelRange();        pageLabelRange2.setStart(1);        pageLabelRange2.setStyle(PDPageLabelRange.STYLE_DECIMAL);        pageLabels.setLabelItem(2, pageLabelRange2);        doc.getDocumentCatalog().setPageLabels(pageLabels);        doc.save("labels.pdf");    }}
public static void pdfbox_f586_0(String[] args) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        page.setResources(new PDResources());                try (PDPageContentStream pcs = new PDPageContentStream(doc, page)) {                        PDColorSpace patternCS1 = new PDPattern(null, PDDeviceRGB.INSTANCE);                        PDTilingPattern tilingPattern1 = new PDTilingPattern();            tilingPattern1.setBBox(new PDRectangle(0, 0, 10, 10));            tilingPattern1.setPaintType(PDTilingPattern.PAINT_COLORED);            tilingPattern1.setTilingType(PDTilingPattern.TILING_CONSTANT_SPACING);            tilingPattern1.setXStep(10);            tilingPattern1.setYStep(10);            COSName patternName1 = page.getResources().add(tilingPattern1);            try (PDPatternContentStream cs1 = new PDPatternContentStream(tilingPattern1)) {                                cs1.setStrokingColor(Color.red);                cs1.moveTo(0, 0);                cs1.lineTo(10, 10);                cs1.moveTo(-1, 9);                cs1.lineTo(1, 11);                cs1.moveTo(9, -1);                cs1.lineTo(11, 1);                cs1.stroke();            }            PDColor patternColor1 = new PDColor(patternName1, patternCS1);            pcs.addRect(50, 500, 200, 200);            pcs.setNonStrokingColor(patternColor1);            pcs.fill();                        PDTilingPattern tilingPattern2 = new PDTilingPattern();            tilingPattern2.setBBox(new PDRectangle(0, 0, 10, 10));            tilingPattern2.setPaintType(PDTilingPattern.PAINT_UNCOLORED);            tilingPattern2.setTilingType(PDTilingPattern.TILING_NO_DISTORTION);            tilingPattern2.setXStep(10);            tilingPattern2.setYStep(10);            COSName patternName2 = page.getResources().add(tilingPattern2);            try (PDPatternContentStream cs2 = new PDPatternContentStream(tilingPattern2)) {                                cs2.moveTo(0, 5);                cs2.lineTo(10, 5);                cs2.moveTo(5, 0);                cs2.lineTo(5, 10);                cs2.stroke();            }                                    PDColorSpace patternCS2 = new PDPattern(null, PDDeviceRGB.INSTANCE);            PDColor patternColor2green = new PDColor(new float[] { 0, 1, 0 }, patternName2, patternCS2);            pcs.addRect(300, 500, 100, 100);            pcs.setNonStrokingColor(patternColor2green);            pcs.fill();                        PDColor patternColor2blue = new PDColor(new float[] { 0, 0, 1 }, patternName2, patternCS2);            pcs.addRect(455, 505, 100, 100);            pcs.setNonStrokingColor(patternColor2blue);            pcs.fill();        }        doc.save("patterns.pdf");    }}
public static void pdfbox_f587_0(String[] args) throws IOException, TransformerException
{    if (args.length != 3) {        System.err.println("usage: " + CreatePDFA.class.getName() + " <output-file> <Message> <ttf-file>");        System.exit(1);    }    String file = args[0];    String message = args[1];    String fontfile = args[2];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                PDFont font = PDType0Font.load(doc, new File(fontfile));                if (!font.isEmbedded()) {            throw new IllegalStateException("PDF/A compliance requires that all fonts used for" + " text rendering in rendering modes other than rendering mode 3 are embedded.");        }                try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }                XMPMetadata xmp = XMPMetadata.createXMPMetadata();        try {            DublinCoreSchema dc = xmp.createAndAddDublinCoreSchema();            dc.setTitle(file);            PDFAIdentificationSchema id = xmp.createAndAddPFAIdentificationSchema();            id.setPart(1);            id.setConformance("B");            XmpSerializer serializer = new XmpSerializer();            ByteArrayOutputStream baos = new ByteArrayOutputStream();            serializer.serialize(xmp, baos, true);            PDMetadata metadata = new PDMetadata(doc);            metadata.importXMPMetadata(baos.toByteArray());            doc.getDocumentCatalog().setMetadata(metadata);        } catch (BadFieldValueException e) {                        throw new IllegalArgumentException(e);        }                InputStream colorProfile = CreatePDFA.class.getResourceAsStream("/org/apache/pdfbox/resources/pdfa/sRGB.icc");        PDOutputIntent intent = new PDOutputIntent(doc, colorProfile);        intent.setInfo("sRGB IEC61966-2.1");        intent.setOutputCondition("sRGB IEC61966-2.1");        intent.setOutputConditionIdentifier("sRGB IEC61966-2.1");        intent.setRegistryName("http://www.color.org");        doc.getDocumentCatalog().addOutputIntent(intent);        doc.save(file);    }}
public void pdfbox_f588_0(String file) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType1Font.HELVETICA_BOLD;        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page)) {            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(100, 700);            contentStream.showText("Go to Document->File Attachments to View Embedded Files");            contentStream.endText();        }                PDEmbeddedFilesNameTreeNode efTree = new PDEmbeddedFilesNameTreeNode();                PDComplexFileSpecification fs = new PDComplexFileSpecification();                fs.setFile("Test.txt");        fs.setFileUnicode("Test.txt");                byte[] data = "This is the contents of the embedded file".getBytes("ISO-8859-1");        ByteArrayInputStream fakeFile = new ByteArrayInputStream(data);        PDEmbeddedFile ef = new PDEmbeddedFile(doc, fakeFile);                ef.setSubtype("text/plain");        ef.setSize(data.length);        ef.setCreationDate(new GregorianCalendar());                fs.setEmbeddedFile(ef);        fs.setEmbeddedFileUnicode(ef);                PDEmbeddedFilesNameTreeNode treeNode = new PDEmbeddedFilesNameTreeNode();        treeNode.setNames(Collections.singletonMap("My first attachment", fs));                List<PDEmbeddedFilesNameTreeNode> kids = new ArrayList<>();        kids.add(treeNode);        efTree.setKids(kids);                PDDocumentNameDictionary names = new PDDocumentNameDictionary(doc.getDocumentCatalog());        names.setEmbeddedFiles(efTree);        doc.getDocumentCatalog().setNames(names);                doc.getDocumentCatalog().setPageMode(PageMode.USE_ATTACHMENTS);        doc.save(file);    }}
public static void pdfbox_f589_0(String[] args) throws IOException
{    EmbeddedFiles app = new EmbeddedFiles();    if (args.length != 1) {        app.usage();    } else {        app.doIt(args[0]);    }}
private void pdfbox_f590_0()
{    System.err.println("usage: " + this.getClass().getName() + " <output-file>");}
public static void pdfbox_f591_0(String[] args) throws IOException
{    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        String dir = "../pdfbox/src/main/resources/org/apache/pdfbox/resources/ttf/";        PDType0Font font = PDType0Font.load(document, new File(dir + "LiberationSans-Regular.ttf"));        try (PDPageContentStream stream = new PDPageContentStream(document, page)) {            stream.beginText();            stream.setFont(font, 12);            stream.setLeading(12 * 1.2f);            stream.newLineAtOffset(50, 600);            stream.showText("PDFBox's Unicode with Embedded TrueType Font");            stream.newLine();            stream.showText("Supports full Unicode text ");            stream.newLine();            stream.showText("English   Ting Vit");            stream.newLine();                        stream.showText("Ligatures: \uFB01lm \uFB02ood");            stream.endText();        }        document.save("example.pdf");    }}
public static void pdfbox_f592_0(String[] args) throws IOException
{    try (PDDocument document = new PDDocument();        TrueTypeCollection ttc2 = new TrueTypeCollection(new File("c:/windows/fonts/batang.ttc"));        TrueTypeCollection ttc3 = new TrueTypeCollection(new File("c:/windows/fonts/mingliu.ttc"))) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);                PDFont font1 = PDType1Font.HELVETICA;                PDType0Font font2 = PDType0Font.load(document, ttc2.getFontByName("Batang"), true);                PDType0Font font3 = PDType0Font.load(document, ttc3.getFontByName("MingLiU"), true);                PDType0Font font4 = PDType0Font.load(document, new File("c:/windows/fonts/mangal.ttf"));                PDType0Font font5 = PDType0Font.load(document, new File("c:/windows/fonts/ArialUni.ttf"));        try (PDPageContentStream cs = new PDPageContentStream(document, page)) {            cs.beginText();            List<PDFont> fonts = new ArrayList<>();            fonts.add(font1);            fonts.add(font2);            fonts.add(font3);            fonts.add(font4);            fonts.add(font5);            cs.newLineAtOffset(20, 700);            showTextMultiple(cs, "abc     abc", fonts, 20);            cs.endText();        }        document.save("example.pdf");    }}
 static void pdfbox_f593_0(PDPageContentStream cs, String text, List<PDFont> fonts, float size) throws IOException
{    try {                fonts.get(0).encode(text);        cs.setFont(fonts.get(0), size);        cs.showText(text);        return;    } catch (IllegalArgumentException ex) {        }        int i = 0;    while (i < text.length()) {        boolean found = false;        for (PDFont font : fonts) {            try {                String s = text.substring(i, i + 1);                font.encode(s);                                int j = i + 1;                for (; j < text.length(); ++j) {                    String s2 = text.substring(j, j + 1);                    if (isWinAnsiEncoding(s2.codePointAt(0)) && font != fonts.get(0)) {                                                break;                    }                    try {                        font.encode(s2);                    } catch (IllegalArgumentException ex) {                                                break;                    }                }                s = text.substring(i, j);                cs.setFont(font, size);                cs.showText(s);                i = j;                found = true;                break;            } catch (IllegalArgumentException ex) {                        }        }        if (!found) {            throw new IllegalArgumentException("Could not show '" + text.substring(i, i + 1) + "' with the fonts provided");        }    }}
 static boolean pdfbox_f594_0(int unicode)
{    String name = GlyphList.getAdobeGlyphList().codePointToName(unicode);    if (".notdef".equals(name)) {        return false;    }    return WinAnsiEncoding.INSTANCE.contains(name);}
public static void pdfbox_f595_0(String[] args) throws IOException
{    PDDocument document = new PDDocument();    PDPage page = new PDPage();    document.addPage(page);                File ipafont = new File("ipag.ttf");                    PDType0Font hfont = PDType0Font.load(document, ipafont);        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);            TrueTypeFont ttf = new TTFParser().parse(ipafont);    PDType0Font vfont2 = PDType0Font.loadVertical(document, ttf, true);    ttf.disableGsubFeature("vrt2");    ttf.disableGsubFeature("vert");    try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {        contentStream.beginText();        contentStream.setFont(hfont, 20);        contentStream.setLeading(25);        contentStream.newLineAtOffset(20, 300);        contentStream.showText("Key:");        contentStream.newLine();        contentStream.showText(" Horizontal");        contentStream.newLine();        contentStream.showText(" Vertical with substitution");        contentStream.newLine();        contentStream.showText(" Vertical without substitution");        contentStream.endText();        contentStream.beginText();        contentStream.setFont(hfont, 20);        contentStream.newLineAtOffset(20, 650);        contentStream.showText("");        contentStream.endText();        contentStream.beginText();        contentStream.setFont(vfont, 20);        contentStream.newLineAtOffset(50, 600);        contentStream.showText("");        contentStream.endText();        contentStream.beginText();        contentStream.setFont(vfont2, 20);        contentStream.newLineAtOffset(100, 600);        contentStream.showText("");        contentStream.endText();    }        document.save("vertical.pdf");}
public static void pdfbox_f596_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();        System.exit(1);    } else {        PDDocument document = null;        try {            File pdfFile = new File(args[0]);            String filePath = pdfFile.getParent() + System.getProperty("file.separator");            document = PDDocument.load(pdfFile);            PDDocumentNameDictionary namesDictionary = new PDDocumentNameDictionary(document.getDocumentCatalog());            PDEmbeddedFilesNameTreeNode efTree = namesDictionary.getEmbeddedFiles();            if (efTree != null) {                Map<String, PDComplexFileSpecification> names = efTree.getNames();                if (names != null) {                    extractFiles(names, filePath);                } else {                    List<PDNameTreeNode<PDComplexFileSpecification>> kids = efTree.getKids();                    for (PDNameTreeNode<PDComplexFileSpecification> node : kids) {                        names = node.getNames();                        extractFiles(names, filePath);                    }                }            }                        for (PDPage page : document.getPages()) {                for (PDAnnotation annotation : page.getAnnotations()) {                    if (annotation instanceof PDAnnotationFileAttachment) {                        PDAnnotationFileAttachment annotationFileAttachment = (PDAnnotationFileAttachment) annotation;                        PDFileSpecification fileSpec = annotationFileAttachment.getFile();                        if (fileSpec instanceof PDComplexFileSpecification) {                            PDComplexFileSpecification complexFileSpec = (PDComplexFileSpecification) fileSpec;                            PDEmbeddedFile embeddedFile = getEmbeddedFile(complexFileSpec);                            extractFile(filePath, complexFileSpec.getFilename(), embeddedFile);                        }                    }                }            }        } finally {            if (document != null) {                document.close();            }        }    }}
private static void pdfbox_f597_0(Map<String, PDComplexFileSpecification> names, String filePath) throws IOException
{    for (Entry<String, PDComplexFileSpecification> entry : names.entrySet()) {        String filename = entry.getKey();        PDComplexFileSpecification fileSpec = entry.getValue();        PDEmbeddedFile embeddedFile = getEmbeddedFile(fileSpec);        extractFile(filePath, filename, embeddedFile);    }}
private static void pdfbox_f598_0(String filePath, String filename, PDEmbeddedFile embeddedFile) throws IOException
{    String embeddedFilename = filePath + filename;    File file = new File(filePath + filename);    System.out.println("Writing " + embeddedFilename);    try (FileOutputStream fos = new FileOutputStream(file)) {        fos.write(embeddedFile.toByteArray());    }}
private static PDEmbeddedFile pdfbox_f599_0(PDComplexFileSpecification fileSpec)
{        PDEmbeddedFile embeddedFile = null;    if (fileSpec != null) {        embeddedFile = fileSpec.getEmbeddedFileUnicode();        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFileDos();        }        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFileMac();        }        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFileUnix();        }        if (embeddedFile == null) {            embeddedFile = fileSpec.getEmbeddedFile();        }    }    return embeddedFile;}
private static void pdfbox_f600_0()
{    System.err.println("Usage: java " + ExtractEmbeddedFiles.class.getName() + " <input-pdf>");}
public static void pdfbox_f601_0(String[] args) throws IOException, XmpParsingException
{    if (args.length != 1) {        usage();        System.exit(1);    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDDocumentCatalog catalog = document.getDocumentCatalog();            PDMetadata meta = catalog.getMetadata();            if (meta != null) {                DomXmpParser xmpParser = new DomXmpParser();                try {                    XMPMetadata metadata = xmpParser.parse(meta.createInputStream());                    DublinCoreSchema dc = metadata.getDublinCoreSchema();                    if (dc != null) {                        display("Title:", dc.getTitle());                        display("Description:", dc.getDescription());                        listString("Creators: ", dc.getCreators());                        listCalendar("Dates:", dc.getDates());                        listString("Subjects:", dc.getSubjects());                    }                    AdobePDFSchema pdf = metadata.getAdobePDFSchema();                    if (pdf != null) {                        display("Keywords:", pdf.getKeywords());                        display("PDF Version:", pdf.getPDFVersion());                        display("PDF Producer:", pdf.getProducer());                    }                    XMPBasicSchema basic = metadata.getXMPBasicSchema();                    if (basic != null) {                        display("Create Date:", basic.getCreateDate());                        display("Modify Date:", basic.getModifyDate());                        display("Creator Tool:", basic.getCreatorTool());                    }                } catch (XmpParsingException e) {                    System.err.println("An error ouccred when parsing the meta data: " + e.getMessage());                }            } else {                                                PDDocumentInformation information = document.getDocumentInformation();                if (information != null) {                    showDocumentInformation(information);                }            }        }    }}
private static void pdfbox_f602_0(PDDocumentInformation information)
{    display("Title:", information.getTitle());    display("Subject:", information.getSubject());    display("Author:", information.getAuthor());    display("Creator:", information.getCreator());    display("Producer:", information.getProducer());}
private static void pdfbox_f603_0(String title, List<String> list)
{    if (list == null) {        return;    }    System.out.println(title);    for (String string : list) {        System.out.println("  " + string);    }}
private static void pdfbox_f604_0(String title, List<Calendar> list)
{    if (list == null) {        return;    }    System.out.println(title);    for (Calendar calendar : list) {        System.out.println("  " + format(calendar));    }}
private static String pdfbox_f605_0(Object o)
{    if (o instanceof Calendar) {        Calendar cal = (Calendar) o;        return DateFormat.getDateInstance().format(cal.getTime());    } else {        return o.toString();    }}
private static void pdfbox_f606_0(String title, Object value)
{    if (value != null) {        System.out.println(title + " " + format(value));    }}
private static void pdfbox_f607_0()
{    System.err.println("Usage: java " + ExtractMetadata.class.getName() + " <input-pdf>");}
public static void pdfbox_f608_0(String[] args) throws IOException
{    ExtractTTFFonts extractor = new ExtractTTFFonts();    extractor.extractFonts(args);}
private void pdfbox_f609_0(String[] args) throws IOException
{    if (args.length < 1 || args.length > 4) {        usage();    } else {        String pdfFile = null;        @SuppressWarnings({ "squid:S2068" })        String password = "";        String prefix = null;        boolean addKey = false;        for (int i = 0; i < args.length; i++) {            switch(args[i]) {                case PASSWORD:                    i++;                    if (i >= args.length) {                        usage();                    }                    password = args[i];                    break;                case PREFIX:                    i++;                    if (i >= args.length) {                        usage();                    }                    prefix = args[i];                    break;                case ADDKEY:                    addKey = true;                    break;                default:                    if (pdfFile == null) {                        pdfFile = args[i];                    }                    break;            }        }        if (pdfFile == null) {            usage();        } else {            if (prefix == null && pdfFile.length() > 4) {                prefix = pdfFile.substring(0, pdfFile.length() - 4);            }            try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {                for (PDPage page : document.getPages()) {                    PDResources resources = page.getResources();                                        processResources(resources, prefix, addKey);                }            }        }    }}
private void pdfbox_f610_0(PDResources resources, String prefix, boolean addKey) throws IOException
{    if (resources == null) {        return;    }    for (COSName key : resources.getFontNames()) {        PDFont font = resources.getFont(key);                if (font instanceof PDTrueTypeFont) {            String name;            if (addKey) {                name = getUniqueFileName(prefix + "_" + key, "ttf");            } else {                name = getUniqueFileName(prefix, "ttf");            }            writeFont(font.getFontDescriptor(), name);        } else if (font instanceof PDType0Font) {            PDCIDFont descendantFont = ((PDType0Font) font).getDescendantFont();            if (descendantFont instanceof PDCIDFontType2) {                String name;                if (addKey) {                    name = getUniqueFileName(prefix + "_" + key, "ttf");                } else {                    name = getUniqueFileName(prefix, "ttf");                }                writeFont(descendantFont.getFontDescriptor(), name);            }        }    }    for (COSName name : resources.getXObjectNames()) {        PDXObject xobject = resources.getXObject(name);        if (xobject instanceof PDFormXObject) {            PDFormXObject xObjectForm = (PDFormXObject) xobject;            PDResources formResources = xObjectForm.getResources();            processResources(formResources, prefix, addKey);        }    }}
private void pdfbox_f611_0(PDFontDescriptor fd, String name) throws IOException
{    if (fd != null) {        PDStream ff2Stream = fd.getFontFile2();        if (ff2Stream != null) {            System.out.println("Writing font: " + name);            try (OutputStream os = new FileOutputStream(new File(name + ".ttf"));                InputStream is = ff2Stream.createInputStream()) {                IOUtils.copy(is, os);            }        }    }}
private String pdfbox_f612_0(String prefix, String suffix)
{    String uniqueName = null;    File f = null;    while (f == null || f.exists()) {        uniqueName = prefix + "-" + fontCounter;        f = new File(uniqueName + "." + suffix);        fontCounter++;    }    return uniqueName;}
private static void pdfbox_f613_0()
{    System.err.println("Usage: java " + ExtractTTFFonts.class.getName() + " [OPTIONS] <PDF file>\n" + "  -password  <password>        Password to decrypt document\n" + "  -prefix  <font-prefix>       Font prefix(default to pdf name)\n" + "  -addkey                      add the internal font key to the file name\n" + "  <PDF file>                   The PDF document to use\n");    System.exit(1);}
public static void pdfbox_f614_0(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Cannot add bookmark destination to encrypted documents.");                System.exit(1);            }            if (document.getNumberOfPages() < 2) {                throw new IOException("Error: The PDF must have at least 2 pages.");            }            PDDocumentOutline bookmarks = document.getDocumentCatalog().getDocumentOutline();            if (bookmarks == null) {                throw new IOException("Error: The PDF does not contain any bookmarks");            }            PDOutlineItem item = bookmarks.getFirstChild().getNextSibling();            PDDestination dest = item.getDestination();            PDActionGoTo action = new PDActionGoTo();            action.setDestination(dest);            document.getDocumentCatalog().setOpenAction(action);            document.save(args[1]);        }    }}
private static void pdfbox_f615_0()
{    System.err.println("Usage: java " + GoToSecondBookmarkOnOpen.class.getName() + "<input-pdf> <output-pdf>");}
public static void pdfbox_f616_0(String[] args) throws IOException
{    if (args.length != 2) {        System.err.println("usage: " + HelloWorld.class.getName() + " <output-file> <Message>");        System.exit(1);    }    String filename = args[0];    String message = args[1];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType1Font.HELVETICA_BOLD;        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }        doc.save(filename);    }}
public static void pdfbox_f617_0(String[] args) throws IOException
{    if (args.length != 3) {        System.err.println("usage: " + HelloWorldTTF.class.getName() + " <output-file> <Message> <ttf-file>");        System.exit(1);    }    String pdfPath = args[0];    String message = args[1];    String ttfPath = args[2];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType0Font.load(doc, new File(ttfPath));        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }        doc.save(pdfPath);        System.out.println(pdfPath + " created!");    }}
public static void pdfbox_f618_0(String[] args) throws IOException
{    if (args.length != 3) {        System.err.println("usage: " + HelloWorldType1.class.getName() + " <output-file> <Message> <pfb-file>");        System.exit(1);    }    String file = args[0];    String message = args[1];    String pfbPath = args[2];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = new PDType1Font(doc, new FileInputStream(pfbPath));        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            contents.beginText();            contents.setFont(font, 12);            contents.newLineAtOffset(100, 700);            contents.showText(message);            contents.endText();        }        doc.save(file);        System.out.println(file + " created!");    }}
public static void pdfbox_f619_0(String[] args) throws IOException
{    if (args.length != 2) {        System.err.println("usage: " + ImageToPDF.class.getName() + " <image> <output-file>");        System.exit(1);    }    String imagePath = args[0];    String pdfPath = args[1];    if (!pdfPath.endsWith(".pdf")) {        System.err.println("Last argument must be the destination .pdf file");        System.exit(1);    }    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                                PDImageXObject pdImage = PDImageXObject.createFromFile(imagePath, doc);                try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                        contents.drawImage(pdImage, 20, 20);                        }        doc.save(pdfPath);    }}
public static void pdfbox_f620_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PrintBookmarks meta = new PrintBookmarks();            PDDocumentOutline outline = document.getDocumentCatalog().getDocumentOutline();            if (outline != null) {                meta.printBookmark(document, outline, "");            } else {                System.out.println("This document does not contain any bookmarks");            }        }    }}
private static void pdfbox_f621_0()
{    System.err.println("Usage: java " + PrintBookmarks.class.getName() + " <input-pdf>");}
public void pdfbox_f622_0(PDDocument document, PDOutlineNode bookmark, String indentation) throws IOException
{    PDOutlineItem current = bookmark.getFirstChild();    while (current != null) {        if (current.getDestination() instanceof PDPageDestination) {            PDPageDestination pd = (PDPageDestination) current.getDestination();            System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));        } else if (current.getDestination() instanceof PDNamedDestination) {            PDPageDestination pd = document.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) current.getDestination());            if (pd != null) {                System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));            }        } else if (current.getDestination() != null) {            System.out.println(indentation + "Destination class: " + current.getDestination().getClass().getSimpleName());        }        if (current.getAction() instanceof PDActionGoTo) {            PDActionGoTo gta = (PDActionGoTo) current.getAction();            if (gta.getDestination() instanceof PDPageDestination) {                PDPageDestination pd = (PDPageDestination) gta.getDestination();                System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));            } else if (gta.getDestination() instanceof PDNamedDestination) {                PDPageDestination pd = document.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) gta.getDestination());                if (pd != null) {                    System.out.println(indentation + "Destination page: " + (pd.retrievePageNumber() + 1));                }            } else {                System.out.println(indentation + "Destination class: " + gta.getDestination().getClass().getSimpleName());            }        } else if (current.getAction() != null) {            System.out.println(indentation + "Action class: " + current.getAction().getClass().getSimpleName());        }        System.out.println(indentation + current.getTitle());        printBookmark(document, current, indentation + "    ");        current = current.getNextSibling();    }}
public static void pdfbox_f623_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PrintDocumentMetaData meta = new PrintDocumentMetaData();            meta.printMetadata(document);        }    }}
private static void pdfbox_f624_0()
{    System.err.println("Usage: java " + PrintDocumentMetaData.class.getName() + " <input-pdf>");}
public void pdfbox_f625_0(PDDocument document) throws IOException
{    PDDocumentInformation info = document.getDocumentInformation();    PDDocumentCatalog cat = document.getDocumentCatalog();    PDMetadata metadata = cat.getMetadata();    System.out.println("Page Count=" + document.getNumberOfPages());    System.out.println("Title=" + info.getTitle());    System.out.println("Author=" + info.getAuthor());    System.out.println("Subject=" + info.getSubject());    System.out.println("Keywords=" + info.getKeywords());    System.out.println("Creator=" + info.getCreator());    System.out.println("Producer=" + info.getProducer());    System.out.println("Creation Date=" + formatDate(info.getCreationDate()));    System.out.println("Modification Date=" + formatDate(info.getModificationDate()));    System.out.println("Trapped=" + info.getTrapped());    if (metadata != null) {        String string = new String(metadata.toByteArray(), "ISO-8859-1");        System.out.println("Metadata=" + string);    }}
private String pdfbox_f626_0(Calendar date)
{    String retval = null;    if (date != null) {        SimpleDateFormat formatter = new SimpleDateFormat();        retval = formatter.format(date.getTime());    }    return retval;}
public static void pdfbox_f627_0(String[] args) throws IOException
{    PDDocument doc = null;    try {        if (args.length != 1) {            usage();        } else {            doc = PDDocument.load(new File(args[0]));            int pageNum = 0;            for (PDPage page : doc.getPages()) {                pageNum++;                PDFTextStripperByArea stripper = new PDFTextStripperByArea();                List<PDAnnotation> annotations = page.getAnnotations();                                for (int j = 0; j < annotations.size(); j++) {                    PDAnnotation annot = annotations.get(j);                    if (getActionURI(annot) != null) {                        PDRectangle rect = annot.getRectangle();                                                float x = rect.getLowerLeftX();                        float y = rect.getUpperRightY();                        float width = rect.getWidth();                        float height = rect.getHeight();                        int rotation = page.getRotation();                        if (rotation == 0) {                            PDRectangle pageSize = page.getMediaBox();                                                        y = pageSize.getHeight() - y;                        } else {                                                                        }                        Rectangle2D.Float awtRect = new Rectangle2D.Float(x, y, width, height);                        stripper.addRegion("" + j, awtRect);                    }                }                stripper.extractRegions(page);                for (int j = 0; j < annotations.size(); j++) {                    PDAnnotation annot = annotations.get(j);                    PDActionURI uri = getActionURI(annot);                    if (uri != null) {                        String urlText = stripper.getTextForRegion("" + j);                        System.out.println("Page " + pageNum + ":'" + urlText.trim() + "'=" + uri.getURI());                    }                }            }        }    } finally {        if (doc != null) {            doc.close();        }    }}
private static PDActionURI pdfbox_f628_0(PDAnnotation annot)
{        try {        Method actionMethod = annot.getClass().getDeclaredMethod("getAction");        if (actionMethod.getReturnType().equals(PDAction.class)) {            PDAction action = (PDAction) actionMethod.invoke(annot);            if (action instanceof PDActionURI) {                return (PDActionURI) action;            }        }    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {    }    return null;}
private static void pdfbox_f629_0()
{    System.err.println("usage: " + PrintURLs.class.getName() + " <input-file>");}
public static void pdfbox_f630_0(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            if (document.getNumberOfPages() <= 1) {                throw new IOException("Error: A PDF document must have at least one page, " + "cannot remove the last page!");            }            document.removePage(0);            document.save(args[1]);        }    }}
private static void pdfbox_f631_0()
{    System.err.println("Usage: java " + RemoveFirstPage.class.getName() + " <input-pdf> <output-pdf>");}
public static void pdfbox_f632_0(String[] args) throws IOException
{    PDDocument doc = null;    try {        if (args.length != 2) {            usage();        } else {            doc = PDDocument.load(new File(args[0]));            int pageNum = 0;            for (PDPage page : doc.getPages()) {                pageNum++;                List<PDAnnotation> annotations = page.getAnnotations();                for (PDAnnotation annotation : annotations) {                    PDAnnotation annot = annotation;                    if (annot instanceof PDAnnotationLink) {                        PDAnnotationLink link = (PDAnnotationLink) annot;                        PDAction action = link.getAction();                        if (action instanceof PDActionURI) {                            PDActionURI uri = (PDActionURI) action;                            String oldURI = uri.getURI();                            String newURI = "http://pdfbox.apache.org";                            System.out.println("Page " + pageNum + ": Replacing " + oldURI + " with " + newURI);                            uri.setURI(newURI);                        }                    }                }            }            doc.save(args[1]);        }    } finally {        if (doc != null) {            doc.close();        }    }}
private static void pdfbox_f633_0()
{    System.err.println("usage: " + ReplaceURLs.class.getName() + " <input-file> <output-file>");}
public static void pdfbox_f634_0(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            for (PDPage page : document.getPages()) {                List<PDAnnotation> annotations = page.getAnnotations();                PDAnnotationRubberStamp rs = new PDAnnotationRubberStamp();                rs.setName(PDAnnotationRubberStamp.NAME_TOP_SECRET);                rs.setRectangle(new PDRectangle(100, 100));                rs.setContents("A top secret note");                annotations.add(rs);            }            document.save(args[1]);        }    }}
private static void pdfbox_f635_0()
{    System.err.println("Usage: java " + RubberStamp.class.getName() + " <input-pdf> <output-pdf>");}
public void pdfbox_f636_0(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                throw new IOException("Encrypted documents are not supported for this example");            }            for (int i = 0; i < document.getNumberOfPages(); i++) {                PDPage page = document.getPage(i);                List<PDAnnotation> annotations = page.getAnnotations();                PDAnnotationRubberStamp rubberStamp = new PDAnnotationRubberStamp();                rubberStamp.setName(PDAnnotationRubberStamp.NAME_TOP_SECRET);                rubberStamp.setRectangle(new PDRectangle(200, 100));                rubberStamp.setContents("A top secret note");                                                                PDImageXObject ximage = PDImageXObject.createFromFile(args[2], document);                                int lowerLeftX = 250;                int lowerLeftY = 550;                int formWidth = 150;                int formHeight = 25;                int imgWidth = 50;                int imgHeight = 25;                PDRectangle rect = new PDRectangle();                rect.setLowerLeftX(lowerLeftX);                rect.setLowerLeftY(lowerLeftY);                rect.setUpperRightX(lowerLeftX + formWidth);                rect.setUpperRightY(lowerLeftY + formHeight);                                PDFormXObject form = new PDFormXObject(document);                form.setResources(new PDResources());                form.setBBox(rect);                form.setFormType(1);                                try (OutputStream os = form.getStream().createOutputStream()) {                    drawXObject(ximage, form.getResources(), os, lowerLeftX, lowerLeftY, imgWidth, imgHeight);                }                PDAppearanceStream myDic = new PDAppearanceStream(form.getCOSObject());                PDAppearanceDictionary appearance = new PDAppearanceDictionary(new COSDictionary());                appearance.setNormalAppearance(myDic);                rubberStamp.setAppearance(appearance);                rubberStamp.setRectangle(rect);                                annotations.add(rubberStamp);            }            document.save(args[1]);        }    }}
private void pdfbox_f637_0(PDImageXObject xobject, PDResources resources, OutputStream os, float x, float y, float width, float height) throws IOException
{        COSName xObjectId = resources.add(xobject);    appendRawCommands(os, SAVE_GRAPHICS_STATE);    appendRawCommands(os, formatDecimal.format(width));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(0));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(0));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(height));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(x));    appendRawCommands(os, SPACE);    appendRawCommands(os, formatDecimal.format(y));    appendRawCommands(os, SPACE);    appendRawCommands(os, CONCATENATE_MATRIX);    appendRawCommands(os, SPACE);    appendRawCommands(os, "/");    appendRawCommands(os, xObjectId.getName());    appendRawCommands(os, SPACE);    appendRawCommands(os, XOBJECT_DO);    appendRawCommands(os, SPACE);    appendRawCommands(os, RESTORE_GRAPHICS_STATE);}
private void pdfbox_f638_0(OutputStream os, String commands) throws IOException
{    os.write(commands.getBytes("ISO-8859-1"));}
public static void pdfbox_f639_0(String[] args) throws IOException
{    RubberStampWithImage rubberStamp = new RubberStampWithImage();    rubberStamp.doIt(args);}
private void pdfbox_f640_0()
{    System.err.println("Usage: java " + getClass().getName() + " <input-pdf> <output-pdf> <image-filename>");}
public static void pdfbox_f641_0(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("usage: " + ShowColorBoxes.class.getName() + " <output-file>");        System.exit(1);    }    String filename = args[0];    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                        contents.setNonStrokingColor(Color.CYAN);            contents.addRect(0, 0, page.getMediaBox().getWidth(), page.getMediaBox().getHeight());            contents.fill();                        contents.setNonStrokingColor(Color.RED);            contents.addRect(10, 10, 100, 100);            contents.fill();        }        doc.save(filename);    }}
public static void pdfbox_f642_0(String[] args) throws IOException
{    doIt("Hello World, this is a test!", "justify-example.pdf");}
public static void pdfbox_f643_0(String message, String outfile) throws IOException
{        try (PDDocument doc = new PDDocument();        InputStream is = PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf")) {                PDFont font = PDType0Font.load(doc, is, true);        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);                float stringWidth = font.getStringWidth(message) * FONT_SIZE;                float stringHeight = font.getFontDescriptor().getFontBoundingBox().getHeight() * FONT_SIZE;                PDRectangle pageSize = page.getMediaBox();        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            contentStream.beginText();            contentStream.setFont(font, FONT_SIZE);                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f));                        contentStream.showText(message);                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 2));                                    float justifyWidth = pageSize.getWidth() * 1000f - stringWidth;            List<Object> text = new ArrayList<>();            String[] parts = message.split("\\s");            float spaceWidth = (justifyWidth / (parts.length - 1)) / FONT_SIZE;            for (int i = 0; i < parts.length; i++) {                if (i != 0) {                    text.add(" ");                                        text.add(-spaceWidth);                }                text.add(parts[i]);            }            contentStream.showTextWithPositioning(text.toArray());            contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 3));                        text = new ArrayList<>();            justifyWidth = pageSize.getWidth() * 1000f - stringWidth;            float extraLetterWidth = (justifyWidth / (message.codePointCount(0, message.length()) - 1)) / FONT_SIZE;            for (int i = 0; i < message.length(); i += Character.charCount(message.codePointAt(i))) {                if (i != 0) {                    text.add(-extraLetterWidth);                }                text.add(String.valueOf(Character.toChars(message.codePointAt(i))));            }            contentStream.showTextWithPositioning(text.toArray());                                                                                    contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 4));            font = PDTrueTypeFont.load(doc, PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"), WinAnsiEncoding.INSTANCE);            contentStream.setFont(font, FONT_SIZE);            contentStream.showText(message);            float wordSpacing = (pageSize.getWidth() * 1000f - stringWidth) / (parts.length - 1) / 1000;                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 5));            font = PDTrueTypeFont.load(doc, PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"), WinAnsiEncoding.INSTANCE);            contentStream.setFont(font, FONT_SIZE);            contentStream.setWordSpacing(wordSpacing);            contentStream.showText(message);                        contentStream.setTextMatrix(Matrix.getTranslateInstance(0, pageSize.getHeight() - stringHeight / 1000f * 6));            font = PDType0Font.load(doc, PDDocument.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf"));            contentStream.setFont(font, FONT_SIZE);            contentStream.setWordSpacing(wordSpacing);            contentStream.showText(message);                        contentStream.endText();        }        doc.save(outfile);    }}
public static void pdfbox_f644_0(String[] args) throws IOException
{    if (args.length != 2) {        System.err.println("usage: " + SuperimposePage.class.getName() + " <source-pdf> <dest-pdf>");        System.exit(1);    }    String sourcePath = args[0];    String destPath = args[1];    try (PDDocument sourceDoc = PDDocument.load(new File(sourcePath))) {        int sourcePage = 1;                try (PDDocument doc = new PDDocument()) {            PDPage page = new PDPage();            doc.addPage(page);                        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {                contents.beginText();                contents.setFont(PDType1Font.HELVETICA_BOLD, 12);                contents.newLineAtOffset(2, PDRectangle.LETTER.getHeight() - 12);                contents.showText("Sample text");                contents.endText();                                LayerUtility layerUtility = new LayerUtility(doc);                PDFormXObject form = layerUtility.importPageAsForm(sourceDoc, sourcePage - 1);                                contents.drawForm(form);                                contents.saveGraphicsState();                Matrix matrix = Matrix.getScaleInstance(0.5f, 0.5f);                contents.transform(matrix);                contents.drawForm(form);                contents.restoreGraphicsState();                                contents.saveGraphicsState();                                matrix.rotate(1.8 * Math.PI);                contents.transform(matrix);                contents.drawForm(form);                contents.restoreGraphicsState();            }            doc.save(destPath);        }    }}
public void pdfbox_f645_0(String message, String outfile) throws IOException
{        try (PDDocument doc = new PDDocument()) {                PDFont font = PDType1Font.HELVETICA;        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        float fontSize = 12.0f;        PDRectangle pageSize = page.getMediaBox();        float centeredXPosition = (pageSize.getWidth() - fontSize / 1000f) / 2f;        float stringWidth = font.getStringWidth(message);        float centeredYPosition = (pageSize.getHeight() - (stringWidth * fontSize) / 1000f) / 3f;        PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        contentStream.setFont(font, fontSize);        contentStream.beginText();                for (int i = 0; i < 8; i++) {            contentStream.setTextMatrix(Matrix.getRotateInstance(i * Math.PI * 0.25, centeredXPosition, pageSize.getHeight() - centeredYPosition));            contentStream.showText(message + " " + i);        }                for (int i = 0; i < 8; i++) {            contentStream.setTextMatrix(Matrix.getRotateInstance(-i * Math.PI * 0.25, centeredXPosition, centeredYPosition));            contentStream.showText(message + " " + i);        }        contentStream.endText();        contentStream.close();                page = new PDPage(PDRectangle.A4);        doc.addPage(page);        fontSize = 1.0f;        contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        contentStream.setFont(font, fontSize);        contentStream.beginText();                for (int i = 0; i < 10; i++) {            contentStream.setTextMatrix(new Matrix(12 + (i * 6), 0, 0, 12 + (i * 6), 100, 100 + i * 50));            contentStream.showText(message + " " + i);        }        contentStream.endText();        contentStream.close();                page = new PDPage(PDRectangle.A4);        doc.addPage(page);        fontSize = 1.0f;        contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        contentStream.setFont(font, fontSize);        contentStream.beginText();        int i = 0;                contentStream.setTextMatrix(new Matrix(12, 0, 0, 12, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.setTextMatrix(new Matrix(0, 18, -18, 0, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.setTextMatrix(new Matrix(-24, 0, 0, -24, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.setTextMatrix(new Matrix(0, -30, 30, 0, centeredXPosition, centeredYPosition * 1.5f));        contentStream.showText(message + " " + i++);        contentStream.endText();        contentStream.close();        doc.save(outfile);    }}
public static void pdfbox_f646_0(String[] args) throws IOException
{    UsingTextMatrix app = new UsingTextMatrix();    if (args.length != 2) {        app.usage();    } else {        app.doIt(args[0], args[1]);    }}
private void pdfbox_f647_0()
{    System.err.println("usage: " + this.getClass().getName() + " <Message> <output-file>");}
public static void pdfbox_f648_0(String[] args) throws PrinterException, IOException
{    if (args.length != 1) {        System.err.println("usage: java " + Printing.class.getName() + " <input>");        System.exit(1);    }    String filename = args[0];    try (PDDocument document = PDDocument.load(new File(filename))) {                print(document);                    }}
private static void pdfbox_f649_0(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    job.print();}
private static void pdfbox_f650_0(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();        attr.add(new PageRanges(1, 1));    job.print(attr);}
private static void pdfbox_f651_0(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    if (job.printDialog()) {        job.print();    }}
private static void pdfbox_f652_0(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));    PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();        attr.add(new PageRanges(1, 1));    PDViewerPreferences vp = document.getDocumentCatalog().getViewerPreferences();    if (vp != null && vp.getDuplex() != null) {        String dp = vp.getDuplex();        if (PDViewerPreferences.DUPLEX.DuplexFlipLongEdge.toString().equals(dp)) {            attr.add(Sides.TWO_SIDED_LONG_EDGE);        } else if (PDViewerPreferences.DUPLEX.DuplexFlipShortEdge.toString().equals(dp)) {            attr.add(Sides.TWO_SIDED_SHORT_EDGE);        } else if (PDViewerPreferences.DUPLEX.Simplex.toString().equals(dp)) {            attr.add(Sides.ONE_SIDED);        }    }    if (job.printDialog(attr)) {        job.print(attr);    }}
private static void pdfbox_f653_0(PDDocument document) throws IOException, PrinterException
{    PrinterJob job = PrinterJob.getPrinterJob();    job.setPageable(new PDFPageable(document));        Paper paper = new Paper();        paper.setSize(306, 396);        paper.setImageableArea(0, 0, paper.getWidth(), paper.getHeight());        PageFormat pageFormat = new PageFormat();    pageFormat.setPaper(paper);        Book book = new Book();        book.append(new PDFPrintable(document), pageFormat, document.getNumberOfPages());    job.setPageable(book);    job.print();}
public static void pdfbox_f654_0(String[] args) throws IOException
{    File file = new File("src/main/resources/org/apache/pdfbox/examples/rendering/", "custom-render-demo.pdf");    try (PDDocument doc = PDDocument.load(file)) {        PDPage page = doc.getPage(0);        CustomGraphicsStreamEngine engine = new CustomGraphicsStreamEngine(page);        engine.run();    }}
public void pdfbox_f655_0() throws IOException
{    processPage(getPage());    for (PDAnnotation annotation : getPage().getAnnotations()) {        showAnnotation(annotation);    }}
public void pdfbox_f656_0(Point2D p0, Point2D p1, Point2D p2, Point2D p3) throws IOException
{    System.out.printf("appendRectangle %.2f %.2f, %.2f %.2f, %.2f %.2f, %.2f %.2f\n", p0.getX(), p0.getY(), p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());}
public void pdfbox_f657_0(PDImage pdImage) throws IOException
{    System.out.println("drawImage");}
public void pdfbox_f658_0(int windingRule) throws IOException
{    System.out.println("clip");}
public void pdfbox_f659_0(float x, float y) throws IOException
{    System.out.printf("moveTo %.2f %.2f\n", x, y);}
public void pdfbox_f660_0(float x, float y) throws IOException
{    System.out.printf("lineTo %.2f %.2f\n", x, y);}
public void pdfbox_f661_0(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{    System.out.printf("curveTo %.2f %.2f, %.2f %.2f, %.2f %.2f\n", x1, y1, x2, y2, x3, y3);}
public Point2D pdfbox_f662_0() throws IOException
{        return new Point2D.Float(0, 0);}
public void pdfbox_f663_0() throws IOException
{    System.out.println("closePath");}
public void pdfbox_f664_0() throws IOException
{    System.out.println("endPath");}
public void pdfbox_f665_0() throws IOException
{    System.out.println("strokePath");}
public void pdfbox_f666_0(int windingRule) throws IOException
{    System.out.println("fillPath");}
public void pdfbox_f667_0(int windingRule) throws IOException
{    System.out.println("fillAndStrokePath");}
public void pdfbox_f668_0(COSName shadingName) throws IOException
{    System.out.println("shadingFill " + shadingName.toString());}
public void pdfbox_f669_0(byte[] string) throws IOException
{    System.out.print("showTextString \"");    super.showTextString(string);    System.out.println("\"");}
public void pdfbox_f670_0(COSArray array) throws IOException
{    System.out.print("showTextStrings \"");    super.showTextStrings(array);    System.out.println("\"");}
protected void pdfbox_f671_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    System.out.print(unicode);    super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);}
public static void pdfbox_f672_0(String[] args) throws IOException
{    File file = new File("src/main/resources/org/apache/pdfbox/examples/rendering/", "custom-render-demo.pdf");    try (PDDocument doc = PDDocument.load(file)) {        PDFRenderer renderer = new MyPDFRenderer(doc);        BufferedImage image = renderer.renderImage(0);        ImageIO.write(image, "PNG", new File("custom-render.png"));    }}
protected PageDrawer pdfbox_f673_0(PageDrawerParameters parameters) throws IOException
{    return new MyPageDrawer(parameters);}
protected Paint pdfbox_f674_0(PDColor color) throws IOException
{        if (getGraphicsState().getNonStrokingColor() == color) {                if (color.toRGB() == (Color.RED.getRGB() & 0x00FFFFFF)) {                        return Color.BLUE;        }    }    return super.getPaint(color);}
protected void pdfbox_f675_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{        super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);        Shape bbox = new Rectangle2D.Float(0, 0, font.getWidth(code) / 1000, 1);    AffineTransform at = textRenderingMatrix.createAffineTransform();    bbox = at.createTransformedShape(bbox);        Graphics2D graphics = getGraphics();    Color color = graphics.getColor();    Stroke stroke = graphics.getStroke();    Shape clip = graphics.getClip();        graphics.setClip(graphics.getDeviceConfiguration().getBounds());    graphics.setColor(Color.RED);    graphics.setStroke(new BasicStroke(.5f));    graphics.draw(bbox);        graphics.setStroke(stroke);    graphics.setColor(color);    graphics.setClip(clip);}
public void pdfbox_f676_0(int windingRule) throws IOException
{        Shape bbox = getLinePath().getBounds2D();        super.fillPath(windingRule);        Graphics2D graphics = getGraphics();    Color color = graphics.getColor();    Stroke stroke = graphics.getStroke();    Shape clip = graphics.getClip();        graphics.setClip(graphics.getDeviceConfiguration().getBounds());    graphics.setColor(Color.GREEN);    graphics.setStroke(new BasicStroke(.5f));    graphics.draw(bbox);        graphics.setStroke(stroke);    graphics.setColor(color);    graphics.setClip(clip);}
public void pdfbox_f677_0(PDAnnotation annotation) throws IOException
{        saveGraphicsState();        getGraphicsState().setNonStrokeAlphaConstant(0.35);    super.showAnnotation(annotation);        restoreGraphicsState();}
public boolean pdfbox_f678_0()
{    return valid;}
public PKIXCertPathBuilderResult pdfbox_f679_0()
{    return result;}
public Throwable pdfbox_f680_0()
{    return exception;}
public static PKIXCertPathBuilderResult pdfbox_f681_1(X509Certificate cert, Set<X509Certificate> additionalCerts, boolean verifySelfSignedCert, Date signDate) throws CertificateVerificationException
{    try {                if (!verifySelfSignedCert && isSelfSigned(cert)) {            throw new CertificateVerificationException("The certificate is self-signed.");        }        Set<X509Certificate> certSet = CertificateVerifier.downloadExtraCertificates(cert);        int downloadSize = certSet.size();        certSet.addAll(additionalCerts);        if (downloadSize > 0) {                    }                        Set<X509Certificate> intermediateCerts = new HashSet<>();        Set<TrustAnchor> trustAnchors = new HashSet<>();        for (X509Certificate additionalCert : certSet) {            if (isSelfSigned(additionalCert)) {                trustAnchors.add(new TrustAnchor(additionalCert, null));            } else {                intermediateCerts.add(additionalCert);            }        }        if (trustAnchors.isEmpty()) {            throw new CertificateVerificationException("No root certificate in the chain");        }                PKIXCertPathBuilderResult verifiedCertChain = verifyCertificate(cert, trustAnchors, intermediateCerts, signDate);                checkRevocations(cert, certSet, signDate);        return verifiedCertChain;    } catch (CertPathBuilderException certPathEx) {        throw new CertificateVerificationException("Error building certification path: " + cert.getSubjectX500Principal(), certPathEx);    } catch (CertificateVerificationException cvex) {        throw cvex;    } catch (IOException | GeneralSecurityException | RevokedCertificateException | OCSPException ex) {        throw new CertificateVerificationException("Error verifying the certificate: " + cert.getSubjectX500Principal(), ex);    }}
private static void pdfbox_f682_1(X509Certificate cert, Set<X509Certificate> additionalCerts, Date signDate) throws IOException, CertificateVerificationException, OCSPException, RevokedCertificateException, GeneralSecurityException
{    if (isSelfSigned(cert)) {                return;    }    X509Certificate issuerCert = null;    for (X509Certificate additionalCert : additionalCerts) {        if (cert.getIssuerX500Principal().equals(additionalCert.getSubjectX500Principal())) {            issuerCert = additionalCert;            break;        }    }                String ocspURL = extractOCSPURL(cert);    if (ocspURL != null) {        OcspHelper ocspHelper = new OcspHelper(cert, signDate, issuerCert, additionalCerts, ocspURL);        try {            verifyOCSP(ocspHelper, additionalCerts);        } catch (IOException ex) {                                    CRLVerifier.verifyCertificateCRLs(cert, signDate, additionalCerts);        }    } else {                                CRLVerifier.verifyCertificateCRLs(cert, signDate, additionalCerts);    }        checkRevocations(issuerCert, additionalCerts, signDate);}
public static boolean pdfbox_f683_1(X509Certificate cert) throws GeneralSecurityException
{    try {                PublicKey key = cert.getPublicKey();        cert.verify(key, SecurityProvider.getProvider().getName());        return true;    } catch (SignatureException | InvalidKeyException | IOException ex) {                        return false;    }}
public static Set<X509Certificate> pdfbox_f684_1(X509Extension ext)
{                Set<X509Certificate> resultSet = new HashSet<>();    byte[] authorityExtensionValue = ext.getExtensionValue(Extension.authorityInfoAccess.getId());    if (authorityExtensionValue == null) {        return resultSet;    }    ASN1Primitive asn1Prim;    try {        asn1Prim = JcaX509ExtensionUtils.parseExtensionValue(authorityExtensionValue);    } catch (IOException ex) {                return resultSet;    }    if (!(asn1Prim instanceof ASN1Sequence)) {                return resultSet;    }    ASN1Sequence asn1Seq = (ASN1Sequence) asn1Prim;    Enumeration<?> objects = asn1Seq.getObjects();    while (objects.hasMoreElements()) {                ASN1Sequence obj = (ASN1Sequence) objects.nextElement();        ASN1Encodable oid = obj.getObjectAt(0);        if (!X509ObjectIdentifiers.id_ad_caIssuers.equals(oid)) {            continue;        }        ASN1TaggedObject location = (ASN1TaggedObject) obj.getObjectAt(1);        ASN1OctetString uri = (ASN1OctetString) location.getObject();        InputStream in = null;        try {            String urlString = new String(uri.getOctets());                        in = new URL(urlString).openStream();            CertificateFactory certFactory = CertificateFactory.getInstance("X.509");            Collection<? extends Certificate> altCerts = certFactory.generateCertificates(in);            altCerts.forEach(altCert -> resultSet.add((X509Certificate) altCert));                    } catch (IOException | CertificateException ex) {                    } finally {            IOUtils.closeQuietly(in);        }    }        return resultSet;}
private static PKIXCertPathBuilderResult pdfbox_f685_0(X509Certificate cert, Set<TrustAnchor> trustAnchors, Set<X509Certificate> intermediateCerts, Date signDate) throws GeneralSecurityException
{        X509CertSelector selector = new X509CertSelector();    selector.setCertificate(cert);        PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(trustAnchors, selector);        pkixParams.setRevocationEnabled(false);                            pkixParams.setPolicyQualifiersRejected(false);                pkixParams.setDate(signDate);        CertStore intermediateCertStore = CertStore.getInstance("Collection", new CollectionCertStoreParameters(intermediateCerts));    pkixParams.addCertStore(intermediateCertStore);                        CertPathBuilder builder = CertPathBuilder.getInstance("PKIX");    return (PKIXCertPathBuilderResult) builder.build(pkixParams);}
private static String pdfbox_f686_1(X509Certificate cert) throws IOException
{    byte[] authorityExtensionValue = cert.getExtensionValue(Extension.authorityInfoAccess.getId());    if (authorityExtensionValue != null) {                        ASN1Sequence asn1Seq = (ASN1Sequence) JcaX509ExtensionUtils.parseExtensionValue(authorityExtensionValue);        Enumeration<?> objects = asn1Seq.getObjects();        while (objects.hasMoreElements()) {                        ASN1Sequence obj = (ASN1Sequence) objects.nextElement();            ASN1Encodable oid = obj.getObjectAt(0);                        ASN1TaggedObject location = (ASN1TaggedObject) obj.getObjectAt(1);            if (X509ObjectIdentifiers.id_ad_ocsp.equals(oid) && location.getTagNo() == GeneralName.uniformResourceIdentifier) {                ASN1OctetString url = (ASN1OctetString) location.getObject();                String ocspURL = new String(url.getOctets());                                return ocspURL;            }        }    }    return null;}
private static void pdfbox_f687_1(OcspHelper ocspHelper, Set<X509Certificate> additionalCerts) throws RevokedCertificateException, IOException, OCSPException, CertificateVerificationException
{    Date now = Calendar.getInstance().getTime();    OCSPResp ocspResponse;    ocspResponse = ocspHelper.getResponseOcsp();    if (ocspResponse.getStatus() != OCSPResp.SUCCESSFUL) {        throw new CertificateVerificationException("OCSP check not successful, status: " + ocspResponse.getStatus());    }        BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResponse.getResponseObject();    X509Certificate ocspResponderCertificate = ocspHelper.getOcspResponderCertificate();    if (ocspResponderCertificate.getExtensionValue(OCSPObjectIdentifiers.id_pkix_ocsp_nocheck.getId()) != null) {                                                return;    }        Set<X509Certificate> additionalCerts2 = new HashSet<>(additionalCerts);    JcaX509CertificateConverter certificateConverter = new JcaX509CertificateConverter();    for (X509CertificateHolder certHolder : basicResponse.getCerts()) {        try {            X509Certificate cert = certificateConverter.getCertificate(certHolder);            if (!ocspResponderCertificate.equals(cert)) {                additionalCerts2.add(cert);            }        } catch (CertificateException ex) {                                }    }    CertificateVerifier.verifyCertificate(ocspResponderCertificate, additionalCerts2, true, now);    }
public static void pdfbox_f688_1(X509Certificate cert, Date signDate, Set<X509Certificate> additionalCerts) throws CertificateVerificationException, RevokedCertificateException
{    try {        Date now = Calendar.getInstance().getTime();        Exception firstException = null;        List<String> crlDistributionPointsURLs = getCrlDistributionPoints(cert);        for (String crlDistributionPointsURL : crlDistributionPointsURLs) {                        X509CRL crl;            try {                crl = downloadCRL(crlDistributionPointsURL);            } catch (IOException | GeneralSecurityException | CertificateVerificationException | NamingException ex) {                                                                if (firstException == null) {                    firstException = ex;                }                continue;            }            Set<X509Certificate> mergedCertSet = CertificateVerifier.downloadExtraCertificates(crl);            mergedCertSet.addAll(additionalCerts);                                                X509Certificate crlIssuerCert = null;            for (X509Certificate possibleCert : mergedCertSet) {                if (crl.getIssuerX500Principal().equals(possibleCert.getSubjectX500Principal())) {                    crlIssuerCert = possibleCert;                    break;                }            }            if (crlIssuerCert == null) {                throw new CertificateVerificationException("Certificate for " + crl.getIssuerX500Principal() + "not found in certificate chain, so the CRL at " + crlDistributionPointsURL + " could not be verified");            }            crl.verify(crlIssuerCert.getPublicKey(), SecurityProvider.getProvider().getName());            if (!crl.getIssuerX500Principal().equals(cert.getIssuerX500Principal())) {                                CertificateVerifier.verifyCertificate(crlIssuerCert, mergedCertSet, true, now);                            } else {                            }            checkRevocation(crl, cert, signDate, crlDistributionPointsURL);                        return;        }        if (firstException != null) {            throw firstException;        }    } catch (RevokedCertificateException | CertificateVerificationException ex) {        throw ex;    } catch (Exception ex) {        throw new CertificateVerificationException("Cannot verify CRL for certificate: " + cert.getSubjectX500Principal(), ex);    }}
public static void pdfbox_f689_1(X509CRL crl, X509Certificate cert, Date signDate, String crlDistributionPointsURL) throws RevokedCertificateException
{    X509CRLEntry revokedCRLEntry = crl.getRevokedCertificate(cert);    if (revokedCRLEntry != null && revokedCRLEntry.getRevocationDate().compareTo(signDate) <= 0) {        throw new RevokedCertificateException("The certificate was revoked by CRL " + crlDistributionPointsURL + " on " + revokedCRLEntry.getRevocationDate(), revokedCRLEntry.getRevocationDate());    } else if (revokedCRLEntry != null) {            } else {            }}
private static X509CRL pdfbox_f690_0(String crlURL) throws IOException, CertificateException, CRLException, CertificateVerificationException, NamingException
{    if (crlURL.startsWith("http://") || crlURL.startsWith("https://") || crlURL.startsWith("ftp://")) {        return downloadCRLFromWeb(crlURL);    } else if (crlURL.startsWith("ldap://")) {        return downloadCRLFromLDAP(crlURL);    } else {        throw new CertificateVerificationException("Can not download CRL from certificate " + "distribution point: " + crlURL);    }}
private static X509CRL pdfbox_f691_0(String ldapURL) throws CertificateException, NamingException, CRLException, CertificateVerificationException
{    @SuppressWarnings({ "squid:S1149" })    Hashtable<String, String> env = new Hashtable<>();    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");    env.put(Context.PROVIDER_URL, ldapURL);            env.put("com.sun.jndi.ldap.connect.timeout", "1000");    DirContext ctx = new InitialDirContext(env);    Attributes avals = ctx.getAttributes("");    Attribute aval = avals.get("certificateRevocationList;binary");    byte[] val = (byte[]) aval.get();    if (val == null || val.length == 0) {        throw new CertificateVerificationException("Can not download CRL from: " + ldapURL);    } else {        InputStream inStream = new ByteArrayInputStream(val);        CertificateFactory cf = CertificateFactory.getInstance("X.509");        return (X509CRL) cf.generateCRL(inStream);    }}
public static X509CRL pdfbox_f692_0(String crlURL) throws IOException, CertificateException, CRLException
{    try (InputStream crlStream = new URL(crlURL).openStream()) {        return (X509CRL) CertificateFactory.getInstance("X.509").generateCRL(crlStream);    }}
public static List<String> pdfbox_f693_0(X509Certificate cert) throws IOException
{    byte[] crldpExt = cert.getExtensionValue(Extension.cRLDistributionPoints.getId());    if (crldpExt == null) {        return new ArrayList<>();    }    ASN1InputStream oAsnInStream = new ASN1InputStream(new ByteArrayInputStream(crldpExt));    ASN1Primitive derObjCrlDP = oAsnInStream.readObject();    ASN1OctetString dosCrlDP = (ASN1OctetString) derObjCrlDP;    byte[] crldpExtOctets = dosCrlDP.getOctets();    ASN1InputStream oAsnInStream2 = new ASN1InputStream(new ByteArrayInputStream(crldpExtOctets));    ASN1Primitive derObj2 = oAsnInStream2.readObject();    CRLDistPoint distPoint = CRLDistPoint.getInstance(derObj2);    List<String> crlUrls = new ArrayList<>();    for (DistributionPoint dp : distPoint.getDistributionPoints()) {        DistributionPointName dpn = dp.getDistributionPoint();                if (dpn != null && dpn.getType() == DistributionPointName.FULL_NAME) {                        for (GeneralName genName : GeneralNames.getInstance(dpn.getName()).getNames()) {                if (genName.getTagNo() == GeneralName.uniformResourceIdentifier) {                    String url = DERIA5String.getInstance(genName.getName()).getString();                    crlUrls.add(url);                }            }        }    }    return crlUrls;}
public OCSPResp pdfbox_f694_0() throws IOException, OCSPException, RevokedCertificateException
{    OCSPResp ocspResponse = performRequest();    verifyOcspResponse(ocspResponse);    return ocspResponse;}
public X509Certificate pdfbox_f695_0()
{    return ocspResponderCertificate;}
private void pdfbox_f696_1(OCSPResp ocspResponse) throws OCSPException, RevokedCertificateException, IOException
{    verifyRespStatus(ocspResponse);    BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResponse.getResponseObject();    if (basicResponse != null) {        ResponderID responderID = basicResponse.getResponderId().toASN1Primitive();                                                                                X500Name name = responderID.getName();        if (name != null) {            findResponderCertificateByName(basicResponse, name);        } else {            byte[] keyHash = responderID.getKeyHash();            if (keyHash != null) {                findResponderCertificateByKeyHash(basicResponse, keyHash);            } else {                throw new OCSPException("OCSP: basic response must provide name or key hash");            }        }        if (ocspResponderCertificate == null) {            throw new OCSPException("OCSP: certificate for responder " + name + " not found");        }        try {            SigUtils.checkResponderCertificateUsage(ocspResponderCertificate);        } catch (CertificateParsingException ex) {                                }        checkOcspSignature(ocspResponderCertificate, basicResponse);        boolean nonceChecked = checkNonce(basicResponse);        SingleResp[] responses = basicResponse.getResponses();        if (responses.length != 1) {            throw new OCSPException("OCSP: Received " + responses.length + " responses instead of 1!");        }        SingleResp resp = responses[0];        Object status = resp.getCertStatus();        if (!nonceChecked) {                                    checkOcspResponseFresh(resp);        }        if (status instanceof RevokedStatus) {            RevokedStatus revokedStatus = (RevokedStatus) status;            if (revokedStatus.getRevocationTime().compareTo(signDate) <= 0) {                throw new RevokedCertificateException("OCSP: Certificate is revoked since " + revokedStatus.getRevocationTime(), revokedStatus.getRevocationTime());            }                    } else if (status != CertificateStatus.GOOD) {            throw new OCSPException("OCSP: Status of Cert is unknown");        }    }}
private byte[] pdfbox_f697_1(X509CertificateHolder certHolder) throws IOException
{                                    SubjectPublicKeyInfo info = certHolder.getSubjectPublicKeyInfo();    try {        return MessageDigest.getInstance("SHA-1").digest(info.getPublicKeyData().getBytes());    } catch (NoSuchAlgorithmException ex) {                        return new byte[0];    }}
private void pdfbox_f698_1(BasicOCSPResp basicResponse, byte[] keyHash) throws IOException
{    X509CertificateHolder[] certHolders = basicResponse.getCerts();    for (X509CertificateHolder certHolder : certHolders) {        byte[] digest = getKeyHashFromCertHolder(certHolder);        if (Arrays.equals(keyHash, digest)) {            try {                ocspResponderCertificate = certificateConverter.getCertificate(certHolder);                return;            } catch (CertificateException ex) {                                            }            break;        }    }        for (X509Certificate cert : additionalCerts) {        try {            byte[] digest = getKeyHashFromCertHolder(new X509CertificateHolder(cert.getEncoded()));            if (Arrays.equals(keyHash, digest)) {                ocspResponderCertificate = cert;                return;            }        } catch (CertificateException ex) {                                }    }}
private void pdfbox_f699_1(BasicOCSPResp basicResponse, X500Name name)
{    X509CertificateHolder[] certHolders = basicResponse.getCerts();    for (X509CertificateHolder certHolder : certHolders) {        if (name.equals(certHolder.getSubject())) {            try {                ocspResponderCertificate = certificateConverter.getCertificate(certHolder);                return;            } catch (CertificateException ex) {                                            }        }    }        for (X509Certificate cert : additionalCerts) {        X500Name certSubjectName = new X500Name(cert.getSubjectX500Principal().getName());        if (certSubjectName.equals(name)) {            ocspResponderCertificate = cert;            return;        }    }}
private void pdfbox_f700_1(SingleResp resp) throws OCSPException
{                        Date curDate = Calendar.getInstance().getTime();    Date thisUpdate = resp.getThisUpdate();    if (thisUpdate == null) {        throw new OCSPException("OCSP: thisUpdate field is missing in response (RFC 5019 2.2.4.)");    }    Date nextUpdate = resp.getNextUpdate();    if (nextUpdate == null) {        throw new OCSPException("OCSP: nextUpdate field is missing in response (RFC 5019 2.2.4.)");    }    if (curDate.compareTo(thisUpdate) < 0) {                throw new OCSPException("OCSP: current date < thisUpdate field (RFC 5019 2.2.4.)");    }    if (curDate.compareTo(nextUpdate) > 0) {                throw new OCSPException("OCSP: current date > nextUpdate field (RFC 5019 2.2.4.)");    }    }
private void pdfbox_f701_0(X509Certificate certificate, BasicOCSPResp basicResponse) throws OCSPException, IOException
{    try {        ContentVerifierProvider verifier = new JcaContentVerifierProviderBuilder().setProvider(SecurityProvider.getProvider()).build(certificate);        if (!basicResponse.isSignatureValid(verifier)) {            throw new OCSPException("OCSP-Signature is not valid!");        }    } catch (OperatorCreationException e) {        throw new OCSPException("Error checking Ocsp-Signature", e);    }}
private boolean pdfbox_f702_1(BasicOCSPResp basicResponse) throws OCSPException
{    Extension nonceExt = basicResponse.getExtension(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);    if (nonceExt != null) {        DEROctetString responseNonceString = (DEROctetString) nonceExt.getExtnValue();        if (!responseNonceString.equals(encodedNonce)) {            throw new OCSPException("Different nonce found in response!");        } else {                        return true;        }    }        return false;}
private OCSPResp pdfbox_f703_0() throws IOException, OCSPException
{    OCSPReq request = generateOCSPRequest();    URL url = new URL(ocspUrl);    HttpURLConnection httpConnection = (HttpURLConnection) url.openConnection();    try {        httpConnection.setRequestProperty("Content-Type", "application/ocsp-request");        httpConnection.setRequestProperty("Accept", "application/ocsp-response");        httpConnection.setDoOutput(true);        try (OutputStream out = httpConnection.getOutputStream()) {            out.write(request.getEncoded());        }        if (httpConnection.getResponseCode() != 200) {            throw new IOException("OCSP: Could not access url, ResponseCode: " + httpConnection.getResponseCode());        }                try (InputStream in = (InputStream) httpConnection.getContent()) {            return new OCSPResp(in);        }    } finally {        httpConnection.disconnect();    }}
public void pdfbox_f704_1(OCSPResp resp) throws OCSPException
{    String statusInfo = "";    if (resp != null) {        int status = resp.getStatus();        switch(status) {            case OCSPResponseStatus.INTERNAL_ERROR:                statusInfo = "INTERNAL_ERROR";                                break;            case OCSPResponseStatus.MALFORMED_REQUEST:                                                statusInfo = "MALFORMED_REQUEST";                                break;            case OCSPResponseStatus.SIG_REQUIRED:                statusInfo = "SIG_REQUIRED";                                break;            case OCSPResponseStatus.TRY_LATER:                statusInfo = "TRY_LATER";                                break;            case OCSPResponseStatus.UNAUTHORIZED:                statusInfo = "UNAUTHORIZED";                                break;            case OCSPResponseStatus.SUCCESSFUL:                break;            default:                statusInfo = "UNKNOWN";                        }    }    if (resp == null || resp.getStatus() != OCSPResponseStatus.SUCCESSFUL) {        throw new OCSPException("OCSP response unsuccessful, status: " + statusInfo);    }}
private OCSPReq pdfbox_f705_0() throws OCSPException, IOException
{    Security.addProvider(SecurityProvider.getProvider());        CertificateID certId;    try {        certId = new CertificateID(new SHA1DigestCalculator(), new JcaX509CertificateHolder(issuerCertificate), certificateToCheck.getSerialNumber());    } catch (CertificateEncodingException e) {        throw new IOException("Error creating CertificateID with the Certificate encoding", e);    }                Extension responseExtension = new Extension(OCSPObjectIdentifiers.id_pkix_ocsp_response, false, new DLSequence(OCSPObjectIdentifiers.id_pkix_ocsp_basic).getEncoded());    Random rand = new Random();    byte[] nonce = new byte[16];    rand.nextBytes(nonce);    encodedNonce = new DEROctetString(new DEROctetString(nonce));    Extension nonceExtension = new Extension(OCSPObjectIdentifiers.id_pkix_ocsp_nonce, false, encodedNonce);    OCSPReqBuilder builder = new OCSPReqBuilder();    builder.setRequestExtensions(new Extensions(new Extension[] { responseExtension, nonceExtension }));    builder.addRequest(certId);    return builder.build();}
public AlgorithmIdentifier pdfbox_f706_0()
{    return new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1);}
public OutputStream pdfbox_f707_0()
{    return bOut;}
public byte[] pdfbox_f708_1()
{    byte[] bytes = bOut.toByteArray();    bOut.reset();    try {        MessageDigest md = MessageDigest.getInstance("SHA-1");        return md.digest(bytes);    } catch (NoSuchAlgorithmException ex) {                        return new byte[0];    }}
public Date pdfbox_f709_0()
{    return revocationTime;}
public Object pdfbox_f710_0()
{    return in;}
public void pdfbox_f711_0(OutputStream out) throws IOException, CMSException
{        IOUtils.copy(in, out);    in.close();}
public ASN1ObjectIdentifier pdfbox_f712_0()
{    return contentType;}
public void pdfbox_f713_0(File file) throws IOException
{    embedTimeStamp(file, file);}
public void pdfbox_f714_0(File inFile, File outFile) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }        try (PDDocument doc = PDDocument.load(inFile)) {        document = doc;        processTimeStamping(outFile, inFile.getAbsolutePath());    }}
private void pdfbox_f715_0(File outFile, String fileName) throws IOException
{    int accessPermissions = SigUtils.getMDPPermission(document);    if (accessPermissions == 1) {        throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");    }    try {        byte[] documentBytes;        try (FileInputStream fis = new FileInputStream(fileName)) {            documentBytes = IOUtils.toByteArray(fis);        }        processRelevantSignatures(documentBytes);        if (changedEncodedSignature != null) {            try (FileOutputStream output = new FileOutputStream(outFile)) {                embedNewSignatureIntoDocument(documentBytes, output);            }        }    } catch (IOException | NoSuchAlgorithmException | CMSException e) {        throw new IOException(e);    }}
private void pdfbox_f716_0(byte[] documentBytes) throws IOException, CMSException, NoSuchAlgorithmException
{    getRelevantSignature(document);    if (signature != null) {        byte[] sigBlock = signature.getContents(documentBytes);        CMSSignedData signedData = new CMSSignedData(sigBlock);        System.out.println("INFO: Byte Range: " + Arrays.toString(signature.getByteRange()));        if (tsaUrl != null && tsaUrl.length() > 0) {            ValidationTimeStamp validation = new ValidationTimeStamp(tsaUrl);            signedData = validation.addSignedTimeStamp(signedData);        }        byte[] newEncoded = Hex.getBytes(signedData.getEncoded());        int maxSize = signature.getByteRange()[2] - signature.getByteRange()[1];        System.out.println("INFO: New Signature has Size: " + newEncoded.length + " maxSize: " + maxSize);        if (newEncoded.length > maxSize - 2) {            throw new IOException("New Signature is too big for existing Signature-Placeholder. Max Place: " + maxSize);        } else {            changedEncodedSignature = newEncoded;        }    }}
private void pdfbox_f717_0(PDDocument document) throws IOException
{                SortedMap<Integer, PDSignature> sortedMap = new TreeMap<>();    for (PDSignature sig : document.getSignatureDictionaries()) {        int sigOffset = sig.getByteRange()[1];        sortedMap.put(sigOffset, sig);    }    if (sortedMap.size() > 0) {        PDSignature lastSignature = sortedMap.get(sortedMap.lastKey());        COSBase type = lastSignature.getCOSObject().getItem(COSName.TYPE);        if (type.equals(COSName.SIG)) {            signature = lastSignature;        }    }}
private void pdfbox_f718_0(byte[] docBytes, OutputStream output) throws IOException
{    int[] byteRange = signature.getByteRange();    output.write(docBytes, byteRange[0], byteRange[1] + 1);    output.write(changedEncodedSignature);    int addingLength = byteRange[2] - byteRange[1] - 2 - changedEncodedSignature.length;    byte[] zeroes = Hex.getBytes(new byte[(addingLength + 1) / 2]);    output.write(zeroes);    output.write(docBytes, byteRange[2] - 1, byteRange[3] + 1);}
public static void pdfbox_f719_0(String[] args) throws IOException
{    if (args.length != 3) {        usage();        System.exit(1);    }    String tsaUrl = null;    for (int i = 0; i < args.length; i++) {        if ("-tsa".equals(args[i])) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }    }    File inFile = new File(args[0]);    System.out.println("Input File: " + args[0]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_eTs.pdf");    System.out.println("Output File: " + outFile.getAbsolutePath());        CreateEmbeddedTimeStamp signing = new CreateEmbeddedTimeStamp(tsaUrl);    signing.embedTimeStamp(inFile, outFile);}
private static void pdfbox_f720_0()
{    System.err.println("usage: java " + CreateEmbeddedTimeStamp.class.getName() + " " + "<pdf_to_sign>\n" + "mandatory option:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n");}
public static void pdfbox_f721_0(String[] args) throws IOException
{        try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                PDAcroForm acroForm = new PDAcroForm(document);        document.getDocumentCatalog().setAcroForm(acroForm);                acroForm.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        acroForm.setDefaultAppearance(defaultAppearanceString);                        PDSignatureField signatureField = new PDSignatureField(acroForm);        PDAnnotationWidget widget = signatureField.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 650, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);        acroForm.getFields().add(signatureField);        document.save(args[0]);    }}
public void pdfbox_f722_0(File file) throws IOException
{    signDetached(file, file, null);}
public void pdfbox_f723_0(File inFile, File outFile) throws IOException
{    signDetached(inFile, outFile, null);}
public void pdfbox_f724_0(File inFile, File outFile, String tsaUrl) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }    setTsaUrl(tsaUrl);        try (FileOutputStream fos = new FileOutputStream(outFile);        PDDocument doc = PDDocument.load(inFile)) {        signDetached(doc, fos);    }}
public void pdfbox_f725_0(PDDocument document, OutputStream output) throws IOException
{    int accessPermissions = SigUtils.getMDPPermission(document);    if (accessPermissions == 1) {        throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");    }        PDSignature signature = new PDSignature();    signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);    signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);    signature.setName("Example User");    signature.setLocation("Los Angeles, CA");    signature.setReason("Testing");            signature.setSignDate(Calendar.getInstance());        if (accessPermissions == 0) {        SigUtils.setMDPPermission(document, signature, 2);    }    if (isExternalSigning()) {        document.addSignature(signature);        ExternalSigningSupport externalSigning = document.saveIncrementalForExternalSigning(output);                byte[] cmsSignature = sign(externalSigning.getContent());                externalSigning.setSignature(cmsSignature);    } else {        SignatureOptions signatureOptions = new SignatureOptions();                signatureOptions.setPreferredSignatureSize(SignatureOptions.DEFAULT_SIGNATURE_SIZE * 2);                document.addSignature(signature, this, signatureOptions);                document.saveIncremental(output);    }}
public static void pdfbox_f726_0(String[] args) throws IOException, GeneralSecurityException
{    if (args.length < 3) {        usage();        System.exit(1);    }    String tsaUrl = null;    boolean externalSig = false;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-tsa")) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }        if (args[i].equals("-e")) {            externalSig = true;        }    }        KeyStore keystore = KeyStore.getInstance("PKCS12");        char[] password = args[1].toCharArray();    keystore.load(new FileInputStream(args[0]), password);            CreateSignature signing = new CreateSignature(keystore, password);    signing.setExternalSigning(externalSig);    File inFile = new File(args[2]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_signed.pdf");    signing.signDetached(inFile, outFile, tsaUrl);}
private static void pdfbox_f727_0()
{    System.err.println("usage: java " + CreateSignature.class.getName() + " " + "<pkcs12_keystore> <password> <pdf_to_sign>\n" + "" + "options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n" + "  -e            sign using external signature creation scenario");}
public final void pdfbox_f728_0(PrivateKey privateKey)
{    this.privateKey = privateKey;}
public final void pdfbox_f729_0(final Certificate[] certificateChain)
{    this.certificateChain = certificateChain;}
public Certificate[] pdfbox_f730_0()
{    return certificateChain;}
public void pdfbox_f731_0(String tsaUrl)
{    this.tsaUrl = tsaUrl;}
public byte[] pdfbox_f732_0(InputStream content) throws IOException
{        try {        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();        X509Certificate cert = (X509Certificate) certificateChain[0];        ContentSigner sha1Signer = new JcaContentSignerBuilder("SHA256WithRSA").build(privateKey);        gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build()).build(sha1Signer, cert));        gen.addCertificates(new JcaCertStore(Arrays.asList(certificateChain)));        CMSProcessableInputStream msg = new CMSProcessableInputStream(content);        CMSSignedData signedData = gen.generate(msg, false);        if (tsaUrl != null && tsaUrl.length() > 0) {            ValidationTimeStamp validation = new ValidationTimeStamp(tsaUrl);            signedData = validation.addSignedTimeStamp(signedData);        }        return signedData.getEncoded();    } catch (GeneralSecurityException | CMSException | OperatorCreationException e) {        throw new IOException(e);    }}
public void pdfbox_f733_0(boolean externalSigning)
{    this.externalSigning = externalSigning;}
public boolean pdfbox_f734_0()
{    return externalSigning;}
public void pdfbox_f735_0(File file) throws IOException
{    signDetached(file, file);}
public void pdfbox_f736_0(File inFile, File outFile) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }        try (PDDocument doc = PDDocument.load(inFile);        FileOutputStream fos = new FileOutputStream(outFile)) {        signDetached(doc, fos);    }}
public void pdfbox_f737_0(PDDocument document, OutputStream output) throws IOException
{    int accessPermissions = SigUtils.getMDPPermission(document);    if (accessPermissions == 1) {        throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");    }        PDSignature signature = new PDSignature();    signature.setType(COSName.DOC_TIME_STAMP);    signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);    signature.setSubFilter(COSName.getPDFName("ETSI.RFC3161"));                        document.addSignature(signature, this);        document.saveIncremental(output);}
public byte[] pdfbox_f738_1(InputStream content) throws IOException
{    ValidationTimeStamp validation;    try {        validation = new ValidationTimeStamp(tsaUrl);        return validation.getTimeStampToken(content);    } catch (NoSuchAlgorithmException e) {            }    return new byte[] {};}
public static void pdfbox_f739_0(String[] args) throws IOException, GeneralSecurityException
{    if (args.length != 3) {        usage();        System.exit(1);    }    String tsaUrl = null;    if ("-tsa".equals(args[1])) {        tsaUrl = args[2];    } else {        usage();        System.exit(1);    }        CreateSignedTimeStamp signing = new CreateSignedTimeStamp(tsaUrl);    File inFile = new File(args[0]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_timestamped.pdf");    signing.signDetached(inFile, outFile);}
private static void pdfbox_f740_0()
{    System.err.println("usage: java " + CreateSignedTimeStamp.class.getName() + " " + "<pdf_to_sign>\n" + "mandatory options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n");}
public boolean pdfbox_f741_0()
{    return lateExternalSigning;}
public void pdfbox_f742_0(boolean lateExternalSigning)
{    this.lateExternalSigning = lateExternalSigning;}
public void pdfbox_f743_0(String filename, int x, int y, int zoomPercent, InputStream imageStream, int page) throws IOException
{    visibleSignDesigner = new PDVisibleSignDesigner(filename, imageStream, page);    visibleSignDesigner.xAxis(x).yAxis(y).zoom(zoomPercent).adjustForRotation();}
public void pdfbox_f744_0(int zoomPercent, InputStream imageStream) throws IOException
{    visibleSignDesigner = new PDVisibleSignDesigner(imageStream);    visibleSignDesigner.zoom(zoomPercent);}
public void pdfbox_f745_0(String name, String location, String reason, int preferredSize, int page, boolean visualSignEnabled)
{    visibleSignatureProperties.signerName(name).signerLocation(location).signatureReason(reason).preferredSize(preferredSize).page(page).visualSignEnabled(visualSignEnabled).setPdVisibleSignature(visibleSignDesigner);}
public void pdfbox_f746_0(String name, String location, String reason, boolean visualSignEnabled)
{    visibleSignatureProperties.signerName(name).signerLocation(location).signatureReason(reason).visualSignEnabled(visualSignEnabled).setPdVisibleSignature(visibleSignDesigner);}
public void pdfbox_f747_0(File inputFile, File signedFile, String tsaUrl) throws IOException
{    this.signPDF(inputFile, signedFile, tsaUrl, null);}
public void pdfbox_f748_0(File inputFile, File signedFile, String tsaUrl, String signatureFieldName) throws IOException
{    if (inputFile == null || !inputFile.exists()) {        throw new IOException("Document for signing does not exist");    }    setTsaUrl(tsaUrl);    try (FileOutputStream fos = new FileOutputStream(signedFile);        PDDocument doc = PDDocument.load(inputFile)) {        int accessPermissions = SigUtils.getMDPPermission(doc);        if (accessPermissions == 1) {            throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");        }                                PDSignature signature;                signature = findExistingSignature(doc, signatureFieldName);        if (signature == null) {                        signature = new PDSignature();        }                if (doc.getVersion() >= 1.5f && accessPermissions == 0) {            SigUtils.setMDPPermission(doc, signature, 2);        }        PDAcroForm acroForm = doc.getDocumentCatalog().getAcroForm();        if (acroForm != null && acroForm.getNeedAppearances()) {                        if (acroForm.getFields().isEmpty()) {                                acroForm.getCOSObject().removeItem(COSName.NEED_APPEARANCES);                                                            } else {                System.out.println("/NeedAppearances is set, signature may be ignored by Adobe Reader");            }        }                signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);                signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);        if (visibleSignatureProperties != null) {                        visibleSignatureProperties.buildSignature();            signature.setName(visibleSignatureProperties.getSignerName());            signature.setLocation(visibleSignatureProperties.getSignerLocation());            signature.setReason(visibleSignatureProperties.getSignatureReason());        }                signature.setSignDate(Calendar.getInstance());                SignatureInterface signatureInterface = isExternalSigning() ? null : this;                if (visibleSignatureProperties != null && visibleSignatureProperties.isVisualSignEnabled()) {            signatureOptions = new SignatureOptions();            signatureOptions.setVisualSignature(visibleSignatureProperties.getVisibleSignature());            signatureOptions.setPage(visibleSignatureProperties.getPage() - 1);            doc.addSignature(signature, signatureInterface, signatureOptions);        } else {            doc.addSignature(signature, signatureInterface);        }        if (isExternalSigning()) {            ExternalSigningSupport externalSigning = doc.saveIncrementalForExternalSigning(fos);                        byte[] cmsSignature = sign(externalSigning.getContent());                        if (isLateExternalSigning()) {                                externalSigning.setSignature(new byte[0]);                                int offset = signature.getByteRange()[1] + 1;                                try (RandomAccessFile raf = new RandomAccessFile(signedFile, "rw")) {                    raf.seek(offset);                    raf.write(Hex.getBytes(cmsSignature));                }            } else {                                externalSigning.setSignature(cmsSignature);            }        } else {                        doc.saveIncremental(fos);        }    }                        IOUtils.closeQuietly(signatureOptions);}
private PDSignature pdfbox_f749_0(PDDocument doc, String sigFieldName)
{    PDSignature signature = null;    PDSignatureField signatureField;    PDAcroForm acroForm = doc.getDocumentCatalog().getAcroForm();    if (acroForm != null) {        signatureField = (PDSignatureField) acroForm.getField(sigFieldName);        if (signatureField != null) {                        signature = signatureField.getSignature();            if (signature == null) {                signature = new PDSignature();                                                                signatureField.getCOSObject().setItem(COSName.V, signature);            } else {                throw new IllegalStateException("The signature field " + sigFieldName + " is already signed.");            }        }    }    return signature;}
public static void pdfbox_f750_0(String[] args) throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException, UnrecoverableKeyException
{        if (args.length < 4) {        usage();        System.exit(1);    }    String tsaUrl = null;            boolean externalSig = false;    for (int i = 0; i < args.length; i++) {        if ("-tsa".equals(args[i])) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }        if ("-e".equals(args[i])) {            externalSig = true;        }    }    File ksFile = new File(args[0]);    KeyStore keystore = KeyStore.getInstance("PKCS12");    char[] pin = args[1].toCharArray();    keystore.load(new FileInputStream(ksFile), pin);    File documentFile = new File(args[2]);    CreateVisibleSignature signing = new CreateVisibleSignature(keystore, pin.clone());    File signedDocumentFile;    int page;    try (InputStream imageStream = new FileInputStream(args[3])) {        String name = documentFile.getName();        String substring = name.substring(0, name.lastIndexOf('.'));        signedDocumentFile = new File(documentFile.getParent(), substring + "_signed.pdf");                page = 1;        signing.setVisibleSignDesigner(args[2], 0, 0, -50, imageStream, page);    }    signing.setVisibleSignatureProperties("name", "location", "Security", 0, page, true);    signing.setExternalSigning(externalSig);    signing.signPDF(documentFile, signedDocumentFile, tsaUrl);}
private static void pdfbox_f751_0()
{    System.err.println("Usage: java " + CreateVisibleSignature.class.getName() + " <pkcs12-keystore-file> <pin> <input-pdf> <sign-image>\n" + "" + "options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n" + "  -e            sign using external signature creation scenario");}
public File pdfbox_f752_0()
{    return imageFile;}
public void pdfbox_f753_0(File imageFile)
{    this.imageFile = imageFile;}
public boolean pdfbox_f754_0()
{    return lateExternalSigning;}
public void pdfbox_f755_0(boolean lateExternalSigning)
{    this.lateExternalSigning = lateExternalSigning;}
public void pdfbox_f756_0(File inputFile, File signedFile, Rectangle2D humanRect, String tsaUrl) throws IOException
{    this.signPDF(inputFile, signedFile, humanRect, tsaUrl, null);}
public void pdfbox_f757_0(File inputFile, File signedFile, Rectangle2D humanRect, String tsaUrl, String signatureFieldName) throws IOException
{    if (inputFile == null || !inputFile.exists()) {        throw new IOException("Document for signing does not exist");    }    setTsaUrl(tsaUrl);    try (FileOutputStream fos = new FileOutputStream(signedFile);        PDDocument doc = PDDocument.load(inputFile)) {        int accessPermissions = SigUtils.getMDPPermission(doc);        if (accessPermissions == 1) {            throw new IllegalStateException("No changes to the document are permitted due to DocMDP transform parameters dictionary");        }                                PDSignature signature = null;        PDAcroForm acroForm = doc.getDocumentCatalog().getAcroForm();        PDRectangle rect = null;                if (acroForm != null) {            signature = findExistingSignature(acroForm, signatureFieldName);            if (signature != null) {                rect = acroForm.getField(signatureFieldName).getWidgets().get(0).getRectangle();            }        }        if (signature == null) {                        signature = new PDSignature();        }        if (rect == null) {            rect = createSignatureRectangle(doc, humanRect);        }                if (doc.getVersion() >= 1.5f && accessPermissions == 0) {            SigUtils.setMDPPermission(doc, signature, 2);        }        if (acroForm != null && acroForm.getNeedAppearances()) {                        if (acroForm.getFields().isEmpty()) {                                acroForm.getCOSObject().removeItem(COSName.NEED_APPEARANCES);                                                            } else {                System.out.println("/NeedAppearances is set, signature may be ignored by Adobe Reader");            }        }                signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);                signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);        signature.setName("Name");        signature.setLocation("Location");        signature.setReason("Reason");                signature.setSignDate(Calendar.getInstance());                SignatureInterface signatureInterface = isExternalSigning() ? null : this;                signatureOptions = new SignatureOptions();        signatureOptions.setVisualSignature(createVisualSignatureTemplate(doc, 0, rect, signature));        signatureOptions.setPage(0);        doc.addSignature(signature, signatureInterface, signatureOptions);        if (isExternalSigning()) {            ExternalSigningSupport externalSigning = doc.saveIncrementalForExternalSigning(fos);                        byte[] cmsSignature = sign(externalSigning.getContent());                        if (isLateExternalSigning()) {                                externalSigning.setSignature(new byte[0]);                                int offset = signature.getByteRange()[1] + 1;                                try (RandomAccessFile raf = new RandomAccessFile(signedFile, "rw")) {                    raf.seek(offset);                    raf.write(Hex.getBytes(cmsSignature));                }            } else {                                externalSigning.setSignature(cmsSignature);            }        } else {                        doc.saveIncremental(fos);        }    }                        IOUtils.closeQuietly(signatureOptions);}
private PDRectangle pdfbox_f758_0(PDDocument doc, Rectangle2D humanRect)
{    float x = (float) humanRect.getX();    float y = (float) humanRect.getY();    float width = (float) humanRect.getWidth();    float height = (float) humanRect.getHeight();    PDPage page = doc.getPage(0);    PDRectangle pageRect = page.getCropBox();    PDRectangle rect = new PDRectangle();        switch(page.getRotation()) {        case 90:            rect.setLowerLeftY(x);            rect.setUpperRightY(x + width);            rect.setLowerLeftX(y);            rect.setUpperRightX(y + height);            break;        case 180:            rect.setUpperRightX(pageRect.getWidth() - x);            rect.setLowerLeftX(pageRect.getWidth() - x - width);            rect.setLowerLeftY(y);            rect.setUpperRightY(y + height);            break;        case 270:            rect.setLowerLeftY(pageRect.getHeight() - x - width);            rect.setUpperRightY(pageRect.getHeight() - x);            rect.setLowerLeftX(pageRect.getWidth() - y - height);            rect.setUpperRightX(pageRect.getWidth() - y);            break;        case 0:        default:            rect.setLowerLeftX(x);            rect.setUpperRightX(x + width);            rect.setLowerLeftY(pageRect.getHeight() - y - height);            rect.setUpperRightY(pageRect.getHeight() - y);            break;    }    return rect;}
private InputStream pdfbox_f759_0(PDDocument srcDoc, int pageNum, PDRectangle rect, PDSignature signature) throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(srcDoc.getPage(pageNum).getMediaBox());        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(doc);        doc.getDocumentCatalog().setAcroForm(acroForm);        PDSignatureField signatureField = new PDSignatureField(acroForm);        PDAnnotationWidget widget = signatureField.getWidgets().get(0);        List<PDField> acroFormFields = acroForm.getFields();        acroForm.setSignaturesExist(true);        acroForm.setAppendOnly(true);        acroForm.getCOSObject().setDirect(true);        acroFormFields.add(signatureField);        widget.setRectangle(rect);                PDStream stream = new PDStream(doc);        PDFormXObject form = new PDFormXObject(stream);        PDResources res = new PDResources();        form.setResources(res);        form.setFormType(1);        PDRectangle bbox = new PDRectangle(rect.getWidth(), rect.getHeight());        float height = bbox.getHeight();        Matrix initialScale = null;        switch(srcDoc.getPage(pageNum).getRotation()) {            case 90:                form.setMatrix(AffineTransform.getQuadrantRotateInstance(1));                initialScale = Matrix.getScaleInstance(bbox.getWidth() / bbox.getHeight(), bbox.getHeight() / bbox.getWidth());                height = bbox.getWidth();                break;            case 180:                form.setMatrix(AffineTransform.getQuadrantRotateInstance(2));                break;            case 270:                form.setMatrix(AffineTransform.getQuadrantRotateInstance(3));                initialScale = Matrix.getScaleInstance(bbox.getWidth() / bbox.getHeight(), bbox.getHeight() / bbox.getWidth());                height = bbox.getWidth();                break;            case 0:            default:                break;        }        form.setBBox(bbox);        PDFont font = PDType1Font.HELVETICA_BOLD;                PDAppearanceDictionary appearance = new PDAppearanceDictionary();        appearance.getCOSObject().setDirect(true);        PDAppearanceStream appearanceStream = new PDAppearanceStream(form.getCOSObject());        appearance.setNormalAppearance(appearanceStream);        widget.setAppearance(appearance);        try (PDPageContentStream cs = new PDPageContentStream(doc, appearanceStream)) {                        if (initialScale != null) {                cs.transform(initialScale);            }                        cs.setNonStrokingColor(Color.yellow);            cs.addRect(-5000, -5000, 10000, 10000);            cs.fill();                                    cs.saveGraphicsState();            cs.transform(Matrix.getScaleInstance(0.25f, 0.25f));            PDImageXObject img = PDImageXObject.createFromFileByExtension(imageFile, doc);            cs.drawImage(img, 0, 0);            cs.restoreGraphicsState();                        float fontSize = 10;            float leading = fontSize * 1.5f;            cs.beginText();            cs.setFont(font, fontSize);            cs.setNonStrokingColor(Color.black);            cs.newLineAtOffset(fontSize, height - leading);            cs.setLeading(leading);            X509Certificate cert = (X509Certificate) getCertificateChain()[0];                        X500Name x500Name = new X500Name(cert.getSubjectX500Principal().getName());            RDN cn = x500Name.getRDNs(BCStyle.CN)[0];            String name = IETFUtils.valueToString(cn.getFirst().getValue());                                    String date = signature.getSignDate().getTime().toString();            String reason = signature.getReason();            cs.showText("Signer: " + name);            cs.newLine();            cs.showText(date);            cs.newLine();            cs.showText("Reason: " + reason);            cs.endText();        }                ByteArrayOutputStream baos = new ByteArrayOutputStream();        doc.save(baos);        return new ByteArrayInputStream(baos.toByteArray());    }}
private PDSignature pdfbox_f760_0(PDAcroForm acroForm, String sigFieldName)
{    PDSignature signature = null;    PDSignatureField signatureField;    if (acroForm != null) {        signatureField = (PDSignatureField) acroForm.getField(sigFieldName);        if (signatureField != null) {                        signature = signatureField.getSignature();            if (signature == null) {                signature = new PDSignature();                                                                signatureField.getCOSObject().setItem(COSName.V, signature);            } else {                throw new IllegalStateException("The signature field " + sigFieldName + " is already signed.");            }        }    }    return signature;}
public static void pdfbox_f761_0(String[] args) throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException, UnrecoverableKeyException
{        if (args.length < 4) {        usage();        System.exit(1);    }    String tsaUrl = null;            boolean externalSig = false;    for (int i = 0; i < args.length; i++) {        if ("-tsa".equals(args[i])) {            i++;            if (i >= args.length) {                usage();                System.exit(1);            }            tsaUrl = args[i];        }        if ("-e".equals(args[i])) {            externalSig = true;        }    }    File ksFile = new File(args[0]);    KeyStore keystore = KeyStore.getInstance("PKCS12");    char[] pin = args[1].toCharArray();    keystore.load(new FileInputStream(ksFile), pin);    File documentFile = new File(args[2]);    CreateVisibleSignature2 signing = new CreateVisibleSignature2(keystore, pin.clone());    signing.setImageFile(new File(args[3]));    File signedDocumentFile;    String name = documentFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    signedDocumentFile = new File(documentFile.getParent(), substring + "_signed.pdf");    signing.setExternalSigning(externalSig);                        Rectangle2D humanRect = new Rectangle2D.Float(100, 200, 150, 50);    signing.signPDF(documentFile, signedDocumentFile, humanRect, tsaUrl, "Signature1");}
private static void pdfbox_f762_0()
{    System.err.println("Usage: java " + CreateVisibleSignature2.class.getName() + " <pkcs12-keystore-file> <pin> <input-pdf> <sign-image>\n" + "" + "options:\n" + "  -tsa <url>    sign timestamp using the given TSA server\n" + "  -e            sign using external signature creation scenario");}
public static void pdfbox_f763_0(String[] args) throws IOException, TSPException, CertificateVerificationException, GeneralSecurityException
{        Security.addProvider(SecurityProvider.getProvider());    ShowSignature show = new ShowSignature();    show.showSignature(args);}
private void pdfbox_f764_0(String[] args) throws IOException, GeneralSecurityException, TSPException, CertificateVerificationException
{    if (args.length != 2) {        usage();    } else {        String password = args[0];        File infile = new File(args[1]);                        RandomAccessBufferedFileInputStream raFile = new RandomAccessBufferedFileInputStream(infile);                                PDFParser parser = new PDFParser(raFile, password);        parser.setLenient(false);        parser.parse();        try (PDDocument document = parser.getPDDocument()) {            for (PDSignature sig : document.getSignatureDictionaries()) {                COSDictionary sigDict = sig.getCOSObject();                COSString contents = (COSString) sigDict.getDictionaryObject(COSName.CONTENTS);                                byte[] buf;                try (FileInputStream fis = new FileInputStream(infile)) {                                        buf = sig.getSignedContent(fis);                }                System.out.println("Signature found");                if (sig.getName() != null) {                    System.out.println("Name:     " + sig.getName());                }                if (sig.getSignDate() != null) {                    System.out.println("Modified: " + sdf.format(sig.getSignDate().getTime()));                }                String subFilter = sig.getSubFilter();                if (subFilter != null) {                    switch(subFilter) {                        case "adbe.pkcs7.detached":                        case "ETSI.CAdES.detached":                            verifyPKCS7(buf, contents, sig);                            break;                        case "adbe.pkcs7.sha1":                            {                                                                byte[] certData = contents.getBytes();                                CertificateFactory factory = CertificateFactory.getInstance("X.509");                                ByteArrayInputStream certStream = new ByteArrayInputStream(certData);                                Collection<? extends Certificate> certs = factory.generateCertificates(certStream);                                System.out.println("certs=" + certs);                                byte[] hash = MessageDigest.getInstance("SHA1").digest(buf);                                verifyPKCS7(hash, contents, sig);                                break;                            }                        case "adbe.x509.rsa_sha1":                            {                                                                COSString certString = (COSString) sigDict.getDictionaryObject(COSName.CERT);                                                                if (certString == null) {                                    System.err.println("The /Cert certificate string is missing in the signature dictionary");                                    return;                                }                                byte[] certData = certString.getBytes();                                CertificateFactory factory = CertificateFactory.getInstance("X.509");                                ByteArrayInputStream certStream = new ByteArrayInputStream(certData);                                Collection<? extends Certificate> certs = factory.generateCertificates(certStream);                                System.out.println("certs=" + certs);                                X509Certificate cert = (X509Certificate) certs.iterator().next();                                try {                                    if (sig.getSignDate() != null) {                                        cert.checkValidity(sig.getSignDate().getTime());                                        System.out.println("Certificate valid at signing time");                                    } else {                                        System.err.println("Certificate cannot be verified without signing time");                                    }                                } catch (CertificateExpiredException ex) {                                    System.err.println("Certificate expired at signing time");                                } catch (CertificateNotYetValidException ex) {                                    System.err.println("Certificate not yet valid at signing time");                                }                                if (CertificateVerifier.isSelfSigned(cert)) {                                    System.err.println("Certificate is self-signed, LOL!");                                } else {                                    System.out.println("Certificate is not self-signed");                                    if (sig.getSignDate() != null) {                                        @SuppressWarnings("unchecked")                                        Store<X509CertificateHolder> store = new JcaCertStore(certs);                                        verifyCertificateChain(store, cert, sig.getSignDate().getTime());                                    }                                }                                break;                            }                        case "ETSI.RFC3161":                                                        verifyETSIdotRFC3161(buf, contents);                                                        break;                        default:                            System.err.println("Unknown certificate type: " + subFilter);                            break;                    }                } else {                    throw new IOException("Missing subfilter for cert dictionary");                }                int[] byteRange = sig.getByteRange();                if (byteRange.length != 4) {                    System.err.println("Signature byteRange must have 4 items");                } else {                    long fileLen = infile.length();                    long rangeMax = byteRange[2] + (long) byteRange[3];                                        int contentLen = contents.getString().length() * 2 + 2;                    if (fileLen != rangeMax || byteRange[0] != 0 || byteRange[1] + contentLen != byteRange[2]) {                                                                                                System.out.println("Signature does not cover whole document");                    } else {                        System.out.println("Signature covers whole document");                    }                    checkContentValueWithFile(infile, byteRange, contents);                }            }            analyseDSS(document);        } catch (CMSException | OperatorCreationException ex) {            throw new IOException(ex);        }        System.out.println("Analyzed: " + args[1]);    }}
private void pdfbox_f765_0(File file, int[] byteRange, COSString contents) throws IOException
{        try (RandomAccessBufferedFileInputStream raf = new RandomAccessBufferedFileInputStream(file)) {        raf.seek(byteRange[1]);        int c = raf.read();        if (c != '<') {            System.err.println("'<' expected at offset " + byteRange[1] + ", but got " + (char) c);        }        byte[] contentFromFile = raf.readFully(byteRange[2] - byteRange[1] - 2);        byte[] contentAsHex = Hex.getString(contents.getBytes()).getBytes(Charsets.US_ASCII);        if (contentFromFile.length != contentAsHex.length) {            System.err.println("Raw content length from file is " + contentFromFile.length + ", but internal content string in hex has length " + contentAsHex.length);        }                for (int i = 0; i < contentFromFile.length; ++i) {            try {                if (Integer.parseInt(String.valueOf((char) contentFromFile[i]), 16) != Integer.parseInt(String.valueOf((char) contentAsHex[i]), 16)) {                    System.err.println("Possible manipulation at file offset " + (byteRange[1] + i + 1) + " in signature content");                    break;                }            } catch (NumberFormatException ex) {                System.err.println("Incorrect hex value");                System.err.println("Possible manipulation at file offset " + (byteRange[1] + i + 1) + " in signature content");                break;            }        }        c = raf.read();        if (c != '>') {            System.err.println("'>' expected at offset " + byteRange[2] + ", but got " + (char) c);        }    }}
private void pdfbox_f766_0(byte[] buf, COSString contents) throws CMSException, NoSuchAlgorithmException, IOException, TSPException, OperatorCreationException, CertificateVerificationException, CertificateException
{    TimeStampToken timeStampToken = new TimeStampToken(new CMSSignedData(contents.getBytes()));    System.out.println("Time stamp gen time: " + timeStampToken.getTimeStampInfo().getGenTime());    System.out.println("Time stamp tsa name: " + timeStampToken.getTimeStampInfo().getTsa().getName());    CertificateFactory factory = CertificateFactory.getInstance("X.509");    ByteArrayInputStream certStream = new ByteArrayInputStream(contents.getBytes());    Collection<? extends Certificate> certs = factory.generateCertificates(certStream);    System.out.println("certs=" + certs);    String hashAlgorithm = timeStampToken.getTimeStampInfo().getMessageImprintAlgOID().getId();        if (Arrays.equals(MessageDigest.getInstance(hashAlgorithm).digest(buf), timeStampToken.getTimeStampInfo().getMessageImprintDigest())) {        System.out.println("ETSI.RFC3161 timestamp signature verified");    } else {        System.err.println("ETSI.RFC3161 timestamp signature verification failed");    }    X509Certificate certFromTimeStamp = (X509Certificate) certs.iterator().next();    SigUtils.checkTimeStampCertificateUsage(certFromTimeStamp);    validateTimestampToken(timeStampToken);    verifyCertificateChain(timeStampToken.getCertificates(), certFromTimeStamp, timeStampToken.getTimeStampInfo().getGenTime());}
private void pdfbox_f767_0(byte[] byteArray, COSString contents, PDSignature sig) throws CMSException, OperatorCreationException, CertificateVerificationException, GeneralSecurityException, TSPException, IOException
{                CMSProcessable signedContent = new CMSProcessableByteArray(byteArray);    CMSSignedData signedData = new CMSSignedData(signedContent, contents.getBytes());    Store<X509CertificateHolder> certificatesStore = signedData.getCertificates();    if (certificatesStore.getMatches(null).isEmpty()) {        throw new IOException("No certificates in signature");    }    Collection<SignerInformation> signers = signedData.getSignerInfos().getSigners();    if (signers.isEmpty()) {        throw new IOException("No signers in signature");    }    SignerInformation signerInformation = signers.iterator().next();    @SuppressWarnings("unchecked")    Collection<X509CertificateHolder> matches = certificatesStore.getMatches((Selector<X509CertificateHolder>) signerInformation.getSID());    if (matches.isEmpty()) {        throw new IOException("Signer '" + signerInformation.getSID().getIssuer() + ", serial# " + signerInformation.getSID().getSerialNumber() + " does not match any certificates");    }    X509CertificateHolder certificateHolder = matches.iterator().next();    X509Certificate certFromSignedData = new JcaX509CertificateConverter().getCertificate(certificateHolder);    System.out.println("certFromSignedData: " + certFromSignedData);    SigUtils.checkCertificateUsage(certFromSignedData);        TimeStampToken timeStampToken = extractTimeStampTokenFromSignerInformation(signerInformation);    if (timeStampToken != null) {                                validateTimestampToken(timeStampToken);                @SuppressWarnings("unchecked")        Collection<X509CertificateHolder> tstMatches = timeStampToken.getCertificates().getMatches((Selector<X509CertificateHolder>) timeStampToken.getSID());        X509CertificateHolder tstCertHolder = tstMatches.iterator().next();        X509Certificate certFromTimeStamp = new JcaX509CertificateConverter().getCertificate(tstCertHolder);                HashSet<X509CertificateHolder> certificateHolderSet = new HashSet<>();        certificateHolderSet.addAll(certificatesStore.getMatches(null));        certificateHolderSet.addAll(timeStampToken.getCertificates().getMatches(null));        verifyCertificateChain(new CollectionStore<>(certificateHolderSet), certFromTimeStamp, timeStampToken.getTimeStampInfo().getGenTime());        SigUtils.checkTimeStampCertificateUsage(certFromTimeStamp);    }    try {        if (sig.getSignDate() != null) {            certFromSignedData.checkValidity(sig.getSignDate().getTime());            System.out.println("Certificate valid at signing time");        } else {            System.err.println("Certificate cannot be verified without signing time");        }    } catch (CertificateExpiredException ex) {        System.err.println("Certificate expired at signing time");    } catch (CertificateNotYetValidException ex) {        System.err.println("Certificate not yet valid at signing time");    }        if (signerInformation.getSignedAttributes() != null) {                Attribute signingTime = signerInformation.getSignedAttributes().get(CMSAttributes.signingTime);        if (signingTime != null) {            Time timeInstance = Time.getInstance(signingTime.getAttrValues().getObjectAt(0));            try {                certFromSignedData.checkValidity(timeInstance.getDate());                System.out.println("Certificate valid at signing time: " + timeInstance.getDate());            } catch (CertificateExpiredException ex) {                System.err.println("Certificate expired at signing time");            } catch (CertificateNotYetValidException ex) {                System.err.println("Certificate not yet valid at signing time");            }        }    }    if (signerInformation.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(SecurityProvider.getProvider()).build(certFromSignedData))) {        System.out.println("Signature verified");    } else {        System.out.println("Signature verification failed");    }    if (CertificateVerifier.isSelfSigned(certFromSignedData)) {        System.err.println("Certificate is self-signed, LOL!");    } else {        System.out.println("Certificate is not self-signed");        if (sig.getSignDate() != null) {            verifyCertificateChain(certificatesStore, certFromSignedData, sig.getSignDate().getTime());        } else {            System.err.println("Certificate cannot be verified without signing time");        }    }}
private TimeStampToken pdfbox_f768_0(SignerInformation signerInformation) throws CMSException, IOException, TSPException
{    if (signerInformation.getUnsignedAttributes() == null) {        return null;    }    AttributeTable unsignedAttributes = signerInformation.getUnsignedAttributes();        Attribute attribute = unsignedAttributes.get(PKCSObjectIdentifiers.id_aa_signatureTimeStampToken);    if (attribute == null) {        return null;    }    ASN1Object obj = (ASN1Object) attribute.getAttrValues().getObjectAt(0);    CMSSignedData signedTSTData = new CMSSignedData(obj.getEncoded());    return new TimeStampToken(signedTSTData);}
private void pdfbox_f769_0(Store<X509CertificateHolder> certificatesStore, X509Certificate certFromSignedData, Date signDate) throws CertificateVerificationException, CertificateException
{                    Collection<X509CertificateHolder> certificateHolders = certificatesStore.getMatches(null);    Set<X509Certificate> additionalCerts = new HashSet<>();    JcaX509CertificateConverter certificateConverter = new JcaX509CertificateConverter();    for (X509CertificateHolder certHolder : certificateHolders) {        X509Certificate certificate = certificateConverter.getCertificate(certHolder);        if (!certificate.equals(certFromSignedData)) {            additionalCerts.add(certificate);        }    }    CertificateVerifier.verifyCertificate(certFromSignedData, additionalCerts, true, signDate);}
private void pdfbox_f770_0(TimeStampToken timeStampToken) throws TSPException, CertificateException, OperatorCreationException, IOException
{            @SuppressWarnings("unchecked")    Collection<X509CertificateHolder> tstMatches = timeStampToken.getCertificates().getMatches((Selector<X509CertificateHolder>) timeStampToken.getSID());    X509CertificateHolder holder = tstMatches.iterator().next();    X509Certificate tstCert = new JcaX509CertificateConverter().getCertificate(holder);    SignerInformationVerifier siv = new JcaSimpleSignerInfoVerifierBuilder().setProvider(SecurityProvider.getProvider()).build(tstCert);    timeStampToken.validate(siv);    System.out.println("TimeStampToken validated");}
private Set<X509Certificate> pdfbox_f771_0() throws GeneralSecurityException, IOException
{    Set<X509Certificate> rootCertificates = new HashSet<>();        String filename = System.getProperty("java.home") + "/lib/security/cacerts";    KeyStore keystore;    try (FileInputStream is = new FileInputStream(filename)) {        keystore = KeyStore.getInstance(KeyStore.getDefaultType());        keystore.load(is, null);    }    PKIXParameters params = new PKIXParameters(keystore);    for (TrustAnchor trustAnchor : params.getTrustAnchors()) {        rootCertificates.add(trustAnchor.getTrustedCert());    }        try {        keystore = KeyStore.getInstance("Windows-ROOT");        keystore.load(null, null);        params = new PKIXParameters(keystore);        for (TrustAnchor trustAnchor : params.getTrustAnchors()) {            rootCertificates.add(trustAnchor.getTrustedCert());        }    } catch (InvalidAlgorithmParameterException | KeyStoreException ex) {        }    return rootCertificates;}
private void pdfbox_f772_0(PDDocument document) throws IOException
{    PDDocumentCatalog catalog = document.getDocumentCatalog();    COSBase dssElement = catalog.getCOSObject().getDictionaryObject("DSS");    if (dssElement instanceof COSDictionary) {        COSDictionary dss = (COSDictionary) dssElement;        System.out.println("DSS Dictionary: " + dss);        COSBase certsElement = dss.getDictionaryObject("Certs");        if (certsElement instanceof COSArray) {            printStreamsFromArray((COSArray) certsElement, "Cert");        }        COSBase ocspsElement = dss.getDictionaryObject("OCSPs");        if (ocspsElement instanceof COSArray) {            printStreamsFromArray((COSArray) ocspsElement, "Ocsp");        }        COSBase crlElement = dss.getDictionaryObject("CRLs");        if (crlElement instanceof COSArray) {            printStreamsFromArray((COSArray) crlElement, "CRL");        }        }}
private void pdfbox_f773_0(COSArray elements, String description) throws IOException
{    for (COSBase baseElem : elements) {        COSObject streamObj = (COSObject) baseElem;        if (streamObj.getObject() instanceof COSStream) {            COSStream cosStream = (COSStream) streamObj.getObject();            try (InputStream is = cosStream.createInputStream()) {                byte[] streamBytes = IOUtils.toByteArray(is);                System.out.println(description + " (" + elements.indexOf(streamObj) + "): " + Hex.getString(streamBytes));            }        }    }}
private static void pdfbox_f774_0()
{    System.err.println("usage: java " + ShowSignature.class.getName() + " <password (usually empty)> <inputfile>");}
public static int pdfbox_f775_0(PDDocument doc)
{    COSBase base = doc.getDocumentCatalog().getCOSObject().getDictionaryObject(COSName.PERMS);    if (base instanceof COSDictionary) {        COSDictionary permsDict = (COSDictionary) base;        base = permsDict.getDictionaryObject(COSName.DOCMDP);        if (base instanceof COSDictionary) {            COSDictionary signatureDict = (COSDictionary) base;            base = signatureDict.getDictionaryObject("Reference");            if (base instanceof COSArray) {                COSArray refArray = (COSArray) base;                for (int i = 0; i < refArray.size(); ++i) {                    base = refArray.getObject(i);                    if (base instanceof COSDictionary) {                        COSDictionary sigRefDict = (COSDictionary) base;                        if (COSName.DOCMDP.equals(sigRefDict.getDictionaryObject("TransformMethod"))) {                            base = sigRefDict.getDictionaryObject("TransformParams");                            if (base instanceof COSDictionary) {                                COSDictionary transformDict = (COSDictionary) base;                                int accessPermissions = transformDict.getInt(COSName.P, 2);                                if (accessPermissions < 1 || accessPermissions > 3) {                                    accessPermissions = 2;                                }                                return accessPermissions;                            }                        }                    }                }            }        }    }    return 0;}
public static void pdfbox_f776_0(PDDocument doc, PDSignature signature, int accessPermissions)
{    COSDictionary sigDict = signature.getCOSObject();        COSDictionary transformParameters = new COSDictionary();    transformParameters.setItem(COSName.TYPE, COSName.getPDFName("TransformParams"));    transformParameters.setInt(COSName.P, accessPermissions);    transformParameters.setName(COSName.V, "1.2");    transformParameters.setNeedToBeUpdated(true);    COSDictionary referenceDict = new COSDictionary();    referenceDict.setItem(COSName.TYPE, COSName.getPDFName("SigRef"));    referenceDict.setItem("TransformMethod", COSName.DOCMDP);    referenceDict.setItem("DigestMethod", COSName.getPDFName("SHA1"));    referenceDict.setItem("TransformParams", transformParameters);    referenceDict.setNeedToBeUpdated(true);    COSArray referenceArray = new COSArray();    referenceArray.add(referenceDict);    sigDict.setItem("Reference", referenceArray);    referenceArray.setNeedToBeUpdated(true);        COSDictionary catalogDict = doc.getDocumentCatalog().getCOSObject();    COSDictionary permsDict = new COSDictionary();    catalogDict.setItem(COSName.PERMS, permsDict);    permsDict.setItem(COSName.DOCMDP, signature);    catalogDict.setNeedToBeUpdated(true);    permsDict.setNeedToBeUpdated(true);}
public static void pdfbox_f777_1(X509Certificate x509Certificate) throws CertificateParsingException
{                boolean[] keyUsage = x509Certificate.getKeyUsage();    if (keyUsage != null && !keyUsage[0] && !keyUsage[1]) {                            }    List<String> extendedKeyUsage = x509Certificate.getExtendedKeyUsage();    if (extendedKeyUsage != null && !extendedKeyUsage.contains(KeyPurposeId.id_kp_emailProtection.toString()) && !extendedKeyUsage.contains(KeyPurposeId.id_kp_codeSigning.toString()) && !extendedKeyUsage.contains(KeyPurposeId.anyExtendedKeyUsage.toString()) && !extendedKeyUsage.contains("1.2.840.113583.1.1.5") &&     !extendedKeyUsage.contains("1.3.6.1.4.1.311.10.3.12")) {            }}
public static void pdfbox_f778_1(X509Certificate x509Certificate) throws CertificateParsingException
{    List<String> extendedKeyUsage = x509Certificate.getExtendedKeyUsage();        if (extendedKeyUsage != null && !extendedKeyUsage.contains(KeyPurposeId.id_kp_timeStamping.toString())) {            }}
public static void pdfbox_f779_1(X509Certificate x509Certificate) throws CertificateParsingException
{    List<String> extendedKeyUsage = x509Certificate.getExtendedKeyUsage();        if (extendedKeyUsage != null && !extendedKeyUsage.contains(KeyPurposeId.id_kp_OCSPSigning.toString())) {            }}
public static PDSignature pdfbox_f780_0(PDDocument document) throws IOException
{    SortedMap<Integer, PDSignature> sortedMap = new TreeMap<>();    for (PDSignature signature : document.getSignatureDictionaries()) {        int sigOffset = signature.getByteRange()[1];        sortedMap.put(sigOffset, signature);    }    if (sortedMap.size() > 0) {        PDSignature lastSignature = sortedMap.get(sortedMap.lastKey());        COSBase type = lastSignature.getCOSObject().getItem(COSName.TYPE);        if (type.equals(COSName.SIG) || type.equals(COSName.DOC_TIME_STAMP)) {            return lastSignature;        }    }    return null;}
public byte[] pdfbox_f781_0(byte[] messageImprint) throws IOException
{    digest.reset();    byte[] hash = digest.digest(messageImprint);        SecureRandom random = new SecureRandom();    int nonce = random.nextInt();        TimeStampRequestGenerator tsaGenerator = new TimeStampRequestGenerator();    tsaGenerator.setCertReq(true);    ASN1ObjectIdentifier oid = getHashObjectIdentifier(digest.getAlgorithm());    TimeStampRequest request = tsaGenerator.generate(oid, hash, BigInteger.valueOf(nonce));        byte[] tsaResponse = getTSAResponse(request.getEncoded());    TimeStampResponse response;    try {        response = new TimeStampResponse(tsaResponse);        response.validate(request);    } catch (TSPException e) {        throw new IOException(e);    }    TimeStampToken token = response.getTimeStampToken();    if (token == null) {        throw new IOException("Response does not have a time stamp token");    }    return token.getEncoded();}
private byte[] pdfbox_f782_1(byte[] request) throws IOException
{            URLConnection connection = url.openConnection();    connection.setDoOutput(true);    connection.setDoInput(true);    connection.setRequestProperty("Content-Type", "application/timestamp-query");        if (username != null && password != null && !username.isEmpty() && !password.isEmpty()) {        connection.setRequestProperty(username, password);    }        OutputStream output = null;    try {        output = connection.getOutputStream();        output.write(request);    } finally {        IOUtils.closeQuietly(output);    }        InputStream input = null;    byte[] response;    try {        input = connection.getInputStream();        response = IOUtils.toByteArray(input);    } finally {        IOUtils.closeQuietly(input);    }        return response;}
private ASN1ObjectIdentifier pdfbox_f783_0(String algorithm)
{    switch(algorithm) {        case "MD2":            return new ASN1ObjectIdentifier(PKCSObjectIdentifiers.md2.getId());        case "MD5":            return new ASN1ObjectIdentifier(PKCSObjectIdentifiers.md5.getId());        case "SHA-1":            return new ASN1ObjectIdentifier(OIWObjectIdentifiers.idSHA1.getId());        case "SHA-224":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha224.getId());        case "SHA-256":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha256.getId());        case "SHA-384":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha384.getId());        case "SHA-512":            return new ASN1ObjectIdentifier(NISTObjectIdentifiers.id_sha512.getId());        default:            return new ASN1ObjectIdentifier(algorithm);    }}
public void pdfbox_f784_0(File inFile, File outFile) throws IOException
{    if (inFile == null || !inFile.exists()) {        throw new FileNotFoundException("Document for signing does not exist");    }    try (PDDocument doc = PDDocument.load(inFile);        FileOutputStream fos = new FileOutputStream(outFile)) {        document = doc;        doValidation(inFile.getAbsolutePath(), fos);    }}
private void pdfbox_f785_0(String filename, OutputStream output) throws IOException
{    certInformationHelper = new CertInformationCollector();    CertSignatureInformation certInfo = null;    try {        PDSignature signature = SigUtils.getLastRelevantSignature(document);        if (signature != null) {            certInfo = certInformationHelper.getLastCertInfo(signature, filename);            signDate = signature.getSignDate();        }    } catch (CertificateProccessingException e) {        throw new IOException("An Error occurred processing the Signature", e);    }    if (certInfo == null) {        throw new IOException("No Certificate information or signature found in the given document");    }    PDDocumentCatalog docCatalog = document.getDocumentCatalog();    COSDictionary catalog = docCatalog.getCOSObject();    catalog.setNeedToBeUpdated(true);    COSDictionary dss = getOrCreateDictionaryEntry(COSDictionary.class, catalog, "DSS");    addExtensions(docCatalog);    vriBase = getOrCreateDictionaryEntry(COSDictionary.class, dss, "VRI");    ocsps = getOrCreateDictionaryEntry(COSArray.class, dss, "OCSPs");    crls = getOrCreateDictionaryEntry(COSArray.class, dss, "CRLs");    certs = getOrCreateDictionaryEntry(COSArray.class, dss, "Certs");    addRevocationData(certInfo);    addAllCertsToCertArray();        document.saveIncremental(output);}
private static T pdfbox_f786_1(Class<T> clazz, COSDictionary parent, String name) throws IOException
{    T result;    COSBase element = parent.getDictionaryObject(name);    if (element != null && clazz.isInstance(element)) {        result = clazz.cast(element);        result.setNeedToBeUpdated(true);    } else if (element != null) {        throw new IOException("Element " + name + " from dictionary is not of type " + clazz.getCanonicalName());    } else {        try {            result = clazz.getDeclaredConstructor().newInstance();        } catch (ReflectiveOperationException | SecurityException e) {                        return null;        }        result.setDirect(false);        parent.setItem(COSName.getPDFName(name), result);    }    return result;}
private void pdfbox_f787_0(CertSignatureInformation certInfo) throws IOException
{    COSDictionary vri = new COSDictionary();    vriBase.setItem(certInfo.getSignatureHash(), vri);    updateVRI(certInfo, vri);    if (certInfo.getTsaCerts() != null) {                correspondingOCSPs = null;        correspondingCRLs = null;        addRevocationDataRecursive(certInfo.getTsaCerts());    }}
private void pdfbox_f788_1(CertSignatureInformation certInfo) throws IOException
{    if (certInfo.isSelfSigned()) {        return;    }        boolean isRevocationInfoFound = foundRevocationInformation.contains(certInfo.getCertificate().getSerialNumber());    if (!isRevocationInfoFound) {        if (certInfo.getOcspUrl() != null && certInfo.getIssuerCertificate() != null) {            isRevocationInfoFound = fetchOcspData(certInfo);        }        if (!isRevocationInfoFound && certInfo.getCrlUrl() != null) {            fetchCrlData(certInfo);            isRevocationInfoFound = true;        }        if (certInfo.getOcspUrl() == null && certInfo.getCrlUrl() == null) {                    } else if (!isRevocationInfoFound) {            throw new IOException("Could not fetch Revocation Info for Cert: " + certInfo.getCertificate().getSubjectX500Principal());        }    }    if (certInfo.getAlternativeCertChain() != null) {        addRevocationDataRecursive(certInfo.getAlternativeCertChain());    }    if (certInfo.getCertChain() != null && certInfo.getCertChain().getCertificate() != null) {        addRevocationDataRecursive(certInfo.getCertChain());    }}
private boolean pdfbox_f789_1(CertSignatureInformation certInfo) throws IOException
{    try {        addOcspData(certInfo);        return true;    } catch (OCSPException | CertificateProccessingException | IOException e) {                return false;    } catch (RevokedCertificateException e) {        throw new IOException(e);    }}
private void pdfbox_f790_1(CertSignatureInformation certInfo) throws IOException
{    try {        addCrlRevocationInfo(certInfo);    } catch (GeneralSecurityException | IOException | RevokedCertificateException | CertificateVerificationException e) {                throw new IOException(e);    }}
private void pdfbox_f791_0(CertSignatureInformation certInfo) throws IOException, OCSPException, CertificateProccessingException, RevokedCertificateException
{    OcspHelper ocspHelper = new OcspHelper(certInfo.getCertificate(), signDate.getTime(), certInfo.getIssuerCertificate(), new HashSet<>(certInformationHelper.getCertificateSet()), certInfo.getOcspUrl());    OCSPResp ocspResp = ocspHelper.getResponseOcsp();    BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResp.getResponseObject();    X509Certificate ocspResponderCertificate = ocspHelper.getOcspResponderCertificate();    certInformationHelper.addAllCertsFromHolders(basicResponse.getCerts());    byte[] signatureHash;    try {        signatureHash = MessageDigest.getInstance("SHA-1").digest(basicResponse.getSignature());    } catch (NoSuchAlgorithmException ex) {        throw new CertificateProccessingException(ex);    }    String signatureHashHex = Hex.getString(signatureHash);    if (!vriBase.containsKey(signatureHashHex)) {        COSArray savedCorrespondingOCSPs = correspondingOCSPs;        COSArray savedCorrespondingCRLs = correspondingCRLs;        COSDictionary vri = new COSDictionary();        vriBase.setItem(signatureHashHex, vri);        CertSignatureInformation ocspCertInfo = certInformationHelper.getCertInfo(ocspResponderCertificate);        updateVRI(ocspCertInfo, vri);        correspondingOCSPs = savedCorrespondingOCSPs;        correspondingCRLs = savedCorrespondingCRLs;    }    byte[] ocspData = ocspResp.getEncoded();    COSStream ocspStream = writeDataToStream(ocspData);    ocsps.add(ocspStream);    if (correspondingOCSPs != null) {        correspondingOCSPs.add(ocspStream);    }    foundRevocationInformation.add(certInfo.getCertificate().getSerialNumber());}
private void pdfbox_f792_0(CertSignatureInformation certInfo) throws IOException, RevokedCertificateException, GeneralSecurityException, CertificateVerificationException
{    X509CRL crl = CRLVerifier.downloadCRLFromWeb(certInfo.getCrlUrl());    X509Certificate issuerCertificate = certInfo.getIssuerCertificate();        for (X509Certificate certificate : certInformationHelper.getCertificateSet()) {        if (certificate.getSubjectX500Principal().equals(crl.getIssuerX500Principal())) {            issuerCertificate = certificate;            break;        }    }    crl.verify(issuerCertificate.getPublicKey(), SecurityProvider.getProvider().getName());    CRLVerifier.checkRevocation(crl, certInfo.getCertificate(), signDate.getTime(), certInfo.getCrlUrl());    COSStream crlStream = writeDataToStream(crl.getEncoded());    crls.add(crlStream);    if (correspondingCRLs != null) {        correspondingCRLs.add(crlStream);        byte[] signatureHash;        try {            signatureHash = MessageDigest.getInstance("SHA-1").digest(crl.getSignature());        } catch (NoSuchAlgorithmException ex) {            throw new CertificateVerificationException(ex.getMessage(), ex);        }        String signatureHashHex = Hex.getString(signatureHash);        if (!vriBase.containsKey(signatureHashHex)) {            COSArray savedCorrespondingOCSPs = correspondingOCSPs;            COSArray savedCorrespondingCRLs = correspondingCRLs;            COSDictionary vri = new COSDictionary();            vriBase.setItem(signatureHashHex, vri);            CertSignatureInformation crlCertInfo;            try {                crlCertInfo = certInformationHelper.getCertInfo(issuerCertificate);            } catch (CertificateProccessingException ex) {                throw new CertificateVerificationException(ex.getMessage(), ex);            }            updateVRI(crlCertInfo, vri);            correspondingOCSPs = savedCorrespondingOCSPs;            correspondingCRLs = savedCorrespondingCRLs;        }    }    foundRevocationInformation.add(certInfo.getCertificate().getSerialNumber());}
private void pdfbox_f793_1(CertSignatureInformation certInfo, COSDictionary vri) throws IOException
{    if (certInfo.getCertificate().getExtensionValue(OCSPObjectIdentifiers.id_pkix_ocsp_nocheck.getId()) == null) {        correspondingOCSPs = new COSArray();        correspondingCRLs = new COSArray();        addRevocationDataRecursive(certInfo);        if (correspondingOCSPs.size() > 0) {            vri.setItem("OCSP", correspondingOCSPs);        }        if (correspondingCRLs.size() > 0) {            vri.setItem("CRL", correspondingCRLs);        }    }    COSArray correspondingCerts = new COSArray();    CertSignatureInformation ci = certInfo;    do {        X509Certificate cert = ci.getCertificate();        try {            COSStream certStream = writeDataToStream(cert.getEncoded());            correspondingCerts.add(certStream);                        certs.add(certStream);        } catch (CertificateEncodingException ex) {                                }        if (cert.getExtensionValue(OCSPObjectIdentifiers.id_pkix_ocsp_nocheck.getId()) != null) {            break;        }        ci = ci.getCertChain();    } while (ci != null);    vri.setItem(COSName.CERT, correspondingCerts);    vri.setDate(COSName.TU, Calendar.getInstance());}
private void pdfbox_f794_0() throws IOException
{    try {        for (X509Certificate cert : certInformationHelper.getCertificateSet()) {            COSStream stream = writeDataToStream(cert.getEncoded());            certs.add(stream);        }    } catch (CertificateEncodingException e) {        throw new IOException(e);    }}
private COSStream pdfbox_f795_0(byte[] data) throws IOException
{    COSStream stream = document.getDocument().createCOSStream();    try (OutputStream os = stream.createOutputStream(COSName.FLATE_DECODE)) {        os.write(data);    }    return stream;}
private void pdfbox_f796_0(PDDocumentCatalog catalog)
{    COSDictionary dssExtensions = new COSDictionary();    dssExtensions.setDirect(true);    catalog.getCOSObject().setItem("Extensions", dssExtensions);    COSDictionary adbeExtension = new COSDictionary();    adbeExtension.setDirect(true);    dssExtensions.setItem("ADBE", adbeExtension);    adbeExtension.setName("BaseVersion", "1.7");    adbeExtension.setInt("ExtensionLevel", 5);    catalog.setVersion("1.7");}
public static void pdfbox_f797_0(String[] args) throws IOException, GeneralSecurityException
{    if (args.length != 1) {        usage();        System.exit(1);    }        Security.addProvider(SecurityProvider.getProvider());        AddValidationInformation addOcspInformation = new AddValidationInformation();    File inFile = new File(args[0]);    String name = inFile.getName();    String substring = name.substring(0, name.lastIndexOf('.'));    File outFile = new File(inFile.getParent(), substring + "_ocsp.pdf");    addOcspInformation.validateSignature(inFile, outFile);}
private static void pdfbox_f798_0()
{    System.err.println("usage: java " + AddValidationInformation.class.getName() + " " + "<pdf_to_add_ocsp>\n");}
public CertSignatureInformation pdfbox_f799_0(PDSignature signature, String fileName) throws CertificateProccessingException, IOException
{    try (FileInputStream documentInput = new FileInputStream(fileName)) {        byte[] signatureContent = signature.getContents(documentInput);        return getCertInfo(signatureContent);    }}
private CertSignatureInformation pdfbox_f800_1(byte[] signatureContent) throws CertificateProccessingException, IOException
{    rootCertInfo = new CertSignatureInformation();    rootCertInfo.signatureHash = CertInformationHelper.getSha1Hash(signatureContent);    try {        CMSSignedData signedData = new CMSSignedData(signatureContent);        Store<X509CertificateHolder> certificatesStore = signedData.getCertificates();        SignerInformation signerInformation = processSignerStore(certificatesStore, signedData, rootCertInfo);        addTimestampCerts(signerInformation);    } catch (CMSException e) {                throw new CertificateProccessingException(e);    }    return rootCertInfo;}
private void pdfbox_f801_0(SignerInformation signerInformation) throws IOException, CertificateProccessingException
{    AttributeTable unsignedAttributes = signerInformation.getUnsignedAttributes();    if (unsignedAttributes == null) {        return;    }    Attribute tsAttribute = signerInformation.getUnsignedAttributes().get(PKCSObjectIdentifiers.id_aa_signatureTimeStampToken);    if (tsAttribute.getAttrValues() instanceof DERSet) {        DERSet tsSet = (DERSet) tsAttribute.getAttrValues();        tsSet.getEncoded("DER");        DERSequence tsSeq = (DERSequence) tsSet.getObjectAt(0);        try {            TimeStampToken tsToken = new TimeStampToken(new CMSSignedData(tsSeq.getEncoded("DER")));            rootCertInfo.tsaCerts = new CertSignatureInformation();            @SuppressWarnings("unchecked")            Store<X509CertificateHolder> certificatesStore = tsToken.getCertificates();            processSignerStore(certificatesStore, tsToken.toCMSSignedData(), rootCertInfo.tsaCerts);        } catch (TSPException | CMSException e) {            throw new IOException("Error parsing timestamp token", e);        }    }}
private SignerInformation pdfbox_f802_0(Store<X509CertificateHolder> certificatesStore, CMSSignedData signedData, CertSignatureInformation certInfo) throws IOException, CertificateProccessingException
{    Collection<SignerInformation> signers = signedData.getSignerInfos().getSigners();    SignerInformation signerInformation = signers.iterator().next();    @SuppressWarnings("unchecked")    Collection<X509CertificateHolder> matches = certificatesStore.getMatches((Selector<X509CertificateHolder>) signerInformation.getSID());    X509Certificate certificate = getCertFromHolder(matches.iterator().next());    certificateSet.add(certificate);    Collection<X509CertificateHolder> allCerts = certificatesStore.getMatches(null);    addAllCerts(allCerts);    traverseChain(certificate, certInfo, MAX_CERTIFICATE_CHAIN_DEPTH);    return signerInformation;}
private void pdfbox_f803_1(X509Certificate certificate, CertSignatureInformation certInfo, int maxDepth) throws IOException, CertificateProccessingException
{    certInfo.certificate = certificate;            byte[] authorityExtensionValue = certificate.getExtensionValue(Extension.authorityInfoAccess.getId());    if (authorityExtensionValue != null) {        CertInformationHelper.getAuthorityInfoExtensionValue(authorityExtensionValue, certInfo);    }    if (certInfo.issuerUrl != null) {        getAlternativeIssuerCertificate(certInfo, maxDepth);    }        byte[] crlExtensionValue = certificate.getExtensionValue(Extension.cRLDistributionPoints.getId());    if (crlExtensionValue != null) {        certInfo.crlUrl = CertInformationHelper.getCrlUrlFromExtensionValue(crlExtensionValue);    }    try {        certInfo.isSelfSigned = CertificateVerifier.isSelfSigned(certificate);    } catch (GeneralSecurityException ex) {        throw new CertificateProccessingException(ex);    }    if (maxDepth <= 0 || certInfo.isSelfSigned) {        return;    }    for (X509Certificate issuer : certificateSet) {        if (certificate.getIssuerX500Principal().equals(issuer.getSubjectX500Principal())) {            try {                certificate.verify(issuer.getPublicKey(), SecurityProvider.getProvider().getName());            } catch (CertificateException | NoSuchAlgorithmException | InvalidKeyException | SignatureException | NoSuchProviderException ex) {                throw new CertificateProccessingException(ex);            }                        certInfo.issuerCertificate = issuer;            certInfo.certChain = new CertSignatureInformation();            traverseChain(issuer, certInfo.certChain, maxDepth - 1);            break;        }    }    if (certInfo.issuerCertificate == null) {        throw new IOException("No Issuer Certificate found for Cert: " + certificate.getSubjectX500Principal());    }}
private void pdfbox_f804_1(CertSignatureInformation certInfo, int maxDepth) throws CertificateProccessingException
{        try {        URL certUrl = new URL(certInfo.issuerUrl);        CertificateFactory certFactory = CertificateFactory.getInstance("X.509");        try (InputStream in = certUrl.openStream()) {            X509Certificate altIssuerCert = (X509Certificate) certFactory.generateCertificate(in);            certificateSet.add(altIssuerCert);            certInfo.alternativeCertChain = new CertSignatureInformation();            traverseChain(altIssuerCert, certInfo.alternativeCertChain, maxDepth - 1);        }    } catch (IOException | CertificateException e) {            }}
private X509Certificate pdfbox_f805_1(X509CertificateHolder certificateHolder) throws CertificateProccessingException
{    try {        return certConverter.getCertificate(certificateHolder);    } catch (CertificateException e) {                throw new CertificateProccessingException(e);    }}
private void pdfbox_f806_1(Collection<X509CertificateHolder> certHolders)
{    for (X509CertificateHolder certificateHolder : certHolders) {        try {            X509Certificate certificate = getCertFromHolder(certificateHolder);            certificateSet.add(certificate);        } catch (CertificateProccessingException e) {                    }    }}
public void pdfbox_f807_0(X509CertificateHolder[] certHolders) throws CertificateProccessingException
{    addAllCerts(Arrays.asList(certHolders));}
 CertSignatureInformation pdfbox_f808_0(X509Certificate certificate) throws CertificateProccessingException
{    try {        CertSignatureInformation certSignatureInformation = new CertSignatureInformation();        traverseChain(certificate, certSignatureInformation, MAX_CERTIFICATE_CHAIN_DEPTH);        return certSignatureInformation;    } catch (IOException ex) {        throw new CertificateProccessingException(ex);    }}
public Set<X509Certificate> pdfbox_f809_0()
{    return certificateSet;}
public String pdfbox_f810_0()
{    return ocspUrl;}
public void pdfbox_f811_0(String ocspUrl)
{    this.ocspUrl = ocspUrl;}
public void pdfbox_f812_0(String issuerUrl)
{    this.issuerUrl = issuerUrl;}
public String pdfbox_f813_0()
{    return crlUrl;}
public X509Certificate pdfbox_f814_0()
{    return certificate;}
public boolean pdfbox_f815_0()
{    return isSelfSigned;}
public X509Certificate pdfbox_f816_0()
{    return issuerCertificate;}
public String pdfbox_f817_0()
{    return signatureHash;}
public CertSignatureInformation pdfbox_f818_0()
{    return certChain;}
public CertSignatureInformation pdfbox_f819_0()
{    return tsaCerts;}
public CertSignatureInformation pdfbox_f820_0()
{    return alternativeCertChain;}
protected static String pdfbox_f821_1(byte[] content)
{    try {        MessageDigest md = MessageDigest.getInstance("SHA-1");        return Hex.getString(md.digest(content));    } catch (NoSuchAlgorithmException e) {            }    return null;}
protected static void pdfbox_f822_0(byte[] extensionValue, CertSignatureInformation certInfo) throws IOException
{    ASN1Sequence asn1Seq = (ASN1Sequence) JcaX509ExtensionUtils.parseExtensionValue(extensionValue);    Enumeration<?> objects = asn1Seq.getObjects();    while (objects.hasMoreElements()) {                ASN1Sequence obj = (ASN1Sequence) objects.nextElement();        ASN1Encodable oid = obj.getObjectAt(0);                ASN1TaggedObject location = (ASN1TaggedObject) obj.getObjectAt(1);        if (X509ObjectIdentifiers.id_ad_ocsp.equals(oid) && location.getTagNo() == GeneralName.uniformResourceIdentifier) {            ASN1OctetString url = (ASN1OctetString) location.getObject();            certInfo.setOcspUrl(new String(url.getOctets()));        } else if (X509ObjectIdentifiers.id_ad_caIssuers.equals(oid)) {            ASN1OctetString uri = (ASN1OctetString) location.getObject();            certInfo.setIssuerUrl(new String(uri.getOctets()));        }    }}
protected static String pdfbox_f823_0(byte[] extensionValue) throws IOException
{    ASN1Sequence asn1Seq = (ASN1Sequence) JcaX509ExtensionUtils.parseExtensionValue(extensionValue);    Enumeration<?> objects = asn1Seq.getObjects();    while (objects.hasMoreElements()) {        DLSequence obj = (DLSequence) objects.nextElement();        ASN1TaggedObject taggedObject = (ASN1TaggedObject) obj.getObjectAt(0);        taggedObject = (ASN1TaggedObject) taggedObject.getObject();                taggedObject = (ASN1TaggedObject) taggedObject.getObject();        if (!(taggedObject.getObject() instanceof ASN1OctetString)) {                        continue;        }        ASN1OctetString uri = (ASN1OctetString) taggedObject.getObject();        String url = new String(uri.getOctets());                if (url.startsWith("http")) {            return url;        }    }    return null;}
public byte[] pdfbox_f824_0(InputStream content) throws IOException
{    return tsaClient.getTimeStampToken(IOUtils.toByteArray(content));}
public CMSSignedData pdfbox_f825_0(CMSSignedData signedData) throws IOException
{    SignerInformationStore signerStore = signedData.getSignerInfos();    List<SignerInformation> newSigners = new ArrayList<>();    for (SignerInformation signer : signerStore.getSigners()) {                newSigners.add(signTimeStamp(signer));    }        return CMSSignedData.replaceSigners(signedData, new SignerInformationStore(newSigners));}
private SignerInformation pdfbox_f826_0(SignerInformation signer) throws IOException
{    AttributeTable unsignedAttributes = signer.getUnsignedAttributes();    ASN1EncodableVector vector = new ASN1EncodableVector();    if (unsignedAttributes != null) {        vector = unsignedAttributes.toASN1EncodableVector();    }    byte[] token = tsaClient.getTimeStampToken(signer.getSignature());    ASN1ObjectIdentifier oid = PKCSObjectIdentifiers.id_aa_signatureTimeStampToken;    ASN1Encodable signatureTimeStamp = new Attribute(oid, new DERSet(ASN1Primitive.fromByteArray(token)));    vector.add(signatureTimeStamp);    Attributes signedAttributes = new Attributes(vector);        return SignerInformation.replaceUnsignedAttributes(signer, new AttributeTable(signedAttributes));}
public static void pdfbox_f827_0(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        File srcFile = new File(args[0]);        File dstFile = new File(args[1]);        String text = args[2];        try (PDDocument doc = PDDocument.load(srcFile)) {            for (PDPage page : doc.getPages()) {                PDFont font = PDType1Font.HELVETICA;                addWatermarkText(doc, page, font, text);            }            doc.save(dstFile);        }    }}
private static void pdfbox_f828_0(PDDocument doc, PDPage page, PDFont font, String text) throws IOException
{    try (PDPageContentStream cs = new PDPageContentStream(doc, page, PDPageContentStream.AppendMode.APPEND, true, true)) {                float fontHeight = 100;        float width = page.getMediaBox().getWidth();        float height = page.getMediaBox().getHeight();        float stringWidth = font.getStringWidth(text) / 1000 * fontHeight;        float diagonalLength = (float) Math.sqrt(width * width + height * height);        float angle = (float) Math.atan2(height, width);                float x = (diagonalLength - stringWidth) / 2;                float y = -fontHeight / 4;        cs.transform(Matrix.getRotateInstance(angle, 0, 0));        cs.setFont(font, fontHeight);                PDExtendedGraphicsState gs = new PDExtendedGraphicsState();        gs.setNonStrokingAlphaConstant(0.2f);        gs.setStrokingAlphaConstant(0.2f);        gs.setBlendMode(BlendMode.MULTIPLY);        gs.setLineWidth(3f);        cs.setGraphicsStateParameters(gs);                        cs.setNonStrokingColor(255, 0, 0);        cs.setStrokingColor(255, 0, 0);        cs.beginText();        cs.newLineAtOffset(x, y);        cs.showText(text);        cs.endText();    }}
private static void pdfbox_f829_0()
{    System.err.println("Usage: java " + AddWatermarkText.class.getName() + " <input-pdf> <output-pdf> <short text>");}
public static void pdfbox_f830_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            DrawPrintTextLocations stripper = new DrawPrintTextLocations(document, args[0]);            stripper.setSortByPosition(true);            for (int page = 0; page < document.getNumberOfPages(); ++page) {                stripper.stripPage(page);            }        }    }}
protected void pdfbox_f831_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    super.showGlyph(textRenderingMatrix, font, code, unicode, displacement);                    Shape cyanShape = calculateGlyphBounds(textRenderingMatrix, font, code);    if (cyanShape != null) {        cyanShape = flipAT.createTransformedShape(cyanShape);        cyanShape = rotateAT.createTransformedShape(cyanShape);        cyanShape = transAT.createTransformedShape(cyanShape);        g2d.setColor(Color.CYAN);        g2d.draw(cyanShape);    }}
private Shape pdfbox_f832_0(Matrix textRenderingMatrix, PDFont font, int code) throws IOException
{    GeneralPath path = null;    AffineTransform at = textRenderingMatrix.createAffineTransform();    at.concatenate(font.getFontMatrix().createAffineTransform());    if (font instanceof PDType3Font) {                                PDType3Font t3Font = (PDType3Font) font;        PDType3CharProc charProc = t3Font.getCharProc(code);        if (charProc != null) {            BoundingBox fontBBox = t3Font.getBoundingBox();            PDRectangle glyphBBox = charProc.getGlyphBBox();            if (glyphBBox != null) {                                glyphBBox.setLowerLeftX(Math.max(fontBBox.getLowerLeftX(), glyphBBox.getLowerLeftX()));                glyphBBox.setLowerLeftY(Math.max(fontBBox.getLowerLeftY(), glyphBBox.getLowerLeftY()));                glyphBBox.setUpperRightX(Math.min(fontBBox.getUpperRightX(), glyphBBox.getUpperRightX()));                glyphBBox.setUpperRightY(Math.min(fontBBox.getUpperRightY(), glyphBBox.getUpperRightY()));                path = glyphBBox.toGeneralPath();            }        }    } else if (font instanceof PDVectorFont) {        PDVectorFont vectorFont = (PDVectorFont) font;        path = vectorFont.getPath(code);        if (font instanceof PDTrueTypeFont) {            PDTrueTypeFont ttFont = (PDTrueTypeFont) font;            int unitsPerEm = ttFont.getTrueTypeFont().getHeader().getUnitsPerEm();            at.scale(1000d / unitsPerEm, 1000d / unitsPerEm);        }        if (font instanceof PDType0Font) {            PDType0Font t0font = (PDType0Font) font;            if (t0font.getDescendantFont() instanceof PDCIDFontType2) {                int unitsPerEm = ((PDCIDFontType2) t0font.getDescendantFont()).getTrueTypeFont().getHeader().getUnitsPerEm();                at.scale(1000d / unitsPerEm, 1000d / unitsPerEm);            }        }    } else {                System.out.println("Unknown font class: " + font.getClass());    }    if (path == null) {        return null;    }    return at.createTransformedShape(path.getBounds2D());}
private void pdfbox_f833_0(int page) throws IOException
{    PDFRenderer pdfRenderer = new PDFRenderer(document);    image = pdfRenderer.renderImage(page, SCALE);    PDPage pdPage = document.getPage(page);    PDRectangle cropBox = pdPage.getCropBox();        flipAT = new AffineTransform();    flipAT.translate(0, pdPage.getBBox().getHeight());    flipAT.scale(1, -1);        rotateAT = new AffineTransform();    int rotation = pdPage.getRotation();    if (rotation != 0) {        PDRectangle mediaBox = pdPage.getMediaBox();        switch(rotation) {            case 90:                rotateAT.translate(mediaBox.getHeight(), 0);                break;            case 270:                rotateAT.translate(0, mediaBox.getWidth());                break;            case 180:                rotateAT.translate(mediaBox.getWidth(), mediaBox.getHeight());                break;            default:                break;        }        rotateAT.rotate(Math.toRadians(rotation));    }        transAT = AffineTransform.getTranslateInstance(-cropBox.getLowerLeftX(), cropBox.getLowerLeftY());    g2d = image.createGraphics();    g2d.setStroke(new BasicStroke(0.1f));    g2d.scale(SCALE, SCALE);    setStartPage(page + 1);    setEndPage(page + 1);    Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());    writeText(document, dummy);        g2d.setStroke(new BasicStroke(0.4f));    List<PDThreadBead> pageArticles = pdPage.getThreadBeads();    for (PDThreadBead bead : pageArticles) {        if (bead == null) {            continue;        }        PDRectangle r = bead.getRectangle();        Shape s = r.toGeneralPath().createTransformedShape(transAT);        s = flipAT.createTransformedShape(s);        s = rotateAT.createTransformedShape(s);        g2d.setColor(Color.green);        g2d.draw(s);    }    g2d.dispose();    String imageFilename = filename;    int pt = imageFilename.lastIndexOf('.');    imageFilename = imageFilename.substring(0, pt) + "-marked-" + (page + 1) + ".png";    ImageIO.write(image, "png", new File(imageFilename));}
protected void pdfbox_f834_0(String string, List<TextPosition> textPositions) throws IOException
{    for (TextPosition text : textPositions) {        System.out.println("String[" + text.getXDirAdj() + "," + text.getYDirAdj() + " fs=" + text.getFontSize() + " xscale=" + text.getXScale() + " height=" + text.getHeightDir() + " space=" + text.getWidthOfSpace() + " width=" + text.getWidthDirAdj() + "]" + text.getUnicode());                        AffineTransform at = text.getTextMatrix().createAffineTransform();                                Rectangle2D.Float rect = new Rectangle2D.Float(0, 0, text.getWidthDirAdj() / text.getTextMatrix().getScalingFactorX(), text.getHeightDir() / text.getTextMatrix().getScalingFactorY());        Shape s = at.createTransformedShape(rect);        s = flipAT.createTransformedShape(s);        s = rotateAT.createTransformedShape(s);        g2d.setColor(Color.red);        g2d.draw(s);                                PDFont font = text.getFont();        BoundingBox bbox = font.getBoundingBox();                        float xadvance = font.getWidth(text.getCharacterCodes()[0]);        rect = new Rectangle2D.Float(0, bbox.getLowerLeftY(), xadvance, bbox.getHeight());        if (font instanceof PDType3Font) {                        at.concatenate(font.getFontMatrix().createAffineTransform());        } else {                        at.scale(1 / 1000f, 1 / 1000f);        }        s = at.createTransformedShape(rect);        s = flipAT.createTransformedShape(s);        s = rotateAT.createTransformedShape(s);        g2d.setColor(Color.blue);        g2d.draw(s);    }}
private static void pdfbox_f835_0()
{    System.err.println("Usage: java " + DrawPrintTextLocations.class.getName() + " <input-pdf>");}
public static void pdfbox_f836_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDFTextStripperByArea stripper = new PDFTextStripperByArea();            stripper.setSortByPosition(true);            Rectangle rect = new Rectangle(10, 280, 275, 60);            stripper.addRegion("class1", rect);            PDPage firstPage = document.getPage(0);            stripper.extractRegions(firstPage);            System.out.println("Text in the area:" + rect);            System.out.println(stripper.getTextForRegion("class1"));        }    }}
private static void pdfbox_f837_0()
{    System.err.println("Usage: java " + ExtractTextByArea.class.getName() + " <input-pdf>");}
public static void pdfbox_f838_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    }    try (PDDocument document = PDDocument.load(new File(args[0]))) {        AccessPermission ap = document.getCurrentAccessPermission();        if (!ap.canExtractContent()) {            throw new IOException("You do not have permission to extract text");        }        PDFTextStripper stripper = new PDFTextStripper();                                stripper.setSortByPosition(true);        for (int p = 1; p <= document.getNumberOfPages(); ++p) {                        stripper.setStartPage(p);            stripper.setEndPage(p);                        String text = stripper.getText(document);                        String pageStr = String.format("page %d:", p);            System.out.println(pageStr);            for (int i = 0; i < pageStr.length(); ++i) {                System.out.print("-");            }            System.out.println();            System.out.println(text.trim());            System.out.println();                                        }    }}
private static void pdfbox_f839_0()
{    System.err.println("Usage: java " + ExtractTextSimple.class.getName() + " <input-pdf>");    System.exit(-1);}
public void pdfbox_f840_0(PDDocument pdDocument, String highlightWord, Writer xmlOutput) throws IOException
{    generateXMLHighlight(pdDocument, new String[] { highlightWord }, xmlOutput);}
public void pdfbox_f841_0(PDDocument pdDocument, String[] sWords, Writer xmlOutput) throws IOException
{    highlighterOutput = xmlOutput;    searchedWords = sWords;    highlighterOutput.write("<XML>\n<Body units=characters " + " version=2>\n<Highlight>\n");    textOS = new ByteArrayOutputStream();    textWriter = new OutputStreamWriter(textOS, ENCODING);    writeText(pdDocument, textWriter);    highlighterOutput.write("</Highlight>\n</Body>\n</XML>");    highlighterOutput.flush();}
protected void pdfbox_f842_0(PDPage pdPage) throws IOException
{    textWriter.flush();    String page = new String(textOS.toByteArray(), ENCODING);    textOS.reset();        if (page.indexOf('a') != -1) {        page = page.replaceAll("a[0-9]{1,3}", ".");    }    for (String searchedWord : searchedWords) {        Pattern pattern = Pattern.compile(searchedWord, Pattern.CASE_INSENSITIVE);        Matcher matcher = pattern.matcher(page);        while (matcher.find()) {            int begin = matcher.start();            int end = matcher.end();            highlighterOutput.write("    <loc " + "pg=" + (getCurrentPageNo() - 1) + " pos=" + begin + " len=" + (end - begin) + ">\n");        }    }}
public static void pdfbox_f843_0(String[] args) throws IOException
{    PDFHighlighter xmlExtractor = new PDFHighlighter();    if (args.length < 2) {        usage();    }    String[] highlightStrings = new String[args.length - 1];    System.arraycopy(args, 1, highlightStrings, 0, highlightStrings.length);    try (PDDocument doc = PDDocument.load(new File(args[0]))) {        xmlExtractor.generateXMLHighlight(doc, highlightStrings, new OutputStreamWriter(System.out));    }}
private static void pdfbox_f844_0()
{    System.err.println("usage: java " + PDFHighlighter.class.getName() + " <pdf file> word1 word2 word3 ...");    System.exit(1);}
public InputStream pdfbox_f845_1(final List<InputStream> sources) throws IOException
{    String title = "My title";    String creator = "Alexander Kriegisch";    String subject = "Subject with umlauts ";    ByteArrayOutputStream mergedPDFOutputStream = null;    COSStream cosStream = null;    try {                        mergedPDFOutputStream = new ByteArrayOutputStream();        cosStream = new COSStream();        PDFMergerUtility pdfMerger = createPDFMergerUtility(sources, mergedPDFOutputStream);                PDDocumentInformation pdfDocumentInfo = createPDFDocumentInfo(title, creator, subject);        PDMetadata xmpMetadata = createXMPMetadata(cosStream, title, creator, subject);        pdfMerger.setDestinationDocumentInformation(pdfDocumentInfo);        pdfMerger.setDestinationMetadata(xmpMetadata);                pdfMerger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());                return new ByteArrayInputStream(mergedPDFOutputStream.toByteArray());    } catch (BadFieldValueException | TransformerException e) {        throw new IOException("PDF merge problem", e);    } finally {        sources.forEach(IOUtils::closeQuietly);        IOUtils.closeQuietly(cosStream);        IOUtils.closeQuietly(mergedPDFOutputStream);    }}
private PDFMergerUtility pdfbox_f846_1(List<InputStream> sources, ByteArrayOutputStream mergedPDFOutputStream)
{        PDFMergerUtility pdfMerger = new PDFMergerUtility();    pdfMerger.addSources(sources);    pdfMerger.setDestinationStream(mergedPDFOutputStream);    return pdfMerger;}
private PDDocumentInformation pdfbox_f847_1(String title, String creator, String subject)
{        PDDocumentInformation documentInformation = new PDDocumentInformation();    documentInformation.setTitle(title);    documentInformation.setCreator(creator);    documentInformation.setSubject(subject);    return documentInformation;}
private PDMetadata pdfbox_f848_1(COSStream cosStream, String title, String creator, String subject) throws BadFieldValueException, TransformerException, IOException
{        XMPMetadata xmpMetadata = XMPMetadata.createXMPMetadata();        PDFAIdentificationSchema pdfaSchema = xmpMetadata.createAndAddPFAIdentificationSchema();    pdfaSchema.setPart(1);    pdfaSchema.setConformance("B");        DublinCoreSchema dublinCoreSchema = xmpMetadata.createAndAddDublinCoreSchema();    dublinCoreSchema.setTitle(title);    dublinCoreSchema.addCreator(creator);    dublinCoreSchema.setDescription(subject);        XMPBasicSchema basicSchema = xmpMetadata.createAndAddXMPBasicSchema();    Calendar creationDate = Calendar.getInstance();    basicSchema.setCreateDate(creationDate);    basicSchema.setModifyDate(creationDate);    basicSchema.setMetadataDate(creationDate);    basicSchema.setCreatorTool(creator);        try (ByteArrayOutputStream xmpOutputStream = new ByteArrayOutputStream();        OutputStream cosXMPStream = cosStream.createOutputStream()) {        new XmpSerializer().serialize(xmpMetadata, xmpOutputStream, true);        cosXMPStream.write(xmpOutputStream.toByteArray());        return new PDMetadata(cosStream);    }}
public static void pdfbox_f849_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PrintImageLocations printer = new PrintImageLocations();            int pageNum = 0;            for (PDPage page : document.getPages()) {                pageNum++;                System.out.println("Processing page: " + pageNum);                printer.processPage(page);            }        }    }}
protected void pdfbox_f850_0(Operator operator, List<COSBase> operands) throws IOException
{    String operation = operator.getName();    if (OperatorName.DRAW_OBJECT.equals(operation)) {        COSName objectName = (COSName) operands.get(0);        PDXObject xobject = getResources().getXObject(objectName);        if (xobject instanceof PDImageXObject) {            PDImageXObject image = (PDImageXObject) xobject;            int imageWidth = image.getWidth();            int imageHeight = image.getHeight();            System.out.println("*******************************************************************");            System.out.println("Found image [" + objectName.getName() + "]");            Matrix ctmNew = getGraphicsState().getCurrentTransformationMatrix();            float imageXScale = ctmNew.getScalingFactorX();            float imageYScale = ctmNew.getScalingFactorY();                        System.out.println("position in PDF = " + ctmNew.getTranslateX() + ", " + ctmNew.getTranslateY() + " in user space units");                        System.out.println("raw image size  = " + imageWidth + ", " + imageHeight + " in pixels");                        System.out.println("displayed size  = " + imageXScale + ", " + imageYScale + " in user space units");                        imageXScale /= 72;            imageYScale /= 72;            System.out.println("displayed size  = " + imageXScale + ", " + imageYScale + " in inches at 72 dpi rendering");                        imageXScale *= 25.4;            imageYScale *= 25.4;            System.out.println("displayed size  = " + imageXScale + ", " + imageYScale + " in millimeters at 72 dpi rendering");            System.out.println();        } else if (xobject instanceof PDFormXObject) {            PDFormXObject form = (PDFormXObject) xobject;            showForm(form);        }    } else {        super.processOperator(operator, operands);    }}
private static void pdfbox_f851_0()
{    System.err.println("Usage: java " + PrintImageLocations.class.getName() + " <input-pdf>");}
public static void pdfbox_f852_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDFTextStripper stripper = new PrintTextColors();            stripper.setSortByPosition(true);            stripper.setStartPage(0);            stripper.setEndPage(document.getNumberOfPages());            Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());            stripper.writeText(document, dummy);        }    }}
protected void pdfbox_f853_0(TextPosition text)
{    super.processTextPosition(text);    PDColor strokingColor = getGraphicsState().getStrokingColor();    PDColor nonStrokingColor = getGraphicsState().getNonStrokingColor();    String unicode = text.getUnicode();    RenderingMode renderingMode = getGraphicsState().getTextState().getRenderingMode();    System.out.println("Unicode:            " + unicode);    System.out.println("Rendering mode:     " + renderingMode);    System.out.println("Stroking color:     " + strokingColor);    System.out.println("Non-Stroking color: " + nonStrokingColor);    System.out.println("Non-Stroking color: " + nonStrokingColor);    System.out.println();}
private static void pdfbox_f854_0()
{    System.err.println("Usage: java " + PrintTextColors.class.getName() + " <input-pdf>");}
public static void pdfbox_f855_0(String[] args) throws IOException
{    if (args.length != 1) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            PDFTextStripper stripper = new PrintTextLocations();            stripper.setSortByPosition(true);            stripper.setStartPage(0);            stripper.setEndPage(document.getNumberOfPages());            Writer dummy = new OutputStreamWriter(new ByteArrayOutputStream());            stripper.writeText(document, dummy);        }    }}
protected void pdfbox_f856_0(String string, List<TextPosition> textPositions) throws IOException
{    for (TextPosition text : textPositions) {        System.out.println("String[" + text.getXDirAdj() + "," + text.getYDirAdj() + " fs=" + text.getFontSize() + " xscale=" + text.getXScale() + " height=" + text.getHeightDir() + " space=" + text.getWidthOfSpace() + " width=" + text.getWidthDirAdj() + "]" + text.getUnicode());    }}
private static void pdfbox_f857_0()
{    System.err.println("Usage: java " + PrintTextLocations.class.getName() + " <input-pdf>");}
public static void pdfbox_f858_0(String[] args) throws IOException
{    if (args.length != 2) {        usage();    } else {        try (PDDocument document = PDDocument.load(new File(args[0]))) {            if (document.isEncrypted()) {                System.err.println("Error: Encrypted documents are not supported for this example.");                System.exit(1);            }            for (PDPage page : document.getPages()) {                List<Object> newTokens = createTokensWithoutText(page);                PDStream newContents = new PDStream(document);                writeTokensToStream(newContents, newTokens);                page.setContents(newContents);                processResources(page.getResources());            }            document.save(args[1]);        }    }}
private static void pdfbox_f859_0(PDResources resources) throws IOException
{    for (COSName name : resources.getXObjectNames()) {        PDXObject xobject = resources.getXObject(name);        if (xobject instanceof PDFormXObject) {            PDFormXObject formXObject = (PDFormXObject) xobject;            writeTokensToStream(formXObject.getContentStream(), createTokensWithoutText(formXObject));            processResources(formXObject.getResources());        }    }    for (COSName name : resources.getPatternNames()) {        PDAbstractPattern pattern = resources.getPattern(name);        if (pattern instanceof PDTilingPattern) {            PDTilingPattern tilingPattern = (PDTilingPattern) pattern;            writeTokensToStream(tilingPattern.getContentStream(), createTokensWithoutText(tilingPattern));            processResources(tilingPattern.getResources());        }    }}
private static void pdfbox_f860_0(PDStream newContents, List<Object> newTokens) throws IOException
{    try (OutputStream out = newContents.createOutputStream(COSName.FLATE_DECODE)) {        ContentStreamWriter writer = new ContentStreamWriter(out);        writer.writeTokens(newTokens);    }}
private static List<Object> pdfbox_f861_0(PDContentStream contentStream) throws IOException
{    PDFStreamParser parser = new PDFStreamParser(contentStream.getContents());    Object token = parser.parseNextToken();    List<Object> newTokens = new ArrayList<>();    while (token != null) {        if (token instanceof Operator) {            Operator op = (Operator) token;            String opName = op.getName();            if (OperatorName.SHOW_TEXT_ADJUSTED.equals(opName) || OperatorName.SHOW_TEXT.equals(opName) || OperatorName.SHOW_TEXT_LINE.equals(opName)) {                                newTokens.remove(newTokens.size() - 1);                token = parser.parseNextToken();                continue;            } else if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(opName)) {                                newTokens.remove(newTokens.size() - 1);                newTokens.remove(newTokens.size() - 1);                newTokens.remove(newTokens.size() - 1);                token = parser.parseNextToken();                continue;            }        }        newTokens.add(token);        token = parser.parseNextToken();    }    return newTokens;}
private static void pdfbox_f862_0()
{    System.err.println("Usage: java " + RemoveAllText.class.getName() + " <input-pdf> <output-pdf>");}
protected void pdfbox_f863_0() throws Exception
{    super.setUp();    new File(outDir).mkdirs();}
public void pdfbox_f864_0() throws Exception
{    System.out.println("testCreatePDFA");    String pdfaFilename = outDir + "/PDFA.pdf";    String message = "The quick brown fox jumps over the lazy dog  @^ {[]}";    String dir = "../pdfbox/src/main/resources/org/apache/pdfbox/resources/ttf/";    String fontfile = dir + "LiberationSans-Regular.ttf";    CreatePDFA.main(new String[] { pdfaFilename, message, fontfile });    PreflightParser preflightParser = new PreflightParser(new File(pdfaFilename));    preflightParser.parse();    try (PreflightDocument preflightDocument = preflightParser.getPreflightDocument()) {        preflightDocument.validate();        ValidationResult result = preflightDocument.getResult();        for (ValidationError ve : result.getErrorsList()) {            System.err.println(ve.getErrorCode() + ": " + ve.getDetails());        }        assertTrue("PDF file created with CreatePDFA is not valid PDF/A-1b", result.isValid());    }        try (PDDocument document = PDDocument.load(new File(pdfaFilename))) {        PDDocumentCatalog catalog = document.getDocumentCatalog();        PDMetadata meta = catalog.getMetadata();        DomXmpParser xmpParser = new DomXmpParser();        XMPMetadata metadata = xmpParser.parse(meta.createInputStream());        DublinCoreSchema dc = metadata.getDublinCoreSchema();        assertEquals(pdfaFilename, dc.getTitle());    }}
public static Collection pdfbox_f865_0()
{    return Arrays.asList(false, true);}
public static void pdfbox_f866_0() throws Exception
{    new File("target/test-output").mkdirs();    KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());    certificate = keystore.getCertificateChain(keystore.aliases().nextElement())[0];}
public void pdfbox_f867_0() throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        CreateSignature signing = new CreateSignature(keystore, password.toCharArray());    signing.setExternalSigning(externallySign);    final String fileName = getOutputFileName("signed{0}.pdf");    signing.signDetached(new File(inDir + "sign_me.pdf"), new File(outDir + fileName));    checkSignature(new File(inDir, "sign_me.pdf"), new File(outDir, fileName));}
public void pdfbox_f868_0() throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{    byte[] content;        try (InputStream input = new FileInputStream(inDir + "tsa_response.asn1")) {        content = IOUtils.toByteArray(input);    }        MockHttpServer mockServer = new MockHttpServer(15371);    mockServer.startServer();    String tsaUrl = "http://localhost:" + mockServer.getServerPort() + "/";    MockHttpServer.MockHttpServerResponse response = new MockHttpServer.MockHttpServerResponse();    response.setMockResponseContent(content);    response.setMockResponseContentType("application/timestamp-reply");    response.setMockResponseCode(200);    mockServer.setMockHttpServerResponses(response);        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        try {        String inPath = inDir + "sign_me_tsa.pdf";        String outPath = outDir + getOutputFileName("signed{0}_tsa.pdf");        CreateSignature signing = new CreateSignature(keystore, password.toCharArray());        signing.setExternalSigning(externallySign);        signing.signDetached(new File(inPath), new File(outPath), tsaUrl);    } catch (IOException e) {        Assert.assertTrue(e.getCause() instanceof TSPValidationException);    }}
public void pdfbox_f869_0() throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        String inPath = inDir + "sign_me.pdf";    File destFile;    try (FileInputStream fis = new FileInputStream(jpegPath)) {        CreateVisibleSignature signing = new CreateVisibleSignature(keystore, password.toCharArray());        signing.setVisibleSignDesigner(inPath, 0, 0, -50, fis, 1);        signing.setVisibleSignatureProperties("name", "location", "Security", 0, 1, true);        signing.setExternalSigning(externallySign);        destFile = new File(outDir + getOutputFileName("signed{0}_visible.pdf"));        signing.signPDF(new File(inPath), destFile, null);    }    checkSignature(new File(inPath), destFile);}
public void pdfbox_f870_0() throws IOException, NoSuchAlgorithmException, KeyStoreException, CertificateException, UnrecoverableKeyException, CMSException, OperatorCreationException, GeneralSecurityException
{    String filename = outDir + "EmptySignatureForm.pdf";    String filenameSigned1 = outDir + "EmptySignatureForm-signed1.pdf";    String filenameSigned2 = outDir + "EmptySignatureForm-signed2.pdf";    if (!externallySign) {        return;    }        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        CreateEmptySignatureForm.main(new String[] { filename });        CreateSignature signing1 = new CreateSignature(keystore, password.toCharArray());    signing1.setExternalSigning(false);    signing1.signDetached(new File(filename), new File(filenameSigned1));    checkSignature(new File(filename), new File(filenameSigned1));    try (PDDocument doc1 = PDDocument.load(new File(filenameSigned1))) {        List<PDSignature> signatureDictionaries = doc1.getSignatureDictionaries();        Assert.assertEquals(1, signatureDictionaries.size());    }        try (FileInputStream fis = new FileInputStream(jpegPath)) {        CreateVisibleSignature signing2 = new CreateVisibleSignature(keystore, password.toCharArray());        signing2.setVisibleSignDesigner(filenameSigned1, 0, 0, -50, fis, 1);        signing2.setVisibleSignatureProperties("name", "location", "Security", 0, 1, true);        signing2.setExternalSigning(externallySign);        signing2.signPDF(new File(filenameSigned1), new File(filenameSigned2), null, "Signature1");    }    checkSignature(new File(filenameSigned1), new File(filenameSigned2));    try (PDDocument doc2 = PDDocument.load(new File(filenameSigned2))) {        List<PDSignature> signatureDictionaries = doc2.getSignatureDictionaries();        Assert.assertEquals(2, signatureDictionaries.size());    }}
private String pdfbox_f871_0(String filePattern)
{    return MessageFormat.format(filePattern, (externallySign ? "_ext" : ""));}
private void pdfbox_f872_0(File origFile, File signedFile) throws IOException, CMSException, OperatorCreationException, GeneralSecurityException
{    String origPageKey;    try (PDDocument document = PDDocument.load(origFile)) {                origPageKey = document.getDocumentCatalog().getCOSObject().getItem(COSName.PAGES).toString();    }    try (PDDocument document = PDDocument.load(signedFile)) {                Assert.assertEquals(origPageKey, document.getDocumentCatalog().getCOSObject().getItem(COSName.PAGES).toString());        List<PDSignature> signatureDictionaries = document.getSignatureDictionaries();        if (signatureDictionaries.isEmpty()) {            Assert.fail("no signature found");        }        for (PDSignature sig : document.getSignatureDictionaries()) {            COSString contents = (COSString) sig.getCOSObject().getDictionaryObject(COSName.CONTENTS);            byte[] buf = sig.getSignedContent(new FileInputStream(signedFile));                        try (FileInputStream fis = new FileInputStream(signedFile)) {                byte[] buf2 = sig.getSignedContent(IOUtils.toByteArray(fis));                Assert.assertArrayEquals(buf, buf2);            }                        try (FileInputStream fis = new FileInputStream(signedFile)) {                byte[] contents2 = sig.getContents(IOUtils.toByteArray(fis));                Assert.assertArrayEquals(contents.getBytes(), contents2);            }            byte[] contents3 = sig.getContents(new FileInputStream(signedFile));            Assert.assertArrayEquals(contents.getBytes(), contents3);                                                CMSSignedData signedData = new CMSSignedData(new CMSProcessableByteArray(buf), contents.getBytes());            Store<X509CertificateHolder> certificatesStore = signedData.getCertificates();            Collection<SignerInformation> signers = signedData.getSignerInfos().getSigners();            SignerInformation signerInformation = signers.iterator().next();            @SuppressWarnings("unchecked")            Collection matches = certificatesStore.getMatches((Selector<X509CertificateHolder>) signerInformation.getSID());            X509CertificateHolder certificateHolder = (X509CertificateHolder) matches.iterator().next();            X509Certificate certFromSignedData = new JcaX509CertificateConverter().getCertificate(certificateHolder);            Assert.assertEquals(certificate, certFromSignedData);                        if (!signerInformation.verify(new JcaSimpleSignerInfoVerifierBuilder().build(certFromSignedData))) {                Assert.fail("Signature verification failed");            }            break;        }    }}
private String pdfbox_f873_0(InputStream inputStream) throws NoSuchAlgorithmException, IOException
{    MessageDigest md = MessageDigest.getInstance("SHA-256");    return Hex.getString(md.digest(IOUtils.toByteArray(inputStream)));}
public void pdfbox_f874_0() throws IOException, NoSuchAlgorithmException
{    if (!externallySign) {        return;    }        PDDocument document = new PDDocument();    PDPage page = new PDPage();    document.addPage(page);    new PDPageContentStream(document, page).close();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    document.save(baos);    document.close();    document = PDDocument.load(baos.toByteArray());        document.setDocumentId(12345L);    PDSignature signature = new PDSignature();    signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);    signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);    document.addSignature(signature);    int[] reserveByteRange = signature.getByteRange();    String digestString = calculateDigestString(document.saveIncrementalForExternalSigning(new ByteArrayOutputStream()).getContent());    boolean caught = false;    try {        document.saveIncrementalForExternalSigning(new ByteArrayOutputStream());    } catch (IllegalStateException ex) {        caught = true;    }    Assert.assertTrue("IllegalStateException should have been thrown", caught);    signature.setByteRange(reserveByteRange);    Assert.assertEquals(digestString, calculateDigestString(document.saveIncrementalForExternalSigning(new ByteArrayOutputStream()).getContent()));}
public void pdfbox_f875_0() throws Exception
{    BufferedImage oldImage, expectedImage1, actualImage1, expectedImage2, actualImage2;        CreateSimpleForm.main(new String[0]);        KeyStore keystore = KeyStore.getInstance("PKCS12");    keystore.load(new FileInputStream(keystorePath), password.toCharArray());        CreateSignature signing = new CreateSignature(keystore, password.toCharArray());    signing.setExternalSigning(externallySign);    final String fileNameSigned = getOutputFileName("SimpleForm_signed{0}.pdf");    final String fileNameResaved1 = getOutputFileName("SimpleForm_signed{0}_incrementallyresaved1.pdf");    final String fileNameResaved2 = getOutputFileName("SimpleForm_signed{0}_incrementallyresaved2.pdf");    signing.signDetached(new File("target/SimpleForm.pdf"), new File(outDir + fileNameSigned));    checkSignature(new File("target/SimpleForm.pdf"), new File(outDir, fileNameSigned));    try (PDDocument doc = PDDocument.load(new File(outDir, fileNameSigned))) {        oldImage = new PDFRenderer(doc).renderImage(0);        FileOutputStream fileOutputStream = new FileOutputStream(new File(outDir, fileNameResaved1));        PDField field = doc.getDocumentCatalog().getAcroForm().getField("SampleField");        field.setValue("New Value 1");                Collection<COSName> fonts = (Collection<COSName>) field.getWidgets().get(0).getAppearance().getNormalAppearance().getAppearanceStream().getResources().getFontNames();        Assert.assertTrue(fonts.contains(COSName.HELV));        Assert.assertEquals(1, fonts.size());        expectedImage1 = new PDFRenderer(doc).renderImage(0);                Assert.assertEquals(oldImage.getWidth(), expectedImage1.getWidth());        Assert.assertEquals(oldImage.getHeight(), expectedImage1.getHeight());        Assert.assertEquals(oldImage.getType(), expectedImage1.getType());        DataBufferInt expectedData = (DataBufferInt) oldImage.getRaster().getDataBuffer();        DataBufferInt actualData = (DataBufferInt) expectedImage1.getRaster().getDataBuffer();        Assert.assertEquals(expectedData.getData().length, actualData.getData().length);        Assert.assertFalse(Arrays.equals(expectedData.getData(), actualData.getData()));                doc.getDocumentCatalog().getCOSObject().setNeedToBeUpdated(true);        doc.getDocumentCatalog().getAcroForm().getCOSObject().setNeedToBeUpdated(true);        field.getCOSObject().setNeedToBeUpdated(true);        field.getWidgets().get(0).getAppearance().getCOSObject().setNeedToBeUpdated(true);        ((COSDictionary) field.getWidgets().get(0).getAppearance().getNormalAppearance().getCOSObject()).setNeedToBeUpdated(true);        doc.saveIncremental(fileOutputStream);    }    checkSignature(new File("target/SimpleForm.pdf"), new File(outDir, fileNameResaved1));    try (PDDocument doc = PDDocument.load(new File(outDir, fileNameResaved1))) {        PDField field = doc.getDocumentCatalog().getAcroForm().getField("SampleField");        Assert.assertEquals("New Value 1", field.getValueAsString());        actualImage1 = new PDFRenderer(doc).renderImage(0);                Assert.assertEquals(expectedImage1.getWidth(), actualImage1.getWidth());        Assert.assertEquals(expectedImage1.getHeight(), actualImage1.getHeight());        Assert.assertEquals(expectedImage1.getType(), actualImage1.getType());        DataBufferInt expectedData = (DataBufferInt) expectedImage1.getRaster().getDataBuffer();        DataBufferInt actualData = (DataBufferInt) actualImage1.getRaster().getDataBuffer();        Assert.assertArrayEquals(expectedData.getData(), actualData.getData());    }}
public void pdfbox_f876_0() throws IOException
{    String documentFile = "src/test/resources/org/apache/pdfbox/examples/pdmodel/document.pdf";    String stampFile = "src/test/resources/org/apache/pdfbox/examples/pdmodel/stamp.jpg";    String outFile = "target/test-output/TestRubberStampWithImage.pdf";    new File("target/test-output").mkdirs();    String[] args = new String[] { documentFile, outFile, stampFile };    RubberStampWithImage rubberStamp = new RubberStampWithImage();    rubberStamp.doIt(args);}
public void pdfbox_f877_0(Map<String, String> headers)
{    mockResponseHeaders.clear();    mockResponseHeaders.putAll(headers);}
public void pdfbox_f878_0(String name, String value)
{    mockResponseHeaders.put(name, value);}
public Map<String, String> pdfbox_f879_0()
{    return mockResponseHeaders;}
public void pdfbox_f880_0(int responseCode)
{    this.mockResponseCode = responseCode;}
public int pdfbox_f881_0()
{    return mockResponseCode;}
public void pdfbox_f882_0(String content)
{    mockResponseContent = content.getBytes();}
public void pdfbox_f883_0(byte[] content)
{    mockResponseContent = content;}
public byte[] pdfbox_f884_0()
{    return mockResponseContent;}
public void pdfbox_f885_0(String type)
{    mockResponseContentType = type;}
public String pdfbox_f886_0()
{    return mockResponseContentType;}
public void pdfbox_f887_0(boolean echo)
{    mockResponseContentEchoRequest = echo;}
public boolean pdfbox_f888_0()
{    return mockResponseContentEchoRequest;}
public synchronized void pdfbox_f889_0()
{    if (serverStarted)        return;        start();    serverStarted = true;        waitForServerToStart();}
private synchronized void pdfbox_f890_0()
{    try {        wait(5000);    } catch (InterruptedException e) {        throw new RuntimeException(e);    }}
private synchronized void pdfbox_f891_0()
{    try {        wait(5000);    } catch (InterruptedException e) {        throw new RuntimeException(e);    }}
public void pdfbox_f892_0()
{    serverThread = Thread.currentThread();    executeLoop();}
private void pdfbox_f893_0()
{    serverStarted();    try {        while (true) {            Socket socket = serverSocket.accept();            HttpProcessor processor = new HttpProcessor(socket);            processor.run();        }    } catch (IOException e) {        if (e instanceof SocketException) {            if (!("Socket closed".equalsIgnoreCase(e.getMessage()) || "Socket is closed".equalsIgnoreCase(e.getMessage()))) {                e.printStackTrace();                throw new RuntimeException(e);            }        } else {            e.printStackTrace();            throw new RuntimeException(e);        }    } finally {                serverStopped();    }}
private synchronized void pdfbox_f894_0()
{        notifyAll();}
private synchronized void pdfbox_f895_0()
{        notifyAll();}
public synchronized void pdfbox_f896_0()
{    if (!serverStarted)        return;    try {        serverStarted = false;                serverThread.interrupt();                serverSocket.close();                waitForServerToStop();    } catch (IOException e) {        e.printStackTrace();    }}
public void pdfbox_f897_0()
{    try {        processRequest(socket);        processResponse(socket);    } catch (IOException e) {        if (e instanceof SocketException) {            if (!("socket closed".equalsIgnoreCase(e.getMessage()))) {                e.printStackTrace();                throw new RuntimeException(e);            }        } else {            e.printStackTrace();            throw new RuntimeException(e);        }    } finally {        try {            socket.shutdownOutput();            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}
private void pdfbox_f898_0(Socket socket) throws IOException
{    requestContent.reset();    BufferedInputStream is = new BufferedInputStream(socket.getInputStream());    String requestMethodHeader = new String(readLine(is));    processRequestMethod(requestMethodHeader);    processRequestHeaders(is);    processRequestContent(is);}
private void pdfbox_f899_0(String requestMethodHeader)
{    String[] parts = requestMethodHeader.split(" ");    if (parts.length < 2) {        throw new RuntimeException("illegal http request");    }    requestMethod = parts[0];    requestUrl = parts[1];}
private void pdfbox_f900_0(InputStream is) throws IOException
{    requestHeaders.clear();    byte[] line;    while ((line = readLine(is)) != null) {        String lineStr = new String(line);                if ("".equals(lineStr.trim())) {            break;        }        addRequestHeader(lineStr);    }}
private void pdfbox_f901_0(InputStream is) throws NumberFormatException, IOException
{    if (!("PUT".equals(requestMethod) || "POST".equals(requestMethod))) {        return;    }    List<String> transferEncodingValues = requestHeaders.get("Transfer-Encoding");    String transferEncoding = (transferEncodingValues == null || transferEncodingValues.isEmpty()) ? null : transferEncodingValues.get(0);    if ("chunked".equals(transferEncoding)) {        processChunkedContent(is);    } else {        processRegularContent(is);    }    if (mockHttpServerResponses.get(responseCounter).getMockResponseContentEchoRequest()) {        mockHttpServerResponses.get(responseCounter).setMockResponseContent(requestContent.toByteArray());    }}
private void pdfbox_f902_0(InputStream is) throws IOException
{    List<String> contentLengthValues = requestHeaders.get("Content-Length");    String contentLength = (contentLengthValues == null || contentLengthValues.isEmpty()) ? null : contentLengthValues.get(0);    if (contentLength == null) {        return;    }    int contentLen = Integer.parseInt(contentLength);    byte[] bytes = new byte[contentLen];    is.read(bytes);    requestContent.write(bytes);}
private void pdfbox_f903_0(InputStream is) throws IOException
{    requestContent.write("".getBytes());    byte[] chunk;    byte[] line = null;    boolean lastChunk = false;        while (!lastChunk && (line = readLine(is)) != null) {        String lineStr = new String(line);                if ("0".equals(lineStr)) {            lastChunk = true;        }        if (!lastChunk) {                                    int chunkLen = Integer.parseInt(lineStr, 16);                        chunk = getChunk(is, chunkLen);                                                readLine(is);            requestContent.write(chunk);        }    }        if (lastChunk) {        readLine(is);    }}
private byte[] pdfbox_f904_0(InputStream is) throws IOException
{    int n;    ByteArrayOutputStream tmpOs = new ByteArrayOutputStream();    while ((n = is.read()) != -1) {        if (n == '\r') {            n = is.read();            if (n == '\n') {                return tmpOs.toByteArray();            } else {                tmpOs.write('\r');                if (n != -1) {                    tmpOs.write(n);                } else {                    return tmpOs.toByteArray();                }            }        } else if (n == '\n') {            return tmpOs.toByteArray();        } else {            tmpOs.write(n);        }    }    return tmpOs.toByteArray();}
private byte[] pdfbox_f905_0(InputStream is, int len) throws IOException
{    ByteArrayOutputStream chunk = new ByteArrayOutputStream();    int read;    int totalRead = 0;    byte[] bytes = new byte[512];        while (totalRead < len) {        read = is.read(bytes, 0, Math.min(bytes.length, len - totalRead));        chunk.write(bytes, 0, read);        totalRead += read;    }    return chunk.toByteArray();}
private void pdfbox_f906_0(String line)
{    String[] parts = line.split(": ");    List<String> values = requestHeaders.get(parts[0]);    if (values == null) {        values = new ArrayList<>();        requestHeaders.put(parts[0], values);    }    values.add(parts[1]);}
private void pdfbox_f907_0(Socket socket) throws IOException
{        if (!delayResponse())        return;    OutputStream sos = socket.getOutputStream();    BufferedOutputStream os = new BufferedOutputStream(sos);    String reason = "";    Status statusCode = Response.Status.fromStatusCode(mockHttpServerResponses.get(responseCounter).getMockResponseCode());    if (statusCode != null) {        reason = statusCode.toString();    }    os.write(("HTTP/1.1 " + mockHttpServerResponses.get(responseCounter).getMockResponseCode() + " " + reason).getBytes());    os.write(NEW_LINE);    processResponseHeaders(os);    processResponseContent(os);    os.flush();    responseCounter++;}
private boolean pdfbox_f908_0()
{        if (delayResponseTime > 0) {        try {            Thread.sleep(delayResponseTime);            return true;        } catch (InterruptedException e) {            return false;        }    }    return true;}
private void pdfbox_f909_0(OutputStream os) throws IOException
{    if (mockHttpServerResponses.get(responseCounter).getMockResponseContent() == null) {        return;    }    os.write(mockHttpServerResponses.get(responseCounter).getMockResponseContent());}
private void pdfbox_f910_0(OutputStream os) throws IOException
{    addServerResponseHeaders();    for (String header : mockHttpServerResponses.get(responseCounter).getMockResponseHeaders().keySet()) {        os.write((header + ": " + mockHttpServerResponses.get(responseCounter).getMockResponseHeaders().get(header)).getBytes());        os.write(NEW_LINE);    }    os.write(NEW_LINE);}
private void pdfbox_f911_0()
{    Map<String, String> mockResponseHeaders = mockHttpServerResponses.get(responseCounter).getMockResponseHeaders();    mockResponseHeaders.put("Content-Type", mockHttpServerResponses.get(responseCounter).getMockResponseContentType());    mockResponseHeaders.put("Content-Length", mockHttpServerResponses.get(responseCounter).getMockResponseContent().length + "");    mockResponseHeaders.put("Server", "Mock HTTP Server v1.0");    mockResponseHeaders.put("Connection", "closed");}
public void pdfbox_f912_0(int milliseconds)
{    readTimeOut = milliseconds;}
public void pdfbox_f913_0(int milliseconds)
{    delayResponseTime = milliseconds;}
public String pdfbox_f914_0()
{    return requestContent.toString();}
public byte[] pdfbox_f915_0()
{    return requestContent.toByteArray();}
public Map<String, List<String>> pdfbox_f916_0()
{    return requestHeaders;}
public String pdfbox_f917_0()
{    return requestMethod;}
public String pdfbox_f918_0()
{    return requestUrl;}
public void pdfbox_f919_0(MockHttpServerResponse... responses)
{    mockHttpServerResponses.clear();    mockHttpServerResponses.addAll(Arrays.asList(responses));}
public List<MockHttpServerResponse> pdfbox_f920_0()
{    return mockHttpServerResponses;}
public void pdfbox_f921_0(int serverPort)
{    this.serverPort = serverPort;}
public int pdfbox_f922_0()
{    return serverPort;}
public FontMetrics pdfbox_f923_0() throws IOException
{    return parseFontMetric(false);}
public FontMetrics pdfbox_f924_0(boolean reducedDataset) throws IOException
{    return parseFontMetric(reducedDataset);}
private FontMetrics pdfbox_f925_0(boolean reducedDataset) throws IOException
{    FontMetrics fontMetrics = new FontMetrics();    String startFontMetrics = readString();    if (!START_FONT_METRICS.equals(startFontMetrics)) {        throw new IOException("Error: The AFM file should start with " + START_FONT_METRICS + " and not '" + startFontMetrics + "'");    }    fontMetrics.setAFMVersion(readFloat());    String nextCommand;    boolean charMetricsRead = false;    while (!END_FONT_METRICS.equals(nextCommand = readString())) {        switch(nextCommand) {            case FONT_NAME:                fontMetrics.setFontName(readLine());                break;            case FULL_NAME:                fontMetrics.setFullName(readLine());                break;            case FAMILY_NAME:                fontMetrics.setFamilyName(readLine());                break;            case WEIGHT:                fontMetrics.setWeight(readLine());                break;            case FONT_BBOX:                BoundingBox bBox = new BoundingBox();                bBox.setLowerLeftX(readFloat());                bBox.setLowerLeftY(readFloat());                bBox.setUpperRightX(readFloat());                bBox.setUpperRightY(readFloat());                fontMetrics.setFontBBox(bBox);                break;            case VERSION:                fontMetrics.setFontVersion(readLine());                break;            case NOTICE:                fontMetrics.setNotice(readLine());                break;            case ENCODING_SCHEME:                fontMetrics.setEncodingScheme(readLine());                break;            case MAPPING_SCHEME:                fontMetrics.setMappingScheme(readInt());                break;            case ESC_CHAR:                fontMetrics.setEscChar(readInt());                break;            case CHARACTER_SET:                fontMetrics.setCharacterSet(readLine());                break;            case CHARACTERS:                fontMetrics.setCharacters(readInt());                break;            case IS_BASE_FONT:                fontMetrics.setIsBaseFont(readBoolean());                break;            case V_VECTOR:                float[] vector = new float[2];                vector[0] = readFloat();                vector[1] = readFloat();                fontMetrics.setVVector(vector);                break;            case IS_FIXED_V:                fontMetrics.setIsFixedV(readBoolean());                break;            case CAP_HEIGHT:                fontMetrics.setCapHeight(readFloat());                break;            case X_HEIGHT:                fontMetrics.setXHeight(readFloat());                break;            case ASCENDER:                fontMetrics.setAscender(readFloat());                break;            case DESCENDER:                fontMetrics.setDescender(readFloat());                break;            case STD_HW:                fontMetrics.setStandardHorizontalWidth(readFloat());                break;            case STD_VW:                fontMetrics.setStandardVerticalWidth(readFloat());                break;            case COMMENT:                fontMetrics.addComment(readLine());                break;            case UNDERLINE_POSITION:                fontMetrics.setUnderlinePosition(readFloat());                break;            case UNDERLINE_THICKNESS:                fontMetrics.setUnderlineThickness(readFloat());                break;            case ITALIC_ANGLE:                fontMetrics.setItalicAngle(readFloat());                break;            case CHAR_WIDTH:                float[] widths = new float[2];                widths[0] = readFloat();                widths[1] = readFloat();                fontMetrics.setCharWidth(widths);                break;            case IS_FIXED_PITCH:                fontMetrics.setFixedPitch(readBoolean());                break;            case START_CHAR_METRICS:                int countMetrics = readInt();                List<CharMetric> charMetrics = new ArrayList<>(countMetrics);                for (int i = 0; i < countMetrics; i++) {                    CharMetric charMetric = parseCharMetric();                    charMetrics.add(charMetric);                }                String endCharMetrics = readString();                if (!endCharMetrics.equals(END_CHAR_METRICS)) {                    throw new IOException("Error: Expected '" + END_CHAR_METRICS + "' actual '" + endCharMetrics + "'");                }                charMetricsRead = true;                fontMetrics.setCharMetrics(charMetrics);                break;            case START_COMPOSITES:                if (!reducedDataset) {                    int countComposites = readInt();                    for (int i = 0; i < countComposites; i++) {                        Composite part = parseComposite();                        fontMetrics.addComposite(part);                    }                    String endComposites = readString();                    if (!endComposites.equals(END_COMPOSITES)) {                        throw new IOException("Error: Expected '" + END_COMPOSITES + "' actual '" + endComposites + "'");                    }                }                break;            case START_KERN_DATA:                if (!reducedDataset) {                    parseKernData(fontMetrics);                }                break;            default:                if (reducedDataset && charMetricsRead) {                    break;                }                throw new IOException("Unknown AFM key '" + nextCommand + "'");        }    }    return fontMetrics;}
private void pdfbox_f926_0(FontMetrics fontMetrics) throws IOException
{    String nextCommand;    while (!(nextCommand = readString()).equals(END_KERN_DATA)) {        switch(nextCommand) {            case START_TRACK_KERN:                int countTrackKern = readInt();                for (int i = 0; i < countTrackKern; i++) {                    TrackKern kern = new TrackKern();                    kern.setDegree(readInt());                    kern.setMinPointSize(readFloat());                    kern.setMinKern(readFloat());                    kern.setMaxPointSize(readFloat());                    kern.setMaxKern(readFloat());                    fontMetrics.addTrackKern(kern);                }                String endTrackKern = readString();                if (!endTrackKern.equals(END_TRACK_KERN)) {                    throw new IOException("Error: Expected '" + END_TRACK_KERN + "' actual '" + endTrackKern + "'");                }                break;            case START_KERN_PAIRS:                int countKernPairs = readInt();                for (int i = 0; i < countKernPairs; i++) {                    KernPair pair = parseKernPair();                    fontMetrics.addKernPair(pair);                }                String endKernPairs = readString();                if (!endKernPairs.equals(END_KERN_PAIRS)) {                    throw new IOException("Error: Expected '" + END_KERN_PAIRS + "' actual '" + endKernPairs + "'");                }                break;            case START_KERN_PAIRS0:                int countKernPairs0 = readInt();                for (int i = 0; i < countKernPairs0; i++) {                    KernPair pair = parseKernPair();                    fontMetrics.addKernPair0(pair);                }                String endKernPairs0 = readString();                if (!endKernPairs0.equals(END_KERN_PAIRS)) {                    throw new IOException("Error: Expected '" + END_KERN_PAIRS + "' actual '" + endKernPairs0 + "'");                }                break;            case START_KERN_PAIRS1:                int countKernPairs1 = readInt();                for (int i = 0; i < countKernPairs1; i++) {                    KernPair pair = parseKernPair();                    fontMetrics.addKernPair1(pair);                }                String endKernPairs1 = readString();                if (!endKernPairs1.equals(END_KERN_PAIRS)) {                    throw new IOException("Error: Expected '" + END_KERN_PAIRS + "' actual '" + endKernPairs1 + "'");                }                break;            default:                throw new IOException("Unknown kerning data type '" + nextCommand + "'");        }    }}
private KernPair pdfbox_f927_0() throws IOException
{    KernPair kernPair = new KernPair();    String cmd = readString();    switch(cmd) {        case KERN_PAIR_KP:            kernPair.setFirstKernCharacter(readString());            kernPair.setSecondKernCharacter(readString());            kernPair.setX(readFloat());            kernPair.setY(readFloat());            break;        case KERN_PAIR_KPH:            kernPair.setFirstKernCharacter(hexToString(readString()));            kernPair.setSecondKernCharacter(hexToString(readString()));            kernPair.setX(readFloat());            kernPair.setY(readFloat());            break;        case KERN_PAIR_KPX:            kernPair.setFirstKernCharacter(readString());            kernPair.setSecondKernCharacter(readString());            kernPair.setX(readFloat());            kernPair.setY(0);            break;        case KERN_PAIR_KPY:            kernPair.setFirstKernCharacter(readString());            kernPair.setSecondKernCharacter(readString());            kernPair.setX(0);            kernPair.setY(readFloat());            break;        default:            throw new IOException("Error expected kern pair command actual='" + cmd + "'");    }    return kernPair;}
private String pdfbox_f928_0(String hexString) throws IOException
{    if (hexString.length() < 2) {        throw new IOException("Error: Expected hex string of length >= 2 not='" + hexString);    }    if (hexString.charAt(0) != '<' || hexString.charAt(hexString.length() - 1) != '>') {        throw new IOException("String should be enclosed by angle brackets '" + hexString + "'");    }    hexString = hexString.substring(1, hexString.length() - 1);    byte[] data = new byte[hexString.length() / 2];    for (int i = 0; i < hexString.length(); i += 2) {        String hex = Character.toString(hexString.charAt(i)) + hexString.charAt(i + 1);        try {            data[i / 2] = (byte) Integer.parseInt(hex, BITS_IN_HEX);        } catch (NumberFormatException e) {            throw new IOException("Error parsing AFM file:" + e);        }    }    return new String(data, Charsets.ISO_8859_1);}
private Composite pdfbox_f929_0() throws IOException
{    Composite composite = new Composite();    String partData = readLine();    StringTokenizer tokenizer = new StringTokenizer(partData, " ;");    String cc = tokenizer.nextToken();    if (!cc.equals(CC)) {        throw new IOException("Expected '" + CC + "' actual='" + cc + "'");    }    String name = tokenizer.nextToken();    composite.setName(name);    int partCount;    try {        partCount = Integer.parseInt(tokenizer.nextToken());    } catch (NumberFormatException e) {        throw new IOException("Error parsing AFM document:" + e);    }    for (int i = 0; i < partCount; i++) {        CompositePart part = new CompositePart();        String pcc = tokenizer.nextToken();        if (!pcc.equals(PCC)) {            throw new IOException("Expected '" + PCC + "' actual='" + pcc + "'");        }        String partName = tokenizer.nextToken();        try {            int x = Integer.parseInt(tokenizer.nextToken());            int y = Integer.parseInt(tokenizer.nextToken());            part.setName(partName);            part.setXDisplacement(x);            part.setYDisplacement(y);            composite.addPart(part);        } catch (NumberFormatException e) {            throw new IOException("Error parsing AFM document:" + e);        }    }    return composite;}
private CharMetric pdfbox_f930_0() throws IOException
{    CharMetric charMetric = new CharMetric();    String metrics = readLine();    StringTokenizer metricsTokenizer = new StringTokenizer(metrics);    try {        while (metricsTokenizer.hasMoreTokens()) {            String nextCommand = metricsTokenizer.nextToken();            switch(nextCommand) {                case CHARMETRICS_C:                    String charCodeC = metricsTokenizer.nextToken();                    charMetric.setCharacterCode(Integer.parseInt(charCodeC));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_CH:                                                            String charCodeCH = metricsTokenizer.nextToken();                    charMetric.setCharacterCode(Integer.parseInt(charCodeCH, BITS_IN_HEX));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_WX:                    charMetric.setWx(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W0X:                    charMetric.setW0x(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W1X:                    charMetric.setW1x(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_WY:                    charMetric.setWy(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W0Y:                    charMetric.setW0y(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W1Y:                    charMetric.setW1y(Float.parseFloat(metricsTokenizer.nextToken()));                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W:                    float[] w = new float[2];                    w[0] = Float.parseFloat(metricsTokenizer.nextToken());                    w[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setW(w);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W0:                    float[] w0 = new float[2];                    w0[0] = Float.parseFloat(metricsTokenizer.nextToken());                    w0[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setW0(w0);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_W1:                    float[] w1 = new float[2];                    w1[0] = Float.parseFloat(metricsTokenizer.nextToken());                    w1[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setW1(w1);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_VV:                    float[] vv = new float[2];                    vv[0] = Float.parseFloat(metricsTokenizer.nextToken());                    vv[1] = Float.parseFloat(metricsTokenizer.nextToken());                    charMetric.setVv(vv);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_N:                    charMetric.setName(metricsTokenizer.nextToken());                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_B:                    BoundingBox box = new BoundingBox();                    box.setLowerLeftX(Float.parseFloat(metricsTokenizer.nextToken()));                    box.setLowerLeftY(Float.parseFloat(metricsTokenizer.nextToken()));                    box.setUpperRightX(Float.parseFloat(metricsTokenizer.nextToken()));                    box.setUpperRightY(Float.parseFloat(metricsTokenizer.nextToken()));                    charMetric.setBoundingBox(box);                    verifySemicolon(metricsTokenizer);                    break;                case CHARMETRICS_L:                    Ligature lig = new Ligature();                    lig.setSuccessor(metricsTokenizer.nextToken());                    lig.setLigature(metricsTokenizer.nextToken());                    charMetric.addLigature(lig);                    verifySemicolon(metricsTokenizer);                    break;                default:                    throw new IOException("Unknown CharMetrics command '" + nextCommand + "'");            }        }    } catch (NumberFormatException e) {        throw new IOException("Error: Corrupt AFM document:" + e);    }    return charMetric;}
private void pdfbox_f931_0(StringTokenizer tokenizer) throws IOException
{    if (tokenizer.hasMoreTokens()) {        String semicolon = tokenizer.nextToken();        if (!";".equals(semicolon)) {            throw new IOException("Error: Expected semicolon in stream actual='" + semicolon + "'");        }    } else {        throw new IOException("CharMetrics is missing a semicolon after a command");    }}
private boolean pdfbox_f932_0() throws IOException
{    String theBoolean = readString();    return Boolean.valueOf(theBoolean);}
private int pdfbox_f933_0() throws IOException
{    String theInt = readString();    try {        return Integer.parseInt(theInt);    } catch (NumberFormatException e) {        throw new IOException("Error parsing AFM document:" + e);    }}
private float pdfbox_f934_0() throws IOException
{    String theFloat = readString();    return Float.parseFloat(theFloat);}
private String pdfbox_f935_0() throws IOException
{        StringBuilder buf = new StringBuilder(60);    int nextByte = input.read();    while (isWhitespace(nextByte)) {        nextByte = input.read();        }    buf.append((char) nextByte);        nextByte = input.read();    while (nextByte != -1 && !isEOL(nextByte)) {        buf.append((char) nextByte);        nextByte = input.read();    }    return buf.toString();}
private String pdfbox_f936_0() throws IOException
{        StringBuilder buf = new StringBuilder(24);    int nextByte = input.read();    while (isWhitespace(nextByte)) {        nextByte = input.read();        }    buf.append((char) nextByte);        nextByte = input.read();    while (nextByte != -1 && !isWhitespace(nextByte)) {        buf.append((char) nextByte);        nextByte = input.read();    }    return buf.toString();}
private boolean pdfbox_f937_0(int character)
{    return character == 0x0D || character == 0x0A;}
private boolean pdfbox_f938_0(int character)
{    return character == ' ' || character == '\t' || character == 0x0D || character == 0x0A;}
public BoundingBox pdfbox_f939_0()
{    return boundingBox;}
public void pdfbox_f940_0(BoundingBox bBox)
{    boundingBox = bBox;}
public int pdfbox_f941_0()
{    return characterCode;}
public void pdfbox_f942_0(int cCode)
{    characterCode = cCode;}
public void pdfbox_f943_0(Ligature ligature)
{    ligatures.add(ligature);}
public List<Ligature> pdfbox_f944_0()
{    return ligatures;}
public void pdfbox_f945_0(List<Ligature> lig)
{    this.ligatures = lig;}
public String pdfbox_f946_0()
{    return name;}
public void pdfbox_f947_0(String n)
{    this.name = n;}
public float[] pdfbox_f948_0()
{    return this.vv;}
public void pdfbox_f949_0(float[] vvValue)
{    this.vv = vvValue;}
public float[] pdfbox_f950_0()
{    return this.w;}
public void pdfbox_f951_0(float[] wValue)
{    this.w = wValue;}
public float[] pdfbox_f952_0()
{    return this.w0;}
public void pdfbox_f953_0(float[] w0Value)
{    w0 = w0Value;}
public float pdfbox_f954_0()
{    return w0x;}
public void pdfbox_f955_0(float w0xValue)
{    w0x = w0xValue;}
public float pdfbox_f956_0()
{    return w0y;}
public void pdfbox_f957_0(float w0yValue)
{    w0y = w0yValue;}
public float[] pdfbox_f958_0()
{    return this.w1;}
public void pdfbox_f959_0(float[] w1Value)
{    w1 = w1Value;}
public float pdfbox_f960_0()
{    return w1x;}
public void pdfbox_f961_0(float w1xValue)
{    w1x = w1xValue;}
public float pdfbox_f962_0()
{    return w1y;}
public void pdfbox_f963_0(float w1yValue)
{    w1y = w1yValue;}
public float pdfbox_f964_0()
{    return wx;}
public void pdfbox_f965_0(float wxValue)
{    wx = wxValue;}
public float pdfbox_f966_0()
{    return wy;}
public void pdfbox_f967_0(float wyValue)
{    this.wy = wyValue;}
public String pdfbox_f968_0()
{    return name;}
public void pdfbox_f969_0(String nameValue)
{    this.name = nameValue;}
public void pdfbox_f970_0(CompositePart part)
{    parts.add(part);}
public List<CompositePart> pdfbox_f971_0()
{    return parts;}
public void pdfbox_f972_0(List<CompositePart> partsList)
{    this.parts = partsList;}
public java.lang.String pdfbox_f973_0()
{    return name;}
public void pdfbox_f974_0(String nameValue)
{    name = nameValue;}
public int pdfbox_f975_0()
{    return xDisplacement;}
public void pdfbox_f976_0(int xDisp)
{    xDisplacement = xDisp;}
public int pdfbox_f977_0()
{    return yDisplacement;}
public void pdfbox_f978_0(int yDisp)
{    yDisplacement = yDisp;}
public float pdfbox_f979_0(String name)
{    float result = 0;    CharMetric metric = charMetricsMap.get(name);    if (metric != null) {        result = metric.getWx();    }    return result;}
public float pdfbox_f980_0(String name)
{    float result = 0;    CharMetric metric = charMetricsMap.get(name);    if (metric != null) {        result = metric.getWy();        if (Float.compare(result, 0) == 0) {            result = metric.getBoundingBox().getHeight();        }    }    return result;}
public float pdfbox_f981_0()
{    float average = 0;    float totalWidths = 0;    float characterCount = 0;    for (CharMetric metric : charMetrics) {        if (metric.getWx() > 0) {            totalWidths += metric.getWx();            characterCount += 1;        }    }    if (totalWidths > 0) {        average = totalWidths / characterCount;    }    return average;}
public void pdfbox_f982_0(String comment)
{    comments.add(comment);}
public List<String> pdfbox_f983_0()
{    return Collections.unmodifiableList(comments);}
public float pdfbox_f984_0()
{    return afmVersion;}
public int pdfbox_f985_0()
{    return metricSets;}
public void pdfbox_f986_0(float afmVersionValue)
{    afmVersion = afmVersionValue;}
public void pdfbox_f987_0(int metricSetsValue)
{    if (metricSetsValue < 0 || metricSetsValue > 2) {        throw new IllegalArgumentException("The metricSets attribute must be in the " + "set {0,1,2} and not '" + metricSetsValue + "'");    }    metricSets = metricSetsValue;}
public String pdfbox_f988_0()
{    return fontName;}
public void pdfbox_f989_0(String name)
{    fontName = name;}
public String pdfbox_f990_0()
{    return fullName;}
public void pdfbox_f991_0(String fullNameValue)
{    fullName = fullNameValue;}
public String pdfbox_f992_0()
{    return familyName;}
public void pdfbox_f993_0(String familyNameValue)
{    familyName = familyNameValue;}
public String pdfbox_f994_0()
{    return weight;}
public void pdfbox_f995_0(String weightValue)
{    weight = weightValue;}
public BoundingBox pdfbox_f996_0()
{    return fontBBox;}
public void pdfbox_f997_0(BoundingBox bBox)
{    this.fontBBox = bBox;}
public String pdfbox_f998_0()
{    return notice;}
public void pdfbox_f999_0(String noticeValue)
{    notice = noticeValue;}
public String pdfbox_f1000_0()
{    return encodingScheme;}
public void pdfbox_f1001_0(String encodingSchemeValue)
{    encodingScheme = encodingSchemeValue;}
public int pdfbox_f1002_0()
{    return mappingScheme;}
public void pdfbox_f1003_0(int mappingSchemeValue)
{    mappingScheme = mappingSchemeValue;}
public int pdfbox_f1004_0()
{    return escChar;}
public void pdfbox_f1005_0(int escCharValue)
{    escChar = escCharValue;}
public String pdfbox_f1006_0()
{    return characterSet;}
public void pdfbox_f1007_0(String characterSetValue)
{    characterSet = characterSetValue;}
public int pdfbox_f1008_0()
{    return characters;}
public void pdfbox_f1009_0(int charactersValue)
{    characters = charactersValue;}
public boolean pdfbox_f1010_0()
{    return isBaseFont;}
public void pdfbox_f1011_0(boolean isBaseFontValue)
{    isBaseFont = isBaseFontValue;}
public float[] pdfbox_f1012_0()
{    return this.vVector;}
public void pdfbox_f1013_0(float[] vVectorValue)
{    vVector = vVectorValue;}
public boolean pdfbox_f1014_0()
{    return isFixedV;}
public void pdfbox_f1015_0(boolean isFixedVValue)
{    isFixedV = isFixedVValue;}
public float pdfbox_f1016_0()
{    return capHeight;}
public void pdfbox_f1017_0(float capHeightValue)
{    capHeight = capHeightValue;}
public float pdfbox_f1018_0()
{    return xHeight;}
public void pdfbox_f1019_0(float xHeightValue)
{    xHeight = xHeightValue;}
public float pdfbox_f1020_0()
{    return ascender;}
public void pdfbox_f1021_0(float ascenderValue)
{    ascender = ascenderValue;}
public float pdfbox_f1022_0()
{    return descender;}
public void pdfbox_f1023_0(float descenderValue)
{    descender = descenderValue;}
public String pdfbox_f1024_0()
{    return fontVersion;}
public void pdfbox_f1025_0(String fontVersionValue)
{    fontVersion = fontVersionValue;}
public float pdfbox_f1026_0()
{    return underlinePosition;}
public void pdfbox_f1027_0(float underlinePositionValue)
{    underlinePosition = underlinePositionValue;}
public float pdfbox_f1028_0()
{    return underlineThickness;}
public void pdfbox_f1029_0(float underlineThicknessValue)
{    underlineThickness = underlineThicknessValue;}
public float pdfbox_f1030_0()
{    return italicAngle;}
public void pdfbox_f1031_0(float italicAngleValue)
{    italicAngle = italicAngleValue;}
public float[] pdfbox_f1032_0()
{    return this.charWidth;}
public void pdfbox_f1033_0(float[] charWidthValue)
{    charWidth = charWidthValue;}
public boolean pdfbox_f1034_0()
{    return isFixedPitch;}
public void pdfbox_f1035_0(boolean isFixedPitchValue)
{    isFixedPitch = isFixedPitchValue;}
public List<CharMetric> pdfbox_f1036_0()
{    return Collections.unmodifiableList(charMetrics);}
public void pdfbox_f1037_0(List<CharMetric> charMetricsValue)
{    charMetrics = charMetricsValue;    charMetricsMap = new HashMap<>(charMetrics.size());    charMetricsValue.forEach(metric -> charMetricsMap.put(metric.getName(), metric));}
public void pdfbox_f1038_0(CharMetric metric)
{    charMetrics.add(metric);    charMetricsMap.put(metric.getName(), metric);}
public List<TrackKern> pdfbox_f1039_0()
{    return Collections.unmodifiableList(trackKern);}
public void pdfbox_f1040_0(List<TrackKern> trackKernValue)
{    trackKern = trackKernValue;}
public void pdfbox_f1041_0(TrackKern kern)
{    trackKern.add(kern);}
public List<Composite> pdfbox_f1042_0()
{    return Collections.unmodifiableList(composites);}
public void pdfbox_f1043_0(List<Composite> compositesList)
{    composites = compositesList;}
public void pdfbox_f1044_0(Composite composite)
{    composites.add(composite);}
public List<KernPair> pdfbox_f1045_0()
{    return Collections.unmodifiableList(kernPairs);}
public void pdfbox_f1046_0(KernPair kernPair)
{    kernPairs.add(kernPair);}
public void pdfbox_f1047_0(List<KernPair> kernPairsList)
{    kernPairs = kernPairsList;}
public List<KernPair> pdfbox_f1048_0()
{    return Collections.unmodifiableList(kernPairs0);}
public void pdfbox_f1049_0(KernPair kernPair)
{    kernPairs0.add(kernPair);}
public void pdfbox_f1050_0(List<KernPair> kernPairs0List)
{    kernPairs0 = kernPairs0List;}
public List<KernPair> pdfbox_f1051_0()
{    return Collections.unmodifiableList(kernPairs1);}
public void pdfbox_f1052_0(KernPair kernPair)
{    kernPairs1.add(kernPair);}
public void pdfbox_f1053_0(List<KernPair> kernPairs1List)
{    kernPairs1 = kernPairs1List;}
public float pdfbox_f1054_0()
{    return standardHorizontalWidth;}
public void pdfbox_f1055_0(float standardHorizontalWidthValue)
{    standardHorizontalWidth = standardHorizontalWidthValue;}
public float pdfbox_f1056_0()
{    return standardVerticalWidth;}
public void pdfbox_f1057_0(float standardVerticalWidthValue)
{    standardVerticalWidth = standardVerticalWidthValue;}
public java.lang.String pdfbox_f1058_0()
{    return firstKernCharacter;}
public void pdfbox_f1059_0(String firstKernCharacterValue)
{    firstKernCharacter = firstKernCharacterValue;}
public java.lang.String pdfbox_f1060_0()
{    return secondKernCharacter;}
public void pdfbox_f1061_0(String secondKernCharacterValue)
{    secondKernCharacter = secondKernCharacterValue;}
public float pdfbox_f1062_0()
{    return x;}
public void pdfbox_f1063_0(float xValue)
{    x = xValue;}
public float pdfbox_f1064_0()
{    return y;}
public void pdfbox_f1065_0(float yValue)
{    y = yValue;}
public String pdfbox_f1066_0()
{    return ligature;}
public void pdfbox_f1067_0(String lig)
{    ligature = lig;}
public String pdfbox_f1068_0()
{    return successor;}
public void pdfbox_f1069_0(String successorValue)
{    successor = successorValue;}
public int pdfbox_f1070_0()
{    return degree;}
public void pdfbox_f1071_0(int degreeValue)
{    degree = degreeValue;}
public float pdfbox_f1072_0()
{    return maxKern;}
public void pdfbox_f1073_0(float maxKernValue)
{    maxKern = maxKernValue;}
public float pdfbox_f1074_0()
{    return maxPointSize;}
public void pdfbox_f1075_0(float maxPointSizeValue)
{    maxPointSize = maxPointSizeValue;}
public float pdfbox_f1076_0()
{    return minKern;}
public void pdfbox_f1077_0(float minKernValue)
{    minKern = minKernValue;}
public float pdfbox_f1078_0()
{    return minPointSize;}
public void pdfbox_f1079_0(float minPointSizeValue)
{    minPointSize = minPointSizeValue;}
public boolean pdfbox_f1080_0()
{    return isCIDFont;}
public void pdfbox_f1081_0(int gid, int sid, String name)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    sidOrCidToGid.put(sid, gid);    gidToSid.put(gid, sid);    nameToSid.put(name, sid);    gidToName.put(gid, name);}
public void pdfbox_f1082_0(int gid, int cid)
{    if (!isCIDFont) {        throw new IllegalStateException("Not a CIDFont");    }    sidOrCidToGid.put(cid, gid);    gidToCid.put(gid, cid);}
 int pdfbox_f1083_0(int sid)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    Integer gid = gidToSid.get(sid);    if (gid == null) {        return 0;    }    return gid;}
 int pdfbox_f1084_0(int sid)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    Integer gid = sidOrCidToGid.get(sid);    if (gid == null) {        return 0;    }    return gid;}
public int pdfbox_f1085_0(int cid)
{    if (!isCIDFont) {        throw new IllegalStateException("Not a CIDFont");    }    Integer gid = sidOrCidToGid.get(cid);    if (gid == null) {        return 0;    }    return gid;}
 int pdfbox_f1086_0(String name)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    Integer sid = nameToSid.get(name);    if (sid == null) {        return 0;    }    return sid;}
public String pdfbox_f1087_0(int gid)
{    if (isCIDFont) {        throw new IllegalStateException("Not a Type 1-equivalent font");    }    return gidToName.get(gid);}
public int pdfbox_f1088_0(int gid)
{    if (!isCIDFont) {        throw new IllegalStateException("Not a CIDFont");    }    Integer cid = gidToCid.get(gid);    if (cid != null) {        return cid;    }    return 0;}
public String pdfbox_f1089_0()
{    return registry;}
 void pdfbox_f1090_0(String registry)
{    this.registry = registry;}
public String pdfbox_f1091_0()
{    return ordering;}
 void pdfbox_f1092_0(String ordering)
{    this.ordering = ordering;}
public int pdfbox_f1093_0()
{    return supplement;}
 void pdfbox_f1094_0(int supplement)
{    this.supplement = supplement;}
public List<Map<String, Object>> pdfbox_f1095_0()
{    return fontDictionaries;}
 void pdfbox_f1096_0(List<Map<String, Object>> fontDict)
{    this.fontDictionaries = fontDict;}
public List<Map<String, Object>> pdfbox_f1097_0()
{    return privateDictionaries;}
 void pdfbox_f1098_0(List<Map<String, Object>> privDict)
{    this.privateDictionaries = privDict;}
public FDSelect pdfbox_f1099_0()
{    return fdSelect;}
 void pdfbox_f1100_0(FDSelect fdSelect)
{    this.fdSelect = fdSelect;}
private int pdfbox_f1101_0(int gid)
{    int fdArrayIndex = this.fdSelect.getFDIndex(gid);    if (fdArrayIndex == -1) {        return 1000;    }    Map<String, Object> privDict = this.privateDictionaries.get(fdArrayIndex);    return privDict.containsKey("defaultWidthX") ? ((Number) privDict.get("defaultWidthX")).intValue() : 1000;}
private int pdfbox_f1102_0(int gid)
{    int fdArrayIndex = this.fdSelect.getFDIndex(gid);    if (fdArrayIndex == -1) {        return 0;    }    Map<String, Object> privDict = this.privateDictionaries.get(fdArrayIndex);    return privDict.containsKey("nominalWidthX") ? ((Number) privDict.get("nominalWidthX")).intValue() : 0;}
private byte[][] pdfbox_f1103_0(int gid)
{    int fdArrayIndex = this.fdSelect.getFDIndex(gid);    if (fdArrayIndex == -1) {        return null;    }    Map<String, Object> privDict = this.privateDictionaries.get(fdArrayIndex);    return (byte[][]) privDict.get("Subrs");}
public CIDKeyedType2CharString pdfbox_f1104_0(int cid) throws IOException
{    CIDKeyedType2CharString type2 = charStringCache.get(cid);    if (type2 == null) {        int gid = charset.getGIDForCID(cid);        byte[] bytes = charStrings[gid];        if (bytes == null) {                        bytes = charStrings[0];        }        Type2CharStringParser parser = new Type2CharStringParser(fontName, cid);        List<Object> type2seq = parser.parse(bytes, globalSubrIndex, getLocalSubrIndex(gid));        type2 = new CIDKeyedType2CharString(reader, fontName, cid, gid, type2seq, getDefaultWidthX(gid), getNominalWidthX(gid));        charStringCache.put(cid, type2);    }    return type2;}
public List<Number> pdfbox_f1105_0()
{        return (List<Number>) topDict.get("FontMatrix");}
public GeneralPath pdfbox_f1106_0(String selector) throws IOException
{    int cid = selectorToCID(selector);    return getType2CharString(cid).getPath();}
public float pdfbox_f1107_0(String selector) throws IOException
{    int cid = selectorToCID(selector);    return getType2CharString(cid).getWidth();}
public boolean pdfbox_f1108_0(String selector) throws IOException
{    int cid = selectorToCID(selector);    return cid != 0;}
private int pdfbox_f1109_0(String selector)
{    if (!selector.startsWith("\\")) {        throw new IllegalArgumentException("Invalid selector");    }    return Integer.parseInt(selector.substring(1));}
public Type1CharString pdfbox_f1110_0(String name) throws IOException
{        return CFFCIDFont.this.getType2CharString(0);}
public int pdfbox_f1111_0() throws IOException
{    return readUnsignedByte();}
public int pdfbox_f1112_0() throws IOException
{    return readUnsignedShort();}
public int pdfbox_f1113_0(int offSize) throws IOException
{    int value = 0;    for (int i = 0; i < offSize; i++) {        value = value << 8 | readUnsignedByte();    }    return value;}
public int pdfbox_f1114_0() throws IOException
{    return readUnsignedByte();}
public int pdfbox_f1115_0() throws IOException
{    return readUnsignedShort();}
public String pdfbox_f1116_0(int code)
{    String name = codeToName.get(code);    if (name == null) {        return ".notdef";    }    return name;}
public void pdfbox_f1117_0(int code, int sid, String name)
{    codeToName.put(code, name);    addCharacterEncoding(code, name);}
protected void pdfbox_f1118_0(int code, int sid)
{    String name = CFFStandardString.getName(sid);    codeToName.put(code, name);    addCharacterEncoding(code, name);}
public static CFFExpertCharset pdfbox_f1119_0()
{    return CFFExpertCharset.INSTANCE;}
public static CFFExpertEncoding pdfbox_f1120_0()
{    return CFFExpertEncoding.INSTANCE;}
public static CFFExpertSubsetCharset pdfbox_f1121_0()
{    return CFFExpertSubsetCharset.INSTANCE;}
public String pdfbox_f1122_0()
{    return fontName;}
 void pdfbox_f1123_0(String name)
{    fontName = name;}
public void pdfbox_f1124_0(String name, Object value)
{    if (value != null) {        topDict.put(name, value);    }}
public Map<String, Object> pdfbox_f1125_0()
{    return topDict;}
public BoundingBox pdfbox_f1126_0()
{    List<Number> numbers = (List<Number>) topDict.get("FontBBox");    return new BoundingBox(numbers);}
public CFFCharset pdfbox_f1127_0()
{    return charset;}
 void pdfbox_f1128_0(CFFCharset charset)
{    this.charset = charset;}
public final List<byte[]> pdfbox_f1129_0()
{    return Arrays.asList(charStrings);}
 final void pdfbox_f1130_0(CFFParser.ByteSource source)
{    this.source = source;}
public byte[] pdfbox_f1131_0() throws IOException
{    return source.getBytes();}
public int pdfbox_f1132_0()
{    return charStrings.length;}
 void pdfbox_f1133_0(byte[][] globalSubrIndexValue)
{    globalSubrIndex = globalSubrIndexValue;}
public List<byte[]> pdfbox_f1134_0()
{    return Arrays.asList(globalSubrIndex);}
public String pdfbox_f1135_0()
{    return getClass().getSimpleName() + "[name=" + fontName + ", topDict=" + topDict + ", charset=" + charset + ", charStrings=" + Arrays.deepToString(charStrings) + "]";}
public static CFFISOAdobeCharset pdfbox_f1136_0()
{    return CFFISOAdobeCharset.INSTANCE;}
public Key pdfbox_f1137_0()
{    return operatorKey;}
private void pdfbox_f1138_0(Key key)
{    operatorKey = key;}
public String pdfbox_f1139_0()
{    return operatorName;}
private void pdfbox_f1140_0(String name)
{    operatorName = name;}
public String pdfbox_f1141_0()
{    return getName();}
public int pdfbox_f1142_0()
{    return getKey().hashCode();}
public boolean pdfbox_f1143_0(Object object)
{    if (object instanceof CFFOperator) {        CFFOperator that = (CFFOperator) object;        return getKey().equals(that.getKey());    }    return false;}
private static void pdfbox_f1144_0(Key key, String name)
{    CFFOperator operator = new CFFOperator(key, name);    keyMap.put(key, operator);    nameMap.put(name, operator);}
public static CFFOperator pdfbox_f1145_0(Key key)
{    return keyMap.get(key);}
public static CFFOperator pdfbox_f1146_0(String name)
{    return nameMap.get(name);}
public int[] pdfbox_f1147_0()
{    return value;}
private void pdfbox_f1148_0(int[] value)
{    this.value = value;}
public String pdfbox_f1149_0()
{    return Arrays.toString(getValue());}
public int pdfbox_f1150_0()
{    return Arrays.hashCode(getValue());}
public boolean pdfbox_f1151_0(Object object)
{    if (object instanceof Key) {        Key that = (Key) object;        return Arrays.equals(getValue(), that.getValue());    }    return false;}
public List<CFFFont> pdfbox_f1152_0(byte[] bytes, ByteSource source) throws IOException
{    this.source = source;    return parse(bytes);}
public List<CFFFont> pdfbox_f1153_0(byte[] bytes) throws IOException
{    CFFDataInput input = new CFFDataInput(bytes);    String firstTag = readTagName(input);        switch(firstTag) {        case TAG_OTTO:            input = createTaggedCFFDataInput(input, bytes);            break;        case TAG_TTCF:            throw new IOException("True Type Collection fonts are not supported.");        case TAG_TTFONLY:            throw new IOException("OpenType fonts containing a true type font are not supported.");        default:            input.setPosition(0);            break;    }    @SuppressWarnings("unused")    Header header = readHeader(input);    String[] nameIndex = readStringIndexData(input);    if (nameIndex == null) {        throw new IOException("Name index missing in CFF font");    }    byte[][] topDictIndex = readIndexData(input);    if (topDictIndex == null) {        throw new IOException("Top DICT INDEX missing in CFF font");    }    stringIndex = readStringIndexData(input);    byte[][] globalSubrIndex = readIndexData(input);    List<CFFFont> fonts = new ArrayList<>();    for (int i = 0; i < nameIndex.length; i++) {        CFFFont font = parseFont(input, nameIndex[i], topDictIndex[i]);        font.setGlobalSubrIndex(globalSubrIndex);        font.setData(source);        fonts.add(font);    }    return fonts;}
private CFFDataInput pdfbox_f1154_0(CFFDataInput input, byte[] bytes) throws IOException
{            short numTables = input.readShort();    @SuppressWarnings({ "unused", "squid:S1854" })    short searchRange = input.readShort();    @SuppressWarnings({ "unused", "squid:S1854" })    short entrySelector = input.readShort();    @SuppressWarnings({ "unused", "squid:S1854" })    short rangeShift = input.readShort();    for (int q = 0; q < numTables; q++) {        String tagName = readTagName(input);        @SuppressWarnings("unused")        long checksum = readLong(input);        long offset = readLong(input);        long length = readLong(input);        if ("CFF ".equals(tagName)) {            byte[] bytes2 = Arrays.copyOfRange(bytes, (int) offset, (int) (offset + length));            return new CFFDataInput(bytes2);        }    }    throw new IOException("CFF tag not found in this OpenType font.");}
private static String pdfbox_f1155_0(CFFDataInput input) throws IOException
{    byte[] b = input.readBytes(4);    return new String(b, Charsets.ISO_8859_1);}
private static long pdfbox_f1156_0(CFFDataInput input) throws IOException
{    return (input.readCard16() << 16) | input.readCard16();}
private static Header pdfbox_f1157_0(CFFDataInput input) throws IOException
{    Header cffHeader = new Header();    cffHeader.major = input.readCard8();    cffHeader.minor = input.readCard8();    cffHeader.hdrSize = input.readCard8();    cffHeader.offSize = input.readOffSize();    return cffHeader;}
private static int[] pdfbox_f1158_0(CFFDataInput input) throws IOException
{    int count = input.readCard16();    if (count == 0) {        return null;    }    int offSize = input.readOffSize();    int[] offsets = new int[count + 1];    for (int i = 0; i <= count; i++) {        int offset = input.readOffset(offSize);        if (offset > input.length()) {            throw new IOException("illegal offset value " + offset + " in CFF font");        }        offsets[i] = offset;    }    return offsets;}
private static byte[][] pdfbox_f1159_0(CFFDataInput input) throws IOException
{    int[] offsets = readIndexDataOffsets(input);    if (offsets == null) {        return null;    }    int count = offsets.length - 1;    byte[][] indexDataValues = new byte[count][];    for (int i = 0; i < count; i++) {        int length = offsets[i + 1] - offsets[i];        indexDataValues[i] = input.readBytes(length);    }    return indexDataValues;}
private static String[] pdfbox_f1160_0(CFFDataInput input) throws IOException
{    int[] offsets = readIndexDataOffsets(input);    if (offsets == null) {        return null;    }    int count = offsets.length - 1;    String[] indexDataValues = new String[count];    for (int i = 0; i < count; i++) {        int length = offsets[i + 1] - offsets[i];        if (length < 0) {            throw new IOException("Negative index data length + " + length + " at " + i + ": offsets[" + (i + 1) + "]=" + offsets[i + 1] + ", offsets[" + i + "]=" + offsets[i]);        }        indexDataValues[i] = new String(input.readBytes(length), Charsets.ISO_8859_1);    }    return indexDataValues;}
private static DictData pdfbox_f1161_0(CFFDataInput input) throws IOException
{    DictData dict = new DictData();    while (input.hasRemaining()) {        dict.add(readEntry(input));    }    return dict;}
private static DictData pdfbox_f1162_0(CFFDataInput input, int dictSize) throws IOException
{    DictData dict = new DictData();    int endPosition = input.getPosition() + dictSize;    while (input.getPosition() < endPosition) {        dict.add(readEntry(input));    }    return dict;}
private static DictData.Entry pdfbox_f1163_0(CFFDataInput input) throws IOException
{    DictData.Entry entry = new DictData.Entry();    while (true) {        int b0 = input.readUnsignedByte();        if (b0 >= 0 && b0 <= 21) {            entry.operator = readOperator(input, b0);            break;        } else if (b0 == 28 || b0 == 29) {            entry.operands.add(readIntegerNumber(input, b0));        } else if (b0 == 30) {            entry.operands.add(readRealNumber(input, b0));        } else if (b0 >= 32 && b0 <= 254) {            entry.operands.add(readIntegerNumber(input, b0));        } else {            throw new IOException("invalid DICT data b0 byte: " + b0);        }    }    return entry;}
private static CFFOperator pdfbox_f1164_0(CFFDataInput input, int b0) throws IOException
{    CFFOperator.Key key = readOperatorKey(input, b0);    return CFFOperator.getOperator(key);}
private static CFFOperator.Key pdfbox_f1165_0(CFFDataInput input, int b0) throws IOException
{    if (b0 == 12) {        int b1 = input.readUnsignedByte();        return new CFFOperator.Key(b0, b1);    }    return new CFFOperator.Key(b0);}
private static Integer pdfbox_f1166_0(CFFDataInput input, int b0) throws IOException
{    if (b0 == 28) {        return (int) input.readShort();    } else if (b0 == 29) {        return input.readInt();    } else if (b0 >= 32 && b0 <= 246) {        return b0 - 139;    } else if (b0 >= 247 && b0 <= 250) {        int b1 = input.readUnsignedByte();        return (b0 - 247) * 256 + b1 + 108;    } else if (b0 >= 251 && b0 <= 254) {        int b1 = input.readUnsignedByte();        return -(b0 - 251) * 256 - b1 - 108;    } else {        throw new IllegalArgumentException();    }}
private static Double pdfbox_f1167_1(CFFDataInput input, int b0) throws IOException
{    StringBuilder sb = new StringBuilder();    boolean done = false;    boolean exponentMissing = false;    boolean hasExponent = false;    while (!done) {        int b = input.readUnsignedByte();        int[] nibbles = { b / 16, b % 16 };        for (int nibble : nibbles) {            switch(nibble) {                case 0x0:                case 0x1:                case 0x2:                case 0x3:                case 0x4:                case 0x5:                case 0x6:                case 0x7:                case 0x8:                case 0x9:                    sb.append(nibble);                    exponentMissing = false;                    break;                case 0xa:                    sb.append(".");                    break;                case 0xb:                    if (hasExponent) {                                                break;                    }                    sb.append("E");                    exponentMissing = true;                    hasExponent = true;                    break;                case 0xc:                    if (hasExponent) {                                                break;                    }                    sb.append("E-");                    exponentMissing = true;                    hasExponent = true;                    break;                case 0xd:                    break;                case 0xe:                    sb.append("-");                    break;                case 0xf:                    done = true;                    break;                default:                    throw new IllegalArgumentException();            }        }    }    if (exponentMissing) {                                sb.append("0");    }    if (sb.length() == 0) {        return 0d;    }    return Double.valueOf(sb.toString());}
private CFFFont pdfbox_f1168_1(CFFDataInput input, String name, byte[] topDictIndex) throws IOException
{        CFFDataInput topDictInput = new CFFDataInput(topDictIndex);    DictData topDict = readDictData(topDictInput);        DictData.Entry syntheticBaseEntry = topDict.getEntry("SyntheticBase");    if (syntheticBaseEntry != null) {        throw new IOException("Synthetic Fonts are not supported");    }        CFFFont font;    boolean isCIDFont = topDict.getEntry("ROS") != null;    if (isCIDFont) {        font = new CFFCIDFont();        DictData.Entry rosEntry = topDict.getEntry("ROS");        ((CFFCIDFont) font).setRegistry(readString(rosEntry.getNumber(0).intValue()));        ((CFFCIDFont) font).setOrdering(readString(rosEntry.getNumber(1).intValue()));        ((CFFCIDFont) font).setSupplement(rosEntry.getNumber(2).intValue());    } else {        font = new CFFType1Font();    }        debugFontName = name;    font.setName(name);        font.addValueToTopDict("version", getString(topDict, "version"));    font.addValueToTopDict("Notice", getString(topDict, "Notice"));    font.addValueToTopDict("Copyright", getString(topDict, "Copyright"));    font.addValueToTopDict("FullName", getString(topDict, "FullName"));    font.addValueToTopDict("FamilyName", getString(topDict, "FamilyName"));    font.addValueToTopDict("Weight", getString(topDict, "Weight"));    font.addValueToTopDict("isFixedPitch", topDict.getBoolean("isFixedPitch", false));    font.addValueToTopDict("ItalicAngle", topDict.getNumber("ItalicAngle", 0));    font.addValueToTopDict("UnderlinePosition", topDict.getNumber("UnderlinePosition", -100));    font.addValueToTopDict("UnderlineThickness", topDict.getNumber("UnderlineThickness", 50));    font.addValueToTopDict("PaintType", topDict.getNumber("PaintType", 0));    font.addValueToTopDict("CharstringType", topDict.getNumber("CharstringType", 2));    font.addValueToTopDict("FontMatrix", topDict.getArray("FontMatrix", Arrays.<Number>asList(0.001, (double) 0, (double) 0, 0.001, (double) 0, (double) 0)));    font.addValueToTopDict("UniqueID", topDict.getNumber("UniqueID", null));    font.addValueToTopDict("FontBBox", topDict.getArray("FontBBox", Arrays.<Number>asList(0, 0, 0, 0)));    font.addValueToTopDict("StrokeWidth", topDict.getNumber("StrokeWidth", 0));    font.addValueToTopDict("XUID", topDict.getArray("XUID", null));        DictData.Entry charStringsEntry = topDict.getEntry("CharStrings");    int charStringsOffset = charStringsEntry.getNumber(0).intValue();    input.setPosition(charStringsOffset);    byte[][] charStringsIndex = readIndexData(input);        DictData.Entry charsetEntry = topDict.getEntry("charset");    CFFCharset charset;    if (charsetEntry != null) {        int charsetId = charsetEntry.getNumber(0).intValue();        if (!isCIDFont && charsetId == 0) {            charset = CFFISOAdobeCharset.getInstance();        } else if (!isCIDFont && charsetId == 1) {            charset = CFFExpertCharset.getInstance();        } else if (!isCIDFont && charsetId == 2) {            charset = CFFExpertSubsetCharset.getInstance();        } else if (charStringsIndex != null) {            input.setPosition(charsetId);            charset = readCharset(input, charStringsIndex.length, isCIDFont);        } else         {                        charset = new EmptyCharset(0);        }    } else {        if (isCIDFont) {                        int numEntries = charStringsIndex == null ? 0 : charStringsIndex.length;                        charset = new EmptyCharset(numEntries);        } else {            charset = CFFISOAdobeCharset.getInstance();        }    }    font.setCharset(charset);        font.charStrings = charStringsIndex;        if (isCIDFont) {                int numEntries = 0;        if (charStringsIndex == null) {                    } else {            numEntries = charStringsIndex.length;        }        parseCIDFontDicts(input, topDict, (CFFCIDFont) font, numEntries);        List<Number> privMatrix = null;        List<Map<String, Object>> fontDicts = ((CFFCIDFont) font).getFontDicts();        if (!fontDicts.isEmpty() && fontDicts.get(0).containsKey("FontMatrix")) {            privMatrix = (List<Number>) fontDicts.get(0).get("FontMatrix");        }                List<Number> matrix = topDict.getArray("FontMatrix", null);        if (matrix == null) {            if (privMatrix != null) {                font.addValueToTopDict("FontMatrix", privMatrix);            } else {                                font.addValueToTopDict("FontMatrix", topDict.getArray("FontMatrix", Arrays.<Number>asList(0.001, (double) 0, (double) 0, 0.001, (double) 0, (double) 0)));            }        } else if (privMatrix != null) {                                                concatenateMatrix(matrix, privMatrix);        }    } else {        parseType1Dicts(input, topDict, (CFFType1Font) font, charset);    }    return font;}
private void pdfbox_f1169_0(List<Number> matrixDest, List<Number> matrixConcat)
{                    double a1 = matrixDest.get(0).doubleValue();    double b1 = matrixDest.get(1).doubleValue();    double c1 = matrixDest.get(2).doubleValue();    double d1 = matrixDest.get(3).doubleValue();    double x1 = matrixDest.get(4).doubleValue();    double y1 = matrixDest.get(5).doubleValue();    double a2 = matrixConcat.get(0).doubleValue();    double b2 = matrixConcat.get(1).doubleValue();    double c2 = matrixConcat.get(2).doubleValue();    double d2 = matrixConcat.get(3).doubleValue();    double x2 = matrixConcat.get(4).doubleValue();    double y2 = matrixConcat.get(5).doubleValue();    matrixDest.set(0, a1 * a2 + b1 * c2);    matrixDest.set(1, a1 * b2 + b1 * d1);    matrixDest.set(2, c1 * a2 + d1 * c2);    matrixDest.set(3, c1 * b2 + d1 * d2);    matrixDest.set(4, x1 * a2 + y1 * c2 + x2);    matrixDest.set(5, x1 * b2 + y1 * d2 + y2);}
private void pdfbox_f1170_0(CFFDataInput input, DictData topDict, CFFCIDFont font, int nrOfcharStrings) throws IOException
{            DictData.Entry fdArrayEntry = topDict.getEntry("FDArray");    if (fdArrayEntry == null) {        throw new IOException("FDArray is missing for a CIDKeyed Font.");    }        int fontDictOffset = fdArrayEntry.getNumber(0).intValue();    input.setPosition(fontDictOffset);    byte[][] fdIndex = readIndexData(input);    List<Map<String, Object>> privateDictionaries = new LinkedList<>();    List<Map<String, Object>> fontDictionaries = new LinkedList<>();    for (byte[] bytes : fdIndex) {        CFFDataInput fontDictInput = new CFFDataInput(bytes);        DictData fontDict = readDictData(fontDictInput);                DictData.Entry privateEntry = fontDict.getEntry("Private");        if (privateEntry == null) {            throw new IOException("Font DICT invalid without \"Private\" entry");        }                Map<String, Object> fontDictMap = new LinkedHashMap<>(4);        fontDictMap.put("FontName", getString(fontDict, "FontName"));        fontDictMap.put("FontType", fontDict.getNumber("FontType", 0));        fontDictMap.put("FontBBox", fontDict.getArray("FontBBox", null));        fontDictMap.put("FontMatrix", fontDict.getArray("FontMatrix", null));                fontDictionaries.add(fontDictMap);        int privateOffset = privateEntry.getNumber(1).intValue();        input.setPosition(privateOffset);        int privateSize = privateEntry.getNumber(0).intValue();        DictData privateDict = readDictData(input, privateSize);                Map<String, Object> privDict = readPrivateDict(privateDict);        privateDictionaries.add(privDict);                int localSubrOffset = (Integer) privateDict.getNumber("Subrs", 0);        if (localSubrOffset > 0) {            input.setPosition(privateOffset + localSubrOffset);            privDict.put("Subrs", readIndexData(input));        }    }        DictData.Entry fdSelectEntry = topDict.getEntry("FDSelect");    int fdSelectPos = fdSelectEntry.getNumber(0).intValue();    input.setPosition(fdSelectPos);    FDSelect fdSelect = readFDSelect(input, nrOfcharStrings, font);                font.setFontDict(fontDictionaries);    font.setPrivDict(privateDictionaries);    font.setFdSelect(fdSelect);}
private Map<String, Object> pdfbox_f1171_0(DictData privateDict)
{    Map<String, Object> privDict = new LinkedHashMap<>(17);    privDict.put("BlueValues", privateDict.getDelta("BlueValues", null));    privDict.put("OtherBlues", privateDict.getDelta("OtherBlues", null));    privDict.put("FamilyBlues", privateDict.getDelta("FamilyBlues", null));    privDict.put("FamilyOtherBlues", privateDict.getDelta("FamilyOtherBlues", null));    privDict.put("BlueScale", privateDict.getNumber("BlueScale", 0.039625));    privDict.put("BlueShift", privateDict.getNumber("BlueShift", 7));    privDict.put("BlueFuzz", privateDict.getNumber("BlueFuzz", 1));    privDict.put("StdHW", privateDict.getNumber("StdHW", null));    privDict.put("StdVW", privateDict.getNumber("StdVW", null));    privDict.put("StemSnapH", privateDict.getDelta("StemSnapH", null));    privDict.put("StemSnapV", privateDict.getDelta("StemSnapV", null));    privDict.put("ForceBold", privateDict.getBoolean("ForceBold", false));    privDict.put("LanguageGroup", privateDict.getNumber("LanguageGroup", 0));    privDict.put("ExpansionFactor", privateDict.getNumber("ExpansionFactor", 0.06));    privDict.put("initialRandomSeed", privateDict.getNumber("initialRandomSeed", 0));    privDict.put("defaultWidthX", privateDict.getNumber("defaultWidthX", 0));    privDict.put("nominalWidthX", privateDict.getNumber("nominalWidthX", 0));    return privDict;}
private void pdfbox_f1172_0(CFFDataInput input, DictData topDict, CFFType1Font font, CFFCharset charset) throws IOException
{        DictData.Entry encodingEntry = topDict.getEntry("Encoding");    CFFEncoding encoding;    int encodingId = encodingEntry != null ? encodingEntry.getNumber(0).intValue() : 0;    switch(encodingId) {        case 0:            encoding = CFFStandardEncoding.getInstance();            break;        case 1:            encoding = CFFExpertEncoding.getInstance();            break;        default:            input.setPosition(encodingId);            encoding = readEncoding(input, charset);            break;    }    font.setEncoding(encoding);        DictData.Entry privateEntry = topDict.getEntry("Private");    if (privateEntry == null) {        throw new IOException("Private dictionary entry missing for font " + font.fontName);    }    int privateOffset = privateEntry.getNumber(1).intValue();    input.setPosition(privateOffset);    int privateSize = privateEntry.getNumber(0).intValue();    DictData privateDict = readDictData(input, privateSize);        Map<String, Object> privDict = readPrivateDict(privateDict);    for (Map.Entry<String, Object> entry : privDict.entrySet()) {        font.addToPrivateDict(entry.getKey(), entry.getValue());    }        int localSubrOffset = (Integer) privateDict.getNumber("Subrs", 0);    if (localSubrOffset > 0) {        input.setPosition(privateOffset + localSubrOffset);        font.addToPrivateDict("Subrs", readIndexData(input));    }}
private String pdfbox_f1173_0(int index) throws IOException
{    if (index >= 0 && index <= 390) {        return CFFStandardString.getName(index);    }    if (index - 391 < stringIndex.length) {        return stringIndex[index - 391];    } else {                return "SID" + index;    }}
private String pdfbox_f1174_0(DictData dict, String name) throws IOException
{    DictData.Entry entry = dict.getEntry(name);    return entry != null ? readString(entry.getNumber(0).intValue()) : null;}
private CFFEncoding pdfbox_f1175_0(CFFDataInput dataInput, CFFCharset charset) throws IOException
{    int format = dataInput.readCard8();    int baseFormat = format & 0x7f;    switch(baseFormat) {        case 0:            return readFormat0Encoding(dataInput, charset, format);        case 1:            return readFormat1Encoding(dataInput, charset, format);        default:            throw new IllegalArgumentException();    }}
private Format0Encoding pdfbox_f1176_0(CFFDataInput dataInput, CFFCharset charset, int format) throws IOException
{    Format0Encoding encoding = new Format0Encoding();    encoding.format = format;    encoding.nCodes = dataInput.readCard8();    encoding.add(0, 0, ".notdef");    for (int gid = 1; gid <= encoding.nCodes; gid++) {        int code = dataInput.readCard8();        int sid = charset.getSIDForGID(gid);        encoding.add(code, sid, readString(sid));    }    if ((format & 0x80) != 0) {        readSupplement(dataInput, encoding);    }    return encoding;}
private Format1Encoding pdfbox_f1177_0(CFFDataInput dataInput, CFFCharset charset, int format) throws IOException
{    Format1Encoding encoding = new Format1Encoding();    encoding.format = format;    encoding.nRanges = dataInput.readCard8();    encoding.add(0, 0, ".notdef");    int gid = 1;    for (int i = 0; i < encoding.nRanges; i++) {        int rangeFirst = dataInput.readCard8();        int rangeLeft = dataInput.readCard8();        for (int j = 0; j < 1 + rangeLeft; j++) {            int sid = charset.getSIDForGID(gid);            int code = rangeFirst + j;            encoding.add(code, sid, readString(sid));            gid++;        }    }    if ((format & 0x80) != 0) {        readSupplement(dataInput, encoding);    }    return encoding;}
private void pdfbox_f1178_0(CFFDataInput dataInput, CFFBuiltInEncoding encoding) throws IOException
{    encoding.nSups = dataInput.readCard8();    encoding.supplement = new CFFBuiltInEncoding.Supplement[encoding.nSups];    for (int i = 0; i < encoding.supplement.length; i++) {        CFFBuiltInEncoding.Supplement supplement = new CFFBuiltInEncoding.Supplement();        supplement.code = dataInput.readCard8();        supplement.sid = dataInput.readSID();        supplement.name = readString(supplement.sid);        encoding.supplement[i] = supplement;        encoding.add(supplement.code, supplement.sid, readString(supplement.sid));    }}
private static FDSelect pdfbox_f1179_0(CFFDataInput dataInput, int nGlyphs, CFFCIDFont ros) throws IOException
{    int format = dataInput.readCard8();    switch(format) {        case 0:            return readFormat0FDSelect(dataInput, format, nGlyphs, ros);        case 3:            return readFormat3FDSelect(dataInput, format, nGlyphs, ros);        default:            throw new IllegalArgumentException();    }}
private static Format0FDSelect pdfbox_f1180_0(CFFDataInput dataInput, int format, int nGlyphs, CFFCIDFont ros) throws IOException
{    Format0FDSelect fdselect = new Format0FDSelect(ros);    fdselect.format = format;    fdselect.fds = new int[nGlyphs];    for (int i = 0; i < fdselect.fds.length; i++) {        fdselect.fds[i] = dataInput.readCard8();    }    return fdselect;}
private static Format3FDSelect pdfbox_f1181_0(CFFDataInput dataInput, int format, int nGlyphs, CFFCIDFont ros) throws IOException
{    Format3FDSelect fdselect = new Format3FDSelect(ros);    fdselect.format = format;    fdselect.nbRanges = dataInput.readCard16();    fdselect.range3 = new Range3[fdselect.nbRanges];    for (int i = 0; i < fdselect.nbRanges; i++) {        Range3 r3 = new Range3();        r3.first = dataInput.readCard16();        r3.fd = dataInput.readCard8();        fdselect.range3[i] = r3;    }    fdselect.sentinel = dataInput.readCard16();    return fdselect;}
public int pdfbox_f1182_0(int gid)
{    for (int i = 0; i < nbRanges; ++i) {        if (range3[i].first <= gid) {            if (i + 1 < nbRanges) {                if (range3[i + 1].first > gid) {                    return range3[i].fd;                }                        } else {                                if (sentinel > gid) {                    return range3[i].fd;                }                return -1;            }        }    }    return 0;}
public String pdfbox_f1183_0()
{    return getClass().getName() + "[format=" + format + " nbRanges=" + nbRanges + ", range3=" + Arrays.toString(range3) + " sentinel=" + sentinel + "]";}
public String pdfbox_f1184_0()
{    return getClass().getName() + "[first=" + first + ", fd=" + fd + "]";}
public int pdfbox_f1185_0(int gid)
{    if (gid < fds.length) {        return fds[gid];    }    return 0;}
public String pdfbox_f1186_0()
{    return getClass().getName() + "[fds=" + Arrays.toString(fds) + "]";}
private CFFCharset pdfbox_f1187_0(CFFDataInput dataInput, int nGlyphs, boolean isCIDFont) throws IOException
{    int format = dataInput.readCard8();    switch(format) {        case 0:            return readFormat0Charset(dataInput, format, nGlyphs, isCIDFont);        case 1:            return readFormat1Charset(dataInput, format, nGlyphs, isCIDFont);        case 2:            return readFormat2Charset(dataInput, format, nGlyphs, isCIDFont);        default:            throw new IllegalArgumentException();    }}
private Format0Charset pdfbox_f1188_0(CFFDataInput dataInput, int format, int nGlyphs, boolean isCIDFont) throws IOException
{    Format0Charset charset = new Format0Charset(isCIDFont);    charset.format = format;    if (isCIDFont) {        charset.addCID(0, 0);    } else {        charset.addSID(0, 0, ".notdef");    }    for (int gid = 1; gid < nGlyphs; gid++) {        int sid = dataInput.readSID();        if (isCIDFont) {            charset.addCID(gid, sid);        } else {            charset.addSID(gid, sid, readString(sid));        }    }    return charset;}
private Format1Charset pdfbox_f1189_0(CFFDataInput dataInput, int format, int nGlyphs, boolean isCIDFont) throws IOException
{    Format1Charset charset = new Format1Charset(isCIDFont);    charset.format = format;    if (isCIDFont) {        charset.addCID(0, 0);        charset.rangesCID2GID = new ArrayList<>();    } else {        charset.addSID(0, 0, ".notdef");    }    for (int gid = 1; gid < nGlyphs; gid++) {        int rangeFirst = dataInput.readSID();        int rangeLeft = dataInput.readCard8();        if (!isCIDFont) {            for (int j = 0; j < 1 + rangeLeft; j++) {                int sid = rangeFirst + j;                charset.addSID(gid + j, sid, readString(sid));            }        } else {            charset.rangesCID2GID.add(new RangeMapping(gid, rangeFirst, rangeLeft));        }        gid += rangeLeft;    }    return charset;}
private Format2Charset pdfbox_f1190_0(CFFDataInput dataInput, int format, int nGlyphs, boolean isCIDFont) throws IOException
{    Format2Charset charset = new Format2Charset(isCIDFont);    charset.format = format;    if (isCIDFont) {        charset.addCID(0, 0);        charset.rangesCID2GID = new ArrayList<>();    } else {        charset.addSID(0, 0, ".notdef");    }    for (int gid = 1; gid < nGlyphs; gid++) {        int first = dataInput.readSID();        int nLeft = dataInput.readCard16();        if (!isCIDFont) {            for (int j = 0; j < 1 + nLeft; j++) {                int sid = first + j;                charset.addSID(gid + j, sid, readString(sid));            }        } else {            charset.rangesCID2GID.add(new RangeMapping(gid, first, nLeft));        }        gid += nLeft;    }    return charset;}
public String pdfbox_f1191_0()
{    return getClass().getName() + "[major=" + major + ", minor=" + minor + ", hdrSize=" + hdrSize + ", offSize=" + offSize + "]";}
public void pdfbox_f1192_0(Entry entry)
{    if (entry.operator != null) {        entries.put(entry.operator.getName(), entry);    }}
public Entry pdfbox_f1193_0(String name)
{    return entries.get(name);}
public Boolean pdfbox_f1194_0(String name, boolean defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getBoolean(0) : defaultValue;}
public List<Number> pdfbox_f1195_0(String name, List<Number> defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getArray() : defaultValue;}
public Number pdfbox_f1196_0(String name, Number defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getNumber(0) : defaultValue;}
public List<Number> pdfbox_f1197_0(String name, List<Number> defaultValue)
{    Entry entry = getEntry(name);    return entry != null && !entry.getArray().isEmpty() ? entry.getDelta() : defaultValue;}
public String pdfbox_f1198_0()
{    return getClass().getName() + "[entries=" + entries + "]";}
public Number pdfbox_f1199_0(int index)
{    return operands.get(index);}
public Boolean pdfbox_f1200_0(int index)
{    Number operand = operands.get(index);    if (operand instanceof Integer) {        switch(operand.intValue()) {            case 0:                return Boolean.FALSE;            case 1:                return Boolean.TRUE;            default:                break;        }    }    throw new IllegalArgumentException();}
public List<Number> pdfbox_f1201_0()
{    return operands;}
public List<Number> pdfbox_f1202_0()
{    List<Number> result = new ArrayList<>(operands);    for (int i = 1; i < result.size(); i++) {        Number previous = result.get(i - 1);        Number current = result.get(i);        Integer sum = previous.intValue() + current.intValue();        result.set(i, sum);    }    return result;}
public String pdfbox_f1203_0()
{    return getClass().getName() + "[operands=" + operands + ", operator=" + operator + "]";}
public int pdfbox_f1204_0()
{    return code;}
public int pdfbox_f1205_0()
{    return sid;}
public String pdfbox_f1206_0()
{    return name;}
public String pdfbox_f1207_0()
{    return getClass().getName() + "[code=" + code + ", sid=" + sid + "]";}
public String pdfbox_f1208_0()
{    return getClass().getName() + "[format=" + format + ", nCodes=" + nCodes + ", supplement=" + Arrays.toString(super.supplement) + "]";}
public String pdfbox_f1209_0()
{    return getClass().getName() + "[format=" + format + ", nRanges=" + nRanges + ", supplement=" + Arrays.toString(super.supplement) + "]";}
public String pdfbox_f1210_0()
{    return getClass().getName();}
public String pdfbox_f1211_0()
{    return getClass().getName() + "[format=" + format + "]";}
public int pdfbox_f1212_0(int gid)
{    if (isCIDFont()) {        for (RangeMapping mapping : rangesCID2GID) {            if (mapping.isInRange(gid)) {                return mapping.mapValue(gid);            }        }    }    return super.getCIDForGID(gid);}
public int pdfbox_f1213_0(int cid)
{    if (isCIDFont()) {        for (RangeMapping mapping : rangesCID2GID) {            if (mapping.isInReverseRange(cid)) {                return mapping.mapReverseValue(cid);            }        }    }    return super.getGIDForCID(cid);}
public String pdfbox_f1214_0()
{    return getClass().getName() + "[format=" + format + "]";}
public int pdfbox_f1215_0(int gid)
{    for (RangeMapping mapping : rangesCID2GID) {        if (mapping.isInRange(gid)) {            return mapping.mapValue(gid);        }    }    return super.getCIDForGID(gid);}
public int pdfbox_f1216_0(int cid)
{    for (RangeMapping mapping : rangesCID2GID) {        if (mapping.isInReverseRange(cid)) {            return mapping.mapReverseValue(cid);        }    }    return super.getGIDForCID(cid);}
public String pdfbox_f1217_0()
{    return getClass().getName() + "[format=" + format + "]";}
 boolean pdfbox_f1218_0(int value)
{    return value >= startValue && value <= endValue;}
 boolean pdfbox_f1219_0(int value)
{    return value >= startMappedValue && value <= endMappedValue;}
 int pdfbox_f1220_0(int value)
{    if (isInRange(value)) {        return startMappedValue + (value - startValue);    } else {        return 0;    }}
 int pdfbox_f1221_0(int value)
{    if (isInReverseRange(value)) {        return startValue + (value - startMappedValue);    } else {        return 0;    }}
public String pdfbox_f1222_0()
{    return getClass().getName() + "[start value=" + startValue + ", end value=" + endValue + ", start mapped-value=" + startMappedValue + ", end mapped-value=" + endMappedValue + "]";}
public String pdfbox_f1223_0()
{    return getClass().getSimpleName() + "[" + debugFontName + "]";}
public static CFFStandardEncoding pdfbox_f1224_0()
{    return CFFStandardEncoding.INSTANCE;}
public static String pdfbox_f1225_0(int sid)
{    return SID2STR[sid];}
public Type1CharString pdfbox_f1226_0(String name) throws IOException
{    return CFFType1Font.this.getType1CharString(name);}
public GeneralPath pdfbox_f1227_0(String name) throws IOException
{    return getType1CharString(name).getPath();}
public float pdfbox_f1228_0(String name) throws IOException
{    return getType1CharString(name).getWidth();}
public boolean pdfbox_f1229_0(String name)
{    int sid = charset.getSID(name);    int gid = charset.getGIDForSID(sid);    return gid != 0;}
public List<Number> pdfbox_f1230_0()
{    return (List<Number>) topDict.get("FontMatrix");}
public Type1CharString pdfbox_f1231_0(String name) throws IOException
{        int gid = nameToGID(name);        return getType2CharString(gid, name);}
public int pdfbox_f1232_0(String name)
{        int sid = charset.getSID(name);    return charset.getGIDForSID(sid);}
public Type2CharString pdfbox_f1233_0(int gid) throws IOException
{        String name = "GID+" + gid;    return getType2CharString(gid, name);}
private Type2CharString pdfbox_f1234_0(int gid, String name) throws IOException
{    Type2CharString type2 = charStringCache.get(gid);    if (type2 == null) {        byte[] bytes = null;        if (gid < charStrings.length) {            bytes = charStrings[gid];        }        if (bytes == null) {                        bytes = charStrings[0];        }        Type2CharStringParser parser = new Type2CharStringParser(fontName, name);        List<Object> type2seq = parser.parse(bytes, globalSubrIndex, getLocalSubrIndex());        type2 = new Type2CharString(reader, fontName, name, gid, type2seq, getDefaultWidthX(), getNominalWidthX());        charStringCache.put(gid, type2);    }    return type2;}
public Map<String, Object> pdfbox_f1235_0()
{    return privateDict;}
 void pdfbox_f1236_0(String name, Object value)
{    if (value != null) {        privateDict.put(name, value);    }}
public CFFEncoding pdfbox_f1237_0()
{    return encoding;}
 void pdfbox_f1238_0(CFFEncoding encoding)
{    this.encoding = encoding;}
private byte[][] pdfbox_f1239_0()
{    return (byte[][]) privateDict.get("Subrs");}
private Object pdfbox_f1240_0(String name)
{    Object topDictValue = topDict.get(name);    if (topDictValue != null) {        return topDictValue;    }    Object privateDictValue = privateDict.get(name);    if (privateDictValue != null) {        return privateDictValue;    }    return null;}
private int pdfbox_f1241_0()
{    Number num = (Number) getProperty("defaultWidthX");    if (num == null) {        return 1000;    }    return num.intValue();}
private int pdfbox_f1242_0()
{    Number num = (Number) getProperty("nominalWidthX");    if (num == null) {        return 0;    }    return num.intValue();}
public Key pdfbox_f1243_0()
{    return commandKey;}
private void pdfbox_f1244_0(Key key)
{    commandKey = key;}
public String pdfbox_f1245_0()
{    String str = TYPE2_VOCABULARY.get(getKey());    if (str == null) {        str = TYPE1_VOCABULARY.get(getKey());    }    if (str == null) {        return getKey().toString() + '|';    }    return str + '|';}
public int pdfbox_f1246_0()
{    return getKey().hashCode();}
public boolean pdfbox_f1247_0(Object object)
{    if (object instanceof CharStringCommand) {        CharStringCommand that = (CharStringCommand) object;        return getKey().equals(that.getKey());    }    return false;}
public int[] pdfbox_f1248_0()
{    return keyValues;}
private void pdfbox_f1249_0(int[] value)
{    keyValues = value;}
public String pdfbox_f1250_0()
{    return Arrays.toString(getValue());}
public int pdfbox_f1251_0()
{    if (keyValues[0] == 12 && keyValues.length > 1) {        return keyValues[0] ^ keyValues[1];    }    return keyValues[0];}
public boolean pdfbox_f1252_0(Object object)
{    if (object instanceof Key) {        Key that = (Key) object;        if (keyValues[0] == 12 && that.keyValues[0] == 12) {            if (keyValues.length > 1 && that.keyValues.length > 1) {                return keyValues[1] == that.keyValues[1];            }            return keyValues.length == that.keyValues.length;        }        return keyValues[0] == that.keyValues[0];    }    return false;}
 List<Number> pdfbox_f1253_0(List<Object> sequence)
{    Stack<Number> stack = new Stack<>();    sequence.forEach(obj -> {        if (obj instanceof CharStringCommand) {            List<Number> results = handleCommand(stack, (CharStringCommand) obj);                        stack.clear();            stack.addAll(results);        } else {            stack.push((Number) obj);        }    });    return stack;}
public int pdfbox_f1254_0()
{    return cid;}
public boolean pdfbox_f1255_0()
{    return bufferPosition < inputBuffer.length;}
public int pdfbox_f1256_0()
{    return bufferPosition;}
public void pdfbox_f1257_0(int position)
{    bufferPosition = position;}
public String pdfbox_f1258_0() throws IOException
{    return new String(inputBuffer, Charsets.ISO_8859_1);}
public byte pdfbox_f1259_1() throws IOException
{    try {        byte value = inputBuffer[bufferPosition];        bufferPosition++;        return value;    } catch (RuntimeException re) {                return -1;    }}
public int pdfbox_f1260_0() throws IOException
{    int b = read();    if (b < 0) {        throw new EOFException();    }    return b;}
public int pdfbox_f1261_0(int offset) throws IOException
{    int b = peek(offset);    if (b < 0) {        throw new EOFException();    }    return b;}
public short pdfbox_f1262_0() throws IOException
{    return (short) readUnsignedShort();}
public int pdfbox_f1263_0() throws IOException
{    int b1 = read();    int b2 = read();    if ((b1 | b2) < 0) {        throw new EOFException();    }    return b1 << 8 | b2;}
public int pdfbox_f1264_0() throws IOException
{    int b1 = read();    int b2 = read();    int b3 = read();    int b4 = read();    if ((b1 | b2 | b3 | b4) < 0) {        throw new EOFException();    }    return b1 << 24 | b2 << 16 | b3 << 8 | b4;}
public byte[] pdfbox_f1265_0(int length) throws IOException
{    if (inputBuffer.length - bufferPosition < length) {        throw new EOFException();    }    byte[] bytes = new byte[length];    System.arraycopy(inputBuffer, bufferPosition, bytes, 0, length);    bufferPosition += length;    return bytes;}
private int pdfbox_f1266_1()
{    try {        int value = inputBuffer[bufferPosition] & 0xff;        bufferPosition++;        return value;    } catch (RuntimeException re) {                return -1;    }}
private int pdfbox_f1267_1(int offset)
{    try {        return inputBuffer[bufferPosition + offset] & 0xff;    } catch (RuntimeException re) {                return -1;    }}
public int pdfbox_f1268_0()
{    return inputBuffer.length;}
public byte[] pdfbox_f1269_0()
{    return outputBuffer.toByteArray();}
public void pdfbox_f1270_0(int value)
{    outputBuffer.write(value);}
public void pdfbox_f1271_0(byte[] buffer)
{    outputBuffer.write(buffer, 0, buffer.length);}
public void pdfbox_f1272_0(byte[] buffer, int offset, int length)
{    outputBuffer.write(buffer, offset, length);}
public void pdfbox_f1273_0(String string) throws IOException
{    write(string.getBytes(outputEncoding));}
public void pdfbox_f1274_0(String string) throws IOException
{    write(string.getBytes(outputEncoding));    write('\n');}
public void pdfbox_f1275_0()
{    write('\n');}
public String pdfbox_f1276_0()
{    return glyphName;}
public Rectangle2D pdfbox_f1277_0()
{    synchronized (LOG) {        if (path == null) {            render();        }    }    return path.getBounds2D();}
public int pdfbox_f1278_0()
{    synchronized (LOG) {        if (path == null) {            render();        }    }    return width;}
public GeneralPath pdfbox_f1279_0()
{    synchronized (LOG) {        if (path == null) {            render();        }    }    return path;}
public List<Object> pdfbox_f1280_0()
{    return type1Sequence;}
private void pdfbox_f1281_0()
{    path = new GeneralPath();    leftSideBearing = new Point2D.Float(0, 0);    width = 0;    CharStringHandler handler = Type1CharString.this::handleCommand;    handler.handleSequence(type1Sequence);}
private List<Number> pdfbox_f1282_1(List<Number> numbers, CharStringCommand command)
{    commandCount++;    String name = CharStringCommand.TYPE1_VOCABULARY.get(command.getKey());    if ("rmoveto".equals(name)) {        if (numbers.size() >= 2) {            if (isFlex) {                flexPoints.add(new Point2D.Float(numbers.get(0).floatValue(), numbers.get(1).floatValue()));            } else {                rmoveTo(numbers.get(0), numbers.get(1));            }        }    } else if ("vmoveto".equals(name)) {        if (numbers.size() >= 1) {            if (isFlex) {                                flexPoints.add(new Point2D.Float(0f, numbers.get(0).floatValue()));            } else {                rmoveTo(0, numbers.get(0));            }        }    } else if ("hmoveto".equals(name)) {        if (numbers.size() >= 1) {            if (isFlex) {                                flexPoints.add(new Point2D.Float(numbers.get(0).floatValue(), 0f));            } else {                rmoveTo(numbers.get(0), 0);            }        }    } else if ("rlineto".equals(name)) {        if (numbers.size() >= 2) {            rlineTo(numbers.get(0), numbers.get(1));        }    } else if ("hlineto".equals(name)) {        if (numbers.size() >= 1) {            rlineTo(numbers.get(0), 0);        }    } else if ("vlineto".equals(name)) {        if (numbers.size() >= 1) {            rlineTo(0, numbers.get(0));        }    } else if ("rrcurveto".equals(name)) {        if (numbers.size() >= 6) {            rrcurveTo(numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), numbers.get(4), numbers.get(5));        }    } else if ("closepath".equals(name)) {        closepath();    } else if ("sbw".equals(name)) {        if (numbers.size() >= 3) {            leftSideBearing = new Point2D.Float(numbers.get(0).floatValue(), numbers.get(1).floatValue());            width = numbers.get(2).intValue();            current.setLocation(leftSideBearing);        }    } else if ("hsbw".equals(name)) {        if (numbers.size() >= 2) {            leftSideBearing = new Point2D.Float(numbers.get(0).floatValue(), 0);            width = numbers.get(1).intValue();            current.setLocation(leftSideBearing);        }    } else if ("vhcurveto".equals(name)) {        if (numbers.size() >= 4) {            rrcurveTo(0, numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), 0);        }    } else if ("hvcurveto".equals(name)) {        if (numbers.size() >= 4) {            rrcurveTo(numbers.get(0), 0, numbers.get(1), numbers.get(2), 0, numbers.get(3));        }    } else if ("seac".equals(name)) {        if (numbers.size() >= 5) {            seac(numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), numbers.get(4));        }    } else if ("setcurrentpoint".equals(name)) {        if (numbers.size() >= 2) {            setcurrentpoint(numbers.get(0), numbers.get(1));        }    } else if ("callothersubr".equals(name)) {        if (numbers.size() >= 1) {            callothersubr(numbers.get(0).intValue());        }    } else if ("div".equals(name)) {        float b = numbers.get(numbers.size() - 1).floatValue();        float a = numbers.get(numbers.size() - 2).floatValue();        float result = a / b;        List<Number> list = new ArrayList<>(numbers);        list.remove(list.size() - 1);        list.remove(list.size() - 1);        list.add(result);        return list;    } else if ("hstem".equals(name) || "vstem".equals(name) || "hstem3".equals(name) || "vstem3".equals(name) || "dotsection".equals(name)) {        } else if ("endchar".equals(name)) {        } else if ("return".equals(name)) {                    } else if (name != null) {                throw new IllegalArgumentException("Unhandled command: " + name);    } else {                    }    return Collections.emptyList();}
private void pdfbox_f1283_0(Number x, Number y)
{    current.setLocation(x.floatValue(), y.floatValue());}
private void pdfbox_f1284_1(int num)
{    if (num == 0) {                isFlex = false;        if (flexPoints.size() < 7) {                        return;        }                Point.Float reference = flexPoints.get(0);        reference.setLocation(current.getX() + reference.getX(), current.getY() + reference.getY());                Point.Float first = flexPoints.get(1);        first.setLocation(reference.getX() + first.getX(), reference.getY() + first.getY());                first.setLocation(first.getX() - current.getX(), first.getY() - current.getY());        rrcurveTo(flexPoints.get(1).getX(), flexPoints.get(1).getY(), flexPoints.get(2).getX(), flexPoints.get(2).getY(), flexPoints.get(3).getX(), flexPoints.get(3).getY());        rrcurveTo(flexPoints.get(4).getX(), flexPoints.get(4).getY(), flexPoints.get(5).getX(), flexPoints.get(5).getY(), flexPoints.get(6).getX(), flexPoints.get(6).getY());        flexPoints.clear();    } else if (num == 1) {                isFlex = true;    } else {                throw new IllegalArgumentException("Unexpected other subroutine: " + num);    }}
private void pdfbox_f1285_0(Number dx, Number dy)
{    float x = (float) current.getX() + dx.floatValue();    float y = (float) current.getY() + dy.floatValue();    path.moveTo(x, y);    current.setLocation(x, y);}
private void pdfbox_f1286_1(Number dx, Number dy)
{    float x = (float) current.getX() + dx.floatValue();    float y = (float) current.getY() + dy.floatValue();    if (path.getCurrentPoint() == null) {                path.moveTo(x, y);    } else {        path.lineTo(x, y);    }    current.setLocation(x, y);}
private void pdfbox_f1287_1(Number dx1, Number dy1, Number dx2, Number dy2, Number dx3, Number dy3)
{    float x1 = (float) current.getX() + dx1.floatValue();    float y1 = (float) current.getY() + dy1.floatValue();    float x2 = x1 + dx2.floatValue();    float y2 = y1 + dy2.floatValue();    float x3 = x2 + dx3.floatValue();    float y3 = y2 + dy3.floatValue();    if (path.getCurrentPoint() == null) {                path.moveTo(x3, y3);    } else {        path.curveTo(x1, y1, x2, y2, x3, y3);    }    current.setLocation(x3, y3);}
private void pdfbox_f1288_1()
{    if (path.getCurrentPoint() == null) {            } else {        path.closePath();    }    path.moveTo(current.getX(), current.getY());}
private void pdfbox_f1289_1(Number asb, Number adx, Number ady, Number bchar, Number achar)
{        String baseName = StandardEncoding.INSTANCE.getName(bchar.intValue());    try {        Type1CharString base = font.getType1CharString(baseName);        path.append(base.getPath().getPathIterator(null), false);    } catch (IOException e) {            }        String accentName = StandardEncoding.INSTANCE.getName(achar.intValue());    try {        Type1CharString accent = font.getType1CharString(accentName);        AffineTransform at = AffineTransform.getTranslateInstance(leftSideBearing.getX() + adx.floatValue() - asb.floatValue(), leftSideBearing.getY() + ady.floatValue());        path.append(accent.getPath().getPathIterator(at), false);    } catch (IOException e) {            }}
public String pdfbox_f1290_0()
{    return type1Sequence.toString().replace("|", "\n").replace(",", " ");}
public List<Object> pdfbox_f1291_0(byte[] bytes, List<byte[]> subrs) throws IOException
{    return parse(bytes, subrs, new ArrayList<>());}
private List<Object> pdfbox_f1292_1(byte[] bytes, List<byte[]> subrs, List<Object> sequence) throws IOException
{    DataInput input = new DataInput(bytes);    while (input.hasRemaining()) {        int b0 = input.readUnsignedByte();        if (b0 == CALLSUBR) {                        Object obj = sequence.remove(sequence.size() - 1);            if (!(obj instanceof Integer)) {                                continue;            }            Integer operand = (Integer) obj;            if (operand >= 0 && operand < subrs.size()) {                byte[] subrBytes = subrs.get(operand);                parse(subrBytes, subrs, sequence);                Object lastItem = sequence.get(sequence.size() - 1);                if (lastItem instanceof CharStringCommand && ((CharStringCommand) lastItem).getKey().getValue()[0] == RETURN) {                                        sequence.remove(sequence.size() - 1);                }            } else {                                                while (sequence.get(sequence.size() - 1) instanceof Integer) {                    sequence.remove(sequence.size() - 1);                }            }        } else if (b0 == TWO_BYTE && input.peekUnsignedByte(0) == CALLOTHERSUBR) {                        input.readByte();            Integer othersubrNum = (Integer) sequence.remove(sequence.size() - 1);            Integer numArgs = (Integer) sequence.remove(sequence.size() - 1);                        Stack<Integer> results = new Stack<>();            switch(othersubrNum) {                case 0:                    results.push(removeInteger(sequence));                    results.push(removeInteger(sequence));                    sequence.remove(sequence.size() - 1);                                        sequence.add(0);                    sequence.add(new CharStringCommand(TWO_BYTE, CALLOTHERSUBR));                    break;                case 1:                                        sequence.add(1);                    sequence.add(new CharStringCommand(TWO_BYTE, CALLOTHERSUBR));                    break;                case 3:                                        results.push(removeInteger(sequence));                    break;                default:                                        for (int i = 0; i < numArgs; i++) {                        results.push(removeInteger(sequence));                    }                    break;            }                        while (input.peekUnsignedByte(0) == TWO_BYTE && input.peekUnsignedByte(1) == POP) {                                input.readByte();                                input.readByte();                sequence.add(results.pop());            }            if (results.size() > 0) {                            }        } else if (b0 >= 0 && b0 <= 31) {            sequence.add(readCommand(input, b0));        } else if (b0 >= 32 && b0 <= 255) {            sequence.add(readNumber(input, b0));        } else {            throw new IllegalArgumentException();        }    }    return sequence;}
private static Integer pdfbox_f1293_0(List<Object> sequence) throws IOException
{    Object item = sequence.remove(sequence.size() - 1);    if (item instanceof Integer) {        return (Integer) item;    }    CharStringCommand command = (CharStringCommand) item;        if (command.getKey().getValue()[0] == 12 && command.getKey().getValue()[1] == 12) {        int a = (Integer) sequence.remove(sequence.size() - 1);        int b = (Integer) sequence.remove(sequence.size() - 1);        return b / a;    }    throw new IOException("Unexpected char string command: " + command.getKey());}
private CharStringCommand pdfbox_f1294_0(DataInput input, int b0) throws IOException
{    if (b0 == 12) {        int b1 = input.readUnsignedByte();        return new CharStringCommand(b0, b1);    }    return new CharStringCommand(b0);}
private Integer pdfbox_f1295_0(DataInput input, int b0) throws IOException
{    if (b0 >= 32 && b0 <= 246) {        return b0 - 139;    } else if (b0 >= 247 && b0 <= 250) {        int b1 = input.readUnsignedByte();        return (b0 - 247) * 256 + b1 + 108;    } else if (b0 >= 251 && b0 <= 254) {        int b1 = input.readUnsignedByte();        return -(b0 - 251) * 256 - b1 - 108;    } else if (b0 == 255) {        return input.readInt();    } else {        throw new IllegalArgumentException();    }}
public static String pdfbox_f1296_0(byte[] bytes)
{    StringBuilder sb = new StringBuilder();    for (byte aByte : bytes) {        String string = Integer.toHexString(aByte & 0xff);        if (string.length() == 1) {            sb.append("0");        }        sb.append(string.toUpperCase(Locale.US));    }    return sb.toString();}
public static byte[] pdfbox_f1297_0(String string)
{    if (string.length() % 2 != 0) {        throw new IllegalArgumentException();    }    byte[] bytes = new byte[string.length() / 2];    for (int i = 0; i < string.length(); i += 2) {        bytes[i / 2] = (byte) Integer.parseInt(string.substring(i, i + 2), 16);    }    return bytes;}
public static byte[] pdfbox_f1298_0(byte[] buffer)
{    return encrypt(buffer, 55665, 4);}
public static byte[] pdfbox_f1299_0(byte[] buffer, int n)
{    return encrypt(buffer, 4330, n);}
private static byte[] pdfbox_f1300_0(byte[] plaintextBytes, int r, int n)
{    byte[] buffer = new byte[plaintextBytes.length + n];    for (int i = 0; i < n; i++) {        buffer[i] = 0;    }    System.arraycopy(plaintextBytes, 0, buffer, n, buffer.length - n);    int c1 = 52845;    int c2 = 22719;    byte[] ciphertextBytes = new byte[buffer.length];    for (int i = 0; i < buffer.length; i++) {        int plain = buffer[i] & 0xff;        int cipher = plain ^ r >> 8;        ciphertextBytes[i] = (byte) cipher;        r = (cipher + r) * c1 + c2 & 0xffff;    }    return ciphertextBytes;}
public static byte[] pdfbox_f1301_0(byte[] buffer)
{    return decrypt(buffer, 55665, 4);}
public static byte[] pdfbox_f1302_0(byte[] buffer, int n)
{    return decrypt(buffer, 4330, n);}
private static byte[] pdfbox_f1303_0(byte[] ciphertextBytes, int r, int n)
{    byte[] buffer = new byte[ciphertextBytes.length];    int c1 = 52845;    int c2 = 22719;    for (int i = 0; i < ciphertextBytes.length; i++) {        int cipher = ciphertextBytes[i] & 0xff;        int plain = cipher ^ r >> 8;        buffer[i] = (byte) plain;        r = (cipher + r) * c1 + c2 & 0xffff;    }    byte[] plaintextBytes = new byte[ciphertextBytes.length - n];    System.arraycopy(buffer, n, plaintextBytes, 0, plaintextBytes.length);    return plaintextBytes;}
public int pdfbox_f1304_0()
{    return gid;}
public List<Object> pdfbox_f1305_0()
{    return type2sequence;}
private void pdfbox_f1306_0(List<Object> sequence)
{    type1Sequence = new ArrayList<>();    pathCount = 0;    CharStringHandler handler = Type2CharString.this::handleCommand;    handler.handleSequence(sequence);}
private List<Number> pdfbox_f1307_0(List<Number> numbers, CharStringCommand command)
{    commandCount++;    String name = CharStringCommand.TYPE2_VOCABULARY.get(command.getKey());    if (name == null) {        addCommand(numbers, command);        return Collections.emptyList();    }    switch(name) {        case "hstem":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, true);            break;        case "vstem":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, false);            break;        case "vmoveto":            numbers = clearStack(numbers, numbers.size() > 1);            markPath();            addCommand(numbers, command);            break;        case "rlineto":            addCommandList(split(numbers, 2), command);            break;        case "hlineto":            drawAlternatingLine(numbers, true);            break;        case "vlineto":            drawAlternatingLine(numbers, false);            break;        case "rrcurveto":            addCommandList(split(numbers, 6), command);            break;        case "endchar":            numbers = clearStack(numbers, numbers.size() == 5 || numbers.size() == 1);            closePath();            if (numbers.size() == 4) {                                numbers.add(0, 0);                addCommand(numbers, new CharStringCommand(12, 6));            } else {                addCommand(numbers, command);            }            break;        case "rmoveto":            numbers = clearStack(numbers, numbers.size() > 2);            markPath();            addCommand(numbers, command);            break;        case "hmoveto":            numbers = clearStack(numbers, numbers.size() > 1);            markPath();            addCommand(numbers, command);            break;        case "vhcurveto":            drawAlternatingCurve(numbers, false);            break;        case "hvcurveto":            drawAlternatingCurve(numbers, true);            break;        case "hflex":            {                List<Number> first = Arrays.asList(numbers.get(0), 0, numbers.get(1), numbers.get(2), numbers.get(3), 0);                List<Number> second = Arrays.asList(numbers.get(4), 0, numbers.get(5), -(numbers.get(2).floatValue()), numbers.get(6), 0);                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "flex":            {                List<Number> first = numbers.subList(0, 6);                List<Number> second = numbers.subList(6, 12);                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "hflex1":            {                List<Number> first = Arrays.asList(numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), numbers.get(4), 0);                List<Number> second = Arrays.asList(numbers.get(5), 0, numbers.get(6), numbers.get(7), numbers.get(8), 0);                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "flex1":            {                int dx = 0;                int dy = 0;                for (int i = 0; i < 5; i++) {                    dx += numbers.get(i * 2).intValue();                    dy += numbers.get(i * 2 + 1).intValue();                }                List<Number> first = numbers.subList(0, 6);                List<Number> second = Arrays.asList(numbers.get(6), numbers.get(7), numbers.get(8), numbers.get(9), (Math.abs(dx) > Math.abs(dy) ? numbers.get(10) : -dx), (Math.abs(dx) > Math.abs(dy) ? -dy : numbers.get(10)));                addCommandList(Arrays.asList(first, second), new CharStringCommand(8));                break;            }        case "hstemhm":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, true);            break;        case "hintmask":        case "cntrmask":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            if (numbers.size() > 0) {                expandStemHints(numbers, false);            }            break;        case "vstemhm":            numbers = clearStack(numbers, numbers.size() % 2 != 0);            expandStemHints(numbers, false);            break;        case "rcurveline":            if (numbers.size() >= 2) {                addCommandList(split(numbers.subList(0, numbers.size() - 2), 6), new CharStringCommand(8));                addCommand(numbers.subList(numbers.size() - 2, numbers.size()), new CharStringCommand(5));            }            break;        case "rlinecurve":            if (numbers.size() >= 6) {                addCommandList(split(numbers.subList(0, numbers.size() - 6), 2), new CharStringCommand(5));                addCommand(numbers.subList(numbers.size() - 6, numbers.size()), new CharStringCommand(8));            }            break;        case "vvcurveto":            drawCurve(numbers, false);            break;        case "hhcurveto":            drawCurve(numbers, true);            break;        default:            addCommand(numbers, command);            break;    }    return Collections.emptyList();}
private List<Number> pdfbox_f1308_0(List<Number> numbers, boolean flag)
{    if (type1Sequence.isEmpty()) {        if (flag) {            addCommand(Arrays.asList((Number) 0f, numbers.get(0).floatValue() + nominalWidthX), new CharStringCommand(13));            numbers = numbers.subList(1, numbers.size());        } else {            addCommand(Arrays.asList((Number) 0f, defWidthX), new CharStringCommand(13));        }    }    return numbers;}
private void pdfbox_f1309_0(List<Number> numbers, boolean horizontal)
{}
private void pdfbox_f1310_0()
{    if (pathCount > 0) {        closePath();    }    pathCount++;}
private void pdfbox_f1311_0()
{    CharStringCommand command = pathCount > 0 ? (CharStringCommand) type1Sequence.get(type1Sequence.size() - 1) : null;    CharStringCommand closepathCommand = new CharStringCommand(9);    if (command != null && !closepathCommand.equals(command)) {        addCommand(Collections.<Number>emptyList(), closepathCommand);    }}
private void pdfbox_f1312_0(List<Number> numbers, boolean horizontal)
{    while (numbers.size() > 0) {        addCommand(numbers.subList(0, 1), new CharStringCommand(horizontal ? 6 : 7));        numbers = numbers.subList(1, numbers.size());        horizontal = !horizontal;    }}
private void pdfbox_f1313_0(List<Number> numbers, boolean horizontal)
{    while (numbers.size() >= 4) {        boolean last = numbers.size() == 5;        if (horizontal) {            addCommand(Arrays.asList(numbers.get(0), 0, numbers.get(1), numbers.get(2), last ? numbers.get(4) : 0, numbers.get(3)), new CharStringCommand(8));        } else {            addCommand(Arrays.asList(0, numbers.get(0), numbers.get(1), numbers.get(2), numbers.get(3), last ? numbers.get(4) : 0), new CharStringCommand(8));        }        numbers = numbers.subList(last ? 5 : 4, numbers.size());        horizontal = !horizontal;    }}
private void pdfbox_f1314_0(List<Number> numbers, boolean horizontal)
{    while (numbers.size() >= 4) {        boolean first = numbers.size() % 4 == 1;        if (horizontal) {            addCommand(Arrays.asList(numbers.get(first ? 1 : 0), first ? numbers.get(0) : 0, numbers.get(first ? 2 : 1), numbers.get(first ? 3 : 2), numbers.get(first ? 4 : 3), 0), new CharStringCommand(8));        } else {            addCommand(Arrays.asList(first ? numbers.get(0) : 0, numbers.get(first ? 1 : 0), numbers.get(first ? 2 : 1), numbers.get(first ? 3 : 2), 0, numbers.get(first ? 4 : 3)), new CharStringCommand(8));        }        numbers = numbers.subList(first ? 5 : 4, numbers.size());    }}
private void pdfbox_f1315_0(List<List<Number>> numbers, CharStringCommand command)
{    numbers.forEach(ns -> addCommand(ns, command));}
private void pdfbox_f1316_0(List<Number> numbers, CharStringCommand command)
{    type1Sequence.addAll(numbers);    type1Sequence.add(command);}
private static List<List<E>> pdfbox_f1317_0(List<E> list, int size)
{    List<List<E>> result = new ArrayList<>();    for (int i = 0; i < list.size() / size; i++) {        result.add(list.subList(i * size, (i + 1) * size));    }    return result;}
public List<Object> pdfbox_f1318_0(byte[] bytes, byte[][] globalSubrIndex, byte[][] localSubrIndex) throws IOException
{    return parse(bytes, globalSubrIndex, localSubrIndex, true);}
private List<Object> pdfbox_f1319_0(byte[] bytes, byte[][] globalSubrIndex, byte[][] localSubrIndex, boolean init) throws IOException
{    if (init) {        hstemCount = 0;        vstemCount = 0;        sequence = new ArrayList<>();    }    DataInput input = new DataInput(bytes);    boolean localSubroutineIndexProvided = localSubrIndex != null && localSubrIndex.length > 0;    boolean globalSubroutineIndexProvided = globalSubrIndex != null && globalSubrIndex.length > 0;    while (input.hasRemaining()) {        int b0 = input.readUnsignedByte();        if (b0 == 10 && localSubroutineIndexProvided) {                        Integer operand = (Integer) sequence.remove(sequence.size() - 1);                        int bias = 0;            int nSubrs = localSubrIndex.length;            if (nSubrs < 1240) {                bias = 107;            } else if (nSubrs < 33900) {                bias = 1131;            } else {                bias = 32768;            }            int subrNumber = bias + operand;            if (subrNumber < localSubrIndex.length) {                byte[] subrBytes = localSubrIndex[subrNumber];                parse(subrBytes, globalSubrIndex, localSubrIndex, false);                Object lastItem = sequence.get(sequence.size() - 1);                if (lastItem instanceof CharStringCommand && ((CharStringCommand) lastItem).getKey().getValue()[0] == 11) {                                        sequence.remove(sequence.size() - 1);                }            }        } else if (b0 == 29 && globalSubroutineIndexProvided) {                        Integer operand = (Integer) sequence.remove(sequence.size() - 1);                        int bias;            int nSubrs = globalSubrIndex.length;            if (nSubrs < 1240) {                bias = 107;            } else if (nSubrs < 33900) {                bias = 1131;            } else {                bias = 32768;            }            int subrNumber = bias + operand;            if (subrNumber < globalSubrIndex.length) {                byte[] subrBytes = globalSubrIndex[subrNumber];                parse(subrBytes, globalSubrIndex, localSubrIndex, false);                Object lastItem = sequence.get(sequence.size() - 1);                if (lastItem instanceof CharStringCommand && ((CharStringCommand) lastItem).getKey().getValue()[0] == 11) {                                        sequence.remove(sequence.size() - 1);                }            }        } else if (b0 >= 0 && b0 <= 27) {            sequence.add(readCommand(b0, input));        } else if (b0 == 28) {            sequence.add(readNumber(b0, input));        } else if (b0 >= 29 && b0 <= 31) {            sequence.add(readCommand(b0, input));        } else if (b0 >= 32 && b0 <= 255) {            sequence.add(readNumber(b0, input));        } else {            throw new IllegalArgumentException();        }    }    return sequence;}
private CharStringCommand pdfbox_f1320_0(int b0, DataInput input) throws IOException
{    if (b0 == 1 || b0 == 18) {        hstemCount += peekNumbers().size() / 2;    } else if (b0 == 3 || b0 == 19 || b0 == 20 || b0 == 23) {        vstemCount += peekNumbers().size() / 2;    }    if (b0 == 12) {        int b1 = input.readUnsignedByte();        return new CharStringCommand(b0, b1);    } else if (b0 == 19 || b0 == 20) {        int[] value = new int[1 + getMaskLength()];        value[0] = b0;        for (int i = 1; i < value.length; i++) {            value[i] = input.readUnsignedByte();        }        return new CharStringCommand(value);    }    return new CharStringCommand(b0);}
private Number pdfbox_f1321_0(int b0, DataInput input) throws IOException
{    if (b0 == 28) {        return (int) input.readShort();    } else if (b0 >= 32 && b0 <= 246) {        return b0 - 139;    } else if (b0 >= 247 && b0 <= 250) {        int b1 = input.readUnsignedByte();        return (b0 - 247) * 256 + b1 + 108;    } else if (b0 >= 251 && b0 <= 254) {        int b1 = input.readUnsignedByte();        return -(b0 - 251) * 256 - b1 - 108;    } else if (b0 == 255) {        short value = input.readShort();                double fraction = input.readUnsignedShort() / 65535d;        return value + fraction;    } else {        throw new IllegalArgumentException();    }}
private int pdfbox_f1322_0()
{    int hintCount = hstemCount + vstemCount;    int length = hintCount / 8;    if (hintCount % 8 > 0) {        length++;    }    return length;}
private List<Number> pdfbox_f1323_0()
{    List<Number> numbers = new ArrayList<>();    for (int i = sequence.size() - 1; i > -1; i--) {        Object object = sequence.get(i);        if (!(object instanceof Number)) {            return numbers;        }        numbers.add(0, (Number) object);    }    return numbers;}
public int pdfbox_f1324_0(char ch)
{    if (from <= ch && ch <= to) {        return cid + (ch - from);    }    return -1;}
public int pdfbox_f1325_0(int code)
{    if (cid <= code && code <= cid + (to - from)) {        return from + (code - cid);    }    return -1;}
public boolean pdfbox_f1326_0(char newFrom, char newTo, int newCid)
{    if ((newFrom == to + 1) && (newCid == cid + to - from + 1)) {        to = newTo;        return true;    }    return false;}
public boolean pdfbox_f1327_0()
{    return !codeToCid.isEmpty() || !codeToCidRanges.isEmpty();}
public boolean pdfbox_f1328_0()
{    return !charToUnicode.isEmpty();}
public String pdfbox_f1329_0(int code)
{    return charToUnicode.get(code);}
public int pdfbox_f1330_1(InputStream in) throws IOException
{    byte[] bytes = new byte[maxCodeLength];    in.read(bytes, 0, minCodeLength);    for (int i = minCodeLength - 1; i < maxCodeLength; i++) {        final int byteCount = i + 1;        for (CodespaceRange range : codespaceRanges) {            if (range.isFullMatch(bytes, byteCount)) {                return toInt(bytes, byteCount);            }        }        if (byteCount < maxCodeLength) {            bytes[byteCount] = (byte) in.read();        }    }    String seq = "";    for (int i = 0; i < maxCodeLength; ++i) {        seq += String.format("0x%02X (%04o) ", bytes[i], bytes[i]);    }        return 0;}
 static int pdfbox_f1331_0(byte[] data, int dataLen)
{    int code = 0;    for (int i = 0; i < dataLen; ++i) {        code <<= 8;        code |= (data[i] & 0xFF);    }    return code;}
public int pdfbox_f1332_0(int code)
{    Integer cid = codeToCid.get(code);    if (cid != null) {        return cid;    }    for (CIDRange range : codeToCidRanges) {        int ch = range.map((char) code);        if (ch != -1) {            return ch;        }    }    return 0;}
private int pdfbox_f1333_0(byte[] data, int offset, int length)
{    int code = 0;    for (int i = 0; i < length; i++) {        code <<= 8;        code |= (data[offset + i] + 256) % 256;    }    return code;}
 void pdfbox_f1334_0(byte[] codes, String unicode)
{    int code = getCodeFromArray(codes, 0, codes.length);    charToUnicode.put(code, unicode);        if (SPACE.equals(unicode)) {        spaceMapping = code;    }}
 void pdfbox_f1335_0(int code, int cid)
{    codeToCid.put(cid, code);}
 void pdfbox_f1336_0(char from, char to, int cid)
{    CIDRange lastRange = null;    if (!codeToCidRanges.isEmpty()) {        lastRange = codeToCidRanges.get(codeToCidRanges.size() - 1);    }    if (lastRange == null || !lastRange.extend(from, to, cid)) {        codeToCidRanges.add(new CIDRange(from, to, cid));    }}
 void pdfbox_f1337_0(CodespaceRange range)
{    codespaceRanges.add(range);    maxCodeLength = Math.max(maxCodeLength, range.getCodeLength());    minCodeLength = Math.min(minCodeLength, range.getCodeLength());}
 void pdfbox_f1338_0(CMap cmap)
{    cmap.codespaceRanges.forEach(this::addCodespaceRange);    charToUnicode.putAll(cmap.charToUnicode);    codeToCid.putAll(cmap.codeToCid);    codeToCidRanges.addAll(cmap.codeToCidRanges);}
public int pdfbox_f1339_0()
{    return wmode;}
public void pdfbox_f1340_0(int newWMode)
{    wmode = newWMode;}
public String pdfbox_f1341_0()
{    return cmapName;}
public void pdfbox_f1342_0(String name)
{    cmapName = name;}
public String pdfbox_f1343_0()
{    return cmapVersion;}
public void pdfbox_f1344_0(String version)
{    cmapVersion = version;}
public int pdfbox_f1345_0()
{    return cmapType;}
public void pdfbox_f1346_0(int type)
{    cmapType = type;}
public String pdfbox_f1347_0()
{    return registry;}
public void pdfbox_f1348_0(String newRegistry)
{    registry = newRegistry;}
public String pdfbox_f1349_0()
{    return ordering;}
public void pdfbox_f1350_0(String newOrdering)
{    ordering = newOrdering;}
public int pdfbox_f1351_0()
{    return supplement;}
public void pdfbox_f1352_0(int newSupplement)
{    supplement = newSupplement;}
public int pdfbox_f1353_0()
{    return spaceMapping;}
public String pdfbox_f1354_0()
{    return cmapName;}
public CMap pdfbox_f1355_0(File file) throws IOException
{    try (FileInputStream input = new FileInputStream(file)) {        return parse(input);    }}
public CMap pdfbox_f1356_0(String name) throws IOException
{    try (InputStream input = getExternalCMap(name)) {        return parse(input);    }}
public CMap pdfbox_f1357_0(InputStream input) throws IOException
{    PushbackInputStream cmapStream = new PushbackInputStream(input);    CMap result = new CMap();    Object previousToken = null;    Object token;    while ((token = parseNextToken(cmapStream)) != null) {        if (token instanceof Operator) {            Operator op = (Operator) token;            if (op.op.equals("endcmap")) {                                break;            }            switch(op.op) {                case "usecmap":                    parseUsecmap((LiteralName) previousToken, result);                    break;                case "begincodespacerange":                    parseBegincodespacerange((Number) previousToken, cmapStream, result);                    break;                case "beginbfchar":                    parseBeginbfchar((Number) previousToken, cmapStream, result);                    break;                case "beginbfrange":                    parseBeginbfrange((Number) previousToken, cmapStream, result);                    break;                case "begincidchar":                    parseBegincidchar((Number) previousToken, cmapStream, result);                    break;                case "begincidrange":                    parseBegincidrange((Integer) previousToken, cmapStream, result);                    break;                default:                    break;            }        } else if (token instanceof LiteralName) {            parseLiteralName((LiteralName) token, cmapStream, result);        }        previousToken = token;    }    return result;}
private void pdfbox_f1358_0(LiteralName useCmapName, CMap result) throws IOException
{    InputStream useStream = getExternalCMap(useCmapName.name);    CMap useCMap = parse(useStream);    result.useCmap(useCMap);}
private void pdfbox_f1359_0(LiteralName literal, PushbackInputStream cmapStream, CMap result) throws IOException
{    switch(literal.name) {        case "WMode":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Integer) {                    result.setWMode((Integer) next);                }                break;            }        case "CMapName":            {                Object next = parseNextToken(cmapStream);                if (next instanceof LiteralName) {                    result.setName(((LiteralName) next).name);                }                break;            }        case "CMapVersion":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Number) {                    result.setVersion(next.toString());                } else if (next instanceof String) {                    result.setVersion((String) next);                }                break;            }        case "CMapType":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Integer) {                    result.setType((Integer) next);                }                break;            }        case "Registry":            {                Object next = parseNextToken(cmapStream);                if (next instanceof String) {                    result.setRegistry((String) next);                }                break;            }        case "Ordering":            {                Object next = parseNextToken(cmapStream);                if (next instanceof String) {                    result.setOrdering((String) next);                }                break;            }        case "Supplement":            {                Object next = parseNextToken(cmapStream);                if (next instanceof Integer) {                    result.setSupplement((Integer) next);                }                break;            }        default:            break;    }}
private void pdfbox_f1360_0(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endcodespacerange")) {                throw new IOException("Error : ~codespacerange contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] startRange = (byte[]) nextToken;        byte[] endRange = (byte[]) parseNextToken(cmapStream);        CodespaceRange range = new CodespaceRange();        range.setStart(startRange);        range.setEnd(endRange);        result.addCodespaceRange(range);    }}
private void pdfbox_f1361_0(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endbfchar")) {                throw new IOException("Error : ~bfchar contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] inputCode = (byte[]) nextToken;        nextToken = parseNextToken(cmapStream);        if (nextToken instanceof byte[]) {            byte[] bytes = (byte[]) nextToken;            String value = createStringFromBytes(bytes);            result.addCharMapping(inputCode, value);        } else if (nextToken instanceof LiteralName) {            result.addCharMapping(inputCode, ((LiteralName) nextToken).name);        } else {            throw new IOException("Error parsing CMap beginbfchar, expected{COSString " + "or COSName} and not " + nextToken);        }    }}
private void pdfbox_f1362_0(int numberOfLines, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int n = 0; n < numberOfLines; n++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endcidrange")) {                throw new IOException("Error : ~cidrange contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] startCode = (byte[]) nextToken;        int start = createIntFromBytes(startCode);        byte[] endCode = (byte[]) parseNextToken(cmapStream);        int end = createIntFromBytes(endCode);        int mappedCode = (Integer) parseNextToken(cmapStream);        if (startCode.length <= 2 && endCode.length <= 2) {                        if (end == start) {                result.addCIDMapping(mappedCode, start);            } else {                result.addCIDRange((char) start, (char) end, mappedCode);            }        } else {                        int endOfMappings = mappedCode + end - start;            while (mappedCode <= endOfMappings) {                int mappedCID = createIntFromBytes(startCode);                result.addCIDMapping(mappedCode++, mappedCID);                increment(startCode);            }        }    }}
private void pdfbox_f1363_0(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endcidchar")) {                throw new IOException("Error : ~cidchar contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] inputCode = (byte[]) nextToken;        int mappedCode = (Integer) parseNextToken(cmapStream);        int mappedCID = createIntFromBytes(inputCode);        result.addCIDMapping(mappedCode, mappedCID);    }}
private void pdfbox_f1364_0(Number cosCount, PushbackInputStream cmapStream, CMap result) throws IOException
{    for (int j = 0; j < cosCount.intValue(); j++) {        Object nextToken = parseNextToken(cmapStream);        if (nextToken instanceof Operator) {            if (!((Operator) nextToken).op.equals("endbfrange")) {                throw new IOException("Error : ~bfrange contains an unexpected operator : " + ((Operator) nextToken).op);            }            break;        }        byte[] startCode = (byte[]) nextToken;        byte[] endCode = (byte[]) parseNextToken(cmapStream);        int start = CMap.toInt(startCode, startCode.length);        int end = CMap.toInt(endCode, endCode.length);                if (end < start) {                        break;        }        nextToken = parseNextToken(cmapStream);        if (nextToken instanceof List<?>) {            List<byte[]> array = (List<byte[]>) nextToken;                        if (!array.isEmpty() && array.size() >= end - start) {                addMappingFrombfrange(result, startCode, array);            }        } else         if (nextToken instanceof byte[]) {            byte[] tokenBytes = (byte[]) nextToken;                        if (tokenBytes.length > 0) {                                int values = Math.min(end - start, 255 - (tokenBytes[tokenBytes.length - 1] & 0xFF)) + 1;                addMappingFrombfrange(result, startCode, values, tokenBytes);            }        }    }}
private void pdfbox_f1365_0(CMap cmap, byte[] startCode, List<byte[]> tokenBytesList)
{    for (byte[] tokenBytes : tokenBytesList) {        String value = createStringFromBytes(tokenBytes);        cmap.addCharMapping(startCode, value);        increment(startCode);    }}
private void pdfbox_f1366_0(CMap cmap, byte[] startCode, int values, byte[] tokenBytes)
{    for (int i = 0; i < values; i++) {        String value = createStringFromBytes(tokenBytes);        cmap.addCharMapping(startCode, value);        increment(startCode);        increment(tokenBytes);    }}
protected InputStream pdfbox_f1367_0(String name) throws IOException
{    InputStream is = getClass().getResourceAsStream(name);    if (is == null) {        throw new IOException("Error: Could not find referenced cmap stream " + name);    }    return is;}
private Object pdfbox_f1368_0(PushbackInputStream is) throws IOException
{    Object retval = null;    int nextByte = is.read();        while (nextByte == 0x09 || nextByte == 0x20 || nextByte == 0x0D || nextByte == 0x0A) {        nextByte = is.read();    }    switch(nextByte) {        case '%':            {                                                StringBuilder buffer = new StringBuilder();                buffer.append((char) nextByte);                readUntilEndOfLine(is, buffer);                retval = buffer.toString();                break;            }        case '(':            {                StringBuilder buffer = new StringBuilder();                int stringByte = is.read();                while (stringByte != -1 && stringByte != ')') {                    buffer.append((char) stringByte);                    stringByte = is.read();                }                retval = buffer.toString();                break;            }        case '>':            {                int secondCloseBrace = is.read();                if (secondCloseBrace == '>') {                    retval = MARK_END_OF_DICTIONARY;                } else {                    throw new IOException("Error: expected the end of a dictionary.");                }                break;            }        case ']':            {                retval = MARK_END_OF_ARRAY;                break;            }        case '[':            {                List<Object> list = new ArrayList<>();                Object nextToken = parseNextToken(is);                while (nextToken != null && !MARK_END_OF_ARRAY.equals(nextToken)) {                    list.add(nextToken);                    nextToken = parseNextToken(is);                }                retval = list;                break;            }        case '<':            {                int theNextByte = is.read();                if (theNextByte == '<') {                    Map<String, Object> result = new HashMap<>();                                        Object key = parseNextToken(is);                    while (key instanceof LiteralName && !MARK_END_OF_DICTIONARY.equals(key)) {                        Object value = parseNextToken(is);                        result.put(((LiteralName) key).name, value);                        key = parseNextToken(is);                    }                    retval = result;                } else {                                        int multiplyer = 16;                    int bufferIndex = -1;                    while (theNextByte != -1 && theNextByte != '>') {                        int intValue = 0;                        if (theNextByte >= '0' && theNextByte <= '9') {                            intValue = theNextByte - '0';                        } else if (theNextByte >= 'A' && theNextByte <= 'F') {                            intValue = 10 + theNextByte - 'A';                        } else if (theNextByte >= 'a' && theNextByte <= 'f') {                            intValue = 10 + theNextByte - 'a';                        } else                         if (isWhitespaceOrEOF(theNextByte)) {                                                        theNextByte = is.read();                            continue;                        } else {                            throw new IOException("Error: expected hex character and not " + (char) theNextByte + ":" + theNextByte);                        }                        intValue *= multiplyer;                        if (multiplyer == 16) {                            bufferIndex++;                            tokenParserByteBuffer[bufferIndex] = 0;                            multiplyer = 1;                        } else {                            multiplyer = 16;                        }                        tokenParserByteBuffer[bufferIndex] += intValue;                        theNextByte = is.read();                    }                    byte[] finalResult = new byte[bufferIndex + 1];                    System.arraycopy(tokenParserByteBuffer, 0, finalResult, 0, bufferIndex + 1);                    retval = finalResult;                }                break;            }        case '/':            {                StringBuilder buffer = new StringBuilder();                int stringByte = is.read();                while (!isWhitespaceOrEOF(stringByte) && !isDelimiter(stringByte)) {                    buffer.append((char) stringByte);                    stringByte = is.read();                }                if (isDelimiter(stringByte)) {                    is.unread(stringByte);                }                retval = new LiteralName(buffer.toString());                break;            }        case -1:            {                                break;            }        case '0':        case '1':        case '2':        case '3':        case '4':        case '5':        case '6':        case '7':        case '8':        case '9':            {                StringBuilder buffer = new StringBuilder();                buffer.append((char) nextByte);                nextByte = is.read();                while (!isWhitespaceOrEOF(nextByte) && (Character.isDigit((char) nextByte) || nextByte == '.')) {                    buffer.append((char) nextByte);                    nextByte = is.read();                }                is.unread(nextByte);                String value = buffer.toString();                if (value.indexOf('.') >= 0) {                    retval = Double.valueOf(value);                } else {                    retval = Integer.valueOf(value);                }                break;            }        default:            {                StringBuilder buffer = new StringBuilder();                buffer.append((char) nextByte);                nextByte = is.read();                                while (!isWhitespaceOrEOF(nextByte) && !isDelimiter(nextByte) && !Character.isDigit(nextByte)) {                    buffer.append((char) nextByte);                    nextByte = is.read();                }                if (isDelimiter(nextByte) || Character.isDigit(nextByte)) {                    is.unread(nextByte);                }                retval = new Operator(buffer.toString());                break;            }    }    return retval;}
private void pdfbox_f1369_0(InputStream is, StringBuilder buf) throws IOException
{    int nextByte = is.read();    while (nextByte != -1 && nextByte != 0x0D && nextByte != 0x0A) {        buf.append((char) nextByte);        nextByte = is.read();    }}
private boolean pdfbox_f1370_0(int aByte)
{    return aByte == -1 || aByte == 0x20 || aByte == 0x0D || aByte == 0x0A;}
private boolean pdfbox_f1371_0(int aByte)
{    switch(aByte) {        case '(':        case ')':        case '<':        case '>':        case '[':        case ']':        case '{':        case '}':        case '/':        case '%':            return true;        default:            return false;    }}
private void pdfbox_f1372_0(byte[] data)
{    increment(data, data.length - 1);}
private void pdfbox_f1373_0(byte[] data, int position)
{    if (position > 0 && (data[position] & 0xFF) == 255) {        data[position] = 0;        increment(data, position - 1);    } else {        data[position] = (byte) (data[position] + 1);    }}
private int pdfbox_f1374_0(byte[] bytes)
{    int intValue = bytes[0] & 0xFF;    if (bytes.length == 2) {        intValue <<= 8;        intValue += bytes[1] & 0xFF;    }    return intValue;}
private String pdfbox_f1375_0(byte[] bytes)
{    return new String(bytes, bytes.length == 1 ? Charsets.ISO_8859_1 : Charsets.UTF_16BE);}
public int pdfbox_f1376_0()
{    return codeLength;}
public byte[] pdfbox_f1377_0()
{    return end;}
 void pdfbox_f1378_0(byte[] endBytes)
{    end = endBytes;    endInt = toInt(endBytes, endBytes.length);}
public byte[] pdfbox_f1379_0()
{    return start;}
 void pdfbox_f1380_0(byte[] startBytes)
{    start = startBytes;    codeLength = start.length;    startInt = toInt(startBytes, startBytes.length);}
public boolean pdfbox_f1381_0(byte[] code)
{    return isFullMatch(code, code.length);}
public boolean pdfbox_f1382_0(byte[] code, int codeLen)
{        if (codeLen == codeLength) {        int value = toInt(code, codeLen);        if (value >= startInt && value <= endInt) {            return true;        }    }    return false;}
protected void pdfbox_f1383_0(int code, String name)
{    codeToName.put(code, name);    nameToCode.put(name, code);}
public Integer pdfbox_f1384_0(String name)
{    return nameToCode.get(name);}
public String pdfbox_f1385_0(int code)
{    String name = codeToName.get(code);    if (name != null) {        return name;    }    return ".notdef";}
public Map<Integer, String> pdfbox_f1386_0()
{    return Collections.unmodifiableMap(codeToName);}
private void pdfbox_f1387_0(final byte[] pfb) throws IOException
{    ByteArrayInputStream in = new ByteArrayInputStream(pfb);    pfbdata = new byte[pfb.length - PFB_HEADER_LENGTH];    lengths = new int[PFB_RECORDS.length];    int pointer = 0;    for (int records = 0; records < PFB_RECORDS.length; records++) {        if (in.read() != START_MARKER) {            throw new IOException("Start marker missing");        }        if (in.read() != PFB_RECORDS[records]) {            throw new IOException("Incorrect record type");        }        int size = in.read();        size += in.read() << 8;        size += in.read() << 16;        size += in.read() << 24;        lengths[records] = size;        if (pointer >= pfbdata.length) {            throw new EOFException("attempted to read past EOF");        }        int got = in.read(pfbdata, pointer, size);        if (got < 0) {            throw new EOFException();        }        pointer += got;    }}
private byte[] pdfbox_f1388_0(final InputStream in) throws IOException
{        ByteArrayOutputStream out = new ByteArrayOutputStream();    byte[] tmpbuf = new byte[BUFFER_SIZE];    int amountRead = -1;    while ((amountRead = in.read(tmpbuf)) != -1) {        out.write(tmpbuf, 0, amountRead);    }    return out.toByteArray();}
public int[] pdfbox_f1389_0()
{    return lengths;}
public byte[] pdfbox_f1390_0()
{    return pfbdata;}
public InputStream pdfbox_f1391_0()
{    return new ByteArrayInputStream(pfbdata);}
public int pdfbox_f1392_0()
{    return pfbdata.length;}
public byte[] pdfbox_f1393_0()
{    return Arrays.copyOfRange(pfbdata, 0, lengths[0]);}
public byte[] pdfbox_f1394_0()
{    return Arrays.copyOfRange(pfbdata, lengths[0], lengths[0] + lengths[1]);}
public final int pdfbox_f1395_0() throws IOException
{    if (bufpos >= bufend && fillBuffer() < 0) {        return -1;    }    if (bufend == 0) {        return -1;    }        return (buffer[bufpos++] + 256) & 0xFF;}
private int pdfbox_f1396_0() throws IOException
{    int n = super.read(buffer, 0, BUFSIZE);    if (n >= 0) {        realpos += n;        bufend = n;        bufpos = 0;    }    return n;}
private void pdfbox_f1397_0() throws IOException
{    bufend = 0;    bufpos = 0;    realpos = super.getFilePointer();}
public int pdfbox_f1398_0(byte[] b, int off, int len) throws IOException
{    int leftover = bufend - bufpos;    if (len <= leftover) {        System.arraycopy(buffer, bufpos, b, off, len);        bufpos += len;        return len;    }    System.arraycopy(buffer, bufpos, b, off, leftover);    bufpos += leftover;    if (fillBuffer() > 0) {        int bytesRead = read(b, off + leftover, len - leftover);        if (bytesRead > 0) {            leftover += bytesRead;        }    }    return leftover > 0 ? leftover : -1;}
public long pdfbox_f1399_0() throws IOException
{    return realpos - bufend + bufpos;}
public void pdfbox_f1400_0(long pos) throws IOException
{    int n = (int) (realpos - pos);    if (n >= 0 && n <= bufend) {        bufpos = bufend - n;    } else {        super.seek(pos);        invalidate();    }}
 void pdfbox_f1401_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    byte[] bytes = data.read((int) getLength());    CFFParser parser = new CFFParser();    cffFont = parser.parse(bytes, new CFFBytesource(font)).get(0);    initialized = true;}
public CFFFont pdfbox_f1402_0()
{    return cffFont;}
public byte[] pdfbox_f1403_0() throws IOException
{    return ttf.getTableBytes(ttf.getTableMap().get(CFFTable.TAG));}
 void pdfbox_f1404_0(TTFDataStream data) throws IOException
{    platformId = data.readUnsignedShort();    platformEncodingId = data.readUnsignedShort();    subTableOffset = data.readUnsignedInt();}
 void pdfbox_f1405_0(CmapTable cmap, int numGlyphs, TTFDataStream data) throws IOException
{    data.seek(cmap.getOffset() + subTableOffset);    int subtableFormat = data.readUnsignedShort();    long length;    long version;    if (subtableFormat < 8) {        length = data.readUnsignedShort();        version = data.readUnsignedShort();    } else {                data.readUnsignedShort();        length = data.readUnsignedInt();        version = data.readUnsignedInt();    }    switch(subtableFormat) {        case 0:            processSubtype0(data);            break;        case 2:            processSubtype2(data, numGlyphs);            break;        case 4:            processSubtype4(data, numGlyphs);            break;        case 6:            processSubtype6(data, numGlyphs);            break;        case 8:            processSubtype8(data, numGlyphs);            break;        case 10:            processSubtype10(data, numGlyphs);            break;        case 12:            processSubtype12(data, numGlyphs);            break;        case 13:            processSubtype13(data, numGlyphs);            break;        case 14:            processSubtype14(data, numGlyphs);            break;        default:            throw new IOException("Unknown cmap format:" + subtableFormat);    }}
 void pdfbox_f1406_1(TTFDataStream data, int numGlyphs) throws IOException
{        int[] is32 = data.readUnsignedByteArray(8192);    long nbGroups = data.readUnsignedInt();        if (nbGroups > 65536) {        throw new IOException("CMap ( Subtype8 ) is invalid");    }    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }        for (long i = 0; i < nbGroups; ++i) {        long firstCode = data.readUnsignedInt();        long endCode = data.readUnsignedInt();        long startGlyph = data.readUnsignedInt();                if (firstCode > endCode || 0 > firstCode) {            throw new IOException("Range invalid");        }        for (long j = firstCode; j <= endCode; ++j) {                        if (j > Integer.MAX_VALUE) {                throw new IOException("[Sub Format 8] Invalid character code " + j);            }            if ((int) j / 8 >= is32.length) {                throw new IOException("[Sub Format 8] Invalid character code " + j);            }            int currentCharCode;            if ((is32[(int) j / 8] & (1 << ((int) j % 8))) == 0) {                currentCharCode = (int) j;            } else {                                                long lead = LEAD_OFFSET + (j >> 10);                long trail = 0xDC00 + (j & 0x3FF);                long codepoint = (lead << 10) + trail + SURROGATE_OFFSET;                if (codepoint > Integer.MAX_VALUE) {                    throw new IOException("[Sub Format 8] Invalid character code " + codepoint);                }                currentCharCode = (int) codepoint;            }            long glyphIndex = startGlyph + (j - firstCode);            if (glyphIndex > numGlyphs || glyphIndex > Integer.MAX_VALUE) {                throw new IOException("CMap contains an invalid glyph index");            }            glyphIdToCharacterCode[(int) glyphIndex] = currentCharCode;            characterCodeToGlyphId.put(currentCharCode, (int) glyphIndex);        }    }}
 void pdfbox_f1407_0(TTFDataStream data, int numGlyphs) throws IOException
{    long startCode = data.readUnsignedInt();    long numChars = data.readUnsignedInt();    if (numChars > Integer.MAX_VALUE) {        throw new IOException("Invalid number of Characters");    }    if (startCode < 0 || startCode > 0x0010FFFF || (startCode + numChars) > 0x0010FFFF || ((startCode + numChars) >= 0x0000D800 && (startCode + numChars) <= 0x0000DFFF)) {        throw new IOException("Invalid Characters codes");    }}
 void pdfbox_f1408_1(TTFDataStream data, int numGlyphs) throws IOException
{    long nbGroups = data.readUnsignedInt();    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }    for (long i = 0; i < nbGroups; ++i) {        long firstCode = data.readUnsignedInt();        long endCode = data.readUnsignedInt();        long startGlyph = data.readUnsignedInt();        if (firstCode < 0 || firstCode > 0x0010FFFF || firstCode >= 0x0000D800 && firstCode <= 0x0000DFFF) {            throw new IOException("Invalid characters codes");        }        if (endCode > 0 && endCode < firstCode || endCode > 0x0010FFFF || endCode >= 0x0000D800 && endCode <= 0x0000DFFF) {            throw new IOException("Invalid characters codes");        }        for (long j = 0; j <= endCode - firstCode; ++j) {            long glyphIndex = startGlyph + j;            if (glyphIndex >= numGlyphs) {                                break;            }            if (firstCode + j > 0x10FFFF) {                            }            glyphIdToCharacterCode[(int) glyphIndex] = (int) (firstCode + j);            characterCodeToGlyphId.put((int) (firstCode + j), (int) glyphIndex);        }    }}
 void pdfbox_f1409_1(TTFDataStream data, int numGlyphs) throws IOException
{    long nbGroups = data.readUnsignedInt();    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }    for (long i = 0; i < nbGroups; ++i) {        long firstCode = data.readUnsignedInt();        long endCode = data.readUnsignedInt();        long glyphId = data.readUnsignedInt();        if (glyphId > numGlyphs) {                        break;        }        if (firstCode < 0 || firstCode > 0x0010FFFF || (firstCode >= 0x0000D800 && firstCode <= 0x0000DFFF)) {            throw new IOException("Invalid Characters codes");        }        if ((endCode > 0 && endCode < firstCode) || endCode > 0x0010FFFF || (endCode >= 0x0000D800 && endCode <= 0x0000DFFF)) {            throw new IOException("Invalid Characters codes");        }        for (long j = 0; j <= endCode - firstCode; ++j) {            if (firstCode + j > Integer.MAX_VALUE) {                throw new IOException("Character Code greater than Integer.MAX_VALUE");            }            if (firstCode + j > 0x10FFFF) {                            }            glyphIdToCharacterCode[(int) glyphId] = (int) (firstCode + j);            characterCodeToGlyphId.put((int) (firstCode + j), (int) glyphId);        }    }}
 void pdfbox_f1410_1(TTFDataStream data, int numGlyphs) throws IOException
{            }
 void pdfbox_f1411_0(TTFDataStream data, int numGlyphs) throws IOException
{    int firstCode = data.readUnsignedShort();    int entryCount = data.readUnsignedShort();        if (entryCount == 0) {        return;    }    characterCodeToGlyphId = new HashMap<>(numGlyphs);    int[] glyphIdArray = data.readUnsignedShortArray(entryCount);    int maxGlyphId = 0;    for (int i = 0; i < entryCount; i++) {        maxGlyphId = Math.max(maxGlyphId, glyphIdArray[i]);        characterCodeToGlyphId.put(firstCode + i, glyphIdArray[i]);    }    buildGlyphIdToCharacterCodeLookup(maxGlyphId);}
 void pdfbox_f1412_1(TTFDataStream data, int numGlyphs) throws IOException
{    int segCountX2 = data.readUnsignedShort();    int segCount = segCountX2 / 2;    int searchRange = data.readUnsignedShort();    int entrySelector = data.readUnsignedShort();    int rangeShift = data.readUnsignedShort();    int[] endCount = data.readUnsignedShortArray(segCount);    int reservedPad = data.readUnsignedShort();    int[] startCount = data.readUnsignedShortArray(segCount);    int[] idDelta = data.readUnsignedShortArray(segCount);    long idRangeOffsetPosition = data.getCurrentPosition();    int[] idRangeOffset = data.readUnsignedShortArray(segCount);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    int maxGlyphId = 0;    for (int i = 0; i < segCount; i++) {        int start = startCount[i];        int end = endCount[i];        int delta = idDelta[i];        int rangeOffset = idRangeOffset[i];        long segmentRangeOffset = idRangeOffsetPosition + (i * 2) + rangeOffset;        if (start != 65535 && end != 65535) {            for (int j = start; j <= end; j++) {                if (rangeOffset == 0) {                    int glyphid = (j + delta) & 0xFFFF;                    maxGlyphId = Math.max(glyphid, maxGlyphId);                    characterCodeToGlyphId.put(j, glyphid);                } else {                    long glyphOffset = segmentRangeOffset + ((j - start) * 2);                    data.seek(glyphOffset);                    int glyphIndex = data.readUnsignedShort();                    if (glyphIndex != 0) {                        glyphIndex = (glyphIndex + delta) & 0xFFFF;                        maxGlyphId = Math.max(glyphIndex, maxGlyphId);                        characterCodeToGlyphId.put(j, glyphIndex);                    }                }            }        }    }    /*         * this is the final result key=glyphId, value is character codes Create an array that contains MAX(GlyphIds)         * element, or -1         */    if (characterCodeToGlyphId.isEmpty()) {                return;    }    buildGlyphIdToCharacterCodeLookup(maxGlyphId);}
private void pdfbox_f1413_0(int maxGlyphId)
{    glyphIdToCharacterCode = newGlyphIdToCharacterCode(maxGlyphId + 1);    for (Entry<Integer, Integer> entry : characterCodeToGlyphId.entrySet()) {        if (glyphIdToCharacterCode[entry.getValue()] == -1) {                        glyphIdToCharacterCode[entry.getValue()] = entry.getKey();        } else {                        List<Integer> mappedValues = glyphIdToCharacterCodeMultiple.get(entry.getValue());            if (mappedValues == null) {                mappedValues = new ArrayList<>();                glyphIdToCharacterCodeMultiple.put(entry.getValue(), mappedValues);                mappedValues.add(glyphIdToCharacterCode[entry.getValue()]);                                glyphIdToCharacterCode[entry.getValue()] = Integer.MIN_VALUE;            }            mappedValues.add(entry.getKey());        }    }}
 void pdfbox_f1414_1(TTFDataStream data, int numGlyphs) throws IOException
{    int[] subHeaderKeys = new int[256];        int maxSubHeaderIndex = 0;    for (int i = 0; i < 256; i++) {        subHeaderKeys[i] = data.readUnsignedShort();        maxSubHeaderIndex = Math.max(maxSubHeaderIndex, subHeaderKeys[i] / 8);    }        SubHeader[] subHeaders = new SubHeader[maxSubHeaderIndex + 1];    for (int i = 0; i <= maxSubHeaderIndex; ++i) {        int firstCode = data.readUnsignedShort();        int entryCount = data.readUnsignedShort();        short idDelta = data.readSignedShort();        int idRangeOffset = data.readUnsignedShort() - (maxSubHeaderIndex + 1 - i - 1) * 8 - 2;        subHeaders[i] = new SubHeader(firstCode, entryCount, idDelta, idRangeOffset);    }    long startGlyphIndexOffset = data.getCurrentPosition();    glyphIdToCharacterCode = newGlyphIdToCharacterCode(numGlyphs);    characterCodeToGlyphId = new HashMap<>(numGlyphs);    if (numGlyphs == 0) {                return;    }    for (int i = 0; i <= maxSubHeaderIndex; ++i) {        SubHeader sh = subHeaders[i];        int firstCode = sh.getFirstCode();        int idRangeOffset = sh.getIdRangeOffset();        int idDelta = sh.getIdDelta();        int entryCount = sh.getEntryCount();        data.seek(startGlyphIndexOffset + idRangeOffset);        for (int j = 0; j < entryCount; ++j) {                        int charCode = i;            charCode = (charCode << 8) + (firstCode + j);                                                            int p = data.readUnsignedShort();                        if (p > 0) {                p = (p + idDelta) % 65536;                if (p < 0) {                    p += 65536;                }            }            if (p >= numGlyphs) {                                continue;            }            glyphIdToCharacterCode[p] = charCode;            characterCodeToGlyphId.put(charCode, p);        }    }}
 void pdfbox_f1415_0(TTFDataStream data) throws IOException
{    byte[] glyphMapping = data.read(256);    glyphIdToCharacterCode = newGlyphIdToCharacterCode(256);    characterCodeToGlyphId = new HashMap<>(glyphMapping.length);    for (int i = 0; i < glyphMapping.length; i++) {        int glyphIndex = glyphMapping[i] & 0xFF;        glyphIdToCharacterCode[glyphIndex] = i;        characterCodeToGlyphId.put(i, glyphIndex);    }}
private int[] pdfbox_f1416_0(int size)
{    int[] gidToCode = new int[size];    Arrays.fill(gidToCode, -1);    return gidToCode;}
public int pdfbox_f1417_0()
{    return platformEncodingId;}
public void pdfbox_f1418_0(int platformEncodingIdValue)
{    platformEncodingId = platformEncodingIdValue;}
public int pdfbox_f1419_0()
{    return platformId;}
public void pdfbox_f1420_0(int platformIdValue)
{    platformId = platformIdValue;}
public int pdfbox_f1421_0(int characterCode)
{    Integer glyphId = characterCodeToGlyphId.get(characterCode);    return glyphId == null ? 0 : glyphId;}
public Integer pdfbox_f1422_0(int gid)
{    int code = getCharCode(gid);    if (code == -1) {        return null;    }        if (code == Integer.MIN_VALUE) {        List<Integer> mappedValues = glyphIdToCharacterCodeMultiple.get(gid);        if (mappedValues != null) {                        return mappedValues.get(0);        }    }    return code;}
private int pdfbox_f1423_0(int gid)
{    if (gid < 0 || gid >= glyphIdToCharacterCode.length) {        return -1;    }    return glyphIdToCharacterCode[gid];}
public List<Integer> pdfbox_f1424_0(int gid)
{    int code = getCharCode(gid);    if (code == -1) {        return null;    }    List<Integer> codes = null;    if (code == Integer.MIN_VALUE) {        List<Integer> mappedValues = glyphIdToCharacterCodeMultiple.get(gid);        if (mappedValues != null) {            codes = new ArrayList<>(mappedValues);                        Collections.sort(codes);        }    } else {        codes = new ArrayList<>(1);        codes.add(code);    }    return codes;}
public String pdfbox_f1425_0()
{    return "{" + getPlatformId() + " " + getPlatformEncodingId() + "}";}
private int pdfbox_f1426_0()
{    return firstCode;}
private int pdfbox_f1427_0()
{    return entryCount;}
private short pdfbox_f1428_0()
{    return idDelta;}
private int pdfbox_f1429_0()
{    return idRangeOffset;}
 void pdfbox_f1430_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    @SuppressWarnings({ "unused", "squid:S1854", "squid:S1481" })    int version = data.readUnsignedShort();    int numberOfTables = data.readUnsignedShort();    cmaps = new CmapSubtable[numberOfTables];    for (int i = 0; i < numberOfTables; i++) {        CmapSubtable cmap = new CmapSubtable();        cmap.initData(data);        cmaps[i] = cmap;    }    for (int i = 0; i < numberOfTables; i++) {        cmaps[i].initSubtable(this, ttf.getNumberOfGlyphs(), data);    }    initialized = true;}
public CmapSubtable[] pdfbox_f1431_0()
{    return cmaps;}
public void pdfbox_f1432_0(CmapSubtable[] cmapsValue)
{    cmaps = cmapsValue;}
public CmapSubtable pdfbox_f1433_0(int platformId, int platformEncodingId)
{    for (CmapSubtable cmap : cmaps) {        if (cmap.getPlatformId() == platformId && cmap.getPlatformEncodingId() == platformEncodingId) {            return cmap;        }    }    return null;}
public void pdfbox_f1434_0(int idx)
{    firstIndex = idx;}
public int pdfbox_f1435_0()
{    return firstIndex;}
public void pdfbox_f1436_0(int idx)
{    firstContour = idx;}
public int pdfbox_f1437_0()
{    return firstContour;}
public short pdfbox_f1438_0()
{    return argument1;}
public short pdfbox_f1439_0()
{    return argument2;}
public short pdfbox_f1440_0()
{    return flags;}
public int pdfbox_f1441_0()
{    return glyphIndex;}
public double pdfbox_f1442_0()
{    return scale01;}
public double pdfbox_f1443_0()
{    return scale10;}
public double pdfbox_f1444_0()
{    return xscale;}
public double pdfbox_f1445_0()
{    return yscale;}
public int pdfbox_f1446_0()
{    return xtranslate;}
public int pdfbox_f1447_0()
{    return ytranslate;}
public int pdfbox_f1448_0(int x, int y)
{    return Math.round((float) (x * xscale + y * scale10));}
public int pdfbox_f1449_0(int x, int y)
{    return Math.round((float) (x * scale01 + y * yscale));}
public void pdfbox_f1450_1()
{    if (resolved) {        return;    }    if (beingResolved) {                return;    }    beingResolved = true;    int firstIndex = 0;    int firstContour = 0;    for (GlyfCompositeComp comp : components) {        comp.setFirstIndex(firstIndex);        comp.setFirstContour(firstContour);        GlyphDescription desc = descriptions.get(comp.getGlyphIndex());        if (desc != null) {            desc.resolve();            firstIndex += desc.getPointCount();            firstContour += desc.getContourCount();        }    }    resolved = true;    beingResolved = false;}
public int pdfbox_f1451_0(int i)
{    GlyfCompositeComp c = getCompositeCompEndPt(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        return gd.getEndPtOfContours(i - c.getFirstContour()) + c.getFirstIndex();    }    return 0;}
public byte pdfbox_f1452_0(int i)
{    GlyfCompositeComp c = getCompositeComp(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        return gd.getFlags(i - c.getFirstIndex());    }    return 0;}
public short pdfbox_f1453_0(int i)
{    GlyfCompositeComp c = getCompositeComp(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        int n = i - c.getFirstIndex();        int x = gd.getXCoordinate(n);        int y = gd.getYCoordinate(n);        short x1 = (short) c.scaleX(x, y);        x1 += c.getXTranslate();        return x1;    }    return 0;}
public short pdfbox_f1454_0(int i)
{    GlyfCompositeComp c = getCompositeComp(i);    if (c != null) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        int n = i - c.getFirstIndex();        int x = gd.getXCoordinate(n);        int y = gd.getYCoordinate(n);        short y1 = (short) c.scaleY(x, y);        y1 += c.getYTranslate();        return y1;    }    return 0;}
public boolean pdfbox_f1455_0()
{    return true;}
public int pdfbox_f1456_1()
{    if (!resolved) {            }    if (pointCount < 0) {        GlyfCompositeComp c = components.get(components.size() - 1);        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        if (gd == null) {                        pointCount = 0;        } else {            pointCount = c.getFirstIndex() + gd.getPointCount();        }    }    return pointCount;}
public int pdfbox_f1457_1()
{    if (!resolved) {            }    if (contourCount < 0) {        GlyfCompositeComp c = components.get(components.size() - 1);        contourCount = c.getFirstContour() + descriptions.get(c.getGlyphIndex()).getContourCount();    }    return contourCount;}
public int pdfbox_f1458_0()
{    return components.size();}
private GlyfCompositeComp pdfbox_f1459_0(int i)
{    for (GlyfCompositeComp c : components) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        if (c.getFirstIndex() <= i && gd != null && i < (c.getFirstIndex() + gd.getPointCount())) {            return c;        }    }    return null;}
private GlyfCompositeComp pdfbox_f1460_0(int i)
{    for (GlyfCompositeComp c : components) {        GlyphDescription gd = descriptions.get(c.getGlyphIndex());        if (c.getFirstContour() <= i && gd != null && i < (c.getFirstContour() + gd.getContourCount())) {            return c;        }    }    return null;}
private void pdfbox_f1461_1()
{    for (GlyfCompositeComp component : components) {        try {            int index = component.getGlyphIndex();            GlyphData glyph = glyphTable.getGlyph(index);            if (glyph != null) {                descriptions.put(index, glyph.getDescription());            }        } catch (IOException e) {                    }    }}
public void pdfbox_f1462_0()
{}
public int pdfbox_f1463_0()
{    return contourCount;}
public int[] pdfbox_f1464_0()
{    return instructions;}
 void pdfbox_f1465_0(TTFDataStream bais, int count) throws IOException
{    instructions = bais.readUnsignedByteArray(count);}
public int pdfbox_f1466_0(int i)
{    return endPtsOfContours[i];}
public byte pdfbox_f1467_0(int i)
{    return flags[i];}
public short pdfbox_f1468_0(int i)
{    return xCoordinates[i];}
public short pdfbox_f1469_0(int i)
{    return yCoordinates[i];}
public boolean pdfbox_f1470_0()
{    return false;}
public int pdfbox_f1471_0()
{    return pointCount;}
private void pdfbox_f1472_0(int count, TTFDataStream bais, short x0) throws IOException
{    short x = x0;    short y = 0;    for (int i = 0; i < count; i++) {        if ((flags[i] & X_DUAL) != 0) {            if ((flags[i] & X_SHORT_VECTOR) != 0) {                x += (short) bais.readUnsignedByte();            }        } else {            if ((flags[i] & X_SHORT_VECTOR) != 0) {                x += (short) -((short) bais.readUnsignedByte());            } else {                x += bais.readSignedShort();            }        }        xCoordinates[i] = x;    }    for (int i = 0; i < count; i++) {        if ((flags[i] & Y_DUAL) != 0) {            if ((flags[i] & Y_SHORT_VECTOR) != 0) {                y += (short) bais.readUnsignedByte();            }        } else {            if ((flags[i] & Y_SHORT_VECTOR) != 0) {                y += (short) -((short) bais.readUnsignedByte());            } else {                y += bais.readSignedShort();            }        }        yCoordinates[i] = y;    }}
private void pdfbox_f1473_0(int flagCount, TTFDataStream bais) throws IOException
{    for (int index = 0; index < flagCount; index++) {        flags[index] = (byte) bais.readUnsignedByte();        if ((flags[index] & REPEAT) != 0) {            int repeats = bais.readUnsignedByte();            for (int i = 1; i <= repeats && index + i < flags.length; i++) {                flags[index + i] = flags[index];            }            index += repeats;        }    }}
 void pdfbox_f1474_0(GlyphTable glyphTable, TTFDataStream data, int leftSideBearing) throws IOException
{    numberOfContours = data.readSignedShort();    xMin = data.readSignedShort();    yMin = data.readSignedShort();    xMax = data.readSignedShort();    yMax = data.readSignedShort();    boundingBox = new BoundingBox(xMin, yMin, xMax, yMax);    if (numberOfContours >= 0) {                short x0 = (short) (leftSideBearing - xMin);        glyphDescription = new GlyfSimpleDescript(numberOfContours, data, x0);    } else {                glyphDescription = new GlyfCompositeDescript(data, glyphTable);    }}
public BoundingBox pdfbox_f1475_0()
{    return boundingBox;}
public void pdfbox_f1476_0(BoundingBox boundingBoxValue)
{    this.boundingBox = boundingBoxValue;}
public short pdfbox_f1477_0()
{    return numberOfContours;}
public void pdfbox_f1478_0(short numberOfContoursValue)
{    this.numberOfContours = numberOfContoursValue;}
public GlyphDescription pdfbox_f1479_0()
{    return glyphDescription;}
public GeneralPath pdfbox_f1480_0()
{    return new GlyphRenderer(glyphDescription).getPath();}
public short pdfbox_f1481_0()
{    return xMax;}
public short pdfbox_f1482_0()
{    return xMin;}
public short pdfbox_f1483_0()
{    return yMax;}
public short pdfbox_f1484_0()
{    return yMin;}
public GeneralPath pdfbox_f1485_0()
{    Point[] points = describe(glyphDescription);    return calculatePath(points);}
private Point[] pdfbox_f1486_0(GlyphDescription gd)
{    int endPtIndex = 0;    int endPtOfContourIndex = -1;    Point[] points = new Point[gd.getPointCount()];    for (int i = 0; i < gd.getPointCount(); i++) {        if (endPtOfContourIndex == -1) {            endPtOfContourIndex = gd.getEndPtOfContours(endPtIndex);        }        boolean endPt = endPtOfContourIndex == i;        if (endPt) {            endPtIndex++;            endPtOfContourIndex = -1;        }        points[i] = new Point(gd.getXCoordinate(i), gd.getYCoordinate(i), (gd.getFlags(i) & GlyfDescript.ON_CURVE) != 0, endPt);    }    return points;}
private GeneralPath pdfbox_f1487_0(Point[] points)
{    GeneralPath path = new GeneralPath();    int start = 0;    for (int p = 0, len = points.length; p < len; ++p) {        if (points[p].endOfContour) {            Point firstPoint = points[start];            Point lastPoint = points[p];            List<Point> contour = new ArrayList<>();            for (int q = start; q <= p; ++q) {                contour.add(points[q]);            }            if (points[start].onCurve) {                                contour.add(firstPoint);            } else if (points[p].onCurve) {                                contour.add(0, lastPoint);            } else {                                Point pmid = midValue(firstPoint, lastPoint);                contour.add(0, pmid);                contour.add(pmid);            }            moveTo(path, contour.get(0));            for (int j = 1, clen = contour.size(); j < clen; j++) {                Point pnow = contour.get(j);                if (pnow.onCurve) {                    lineTo(path, pnow);                } else if (contour.get(j + 1).onCurve) {                    quadTo(path, pnow, contour.get(j + 1));                    ++j;                } else {                    quadTo(path, pnow, midValue(pnow, contour.get(j + 1)));                }            }            path.closePath();            start = p + 1;        }    }    return path;}
private void pdfbox_f1488_0(GeneralPath path, Point point)
{    path.moveTo(point.x, point.y);    if (LOG.isDebugEnabled()) {        LOG.trace("moveTo: " + String.format(Locale.US, "%d,%d", point.x, point.y));    }}
private void pdfbox_f1489_0(GeneralPath path, Point point)
{    path.lineTo(point.x, point.y);    if (LOG.isDebugEnabled()) {        LOG.trace("lineTo: " + String.format(Locale.US, "%d,%d", point.x, point.y));    }}
private void pdfbox_f1490_0(GeneralPath path, Point ctrlPoint, Point point)
{    path.quadTo(ctrlPoint.x, ctrlPoint.y, point.x, point.y);    if (LOG.isDebugEnabled()) {        LOG.trace("quadTo: " + String.format(Locale.US, "%d,%d %d,%d", ctrlPoint.x, ctrlPoint.y, point.x, point.y));    }}
private int pdfbox_f1491_0(int a, int b)
{    return a + (b - a) / 2;}
private Point pdfbox_f1492_0(Point point1, Point point2)
{    return new Point(midValue(point1.x, point2.x), midValue(point1.y, point2.y));}
public String pdfbox_f1493_0()
{    return String.format(Locale.US, "Point(%d,%d,%s,%s)", x, y, onCurve ? "onCurve" : "", endOfContour ? "endOfContour" : "");}
 void pdfbox_f1494_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    long start = data.getCurrentPosition();    @SuppressWarnings({ "unused" })    int majorVersion = data.readUnsignedShort();    int minorVersion = data.readUnsignedShort();    int scriptListOffset = data.readUnsignedShort();    int featureListOffset = data.readUnsignedShort();    int lookupListOffset = data.readUnsignedShort();    @SuppressWarnings({ "unused" })    long featureVariationsOffset = -1L;    if (minorVersion == 1L) {        featureVariationsOffset = data.readUnsignedInt();    }    scriptList = readScriptList(data, start + scriptListOffset);    featureListTable = readFeatureList(data, start + featureListOffset);    lookupListTable = readLookupList(data, start + lookupListOffset);    GlyphSubstitutionDataExtractor glyphSubstitutionDataExtractor = new GlyphSubstitutionDataExtractor();    gsubData = glyphSubstitutionDataExtractor.getGsubData(scriptList, featureListTable, lookupListTable);}
private Map<String, ScriptTable> pdfbox_f1495_0(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int scriptCount = data.readUnsignedShort();    ScriptTable[] scriptTables = new ScriptTable[scriptCount];    int[] scriptOffsets = new int[scriptCount];    String[] scriptTags = new String[scriptCount];    for (int i = 0; i < scriptCount; i++) {        scriptTags[i] = data.readString(4);        scriptOffsets[i] = data.readUnsignedShort();    }    for (int i = 0; i < scriptCount; i++) {        scriptTables[i] = readScriptTable(data, offset + scriptOffsets[i]);    }    Map<String, ScriptTable> resultScriptList = new LinkedHashMap<>(scriptCount);    for (int i = 0; i < scriptCount; i++) {        ScriptRecord scriptRecord = new ScriptRecord(scriptTags[i], scriptTables[i]);        resultScriptList.put(scriptRecord.getScriptTag(), scriptRecord.getScriptTable());    }    return Collections.unmodifiableMap(resultScriptList);}
private ScriptTable pdfbox_f1496_1(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int defaultLangSys = data.readUnsignedShort();    int langSysCount = data.readUnsignedShort();    LangSysRecord[] langSysRecords = new LangSysRecord[langSysCount];    String[] langSysTags = new String[langSysCount];    int[] langSysOffsets = new int[langSysCount];    for (int i = 0; i < langSysCount; i++) {        langSysTags[i] = data.readString(4);        if (i > 0 && langSysTags[i].compareTo(langSysTags[i - 1]) <= 0) {                                                return new ScriptTable(null, new LinkedHashMap<>());        }        langSysOffsets[i] = data.readUnsignedShort();    }    LangSysTable defaultLangSysTable = null;    if (defaultLangSys != 0) {        defaultLangSysTable = readLangSysTable(data, offset + defaultLangSys);    }    for (int i = 0; i < langSysCount; i++) {        LangSysTable langSysTable = readLangSysTable(data, offset + langSysOffsets[i]);        langSysRecords[i] = new LangSysRecord(langSysTags[i], langSysTable);    }    Map<String, LangSysTable> langSysTables = new LinkedHashMap<>(langSysCount);    for (LangSysRecord langSysRecord : langSysRecords) {        langSysTables.put(langSysRecord.getLangSysTag(), langSysRecord.getLangSysTable());    }    return new ScriptTable(defaultLangSysTable, Collections.unmodifiableMap(langSysTables));}
private LangSysTable pdfbox_f1497_0(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int lookupOrder = data.readUnsignedShort();    int requiredFeatureIndex = data.readUnsignedShort();    int featureIndexCount = data.readUnsignedShort();    int[] featureIndices = new int[featureIndexCount];    for (int i = 0; i < featureIndexCount; i++) {        featureIndices[i] = data.readUnsignedShort();    }    return new LangSysTable(lookupOrder, requiredFeatureIndex, featureIndexCount, featureIndices);}
private FeatureListTable pdfbox_f1498_1(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int featureCount = data.readUnsignedShort();    FeatureRecord[] featureRecords = new FeatureRecord[featureCount];    int[] featureOffsets = new int[featureCount];    String[] featureTags = new String[featureCount];    for (int i = 0; i < featureCount; i++) {        featureTags[i] = data.readString(4);        if (i > 0 && featureTags[i].compareTo(featureTags[i - 1]) < 0) {                                                return new FeatureListTable(0, new FeatureRecord[0]);        }        featureOffsets[i] = data.readUnsignedShort();    }    for (int i = 0; i < featureCount; i++) {        FeatureTable featureTable = readFeatureTable(data, offset + featureOffsets[i]);        featureRecords[i] = new FeatureRecord(featureTags[i], featureTable);    }    return new FeatureListTable(featureCount, featureRecords);}
private FeatureTable pdfbox_f1499_0(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int featureParams = data.readUnsignedShort();    int lookupIndexCount = data.readUnsignedShort();    int[] lookupListIndices = new int[lookupIndexCount];    for (int i = 0; i < lookupIndexCount; i++) {        lookupListIndices[i] = data.readUnsignedShort();    }    return new FeatureTable(featureParams, lookupIndexCount, lookupListIndices);}
private LookupListTable pdfbox_f1500_0(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int lookupCount = data.readUnsignedShort();    int[] lookups = new int[lookupCount];    for (int i = 0; i < lookupCount; i++) {        lookups[i] = data.readUnsignedShort();    }    LookupTable[] lookupTables = new LookupTable[lookupCount];    for (int i = 0; i < lookupCount; i++) {        lookupTables[i] = readLookupTable(data, offset + lookups[i]);    }    return new LookupListTable(lookupCount, lookupTables);}
private LookupTable pdfbox_f1501_1(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int lookupType = data.readUnsignedShort();    int lookupFlag = data.readUnsignedShort();    int subTableCount = data.readUnsignedShort();    int[] subTableOffets = new int[subTableCount];    for (int i = 0; i < subTableCount; i++) {        subTableOffets[i] = data.readUnsignedShort();    }    int markFilteringSet;    if ((lookupFlag & 0x0010) != 0) {        markFilteringSet = data.readUnsignedShort();    } else {        markFilteringSet = 0;    }    LookupSubTable[] subTables = new LookupSubTable[subTableCount];    switch(lookupType) {        case 1:                        for (int i = 0; i < subTableCount; i++) {                subTables[i] = readLookupSubTable(data, offset + subTableOffets[i]);            }            break;        case 4:                        for (int i = 0; i < subTableCount; i++) {                subTables[i] = readLigatureSubstitutionSubtable(data, offset + subTableOffets[i]);            }            break;        default:                            }    return new LookupTable(lookupType, lookupFlag, markFilteringSet, subTables);}
private LookupSubTable pdfbox_f1502_0(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int substFormat = data.readUnsignedShort();    switch(substFormat) {        case 1:            {                                                int coverageOffset = data.readUnsignedShort();                short deltaGlyphID = data.readSignedShort();                CoverageTable coverageTable = readCoverageTable(data, offset + coverageOffset);                return new LookupTypeSingleSubstFormat1(substFormat, coverageTable, deltaGlyphID);            }        case 2:            {                                                int coverageOffset = data.readUnsignedShort();                int glyphCount = data.readUnsignedShort();                int[] substituteGlyphIDs = new int[glyphCount];                for (int i = 0; i < glyphCount; i++) {                    substituteGlyphIDs[i] = data.readUnsignedShort();                }                CoverageTable coverageTable = readCoverageTable(data, offset + coverageOffset);                return new LookupTypeSingleSubstFormat2(substFormat, coverageTable, substituteGlyphIDs);            }        default:            throw new IOException("Unknown substFormat: " + substFormat);    }}
private LookupSubTable pdfbox_f1503_0(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int substFormat = data.readUnsignedShort();    if (substFormat != 1) {        throw new IOException("The expected SubstFormat for LigatureSubstitutionTable is 1");    }    int coverage = data.readUnsignedShort();    int ligSetCount = data.readUnsignedShort();    int[] ligatureOffsets = new int[ligSetCount];    for (int i = 0; i < ligSetCount; i++) {        ligatureOffsets[i] = data.readUnsignedShort();    }    CoverageTable coverageTable = readCoverageTable(data, offset + coverage);    if (ligSetCount != coverageTable.getSize()) {        throw new IOException("According to the OpenTypeFont specifications, the coverage count should be equal to the no. of LigatureSetTables");    }    LigatureSetTable[] ligatureSetTables = new LigatureSetTable[ligSetCount];    for (int i = 0; i < ligSetCount; i++) {        int coverageGlyphId = coverageTable.getGlyphId(i);        ligatureSetTables[i] = readLigatureSetTable(data, offset + ligatureOffsets[i], coverageGlyphId);    }    return new LookupTypeLigatureSubstitutionSubstFormat1(substFormat, coverageTable, ligatureSetTables);}
private LigatureSetTable pdfbox_f1504_1(TTFDataStream data, long ligatureSetTableLocation, int coverageGlyphId) throws IOException
{    data.seek(ligatureSetTableLocation);    int ligatureCount = data.readUnsignedShort();        int[] ligatureOffsets = new int[ligatureCount];    LigatureTable[] ligatureTables = new LigatureTable[ligatureCount];    for (int i = 0; i < ligatureOffsets.length; i++) {        ligatureOffsets[i] = data.readUnsignedShort();    }    for (int i = 0; i < ligatureOffsets.length; i++) {        int ligatureOffset = ligatureOffsets[i];        ligatureTables[i] = readLigatureTable(data, ligatureSetTableLocation + ligatureOffset, coverageGlyphId);    }    return new LigatureSetTable(ligatureCount, ligatureTables);}
private LigatureTable pdfbox_f1505_0(TTFDataStream data, long ligatureTableLocation, int coverageGlyphId) throws IOException
{    data.seek(ligatureTableLocation);    int ligatureGlyph = data.readUnsignedShort();    int componentCount = data.readUnsignedShort();    int[] componentGlyphIDs = new int[componentCount];    if (componentCount > 0) {        componentGlyphIDs[0] = coverageGlyphId;    }    for (int i = 1; i <= componentCount - 1; i++) {        componentGlyphIDs[i] = data.readUnsignedShort();    }    return new LigatureTable(ligatureGlyph, componentCount, componentGlyphIDs);}
private CoverageTable pdfbox_f1506_0(TTFDataStream data, long offset) throws IOException
{    data.seek(offset);    int coverageFormat = data.readUnsignedShort();    switch(coverageFormat) {        case 1:            {                int glyphCount = data.readUnsignedShort();                int[] glyphArray = new int[glyphCount];                for (int i = 0; i < glyphCount; i++) {                    glyphArray[i] = data.readUnsignedShort();                }                return new CoverageTableFormat1(coverageFormat, glyphArray);            }        case 2:            {                int rangeCount = data.readUnsignedShort();                RangeRecord[] rangeRecords = new RangeRecord[rangeCount];                for (int i = 0; i < rangeCount; i++) {                    rangeRecords[i] = readRangeRecord(data);                }                return new CoverageTableFormat2(coverageFormat, rangeRecords);            }        default:                        throw new IOException("Unknown coverage format: " + coverageFormat);    }}
private String pdfbox_f1507_0(String[] tags)
{    if (tags.length == 1) {        String tag = tags[0];        if (OpenTypeScript.INHERITED.equals(tag) || (OpenTypeScript.TAG_DEFAULT.equals(tag) && !scriptList.containsKey(tag))) {                        if (lastUsedSupportedScript == null) {                                lastUsedSupportedScript = scriptList.keySet().iterator().next();            }            return lastUsedSupportedScript;        }    }    for (String tag : tags) {        if (scriptList.containsKey(tag)) {                                    lastUsedSupportedScript = tag;            return lastUsedSupportedScript;        }    }    return tags[0];}
private Collection<LangSysTable> pdfbox_f1508_0(String scriptTag)
{    Collection<LangSysTable> result = Collections.emptyList();    ScriptTable scriptTable = scriptList.get(scriptTag);    if (scriptTable != null) {        if (scriptTable.getDefaultLangSysTable() == null) {            result = scriptTable.getLangSysTables().values();        } else {            result = new ArrayList<>(scriptTable.getLangSysTables().values());            result.add(scriptTable.getDefaultLangSysTable());        }    }    return result;}
private List<FeatureRecord> pdfbox_f1509_0(Collection<LangSysTable> langSysTables, final List<String> enabledFeatures)
{    if (langSysTables.isEmpty()) {        return Collections.emptyList();    }    List<FeatureRecord> result = new ArrayList<>();    langSysTables.forEach(langSysTable -> {        int required = langSysTable.getRequiredFeatureIndex();        if (        required != 0xffff) {            result.add(featureListTable.getFeatureRecords()[required]);        }        for (int featureIndex : langSysTable.getFeatureIndices()) {            if (enabledFeatures == null || enabledFeatures.contains(featureListTable.getFeatureRecords()[featureIndex].getFeatureTag())) {                result.add(featureListTable.getFeatureRecords()[featureIndex]);            }        }    });        if (containsFeature(result, "vrt2")) {        removeFeature(result, "vert");    }    if (enabledFeatures != null && result.size() > 1) {        Collections.sort(result, (o1, o2) -> Integer.compare(enabledFeatures.indexOf(o1.getFeatureTag()), enabledFeatures.indexOf(o2.getFeatureTag())));    }    return result;}
private boolean pdfbox_f1510_0(List<FeatureRecord> featureRecords, String featureTag)
{    return featureRecords.stream().anyMatch(featureRecord -> featureRecord.getFeatureTag().equals(featureTag));}
private void pdfbox_f1511_0(List<FeatureRecord> featureRecords, String featureTag)
{    Iterator<FeatureRecord> iter = featureRecords.iterator();    while (iter.hasNext()) {        if (iter.next().getFeatureTag().equals(featureTag)) {            iter.remove();        }    }}
private int pdfbox_f1512_1(FeatureRecord featureRecord, int gid)
{    int lookupResult = gid;    for (int lookupListIndex : featureRecord.getFeatureTable().getLookupListIndices()) {        LookupTable lookupTable = lookupListTable.getLookups()[lookupListIndex];        if (lookupTable.getLookupType() != 1) {                        continue;        }        lookupResult = doLookup(lookupTable, lookupResult);    }    return lookupResult;}
private int pdfbox_f1513_0(LookupTable lookupTable, int gid)
{    for (LookupSubTable lookupSubtable : lookupTable.getSubTables()) {        int coverageIndex = lookupSubtable.getCoverageTable().getCoverageIndex(gid);        if (coverageIndex >= 0) {            return lookupSubtable.doSubstitution(gid, coverageIndex);        }    }    return gid;}
public int pdfbox_f1514_0(int gid, String[] scriptTags, List<String> enabledFeatures)
{    if (gid == -1) {        return -1;    }    Integer cached = lookupCache.get(gid);    if (cached != null) {                return cached;    }    String scriptTag = selectScriptTag(scriptTags);    Collection<LangSysTable> langSysTables = getLangSysTables(scriptTag);    List<FeatureRecord> featureRecords = getFeatureRecords(langSysTables, enabledFeatures);    int sgid = gid;    for (FeatureRecord featureRecord : featureRecords) {        sgid = applyFeature(featureRecord, sgid);    }    lookupCache.put(gid, sgid);    reverseLookup.put(sgid, gid);    return sgid;}
public int pdfbox_f1515_1(int sgid)
{    Integer gid = reverseLookup.get(sgid);    if (gid == null) {                return sgid;    }    return gid;}
public GsubData pdfbox_f1516_0()
{    return gsubData;}
private RangeRecord pdfbox_f1517_0(TTFDataStream data) throws IOException
{    int startGlyphID = data.readUnsignedShort();    int endGlyphID = data.readUnsignedShort();    int startCoverageIndex = data.readUnsignedShort();    return new RangeRecord(startGlyphID, endGlyphID, startCoverageIndex);}
 void pdfbox_f1518_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    loca = ttf.getIndexToLocation();    numGlyphs = ttf.getNumberOfGlyphs();    if (numGlyphs < MAX_CACHE_SIZE) {                glyphs = new GlyphData[numGlyphs];    }        this.data = data;    initialized = true;}
public GlyphData[] pdfbox_f1519_0() throws IOException
{        synchronized (data) {                long[] offsets = loca.getOffsets();                                        long endOfGlyphs = offsets[numGlyphs];        long offset = getOffset();        if (glyphs == null) {            glyphs = new GlyphData[numGlyphs];        }        for (int gid = 0; gid < numGlyphs; gid++) {                        if (endOfGlyphs != 0 && endOfGlyphs == offsets[gid]) {                break;            }                        if (offsets[gid + 1] <= offsets[gid]) {                continue;            }            if (glyphs[gid] != null) {                                continue;            }            data.seek(offset + offsets[gid]);            if (glyphs[gid] == null) {                ++cached;            }            glyphs[gid] = getGlyphData(gid);        }        initialized = true;        return glyphs;    }}
public void pdfbox_f1520_0(GlyphData[] glyphsValue)
{    glyphs = glyphsValue;}
public GlyphData pdfbox_f1521_0(int gid) throws IOException
{    if (gid < 0 || gid >= numGlyphs) {        return null;    }    if (glyphs != null && glyphs[gid] != null) {        return glyphs[gid];    }        synchronized (data) {                long[] offsets = loca.getOffsets();        if (offsets[gid] == offsets[gid + 1]) {                        return null;        }                long currentPosition = data.getCurrentPosition();        data.seek(getOffset() + offsets[gid]);        GlyphData glyph = getGlyphData(gid);                data.seek(currentPosition);        if (glyphs != null && glyphs[gid] == null && cached < MAX_CACHED_GLYPHS) {            glyphs[gid] = glyph;            ++cached;        }        return glyph;    }}
private GlyphData pdfbox_f1522_0(int gid) throws IOException
{    GlyphData glyph = new GlyphData();    HorizontalMetricsTable hmt = font.getHorizontalMetrics();    int leftSideBearing = hmt == null ? 0 : hmt.getLeftSideBearing(gid);    glyph.initData(this, data, leftSideBearing);        if (glyph.getDescription().isComposite()) {        glyph.getDescription().resolve();    }    return glyph;}
public List<String> pdfbox_f1523_0(String text)
{    List<String> tokens = new ArrayList<>();    Matcher regexMatcher = regexExpression.matcher(text);    int lastIndexOfPrevMatch = 0;    while (regexMatcher.find()) {        int beginIndexOfNextMatch = regexMatcher.start();        String prevToken = text.substring(lastIndexOfPrevMatch, beginIndexOfNextMatch);        if (prevToken.length() > 0) {            tokens.add(prevToken);        }        String currentMatch = regexMatcher.group();        tokens.add(currentMatch);        lastIndexOfPrevMatch = regexMatcher.end();    }    String tail = text.substring(lastIndexOfPrevMatch, text.length());    if (tail.length() > 0) {        tokens.add(tail);    }    return tokens;}
private String pdfbox_f1524_0(Set<String> compoundWords)
{    StringBuilder sb = new StringBuilder();    for (String compoundWord : compoundWords) {        sb.append("(");        sb.append(compoundWord);        sb.append(")|");    }    sb.setLength(sb.length() - 1);    return sb.toString();}
public List<List<Integer>> pdfbox_f1525_0(List<Integer> glyphIds)
{    String originalGlyphsAsText = convertGlyphIdsToString(glyphIds);    List<String> tokens = compoundCharacterTokenizer.tokenize(originalGlyphsAsText);    List<List<Integer>> modifiedGlyphs = new ArrayList<>();    tokens.forEach(token -> modifiedGlyphs.add(convertGlyphIdsToList(token)));    return modifiedGlyphs;}
private Set<String> pdfbox_f1526_0(Set<List<Integer>> matchers)
{    Set<String> stringMatchers = new HashSet<>(matchers.size());    matchers.forEach(glyphIds -> stringMatchers.add(convertGlyphIdsToString(glyphIds)));    return stringMatchers;}
private String pdfbox_f1527_0(List<Integer> glyphIds)
{    StringBuilder sb = new StringBuilder(20);    sb.append(GLYPH_ID_SEPARATOR);    glyphIds.forEach(glyphId -> sb.append(glyphId).append(GLYPH_ID_SEPARATOR));    return sb.toString();}
private List<Integer> pdfbox_f1528_0(String glyphIdsAsString)
{    List<Integer> gsubProcessedGlyphsIds = new ArrayList<>();    for (String glyphId : glyphIdsAsString.split(GLYPH_ID_SEPARATOR)) {        if (glyphId.trim().length() == 0) {            continue;        }        gsubProcessedGlyphsIds.add(Integer.valueOf(glyphId));    }    return gsubProcessedGlyphsIds;}
public GsubData pdfbox_f1529_0(Map<String, ScriptTable> scriptList, FeatureListTable featureListTable, LookupListTable lookupListTable)
{    ScriptTableDetails scriptTableDetails = getSupportedLanguage(scriptList);    if (scriptTableDetails == null) {        return GsubData.NO_DATA_FOUND;    }    ScriptTable scriptTable = scriptTableDetails.getScriptTable();    Map<String, Map<List<Integer>, Integer>> gsubData = new LinkedHashMap<>();        if (scriptTable.getDefaultLangSysTable() != null) {        populateGsubData(gsubData, scriptTable.getDefaultLangSysTable(), featureListTable, lookupListTable);    }    for (LangSysTable langSysTable : scriptTable.getLangSysTables().values()) {        populateGsubData(gsubData, langSysTable, featureListTable, lookupListTable);    }    return new MapBackedGsubData(scriptTableDetails.getLanguage(), scriptTableDetails.getFeatureName(), gsubData);}
private ScriptTableDetails pdfbox_f1530_0(Map<String, ScriptTable> scriptList)
{    for (Language lang : Language.values()) {        for (String scriptName : lang.getScriptNames()) {            if (scriptList.containsKey(scriptName)) {                return new ScriptTableDetails(lang, scriptName, scriptList.get(scriptName));            }        }    }    return null;}
private void pdfbox_f1531_0(Map<String, Map<List<Integer>, Integer>> gsubData, LangSysTable langSysTable, FeatureListTable featureListTable, LookupListTable lookupListTable)
{    FeatureRecord[] featureRecords = featureListTable.getFeatureRecords();    for (int featureIndex : langSysTable.getFeatureIndices()) {        if (featureIndex < featureRecords.length) {            populateGsubData(gsubData, featureRecords[featureIndex], lookupListTable);        }    }}
private void pdfbox_f1532_1(Map<String, Map<List<Integer>, Integer>> gsubData, FeatureRecord featureRecord, LookupListTable lookupListTable)
{    LookupTable[] lookups = lookupListTable.getLookups();    Map<List<Integer>, Integer> glyphSubstitutionMap = new LinkedHashMap<>();    for (int lookupIndex : featureRecord.getFeatureTable().getLookupListIndices()) {        if (lookupIndex < lookups.length) {            extractData(glyphSubstitutionMap, lookups[lookupIndex]);        }    }        gsubData.put(featureRecord.getFeatureTag(), Collections.unmodifiableMap(glyphSubstitutionMap));}
private void pdfbox_f1533_1(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTable lookupTable)
{    for (LookupSubTable lookupSubTable : lookupTable.getSubTables()) {        if (lookupSubTable instanceof LookupTypeLigatureSubstitutionSubstFormat1) {            extractDataFromLigatureSubstitutionSubstFormat1Table(glyphSubstitutionMap, (LookupTypeLigatureSubstitutionSubstFormat1) lookupSubTable);        } else if (lookupSubTable instanceof LookupTypeSingleSubstFormat1) {            extractDataFromSingleSubstTableFormat1Table(glyphSubstitutionMap, (LookupTypeSingleSubstFormat1) lookupSubTable);        } else if (lookupSubTable instanceof LookupTypeSingleSubstFormat2) {            extractDataFromSingleSubstTableFormat2Table(glyphSubstitutionMap, (LookupTypeSingleSubstFormat2) lookupSubTable);        } else {                                }    }}
private void pdfbox_f1534_0(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTypeSingleSubstFormat1 singleSubstTableFormat1)
{    CoverageTable coverageTable = singleSubstTableFormat1.getCoverageTable();    for (int i = 0; i < coverageTable.getSize(); i++) {        int coverageGlyphId = coverageTable.getGlyphId(i);        int substituteGlyphId = coverageGlyphId + singleSubstTableFormat1.getDeltaGlyphID();        putNewSubstitutionEntry(glyphSubstitutionMap, substituteGlyphId, Arrays.asList(coverageGlyphId));    }}
private void pdfbox_f1535_0(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTypeSingleSubstFormat2 singleSubstTableFormat2)
{    CoverageTable coverageTable = singleSubstTableFormat2.getCoverageTable();    if (coverageTable.getSize() != singleSubstTableFormat2.getSubstituteGlyphIDs().length) {        throw new IllegalArgumentException("The no. coverage table entries should be the same as the size of the substituteGlyphIDs");    }    for (int i = 0; i < coverageTable.getSize(); i++) {        int coverageGlyphId = coverageTable.getGlyphId(i);        int substituteGlyphId = coverageGlyphId + singleSubstTableFormat2.getSubstituteGlyphIDs()[i];        putNewSubstitutionEntry(glyphSubstitutionMap, substituteGlyphId, Arrays.asList(coverageGlyphId));    }}
private void pdfbox_f1536_0(Map<List<Integer>, Integer> glyphSubstitutionMap, LookupTypeLigatureSubstitutionSubstFormat1 ligatureSubstitutionTable)
{    for (LigatureSetTable ligatureSetTable : ligatureSubstitutionTable.getLigatureSetTables()) {        for (LigatureTable ligatureTable : ligatureSetTable.getLigatureTables()) {            extractDataFromLigatureTable(glyphSubstitutionMap, ligatureTable);        }    }}
private void pdfbox_f1537_1(Map<List<Integer>, Integer> glyphSubstitutionMap, LigatureTable ligatureTable)
{    List<Integer> glyphsToBeSubstituted = new ArrayList<>();    for (int componentGlyphID : ligatureTable.getComponentGlyphIDs()) {        glyphsToBeSubstituted.add(componentGlyphID);    }        putNewSubstitutionEntry(glyphSubstitutionMap, ligatureTable.getLigatureGlyph(), glyphsToBeSubstituted);}
private void pdfbox_f1538_1(Map<List<Integer>, Integer> glyphSubstitutionMap, int newGlyph, List<Integer> glyphsToBeSubstituted)
{    Integer oldValue = glyphSubstitutionMap.put(glyphsToBeSubstituted, newGlyph);    if (oldValue != null) {        String message = "For the newGlyph: " + newGlyph + ", newValue: " + glyphsToBeSubstituted + " is trying to override the oldValue: " + oldValue;            }}
public Language pdfbox_f1539_0()
{    return language;}
public String pdfbox_f1540_0()
{    return featureName;}
public ScriptTable pdfbox_f1541_0()
{    return scriptTable;}
public GsubWorker pdfbox_f1542_0(CmapLookup cmapLookup, GsubData gsubData)
{    switch(gsubData.getLanguage()) {        case BENGALI:            return new GsubWorkerForBengali(cmapLookup, gsubData);        default:            throw new UnsupportedOperationException("The language " + gsubData.getLanguage() + " is not yet supported");    }}
public List<Integer> pdfbox_f1543_1(List<Integer> originalGlyphIds)
{    List<Integer> intermediateGlyphsFromGsub = originalGlyphIds;    for (String feature : FEATURES_IN_ORDER) {        if (!gsubData.isFeatureSupported(feature)) {                        continue;        }                ScriptFeature scriptFeature = gsubData.getFeature(feature);        intermediateGlyphsFromGsub = applyGsubFeature(scriptFeature, intermediateGlyphsFromGsub);    }    return Collections.unmodifiableList(repositionGlyphs(intermediateGlyphsFromGsub));}
private List<Integer> pdfbox_f1544_0(List<Integer> originalGlyphIds)
{    List<Integer> glyphsRepositionedByBeforeHalf = repositionBeforeHalfGlyphIds(originalGlyphIds);    return repositionBeforeAndAfterSpanGlyphIds(glyphsRepositionedByBeforeHalf);}
private List<Integer> pdfbox_f1545_0(List<Integer> originalGlyphIds)
{    List<Integer> repositionedGlyphIds = new ArrayList<>(originalGlyphIds);    for (int index = 1; index < originalGlyphIds.size(); index++) {        int glyphId = originalGlyphIds.get(index);        if (beforeHalfGlyphIds.contains(glyphId)) {            int previousGlyphId = originalGlyphIds.get(index - 1);            repositionedGlyphIds.set(index, previousGlyphId);            repositionedGlyphIds.set(index - 1, glyphId);        }    }    return repositionedGlyphIds;}
private List<Integer> pdfbox_f1546_0(List<Integer> originalGlyphIds)
{    List<Integer> repositionedGlyphIds = new ArrayList<>(originalGlyphIds);    for (int index = 1; index < originalGlyphIds.size(); index++) {        int glyphId = originalGlyphIds.get(index);        if (beforeAndAfterSpanGlyphIds.containsKey(glyphId)) {            BeforeAndAfterSpanComponent beforeAndAfterSpanComponent = beforeAndAfterSpanGlyphIds.get(glyphId);            int previousGlyphId = originalGlyphIds.get(index - 1);            repositionedGlyphIds.set(index, previousGlyphId);            repositionedGlyphIds.set(index - 1, getGlyphId(beforeAndAfterSpanComponent.beforeComponentCharacter));            repositionedGlyphIds.add(index + 1, getGlyphId(beforeAndAfterSpanComponent.afterComponentCharacter));        }    }    return repositionedGlyphIds;}
private List<Integer> pdfbox_f1547_1(ScriptFeature scriptFeature, List<Integer> originalGlyphs)
{    GlyphArraySplitter glyphArraySplitter = new GlyphArraySplitterRegexImpl(scriptFeature.getAllGlyphIdsForSubstitution());    List<List<Integer>> tokens = glyphArraySplitter.split(originalGlyphs);    List<Integer> gsubProcessedGlyphs = new ArrayList<>();    for (List<Integer> chunk : tokens) {        if (scriptFeature.canReplaceGlyphs(chunk)) {                        int glyphId = scriptFeature.getReplacementForGlyphs(chunk);            gsubProcessedGlyphs.add(glyphId);        } else {            gsubProcessedGlyphs.addAll(chunk);        }    }        return gsubProcessedGlyphs;}
private List<Integer> pdfbox_f1548_0()
{    List<Integer> glyphIds = new ArrayList<>();    for (char character : BEFORE_HALF_CHARS) {        glyphIds.add(getGlyphId(character));    }    if (gsubData.isFeatureSupported(INIT_FEATURE)) {        ScriptFeature feature = gsubData.getFeature(INIT_FEATURE);        for (List<Integer> glyphCluster : feature.getAllGlyphIdsForSubstitution()) {            glyphIds.add(feature.getReplacementForGlyphs(glyphCluster));        }    }    return Collections.unmodifiableList(glyphIds);}
private Integer pdfbox_f1549_0(char character)
{    return cmapLookup.getGlyphId(character);}
private Map<Integer, BeforeAndAfterSpanComponent> pdfbox_f1550_0()
{    Map<Integer, BeforeAndAfterSpanComponent> result = new HashMap<>();    for (BeforeAndAfterSpanComponent beforeAndAfterSpanComponent : BEFORE_AND_AFTER_SPAN_CHARS) {        result.put(getGlyphId(beforeAndAfterSpanComponent.originalCharacter), beforeAndAfterSpanComponent);    }    return Collections.unmodifiableMap(result);}
 void pdfbox_f1551_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    fontRevision = data.read32Fixed();    checkSumAdjustment = data.readUnsignedInt();    magicNumber = data.readUnsignedInt();    flags = data.readUnsignedShort();    unitsPerEm = data.readUnsignedShort();    created = data.readInternationalDate();    modified = data.readInternationalDate();    xMin = data.readSignedShort();    yMin = data.readSignedShort();    xMax = data.readSignedShort();    yMax = data.readSignedShort();    macStyle = data.readUnsignedShort();    lowestRecPPEM = data.readUnsignedShort();    fontDirectionHint = data.readSignedShort();    indexToLocFormat = data.readSignedShort();    glyphDataFormat = data.readSignedShort();    initialized = true;}
public long pdfbox_f1552_0()
{    return checkSumAdjustment;}
public void pdfbox_f1553_0(long checkSumAdjustmentValue)
{    this.checkSumAdjustment = checkSumAdjustmentValue;}
public Calendar pdfbox_f1554_0()
{    return created;}
public void pdfbox_f1555_0(Calendar createdValue)
{    this.created = createdValue;}
public int pdfbox_f1556_0()
{    return flags;}
public void pdfbox_f1557_0(int flagsValue)
{    this.flags = flagsValue;}
public short pdfbox_f1558_0()
{    return fontDirectionHint;}
public void pdfbox_f1559_0(short fontDirectionHintValue)
{    this.fontDirectionHint = fontDirectionHintValue;}
public float pdfbox_f1560_0()
{    return fontRevision;}
public void pdfbox_f1561_0(float fontRevisionValue)
{    this.fontRevision = fontRevisionValue;}
public short pdfbox_f1562_0()
{    return glyphDataFormat;}
public void pdfbox_f1563_0(short glyphDataFormatValue)
{    this.glyphDataFormat = glyphDataFormatValue;}
public short pdfbox_f1564_0()
{    return indexToLocFormat;}
public void pdfbox_f1565_0(short indexToLocFormatValue)
{    this.indexToLocFormat = indexToLocFormatValue;}
public int pdfbox_f1566_0()
{    return lowestRecPPEM;}
public void pdfbox_f1567_0(int lowestRecPPEMValue)
{    this.lowestRecPPEM = lowestRecPPEMValue;}
public int pdfbox_f1568_0()
{    return macStyle;}
public void pdfbox_f1569_0(int macStyleValue)
{    this.macStyle = macStyleValue;}
public long pdfbox_f1570_0()
{    return magicNumber;}
public void pdfbox_f1571_0(long magicNumberValue)
{    this.magicNumber = magicNumberValue;}
public Calendar pdfbox_f1572_0()
{    return modified;}
public void pdfbox_f1573_0(Calendar modifiedValue)
{    this.modified = modifiedValue;}
public int pdfbox_f1574_0()
{    return unitsPerEm;}
public void pdfbox_f1575_0(int unitsPerEmValue)
{    this.unitsPerEm = unitsPerEmValue;}
public float pdfbox_f1576_0()
{    return version;}
public void pdfbox_f1577_0(float versionValue)
{    this.version = versionValue;}
public short pdfbox_f1578_0()
{    return xMax;}
public void pdfbox_f1579_0(short maxValue)
{    xMax = maxValue;}
public short pdfbox_f1580_0()
{    return xMin;}
public void pdfbox_f1581_0(short minValue)
{    xMin = minValue;}
public short pdfbox_f1582_0()
{    return yMax;}
public void pdfbox_f1583_0(short maxValue)
{    yMax = maxValue;}
public short pdfbox_f1584_0()
{    return yMin;}
public void pdfbox_f1585_0(short minValue)
{    yMin = minValue;}
 void pdfbox_f1586_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    ascender = data.readSignedShort();    descender = data.readSignedShort();    lineGap = data.readSignedShort();    advanceWidthMax = data.readUnsignedShort();    minLeftSideBearing = data.readSignedShort();    minRightSideBearing = data.readSignedShort();    xMaxExtent = data.readSignedShort();    caretSlopeRise = data.readSignedShort();    caretSlopeRun = data.readSignedShort();    reserved1 = data.readSignedShort();    reserved2 = data.readSignedShort();    reserved3 = data.readSignedShort();    reserved4 = data.readSignedShort();    reserved5 = data.readSignedShort();    metricDataFormat = data.readSignedShort();    numberOfHMetrics = data.readUnsignedShort();    initialized = true;}
public int pdfbox_f1587_0()
{    return advanceWidthMax;}
public void pdfbox_f1588_0(int advanceWidthMaxValue)
{    this.advanceWidthMax = advanceWidthMaxValue;}
public short pdfbox_f1589_0()
{    return ascender;}
public void pdfbox_f1590_0(short ascenderValue)
{    this.ascender = ascenderValue;}
public short pdfbox_f1591_0()
{    return caretSlopeRise;}
public void pdfbox_f1592_0(short caretSlopeRiseValue)
{    this.caretSlopeRise = caretSlopeRiseValue;}
public short pdfbox_f1593_0()
{    return caretSlopeRun;}
public void pdfbox_f1594_0(short caretSlopeRunValue)
{    this.caretSlopeRun = caretSlopeRunValue;}
public short pdfbox_f1595_0()
{    return descender;}
public void pdfbox_f1596_0(short descenderValue)
{    this.descender = descenderValue;}
public short pdfbox_f1597_0()
{    return lineGap;}
public void pdfbox_f1598_0(short lineGapValue)
{    this.lineGap = lineGapValue;}
public short pdfbox_f1599_0()
{    return metricDataFormat;}
public void pdfbox_f1600_0(short metricDataFormatValue)
{    this.metricDataFormat = metricDataFormatValue;}
public short pdfbox_f1601_0()
{    return minLeftSideBearing;}
public void pdfbox_f1602_0(short minLeftSideBearingValue)
{    this.minLeftSideBearing = minLeftSideBearingValue;}
public short pdfbox_f1603_0()
{    return minRightSideBearing;}
public void pdfbox_f1604_0(short minRightSideBearingValue)
{    this.minRightSideBearing = minRightSideBearingValue;}
public int pdfbox_f1605_0()
{    return numberOfHMetrics;}
public void pdfbox_f1606_0(int numberOfHMetricsValue)
{    this.numberOfHMetrics = numberOfHMetricsValue;}
public short pdfbox_f1607_0()
{    return reserved1;}
public void pdfbox_f1608_0(short reserved1Value)
{    this.reserved1 = reserved1Value;}
public short pdfbox_f1609_0()
{    return reserved2;}
public void pdfbox_f1610_0(short reserved2Value)
{    this.reserved2 = reserved2Value;}
public short pdfbox_f1611_0()
{    return reserved3;}
public void pdfbox_f1612_0(short reserved3Value)
{    this.reserved3 = reserved3Value;}
public short pdfbox_f1613_0()
{    return reserved4;}
public void pdfbox_f1614_0(short reserved4Value)
{    this.reserved4 = reserved4Value;}
public short pdfbox_f1615_0()
{    return reserved5;}
public void pdfbox_f1616_0(short reserved5Value)
{    this.reserved5 = reserved5Value;}
public float pdfbox_f1617_0()
{    return version;}
public void pdfbox_f1618_0(float versionValue)
{    this.version = versionValue;}
public short pdfbox_f1619_0()
{    return xMaxExtent;}
public void pdfbox_f1620_0(short maxExtentValue)
{    xMaxExtent = maxExtentValue;}
 void pdfbox_f1621_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    HorizontalHeaderTable hHeader = ttf.getHorizontalHeader();    if (hHeader == null) {        throw new IOException("Could not get hhea table");    }    numHMetrics = hHeader.getNumberOfHMetrics();    int numGlyphs = ttf.getNumberOfGlyphs();    int bytesRead = 0;    advanceWidth = new int[numHMetrics];    leftSideBearing = new short[numHMetrics];    for (int i = 0; i < numHMetrics; i++) {        advanceWidth[i] = data.readUnsignedShort();        leftSideBearing[i] = data.readSignedShort();        bytesRead += 4;    }    int numberNonHorizontal = numGlyphs - numHMetrics;        if (numberNonHorizontal < 0) {        numberNonHorizontal = numGlyphs;    }            nonHorizontalLeftSideBearing = new short[numberNonHorizontal];    if (bytesRead < getLength()) {        for (int i = 0; i < numberNonHorizontal; i++) {            if (bytesRead < getLength()) {                nonHorizontalLeftSideBearing[i] = data.readSignedShort();                bytesRead += 2;            }        }    }    initialized = true;}
public int pdfbox_f1622_0(int gid)
{    if (gid < numHMetrics) {        return advanceWidth[gid];    } else {                return advanceWidth[advanceWidth.length - 1];    }}
public int pdfbox_f1623_0(int gid)
{    if (gid < numHMetrics) {        return leftSideBearing[gid];    } else {        return nonHorizontalLeftSideBearing[gid - numHMetrics];    }}
 void pdfbox_f1624_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    HeaderTable head = ttf.getHeader();    if (head == null) {        throw new IOException("Could not get head table");    }    int numGlyphs = ttf.getNumberOfGlyphs();    offsets = new long[numGlyphs + 1];    for (int i = 0; i < numGlyphs + 1; i++) {        if (head.getIndexToLocFormat() == SHORT_OFFSETS) {            offsets[i] = data.readUnsignedShort() * 2L;        } else if (head.getIndexToLocFormat() == LONG_OFFSETS) {            offsets[i] = data.readUnsignedInt();        } else {            throw new IOException("Error:TTF.loca unknown offset format: " + head.getIndexToLocFormat());        }    }    initialized = true;}
public long[] pdfbox_f1625_0()
{    return offsets;}
public void pdfbox_f1626_0(long[] offsetsValue)
{    offsets = offsetsValue;}
 void pdfbox_f1627_0(TTFDataStream data, int version) throws IOException
{    if (version == 0) {        readSubtable0(data);    } else if (version == 1) {        readSubtable1(data);    } else {        throw new IllegalStateException();    }}
public boolean pdfbox_f1628_0()
{    return isHorizontalKerning(false);}
public boolean pdfbox_f1629_0(boolean cross)
{    if (!horizontal) {        return false;    } else if (minimums) {        return false;    } else if (cross) {        return crossStream;    } else {        return !crossStream;    }}
public int[] pdfbox_f1630_1(int[] glyphs)
{    int[] kerning = null;    if (pairs != null) {        int ng = glyphs.length;        kerning = new int[ng];        for (int i = 0; i < ng; ++i) {            int l = glyphs[i];            int r = -1;            for (int k = i + 1; k < ng; ++k) {                int g = glyphs[k];                if (g >= 0) {                    r = g;                    break;                }            }            kerning[i] = getKerning(l, r);        }    } else {            }    return kerning;}
public int pdfbox_f1631_1(int l, int r)
{    if (pairs == null) {                return 0;    }    return pairs.getKerning(l, r);}
private void pdfbox_f1632_1(TTFDataStream data) throws IOException
{    int version = data.readUnsignedShort();    if (version != 0) {                return;    }    int length = data.readUnsignedShort();    if (length < 6) {        throw new IOException("Kerning sub-table too short, got " + length + " bytes, expect 6 or more.");    }    int coverage = data.readUnsignedShort();    if (isBitsSet(coverage, COVERAGE_HORIZONTAL, COVERAGE_HORIZONTAL_SHIFT)) {        this.horizontal = true;    }    if (isBitsSet(coverage, COVERAGE_MINIMUMS, COVERAGE_MINIMUMS_SHIFT)) {        this.minimums = true;    }    if (isBitsSet(coverage, COVERAGE_CROSS_STREAM, COVERAGE_CROSS_STREAM_SHIFT)) {        this.crossStream = true;    }    int format = getBits(coverage, COVERAGE_FORMAT, COVERAGE_FORMAT_SHIFT);    if (format == 0) {        readSubtable0Format0(data);    } else if (format == 2) {        readSubtable0Format2(data);    } else {            }}
private void pdfbox_f1633_0(TTFDataStream data) throws IOException
{    pairs = new PairData0Format0();    pairs.read(data);}
private void pdfbox_f1634_1(TTFDataStream data) throws IOException
{    }
private void pdfbox_f1635_1(TTFDataStream data) throws IOException
{    }
private static boolean pdfbox_f1636_0(int bits, int mask, int shift)
{    return getBits(bits, mask, shift) != 0;}
private static int pdfbox_f1637_0(int bits, int mask, int shift)
{    return (bits & mask) >> shift;}
public void pdfbox_f1638_0(TTFDataStream data) throws IOException
{    int numPairs = data.readUnsignedShort();    searchRange = data.readUnsignedShort() / 6;    int entrySelector = data.readUnsignedShort();    int rangeShift = data.readUnsignedShort();    pairs = new int[numPairs][3];    for (int i = 0; i < numPairs; ++i) {        int left = data.readUnsignedShort();        int right = data.readUnsignedShort();        int value = data.readSignedShort();        pairs[i][0] = left;        pairs[i][1] = right;        pairs[i][2] = value;    }}
public int pdfbox_f1639_0(int l, int r)
{    int[] key = new int[] { l, r, 0 };    int index = Arrays.binarySearch(pairs, key, this);    if (index >= 0) {        return pairs[index][2];    }    return 0;}
public int pdfbox_f1640_0(int[] p1, int[] p2)
{    assert p1 != null;    assert p1.length >= 2;    assert p2 != null;    assert p2.length >= 2;    int cmp1 = Integer.compare(p1[0], p2[0]);    if (cmp1 != 0) {        return cmp1;    }    return Integer.compare(p1[1], p2[1]);}
 void pdfbox_f1641_1(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    int version = data.readUnsignedShort();    if (version != 0) {        version = (version << 16) | data.readUnsignedShort();    }    int numSubtables = 0;    if (version == 0) {        numSubtables = data.readUnsignedShort();    } else if (version == 1) {        numSubtables = (int) data.readUnsignedInt();    } else {            }    if (numSubtables > 0) {        subtables = new KerningSubtable[numSubtables];        for (int i = 0; i < numSubtables; ++i) {            KerningSubtable subtable = new KerningSubtable();            subtable.read(data, version);            subtables[i] = subtable;        }    }    initialized = true;}
public KerningSubtable pdfbox_f1642_0()
{    return getHorizontalKerningSubtable(false);}
public KerningSubtable pdfbox_f1643_0(boolean cross)
{    if (subtables != null) {        for (KerningSubtable s : subtables) {            if (s.isHorizontalKerning(cross)) {                return s;            }        }    }    return null;}
public int pdfbox_f1644_0()
{    return maxComponentDepth;}
public void pdfbox_f1645_0(int maxComponentDepthValue)
{    this.maxComponentDepth = maxComponentDepthValue;}
public int pdfbox_f1646_0()
{    return maxComponentElements;}
public void pdfbox_f1647_0(int maxComponentElementsValue)
{    this.maxComponentElements = maxComponentElementsValue;}
public int pdfbox_f1648_0()
{    return maxCompositeContours;}
public void pdfbox_f1649_0(int maxCompositeContoursValue)
{    this.maxCompositeContours = maxCompositeContoursValue;}
public int pdfbox_f1650_0()
{    return maxCompositePoints;}
public void pdfbox_f1651_0(int maxCompositePointsValue)
{    this.maxCompositePoints = maxCompositePointsValue;}
public int pdfbox_f1652_0()
{    return maxContours;}
public void pdfbox_f1653_0(int maxContoursValue)
{    this.maxContours = maxContoursValue;}
public int pdfbox_f1654_0()
{    return maxFunctionDefs;}
public void pdfbox_f1655_0(int maxFunctionDefsValue)
{    this.maxFunctionDefs = maxFunctionDefsValue;}
public int pdfbox_f1656_0()
{    return maxInstructionDefs;}
public void pdfbox_f1657_0(int maxInstructionDefsValue)
{    this.maxInstructionDefs = maxInstructionDefsValue;}
public int pdfbox_f1658_0()
{    return maxPoints;}
public void pdfbox_f1659_0(int maxPointsValue)
{    this.maxPoints = maxPointsValue;}
public int pdfbox_f1660_0()
{    return maxSizeOfInstructions;}
public void pdfbox_f1661_0(int maxSizeOfInstructionsValue)
{    this.maxSizeOfInstructions = maxSizeOfInstructionsValue;}
public int pdfbox_f1662_0()
{    return maxStackElements;}
public void pdfbox_f1663_0(int maxStackElementsValue)
{    this.maxStackElements = maxStackElementsValue;}
public int pdfbox_f1664_0()
{    return maxStorage;}
public void pdfbox_f1665_0(int maxStorageValue)
{    this.maxStorage = maxStorageValue;}
public int pdfbox_f1666_0()
{    return maxTwilightPoints;}
public void pdfbox_f1667_0(int maxTwilightPointsValue)
{    this.maxTwilightPoints = maxTwilightPointsValue;}
public int pdfbox_f1668_0()
{    return maxZones;}
public void pdfbox_f1669_0(int maxZonesValue)
{    this.maxZones = maxZonesValue;}
public int pdfbox_f1670_0()
{    return numGlyphs;}
public void pdfbox_f1671_0(int numGlyphsValue)
{    this.numGlyphs = numGlyphsValue;}
public float pdfbox_f1672_0()
{    return version;}
public void pdfbox_f1673_0(float versionValue)
{    this.version = versionValue;}
 void pdfbox_f1674_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    numGlyphs = data.readUnsignedShort();    maxPoints = data.readUnsignedShort();    maxContours = data.readUnsignedShort();    maxCompositePoints = data.readUnsignedShort();    maxCompositeContours = data.readUnsignedShort();    maxZones = data.readUnsignedShort();    maxTwilightPoints = data.readUnsignedShort();    maxStorage = data.readUnsignedShort();    maxFunctionDefs = data.readUnsignedShort();    maxInstructionDefs = data.readUnsignedShort();    maxStackElements = data.readUnsignedShort();    maxSizeOfInstructions = data.readUnsignedShort();    maxComponentElements = data.readUnsignedShort();    maxComponentDepth = data.readUnsignedShort();    initialized = true;}
public long pdfbox_f1675_0() throws IOException
{    return ((long) (readSignedInt()) << 32) + (readSignedInt() & 0xFFFFFFFFL);}
public int pdfbox_f1676_0() throws IOException
{    int ch1 = read();    int ch2 = read();    int ch3 = read();    int ch4 = read();    if ((ch1 | ch2 | ch3 | ch4) < 0) {        throw new EOFException();    }    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));}
public int pdfbox_f1677_0() throws IOException
{    if (currentPosition >= data.length) {        return -1;    }    int retval = data[currentPosition];    currentPosition++;    return (retval + 256) % 256;}
public int pdfbox_f1678_0() throws IOException
{    int ch1 = this.read();    int ch2 = this.read();    if ((ch1 | ch2) < 0) {        throw new EOFException();    }    return (ch1 << 8) + (ch2 << 0);}
public short pdfbox_f1679_0() throws IOException
{    int ch1 = this.read();    int ch2 = this.read();    if ((ch1 | ch2) < 0) {        throw new EOFException();    }    return (short) ((ch1 << 8) + (ch2 << 0));}
public void pdfbox_f1680_0() throws IOException
{}
public void pdfbox_f1681_0(long pos) throws IOException
{    if (pos < 0 || pos > Integer.MAX_VALUE) {        throw new IOException("Illegal seek position: " + pos);    }    currentPosition = (int) pos;}
public int pdfbox_f1682_0(byte[] b, int off, int len) throws IOException
{    if (currentPosition < data.length) {        int amountRead = Math.min(len, data.length - currentPosition);        System.arraycopy(data, currentPosition, b, off, amountRead);        currentPosition += amountRead;        return amountRead;    } else {        return -1;    }}
public long pdfbox_f1683_0() throws IOException
{    return currentPosition;}
public InputStream pdfbox_f1684_0() throws IOException
{    return new ByteArrayInputStream(data);}
public long pdfbox_f1685_0()
{    return data.length;}
public boolean pdfbox_f1686_0(String featureName)
{    throw new UnsupportedOperationException();}
public Language pdfbox_f1687_0()
{    throw new UnsupportedOperationException();}
public ScriptFeature pdfbox_f1688_0(String featureName)
{    throw new UnsupportedOperationException();}
public String pdfbox_f1689_0()
{    throw new UnsupportedOperationException();}
public Set<String> pdfbox_f1690_0()
{    throw new UnsupportedOperationException();}
public String[] pdfbox_f1691_0()
{    return scriptNames;}
public Language pdfbox_f1692_0()
{    return language;}
public String pdfbox_f1693_0()
{    return activeScriptName;}
public boolean pdfbox_f1694_0(String featureName)
{    return glyphSubstitutionMap.containsKey(featureName);}
public ScriptFeature pdfbox_f1695_0(String featureName)
{    if (!isFeatureSupported(featureName)) {        throw new UnsupportedOperationException("The feature " + featureName + " is not supported!");    }    return new MapBackedScriptFeature(featureName, glyphSubstitutionMap.get(featureName));}
public Set<String> pdfbox_f1696_0()
{    return glyphSubstitutionMap.keySet();}
public String pdfbox_f1697_0()
{    return name;}
public Set<List<Integer>> pdfbox_f1698_0()
{    return featureMap.keySet();}
public boolean pdfbox_f1699_0(List<Integer> glyphIds)
{    return featureMap.containsKey(glyphIds);}
public Integer pdfbox_f1700_0(List<Integer> glyphIds)
{    if (!canReplaceGlyphs(glyphIds)) {        throw new UnsupportedOperationException("The glyphs " + glyphIds + " cannot be replaced");    }    return featureMap.get(glyphIds);}
public int pdfbox_f1701_0()
{    final int prime = 31;    int result = 1;    result = prime * result + ((featureMap == null) ? 0 : featureMap.hashCode());    result = prime * result + ((name == null) ? 0 : name.hashCode());    return result;}
public boolean pdfbox_f1702_0(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    MapBackedScriptFeature other = (MapBackedScriptFeature) obj;    if (featureMap == null) {        if (other.featureMap != null) {            return false;        }    } else if (!featureMap.equals(other.featureMap)) {        return false;    }    if (name == null) {        if (other.name != null) {            return false;        }    } else if (!name.equals(other.name)) {        return false;    }    return true;}
public int pdfbox_f1703_0()
{    return stringLength;}
public void pdfbox_f1704_0(int stringLengthValue)
{    this.stringLength = stringLengthValue;}
public int pdfbox_f1705_0()
{    return stringOffset;}
public void pdfbox_f1706_0(int stringOffsetValue)
{    this.stringOffset = stringOffsetValue;}
public int pdfbox_f1707_0()
{    return languageId;}
public void pdfbox_f1708_0(int languageIdValue)
{    this.languageId = languageIdValue;}
public int pdfbox_f1709_0()
{    return nameId;}
public void pdfbox_f1710_0(int nameIdValue)
{    this.nameId = nameIdValue;}
public int pdfbox_f1711_0()
{    return platformEncodingId;}
public void pdfbox_f1712_0(int platformEncodingIdValue)
{    this.platformEncodingId = platformEncodingIdValue;}
public int pdfbox_f1713_0()
{    return platformId;}
public void pdfbox_f1714_0(int platformIdValue)
{    this.platformId = platformIdValue;}
 void pdfbox_f1715_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    platformId = data.readUnsignedShort();    platformEncodingId = data.readUnsignedShort();    languageId = data.readUnsignedShort();    nameId = data.readUnsignedShort();    stringLength = data.readUnsignedShort();    stringOffset = data.readUnsignedShort();}
public String pdfbox_f1716_0()
{    return "platform=" + platformId + " pEncoding=" + platformEncodingId + " language=" + languageId + " name=" + nameId + " " + string;}
public String pdfbox_f1717_0()
{    return string;}
public void pdfbox_f1718_0(String stringValue)
{    this.string = stringValue;}
 void pdfbox_f1719_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    int formatSelector = data.readUnsignedShort();    int numberOfNameRecords = data.readUnsignedShort();    int offsetToStartOfStringStorage = data.readUnsignedShort();    nameRecords = new ArrayList<>(numberOfNameRecords);    for (int i = 0; i < numberOfNameRecords; i++) {        NameRecord nr = new NameRecord();        nr.initData(ttf, data);        nameRecords.add(nr);    }    for (NameRecord nr : nameRecords) {                if (nr.getStringOffset() > getLength()) {            nr.setString(null);            continue;        }        data.seek(getOffset() + (2 * 3) + numberOfNameRecords * 2 * 6 + nr.getStringOffset());        int platform = nr.getPlatformId();        int encoding = nr.getPlatformEncodingId();        Charset charset = Charsets.ISO_8859_1;        if (platform == NameRecord.PLATFORM_WINDOWS && (encoding == NameRecord.ENCODING_WINDOWS_SYMBOL || encoding == NameRecord.ENCODING_WINDOWS_UNICODE_BMP)) {            charset = Charsets.UTF_16;        } else if (platform == NameRecord.PLATFORM_UNICODE) {            charset = Charsets.UTF_16;        } else if (platform == NameRecord.PLATFORM_ISO) {            switch(encoding) {                case 0:                    charset = Charsets.US_ASCII;                    break;                case 1:                                        charset = Charsets.ISO_10646;                    break;                case 2:                    charset = Charsets.ISO_8859_1;                    break;                default:                    break;            }        }        String string = data.readString(nr.getStringLength(), charset);        nr.setString(string);    }        lookupTable = new HashMap<>(nameRecords.size());    for (NameRecord nr : nameRecords) {                Map<Integer, Map<Integer, Map<Integer, String>>> platformLookup = lookupTable.get(nr.getNameId());        if (platformLookup == null) {            platformLookup = new HashMap<>();            lookupTable.put(nr.getNameId(), platformLookup);        }                Map<Integer, Map<Integer, String>> encodingLookup = platformLookup.get(nr.getPlatformId());        if (encodingLookup == null) {            encodingLookup = new HashMap<>();            platformLookup.put(nr.getPlatformId(), encodingLookup);        }                Map<Integer, String> languageLookup = encodingLookup.get(nr.getPlatformEncodingId());        if (languageLookup == null) {            languageLookup = new HashMap<>();            encodingLookup.put(nr.getPlatformEncodingId(), languageLookup);        }                languageLookup.put(nr.getLanguageId(), nr.getString());    }        fontFamily = getEnglishName(NameRecord.NAME_FONT_FAMILY_NAME);    fontSubFamily = getEnglishName(NameRecord.NAME_FONT_SUB_FAMILY_NAME);        psName = getName(NameRecord.NAME_POSTSCRIPT_NAME, NameRecord.PLATFORM_MACINTOSH, NameRecord.ENCODING_MACINTOSH_ROMAN, NameRecord.LANGUGAE_MACINTOSH_ENGLISH);    if (psName == null) {        psName = getName(NameRecord.NAME_POSTSCRIPT_NAME, NameRecord.PLATFORM_WINDOWS, NameRecord.ENCODING_WINDOWS_UNICODE_BMP, NameRecord.LANGUGAE_WINDOWS_EN_US);    }    if (psName != null) {        psName = psName.trim();    }    initialized = true;}
private String pdfbox_f1720_0(int nameId)
{        for (int i = 4; i >= 0; i--) {        String nameUni = getName(nameId, NameRecord.PLATFORM_UNICODE, i, NameRecord.LANGUGAE_UNICODE);        if (nameUni != null) {            return nameUni;        }    }        String nameWin = getName(nameId, NameRecord.PLATFORM_WINDOWS, NameRecord.ENCODING_WINDOWS_UNICODE_BMP, NameRecord.LANGUGAE_WINDOWS_EN_US);    if (nameWin != null) {        return nameWin;    }        String nameMac = getName(nameId, NameRecord.PLATFORM_MACINTOSH, NameRecord.ENCODING_MACINTOSH_ROMAN, NameRecord.LANGUGAE_MACINTOSH_ENGLISH);    if (nameMac != null) {        return nameMac;    }    return null;}
public String pdfbox_f1721_0(int nameId, int platformId, int encodingId, int languageId)
{    Map<Integer, Map<Integer, Map<Integer, String>>> platforms = lookupTable.get(nameId);    if (platforms == null) {        return null;    }    Map<Integer, Map<Integer, String>> encodings = platforms.get(platformId);    if (encodings == null) {        return null;    }    Map<Integer, String> languages = encodings.get(encodingId);    if (languages == null) {        return null;    }    return languages.get(languageId);}
public List<NameRecord> pdfbox_f1722_0()
{    return nameRecords;}
public String pdfbox_f1723_0()
{    return fontFamily;}
public String pdfbox_f1724_0()
{    return fontSubFamily;}
public String pdfbox_f1725_0()
{    return psName;}
 void pdfbox_f1726_0(float versionValue)
{        isPostScript = Float.floatToIntBits(versionValue) == 0x469EA8A9;    super.setVersion(versionValue);}
public CFFTable pdfbox_f1727_0() throws IOException
{    if (!isPostScript) {        throw new UnsupportedOperationException("TTF fonts do not have a CFF table");    }    return (CFFTable) getTable(CFFTable.TAG);}
public GlyphTable pdfbox_f1728_0() throws IOException
{    if (isPostScript) {        throw new UnsupportedOperationException("OTF fonts do not have a glyf table");    }    return super.getGlyph();}
public GeneralPath pdfbox_f1729_0(String name) throws IOException
{    int gid = nameToGID(name);    return getCFF().getFont().getType2CharString(gid).getPath();}
public boolean pdfbox_f1730_0()
{    return tables.containsKey(CFFTable.TAG);}
public boolean pdfbox_f1731_0()
{    return tables.containsKey("BASE") || tables.containsKey("GDEF") || tables.containsKey("GPOS") || tables.containsKey("GSUB") || tables.containsKey("JSTF");}
private static void pdfbox_f1732_0(InputStream inputStream) throws IOException
{    Map<int[], String> unicodeRanges = new TreeMap<>((o1, o2) -> Integer.compare(o1[0], o2[0]));    try (LineNumberReader rd = new LineNumberReader(new InputStreamReader(inputStream))) {        int[] lastRange = { Integer.MIN_VALUE, Integer.MIN_VALUE };        String lastScript = null;        do {            String s = rd.readLine();            if (s == null) {                break;            }                        int comment = s.indexOf('#');            if (comment != -1) {                s = s.substring(0, comment);            }            if (s.length() < 2) {                continue;            }            StringTokenizer st = new StringTokenizer(s, ";");            int nFields = st.countTokens();            if (nFields < 2) {                continue;            }            String characters = st.nextToken().trim();            String script = st.nextToken().trim();            int[] range = new int[2];            int rangeDelim = characters.indexOf("..");            if (rangeDelim == -1) {                range[0] = range[1] = Integer.parseInt(characters, 16);            } else {                range[0] = Integer.parseInt(characters.substring(0, rangeDelim), 16);                range[1] = Integer.parseInt(characters.substring(rangeDelim + 2), 16);            }            if (range[0] == lastRange[1] + 1 && script.equals(lastScript)) {                                lastRange[1] = range[1];            } else {                unicodeRanges.put(range, script);                lastRange = range;                lastScript = script;            }        } while (true);    }    unicodeRangeStarts = new int[unicodeRanges.size()];    unicodeRangeScripts = new String[unicodeRanges.size()];    int i = 0;    for (Entry<int[], String> e : unicodeRanges.entrySet()) {        unicodeRangeStarts[i] = e.getKey()[0];        unicodeRangeScripts[i] = e.getValue();        i++;    }}
private static String pdfbox_f1733_0(int codePoint)
{    ensureValidCodePoint(codePoint);    int type = Character.getType(codePoint);    if (type == Character.UNASSIGNED) {        return UNKNOWN;    }    int scriptIndex = Arrays.binarySearch(unicodeRangeStarts, codePoint);    if (scriptIndex < 0) {        scriptIndex = -scriptIndex - 2;    }    return unicodeRangeScripts[scriptIndex];}
public static String[] pdfbox_f1734_0(int codePoint)
{    ensureValidCodePoint(codePoint);    String unicode = getUnicodeScript(codePoint);    return UNICODE_SCRIPT_TO_OPENTYPE_TAG_MAP.get(unicode);}
private static void pdfbox_f1735_0(int codePoint)
{    if (codePoint < Character.MIN_CODE_POINT || codePoint > Character.MAX_CODE_POINT) {        throw new IllegalArgumentException("Invalid codepoint: " + codePoint);    }}
public String pdfbox_f1736_0()
{    return achVendId;}
public void pdfbox_f1737_0(String achVendIdValue)
{    this.achVendId = achVendIdValue;}
public short pdfbox_f1738_0()
{    return averageCharWidth;}
public void pdfbox_f1739_0(short averageCharWidthValue)
{    this.averageCharWidth = averageCharWidthValue;}
public long pdfbox_f1740_0()
{    return codePageRange1;}
public void pdfbox_f1741_0(long codePageRange1Value)
{    this.codePageRange1 = codePageRange1Value;}
public long pdfbox_f1742_0()
{    return codePageRange2;}
public void pdfbox_f1743_0(long codePageRange2Value)
{    this.codePageRange2 = codePageRange2Value;}
public int pdfbox_f1744_0()
{    return familyClass;}
public void pdfbox_f1745_0(int familyClassValue)
{    this.familyClass = familyClassValue;}
public int pdfbox_f1746_0()
{    return firstCharIndex;}
public void pdfbox_f1747_0(int firstCharIndexValue)
{    this.firstCharIndex = firstCharIndexValue;}
public int pdfbox_f1748_0()
{    return fsSelection;}
public void pdfbox_f1749_0(int fsSelectionValue)
{    this.fsSelection = fsSelectionValue;}
public short pdfbox_f1750_0()
{    return fsType;}
public void pdfbox_f1751_0(short fsTypeValue)
{    this.fsType = fsTypeValue;}
public int pdfbox_f1752_0()
{    return lastCharIndex;}
public void pdfbox_f1753_0(int lastCharIndexValue)
{    this.lastCharIndex = lastCharIndexValue;}
public byte[] pdfbox_f1754_0()
{    return panose;}
public void pdfbox_f1755_0(byte[] panoseValue)
{    this.panose = panoseValue;}
public short pdfbox_f1756_0()
{    return strikeoutPosition;}
public void pdfbox_f1757_0(short strikeoutPositionValue)
{    this.strikeoutPosition = strikeoutPositionValue;}
public short pdfbox_f1758_0()
{    return strikeoutSize;}
public void pdfbox_f1759_0(short strikeoutSizeValue)
{    this.strikeoutSize = strikeoutSizeValue;}
public short pdfbox_f1760_0()
{    return subscriptXOffset;}
public void pdfbox_f1761_0(short subscriptXOffsetValue)
{    this.subscriptXOffset = subscriptXOffsetValue;}
public short pdfbox_f1762_0()
{    return subscriptXSize;}
public void pdfbox_f1763_0(short subscriptXSizeValue)
{    this.subscriptXSize = subscriptXSizeValue;}
public short pdfbox_f1764_0()
{    return subscriptYOffset;}
public void pdfbox_f1765_0(short subscriptYOffsetValue)
{    this.subscriptYOffset = subscriptYOffsetValue;}
public short pdfbox_f1766_0()
{    return subscriptYSize;}
public void pdfbox_f1767_0(short subscriptYSizeValue)
{    this.subscriptYSize = subscriptYSizeValue;}
public short pdfbox_f1768_0()
{    return superscriptXOffset;}
public void pdfbox_f1769_0(short superscriptXOffsetValue)
{    this.superscriptXOffset = superscriptXOffsetValue;}
public short pdfbox_f1770_0()
{    return superscriptXSize;}
public void pdfbox_f1771_0(short superscriptXSizeValue)
{    this.superscriptXSize = superscriptXSizeValue;}
public short pdfbox_f1772_0()
{    return superscriptYOffset;}
public void pdfbox_f1773_0(short superscriptYOffsetValue)
{    this.superscriptYOffset = superscriptYOffsetValue;}
public short pdfbox_f1774_0()
{    return superscriptYSize;}
public void pdfbox_f1775_0(short superscriptYSizeValue)
{    this.superscriptYSize = superscriptYSizeValue;}
public int pdfbox_f1776_0()
{    return typoLineGap;}
public void pdfbox_f1777_0(int typeLineGapValue)
{    this.typoLineGap = typeLineGapValue;}
public int pdfbox_f1778_0()
{    return typoAscender;}
public void pdfbox_f1779_0(int typoAscenderValue)
{    this.typoAscender = typoAscenderValue;}
public int pdfbox_f1780_0()
{    return typoDescender;}
public void pdfbox_f1781_0(int typoDescenderValue)
{    this.typoDescender = typoDescenderValue;}
public long pdfbox_f1782_0()
{    return unicodeRange1;}
public void pdfbox_f1783_0(long unicodeRange1Value)
{    this.unicodeRange1 = unicodeRange1Value;}
public long pdfbox_f1784_0()
{    return unicodeRange2;}
public void pdfbox_f1785_0(long unicodeRange2Value)
{    this.unicodeRange2 = unicodeRange2Value;}
public long pdfbox_f1786_0()
{    return unicodeRange3;}
public void pdfbox_f1787_0(long unicodeRange3Value)
{    this.unicodeRange3 = unicodeRange3Value;}
public long pdfbox_f1788_0()
{    return unicodeRange4;}
public void pdfbox_f1789_0(long unicodeRange4Value)
{    this.unicodeRange4 = unicodeRange4Value;}
public int pdfbox_f1790_0()
{    return version;}
public void pdfbox_f1791_0(int versionValue)
{    this.version = versionValue;}
public int pdfbox_f1792_0()
{    return weightClass;}
public void pdfbox_f1793_0(int weightClassValue)
{    this.weightClass = weightClassValue;}
public int pdfbox_f1794_0()
{    return widthClass;}
public void pdfbox_f1795_0(int widthClassValue)
{    this.widthClass = widthClassValue;}
public int pdfbox_f1796_0()
{    return winAscent;}
public void pdfbox_f1797_0(int winAscentValue)
{    this.winAscent = winAscentValue;}
public int pdfbox_f1798_0()
{    return winDescent;}
public void pdfbox_f1799_0(int winDescentValue)
{    this.winDescent = winDescentValue;}
public int pdfbox_f1800_0()
{    return sxHeight;}
public int pdfbox_f1801_0()
{    return sCapHeight;}
public int pdfbox_f1802_0()
{    return usDefaultChar;}
public int pdfbox_f1803_0()
{    return usBreakChar;}
public int pdfbox_f1804_0()
{    return usMaxContext;}
 void pdfbox_f1805_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.readUnsignedShort();    averageCharWidth = data.readSignedShort();    weightClass = data.readUnsignedShort();    widthClass = data.readUnsignedShort();    fsType = data.readSignedShort();    subscriptXSize = data.readSignedShort();    subscriptYSize = data.readSignedShort();    subscriptXOffset = data.readSignedShort();    subscriptYOffset = data.readSignedShort();    superscriptXSize = data.readSignedShort();    superscriptYSize = data.readSignedShort();    superscriptXOffset = data.readSignedShort();    superscriptYOffset = data.readSignedShort();    strikeoutSize = data.readSignedShort();    strikeoutPosition = data.readSignedShort();    familyClass = data.readSignedShort();    panose = data.read(10);    unicodeRange1 = data.readUnsignedInt();    unicodeRange2 = data.readUnsignedInt();    unicodeRange3 = data.readUnsignedInt();    unicodeRange4 = data.readUnsignedInt();    achVendId = data.readString(4);    fsSelection = data.readUnsignedShort();    firstCharIndex = data.readUnsignedShort();    lastCharIndex = data.readUnsignedShort();    typoAscender = data.readSignedShort();    typoDescender = data.readSignedShort();    typoLineGap = data.readSignedShort();    winAscent = data.readUnsignedShort();    winDescent = data.readUnsignedShort();    if (version >= 1) {        codePageRange1 = data.readUnsignedInt();        codePageRange2 = data.readUnsignedInt();    }    if (version >= 1.2) {        sxHeight = data.readSignedShort();        sCapHeight = data.readSignedShort();        usDefaultChar = data.readUnsignedShort();        usBreakChar = data.readUnsignedShort();        usMaxContext = data.readUnsignedShort();    }    initialized = true;}
public OpenTypeFont pdfbox_f1806_0(String file) throws IOException
{    return (OpenTypeFont) super.parse(file);}
public OpenTypeFont pdfbox_f1807_0(File file) throws IOException
{    return (OpenTypeFont) super.parse(file);}
public OpenTypeFont pdfbox_f1808_0(InputStream data) throws IOException
{    return (OpenTypeFont) super.parse(data);}
 OpenTypeFont pdfbox_f1809_0(TTFDataStream raf) throws IOException
{    return (OpenTypeFont) super.parse(raf);}
 OpenTypeFont pdfbox_f1810_0(TTFDataStream raf)
{    return new OpenTypeFont(raf);}
protected TTFTable pdfbox_f1811_0(TrueTypeFont font, String tag)
{        switch(tag) {        case "BASE":        case "GDEF":        case "GPOS":        case "GSUB":        case "JSTF":            return new OTLTable(font);        case "CFF ":            return new CFFTable(font);        default:            return super.readTable(font, tag);    }}
protected boolean pdfbox_f1812_0()
{    return true;}
 void pdfbox_f1813_1(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    formatType = data.read32Fixed();    italicAngle = data.read32Fixed();    underlinePosition = data.readSignedShort();    underlineThickness = data.readSignedShort();    isFixedPitch = data.readUnsignedInt();    minMemType42 = data.readUnsignedInt();    maxMemType42 = data.readUnsignedInt();    mimMemType1 = data.readUnsignedInt();    maxMemType1 = data.readUnsignedInt();    if (Float.compare(formatType, 1.0f) == 0) {        /*             * This TrueType font file contains exactly the 258 glyphs in the standard Macintosh TrueType.             */        glyphNames = new String[WGL4Names.NUMBER_OF_MAC_GLYPHS];        System.arraycopy(WGL4Names.MAC_GLYPH_NAMES, 0, glyphNames, 0, WGL4Names.NUMBER_OF_MAC_GLYPHS);    } else if (Float.compare(formatType, 2.0f) == 0) {        int numGlyphs = data.readUnsignedShort();        int[] glyphNameIndex = new int[numGlyphs];        glyphNames = new String[numGlyphs];        int maxIndex = Integer.MIN_VALUE;        for (int i = 0; i < numGlyphs; i++) {            int index = data.readUnsignedShort();            glyphNameIndex[i] = index;                        if (index <= 32767) {                maxIndex = Math.max(maxIndex, index);            }        }        String[] nameArray = null;        if (maxIndex >= WGL4Names.NUMBER_OF_MAC_GLYPHS) {            nameArray = new String[maxIndex - WGL4Names.NUMBER_OF_MAC_GLYPHS + 1];            for (int i = 0; i < maxIndex - WGL4Names.NUMBER_OF_MAC_GLYPHS + 1; i++) {                int numberOfChars = data.readUnsignedByte();                nameArray[i] = data.readString(numberOfChars);            }        }        for (int i = 0; i < numGlyphs; i++) {            int index = glyphNameIndex[i];            if (index >= 0 && index < WGL4Names.NUMBER_OF_MAC_GLYPHS) {                glyphNames[i] = WGL4Names.MAC_GLYPH_NAMES[index];            } else if (index >= WGL4Names.NUMBER_OF_MAC_GLYPHS && index <= 32767 && nameArray != null) {                glyphNames[i] = nameArray[index - WGL4Names.NUMBER_OF_MAC_GLYPHS];            } else {                                                glyphNames[i] = ".undefined";            }        }    } else if (Float.compare(formatType, 2.5f) == 0) {        int[] glyphNameIndex = new int[ttf.getNumberOfGlyphs()];        for (int i = 0; i < glyphNameIndex.length; i++) {            int offset = data.readSignedByte();            glyphNameIndex[i] = i + 1 + offset;        }        glyphNames = new String[glyphNameIndex.length];        for (int i = 0; i < glyphNames.length; i++) {            int index = glyphNameIndex[i];            if (index >= 0 && index < WGL4Names.NUMBER_OF_MAC_GLYPHS) {                String name = WGL4Names.MAC_GLYPH_NAMES[index];                if (name != null) {                    glyphNames[i] = name;                }            } else {                            }        }    } else if (Float.compare(formatType, 3.0f) == 0) {                    }    initialized = true;}
public float pdfbox_f1814_0()
{    return formatType;}
public void pdfbox_f1815_0(float formatTypeValue)
{    this.formatType = formatTypeValue;}
public long pdfbox_f1816_0()
{    return isFixedPitch;}
public void pdfbox_f1817_0(long isFixedPitchValue)
{    this.isFixedPitch = isFixedPitchValue;}
public float pdfbox_f1818_0()
{    return italicAngle;}
public void pdfbox_f1819_0(float italicAngleValue)
{    this.italicAngle = italicAngleValue;}
public long pdfbox_f1820_0()
{    return maxMemType1;}
public void pdfbox_f1821_0(long maxMemType1Value)
{    this.maxMemType1 = maxMemType1Value;}
public long pdfbox_f1822_0()
{    return maxMemType42;}
public void pdfbox_f1823_0(long maxMemType42Value)
{    this.maxMemType42 = maxMemType42Value;}
public long pdfbox_f1824_0()
{    return mimMemType1;}
public void pdfbox_f1825_0(long mimMemType1Value)
{    this.mimMemType1 = mimMemType1Value;}
public long pdfbox_f1826_0()
{    return minMemType42;}
public void pdfbox_f1827_0(long minMemType42Value)
{    this.minMemType42 = minMemType42Value;}
public short pdfbox_f1828_0()
{    return underlinePosition;}
public void pdfbox_f1829_0(short underlinePositionValue)
{    this.underlinePosition = underlinePositionValue;}
public short pdfbox_f1830_0()
{    return underlineThickness;}
public void pdfbox_f1831_0(short underlineThicknessValue)
{    this.underlineThickness = underlineThicknessValue;}
public String[] pdfbox_f1832_0()
{    return glyphNames;}
public void pdfbox_f1833_0(String[] glyphNamesValue)
{    this.glyphNames = glyphNamesValue;}
public String pdfbox_f1834_0(int gid)
{    if (gid < 0 || glyphNames == null || gid >= glyphNames.length) {        return null;    }    return glyphNames[gid];}
public short pdfbox_f1835_0() throws IOException
{    return raf.readShort();}
public long pdfbox_f1836_0() throws IOException
{    return raf.getFilePointer();}
public void pdfbox_f1837_0() throws IOException
{    if (raf != null) {        raf.close();        raf = null;    }}
public int pdfbox_f1838_0() throws IOException
{    return raf.read();}
public int pdfbox_f1839_0() throws IOException
{    return raf.readUnsignedShort();}
public long pdfbox_f1840_0() throws IOException
{    return raf.readLong();}
public void pdfbox_f1841_0(long pos) throws IOException
{    raf.seek(pos);}
public int pdfbox_f1842_0(byte[] b, int off, int len) throws IOException
{    return raf.read(b, off, len);}
public InputStream pdfbox_f1843_0() throws IOException
{    return new FileInputStream(ttfFile);}
public long pdfbox_f1844_0()
{    return ttfFile.length();}
public int pdfbox_f1845_0(int characterCode)
{    int gid = cmap.getGlyphId(characterCode);    String[] scriptTags = OpenTypeScript.getScriptTags(characterCode);    return gsub.getSubstitution(gid, scriptTags, enabledFeatures);}
public List<Integer> pdfbox_f1846_0(int gid)
{    return cmap.getCharCodes(gsub.getUnsubstitution(gid));}
public int pdfbox_f1847_0()
{    return coverageFormat;}
public int pdfbox_f1848_0(int gid)
{    return Arrays.binarySearch(glyphArray, gid);}
public int pdfbox_f1849_0(int index)
{    return glyphArray[index];}
public int pdfbox_f1850_0()
{    return glyphArray.length;}
public int[] pdfbox_f1851_0()
{    return glyphArray;}
public String pdfbox_f1852_0()
{    return String.format("CoverageTableFormat1[coverageFormat=%d,glyphArray=%s]", getCoverageFormat(), Arrays.toString(glyphArray));}
public RangeRecord[] pdfbox_f1853_0()
{    return rangeRecords;}
private static int[] pdfbox_f1854_0(RangeRecord[] rangeRecords)
{    List<Integer> glyphIds = new ArrayList<>();    for (RangeRecord rangeRecord : rangeRecords) {        for (int glyphId = rangeRecord.getStartGlyphID(); glyphId <= rangeRecord.getEndGlyphID(); glyphId++) {            glyphIds.add(glyphId);        }    }    int[] glyphArray = new int[glyphIds.size()];    for (int i = 0; i < glyphArray.length; i++) {        glyphArray[i] = glyphIds.get(i);    }    return glyphArray;}
public String pdfbox_f1855_0()
{    return String.format("CoverageTableFormat2[coverageFormat=%d]", getCoverageFormat());}
public int pdfbox_f1856_0()
{    return featureCount;}
public FeatureRecord[] pdfbox_f1857_0()
{    return featureRecords;}
public String pdfbox_f1858_0()
{    return String.format("%s[featureCount=%d]", FeatureListTable.class.getSimpleName(), featureCount);}
public String pdfbox_f1859_0()
{    return featureTag;}
public FeatureTable pdfbox_f1860_0()
{    return featureTable;}
public String pdfbox_f1861_0()
{    return String.format("FeatureRecord[featureTag=%s]", featureTag);}
public int pdfbox_f1862_0()
{    return featureParams;}
public int pdfbox_f1863_0()
{    return lookupIndexCount;}
public int[] pdfbox_f1864_0()
{    return lookupListIndices;}
public String pdfbox_f1865_0()
{    return String.format("FeatureTable[lookupListIndiciesCount=%d]", lookupListIndices.length);}
public String pdfbox_f1866_0()
{    return langSysTag;}
public LangSysTable pdfbox_f1867_0()
{    return langSysTable;}
public String pdfbox_f1868_0()
{    return String.format("LangSysRecord[langSysTag=%s]", langSysTag);}
public int pdfbox_f1869_0()
{    return lookupOrder;}
public int pdfbox_f1870_0()
{    return requiredFeatureIndex;}
public int pdfbox_f1871_0()
{    return featureIndexCount;}
public int[] pdfbox_f1872_0()
{    return featureIndices;}
public String pdfbox_f1873_0()
{    return String.format("LangSysTable[requiredFeatureIndex=%d]", requiredFeatureIndex);}
public int pdfbox_f1874_0()
{    return lookupCount;}
public LookupTable[] pdfbox_f1875_0()
{    return lookups;}
public String pdfbox_f1876_0()
{    return String.format("%s[lookupCount=%d]", LookupListTable.class.getSimpleName(), lookupCount);}
public int pdfbox_f1877_0()
{    return substFormat;}
public CoverageTable pdfbox_f1878_0()
{    return coverageTable;}
public int pdfbox_f1879_0()
{    return lookupType;}
public int pdfbox_f1880_0()
{    return lookupFlag;}
public int pdfbox_f1881_0()
{    return markFilteringSet;}
public LookupSubTable[] pdfbox_f1882_0()
{    return subTables;}
public String pdfbox_f1883_0()
{    return String.format("LookupTable[lookupType=%d,lookupFlag=%d,markFilteringSet=%d]", lookupType, lookupFlag, markFilteringSet);}
public int pdfbox_f1884_0()
{    return startGlyphID;}
public int pdfbox_f1885_0()
{    return endGlyphID;}
public int pdfbox_f1886_0()
{    return startCoverageIndex;}
public String pdfbox_f1887_0()
{    return String.format("RangeRecord[startGlyphID=%d,endGlyphID=%d,startCoverageIndex=%d]", startGlyphID, endGlyphID, startCoverageIndex);}
public String pdfbox_f1888_0()
{    return scriptTag;}
public ScriptTable pdfbox_f1889_0()
{    return scriptTable;}
public String pdfbox_f1890_0()
{    return String.format("ScriptRecord[scriptTag=%s]", scriptTag);}
public LangSysTable pdfbox_f1891_0()
{    return defaultLangSysTable;}
public Map<String, LangSysTable> pdfbox_f1892_0()
{    return langSysTables;}
public String pdfbox_f1893_0()
{    return String.format("ScriptTable[hasDefault=%s,langSysRecordsCount=%d]", defaultLangSysTable != null, langSysTables.size());}
public int pdfbox_f1894_0()
{    return ligatureCount;}
public LigatureTable[] pdfbox_f1895_0()
{    return ligatureTables;}
public String pdfbox_f1896_0()
{    return String.format("%s[ligatureCount=%d]", LigatureSetTable.class.getSimpleName(), ligatureCount);}
public int pdfbox_f1897_0()
{    return ligatureGlyph;}
public int pdfbox_f1898_0()
{    return componentCount;}
public int[] pdfbox_f1899_0()
{    return componentGlyphIDs;}
public String pdfbox_f1900_0()
{    return String.format("%s[ligatureGlyph=%d, componentCount=%d]", LigatureTable.class.getSimpleName(), ligatureGlyph, componentCount);}
public int pdfbox_f1901_0(int gid, int coverageIndex)
{    throw new UnsupportedOperationException();}
public LigatureSetTable[] pdfbox_f1902_0()
{    return ligatureSetTables;}
public String pdfbox_f1903_0()
{    return String.format("%s[substFormat=%d]", LookupTypeLigatureSubstitutionSubstFormat1.class.getSimpleName(), getSubstFormat());}
public int pdfbox_f1904_0(int gid, int coverageIndex)
{    return coverageIndex < 0 ? gid : gid + deltaGlyphID;}
public short pdfbox_f1905_0()
{    return deltaGlyphID;}
public String pdfbox_f1906_0()
{    return String.format("LookupTypeSingleSubstFormat1[substFormat=%d,deltaGlyphID=%d]", getSubstFormat(), deltaGlyphID);}
public int pdfbox_f1907_0(int gid, int coverageIndex)
{    return coverageIndex < 0 ? gid : substituteGlyphIDs[coverageIndex];}
public int[] pdfbox_f1908_0()
{    return substituteGlyphIDs;}
public String pdfbox_f1909_0()
{    return String.format("LookupTypeSingleSubstFormat2[substFormat=%d,substituteGlyphIDs=%s]", getSubstFormat(), Arrays.toString(substituteGlyphIDs));}
public void pdfbox_f1910_0(TrueTypeFontProcessor trueTypeFontProcessor) throws IOException
{    for (int i = 0; i < numFonts; i++) {        TrueTypeFont font = getFontAtIndex(i);        trueTypeFontProcessor.process(font);    }}
private TrueTypeFont pdfbox_f1911_0(int idx) throws IOException
{    stream.seek(fontOffsets[idx]);    TTFParser parser;    if (stream.readTag().equals("OTTO")) {        parser = new OTFParser(false, true);    } else {        parser = new TTFParser(false, true);    }    stream.seek(fontOffsets[idx]);    return parser.parse(new TTCDataStream(stream));}
public TrueTypeFont pdfbox_f1912_0(String name) throws IOException
{    for (int i = 0; i < numFonts; i++) {        TrueTypeFont font = getFontAtIndex(i);        if (font.getName().equals(name)) {            return font;        }    }    return null;}
public void pdfbox_f1913_0() throws IOException
{    stream.close();}
public void pdfbox_f1914_0() throws IOException
{    data.close();}
public float pdfbox_f1915_0()
{    return version;}
 void pdfbox_f1916_0(float versionValue)
{    version = versionValue;}
 void pdfbox_f1917_0(TTFTable table)
{    tables.put(table.getTag(), table);}
public Collection<TTFTable> pdfbox_f1918_0()
{    return tables.values();}
public Map<String, TTFTable> pdfbox_f1919_0()
{    return tables;}
public byte[] pdfbox_f1920_0(TTFTable table) throws IOException
{    synchronized (lockReadtable) {                long currentPosition = data.getCurrentPosition();        data.seek(table.getOffset());                byte[] bytes = data.read((int) table.getLength());                data.seek(currentPosition);        return bytes;    }}
protected TTFTable pdfbox_f1921_0(String tag) throws IOException
{            TTFTable ttfTable = tables.get(tag);    if (ttfTable != null) {        if (!ttfTable.initialized) {            synchronized (lockReadtable) {                if (!ttfTable.initialized) {                    readTable(ttfTable);                }            }        }    }    return ttfTable;}
public NamingTable pdfbox_f1922_0() throws IOException
{    return (NamingTable) getTable(NamingTable.TAG);}
public PostScriptTable pdfbox_f1923_0() throws IOException
{    return (PostScriptTable) getTable(PostScriptTable.TAG);}
public OS2WindowsMetricsTable pdfbox_f1924_0() throws IOException
{    return (OS2WindowsMetricsTable) getTable(OS2WindowsMetricsTable.TAG);}
public MaximumProfileTable pdfbox_f1925_0() throws IOException
{    return (MaximumProfileTable) getTable(MaximumProfileTable.TAG);}
public HeaderTable pdfbox_f1926_0() throws IOException
{    return (HeaderTable) getTable(HeaderTable.TAG);}
public HorizontalHeaderTable pdfbox_f1927_0() throws IOException
{    return (HorizontalHeaderTable) getTable(HorizontalHeaderTable.TAG);}
public HorizontalMetricsTable pdfbox_f1928_0() throws IOException
{    return (HorizontalMetricsTable) getTable(HorizontalMetricsTable.TAG);}
public IndexToLocationTable pdfbox_f1929_0() throws IOException
{    return (IndexToLocationTable) getTable(IndexToLocationTable.TAG);}
public GlyphTable pdfbox_f1930_0() throws IOException
{    return (GlyphTable) getTable(GlyphTable.TAG);}
public CmapTable pdfbox_f1931_0() throws IOException
{    return (CmapTable) getTable(CmapTable.TAG);}
public VerticalHeaderTable pdfbox_f1932_0() throws IOException
{    return (VerticalHeaderTable) getTable(VerticalHeaderTable.TAG);}
public VerticalMetricsTable pdfbox_f1933_0() throws IOException
{    return (VerticalMetricsTable) getTable(VerticalMetricsTable.TAG);}
public VerticalOriginTable pdfbox_f1934_0() throws IOException
{    return (VerticalOriginTable) getTable(VerticalOriginTable.TAG);}
public KerningTable pdfbox_f1935_0() throws IOException
{    return (KerningTable) getTable(KerningTable.TAG);}
public GlyphSubstitutionTable pdfbox_f1936_0() throws IOException
{    return (GlyphSubstitutionTable) getTable(GlyphSubstitutionTable.TAG);}
public InputStream pdfbox_f1937_0() throws IOException
{    return data.getOriginalData();}
public long pdfbox_f1938_0()
{    return data.getOriginalDataSize();}
 void pdfbox_f1939_0(TTFTable table) throws IOException
{        synchronized (data) {                long currentPosition = data.getCurrentPosition();        data.seek(table.getOffset());        table.read(this, data);                data.seek(currentPosition);    }}
public int pdfbox_f1940_0() throws IOException
{    if (numberOfGlyphs == -1) {        MaximumProfileTable maximumProfile = getMaximumProfile();        if (maximumProfile != null) {            numberOfGlyphs = maximumProfile.getNumGlyphs();        } else {                        numberOfGlyphs = 0;        }    }    return numberOfGlyphs;}
public int pdfbox_f1941_0() throws IOException
{    if (unitsPerEm == -1) {        HeaderTable header = getHeader();        if (header != null) {            unitsPerEm = header.getUnitsPerEm();        } else {                        unitsPerEm = 0;        }    }    return unitsPerEm;}
public int pdfbox_f1942_0(int gid) throws IOException
{    HorizontalMetricsTable hmtx = getHorizontalMetrics();    if (hmtx != null) {        return hmtx.getAdvanceWidth(gid);    } else {                return 250;    }}
public int pdfbox_f1943_0(int gid) throws IOException
{    VerticalMetricsTable vmtx = getVerticalMetrics();    if (vmtx != null) {        return vmtx.getAdvanceHeight(gid);    } else {                return 250;    }}
public String pdfbox_f1944_0() throws IOException
{    if (getNaming() != null) {        return getNaming().getPostScriptName();    } else {        return null;    }}
private void pdfbox_f1945_0() throws IOException
{    Map<String, Integer> psnames = postScriptNames;    if (psnames == null) {                PostScriptTable post = getPostScript();        synchronized (lockPSNames) {            psnames = postScriptNames;            if (psnames == null) {                String[] names = post != null ? post.getGlyphNames() : null;                if (names != null) {                    psnames = new HashMap<>(names.length);                    for (int i = 0; i < names.length; i++) {                        psnames.put(names[i], i);                    }                } else {                    psnames = new HashMap<>();                }                postScriptNames = psnames;            }        }    }}
public CmapSubtable pdfbox_f1946_0() throws IOException
{    return getUnicodeCmap(true);}
public CmapSubtable pdfbox_f1947_0(boolean isStrict) throws IOException
{    return getUnicodeCmapImpl(isStrict);}
public CmapLookup pdfbox_f1948_0() throws IOException
{    return getUnicodeCmapLookup(true);}
public CmapLookup pdfbox_f1949_0(boolean isStrict) throws IOException
{    CmapSubtable cmap = getUnicodeCmapImpl(isStrict);    if (!enabledGsubFeatures.isEmpty()) {        GlyphSubstitutionTable table = getGsub();        if (table != null) {            return new SubstitutingCmapLookup(cmap, table, Collections.unmodifiableList(enabledGsubFeatures));        }    }    return cmap;}
private CmapSubtable pdfbox_f1950_0(boolean isStrict) throws IOException
{    CmapTable cmapTable = getCmap();    if (cmapTable == null) {        if (isStrict) {            throw new IOException("The TrueType font " + getName() + " does not contain a 'cmap' table");        } else {            return null;        }    }    CmapSubtable cmap = cmapTable.getSubtable(CmapTable.PLATFORM_UNICODE, CmapTable.ENCODING_UNICODE_2_0_FULL);    if (cmap == null) {        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_WINDOWS, CmapTable.ENCODING_WIN_UNICODE_FULL);    }    if (cmap == null) {        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_UNICODE, CmapTable.ENCODING_UNICODE_2_0_BMP);    }    if (cmap == null) {        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_WINDOWS, CmapTable.ENCODING_WIN_UNICODE_BMP);    }    if (cmap == null) {                        cmap = cmapTable.getSubtable(CmapTable.PLATFORM_WINDOWS, CmapTable.ENCODING_WIN_SYMBOL);    }    if (cmap == null) {        if (isStrict) {            throw new IOException("The TrueType font does not contain a Unicode cmap");        } else if (cmapTable.getCmaps().length > 0) {                        cmap = cmapTable.getCmaps()[0];        }    }    return cmap;}
public int pdfbox_f1951_0(String name) throws IOException
{        readPostScriptNames();    if (postScriptNames != null) {        Integer gid = postScriptNames.get(name);        if (gid != null && gid > 0 && gid < getMaximumProfile().getNumGlyphs()) {            return gid;        }    }        int uni = parseUniName(name);    if (uni > -1) {        CmapLookup cmap = getUnicodeCmapLookup(false);        return cmap.getGlyphId(uni);    }    return 0;}
public GsubData pdfbox_f1952_0() throws IOException
{    GlyphSubstitutionTable table = getGsub();    if (table == null) {        return GsubData.NO_DATA_FOUND;    }    return table.getGsubData();}
private int pdfbox_f1953_0(String name) throws IOException
{    if (name.startsWith("uni") && name.length() == 7) {        int nameLength = name.length();        StringBuilder uniStr = new StringBuilder();        try {            for (int chPos = 3; chPos + 4 <= nameLength; chPos += 4) {                int codePoint = Integer.parseInt(name.substring(chPos, chPos + 4), 16);                if (                codePoint <= 0xD7FF || codePoint >= 0xE000) {                    uniStr.append((char) codePoint);                }            }            String unicode = uniStr.toString();            if (unicode.length() == 0) {                return -1;            }            return unicode.codePointAt(0);        } catch (NumberFormatException e) {            return -1;        }    }    return -1;}
public GeneralPath pdfbox_f1954_0(String name) throws IOException
{    int gid = nameToGID(name);        GlyphData glyph = getGlyph().getGlyph(gid);    if (glyph == null) {        return new GeneralPath();    } else {                return glyph.getPath();    }}
public float pdfbox_f1955_0(String name) throws IOException
{    Integer gid = nameToGID(name);    return getAdvanceWidth(gid);}
public boolean pdfbox_f1956_0(String name) throws IOException
{    return nameToGID(name) != 0;}
public BoundingBox pdfbox_f1957_0() throws IOException
{    short xMin = getHeader().getXMin();    short xMax = getHeader().getXMax();    short yMin = getHeader().getYMin();    short yMax = getHeader().getYMax();    float scale = 1000f / getUnitsPerEm();    return new BoundingBox(xMin * scale, yMin * scale, xMax * scale, yMax * scale);}
public List<Number> pdfbox_f1958_0() throws IOException
{    float scale = 1000f / getUnitsPerEm();    return Arrays.<Number>asList(0.001f * scale, 0, 0, 0.001f * scale, 0, 0);}
public void pdfbox_f1959_0(String featureTag)
{    enabledGsubFeatures.add(featureTag);}
public void pdfbox_f1960_0(String featureTag)
{    enabledGsubFeatures.remove(featureTag);}
public void pdfbox_f1961_0()
{    enableGsubFeature("vrt2");    enableGsubFeature("vert");}
public String pdfbox_f1962_1()
{    try {        if (getNaming() != null) {            return getNaming().getPostScriptName();        } else {            return "(null)";        }    } catch (IOException e) {                return "(null - " + e.getMessage() + ")";    }}
public int pdfbox_f1963_0() throws IOException
{    return stream.read();}
public long pdfbox_f1964_0() throws IOException
{    return stream.readLong();}
public int pdfbox_f1965_0() throws IOException
{    return stream.readUnsignedShort();}
public short pdfbox_f1966_0() throws IOException
{    return stream.readSignedShort();}
public void pdfbox_f1967_0() throws IOException
{}
public void pdfbox_f1968_0(long pos) throws IOException
{    stream.seek(pos);}
public int pdfbox_f1969_0(byte[] b, int off, int len) throws IOException
{    return stream.read(b, off, len);}
public long pdfbox_f1970_0() throws IOException
{    return stream.getCurrentPosition();}
public InputStream pdfbox_f1971_0() throws IOException
{    return stream.getOriginalData();}
public long pdfbox_f1972_0()
{    return stream.getOriginalDataSize();}
public float pdfbox_f1973_0() throws IOException
{    float retval = 0;    retval = readSignedShort();    retval += (readUnsignedShort() / 65536.0);    return retval;}
public String pdfbox_f1974_0(int length) throws IOException
{    return readString(length, Charsets.ISO_8859_1);}
public String pdfbox_f1975_0(int length, String charset) throws IOException
{    byte[] buffer = read(length);    return new String(buffer, charset);}
public String pdfbox_f1976_0(int length, Charset charset) throws IOException
{    byte[] buffer = read(length);    return new String(buffer, charset);}
public int pdfbox_f1977_0() throws IOException
{    int signedByte = read();    return signedByte <= 127 ? signedByte : signedByte - 256;}
public int pdfbox_f1978_0() throws IOException
{    int unsignedByte = read();    if (unsignedByte == -1) {        throw new EOFException("premature EOF");    }    return unsignedByte;}
public long pdfbox_f1979_0() throws IOException
{    long byte1 = read();    long byte2 = read();    long byte3 = read();    long byte4 = read();    if (byte4 < 0) {        throw new EOFException();    }    return (byte1 << 24) + (byte2 << 16) + (byte3 << 8) + (byte4 << 0);}
public int[] pdfbox_f1980_0(int length) throws IOException
{    int[] array = new int[length];    for (int i = 0; i < length; i++) {        array[i] = read();    }    return array;}
public int[] pdfbox_f1981_0(int length) throws IOException
{    int[] array = new int[length];    for (int i = 0; i < length; i++) {        array[i] = readUnsignedShort();    }    return array;}
public Calendar pdfbox_f1982_0() throws IOException
{    long secondsSince1904 = readLong();    Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("UTC"));    cal.set(1904, 0, 1, 0, 0, 0);    cal.set(Calendar.MILLISECOND, 0);    long millisFor1904 = cal.getTimeInMillis();    millisFor1904 += (secondsSince1904 * 1000);    cal.setTimeInMillis(millisFor1904);    return cal;}
public String pdfbox_f1983_0() throws IOException
{    return new String(read(4), Charsets.US_ASCII);}
public byte[] pdfbox_f1984_0(int numberOfBytes) throws IOException
{    byte[] data = new byte[numberOfBytes];    int amountRead = 0;    int totalAmountRead = 0;        while (totalAmountRead < numberOfBytes && (amountRead = read(data, totalAmountRead, numberOfBytes - totalAmountRead)) != -1) {        totalAmountRead += amountRead;    }    if (totalAmountRead == numberOfBytes) {        return data;    } else {        throw new IOException("Unexpected end of TTF stream reached");    }}
public TrueTypeFont pdfbox_f1985_0(String ttfFile) throws IOException
{    return parse(new File(ttfFile));}
public TrueTypeFont pdfbox_f1986_0(File ttfFile) throws IOException
{    RAFDataStream raf = new RAFDataStream(ttfFile, "r");    try {        return parse(raf);    } catch (IOException ex) {                raf.close();        throw ex;    }}
public TrueTypeFont pdfbox_f1987_0(InputStream inputStream) throws IOException
{    return parse(new MemoryTTFDataStream(inputStream));}
public TrueTypeFont pdfbox_f1988_0(InputStream inputStream) throws IOException
{    this.isEmbedded = true;    return parse(new MemoryTTFDataStream(inputStream));}
 TrueTypeFont pdfbox_f1989_0(TTFDataStream raf) throws IOException
{    TrueTypeFont font = newFont(raf);    font.setVersion(raf.read32Fixed());    int numberOfTables = raf.readUnsignedShort();    int searchRange = raf.readUnsignedShort();    int entrySelector = raf.readUnsignedShort();    int rangeShift = raf.readUnsignedShort();    for (int i = 0; i < numberOfTables; i++) {        TTFTable table = readTableDirectory(font, raf);                if (table != null) {            font.addTable(table);        }    }        if (!parseOnDemandOnly) {        parseTables(font);    }    return font;}
 TrueTypeFont pdfbox_f1990_0(TTFDataStream raf)
{    return new TrueTypeFont(raf);}
private void pdfbox_f1991_0(TrueTypeFont font) throws IOException
{    for (TTFTable table : font.getTables()) {        if (!table.getInitialized()) {            font.readTable(table);        }    }    boolean isPostScript = allowCFF() && font.tables.containsKey(CFFTable.TAG);    HeaderTable head = font.getHeader();    if (head == null) {        throw new IOException("head is mandatory");    }    HorizontalHeaderTable hh = font.getHorizontalHeader();    if (hh == null) {        throw new IOException("hhead is mandatory");    }    MaximumProfileTable maxp = font.getMaximumProfile();    if (maxp == null) {        throw new IOException("maxp is mandatory");    }    PostScriptTable post = font.getPostScript();    if (post == null && !isEmbedded) {                throw new IOException("post is mandatory");    }    if (!isPostScript) {        IndexToLocationTable loc = font.getIndexToLocation();        if (loc == null) {            throw new IOException("loca is mandatory");        }        if (font.getGlyph() == null) {            throw new IOException("glyf is mandatory");        }    }    if (font.getNaming() == null && !isEmbedded) {        throw new IOException("name is mandatory");    }    if (font.getHorizontalMetrics() == null) {        throw new IOException("hmtx is mandatory");    }    if (!isEmbedded && font.getCmap() == null) {        throw new IOException("cmap is mandatory");    }}
protected boolean pdfbox_f1992_0()
{    return false;}
private TTFTable pdfbox_f1993_0(TrueTypeFont font, TTFDataStream raf) throws IOException
{    TTFTable table;    String tag = raf.readString(4);    switch(tag) {        case CmapTable.TAG:            table = new CmapTable(font);            break;        case GlyphTable.TAG:            table = new GlyphTable(font);            break;        case HeaderTable.TAG:            table = new HeaderTable(font);            break;        case HorizontalHeaderTable.TAG:            table = new HorizontalHeaderTable(font);            break;        case HorizontalMetricsTable.TAG:            table = new HorizontalMetricsTable(font);            break;        case IndexToLocationTable.TAG:            table = new IndexToLocationTable(font);            break;        case MaximumProfileTable.TAG:            table = new MaximumProfileTable(font);            break;        case NamingTable.TAG:            table = new NamingTable(font);            break;        case OS2WindowsMetricsTable.TAG:            table = new OS2WindowsMetricsTable(font);            break;        case PostScriptTable.TAG:            table = new PostScriptTable(font);            break;        case DigitalSignatureTable.TAG:            table = new DigitalSignatureTable(font);            break;        case KerningTable.TAG:            table = new KerningTable(font);            break;        case VerticalHeaderTable.TAG:            table = new VerticalHeaderTable(font);            break;        case VerticalMetricsTable.TAG:            table = new VerticalMetricsTable(font);            break;        case VerticalOriginTable.TAG:            table = new VerticalOriginTable(font);            break;        case GlyphSubstitutionTable.TAG:            table = new GlyphSubstitutionTable(font);            break;        default:            table = readTable(font, tag);            break;    }    table.setTag(tag);    table.setCheckSum(raf.readUnsignedInt());    table.setOffset(raf.readUnsignedInt());    table.setLength(raf.readUnsignedInt());        if (table.getLength() == 0 && !tag.equals(GlyphTable.TAG)) {        return null;    }    return table;}
protected TTFTable pdfbox_f1994_0(TrueTypeFont font, String tag)
{        return new TTFTable(font);}
public void pdfbox_f1995_0(String prefix)
{    this.prefix = prefix;}
public void pdfbox_f1996_0(int unicode)
{    int gid = unicodeCmap.getGlyphId(unicode);    if (gid != 0) {        uniToGID.put(unicode, gid);        glyphIds.add(gid);    }}
public void pdfbox_f1997_0(Set<Integer> unicodeSet)
{    unicodeSet.forEach(this::add);}
public Map<Integer, Integer> pdfbox_f1998_0() throws IOException
{    addCompoundReferences();    Map<Integer, Integer> newToOld = new HashMap<>();    int newGID = 0;    for (int oldGID : glyphIds) {        newToOld.put(newGID, oldGID);        newGID++;    }    return newToOld;}
private long pdfbox_f1999_0(DataOutputStream out, int nTables) throws IOException
{    out.writeInt(0x00010000);    out.writeShort(nTables);    int mask = Integer.highestOneBit(nTables);    int searchRange = mask * 16;    out.writeShort(searchRange);    int entrySelector = log2(mask);    out.writeShort(entrySelector);        int last = 16 * nTables - searchRange;    out.writeShort(last);    return 0x00010000L + toUInt32(nTables, searchRange) + toUInt32(entrySelector, last);}
private long pdfbox_f2000_0(DataOutputStream out, String tag, long offset, byte[] bytes) throws IOException
{    long checksum = 0;    for (int nup = 0, n = bytes.length; nup < n; nup++) {        checksum += (bytes[nup] & 0xffL) << 24 - nup % 4 * 8;    }    checksum &= 0xffffffffL;    byte[] tagbytes = tag.getBytes("US-ASCII");    out.write(tagbytes, 0, 4);    out.writeInt((int) checksum);    out.writeInt((int) offset);    out.writeInt(bytes.length);        return toUInt32(tagbytes) + checksum + checksum + offset + bytes.length;}
private void pdfbox_f2001_0(OutputStream os, byte[] bytes) throws IOException
{    int n = bytes.length;    os.write(bytes);    if (n % 4 != 0) {        os.write(PAD_BUF, 0, 4 - n % 4);    }}
private byte[] pdfbox_f2002_0() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    HeaderTable h = ttf.getHeader();    writeFixed(out, h.getVersion());    writeFixed(out, h.getFontRevision());        writeUint32(out, 0);    writeUint32(out, h.getMagicNumber());    writeUint16(out, h.getFlags());    writeUint16(out, h.getUnitsPerEm());    writeLongDateTime(out, h.getCreated());    writeLongDateTime(out, h.getModified());    writeSInt16(out, h.getXMin());    writeSInt16(out, h.getYMin());    writeSInt16(out, h.getXMax());    writeSInt16(out, h.getYMax());    writeUint16(out, h.getMacStyle());    writeUint16(out, h.getLowestRecPPEM());    writeSInt16(out, h.getFontDirectionHint());            writeSInt16(out, (short) 1);    writeSInt16(out, h.getGlyphDataFormat());    out.flush();    return bos.toByteArray();}
private byte[] pdfbox_f2003_0() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    HorizontalHeaderTable h = ttf.getHorizontalHeader();    writeFixed(out, h.getVersion());    writeSInt16(out, h.getAscender());    writeSInt16(out, h.getDescender());    writeSInt16(out, h.getLineGap());    writeUint16(out, h.getAdvanceWidthMax());    writeSInt16(out, h.getMinLeftSideBearing());    writeSInt16(out, h.getMinRightSideBearing());    writeSInt16(out, h.getXMaxExtent());    writeSInt16(out, h.getCaretSlopeRise());    writeSInt16(out, h.getCaretSlopeRun());        writeSInt16(out, h.getReserved1());    writeSInt16(out, h.getReserved2());    writeSInt16(out, h.getReserved3());    writeSInt16(out, h.getReserved4());    writeSInt16(out, h.getReserved5());    writeSInt16(out, h.getMetricDataFormat());            int hmetrics = glyphIds.subSet(0, h.getNumberOfHMetrics()).size();    if (glyphIds.last() >= h.getNumberOfHMetrics() && !glyphIds.contains(h.getNumberOfHMetrics() - 1)) {        ++hmetrics;    }    writeUint16(out, hmetrics);    out.flush();    return bos.toByteArray();}
private boolean pdfbox_f2004_0(NameRecord nr)
{    return nr.getPlatformId() == NameRecord.PLATFORM_WINDOWS && nr.getPlatformEncodingId() == NameRecord.ENCODING_WINDOWS_UNICODE_BMP && nr.getLanguageId() == NameRecord.LANGUGAE_WINDOWS_EN_US && nr.getNameId() >= 0 && nr.getNameId() < 7;}
private byte[] pdfbox_f2005_0() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    NamingTable name = ttf.getNaming();    if (name == null || keepTables != null && !keepTables.contains("name")) {        return null;    }    List<NameRecord> nameRecords = name.getNameRecords();    int numRecords = (int) nameRecords.stream().filter(this::shouldCopyNameRecord).count();    writeUint16(out, 0);    writeUint16(out, numRecords);    writeUint16(out, 2 * 3 + 2 * 6 * numRecords);    if (numRecords == 0) {        return null;    }    byte[][] names = new byte[numRecords][];    int j = 0;    for (NameRecord record : nameRecords) {        if (shouldCopyNameRecord(record)) {            int platform = record.getPlatformId();            int encoding = record.getPlatformEncodingId();            String charset = "ISO-8859-1";            if (platform == CmapTable.PLATFORM_WINDOWS && encoding == CmapTable.ENCODING_WIN_UNICODE_BMP) {                charset = "UTF-16BE";            } else if (            platform == 2) {                if (                encoding == 0) {                    charset = "US-ASCII";                } else if (                encoding == 1) {                                        charset = "UTF16-BE";                } else if (                encoding == 2) {                    charset = "ISO-8859-1";                }            }            String value = record.getString();            if (record.getNameId() == 6 && prefix != null) {                value = prefix + value;            }            names[j] = value.getBytes(charset);            j++;        }    }    int offset = 0;    j = 0;    for (NameRecord nr : nameRecords) {        if (shouldCopyNameRecord(nr)) {            writeUint16(out, nr.getPlatformId());            writeUint16(out, nr.getPlatformEncodingId());            writeUint16(out, nr.getLanguageId());            writeUint16(out, nr.getNameId());            writeUint16(out, names[j].length);            writeUint16(out, offset);            offset += names[j].length;            j++;        }    }    for (int i = 0; i < numRecords; i++) {        out.write(names[i]);    }    out.flush();    return bos.toByteArray();}
private byte[] pdfbox_f2006_0() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    MaximumProfileTable p = ttf.getMaximumProfile();    writeFixed(out, 1.0);    writeUint16(out, glyphIds.size());    writeUint16(out, p.getMaxPoints());    writeUint16(out, p.getMaxContours());    writeUint16(out, p.getMaxCompositePoints());    writeUint16(out, p.getMaxCompositeContours());    writeUint16(out, p.getMaxZones());    writeUint16(out, p.getMaxTwilightPoints());    writeUint16(out, p.getMaxStorage());    writeUint16(out, p.getMaxFunctionDefs());    writeUint16(out, p.getMaxInstructionDefs());    writeUint16(out, p.getMaxStackElements());    writeUint16(out, p.getMaxSizeOfInstructions());    writeUint16(out, p.getMaxComponentElements());    writeUint16(out, p.getMaxComponentDepth());    out.flush();    return bos.toByteArray();}
private byte[] pdfbox_f2007_0() throws IOException
{    OS2WindowsMetricsTable os2 = ttf.getOS2Windows();    if (os2 == null || uniToGID.isEmpty() || keepTables != null && !keepTables.contains("OS/2")) {        return null;    }    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    writeUint16(out, os2.getVersion());    writeSInt16(out, os2.getAverageCharWidth());    writeUint16(out, os2.getWeightClass());    writeUint16(out, os2.getWidthClass());    writeSInt16(out, os2.getFsType());    writeSInt16(out, os2.getSubscriptXSize());    writeSInt16(out, os2.getSubscriptYSize());    writeSInt16(out, os2.getSubscriptXOffset());    writeSInt16(out, os2.getSubscriptYOffset());    writeSInt16(out, os2.getSuperscriptXSize());    writeSInt16(out, os2.getSuperscriptYSize());    writeSInt16(out, os2.getSuperscriptXOffset());    writeSInt16(out, os2.getSuperscriptYOffset());    writeSInt16(out, os2.getStrikeoutSize());    writeSInt16(out, os2.getStrikeoutPosition());    writeSInt16(out, (short) os2.getFamilyClass());    out.write(os2.getPanose());    writeUint32(out, 0);    writeUint32(out, 0);    writeUint32(out, 0);    writeUint32(out, 0);    out.write(os2.getAchVendId().getBytes("US-ASCII"));    writeUint16(out, os2.getFsSelection());    writeUint16(out, uniToGID.firstKey());    writeUint16(out, uniToGID.lastKey());    writeUint16(out, os2.getTypoAscender());    writeUint16(out, os2.getTypoDescender());    writeUint16(out, os2.getTypoLineGap());    writeUint16(out, os2.getWinAscent());    writeUint16(out, os2.getWinDescent());    out.flush();    return bos.toByteArray();}
private byte[] pdfbox_f2008_0(long[] newOffsets) throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);    for (long offset : newOffsets) {        writeUint32(out, offset);    }    out.flush();    return bos.toByteArray();}
private void pdfbox_f2009_1() throws IOException
{    if (hasAddedCompoundReferences) {        return;    }    hasAddedCompoundReferences = true;    boolean hasNested;    do {        GlyphTable g = ttf.getGlyph();        long[] offsets = ttf.getIndexToLocation().getOffsets();        InputStream is = ttf.getOriginalData();        Set<Integer> glyphIdsToAdd = null;        try {            long isResult = is.skip(g.getOffset());            if (Long.compare(isResult, g.getOffset()) != 0) {                            }            long lastOff = 0L;            for (Integer glyphId : glyphIds) {                long offset = offsets[glyphId];                long len = offsets[glyphId + 1] - offset;                isResult = is.skip(offset - lastOff);                if (Long.compare(isResult, offset - lastOff) != 0) {                                    }                byte[] buf = new byte[(int) len];                isResult = is.read(buf);                if (Long.compare(isResult, len) != 0) {                                    }                                if (buf.length >= 2 && buf[0] == -1 && buf[1] == -1) {                    int off = 2 * 5;                    int flags;                    do {                        flags = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                        off += 2;                        int ogid = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                        if (!glyphIds.contains(ogid)) {                            if (glyphIdsToAdd == null) {                                glyphIdsToAdd = new TreeSet<>();                            }                            glyphIdsToAdd.add(ogid);                        }                        off += 2;                                                if ((flags & 1 << 0) != 0) {                            off += 2 * 2;                        } else {                            off += 2;                        }                                                if ((flags & 1 << 7) != 0) {                            off += 2 * 4;                        } else                         if ((flags & 1 << 6) != 0) {                            off += 2 * 2;                        } else                         if ((flags & 1 << 3) != 0) {                            off += 2;                        }                    } while (                    (flags & 1 << 5) != 0);                }                lastOff = offsets[glyphId + 1];            }        } finally {            is.close();        }        if (glyphIdsToAdd != null) {            glyphIds.addAll(glyphIdsToAdd);        }        hasNested = glyphIdsToAdd != null;    } while (hasNested);}
private byte[] pdfbox_f2010_1(long[] newOffsets) throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    GlyphTable g = ttf.getGlyph();    long[] offsets = ttf.getIndexToLocation().getOffsets();    try (InputStream is = ttf.getOriginalData()) {        long isResult = is.skip(g.getOffset());        if (Long.compare(isResult, g.getOffset()) != 0) {                    }                long prevEnd = 0;                long newOffset = 0;                int newGid = 0;                for (Integer gid : glyphIds) {            long offset = offsets[gid];            long length = offsets[gid + 1] - offset;            newOffsets[newGid++] = newOffset;            isResult = is.skip(offset - prevEnd);            if (Long.compare(isResult, offset - prevEnd) != 0) {                            }            byte[] buf = new byte[(int) length];            isResult = is.read(buf);            if (Long.compare(isResult, length) != 0) {                            }                        if (buf.length >= 2 && buf[0] == -1 && buf[1] == -1) {                                int off = 2 * 5;                int flags;                do {                                        flags = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                    off += 2;                                        int componentGid = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                    if (!glyphIds.contains(componentGid)) {                        glyphIds.add(componentGid);                    }                    int newComponentGid = getNewGlyphId(componentGid);                    buf[off] = (byte) (newComponentGid >>> 8);                    buf[off + 1] = (byte) newComponentGid;                    off += 2;                                        if ((flags & 1 << 0) != 0) {                        off += 2 * 2;                    } else {                        off += 2;                    }                                        if ((flags & 1 << 7) != 0) {                        off += 2 * 4;                    } else                     if ((flags & 1 << 6) != 0) {                        off += 2 * 2;                    } else                     if ((flags & 1 << 3) != 0) {                        off += 2;                    }                } while (                (flags & 1 << 5) != 0);                                if ((flags & 0x0100) == 0x0100) {                                        int numInstr = (buf[off] & 0xff) << 8 | buf[off + 1] & 0xff;                    off += 2;                                        off += numInstr;                }                                bos.write(buf, 0, off);                                newOffset += off;            } else if (buf.length > 0) {                                bos.write(buf, 0, buf.length);                                newOffset += buf.length;            }                        if (newOffset % 4 != 0) {                int len = 4 - (int) (newOffset % 4);                bos.write(PAD_BUF, 0, len);                newOffset += len;            }            prevEnd = offset + length;        }        newOffsets[newGid++] = newOffset;    }    return bos.toByteArray();}
private int pdfbox_f2011_0(Integer oldGid)
{    return glyphIds.headSet(oldGid).size();}
private byte[] pdfbox_f2012_0() throws IOException
{    if (ttf.getCmap() == null || uniToGID.isEmpty() || keepTables != null && !keepTables.contains("cmap")) {        return null;    }    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);            writeUint16(out, 0);        writeUint16(out, 1);            writeUint16(out, CmapTable.PLATFORM_WINDOWS);        writeUint16(out, CmapTable.ENCODING_WIN_UNICODE_BMP);        writeUint32(out, 4 * 2 + 4);        Iterator<Entry<Integer, Integer>> it = uniToGID.entrySet().iterator();    Entry<Integer, Integer> lastChar = it.next();    Entry<Integer, Integer> prevChar = lastChar;    int lastGid = getNewGlyphId(lastChar.getValue());        int[] startCode = new int[uniToGID.size() + 1];    int[] endCode = new int[uniToGID.size() + 1];    int[] idDelta = new int[uniToGID.size() + 1];    int segCount = 0;    while (it.hasNext()) {        Entry<Integer, Integer> curChar2Gid = it.next();        int curGid = getNewGlyphId(curChar2Gid.getValue());                if (curChar2Gid.getKey() > 0xFFFF) {            throw new UnsupportedOperationException("non-BMP Unicode character");        }        if (curChar2Gid.getKey() != prevChar.getKey() + 1 || curGid - lastGid != curChar2Gid.getKey() - lastChar.getKey()) {            if (lastGid != 0) {                                                startCode[segCount] = lastChar.getKey();                endCode[segCount] = prevChar.getKey();                idDelta[segCount] = lastGid - lastChar.getKey();                segCount++;            } else if (!lastChar.getKey().equals(prevChar.getKey())) {                                startCode[segCount] = lastChar.getKey() + 1;                endCode[segCount] = prevChar.getKey();                idDelta[segCount] = lastGid - lastChar.getKey();                segCount++;            }            lastGid = curGid;            lastChar = curChar2Gid;        }        prevChar = curChar2Gid;    }        startCode[segCount] = lastChar.getKey();    endCode[segCount] = prevChar.getKey();    idDelta[segCount] = lastGid - lastChar.getKey();    segCount++;        startCode[segCount] = 0xffff;    endCode[segCount] = 0xffff;    idDelta[segCount] = 1;    segCount++;        int searchRange = 2 * (int) Math.pow(2, log2(segCount));        writeUint16(out, 4);        writeUint16(out, 8 * 2 + segCount * 4 * 2);        writeUint16(out, 0);        writeUint16(out, segCount * 2);        writeUint16(out, searchRange);        writeUint16(out, log2(searchRange / 2));        writeUint16(out, 2 * segCount - searchRange);        for (int i = 0; i < segCount; i++) {        writeUint16(out, endCode[i]);    }        writeUint16(out, 0);        for (int i = 0; i < segCount; i++) {        writeUint16(out, startCode[i]);    }        for (int i = 0; i < segCount; i++) {        writeUint16(out, idDelta[i]);    }    for (int i = 0; i < segCount; i++) {        writeUint16(out, 0);    }    return bos.toByteArray();}
private byte[] pdfbox_f2013_0() throws IOException
{    PostScriptTable post = ttf.getPostScript();    if (post == null || keepTables != null && !keepTables.contains("post")) {        return null;    }    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bos);        writeFixed(out, 2.0);    writeFixed(out, post.getItalicAngle());    writeSInt16(out, post.getUnderlinePosition());    writeSInt16(out, post.getUnderlineThickness());    writeUint32(out, post.getIsFixedPitch());    writeUint32(out, post.getMinMemType42());    writeUint32(out, post.getMaxMemType42());    writeUint32(out, post.getMinMemType1());    writeUint32(out, post.getMaxMemType1());            writeUint16(out, glyphIds.size());        Map<String, Integer> names = new LinkedHashMap<>();    for (int gid : glyphIds) {        String name = post.getName(gid);        Integer macId = WGL4Names.MAC_GLYPH_NAMES_INDICES.get(name);        if (macId != null) {                        writeUint16(out, macId);        } else {                        Integer ordinal = names.get(name);            if (ordinal == null) {                ordinal = names.size();                names.put(name, ordinal);            }            writeUint16(out, 258 + ordinal);        }    }        for (String name : names.keySet()) {        byte[] buf = name.getBytes(Charset.forName("US-ASCII"));        writeUint8(out, buf.length);        out.write(buf);    }    out.flush();    return bos.toByteArray();}
private byte[] pdfbox_f2014_1() throws IOException
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    HorizontalHeaderTable h = ttf.getHorizontalHeader();    HorizontalMetricsTable hm = ttf.getHorizontalMetrics();    InputStream is = ttf.getOriginalData();        int lastgid = h.getNumberOfHMetrics() - 1;        boolean needLastGidWidth = false;    if (glyphIds.last() > lastgid && !glyphIds.contains(lastgid)) {        needLastGidWidth = true;    }    try {        long isResult = is.skip(hm.getOffset());        if (Long.compare(isResult, hm.getOffset()) != 0) {                    }        long lastOffset = 0;        for (Integer glyphId : glyphIds) {                        long offset;            if (glyphId <= lastgid) {                                offset = glyphId * 4;                lastOffset = copyBytes(is, bos, offset, lastOffset, 4);            } else {                if (needLastGidWidth) {                                                            needLastGidWidth = false;                    offset = lastgid * 4;                    lastOffset = copyBytes(is, bos, offset, lastOffset, 2);                                }                                offset = h.getNumberOfHMetrics() * 4 + (glyphId - h.getNumberOfHMetrics()) * 2;                lastOffset = copyBytes(is, bos, offset, lastOffset, 2);            }        }        return bos.toByteArray();    } finally {        is.close();    }}
private long pdfbox_f2015_0(InputStream is, OutputStream os, long newOffset, long lastOffset, int count) throws IOException
{        long nskip = newOffset - lastOffset;    if (nskip != is.skip(nskip)) {        throw new EOFException("Unexpected EOF exception parsing glyphId of hmtx table.");    }    byte[] buf = new byte[count];    if (count != is.read(buf, 0, count)) {        throw new EOFException("Unexpected EOF exception parsing glyphId of hmtx table.");    }    os.write(buf, 0, count);    return newOffset + count;}
public void pdfbox_f2016_1(OutputStream os) throws IOException
{    if (glyphIds.isEmpty() && uniToGID.isEmpty()) {            }    addCompoundReferences();    try (DataOutputStream out = new DataOutputStream(os)) {        long[] newLoca = new long[glyphIds.size() + 1];                byte[] head = buildHeadTable();        byte[] hhea = buildHheaTable();        byte[] maxp = buildMaxpTable();        byte[] name = buildNameTable();        byte[] os2 = buildOS2Table();        byte[] glyf = buildGlyfTable(newLoca);        byte[] loca = buildLocaTable(newLoca);        byte[] cmap = buildCmapTable();        byte[] hmtx = buildHmtxTable();        byte[] post = buildPostTable();                Map<String, byte[]> tables = new TreeMap<>();        if (os2 != null) {            tables.put("OS/2", os2);        }        if (cmap != null) {            tables.put("cmap", cmap);        }        tables.put("glyf", glyf);        tables.put("head", head);        tables.put("hhea", hhea);        tables.put("hmtx", hmtx);        tables.put("loca", loca);        tables.put("maxp", maxp);        if (name != null) {            tables.put("name", name);        }        if (post != null) {            tables.put("post", post);        }                for (Map.Entry<String, TTFTable> entry : ttf.getTableMap().entrySet()) {            String tag = entry.getKey();            TTFTable table = entry.getValue();            if (!tables.containsKey(tag) && (keepTables == null || keepTables.contains(tag))) {                tables.put(tag, ttf.getTableBytes(table));            }        }                long checksum = writeFileHeader(out, tables.size());        long offset = 12L + 16L * tables.size();        for (Map.Entry<String, byte[]> entry : tables.entrySet()) {            checksum += writeTableHeader(out, entry.getKey(), offset, entry.getValue());            offset += (entry.getValue().length + 3) / 4 * 4;        }        checksum = 0xB1B0AFBAL - (checksum & 0xffffffffL);                head[8] = (byte) (checksum >>> 24);        head[9] = (byte) (checksum >>> 16);        head[10] = (byte) (checksum >>> 8);        head[11] = (byte) checksum;        for (byte[] bytes : tables.values()) {            writeTableBody(out, bytes);        }    }}
private void pdfbox_f2017_0(DataOutputStream out, double f) throws IOException
{    double ip = Math.floor(f);    double fp = (f - ip) * 65536.0;    out.writeShort((int) ip);    out.writeShort((int) fp);}
private void pdfbox_f2018_0(DataOutputStream out, long l) throws IOException
{    out.writeInt((int) l);}
private void pdfbox_f2019_0(DataOutputStream out, int i) throws IOException
{    out.writeShort(i);}
private void pdfbox_f2020_0(DataOutputStream out, short i) throws IOException
{    out.writeShort(i);}
private void pdfbox_f2021_0(DataOutputStream out, int i) throws IOException
{    out.writeByte(i);}
private void pdfbox_f2022_0(DataOutputStream out, Calendar calendar) throws IOException
{        Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("UTC"));    cal.set(1904, 0, 1, 0, 0, 0);    cal.set(Calendar.MILLISECOND, 0);    long millisFor1904 = cal.getTimeInMillis();    long secondsSince1904 = (calendar.getTimeInMillis() - millisFor1904) / 1000L;    out.writeLong(secondsSince1904);}
private long pdfbox_f2023_0(int high, int low)
{    return (high & 0xffffL) << 16 | low & 0xffffL;}
private long pdfbox_f2024_0(byte[] bytes)
{    return (bytes[0] & 0xffL) << 24 | (bytes[1] & 0xffL) << 16 | (bytes[2] & 0xffL) << 8 | bytes[3] & 0xffL;}
private int pdfbox_f2025_0(int num)
{    return (int) Math.round(Math.log(num) / Math.log(2));}
public void pdfbox_f2026_0(Set<Integer> allGlyphIds)
{    glyphIds.addAll(allGlyphIds);}
public long pdfbox_f2027_0()
{    return checkSum;}
 void pdfbox_f2028_0(long checkSumValue)
{    this.checkSum = checkSumValue;}
public long pdfbox_f2029_0()
{    return length;}
 void pdfbox_f2030_0(long lengthValue)
{    this.length = lengthValue;}
public long pdfbox_f2031_0()
{    return offset;}
 void pdfbox_f2032_0(long offsetValue)
{    this.offset = offsetValue;}
public String pdfbox_f2033_0()
{    return tag;}
 void pdfbox_f2034_0(String tagValue)
{    this.tag = tagValue;}
public boolean pdfbox_f2035_0()
{    return initialized;}
 void pdfbox_f2036_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{}
 void pdfbox_f2037_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    ascender = data.readSignedShort();    descender = data.readSignedShort();    lineGap = data.readSignedShort();    advanceHeightMax = data.readUnsignedShort();    minTopSideBearing = data.readSignedShort();    minBottomSideBearing = data.readSignedShort();    yMaxExtent = data.readSignedShort();    caretSlopeRise = data.readSignedShort();    caretSlopeRun = data.readSignedShort();    caretOffset = data.readSignedShort();    reserved1 = data.readSignedShort();    reserved2 = data.readSignedShort();    reserved3 = data.readSignedShort();    reserved4 = data.readSignedShort();    metricDataFormat = data.readSignedShort();    numberOfVMetrics = data.readUnsignedShort();    initialized = true;}
public int pdfbox_f2038_0()
{    return advanceHeightMax;}
public short pdfbox_f2039_0()
{    return ascender;}
public short pdfbox_f2040_0()
{    return caretSlopeRise;}
public short pdfbox_f2041_0()
{    return caretSlopeRun;}
public short pdfbox_f2042_0()
{    return caretOffset;}
public short pdfbox_f2043_0()
{    return descender;}
public short pdfbox_f2044_0()
{    return lineGap;}
public short pdfbox_f2045_0()
{    return metricDataFormat;}
public short pdfbox_f2046_0()
{    return minTopSideBearing;}
public short pdfbox_f2047_0()
{    return minBottomSideBearing;}
public int pdfbox_f2048_0()
{    return numberOfVMetrics;}
public short pdfbox_f2049_0()
{    return reserved1;}
public short pdfbox_f2050_0()
{    return reserved2;}
public short pdfbox_f2051_0()
{    return reserved3;}
public short pdfbox_f2052_0()
{    return reserved4;}
public float pdfbox_f2053_0()
{    return version;}
public short pdfbox_f2054_0()
{    return yMaxExtent;}
 void pdfbox_f2055_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    VerticalHeaderTable vHeader = ttf.getVerticalHeader();    if (vHeader == null) {        throw new IOException("Could not get vhea table");    }    numVMetrics = vHeader.getNumberOfVMetrics();    int numGlyphs = ttf.getNumberOfGlyphs();    int bytesRead = 0;    advanceHeight = new int[numVMetrics];    topSideBearing = new short[numVMetrics];    for (int i = 0; i < numVMetrics; i++) {        advanceHeight[i] = data.readUnsignedShort();        topSideBearing[i] = data.readSignedShort();        bytesRead += 4;    }    if (bytesRead < getLength()) {        int numberNonVertical = numGlyphs - numVMetrics;                if (numberNonVertical < 0) {            numberNonVertical = numGlyphs;        }        additionalTopSideBearing = new short[numberNonVertical];        for (int i = 0; i < numberNonVertical; i++) {            if (bytesRead < getLength()) {                additionalTopSideBearing[i] = data.readSignedShort();                bytesRead += 2;            }        }    }    initialized = true;}
public int pdfbox_f2056_0(int gid)
{    if (gid < numVMetrics) {        return topSideBearing[gid];    } else {        return additionalTopSideBearing[gid - numVMetrics];    }}
public int pdfbox_f2057_0(int gid)
{    if (gid < numVMetrics) {        return advanceHeight[gid];    } else {                return advanceHeight[advanceHeight.length - 1];    }}
 void pdfbox_f2058_0(TrueTypeFont ttf, TTFDataStream data) throws IOException
{    version = data.read32Fixed();    defaultVertOriginY = data.readSignedShort();    int numVertOriginYMetrics = data.readUnsignedShort();    origins = new ConcurrentHashMap<>(numVertOriginYMetrics);    for (int i = 0; i < numVertOriginYMetrics; ++i) {        int g = data.readUnsignedShort();        int y = data.readSignedShort();        origins.put(g, y);    }    initialized = true;}
public float pdfbox_f2059_0()
{    return version;}
public int pdfbox_f2060_0(int gid)
{    if (origins.containsKey(gid)) {        return origins.get(gid);    } else {        return defaultVertOriginY;    }}
public String pdfbox_f2061_0()
{    return text;}
public Kind pdfbox_f2062_0()
{    return kind;}
public int pdfbox_f2063_0()
{        return (int) Float.parseFloat(text);}
public float pdfbox_f2064_0()
{    return Float.parseFloat(text);}
public boolean pdfbox_f2065_0()
{    return text.equals("true");}
public byte[] pdfbox_f2066_0()
{    return data;}
public String pdfbox_f2067_0()
{    if (kind == CHARSTRING) {        return "Token[kind=CHARSTRING, data=" + data.length + " bytes]";    } else {        return "Token[kind=" + kind + ", text=" + text + "]";    }}
public static Type1Font pdfbox_f2068_0(InputStream pfbStream) throws IOException
{    PfbParser pfb = new PfbParser(pfbStream);    Type1Parser parser = new Type1Parser();    return parser.parse(pfb.getSegment1(), pfb.getSegment2());}
public static Type1Font pdfbox_f2069_0(byte[] pfbBytes) throws IOException
{    PfbParser pfb = new PfbParser(pfbBytes);    Type1Parser parser = new Type1Parser();    return parser.parse(pfb.getSegment1(), pfb.getSegment2());}
public static Type1Font pdfbox_f2070_0(byte[] segment1, byte[] segment2) throws IOException
{    Type1Parser parser = new Type1Parser();    return parser.parse(segment1, segment2);}
public List<byte[]> pdfbox_f2071_0()
{    return Collections.unmodifiableList(subrs);}
public Map<String, byte[]> pdfbox_f2072_0()
{    return Collections.unmodifiableMap(charstrings);}
public String pdfbox_f2073_0()
{    return fontName;}
public GeneralPath pdfbox_f2074_0(String name) throws IOException
{    return getType1CharString(name).getPath();}
public float pdfbox_f2075_0(String name) throws IOException
{    return getType1CharString(name).getWidth();}
public boolean pdfbox_f2076_0(String name)
{    return charstrings.get(name) != null;}
public Type1CharString pdfbox_f2077_0(String name) throws IOException
{    Type1CharString type1 = charStringCache.get(name);    if (type1 == null) {        byte[] bytes = charstrings.get(name);        if (bytes == null) {            bytes = charstrings.get(".notdef");        }        Type1CharStringParser parser = new Type1CharStringParser(fontName, name);        List<Object> sequence = parser.parse(bytes, subrs);        type1 = new Type1CharString(this, fontName, name, sequence);        charStringCache.put(name, type1);    }    return type1;}
public String pdfbox_f2078_0()
{    return fontName;}
public Encoding pdfbox_f2079_0()
{    return encoding;}
public int pdfbox_f2080_0()
{    return paintType;}
public int pdfbox_f2081_0()
{    return fontType;}
public List<Number> pdfbox_f2082_0()
{    return Collections.unmodifiableList(fontMatrix);}
public BoundingBox pdfbox_f2083_0()
{    return new BoundingBox(fontBBox);}
public int pdfbox_f2084_0()
{    return uniqueID;}
public float pdfbox_f2085_0()
{    return strokeWidth;}
public String pdfbox_f2086_0()
{    return fontID;}
public String pdfbox_f2087_0()
{    return version;}
public String pdfbox_f2088_0()
{    return notice;}
public String pdfbox_f2089_0()
{    return fullName;}
public String pdfbox_f2090_0()
{    return familyName;}
public String pdfbox_f2091_0()
{    return weight;}
public float pdfbox_f2092_0()
{    return italicAngle;}
public boolean pdfbox_f2093_0()
{    return isFixedPitch;}
public float pdfbox_f2094_0()
{    return underlinePosition;}
public float pdfbox_f2095_0()
{    return underlineThickness;}
public List<Number> pdfbox_f2096_0()
{    return Collections.unmodifiableList(blueValues);}
public List<Number> pdfbox_f2097_0()
{    return Collections.unmodifiableList(otherBlues);}
public List<Number> pdfbox_f2098_0()
{    return Collections.unmodifiableList(familyBlues);}
public List<Number> pdfbox_f2099_0()
{    return Collections.unmodifiableList(familyOtherBlues);}
public float pdfbox_f2100_0()
{    return blueScale;}
public int pdfbox_f2101_0()
{    return blueShift;}
public int pdfbox_f2102_0()
{    return blueFuzz;}
public List<Number> pdfbox_f2103_0()
{    return Collections.unmodifiableList(stdHW);}
public List<Number> pdfbox_f2104_0()
{    return Collections.unmodifiableList(stdVW);}
public List<Number> pdfbox_f2105_0()
{    return Collections.unmodifiableList(stemSnapH);}
public List<Number> pdfbox_f2106_0()
{    return Collections.unmodifiableList(stemSnapV);}
public boolean pdfbox_f2107_0()
{    return forceBold;}
public int pdfbox_f2108_0()
{    return languageGroup;}
public byte[] pdfbox_f2109_0()
{    return segment1;}
public byte[] pdfbox_f2110_0()
{    return segment2;}
public String pdfbox_f2111_0()
{    return getClass().getName() + "[fontName=" + fontName + ", fullName=" + fullName + ", encoding=" + encoding + ", charStringsDict=" + charstrings + "]";}
public Token pdfbox_f2112_0() throws IOException
{    Token curToken = aheadToken;        aheadToken = readToken(curToken);    return curToken;}
public Token pdfbox_f2113_0()
{    return aheadToken;}
private char pdfbox_f2114_0()
{    return (char) buffer.get();}
private Token pdfbox_f2115_1(Token prevToken) throws IOException
{    boolean skip;    do {        skip = false;        while (buffer.hasRemaining()) {            char c = getChar();                        if (c == '%') {                                readComment();            } else if (c == '(') {                return readString();            } else if (c == ')') {                                throw new IOException("unexpected closing parenthesis");            } else if (c == '[') {                return new Token(c, Token.START_ARRAY);            } else if (c == '{') {                return new Token(c, Token.START_PROC);            } else if (c == ']') {                return new Token(c, Token.END_ARRAY);            } else if (c == '}') {                return new Token(c, Token.END_PROC);            } else if (c == '/') {                return new Token(readRegular(), Token.LITERAL);            } else if (c == '<') {                char c2 = getChar();                if (c2 == c) {                    return new Token("<<", Token.START_DICT);                } else {                                        buffer.position(buffer.position() - 1);                    return new Token(c, Token.NAME);                }            } else if (c == '>') {                char c2 = getChar();                if (c2 == c) {                    return new Token(">>", Token.END_DICT);                } else {                                        buffer.position(buffer.position() - 1);                    return new Token(c, Token.NAME);                }            } else if (Character.isWhitespace(c)) {                skip = true;            } else if (c == 0) {                                skip = true;            } else {                buffer.position(buffer.position() - 1);                                Token number = tryReadNumber();                if (number != null) {                    return number;                } else {                                        String name = readRegular();                    if (name == null) {                                                throw new DamagedFontException("Could not read token at position " + buffer.position());                    }                    if (name.equals("RD") || name.equals("-|")) {                                                if (prevToken.getKind() == Token.INTEGER) {                            return readCharString(prevToken.intValue());                        } else {                            throw new IOException("expected INTEGER before -| or RD");                        }                    } else {                        return new Token(name, Token.NAME);                    }                }            }        }    } while (skip);    return null;}
private Token pdfbox_f2116_0()
{    buffer.mark();    StringBuilder sb = new StringBuilder();    StringBuilder radix = null;    char c = getChar();    boolean hasDigit = false;        if (c == '+' || c == '-') {        sb.append(c);        c = getChar();    }        while (Character.isDigit(c)) {        sb.append(c);        c = getChar();        hasDigit = true;    }        if (c == '.') {        sb.append(c);        c = getChar();    } else if (c == '#') {                radix = sb;        sb = new StringBuilder();        c = getChar();    } else if (sb.length() == 0 || !hasDigit) {                buffer.reset();        return null;    } else {                buffer.position(buffer.position() - 1);        return new Token(sb.toString(), Token.INTEGER);    }        if (Character.isDigit(c)) {        sb.append(c);        c = getChar();    } else {                buffer.reset();        return null;    }        while (Character.isDigit(c)) {        sb.append(c);        c = getChar();    }        if (c == 'E') {        sb.append(c);        c = getChar();                if (c == '-') {            sb.append(c);            c = getChar();        }                if (Character.isDigit(c)) {            sb.append(c);            c = getChar();        } else {                        buffer.reset();            return null;        }                while (Character.isDigit(c)) {            sb.append(c);            c = getChar();        }    }    buffer.position(buffer.position() - 1);    if (radix != null) {        Integer val = Integer.parseInt(sb.toString(), Integer.parseInt(radix.toString()));        return new Token(val.toString(), Token.INTEGER);    }    return new Token(sb.toString(), Token.REAL);}
private String pdfbox_f2117_0()
{    StringBuilder sb = new StringBuilder();    while (buffer.hasRemaining()) {        buffer.mark();        char c = getChar();        if (Character.isWhitespace(c) || c == '(' || c == ')' || c == '<' || c == '>' || c == '[' || c == ']' || c == '{' || c == '}' || c == '/' || c == '%') {            buffer.reset();            break;        } else {            sb.append(c);        }    }    String regular = sb.toString();    if (regular.length() == 0) {        return null;    }    return regular;}
private String pdfbox_f2118_0()
{    StringBuilder sb = new StringBuilder();    while (buffer.hasRemaining()) {        char c = getChar();        if (c == '\r' || c == '\n') {            break;        } else {            sb.append(c);        }    }    return sb.toString();}
private Token pdfbox_f2119_0()
{    StringBuilder sb = new StringBuilder();    while (buffer.hasRemaining()) {        char c = getChar();                switch(c) {            case '(':                openParens++;                sb.append('(');                break;            case ')':                if (openParens == 0) {                                        return new Token(sb.toString(), Token.STRING);                }                sb.append(')');                openParens--;                break;            case '\\':                                char c1 = getChar();                switch(c1) {                    case 'n':                    case 'r':                        sb.append("\n");                        break;                    case 't':                        sb.append('\t');                        break;                    case 'b':                        sb.append('\b');                        break;                    case 'f':                        sb.append('\f');                        break;                    case '\\':                        sb.append('\\');                        break;                    case '(':                        sb.append('(');                        break;                    case ')':                        sb.append(')');                        break;                }                                if (Character.isDigit(c1)) {                    String num = String.valueOf(new char[] { c1, getChar(), getChar() });                    Integer code = Integer.parseInt(num, 8);                    sb.append((char) (int) code);                }                break;            case '\r':            case '\n':                sb.append("\n");                break;            default:                sb.append(c);                break;        }    }    return null;}
private Token pdfbox_f2120_0(int length)
{        buffer.get();    byte[] data = new byte[length];    buffer.get(data);    return new Token(data, Token.CHARSTRING);}
public Type1Font pdfbox_f2121_0(byte[] segment1, byte[] segment2) throws IOException
{    font = new Type1Font(segment1, segment2);    parseASCII(segment1);    if (segment2.length > 0) {        parseBinary(segment2);    }    return font;}
private void pdfbox_f2122_0(byte[] bytes) throws IOException
{    if (bytes.length == 0) {        throw new IllegalArgumentException("byte[] is empty");    }        if (bytes.length < 2 || (bytes[0] != '%' && bytes[1] != '!')) {        throw new IOException("Invalid start of ASCII segment");    }    lexer = new Type1Lexer(bytes);        if (lexer.peekToken().getText().equals("FontDirectory")) {        read(Token.NAME, "FontDirectory");                read(Token.LITERAL);        read(Token.NAME, "known");        read(Token.START_PROC);        readProc();        read(Token.START_PROC);        readProc();        read(Token.NAME, "ifelse");    }        int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");        readMaybe(Token.NAME, "dup");        read(Token.NAME, "begin");    for (int i = 0; i < length; i++) {                Token token = lexer.peekToken();        if (token == null) {            break;        }        if (token.getKind() == Token.NAME && ("currentdict".equals(token.getText()) || "end".equals(token.getText()))) {            break;        }                String key = read(Token.LITERAL).getText();        switch(key) {            case "FontInfo":            case "Fontinfo":                readFontInfo(readSimpleDict());                break;            case "Metrics":                readSimpleDict();                break;            case "Encoding":                readEncoding();                break;            default:                readSimpleValue(key);                break;        }    }    readMaybe(Token.NAME, "currentdict");    read(Token.NAME, "end");    read(Token.NAME, "currentfile");    read(Token.NAME, "eexec");}
private void pdfbox_f2123_0(String key) throws IOException
{    List<Token> value = readDictValue();    switch(key) {        case "FontName":            font.fontName = value.get(0).getText();            break;        case "PaintType":            font.paintType = value.get(0).intValue();            break;        case "FontType":            font.fontType = value.get(0).intValue();            break;        case "FontMatrix":            font.fontMatrix = arrayToNumbers(value);            break;        case "FontBBox":            font.fontBBox = arrayToNumbers(value);            break;        case "UniqueID":            font.uniqueID = value.get(0).intValue();            break;        case "StrokeWidth":            font.strokeWidth = value.get(0).floatValue();            break;        case "FID":            font.fontID = value.get(0).getText();            break;        default:            break;    }}
private void pdfbox_f2124_0() throws IOException
{    if (lexer.peekToken().getKind() == Token.NAME) {        String name = lexer.nextToken().getText();        if (name.equals("StandardEncoding")) {            font.encoding = StandardEncoding.INSTANCE;        } else {            throw new IOException("Unknown encoding: " + name);        }        readMaybe(Token.NAME, "readonly");        read(Token.NAME, "def");    } else {        read(Token.INTEGER).intValue();        readMaybe(Token.NAME, "array");                while (!(lexer.peekToken().getKind() == Token.NAME && (lexer.peekToken().getText().equals("dup") || lexer.peekToken().getText().equals("readonly") || lexer.peekToken().getText().equals("def")))) {            lexer.nextToken();        }        Map<Integer, String> codeToName = new HashMap<>();        while (lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("dup")) {            read(Token.NAME, "dup");            int code = read(Token.INTEGER).intValue();            String name = read(Token.LITERAL).getText();            read(Token.NAME, "put");            codeToName.put(code, name);        }        font.encoding = new BuiltInEncoding(codeToName);        readMaybe(Token.NAME, "readonly");        read(Token.NAME, "def");    }}
private List<Number> pdfbox_f2125_0(List<Token> value) throws IOException
{    List<Number> numbers = new ArrayList<>();    for (int i = 1, size = value.size() - 1; i < size; i++) {        Token token = value.get(i);        if (token.getKind() == Token.REAL) {            numbers.add(token.floatValue());        } else if (token.getKind() == Token.INTEGER) {            numbers.add(token.intValue());        } else {            throw new IOException("Expected INTEGER or REAL but got " + token.getKind());        }    }    return numbers;}
private void pdfbox_f2126_0(Map<String, List<Token>> fontInfo)
{    for (Map.Entry<String, List<Token>> entry : fontInfo.entrySet()) {        String key = entry.getKey();        List<Token> value = entry.getValue();        switch(key) {            case "version":                font.version = value.get(0).getText();                break;            case "Notice":                font.notice = value.get(0).getText();                break;            case "FullName":                font.fullName = value.get(0).getText();                break;            case "FamilyName":                font.familyName = value.get(0).getText();                break;            case "Weight":                font.weight = value.get(0).getText();                break;            case "ItalicAngle":                font.italicAngle = value.get(0).floatValue();                break;            case "isFixedPitch":                font.isFixedPitch = value.get(0).booleanValue();                break;            case "UnderlinePosition":                font.underlinePosition = value.get(0).floatValue();                break;            case "UnderlineThickness":                font.underlineThickness = value.get(0).floatValue();                break;            default:                break;        }    }}
private Map<String, List<Token>> pdfbox_f2127_0() throws IOException
{    Map<String, List<Token>> dict = new HashMap<>();    int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");    readMaybe(Token.NAME, "dup");    read(Token.NAME, "begin");    for (int i = 0; i < length; i++) {        if (lexer.peekToken() == null) {            break;        }        if (lexer.peekToken().getKind() == Token.NAME && !lexer.peekToken().getText().equals("end")) {            read(Token.NAME);        }                if (lexer.peekToken() == null) {            break;        }        if (lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("end")) {            break;        }                String key = read(Token.LITERAL).getText();        List<Token> value = readDictValue();        dict.put(key, value);    }    read(Token.NAME, "end");    readMaybe(Token.NAME, "readonly");    read(Token.NAME, "def");    return dict;}
private List<Token> pdfbox_f2128_0() throws IOException
{    List<Token> value = readValue();    readDef();    return value;}
private List<Token> pdfbox_f2129_0() throws IOException
{    List<Token> value = new ArrayList<>();    Token token = lexer.nextToken();    if (lexer.peekToken() == null) {        return value;    }    value.add(token);    if (token.getKind() == Token.START_ARRAY) {        int openArray = 1;        while (true) {            if (lexer.peekToken() == null) {                return value;            }            if (lexer.peekToken().getKind() == Token.START_ARRAY) {                openArray++;            }            token = lexer.nextToken();            value.add(token);            if (token.getKind() == Token.END_ARRAY) {                openArray--;                if (openArray == 0) {                    break;                }            }        }    } else if (token.getKind() == Token.START_PROC) {        value.addAll(readProc());    } else if (token.getKind() == Token.START_DICT) {                read(Token.END_DICT);        return value;    }    readPostScriptWrapper(value);    return value;}
private void pdfbox_f2130_0(List<Token> value) throws IOException
{        if (lexer.peekToken().getText().equals("systemdict")) {        read(Token.NAME, "systemdict");        read(Token.LITERAL, "internaldict");        read(Token.NAME, "known");        read(Token.START_PROC);        readProc();        read(Token.START_PROC);        readProc();        read(Token.NAME, "ifelse");                read(Token.START_PROC);        read(Token.NAME, "pop");        value.clear();        value.addAll(readValue());        read(Token.END_PROC);        read(Token.NAME, "if");    }}
private List<Token> pdfbox_f2131_0() throws IOException
{    List<Token> value = new ArrayList<>();    int openProc = 1;    while (true) {        if (lexer.peekToken().getKind() == Token.START_PROC) {            openProc++;        }        Token token = lexer.nextToken();        value.add(token);        if (token.getKind() == Token.END_PROC) {            openProc--;            if (openProc == 0) {                break;            }        }    }    Token executeonly = readMaybe(Token.NAME, "executeonly");    if (executeonly != null) {        value.add(executeonly);    }    return value;}
private void pdfbox_f2132_0(byte[] bytes) throws IOException
{    byte[] decrypted;        if (isBinary(bytes)) {        decrypted = decrypt(bytes, EEXEC_KEY, 4);    } else {        decrypted = decrypt(hexToBinary(bytes), EEXEC_KEY, 4);    }    lexer = new Type1Lexer(decrypted);        Token peekToken = lexer.peekToken();    while (peekToken != null && !peekToken.getText().equals("Private")) {                                lexer.nextToken();        peekToken = lexer.peekToken();    }    if (peekToken == null) {        throw new IOException("/Private token not found");    }        read(Token.LITERAL, "Private");    int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");            readMaybe(Token.NAME, "dup");    read(Token.NAME, "begin");        int lenIV = 4;    for (int i = 0; i < length; i++) {                if (lexer.peekToken() == null || lexer.peekToken().getKind() != Token.LITERAL) {            break;        }                String key = read(Token.LITERAL).getText();        switch(key) {            case "Subrs":                readSubrs(lenIV);                break;            case "OtherSubrs":                readOtherSubrs();                break;            case "lenIV":                lenIV = readDictValue().get(0).intValue();                break;            case "ND":                read(Token.START_PROC);                                readMaybe(Token.NAME, "noaccess");                read(Token.NAME, "def");                read(Token.END_PROC);                readMaybe(Token.NAME, "executeonly");                read(Token.NAME, "def");                break;            case "NP":                read(Token.START_PROC);                readMaybe(Token.NAME, "noaccess");                read(Token.NAME);                read(Token.END_PROC);                readMaybe(Token.NAME, "executeonly");                read(Token.NAME, "def");                break;            case "RD":                                read(Token.START_PROC);                readProc();                readMaybe(Token.NAME, "bind");                readMaybe(Token.NAME, "executeonly");                read(Token.NAME, "def");                break;            default:                readPrivate(key, readDictValue());                break;        }    }        while (!(lexer.peekToken().getKind() == Token.LITERAL && lexer.peekToken().getText().equals("CharStrings"))) {        lexer.nextToken();    }        read(Token.LITERAL, "CharStrings");    readCharStrings(lenIV);}
private void pdfbox_f2133_0(String key, List<Token> value) throws IOException
{    switch(key) {        case "BlueValues":            font.blueValues = arrayToNumbers(value);            break;        case "OtherBlues":            font.otherBlues = arrayToNumbers(value);            break;        case "FamilyBlues":            font.familyBlues = arrayToNumbers(value);            break;        case "FamilyOtherBlues":            font.familyOtherBlues = arrayToNumbers(value);            break;        case "BlueScale":            font.blueScale = value.get(0).floatValue();            break;        case "BlueShift":            font.blueShift = value.get(0).intValue();            break;        case "BlueFuzz":            font.blueFuzz = value.get(0).intValue();            break;        case "StdHW":            font.stdHW = arrayToNumbers(value);            break;        case "StdVW":            font.stdVW = arrayToNumbers(value);            break;        case "StemSnapH":            font.stemSnapH = arrayToNumbers(value);            break;        case "StemSnapV":            font.stemSnapV = arrayToNumbers(value);            break;        case "ForceBold":            font.forceBold = value.get(0).booleanValue();            break;        case "LanguageGroup":            font.languageGroup = value.get(0).intValue();            break;        default:            break;    }}
private void pdfbox_f2134_0(int lenIV) throws IOException
{        int length = read(Token.INTEGER).intValue();    for (int i = 0; i < length; i++) {        font.subrs.add(null);    }    read(Token.NAME, "array");    for (int i = 0; i < length; i++) {                if (lexer.peekToken() == null) {            break;        }        if (!(lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("dup"))) {            break;        }        read(Token.NAME, "dup");        Token index = read(Token.INTEGER);        read(Token.INTEGER);                Token charstring = read(Token.CHARSTRING);        font.subrs.set(index.intValue(), decrypt(charstring.getData(), CHARSTRING_KEY, lenIV));        readPut();    }    readDef();}
private void pdfbox_f2135_0() throws IOException
{    if (lexer.peekToken().getKind() == Token.START_ARRAY) {        readValue();        readDef();    } else {        int length = read(Token.INTEGER).intValue();        read(Token.NAME, "array");        for (int i = 0; i < length; i++) {            read(Token.NAME, "dup");                        read(Token.INTEGER);                        readValue();            readPut();        }        readDef();    }}
private void pdfbox_f2136_0(int lenIV) throws IOException
{    int length = read(Token.INTEGER).intValue();    read(Token.NAME, "dict");            read(Token.NAME, "dup");    read(Token.NAME, "begin");    for (int i = 0; i < length; i++) {                if (lexer.peekToken() == null) {            break;        }        if (lexer.peekToken().getKind() == Token.NAME && lexer.peekToken().getText().equals("end")) {            break;        }                String name = read(Token.LITERAL).getText();                read(Token.INTEGER);        Token charstring = read(Token.CHARSTRING);        font.charstrings.put(name, decrypt(charstring.getData(), CHARSTRING_KEY, lenIV));        readDef();    }        read(Token.NAME, "end");}
private void pdfbox_f2137_0() throws IOException
{    readMaybe(Token.NAME, "readonly");        readMaybe(Token.NAME, "noaccess");    Token token = read(Token.NAME);    switch(token.getText()) {        case "ND":        case "|-":            return;        case "noaccess":            token = read(Token.NAME);            break;        default:            break;    }    if (token.getText().equals("def")) {        return;    }    throw new IOException("Found " + token + " but expected ND");}
private void pdfbox_f2138_0() throws IOException
{    readMaybe(Token.NAME, "readonly");    Token token = read(Token.NAME);    switch(token.getText()) {        case "NP":        case "|":            return;        case "noaccess":            token = read(Token.NAME);            break;        default:            break;    }    if (token.getText().equals("put")) {        return;    }    throw new IOException("Found " + token + " but expected NP");}
private Token pdfbox_f2139_0(Token.Kind kind) throws IOException
{    Token token = lexer.nextToken();    if (token == null || token.getKind() != kind) {        throw new IOException("Found " + token + " but expected " + kind);    }    return token;}
private void pdfbox_f2140_0(Token.Kind kind, String name) throws IOException
{    Token token = read(kind);    if (!token.getText().equals(name)) {        throw new IOException("Found " + token + " but expected " + name);    }}
private Token pdfbox_f2141_0(Token.Kind kind, String name) throws IOException
{    Token token = lexer.peekToken();    if (token != null && token.getKind() == kind && token.getText().equals(name)) {        return lexer.nextToken();    }    return null;}
private byte[] pdfbox_f2142_0(byte[] cipherBytes, int r, int n)
{        if (n == -1) {        return cipherBytes;    }        if (cipherBytes.length == 0 || n > cipherBytes.length) {        return new byte[] {};    }        int c1 = 52845;    int c2 = 22719;    byte[] plainBytes = new byte[cipherBytes.length - n];    for (int i = 0; i < cipherBytes.length; i++) {        int cipher = cipherBytes[i] & 0xFF;        int plain = cipher ^ r >> 8;        if (i >= n) {            plainBytes[i - n] = (byte) plain;        }        r = (cipher + r) * c1 + c2 & 0xffff;    }    return plainBytes;}
private boolean pdfbox_f2143_0(byte[] bytes)
{    if (bytes.length < 4) {        return true;    }        for (int i = 0; i < 4; ++i) {        byte by = bytes[i];        if (by != 0x0a && by != 0x0d && by != 0x20 && by != '\t' && Character.digit((char) by, 16) == -1) {            return true;        }    }    return false;}
private byte[] pdfbox_f2144_0(byte[] bytes)
{        int len = 0;    for (byte by : bytes) {        if (Character.digit((char) by, 16) != -1) {            ++len;        }    }    byte[] res = new byte[len / 2];    int r = 0;    int prev = -1;    for (byte by : bytes) {        int digit = Character.digit((char) by, 16);        if (digit != -1) {            if (prev == -1) {                prev = digit;            } else {                res[r++] = (byte) (prev * 16 + digit);                prev = -1;            }        }    }    return res;}
private FontDirFinder pdfbox_f2145_0()
{    final String osName = System.getProperty("os.name");    if (osName.startsWith("Windows")) {        return new WindowsFontDirFinder();    } else if (osName.startsWith("Mac")) {        return new MacFontDirFinder();    } else if (osName.startsWith("OS/400")) {        return new OS400FontDirFinder();    } else {        return new UnixFontDirFinder();    }}
public List<URI> pdfbox_f2146_0()
{    if (fontDirFinder == null) {        fontDirFinder = determineDirFinder();    }    List<File> fontDirs = fontDirFinder.find();    List<URI> results = new ArrayList<>();    fontDirs.forEach(dir -> walk(dir, results));    return results;}
public List<URI> pdfbox_f2147_0(String dir)
{    List<URI> results = new ArrayList<>();    File directory = new File(dir);    if (directory.isDirectory()) {        walk(directory, results);    }    return results;}
private void pdfbox_f2148_1(File directory, List<URI> results)
{        if (!directory.isDirectory()) {        return;    }    File[] filelist = directory.listFiles();    if (filelist == null) {        return;    }    for (File file : filelist) {        if (file.isDirectory()) {                        if (file.getName().startsWith(".")) {                continue;            }            walk(file, results);        } else {            if (LOG.isDebugEnabled()) {                            }            if (checkFontfile(file)) {                if (LOG.isDebugEnabled()) {                                    }                results.add(file.toURI());            }        }    }}
private boolean pdfbox_f2149_0(File file)
{    String name = file.getName().toLowerCase(Locale.US);    return (name.endsWith(".ttf") || name.endsWith(".otf") || name.endsWith(".pfb") || name.endsWith(".ttc")) &&     !name.startsWith("fonts.");}
protected String[] pdfbox_f2150_0()
{    return new String[] {     System.getProperty("user.home") + "/Library/Fonts/",     "/Library/Fonts/",     "/System/Library/Fonts/",     "/Network/Library/Fonts/" };}
public List<File> pdfbox_f2151_1()
{    List<File> fontDirList = new java.util.ArrayList<>();    String[] searchableDirectories = getSearchableDirectories();    if (searchableDirectories != null) {        for (String searchableDirectorie : searchableDirectories) {            File fontDir = new File(searchableDirectorie);            try {                if (fontDir.exists() && fontDir.canRead()) {                    fontDirList.add(fontDir);                }            } catch (SecurityException e) {                                        }        }    }    return fontDirList;}
protected String[] pdfbox_f2152_0()
{    return new String[] {     System.getProperty("user.home") + "/.fonts", "/QIBM/ProdData/OS400/Fonts" };}
protected String[] pdfbox_f2153_0()
{    return new String[] {     System.getProperty("user.home") + "/.fonts",     "/usr/local/fonts",     "/usr/local/share/fonts",     "/usr/share/fonts",     "/usr/X11R6/lib/X11/fonts" };}
private String pdfbox_f2154_0(String osName) throws IOException
{    Process process;    Runtime runtime = Runtime.getRuntime();    if (osName.startsWith("Windows 9")) {        process = runtime.exec("command.com /c echo %windir%");    } else {        process = runtime.exec("cmd.exe /c echo %windir%");    }    try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream(), Charsets.ISO_8859_1))) {        return bufferedReader.readLine();    }}
public List<File> pdfbox_f2155_1()
{    List<File> fontDirList = new java.util.ArrayList<>();    String windir = null;    try {        windir = System.getProperty("env.windir");    } catch (SecurityException e) {                }    String osName = System.getProperty("os.name");    if (windir == null) {        try {            windir = getWinDir(osName);        } catch (IOException | SecurityException e) {                            }    }    File osFontsDir;    File psFontsDir;    if (windir != null && windir.length() > 2) {                if (windir.endsWith("/")) {            windir = windir.substring(0, windir.length() - 1);        }        osFontsDir = new File(windir + File.separator + "FONTS");        if (osFontsDir.exists() && osFontsDir.canRead()) {            fontDirList.add(osFontsDir);        }        psFontsDir = new File(windir.substring(0, 2) + File.separator + "PSFONTS");        if (psFontsDir.exists() && psFontsDir.canRead()) {            fontDirList.add(psFontsDir);        }    } else {        String windowsDirName = osName.endsWith("NT") ? "WINNT" : "WINDOWS";                for (char driveLetter = 'C'; driveLetter <= 'E'; driveLetter++) {            osFontsDir = new File(driveLetter + ":" + File.separator + windowsDirName + File.separator + "FONTS");            try {                if (osFontsDir.exists() && osFontsDir.canRead()) {                    fontDirList.add(osFontsDir);                    break;                }            } catch (SecurityException e) {                                        }        }                for (char driveLetter = 'C'; driveLetter <= 'E'; driveLetter++) {            psFontsDir = new File(driveLetter + ":" + File.separator + "PSFONTS");            try {                if (psFontsDir.exists() && psFontsDir.canRead()) {                    fontDirList.add(psFontsDir);                    break;                }            } catch (SecurityException e) {                                        }        }    }    return fontDirList;}
public float pdfbox_f2156_0()
{    return lowerLeftX;}
public void pdfbox_f2157_0(float lowerLeftXValue)
{    this.lowerLeftX = lowerLeftXValue;}
public float pdfbox_f2158_0()
{    return lowerLeftY;}
public void pdfbox_f2159_0(float lowerLeftYValue)
{    this.lowerLeftY = lowerLeftYValue;}
public float pdfbox_f2160_0()
{    return upperRightX;}
public void pdfbox_f2161_0(float upperRightXValue)
{    this.upperRightX = upperRightXValue;}
public float pdfbox_f2162_0()
{    return upperRightY;}
public void pdfbox_f2163_0(float upperRightYValue)
{    this.upperRightY = upperRightYValue;}
public float pdfbox_f2164_0()
{    return getUpperRightX() - getLowerLeftX();}
public float pdfbox_f2165_0()
{    return getUpperRightY() - getLowerLeftY();}
public boolean pdfbox_f2166_0(float x, float y)
{    return x >= lowerLeftX && x <= upperRightX && y >= lowerLeftY && y <= upperRightY;}
public String pdfbox_f2167_0()
{    return "[" + getLowerLeftX() + "," + getLowerLeftY() + "," + getUpperRightX() + "," + getUpperRightY() + "]";}
public void pdfbox_f2168_0() throws IOException
{    try {        new AFMParser(new ByteArrayInputStream("huhu".getBytes(Charsets.US_ASCII))).parse();    } catch (IOException ex) {        Assert.assertEquals("Error: The AFM file should start with StartFontMetrics and not 'huhu'", ex.getMessage());    }}
public void pdfbox_f2169_0() throws IOException
{    List<CFFFont> fonts = readFont("target/pdfs/SourceSansProBold.otf");    CFFType1Font font = (CFFType1Font) fonts.get(0);    @SuppressWarnings("unchecked")    List<Number> blues = (List<Number>) font.getPrivateDict().get("BlueValues");        assertNumberList("Blue values are different than expected: " + blues.toString(), new int[] { -12, 0, 496, 508, 578, 590, 635, 647, 652, 664, 701, 713 }, blues);    @SuppressWarnings("unchecked")    List<Number> otherBlues = (List<Number>) font.getPrivateDict().get("OtherBlues");    assertNumberList("Other blues are different than expected: " + otherBlues.toString(), new int[] { -196, -184 }, otherBlues);    @SuppressWarnings("unchecked")    List<Number> familyBlues = (List<Number>) font.getPrivateDict().get("FamilyBlues");    assertNumberList("Other blues are different than expected: " + familyBlues.toString(), new int[] { -12, 0, 486, 498, 574, 586, 638, 650, 656, 668, 712, 724 }, familyBlues);    @SuppressWarnings("unchecked")    List<Number> familyOtherBlues = (List<Number>) font.getPrivateDict().get("FamilyOtherBlues");    assertNumberList("Other blues are different than expected: " + familyOtherBlues.toString(), new int[] { -217, -205 }, familyOtherBlues);    @SuppressWarnings("unchecked")    List<Number> stemSnapH = (List<Number>) font.getPrivateDict().get("StemSnapH");    assertNumberList("StemSnapH values are different than expected: " + stemSnapH.toString(), new int[] { 115 }, stemSnapH);    @SuppressWarnings("unchecked")    List<Number> stemSnapV = (List<Number>) font.getPrivateDict().get("StemSnapV");    assertNumberList("StemSnapV values are different than expected: " + stemSnapV.toString(), new int[] { 146, 150 }, stemSnapV);}
private List<CFFFont> pdfbox_f2170_0(String filename) throws IOException
{    ByteArrayOutputStream content = new ByteArrayOutputStream();    Files.copy(Paths.get(filename), content);    CFFParser parser = new CFFParser();    return parser.parse(content.toByteArray());}
private void pdfbox_f2171_0(String message, int[] expected, List<Number> found)
{    assertEquals(message, expected.length, found.size());    for (int i = 0; i < expected.length; i++) {        assertEquals(message, expected[i], found.get(i).intValue());    }}
public void pdfbox_f2172_0()
{    long seed = DEFAULTSEED;    tryHexEncoding(seed);    for (int i = 0; i < LOOPS; ++i) {        tryHexEncoding(System.currentTimeMillis());    }}
private void pdfbox_f2173_0(long seed) throws ArrayComparisonFailure
{    byte[] bytes = createRandomByteArray(128, seed);    String encodedBytes = Type1FontUtil.hexEncode(bytes);    byte[] decodedBytes = Type1FontUtil.hexDecode(encodedBytes);    assertArrayEquals("Seed: " + seed, bytes, decodedBytes);}
public void pdfbox_f2174_0()
{    long seed = DEFAULTSEED;    tryEexecEncryption(seed);    for (int i = 0; i < LOOPS; ++i) {        tryEexecEncryption(System.currentTimeMillis());    }}
private void pdfbox_f2175_0(long seed) throws ArrayComparisonFailure
{    byte[] bytes = createRandomByteArray(128, seed);    byte[] encryptedBytes = Type1FontUtil.eexecEncrypt(bytes);    byte[] decryptedBytes = Type1FontUtil.eexecDecrypt(encryptedBytes);    assertArrayEquals("Seed: " + seed, bytes, decryptedBytes);}
public void pdfbox_f2176_0()
{    long seed = DEFAULTSEED;    tryCharstringEncryption(seed);    for (int i = 0; i < LOOPS; ++i) {        tryCharstringEncryption(System.currentTimeMillis());    }}
private void pdfbox_f2177_0(long seed) throws ArrayComparisonFailure
{    byte[] bytes = createRandomByteArray(128, seed);    byte[] encryptedBytes = Type1FontUtil.charstringEncrypt(bytes, 4);    byte[] decryptedBytes = Type1FontUtil.charstringDecrypt(encryptedBytes, 4);    assertArrayEquals("Seed: " + seed, bytes, decryptedBytes);}
private static byte[] pdfbox_f2178_0(int arrayLength, long seed)
{    byte[] bytes = new byte[arrayLength];    Random ramdom = new Random(seed);    for (int i = 0; i < arrayLength; i++) {        bytes[i] = (byte) ramdom.nextInt(256);    }    return bytes;}
public void pdfbox_f2179_0() throws IOException
{    byte[] bs = new byte[1];    bs[0] = (byte) 200;    CMap cMap = new CMap();    cMap.addCharMapping(bs, "a");    assertTrue("a".equals(cMap.toUnicode(200)));}
public void pdfbox_f2180_0() throws IOException
{    try (TrueTypeFont ttf = new TTFParser().parse("target/pdfs/NotoEmoji-Regular.ttf")) {        CmapLookup cmap = ttf.getUnicodeCmapLookup(false);        assertEquals(886, cmap.getGlyphId(0x1F681));    }}
public void pdfbox_f2181_0() throws IOException
{    final String resourceDir = "src/test/resources/cmap";    File inDir = new File(resourceDir);    CMapParser parser = new CMapParser();    CMap cMap = parser.parse(new File(inDir, "CMapTest"));        byte[] bytes1 = { 0, 1 };    assertEquals("bytes 00 01 from bfrange <0001> <0005> <0041>", "A", cMap.toUnicode(toInt(bytes1, bytes1.length)));    byte[] bytes2 = { 1, 00 };    String str2 = "0";    assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", str2, cMap.toUnicode(toInt(bytes2, bytes2.length)));    byte[] bytes3 = { 1, 32 };    assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", "P", cMap.toUnicode(toInt(bytes3, bytes3.length)));    byte[] bytes4 = { 1, 33 };    assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", "R", cMap.toUnicode(toInt(bytes4, bytes4.length)));    byte[] bytes5 = { 0, 10 };    String str5 = "*";    assertEquals("bytes 00 0A from bfchar <000A> <002A>", str5, cMap.toUnicode(toInt(bytes5, bytes5.length)));    byte[] bytes6 = { 1, 10 };    String str6 = "+";    assertEquals("bytes 01 0A from bfchar <010A> <002B>", str6, cMap.toUnicode(toInt(bytes6, bytes6.length)));        int cid1 = 65;    assertEquals("CID 65 from cidrange <0000> <00ff> 0 ", 65, cMap.toCID(cid1));    int cid2 = 280;    int strCID2 = 0x0118;    assertEquals("CID 280 from cidrange <0100> <01ff> 256", strCID2, cMap.toCID(cid2));    int cid3 = 520;    int strCID3 = 0x0208;    assertEquals("CID 520 from cidchar <0208> 520", strCID3, cMap.toCID(cid3));    int cid4 = 300;    int strCID4 = 0x12C;    assertEquals("CID 300 from cidrange <0300> <0300> 300", strCID4, cMap.toCID(cid4));}
public void pdfbox_f2182_0() throws IOException
{    final String resourceDir = "src/main/resources/org/apache/fontbox/cmap";    File inDir = new File(resourceDir);    CMapParser parser = new CMapParser();    CMap cMap = parser.parse(new File(inDir, "Identity-H"));    assertEquals("Indentity-H CID 65", 65, cMap.toCID(65));    assertEquals("Indentity-H CID 12345", 12345, cMap.toCID(12345));    assertEquals("Indentity-H CID 0xFFFF", 0xFFFF, cMap.toCID(0xFFFF));}
public void pdfbox_f2183_0() throws IOException
{    final String resourceDir = "src/main/resources/org/apache/fontbox/cmap";    File inDir = new File(resourceDir);    CMapParser parser = new CMapParser();    CMap cMap = parser.parse(new File(inDir, "UniJIS-UCS2-H"));    assertEquals("UniJIS-UCS2-H CID 65 -> 34", 34, cMap.toCID(65));}
public void pdfbox_f2184_0() throws IOException
{    CMap cMap = new CMapParser().parse(new File("src/test/resources/cmap", "CMapNoWhitespace"));    assertNotNull("Failed to parse nasty CMap file", cMap);}
public void pdfbox_f2185_0() throws IOException
{    CMap cMap = new CMapParser().parse(new File("src/test/resources/cmap", "CMapMalformedbfrange1"));    assertNotNull("Failed to parse malformed CMap file", cMap);    byte[] bytes1 = { 0, 1 };    assertEquals("bytes 00 01 from bfrange <0001> <0009> <0041>", "A", cMap.toUnicode(toInt(bytes1, bytes1.length)));    byte[] bytes2 = { 1, 00 };    assertNull(cMap.toUnicode(toInt(bytes2, bytes2.length)));}
public void pdfbox_f2186_0() throws IOException
{    CMap cMap = new CMapParser().parse(new File("src/test/resources/cmap", "CMapMalformedbfrange2"));    assertNotNull("Failed to parse malformed CMap file", cMap);    assertEquals("bytes 00 01 from bfrange <0001> <0009> <0030>", "0", cMap.toUnicode(0x001));    assertEquals("bytes 02 32 from bfrange <0232> <0432> <0041>", "A", cMap.toUnicode(0x232));        assertNotNull(cMap.toUnicode(0x2F0));    assertNull(cMap.toUnicode(0x2F1));}
public void pdfbox_f2187_0() throws IOException
{    final File file = File.createTempFile("apache-pdfbox", ".dat");    try (OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(file))) {        final String content = "1234567890";        outputStream.write(content.getBytes("UTF-8"));        outputStream.flush();    }    final byte[] readBuffer = new byte[2];    final BufferedRandomAccessFile buffer = new BufferedRandomAccessFile(file, "r", 4);    int amountRead;    int totalAmountRead = 0;    while ((amountRead = buffer.read(readBuffer, 0, 2)) != -1) {        totalAmountRead += amountRead;    }    Assert.assertEquals(10, totalAmountRead);}
public void pdfbox_f2188_0() throws IOException
{        MemoryTTFDataStream memoryTTFDataStream = new MemoryTTFDataStream(GlyphSubstitutionTableTest.class.getResourceAsStream("/ttf/Lohit-Bengali.ttf"));    memoryTTFDataStream.seek(DATA_POSITION_FOR_GSUB_TABLE);    GlyphSubstitutionTable testClass = new GlyphSubstitutionTable(null);        testClass.read(null, memoryTTFDataStream);        GsubData gsubData = testClass.getGsubData();    assertNotNull(gsubData);    assertNotEquals(GsubData.NO_DATA_FOUND, gsubData);    assertEquals(Language.BENGALI, gsubData.getLanguage());    assertEquals("bng2", gsubData.getActiveScriptName());    assertEquals(new HashSet<>(EXPECTED_FEATURE_NAMES), gsubData.getSupportedFeatures());    String templatePathToFile = "/gsub/lohit_bengali/bng2/%s.txt";    for (String featureName : EXPECTED_FEATURE_NAMES) {        System.out.println("******* Testing feature: " + featureName);        Map<List<Integer>, Integer> expectedGsubTableRawData = getExpectedGsubTableRawData(String.format(templatePathToFile, featureName));        ScriptFeature scriptFeature = new MapBackedScriptFeature(featureName, expectedGsubTableRawData);        assertEquals(scriptFeature, gsubData.getFeature(featureName));    }}
private Map<List<Integer>, Integer> pdfbox_f2189_0(String pathToResource) throws IOException
{    Map<List<Integer>, Integer> gsubData = new HashMap<>();    try (BufferedReader br = new BufferedReader(new InputStreamReader(TestTTFParser.class.getResourceAsStream(pathToResource)))) {        while (true) {            String line = br.readLine();            if (line == null) {                break;            }            if (line.trim().length() == 0) {                continue;            }            if (line.startsWith("#")) {                continue;            }            String[] lineSplittedByKeyValue = line.split("=");            if (lineSplittedByKeyValue.length != 2) {                throw new IllegalArgumentException("invalid format");            }            List<Integer> oldGlyphIds = new ArrayList<>();            for (String value : lineSplittedByKeyValue[0].split(",")) {                oldGlyphIds.add(Integer.valueOf(value));            }            Integer newGlyphId = Integer.valueOf(lineSplittedByKeyValue[1]);            gsubData.put(oldGlyphIds, newGlyphId);        }    }    return gsubData;}
public void pdfbox_f2190_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "HrkJj", "68RetP", "Yx!23uyt" })));    String text = "12345HrkJjxabbcc68RetPxxxcfb1245678Yx!23uyt889000";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("12345", "HrkJj", "xabbcc", "68RetP", "xxxcfb1245678", "Yx!23uyt", "889000"), tokens);}
public void pdfbox_f2191_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "84_93", "104_82", "104_87" })));    String text = "84_112_93_104_82_61_96_102_93_104_87_110";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("84_112_93_", "104_82", "_61_96_102_93_", "104_87", "_110"), tokens);}
public void pdfbox_f2192_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "67_112_96", "74_112_76" })));    String text = "67_112_96_103_93_108_93";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("67_112_96", "_103_93_108_93"), tokens);}
public void pdfbox_f2193_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "67_112_96", "74_112_76" })));    String text = "94_67_112_96_112_91_103";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("94_", "67_112_96", "_112_91_103"), tokens);}
public void pdfbox_f2194_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "67_112", "76_112" })));    String text = "94_167_112_91_103";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(Arrays.asList("94_1", "67_112", "_91_103"), tokens);}
public void pdfbox_f2195_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "HrkJj", "68RetP", "Yx!23uyt" })));    String text = "Yx!23uyte12345HrkJjxabbcc68RetPxxxcfb1245678Yx!23uyt889000";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    List<String> tokenList = tokens;    assertEquals(0, tokenList.indexOf("Yx!23uyt"));}
public void pdfbox_f2196_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "HrkJj", "68RetP", "Yx!23uyt" })));    String text = "Yx!23uyte12345HrkJjxabbcc68RetPxxxcfb1245678Yx!23uyt889000HrkJj";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    assertEquals(0, tokens.indexOf("Yx!23uyt"));    assertEquals(2, tokens.indexOf("HrkJj"));    assertEquals(tokens.size() - 1, tokens.lastIndexOf("HrkJj"));}
public void pdfbox_f2197_0()
{        CompoundCharacterTokenizer tokenizer = new CompoundCharacterTokenizer(new HashSet<>(Arrays.asList(new String[] { "\u0995\u09cd\u09b7", "\u09aa\u09c1\u09a4\u09c1" })));    String text = "\u0986\u09ae\u09bf \u0995\u09cb\u09a8 \u09aa\u09a5\u09c7  \u0995\u09cd\u09b7\u09c0\u09b0\u09c7\u09b0 \u09b7\u09a8\u09cd\u09a1  \u09aa\u09c1\u09a4\u09c1\u09b2 \u09b0\u09c1\u09aa\u09cb  \u0997\u0999\u09cd\u0997\u09be \u098b\u09b7\u09bf";        List<String> tokens = tokenizer.tokenize(text);        StringBuilder sb = new StringBuilder();    tokens.forEach(token -> sb.append(token));    assertEquals(text, sb.toString());    List<String> tokenList = tokens;    assertTrue(tokenList.contains("\u0995\u09cd\u09b7"));    assertTrue(tokenList.contains("\u09aa\u09c1\u09a4\u09c1"));}
public void pdfbox_f2198_0()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(84, 93), Arrays.asList(102, 82), Arrays.asList(104, 87)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(84, 112, 93, 104, 82, 61, 96, 102, 93, 104, 87, 110);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(84, 112, 93, 104, 82, 61, 96, 102, 93), Arrays.asList(104, 87), Arrays.asList(110)), tokens);}
public void pdfbox_f2199_0()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(67, 112, 96), Arrays.asList(74, 112, 76)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(67, 112, 96, 103, 93, 108, 93);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(67, 112, 96), Arrays.asList(103, 93, 108, 93)), tokens);}
public void pdfbox_f2200_0()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(67, 112, 96), Arrays.asList(74, 112, 76)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(94, 67, 112, 96, 112, 91, 103);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(94), Arrays.asList(67, 112, 96), Arrays.asList(112, 91, 103)), tokens);}
public void pdfbox_f2201_0()
{        Set<List<Integer>> matchers = new HashSet<>(Arrays.asList(Arrays.asList(67, 112), Arrays.asList(76, 112)));    GlyphArraySplitter testClass = new GlyphArraySplitterRegexImpl(matchers);    List<Integer> glyphIds = Arrays.asList(94, 167, 112, 91, 103);        List<List<Integer>> tokens = testClass.split(glyphIds);        assertEquals(Arrays.asList(Arrays.asList(94, 167, 112, 91, 103)), tokens);}
public void pdfbox_f2202_0(GsubData gsubData, CmapLookup cmap)
{    System.err.println("Format:\n<Serial no.>.) <Space separated characters to be replaced> : RawUnicode: [<Space separated unicode representation of each character to be replaced in hexadecimal>] : <The compound character> : <The GlyphId with which these characters are replaced>");    Map<Integer, List<Integer>> rawGSubTableData = new HashMap<>();    for (String featureName : gsubData.getSupportedFeatures()) {        ScriptFeature scriptFeature = gsubData.getFeature(featureName);        for (List<Integer> glyphsToBeReplaced : scriptFeature.getAllGlyphIdsForSubstitution()) {            rawGSubTableData.put(scriptFeature.getReplacementForGlyphs(glyphsToBeReplaced), glyphsToBeReplaced);        }    }    for (String featureName : gsubData.getSupportedFeatures()) {        System.out.println("******************      " + featureName + "      ******************");        ScriptFeature scriptFeature = gsubData.getFeature(featureName);        int index = 0;        for (List<Integer> glyphsToBeReplaced : scriptFeature.getAllGlyphIdsForSubstitution()) {            String unicodeText = getUnicodeString(rawGSubTableData, cmap, glyphsToBeReplaced);            System.out.println(++index + ".) " + getExplainedUnicodeText(unicodeText) + " : " + scriptFeature.getReplacementForGlyphs(glyphsToBeReplaced));        }    }}
private String pdfbox_f2203_0(Map<Integer, List<Integer>> rawGSubTableData, CmapLookup cmap, Integer glyphId)
{    List<Integer> keyChars = cmap.getCharCodes(glyphId);        if (keyChars == null) {        List<Integer> constituentGlyphs = rawGSubTableData.get(glyphId);        if (constituentGlyphs == null || constituentGlyphs.isEmpty()) {            String message = "lookup for the glyphId: " + glyphId + " failed, as no corresponding Unicode char found mapped to it";            throw new IllegalStateException(message);        } else {            return getUnicodeString(rawGSubTableData, cmap, constituentGlyphs);        }    } else {        StringBuilder sb = new StringBuilder();        for (int unicodeChar : keyChars) {            sb.append((char) unicodeChar);        }        return sb.toString();    }}
private String pdfbox_f2204_0(Map<Integer, List<Integer>> rawGSubTableData, CmapLookup cmap, List<Integer> glyphIDs)
{    StringBuilder sb = new StringBuilder();    for (Integer glyphId : glyphIDs) {        sb.append(getUnicodeChar(rawGSubTableData, cmap, glyphId));    }    return sb.toString();}
private String pdfbox_f2205_0(String unicodeText)
{    StringBuilder sb = new StringBuilder();    for (char unicode : unicodeText.toCharArray()) {        sb.append(unicode).append(" ");    }    sb.append(":");    sb.append(" RawUnicode: [");    for (char unicode : unicodeText.toCharArray()) {        sb.append("\\u0").append(Integer.toHexString(unicode).toUpperCase()).append(" ");    }    sb.append("] : ");    sb.append(unicodeText);    return sb.toString();}
public void pdfbox_f2206_0() throws IOException
{    MemoryTTFDataStream memoryTTFDataStream = new MemoryTTFDataStream(GSUBTableDebugger.class.getResourceAsStream(LOHIT_BENGALI_FONT_FILE));    memoryTTFDataStream.seek(GlyphSubstitutionTableTest.DATA_POSITION_FOR_GSUB_TABLE);    GlyphSubstitutionTable glyphSubstitutionTable = new GlyphSubstitutionTable(null);    glyphSubstitutionTable.read(null, memoryTTFDataStream);    TrueTypeFont trueTypeFont = new TTFParser().parse(GSUBTableDebugger.class.getResourceAsStream(LOHIT_BENGALI_FONT_FILE));    GsubData gsubData = glyphSubstitutionTable.getGsubData();    new GSUBTablePrintUtil().printCharacterToGlyph(gsubData, trueTypeFont.getUnicodeCmapLookup());}
public void pdfbox_f2207_0() throws IOException
{    RAFDataStream raf = new RAFDataStream("src/test/resources/ttf/LiberationSans-Regular.ttf", "r");    raf.close();    raf.close();}
public void pdfbox_f2208_0() throws IOException
{    byte[] byteArray = new byte[10];    ByteArrayInputStream inputStream = new ByteArrayInputStream(byteArray);    MemoryTTFDataStream dataStream = new MemoryTTFDataStream(inputStream);    int value = dataStream.read();    try {        while (value > -1) {            value = dataStream.read();        }    } catch (ArrayIndexOutOfBoundsException exception) {        fail("EOF not detected!");    } finally {        dataStream.close();    }}
public void pdfbox_f2209_0() throws IOException
{    final File testFile = new File("src/test/resources/ttf/LiberationSans-Regular.ttf");    TimeZone utc = TimeZone.getTimeZone("UTC");            TimeZone.setDefault(TimeZone.getTimeZone("America/Los Angeles"));    TTFParser parser = new TTFParser();    TrueTypeFont ttf = parser.parse(testFile);    Calendar created = ttf.getHeader().getCreated();    assertEquals(created.getTimeZone(), utc);    Calendar target = Calendar.getInstance(utc);    target.set(2012, 9, 4, 11, 2, 31);    target.set(Calendar.MILLISECOND, 0);    assertEquals(target, created);}
public void pdfbox_f2210_0() throws IOException
{    TrueTypeFont x = new TTFParser().parse("src/test/resources/ttf/LiberationSans-Regular.ttf");    TTFSubsetter ttfSubsetter = new TTFSubsetter(x);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(1, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertNotNull(subset.getGlyph().getGlyph(0));    }}
public void pdfbox_f2211_0() throws IOException
{    TrueTypeFont x = new TTFParser().parse("src/test/resources/ttf/LiberationSans-Regular.ttf");        List<String> tables = new ArrayList<>();    tables.add("head");    tables.add("hhea");    tables.add("loca");    tables.add("maxp");    tables.add("cvt ");    tables.add("prep");    tables.add("glyf");    tables.add("hmtx");    tables.add("fpgm");    tables.add("gasp");    TTFSubsetter ttfSubsetter = new TTFSubsetter(x, tables);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(1, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertNotNull(subset.getGlyph().getGlyph(0));    }}
public void pdfbox_f2212_0() throws IOException
{    TrueTypeFont full = new TTFParser().parse("src/test/resources/ttf/LiberationSans-Regular.ttf");    TTFSubsetter ttfSubsetter = new TTFSubsetter(full);    ttfSubsetter.add('a');    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(2, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertEquals(1, subset.nameToGID("a"));        assertNotNull(subset.getGlyph().getGlyph(0));        assertNotNull(subset.getGlyph().getGlyph(1));        assertNull(subset.getGlyph().getGlyph(2));        assertEquals(full.getAdvanceWidth(full.nameToGID("a")), subset.getAdvanceWidth(subset.nameToGID("a")));        assertEquals(full.getHorizontalMetrics().getLeftSideBearing(full.nameToGID("a")), subset.getHorizontalMetrics().getLeftSideBearing(subset.nameToGID("a")));    }}
public void pdfbox_f2213_0() throws IOException
{    System.out.println("Searching for SimHei font...");    FontFileFinder fontFileFinder = new FontFileFinder();    List<URI> files = fontFileFinder.find();    File simhei = null;    for (URI uri : files) {        if (uri.getPath() != null && uri.getPath().toLowerCase(Locale.US).endsWith("simhei.ttf")) {            simhei = new File(uri);        }    }    if (simhei == null) {        System.err.println("SimHei font not available on this machine, test skipped");        return;    }    System.out.println("SimHei font found!");    TrueTypeFont full = new TTFParser().parse(simhei);            List<String> tables = new ArrayList<>();    tables.add("head");    tables.add("hhea");    tables.add("loca");    tables.add("maxp");    tables.add("cvt ");    tables.add("prep");    tables.add("glyf");    tables.add("hmtx");    tables.add("fpgm");    tables.add("gasp");    TTFSubsetter ttfSubsetter = new TTFSubsetter(full, tables);    String chinese = "!";    for (int offset = 0; offset < chinese.length(); ) {        int codePoint = chinese.codePointAt(offset);        ttfSubsetter.add(codePoint);        offset += Character.charCount(codePoint);    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(6, subset.getNumberOfGlyphs());        for (Entry<Integer, Integer> entry : ttfSubsetter.getGIDMap().entrySet()) {            Integer newGID = entry.getKey();            Integer oldGID = entry.getValue();            assertEquals(full.getAdvanceWidth(oldGID), subset.getAdvanceWidth(newGID));            assertEquals(full.getHorizontalMetrics().getLeftSideBearing(oldGID), subset.getHorizontalMetrics().getLeftSideBearing(newGID));        }    }}
public void pdfbox_f2214_0() throws IOException
{    TrueTypeFont full = new TTFParser().parse("target/pdfs/DejaVuSansMono.ttf");    TTFSubsetter ttfSubsetter = new TTFSubsetter(full);    ttfSubsetter.add('A');    ttfSubsetter.add(' ');    ttfSubsetter.add('B');    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser().parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(4, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertEquals(1, subset.nameToGID("space"));        assertEquals(2, subset.nameToGID("A"));        assertEquals(3, subset.nameToGID("B"));        String[] names = new String[] { "A", "B", "space" };        for (String name : names) {            assertEquals(full.getAdvanceWidth(full.nameToGID(name)), subset.getAdvanceWidth(subset.nameToGID(name)));            assertEquals(full.getHorizontalMetrics().getLeftSideBearing(full.nameToGID(name)), subset.getHorizontalMetrics().getLeftSideBearing(subset.nameToGID(name)));        }    }}
public void pdfbox_f2215_0() throws IOException
{    final File testFile = new File("src/test/resources/ttf/LiberationSans-Regular.ttf");    TrueTypeFont ttf = new TTFParser().parse(testFile);    TTFSubsetter ttfSubsetter = new TTFSubsetter(ttf);    ttfSubsetter.add('');    ttfSubsetter.add('\u200A');    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ttfSubsetter.writeToStream(baos);    try (TrueTypeFont subset = new TTFParser(true).parse(new ByteArrayInputStream(baos.toByteArray()))) {        assertEquals(5, subset.getNumberOfGlyphs());        assertEquals(0, subset.nameToGID(".notdef"));        assertEquals(1, subset.nameToGID("O"));        assertEquals(2, subset.nameToGID("Odieresis"));        assertEquals(3, subset.nameToGID("uni200A"));        assertEquals(4, subset.nameToGID("dieresis.uc"));        PostScriptTable pst = subset.getPostScript();        assertEquals(pst.getName(0), ".notdef");        assertEquals(pst.getName(1), "O");        assertEquals(pst.getName(2), "Odieresis");        assertEquals(pst.getName(3), "uni200A");        assertEquals(pst.getName(4), "dieresis.uc");        assertTrue("Hair space path should be empty", subset.getPath("uni200A").getBounds2D().isEmpty());        assertFalse("UC dieresis path should not be empty", subset.getPath("dieresis.uc").getBounds2D().isEmpty());    }}
public void pdfbox_f2216_0(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace colorSpace = getColorSpace();    if (!(colorSpace instanceof PDPattern)) {        if (arguments.size() < colorSpace.getNumberOfComponents()) {            throw new MissingOperandException(operator, arguments);        }        if (!checkArrayTypesClass(arguments, COSNumber.class)) {            return;        }    }    COSArray array = new COSArray();    array.addAll(arguments);    setColor(new PDColor(array, colorSpace));}
protected PDColor pdfbox_f2217_0()
{    return context.getGraphicsState().getNonStrokingColor();}
protected void pdfbox_f2218_0(PDColor color)
{    context.getGraphicsState().setNonStrokingColor(color);}
protected PDColorSpace pdfbox_f2219_0()
{    return context.getGraphicsState().getNonStrokingColorSpace();}
public String pdfbox_f2220_0()
{    return OperatorName.NON_STROKING_COLOR;}
public String pdfbox_f2221_0()
{    return OperatorName.NON_STROKING_COLOR_N;}
public void pdfbox_f2222_0(Operator operator, List<COSBase> arguments) throws IOException
{    COSName name = (COSName) arguments.get(0);    PDColorSpace cs = context.getResources().getColorSpace(name);    context.getGraphicsState().setNonStrokingColorSpace(cs);    context.getGraphicsState().setNonStrokingColor(cs.getInitialColor());}
public String pdfbox_f2223_0()
{    return OperatorName.NON_STROKING_COLORSPACE;}
public void pdfbox_f2224_0(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICECMYK);    context.getGraphicsState().setNonStrokingColorSpace(cs);    super.process(operator, arguments);}
public String pdfbox_f2225_0()
{    return OperatorName.NON_STROKING_CMYK;}
public void pdfbox_f2226_0(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICEGRAY);    context.getGraphicsState().setNonStrokingColorSpace(cs);    super.process(operator, arguments);}
public String pdfbox_f2227_0()
{    return OperatorName.NON_STROKING_GRAY;}
public void pdfbox_f2228_0(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICERGB);    context.getGraphicsState().setNonStrokingColorSpace(cs);    super.process(operator, arguments);}
public String pdfbox_f2229_0()
{    return OperatorName.NON_STROKING_RGB;}
protected PDColor pdfbox_f2230_0()
{    return context.getGraphicsState().getStrokingColor();}
protected void pdfbox_f2231_0(PDColor color)
{    context.getGraphicsState().setStrokingColor(color);}
protected PDColorSpace pdfbox_f2232_0()
{    return context.getGraphicsState().getStrokingColorSpace();}
public String pdfbox_f2233_0()
{    return OperatorName.STROKING_COLOR;}
public String pdfbox_f2234_0()
{    return OperatorName.STROKING_COLOR_N;}
public void pdfbox_f2235_0(Operator operator, List<COSBase> arguments) throws IOException
{    COSBase base = arguments.get(0);    if (!(base instanceof COSName)) {        return;    }    PDColorSpace cs = context.getResources().getColorSpace((COSName) base);    context.getGraphicsState().setStrokingColorSpace(cs);    context.getGraphicsState().setStrokingColor(cs.getInitialColor());}
public String pdfbox_f2236_0()
{    return OperatorName.STROKING_COLORSPACE;}
public void pdfbox_f2237_0(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICECMYK);    context.getGraphicsState().setStrokingColorSpace(cs);    super.process(operator, arguments);}
public String pdfbox_f2238_0()
{    return OperatorName.STROKING_COLOR_CMYK;}
public void pdfbox_f2239_0(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICEGRAY);    context.getGraphicsState().setStrokingColorSpace(cs);    super.process(operator, arguments);}
public String pdfbox_f2240_0()
{    return OperatorName.STROKING_COLOR_GRAY;}
public void pdfbox_f2241_0(Operator operator, List<COSBase> arguments) throws IOException
{    PDColorSpace cs = context.getResources().getColorSpace(COSName.DEVICERGB);    context.getGraphicsState().setStrokingColorSpace(cs);    super.process(operator, arguments);}
public String pdfbox_f2242_0()
{    return OperatorName.STROKING_COLOR_RGB;}
public void pdfbox_f2243_1(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSName)) {        return;    }    COSName name = (COSName) base0;    if (context.getResources().isImageXObject(name)) {                return;    }    PDXObject xobject = context.getResources().getXObject(name);    if (xobject instanceof PDFormXObject) {        PDFormXObject form = (PDFormXObject) xobject;        PDResources formResources = form.getResources();        if (formResources != null && context.getResources().getCOSObject() == formResources.getCOSObject()) {                        return;        }        if (form instanceof PDTransparencyGroup) {            context.showTransparencyGroup((PDTransparencyGroup) form);        } else {            context.showForm(form);        }    }}
public String pdfbox_f2244_0()
{    return OperatorName.DRAW_OBJECT;}
public void pdfbox_f2245_0(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 4) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x = (COSNumber) operands.get(0);    COSNumber y = (COSNumber) operands.get(1);    COSNumber w = (COSNumber) operands.get(2);    COSNumber h = (COSNumber) operands.get(3);    float x1 = x.floatValue();    float y1 = y.floatValue();        float x2 = w.floatValue() + x1;    float y2 = h.floatValue() + y1;    Point2D p0 = context.transformedPoint(x1, y1);    Point2D p1 = context.transformedPoint(x2, y1);    Point2D p2 = context.transformedPoint(x2, y2);    Point2D p3 = context.transformedPoint(x1, y2);    context.appendRectangle(p0, p1, p2, p3);}
public String pdfbox_f2246_0()
{    return OperatorName.APPEND_RECT;}
public void pdfbox_f2247_0(Operator operator, List<COSBase> operands) throws IOException
{    if (operator.getImageData() == null || operator.getImageData().length == 0) {        return;    }    PDImage image = new PDInlineImage(operator.getImageParameters(), operator.getImageData(), context.getResources());    context.drawImage(image);}
public String pdfbox_f2248_0()
{    return OperatorName.BEGIN_INLINE_IMAGE;}
public void pdfbox_f2249_0(Operator operator, List<COSBase> operands) throws IOException
{    context.clip(GeneralPath.WIND_EVEN_ODD);}
public String pdfbox_f2250_0()
{    return OperatorName.CLIP_EVEN_ODD;}
public void pdfbox_f2251_0(Operator operator, List<COSBase> operands) throws IOException
{    context.clip(GeneralPath.WIND_NON_ZERO);}
public String pdfbox_f2252_0()
{    return OperatorName.CLIP_NON_ZERO;}
public void pdfbox_f2253_0(Operator operator, List<COSBase> arguments) throws IOException
{    context.processOperator(OperatorName.CLOSE_PATH, arguments);    context.processOperator(OperatorName.STROKE_PATH, arguments);}
public String pdfbox_f2254_0()
{    return OperatorName.CLOSE_AND_STROKE;}
public void pdfbox_f2255_0(Operator operator, List<COSBase> operands) throws IOException
{    context.processOperator(OperatorName.CLOSE_PATH, operands);    context.processOperator(OperatorName.FILL_EVEN_ODD_AND_STROKE, operands);}
public String pdfbox_f2256_0()
{    return OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE;}
public void pdfbox_f2257_0(Operator operator, List<COSBase> operands) throws IOException
{    context.processOperator(OperatorName.CLOSE_PATH, operands);    context.processOperator(OperatorName.FILL_NON_ZERO_AND_STROKE, operands);}
public String pdfbox_f2258_0()
{    return OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE;}
public void pdfbox_f2259_1(Operator operator, List<COSBase> operands) throws IOException
{    if (context.getCurrentPoint() == null) {                return;    }    context.closePath();}
public String pdfbox_f2260_0()
{    return OperatorName.CLOSE_PATH;}
public void pdfbox_f2261_1(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 6) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x1 = (COSNumber) operands.get(0);    COSNumber y1 = (COSNumber) operands.get(1);    COSNumber x2 = (COSNumber) operands.get(2);    COSNumber y2 = (COSNumber) operands.get(3);    COSNumber x3 = (COSNumber) operands.get(4);    COSNumber y3 = (COSNumber) operands.get(5);    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());    if (context.getCurrentPoint() == null) {                context.moveTo(point3.x, point3.y);    } else {        context.curveTo(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y);    }}
public String pdfbox_f2262_0()
{    return OperatorName.CURVE_TO;}
public void pdfbox_f2263_0(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 4) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x1 = (COSNumber) operands.get(0);    COSNumber y1 = (COSNumber) operands.get(1);    COSNumber x3 = (COSNumber) operands.get(2);    COSNumber y3 = (COSNumber) operands.get(3);    Point2D.Float point1 = context.transformedPoint(x1.floatValue(), y1.floatValue());    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());    context.curveTo(point1.x, point1.y, point3.x, point3.y, point3.x, point3.y);}
public String pdfbox_f2264_0()
{    return OperatorName.CURVE_TO_REPLICATE_FINAL_POINT;}
public void pdfbox_f2265_1(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 4) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber x2 = (COSNumber) operands.get(0);    COSNumber y2 = (COSNumber) operands.get(1);    COSNumber x3 = (COSNumber) operands.get(2);    COSNumber y3 = (COSNumber) operands.get(3);    Point2D currentPoint = context.getCurrentPoint();    Point2D.Float point2 = context.transformedPoint(x2.floatValue(), y2.floatValue());    Point2D.Float point3 = context.transformedPoint(x3.floatValue(), y3.floatValue());    if (currentPoint == null) {                context.moveTo(point3.x, point3.y);    } else {        context.curveTo((float) currentPoint.getX(), (float) currentPoint.getY(), point2.x, point2.y, point3.x, point3.y);    }}
public String pdfbox_f2266_0()
{    return OperatorName.CURVE_TO_REPLICATE_INITIAL_POINT;}
public void pdfbox_f2267_1(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    COSBase base0 = operands.get(0);    if (!(base0 instanceof COSName)) {        return;    }    COSName objectName = (COSName) base0;    PDXObject xobject = context.getResources().getXObject(objectName);    if (xobject == null) {        throw new MissingResourceException("Missing XObject: " + objectName.getName());    } else if (xobject instanceof PDImageXObject) {        PDImageXObject image = (PDImageXObject) xobject;        context.drawImage(image);    } else if (xobject instanceof PDFormXObject) {        PDFormXObject form = (PDFormXObject) xobject;        PDResources formResources = form.getResources();        if (formResources != null && context.getResources().getCOSObject() == formResources.getCOSObject()) {                                                return;        }        if (form instanceof PDTransparencyGroup) {            context.showTransparencyGroup((PDTransparencyGroup) form);        } else {            context.showForm(form);        }    }}
public String pdfbox_f2268_0()
{    return OperatorName.DRAW_OBJECT;}
public void pdfbox_f2269_0(Operator operator, List<COSBase> operands) throws IOException
{    context.endPath();}
public String pdfbox_f2270_0()
{    return OperatorName.ENDPATH;}
public void pdfbox_f2271_0(Operator operator, List<COSBase> operands) throws IOException
{    context.fillAndStrokePath(GeneralPath.WIND_EVEN_ODD);}
public String pdfbox_f2272_0()
{    return OperatorName.FILL_EVEN_ODD_AND_STROKE;}
public void pdfbox_f2273_0(Operator operator, List<COSBase> operands) throws IOException
{    context.fillPath(GeneralPath.WIND_EVEN_ODD);}
public String pdfbox_f2274_0()
{    return OperatorName.FILL_EVEN_ODD;}
public void pdfbox_f2275_0(Operator operator, List<COSBase> operands) throws IOException
{    context.fillAndStrokePath(GeneralPath.WIND_NON_ZERO);}
public String pdfbox_f2276_0()
{    return OperatorName.FILL_NON_ZERO_AND_STROKE;}
public final void pdfbox_f2277_0(Operator operator, List<COSBase> operands) throws IOException
{    context.fillPath(GeneralPath.WIND_NON_ZERO);}
public String pdfbox_f2278_0()
{    return OperatorName.FILL_NON_ZERO;}
public void pdfbox_f2279_0(PDFStreamEngine context)
{    super.setContext(context);    this.context = (PDFGraphicsStreamEngine) context;}
public String pdfbox_f2280_0()
{    return OperatorName.LEGACY_FILL_NON_ZERO;}
public void pdfbox_f2281_1(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 2) {        throw new MissingOperandException(operator, operands);    }    COSBase base0 = operands.get(0);    if (!(base0 instanceof COSNumber)) {        return;    }    COSBase base1 = operands.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }        COSNumber x = (COSNumber) base0;    COSNumber y = (COSNumber) base1;    Point2D.Float pos = context.transformedPoint(x.floatValue(), y.floatValue());    if (context.getCurrentPoint() == null) {                context.moveTo(pos.x, pos.y);    } else {        context.lineTo(pos.x, pos.y);    }}
public String pdfbox_f2282_0()
{    return OperatorName.LINE_TO;}
public void pdfbox_f2283_0(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.size() < 2) {        throw new MissingOperandException(operator, operands);    }    COSBase base0 = operands.get(0);    if (!(base0 instanceof COSNumber)) {        return;    }    COSBase base1 = operands.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }    COSNumber x = (COSNumber) base0;    COSNumber y = (COSNumber) base1;    Point2D.Float pos = context.transformedPoint(x.floatValue(), y.floatValue());    context.moveTo(pos.x, pos.y);}
public String pdfbox_f2284_0()
{    return OperatorName.MOVE_TO;}
public void pdfbox_f2285_0(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    context.shadingFill((COSName) operands.get(0));}
public String pdfbox_f2286_0()
{    return OperatorName.SHADING_FILL;}
public void pdfbox_f2287_0(Operator operator, List<COSBase> operands) throws IOException
{    context.strokePath();}
public String pdfbox_f2288_0()
{    return OperatorName.STROKE_PATH;}
public void pdfbox_f2289_0(Operator operator, List<COSBase> arguments) throws IOException
{    COSName tag = null;    for (COSBase argument : arguments) {        if (argument instanceof COSName) {            tag = (COSName) argument;        }    }    context.beginMarkedContentSequence(tag, null);}
public String pdfbox_f2290_0()
{    return OperatorName.BEGIN_MARKED_CONTENT;}
public void pdfbox_f2291_0(Operator operator, List<COSBase> arguments) throws IOException
{    COSName tag = null;    COSDictionary properties = null;    for (COSBase argument : arguments) {        if (argument instanceof COSName) {            tag = (COSName) argument;        } else if (argument instanceof COSDictionary) {            properties = (COSDictionary) argument;        }    }    context.beginMarkedContentSequence(tag, properties);}
public String pdfbox_f2292_0()
{    return OperatorName.BEGIN_MARKED_CONTENT_SEQ;}
public void pdfbox_f2293_1(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSName)) {        return;    }    COSName name = (COSName) base0;    PDXObject xobject = context.getResources().getXObject(name);    ((PDFMarkedContentExtractor) context).xobject(xobject);    if (xobject instanceof PDFormXObject) {        PDFormXObject form = (PDFormXObject) xobject;        PDResources formResources = form.getResources();        if (formResources != null && context.getResources().getCOSObject() == formResources.getCOSObject()) {                        return;        }        if (form instanceof PDTransparencyGroup) {            context.showTransparencyGroup((PDTransparencyGroup) form);        } else {            context.showForm(form);        }    }}
public String pdfbox_f2294_0()
{    return OperatorName.DRAW_OBJECT;}
public void pdfbox_f2295_0(Operator operator, List<COSBase> arguments) throws IOException
{    context.endMarkedContentSequence();}
public String pdfbox_f2296_0()
{    return OperatorName.END_MARKED_CONTENT;}
public static Operator pdfbox_f2297_0(String operator)
{    Operator operation;    if (operator.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA) || OperatorName.BEGIN_INLINE_IMAGE.equals(operator)) {                operation = new Operator(operator);    } else {        operation = operators.get(operator);        if (operation == null) {                                    operation = operators.putIfAbsent(operator, new Operator(operator));            if (operation == null) {                operation = operators.get(operator);            }        }    }    return operation;}
public String pdfbox_f2298_0()
{    return theOperator;}
public String pdfbox_f2299_0()
{    return "PDFOperator{" + theOperator + "}";}
public byte[] pdfbox_f2300_0()
{    return this.imageData;}
public void pdfbox_f2301_0(byte[] imageDataArray)
{    imageData = imageDataArray;}
public COSDictionary pdfbox_f2302_0()
{    return imageParameters;}
public void pdfbox_f2303_0(COSDictionary params)
{    imageParameters = params;}
protected final PDFStreamEngine pdfbox_f2304_0()
{    return context;}
public void pdfbox_f2305_0(PDFStreamEngine context)
{    this.context = context;}
public boolean pdfbox_f2306_0(List<COSBase> operands, Class<?> clazz)
{    for (COSBase base : operands) {        if (!clazz.isInstance(base)) {            return false;        }    }    return true;}
public void pdfbox_f2307_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 6) {        throw new MissingOperandException(operator, arguments);    }    if (!checkArrayTypesClass(arguments, COSNumber.class)) {        return;    }        COSNumber a = (COSNumber) arguments.get(0);    COSNumber b = (COSNumber) arguments.get(1);    COSNumber c = (COSNumber) arguments.get(2);    COSNumber d = (COSNumber) arguments.get(3);    COSNumber e = (COSNumber) arguments.get(4);    COSNumber f = (COSNumber) arguments.get(5);    Matrix matrix = new Matrix(a.floatValue(), b.floatValue(), c.floatValue(), d.floatValue(), e.floatValue(), f.floatValue());    context.getGraphicsState().getCurrentTransformationMatrix().concatenate(matrix);}
public String pdfbox_f2308_0()
{    return OperatorName.CONCAT;}
public void pdfbox_f2309_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (context.getGraphicsStackSize() > 1) {        context.restoreGraphicsState();    } else {                throw new EmptyGraphicsStackException();    }}
public String pdfbox_f2310_0()
{    return OperatorName.RESTORE;}
public void pdfbox_f2311_0(Operator operator, List<COSBase> arguments)
{    context.saveGraphicsState();}
public String pdfbox_f2312_0()
{    return OperatorName.SAVE;}
public void pdfbox_f2313_0(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    if (!checkArrayTypesClass(operands, COSNumber.class)) {        return;    }    COSNumber value = (COSNumber) operands.get(0);    context.getGraphicsState().setFlatness(value.floatValue());}
public String pdfbox_f2314_0()
{    return OperatorName.SET_FLATNESS;}
public void pdfbox_f2315_1(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSName)) {        return;    }        COSName graphicsName = (COSName) base0;    PDExtendedGraphicsState gs = context.getResources().getExtGState(graphicsName);    if (gs == null) {                return;    }    gs.copyIntoGraphicsState(context.getGraphicsState());}
public String pdfbox_f2316_0()
{    return OperatorName.SET_GRAPHICS_STATE_PARAMS;}
public void pdfbox_f2317_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    int lineCapStyle = ((COSNumber) arguments.get(0)).intValue();    context.getGraphicsState().setLineCap(lineCapStyle);}
public String pdfbox_f2318_0()
{    return OperatorName.SET_LINE_CAPSTYLE;}
public void pdfbox_f2319_1(Operator operator, List<COSBase> arguments) throws MissingOperandException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSArray)) {        return;    }    COSBase base1 = arguments.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }    COSArray dashArray = (COSArray) base0;    int dashPhase = ((COSNumber) base1).intValue();    boolean allZero = true;    for (COSBase base : dashArray) {        if (base instanceof COSNumber) {            COSNumber num = (COSNumber) base;            if (Float.compare(num.floatValue(), 0) != 0) {                allZero = false;                break;            }        } else {                        dashArray = new COSArray();            break;        }    }    if (dashArray.size() > 0 && allZero) {                dashArray = new COSArray();    }    context.setLineDashPattern(dashArray, dashPhase);}
public String pdfbox_f2320_0()
{    return OperatorName.SET_LINE_DASHPATTERN;}
public void pdfbox_f2321_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    int lineJoinStyle = ((COSNumber) arguments.get(0)).intValue();    context.getGraphicsState().setLineJoin(lineJoinStyle);}
public String pdfbox_f2322_0()
{    return OperatorName.SET_LINE_JOINSTYLE;}
public void pdfbox_f2323_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSNumber miterLimit = (COSNumber) arguments.get(0);    context.getGraphicsState().setMiterLimit(miterLimit.floatValue());}
public String pdfbox_f2324_0()
{    return OperatorName.SET_LINE_MITERLIMIT;}
public void pdfbox_f2325_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSNumber width = (COSNumber) arguments.get(0);    context.getGraphicsState().setLineWidth(width.floatValue());}
public String pdfbox_f2326_0()
{    return OperatorName.SET_LINE_WIDTH;}
public void pdfbox_f2327_0(Operator operator, List<COSBase> arguments) throws MissingOperandException
{    if (arguments.size() < 6) {        throw new MissingOperandException(operator, arguments);    }    if (!checkArrayTypesClass(arguments, COSNumber.class)) {        return;    }    COSNumber a = (COSNumber) arguments.get(0);    COSNumber b = (COSNumber) arguments.get(1);    COSNumber c = (COSNumber) arguments.get(2);    COSNumber d = (COSNumber) arguments.get(3);    COSNumber e = (COSNumber) arguments.get(4);    COSNumber f = (COSNumber) arguments.get(5);    Matrix matrix = new Matrix(a.floatValue(), b.floatValue(), c.floatValue(), d.floatValue(), e.floatValue(), f.floatValue());    context.setTextMatrix(matrix);    context.setTextLineMatrix(matrix.clone());}
public String pdfbox_f2328_0()
{    return OperatorName.SET_MATRIX;}
public void pdfbox_f2329_0(Operator operator, List<COSBase> operands) throws IOException
{    if (operands.isEmpty()) {        throw new MissingOperandException(operator, operands);    }    COSBase base = operands.get(0);    if (!(base instanceof COSName)) {        return;    }    context.getGraphicsState().setRenderingIntent(RenderingIntent.fromString(((COSName) base).getName()));}
public String pdfbox_f2330_0()
{    return OperatorName.SET_RENDERINGINTENT;}
public void pdfbox_f2331_0(Operator operator, List<COSBase> arguments) throws IOException
{    context.setTextMatrix(new Matrix());    context.setTextLineMatrix(new Matrix());    context.beginText();}
public String pdfbox_f2332_0()
{    return OperatorName.BEGIN_TEXT;}
public void pdfbox_f2333_0(Operator operator, List<COSBase> arguments) throws IOException
{    context.setTextMatrix(null);    context.setTextLineMatrix(null);    context.endText();}
public String pdfbox_f2334_0()
{    return OperatorName.END_TEXT;}
public void pdfbox_f2335_1(Operator operator, List<COSBase> arguments) throws MissingOperandException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }    Matrix textLineMatrix = context.getTextLineMatrix();    if (textLineMatrix == null) {                return;    }    COSBase base0 = arguments.get(0);    COSBase base1 = arguments.get(1);    if (!(base0 instanceof COSNumber)) {        return;    }    if (!(base1 instanceof COSNumber)) {        return;    }    COSNumber x = (COSNumber) base0;    COSNumber y = (COSNumber) base1;    Matrix matrix = new Matrix(1, 0, 0, 1, x.floatValue(), y.floatValue());    textLineMatrix.concatenate(matrix);    context.setTextMatrix(textLineMatrix.clone());}
public String pdfbox_f2336_0()
{    return OperatorName.MOVE_TEXT;}
public void pdfbox_f2337_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }        COSBase base1 = arguments.get(1);    if (!(base1 instanceof COSNumber)) {        return;    }    COSNumber y = (COSNumber) base1;    List<COSBase> args = new ArrayList<>();    args.add(new COSFloat(-1 * y.floatValue()));    context.processOperator(OperatorName.SET_TEXT_LEADING, args);    context.processOperator(OperatorName.MOVE_TEXT, arguments);}
public String pdfbox_f2338_0()
{    return OperatorName.MOVE_TEXT_SET_LEADING;}
public void pdfbox_f2339_0(Operator operator, List<COSBase> arguments) throws IOException
{        List<COSBase> args = new ArrayList<>();    args.add(new COSFloat(0f));            args.add(new COSFloat(-1 * context.getGraphicsState().getTextState().getLeading()));        context.processOperator(OperatorName.MOVE_TEXT, args);}
public String pdfbox_f2340_0()
{    return OperatorName.NEXT_LINE;}
public void pdfbox_f2341_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }                Object charSpacing = arguments.get(arguments.size() - 1);    if (charSpacing instanceof COSNumber) {        COSNumber characterSpacing = (COSNumber) charSpacing;        context.getGraphicsState().getTextState().setCharacterSpacing(characterSpacing.floatValue());    }}
public String pdfbox_f2342_0()
{    return OperatorName.SET_CHAR_SPACING;}
public void pdfbox_f2343_1(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 2) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    COSBase base1 = arguments.get(1);    if (!(base0 instanceof COSName)) {        return;    }    if (!(base1 instanceof COSNumber)) {        return;    }    COSName fontName = (COSName) base0;    float fontSize = ((COSNumber) base1).floatValue();    context.getGraphicsState().getTextState().setFontSize(fontSize);    PDFont font = context.getResources().getFont(fontName);    if (font == null) {            }    context.getGraphicsState().getTextState().setFont(font);}
public String pdfbox_f2344_0()
{    return OperatorName.SET_FONT_AND_SIZE;}
public void pdfbox_f2345_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSNumber scaling = (COSNumber) arguments.get(0);    context.getGraphicsState().getTextState().setHorizontalScaling(scaling.floatValue());}
public String pdfbox_f2346_0()
{    return OperatorName.SET_TEXT_HORIZONTAL_SCALING;}
public void pdfbox_f2347_0(Operator operator, List<COSBase> arguments)
{    COSNumber leading = (COSNumber) arguments.get(0);    context.getGraphicsState().getTextState().setLeading(leading.floatValue());}
public String pdfbox_f2348_0()
{    return OperatorName.SET_TEXT_LEADING;}
public void pdfbox_f2349_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        throw new MissingOperandException(operator, arguments);    }    COSBase base0 = arguments.get(0);    if (!(base0 instanceof COSNumber)) {        return;    }    COSNumber mode = (COSNumber) base0;    int val = mode.intValue();    if (val < 0 || val >= RenderingMode.values().length) {        return;    }    RenderingMode renderingMode = RenderingMode.fromInt(val);    context.getGraphicsState().getTextState().setRenderingMode(renderingMode);}
public String pdfbox_f2350_0()
{    return OperatorName.SET_TEXT_RENDERINGMODE;}
public void pdfbox_f2351_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSNumber)) {        return;    }    COSNumber rise = (COSNumber) base;    context.getGraphicsState().getTextState().setRise(rise.floatValue());}
public String pdfbox_f2352_0()
{    return OperatorName.SET_TEXT_RISE;}
public void pdfbox_f2353_0(Operator operator, List<COSBase> arguments)
{    if (arguments.isEmpty()) {        return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSNumber)) {        return;    }    COSNumber wordSpacing = (COSNumber) base;    context.getGraphicsState().getTextState().setWordSpacing(wordSpacing.floatValue());}
public String pdfbox_f2354_0()
{    return OperatorName.SET_WORD_SPACING;}
public void pdfbox_f2355_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {                return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSString)) {                return;    }    if (context.getTextMatrix() == null) {                return;    }    COSString string = (COSString) base;    context.showTextString(string.getBytes());}
public String pdfbox_f2356_0()
{    return OperatorName.SHOW_TEXT;}
public void pdfbox_f2357_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.isEmpty()) {        return;    }    COSBase base = arguments.get(0);    if (!(base instanceof COSArray)) {        return;    }    if (context.getTextMatrix() == null) {                return;    }    COSArray array = (COSArray) base;    context.showTextStrings(array);}
public String pdfbox_f2358_0()
{    return OperatorName.SHOW_TEXT_ADJUSTED;}
public void pdfbox_f2359_0(Operator operator, List<COSBase> arguments) throws IOException
{    context.processOperator(OperatorName.NEXT_LINE, null);    context.processOperator(OperatorName.SHOW_TEXT, arguments);}
public String pdfbox_f2360_0()
{    return OperatorName.SHOW_TEXT_LINE;}
public void pdfbox_f2361_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (arguments.size() < 3) {        throw new MissingOperandException(operator, arguments);    }    context.processOperator(OperatorName.SET_WORD_SPACING, arguments.subList(0, 1));    context.processOperator(OperatorName.SET_CHAR_SPACING, arguments.subList(1, 2));    context.processOperator(OperatorName.SHOW_TEXT_LINE, arguments.subList(2, 3));}
public String pdfbox_f2362_0()
{    return OperatorName.SHOW_TEXT_LINE_AND_SPACE;}
protected final PDPage pdfbox_f2363_0()
{    return page;}
public void pdfbox_f2364_0(String operator, OperatorProcessor op)
{    op.setContext(this);    operators.put(operator, op);}
public final void pdfbox_f2365_0(OperatorProcessor op)
{    op.setContext(this);    operators.put(op.getName(), op);}
private void pdfbox_f2366_0(PDPage page)
{    if (page == null) {        throw new IllegalArgumentException("Page cannot be null");    }    currentPage = page;    graphicsStack.clear();    graphicsStack.push(new PDGraphicsState(page.getCropBox()));    textMatrix = null;    textLineMatrix = null;    resources = null;    initialMatrix = page.getMatrix();}
public void pdfbox_f2367_0(PDPage page) throws IOException
{    initPage(page);    if (page.hasContents()) {        isProcessingPage = true;        processStream(page);        isProcessingPage = false;    }}
public void pdfbox_f2368_0(PDTransparencyGroup form) throws IOException
{    processTransparencyGroup(form);}
public void pdfbox_f2369_0(PDFormXObject form) throws IOException
{    if (currentPage == null) {        throw new IllegalStateException("No current page, call " + "#processChildStream(PDContentStream, PDPage) instead");    }    if (form.getCOSObject().getLength() > 0) {        processStream(form);    }}
protected void pdfbox_f2370_0(PDTransparencyGroup group) throws IOException
{    saveGraphicsState();    Matrix softMaskCTM = getGraphicsState().getSoftMask().getInitialTransformationMatrix();    getGraphicsState().setCurrentTransformationMatrix(softMaskCTM);    processTransparencyGroup(group);    restoreGraphicsState();}
protected void pdfbox_f2371_0(PDTransparencyGroup group) throws IOException
{    if (currentPage == null) {        throw new IllegalStateException("No current page, call " + "#processChildStream(PDContentStream, PDPage) instead");    }    PDResources parent = pushResources(group);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();    Matrix parentMatrix = initialMatrix;        initialMatrix = getGraphicsState().getCurrentTransformationMatrix().clone();        getGraphicsState().getCurrentTransformationMatrix().concatenate(group.getMatrix());                getGraphicsState().setBlendMode(BlendMode.NORMAL);    getGraphicsState().setAlphaConstant(1);    getGraphicsState().setNonStrokeAlphaConstant(1);    getGraphicsState().setSoftMask(null);        clipToRect(group.getBBox());    processStreamOperators(group);    initialMatrix = parentMatrix;    restoreGraphicsStack(savedStack);    popResources(parent);}
protected void pdfbox_f2372_0(PDType3CharProc charProc, Matrix textRenderingMatrix) throws IOException
{    if (currentPage == null) {        throw new IllegalStateException("No current page, call " + "#processChildStream(PDContentStream, PDPage) instead");    }    PDResources parent = pushResources(charProc);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();        getGraphicsState().setCurrentTransformationMatrix(textRenderingMatrix);        getGraphicsState().getCurrentTransformationMatrix().concatenate(charProc.getMatrix());            Matrix textMatrixOld = textMatrix;    textMatrix = new Matrix();    Matrix textLineMatrixOld = textLineMatrix;    textLineMatrix = new Matrix();    processStreamOperators(charProc);        textMatrix = textMatrixOld;    textLineMatrix = textLineMatrixOld;    restoreGraphicsStack(savedStack);    popResources(parent);}
protected void pdfbox_f2373_0(PDAnnotation annotation, PDAppearanceStream appearance) throws IOException
{    PDResources parent = pushResources(appearance);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();    PDRectangle bbox = appearance.getBBox();    PDRectangle rect = annotation.getRectangle();    Matrix matrix = appearance.getMatrix();        if (rect != null && rect.getWidth() > 0 && rect.getHeight() > 0 && bbox != null) {                Rectangle2D transformedBox = bbox.transform(matrix).getBounds2D();                        Matrix a = Matrix.getTranslateInstance(rect.getLowerLeftX(), rect.getLowerLeftY());        a.concatenate(Matrix.getScaleInstance((float) (rect.getWidth() / transformedBox.getWidth()), (float) (rect.getHeight() / transformedBox.getHeight())));        a.concatenate(Matrix.getTranslateInstance((float) -transformedBox.getX(), (float) -transformedBox.getY()));                                                Matrix aa = Matrix.concatenate(a, matrix);                getGraphicsState().setCurrentTransformationMatrix(aa);                clipToRect(bbox);                initialMatrix = aa.clone();        processStreamOperators(appearance);    }    restoreGraphicsStack(savedStack);    popResources(parent);}
protected final void pdfbox_f2374_0(PDTilingPattern tilingPattern, PDColor color, PDColorSpace colorSpace) throws IOException
{    processTilingPattern(tilingPattern, color, colorSpace, tilingPattern.getMatrix());}
protected final void pdfbox_f2375_0(PDTilingPattern tilingPattern, PDColor color, PDColorSpace colorSpace, Matrix patternMatrix) throws IOException
{    PDResources parent = pushResources(tilingPattern);    Matrix parentMatrix = initialMatrix;    initialMatrix = Matrix.concatenate(initialMatrix, patternMatrix);        Deque<PDGraphicsState> savedStack = saveGraphicsStack();        Rectangle2D bbox = tilingPattern.getBBox().transform(patternMatrix).getBounds2D();    PDRectangle rect = new PDRectangle((float) bbox.getX(), (float) bbox.getY(), (float) bbox.getWidth(), (float) bbox.getHeight());    graphicsStack.push(new PDGraphicsState(rect));        if (colorSpace != null) {        color = new PDColor(color.getComponents(), colorSpace);        getGraphicsState().setNonStrokingColorSpace(colorSpace);        getGraphicsState().setNonStrokingColor(color);        getGraphicsState().setStrokingColorSpace(colorSpace);        getGraphicsState().setStrokingColor(color);    }        getGraphicsState().getCurrentTransformationMatrix().concatenate(patternMatrix);        clipToRect(tilingPattern.getBBox());    processStreamOperators(tilingPattern);    initialMatrix = parentMatrix;    restoreGraphicsStack(savedStack);    popResources(parent);}
public void pdfbox_f2376_0(PDAnnotation annotation) throws IOException
{    PDAppearanceStream appearanceStream = getAppearance(annotation);    if (appearanceStream != null) {        processAnnotation(annotation, appearanceStream);    }}
public PDAppearanceStream pdfbox_f2377_0(PDAnnotation annotation)
{    return annotation.getNormalAppearanceStream();}
protected void pdfbox_f2378_0(PDContentStream contentStream, PDPage page) throws IOException
{    if (isProcessingPage) {        throw new IllegalStateException("Current page has already been set via " + " #processPage(PDPage) call #processChildStream(PDContentStream) instead");    }    initPage(page);    processStream(contentStream);    currentPage = null;}
private void pdfbox_f2379_0(PDContentStream contentStream) throws IOException
{    PDResources parent = pushResources(contentStream);    Deque<PDGraphicsState> savedStack = saveGraphicsStack();    Matrix parentMatrix = initialMatrix;        getGraphicsState().getCurrentTransformationMatrix().concatenate(contentStream.getMatrix());        initialMatrix = getGraphicsState().getCurrentTransformationMatrix().clone();        PDRectangle bbox = contentStream.getBBox();    clipToRect(bbox);    processStreamOperators(contentStream);    initialMatrix = parentMatrix;    restoreGraphicsStack(savedStack);    popResources(parent);}
private void pdfbox_f2380_0(PDContentStream contentStream) throws IOException
{    List<COSBase> arguments = new ArrayList<>();    try (InputStream is = contentStream.getContents()) {        PDFStreamParser parser = new PDFStreamParser(is);        Object token = parser.parseNextToken();        while (token != null) {            if (token instanceof COSObject) {                arguments.add(((COSObject) token).getObject());            } else if (token instanceof Operator) {                processOperator((Operator) token, arguments);                arguments = new ArrayList<>();            } else {                arguments.add((COSBase) token);            }            token = parser.parseNextToken();        }    }}
private PDResources pdfbox_f2381_0(PDContentStream contentStream)
{        PDResources parentResources = resources;    PDResources streamResources = contentStream.getResources();    if (streamResources != null) {        resources = streamResources;    } else if (resources != null) {            } else {        resources = currentPage.getResources();    }        if (resources == null) {        resources = new PDResources();    }    return parentResources;}
private void pdfbox_f2382_0(PDResources parentResources)
{    resources = parentResources;}
private void pdfbox_f2383_0(PDRectangle rectangle)
{    if (rectangle != null) {        GeneralPath clip = rectangle.transform(getGraphicsState().getCurrentTransformationMatrix());        getGraphicsState().intersectClippingPath(clip);    }}
public void pdfbox_f2384_0() throws IOException
{}
public void pdfbox_f2385_0() throws IOException
{}
public void pdfbox_f2386_0(byte[] string) throws IOException
{    showText(string);}
public void pdfbox_f2387_0(COSArray array) throws IOException
{    PDTextState textState = getGraphicsState().getTextState();    float fontSize = textState.getFontSize();    float horizontalScaling = textState.getHorizontalScaling() / 100f;    PDFont font = textState.getFont();    boolean isVertical = false;    if (font != null) {        isVertical = font.isVertical();    }    for (COSBase obj : array) {        if (obj instanceof COSNumber) {            float tj = ((COSNumber) obj).floatValue();                        float tx;            float ty;            if (isVertical) {                tx = 0;                ty = -tj / 1000 * fontSize;            } else {                tx = -tj / 1000 * fontSize * horizontalScaling;                ty = 0;            }            applyTextAdjustment(tx, ty);        } else if (obj instanceof COSString) {            byte[] string = ((COSString) obj).getBytes();            showText(string);        } else {            throw new IOException("Unknown type in array for TJ operation:" + obj);        }    }}
protected void pdfbox_f2388_0(float tx, float ty) throws IOException
{        textMatrix.concatenate(Matrix.getTranslateInstance(tx, ty));}
protected void pdfbox_f2389_1(byte[] string) throws IOException
{    PDGraphicsState state = getGraphicsState();    PDTextState textState = state.getTextState();        PDFont font = textState.getFont();    if (font == null) {                font = PDFontFactory.createDefaultFont();    }    float fontSize = textState.getFontSize();    float horizontalScaling = textState.getHorizontalScaling() / 100f;    float charSpacing = textState.getCharacterSpacing();        Matrix parameters = new Matrix(    fontSize * horizontalScaling,     0,     0,     fontSize, 0,     textState.getRise());        InputStream in = new ByteArrayInputStream(string);    while (in.available() > 0) {                int before = in.available();        int code = font.readCode(in);        int codeLength = before - in.available();        String unicode = font.toUnicode(code);                                float wordSpacing = 0;        if (codeLength == 1 && code == 32) {            wordSpacing += textState.getWordSpacing();        }                Matrix ctm = state.getCurrentTransformationMatrix();        Matrix textRenderingMatrix = parameters.multiply(textMatrix).multiply(ctm);                if (font.isVertical()) {                        Vector v = font.getPositionVector(code);                        textRenderingMatrix.translate(v);        }                Vector w = font.getDisplacement(code);                saveGraphicsState();        Matrix textMatrixOld = textMatrix;        Matrix textLineMatrixOld = textLineMatrix;        showGlyph(textRenderingMatrix, font, code, unicode, w);        textMatrix = textMatrixOld;        textLineMatrix = textLineMatrixOld;        restoreGraphicsState();                float tx;        float ty;        if (font.isVertical()) {            tx = 0;            ty = w.getY() * fontSize + charSpacing + wordSpacing;        } else {            tx = (w.getX() * fontSize + charSpacing + wordSpacing) * horizontalScaling;            ty = 0;        }                textMatrix.concatenate(Matrix.getTranslateInstance(tx, ty));    }}
protected void pdfbox_f2390_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    if (font instanceof PDType3Font) {        showType3Glyph(textRenderingMatrix, (PDType3Font) font, code, unicode, displacement);    } else {        showFontGlyph(textRenderingMatrix, font, code, unicode, displacement);    }}
protected void pdfbox_f2391_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{}
protected void pdfbox_f2392_0(Matrix textRenderingMatrix, PDType3Font font, int code, String unicode, Vector displacement) throws IOException
{    PDType3CharProc charProc = font.getCharProc(code);    if (charProc != null) {        processType3Stream(charProc, textRenderingMatrix);    }}
public void pdfbox_f2393_0(COSName tag, COSDictionary properties)
{}
public void pdfbox_f2394_0()
{}
public void pdfbox_f2395_0(String operation, List<COSBase> arguments) throws IOException
{    Operator operator = Operator.getOperator(operation);    processOperator(operator, arguments);}
protected void pdfbox_f2396_0(Operator operator, List<COSBase> operands) throws IOException
{    String name = operator.getName();    OperatorProcessor processor = operators.get(name);    if (processor != null) {        processor.setContext(this);        try {            processor.process(operator, operands);        } catch (IOException e) {            operatorException(operator, operands, e);        }    } else {        unsupportedOperator(operator, operands);    }}
protected void pdfbox_f2397_0(Operator operator, List<COSBase> operands) throws IOException
{}
protected void pdfbox_f2398_1(Operator operator, List<COSBase> operands, IOException e) throws IOException
{    if (e instanceof MissingOperandException || e instanceof MissingResourceException || e instanceof MissingImageReaderException) {            } else if (e instanceof EmptyGraphicsStackException) {            } else if (operator.getName().equals("Do")) {                            } else {        throw e;    }}
public void pdfbox_f2399_0()
{    graphicsStack.push(graphicsStack.peek().clone());}
public void pdfbox_f2400_0()
{    graphicsStack.pop();}
protected final Deque<PDGraphicsState> pdfbox_f2401_0()
{    Deque<PDGraphicsState> savedStack = graphicsStack;    graphicsStack = new ArrayDeque<>();    graphicsStack.add(savedStack.peek().clone());    return savedStack;}
protected final void pdfbox_f2402_0(Deque<PDGraphicsState> snapshot)
{    graphicsStack = snapshot;}
public int pdfbox_f2403_0()
{    return graphicsStack.size();}
public PDGraphicsState pdfbox_f2404_0()
{    return graphicsStack.peek();}
public Matrix pdfbox_f2405_0()
{    return textLineMatrix;}
public void pdfbox_f2406_0(Matrix value)
{    textLineMatrix = value;}
public Matrix pdfbox_f2407_0()
{    return textMatrix;}
public void pdfbox_f2408_0(Matrix value)
{    textMatrix = value;}
public void pdfbox_f2409_1(COSArray array, int phase)
{    if (phase < 0) {                phase = 0;    }    PDLineDashPattern lineDash = new PDLineDashPattern(array, phase);    getGraphicsState().setLineDashPattern(lineDash);}
public PDResources pdfbox_f2410_0()
{    return resources;}
public PDPage pdfbox_f2411_0()
{    return currentPage;}
public Matrix pdfbox_f2412_0()
{    return initialMatrix;}
public Point2D.Float pdfbox_f2413_0(float x, float y)
{    float[] position = { x, y };    getGraphicsState().getCurrentTransformationMatrix().createAffineTransform().transform(position, 0, position, 0, 1);    return new Point2D.Float(position[0], position[1]);}
protected float pdfbox_f2414_0(float width)
{    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();    float x = ctm.getScaleX() + ctm.getShearX();    float y = ctm.getScaleY() + ctm.getShearY();    return width * (float) Math.sqrt((x * x + y * y) * 0.5);}
public void pdfbox_f2415_0(COSBase object)
{    objects.add(object);}
public void pdfbox_f2416_0(COSObjectable object)
{    objects.add(object.getCOSObject());}
public void pdfbox_f2417_0(int i, COSBase object)
{    objects.add(i, object);}
public void pdfbox_f2418_0()
{    objects.clear();}
public void pdfbox_f2419_0(Collection<COSBase> objectsList)
{    objects.removeAll(objectsList);}
public void pdfbox_f2420_0(Collection<COSBase> objectsList)
{    objects.retainAll(objectsList);}
public void pdfbox_f2421_0(Collection<COSBase> objectsList)
{    objects.addAll(objectsList);}
public void pdfbox_f2422_0(COSArray objectList)
{    if (objectList != null) {        objects.addAll(objectList.objects);    }}
public void pdfbox_f2423_0(int i, Collection<COSBase> objectList)
{    objects.addAll(i, objectList);}
public void pdfbox_f2424_0(int index, COSBase object)
{    objects.set(index, object);}
public void pdfbox_f2425_0(int index, int intVal)
{    objects.set(index, COSInteger.get(intVal));}
public void pdfbox_f2426_0(int index, COSObjectable object)
{    COSBase base = null;    if (object != null) {        base = object.getCOSObject();    }    objects.set(index, base);}
public COSBase pdfbox_f2427_0(int index)
{    Object obj = objects.get(index);    if (obj instanceof COSObject) {        obj = ((COSObject) obj).getObject();    }    if (obj instanceof COSNull) {        obj = null;    }    return (COSBase) obj;}
public COSBase pdfbox_f2428_0(int index)
{    return objects.get(index);}
public int pdfbox_f2429_0(int index)
{    return getInt(index, -1);}
public int pdfbox_f2430_0(int index, int defaultValue)
{    int retval = defaultValue;    if (index < size()) {        Object obj = objects.get(index);        if (obj instanceof COSNumber) {            retval = ((COSNumber) obj).intValue();        }    }    return retval;}
public void pdfbox_f2431_0(int index, int value)
{    set(index, COSInteger.get(value));}
public void pdfbox_f2432_0(int index, String name)
{    set(index, COSName.getPDFName(name));}
public String pdfbox_f2433_0(int index)
{    return getName(index, null);}
public String pdfbox_f2434_0(int index, String defaultValue)
{    String retval = defaultValue;    if (index < size()) {        Object obj = objects.get(index);        if (obj instanceof COSName) {            retval = ((COSName) obj).getName();        }    }    return retval;}
public void pdfbox_f2435_0(int index, String string)
{    if (string != null) {        set(index, new COSString(string));    } else {        set(index, null);    }}
public String pdfbox_f2436_0(int index)
{    return getString(index, null);}
public String pdfbox_f2437_0(int index, String defaultValue)
{    String retval = defaultValue;    if (index < size()) {        Object obj = objects.get(index);        if (obj instanceof COSString) {            retval = ((COSString) obj).getString();        }    }    return retval;}
public int pdfbox_f2438_0()
{    return objects.size();}
public COSBase pdfbox_f2439_0(int i)
{    return objects.remove(i);}
public boolean pdfbox_f2440_0(COSBase o)
{    return objects.remove(o);}
public boolean pdfbox_f2441_0(COSBase o)
{    boolean removed = this.remove(o);    if (!removed) {        for (int i = 0; i < this.size(); i++) {            COSBase entry = this.get(i);            if (entry instanceof COSObject) {                COSObject objEntry = (COSObject) entry;                if (objEntry.getObject().equals(o)) {                    return this.remove(entry);                }            }        }    }    return removed;}
public String pdfbox_f2442_0()
{    return "COSArray{" + objects + "}";}
public Iterator<COSBase> pdfbox_f2443_0()
{    return objects.iterator();}
public int pdfbox_f2444_0(COSBase object)
{    int retval = -1;    for (int i = 0; retval < 0 && i < size(); i++) {        if (get(i).equals(object)) {            retval = i;        }    }    return retval;}
public int pdfbox_f2445_0(COSBase object)
{    int retval = -1;    for (int i = 0; retval < 0 && i < this.size(); i++) {        COSBase item = this.get(i);        if (item.equals(object) || item instanceof COSObject && ((COSObject) item).getObject().equals(object)) {            retval = i;            break;        }    }    return retval;}
public void pdfbox_f2446_0(int size)
{    growToSize(size, null);}
public void pdfbox_f2447_0(int size, COSBase object)
{    while (size() < size) {        add(object);    }}
public Object pdfbox_f2448_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromArray(this);}
public boolean pdfbox_f2449_0()
{    return needToBeUpdated;}
public void pdfbox_f2450_0(boolean flag)
{    needToBeUpdated = flag;}
public float[] pdfbox_f2451_0()
{    float[] retval = new float[size()];    for (int i = 0; i < size(); i++) {        COSBase base = getObject(i);        retval[i] = base instanceof COSNumber ? ((COSNumber) base).floatValue() : 0;    }    return retval;}
public void pdfbox_f2452_0(float[] value)
{    this.clear();    for (float aValue : value) {        add(new COSFloat(aValue));    }}
public List<? extends COSBase> pdfbox_f2453_0()
{    List<COSBase> retList = new ArrayList<>(size());    for (int i = 0; i < size(); i++) {        retList.add(get(i));    }    return retList;}
public COSBase pdfbox_f2454_0()
{    return this;}
public boolean pdfbox_f2455_0()
{    return direct;}
public void pdfbox_f2456_0(boolean direct)
{    this.direct = direct;}
public boolean pdfbox_f2457_0()
{    return value;}
public Boolean pdfbox_f2458_0()
{    return value ? Boolean.TRUE : Boolean.FALSE;}
public static COSBoolean pdfbox_f2459_0(boolean value)
{    return value ? TRUE : FALSE;}
public static COSBoolean pdfbox_f2460_0(Boolean value)
{    return getBoolean(value.booleanValue());}
public Object pdfbox_f2461_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromBoolean(this);}
public String pdfbox_f2462_0()
{    return String.valueOf(value);}
public void pdfbox_f2463_0(OutputStream output) throws IOException
{    if (value) {        output.write(TRUE_BYTES);    } else {        output.write(FALSE_BYTES);    }}
public boolean pdfbox_f2464_0(Object value)
{    boolean contains = items.containsValue(value);    if (!contains && value instanceof COSObject) {        contains = items.containsValue(((COSObject) value).getObject());    }    return contains;}
public COSName pdfbox_f2465_0(Object value)
{    for (Map.Entry<COSName, COSBase> entry : items.entrySet()) {        Object nextValue = entry.getValue();        if (nextValue.equals(value) || (nextValue instanceof COSObject && ((COSObject) nextValue).getObject().equals(value))) {            return entry.getKey();        }    }    return null;}
public int pdfbox_f2466_0()
{    return items.size();}
public void pdfbox_f2467_0()
{    items.clear();}
public COSBase pdfbox_f2468_0(String key)
{    return getDictionaryObject(COSName.getPDFName(key));}
public COSBase pdfbox_f2469_0(COSName firstKey, COSName secondKey)
{    COSBase retval = getDictionaryObject(firstKey);    if (retval == null && secondKey != null) {        retval = getDictionaryObject(secondKey);    }    return retval;}
public COSBase pdfbox_f2470_0(COSName key)
{    COSBase retval = items.get(key);    if (retval instanceof COSObject) {        retval = ((COSObject) retval).getObject();    }    if (retval instanceof COSNull) {        retval = null;    }    return retval;}
public void pdfbox_f2471_0(COSName key, COSBase value)
{    if (value == null) {        removeItem(key);    } else {        items.put(key, value);    }}
public void pdfbox_f2472_0(COSName key, COSObjectable value)
{    COSBase base = null;    if (value != null) {        base = value.getCOSObject();    }    setItem(key, base);}
public void pdfbox_f2473_0(String key, COSObjectable value)
{    setItem(COSName.getPDFName(key), value);}
public void pdfbox_f2474_0(String key, boolean value)
{    setItem(COSName.getPDFName(key), COSBoolean.getBoolean(value));}
public void pdfbox_f2475_0(COSName key, boolean value)
{    setItem(key, COSBoolean.getBoolean(value));}
public void pdfbox_f2476_0(String key, COSBase value)
{    setItem(COSName.getPDFName(key), value);}
public void pdfbox_f2477_0(String key, String value)
{    setName(COSName.getPDFName(key), value);}
public void pdfbox_f2478_0(COSName key, String value)
{    COSName name = null;    if (value != null) {        name = COSName.getPDFName(value);    }    setItem(key, name);}
public void pdfbox_f2479_0(String key, Calendar date)
{    setDate(COSName.getPDFName(key), date);}
public void pdfbox_f2480_0(COSName key, Calendar date)
{    setString(key, DateConverter.toString(date));}
public void pdfbox_f2481_0(String embedded, String key, Calendar date)
{    setEmbeddedDate(embedded, COSName.getPDFName(key), date);}
public void pdfbox_f2482_0(String embedded, COSName key, Calendar date)
{    COSDictionary dic = (COSDictionary) getDictionaryObject(embedded);    if (dic == null && date != null) {        dic = new COSDictionary();        setItem(embedded, dic);    }    if (dic != null) {        dic.setDate(key, date);    }}
public void pdfbox_f2483_0(String key, String value)
{    setString(COSName.getPDFName(key), value);}
public void pdfbox_f2484_0(COSName key, String value)
{    COSString name = null;    if (value != null) {        name = new COSString(value);    }    setItem(key, name);}
public void pdfbox_f2485_0(String embedded, String key, String value)
{    setEmbeddedString(embedded, COSName.getPDFName(key), value);}
public void pdfbox_f2486_0(String embedded, COSName key, String value)
{    COSDictionary dic = (COSDictionary) getDictionaryObject(embedded);    if (dic == null && value != null) {        dic = new COSDictionary();        setItem(embedded, dic);    }    if (dic != null) {        dic.setString(key, value);    }}
public void pdfbox_f2487_0(String key, int value)
{    setInt(COSName.getPDFName(key), value);}
public void pdfbox_f2488_0(COSName key, int value)
{    setItem(key, COSInteger.get(value));}
public void pdfbox_f2489_0(String key, long value)
{    setLong(COSName.getPDFName(key), value);}
public void pdfbox_f2490_0(COSName key, long value)
{    COSInteger intVal = COSInteger.get(value);    setItem(key, intVal);}
public void pdfbox_f2491_0(String embeddedDictionary, String key, int value)
{    setEmbeddedInt(embeddedDictionary, COSName.getPDFName(key), value);}
public void pdfbox_f2492_0(String embeddedDictionary, COSName key, int value)
{    COSDictionary embedded = (COSDictionary) getDictionaryObject(embeddedDictionary);    if (embedded == null) {        embedded = new COSDictionary();        setItem(embeddedDictionary, embedded);    }    embedded.setInt(key, value);}
public void pdfbox_f2493_0(String key, float value)
{    setFloat(COSName.getPDFName(key), value);}
public void pdfbox_f2494_0(COSName key, float value)
{    COSFloat fltVal = new COSFloat(value);    setItem(key, fltVal);}
public void pdfbox_f2495_0(COSName field, int bitFlag, boolean value)
{    int currentFlags = getInt(field, 0);    if (value) {        currentFlags = currentFlags | bitFlag;    } else {        currentFlags &= ~bitFlag;    }    setInt(field, currentFlags);}
public COSName pdfbox_f2496_0(COSName key)
{    COSBase name = getDictionaryObject(key);    if (name instanceof COSName) {        return (COSName) name;    }    return null;}
public COSObject pdfbox_f2497_0(COSName key)
{    COSBase object = getItem(key);    if (object instanceof COSObject) {        return (COSObject) object;    }    return null;}
public COSDictionary pdfbox_f2498_0(COSName key)
{    COSBase dictionary = getDictionaryObject(key);    if (dictionary instanceof COSDictionary) {        return (COSDictionary) dictionary;    }    return null;}
public COSStream pdfbox_f2499_0(COSName key)
{    COSBase base = getDictionaryObject(key);    if (base instanceof COSStream) {        return (COSStream) base;    }    return null;}
public COSArray pdfbox_f2500_0(COSName key)
{    COSBase array = getDictionaryObject(key);    if (array instanceof COSArray) {        return (COSArray) array;    }    return null;}
public COSName pdfbox_f2501_0(COSName key, COSName defaultValue)
{    COSBase name = getDictionaryObject(key);    if (name instanceof COSName) {        return (COSName) name;    }    return defaultValue;}
public String pdfbox_f2502_0(String key)
{    return getNameAsString(COSName.getPDFName(key));}
public String pdfbox_f2503_0(COSName key)
{    String retval = null;    COSBase name = getDictionaryObject(key);    if (name instanceof COSName) {        retval = ((COSName) name).getName();    } else if (name instanceof COSString) {        retval = ((COSString) name).getString();    }    return retval;}
public String pdfbox_f2504_0(String key, String defaultValue)
{    return getNameAsString(COSName.getPDFName(key), defaultValue);}
public String pdfbox_f2505_0(COSName key, String defaultValue)
{    String retval = getNameAsString(key);    if (retval == null) {        retval = defaultValue;    }    return retval;}
public String pdfbox_f2506_0(String key)
{    return getString(COSName.getPDFName(key));}
public String pdfbox_f2507_0(COSName key)
{    String retval = null;    COSBase value = getDictionaryObject(key);    if (value instanceof COSString) {        retval = ((COSString) value).getString();    }    return retval;}
public String pdfbox_f2508_0(String key, String defaultValue)
{    return getString(COSName.getPDFName(key), defaultValue);}
public String pdfbox_f2509_0(COSName key, String defaultValue)
{    String retval = getString(key);    if (retval == null) {        retval = defaultValue;    }    return retval;}
public String pdfbox_f2510_0(String embedded, String key)
{    return getEmbeddedString(embedded, COSName.getPDFName(key), null);}
public String pdfbox_f2511_0(String embedded, COSName key)
{    return getEmbeddedString(embedded, key, null);}
public String pdfbox_f2512_0(String embedded, String key, String defaultValue)
{    return getEmbeddedString(embedded, COSName.getPDFName(key), defaultValue);}
public String pdfbox_f2513_0(String embedded, COSName key, String defaultValue)
{    String retval = defaultValue;    COSBase base = getDictionaryObject(embedded);    if (base instanceof COSDictionary) {        retval = ((COSDictionary) base).getString(key, defaultValue);    }    return retval;}
public Calendar pdfbox_f2514_0(String key)
{    return getDate(COSName.getPDFName(key));}
public Calendar pdfbox_f2515_0(COSName key)
{    COSBase base = getDictionaryObject(key);    if (base instanceof COSString) {        return DateConverter.toCalendar((COSString) base);    }    return null;}
public Calendar pdfbox_f2516_0(String key, Calendar defaultValue)
{    return getDate(COSName.getPDFName(key), defaultValue);}
public Calendar pdfbox_f2517_0(COSName key, Calendar defaultValue)
{    Calendar retval = getDate(key);    if (retval == null) {        retval = defaultValue;    }    return retval;}
public Calendar pdfbox_f2518_0(String embedded, String key)
{    return getEmbeddedDate(embedded, COSName.getPDFName(key), null);}
public Calendar pdfbox_f2519_0(String embedded, COSName key)
{    return getEmbeddedDate(embedded, key, null);}
public Calendar pdfbox_f2520_0(String embedded, String key, Calendar defaultValue)
{    return getEmbeddedDate(embedded, COSName.getPDFName(key), defaultValue);}
public Calendar pdfbox_f2521_0(String embedded, COSName key, Calendar defaultValue)
{    Calendar retval = defaultValue;    COSDictionary eDic = (COSDictionary) getDictionaryObject(embedded);    if (eDic != null) {        retval = eDic.getDate(key, defaultValue);    }    return retval;}
public boolean pdfbox_f2522_0(String key, boolean defaultValue)
{    return getBoolean(COSName.getPDFName(key), defaultValue);}
public boolean pdfbox_f2523_0(COSName key, boolean defaultValue)
{    return getBoolean(key, null, defaultValue);}
public boolean pdfbox_f2524_0(COSName firstKey, COSName secondKey, boolean defaultValue)
{    boolean retval = defaultValue;    COSBase bool = getDictionaryObject(firstKey, secondKey);    if (bool instanceof COSBoolean) {        retval = ((COSBoolean) bool).getValue();    }    return retval;}
public int pdfbox_f2525_0(String embeddedDictionary, String key)
{    return getEmbeddedInt(embeddedDictionary, COSName.getPDFName(key));}
public int pdfbox_f2526_0(String embeddedDictionary, COSName key)
{    return getEmbeddedInt(embeddedDictionary, key, -1);}
public int pdfbox_f2527_0(String embeddedDictionary, String key, int defaultValue)
{    return getEmbeddedInt(embeddedDictionary, COSName.getPDFName(key), defaultValue);}
public int pdfbox_f2528_0(String embeddedDictionary, COSName key, int defaultValue)
{    int retval = defaultValue;    COSDictionary embedded = (COSDictionary) getDictionaryObject(embeddedDictionary);    if (embedded != null) {        retval = embedded.getInt(key, defaultValue);    }    return retval;}
public int pdfbox_f2529_0(String key)
{    return getInt(COSName.getPDFName(key), -1);}
public int pdfbox_f2530_0(COSName key)
{    return getInt(key, -1);}
public int pdfbox_f2531_0(String key, int defaultValue)
{    return getInt(COSName.getPDFName(key), defaultValue);}
public int pdfbox_f2532_0(COSName key, int defaultValue)
{    return getInt(key, null, defaultValue);}
public int pdfbox_f2533_0(COSName firstKey, COSName secondKey)
{    return getInt(firstKey, secondKey, -1);}
public int pdfbox_f2534_0(COSName firstKey, COSName secondKey, int defaultValue)
{    int retval = defaultValue;    COSBase obj = getDictionaryObject(firstKey, secondKey);    if (obj instanceof COSNumber) {        retval = ((COSNumber) obj).intValue();    }    return retval;}
public long pdfbox_f2535_0(String key)
{    return getLong(COSName.getPDFName(key), -1L);}
public long pdfbox_f2536_0(COSName key)
{    return getLong(key, -1L);}
public long pdfbox_f2537_0(String key, long defaultValue)
{    return getLong(COSName.getPDFName(key), defaultValue);}
public long pdfbox_f2538_0(COSName key, long defaultValue)
{    long retval = defaultValue;    COSBase obj = getDictionaryObject(key);    if (obj instanceof COSNumber) {        retval = ((COSNumber) obj).longValue();    }    return retval;}
public float pdfbox_f2539_0(String key)
{    return getFloat(COSName.getPDFName(key), -1);}
public float pdfbox_f2540_0(COSName key)
{    return getFloat(key, -1);}
public float pdfbox_f2541_0(String key, float defaultValue)
{    return getFloat(COSName.getPDFName(key), defaultValue);}
public float pdfbox_f2542_0(COSName key, float defaultValue)
{    float retval = defaultValue;    COSBase obj = getDictionaryObject(key);    if (obj instanceof COSNumber) {        retval = ((COSNumber) obj).floatValue();    }    return retval;}
public boolean pdfbox_f2543_0(COSName field, int bitFlag)
{    int ff = getInt(field, 0);    return (ff & bitFlag) == bitFlag;}
public void pdfbox_f2544_0(COSName key)
{    items.remove(key);}
public COSBase pdfbox_f2545_0(COSName key)
{    return items.get(key);}
public COSBase pdfbox_f2546_0(String key)
{    return getItem(COSName.getPDFName(key));}
public COSBase pdfbox_f2547_0(COSName firstKey, COSName secondKey)
{    COSBase retval = getItem(firstKey);    if (retval == null && secondKey != null) {        retval = getItem(secondKey);    }    return retval;}
public Set<COSName> pdfbox_f2548_0()
{    return items.keySet();}
public Set<Map.Entry<COSName, COSBase>> pdfbox_f2549_0()
{    return items.entrySet();}
public Collection<COSBase> pdfbox_f2550_0()
{    return items.values();}
public Object pdfbox_f2551_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromDictionary(this);}
public boolean pdfbox_f2552_0()
{    return needToBeUpdated;}
public void pdfbox_f2553_0(boolean flag)
{    needToBeUpdated = flag;}
public void pdfbox_f2554_0(COSDictionary dic)
{    for (Map.Entry<COSName, COSBase> entry : dic.entrySet()) {        /*             * If we're at a second trailer, we have a linearized pdf file, meaning that the first Size entry represents             * all of the objects so we don't need to grab the second.             */        if (!COSName.SIZE.equals(entry.getKey()) || !items.containsKey(COSName.SIZE)) {            setItem(entry.getKey(), entry.getValue());        }    }}
public boolean pdfbox_f2555_0(COSName name)
{    return this.items.containsKey(name);}
public boolean pdfbox_f2556_0(String name)
{    return containsKey(COSName.getPDFName(name));}
public COSBase pdfbox_f2557_0(String objPath)
{    String[] path = objPath.split(PATH_SEPARATOR);    COSBase retval = this;    for (String pathString : path) {        if (retval instanceof COSArray) {            int idx = Integer.parseInt(pathString.replaceAll("\\[", "").replaceAll("\\]", ""));            retval = ((COSArray) retval).getObject(idx);        } else if (retval instanceof COSDictionary) {            retval = ((COSDictionary) retval).getDictionaryObject(pathString);        }    }    return retval;}
public COSDictionary pdfbox_f2558_0()
{    return new UnmodifiableCOSDictionary(this);}
public String pdfbox_f2559_1()
{    try {        return getDictionaryString(this, new ArrayList<COSBase>());    } catch (IOException e) {                return "COSDictionary{" + e.getMessage() + "}";    }}
private static String pdfbox_f2560_0(COSBase base, List<COSBase> objs) throws IOException
{    if (base == null) {        return "null";    }    if (objs.contains(base)) {                return String.valueOf(base.hashCode());    }    objs.add(base);    if (base instanceof COSDictionary) {        StringBuilder sb = new StringBuilder();        sb.append("COSDictionary{");        for (Map.Entry<COSName, COSBase> x : ((COSDictionary) base).entrySet()) {            sb.append(x.getKey());            sb.append(":");            sb.append(getDictionaryString(x.getValue(), objs));            sb.append(";");        }        sb.append("}");        if (base instanceof COSStream) {            try (InputStream stream = ((COSStream) base).createRawInputStream()) {                byte[] b = IOUtils.toByteArray(stream);                sb.append("COSStream{").append(Arrays.hashCode(b)).append("}");            }        }        return sb.toString();    }    if (base instanceof COSArray) {        StringBuilder sb = new StringBuilder();        sb.append("COSArray{");        for (COSBase x : ((COSArray) base).toList()) {            sb.append(getDictionaryString(x, objs));            sb.append(";");        }        sb.append("}");        return sb.toString();    }    if (base instanceof COSObject) {        COSObject obj = (COSObject) base;        return "COSObject{" + getDictionaryString(obj.getObject(), objs) + "}";    }    return base.toString();}
public COSStream pdfbox_f2561_0()
{    COSStream stream = new COSStream(scratchFile);                streams.add(stream);    return stream;}
public COSStream pdfbox_f2562_0(COSDictionary dictionary)
{    COSStream stream = new COSStream(scratchFile);    for (Map.Entry<COSName, COSBase> entry : dictionary.entrySet()) {        stream.setItem(entry.getKey(), entry.getValue());    }    return stream;}
public COSObject pdfbox_f2563_1(COSName type)
{    for (COSObject object : objectPool.values()) {        COSBase realObject = object.getObject();        if (realObject instanceof COSDictionary) {            try {                COSDictionary dic = (COSDictionary) realObject;                COSBase typeItem = dic.getItem(COSName.TYPE);                if (typeItem instanceof COSName) {                    COSName objectType = (COSName) typeItem;                    if (objectType.equals(type)) {                        return object;                    }                } else if (typeItem != null) {                                    }            } catch (ClassCastException e) {                            }        }    }    return null;}
public List<COSObject> pdfbox_f2564_0(String type)
{    return getObjectsByType(COSName.getPDFName(type));}
public List<COSObject> pdfbox_f2565_1(COSName type)
{    List<COSObject> retval = new ArrayList<>();    for (COSObject object : objectPool.values()) {        COSBase realObject = object.getObject();        if (realObject instanceof COSDictionary) {            try {                COSDictionary dic = (COSDictionary) realObject;                COSBase typeItem = dic.getItem(COSName.TYPE);                if (typeItem instanceof COSName) {                    COSName objectType = (COSName) typeItem;                    if (objectType.equals(type)) {                        retval.add(object);                    }                } else if (typeItem != null) {                                    }            } catch (ClassCastException e) {                            }        }    }    return retval;}
public COSObjectKey pdfbox_f2566_0(COSBase object)
{    for (Map.Entry<COSObjectKey, COSObject> entry : objectPool.entrySet()) {        if (entry.getValue().getObject() == object) {            return entry.getKey();        }    }    return null;}
public void pdfbox_f2567_0()
{    for (COSObject object : objectPool.values()) {        System.out.println(object);    }}
public void pdfbox_f2568_0(float versionValue)
{    version = versionValue;}
public float pdfbox_f2569_0()
{    return version;}
public void pdfbox_f2570_0()
{    isDecrypted = true;}
public boolean pdfbox_f2571_0()
{    return isDecrypted;}
public boolean pdfbox_f2572_0()
{    boolean encrypted = false;    if (trailer != null) {        encrypted = trailer.getDictionaryObject(COSName.ENCRYPT) instanceof COSDictionary;    }    return encrypted;}
public COSDictionary pdfbox_f2573_0()
{    return trailer.getCOSDictionary(COSName.ENCRYPT);}
public void pdfbox_f2574_0(COSDictionary encDictionary)
{    trailer.setItem(COSName.ENCRYPT, encDictionary);}
public COSArray pdfbox_f2575_0()
{    return getTrailer().getCOSArray(COSName.ID);}
public void pdfbox_f2576_0(COSArray id)
{    getTrailer().setItem(COSName.ID, id);}
public List<COSObject> pdfbox_f2577_0()
{    return new ArrayList<>(objectPool.values());}
public COSDictionary pdfbox_f2578_0()
{    return trailer;}
public void pdfbox_f2579_0(COSDictionary newTrailer)
{    trailer = newTrailer;}
public long pdfbox_f2580_0()
{    return highestXRefObjectNumber;}
public void pdfbox_f2581_0(long highestXRefObjectNumber)
{    this.highestXRefObjectNumber = highestXRefObjectNumber;}
public Object pdfbox_f2582_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromDocument(this);}
public void pdfbox_f2583_0() throws IOException
{    if (!closed) {                                                IOException firstException = null;                for (COSObject object : getObjects()) {            COSBase cosObject = object.getObject();            if (cosObject instanceof COSStream) {                firstException = IOUtils.closeAndLogException((COSStream) cosObject, LOG, "COSStream", firstException);            }        }        for (COSStream stream : streams) {            firstException = IOUtils.closeAndLogException(stream, LOG, "COSStream", firstException);        }        if (scratchFile != null) {            firstException = IOUtils.closeAndLogException(scratchFile, LOG, "ScratchFile", firstException);        }        closed = true;                if (firstException != null) {            throw firstException;        }    }}
public boolean pdfbox_f2584_0()
{    return closed;}
protected void pdfbox_f2585_1() throws IOException
{    if (!closed) {        if (warnMissingClose) {                    }        close();    }}
public void pdfbox_f2586_0(boolean warn)
{    this.warnMissingClose = warn;}
public void pdfbox_f2587_0() throws IOException
{    for (COSObject objStream : getObjectsByType(COSName.OBJ_STM)) {        COSStream stream = (COSStream) objStream.getObject();        PDFObjectStreamParser parser = new PDFObjectStreamParser(stream, this);        parser.parse();        for (COSObject next : parser.getObjects()) {            COSObjectKey key = new COSObjectKey(next);            if (objectPool.get(key) == null || objectPool.get(key).getObject() == null ||             (xrefTable.containsKey(key) && xrefTable.get(key) == -objStream.getObjectNumber())) {                COSObject obj = getObjectFromPool(key);                obj.setObject(next.getObject());            }        }    }}
public COSObject pdfbox_f2588_0(COSObjectKey key)
{    COSObject obj = null;    if (key != null) {        obj = objectPool.get(key);    }    if (obj == null) {                obj = new COSObject(null);        if (key != null) {            obj.setObjectNumber(key.getNumber());            obj.setGenerationNumber(key.getGeneration());            objectPool.put(key, obj);        }    }    return obj;}
public COSObject pdfbox_f2589_0(COSObjectKey key)
{    return objectPool.remove(key);}
public void pdfbox_f2590_0(Map<COSObjectKey, Long> xrefTableValues)
{    xrefTable.putAll(xrefTableValues);}
public Map<COSObjectKey, Long> pdfbox_f2591_0()
{    return xrefTable;}
public void pdfbox_f2592_0(long startXrefValue)
{    startXref = startXrefValue;}
public long pdfbox_f2593_0()
{    return startXref;}
public boolean pdfbox_f2594_0()
{    return isXRefStream;}
public void pdfbox_f2595_0(boolean isXRefStreamValue)
{    isXRefStream = isXRefStreamValue;}
private void pdfbox_f2596_0()
{    float floatValue = value.floatValue();    double doubleValue = value.doubleValue();    boolean valueReplaced = false;        if (Float.isInfinite(floatValue)) {        if (Math.abs(doubleValue) > Float.MAX_VALUE) {            floatValue = Float.MAX_VALUE * (Float.compare(floatValue, Float.POSITIVE_INFINITY) == 0 ? 1 : -1);            valueReplaced = true;        }    } else     if (Float.compare(floatValue, 0) == 0 && Double.compare(doubleValue, 0) != 0) {        if (Math.abs(doubleValue) < Float.MIN_NORMAL) {            floatValue = Float.MIN_NORMAL;            floatValue *= doubleValue >= 0 ? 1 : -1;            valueReplaced = true;        }    }    if (valueReplaced) {        value = BigDecimal.valueOf(floatValue);        valueAsString = removeNullDigits(value.toPlainString());    }}
private String pdfbox_f2597_0(String plainStringValue)
{        if (plainStringValue.indexOf('.') > -1 && !plainStringValue.endsWith(".0")) {        while (plainStringValue.endsWith("0") && !plainStringValue.endsWith(".0")) {            plainStringValue = plainStringValue.substring(0, plainStringValue.length() - 1);        }    }    return plainStringValue;}
public float pdfbox_f2598_0()
{    return value.floatValue();}
public double pdfbox_f2599_0()
{    return value.doubleValue();}
public long pdfbox_f2600_0()
{    return value.longValue();}
public int pdfbox_f2601_0()
{    return value.intValue();}
public boolean pdfbox_f2602_0(Object o)
{    return o instanceof COSFloat && Float.floatToIntBits(((COSFloat) o).value.floatValue()) == Float.floatToIntBits(value.floatValue());}
public int pdfbox_f2603_0()
{    return value.hashCode();}
public String pdfbox_f2604_0()
{    return "COSFloat{" + valueAsString + "}";}
public Object pdfbox_f2605_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromFloat(this);}
public void pdfbox_f2606_0(OutputStream output) throws IOException
{    output.write(valueAsString.getBytes("ISO-8859-1"));}
 static COSInputStream pdfbox_f2607_0(List<Filter> filters, COSDictionary parameters, InputStream in, ScratchFile scratchFile) throws IOException
{    return create(filters, parameters, in, scratchFile, DecodeOptions.DEFAULT);}
 static COSInputStream pdfbox_f2608_0(List<Filter> filters, COSDictionary parameters, InputStream in, ScratchFile scratchFile, DecodeOptions options) throws IOException
{    List<DecodeResult> results = new ArrayList<>();    InputStream input = in;    if (filters.isEmpty()) {        input = in;    } else {        Set<Filter> filterSet = new HashSet<>(filters);        if (filterSet.size() != filters.size()) {            throw new IOException("Duplicate");        }                for (int i = 0; i < filters.size(); i++) {            if (scratchFile != null) {                                final RandomAccess buffer = scratchFile.createBuffer();                DecodeResult result = filters.get(i).decode(input, new RandomAccessOutputStream(buffer), parameters, i, options);                results.add(result);                input = new RandomAccessInputStream(buffer) {                    @Override                    public void close() throws IOException {                        buffer.close();                    }                };            } else {                                ByteArrayOutputStream output = new ByteArrayOutputStream();                DecodeResult result = filters.get(i).decode(input, output, parameters, i, options);                results.add(result);                input = new ByteArrayInputStream(output.toByteArray());            }        }    }    return new COSInputStream(input, results);}
public void pdfbox_f2609_0() throws IOException
{    buffer.close();}
public DecodeResult pdfbox_f2610_0()
{    if (decodeResults.isEmpty()) {        return DecodeResult.DEFAULT;    } else {        return decodeResults.get(decodeResults.size() - 1);    }}
public static COSInteger pdfbox_f2611_0(long val)
{    if (LOW <= val && val <= HIGH) {        int index = (int) val - LOW;                if (STATIC[index] == null) {            STATIC[index] = new COSInteger(val);        }        return STATIC[index];    }    return new COSInteger(val);}
public boolean pdfbox_f2612_0(Object o)
{    return o instanceof COSInteger && ((COSInteger) o).intValue() == intValue();}
public int pdfbox_f2613_0()
{        return (int) (value ^ (value >> 32));}
public String pdfbox_f2614_0()
{    return "COSInt{" + value + "}";}
public float pdfbox_f2615_0()
{    return value;}
public double pdfbox_f2616_0()
{    return value;}
public int pdfbox_f2617_0()
{    return (int) value;}
public long pdfbox_f2618_0()
{    return value;}
public Object pdfbox_f2619_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromInt(this);}
public void pdfbox_f2620_0(OutputStream output) throws IOException
{    output.write(String.valueOf(value).getBytes("ISO-8859-1"));}
public static COSName pdfbox_f2621_0(String aName)
{    COSName name = null;    if (aName != null) {                name = commonNameMap.get(aName);        if (name == null) {                        name = nameMap.get(aName);            if (name == null) {                                name = new COSName(aName, false);            }        }    }    return name;}
public String pdfbox_f2622_0()
{    return name;}
public String pdfbox_f2623_0()
{    return "COSName{" + name + "}";}
public boolean pdfbox_f2624_0(Object object)
{    return object instanceof COSName && name.equals(((COSName) object).name);}
public int pdfbox_f2625_0()
{    return hashCode;}
public int pdfbox_f2626_0(COSName other)
{    return name.compareTo(other.name);}
public boolean pdfbox_f2627_0()
{    return name.isEmpty();}
public Object pdfbox_f2628_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromName(this);}
public void pdfbox_f2629_0(OutputStream output) throws IOException
{    output.write('/');    byte[] bytes = getName().getBytes(Charsets.UTF_8);    for (byte b : bytes) {        int current = b & 0xFF;                if (current >= 'A' && current <= 'Z' || current >= 'a' && current <= 'z' || current >= '0' && current <= '9' || current == '+' || current == '-' || current == '_' || current == '@' || current == '*' || current == '$' || current == ';' || current == '.') {            output.write(current);        } else {            output.write('#');            Hex.writeHexByte(b, output);        }    }}
public static synchronized void pdfbox_f2630_0()
{        nameMap.clear();}
public Object pdfbox_f2631_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromNull(this);}
public void pdfbox_f2632_0(OutputStream output) throws IOException
{    output.write(NULL_BYTES);}
public String pdfbox_f2633_0()
{    return "COSNull{}";}
public static COSNumber pdfbox_f2634_0(String number) throws IOException
{    if (number.length() == 1) {        char digit = number.charAt(0);        if ('0' <= digit && digit <= '9') {            return COSInteger.get(digit - '0');        } else if (digit == '-' || digit == '.') {                        return COSInteger.ZERO;        } else {            throw new IOException("Not a number: " + number);        }    } else if (number.indexOf('.') == -1 && (number.toLowerCase().indexOf('e') == -1)) {        try {            if (number.charAt(0) == '+') {                return COSInteger.get(Long.parseLong(number.substring(1)));            }            return COSInteger.get(Long.parseLong(number));        } catch (NumberFormatException e) {                        return new COSFloat(number);        }    } else {        return new COSFloat(number);    }}
public COSBase pdfbox_f2635_0(COSName key)
{    COSBase retval = null;    if (baseObject instanceof COSDictionary) {        retval = ((COSDictionary) baseObject).getDictionaryObject(key);    }    return retval;}
public COSBase pdfbox_f2636_0(COSName key)
{    COSBase retval = null;    if (baseObject instanceof COSDictionary) {        retval = ((COSDictionary) baseObject).getItem(key);    }    return retval;}
public COSBase pdfbox_f2637_0()
{    return baseObject;}
public final void pdfbox_f2638_0(COSBase object)
{    baseObject = object;}
public String pdfbox_f2639_0()
{    return "COSObject{" + Long.toString(objectNumber) + ", " + Integer.toString(generationNumber) + "}";}
public long pdfbox_f2640_0()
{    return objectNumber;}
public void pdfbox_f2641_0(long objectNum)
{    objectNumber = objectNum;}
public int pdfbox_f2642_0()
{    return generationNumber;}
public void pdfbox_f2643_0(int generationNumberValue)
{    generationNumber = generationNumberValue;}
public Object pdfbox_f2644_0(ICOSVisitor visitor) throws IOException
{    return getObject() != null ? getObject().accept(visitor) : COSNull.NULL.accept(visitor);}
public boolean pdfbox_f2645_0()
{    return needToBeUpdated;}
public void pdfbox_f2646_0(boolean flag)
{    needToBeUpdated = flag;}
public boolean pdfbox_f2647_0(Object obj)
{    COSObjectKey objToBeCompared = obj instanceof COSObjectKey ? (COSObjectKey) obj : null;    return objToBeCompared != null && objToBeCompared.getNumber() == getNumber() && objToBeCompared.getGeneration() == getGeneration();}
public int pdfbox_f2648_0()
{    return generation;}
public void pdfbox_f2649_0(int genNumber)
{    generation = genNumber;}
public long pdfbox_f2650_0()
{    return number;}
public int pdfbox_f2651_0()
{    return Long.valueOf(number + generation).hashCode();}
public String pdfbox_f2652_0()
{    return Long.toString(number) + " " + Integer.toString(generation) + " R";}
public int pdfbox_f2653_0(COSObjectKey other)
{    int result = Long.compare(getNumber(), other.getNumber());    if (result == 0) {        return Integer.compare(getGeneration(), other.getGeneration());    }    return result;}
public void pdfbox_f2654_0(byte[] b) throws IOException
{    if (buffer != null) {        buffer.write(b);    } else {        super.write(b);    }}
public void pdfbox_f2655_0(byte[] b, int off, int len) throws IOException
{    if (buffer != null) {        buffer.write(b, off, len);    } else {        super.write(b, off, len);    }}
public void pdfbox_f2656_0(int b) throws IOException
{    if (buffer != null) {        buffer.write(b);    } else {        super.write(b);    }}
public void pdfbox_f2657_0() throws IOException
{}
public void pdfbox_f2658_0() throws IOException
{    try {        if (buffer != null) {            try {                                for (int i = filters.size() - 1; i >= 0; i--) {                    try (InputStream unfilteredIn = new RandomAccessInputStream(buffer)) {                        if (i == 0) {                            /*                                 * The last filter to run can encode directly to the enclosed output                                 * stream.                                 */                            filters.get(i).encode(unfilteredIn, out, parameters, i);                        } else {                            RandomAccess filteredBuffer = scratchFile.createBuffer();                            try {                                try (OutputStream filteredOut = new RandomAccessOutputStream(filteredBuffer)) {                                    filters.get(i).encode(unfilteredIn, filteredOut, parameters, i);                                }                                RandomAccess tmpSwap = filteredBuffer;                                filteredBuffer = buffer;                                buffer = tmpSwap;                            } finally {                                filteredBuffer.close();                            }                        }                    }                }            } finally {                buffer.close();                buffer = null;            }        }    } finally {        super.close();    }}
private void pdfbox_f2659_0() throws IOException
{    if (randomAccess != null && randomAccess.isClosed()) {        throw new IOException("COSStream has been closed and cannot be read. " + "Perhaps its enclosing PDDocument has been closed?");            }}
public InputStream pdfbox_f2660_0() throws IOException
{    return createRawInputStream();}
private void pdfbox_f2661_1(boolean forInputStream) throws IOException
{    if (randomAccess == null) {        if (forInputStream && LOG.isDebugEnabled()) {                                }        randomAccess = scratchFile.createBuffer();    }}
public InputStream pdfbox_f2662_0() throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot read while there is an open stream writer");    }    ensureRandomAccessExists(true);    return new RandomAccessInputStream(randomAccess);}
public InputStream pdfbox_f2663_0() throws IOException
{    return createInputStream();}
public COSInputStream pdfbox_f2664_0() throws IOException
{    return createInputStream(DecodeOptions.DEFAULT);}
public COSInputStream pdfbox_f2665_0(DecodeOptions options) throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot read while there is an open stream writer");    }    ensureRandomAccessExists(true);    InputStream input = new RandomAccessInputStream(randomAccess);    return COSInputStream.create(getFilterList(), this, input, scratchFile, options);}
public OutputStream pdfbox_f2666_0() throws IOException
{    return createOutputStream();}
public OutputStream pdfbox_f2667_0() throws IOException
{    return createOutputStream(null);}
public OutputStream pdfbox_f2668_0(COSBase filters) throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot have more than one open stream writer.");    }        if (filters != null) {        setItem(COSName.FILTER, filters);    }    IOUtils.closeQuietly(randomAccess);    randomAccess = scratchFile.createBuffer();    OutputStream randomOut = new RandomAccessOutputStream(randomAccess);    OutputStream cosOut = new COSOutputStream(getFilterList(), this, randomOut, scratchFile);    isWriting = true;    return new FilterOutputStream(cosOut) {        @Override        public void write(byte[] b, int off, int len) throws IOException {            this.out.write(b, off, len);        }        @Override        public void close() throws IOException {            super.close();            setInt(COSName.LENGTH, (int) randomAccess.length());            isWriting = false;        }    };}
public void pdfbox_f2669_0(byte[] b, int off, int len) throws IOException
{    this.out.write(b, off, len);}
public void pdfbox_f2670_0() throws IOException
{    super.close();    setInt(COSName.LENGTH, (int) randomAccess.length());    isWriting = false;}
public OutputStream pdfbox_f2671_0() throws IOException
{    return createRawOutputStream();}
public OutputStream pdfbox_f2672_0() throws IOException
{    checkClosed();    if (isWriting) {        throw new IllegalStateException("Cannot have more than one open stream writer.");    }    IOUtils.closeQuietly(randomAccess);    randomAccess = scratchFile.createBuffer();    OutputStream out = new RandomAccessOutputStream(randomAccess);    isWriting = true;    return new FilterOutputStream(out) {        @Override        public void write(byte[] b, int off, int len) throws IOException {            this.out.write(b, off, len);        }        @Override        public void close() throws IOException {            super.close();            setInt(COSName.LENGTH, (int) randomAccess.length());            isWriting = false;        }    };}
public void pdfbox_f2673_0(byte[] b, int off, int len) throws IOException
{    this.out.write(b, off, len);}
public void pdfbox_f2674_0() throws IOException
{    super.close();    setInt(COSName.LENGTH, (int) randomAccess.length());    isWriting = false;}
private List<Filter> pdfbox_f2675_0() throws IOException
{    List<Filter> filterList = new ArrayList<>();    COSBase filters = getFilters();    if (filters instanceof COSName) {        filterList.add(FilterFactory.INSTANCE.getFilter((COSName) filters));    } else if (filters instanceof COSArray) {        COSArray filterArray = (COSArray) filters;        for (int i = 0; i < filterArray.size(); i++) {            COSName filterName = (COSName) filterArray.get(i);            filterList.add(FilterFactory.INSTANCE.getFilter(filterName));        }    }    return filterList;}
public long pdfbox_f2676_0()
{    if (isWriting) {        throw new IllegalStateException("There is an open OutputStream associated with " + "this COSStream. It must be closed before querying" + "length of this COSStream.");    }    return getInt(COSName.LENGTH, 0);}
public COSBase pdfbox_f2677_0()
{    return getDictionaryObject(COSName.FILTER);}
public void pdfbox_f2678_0(COSBase filters) throws IOException
{    setItem(COSName.FILTER, filters);}
public String pdfbox_f2679_0()
{    return toTextString();}
public String pdfbox_f2680_1()
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    InputStream input = null;    try {        input = createInputStream();        IOUtils.copy(input, out);    } catch (IOException e) {                return "";    } finally {        IOUtils.closeQuietly(input);    }    COSString string = new COSString(out.toByteArray());    return string.getString();}
public Object pdfbox_f2681_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromStream(this);}
public void pdfbox_f2682_0() throws IOException
{        if (randomAccess != null) {        randomAccess.close();    }}
public static COSString pdfbox_f2683_1(String hex) throws IOException
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    StringBuilder hexBuffer = new StringBuilder(hex.trim());        if (hexBuffer.length() % 2 != 0) {        hexBuffer.append('0');    }    int length = hexBuffer.length();    for (int i = 0; i < length; i += 2) {        try {            bytes.write(Integer.parseInt(hexBuffer.substring(i, i + 2), 16));        } catch (NumberFormatException e) {            if (FORCE_PARSING) {                                                bytes.write('?');            } else {                throw new IOException("Invalid hex string: " + hex, e);            }        }    }    return new COSString(bytes.toByteArray());}
public void pdfbox_f2684_0(byte[] value)
{    bytes = value.clone();}
public void pdfbox_f2685_0(boolean value)
{    this.forceHexForm = value;}
public boolean pdfbox_f2686_0()
{    return forceHexForm;}
public String pdfbox_f2687_0()
{        if (bytes.length >= 2) {        if ((bytes[0] & 0xff) == 0xFE && (bytes[1] & 0xff) == 0xFF) {                        return new String(bytes, 2, bytes.length - 2, Charsets.UTF_16BE);        } else if ((bytes[0] & 0xff) == 0xFF && (bytes[1] & 0xff) == 0xFE) {                        return new String(bytes, 2, bytes.length - 2, Charsets.UTF_16LE);        }    }        return PDFDocEncoding.toString(bytes);}
public String pdfbox_f2688_0()
{        return new String(bytes, Charsets.US_ASCII);}
public byte[] pdfbox_f2689_0()
{    return bytes;}
public String pdfbox_f2690_0()
{    return Hex.getString(bytes);}
public Object pdfbox_f2691_0(ICOSVisitor visitor) throws IOException
{    return visitor.visitFromString(this);}
public boolean pdfbox_f2692_0(Object obj)
{    if (obj instanceof COSString) {        COSString strObj = (COSString) obj;        return getString().equals(strObj.getString()) && forceHexForm == strObj.forceHexForm;    }    return false;}
public int pdfbox_f2693_0()
{    int result = Arrays.hashCode(bytes);    return result + (forceHexForm ? 17 : 0);}
public String pdfbox_f2694_0()
{    return "COSString{" + getString() + "}";}
private static void pdfbox_f2695_0(int code, char unicode)
{    CODE_TO_UNI[code] = unicode;    UNI_TO_CODE.put(unicode, code);}
public static String pdfbox_f2696_0(byte[] bytes)
{    StringBuilder sb = new StringBuilder();    for (byte b : bytes) {        if ((b & 0xff) >= CODE_TO_UNI.length) {            sb.append('?');        } else {            sb.append((char) CODE_TO_UNI[b & 0xff]);        }    }    return sb.toString();}
public static byte[] pdfbox_f2697_0(String text)
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    for (char c : text.toCharArray()) {        Integer code = UNI_TO_CODE.get(c);        if (code == null) {            out.write(0);        } else {            out.write(code);        }    }    return out.toByteArray();}
public static boolean pdfbox_f2698_0(char character)
{    return UNI_TO_CODE.containsKey(character);}
public void pdfbox_f2699_0()
{    throw new UnsupportedOperationException();}
public void pdfbox_f2700_0(COSName key, COSBase value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2701_0(COSName key, COSObjectable value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2702_0(String key, COSObjectable value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2703_0(String key, boolean value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2704_0(COSName key, boolean value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2705_0(String key, COSBase value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2706_0(String key, String value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2707_0(COSName key, String value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2708_0(String key, Calendar date)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2709_0(COSName key, Calendar date)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2710_0(String embedded, String key, Calendar date)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2711_0(String embedded, COSName key, Calendar date)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2712_0(String key, String value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2713_0(COSName key, String value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2714_0(String embedded, String key, String value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2715_0(String embedded, COSName key, String value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2716_0(String key, int value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2717_0(COSName key, int value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2718_0(String key, long value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2719_0(COSName key, long value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2720_0(String embeddedDictionary, String key, int value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2721_0(String embeddedDictionary, COSName key, int value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2722_0(String key, float value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2723_0(COSName key, float value)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2724_0(COSName key)
{    throw new UnsupportedOperationException();}
public void pdfbox_f2725_0(COSDictionary dic)
{    throw new UnsupportedOperationException();}
public DecodeResult pdfbox_f2726_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    try (ASCII85InputStream is = new ASCII85InputStream(encoded)) {        IOUtils.copy(is, decoded);    }    decoded.flush();    return new DecodeResult(parameters);}
protected void pdfbox_f2727_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    try (ASCII85OutputStream os = new ASCII85OutputStream(encoded)) {        IOUtils.copy(input, os);    }    encoded.flush();}
public int pdfbox_f2728_0() throws IOException
{    if (index >= n) {        if (eof) {            return -1;        }        index = 0;        int k;        byte z;        do {            int zz = (byte) in.read();            if (zz == -1) {                eof = true;                return -1;            }            z = (byte) zz;        } while (z == NEWLINE || z == RETURN || z == SPACE);        if (z == TERMINATOR) {            eof = true;            ascii = b = null;            n = 0;            return -1;        } else if (z == Z) {            b[0] = b[1] = b[2] = b[3] = 0;            n = 4;        } else {                        ascii[0] = z;            for (k = 1; k < 5; ++k) {                do {                    int zz = (byte) in.read();                    if (zz == -1) {                        eof = true;                        return -1;                    }                    z = (byte) zz;                } while (z == NEWLINE || z == RETURN || z == SPACE);                ascii[k] = z;                if (z == TERMINATOR) {                                        ascii[k] = (byte) PADDING_U;                    break;                }            }            n = k - 1;            if (n == 0) {                eof = true;                ascii = null;                b = null;                return -1;            }            if (k < 5) {                for (++k; k < 5; ++k) {                                        ascii[k] = (byte) PADDING_U;                }                eof = true;            }                        long t = 0;            for (k = 0; k < 5; ++k) {                z = (byte) (ascii[k] - OFFSET);                if (z < 0 || z > 93) {                    n = 0;                    eof = true;                    ascii = null;                    b = null;                    throw new IOException("Invalid data in Ascii85 stream");                }                t = (t * 85L) + z;            }            for (k = 3; k >= 0; --k) {                b[k] = (byte) (t & 0xFFL);                t >>>= 8;            }        }    }    return b[index++] & 0xFF;}
public int pdfbox_f2729_0(byte[] data, int offset, int len) throws IOException
{    if (eof && index >= n) {        return -1;    }    for (int i = 0; i < len; i++) {        if (index < n) {            data[i + offset] = b[index++];        } else {            int t = read();            if (t == -1) {                return i;            }            data[i + offset] = (byte) t;        }    }    return len;}
public void pdfbox_f2730_0() throws IOException
{    ascii = null;    eof = true;    b = null;    super.close();}
public boolean pdfbox_f2731_0()
{    return false;}
public long pdfbox_f2732_0(long nValue)
{    return 0;}
public int pdfbox_f2733_0()
{    return 0;}
public void pdfbox_f2734_0(int readlimit)
{}
public void pdfbox_f2735_0() throws IOException
{    throw new IOException("Reset is not supported");}
public void pdfbox_f2736_0(char term)
{    if (term < 118 || term > 126 || term == Z) {        throw new IllegalArgumentException("Terminator must be 118-126 excluding z");    }    terminator = term;}
public char pdfbox_f2737_0()
{    return terminator;}
public void pdfbox_f2738_0(int l)
{    if (lineBreak > l) {        lineBreak = l;    }    maxline = l;}
public int pdfbox_f2739_0()
{    return maxline;}
private void pdfbox_f2740_0()
{    long word = ((((indata[0] << 8) | (indata[1] & 0xFF)) << 16) | ((indata[2] & 0xFF) << 8) | (indata[3] & 0xFF)) & 0xFFFFFFFFL;    if (word == 0) {        outdata[0] = (byte) Z;        outdata[1] = 0;        return;    }    long x;    x = word / (85L * 85L * 85L * 85L);    outdata[0] = (byte) (x + OFFSET);    word -= x * 85L * 85L * 85L * 85L;    x = word / (85L * 85L * 85L);    outdata[1] = (byte) (x + OFFSET);    word -= x * 85L * 85L * 85L;    x = word / (85L * 85L);    outdata[2] = (byte) (x + OFFSET);    word -= x * 85L * 85L;    x = word / 85L;    outdata[3] = (byte) (x + OFFSET);    outdata[4] = (byte) ((word % 85L) + OFFSET);}
public void pdfbox_f2741_0(int b) throws IOException
{    flushed = false;    indata[count++] = (byte) b;    if (count < 4) {        return;    }    transformASCII85();    for (int i = 0; i < 5; i++) {        if (outdata[i] == 0) {            break;        }        out.write(outdata[i]);        if (--lineBreak == 0) {            out.write(NEWLINE);            lineBreak = maxline;        }    }    count = 0;}
public void pdfbox_f2742_0() throws IOException
{    if (flushed) {        return;    }    if (count > 0) {        for (int i = count; i < 4; i++) {            indata[i] = 0;        }        transformASCII85();        if (outdata[0] == Z) {            for (            int i = 0;             i < 5;             i++) {                outdata[i] = (byte) OFFSET;            }        }        for (int i = 0; i < count + 1; i++) {            out.write(outdata[i]);            if (--lineBreak == 0) {                out.write(NEWLINE);                lineBreak = maxline;            }        }    }    if (--lineBreak == 0) {        out.write(NEWLINE);    }    out.write(terminator);    out.write('>');    out.write(NEWLINE);    count = 0;    lineBreak = maxline;    flushed = true;    super.flush();}
public void pdfbox_f2743_0() throws IOException
{    try {        flush();        super.close();    } finally {        indata = outdata = null;    }}
public DecodeResult pdfbox_f2744_1(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    int value, firstByte, secondByte;    while ((firstByte = encoded.read()) != -1) {                while (isWhitespace(firstByte)) {            firstByte = encoded.read();        }        if (firstByte == -1 || isEOD(firstByte)) {            break;        }        if (REVERSE_HEX[firstByte] == -1) {                    }        value = REVERSE_HEX[firstByte] * 16;        secondByte = encoded.read();        if (secondByte == -1 || isEOD(secondByte)) {                        decoded.write(value);            break;        }        if (secondByte >= 0) {            if (REVERSE_HEX[secondByte] == -1) {                            }            value += REVERSE_HEX[secondByte];        }        decoded.write(value);    }    decoded.flush();    return new DecodeResult(parameters);}
private boolean pdfbox_f2745_0(int c)
{    return c == 0 || c == 9 || c == 10 || c == 12 || c == 13 || c == 32;}
private boolean pdfbox_f2746_0(int c)
{    return c == '>';}
public void pdfbox_f2747_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    int byteRead;    while ((byteRead = input.read()) != -1) {        Hex.writeHexByte((byte) byteRead, encoded);    }    encoded.flush();}
private void pdfbox_f2748_0() throws IOException
{    if (decodedPos >= decodedLength) {        decodedLength = 0;        try {            decodeRow();        } catch (EOFException e) {                        if (decodedLength != 0) {                throw e;            }                                    decodedLength = -1;        }        decodedPos = 0;    }}
private void pdfbox_f2749_0() throws IOException
{    int index = 0;    boolean white = true;    changesCurrentRowCount = 0;    do {        int completeRun;        if (white) {            completeRun = decodeRun(whiteRunTree);        } else {            completeRun = decodeRun(blackRunTree);        }        if (completeRun == VALUE_EOL) {            continue;        }        index += completeRun;        changesCurrentRow[changesCurrentRowCount++] = index;                white = !white;    } while (index < columns);}
private void pdfbox_f2750_0() throws IOException
{    changesReferenceRowCount = changesCurrentRowCount;    int[] tmp = changesCurrentRow;    changesCurrentRow = changesReferenceRow;    changesReferenceRow = tmp;    boolean white = true;    int index = 0;    changesCurrentRowCount = 0;    mode: while (index < columns) {                Node n = codeTree.root;        while (true) {            n = n.walk(readBit());            if (n == null) {                continue mode;            } else if (n.isLeaf) {                switch(n.value) {                    case VALUE_HMODE:                        int runLength;                        runLength = decodeRun(white ? whiteRunTree : blackRunTree);                        index += runLength;                        changesCurrentRow[changesCurrentRowCount++] = index;                        runLength = decodeRun(white ? blackRunTree : whiteRunTree);                        index += runLength;                        changesCurrentRow[changesCurrentRowCount++] = index;                        break;                    case VALUE_PASSMODE:                        int pChangingElement = getNextChangingElement(index, white) + 1;                        if (pChangingElement >= changesReferenceRowCount) {                            index = columns;                        } else {                            index = changesReferenceRow[pChangingElement];                        }                        break;                    default:                                                int vChangingElement = getNextChangingElement(index, white);                        if (vChangingElement >= changesReferenceRowCount || vChangingElement == -1) {                            index = columns + n.value;                        } else {                            index = changesReferenceRow[vChangingElement] + n.value;                        }                        changesCurrentRow[changesCurrentRowCount] = index;                        changesCurrentRowCount++;                        white = !white;                        break;                }                continue mode;            }        }    }}
private int pdfbox_f2751_0(final int a0, final boolean white)
{    int start = (lastChangingElement & 0xFFFFFFFE) + (white ? 0 : 1);    if (start > 2) {        start -= 2;    }    if (a0 == 0) {        return start;    }    for (int i = start; i < changesReferenceRowCount; i += 2) {        if (a0 < changesReferenceRow[i]) {            lastChangingElement = i;            return i;        }    }    return -1;}
private void pdfbox_f2752_0() throws IOException
{    if (optionByteAligned) {        resetBuffer();    }    decode1D();}
private void pdfbox_f2753_0() throws IOException
{    if (optionByteAligned) {        resetBuffer();    }    eof: while (true) {                Node n = eolOnlyTree.root;        while (true) {            n = n.walk(readBit());            if (n == null) {                continue eof;            }            if (n.isLeaf) {                break eof;            }        }    }    if (!optionG32D || readBit()) {        decode1D();    } else {        decode2D();    }}
private void pdfbox_f2754_0() throws IOException
{    if (optionByteAligned) {        resetBuffer();    }    decode2D();}
private void pdfbox_f2755_0() throws IOException
{    switch(type) {        case TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE:            decodeRowType2();            break;        case TIFFExtension.COMPRESSION_CCITT_T4:            decodeRowType4();            break;        case TIFFExtension.COMPRESSION_CCITT_T6:            decodeRowType6();            break;    }    int index = 0;    boolean white = true;    lastChangingElement = 0;    for (int i = 0; i <= changesCurrentRowCount; i++) {        int nextChange = columns;        if (i != changesCurrentRowCount) {            nextChange = changesCurrentRow[i];        }        if (nextChange > columns) {            nextChange = columns;        }        int byteIndex = index / 8;        while (index % 8 != 0 && (nextChange - index) > 0) {            decodedRow[byteIndex] |= (white ? 0 : 1 << (7 - ((index) % 8)));            index++;        }        if (index % 8 == 0) {            byteIndex = index / 8;            final byte value = (byte) (white ? 0x00 : 0xff);            while ((nextChange - index) > 7) {                decodedRow[byteIndex] = value;                index += 8;                ++byteIndex;            }        }        while ((nextChange - index) > 0) {            if (index % 8 == 0) {                decodedRow[byteIndex] = 0;            }            decodedRow[byteIndex] |= (white ? 0 : 1 << (7 - ((index) % 8)));            index++;        }        white = !white;    }    if (index != columns) {        throw new IOException("Sum of run-lengths does not equal scan line width: " + index + " > " + columns);    }    decodedLength = (index + 7) / 8;}
private int pdfbox_f2756_0(final Tree tree) throws IOException
{    int total = 0;    Node n = tree.root;    while (true) {        boolean bit = readBit();        n = n.walk(bit);        if (n == null) {            throw new IOException("Unknown code in Huffman RLE stream");        }        if (n.isLeaf) {            total += n.value;            if (n.value < 64) {                return total;            } else {                n = tree.root;            }        }    }}
private void pdfbox_f2757_0() throws IOException
{    bufferPos = -1;}
private boolean pdfbox_f2758_0() throws IOException
{    if (bufferPos < 0 || bufferPos > 7) {        buffer = in.read();        if (buffer == -1) {            throw new EOFException("Unexpected end of Huffman RLE stream");        }        bufferPos = 0;    }    boolean isSet;    if (fillOrder == TIFFExtension.FILL_LEFT_TO_RIGHT) {        isSet = ((buffer >> (7 - bufferPos)) & 1) == 1;    } else {        isSet = ((buffer >> (bufferPos)) & 1) == 1;    }    bufferPos++;    if (bufferPos > 7) {        bufferPos = -1;    }    return isSet;}
public int pdfbox_f2759_0() throws IOException
{    if (decodedLength < 0) {        return 0x0;    }    if (decodedPos >= decodedLength) {        fetch();        if (decodedLength < 0) {            return 0x0;        }    }    return decodedRow[decodedPos++] & 0xff;}
public int pdfbox_f2760_0(byte[] b, int off, int len) throws IOException
{    if (decodedLength < 0) {                Arrays.fill(b, off, off + len, (byte) 0x0);        return len;    }    if (decodedPos >= decodedLength) {        fetch();        if (decodedLength < 0) {            Arrays.fill(b, off, off + len, (byte) 0x0);            return len;        }    }    int read = Math.min(decodedLength - decodedPos, len);    System.arraycopy(decodedRow, decodedPos, b, off, read);    decodedPos += read;    return read;}
public long pdfbox_f2761_0(long n) throws IOException
{    if (decodedLength < 0) {        return -1;    }    if (decodedPos >= decodedLength) {        fetch();        if (decodedLength < 0) {            return -1;        }    }    int skipped = (int) Math.min(decodedLength - decodedPos, n);    decodedPos += skipped;    return skipped;}
public boolean pdfbox_f2762_0()
{    return false;}
public synchronized void pdfbox_f2763_0() throws IOException
{    throw new IOException("mark/reset not supported");}
 void pdfbox_f2764_0(final boolean next, final Node node)
{    if (!next) {        left = node;    } else {        right = node;    }}
 Node pdfbox_f2765_0(final boolean next)
{    return next ? right : left;}
public String pdfbox_f2766_0()
{    return "[leaf=" + isLeaf + ", value=" + value + ", canBeFill=" + canBeFill + "]";}
 void pdfbox_f2767_0(final int depth, final int path, final int value) throws IOException
{    Node current = root;    for (int i = 0; i < depth; i++) {        int bitPos = depth - 1 - i;        boolean isSet = ((path >> bitPos) & 1) == 1;        Node next = current.walk(isSet);        if (next == null) {            next = new Node();            if (i == depth - 1) {                next.value = value;                next.isLeaf = true;            }            if (path == 0) {                next.canBeFill = true;            }            current.set(isSet, next);        } else {            if (next.isLeaf) {                throw new IOException("node is leaf, no other following");            }        }        current = next;    }}
 void pdfbox_f2768_0(final int depth, final int path, final Node node) throws IOException
{    Node current = root;    for (int i = 0; i < depth; i++) {        int bitPos = depth - 1 - i;        boolean isSet = ((path >> bitPos) & 1) == 1;        Node next = current.walk(isSet);        if (next == null) {            if (i == depth - 1) {                next = node;            } else {                next = new Node();            }            if (path == 0) {                next.canBeFill = true;            }            current.set(isSet, next);        } else {            if (next.isLeaf) {                throw new IOException("node is leaf, no other following");            }        }        current = next;    }}
public void pdfbox_f2769_0(int b) throws IOException
{    inputBuffer[currentBufferLength] = (byte) b;    currentBufferLength++;    if (currentBufferLength == inputBufferLength) {        encodeRow();        currentBufferLength = 0;    }}
public void pdfbox_f2770_0() throws IOException
{    stream.flush();}
public void pdfbox_f2771_0() throws IOException
{    stream.close();}
private void pdfbox_f2772_0() throws IOException
{    currentRow++;    int[] tmp = changesReferenceRow;    changesReferenceRow = changesCurrentRow;    changesCurrentRow = tmp;    changesReferenceRowLength = changesCurrentRowLength;    changesCurrentRowLength = 0;    int index = 0;    boolean white = true;    while (index < columns) {        int byteIndex = index / 8;        int bit = index % 8;        if ((((inputBuffer[byteIndex] >> (7 - bit)) & 1) == 1) == (white)) {            changesCurrentRow[changesCurrentRowLength] = index;            changesCurrentRowLength++;            white = !white;        }        index++;    }    encodeRowType6();    if (currentRow == rows) {        writeEOL();        writeEOL();        fill();    }}
private void pdfbox_f2773_0() throws IOException
{    encode2D();}
private int[] pdfbox_f2774_0(int pos, boolean white)
{    int[] result = new int[] { columns, columns };    for (int i = 0; i < changesCurrentRowLength; i++) {        if (pos < changesCurrentRow[i] || (pos == 0 && white)) {            result[0] = changesCurrentRow[i];            if ((i + 1) < changesCurrentRowLength) {                result[1] = changesCurrentRow[i + 1];            }            break;        }    }    return result;}
private void pdfbox_f2775_0(int runLength, boolean white) throws IOException
{    int nonterm = runLength / 64;    Code[] codes = white ? WHITE_NONTERMINATING_CODES : BLACK_NONTERMINATING_CODES;    while (nonterm > 0) {        if (nonterm >= codes.length) {            write(codes[codes.length - 1].code, codes[codes.length - 1].length);            nonterm -= codes.length;        } else {            write(codes[nonterm - 1].code, codes[nonterm - 1].length);            nonterm = 0;        }    }    Code c = white ? WHITE_TERMINATING_CODES[runLength % 64] : BLACK_TERMINATING_CODES[runLength % 64];    write(c.code, c.length);}
private void pdfbox_f2776_0() throws IOException
{    boolean white = true;        int index = 0;    while (index < columns) {                int[] nextChanges = getNextChanges(index, white);                int[] nextRefs = getNextRefChanges(index, white);        int difference = nextChanges[0] - nextRefs[0];        if (nextChanges[0] > nextRefs[1]) {                        write(1, 4);            index = nextRefs[1];        } else if (difference > 3 || difference < -3) {                        write(1, 3);            writeRun(nextChanges[0] - index, white);            writeRun(nextChanges[1] - nextChanges[0], !white);            index = nextChanges[1];        } else {                        switch(difference) {                case 0:                    write(1, 1);                    break;                case 1:                    write(3, 3);                    break;                case 2:                    write(3, 6);                    break;                case 3:                    write(3, 7);                    break;                case -1:                    write(2, 3);                    break;                case -2:                    write(2, 6);                    break;                case -3:                    write(2, 7);                    break;            }            white = !white;            index = nextRefs[0] + difference;        }    }}
private int[] pdfbox_f2777_0(int a0, boolean white)
{    int[] result = new int[] { columns, columns };    for (int i = (white ? 0 : 1); i < changesReferenceRowLength; i += 2) {        if (changesReferenceRow[i] > a0 || (a0 == 0 && i == 0)) {            result[0] = changesReferenceRow[i];            if ((i + 1) < changesReferenceRowLength) {                result[1] = changesReferenceRow[i + 1];            }            break;        }    }    return result;}
private void pdfbox_f2778_0(int code, int codeLength) throws IOException
{    for (int i = 0; i < codeLength; i++) {        boolean codeBit = ((code >> (codeLength - i - 1)) & 1) == 1;        if (fillOrder == TIFFExtension.FILL_LEFT_TO_RIGHT) {            outputBuffer |= (codeBit ? 1 << (7 - ((outputBufferBitLength) % 8)) : 0);        } else {            outputBuffer |= (codeBit ? 1 << (((outputBufferBitLength) % 8)) : 0);        }        outputBufferBitLength++;        if (outputBufferBitLength == 8) {            stream.write(outputBuffer);            clearOutputBuffer();        }    }}
private void pdfbox_f2779_0() throws IOException
{    write(1, 12);}
private void pdfbox_f2780_0() throws IOException
{    if (outputBufferBitLength != 0) {        stream.write(outputBuffer);    }    clearOutputBuffer();}
private void pdfbox_f2781_0()
{    outputBuffer = 0;    outputBufferBitLength = 0;}
public DecodeResult pdfbox_f2782_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{        COSDictionary decodeParms = getDecodeParams(parameters, index);        int cols = decodeParms.getInt(COSName.COLUMNS, 1728);    int rows = decodeParms.getInt(COSName.ROWS, 0);    int height = parameters.getInt(COSName.HEIGHT, COSName.H, 0);    if (rows > 0 && height > 0) {                rows = height;    } else {                rows = Math.max(rows, height);    }        int k = decodeParms.getInt(COSName.K, 0);    boolean encodedByteAlign = decodeParms.getBoolean(COSName.ENCODED_BYTE_ALIGN, false);    int arraySize = (cols + 7) / 8 * rows;        byte[] decompressed = new byte[arraySize];    CCITTFaxDecoderStream s;    int type;    long tiffOptions;    if (k == 0) {        tiffOptions = encodedByteAlign ? TIFFExtension.GROUP3OPT_BYTEALIGNED : 0;        type = TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE;    } else {        if (k > 0) {            tiffOptions = encodedByteAlign ? TIFFExtension.GROUP3OPT_BYTEALIGNED : 0;            tiffOptions |= TIFFExtension.GROUP3OPT_2DENCODING;            type = TIFFExtension.COMPRESSION_CCITT_T4;        } else {                        tiffOptions = encodedByteAlign ? TIFFExtension.GROUP4OPT_BYTEALIGNED : 0;            type = TIFFExtension.COMPRESSION_CCITT_T6;        }    }    s = new CCITTFaxDecoderStream(encoded, cols, type, TIFFExtension.FILL_LEFT_TO_RIGHT, tiffOptions);    readFromDecoderStream(s, decompressed);        boolean blackIsOne = decodeParms.getBoolean(COSName.BLACK_IS_1, false);    if (!blackIsOne) {                                        invertBitmap(decompressed);    }    decoded.write(decompressed);    return new DecodeResult(parameters);}
 void pdfbox_f2783_0(CCITTFaxDecoderStream decoderStream, byte[] result) throws IOException
{    int pos = 0;    int read;    while ((read = decoderStream.read(result, pos, result.length - pos)) > -1) {        pos += read;        if (pos >= result.length) {            break;        }    }    decoderStream.close();}
private void pdfbox_f2784_0(byte[] bufferData)
{    for (int i = 0, c = bufferData.length; i < c; i++) {        bufferData[i] = (byte) (~bufferData[i] & 0xFF);    }}
protected void pdfbox_f2785_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    int cols = parameters.getInt(COSName.COLUMNS);    int rows = parameters.getInt(COSName.ROWS);    CCITTFaxEncoderStream ccittFaxEncoderStream = new CCITTFaxEncoderStream(encoded, cols, rows, TIFFExtension.FILL_LEFT_TO_RIGHT);    IOUtils.copy(input, ccittFaxEncoderStream);    input.close();}
public DecodeResult pdfbox_f2786_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    COSName encryptionName = (COSName) parameters.getDictionaryObject(COSName.NAME);    if (encryptionName == null || encryptionName.equals(COSName.IDENTITY)) {                Filter identityFilter = new IdentityFilter();        identityFilter.decode(encoded, decoded, parameters, index);        return new DecodeResult(parameters);    }    throw new IOException("Unsupported crypt filter " + encryptionName.getName());}
protected void pdfbox_f2787_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    COSName encryptionName = (COSName) parameters.getDictionaryObject(COSName.NAME);    if (encryptionName == null || encryptionName.equals(COSName.IDENTITY)) {                Filter identityFilter = new IdentityFilter();        identityFilter.encode(input, encoded, parameters);    } else {        throw new IOException("Unsupported crypt filter " + encryptionName.getName());    }}
public DecodeResult pdfbox_f2788_1(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    ImageReader reader = findImageReader("JPEG", "a suitable JAI I/O image filter is not installed");    try (ImageInputStream iis = ImageIO.createImageInputStream(encoded)) {                if (iis.read() != 0x0A) {            iis.seek(0);        }        reader.setInput(iis);        ImageReadParam irp = reader.getDefaultReadParam();        irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());        irp.setSourceRegion(options.getSourceRegion());        options.setFilterSubsampled(true);        String numChannels = getNumChannels(reader);                ImageIO.setUseCache(false);        Raster raster;                if ("3".equals(numChannels) || numChannels.isEmpty()) {            try {                                BufferedImage image = reader.read(0, irp);                raster = image.getRaster();            } catch (IIOException e) {                                                                raster = reader.readRaster(0, irp);            }        } else {                                    raster = reader.readRaster(0, irp);        }                if (raster.getNumBands() == 4) {                        Integer transform;            try {                transform = getAdobeTransform(reader.getImageMetadata(0));            } catch (IIOException | NegativeArraySizeException e) {                                                transform = getAdobeTransformByBruteForce(iis);            }            int colorTransform = transform != null ? transform : 0;                        switch(colorTransform) {                case 0:                                        break;                case 1:                    raster = fromYCbCrtoCMYK(raster);                    break;                case 2:                    raster = fromYCCKtoCMYK(raster);                    break;                default:                    throw new IllegalArgumentException("Unknown colorTransform");            }        } else if (raster.getNumBands() == 3) {                        raster = fromBGRtoRGB(raster);        }        DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();        decoded.write(dataBuffer.getData());    } finally {        reader.dispose();    }    return new DecodeResult(parameters);}
public DecodeResult pdfbox_f2789_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    return decode(encoded, decoded, parameters, index, DecodeOptions.DEFAULT);}
private Integer pdfbox_f2790_0(IIOMetadata metadata)
{    Element tree = (Element) metadata.getAsTree("javax_imageio_jpeg_image_1.0");    Element markerSequence = (Element) tree.getElementsByTagName("markerSequence").item(0);    NodeList app14AdobeNodeList = markerSequence.getElementsByTagName("app14Adobe");    if (app14AdobeNodeList != null && app14AdobeNodeList.getLength() > 0) {        Element adobe = (Element) app14AdobeNodeList.item(0);        return Integer.parseInt(adobe.getAttribute("transform"));    }    return 0;}
private int pdfbox_f2791_0(ImageInputStream iis) throws IOException
{    int a = 0;    iis.seek(0);    int by;    while ((by = iis.read()) != -1) {        if (ADOBE.charAt(a) == by) {            ++a;            if (a != ADOBE.length()) {                continue;            }                        a = 0;            long afterAdobePos = iis.getStreamPosition();            iis.seek(iis.getStreamPosition() - 9);            int tag = iis.readUnsignedShort();            if (tag != 0xFFEE) {                iis.seek(afterAdobePos);                continue;            }            int len = iis.readUnsignedShort();            if (len >= POS_TRANSFORM + 1) {                byte[] app14 = new byte[Math.max(len, POS_TRANSFORM + 1)];                if (iis.read(app14) >= POS_TRANSFORM + 1) {                    return app14[POS_TRANSFORM];                }            }        } else {            a = 0;        }    }    return 0;}
private WritableRaster pdfbox_f2792_0(Raster raster)
{    WritableRaster writableRaster = raster.createCompatibleWritableRaster();    int[] value = new int[4];    for (int y = 0, height = raster.getHeight(); y < height; y++) {        for (int x = 0, width = raster.getWidth(); x < width; x++) {            raster.getPixel(x, y, value);                        float Y = value[0];            float Cb = value[1];            float Cr = value[2];            float K = value[3];                        int r = clamp(Y + 1.402f * Cr - 179.456f);            int g = clamp(Y - 0.34414f * Cb - 0.71414f * Cr + 135.45984f);            int b = clamp(Y + 1.772f * Cb - 226.816f);                        int cyan = 255 - r;            int magenta = 255 - g;            int yellow = 255 - b;                        value[0] = cyan;            value[1] = magenta;            value[2] = yellow;            value[3] = (int) K;            writableRaster.setPixel(x, y, value);        }    }    return writableRaster;}
private WritableRaster pdfbox_f2793_0(Raster raster)
{    WritableRaster writableRaster = raster.createCompatibleWritableRaster();    int[] value = new int[4];    for (int y = 0, height = raster.getHeight(); y < height; y++) {        for (int x = 0, width = raster.getWidth(); x < width; x++) {            raster.getPixel(x, y, value);                        float Y = value[0];            float Cb = value[1];            float Cr = value[2];            float K = value[3];                        int r = clamp((1.164f * (Y - 16)) + (1.596f * (Cr - 128)));            int g = clamp((1.164f * (Y - 16)) + (-0.392f * (Cb - 128)) + (-0.813f * (Cr - 128)));            int b = clamp((1.164f * (Y - 16)) + (2.017f * (Cb - 128)));                        int cyan = 255 - r;            int magenta = 255 - g;            int yellow = 255 - b;                        value[0] = cyan;            value[1] = magenta;            value[2] = yellow;            value[3] = (int) K;            writableRaster.setPixel(x, y, value);        }    }    return writableRaster;}
private WritableRaster pdfbox_f2794_0(Raster raster)
{    WritableRaster writableRaster = raster.createCompatibleWritableRaster();    int width = raster.getWidth();    int height = raster.getHeight();    int w3 = width * 3;    int[] tab = new int[w3];        for (int y = 0; y < height; y++) {        raster.getPixels(0, y, width, 1, tab);        for (int off = 0; off < w3; off += 3) {            int tmp = tab[off];            tab[off] = tab[off + 2];            tab[off + 2] = tmp;        }        writableRaster.setPixels(0, y, width, 1, tab);    }    return writableRaster;}
private String pdfbox_f2795_1(ImageReader reader)
{    try {        IIOMetadata imageMetadata = reader.getImageMetadata(0);        if (imageMetadata == null) {            return "";        }        IIOMetadataNode metaTree = (IIOMetadataNode) imageMetadata.getAsTree("javax_imageio_1.0");        Element numChannelsItem = (Element) metaTree.getElementsByTagName("NumChannels").item(0);        if (numChannelsItem == null) {            return "";        }        return numChannelsItem.getAttribute("value");    } catch (IOException | NegativeArraySizeException e) {                return "";    }}
private int pdfbox_f2796_0(float value)
{    return (int) ((value < 0) ? 0 : ((value > 255) ? 255 : value));}
protected void pdfbox_f2797_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    throw new UnsupportedOperationException("DCTFilter encoding not implemented, use the JPEGFactory methods instead");}
public Rectangle pdfbox_f2798_0()
{    return sourceRegion;}
public void pdfbox_f2799_0(Rectangle sourceRegion)
{    this.sourceRegion = sourceRegion;}
public int pdfbox_f2800_0()
{    return subsamplingX;}
public void pdfbox_f2801_0(int ssX)
{    this.subsamplingX = ssX;}
public int pdfbox_f2802_0()
{    return subsamplingY;}
public void pdfbox_f2803_0(int ssY)
{    this.subsamplingY = ssY;}
public int pdfbox_f2804_0()
{    return subsamplingOffsetX;}
public void pdfbox_f2805_0(int ssOffsetX)
{    this.subsamplingOffsetX = ssOffsetX;}
public int pdfbox_f2806_0()
{    return subsamplingOffsetY;}
public void pdfbox_f2807_0(int ssOffsetY)
{    this.subsamplingOffsetY = ssOffsetY;}
public boolean pdfbox_f2808_0()
{    return filterSubsampled;}
 void pdfbox_f2809_0(boolean filterSubsampled)
{    this.filterSubsampled = filterSubsampled;}
public void pdfbox_f2810_0(Rectangle sourceRegion)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
public void pdfbox_f2811_0(int ssX)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
public void pdfbox_f2812_0(int ssY)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
public void pdfbox_f2813_0(int ssOffsetX)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
public void pdfbox_f2814_0(int ssOffsetY)
{    throw new UnsupportedOperationException("This instance may not be modified.");}
 void pdfbox_f2815_0(boolean filterSubsampled)
{}
public COSDictionary pdfbox_f2816_0()
{    return parameters;}
public PDJPXColorSpace pdfbox_f2817_0()
{    return colorSpace;}
 void pdfbox_f2818_0(PDJPXColorSpace colorSpace)
{    this.colorSpace = colorSpace;}
public DecodeResult pdfbox_f2819_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    return decode(encoded, decoded, parameters, index);}
public final void pdfbox_f2820_0(InputStream input, OutputStream encoded, COSDictionary parameters, int index) throws IOException
{    encode(input, encoded, parameters.asUnmodifiableDictionary());}
protected COSDictionary pdfbox_f2821_1(COSDictionary dictionary, int index)
{    COSBase filter = dictionary.getDictionaryObject(COSName.FILTER, COSName.F);    COSBase obj = dictionary.getDictionaryObject(COSName.DECODE_PARMS, COSName.DP);    if (filter instanceof COSName && obj instanceof COSDictionary) {                return (COSDictionary) obj;    } else if (filter instanceof COSArray && obj instanceof COSArray) {        COSArray array = (COSArray) obj;        if (index < array.size()) {            COSBase objAtIndex = array.getObject(index);            if (objAtIndex instanceof COSDictionary) {                return (COSDictionary) array.getObject(index);            }        }    } else if (obj != null && !(filter instanceof COSArray || obj instanceof COSArray)) {            }    return new COSDictionary();}
protected static ImageReader pdfbox_f2822_0(String formatName, String errorCause) throws MissingImageReaderException
{    Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName(formatName);    ImageReader reader = null;    while (readers.hasNext()) {        reader = readers.next();        if (reader != null && reader.canReadRaster()) {            break;        }    }    if (reader == null) {        throw new MissingImageReaderException("Cannot read " + formatName + " image: " + errorCause);    }    return reader;}
public static int pdfbox_f2823_1()
{    int compressionLevel = Deflater.DEFAULT_COMPRESSION;    try {        compressionLevel = Integer.parseInt(System.getProperty(Filter.SYSPROP_DEFLATELEVEL, "-1"));    } catch (NumberFormatException ex) {            }    return Math.max(-1, Math.min(Deflater.BEST_COMPRESSION, compressionLevel));}
public Filter pdfbox_f2824_0(String filterName) throws IOException
{    return getFilter(COSName.getPDFName(filterName));}
public Filter pdfbox_f2825_0(COSName filterName) throws IOException
{    Filter filter = filters.get(filterName);    if (filter == null) {        throw new IOException("Invalid filter: " + filterName);    }    return filter;}
 Collection<Filter> pdfbox_f2826_0()
{    return filters.values();}
public DecodeResult pdfbox_f2827_1(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    final COSDictionary decodeParams = getDecodeParams(parameters, index);    try {        decompress(encoded, Predictor.wrapPredictor(decoded, decodeParams));    } catch (DataFormatException e) {                                throw new IOException(e);    }    return new DecodeResult(parameters);}
private void pdfbox_f2828_1(InputStream in, OutputStream out) throws IOException, DataFormatException
{    byte[] buf = new byte[2048];        in.read(buf, 0, 2);    int read = in.read(buf);    if (read > 0) {                Inflater inflater = new Inflater(true);        inflater.setInput(buf, 0, read);        byte[] res = new byte[1024];        boolean dataWritten = false;        while (true) {            int resRead = 0;            try {                resRead = inflater.inflate(res);            } catch (DataFormatException exception) {                if (dataWritten) {                                                            break;                } else {                                        throw exception;                }            }            if (resRead != 0) {                out.write(res, 0, resRead);                dataWritten = true;                continue;            }            if (inflater.finished() || inflater.needsDictionary() || in.available() == 0) {                break;            }            read = in.read(buf);            inflater.setInput(buf, 0, read);        }        inflater.end();    }    out.flush();}
protected void pdfbox_f2829_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    int compressionLevel = getCompressionLevel();    Deflater deflater = new Deflater(compressionLevel);    try (DeflaterOutputStream out = new DeflaterOutputStream(encoded, deflater)) {        int amountRead;        int mayRead = input.available();        if (mayRead > 0) {            byte[] buffer = new byte[Math.min(mayRead, BUFFER_SIZE)];            while ((amountRead = input.read(buffer, 0, Math.min(mayRead, BUFFER_SIZE))) != -1) {                out.write(buffer, 0, amountRead);            }        }    }    encoded.flush();    deflater.end();}
public DecodeResult pdfbox_f2830_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    IOUtils.copy(encoded, decoded);    decoded.flush();    return new DecodeResult(parameters);}
protected void pdfbox_f2831_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    IOUtils.copy(input, encoded);    encoded.flush();}
private static synchronized void pdfbox_f2832_1()
{    if (!levigoLogged) {                        levigoLogged = true;    }}
public DecodeResult pdfbox_f2833_1(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    ImageReader reader = findImageReader("JBIG2", "jbig2-imageio is not installed");    if (reader.getClass().getName().contains("levigo")) {        logLevigoDonated();    }    int bits = parameters.getInt(COSName.BITS_PER_COMPONENT, 1);    COSDictionary params = getDecodeParams(parameters, index);    ImageReadParam irp = reader.getDefaultReadParam();    irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());    irp.setSourceRegion(options.getSourceRegion());    options.setFilterSubsampled(true);    InputStream source = encoded;    if (params != null) {        COSBase globals = params.getDictionaryObject(COSName.JBIG2_GLOBALS);        if (globals instanceof COSStream) {            source = new SequenceInputStream(((COSStream) globals).createInputStream(), encoded);        }    }    try (ImageInputStream iis = ImageIO.createImageInputStream(source)) {        reader.setInput(iis);        BufferedImage image;        try {            image = reader.read(0, irp);        } catch (Exception e) {                        throw new IOException("Could not read JBIG2 image", e);        }                if (image.getColorModel().getPixelSize() != bits) {            if (bits != 1) {                            }            BufferedImage packedImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);            Graphics graphics = packedImage.getGraphics();            graphics.drawImage(image, 0, 0, null);            graphics.dispose();            image = packedImage;        }        DataBuffer dBuf = image.getData().getDataBuffer();        if (dBuf.getDataType() == DataBuffer.TYPE_BYTE) {            decoded.write(((DataBufferByte) dBuf).getData());        } else {            throw new IOException("Unexpected image buffer type");        }    } finally {        reader.dispose();    }    return new DecodeResult(parameters);}
public DecodeResult pdfbox_f2834_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    return decode(encoded, decoded, parameters, index, DecodeOptions.DEFAULT);}
protected void pdfbox_f2835_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    throw new UnsupportedOperationException("JBIG2 encoding not implemented");}
public DecodeResult pdfbox_f2836_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index, DecodeOptions options) throws IOException
{    DecodeResult result = new DecodeResult(new COSDictionary());    result.getParameters().addAll(parameters);    BufferedImage image = readJPX(encoded, options, result);    Raster raster = image.getRaster();    switch(raster.getDataBuffer().getDataType()) {        case DataBuffer.TYPE_BYTE:            DataBufferByte byteBuffer = (DataBufferByte) raster.getDataBuffer();            decoded.write(byteBuffer.getData());            return result;        case DataBuffer.TYPE_USHORT:            DataBufferUShort wordBuffer = (DataBufferUShort) raster.getDataBuffer();            for (short w : wordBuffer.getData()) {                decoded.write(w >> 8);                decoded.write(w);            }            return result;        case DataBuffer.TYPE_INT:                                    int[] ar = new int[raster.getNumBands()];            for (int y = 0; y < image.getHeight(); ++y) {                for (int x = 0; x < image.getWidth(); ++x) {                    raster.getPixel(x, y, ar);                    for (int i = 0; i < ar.length; ++i) {                        decoded.write(ar[i]);                    }                }            }            return result;        default:            throw new IOException("Data type " + raster.getDataBuffer().getDataType() + " not implemented");    }}
public DecodeResult pdfbox_f2837_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    return decode(encoded, decoded, parameters, index, DecodeOptions.DEFAULT);}
private BufferedImage pdfbox_f2838_0(InputStream input, DecodeOptions options, DecodeResult result) throws IOException
{    ImageReader reader = findImageReader("JPEG2000", "Java Advanced Imaging (JAI) Image I/O Tools are not installed");        try (ImageInputStream iis = new MemoryCacheImageInputStream(input)) {        reader.setInput(iis, true, true);        ImageReadParam irp = reader.getDefaultReadParam();        irp.setSourceRegion(options.getSourceRegion());        irp.setSourceSubsampling(options.getSubsamplingX(), options.getSubsamplingY(), options.getSubsamplingOffsetX(), options.getSubsamplingOffsetY());        options.setFilterSubsampled(true);        BufferedImage image;        try {            image = reader.read(0, irp);        } catch (Exception e) {                        throw new IOException("Could not read JPEG 2000 (JPX) image", e);        }        COSDictionary parameters = result.getParameters();                                        int bpc = image.getColorModel().getPixelSize() / image.getRaster().getNumBands();        parameters.setInt(COSName.BITS_PER_COMPONENT, bpc);                if (!parameters.getBoolean(COSName.IMAGE_MASK, false)) {            parameters.setItem(COSName.DECODE, null);        }                parameters.setInt(COSName.WIDTH, reader.getWidth(0));        parameters.setInt(COSName.HEIGHT, reader.getHeight(0));                if (!parameters.containsKey(COSName.COLORSPACE)) {            if (image.getSampleModel() instanceof MultiPixelPackedSampleModel && image.getColorModel().getPixelSize() == 1 && image.getRaster().getNumBands() == 1 && image.getColorModel() instanceof IndexColorModel) {                                                                                result.setColorSpace(new PDJPXColorSpace(ColorSpace.getInstance(ColorSpace.CS_GRAY)));            } else {                result.setColorSpace(new PDJPXColorSpace(image.getColorModel().getColorSpace()));            }        }        return image;    } finally {        reader.dispose();    }}
protected void pdfbox_f2839_0(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    throw new UnsupportedOperationException("JPX encoding not implemented");}
public DecodeResult pdfbox_f2840_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    COSDictionary decodeParams = getDecodeParams(parameters, index);    int earlyChange = decodeParams.getInt(COSName.EARLY_CHANGE, 1);    if (earlyChange != 0 && earlyChange != 1) {        earlyChange = 1;    }    doLZWDecode(encoded, Predictor.wrapPredictor(decoded, decodeParams), earlyChange);    return new DecodeResult(parameters);}
private void pdfbox_f2841_1(InputStream encoded, OutputStream decoded, int earlyChange) throws IOException
{    List<byte[]> codeTable = new ArrayList<>();    int chunk = 9;    final MemoryCacheImageInputStream in = new MemoryCacheImageInputStream(encoded);    long nextCommand;    long prevCommand = -1;    try {        while ((nextCommand = in.readBits(chunk)) != EOD) {            if (nextCommand == CLEAR_TABLE) {                chunk = 9;                codeTable = createCodeTable();                prevCommand = -1;            } else {                if (nextCommand < codeTable.size()) {                    byte[] data = codeTable.get((int) nextCommand);                    byte firstByte = data[0];                    decoded.write(data);                    if (prevCommand != -1) {                        checkIndexBounds(codeTable, prevCommand, in);                        data = codeTable.get((int) prevCommand);                        byte[] newData = Arrays.copyOf(data, data.length + 1);                        newData[data.length] = firstByte;                        codeTable.add(newData);                    }                } else {                    checkIndexBounds(codeTable, prevCommand, in);                    byte[] data = codeTable.get((int) prevCommand);                    byte[] newData = Arrays.copyOf(data, data.length + 1);                    newData[data.length] = data[0];                    decoded.write(newData);                    codeTable.add(newData);                }                chunk = calculateChunk(codeTable.size(), earlyChange);                prevCommand = nextCommand;            }        }    } catch (EOFException ex) {            }    decoded.flush();}
private void pdfbox_f2842_0(List<byte[]> codeTable, long index, MemoryCacheImageInputStream in) throws IOException
{    if (index < 0) {        throw new IOException("negative array index: " + index + " near offset " + in.getStreamPosition());    }    if (index >= codeTable.size()) {        throw new IOException("array index overflow: " + index + " >= " + codeTable.size() + " near offset " + in.getStreamPosition());    }}
protected void pdfbox_f2843_0(InputStream rawData, OutputStream encoded, COSDictionary parameters) throws IOException
{    List<byte[]> codeTable = createCodeTable();    int chunk = 9;    byte[] inputPattern = null;    try (MemoryCacheImageOutputStream out = new MemoryCacheImageOutputStream(encoded)) {        out.writeBits(CLEAR_TABLE, chunk);        int foundCode = -1;        int r;        while ((r = rawData.read()) != -1) {            byte by = (byte) r;            if (inputPattern == null) {                inputPattern = new byte[] { by };                foundCode = by & 0xff;            } else {                inputPattern = Arrays.copyOf(inputPattern, inputPattern.length + 1);                inputPattern[inputPattern.length - 1] = by;                int newFoundCode = findPatternCode(codeTable, inputPattern);                if (newFoundCode == -1) {                                        chunk = calculateChunk(codeTable.size() - 1, 1);                    out.writeBits(foundCode, chunk);                                        codeTable.add(inputPattern);                    if (codeTable.size() == 4096) {                                                out.writeBits(CLEAR_TABLE, chunk);                        codeTable = createCodeTable();                    }                    inputPattern = new byte[] { by };                    foundCode = by & 0xff;                } else {                    foundCode = newFoundCode;                }            }        }        if (foundCode != -1) {            chunk = calculateChunk(codeTable.size() - 1, 1);            out.writeBits(foundCode, chunk);        }                                                chunk = calculateChunk(codeTable.size(), 1);        out.writeBits(EOD, chunk);                out.writeBits(0, 7);                out.flush();    }}
private int pdfbox_f2844_0(List<byte[]> codeTable, byte[] pattern)
{    int foundCode = -1;    int foundLen = 0;    for (int i = codeTable.size() - 1; i >= 0; --i) {        if (i <= EOD) {                        if (foundCode != -1) {                                return foundCode;            } else if (pattern.length > 1) {                                return -1;            }        }        byte[] tryPattern = codeTable.get(i);        if ((foundCode != -1 || tryPattern.length > foundLen) && Arrays.equals(tryPattern, pattern)) {            foundCode = i;            foundLen = tryPattern.length;        }    }    return foundCode;}
private List<byte[]> pdfbox_f2845_0()
{    List<byte[]> codeTable = new ArrayList<>(4096);    for (int i = 0; i < 256; ++i) {        codeTable.add(new byte[] { (byte) (i & 0xFF) });    }        codeTable.add(null);        codeTable.add(null);    return codeTable;}
private int pdfbox_f2846_0(int tabSize, int earlyChange)
{    if (tabSize >= 2048 - earlyChange) {        return 12;    }    if (tabSize >= 1024 - earlyChange) {        return 11;    }    if (tabSize >= 512 - earlyChange) {        return 10;    }    return 9;}
 static void pdfbox_f2847_0(int predictor, int colors, int bitsPerComponent, int columns, byte[] actline, byte[] lastline)
{    if (predictor == 1) {                return;    }    final int bitsPerPixel = colors * bitsPerComponent;    final int bytesPerPixel = (bitsPerPixel + 7) / 8;    final int rowlength = actline.length;    switch(predictor) {        case 2:                        if (bitsPerComponent == 8) {                                for (int p = bytesPerPixel; p < rowlength; p++) {                    int sub = actline[p] & 0xff;                    int left = actline[p - bytesPerPixel] & 0xff;                    actline[p] = (byte) (sub + left);                }                break;            }            if (bitsPerComponent == 16) {                for (int p = bytesPerPixel; p < rowlength; p += 2) {                    int sub = ((actline[p] & 0xff) << 8) + (actline[p + 1] & 0xff);                    int left = (((actline[p - bytesPerPixel] & 0xff) << 8) + (actline[p - bytesPerPixel + 1] & 0xff));                    actline[p] = (byte) (((sub + left) >> 8) & 0xff);                    actline[p + 1] = (byte) ((sub + left) & 0xff);                }                break;            }            if (bitsPerComponent == 1 && colors == 1) {                                for (int p = 0; p < rowlength; p++) {                    for (int bit = 7; bit >= 0; --bit) {                        int sub = (actline[p] >> bit) & 1;                        if (p == 0 && bit == 7) {                            continue;                        }                        int left;                        if (bit == 7) {                                                        left = actline[p - 1] & 1;                        } else {                                                        left = (actline[p] >> (bit + 1)) & 1;                        }                        if (((sub + left) & 1) == 0) {                                                        actline[p] = (byte) (actline[p] & ~(1 << bit));                        } else {                                                        actline[p] = (byte) (actline[p] | (1 << bit));                        }                    }                }                break;            }                        int elements = columns * colors;            for (int p = colors; p < elements; ++p) {                int bytePosSub = p * bitsPerComponent / 8;                int bitPosSub = 8 - p * bitsPerComponent % 8 - bitsPerComponent;                int bytePosLeft = (p - colors) * bitsPerComponent / 8;                int bitPosLeft = 8 - (p - colors) * bitsPerComponent % 8 - bitsPerComponent;                int sub = getBitSeq(actline[bytePosSub], bitPosSub, bitsPerComponent);                int left = getBitSeq(actline[bytePosLeft], bitPosLeft, bitsPerComponent);                actline[bytePosSub] = (byte) calcSetBitSeq(actline[bytePosSub], bitPosSub, bitsPerComponent, sub + left);            }            break;        case 10:                        break;        case 11:                        for (int p = bytesPerPixel; p < rowlength; p++) {                int sub = actline[p];                int left = actline[p - bytesPerPixel];                actline[p] = (byte) (sub + left);            }            break;        case 12:                        for (int p = 0; p < rowlength; p++) {                int up = actline[p] & 0xff;                int prior = lastline[p] & 0xff;                actline[p] = (byte) ((up + prior) & 0xff);            }            break;        case 13:                        for (int p = 0; p < rowlength; p++) {                int avg = actline[p] & 0xff;                int left = p - bytesPerPixel >= 0 ? actline[p - bytesPerPixel] & 0xff : 0;                int up = lastline[p] & 0xff;                actline[p] = (byte) ((avg + (left + up) / 2) & 0xff);            }            break;        case 14:                        for (int p = 0; p < rowlength; p++) {                int paeth = actline[p] & 0xff;                                int a = p - bytesPerPixel >= 0 ? actline[p - bytesPerPixel] & 0xff : 0;                                int b = lastline[p] & 0xff;                                int c = p - bytesPerPixel >= 0 ? lastline[p - bytesPerPixel] & 0xff : 0;                int value = a + b - c;                int absa = Math.abs(value - a);                int absb = Math.abs(value - b);                int absc = Math.abs(value - c);                if (absa <= absb && absa <= absc) {                    actline[p] = (byte) ((paeth + a) & 0xff);                } else if (absb <= absc) {                    actline[p] = (byte) ((paeth + b) & 0xff);                } else {                    actline[p] = (byte) ((paeth + c) & 0xff);                }            }            break;        default:            break;    }}
 static void pdfbox_f2848_0(int predictor, int colors, int bitsPerComponent, int columns, InputStream in, OutputStream out) throws IOException
{    if (predictor == 1) {                IOUtils.copy(in, out);    } else {                final int rowlength = calculateRowLength(colors, bitsPerComponent, columns);        byte[] actline = new byte[rowlength];        byte[] lastline = new byte[rowlength];        int linepredictor = predictor;        while (in.available() > 0) {                        if (predictor >= 10) {                                                linepredictor = in.read();                if (linepredictor == -1) {                    return;                }                                linepredictor += 10;            }                        int i, offset = 0;            while (offset < rowlength && ((i = in.read(actline, offset, rowlength - offset)) != -1)) {                offset += i;            }            decodePredictorRow(linepredictor, colors, bitsPerComponent, columns, actline, lastline);            System.arraycopy(actline, 0, lastline, 0, rowlength);            out.write(actline);        }    }}
 static int pdfbox_f2849_0(int colors, int bitsPerComponent, int columns)
{    final int bitsPerPixel = colors * bitsPerComponent;    return (columns * bitsPerPixel + 7) / 8;}
 static int pdfbox_f2850_0(int by, int startBit, int bitSize)
{    int mask = ((1 << bitSize) - 1);    return (by >>> startBit) & mask;}
 static int pdfbox_f2851_0(int by, int startBit, int bitSize, int val)
{    int mask = ((1 << bitSize) - 1);    int truncatedVal = val & mask;    mask = ~(mask << startBit);    return (by & mask) | (truncatedVal << startBit);}
 static OutputStream pdfbox_f2852_0(OutputStream out, COSDictionary decodeParams)
{    int predictor = decodeParams.getInt(COSName.PREDICTOR);    if (predictor > 1) {        int colors = Math.min(decodeParams.getInt(COSName.COLORS, 1), 32);        int bitsPerPixel = decodeParams.getInt(COSName.BITS_PER_COMPONENT, 8);        int columns = decodeParams.getInt(COSName.COLUMNS, 1);        return new PredictorOutputStream(out, predictor, colors, bitsPerPixel, columns);    } else {        return out;    }}
public void pdfbox_f2853_0(byte[] bytes) throws IOException
{    write(bytes, 0, bytes.length);}
public void pdfbox_f2854_0(byte[] bytes, int off, int len) throws IOException
{    int currentOffset = off;    int maxOffset = currentOffset + len;    while (currentOffset < maxOffset) {        if (predictorPerRow && currentRowData == 0 && !predictorRead) {                                    predictor = bytes[currentOffset] + 10;            currentOffset++;            predictorRead = true;        } else {            int toRead = Math.min(rowLength - currentRowData, maxOffset - currentOffset);            System.arraycopy(bytes, currentOffset, currentRow, currentRowData, toRead);            currentRowData += toRead;            currentOffset += toRead;                        if (currentRowData == currentRow.length) {                decodeAndWriteRow();            }        }    }}
private void pdfbox_f2855_0() throws IOException
{    decodePredictorRow(predictor, colors, bitsPerComponent, columns, currentRow, lastRow);    out.write(currentRow);    flipRows();}
private void pdfbox_f2856_0()
{    byte[] temp = lastRow;    lastRow = currentRow;    currentRow = temp;    currentRowData = 0;    predictorRead = false;}
public void pdfbox_f2857_0() throws IOException
{        if (currentRowData > 0) {        Arrays.fill(currentRow, currentRowData, rowLength, (byte) 0);        decodeAndWriteRow();    }    super.flush();}
public void pdfbox_f2858_0(int i) throws IOException
{    throw new UnsupportedOperationException("Not supported");}
public DecodeResult pdfbox_f2859_0(InputStream encoded, OutputStream decoded, COSDictionary parameters, int index) throws IOException
{    int dupAmount;    byte[] buffer = new byte[128];    while ((dupAmount = encoded.read()) != -1 && dupAmount != RUN_LENGTH_EOD) {        if (dupAmount <= 127) {            int amountToCopy = dupAmount + 1;            int compressedRead;            while (amountToCopy > 0) {                compressedRead = encoded.read(buffer, 0, amountToCopy);                                if (compressedRead == -1) {                    break;                }                decoded.write(buffer, 0, compressedRead);                amountToCopy -= compressedRead;            }        } else {            int dupByte = encoded.read();                        if (dupByte == -1) {                break;            }            for (int i = 0; i < 257 - dupAmount; i++) {                decoded.write(dupByte);            }        }    }    return new DecodeResult(parameters);}
protected void pdfbox_f2860_1(InputStream input, OutputStream encoded, COSDictionary parameters) throws IOException
{    }
public static byte[] pdfbox_f2861_0(InputStream in) throws IOException
{    ByteArrayOutputStream baout = new ByteArrayOutputStream();    copy(in, baout);    return baout.toByteArray();}
public static long pdfbox_f2862_0(InputStream input, OutputStream output) throws IOException
{    byte[] buffer = new byte[4096];    long count = 0;    int n = 0;    while (-1 != (n = input.read(buffer))) {        output.write(buffer, 0, n);        count += n;    }    return count;}
public static long pdfbox_f2863_0(InputStream in, byte[] buffer) throws IOException
{    int remaining = buffer.length;    while (remaining > 0) {        int bufferWritePos = buffer.length - remaining;        int bytesRead = in.read(buffer, bufferWritePos, remaining);        if (bytesRead < 0) {                        break;        }        remaining -= bytesRead;    }    return buffer.length - remaining;}
public static void pdfbox_f2864_1(Closeable closeable)
{    try {        if (closeable != null) {            closeable.close();        }    } catch (IOException ioe) {                }}
public static IOException pdfbox_f2865_1(Closeable closeable, Log logger, String resourceName, IOException initialException)
{    try {        closeable.close();    } catch (IOException ioe) {                if (initialException == null) {            return ioe;        }    }    return initialException;}
public static MemoryUsageSetting pdfbox_f2866_0()
{    return setupMainMemoryOnly(-1);}
public static MemoryUsageSetting pdfbox_f2867_0(long maxMainMemoryBytes)
{    return new MemoryUsageSetting(true, false, maxMainMemoryBytes, maxMainMemoryBytes);}
public static MemoryUsageSetting pdfbox_f2868_0()
{    return setupTempFileOnly(-1);}
public static MemoryUsageSetting pdfbox_f2869_0(long maxStorageBytes)
{    return new MemoryUsageSetting(false, true, 0, maxStorageBytes);}
public static MemoryUsageSetting pdfbox_f2870_0(long maxMainMemoryBytes)
{    return setupMixed(maxMainMemoryBytes, -1);}
public static MemoryUsageSetting pdfbox_f2871_0(long maxMainMemoryBytes, long maxStorageBytes)
{    return new MemoryUsageSetting(true, true, maxMainMemoryBytes, maxStorageBytes);}
public MemoryUsageSetting pdfbox_f2872_0(int parallelUseCount)
{    long newMaxMainMemoryBytes = maxMainMemoryBytes <= 0 ? maxMainMemoryBytes : maxMainMemoryBytes / parallelUseCount;    long newMaxStorageBytes = maxStorageBytes <= 0 ? maxStorageBytes : maxStorageBytes / parallelUseCount;    MemoryUsageSetting copy = new MemoryUsageSetting(useMainMemory, useTempFile, newMaxMainMemoryBytes, newMaxStorageBytes);    copy.tempDir = tempDir;    return copy;}
public MemoryUsageSetting pdfbox_f2873_0(File tempDir)
{    this.tempDir = tempDir;    return this;}
public boolean pdfbox_f2874_0()
{    return useMainMemory;}
public boolean pdfbox_f2875_0()
{    return useTempFile;}
public boolean pdfbox_f2876_0()
{    return maxMainMemoryBytes >= 0;}
public boolean pdfbox_f2877_0()
{    return maxStorageBytes > 0;}
public long pdfbox_f2878_0()
{    return maxMainMemoryBytes;}
public long pdfbox_f2879_0()
{    return maxStorageBytes;}
public File pdfbox_f2880_0()
{    return tempDir;}
public String pdfbox_f2881_0()
{    return useMainMemory ? (useTempFile ? "Mixed mode with max. of " + maxMainMemoryBytes + " main memory bytes" + (isStorageRestricted() ? " and max. of " + maxStorageBytes + " storage bytes" : " and unrestricted scratch file size") : (isMainMemoryRestricted() ? "Main memory only with max. of " + maxMainMemoryBytes + " bytes" : "Main memory only with no size restriction")) : (isStorageRestricted() ? "Scratch file only with max. of " + maxStorageBytes + " bytes" : "Scratch file only with no size restriction");}
public RandomAccessBuffer pdfbox_f2882_0()
{    RandomAccessBuffer copy = new RandomAccessBuffer(chunkSize);    copy.bufferList = new ArrayList<>(bufferList.size());    for (byte[] buffer : bufferList) {        byte[] newBuffer = new byte[buffer.length];        System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);        copy.bufferList.add(newBuffer);    }    if (currentBuffer != null) {        copy.currentBuffer = copy.bufferList.get(copy.bufferList.size() - 1);    } else {        copy.currentBuffer = null;    }    copy.pointer = pointer;    copy.currentBufferPointer = currentBufferPointer;    copy.size = size;    copy.bufferListIndex = bufferListIndex;    copy.bufferListMaxIndex = bufferListMaxIndex;    return copy;}
public void pdfbox_f2883_0() throws IOException
{    currentBuffer = null;    bufferList.clear();    pointer = 0;    currentBufferPointer = 0;    size = 0;    bufferListIndex = 0;}
public void pdfbox_f2884_0()
{    bufferList.clear();    currentBuffer = new byte[chunkSize];    bufferList.add(currentBuffer);    pointer = 0;    currentBufferPointer = 0;    size = 0;    bufferListIndex = 0;    bufferListMaxIndex = 0;}
public void pdfbox_f2885_0(long position) throws IOException
{    checkClosed();    if (position < 0) {        throw new IOException("Invalid position " + position);    }    pointer = position;    if (pointer < size) {                bufferListIndex = (int) (pointer / chunkSize);        currentBufferPointer = (int) (pointer % chunkSize);        currentBuffer = bufferList.get(bufferListIndex);    } else {                        bufferListIndex = bufferListMaxIndex;        currentBuffer = bufferList.get(bufferListIndex);        currentBufferPointer = (int) (size % chunkSize);    }}
public long pdfbox_f2886_0() throws IOException
{    checkClosed();    return pointer;}
public int pdfbox_f2887_0() throws IOException
{    checkClosed();    if (pointer >= this.size) {        return -1;    }    if (currentBufferPointer >= chunkSize) {        if (bufferListIndex >= bufferListMaxIndex) {            return -1;        } else {            currentBuffer = bufferList.get(++bufferListIndex);            currentBufferPointer = 0;        }    }    pointer++;    return currentBuffer[currentBufferPointer++] & 0xff;}
public int pdfbox_f2888_0(byte[] b, int offset, int length) throws IOException
{    checkClosed();    if (pointer >= size) {        return 0;    }    int bytesRead = readRemainingBytes(b, offset, length);    while (bytesRead < length && available() > 0) {        bytesRead += readRemainingBytes(b, offset + bytesRead, length - bytesRead);        if (currentBufferPointer == chunkSize) {            nextBuffer();        }    }    return bytesRead;}
private int pdfbox_f2889_0(byte[] b, int offset, int length) throws IOException
{    if (pointer >= size) {        return 0;    }    int maxLength = (int) Math.min(length, size - pointer);    int remainingBytes = chunkSize - currentBufferPointer;        if (remainingBytes == 0) {        return 0;    }    if (maxLength >= remainingBytes) {                System.arraycopy(currentBuffer, currentBufferPointer, b, offset, remainingBytes);                currentBufferPointer += remainingBytes;        pointer += remainingBytes;        return remainingBytes;    } else {                System.arraycopy(currentBuffer, currentBufferPointer, b, offset, maxLength);                currentBufferPointer += maxLength;        pointer += maxLength;        return maxLength;    }}
public long pdfbox_f2890_0() throws IOException
{    checkClosed();    return size;}
public void pdfbox_f2891_0(int b) throws IOException
{    checkClosed();        if (currentBufferPointer >= chunkSize) {        if (pointer + chunkSize >= Integer.MAX_VALUE) {            throw new IOException("RandomAccessBuffer overflow");        }        expandBuffer();    }    currentBuffer[currentBufferPointer++] = (byte) b;    pointer++;    if (pointer > this.size) {        this.size = pointer;    }        if (currentBufferPointer >= chunkSize) {        if (pointer + chunkSize >= Integer.MAX_VALUE) {            throw new IOException("RandomAccessBuffer overflow");        }        expandBuffer();    }}
public void pdfbox_f2892_0(byte[] b) throws IOException
{    write(b, 0, b.length);}
public void pdfbox_f2893_0(byte[] b, int offset, int length) throws IOException
{    checkClosed();    long newSize = pointer + length;    int remainingBytes = chunkSize - currentBufferPointer;    if (length >= remainingBytes) {        if (newSize > Integer.MAX_VALUE) {            throw new IOException("RandomAccessBuffer overflow");        }                System.arraycopy(b, offset, currentBuffer, currentBufferPointer, remainingBytes);        int newOffset = offset + remainingBytes;        long remainingBytes2Write = length - remainingBytes;                int numberOfNewArrays = (int) remainingBytes2Write / chunkSize;        for (int i = 0; i < numberOfNewArrays; i++) {            expandBuffer();            System.arraycopy(b, newOffset, currentBuffer, currentBufferPointer, chunkSize);            newOffset += chunkSize;        }                remainingBytes2Write -= numberOfNewArrays * (long) chunkSize;        if (remainingBytes2Write >= 0) {            expandBuffer();            if (remainingBytes2Write > 0) {                System.arraycopy(b, newOffset, currentBuffer, currentBufferPointer, (int) remainingBytes2Write);            }            currentBufferPointer = (int) remainingBytes2Write;        }    } else {        System.arraycopy(b, offset, currentBuffer, currentBufferPointer, length);        currentBufferPointer += length;    }    pointer += length;    if (pointer > this.size) {        this.size = pointer;    }}
private void pdfbox_f2894_0() throws IOException
{    if (bufferListMaxIndex > bufferListIndex) {                nextBuffer();    } else {                currentBuffer = new byte[chunkSize];        bufferList.add(currentBuffer);        currentBufferPointer = 0;        bufferListMaxIndex++;        bufferListIndex++;    }}
private void pdfbox_f2895_0() throws IOException
{    if (bufferListIndex == bufferListMaxIndex) {        throw new IOException("No more chunks available, end of buffer reached");    }    currentBufferPointer = 0;    currentBuffer = bufferList.get(++bufferListIndex);}
private void pdfbox_f2896_0() throws IOException
{    if (currentBuffer == null) {                throw new IOException("RandomAccessBuffer already closed");    }}
public boolean pdfbox_f2897_0()
{    return currentBuffer == null;}
public boolean pdfbox_f2898_0() throws IOException
{    checkClosed();    return pointer >= size;}
public int pdfbox_f2899_0() throws IOException
{    return (int) Math.min(length() - getPosition(), Integer.MAX_VALUE);}
public int pdfbox_f2900_0() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
public void pdfbox_f2901_0(int bytes) throws IOException
{    checkClosed();    seek(getPosition() - bytes);}
public byte[] pdfbox_f2902_0(int length) throws IOException
{    byte[] b = new byte[length];    int bytesRead = read(b);    while (bytesRead < length) {        bytesRead += read(b, bytesRead, length - bytesRead);    }    return b;}
public int pdfbox_f2903_0(byte[] b) throws IOException
{    return read(b, 0, b.length);}
protected boolean pdfbox_f2904_0(Map.Entry<Long, byte[]> eldest)
{    final boolean doRemove = size() > maxCachedPages;    if (doRemove) {        lastRemovedCachePage = eldest.getValue();    }    return doRemove;}
private File pdfbox_f2905_0(InputStream input) throws IOException
{    File tmpFile = File.createTempFile(TMP_FILE_PREFIX, ".pdf");    try (FileOutputStream fos = new FileOutputStream(tmpFile)) {        IOUtils.copy(input, fos);        return tmpFile;    } finally {        IOUtils.closeQuietly(input);    }}
private void pdfbox_f2906_0()
{    if (tempFile != null) {        tempFile.delete();    }}
public long pdfbox_f2907_0()
{    return fileOffset;}
public void pdfbox_f2908_0(final long newOffset) throws IOException
{    final long newPageOffset = newOffset & pageOffsetMask;    if (newPageOffset != curPageOffset) {        byte[] newPage = pageCache.get(newPageOffset);        if (newPage == null) {            raFile.seek(newPageOffset);            newPage = readPage();            pageCache.put(newPageOffset, newPage);        }        curPageOffset = newPageOffset;        curPage = newPage;    }    offsetWithinPage = (int) (newOffset - curPageOffset);    fileOffset = newOffset;}
private byte[] pdfbox_f2909_0() throws IOException
{    byte[] page;    if (lastRemovedCachePage != null) {        page = lastRemovedCachePage;        lastRemovedCachePage = null;    } else {        page = new byte[pageSize];    }    int readBytes = 0;    while (readBytes < pageSize) {        int curBytesRead = raFile.read(page, readBytes, pageSize - readBytes);        if (curBytesRead < 0) {                        break;        }        readBytes += curBytesRead;    }    return page;}
public int pdfbox_f2910_0() throws IOException
{    if (fileOffset >= fileLength) {        return -1;    }    if (offsetWithinPage == pageSize) {        seek(fileOffset);    }    fileOffset++;    return curPage[offsetWithinPage++] & 0xff;}
public int pdfbox_f2911_0(byte[] b) throws IOException
{    return read(b, 0, b.length);}
public int pdfbox_f2912_0(byte[] b, int off, int len) throws IOException
{    if (fileOffset >= fileLength) {        return -1;    }    if (offsetWithinPage == pageSize) {        seek(fileOffset);    }    int commonLen = Math.min(pageSize - offsetWithinPage, len);    if ((fileLength - fileOffset) < pageSize) {        commonLen = Math.min(commonLen, (int) (fileLength - fileOffset));    }    System.arraycopy(curPage, offsetWithinPage, b, off, commonLen);    offsetWithinPage += commonLen;    fileOffset += commonLen;    return commonLen;}
public int pdfbox_f2913_0() throws IOException
{    return (int) Math.min(fileLength - fileOffset, Integer.MAX_VALUE);}
public long pdfbox_f2914_0(long n) throws IOException
{        long toSkip = n;    if (fileLength - fileOffset < toSkip) {        toSkip = fileLength - fileOffset;    }    if ((toSkip < pageSize) && ((offsetWithinPage + toSkip) <= pageSize)) {                offsetWithinPage += toSkip;        fileOffset += toSkip;    } else {                seek(fileOffset + toSkip);    }    return toSkip;}
public long pdfbox_f2915_0() throws IOException
{    return fileLength;}
public void pdfbox_f2916_0() throws IOException
{    raFile.close();    deleteTempFile();    pageCache.clear();    isClosed = true;}
public boolean pdfbox_f2917_0()
{    return isClosed;}
public int pdfbox_f2918_0() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
public void pdfbox_f2919_0(int bytes) throws IOException
{    seek(getPosition() - bytes);}
public byte[] pdfbox_f2920_0(int length) throws IOException
{    byte[] b = new byte[length];    int bytesRead = read(b);    while (bytesRead < length) {        bytesRead += read(b, bytesRead, length - bytesRead);    }    return b;}
public boolean pdfbox_f2921_0() throws IOException
{    int peek = peek();    return peek == -1;}
public void pdfbox_f2922_0() throws IOException
{    ras.close();    isClosed = true;}
public void pdfbox_f2923_0() throws IOException
{    checkClosed();    ras.seek(0);    ras.setLength(0);}
public void pdfbox_f2924_0(long position) throws IOException
{    checkClosed();    ras.seek(position);}
public long pdfbox_f2925_0() throws IOException
{    checkClosed();    return ras.getFilePointer();}
public int pdfbox_f2926_0() throws IOException
{    checkClosed();    return ras.read();}
public int pdfbox_f2927_0(byte[] b) throws IOException
{    checkClosed();    return ras.read(b);}
public int pdfbox_f2928_0(byte[] b, int offset, int length) throws IOException
{    checkClosed();    return ras.read(b, offset, length);}
public long pdfbox_f2929_0() throws IOException
{    checkClosed();    return ras.length();}
private void pdfbox_f2930_0() throws IOException
{    if (isClosed) {        throw new IOException("RandomAccessFile already closed");    }}
public boolean pdfbox_f2931_0()
{    return isClosed;}
public void pdfbox_f2932_0(byte[] b, int offset, int length) throws IOException
{    checkClosed();    ras.write(b, offset, length);}
public void pdfbox_f2933_0(byte[] b) throws IOException
{    write(b, 0, b.length);}
public void pdfbox_f2934_0(int b) throws IOException
{    checkClosed();    ras.write(b);}
public int pdfbox_f2935_0() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
public void pdfbox_f2936_0(int bytes) throws IOException
{    checkClosed();    ras.seek(ras.getFilePointer() - bytes);}
public byte[] pdfbox_f2937_0(int length) throws IOException
{    checkClosed();    byte[] b = new byte[length];    ras.readFully(b);    return b;}
public boolean pdfbox_f2938_0() throws IOException
{    return peek() == -1;}
public int pdfbox_f2939_0() throws IOException
{    checkClosed();    return (int) Math.min(ras.length() - getPosition(), Integer.MAX_VALUE);}
 void pdfbox_f2940_0() throws IOException
{    input.seek(position);}
public int pdfbox_f2941_0() throws IOException
{    restorePosition();    long available = input.length() - input.getPosition();    if (available > Integer.MAX_VALUE) {        return Integer.MAX_VALUE;    }    return (int) available;}
public int pdfbox_f2942_1() throws IOException
{    restorePosition();    if (input.isEOF()) {        return -1;    }    int b = input.read();    if (b != -1) {        position += 1;    } else {                            }    return b;}
public int pdfbox_f2943_1(byte[] b, int off, int len) throws IOException
{    restorePosition();    if (input.isEOF()) {        return -1;    }    int n = input.read(b, off, len);    if (n != -1) {        position += n;    } else {                            }    return n;}
public long pdfbox_f2944_0(long n) throws IOException
{    restorePosition();    input.seek(position + n);    position += n;    return n;}
public void pdfbox_f2945_0(byte[] b, int offset, int length) throws IOException
{    writer.write(b, offset, length);}
public void pdfbox_f2946_0(byte[] b) throws IOException
{    writer.write(b);}
public void pdfbox_f2947_0(int b) throws IOException
{    writer.write(b);}
public static ScratchFile pdfbox_f2948_1()
{    try {        return new ScratchFile(MemoryUsageSetting.setupMainMemoryOnly());    } catch (IOException ioe) {                        return null;    }}
public static ScratchFile pdfbox_f2949_1(long maxMainMemoryBytes)
{    try {        return new ScratchFile(MemoryUsageSetting.setupMainMemoryOnly(maxMainMemoryBytes));    } catch (IOException ioe) {                        return null;    }}
 int pdfbox_f2950_0() throws IOException
{    synchronized (freePages) {        int idx = freePages.nextSetBit(0);        if (idx < 0) {            enlarge();            idx = freePages.nextSetBit(0);            if (idx < 0) {                throw new IOException("Maximum allowed scratch file memory exceeded.");            }        }        freePages.clear(idx);        if (idx >= pageCount) {            pageCount = idx + 1;        }        return idx;    }}
private void pdfbox_f2951_1() throws IOException
{    synchronized (ioLock) {        checkClosed();        if (pageCount >= maxPageCount) {            return;        }        if (useScratchFile) {                        if (raf == null) {                file = File.createTempFile("PDFBox", ".tmp", scratchFileDirectory);                try {                    raf = new java.io.RandomAccessFile(file, "rw");                } catch (IOException e) {                    if (!file.delete()) {                                            }                    throw e;                }            }            long fileLen = raf.length();            long expectedFileLen = ((long) pageCount - inMemoryMaxPageCount) * PAGE_SIZE;            if (expectedFileLen != fileLen) {                throw new IOException("Expected scratch file size of " + expectedFileLen + " but found " + fileLen);            }                        if (pageCount + ENLARGE_PAGE_COUNT > pageCount) {                fileLen += ENLARGE_PAGE_COUNT * PAGE_SIZE;                raf.setLength(fileLen);                freePages.set(pageCount, pageCount + ENLARGE_PAGE_COUNT);            }        } else if (!maxMainMemoryIsRestricted) {                        int oldSize = inMemoryPages.length;                        int newSize = (int) Math.min(((long) oldSize) * 2, Integer.MAX_VALUE);            if (newSize > oldSize) {                byte[][] newInMemoryPages = new byte[newSize][];                System.arraycopy(inMemoryPages, 0, newInMemoryPages, 0, oldSize);                inMemoryPages = newInMemoryPages;                freePages.set(oldSize, newSize);            }        }    }}
 int pdfbox_f2952_0()
{    return PAGE_SIZE;}
 byte[] pdfbox_f2953_0(int pageIdx) throws IOException
{    if ((pageIdx < 0) || (pageIdx >= pageCount)) {        checkClosed();        throw new IOException("Page index out of range: " + pageIdx + ". Max value: " + (pageCount - 1));    }        if (pageIdx < inMemoryMaxPageCount) {        byte[] page = inMemoryPages[pageIdx];                if (page == null) {            checkClosed();            throw new IOException("Requested page with index " + pageIdx + " was not written before.");        }        return page;    }    synchronized (ioLock) {        if (raf == null) {            checkClosed();            throw new IOException("Missing scratch file to read page with index " + pageIdx + " from.");        }        byte[] page = new byte[PAGE_SIZE];        raf.seek(((long) pageIdx - inMemoryMaxPageCount) * PAGE_SIZE);        raf.readFully(page);        return page;    }}
 void pdfbox_f2954_0(int pageIdx, byte[] page) throws IOException
{    if ((pageIdx < 0) || (pageIdx >= pageCount)) {        checkClosed();        throw new IOException("Page index out of range: " + pageIdx + ". Max value: " + (pageCount - 1));    }    if (page.length != PAGE_SIZE) {        throw new IOException("Wrong page size to write: " + page.length + ". Expected: " + PAGE_SIZE);    }    if (pageIdx < inMemoryMaxPageCount) {        if (maxMainMemoryIsRestricted) {            inMemoryPages[pageIdx] = page;        } else {                        synchronized (ioLock) {                inMemoryPages[pageIdx] = page;            }        }                checkClosed();    } else {        synchronized (ioLock) {            checkClosed();            raf.seek(((long) pageIdx - inMemoryMaxPageCount) * PAGE_SIZE);            raf.write(page);        }    }}
 void pdfbox_f2955_0() throws IOException
{    if (isClosed) {        throw new IOException("Scratch file already closed");    }}
public RandomAccess pdfbox_f2956_0() throws IOException
{    return new ScratchFileBuffer(this);}
public RandomAccess pdfbox_f2957_0(InputStream input) throws IOException
{    ScratchFileBuffer buf = new ScratchFileBuffer(this);    byte[] byteBuffer = new byte[8192];    int bytesRead;    while ((bytesRead = input.read(byteBuffer)) > -1) {        buf.write(byteBuffer, 0, bytesRead);    }    buf.seek(0);    return buf;}
 void pdfbox_f2958_0(int[] pageIndexes, int off, int count)
{    synchronized (freePages) {        for (int aIdx = off; aIdx < count; aIdx++) {            int pageIdx = pageIndexes[aIdx];            if ((pageIdx >= 0) && (pageIdx < pageCount) && (!freePages.get(pageIdx))) {                freePages.set(pageIdx);                if (pageIdx < inMemoryMaxPageCount) {                                        inMemoryPages[pageIdx] = null;                                }            }        }    }}
public void pdfbox_f2959_0() throws IOException
{    IOException ioexc = null;    synchronized (ioLock) {        if (isClosed) {            return;        }        isClosed = true;        if (raf != null) {            try {                raf.close();            } catch (IOException ioe) {                ioexc = ioe;            }        }        if (file != null) {            if (!file.delete()) {                if (file.exists() && (ioexc == null)) {                    ioexc = new IOException("Error deleting scratch file: " + file.getAbsolutePath());                }            }        }    }    synchronized (freePages) {        freePages.clear();        pageCount = 0;    }    if (ioexc != null) {        throw ioexc;    }}
private void pdfbox_f2960_0() throws IOException
{    if (pageHandler == null) {        throw new IOException("Buffer already closed");    }    pageHandler.checkClosed();}
private void pdfbox_f2961_0() throws IOException
{    if (pageCount + 1 >= pageIndexes.length) {        int newSize = pageIndexes.length * 2;                if (newSize < pageIndexes.length) {            if (pageIndexes.length == Integer.MAX_VALUE) {                throw new IOException("Maximum buffer size reached.");            }            newSize = Integer.MAX_VALUE;        }        int[] newPageIndexes = new int[newSize];        System.arraycopy(pageIndexes, 0, newPageIndexes, 0, pageCount);        pageIndexes = newPageIndexes;    }    int newPageIdx = pageHandler.getNewPage();    pageIndexes[pageCount] = newPageIdx;    currentPagePositionInPageIndexes = pageCount;    currentPageOffset = ((long) pageCount) * pageSize;    pageCount++;    currentPage = new byte[pageSize];    positionInPage = 0;}
public long pdfbox_f2962_0() throws IOException
{    return size;}
private boolean pdfbox_f2963_0(boolean addNewPageIfNeeded) throws IOException
{    if (positionInPage >= pageSize) {                if (currentPageContentChanged) {                        pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);            currentPageContentChanged = false;        }                if (currentPagePositionInPageIndexes + 1 < pageCount) {                        currentPage = pageHandler.readPage(pageIndexes[++currentPagePositionInPageIndexes]);            currentPageOffset = ((long) currentPagePositionInPageIndexes) * pageSize;            positionInPage = 0;        } else if (addNewPageIfNeeded) {                        addPage();        } else {                        return false;        }    }    return true;}
public void pdfbox_f2964_0(int b) throws IOException
{    checkClosed();    ensureAvailableBytesInPage(true);    currentPage[positionInPage++] = (byte) b;    currentPageContentChanged = true;    if (currentPageOffset + positionInPage > size) {        size = currentPageOffset + positionInPage;    }}
public void pdfbox_f2965_0(byte[] b) throws IOException
{    write(b, 0, b.length);}
public void pdfbox_f2966_0(byte[] b, int off, int len) throws IOException
{    checkClosed();    int remain = len;    int bOff = off;    while (remain > 0) {        ensureAvailableBytesInPage(true);        int bytesToWrite = Math.min(remain, pageSize - positionInPage);        System.arraycopy(b, bOff, currentPage, positionInPage, bytesToWrite);        positionInPage += bytesToWrite;        currentPageContentChanged = true;        bOff += bytesToWrite;        remain -= bytesToWrite;    }    if (currentPageOffset + positionInPage > size) {        size = currentPageOffset + positionInPage;    }}
public final void pdfbox_f2967_0() throws IOException
{    checkClosed();        pageHandler.markPagesAsFree(pageIndexes, 1, pageCount - 1);    pageCount = 1;        if (currentPagePositionInPageIndexes > 0) {        currentPage = pageHandler.readPage(pageIndexes[0]);        currentPagePositionInPageIndexes = 0;        currentPageOffset = 0;    }    positionInPage = 0;    size = 0;    currentPageContentChanged = false;}
public long pdfbox_f2968_0() throws IOException
{    checkClosed();    return currentPageOffset + positionInPage;}
public void pdfbox_f2969_0(long seekToPosition) throws IOException
{    checkClosed();    /*         * for now we won't allow to seek past end of buffer; this can be changed by adding new pages as needed         */    if (seekToPosition > size) {        throw new EOFException();    }    if (seekToPosition < 0) {        throw new IOException("Negative seek offset: " + seekToPosition);    }    if ((seekToPosition >= currentPageOffset) && (seekToPosition <= currentPageOffset + pageSize)) {                positionInPage = (int) (seekToPosition - currentPageOffset);    } else {                if (currentPageContentChanged) {            pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);            currentPageContentChanged = false;        }        int newPagePosition = (int) (seekToPosition / pageSize);        currentPage = pageHandler.readPage(pageIndexes[newPagePosition]);        currentPagePositionInPageIndexes = newPagePosition;        currentPageOffset = ((long) currentPagePositionInPageIndexes) * pageSize;        positionInPage = (int) (seekToPosition - currentPageOffset);    }}
public boolean pdfbox_f2970_0()
{    return pageHandler == null;}
public int pdfbox_f2971_0() throws IOException
{    int result = read();    if (result != -1) {        rewind(1);    }    return result;}
public void pdfbox_f2972_0(int bytes) throws IOException
{    seek(currentPageOffset + positionInPage - bytes);}
public byte[] pdfbox_f2973_0(int len) throws IOException
{    byte[] b = new byte[len];    int n = 0;    do {        int count = read(b, n, len - n);        if (count < 0) {            throw new EOFException();        }        n += count;    } while (n < len);    return b;}
public boolean pdfbox_f2974_0() throws IOException
{    checkClosed();    return currentPageOffset + positionInPage >= size;}
public int pdfbox_f2975_0() throws IOException
{    checkClosed();    return (int) Math.min(size - (currentPageOffset + positionInPage), Integer.MAX_VALUE);}
public int pdfbox_f2976_0() throws IOException
{    checkClosed();    if (currentPageOffset + positionInPage >= size) {        return -1;    }    if (!ensureAvailableBytesInPage(false)) {                throw new IOException("Unexpectedly no bytes available for read in buffer.");    }    return currentPage[positionInPage++] & 0xff;}
public int pdfbox_f2977_0(byte[] b) throws IOException
{    return read(b, 0, b.length);}
public int pdfbox_f2978_0(byte[] b, int off, int len) throws IOException
{    checkClosed();    if (currentPageOffset + positionInPage >= size) {        return -1;    }    int remain = (int) Math.min(len, size - (currentPageOffset + positionInPage));    int totalBytesRead = 0;    int bOff = off;    while (remain > 0) {        if (!ensureAvailableBytesInPage(false)) {                        throw new IOException("Unexpectedly no bytes available for read in buffer.");        }        int readBytes = Math.min(remain, pageSize - positionInPage);        System.arraycopy(currentPage, positionInPage, b, bOff, readBytes);        positionInPage += readBytes;        totalBytesRead += readBytes;        bOff += readBytes;        remain -= readBytes;    }    return totalBytesRead;}
public void pdfbox_f2979_0() throws IOException
{    if (pageHandler != null) {        pageHandler.markPagesAsFree(pageIndexes, 0, pageCount);        pageHandler = null;        pageIndexes = null;        currentPage = null;        currentPageOffset = 0;        currentPagePositionInPageIndexes = -1;        positionInPage = 0;        size = 0;    }}
protected void pdfbox_f2980_1() throws Throwable
{    try {        if ((pageHandler != null) && LOG.isDebugEnabled()) {                    }        close();    } finally {        super.finalize();    }}
public PDDocument pdfbox_f2981_0()
{    return this.targetDoc;}
public void pdfbox_f2982_0(PDPage page) throws IOException
{    COSStream saveGraphicsStateStream = getDocument().getDocument().createCOSStream();    try (OutputStream saveStream = saveGraphicsStateStream.createOutputStream()) {        saveStream.write("q\n".getBytes("ISO-8859-1"));    }    COSStream restoreGraphicsStateStream = getDocument().getDocument().createCOSStream();    try (OutputStream restoreStream = restoreGraphicsStateStream.createOutputStream()) {        restoreStream.write("Q\n".getBytes("ISO-8859-1"));    }            COSDictionary pageDictionary = page.getCOSObject();    COSBase contents = pageDictionary.getDictionaryObject(COSName.CONTENTS);    if (contents instanceof COSStream) {        COSStream contentsStream = (COSStream) contents;        COSArray array = new COSArray();        array.add(saveGraphicsStateStream);        array.add(contentsStream);        array.add(restoreGraphicsStateStream);        pageDictionary.setItem(COSName.CONTENTS, array);    } else if (contents instanceof COSArray) {        COSArray contentsArray = (COSArray) contents;        contentsArray.add(0, saveGraphicsStateStream);        contentsArray.add(restoreGraphicsStateStream);    } else {        throw new IOException("Contents are unknown type: " + contents.getClass().getName());    }}
public PDFormXObject pdfbox_f2983_0(PDDocument sourceDoc, int pageNumber) throws IOException
{    PDPage page = sourceDoc.getPage(pageNumber);    return importPageAsForm(sourceDoc, page);}
public PDFormXObject pdfbox_f2984_0(PDDocument sourceDoc, PDPage page) throws IOException
{    importOcProperties(sourceDoc);    PDStream newStream = new PDStream(targetDoc, page.getContents(), COSName.FLATE_DECODE);    PDFormXObject form = new PDFormXObject(newStream);        PDResources pageRes = page.getResources();    PDResources formRes = new PDResources();    cloner.cloneMerge(pageRes, formRes);    form.setResources(formRes);        transferDict(page.getCOSObject(), form.getCOSObject(), PAGE_TO_FORM_FILTER, true);    Matrix matrix = form.getMatrix();    AffineTransform at = matrix.createAffineTransform();    PDRectangle mediaBox = page.getMediaBox();    PDRectangle cropBox = page.getCropBox();    PDRectangle viewBox = (cropBox != null ? cropBox : mediaBox);        int rotation = page.getRotation();            at.translate(mediaBox.getLowerLeftX() - viewBox.getLowerLeftX(), mediaBox.getLowerLeftY() - viewBox.getLowerLeftY());    switch(rotation) {        case 90:            at.scale(viewBox.getWidth() / viewBox.getHeight(), viewBox.getHeight() / viewBox.getWidth());            at.translate(0, viewBox.getWidth());            at.rotate(-Math.PI / 2.0);            break;        case 180:            at.translate(viewBox.getWidth(), viewBox.getHeight());            at.rotate(-Math.PI);            break;        case 270:            at.scale(viewBox.getWidth() / viewBox.getHeight(), viewBox.getHeight() / viewBox.getWidth());            at.translate(viewBox.getHeight(), 0);            at.rotate(-Math.PI * 1.5);            break;        default:    }        at.translate(-viewBox.getLowerLeftX(), -viewBox.getLowerLeftY());    if (!at.isIdentity()) {        form.setMatrix(at);    }    BoundingBox bbox = new BoundingBox();    bbox.setLowerLeftX(viewBox.getLowerLeftX());    bbox.setLowerLeftY(viewBox.getLowerLeftY());    bbox.setUpperRightX(viewBox.getUpperRightX());    bbox.setUpperRightY(viewBox.getUpperRightY());    form.setBBox(new PDRectangle(bbox));    return form;}
public PDOptionalContentGroup pdfbox_f2985_1(PDPage targetPage, PDFormXObject form, AffineTransform transform, String layerName) throws IOException
{    PDDocumentCatalog catalog = targetDoc.getDocumentCatalog();    PDOptionalContentProperties ocprops = catalog.getOCProperties();    if (ocprops == null) {        ocprops = new PDOptionalContentProperties();        catalog.setOCProperties(ocprops);    }    if (ocprops.hasGroup(layerName)) {        throw new IllegalArgumentException("Optional group (layer) already exists: " + layerName);    }    PDRectangle cropBox = targetPage.getCropBox();    if ((cropBox.getLowerLeftX() < 0 || cropBox.getLowerLeftY() < 0) && transform.isIdentity()) {                    }    PDOptionalContentGroup layer = new PDOptionalContentGroup(layerName);    ocprops.addGroup(layer);    try (PDPageContentStream contentStream = new PDPageContentStream(targetDoc, targetPage, AppendMode.APPEND, !DEBUG)) {        contentStream.beginMarkedContent(COSName.OC, layer);        contentStream.saveGraphicsState();        contentStream.transform(new Matrix(transform));        contentStream.drawForm(form);        contentStream.restoreGraphicsState();        contentStream.endMarkedContent();    }    return layer;}
private void pdfbox_f2986_0(COSDictionary orgDict, COSDictionary targetDict, Set<String> filter, boolean inclusive) throws IOException
{    for (Map.Entry<COSName, COSBase> entry : orgDict.entrySet()) {        COSName key = entry.getKey();        if (inclusive && !filter.contains(key.getName())) {            continue;        } else if (!inclusive && filter.contains(key.getName())) {            continue;        }        targetDict.setItem(key, cloner.cloneForNewDocument(entry.getValue()));    }}
private void pdfbox_f2987_0(PDDocument srcDoc) throws IOException
{    PDDocumentCatalog srcCatalog = srcDoc.getDocumentCatalog();    PDOptionalContentProperties srcOCProperties = srcCatalog.getOCProperties();    if (srcOCProperties == null) {        return;    }    PDDocumentCatalog dstCatalog = targetDoc.getDocumentCatalog();    PDOptionalContentProperties dstOCProperties = dstCatalog.getOCProperties();    if (dstOCProperties == null) {        dstCatalog.setOCProperties(new PDOptionalContentProperties((COSDictionary) cloner.cloneForNewDocument(srcOCProperties)));    } else {        cloner.cloneMerge(srcOCProperties, dstOCProperties);    }}
public PDDocument pdfbox_f2988_0(Map<Integer, String> specificPageOverlayFile) throws IOException
{    Map<String, PDDocument> loadedDocuments = new HashMap<>();    Map<PDDocument, LayoutPage> layouts = new HashMap<>();    loadPDFs();    for (Map.Entry<Integer, String> e : specificPageOverlayFile.entrySet()) {        PDDocument doc = loadedDocuments.get(e.getValue());        if (doc == null) {            doc = loadPDF(e.getValue());            loadedDocuments.put(e.getValue(), doc);            layouts.put(doc, getLayoutPage(doc));        }        openDocuments.add(doc);        specificPageOverlayPage.put(e.getKey(), layouts.get(doc));    }    processPages(inputPDFDocument);    return inputPDFDocument;}
public PDDocument pdfbox_f2989_0(Map<Integer, PDDocument> specificPageOverlayDocuments) throws IOException
{    loadPDFs();    for (Map.Entry<Integer, PDDocument> e : specificPageOverlayDocuments.entrySet()) {        PDDocument doc = e.getValue();        if (doc != null) {            specificPageOverlayPage.put(e.getKey(), getLayoutPage(doc));        }    }    processPages(inputPDFDocument);    return inputPDFDocument;}
public void pdfbox_f2990_0() throws IOException
{    if (defaultOverlay != null) {        defaultOverlay.close();    }    if (firstPageOverlay != null) {        firstPageOverlay.close();    }    if (lastPageOverlay != null) {        lastPageOverlay.close();    }    if (allPagesOverlay != null) {        allPagesOverlay.close();    }    if (oddPageOverlay != null) {        oddPageOverlay.close();    }    if (evenPageOverlay != null) {        evenPageOverlay.close();    }    for (PDDocument doc : openDocuments) {        doc.close();    }    openDocuments.clear();    specificPageOverlayPage.clear();}
private void pdfbox_f2991_0() throws IOException
{        if (inputFileName != null) {        inputPDFDocument = loadPDF(inputFileName);    }        if (defaultOverlayFilename != null) {        defaultOverlay = loadPDF(defaultOverlayFilename);    }    if (defaultOverlay != null) {        defaultOverlayPage = getLayoutPage(defaultOverlay);    }        if (firstPageOverlayFilename != null) {        firstPageOverlay = loadPDF(firstPageOverlayFilename);    }    if (firstPageOverlay != null) {        firstPageOverlayPage = getLayoutPage(firstPageOverlay);    }        if (lastPageOverlayFilename != null) {        lastPageOverlay = loadPDF(lastPageOverlayFilename);    }    if (lastPageOverlay != null) {        lastPageOverlayPage = getLayoutPage(lastPageOverlay);    }        if (oddPageOverlayFilename != null) {        oddPageOverlay = loadPDF(oddPageOverlayFilename);    }    if (oddPageOverlay != null) {        oddPageOverlayPage = getLayoutPage(oddPageOverlay);    }        if (evenPageOverlayFilename != null) {        evenPageOverlay = loadPDF(evenPageOverlayFilename);    }    if (evenPageOverlay != null) {        evenPageOverlayPage = getLayoutPage(evenPageOverlay);    }        if (allPagesOverlayFilename != null) {        allPagesOverlay = loadPDF(allPagesOverlayFilename);    }    if (allPagesOverlay != null) {        specificPageOverlayPage = getLayoutPages(allPagesOverlay);        useAllOverlayPages = true;        numberOfOverlayPages = specificPageOverlayPage.size();    }}
private PDDocument pdfbox_f2992_0(String pdfName) throws IOException
{    return PDDocument.load(new File(pdfName));}
private LayoutPage pdfbox_f2993_0(PDDocument doc) throws IOException
{    PDPage page = doc.getPage(0);    COSBase contents = page.getCOSObject().getDictionaryObject(COSName.CONTENTS);    PDResources resources = page.getResources();    if (resources == null) {        resources = new PDResources();    }    return new LayoutPage(page.getMediaBox(), createCombinedContentStream(contents), resources.getCOSObject(), page.getRotation());}
private Map<Integer, LayoutPage> pdfbox_f2994_0(PDDocument doc) throws IOException
{    int numberOfPages = doc.getNumberOfPages();    Map<Integer, LayoutPage> layoutPages = new HashMap<>(numberOfPages);    for (int i = 0; i < numberOfPages; i++) {        PDPage page = doc.getPage(i);        COSBase contents = page.getCOSObject().getDictionaryObject(COSName.CONTENTS);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();        }        layoutPages.put(i, new LayoutPage(page.getMediaBox(), createCombinedContentStream(contents), resources.getCOSObject(), page.getRotation()));    }    return layoutPages;}
private COSStream pdfbox_f2995_0(COSBase contents) throws IOException
{    List<COSStream> contentStreams = createContentStreamList(contents);        COSStream concatStream = inputPDFDocument.getDocument().createCOSStream();    try (OutputStream out = concatStream.createOutputStream(COSName.FLATE_DECODE)) {        for (COSStream contentStream : contentStreams) {            try (InputStream in = contentStream.createInputStream()) {                IOUtils.copy(in, out);                out.flush();            }        }    }    return concatStream;}
private List<COSStream> pdfbox_f2996_0(COSBase contents) throws IOException
{    List<COSStream> contentStreams = new ArrayList<>();    if (contents == null) {        return contentStreams;    } else if (contents instanceof COSStream) {        contentStreams.add((COSStream) contents);    } else if (contents instanceof COSArray) {        for (COSBase item : (COSArray) contents) {            contentStreams.addAll(createContentStreamList(item));        }    } else if (contents instanceof COSObject) {        contentStreams.addAll(createContentStreamList(((COSObject) contents).getObject()));    } else {        throw new IOException("Unknown content type: " + contents.getClass().getName());    }    return contentStreams;}
private void pdfbox_f2997_0(PDDocument document) throws IOException
{    int pageCounter = 0;    for (PDPage page : document.getPages()) {        pageCounter++;        COSDictionary pageDictionary = page.getCOSObject();        COSBase originalContent = pageDictionary.getDictionaryObject(COSName.CONTENTS);        COSArray newContentArray = new COSArray();        LayoutPage layoutPage = getLayoutPage(pageCounter, document.getNumberOfPages());        if (layoutPage == null) {            continue;        }        switch(position) {            case FOREGROUND:                                newContentArray.add(createStream("q\n"));                addOriginalContent(originalContent, newContentArray);                                newContentArray.add(createStream("Q\n"));                                overlayPage(page, layoutPage, newContentArray);                break;            case BACKGROUND:                                overlayPage(page, layoutPage, newContentArray);                addOriginalContent(originalContent, newContentArray);                break;            default:                throw new IOException("Unknown type of position:" + position);        }        pageDictionary.setItem(COSName.CONTENTS, newContentArray);    }}
private void pdfbox_f2998_0(COSBase contents, COSArray contentArray) throws IOException
{    if (contents == null) {        return;    }    if (contents instanceof COSStream) {        contentArray.add(contents);    } else if (contents instanceof COSArray) {        contentArray.addAll((COSArray) contents);    } else {        throw new IOException("Unknown content type: " + contents.getClass().getName());    }}
private void pdfbox_f2999_0(PDPage page, LayoutPage layoutPage, COSArray array) throws IOException
{    PDResources resources = page.getResources();    if (resources == null) {        resources = new PDResources();        page.setResources(resources);    }    COSName xObjectId = createOverlayXObject(page, layoutPage);    array.add(createOverlayStream(page, layoutPage, xObjectId));}
private LayoutPage pdfbox_f3000_0(int pageNumber, int numberOfPages)
{    LayoutPage layoutPage = null;    if (!useAllOverlayPages && specificPageOverlayPage.containsKey(pageNumber)) {        layoutPage = specificPageOverlayPage.get(pageNumber);    } else if ((pageNumber == 1) && (firstPageOverlayPage != null)) {        layoutPage = firstPageOverlayPage;    } else if ((pageNumber == numberOfPages) && (lastPageOverlayPage != null)) {        layoutPage = lastPageOverlayPage;    } else if ((pageNumber % 2 == 1) && (oddPageOverlayPage != null)) {        layoutPage = oddPageOverlayPage;    } else if ((pageNumber % 2 == 0) && (evenPageOverlayPage != null)) {        layoutPage = evenPageOverlayPage;    } else if (defaultOverlayPage != null) {        layoutPage = defaultOverlayPage;    } else if (useAllOverlayPages) {        int usePageNum = (pageNumber - 1) % numberOfOverlayPages;        layoutPage = specificPageOverlayPage.get(usePageNum);    }    return layoutPage;}
private COSName pdfbox_f3001_0(PDPage page, LayoutPage layoutPage)
{    PDFormXObject xobjForm = new PDFormXObject(layoutPage.overlayContentStream);    xobjForm.setResources(new PDResources(layoutPage.overlayResources));    xobjForm.setFormType(1);    xobjForm.setBBox(layoutPage.overlayMediaBox.createRetranslatedRectangle());    AffineTransform at = new AffineTransform();    switch(layoutPage.overlayRotation) {        case 90:            at.translate(0, layoutPage.overlayMediaBox.getWidth());            at.rotate(Math.toRadians(-90));            break;        case 180:            at.translate(layoutPage.overlayMediaBox.getWidth(), layoutPage.overlayMediaBox.getHeight());            at.rotate(Math.toRadians(-180));            break;        case 270:            at.translate(layoutPage.overlayMediaBox.getHeight(), 0);            at.rotate(Math.toRadians(-270));            break;        default:            break;    }    xobjForm.setMatrix(at);    PDResources resources = page.getResources();    return resources.add(xobjForm, "OL");}
private COSStream pdfbox_f3002_0(PDPage page, LayoutPage layoutPage, COSName xObjectId) throws IOException
{        StringBuilder overlayStream = new StringBuilder();    overlayStream.append("q\nq\n");    PDRectangle overlayMediaBox = new PDRectangle(layoutPage.overlayMediaBox.getCOSArray());    if (layoutPage.overlayRotation == 90 || layoutPage.overlayRotation == 270) {        overlayMediaBox.setLowerLeftX(layoutPage.overlayMediaBox.getLowerLeftY());        overlayMediaBox.setLowerLeftY(layoutPage.overlayMediaBox.getLowerLeftX());        overlayMediaBox.setUpperRightX(layoutPage.overlayMediaBox.getUpperRightY());        overlayMediaBox.setUpperRightY(layoutPage.overlayMediaBox.getUpperRightX());    }    AffineTransform at = calculateAffineTransform(page, overlayMediaBox);    double[] flatmatrix = new double[6];    at.getMatrix(flatmatrix);    for (double v : flatmatrix) {        overlayStream.append(float2String((float) v));        overlayStream.append(" ");    }    overlayStream.append(" cm\n");                overlayStream.append(" /");    overlayStream.append(xObjectId.getName());    overlayStream.append(" Do Q\nQ\n");    return createStream(overlayStream.toString());}
protected AffineTransform pdfbox_f3003_0(PDPage page, PDRectangle overlayMediaBox)
{    AffineTransform at = new AffineTransform();    PDRectangle pageMediaBox = page.getMediaBox();    float hShift = (pageMediaBox.getWidth() - overlayMediaBox.getWidth()) / 2.0f;    float vShift = (pageMediaBox.getHeight() - overlayMediaBox.getHeight()) / 2.0f;    at.translate(hShift, vShift);    return at;}
private String pdfbox_f3004_0(float floatValue)
{            BigDecimal value = new BigDecimal(String.valueOf(floatValue));    String stringValue = value.toPlainString();        if (stringValue.indexOf('.') > -1 && !stringValue.endsWith(".0")) {        while (stringValue.endsWith("0") && !stringValue.endsWith(".0")) {            stringValue = stringValue.substring(0, stringValue.length() - 1);        }    }    return stringValue;}
private COSStream pdfbox_f3005_0(String content) throws IOException
{    COSStream stream = inputPDFDocument.getDocument().createCOSStream();    try (OutputStream out = stream.createOutputStream(content.length() > 20 ? COSName.FLATE_DECODE : null)) {        out.write(content.getBytes("ISO-8859-1"));    }    return stream;}
public void pdfbox_f3006_0(Position overlayPosition)
{    position = overlayPosition;}
public void pdfbox_f3007_0(String inputFile)
{    inputFileName = inputFile;}
public void pdfbox_f3008_0(PDDocument inputPDF)
{    inputPDFDocument = inputPDF;}
public String pdfbox_f3009_0()
{    return inputFileName;}
public void pdfbox_f3010_0(String defaultOverlayFile)
{    defaultOverlayFilename = defaultOverlayFile;}
public void pdfbox_f3011_0(PDDocument defaultOverlayPDF)
{    defaultOverlay = defaultOverlayPDF;}
public String pdfbox_f3012_0()
{    return defaultOverlayFilename;}
public void pdfbox_f3013_0(String firstPageOverlayFile)
{    firstPageOverlayFilename = firstPageOverlayFile;}
public void pdfbox_f3014_0(PDDocument firstPageOverlayPDF)
{    firstPageOverlay = firstPageOverlayPDF;}
public void pdfbox_f3015_0(String lastPageOverlayFile)
{    lastPageOverlayFilename = lastPageOverlayFile;}
public void pdfbox_f3016_0(PDDocument lastPageOverlayPDF)
{    lastPageOverlay = lastPageOverlayPDF;}
public void pdfbox_f3017_0(String allPagesOverlayFile)
{    allPagesOverlayFilename = allPagesOverlayFile;}
public void pdfbox_f3018_0(PDDocument allPagesOverlayPDF)
{    allPagesOverlay = allPagesOverlayPDF;}
public void pdfbox_f3019_0(String oddPageOverlayFile)
{    oddPageOverlayFilename = oddPageOverlayFile;}
public void pdfbox_f3020_0(PDDocument oddPageOverlayPDF)
{    oddPageOverlay = oddPageOverlayPDF;}
public void pdfbox_f3021_0(String evenPageOverlayFile)
{    evenPageOverlayFilename = evenPageOverlayFile;}
public void pdfbox_f3022_0(PDDocument evenPageOverlayPDF)
{    evenPageOverlay = evenPageOverlayPDF;}
public PDDocument pdfbox_f3023_0() throws IOException
{    PDDocument extractedDocument = new PDDocument();    extractedDocument.setDocumentInformation(sourceDocument.getDocumentInformation());    extractedDocument.getDocumentCatalog().setViewerPreferences(sourceDocument.getDocumentCatalog().getViewerPreferences());    for (int i = startPage; i <= endPage; i++) {        PDPage page = sourceDocument.getPage(i - 1);        PDPage imported = extractedDocument.importPage(page);        imported.setCropBox(page.getCropBox());        imported.setMediaBox(page.getMediaBox());        imported.setResources(page.getResources());        imported.setRotation(page.getRotation());    }    return extractedDocument;}
public int pdfbox_f3024_0()
{    return startPage;}
public void pdfbox_f3025_0(int startPage)
{    this.startPage = startPage;}
public int pdfbox_f3026_0()
{    return endPage;}
public void pdfbox_f3027_0(int endPage)
{    this.endPage = endPage;}
 PDDocument pdfbox_f3028_0()
{    return this.destination;}
 COSBase pdfbox_f3029_0(Object base) throws IOException
{    if (base == null) {        return null;    }    COSBase retval = clonedVersion.get(base);    if (retval != null) {                return retval;    }    if (base instanceof COSBase && clonedValues.contains(base)) {                return (COSBase) base;    }    if (base instanceof List) {        COSArray array = new COSArray();        List<?> list = (List<?>) base;        for (Object obj : list) {            array.add(cloneForNewDocument(obj));        }        retval = array;    } else if (base instanceof COSObjectable && !(base instanceof COSBase)) {        retval = cloneForNewDocument(((COSObjectable) base).getCOSObject());    } else if (base instanceof COSObject) {        COSObject object = (COSObject) base;        retval = cloneForNewDocument(object.getObject());    } else if (base instanceof COSArray) {        COSArray newArray = new COSArray();        COSArray array = (COSArray) base;        for (int i = 0; i < array.size(); i++) {            newArray.add(cloneForNewDocument(array.get(i)));        }        retval = newArray;    } else if (base instanceof COSStream) {        COSStream originalStream = (COSStream) base;        COSStream stream = destination.getDocument().createCOSStream();        try (OutputStream output = stream.createRawOutputStream();            InputStream input = originalStream.createRawInputStream()) {            IOUtils.copy(input, output);        }        clonedVersion.put(base, stream);        for (Map.Entry<COSName, COSBase> entry : originalStream.entrySet()) {            stream.setItem(entry.getKey(), cloneForNewDocument(entry.getValue()));        }        retval = stream;    } else if (base instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) base;        retval = new COSDictionary();        clonedVersion.put(base, retval);        for (Map.Entry<COSName, COSBase> entry : dic.entrySet()) {            ((COSDictionary) retval).setItem(entry.getKey(), cloneForNewDocument(entry.getValue()));        }    } else {        retval = (COSBase) base;    }    clonedVersion.put(base, retval);    clonedValues.add(retval);    return retval;}
 void pdfbox_f3030_0(final COSObjectable base, COSObjectable target) throws IOException
{    if (base == null) {        return;    }    COSBase retval = clonedVersion.get(base);    if (retval != null) {        return;        }        if (!(base instanceof COSBase)) {        cloneMerge(base.getCOSObject(), target.getCOSObject());    } else if (base instanceof COSObject) {        if (target instanceof COSObject) {            cloneMerge(((COSObject) base).getObject(), ((COSObject) target).getObject());        } else if (target instanceof COSDictionary || target instanceof COSArray) {            cloneMerge(((COSObject) base).getObject(), target);        }    } else if (base instanceof COSArray) {        COSArray array = (COSArray) base;        for (int i = 0; i < array.size(); i++) {            ((COSArray) target).add(cloneForNewDocument(array.get(i)));        }    } else if (base instanceof COSStream) {                COSStream originalStream = (COSStream) base;        COSStream stream = destination.getDocument().createCOSStream();        try (OutputStream output = stream.createOutputStream(originalStream.getFilters())) {            IOUtils.copy(originalStream.createInputStream(), output);        }        clonedVersion.put(base, stream);        for (Map.Entry<COSName, COSBase> entry : originalStream.entrySet()) {            stream.setItem(entry.getKey(), cloneForNewDocument(entry.getValue()));        }        retval = stream;    } else if (base instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) base;        clonedVersion.put(base, retval);        for (Map.Entry<COSName, COSBase> entry : dic.entrySet()) {            COSName key = entry.getKey();            COSBase value = entry.getValue();            if (((COSDictionary) target).getItem(key) != null) {                cloneMerge(value, ((COSDictionary) target).getItem(key));            } else {                ((COSDictionary) target).setItem(key, cloneForNewDocument(value));            }        }    } else {        retval = (COSBase) base;    }    clonedVersion.put(base, retval);    clonedValues.add(retval);}
public AcroFormMergeMode pdfbox_f3031_0()
{    return acroFormMergeMode;}
public void pdfbox_f3032_0(AcroFormMergeMode theAcroFormMergeMode)
{    this.acroFormMergeMode = theAcroFormMergeMode;}
public DocumentMergeMode pdfbox_f3033_0()
{    return documentMergeMode;}
public void pdfbox_f3034_0(DocumentMergeMode theDocumentMergeMode)
{    this.documentMergeMode = theDocumentMergeMode;}
public void pdfbox_f3035_0(DocumentMergeMode theDocumentMergeMode)
{    this.documentMergeMode = theDocumentMergeMode;}
public String pdfbox_f3036_0()
{    return destinationFileName;}
public void pdfbox_f3037_0(String destination)
{    destinationFileName = destination;}
public OutputStream pdfbox_f3038_0()
{    return destinationStream;}
public void pdfbox_f3039_0(OutputStream destStream)
{    destinationStream = destStream;}
public PDDocumentInformation pdfbox_f3040_0()
{    return destinationDocumentInformation;}
public void pdfbox_f3041_0(PDDocumentInformation info)
{    destinationDocumentInformation = info;}
public PDMetadata pdfbox_f3042_0()
{    return destinationMetadata;}
public void pdfbox_f3043_0(PDMetadata meta)
{    destinationMetadata = meta;}
public void pdfbox_f3044_0(String source) throws FileNotFoundException
{    addSource(new File(source));}
public void pdfbox_f3045_0(File source) throws FileNotFoundException
{    sources.add(source);}
public void pdfbox_f3046_0(InputStream source)
{    sources.add(source);}
public void pdfbox_f3047_0(List<InputStream> sourcesList)
{    sources.addAll(sourcesList);}
public void pdfbox_f3048_0() throws IOException
{    mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());}
public void pdfbox_f3049_0(MemoryUsageSetting memUsageSetting) throws IOException
{    if (documentMergeMode == DocumentMergeMode.PDFBOX_LEGACY_MODE) {        legacyMergeDocuments(memUsageSetting);    } else if (documentMergeMode == DocumentMergeMode.OPTIMIZE_RESOURCES_MODE) {        optimizedMergeDocuments(memUsageSetting);    }}
private void pdfbox_f3050_0(MemoryUsageSetting memUsageSetting) throws IOException
{    try (PDDocument destination = new PDDocument(memUsageSetting)) {        PDFCloneUtility cloner = new PDFCloneUtility(destination);        for (Object sourceObject : sources) {            PDDocument sourceDoc = null;            try {                if (sourceObject instanceof File) {                    sourceDoc = PDDocument.load((File) sourceObject, memUsageSetting);                } else {                    sourceDoc = PDDocument.load((InputStream) sourceObject, memUsageSetting);                }                for (PDPage page : sourceDoc.getPages()) {                    PDPage newPage = new PDPage((COSDictionary) cloner.cloneForNewDocument(page.getCOSObject()));                    newPage.setCropBox(page.getCropBox());                    newPage.setMediaBox(page.getMediaBox());                    newPage.setRotation(page.getRotation());                    PDResources resources = page.getResources();                    if (resources != null) {                                                                        newPage.setResources(new PDResources((COSDictionary) cloner.cloneForNewDocument(resources)));                    } else {                        newPage.setResources(new PDResources());                    }                    destination.addPage(newPage);                }            } finally {                IOUtils.closeQuietly(sourceDoc);            }        }        if (destinationStream == null) {            destination.save(destinationFileName);        } else {            destination.save(destinationStream);        }    }}
private void pdfbox_f3051_0(MemoryUsageSetting memUsageSetting) throws IOException
{    if (sources != null && !sources.isEmpty()) {                                                List<PDDocument> tobeclosed = new ArrayList<>();        MemoryUsageSetting partitionedMemSetting = memUsageSetting != null ? memUsageSetting.getPartitionedCopy(sources.size() + 1) : MemoryUsageSetting.setupMainMemoryOnly();        try (PDDocument destination = new PDDocument(partitionedMemSetting)) {            for (Object sourceObject : sources) {                PDDocument sourceDoc = null;                if (sourceObject instanceof File) {                    sourceDoc = PDDocument.load((File) sourceObject, partitionedMemSetting);                } else {                    sourceDoc = PDDocument.load((InputStream) sourceObject, partitionedMemSetting);                }                tobeclosed.add(sourceDoc);                appendDocument(destination, sourceDoc);            }                        if (destinationDocumentInformation != null) {                destination.setDocumentInformation(destinationDocumentInformation);            }            if (destinationMetadata != null) {                destination.getDocumentCatalog().setMetadata(destinationMetadata);            }            if (destinationStream == null) {                destination.save(destinationFileName);            } else {                destination.save(destinationStream);            }        } finally {            for (PDDocument doc : tobeclosed) {                IOUtils.closeAndLogException(doc, LOG, "PDDocument", null);            }        }    }}
public void pdfbox_f3052_1(PDDocument destination, PDDocument source) throws IOException
{    if (source.getDocument().isClosed()) {        throw new IOException("Error: source PDF is closed.");    }    if (destination.getDocument().isClosed()) {        throw new IOException("Error: destination PDF is closed.");    }    PDDocumentCatalog destCatalog = destination.getDocumentCatalog();    PDDocumentCatalog srcCatalog = source.getDocumentCatalog();    if (isDynamicXfa(srcCatalog.getAcroForm())) {        throw new IOException("Error: can't merge source document containing dynamic XFA form content.");    }    PDDocumentInformation destInfo = destination.getDocumentInformation();    PDDocumentInformation srcInfo = source.getDocumentInformation();    mergeInto(srcInfo.getCOSObject(), destInfo.getCOSObject(), Collections.<COSName>emptySet());        float destVersion = destination.getVersion();    float srcVersion = source.getVersion();    if (destVersion < srcVersion) {        destination.setVersion(srcVersion);    }    int pageIndexOpenActionDest = -1;    if (destCatalog.getOpenAction() == null) {                PDDestinationOrAction openAction = null;        try {            openAction = srcCatalog.getOpenAction();        } catch (IOException ex) {                                }        PDDestination openActionDestination = null;        if (openAction instanceof PDActionGoTo) {            openActionDestination = ((PDActionGoTo) openAction).getDestination();        } else if (openAction instanceof PDDestination) {            openActionDestination = (PDDestination) openAction;        }        if (openActionDestination instanceof PDPageDestination) {            PDPage page = ((PDPageDestination) openActionDestination).getPage();            if (page != null) {                pageIndexOpenActionDest = srcCatalog.getPages().indexOf(page);            }        }        destCatalog.setOpenAction(openAction);    }    PDFCloneUtility cloner = new PDFCloneUtility(destination);    mergeAcroForm(cloner, destCatalog, srcCatalog);    COSArray destThreads = (COSArray) destCatalog.getCOSObject().getDictionaryObject(COSName.THREADS);    COSArray srcThreads = (COSArray) cloner.cloneForNewDocument(destCatalog.getCOSObject().getDictionaryObject(COSName.THREADS));    if (destThreads == null) {        destCatalog.getCOSObject().setItem(COSName.THREADS, srcThreads);    } else {        destThreads.addAll(srcThreads);    }    PDDocumentNameDictionary destNames = destCatalog.getNames();    PDDocumentNameDictionary srcNames = srcCatalog.getNames();    if (srcNames != null) {        if (destNames == null) {            destCatalog.getCOSObject().setItem(COSName.NAMES, cloner.cloneForNewDocument(srcNames));        } else {            cloner.cloneMerge(srcNames, destNames);        }    }    if (destNames != null) {                destNames.getCOSObject().removeItem(COSName.ID_TREE);            }    PDDocumentNameDestinationDictionary destDests = destCatalog.getDests();    PDDocumentNameDestinationDictionary srcDests = srcCatalog.getDests();    if (srcDests != null) {        if (destDests == null) {            destCatalog.getCOSObject().setItem(COSName.DESTS, cloner.cloneForNewDocument(srcDests));        } else {            cloner.cloneMerge(srcDests, destDests);        }    }    PDDocumentOutline destOutline = destCatalog.getDocumentOutline();    PDDocumentOutline srcOutline = srcCatalog.getDocumentOutline();    if (srcOutline != null) {        if (destOutline == null || destOutline.getFirstChild() == null) {            PDDocumentOutline cloned = new PDDocumentOutline((COSDictionary) cloner.cloneForNewDocument(srcOutline));            destCatalog.setDocumentOutline(cloned);        } else {                        PDOutlineItem destLastOutlineItem = destOutline.getFirstChild();            while (destLastOutlineItem.getNextSibling() != null) {                destLastOutlineItem = destLastOutlineItem.getNextSibling();            }            for (PDOutlineItem item : srcOutline.children()) {                                                COSDictionary clonedDict = (COSDictionary) cloner.cloneForNewDocument(item);                clonedDict.removeItem(COSName.PREV);                clonedDict.removeItem(COSName.NEXT);                PDOutlineItem clonedItem = new PDOutlineItem(clonedDict);                destLastOutlineItem.insertSiblingAfter(clonedItem);                destLastOutlineItem = destLastOutlineItem.getNextSibling();            }        }    }    PageMode destPageMode = destCatalog.getPageMode();    PageMode srcPageMode = srcCatalog.getPageMode();    if (destPageMode == null) {        destCatalog.setPageMode(srcPageMode);    }    COSDictionary destLabels = (COSDictionary) destCatalog.getCOSObject().getDictionaryObject(COSName.PAGE_LABELS);    COSDictionary srcLabels = (COSDictionary) srcCatalog.getCOSObject().getDictionaryObject(COSName.PAGE_LABELS);    if (srcLabels != null) {        int destPageCount = destination.getNumberOfPages();        COSArray destNums;        if (destLabels == null) {            destLabels = new COSDictionary();            destNums = new COSArray();            destLabels.setItem(COSName.NUMS, destNums);            destCatalog.getCOSObject().setItem(COSName.PAGE_LABELS, destLabels);        } else {            destNums = (COSArray) destLabels.getDictionaryObject(COSName.NUMS);        }        COSArray srcNums = (COSArray) srcLabels.getDictionaryObject(COSName.NUMS);        if (srcNums != null) {            int startSize = destNums.size();            for (int i = 0; i < srcNums.size(); i += 2) {                COSBase base = srcNums.getObject(i);                if (!(base instanceof COSNumber)) {                                                            while (destNums.size() > startSize) {                        destNums.remove(startSize);                    }                    break;                }                COSNumber labelIndex = (COSNumber) base;                long labelIndexValue = labelIndex.intValue();                destNums.add(COSInteger.get(labelIndexValue + destPageCount));                destNums.add(cloner.cloneForNewDocument(srcNums.getObject(i + 1)));            }        }    }    COSStream destMetadata = (COSStream) destCatalog.getCOSObject().getDictionaryObject(COSName.METADATA);    COSStream srcMetadata = (COSStream) srcCatalog.getCOSObject().getDictionaryObject(COSName.METADATA);    if (destMetadata == null && srcMetadata != null) {        try {            PDStream newStream = new PDStream(destination, srcMetadata.createInputStream(), (COSName) null);            mergeInto(srcMetadata, newStream.getCOSObject(), new HashSet<>(Arrays.asList(COSName.FILTER, COSName.LENGTH)));            destCatalog.getCOSObject().setItem(COSName.METADATA, newStream);        } catch (IOException ex) {                                }    }    COSDictionary destOCP = (COSDictionary) destCatalog.getCOSObject().getDictionaryObject(COSName.OCPROPERTIES);    COSDictionary srcOCP = (COSDictionary) srcCatalog.getCOSObject().getDictionaryObject(COSName.OCPROPERTIES);    if (destOCP == null && srcOCP != null) {        destCatalog.getCOSObject().setItem(COSName.OCPROPERTIES, cloner.cloneForNewDocument(srcOCP));    } else if (destOCP != null && srcOCP != null) {        cloner.cloneMerge(srcOCP, destOCP);    }    mergeOutputIntents(cloner, srcCatalog, destCatalog);        boolean mergeStructTree = false;    int destParentTreeNextKey = -1;    Map<Integer, COSObjectable> srcNumberTreeAsMap = null;    Map<Integer, COSObjectable> destNumberTreeAsMap = null;    PDStructureTreeRoot srcStructTree = srcCatalog.getStructureTreeRoot();    PDStructureTreeRoot destStructTree = destCatalog.getStructureTreeRoot();    if (destStructTree == null && srcStructTree != null) {                        destStructTree = new PDStructureTreeRoot();        destCatalog.setStructureTreeRoot(destStructTree);        destStructTree.setParentTree(new PDNumberTreeNode(PDParentTreeValue.class));                for (PDPage page : destCatalog.getPages()) {            page.getCOSObject().removeItem(COSName.STRUCT_PARENTS);            for (PDAnnotation ann : page.getAnnotations()) {                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);            }        }    }    if (destStructTree != null) {        PDNumberTreeNode destParentTree = destStructTree.getParentTree();        destParentTreeNextKey = destStructTree.getParentTreeNextKey();        if (destParentTree != null) {            destNumberTreeAsMap = getNumberTreeAsMap(destParentTree);            if (destParentTreeNextKey < 0) {                if (destNumberTreeAsMap.isEmpty()) {                    destParentTreeNextKey = 0;                } else {                    destParentTreeNextKey = Collections.max(destNumberTreeAsMap.keySet()) + 1;                }            }            if (destParentTreeNextKey >= 0 && srcStructTree != null) {                PDNumberTreeNode srcParentTree = srcStructTree.getParentTree();                if (srcParentTree != null) {                    srcNumberTreeAsMap = getNumberTreeAsMap(srcParentTree);                    if (!srcNumberTreeAsMap.isEmpty()) {                        mergeStructTree = true;                    }                }            }        }    }    Map<COSDictionary, COSDictionary> objMapping = new HashMap<>();    int pageIndex = 0;    for (PDPage page : srcCatalog.getPages()) {        PDPage newPage = new PDPage((COSDictionary) cloner.cloneForNewDocument(page.getCOSObject()));        if (!mergeStructTree) {                        newPage.getCOSObject().removeItem(COSName.STRUCT_PARENTS);            for (PDAnnotation ann : newPage.getAnnotations()) {                ann.getCOSObject().removeItem(COSName.STRUCT_PARENT);            }        }        newPage.setCropBox(page.getCropBox());        newPage.setMediaBox(page.getMediaBox());        newPage.setRotation(page.getRotation());        PDResources resources = page.getResources();        if (resources != null) {                        newPage.setResources(new PDResources((COSDictionary) cloner.cloneForNewDocument(resources)));        } else {            newPage.setResources(new PDResources());        }        if (mergeStructTree) {                                    updateStructParentEntries(newPage, destParentTreeNextKey);            objMapping.put(page.getCOSObject(), newPage.getCOSObject());            List<PDAnnotation> oldAnnots = page.getAnnotations();            List<PDAnnotation> newAnnots = newPage.getAnnotations();            for (int i = 0; i < oldAnnots.size(); i++) {                objMapping.put(oldAnnots.get(i).getCOSObject(), newAnnots.get(i).getCOSObject());            }                }        destination.addPage(newPage);        if (pageIndex == pageIndexOpenActionDest) {                                    PDDestinationOrAction openAction = destCatalog.getOpenAction();            PDPageDestination pageDestination;            if (openAction instanceof PDActionGoTo) {                pageDestination = (PDPageDestination) ((PDActionGoTo) openAction).getDestination();            } else {                pageDestination = (PDPageDestination) openAction;            }            pageDestination.setPage(newPage);        }        ++pageIndex;    }    if (mergeStructTree) {        updatePageReferences(cloner, srcNumberTreeAsMap, objMapping);        int maxSrcKey = -1;        for (Map.Entry<Integer, COSObjectable> entry : srcNumberTreeAsMap.entrySet()) {            int srcKey = entry.getKey();            maxSrcKey = Math.max(srcKey, maxSrcKey);            destNumberTreeAsMap.put(destParentTreeNextKey + srcKey, cloner.cloneForNewDocument(entry.getValue()));        }        destParentTreeNextKey += maxSrcKey + 1;        PDNumberTreeNode newParentTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);                                        newParentTreeNode.setNumbers(destNumberTreeAsMap);        destStructTree.setParentTree(newParentTreeNode);        destStructTree.setParentTreeNextKey(destParentTreeNextKey);        mergeKEntries(cloner, srcStructTree, destStructTree);        mergeRoleMap(srcStructTree, destStructTree);        mergeIDTree(cloner, srcStructTree, destStructTree);        mergeMarkInfo(destCatalog, srcCatalog);        mergeLanguage(destCatalog, srcCatalog);        mergeViewerPreferences(destCatalog, srcCatalog);    }}
private void pdfbox_f3053_0(PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog)
{    PDViewerPreferences srcViewerPreferences = srcCatalog.getViewerPreferences();    if (srcViewerPreferences == null) {        return;    }    PDViewerPreferences destViewerPreferences = destCatalog.getViewerPreferences();    if (destViewerPreferences == null) {        destViewerPreferences = new PDViewerPreferences(new COSDictionary());        destCatalog.setViewerPreferences(destViewerPreferences);    }    mergeInto(srcViewerPreferences.getCOSObject(), destViewerPreferences.getCOSObject(), Collections.<COSName>emptySet());        if (srcViewerPreferences.hideToolbar() || destViewerPreferences.hideToolbar()) {        destViewerPreferences.setHideToolbar(true);    }    if (srcViewerPreferences.hideMenubar() || destViewerPreferences.hideMenubar()) {        destViewerPreferences.setHideMenubar(true);    }    if (srcViewerPreferences.hideWindowUI() || destViewerPreferences.hideWindowUI()) {        destViewerPreferences.setHideWindowUI(true);    }    if (srcViewerPreferences.fitWindow() || destViewerPreferences.fitWindow()) {        destViewerPreferences.setFitWindow(true);    }    if (srcViewerPreferences.centerWindow() || destViewerPreferences.centerWindow()) {        destViewerPreferences.setCenterWindow(true);    }    if (srcViewerPreferences.displayDocTitle() || destViewerPreferences.displayDocTitle()) {        destViewerPreferences.setDisplayDocTitle(true);    }}
private void pdfbox_f3054_0(PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog)
{    if (destCatalog.getLanguage() == null && srcCatalog.getLanguage() != null) {        destCatalog.setLanguage(srcCatalog.getLanguage());    }}
private void pdfbox_f3055_0(PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog)
{    PDMarkInfo destMark = destCatalog.getMarkInfo();    PDMarkInfo srcMark = srcCatalog.getMarkInfo();    if (destMark == null) {        destMark = new PDMarkInfo();    }    if (srcMark == null) {        srcMark = new PDMarkInfo();    }    destMark.setMarked(true);    destMark.setSuspect(srcMark.isSuspect() || destMark.isSuspect());    destMark.setSuspect(srcMark.usesUserProperties() || destMark.usesUserProperties());    destCatalog.setMarkInfo(destMark);}
private void pdfbox_f3056_0(PDFCloneUtility cloner, PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree) throws IOException
{        COSArray newKArray = new COSArray();    if (destStructTree.getK() != null) {        COSBase base = destStructTree.getK();        if (base instanceof COSArray) {            newKArray.addAll((COSArray) base);        } else {            newKArray.add(base);        }    }    if (srcStructTree.getK() != null) {        COSBase base = cloner.cloneForNewDocument(srcStructTree.getK());        if (base instanceof COSArray) {            newKArray.addAll((COSArray) base);        } else {            newKArray.add(base);        }    }    if (newKArray.size() > 0) {        COSDictionary kDictLevel0 = new COSDictionary();        updateParentEntry(newKArray, kDictLevel0);        kDictLevel0.setItem(COSName.K, newKArray);        kDictLevel0.setItem(COSName.P, destStructTree);        kDictLevel0.setItem(COSName.S, COSName.DOCUMENT);        destStructTree.setK(kDictLevel0);    }}
private void pdfbox_f3057_1(PDFCloneUtility cloner, PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree) throws IOException
{    PDNameTreeNode<PDStructureElement> srcIDTree = srcStructTree.getIDTree();    PDNameTreeNode<PDStructureElement> destIDTree = destStructTree.getIDTree();    if (srcIDTree == null) {        return;    }    if (destIDTree == null) {        destIDTree = new PDStructureElementNameTreeNode();    }    Map<String, PDStructureElement> srcNames = getIDTreeAsMap(srcIDTree);    Map<String, PDStructureElement> destNames = getIDTreeAsMap(destIDTree);    for (Map.Entry<String, PDStructureElement> entry : srcNames.entrySet()) {        if (destNames.containsKey(entry.getKey())) {                    } else {            destNames.put(entry.getKey(), new PDStructureElement((COSDictionary) cloner.cloneForNewDocument(entry.getValue().getCOSObject())));        }    }    destIDTree = new PDStructureElementNameTreeNode();    destIDTree.setNames(destNames);    destStructTree.setIDTree(destIDTree);}
 static Map<String, PDStructureElement> pdfbox_f3058_0(PDNameTreeNode<PDStructureElement> idTree) throws IOException
{    Map<String, PDStructureElement> names = idTree.getNames();    if (names == null) {        names = new LinkedHashMap<>();    } else {                names = new LinkedHashMap<>(names);    }    List<PDNameTreeNode<PDStructureElement>> kids = idTree.getKids();    if (kids != null) {        for (PDNameTreeNode<PDStructureElement> kid : kids) {            names.putAll(getIDTreeAsMap(kid));        }    }    return names;}
 static Map<Integer, COSObjectable> pdfbox_f3059_0(PDNumberTreeNode tree) throws IOException
{    Map<Integer, COSObjectable> numbers = tree.getNumbers();    if (numbers == null) {        numbers = new LinkedHashMap<>();    } else {                numbers = new LinkedHashMap<>(numbers);    }    List<PDNumberTreeNode> kids = tree.getKids();    if (kids != null) {        for (PDNumberTreeNode kid : kids) {            numbers.putAll(getNumberTreeAsMap(kid));        }    }    return numbers;}
private void pdfbox_f3060_1(PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree)
{    COSDictionary srcDict = srcStructTree.getCOSObject().getCOSDictionary(COSName.ROLE_MAP);    COSDictionary destDict = destStructTree.getCOSObject().getCOSDictionary(COSName.ROLE_MAP);    if (srcDict == null) {        return;    }    if (destDict == null) {                destStructTree.getCOSObject().setItem(COSName.ROLE_MAP, srcDict);        return;    }    for (Map.Entry<COSName, COSBase> entry : srcDict.entrySet()) {        COSBase destValue = destDict.getDictionaryObject(entry.getKey());        if (destValue != null && destValue.equals(entry.getValue())) {                        continue;        }        if (destDict.containsKey(entry.getKey())) {                    } else {            destDict.setItem(entry.getKey(), entry.getValue());        }    }}
private void pdfbox_f3061_0(PDFCloneUtility cloner, PDDocumentCatalog destCatalog, PDDocumentCatalog srcCatalog) throws IOException
{    try {        PDAcroForm destAcroForm = destCatalog.getAcroForm();        PDAcroForm srcAcroForm = srcCatalog.getAcroForm();        if (destAcroForm == null && srcAcroForm != null) {            destCatalog.getCOSObject().setItem(COSName.ACRO_FORM, cloner.cloneForNewDocument(srcAcroForm.getCOSObject()));        } else {            if (srcAcroForm != null) {                if (acroFormMergeMode == AcroFormMergeMode.PDFBOX_LEGACY_MODE) {                    acroFormLegacyMode(cloner, destAcroForm, srcAcroForm);                } else if (acroFormMergeMode == AcroFormMergeMode.JOIN_FORM_FIELDS_MODE) {                    acroFormJoinFieldsMode(cloner, destAcroForm, srcAcroForm);                }            }        }    } catch (IOException e) {                if (!ignoreAcroFormErrors) {            throw new IOException(e);        }    }}
private void pdfbox_f3062_0(PDFCloneUtility cloner, PDAcroForm destAcroForm, PDAcroForm srcAcroForm) throws IOException
{    acroFormLegacyMode(cloner, destAcroForm, srcAcroForm);}
private void pdfbox_f3063_0(PDFCloneUtility cloner, PDAcroForm destAcroForm, PDAcroForm srcAcroForm) throws IOException
{    List<PDField> srcFields = srcAcroForm.getFields();    COSArray destFields;    if (srcFields != null && !srcFields.isEmpty()) {                                final String prefix = "dummyFieldName";        final int prefixLength = prefix.length();        for (PDField destField : destAcroForm.getFieldTree()) {            String fieldName = destField.getPartialName();            if (fieldName.startsWith(prefix)) {                nextFieldNum = Math.max(nextFieldNum, Integer.parseInt(fieldName.substring(prefixLength, fieldName.length())) + 1);            }        }                        COSBase base = destAcroForm.getCOSObject().getItem(COSName.FIELDS);        if (base instanceof COSArray) {            destFields = (COSArray) base;        } else {            destFields = new COSArray();        }        for (PDField srcField : srcAcroForm.getFields()) {            COSDictionary dstField = (COSDictionary) cloner.cloneForNewDocument(srcField.getCOSObject());                        if (destAcroForm.getField(srcField.getFullyQualifiedName()) != null) {                dstField.setString(COSName.T, prefix + nextFieldNum++);            }            destFields.add(dstField);        }        destAcroForm.getCOSObject().setItem(COSName.FIELDS, destFields);    }}
private void pdfbox_f3064_0(PDFCloneUtility cloner, PDDocumentCatalog srcCatalog, PDDocumentCatalog destCatalog) throws IOException
{    List<PDOutputIntent> srcOutputIntents = srcCatalog.getOutputIntents();    List<PDOutputIntent> dstOutputIntents = destCatalog.getOutputIntents();    for (PDOutputIntent srcOI : srcOutputIntents) {        String srcOCI = srcOI.getOutputConditionIdentifier();        if (srcOCI != null && !"Custom".equals(srcOCI)) {                        boolean skip = false;            for (PDOutputIntent dstOI : dstOutputIntents) {                if (dstOI.getOutputConditionIdentifier().equals(srcOCI)) {                    skip = true;                    break;                }            }            if (skip) {                continue;            }        }        destCatalog.addOutputIntent(new PDOutputIntent((COSDictionary) cloner.cloneForNewDocument(srcOI)));        dstOutputIntents.add(srcOI);    }}
public boolean pdfbox_f3065_0()
{    return ignoreAcroFormErrors;}
public void pdfbox_f3066_0(boolean ignoreAcroFormErrorsValue)
{    ignoreAcroFormErrors = ignoreAcroFormErrorsValue;}
private void pdfbox_f3067_0(PDFCloneUtility cloner, Map<Integer, COSObjectable> numberTreeAsMap, Map<COSDictionary, COSDictionary> objMapping) throws IOException
{    for (COSObjectable obj : numberTreeAsMap.values()) {        if (obj == null) {            continue;        }        PDParentTreeValue val = (PDParentTreeValue) obj;        COSBase base = val.getCOSObject();        if (base instanceof COSArray) {            updatePageReferences(cloner, (COSArray) base, objMapping);        } else {            updatePageReferences(cloner, (COSDictionary) base, objMapping);        }    }}
private void pdfbox_f3068_1(PDFCloneUtility cloner, COSDictionary parentTreeEntry, Map<COSDictionary, COSDictionary> objMapping) throws IOException
{    COSDictionary pageDict = parentTreeEntry.getCOSDictionary(COSName.PG);    if (objMapping.containsKey(pageDict)) {        parentTreeEntry.setItem(COSName.PG, objMapping.get(pageDict));    }    COSBase obj = parentTreeEntry.getDictionaryObject(COSName.OBJ);    if (obj instanceof COSDictionary) {        COSDictionary objDict = (COSDictionary) obj;        if (objMapping.containsKey(objDict)) {            parentTreeEntry.setItem(COSName.OBJ, objMapping.get(objDict));        } else {                                    COSBase item = parentTreeEntry.getItem(COSName.OBJ);            if (item instanceof COSObject) {                            } else {                                            }            parentTreeEntry.setItem(COSName.OBJ, cloner.cloneForNewDocument(obj));        }    }    COSBase kSubEntry = parentTreeEntry.getDictionaryObject(COSName.K);    if (kSubEntry instanceof COSArray) {        updatePageReferences(cloner, (COSArray) kSubEntry, objMapping);    } else if (kSubEntry instanceof COSDictionary) {        updatePageReferences(cloner, (COSDictionary) kSubEntry, objMapping);    }}
private void pdfbox_f3069_0(PDFCloneUtility cloner, COSArray parentTreeEntry, Map<COSDictionary, COSDictionary> objMapping) throws IOException
{    for (int i = 0; i < parentTreeEntry.size(); i++) {        COSBase subEntry = parentTreeEntry.getObject(i);        if (subEntry instanceof COSArray) {            updatePageReferences(cloner, (COSArray) subEntry, objMapping);        } else if (subEntry instanceof COSDictionary) {            updatePageReferences(cloner, (COSDictionary) subEntry, objMapping);        }    }}
private void pdfbox_f3070_0(COSArray kArray, COSDictionary newParent)
{    for (int i = 0; i < kArray.size(); i++) {        COSBase subEntry = kArray.getObject(i);        if (subEntry instanceof COSDictionary) {            COSDictionary dictEntry = (COSDictionary) subEntry;            if (dictEntry.getDictionaryObject(COSName.P) != null) {                dictEntry.setItem(COSName.P, newParent);            }        }    }}
private void pdfbox_f3071_0(PDPage page, int structParentOffset) throws IOException
{    if (page.getStructParents() >= 0) {        page.setStructParents(page.getStructParents() + structParentOffset);    }    List<PDAnnotation> annots = page.getAnnotations();    List<PDAnnotation> newannots = new ArrayList<>();    for (PDAnnotation annot : annots) {        if (annot.getStructParent() >= 0) {            annot.setStructParent(annot.getStructParent() + structParentOffset);        }        newannots.add(annot);    }    page.setAnnotations(newannots);}
private boolean pdfbox_f3072_0(PDAcroForm acroForm)
{    return acroForm != null && acroForm.xfaIsDynamic();}
private void pdfbox_f3073_0(COSDictionary src, COSDictionary dst, Set<COSName> exclude)
{    for (Map.Entry<COSName, COSBase> entry : src.entrySet()) {        if (!exclude.contains(entry.getKey()) && !dst.containsKey(entry.getKey())) {            dst.setItem(entry.getKey(), entry.getValue());        }    }}
public MemoryUsageSetting pdfbox_f3074_0()
{    return memoryUsageSetting;}
public void pdfbox_f3075_0(MemoryUsageSetting memoryUsageSetting)
{    this.memoryUsageSetting = memoryUsageSetting;}
public List<PDDocument> pdfbox_f3076_0(PDDocument document) throws IOException
{    destinationDocuments = new ArrayList<>();    sourceDocument = document;    processPages();    return destinationDocuments;}
public void pdfbox_f3077_0(int split)
{    if (split <= 0) {        throw new IllegalArgumentException("Number of pages is smaller than one");    }    splitLength = split;}
public void pdfbox_f3078_0(int start)
{    if (start <= 0) {        throw new IllegalArgumentException("Start page is smaller than one");    }    startPage = start;}
public void pdfbox_f3079_0(int end)
{    if (end <= 0) {        throw new IllegalArgumentException("End page is smaller than one");    }    endPage = end;}
private void pdfbox_f3080_0() throws IOException
{    for (PDPage page : sourceDocument.getPages()) {        if (currentPageNumber + 1 >= startPage && currentPageNumber + 1 <= endPage) {            processPage(page);            currentPageNumber++;        } else {            if (currentPageNumber > endPage) {                break;            } else {                currentPageNumber++;            }        }    }}
private void pdfbox_f3081_0() throws IOException
{    if (splitAtPage(currentPageNumber) || currentDestinationDocument == null) {        currentDestinationDocument = createNewDocument();        destinationDocuments.add(currentDestinationDocument);    }}
protected boolean pdfbox_f3082_0(int pageNumber)
{    return (pageNumber + 1 - Math.max(1, startPage)) % splitLength == 0;}
protected PDDocument pdfbox_f3083_0() throws IOException
{    PDDocument document = memoryUsageSetting == null ? new PDDocument() : new PDDocument(memoryUsageSetting);    document.getDocument().setVersion(getSourceDocument().getVersion());    document.setDocumentInformation(getSourceDocument().getDocumentInformation());    document.getDocumentCatalog().setViewerPreferences(getSourceDocument().getDocumentCatalog().getViewerPreferences());    return document;}
protected void pdfbox_f3084_0(PDPage page) throws IOException
{    createNewDocumentIfNecessary();    PDPage imported = getDestinationDocument().importPage(page);    imported.setResources(page.getResources());        processAnnotations(imported);}
private void pdfbox_f3085_0(PDPage imported) throws IOException
{    List<PDAnnotation> annotations = imported.getAnnotations();    for (PDAnnotation annotation : annotations) {        if (annotation instanceof PDAnnotationLink) {            PDAnnotationLink link = (PDAnnotationLink) annotation;            PDDestination destination = link.getDestination();            if (destination == null && link.getAction() != null) {                PDAction action = link.getAction();                if (action instanceof PDActionGoTo) {                    destination = ((PDActionGoTo) action).getDestination();                }            }            if (destination instanceof PDPageDestination) {                                ((PDPageDestination) destination).setPage(null);            }        }                annotation.setPage(null);    }}
protected final PDDocument pdfbox_f3086_0()
{    return sourceDocument;}
protected final PDDocument pdfbox_f3087_0()
{    return currentDestinationDocument;}
private static boolean pdfbox_f3088_0(char ch)
{    return isDigit(ch) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');}
private COSBase pdfbox_f3089_1() throws IOException
{    long numOffset = seqSource.getPosition();    COSBase value = parseDirObject();    skipSpaces();        if (!(value instanceof COSNumber) || !isDigit()) {        return value;    }        long genOffset = seqSource.getPosition();    COSBase generationNumber = parseDirObject();    skipSpaces();    readExpectedChar('R');    if (!(value instanceof COSInteger)) {                return COSNull.NULL;    }    if (!(generationNumber instanceof COSInteger)) {                return COSNull.NULL;    }    COSObjectKey key = new COSObjectKey(((COSInteger) value).longValue(), ((COSInteger) generationNumber).intValue());        return getObjectFromPool(key);}
private COSBase pdfbox_f3090_0(COSObjectKey key) throws IOException
{    if (document == null) {        throw new IOException("object reference " + key + " at offset " + seqSource.getPosition() + " in content stream");    }    return document.getObjectFromPool(key);}
protected COSDictionary pdfbox_f3091_1() throws IOException
{    readExpectedChar('<');    readExpectedChar('<');    skipSpaces();    COSDictionary obj = new COSDictionary();    boolean done = false;    while (!done) {        skipSpaces();        char c = (char) seqSource.peek();        if (c == '>') {            done = true;        } else if (c == '/') {            parseCOSDictionaryNameValuePair(obj);        } else {                                    if (readUntilEndOfCOSDictionary()) {                                return obj;            }        }    }    readExpectedChar('>');    readExpectedChar('>');    return obj;}
private boolean pdfbox_f3092_0() throws IOException
{    int c = seqSource.read();    while (c != -1 && c != '/' && c != '>') {                if (c == E) {            c = seqSource.read();            if (c == N) {                c = seqSource.read();                if (c == D) {                    c = seqSource.read();                    boolean isStream = c == S && seqSource.read() == T && seqSource.read() == R && seqSource.read() == E && seqSource.read() == A && seqSource.read() == M;                    boolean isObj = !isStream && c == O && seqSource.read() == B && seqSource.read() == J;                    if (isStream || isObj) {                                                return true;                    }                }            }        }        c = seqSource.read();    }    if (c == -1) {        return true;    }    seqSource.unread(c);    return false;}
private void pdfbox_f3093_1(COSDictionary obj) throws IOException
{    COSName key = parseCOSName();    COSBase value = parseCOSDictionaryValue();    skipSpaces();    if (((char) seqSource.peek()) == 'd') {                        String potentialDEF = readString();        if (!potentialDEF.equals(DEF)) {            seqSource.unread(potentialDEF.getBytes(ISO_8859_1));        } else {            skipSpaces();        }    }    if (value == null) {            } else {                value.setDirect(true);        obj.setItem(key, value);    }}
protected void pdfbox_f3094_0() throws IOException
{            int whitespace = seqSource.read();        while (ASCII_SPACE == whitespace) {        whitespace = seqSource.read();    }    if (ASCII_CR == whitespace) {        whitespace = seqSource.read();        if (ASCII_LF != whitespace) {            seqSource.unread(whitespace);                        }    } else if (ASCII_LF != whitespace) {                                seqSource.unread(whitespace);    }}
private int pdfbox_f3095_0(final int bracesParameter) throws IOException
{    int braces = bracesParameter;    byte[] nextThreeBytes = new byte[3];    int amountRead = seqSource.read(nextThreeBytes);        if (amountRead == 3 && nextThreeBytes[0] == ASCII_CR) {        if ((nextThreeBytes[1] == ASCII_LF && (nextThreeBytes[2] == '/') || nextThreeBytes[2] == '>') || nextThreeBytes[1] == '/' || nextThreeBytes[1] == '>') {            braces = 0;        }    }    if (amountRead > 0) {        seqSource.unread(nextThreeBytes, 0, amountRead);    }    return braces;}
protected COSString pdfbox_f3096_0() throws IOException
{    char nextChar = (char) seqSource.read();    if (nextChar == '<') {        return parseCOSHexString();    } else if (nextChar != '(') {        throw new IOException("parseCOSString string should start with '(' or '<' and not '" + nextChar + "' at offset " + seqSource.getPosition());    }    ByteArrayOutputStream out = new ByteArrayOutputStream();        int braces = 1;    int c = seqSource.read();    while (braces > 0 && c != -1) {        char ch = (char) c;                int nextc = -2;        if (ch == ')') {            braces--;            braces = checkForEndOfString(braces);            if (braces != 0) {                out.write(ch);            }        } else if (ch == '(') {            braces++;            out.write(ch);        } else if (ch == '\\') {                        char next = (char) seqSource.read();            switch(next) {                case 'n':                    out.write('\n');                    break;                case 'r':                    out.write('\r');                    break;                case 't':                    out.write('\t');                    break;                case 'b':                    out.write('\b');                    break;                case 'f':                    out.write('\f');                    break;                case ')':                                        braces = checkForEndOfString(braces);                    if (braces != 0) {                        out.write(next);                    } else {                        out.write('\\');                    }                    break;                case '(':                case '\\':                    out.write(next);                    break;                case ASCII_LF:                case ASCII_CR:                                        c = seqSource.read();                    while (isEOL(c) && c != -1) {                        c = seqSource.read();                    }                    nextc = c;                    break;                case '0':                case '1':                case '2':                case '3':                case '4':                case '5':                case '6':                case '7':                    {                        StringBuilder octal = new StringBuilder();                        octal.append(next);                        c = seqSource.read();                        char digit = (char) c;                        if (digit >= '0' && digit <= '7') {                            octal.append(digit);                            c = seqSource.read();                            digit = (char) c;                            if (digit >= '0' && digit <= '7') {                                octal.append(digit);                            } else {                                nextc = c;                            }                        } else {                            nextc = c;                        }                        int character = 0;                        try {                            character = Integer.parseInt(octal.toString(), 8);                        } catch (NumberFormatException e) {                            throw new IOException("Error: Expected octal character, actual='" + octal + "'", e);                        }                        out.write(character);                        break;                    }                default:                    {                                                                        out.write(next);                    }            }        } else {            out.write(ch);        }        if (nextc != -2) {            c = nextc;        } else {            c = seqSource.read();        }    }    if (c != -1) {        seqSource.unread(c);    }    return new COSString(out.toByteArray());}
private COSString pdfbox_f3097_0() throws IOException
{    final StringBuilder sBuf = new StringBuilder();    while (true) {        int c = seqSource.read();        if (isHexDigit((char) c)) {            sBuf.append((char) c);        } else if (c == '>') {            break;        } else if (c < 0) {            throw new IOException("Missing closing bracket for hex string. Reached EOS.");        } else if ((c == ' ') || (c == '\n') || (c == '\t') || (c == '\r') || (c == '\b') || (c == '\f')) {            continue;        } else {                        if (sBuf.length() % 2 != 0) {                sBuf.deleteCharAt(sBuf.length() - 1);            }                        do {                c = seqSource.read();            } while (c != '>' && c >= 0);                        if (c < 0) {                throw new IOException("Missing closing bracket for hex string. Reached EOS.");            }                        break;        }    }    return COSString.parseHex(sBuf.toString());}
protected COSArray pdfbox_f3098_1() throws IOException
{    long startPosition = seqSource.getPosition();    readExpectedChar('[');    COSArray po = new COSArray();    COSBase pbo;    skipSpaces();    int i;    while (((i = seqSource.peek()) > 0) && ((char) i != ']')) {        pbo = parseDirObject();        if (pbo instanceof COSObject) {                        if (po.size() > 0 && po.get(po.size() - 1) instanceof COSInteger) {                COSInteger genNumber = (COSInteger) po.remove(po.size() - 1);                if (po.size() > 0 && po.get(po.size() - 1) instanceof COSInteger) {                    COSInteger number = (COSInteger) po.remove(po.size() - 1);                    COSObjectKey key = new COSObjectKey(number.longValue(), genNumber.intValue());                    pbo = getObjectFromPool(key);                } else {                                        pbo = null;                }            } else {                pbo = null;            }        }        if (pbo != null) {            po.add(pbo);        } else {                                                            String isThisTheEnd = readString();            seqSource.unread(isThisTheEnd.getBytes(ISO_8859_1));            if (ENDOBJ_STRING.equals(isThisTheEnd) || ENDSTREAM_STRING.equals(isThisTheEnd)) {                return po;            }        }        skipSpaces();    }        seqSource.read();    skipSpaces();    return po;}
protected boolean pdfbox_f3099_0(int ch)
{    return ch == ASCII_SPACE || ch == ASCII_CR || ch == ASCII_LF || ch == 9 || ch == '>' || ch == '<' || ch == '[' || ch == '/' || ch == ']' || ch == ')' || ch == '(' || ch == 0 || ch == '\f';}
protected COSName pdfbox_f3100_1() throws IOException
{    readExpectedChar('/');    ByteArrayOutputStream buffer = new ByteArrayOutputStream();    int c = seqSource.read();    while (c != -1) {        int ch = c;        if (ch == '#') {            int ch1 = seqSource.read();            int ch2 = seqSource.read();                        if (isHexDigit((char) ch1) && isHexDigit((char) ch2)) {                String hex = Character.toString((char) ch1) + (char) ch2;                try {                    buffer.write(Integer.parseInt(hex, 16));                } catch (NumberFormatException e) {                    throw new IOException("Error: expected hex digit, actual='" + hex + "'", e);                }                c = seqSource.read();            } else {                                if (ch2 == -1 || ch1 == -1) {                                        c = -1;                    break;                }                seqSource.unread(ch2);                c = ch1;                buffer.write(ch);            }        } else if (isEndOfName(ch)) {            break;        } else {            buffer.write(ch);            c = seqSource.read();        }    }    if (c != -1) {        seqSource.unread(c);    }    byte[] bytes = buffer.toByteArray();    String string;    if (isValidUTF8(bytes)) {        string = new String(buffer.toByteArray(), Charsets.UTF_8);    } else {                string = new String(buffer.toByteArray(), Charsets.WINDOWS_1252);    }    return COSName.getPDFName(string);}
private boolean pdfbox_f3101_1(byte[] input)
{    try {        utf8Decoder.decode(ByteBuffer.wrap(input));        return true;    } catch (CharacterCodingException e) {                return false;    }}
protected COSBoolean pdfbox_f3102_0() throws IOException
{    COSBoolean retval;    char c = (char) seqSource.peek();    if (c == 't') {        String trueString = new String(seqSource.readFully(4), ISO_8859_1);        if (!trueString.equals(TRUE)) {            throw new IOException("Error parsing boolean: expected='true' actual='" + trueString + "' at offset " + seqSource.getPosition());        } else {            retval = COSBoolean.TRUE;        }    } else if (c == 'f') {        String falseString = new String(seqSource.readFully(5), ISO_8859_1);        if (!falseString.equals(FALSE)) {            throw new IOException("Error parsing boolean: expected='true' actual='" + falseString + "' at offset " + seqSource.getPosition());        } else {            retval = COSBoolean.FALSE;        }    } else {        throw new IOException("Error parsing boolean expected='t or f' actual='" + c + "' at offset " + seqSource.getPosition());    }    return retval;}
protected COSBase pdfbox_f3103_0() throws IOException
{    COSBase retval = null;    skipSpaces();    int nextByte = seqSource.peek();    char c = (char) nextByte;    switch(c) {        case '<':            {                                int leftBracket = seqSource.read();                                c = (char) seqSource.peek();                seqSource.unread(leftBracket);                if (c == '<') {                    retval = parseCOSDictionary();                    skipSpaces();                } else {                    retval = parseCOSString();                }                break;            }        case '[':            {                                retval = parseCOSArray();                break;            }        case '(':            retval = parseCOSString();            break;        case '/':                        retval = parseCOSName();            break;        case 'n':            {                                readExpectedString(NULL);                retval = COSNull.NULL;                break;            }        case 't':            {                String trueString = new String(seqSource.readFully(4), ISO_8859_1);                if (trueString.equals(TRUE)) {                    retval = COSBoolean.TRUE;                } else {                    throw new IOException("expected true actual='" + trueString + "' " + seqSource + "' at offset " + seqSource.getPosition());                }                break;            }        case 'f':            {                String falseString = new String(seqSource.readFully(5), ISO_8859_1);                if (falseString.equals(FALSE)) {                    retval = COSBoolean.FALSE;                } else {                    throw new IOException("expected false actual='" + falseString + "' " + seqSource + "' at offset " + seqSource.getPosition());                }                break;            }        case 'R':            seqSource.read();            retval = new COSObject(null);            break;        case (char) -1:            return null;        default:            {                if (Character.isDigit(c) || c == '-' || c == '+' || c == '.') {                    StringBuilder buf = new StringBuilder();                    int ic = seqSource.read();                    c = (char) ic;                    while (Character.isDigit(c) || c == '-' || c == '+' || c == '.' || c == 'E' || c == 'e') {                        buf.append(c);                        ic = seqSource.read();                        c = (char) ic;                    }                    if (ic != -1) {                        seqSource.unread(ic);                    }                    retval = COSNumber.get(buf.toString());                } else {                                                                                String badString = readString();                    if (badString.isEmpty()) {                        int peek = seqSource.peek();                                                throw new IOException("Unknown dir object c='" + c + "' cInt=" + (int) c + " peek='" + (char) peek + "' peekInt=" + peek + " at offset " + seqSource.getPosition());                    }                                        if (ENDOBJ_STRING.equals(badString) || ENDSTREAM_STRING.equals(badString)) {                        seqSource.unread(badString.getBytes(ISO_8859_1));                    }                }            }    }    return retval;}
protected String pdfbox_f3104_0() throws IOException
{    skipSpaces();    StringBuilder buffer = new StringBuilder();    int c = seqSource.read();    while (!isEndOfName((char) c) && c != -1) {        buffer.append((char) c);        c = seqSource.read();    }    if (c != -1) {        seqSource.unread(c);    }    return buffer.toString();}
protected void pdfbox_f3105_0(String expectedString) throws IOException
{    readExpectedString(expectedString.toCharArray(), false);}
protected final void pdfbox_f3106_0(final char[] expectedString, boolean skipSpaces) throws IOException
{    skipSpaces();    for (char c : expectedString) {        if (seqSource.read() != c) {            throw new IOException("Expected string '" + new String(expectedString) + "' but missed at character '" + c + "' at offset " + seqSource.getPosition());        }    }    skipSpaces();}
protected void pdfbox_f3107_0(char ec) throws IOException
{    char c = (char) seqSource.read();    if (c != ec) {        throw new IOException("expected='" + ec + "' actual='" + c + "' at offset " + seqSource.getPosition());    }}
protected String pdfbox_f3108_0(int length) throws IOException
{    skipSpaces();    int c = seqSource.read();            StringBuilder buffer = new StringBuilder(length);    while (!isWhitespace(c) && !isClosing(c) && c != -1 && buffer.length() < length && c != '[' && c != '<' && c != '(' && c != '/') {        buffer.append((char) c);        c = seqSource.read();    }    if (c != -1) {        seqSource.unread(c);    }    return buffer.toString();}
protected boolean pdfbox_f3109_0() throws IOException
{    return isClosing(seqSource.peek());}
protected boolean pdfbox_f3110_0(int c)
{    return c == ']';}
protected String pdfbox_f3111_0() throws IOException
{    if (seqSource.isEOF()) {        throw new IOException("Error: End-of-File, expected line");    }    StringBuilder buffer = new StringBuilder(11);    int c;    while ((c = seqSource.read()) != -1) {                if (isEOL(c)) {            break;        }        buffer.append((char) c);    }        if (isCR(c) && isLF(seqSource.peek())) {        seqSource.read();    }    return buffer.toString();}
protected boolean pdfbox_f3112_0() throws IOException
{    return isEOL(seqSource.peek());}
protected boolean pdfbox_f3113_0(int c)
{    return isLF(c) || isCR(c);}
private boolean pdfbox_f3114_0(int c)
{    return ASCII_LF == c;}
private boolean pdfbox_f3115_0(int c)
{    return ASCII_CR == c;}
protected boolean pdfbox_f3116_0() throws IOException
{    return isWhitespace(seqSource.peek());}
protected boolean pdfbox_f3117_0(int c)
{    return c == 0 || c == 9 || c == 12 || c == ASCII_LF || c == ASCII_CR || c == ASCII_SPACE;}
protected boolean pdfbox_f3118_0() throws IOException
{    return isSpace(seqSource.peek());}
protected boolean pdfbox_f3119_0(int c)
{    return ASCII_SPACE == c;}
protected boolean pdfbox_f3120_0() throws IOException
{    return isDigit(seqSource.peek());}
protected static boolean pdfbox_f3121_0(int c)
{    return c >= ASCII_ZERO && c <= ASCII_NINE;}
protected void pdfbox_f3122_0() throws IOException
{    int c = seqSource.read();        while (isWhitespace(c) || c == 37) {        if (c == 37) {                        c = seqSource.read();            while (!isEOL(c) && c != -1) {                c = seqSource.read();            }        } else {            c = seqSource.read();        }    }    if (c != -1) {        seqSource.unread(c);    }}
protected long pdfbox_f3123_0() throws IOException
{    long retval = readLong();    if (retval < 0 || retval >= OBJECT_NUMBER_THRESHOLD) {        throw new IOException("Object Number '" + retval + "' has more than 10 digits or is negative");    }    return retval;}
protected int pdfbox_f3124_0() throws IOException
{    int retval = readInt();    if (retval < 0 || retval > GENERATION_NUMBER_THRESHOLD) {        throw new IOException("Generation Number '" + retval + "' has more than 5 digits");    }    return retval;}
protected int pdfbox_f3125_0() throws IOException
{    skipSpaces();    int retval = 0;    StringBuilder intBuffer = readStringNumber();    try {        retval = Integer.parseInt(intBuffer.toString());    } catch (NumberFormatException e) {        seqSource.unread(intBuffer.toString().getBytes(ISO_8859_1));        throw new IOException("Error: Expected an integer type at offset " + seqSource.getPosition() + ", instead got '" + intBuffer + "'", e);    }    return retval;}
protected long pdfbox_f3126_0() throws IOException
{    skipSpaces();    long retval = 0;    StringBuilder longBuffer = readStringNumber();    try {        retval = Long.parseLong(longBuffer.toString());    } catch (NumberFormatException e) {        seqSource.unread(longBuffer.toString().getBytes(ISO_8859_1));        throw new IOException("Error: Expected a long type at offset " + seqSource.getPosition() + ", instead got '" + longBuffer + "'", e);    }    return retval;}
protected final StringBuilder pdfbox_f3127_0() throws IOException
{    int lastByte;    StringBuilder buffer = new StringBuilder();    while ((lastByte = seqSource.read()) != ASCII_SPACE && lastByte != ASCII_LF && lastByte != ASCII_CR &&     lastByte != 60 &&     lastByte != '[' &&     lastByte != '(' &&     lastByte != 0 && lastByte != -1) {        buffer.append((char) lastByte);        if (buffer.length() > MAX_LENGTH_LONG) {            throw new IOException("Number '" + buffer + "' is getting too long, stop reading at offset " + seqSource.getPosition());        }    }    if (lastByte != -1) {        seqSource.unread(lastByte);    }    return buffer;}
public void pdfbox_f3128_0(int byteCount)
{    if (byteCount > 15) {        readTrailBytes = byteCount;    }}
protected COSDictionary pdfbox_f3129_0() throws IOException
{    COSDictionary trailer = null;    boolean rebuildTrailer = false;    try {                        long startXRefOffset = getStartxrefOffset();        if (startXRefOffset > -1) {            trailer = parseXref(startXRefOffset);        } else {            rebuildTrailer = isLenient();        }    } catch (IOException exception) {        if (isLenient()) {            rebuildTrailer = true;        } else {            throw exception;        }    }        if (trailer != null && trailer.getItem(COSName.ROOT) == null) {        rebuildTrailer = isLenient();    }    if (rebuildTrailer) {        trailer = rebuildTrailer();    } else {                prepareDecryption();        if (bfSearchCOSObjectKeyOffsets != null && !bfSearchCOSObjectKeyOffsets.isEmpty()) {            bfSearchForObjStreams();        }    }    return trailer;}
private COSDictionary pdfbox_f3130_1(long startXRefOffset) throws IOException
{    source.seek(startXRefOffset);    long startXrefOffset = Math.max(0, parseStartXref());        long fixedOffset = checkXRefOffset(startXrefOffset);    if (fixedOffset > -1) {        startXrefOffset = fixedOffset;    }    document.setStartXref(startXrefOffset);    long prev = startXrefOffset;        Set<Long> prevSet = new HashSet<>();    while (prev > 0) {                source.seek(prev);                skipSpaces();                if (source.peek() == X) {                        if (!parseXrefTable(prev) || !parseTrailer()) {                throw new IOException("Expected trailer object at offset " + source.getPosition());            }            COSDictionary trailer = xrefTrailerResolver.getCurrentTrailer();                        if (trailer.containsKey(COSName.XREF_STM)) {                int streamOffset = trailer.getInt(COSName.XREF_STM);                                fixedOffset = checkXRefOffset(streamOffset);                if (fixedOffset > -1 && fixedOffset != streamOffset) {                                        streamOffset = (int) fixedOffset;                    trailer.setInt(COSName.XREF_STM, streamOffset);                }                if (streamOffset > 0) {                    source.seek(streamOffset);                    skipSpaces();                    try {                        parseXrefObjStream(prev, false);                    } catch (IOException ex) {                        if (isLenient) {                                                    } else {                            throw ex;                        }                    }                } else {                    if (isLenient) {                                            } else {                        throw new IOException("Skipped XRef stream due to a corrupt offset:" + streamOffset);                    }                }            }            prev = trailer.getLong(COSName.PREV);            if (prev > 0) {                                fixedOffset = checkXRefOffset(prev);                if (fixedOffset > -1 && fixedOffset != prev) {                    prev = fixedOffset;                    trailer.setLong(COSName.PREV, prev);                }            }        } else {                        prev = parseXrefObjStream(prev, true);            if (prev > 0) {                                fixedOffset = checkXRefOffset(prev);                if (fixedOffset > -1 && fixedOffset != prev) {                    prev = fixedOffset;                    COSDictionary trailer = xrefTrailerResolver.getCurrentTrailer();                    trailer.setLong(COSName.PREV, prev);                }            }        }        if (prevSet.contains(prev)) {            throw new IOException("/Prev loop at offset " + prev);        }        prevSet.add(prev);    }        xrefTrailerResolver.setStartxref(startXrefOffset);    COSDictionary trailer = xrefTrailerResolver.getTrailer();    document.setTrailer(trailer);    document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());        checkXrefOffsets();        document.addXRefTable(xrefTrailerResolver.getXrefTable());    return trailer;}
private long pdfbox_f3131_0(long objByteOffset, boolean isStandalone) throws IOException
{        long objectNumber = readObjectNumber();        long currentHighestXRefObjectNumber = document.getHighestXRefObjectNumber();    document.setHighestXRefObjectNumber(Math.max(currentHighestXRefObjectNumber, objectNumber));    readGenerationNumber();    readExpectedString(OBJ_MARKER, true);    COSDictionary dict = parseCOSDictionary();    try (COSStream xrefStream = parseCOSStream(dict)) {        parseXrefStream(xrefStream, objByteOffset, isStandalone);    }    return dict.getLong(COSName.PREV);}
private long pdfbox_f3132_1() throws IOException
{    byte[] buf;    long skipBytes;        try {        final int trailByteCount = (fileLen < readTrailBytes) ? (int) fileLen : readTrailBytes;        buf = new byte[trailByteCount];        skipBytes = fileLen - trailByteCount;        source.seek(skipBytes);        int off = 0;        int readBytes;        while (off < trailByteCount) {            readBytes = source.read(buf, off, trailByteCount - off);                        if (readBytes < 1) {                throw new IOException("No more bytes to read for trailing buffer, but expected: " + (trailByteCount - off));            }            off += readBytes;        }    } finally {        source.seek(0);    }        int bufOff = lastIndexOf(EOF_MARKER, buf, buf.length);    if (bufOff < 0) {        if (isLenient) {                        bufOff = buf.length;                    } else {            throw new IOException("Missing end of file marker '" + new String(EOF_MARKER) + "'");        }    }        bufOff = lastIndexOf(STARTXREF, buf, bufOff);    if (bufOff < 0) {        throw new IOException("Missing 'startxref' marker.");    } else {        return skipBytes + bufOff;    }}
protected int pdfbox_f3133_0(final char[] pattern, final byte[] buf, final int endOff)
{    final int lastPatternChOff = pattern.length - 1;    int bufOff = endOff;    int patOff = lastPatternChOff;    char lookupCh = pattern[patOff];    while (--bufOff >= 0) {        if (buf[bufOff] == lookupCh) {            if (--patOff < 0) {                                return bufOff;            }                        lookupCh = pattern[patOff];        } else if (patOff < lastPatternChOff) {                        patOff = lastPatternChOff;            lookupCh = pattern[patOff];        }    }    return -1;}
public boolean pdfbox_f3134_0()
{    return isLenient;}
public void pdfbox_f3135_0(boolean lenient)
{    if (initialParseDone) {        throw new IllegalArgumentException("Cannot change leniency after parsing");    }    this.isLenient = lenient;}
private long pdfbox_f3136_0(final COSObject obj)
{    return obj.getObjectNumber() << 32 | obj.getGenerationNumber();}
private void pdfbox_f3137_0(final Queue<COSBase> toBeParsedList, final Collection<COSBase> newObjects, final Set<Long> addedObjects)
{    for (COSBase newObject : newObjects) {        addNewToList(toBeParsedList, newObject, addedObjects);    }}
private void pdfbox_f3138_0(final Queue<COSBase> toBeParsedList, final COSBase newObject, final Set<Long> addedObjects)
{    if (newObject instanceof COSObject) {        final long objId = getObjectId((COSObject) newObject);        if (!addedObjects.add(objId)) {            return;        }        toBeParsedList.add(newObject);    } else if (newObject instanceof COSDictionary || newObject instanceof COSArray) {        toBeParsedList.add(newObject);    }}
protected void pdfbox_f3139_1(COSDictionary dict, COSName... excludeObjects) throws IOException
{        final Queue<COSBase> toBeParsedList = new LinkedList<>();        final TreeMap<Long, List<COSObject>> objToBeParsed = new TreeMap<>();        final Set<Long> parsedObjects = new HashSet<>();    final Set<Long> addedObjects = new HashSet<>();    addExcludedToList(excludeObjects, dict, parsedObjects);    addNewToList(toBeParsedList, dict.getValues(), addedObjects);        while (!(toBeParsedList.isEmpty() && objToBeParsed.isEmpty())) {                        COSBase baseObj;        while ((baseObj = toBeParsedList.poll()) != null) {            if (baseObj instanceof COSDictionary) {                addNewToList(toBeParsedList, ((COSDictionary) baseObj).getValues(), addedObjects);            } else if (baseObj instanceof COSArray) {                for (COSBase cosBase : (COSArray) baseObj) {                    addNewToList(toBeParsedList, cosBase, addedObjects);                }            } else if (baseObj instanceof COSObject) {                COSObject obj = (COSObject) baseObj;                long objId = getObjectId(obj);                COSObjectKey objKey = new COSObjectKey(obj.getObjectNumber(), obj.getGenerationNumber());                if (!parsedObjects.contains(objId)) {                    Long fileOffset = document.getXrefTable().get(objKey);                    if (fileOffset == null && isLenient) {                        Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();                        fileOffset = bfCOSObjectKeyOffsets.get(objKey);                        if (fileOffset != null) {                                                        document.getXrefTable().put(objKey, fileOffset);                        }                    }                                        if (fileOffset != null && fileOffset != 0) {                        if (fileOffset > 0) {                            objToBeParsed.put(fileOffset, Collections.singletonList(obj));                        } else {                                                                                    COSObjectKey key = new COSObjectKey((int) -fileOffset, 0);                            fileOffset = document.getXrefTable().get(key);                            if ((fileOffset == null) || (fileOffset <= 0)) {                                if (isLenient) {                                    Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();                                    fileOffset = bfCOSObjectKeyOffsets.get(key);                                    if (fileOffset != null) {                                                                                document.getXrefTable().put(key, fileOffset);                                    } else {                                                                                continue;                                    }                                } else {                                    throw new IOException("Invalid object stream xref object reference for key '" + objKey + "': " + fileOffset);                                }                            }                            List<COSObject> stmObjects = objToBeParsed.get(fileOffset);                            if (stmObjects == null) {                                stmObjects = new ArrayList<>();                                objToBeParsed.put(fileOffset, stmObjects);                            } else                             if (!(stmObjects instanceof ArrayList)) {                                throw new IOException(obj + " cannot be assigned to offset " + fileOffset + ", this belongs to " + stmObjects.get(0));                            }                            stmObjects.add(obj);                        }                    } else {                                                COSObject pdfObject = document.getObjectFromPool(objKey);                        pdfObject.setObject(COSNull.NULL);                    }                }            }        }                if (objToBeParsed.isEmpty()) {            break;        }        for (COSObject obj : objToBeParsed.remove(objToBeParsed.firstKey())) {            COSBase parsedObj = parseObjectDynamically(obj, false);            if (parsedObj != null) {                obj.setObject(parsedObj);                addNewToList(toBeParsedList, parsedObj, addedObjects);                parsedObjects.add(getObjectId(obj));            }        }    }}
private void pdfbox_f3140_0(COSName[] excludeObjects, COSDictionary dict, final Set<Long> parsedObjects)
{    if (excludeObjects != null) {        for (COSName objName : excludeObjects) {            COSBase baseObj = dict.getItem(objName);            if (baseObj instanceof COSObject) {                parsedObjects.add(getObjectId((COSObject) baseObj));            }        }    }}
protected final COSBase pdfbox_f3141_0(COSObject obj, boolean requireExistingNotCompressedObj) throws IOException
{    return parseObjectDynamically(obj.getObjectNumber(), obj.getGenerationNumber(), requireExistingNotCompressedObj);}
protected COSBase pdfbox_f3142_1(long objNr, int objGenNr, boolean requireExistingNotCompressedObj) throws IOException
{        final COSObjectKey objKey = new COSObjectKey(objNr, objGenNr);    final COSObject pdfObject = document.getObjectFromPool(objKey);    if (pdfObject.getObject() == null) {                        Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);                if (offsetOrObjstmObNr == null && isLenient) {            Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();            offsetOrObjstmObNr = bfCOSObjectKeyOffsets.get(objKey);            if (offsetOrObjstmObNr != null) {                                document.getXrefTable().put(objKey, offsetOrObjstmObNr);            }        }                if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null) || (offsetOrObjstmObNr <= 0))) {            throw new IOException("Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration());        }        if (offsetOrObjstmObNr == null) {                        pdfObject.setObject(COSNull.NULL);        } else if (offsetOrObjstmObNr > 0) {                        parseFileObject(offsetOrObjstmObNr, objKey, pdfObject);        } else {                                    parseObjectStream((int) -offsetOrObjstmObNr);        }    }    return pdfObject.getObject();}
private void pdfbox_f3143_1(Long offsetOrObjstmObNr, final COSObjectKey objKey, final COSObject pdfObject) throws IOException
{        source.seek(offsetOrObjstmObNr);        final long readObjNr = readObjectNumber();    final int readObjGen = readGenerationNumber();    readExpectedString(OBJ_MARKER, true);        if ((readObjNr != objKey.getNumber()) || (readObjGen != objKey.getGeneration())) {        throw new IOException("XREF for " + objKey.getNumber() + ":" + objKey.getGeneration() + " points to wrong object: " + readObjNr + ":" + readObjGen + " at offset " + offsetOrObjstmObNr);    }    skipSpaces();    COSBase pb = parseDirObject();    String endObjectKey = readString();    if (endObjectKey.equals(STREAM_STRING)) {        source.rewind(endObjectKey.getBytes(ISO_8859_1).length);        if (pb instanceof COSDictionary) {            COSStream stream = parseCOSStream((COSDictionary) pb);            if (securityHandler != null) {                securityHandler.decryptStream(stream, objKey.getNumber(), objKey.getGeneration());            }            pb = stream;        } else {                        throw new IOException("Stream not preceded by dictionary (offset: " + offsetOrObjstmObNr + ").");        }        skipSpaces();        endObjectKey = readLine();                if (!endObjectKey.startsWith(ENDOBJ_STRING) && endObjectKey.startsWith(ENDSTREAM_STRING)) {            endObjectKey = endObjectKey.substring(9).trim();            if (endObjectKey.length() == 0) {                                                endObjectKey = readLine();            }        }    } else if (securityHandler != null) {        securityHandler.decrypt(pb, objKey.getNumber(), objKey.getGeneration());    }    pdfObject.setObject(pb);    if (!endObjectKey.startsWith(ENDOBJ_STRING)) {        if (isLenient) {                    } else {            throw new IOException("Object (" + readObjNr + ":" + readObjGen + ") at offset " + offsetOrObjstmObNr + " does not end with 'endobj' but with '" + endObjectKey + "'");        }    }}
private void pdfbox_f3144_1(int objstmObjNr) throws IOException
{    final COSBase objstmBaseObj = parseObjectDynamically(objstmObjNr, 0, true);    if (objstmBaseObj instanceof COSStream) {                PDFObjectStreamParser parser;        try {            parser = new PDFObjectStreamParser((COSStream) objstmBaseObj, document);        } catch (IOException ex) {            if (isLenient) {                                return;            } else {                throw ex;            }        }        try {            parser.parse();        } catch (IOException exception) {            if (isLenient) {                                                return;            } else {                throw exception;            }        }                for (COSObject next : parser.getObjects()) {            COSObjectKey stmObjKey = new COSObjectKey(next);            Long offset = xrefTrailerResolver.getXrefTable().get(stmObjKey);            if (offset != null && offset == -objstmObjNr) {                COSObject stmObj = document.getObjectFromPool(stmObjKey);                stmObj.setObject(next.getObject());            }        }    }}
private COSNumber pdfbox_f3145_1(final COSBase lengthBaseObj, final COSName streamType) throws IOException
{    if (lengthBaseObj == null) {        return null;    }    COSNumber retVal;        if (lengthBaseObj instanceof COSNumber) {        retVal = (COSNumber) lengthBaseObj;    } else     if (lengthBaseObj instanceof COSObject) {        COSObject lengthObj = (COSObject) lengthBaseObj;        COSBase length = lengthObj.getObject();        if (length == null) {                        final long curFileOffset = source.getPosition();            boolean isObjectStream = COSName.OBJ_STM.equals(streamType);            parseObjectDynamically(lengthObj, isObjectStream);                        source.seek(curFileOffset);            length = lengthObj.getObject();        }        if (length == null) {            throw new IOException("Length object content was not read.");        }        if (COSNull.NULL == length) {                        return null;        }        if (!(length instanceof COSNumber)) {            throw new IOException("Wrong type of referenced length object " + lengthObj + ": " + length.getClass().getSimpleName());        }        retVal = (COSNumber) length;    } else {        throw new IOException("Wrong type of length object: " + lengthBaseObj.getClass().getSimpleName());    }    return retVal;}
protected COSStream pdfbox_f3146_1(COSDictionary dic) throws IOException
{    COSStream stream = document.createCOSStream(dic);        readString();    skipWhiteSpaces();    /*         * This needs to be dic.getItem because when we are parsing, the underlying object might still be null.         */    COSNumber streamLengthObj = getLength(dic.getItem(COSName.LENGTH), dic.getCOSName(COSName.TYPE));    if (streamLengthObj == null) {        if (isLenient) {                    } else {            throw new IOException("Missing length for stream.");        }    }        try (OutputStream out = stream.createRawOutputStream()) {        if (streamLengthObj != null && validateStreamLength(streamLengthObj.longValue())) {            readValidStream(out, streamLengthObj);        } else {            readUntilEndStream(new EndstreamOutputStream(out));        }    }    String endStream = readString();    if (endStream.equals("endobj") && isLenient) {                        source.rewind(ENDOBJ.length);    } else if (endStream.length() > 9 && isLenient && endStream.substring(0, 9).equals(ENDSTREAM_STRING)) {                        source.rewind(endStream.substring(9).getBytes(ISO_8859_1).length);    } else if (!endStream.equals(ENDSTREAM_STRING)) {        throw new IOException("Error reading stream, expected='endstream' actual='" + endStream + "' at offset " + source.getPosition());    }    return stream;}
private void pdfbox_f3147_0(final OutputStream out) throws IOException
{    int bufSize;    int charMatchCount = 0;    byte[] keyw = ENDSTREAM;        final int quickTestOffset = 5;        while ((bufSize = source.read(strmBuf, charMatchCount, STRMBUFLEN - charMatchCount)) > 0) {        bufSize += charMatchCount;        int bIdx = charMatchCount;        int quickTestIdx;                for (int maxQuicktestIdx = bufSize - quickTestOffset; bIdx < bufSize; bIdx++) {                                                            quickTestIdx = bIdx + quickTestOffset;            if (charMatchCount == 0 && quickTestIdx < maxQuicktestIdx) {                final byte ch = strmBuf[quickTestIdx];                if ((ch > 't') || (ch < 'a')) {                                                            bIdx = quickTestIdx;                    continue;                }            }                        final byte ch = strmBuf[bIdx];            if (ch == keyw[charMatchCount]) {                if (++charMatchCount == keyw.length) {                                        bIdx++;                    break;                }            } else {                if ((charMatchCount == 3) && (ch == ENDOBJ[charMatchCount])) {                                        keyw = ENDOBJ;                    charMatchCount++;                } else {                                                                                                                        charMatchCount = (ch == E) ? 1 : ((ch == N) && (charMatchCount == 7)) ? 2 : 0;                                        keyw = ENDSTREAM;                }            }        }        int contentBytes = Math.max(0, bIdx - charMatchCount);                if (contentBytes > 0) {            out.write(strmBuf, 0, contentBytes);        }        if (charMatchCount == keyw.length) {                        source.rewind(bufSize - contentBytes);            break;        } else {                        System.arraycopy(keyw, 0, strmBuf, 0, charMatchCount);        }    }        out.flush();}
private void pdfbox_f3148_0(OutputStream out, COSNumber streamLengthObj) throws IOException
{    long remainBytes = streamLengthObj.longValue();    while (remainBytes > 0) {        final int chunk = (remainBytes > STREAMCOPYBUFLEN) ? STREAMCOPYBUFLEN : (int) remainBytes;        final int readBytes = source.read(streamCopyBuf, 0, chunk);        if (readBytes <= 0) {                        throw new IOException("read error at offset " + source.getPosition() + ": expected " + chunk + " bytes, but read() returns " + readBytes);        }        out.write(streamCopyBuf, 0, readBytes);        remainBytes -= readBytes;    }}
private boolean pdfbox_f3149_1(long streamLength) throws IOException
{    boolean streamLengthIsValid = true;    long originOffset = source.getPosition();    long expectedEndOfStream = originOffset + streamLength;    if (expectedEndOfStream > fileLen) {        streamLengthIsValid = false;            } else {        source.seek(expectedEndOfStream);        skipSpaces();        if (!isString(ENDSTREAM)) {            streamLengthIsValid = false;                    }        source.seek(originOffset);    }    return streamLengthIsValid;}
private long pdfbox_f3150_0(long startXRefOffset) throws IOException
{        if (!isLenient) {        return startXRefOffset;    }    source.seek(startXRefOffset);    skipSpaces();    if (source.peek() == X && isString(XREF_TABLE)) {        return startXRefOffset;    }    if (startXRefOffset > 0) {        if (checkXRefStreamOffset(startXRefOffset)) {            return startXRefOffset;        } else {            return calculateXRefFixedOffset(startXRefOffset);        }    }        return -1;}
private boolean pdfbox_f3151_1(long startXRefOffset) throws IOException
{        if (!isLenient || startXRefOffset == 0) {        return true;    }        source.seek(startXRefOffset - 1);    int nextValue = source.read();        if (isWhitespace(nextValue)) {        skipSpaces();        if (isDigit()) {            try {                                readObjectNumber();                readGenerationNumber();                readExpectedString(OBJ_MARKER, true);                                COSDictionary dict = parseCOSDictionary();                source.seek(startXRefOffset);                if ("XRef".equals(dict.getNameAsString(COSName.TYPE))) {                    return true;                }            } catch (IOException exception) {                                                source.seek(startXRefOffset);            }        }    }    return false;}
private long pdfbox_f3152_1(long objectOffset) throws IOException
{    if (objectOffset < 0) {                return 0;    }        long newOffset = bfSearchForXRef(objectOffset);    if (newOffset > -1) {                return newOffset;    }        return 0;}
private boolean pdfbox_f3153_1(Map<COSObjectKey, Long> xrefOffset) throws IOException
{    if (xrefOffset == null) {        return true;    }    for (Entry<COSObjectKey, Long> objectEntry : xrefOffset.entrySet()) {        COSObjectKey objectKey = objectEntry.getKey();        Long objectOffset = objectEntry.getValue();                if (objectOffset != null && objectOffset >= 0 && !checkObjectKey(objectKey, objectOffset)) {                        return false;        }    }    return true;}
private void pdfbox_f3154_1() throws IOException
{        if (!isLenient) {        return;    }    Map<COSObjectKey, Long> xrefOffset = xrefTrailerResolver.getXrefTable();    if (!validateXrefOffsets(xrefOffset)) {        Map<COSObjectKey, Long> bfCOSObjectKeyOffsets = getBFCOSObjectOffsets();        if (!bfCOSObjectKeyOffsets.isEmpty()) {                        xrefOffset.clear();            xrefOffset.putAll(bfCOSObjectKeyOffsets);        }    }}
private boolean pdfbox_f3155_1(COSObjectKey objectKey, long offset) throws IOException
{        if (offset < MINIMUM_SEARCH_OFFSET) {        return false;    }    boolean objectKeyFound = false;    try {        source.seek(offset);                if (objectKey.getNumber() == readObjectNumber()) {            int genNumber = readGenerationNumber();            if (genNumber == objectKey.getGeneration()) {                                readExpectedString(OBJ_MARKER, true);                objectKeyFound = true;            } else if (isLenient && genNumber > objectKey.getGeneration()) {                                readExpectedString(OBJ_MARKER, true);                objectKeyFound = true;                objectKey.fixGeneration(genNumber);            }        }    } catch (IOException exception) {                    }        return objectKeyFound;}
private Map<COSObjectKey, Long> pdfbox_f3156_0() throws IOException
{    if (bfSearchCOSObjectKeyOffsets == null) {        bfSearchForObjects();    }    return bfSearchCOSObjectKeyOffsets;}
private void pdfbox_f3157_0() throws IOException
{    bfSearchForLastEOFMarker();    bfSearchCOSObjectKeyOffsets = new HashMap<>();    long originOffset = source.getPosition();    long currentOffset = MINIMUM_SEARCH_OFFSET;    long lastObjectId = Long.MIN_VALUE;    int lastGenID = Integer.MIN_VALUE;    long lastObjOffset = Long.MIN_VALUE;    char[] endobjString = "ndo".toCharArray();    char[] endobjRemainingString = "bj".toCharArray();    boolean endOfObjFound = false;    do {        source.seek(currentOffset);        int nextChar = source.read();        currentOffset++;        if (isWhitespace(nextChar) && isString(OBJ_MARKER)) {            long tempOffset = currentOffset - 2;            source.seek(tempOffset);            int genID = source.peek();                        if (isDigit(genID)) {                genID -= 48;                tempOffset--;                source.seek(tempOffset);                if (isWhitespace()) {                    while (tempOffset > MINIMUM_SEARCH_OFFSET && isWhitespace()) {                        source.seek(--tempOffset);                    }                    boolean objectIDFound = false;                    while (tempOffset > MINIMUM_SEARCH_OFFSET && isDigit()) {                        source.seek(--tempOffset);                        objectIDFound = true;                    }                    if (objectIDFound) {                        source.read();                        long objectId = readObjectNumber();                        if (lastObjOffset > 0) {                                                        bfSearchCOSObjectKeyOffsets.put(new COSObjectKey(lastObjectId, lastGenID), lastObjOffset);                        }                        lastObjectId = objectId;                        lastGenID = genID;                        lastObjOffset = tempOffset + 1;                        currentOffset += OBJ_MARKER.length - 1;                        endOfObjFound = false;                    }                }            }        } else         if (nextChar == 'e' && isString(endobjString)) {            currentOffset += endobjString.length;            source.seek(currentOffset);            if (source.isEOF()) {                endOfObjFound = true;                continue;            }            if (isString(endobjRemainingString)) {                currentOffset += endobjRemainingString.length;                endOfObjFound = true;                continue;            }        }    } while (currentOffset < lastEOFMarker && !source.isEOF());    if ((lastEOFMarker < Long.MAX_VALUE || endOfObjFound) && lastObjOffset > 0) {                        bfSearchCOSObjectKeyOffsets.put(new COSObjectKey(lastObjectId, lastGenID), lastObjOffset);    }        source.seek(originOffset);}
private long pdfbox_f3158_0(long xrefOffset) throws IOException
{    long newOffset = -1;        bfSearchForXRefTables();        bfSearchForXRefStreams();        long newOffsetTable = searchNearestValue(bfSearchXRefTablesOffsets, xrefOffset);        long newOffsetStream = searchNearestValue(bfSearchXRefStreamsOffsets, xrefOffset);        if (newOffsetTable > -1 && newOffsetStream > -1) {        long differenceTable = xrefOffset - newOffsetTable;        long differenceStream = xrefOffset - newOffsetStream;        if (Math.abs(differenceTable) > Math.abs(differenceStream)) {            newOffset = newOffsetStream;            bfSearchXRefStreamsOffsets.remove(newOffsetStream);        } else {            newOffset = newOffsetTable;            bfSearchXRefTablesOffsets.remove(newOffsetTable);        }    } else if (newOffsetTable > -1) {        newOffset = newOffsetTable;        bfSearchXRefTablesOffsets.remove(newOffsetTable);    } else if (newOffsetStream > -1) {        newOffset = newOffsetStream;        bfSearchXRefStreamsOffsets.remove(newOffsetStream);    }    return newOffset;}
private long pdfbox_f3159_0(List<Long> values, long offset)
{    long newValue = -1;    Long currentDifference = null;    int currentOffsetIndex = -1;    int numberOfOffsets = values.size();        for (int i = 0; i < numberOfOffsets; i++) {        long newDifference = offset - values.get(i);                if (currentDifference == null || (Math.abs(currentDifference) > Math.abs(newDifference))) {            currentDifference = newDifference;            currentOffsetIndex = i;        }    }    if (currentOffsetIndex > -1) {        newValue = values.get(currentOffsetIndex);    }    return newValue;}
private boolean pdfbox_f3160_1(COSDictionary trailer) throws IOException
{    Map<String, COSDictionary> trailerDicts = new HashMap<>();    long originOffset = source.getPosition();    source.seek(MINIMUM_SEARCH_OFFSET);    while (!source.isEOF()) {                if (isString(TRAILER_MARKER)) {            source.seek(source.getPosition() + TRAILER_MARKER.length);            try {                boolean rootFound = false;                boolean infoFound = false;                skipSpaces();                COSDictionary trailerDict = parseCOSDictionary();                StringBuilder trailerKeys = new StringBuilder();                COSObject rootObj = trailerDict.getCOSObject(COSName.ROOT);                if (rootObj != null) {                    long objNumber = rootObj.getObjectNumber();                    int genNumber = rootObj.getGenerationNumber();                    trailerKeys.append(objNumber).append(" ");                    trailerKeys.append(genNumber).append(" ");                    rootFound = true;                }                COSObject infoObj = trailerDict.getCOSObject(COSName.INFO);                if (infoObj != null) {                    long objNumber = infoObj.getObjectNumber();                    int genNumber = infoObj.getGenerationNumber();                    trailerKeys.append(objNumber).append(" ");                    trailerKeys.append(genNumber).append(" ");                    infoFound = true;                }                if (rootFound && infoFound) {                    trailerDicts.put(trailerKeys.toString(), trailerDict);                }            } catch (IOException exception) {                                continue;            }        }        source.read();    }    source.seek(originOffset);        int trailerdictsSize = trailerDicts.size();    String firstEntry = null;    if (trailerdictsSize > 0) {        String[] keys = new String[trailerdictsSize];        trailerDicts.keySet().toArray(keys);        firstEntry = keys[0];        for (int i = 1; i < trailerdictsSize; i++) {            if (firstEntry.equals(keys[i])) {                trailerDicts.remove(keys[i]);            }        }    }        if (trailerDicts.size() == 1) {        boolean rootFound = false;        boolean infoFound = false;        COSDictionary trailerDict = trailerDicts.get(firstEntry);        COSBase rootObj = trailerDict.getItem(COSName.ROOT);        if (rootObj instanceof COSObject) {                        COSDictionary rootDict = retrieveCOSDictionary((COSObject) rootObj);            if (rootDict != null && isCatalog(rootDict)) {                rootFound = true;            }        }        COSBase infoObj = trailerDict.getItem(COSName.INFO);        if (infoObj instanceof COSObject) {                        COSDictionary infoDict = retrieveCOSDictionary((COSObject) infoObj);            if (infoDict != null && isInfo(infoDict)) {                infoFound = true;            }        }        if (rootFound && infoFound) {            trailer.setItem(COSName.ROOT, rootObj);            trailer.setItem(COSName.INFO, infoObj);            if (trailerDict.containsKey(COSName.ENCRYPT)) {                COSBase encObj = trailerDict.getItem(COSName.ENCRYPT);                if (encObj instanceof COSObject) {                                                            COSDictionary encDict = retrieveCOSDictionary((COSObject) encObj);                    if (encDict != null) {                        trailer.setItem(COSName.ENCRYPT, encObj);                    }                }            }            if (trailerDict.containsKey(COSName.ID)) {                COSBase idObj = trailerDict.getItem(COSName.ID);                if (idObj instanceof COSArray) {                    trailer.setItem(COSName.ID, idObj);                }            }            return true;        }    }    return false;}
private void pdfbox_f3161_1() throws IOException
{    if (lastEOFMarker == null) {        long originOffset = source.getPosition();        source.seek(MINIMUM_SEARCH_OFFSET);        while (!source.isEOF()) {                        if (isString(EOF_MARKER)) {                long tempMarker = source.getPosition();                source.seek(tempMarker + 5);                try {                                                                                skipSpaces();                    if (!isString(XREF_TABLE)) {                        readObjectNumber();                        readGenerationNumber();                    }                } catch (IOException exception) {                                                            lastEOFMarker = tempMarker;                }            }            source.read();        }        source.seek(originOffset);                if (lastEOFMarker == null) {            lastEOFMarker = Long.MAX_VALUE;        }    }}
private void pdfbox_f3162_1() throws IOException
{    HashMap<Long, COSObjectKey> bfSearchObjStreamsOffsets = new HashMap<>();    long originOffset = source.getPosition();    source.seek(MINIMUM_SEARCH_OFFSET);    char[] string = " obj".toCharArray();    while (!source.isEOF()) {                if (isString(OBJ_STREAM)) {            long currentPosition = source.getPosition();                        long newOffset = -1;            boolean objFound = false;            for (int i = 1; i < 40 && !objFound; i++) {                long currentOffset = currentPosition - (i * 10);                if (currentOffset > 0) {                    source.seek(currentOffset);                    for (int j = 0; j < 10; j++) {                        if (isString(string)) {                            long tempOffset = currentOffset - 1;                            source.seek(tempOffset);                            int genID = source.peek();                                                        if (isDigit(genID)) {                                tempOffset--;                                source.seek(tempOffset);                                if (isSpace()) {                                    int length = 0;                                    source.seek(--tempOffset);                                    while (tempOffset > MINIMUM_SEARCH_OFFSET && isDigit()) {                                        source.seek(--tempOffset);                                        length++;                                    }                                    if (length > 0) {                                        source.read();                                        newOffset = source.getPosition();                                        long objNumber = readObjectNumber();                                        int genNumber = readGenerationNumber();                                        COSObjectKey streamObjectKey = new COSObjectKey(objNumber, genNumber);                                        bfSearchObjStreamsOffsets.put(newOffset, streamObjectKey);                                    }                                }                            }                                                        objFound = true;                            break;                        } else {                            currentOffset++;                            source.read();                        }                    }                }            }            source.seek(currentPosition + OBJ_STREAM.length);        }        source.read();    }        for (Entry<Long, COSObjectKey> streamOffsetsEntry : bfSearchObjStreamsOffsets.entrySet()) {        Long offset = streamOffsetsEntry.getKey();        Long bfOffset = bfSearchCOSObjectKeyOffsets.get(streamOffsetsEntry.getValue());                if (bfOffset == null) {                        continue;        }                if (offset.equals(bfOffset)) {            source.seek(offset);            long stmObjNumber = readObjectNumber();            int stmGenNumber = readGenerationNumber();            readExpectedString(OBJ_MARKER, true);            int nrOfObjects = 0;            byte[] numbersBytes = null;            COSStream stream = null;            COSInputStream is = null;            try {                COSDictionary dict = parseCOSDictionary();                int offsetFirstStream = dict.getInt(COSName.FIRST);                nrOfObjects = dict.getInt(COSName.N);                                if (offsetFirstStream == -1 || nrOfObjects == -1) {                    continue;                }                stream = parseCOSStream(dict);                if (securityHandler != null) {                    securityHandler.decryptStream(stream, stmObjNumber, stmGenNumber);                }                is = stream.createInputStream();                numbersBytes = new byte[offsetFirstStream];                long isResult = is.read(numbersBytes);                if (Long.compare(isResult, numbersBytes.length) != 0) {                                    }            } catch (IOException exception) {                                continue;            } finally {                if (is != null) {                    is.close();                }                if (stream != null) {                    stream.close();                }            }            int start = 0;                        while (start < numbersBytes.length && numbersBytes[start] == 32) {                start++;            }            String numbersStr = new String(numbersBytes, start, numbersBytes.length - start, "ISO-8859-1");            numbersStr = numbersStr.replaceAll("\n", " ").replaceAll("  ", " ");            String[] numbers = numbersStr.split(" ");            if (numbers.length < nrOfObjects * 2) {                                continue;            }            Map<COSObjectKey, Long> xrefOffset = xrefTrailerResolver.getXrefTable();            for (int i = 0; i < nrOfObjects; i++) {                try {                    long objNumber = Long.parseLong(numbers[i * 2]);                    COSObjectKey objKey = new COSObjectKey(objNumber, 0);                    Long existingOffset = bfSearchCOSObjectKeyOffsets.get(objKey);                    if (existingOffset != null && existingOffset < 0) {                                                COSObjectKey objStmKey = new COSObjectKey(Math.abs(existingOffset), 0);                        existingOffset = bfSearchCOSObjectKeyOffsets.get(objStmKey);                    }                    if (existingOffset == null || offset > existingOffset) {                        bfSearchCOSObjectKeyOffsets.put(objKey, -stmObjNumber);                        xrefOffset.put(objKey, -stmObjNumber);                    }                } catch (NumberFormatException exception) {                                    }            }        }    }    source.seek(originOffset);}
private void pdfbox_f3163_0() throws IOException
{    if (bfSearchXRefTablesOffsets == null) {                bfSearchXRefTablesOffsets = new ArrayList<>();        long originOffset = source.getPosition();        source.seek(MINIMUM_SEARCH_OFFSET);                while (!source.isEOF()) {            if (isString(XREF_TABLE)) {                long newOffset = source.getPosition();                source.seek(newOffset - 1);                                if (isWhitespace()) {                    bfSearchXRefTablesOffsets.add(newOffset);                }                source.seek(newOffset + 4);            }            source.read();        }        source.seek(originOffset);    }}
private void pdfbox_f3164_1() throws IOException
{    if (bfSearchXRefStreamsOffsets == null) {                bfSearchXRefStreamsOffsets = new ArrayList<>();        long originOffset = source.getPosition();        source.seek(MINIMUM_SEARCH_OFFSET);                String objString = " obj";        char[] string = objString.toCharArray();        while (!source.isEOF()) {            if (isString(XREF_STREAM)) {                                long newOffset = -1;                long xrefOffset = source.getPosition();                boolean objFound = false;                for (int i = 1; i < 40 && !objFound; i++) {                    long currentOffset = xrefOffset - (i * 10);                    if (currentOffset > 0) {                        source.seek(currentOffset);                        for (int j = 0; j < 10; j++) {                            if (isString(string)) {                                long tempOffset = currentOffset - 1;                                source.seek(tempOffset);                                int genID = source.peek();                                                                if (isDigit(genID)) {                                    tempOffset--;                                    source.seek(tempOffset);                                    if (isSpace()) {                                        int length = 0;                                        source.seek(--tempOffset);                                        while (tempOffset > MINIMUM_SEARCH_OFFSET && isDigit()) {                                            source.seek(--tempOffset);                                            length++;                                        }                                        if (length > 0) {                                            source.read();                                            newOffset = source.getPosition();                                        }                                    }                                }                                                                objFound = true;                                break;                            } else {                                currentOffset++;                                source.read();                            }                        }                    }                }                if (newOffset > -1) {                    bfSearchXRefStreamsOffsets.add(newOffset);                }                source.seek(xrefOffset + 5);            }            source.read();        }        source.seek(originOffset);    }}
private COSDictionary pdfbox_f3165_0() throws IOException
{    COSDictionary trailer = null;    bfSearchForObjects();    if (bfSearchCOSObjectKeyOffsets != null) {                xrefTrailerResolver.reset();                xrefTrailerResolver.nextXrefObj(0, XRefType.TABLE);        for (Entry<COSObjectKey, Long> entry : bfSearchCOSObjectKeyOffsets.entrySet()) {            xrefTrailerResolver.setXRef(entry.getKey(), entry.getValue());        }        xrefTrailerResolver.setStartxref(0);        trailer = xrefTrailerResolver.getTrailer();        getDocument().setTrailer(trailer);        boolean searchForObjStreamsDone = false;        if (!bfSearchForTrailer(trailer) && !searchForTrailerItems(trailer)) {                        bfSearchForObjStreams();            searchForObjStreamsDone = true;                        searchForTrailerItems(trailer);        }                prepareDecryption();        if (!searchForObjStreamsDone) {            bfSearchForObjStreams();        }    }    trailerWasRebuild = true;    return trailer;}
private boolean pdfbox_f3166_0(COSDictionary trailer) throws IOException
{    boolean rootFound = false;    for (Entry<COSObjectKey, Long> entry : bfSearchCOSObjectKeyOffsets.entrySet()) {        COSDictionary dictionary = retrieveCOSDictionary(entry.getKey(), entry.getValue());        if (dictionary == null) {            continue;        }                if (isCatalog(dictionary)) {            trailer.setItem(COSName.ROOT, document.getObjectFromPool(entry.getKey()));            rootFound = true;        } else         if (isInfo(dictionary)) {            trailer.setItem(COSName.INFO, document.getObjectFromPool(entry.getKey()));        }            }    return rootFound;}
private COSDictionary pdfbox_f3167_0(COSObject object) throws IOException
{    COSObjectKey key = new COSObjectKey(object);    Long offset = bfSearchCOSObjectKeyOffsets.get(key);    if (offset != null) {        return retrieveCOSDictionary(key, offset);    }    return null;}
private COSDictionary pdfbox_f3168_1(COSObjectKey key, long offset) throws IOException
{    COSDictionary dictionary = null;        if (offset < 0) {        COSObject compressedObject = document.getObjectFromPool(key);        if (compressedObject.getObject() == null) {            parseObjectStream((int) -offset);        }        COSBase baseObject = compressedObject.getObject();        if (baseObject instanceof COSDictionary) {            dictionary = (COSDictionary) baseObject;        }    } else {        source.seek(offset);        readObjectNumber();        readGenerationNumber();        readExpectedString(OBJ_MARKER, true);        if (source.peek() != '<') {            return null;        }        try {            dictionary = parseCOSDictionary();        } catch (IOException exception) {                    }    }    return dictionary;}
protected void pdfbox_f3169_0(COSDictionary root) throws IOException
{    if (trailerWasRebuild) {                COSBase pages = root.getDictionaryObject(COSName.PAGES);        if (pages instanceof COSDictionary) {            checkPagesDictionary((COSDictionary) pages, new HashSet<COSObject>());        }    }    if (!(root.getDictionaryObject(COSName.PAGES) instanceof COSDictionary)) {        throw new IOException("Page tree root must be a dictionary");    }}
private int pdfbox_f3170_1(COSDictionary pagesDict, Set<COSObject> set)
{        COSBase kids = pagesDict.getDictionaryObject(COSName.KIDS);    int numberOfPages = 0;    if (kids instanceof COSArray) {        COSArray kidsArray = (COSArray) kids;        List<? extends COSBase> kidsList = kidsArray.toList();        for (COSBase kid : kidsList) {            if (!(kid instanceof COSObject) || set.contains((COSObject) kid)) {                kidsArray.remove(kid);                continue;            }            COSObject kidObject = (COSObject) kid;            COSBase kidBaseobject = kidObject.getObject();                        if (kidBaseobject == null || kidBaseobject.equals(COSNull.NULL)) {                                kidsArray.remove(kid);            } else if (kidBaseobject instanceof COSDictionary) {                COSDictionary kidDictionary = (COSDictionary) kidBaseobject;                COSName type = kidDictionary.getCOSName(COSName.TYPE);                if (COSName.PAGES.equals(type)) {                                        set.add(kidObject);                    numberOfPages += checkPagesDictionary(kidDictionary, set);                } else if (COSName.PAGE.equals(type)) {                                        numberOfPages++;                }            }        }    }        pagesDict.setInt(COSName.COUNT, numberOfPages);    return numberOfPages;}
protected boolean pdfbox_f3171_0(COSDictionary dictionary)
{    return COSName.CATALOG.equals(dictionary.getCOSName(COSName.TYPE));}
private boolean pdfbox_f3172_0(COSDictionary dictionary)
{    if (dictionary.containsKey(COSName.PARENT) || dictionary.containsKey(COSName.A) || dictionary.containsKey(COSName.DEST)) {        return false;    }    if (!dictionary.containsKey(COSName.MOD_DATE) && !dictionary.containsKey(COSName.TITLE) && !dictionary.containsKey(COSName.AUTHOR) && !dictionary.containsKey(COSName.SUBJECT) && !dictionary.containsKey(COSName.KEYWORDS) && !dictionary.containsKey(COSName.CREATOR) && !dictionary.containsKey(COSName.PRODUCER) && !dictionary.containsKey(COSName.CREATION_DATE)) {        return false;    }    return true;}
private long pdfbox_f3173_0() throws IOException
{    long startXref = -1;    if (isString(STARTXREF)) {        readString();        skipSpaces();                startXref = readLong();    }    return startXref;}
private boolean pdfbox_f3174_0(byte[] string) throws IOException
{    boolean bytesMatching = false;    if (source.peek() == string[0]) {        int length = string.length;        byte[] bytesRead = new byte[length];        int numberOfBytes = source.read(bytesRead, 0, length);        while (numberOfBytes < length) {            int readMore = source.read(bytesRead, numberOfBytes, length - numberOfBytes);            if (readMore < 0) {                break;            }            numberOfBytes += readMore;        }        bytesMatching = Arrays.equals(string, bytesRead);        source.rewind(numberOfBytes);    }    return bytesMatching;}
private boolean pdfbox_f3175_0(char[] string) throws IOException
{    boolean bytesMatching = true;    long originOffset = source.getPosition();    for (char c : string) {        if (source.read() != c) {            bytesMatching = false;            break;        }    }    source.seek(originOffset);    return bytesMatching;}
private boolean pdfbox_f3176_1() throws IOException
{        trailerOffset = source.getPosition();        if (isLenient) {        int nextCharacter = source.peek();        while (nextCharacter != 't' && isDigit(nextCharacter)) {            if (source.getPosition() == trailerOffset) {                                            }            readLine();            nextCharacter = source.peek();        }    }    if (source.peek() != 't') {        return false;    }        long currentOffset = source.getPosition();    String nextLine = readLine();    if (!nextLine.trim().equals("trailer")) {                if (nextLine.startsWith("trailer")) {                        int len = "trailer".length();                        source.seek(currentOffset + len);        } else {            return false;        }    }                skipSpaces();    COSDictionary parsedTrailer = parseCOSDictionary();    xrefTrailerResolver.setTrailer(parsedTrailer);    skipSpaces();    return true;}
protected boolean pdfbox_f3177_0() throws IOException
{    return parseHeader(PDF_HEADER, PDF_DEFAULT_VERSION);}
protected boolean pdfbox_f3178_0() throws IOException
{    return parseHeader(FDF_HEADER, FDF_DEFAULT_VERSION);}
private boolean pdfbox_f3179_1(String headerMarker, String defaultVersion) throws IOException
{        String header = readLine();        if (!header.contains(headerMarker)) {        header = readLine();        while (!header.contains(headerMarker)) {                        if ((header.length() > 0) && (Character.isDigit(header.charAt(0)))) {                break;            }            header = readLine();        }    }        if (!header.contains(headerMarker)) {        source.seek(0);        return false;    }            int headerStart = header.indexOf(headerMarker);        if (headerStart > 0) {                header = header.substring(headerStart, header.length());    }        if (header.startsWith(headerMarker) && !header.matches(headerMarker + "\\d.\\d")) {        if (header.length() < headerMarker.length() + 3) {                        header = headerMarker + defaultVersion;                    } else {            String headerGarbage = header.substring(headerMarker.length() + 3, header.length()) + "\n";            header = header.substring(0, headerMarker.length() + 3);            source.rewind(headerGarbage.getBytes(ISO_8859_1).length);        }    }    float headerVersion = -1;    try {        String[] headerParts = header.split("-");        if (headerParts.length == 2) {            headerVersion = Float.parseFloat(headerParts[1]);        }    } catch (NumberFormatException exception) {            }    if (headerVersion < 0) {        if (isLenient) {            headerVersion = 1.7f;        } else {            throw new IOException("Error getting header version: " + header);        }    }    document.setVersion(headerVersion);        source.seek(0);    return true;}
protected boolean pdfbox_f3180_1(long startByteOffset) throws IOException
{    if (source.peek() != 'x') {        return false;    }    String xref = readString();    if (!xref.trim().equals("xref")) {        return false;    }        String str = readString();    byte[] b = str.getBytes(ISO_8859_1);    source.rewind(b.length);        xrefTrailerResolver.nextXrefObj(startByteOffset, XRefType.TABLE);    if (str.startsWith("trailer")) {                return false;    }        while (true) {        String currentLine = readLine();        String[] splitString = currentLine.split("\\s");        if (splitString.length != 2) {                        return false;        }                long currObjID;        try {            currObjID = Long.parseLong(splitString[0]);        } catch (NumberFormatException exception) {                        return false;        }                int count = 0;        try {            count = Integer.parseInt(splitString[1]);        } catch (NumberFormatException exception) {                        return false;        }        skipSpaces();        for (int i = 0; i < count; i++) {            if (source.isEOF() || isEndOfName((char) source.peek())) {                break;            }            if (source.peek() == 't') {                break;            }                        currentLine = readLine();            splitString = currentLine.split("\\s");            if (splitString.length < 3) {                                break;            }            /* This supports the corrupt table as reported in                 * PDFBOX-474 (XXXX XXX XX n) */            if (splitString[splitString.length - 1].equals("n")) {                try {                    long currOffset = Long.parseLong(splitString[0]);                    int currGenID = Integer.parseInt(splitString[1]);                    COSObjectKey objKey = new COSObjectKey(currObjID, currGenID);                    xrefTrailerResolver.setXRef(objKey, currOffset);                } catch (NumberFormatException e) {                    throw new IOException(e);                }            } else if (!splitString[2].equals("f")) {                throw new IOException("Corrupt XRefTable Entry - ObjID:" + currObjID);            }            currObjID++;            skipSpaces();        }        skipSpaces();        if (!isDigit()) {            break;        }    }    return true;}
private void pdfbox_f3181_0(COSStream stream, long objByteOffset, boolean isStandalone) throws IOException
{        if (isStandalone) {        xrefTrailerResolver.nextXrefObj(objByteOffset, XRefType.STREAM);        xrefTrailerResolver.setTrailer(stream);    }    PDFXrefStreamParser parser = new PDFXrefStreamParser(stream, document, xrefTrailerResolver);    parser.parse();}
public COSDocument pdfbox_f3182_0() throws IOException
{    if (document == null) {        throw new IOException("You must parse the document first before calling getDocument()");    }    return document;}
public PDEncryption pdfbox_f3183_0() throws IOException
{    if (document == null) {        throw new IOException("You must parse the document first before calling getEncryption()");    }    return encryption;}
public AccessPermission pdfbox_f3184_0() throws IOException
{    if (document == null) {        throw new IOException("You must parse the document first before calling getAccessPermission()");    }    return accessPermission;}
protected COSBase pdfbox_f3185_0(COSDictionary trailer) throws IOException
{        for (COSBase trailerEntry : trailer.getValues()) {        if (trailerEntry instanceof COSObject) {            COSObject tmpObj = (COSObject) trailerEntry;            parseObjectDynamically(tmpObj, false);        }    }        COSObject root = trailer.getCOSObject(COSName.ROOT);    if (root == null) {        throw new IOException("Missing root object specification in trailer.");    }    return root.getObject();}
private void pdfbox_f3186_0() throws IOException
{    if (encryption != null) {        return;    }    COSBase trailerEncryptItem = document.getTrailer().getItem(COSName.ENCRYPT);    if (trailerEncryptItem == null || trailerEncryptItem instanceof COSNull) {        return;    }    if (trailerEncryptItem instanceof COSObject) {        COSObject trailerEncryptObj = (COSObject) trailerEncryptItem;        parseDictionaryRecursive(trailerEncryptObj);    }    try {        encryption = new PDEncryption(document.getEncryptionDictionary());        DecryptionMaterial decryptionMaterial;        if (keyStoreInputStream != null) {            KeyStore ks = KeyStore.getInstance("PKCS12");            ks.load(keyStoreInputStream, password.toCharArray());            decryptionMaterial = new PublicKeyDecryptionMaterial(ks, keyAlias, password);        } else {            decryptionMaterial = new StandardDecryptionMaterial(password);        }        securityHandler = encryption.getSecurityHandler();        securityHandler.prepareForDecryption(encryption, document.getDocumentID(), decryptionMaterial);        accessPermission = securityHandler.getCurrentAccessPermission();    } catch (IOException e) {        throw e;    } catch (GeneralSecurityException e) {        throw new IOException("Error (" + e.getClass().getSimpleName() + ") while creating security handler for decryption", e);    } finally {        if (keyStoreInputStream != null) {            IOUtils.closeQuietly(keyStoreInputStream);        }    }}
private void pdfbox_f3187_0(COSObject dictionaryObject) throws IOException
{    parseObjectDynamically(dictionaryObject, true);    if (!(dictionaryObject.getObject() instanceof COSDictionary)) {                throw new IOException("Dictionary object expected at offset " + source.getPosition());    }    COSDictionary dictionary = (COSDictionary) dictionaryObject.getObject();    for (COSBase value : dictionary.getValues()) {        if (value instanceof COSObject) {            COSObject object = (COSObject) value;            if (object.getObject() == null) {                parseDictionaryRecursive(object);            }        }    }}
public void pdfbox_f3188_0(byte[] b, int off, int len) throws IOException
{    if (pos == 0 && len > 10) {                mustFilter = false;        for (int i = 0; i < 10; ++i) {                        if ((b[i] < 0x09) || ((b[i] > 0x0a) && (b[i] < 0x20) && (b[i] != 0x0d))) {                                mustFilter = true;                break;            }        }    }    if (mustFilter) {                if (hasCR) {                        hasCR = false;            if (!hasLF && len == 1 && b[off] == '\n') {                                return;            }            super.write('\r');        }        if (hasLF) {            super.write('\n');            hasLF = false;        }                if (len > 0) {            if (b[off + len - 1] == '\r') {                hasCR = true;                --len;            } else if (b[off + len - 1] == '\n') {                hasLF = true;                --len;                if (len > 0 && b[off + len - 1] == '\r') {                    hasCR = true;                    --len;                }            }        }    }    super.write(b, off, len);    pos += len;}
public void pdfbox_f3189_0() throws IOException
{        if (hasCR && !hasLF) {        super.write('\r');        ++pos;    }    hasCR = false;    hasLF = false;    super.flush();}
protected final boolean pdfbox_f3190_0(COSDictionary dictionary)
{    return dictionary.containsKey(COSName.FDF);}
private void pdfbox_f3191_1() throws IOException
{    String eofLookupRangeStr = System.getProperty(SYSPROP_EOFLOOKUPRANGE);    if (eofLookupRangeStr != null) {        try {            setEOFLookupRange(Integer.parseInt(eofLookupRangeStr));        } catch (NumberFormatException nfe) {                    }    }    document = new COSDocument();}
private void pdfbox_f3192_0() throws IOException
{    COSDictionary trailer = retrieveTrailer();    COSBase rootObject = parseTrailerValuesDynamically(trailer);        if (rootObject instanceof COSDictionary) {        parseDictObjects((COSDictionary) rootObject, (COSName[]) null);    }    initialParseDone = true;}
public void pdfbox_f3193_0() throws IOException
{        boolean exceptionOccurred = true;    try {        if (!parseFDFHeader()) {            throw new IOException("Error: Header doesn't contain versioninfo");        }        initialParse();        exceptionOccurred = false;    } finally {        if (exceptionOccurred && document != null) {            IOUtils.closeQuietly(document);            document = null;        }    }}
public int pdfbox_f3194_0() throws IOException
{    int b = input.read();    position++;    return b;}
public int pdfbox_f3195_0(byte[] b) throws IOException
{    int n = input.read(b);    if (n > 0) {        position += n;        return n;    } else {        return -1;    }}
public int pdfbox_f3196_0(byte[] b, int offset, int length) throws IOException
{    int n = input.read(b, offset, length);    if (n > 0) {        position += n;        return n;    } else {        return -1;    }}
public long pdfbox_f3197_0() throws IOException
{    return position;}
public int pdfbox_f3198_0() throws IOException
{    int b = input.read();    if (b != -1) {        input.unread(b);    }    return b;}
public void pdfbox_f3199_0(int b) throws IOException
{    input.unread(b);    position--;}
public void pdfbox_f3200_0(byte[] bytes) throws IOException
{    input.unread(bytes);    position -= bytes.length;}
public void pdfbox_f3201_0(byte[] bytes, int start, int len) throws IOException
{    input.unread(bytes, start, len);    position -= len - start;}
public byte[] pdfbox_f3202_0(int length) throws IOException
{    byte[] bytes = new byte[length];    int off = 0;    int len = length;    while (len > 0) {        int n = this.read(bytes, off, len);        if (n > 0) {            off += n;            len -= n;            position += n;        } else {            break;        }    }    return bytes;}
public boolean pdfbox_f3203_0() throws IOException
{    return peek() == -1;}
public void pdfbox_f3204_0() throws IOException
{    input.close();}
public void pdfbox_f3205_1() throws IOException
{    try {                int numberOfObjects = stream.getInt("N");        if (numberOfObjects == -1) {            throw new IOException("/N entry missing in object stream");        }        List<Long> objectNumbers = new ArrayList<>(numberOfObjects);        streamObjects = new ArrayList<>(numberOfObjects);        for (int i = 0; i < numberOfObjects; i++) {            long objectNumber = readObjectNumber();                        readLong();            objectNumbers.add(objectNumber);        }        COSObject object;        COSBase cosObject;        int objectCounter = 0;        while ((cosObject = parseDirObject()) != null) {            object = new COSObject(cosObject);            object.setGenerationNumber(0);            if (objectCounter >= objectNumbers.size()) {                                break;            }            object.setObjectNumber(objectNumbers.get(objectCounter));            streamObjects.add(object);            if (LOG.isDebugEnabled()) {                            }                        if (!seqSource.isEOF() && seqSource.peek() == 'e') {                readLine();            }            objectCounter++;        }    } finally {        seqSource.close();    }}
public List<COSObject> pdfbox_f3206_0()
{    return streamObjects;}
private void pdfbox_f3207_1(ScratchFile scratchFile) throws IOException
{    String eofLookupRangeStr = System.getProperty(SYSPROP_EOFLOOKUPRANGE);    if (eofLookupRangeStr != null) {        try {            setEOFLookupRange(Integer.parseInt(eofLookupRangeStr));        } catch (NumberFormatException nfe) {                    }    }    document = new COSDocument(scratchFile);}
public PDDocument pdfbox_f3208_0() throws IOException
{    PDDocument doc = new PDDocument(getDocument(), source, getAccessPermission());    doc.setEncryptionDictionary(getEncryption());    return doc;}
protected void pdfbox_f3209_0() throws IOException
{    COSDictionary trailer = retrieveTrailer();    COSBase base = parseTrailerValuesDynamically(trailer);    if (!(base instanceof COSDictionary)) {        throw new IOException("Expected root dictionary, but got this: " + base);    }    COSDictionary root = (COSDictionary) base;        if (isLenient() && !root.containsKey(COSName.TYPE)) {        root.setItem(COSName.TYPE, COSName.CATALOG);    }        parseDictObjects(root, (COSName[]) null);        COSBase infoBase = trailer.getDictionaryObject(COSName.INFO);    if (infoBase instanceof COSDictionary) {        parseDictObjects((COSDictionary) infoBase, (COSName[]) null);    }        checkPages(root);    document.setDecrypted();    initialParseDone = true;}
public void pdfbox_f3210_0() throws IOException
{        boolean exceptionOccurred = true;    try {                if (!parsePDFHeader() && !parseFDFHeader()) {            throw new IOException("Error: Header doesn't contain versioninfo");        }        if (!initialParseDone) {            initialParse();        }        exceptionOccurred = false;    } finally {        if (exceptionOccurred && document != null) {            IOUtils.closeQuietly(document);            document = null;        }    }}
public void pdfbox_f3211_0() throws IOException
{    Object token;    while ((token = parseNextToken()) != null) {        streamObjects.add(token);    }}
public List<Object> pdfbox_f3212_0()
{    return streamObjects;}
public Object pdfbox_f3213_1() throws IOException
{    Object retval;    skipSpaces();    int nextByte = seqSource.peek();    if (((byte) nextByte) == -1) {        return null;    }    char c = (char) nextByte;    switch(c) {        case '<':            {                                int leftBracket = seqSource.read();                                c = (char) seqSource.peek();                                seqSource.unread(leftBracket);                if (c == '<') {                    retval = parseCOSDictionary();                } else {                    retval = parseCOSString();                }                break;            }        case '[':            {                                retval = parseCOSArray();                break;            }        case '(':                        retval = parseCOSString();            break;        case '/':                        retval = parseCOSName();            break;        case 'n':            {                                String nullString = readString();                if (nullString.equals("null")) {                    retval = COSNull.NULL;                } else {                    retval = Operator.getOperator(nullString);                }                break;            }        case 't':        case 'f':            {                String next = readString();                if (next.equals("true")) {                    retval = COSBoolean.TRUE;                    break;                } else if (next.equals("false")) {                    retval = COSBoolean.FALSE;                } else {                    retval = Operator.getOperator(next);                }                break;            }        case 'R':            {                String line = readString();                if (line.equals("R")) {                    retval = new COSObject(null);                } else {                    retval = Operator.getOperator(line);                }                break;            }        case '0':        case '1':        case '2':        case '3':        case '4':        case '5':        case '6':        case '7':        case '8':        case '9':        case '-':        case '+':        case '.':            {                /* We will be filling buf with the rest of the number.  Only                 * allow 1 "." and "-" and "+" at start of number. */                StringBuilder buf = new StringBuilder();                buf.append(c);                seqSource.read();                                if (c == '-' && seqSource.peek() == c) {                    seqSource.read();                }                boolean dotNotRead = c != '.';                while (Character.isDigit(c = (char) seqSource.peek()) || dotNotRead && c == '.' || c == '-') {                    if (c != '-') {                                                buf.append(c);                    }                    seqSource.read();                    if (dotNotRead && c == '.') {                        dotNotRead = false;                    }                }                retval = COSNumber.get(buf.toString());                break;            }        case 'B':            {                String next = readString();                retval = Operator.getOperator(next);                if (next.equals(OperatorName.BEGIN_INLINE_IMAGE)) {                    Operator beginImageOP = (Operator) retval;                    COSDictionary imageParams = new COSDictionary();                    beginImageOP.setImageParameters(imageParams);                    Object nextToken = null;                    while ((nextToken = parseNextToken()) instanceof COSName) {                        Object value = parseNextToken();                        imageParams.setItem((COSName) nextToken, (COSBase) value);                    }                                        if (nextToken instanceof Operator) {                        Operator imageData = (Operator) nextToken;                        if (imageData.getImageData() == null || imageData.getImageData().length == 0) {                                                    }                        beginImageOP.setImageData(imageData.getImageData());                    }                }                break;            }        case 'I':            {                                String id = Character.toString((char) seqSource.read()) + (char) seqSource.read();                if (!id.equals(OperatorName.BEGIN_INLINE_IMAGE_DATA)) {                    throw new IOException("Error: Expected operator 'ID' actual='" + id + "' at stream offset " + seqSource.getPosition());                }                ByteArrayOutputStream imageData = new ByteArrayOutputStream();                if (isWhitespace()) {                                        seqSource.read();                }                int lastByte = seqSource.read();                int currentByte = seqSource.read();                                while (!(lastByte == 'E' && currentByte == 'I' && hasNextSpaceOrReturn() && hasNoFollowingBinData(seqSource)) && !seqSource.isEOF()) {                    imageData.write(lastByte);                    lastByte = currentByte;                    currentByte = seqSource.read();                }                                retval = Operator.getOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);                                ((Operator) retval).setImageData(imageData.toByteArray());                break;            }        case ']':            {                                                seqSource.read();                                retval = COSNull.NULL;                break;            }        default:            {                                String operator = readOperator();                if (operator.trim().length() == 0) {                                        retval = null;                } else {                    retval = Operator.getOperator(operator);                }            }    }    return retval;}
private boolean pdfbox_f3214_1(SequentialSource pdfSource) throws IOException
{        final int readBytes = pdfSource.read(binCharTestArr, 0, MAX_BIN_CHAR_TEST_LENGTH);    boolean noBinData = true;    int startOpIdx = -1;    int endOpIdx = -1;    if (readBytes > 0) {        for (int bIdx = 0; bIdx < readBytes; bIdx++) {            final byte b = binCharTestArr[bIdx];            if (b != 0 && b < 0x09 || b > 0x0a && b < 0x20 && b != 0x0d) {                                noBinData = false;                break;            }                        if (startOpIdx == -1 && !(b == 0 || b == 9 || b == 0x20 || b == 0x0a || b == 0x0d)) {                startOpIdx = bIdx;            } else if (startOpIdx != -1 && endOpIdx == -1 && (b == 0 || b == 9 || b == 0x20 || b == 0x0a || b == 0x0d)) {                endOpIdx = bIdx;            }        }                if (endOpIdx != -1 && startOpIdx != -1) {                        String s = new String(binCharTestArr, startOpIdx, endOpIdx - startOpIdx);            if (!"Q".equals(s) && !"EMC".equals(s) && !"S".equals(s)) {                noBinData = false;            }        }                if (readBytes == MAX_BIN_CHAR_TEST_LENGTH) {                        if (startOpIdx != -1 && endOpIdx == -1) {                endOpIdx = MAX_BIN_CHAR_TEST_LENGTH;            }            if (endOpIdx != -1 && startOpIdx != -1 && endOpIdx - startOpIdx > 3) {                noBinData = false;            }        }        pdfSource.unread(binCharTestArr, 0, readBytes);    }    if (!noBinData) {            }    return noBinData;}
protected String pdfbox_f3215_0() throws IOException
{    skipSpaces();            StringBuilder buffer = new StringBuilder(4);    int nextChar = seqSource.peek();    while (    nextChar != -1 && !isWhitespace(nextChar) && !isClosing(nextChar) && nextChar != '[' && nextChar != '<' && nextChar != '(' && nextChar != '/' && (nextChar < '0' || nextChar > '9')) {        char currentChar = (char) seqSource.read();        nextChar = seqSource.peek();        buffer.append(currentChar);                if (currentChar == 'd' && (nextChar == '0' || nextChar == '1')) {            buffer.append((char) seqSource.read());            nextChar = seqSource.peek();        }    }    return buffer.toString();}
private boolean pdfbox_f3216_0(int c)
{    return c == 10 || c == 13 || c == 32;}
private boolean pdfbox_f3217_0() throws IOException
{    return isSpaceOrReturn(seqSource.peek());}
public COSStream pdfbox_f3218_0() throws IOException
{    stream.setItem(COSName.TYPE, COSName.XREF);    if (size == -1) {        throw new IllegalArgumentException("size is not set in xrefstream");    }    stream.setLong(COSName.SIZE, size);    List<Long> indexEntry = getIndexEntry();    COSArray indexAsArray = new COSArray();    for (Long i : indexEntry) {        indexAsArray.add(COSInteger.get(i));    }    stream.setItem(COSName.INDEX, indexAsArray);    int[] wEntry = getWEntry();    COSArray wAsArray = new COSArray();    for (int j : wEntry) {        wAsArray.add(COSInteger.get(j));    }    stream.setItem(COSName.W, wAsArray);    try (OutputStream outputStream = this.stream.createOutputStream(COSName.FLATE_DECODE)) {        writeStreamData(outputStream, wEntry);        outputStream.flush();    }    Set<COSName> keySet = this.stream.keySet();    for (COSName cosName : keySet) {                if (COSName.ROOT.equals(cosName) || COSName.INFO.equals(cosName) || COSName.PREV.equals(cosName)) {            continue;        }                if (COSName.ENCRYPT.equals(cosName)) {            continue;        }        COSBase dictionaryObject = this.stream.getDictionaryObject(cosName);        dictionaryObject.setDirect(true);    }    return this.stream;}
public void pdfbox_f3219_0(COSDictionary trailerDict)
{    Set<Entry<COSName, COSBase>> entrySet = trailerDict.entrySet();    for (Entry<COSName, COSBase> entry : entrySet) {        COSName key = entry.getKey();        if (COSName.INFO.equals(key) || COSName.ROOT.equals(key) || COSName.ENCRYPT.equals(key) || COSName.ID.equals(key) || COSName.PREV.equals(key)) {            stream.setItem(key, entry.getValue());        }    }}
public void pdfbox_f3220_0(COSWriterXRefEntry entry)
{    objectNumbers.add(entry.getKey().getNumber());    if (entry.isFree()) {                FreeReference value = new FreeReference();        value.nextGenNumber = entry.getKey().getGeneration();        value.nextFree = entry.getKey().getNumber();        streamData.put(value.nextFree, value);    } else {                        NormalReference value = new NormalReference();        value.genNumber = entry.getKey().getGeneration();        value.offset = entry.getOffset();        streamData.put(entry.getKey().getNumber(), value);    }}
private int[] pdfbox_f3221_0()
{    long[] wMax = new long[3];    for (Object entry : streamData.values()) {        if (entry instanceof FreeReference) {            FreeReference free = (FreeReference) entry;                        wMax[0] = Math.max(wMax[0], ENTRY_FREE);            wMax[1] = Math.max(wMax[1], free.nextFree);            wMax[2] = Math.max(wMax[2], free.nextGenNumber);        } else if (entry instanceof NormalReference) {            NormalReference ref = (NormalReference) entry;                        wMax[0] = Math.max(wMax[0], ENTRY_NORMAL);            wMax[1] = Math.max(wMax[1], ref.offset);            wMax[2] = Math.max(wMax[2], ref.genNumber);        } else if (entry instanceof ObjectStreamReference) {            ObjectStreamReference objStream = (ObjectStreamReference) entry;                        wMax[0] = Math.max(wMax[0], ENTRY_OBJSTREAM);            wMax[1] = Math.max(wMax[1], objStream.offset);            wMax[2] = Math.max(wMax[2], objStream.objectNumberOfObjectStream);        } else         {            throw new RuntimeException("unexpected reference type");        }    }        int[] w = new int[3];    for (int i = 0; i < w.length; i++) {        while (wMax[i] > 0) {            w[i]++;            wMax[i] >>= 8;        }    }    return w;}
public void pdfbox_f3222_0(long streamSize)
{    this.size = streamSize;}
private List<Long> pdfbox_f3223_0()
{    LinkedList<Long> linkedList = new LinkedList<>();    Long first = null;    Long length = null;    Set<Long> objNumbers = new TreeSet<>();        objNumbers.add(0L);    objNumbers.addAll(objectNumbers);    for (Long objNumber : objNumbers) {        if (first == null) {            first = objNumber;            length = 1L;        }        if (first + length == objNumber) {            length += 1;        }        if (first + length < objNumber) {            linkedList.add(first);            linkedList.add(length);            first = objNumber;            length = 1L;        }    }    linkedList.add(first);    linkedList.add(length);    return linkedList;}
private void pdfbox_f3224_0(OutputStream os, long number, int bytes) throws IOException
{    byte[] buffer = new byte[bytes];    for (int i = 0; i < bytes; i++) {        buffer[i] = (byte) (number & 0xff);        number >>= 8;    }    for (int i = 0; i < bytes; i++) {        os.write(buffer[bytes - i - 1]);    }}
private void pdfbox_f3225_0(OutputStream os, int[] w) throws IOException
{        writeNumber(os, ENTRY_FREE, w[0]);    writeNumber(os, ENTRY_FREE, w[1]);    writeNumber(os, 0xFFFF, w[2]);        for (Object entry : streamData.values()) {        if (entry instanceof FreeReference) {            FreeReference free = (FreeReference) entry;            writeNumber(os, ENTRY_FREE, w[0]);            writeNumber(os, free.nextFree, w[1]);            writeNumber(os, free.nextGenNumber, w[2]);        } else if (entry instanceof NormalReference) {            NormalReference ref = (NormalReference) entry;            writeNumber(os, ENTRY_NORMAL, w[0]);            writeNumber(os, ref.offset, w[1]);            writeNumber(os, ref.genNumber, w[2]);        } else if (entry instanceof ObjectStreamReference) {            ObjectStreamReference objStream = (ObjectStreamReference) entry;            writeNumber(os, ENTRY_OBJSTREAM, w[0]);            writeNumber(os, objStream.offset, w[1]);            writeNumber(os, objStream.objectNumberOfObjectStream, w[2]);        } else         {            throw new RuntimeException("unexpected reference type");        }    }}
public COSObject pdfbox_f3226_0(int objectNumber)
{    return null;}
public void pdfbox_f3227_0() throws IOException
{    COSBase w = stream.getDictionaryObject(COSName.W);    if (!(w instanceof COSArray)) {        throw new IOException("/W array is missing in Xref stream");    }    COSArray xrefFormat = (COSArray) w;    COSBase base = stream.getDictionaryObject(COSName.INDEX);    COSArray indexArray;    if (base instanceof COSArray) {        indexArray = (COSArray) base;    } else {                indexArray = new COSArray();        indexArray.add(COSInteger.ZERO);        indexArray.add(COSInteger.get(stream.getInt(COSName.SIZE, 0)));    }    List<Long> objNums = new ArrayList<>();    /*         * Populates objNums with all object numbers available         */    Iterator<COSBase> indexIter = indexArray.iterator();    while (indexIter.hasNext()) {        base = indexIter.next();        if (!(base instanceof COSInteger)) {            throw new IOException("Xref stream must have integer in /Index array");        }        long objID = ((COSInteger) base).longValue();        if (!indexIter.hasNext()) {            break;        }        base = indexIter.next();        if (!(base instanceof COSInteger)) {            throw new IOException("Xref stream must have integer in /Index array");        }        int size = ((COSInteger) base).intValue();        for (int i = 0; i < size; i++) {            objNums.add(objID + i);        }    }    Iterator<Long> objIter = objNums.iterator();    /*         * Calculating the size of the line in bytes         */    int w0 = xrefFormat.getInt(0, 0);    int w1 = xrefFormat.getInt(1, 0);    int w2 = xrefFormat.getInt(2, 0);    int lineSize = w0 + w1 + w2;    while (!seqSource.isEOF() && objIter.hasNext()) {        byte[] currLine = new byte[lineSize];        seqSource.read(currLine);        int type;        if (w0 == 0) {                                    type = 1;        } else {            type = 0;            /*                 * Grabs the number of bytes specified for the first column in                 * the W array and stores it.                 */            for (int i = 0; i < w0; i++) {                type += (currLine[i] & 0x00ff) << ((w0 - i - 1) * 8);            }        }                Long objID = objIter.next();        /*             * 3 different types of entries.             */        switch(type) {            case 0:                /*                     * Skipping free objects                     */                break;            case 1:                int offset = 0;                for (int i = 0; i < w1; i++) {                    offset += (currLine[i + w0] & 0x00ff) << ((w1 - i - 1) * 8);                }                int genNum = 0;                for (int i = 0; i < w2; i++) {                    genNum += (currLine[i + w0 + w1] & 0x00ff) << ((w2 - i - 1) * 8);                }                COSObjectKey objKey = new COSObjectKey(objID, genNum);                xrefTrailerResolver.setXRef(objKey, offset);                break;            case 2:                /*                     * object stored in object stream:                      * 2nd argument is object number of object stream                     * 3rd argument is index of object within object stream                     *                      * For sequential PDFParser we do not need this information                     * because                     * These objects are handled by the dereferenceObjects() method                     * since they're only pointing to object numbers                     *                      * However for XRef aware parsers we have to know which objects contain                     * object streams. We will store this information in normal xref mapping                     * table but add object stream number with minus sign in order to                     * distinguish from file offsets                     */                int objstmObjNr = 0;                for (int i = 0; i < w1; i++) {                    objstmObjNr += (currLine[i + w0] & 0x00ff) << ((w1 - i - 1) * 8);                }                objKey = new COSObjectKey(objID, 0);                xrefTrailerResolver.setXRef(objKey, -objstmObjNr);                break;            default:                break;        }    }}
public int pdfbox_f3228_0() throws IOException
{    return reader.read();}
public int pdfbox_f3229_0(byte[] b) throws IOException
{    return reader.read(b);}
public int pdfbox_f3230_0(byte[] b, int offset, int length) throws IOException
{    return reader.read(b, offset, length);}
public long pdfbox_f3231_0() throws IOException
{    return reader.getPosition();}
public int pdfbox_f3232_0() throws IOException
{    return reader.peek();}
public void pdfbox_f3233_0(int b) throws IOException
{    reader.rewind(1);}
public void pdfbox_f3234_0(byte[] bytes) throws IOException
{    reader.rewind(bytes.length);}
public void pdfbox_f3235_0(byte[] bytes, int start, int len) throws IOException
{    reader.rewind(len - start);}
public byte[] pdfbox_f3236_0(int length) throws IOException
{    return reader.readFully(length);}
public boolean pdfbox_f3237_0() throws IOException
{    return reader.isEOF();}
public void pdfbox_f3238_0() throws IOException
{    reader.close();}
public void pdfbox_f3239_0()
{    xrefTable.clear();}
public final COSDictionary pdfbox_f3240_0()
{    if (bytePosToXrefMap.isEmpty()) {        return null;    }    Set<Long> offsets = bytePosToXrefMap.keySet();    SortedSet<Long> sortedOffset = new TreeSet<>(offsets);    return bytePosToXrefMap.get(sortedOffset.first()).trailer;}
public final COSDictionary pdfbox_f3241_0()
{    if (bytePosToXrefMap.isEmpty()) {        return null;    }    Set<Long> offsets = bytePosToXrefMap.keySet();    SortedSet<Long> sortedOffset = new TreeSet<>(offsets);    return bytePosToXrefMap.get(sortedOffset.last()).trailer;}
public final int pdfbox_f3242_0()
{    return bytePosToXrefMap.size();}
public void pdfbox_f3243_0(final long startBytePos, XRefType type)
{    curXrefTrailerObj = new XrefTrailerObj();    bytePosToXrefMap.put(startBytePos, curXrefTrailerObj);    curXrefTrailerObj.xrefType = type;}
public XRefType pdfbox_f3244_0()
{    return (resolvedXrefTrailer == null) ? null : resolvedXrefTrailer.xrefType;}
public void pdfbox_f3245_1(COSObjectKey objKey, long offset)
{    if (curXrefTrailerObj == null) {                        return;    }        if (!curXrefTrailerObj.xrefTable.containsKey(objKey)) {        curXrefTrailerObj.xrefTable.put(objKey, offset);    }}
public void pdfbox_f3246_1(COSDictionary trailer)
{    if (curXrefTrailerObj == null) {                        return;    }    curXrefTrailerObj.trailer = trailer;}
public COSDictionary pdfbox_f3247_0()
{    return curXrefTrailerObj.trailer;}
public void pdfbox_f3248_1(long startxrefBytePosValue)
{    if (resolvedXrefTrailer != null) {                return;    }    resolvedXrefTrailer = new XrefTrailerObj();    resolvedXrefTrailer.trailer = new COSDictionary();    XrefTrailerObj curObj = bytePosToXrefMap.get(startxrefBytePosValue);    List<Long> xrefSeqBytePos = new ArrayList<>();    if (curObj == null) {                                xrefSeqBytePos.addAll(bytePosToXrefMap.keySet());        Collections.sort(xrefSeqBytePos);    } else {                resolvedXrefTrailer.xrefType = curObj.xrefType;                        xrefSeqBytePos.add(startxrefBytePosValue);        while (curObj.trailer != null) {            long prevBytePos = curObj.trailer.getLong(COSName.PREV, -1L);            if (prevBytePos == -1) {                break;            }            curObj = bytePosToXrefMap.get(prevBytePos);            if (curObj == null) {                                break;            }            xrefSeqBytePos.add(prevBytePos);                        if (xrefSeqBytePos.size() >= bytePosToXrefMap.size()) {                break;            }        }                Collections.reverse(xrefSeqBytePos);    }        for (Long bPos : xrefSeqBytePos) {        curObj = bytePosToXrefMap.get(bPos);        if (curObj.trailer != null) {            resolvedXrefTrailer.trailer.addAll(curObj.trailer);        }        resolvedXrefTrailer.xrefTable.putAll(curObj.xrefTable);    }}
public COSDictionary pdfbox_f3249_0()
{    return (resolvedXrefTrailer == null) ? null : resolvedXrefTrailer.trailer;}
public Map<COSObjectKey, Long> pdfbox_f3250_0()
{    return (resolvedXrefTrailer == null) ? null : resolvedXrefTrailer.xrefTable;}
public Set<Long> pdfbox_f3251_0(final int objstmObjNr)
{    if (resolvedXrefTrailer == null) {        return null;    }    final Set<Long> refObjNrs = new HashSet<>();    final long cmpVal = -objstmObjNr;    for (Entry<COSObjectKey, Long> xrefEntry : resolvedXrefTrailer.xrefTable.entrySet()) {        if (xrefEntry.getValue() == cmpVal) {            refObjNrs.add(xrefEntry.getKey().getNumber());        }    }    return refObjNrs;}
protected void pdfbox_f3252_0()
{    for (XrefTrailerObj trailerObj : bytePosToXrefMap.values()) {        trailerObj.reset();    }    curXrefTrailerObj = null;    resolvedXrefTrailer = null;}
public void pdfbox_f3253_0(COSBase base) throws IOException
{    writeObject(base);}
public void pdfbox_f3254_0(Operator op) throws IOException
{    writeObject(op);}
public void pdfbox_f3255_0(Object... tokens) throws IOException
{    for (Object token : tokens) {        writeObject(token);    }    output.write("\n".getBytes(Charsets.US_ASCII));}
public void pdfbox_f3256_0(List<?> tokens) throws IOException
{    for (Object token : tokens) {        writeObject(token);    }}
private void pdfbox_f3257_0(Object o) throws IOException
{    if (o instanceof COSString) {        COSWriter.writeString((COSString) o, output);        output.write(SPACE);    } else if (o instanceof COSFloat) {        ((COSFloat) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSInteger) {        ((COSInteger) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSBoolean) {        ((COSBoolean) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSName) {        ((COSName) o).writePDF(output);        output.write(SPACE);    } else if (o instanceof COSArray) {        COSArray array = (COSArray) o;        output.write(COSWriter.ARRAY_OPEN);        for (int i = 0; i < array.size(); i++) {            writeObject(array.get(i));            output.write(SPACE);        }        output.write(COSWriter.ARRAY_CLOSE);    } else if (o instanceof COSDictionary) {        COSDictionary obj = (COSDictionary) o;        output.write(COSWriter.DICT_OPEN);        for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {            if (entry.getValue() != null) {                writeObject(entry.getKey());                output.write(SPACE);                writeObject(entry.getValue());                output.write(SPACE);            }        }        output.write(COSWriter.DICT_CLOSE);        output.write(SPACE);    } else if (o instanceof Operator) {        Operator op = (Operator) o;        if (op.getName().equals(OperatorName.BEGIN_INLINE_IMAGE)) {            output.write(OperatorName.BEGIN_INLINE_IMAGE.getBytes(Charsets.ISO_8859_1));            COSDictionary dic = op.getImageParameters();            for (COSName key : dic.keySet()) {                Object value = dic.getDictionaryObject(key);                key.writePDF(output);                output.write(SPACE);                writeObject(value);                output.write(EOL);            }            output.write(OperatorName.BEGIN_INLINE_IMAGE_DATA.getBytes(Charsets.ISO_8859_1));            output.write(EOL);            output.write(op.getImageData());            output.write(EOL);            output.write(OperatorName.END_INLINE_IMAGE.getBytes(Charsets.ISO_8859_1));            output.write(EOL);        } else {            output.write(op.getName().getBytes(Charsets.ISO_8859_1));            output.write(EOL);        }    } else {        throw new IOException("Error:Unknown type in content stream:" + o);    }}
public long pdfbox_f3258_0()
{    return position;}
public boolean pdfbox_f3259_0()
{    return onNewLine;}
public void pdfbox_f3260_0(boolean newOnNewLine)
{    onNewLine = newOnNewLine;}
public void pdfbox_f3261_0(byte[] b, int off, int len) throws IOException
{    setOnNewLine(false);    out.write(b, off, len);    position += len;}
public void pdfbox_f3262_0(int b) throws IOException
{    setOnNewLine(false);    out.write(b);    position++;}
public void pdfbox_f3263_0() throws IOException
{    write(CRLF);}
public void pdfbox_f3264_0() throws IOException
{    if (!isOnNewLine()) {        write(EOL);        setOnNewLine(true);    }}
public void pdfbox_f3265_0() throws IOException
{    write(LF);}
private void pdfbox_f3266_0(PDDocument doc)
{    if (doc != null) {        COSDocument cosDoc = doc.getDocument();        Map<COSObjectKey, Long> xrefTable = cosDoc.getXrefTable();        Set<COSObjectKey> keySet = xrefTable.keySet();        long highestNumber = doc.getDocument().getHighestXRefObjectNumber();        for (COSObjectKey cosObjectKey : keySet) {            COSBase object = cosDoc.getObjectFromPool(cosObjectKey).getObject();            if (object != null && cosObjectKey != null && !(object instanceof COSNumber)) {                objectKeys.put(object, cosObjectKey);                keyObject.put(cosObjectKey, object);            }            if (cosObjectKey != null) {                long num = cosObjectKey.getNumber();                if (num > highestNumber) {                    highestNumber = num;                }            }        }        setNumber(highestNumber);    }}
protected void pdfbox_f3267_0(COSWriterXRefEntry entry)
{    getXRefEntries().add(entry);}
public void pdfbox_f3268_0() throws IOException
{    if (getStandardOutput() != null) {        getStandardOutput().close();    }    if (incrementalOutput != null) {        incrementalOutput.close();    }}
protected long pdfbox_f3269_0()
{    return number;}
public Map<COSBase, COSObjectKey> pdfbox_f3270_0()
{    return objectKeys;}
protected java.io.OutputStream pdfbox_f3271_0()
{    return output;}
protected COSStandardOutputStream pdfbox_f3272_0()
{    return standardOutput;}
protected long pdfbox_f3273_0()
{    return startxref;}
protected List<COSWriterXRefEntry> pdfbox_f3274_0()
{    return xRefEntries;}
protected void pdfbox_f3275_0(long newNumber)
{    number = newNumber;}
private void pdfbox_f3276_0(OutputStream newOutput)
{    output = newOutput;}
private void pdfbox_f3277_0(COSStandardOutputStream newStandardOutput)
{    standardOutput = newStandardOutput;}
protected void pdfbox_f3278_0(long newStartxref)
{    startxref = newStartxref;}
protected void pdfbox_f3279_0(COSDocument doc) throws IOException
{    COSDictionary trailer = doc.getTrailer();    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);    COSDictionary info = trailer.getCOSDictionary(COSName.INFO);    COSDictionary encrypt = trailer.getCOSDictionary(COSName.ENCRYPT);    if (root != null) {        addObjectToWrite(root);    }    if (info != null) {        addObjectToWrite(info);    }    doWriteObjects();    willEncrypt = false;    if (encrypt != null) {        addObjectToWrite(encrypt);    }    doWriteObjects();}
private void pdfbox_f3280_0() throws IOException
{    while (objectsToWrite.size() > 0) {        COSBase nextObject = objectsToWrite.removeFirst();        objectsToWriteSet.remove(nextObject);        doWriteObject(nextObject);    }}
private void pdfbox_f3281_0(COSBase object)
{    COSBase actual = object;    if (actual instanceof COSObject) {        actual = ((COSObject) actual).getObject();    }    if (!writtenObjects.contains(object) && !objectsToWriteSet.contains(object) && !actualsAdded.contains(actual)) {        COSBase cosBase = null;        COSObjectKey cosObjectKey = null;        if (actual != null) {            cosObjectKey = objectKeys.get(actual);        }        if (cosObjectKey != null) {            cosBase = keyObject.get(cosObjectKey);        }        if (actual != null && objectKeys.containsKey(actual) && object instanceof COSUpdateInfo && !((COSUpdateInfo) object).isNeedToBeUpdated() && cosBase instanceof COSUpdateInfo && !((COSUpdateInfo) cosBase).isNeedToBeUpdated()) {            return;        }        objectsToWrite.add(object);        objectsToWriteSet.add(object);        if (actual != null) {            actualsAdded.add(actual);        }    }}
public void pdfbox_f3282_0(COSBase obj) throws IOException
{    writtenObjects.add(obj);        currentObjectKey = getObjectKey(obj);        addXRefEntry(new COSWriterXRefEntry(getStandardOutput().getPos(), obj, currentObjectKey));        getStandardOutput().write(String.valueOf(currentObjectKey.getNumber()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(String.valueOf(currentObjectKey.getGeneration()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(OBJ);    getStandardOutput().writeEOL();        if (obj != null) {        obj.accept(this);    }    getStandardOutput().writeEOL();    getStandardOutput().write(ENDOBJ);    getStandardOutput().writeEOL();}
protected void pdfbox_f3283_0(COSDocument doc) throws IOException
{    String headerString;    if (fdfDocument != null) {        headerString = "%FDF-" + Float.toString(doc.getVersion());    } else {        headerString = "%PDF-" + Float.toString(doc.getVersion());    }    getStandardOutput().write(headerString.getBytes(Charsets.ISO_8859_1));    getStandardOutput().writeEOL();    getStandardOutput().write(COMMENT);    getStandardOutput().write(GARBAGE);    getStandardOutput().writeEOL();}
protected void pdfbox_f3284_0(COSDocument doc) throws IOException
{    getStandardOutput().write(TRAILER);    getStandardOutput().writeEOL();    COSDictionary trailer = doc.getTrailer();        Collections.sort(getXRefEntries());    COSWriterXRefEntry lastEntry = getXRefEntries().get(getXRefEntries().size() - 1);    trailer.setLong(COSName.SIZE, lastEntry.getKey().getNumber() + 1);        if (!incrementalUpdate) {        trailer.removeItem(COSName.PREV);    }    if (!doc.isXRefStream()) {        trailer.removeItem(COSName.XREF_STM);    }        trailer.removeItem(COSName.DOC_CHECKSUM);    COSArray idArray = trailer.getCOSArray(COSName.ID);    if (idArray != null) {        idArray.setDirect(true);    }    trailer.accept(this);}
private void pdfbox_f3285_0(COSDocument doc, long hybridPrev) throws IOException
{    if (doc.isXRefStream() || hybridPrev != -1) {                                        PDFXRefStream pdfxRefStream = new PDFXRefStream(doc);                List<COSWriterXRefEntry> xRefEntries2 = getXRefEntries();        for (COSWriterXRefEntry cosWriterXRefEntry : xRefEntries2) {            pdfxRefStream.addEntry(cosWriterXRefEntry);        }        COSDictionary trailer = doc.getTrailer();        if (incrementalUpdate) {                        trailer.setLong(COSName.PREV, doc.getStartXref());        } else {            trailer.removeItem(COSName.PREV);        }        pdfxRefStream.addTrailerInfo(trailer);                        pdfxRefStream.setSize(getNumber() + 2);        setStartxref(getStandardOutput().getPos());        COSStream stream2 = pdfxRefStream.getStream();        doWriteObject(stream2);    }    if (!doc.isXRefStream() || hybridPrev != -1) {        COSDictionary trailer = doc.getTrailer();        trailer.setLong(COSName.PREV, doc.getStartXref());        if (hybridPrev != -1) {            COSName xrefStm = COSName.XREF_STM;            trailer.removeItem(xrefStm);            trailer.setLong(xrefStm, getStartxref());        }        doWriteXRefTable();        doWriteTrailer(doc);    }}
private void pdfbox_f3286_0() throws IOException
{    addXRefEntry(COSWriterXRefEntry.getNullEntry());        Collections.sort(getXRefEntries());        setStartxref(getStandardOutput().getPos());    getStandardOutput().write(XREF);    getStandardOutput().writeEOL();            Long[] xRefRanges = getXRefRanges(getXRefEntries());    int xRefLength = xRefRanges.length;    int x = 0;    int j = 0;    while (x < xRefLength && (xRefLength % 2) == 0) {        writeXrefRange(xRefRanges[x], xRefRanges[x + 1]);        for (int i = 0; i < xRefRanges[x + 1]; ++i) {            writeXrefEntry(xRefEntries.get(j++));        }        x += 2;    }}
private void pdfbox_f3287_0() throws IOException
{        IOUtils.copy(new RandomAccessInputStream(incrementalInput), incrementalOutput);        incrementalOutput.write(((ByteArrayOutputStream) output).toByteArray());}
private void pdfbox_f3288_0() throws IOException
{        long inLength = incrementalInput.length();    long beforeLength = signatureOffset;    long afterOffset = signatureOffset + signatureLength;    long afterLength = getStandardOutput().getPos() - (inLength + signatureLength) - (signatureOffset - inLength);    String byteRange = "0 " + beforeLength + " " + afterOffset + " " + afterLength + "]";        byteRangeArray.set(0, COSInteger.ZERO);    byteRangeArray.set(1, COSInteger.get(beforeLength));    byteRangeArray.set(2, COSInteger.get(afterOffset));    byteRangeArray.set(3, COSInteger.get(afterLength));    if (byteRange.length() > byteRangeLength) {        throw new IOException("Can't write new byteRange '" + byteRange + "' not enough space: byteRange.length(): " + byteRange.length() + ", byteRangeLength: " + byteRangeLength);    }        ByteArrayOutputStream byteOut = (ByteArrayOutputStream) output;    byteOut.flush();    incrementPart = byteOut.toByteArray();        byte[] byteRangeBytes = byteRange.getBytes(Charsets.ISO_8859_1);    for (int i = 0; i < byteRangeLength; i++) {        if (i >= byteRangeBytes.length) {                        incrementPart[(int) (byteRangeOffset + i - inLength)] = 0x20;        } else {            incrementPart[(int) (byteRangeOffset + i - inLength)] = byteRangeBytes[i];        }    }    if (signatureInterface != null) {                final InputStream dataToSign = getDataToSign();                byte[] signatureBytes = signatureInterface.sign(dataToSign);        writeExternalSignature(signatureBytes);    }}
public InputStream pdfbox_f3289_0() throws IOException
{    if (incrementPart == null || incrementalInput == null) {        throw new IllegalStateException("PDF not prepared for signing");    }        int incPartSigOffset = (int) (signatureOffset - incrementalInput.length());    int afterSigOffset = incPartSigOffset + (int) signatureLength;    int[] range = { 0, incPartSigOffset, afterSigOffset, incrementPart.length - afterSigOffset };    return new SequenceInputStream(new RandomAccessInputStream(incrementalInput), new COSFilterInputStream(incrementPart, range));}
public void pdfbox_f3290_0(byte[] cmsSignature) throws IOException
{    if (incrementPart == null || incrementalInput == null) {        throw new IllegalStateException("PDF not prepared for setting signature");    }    byte[] signatureBytes = Hex.getBytes(cmsSignature);        if (signatureBytes.length > signatureLength - 2) {        throw new IOException("Can't write signature, not enough space");    }        int incPartSigOffset = (int) (signatureOffset - incrementalInput.length());    System.arraycopy(signatureBytes, 0, incrementPart, incPartSigOffset + 1, signatureBytes.length);        IOUtils.copy(new RandomAccessInputStream(incrementalInput), incrementalOutput);    incrementalOutput.write(incrementPart);        incrementPart = null;}
private void pdfbox_f3291_0(long x, long y) throws IOException
{    getStandardOutput().write(String.valueOf(x).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(String.valueOf(y).getBytes(Charsets.ISO_8859_1));    getStandardOutput().writeEOL();}
private void pdfbox_f3292_0(COSWriterXRefEntry entry) throws IOException
{    String offset = formatXrefOffset.format(entry.getOffset());    String generation = formatXrefGeneration.format(entry.getKey().getGeneration());    getStandardOutput().write(offset.getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(generation.getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(entry.isFree() ? XREF_FREE : XREF_USED);    getStandardOutput().writeCRLF();}
protected Long[] pdfbox_f3293_0(List<COSWriterXRefEntry> xRefEntriesList)
{    long last = -2;    long count = 1;    List<Long> list = new ArrayList<>();    for (Object object : xRefEntriesList) {        long nr = (int) ((COSWriterXRefEntry) object).getKey().getNumber();        if (nr == last + 1) {            ++count;            last = nr;        } else if (last == -2) {            last = nr;        } else {            list.add(last - count + 1);            list.add(count);            last = nr;            count = 1;        }    }        if (xRefEntriesList.size() > 0) {        list.add(last - count + 1);        list.add(count);    }    return list.toArray(new Long[list.size()]);}
private COSObjectKey pdfbox_f3294_0(COSBase obj)
{    COSBase actual = obj;    if (actual instanceof COSObject) {        actual = ((COSObject) obj).getObject();    }            COSObjectKey key = objectKeys.get(obj);    if (key == null && actual != null) {        key = objectKeys.get(actual);    }    if (key == null) {        setNumber(getNumber() + 1);        key = new COSObjectKey(getNumber(), 0);        objectKeys.put(obj, key);        if (actual != null) {            objectKeys.put(actual, key);        }    }    return key;}
public Object pdfbox_f3295_0(COSArray obj) throws IOException
{    int count = 0;    getStandardOutput().write(ARRAY_OPEN);    for (Iterator<COSBase> i = obj.iterator(); i.hasNext(); ) {        COSBase current = i.next();        if (current instanceof COSDictionary) {            if (current.isDirect()) {                visitFromDictionary((COSDictionary) current);            } else {                addObjectToWrite(current);                writeReference(current);            }        } else if (current instanceof COSObject) {            COSBase subValue = ((COSObject) current).getObject();            if (willEncrypt || incrementalUpdate || subValue instanceof COSDictionary || subValue == null) {                                                                                addObjectToWrite(current);                writeReference(current);            } else {                subValue.accept(this);            }        } else if (current == null) {            COSNull.NULL.accept(this);        } else {            current.accept(this);        }        count++;        if (i.hasNext()) {            if (count % 10 == 0) {                getStandardOutput().writeEOL();            } else {                getStandardOutput().write(SPACE);            }        }    }    getStandardOutput().write(ARRAY_CLOSE);    getStandardOutput().writeEOL();    return null;}
public Object pdfbox_f3296_0(COSBoolean obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
public Object pdfbox_f3297_0(COSDictionary obj) throws IOException
{    if (!reachedSignature) {        COSBase itemType = obj.getItem(COSName.TYPE);        if (COSName.SIG.equals(itemType) || COSName.DOC_TIME_STAMP.equals(itemType)) {            reachedSignature = true;        }    }    getStandardOutput().write(DICT_OPEN);    getStandardOutput().writeEOL();    for (Map.Entry<COSName, COSBase> entry : obj.entrySet()) {        COSBase value = entry.getValue();        if (value != null) {            entry.getKey().accept(this);            getStandardOutput().write(SPACE);            if (value instanceof COSDictionary) {                COSDictionary dict = (COSDictionary) value;                if (!incrementalUpdate) {                                                            COSBase item = dict.getItem(COSName.XOBJECT);                    if (item != null && !COSName.XOBJECT.equals(entry.getKey())) {                        item.setDirect(true);                    }                    item = dict.getItem(COSName.RESOURCES);                    if (item != null && !COSName.RESOURCES.equals(entry.getKey())) {                        item.setDirect(true);                    }                }                if (dict.isDirect()) {                                                            visitFromDictionary(dict);                } else {                    addObjectToWrite(dict);                    writeReference(dict);                }            } else if (value instanceof COSObject) {                COSBase subValue = ((COSObject) value).getObject();                if (willEncrypt || incrementalUpdate || subValue instanceof COSDictionary || subValue == null) {                                                                                                    addObjectToWrite(value);                    writeReference(value);                } else {                    subValue.accept(this);                }            } else {                                if (reachedSignature && COSName.CONTENTS.equals(entry.getKey())) {                    signatureOffset = getStandardOutput().getPos();                    value.accept(this);                    signatureLength = getStandardOutput().getPos() - signatureOffset;                } else if (reachedSignature && COSName.BYTERANGE.equals(entry.getKey())) {                    byteRangeArray = (COSArray) entry.getValue();                    byteRangeOffset = getStandardOutput().getPos() + 1;                    value.accept(this);                    byteRangeLength = getStandardOutput().getPos() - 1 - byteRangeOffset;                    reachedSignature = false;                } else {                    value.accept(this);                }            }            getStandardOutput().writeEOL();        } else {                                        }    }    getStandardOutput().write(DICT_CLOSE);    getStandardOutput().writeEOL();    return null;}
public Object pdfbox_f3298_0(COSDocument doc) throws IOException
{    if (!incrementalUpdate) {        doWriteHeader(doc);    } else {                                        getStandardOutput().writeCRLF();    }    doWriteBody(doc);        COSDictionary trailer = doc.getTrailer();    long hybridPrev = -1;    if (trailer != null) {        hybridPrev = trailer.getLong(COSName.XREF_STM);    }    if (incrementalUpdate || doc.isXRefStream()) {        doWriteXRefInc(doc, hybridPrev);    } else {        doWriteXRefTable();        doWriteTrailer(doc);    }        getStandardOutput().write(STARTXREF);    getStandardOutput().writeEOL();    getStandardOutput().write(String.valueOf(getStartxref()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().writeEOL();    getStandardOutput().write(EOF);    getStandardOutput().writeEOL();    if (incrementalUpdate) {        if (signatureOffset == 0 || byteRangeOffset == 0) {            doWriteIncrement();        } else {            doWriteSignature();        }    }    return null;}
public Object pdfbox_f3299_0(COSFloat obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
public Object pdfbox_f3300_0(COSInteger obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
public Object pdfbox_f3301_0(COSName obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
public Object pdfbox_f3302_0(COSNull obj) throws IOException
{    obj.writePDF(getStandardOutput());    return null;}
public void pdfbox_f3303_0(COSBase obj) throws IOException
{    COSObjectKey key = getObjectKey(obj);    getStandardOutput().write(String.valueOf(key.getNumber()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(String.valueOf(key.getGeneration()).getBytes(Charsets.ISO_8859_1));    getStandardOutput().write(SPACE);    getStandardOutput().write(REFERENCE);}
public Object pdfbox_f3304_0(COSStream obj) throws IOException
{    if (willEncrypt) {        pdDocument.getEncryption().getSecurityHandler().encryptStream(obj, currentObjectKey.getNumber(), currentObjectKey.getGeneration());    }    InputStream input = null;    try {                visitFromDictionary(obj);        getStandardOutput().write(STREAM);        getStandardOutput().writeCRLF();        input = obj.createRawInputStream();        IOUtils.copy(input, getStandardOutput());        getStandardOutput().writeCRLF();        getStandardOutput().write(ENDSTREAM);        getStandardOutput().writeEOL();        return null;    } finally {        if (input != null) {            input.close();        }    }}
public Object pdfbox_f3305_0(COSString obj) throws IOException
{    if (willEncrypt) {        pdDocument.getEncryption().getSecurityHandler().encryptString(obj, currentObjectKey.getNumber(), currentObjectKey.getGeneration());    }    COSWriter.writeString(obj, getStandardOutput());    return null;}
public void pdfbox_f3306_0(COSDocument doc) throws IOException
{    PDDocument pdDoc = new PDDocument(doc);    write(pdDoc);}
public void pdfbox_f3307_0(PDDocument doc) throws IOException
{    write(doc, null);}
public void pdfbox_f3308_0(PDDocument doc, SignatureInterface signInterface) throws IOException
{    Long idTime = doc.getDocumentId() == null ? System.currentTimeMillis() : doc.getDocumentId();    pdDocument = doc;    signatureInterface = signInterface;    if (incrementalUpdate) {        prepareIncrement(doc);    }        if (doc.isAllSecurityToBeRemoved()) {        willEncrypt = false;                        COSDocument cosDoc = doc.getDocument();        COSDictionary trailer = cosDoc.getTrailer();        trailer.removeItem(COSName.ENCRYPT);    } else {        if (pdDocument.getEncryption() != null) {            if (!incrementalUpdate) {                SecurityHandler securityHandler = pdDocument.getEncryption().getSecurityHandler();                if (!securityHandler.hasProtectionPolicy()) {                    throw new IllegalStateException("PDF contains an encryption dictionary, please remove it with " + "setAllSecurityToBeRemoved() or set a protection policy with protect()");                }                securityHandler.prepareDocumentForEncryption(pdDocument);            }            willEncrypt = true;        } else {            willEncrypt = false;        }    }    COSDocument cosDoc = pdDocument.getDocument();    COSDictionary trailer = cosDoc.getTrailer();    COSArray idArray;    boolean missingID = true;    COSBase base = trailer.getDictionaryObject(COSName.ID);    if (base instanceof COSArray) {        idArray = (COSArray) base;        if (idArray.size() == 2) {            missingID = false;        }    } else {        idArray = new COSArray();    }    if (missingID || incrementalUpdate) {        MessageDigest md5;        try {            md5 = MessageDigest.getInstance("MD5");        } catch (NoSuchAlgorithmException e) {                        throw new RuntimeException(e);        }                        md5.update(Long.toString(idTime).getBytes(Charsets.ISO_8859_1));        COSDictionary info = trailer.getCOSDictionary(COSName.INFO);        if (info != null) {            for (COSBase cosBase : info.getValues()) {                md5.update(cosBase.toString().getBytes(Charsets.ISO_8859_1));            }        }                COSString firstID = missingID ? new COSString(md5.digest()) : (COSString) idArray.get(0);                COSString secondID = missingID ? firstID : new COSString(md5.digest());        idArray = new COSArray();        idArray.add(firstID);        idArray.add(secondID);        trailer.setItem(COSName.ID, idArray);    }    cosDoc.accept(this);}
public void pdfbox_f3309_0(FDFDocument doc) throws IOException
{    fdfDocument = doc;    willEncrypt = false;    COSDocument cosDoc = fdfDocument.getDocument();    cosDoc.accept(this);}
public static void pdfbox_f3310_0(COSString string, OutputStream output) throws IOException
{    writeString(string.getBytes(), string.getForceHexForm(), output);}
public static void pdfbox_f3311_0(byte[] bytes, OutputStream output) throws IOException
{    writeString(bytes, false, output);}
private static void pdfbox_f3312_0(byte[] bytes, boolean forceHex, OutputStream output) throws IOException
{        boolean isASCII = true;    if (!forceHex) {        for (byte b : bytes) {                        if (b < 0) {                isASCII = false;                break;            }                        if (b == 0x0d || b == 0x0a) {                isASCII = false;                break;            }        }    }    if (isASCII && !forceHex) {                output.write('(');        for (byte b : bytes) {            switch(b) {                case '(':                case ')':                case '\\':                    output.write('\\');                    output.write(b);                    break;                default:                    output.write(b);                    break;            }        }        output.write(')');    } else {                output.write('<');        Hex.writeHexBytes(bytes, output);        output.write('>');    }}
public int pdfbox_f3313_0(COSWriterXRefEntry obj)
{    if (obj != null) {        return Long.compare(getKey().getNumber(), obj.getKey().getNumber());    }    return -1;}
public static COSWriterXRefEntry pdfbox_f3314_0()
{    return NULLENTRY;}
public COSObjectKey pdfbox_f3315_0()
{    return key;}
public long pdfbox_f3316_0()
{    return offset;}
public boolean pdfbox_f3317_0()
{    return free;}
public void pdfbox_f3318_0(boolean newFree)
{    free = newFree;}
private void pdfbox_f3319_0(COSObjectKey newKey)
{    key = newKey;}
public final void pdfbox_f3320_0(long newOffset)
{    offset = newOffset;}
public COSBase pdfbox_f3321_0()
{    return object;}
private void pdfbox_f3322_0(COSBase newObject)
{    object = newObject;}
public int pdfbox_f3323_0()
{    return actual.size();}
public boolean pdfbox_f3324_0()
{    return actual.isEmpty();}
public boolean pdfbox_f3325_0(Object o)
{    return actual.contains(o);}
public Iterator<E> pdfbox_f3326_0()
{    return actual.iterator();}
public Object[] pdfbox_f3327_0()
{    return actual.toArray();}
public X[] pdfbox_f3328_0(X[] a)
{    return actual.toArray(a);}
public boolean pdfbox_f3329_0(E o)
{        if (parentDict != null) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }        if (o instanceof String) {        array.add(new COSString((String) o));    } else {        if (array != null) {            array.add(((COSObjectable) o).getCOSObject());        }    }    return actual.add(o);}
public boolean pdfbox_f3330_0(Object o)
{    boolean retval = true;    int index = actual.indexOf(o);    if (index >= 0) {        actual.remove(index);        array.remove(index);    } else {        retval = false;    }    return retval;}
public boolean pdfbox_f3331_0(Collection<?> c)
{    return actual.containsAll(c);}
public boolean pdfbox_f3332_0(Collection<? extends E> c)
{        if (parentDict != null && c.size() > 0) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }    array.addAll(toCOSObjectList(c));    return actual.addAll(c);}
public boolean pdfbox_f3333_0(int index, Collection<? extends E> c)
{        if (parentDict != null && c.size() > 0) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }    array.addAll(index, toCOSObjectList(c));    return actual.addAll(index, c);}
public static List<Integer> pdfbox_f3334_0(COSArray intArray)
{    List<Integer> retval = null;    if (intArray != null) {        List<Integer> numbers = new ArrayList<>();        for (int i = 0; i < intArray.size(); i++) {            COSNumber num;            if (intArray.get(i) instanceof COSObject) {                num = (COSNumber) ((COSObject) intArray.get(i)).getObject();            } else {                num = (COSNumber) intArray.get(i);            }            numbers.add(num.intValue());        }        retval = new COSArrayList<>(numbers, intArray);    }    return retval;}
public static List<Float> pdfbox_f3335_0(COSArray floatArray)
{    List<Float> retval = null;    if (floatArray != null) {        List<Float> numbers = new ArrayList<>(floatArray.size());        for (int i = 0; i < floatArray.size(); i++) {            COSBase base = floatArray.getObject(i);            if (base instanceof COSNumber) {                numbers.add(((COSNumber) base).floatValue());            } else {                numbers.add(null);            }        }        retval = new COSArrayList<>(numbers, floatArray);    }    return retval;}
public static List<String> pdfbox_f3336_0(COSArray nameArray)
{    List<String> retval = null;    if (nameArray != null) {        List<String> names = new ArrayList<>();        for (int i = 0; i < nameArray.size(); i++) {            names.add(((COSName) nameArray.getObject(i)).getName());        }        retval = new COSArrayList<>(names, nameArray);    }    return retval;}
public static List<String> pdfbox_f3337_0(COSArray stringArray)
{    List<String> retval = null;    if (stringArray != null) {        List<String> string = new ArrayList<>();        for (int i = 0; i < stringArray.size(); i++) {            string.add(((COSString) stringArray.getObject(i)).getString());        }        retval = new COSArrayList<>(string, stringArray);    }    return retval;}
public static COSArray pdfbox_f3338_0(List<String> strings)
{    COSArray retval = new COSArray();    for (String string : strings) {        retval.add(COSName.getPDFName(string));    }    return retval;}
public static COSArray pdfbox_f3339_0(List<String> strings)
{    COSArray retval = new COSArray();    for (String string : strings) {        retval.add(new COSString(string));    }    return retval;}
public static COSArray pdfbox_f3340_0(List<?> cosObjectableList)
{    COSArray array = null;    if (cosObjectableList != null) {        if (cosObjectableList instanceof COSArrayList) {                        array = ((COSArrayList<?>) cosObjectableList).array;        } else {            array = new COSArray();            for (Object next : cosObjectableList) {                if (next instanceof String) {                    array.add(new COSString((String) next));                } else if (next instanceof Integer || next instanceof Long) {                    array.add(COSInteger.get(((Number) next).longValue()));                } else if (next instanceof Float || next instanceof Double) {                    array.add(new COSFloat(((Number) next).floatValue()));                } else if (next instanceof COSObjectable) {                    COSObjectable object = (COSObjectable) next;                    array.add(object.getCOSObject());                } else if (next == null) {                    array.add(COSNull.NULL);                } else {                    throw new IllegalArgumentException("Error: Don't know how to convert type to COSBase '" + next.getClass().getName() + "'");                }            }        }    }    return array;}
private List<COSBase> pdfbox_f3341_0(Collection<?> list)
{    List<COSBase> cosObjects = new ArrayList<>();    for (Object next : list) {        if (next instanceof String) {            cosObjects.add(new COSString((String) next));        } else {            COSObjectable cos = (COSObjectable) next;            cosObjects.add(cos.getCOSObject());        }    }    return cosObjects;}
public boolean pdfbox_f3342_0(Collection<?> c)
{    array.removeAll(toCOSObjectList(c));    return actual.removeAll(c);}
public boolean pdfbox_f3343_0(Collection<?> c)
{    array.retainAll(toCOSObjectList(c));    return actual.retainAll(c);}
public void pdfbox_f3344_0()
{        if (parentDict != null) {        parentDict.setItem(dictKey, null);    }    actual.clear();    array.clear();}
public boolean pdfbox_f3345_0(Object o)
{    return actual.equals(o);}
public int pdfbox_f3346_0()
{    return actual.hashCode();}
public E pdfbox_f3347_0(int index)
{    return actual.get(index);}
public E pdfbox_f3348_0(int index, E element)
{    if (element instanceof String) {        COSString item = new COSString((String) element);        if (parentDict != null && index == 0) {            parentDict.setItem(dictKey, item);        }        array.set(index, item);    } else {        if (parentDict != null && index == 0) {            parentDict.setItem(dictKey, ((COSObjectable) element).getCOSObject());        }        array.set(index, ((COSObjectable) element).getCOSObject());    }    return actual.set(index, element);}
public void pdfbox_f3349_0(int index, E element)
{        if (parentDict != null) {        parentDict.setItem(dictKey, array);                        parentDict = null;    }    actual.add(index, element);    if (element instanceof String) {        array.add(index, new COSString((String) element));    } else {        array.add(index, ((COSObjectable) element).getCOSObject());    }}
public E pdfbox_f3350_0(int index)
{    array.remove(index);    return actual.remove(index);}
public int pdfbox_f3351_0(Object o)
{    return actual.indexOf(o);}
public int pdfbox_f3352_0(Object o)
{    return actual.indexOf(o);}
public ListIterator<E> pdfbox_f3353_0()
{    return actual.listIterator();}
public ListIterator<E> pdfbox_f3354_0(int index)
{    return actual.listIterator(index);}
public List<E> pdfbox_f3355_0(int fromIndex, int toIndex)
{    return actual.subList(fromIndex, toIndex);}
public String pdfbox_f3356_0()
{    return "COSArrayList{" + array.toString() + "}";}
public COSArray pdfbox_f3357_0()
{    return array;}
public int pdfbox_f3358_0()
{    return map.size();}
public boolean pdfbox_f3359_0()
{    return size() == 0;}
public boolean pdfbox_f3360_0(Object key)
{    return actuals.containsKey(key);}
public boolean pdfbox_f3361_0(Object value)
{    return actuals.containsValue(value);}
public V pdfbox_f3362_0(Object key)
{    return actuals.get(key);}
public V pdfbox_f3363_0(K key, V value)
{    COSObjectable object = (COSObjectable) value;    map.setItem(COSName.getPDFName((String) key), object.getCOSObject());    return actuals.put(key, value);}
public V pdfbox_f3364_0(Object key)
{    map.removeItem(COSName.getPDFName((String) key));    return actuals.remove(key);}
public void pdfbox_f3365_0(Map<? extends K, ? extends V> t)
{    throw new RuntimeException("Not yet implemented");}
public void pdfbox_f3366_0()
{    map.clear();    actuals.clear();}
public Set<K> pdfbox_f3367_0()
{    return actuals.keySet();}
public Collection<V> pdfbox_f3368_0()
{    return actuals.values();}
public Set<Map.Entry<K, V>> pdfbox_f3369_0()
{    return Collections.unmodifiableSet(actuals.entrySet());}
public boolean pdfbox_f3370_0(Object o)
{    boolean retval = false;    if (o instanceof COSDictionaryMap) {        COSDictionaryMap<K, V> other = (COSDictionaryMap<K, V>) o;        retval = other.map.equals(this.map);    }    return retval;}
public String pdfbox_f3371_0()
{    return actuals.toString();}
public int pdfbox_f3372_0()
{    return map.hashCode();}
public static COSDictionary pdfbox_f3373_0(Map<String, ?> someMap)
{    COSDictionary dic = new COSDictionary();    for (Entry<String, ?> entry : someMap.entrySet()) {        String name = entry.getKey();        COSObjectable object = (COSObjectable) entry.getValue();        dic.setItem(COSName.getPDFName(name), object.getCOSObject());    }    return dic;}
public static COSDictionaryMap<String, Object> pdfbox_f3374_0(COSDictionary map) throws IOException
{    COSDictionaryMap<String, Object> retval = null;    if (map != null) {        Map<String, Object> actualMap = new HashMap<>();        for (COSName key : map.keySet()) {            COSBase cosObj = map.getDictionaryObject(key);            Object actualObject = null;            if (cosObj instanceof COSString) {                actualObject = ((COSString) cosObj).getString();            } else if (cosObj instanceof COSInteger) {                actualObject = ((COSInteger) cosObj).intValue();            } else if (cosObj instanceof COSName) {                actualObject = ((COSName) cosObj).getName();            } else if (cosObj instanceof COSFloat) {                actualObject = ((COSFloat) cosObj).floatValue();            } else if (cosObj instanceof COSBoolean) {                actualObject = ((COSBoolean) cosObj).getValue() ? Boolean.TRUE : Boolean.FALSE;            } else {                throw new IOException("Error:unknown type of object to convert:" + cosObj);            }            actualMap.put(key.getName(), actualObject);        }        retval = new COSDictionaryMap<>(actualMap, map);    }    return retval;}
public COSDictionary pdfbox_f3375_0()
{    return fs;}
private COSDictionary pdfbox_f3376_0()
{    if (efDictionary == null && fs != null) {        efDictionary = (COSDictionary) fs.getDictionaryObject(COSName.EF);    }    return efDictionary;}
private COSBase pdfbox_f3377_0(COSName key)
{    COSDictionary ef = getEFDictionary();    if (ef != null) {        return ef.getDictionaryObject(key);    }    return null;}
public String pdfbox_f3378_0()
{    String filename = getFileUnicode();    if (filename == null) {        filename = getFileDos();    }    if (filename == null) {        filename = getFileMac();    }    if (filename == null) {        filename = getFileUnix();    }    if (filename == null) {        filename = getFile();    }    return filename;}
public String pdfbox_f3379_0()
{    return fs.getString(COSName.UF);}
public void pdfbox_f3380_0(String file)
{    fs.setString(COSName.UF, file);}
public String pdfbox_f3381_0()
{    return fs.getString(COSName.F);}
public void pdfbox_f3382_0(String file)
{    fs.setString(COSName.F, file);}
public String pdfbox_f3383_0()
{    return fs.getString(COSName.DOS);}
public void pdfbox_f3384_0(String file)
{    fs.setString(COSName.DOS, file);}
public String pdfbox_f3385_0()
{    return fs.getString(COSName.MAC);}
public void pdfbox_f3386_0(String file)
{    fs.setString(COSName.MAC, file);}
public String pdfbox_f3387_0()
{    return fs.getString(COSName.UNIX);}
public void pdfbox_f3388_0(String file)
{    fs.setString(COSName.UNIX, file);}
public void pdfbox_f3389_0(boolean fileIsVolatile)
{    fs.setBoolean(COSName.V, fileIsVolatile);}
public boolean pdfbox_f3390_0()
{    return fs.getBoolean(COSName.V, false);}
public PDEmbeddedFile pdfbox_f3391_0()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.F);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
public void pdfbox_f3392_0(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.F, file);    }}
public PDEmbeddedFile pdfbox_f3393_0()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.DOS);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
public void pdfbox_f3394_0(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.DOS, file);    }}
public PDEmbeddedFile pdfbox_f3395_0()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.MAC);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
public void pdfbox_f3396_0(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.MAC, file);    }}
public PDEmbeddedFile pdfbox_f3397_0()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.UNIX);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
public void pdfbox_f3398_0(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.UNIX, file);    }}
public PDEmbeddedFile pdfbox_f3399_0()
{    PDEmbeddedFile file = null;    COSStream stream = (COSStream) getObjectFromEFDictionary(COSName.UF);    if (stream != null) {        file = new PDEmbeddedFile(stream);    }    return file;}
public void pdfbox_f3400_0(PDEmbeddedFile file)
{    COSDictionary ef = getEFDictionary();    if (ef == null && file != null) {        ef = new COSDictionary();        fs.setItem(COSName.EF, ef);    }    if (ef != null) {        ef.setItem(COSName.UF, file);    }}
public void pdfbox_f3401_0(String description)
{    fs.setString(COSName.DESC, description);}
public String pdfbox_f3402_0()
{    return fs.getString(COSName.DESC);}
public void pdfbox_f3403_0(String mimeType)
{    getCOSObject().setName(COSName.SUBTYPE, mimeType);}
public String pdfbox_f3404_0()
{    return getCOSObject().getNameAsString(COSName.SUBTYPE);}
public int pdfbox_f3405_0()
{    return getCOSObject().getEmbeddedInt("Params", "Size");}
public void pdfbox_f3406_0(int size)
{    getCOSObject().setEmbeddedInt("Params", "Size", size);}
public Calendar pdfbox_f3407_0() throws IOException
{    return getCOSObject().getEmbeddedDate("Params", "CreationDate");}
public void pdfbox_f3408_0(Calendar creation)
{    getCOSObject().setEmbeddedDate("Params", "CreationDate", creation);}
public Calendar pdfbox_f3409_0() throws IOException
{    return getCOSObject().getEmbeddedDate("Params", "ModDate");}
public void pdfbox_f3410_0(Calendar mod)
{    getCOSObject().setEmbeddedDate("Params", "ModDate", mod);}
public String pdfbox_f3411_0()
{    return getCOSObject().getEmbeddedString("Params", "CheckSum");}
public void pdfbox_f3412_0(String checksum)
{    getCOSObject().setEmbeddedString("Params", "CheckSum", checksum);}
public String pdfbox_f3413_0()
{    String retval = null;    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params != null) {        retval = params.getEmbeddedString("Mac", "Subtype");    }    return retval;}
public void pdfbox_f3414_0(String macSubtype)
{    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params == null && macSubtype != null) {        params = new COSDictionary();        getCOSObject().setItem(COSName.PARAMS, params);    }    if (params != null) {        params.setEmbeddedString("Mac", "Subtype", macSubtype);    }}
public String pdfbox_f3415_0()
{    String retval = null;    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params != null) {        retval = params.getEmbeddedString("Mac", "Creator");    }    return retval;}
public void pdfbox_f3416_0(String macCreator)
{    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params == null && macCreator != null) {        params = new COSDictionary();        getCOSObject().setItem(COSName.PARAMS, params);    }    if (params != null) {        params.setEmbeddedString("Mac", "Creator", macCreator);    }}
public String pdfbox_f3417_0()
{    String retval = null;    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params != null) {        retval = params.getEmbeddedString("Mac", "ResFork");    }    return retval;}
public void pdfbox_f3418_0(String macResFork)
{    COSDictionary params = (COSDictionary) getCOSObject().getDictionaryObject(COSName.PARAMS);    if (params == null && macResFork != null) {        params = new COSDictionary();        getCOSObject().setItem(COSName.PARAMS, params);    }    if (params != null) {        params.setEmbeddedString("Mac", "ResFork", macResFork);    }}
public static PDFileSpecification pdfbox_f3419_0(COSBase base) throws IOException
{    PDFileSpecification retval = null;    if (base == null) {        } else if (base instanceof COSString) {        retval = new PDSimpleFileSpecification((COSString) base);    } else if (base instanceof COSDictionary) {        retval = new PDComplexFileSpecification((COSDictionary) base);    } else {        throw new IOException("Error: Unknown file specification " + base);    }    return retval;}
public String pdfbox_f3420_0()
{    return file.getString();}
public void pdfbox_f3421_0(String fileName)
{    file = new COSString(fileName);}
public COSBase pdfbox_f3422_0()
{    return file;}
public COSDictionary pdfbox_f3423_0()
{    if (functionStream != null) {        return functionStream.getCOSObject();    } else {        return functionDictionary;    }}
protected PDStream pdfbox_f3424_0()
{    return functionStream;}
public static PDFunction pdfbox_f3425_0(COSBase function) throws IOException
{    if (function == COSName.IDENTITY) {        return new PDFunctionTypeIdentity(null);    }    COSBase base = function;    if (function instanceof COSObject) {        base = ((COSObject) function).getObject();    }    if (!(base instanceof COSDictionary)) {        throw new IOException("Error: Function must be a Dictionary, but is " + base.getClass().getSimpleName());    }    COSDictionary functionDictionary = (COSDictionary) base;    int functionType = functionDictionary.getInt(COSName.FUNCTION_TYPE);    switch(functionType) {        case 0:            return new PDFunctionType0(functionDictionary);        case 2:            return new PDFunctionType2(functionDictionary);        case 3:            return new PDFunctionType3(functionDictionary);        case 4:            return new PDFunctionType4(functionDictionary);        default:            throw new IOException("Error: Unknown function type " + functionType);    }}
public int pdfbox_f3426_0()
{    if (numberOfOutputValues == -1) {        COSArray rangeValues = getRangeValues();        numberOfOutputValues = rangeValues.size() / 2;    }    return numberOfOutputValues;}
public PDRange pdfbox_f3427_0(int n)
{    COSArray rangeValues = getRangeValues();    return new PDRange(rangeValues, n);}
public void pdfbox_f3428_0(COSArray rangeValues)
{    range = rangeValues;    getCOSObject().setItem(COSName.RANGE, rangeValues);}
public int pdfbox_f3429_0()
{    if (numberOfInputValues == -1) {        COSArray array = getDomainValues();        numberOfInputValues = array.size() / 2;    }    return numberOfInputValues;}
public PDRange pdfbox_f3430_0(int n)
{    COSArray domainValues = getDomainValues();    return new PDRange(domainValues, n);}
public void pdfbox_f3431_0(COSArray domainValues)
{    domain = domainValues;    getCOSObject().setItem(COSName.DOMAIN, domainValues);}
protected COSArray pdfbox_f3432_0()
{    if (range == null) {        range = (COSArray) getCOSObject().getDictionaryObject(COSName.RANGE);    }    return range;}
private COSArray pdfbox_f3433_0()
{    if (domain == null) {        domain = (COSArray) getCOSObject().getDictionaryObject(COSName.DOMAIN);    }    return domain;}
protected float[] pdfbox_f3434_0(float[] inputValues)
{    COSArray rangesArray = getRangeValues();    float[] result;    if (rangesArray != null) {        float[] rangeValues = rangesArray.toFloatArray();        int numberOfRanges = rangeValues.length / 2;        result = new float[numberOfRanges];        for (int i = 0; i < numberOfRanges; i++) {            int index = i << 1;            result[i] = clipToRange(inputValues[i], rangeValues[index], rangeValues[index + 1]);        }    } else {        result = inputValues;    }    return result;}
protected float pdfbox_f3435_0(float x, float rangeMin, float rangeMax)
{    if (x < rangeMin) {        return rangeMin;    } else if (x > rangeMax) {        return rangeMax;    }    return x;}
protected float pdfbox_f3436_0(float x, float xRangeMin, float xRangeMax, float yRangeMin, float yRangeMax)
{    return yRangeMin + ((x - xRangeMin) * (yRangeMax - yRangeMin) / (xRangeMax - xRangeMin));}
public String pdfbox_f3437_0()
{    return "FunctionType" + getFunctionType();}
public int pdfbox_f3438_0()
{    return 0;}
public COSArray pdfbox_f3439_0()
{    if (size == null) {        size = (COSArray) getCOSObject().getDictionaryObject(COSName.SIZE);    }    return size;}
public int pdfbox_f3440_0()
{    return getCOSObject().getInt(COSName.BITS_PER_SAMPLE);}
public int pdfbox_f3441_0()
{    return getCOSObject().getInt(COSName.ORDER, 1);}
public void pdfbox_f3442_0(int bps)
{    getCOSObject().setInt(COSName.BITS_PER_SAMPLE, bps);}
private COSArray pdfbox_f3443_0()
{    if (encode == null) {        encode = (COSArray) getCOSObject().getDictionaryObject(COSName.ENCODE);                if (encode == null) {            encode = new COSArray();            COSArray sizeValues = getSize();            int sizeValuesSize = sizeValues.size();            for (int i = 0; i < sizeValuesSize; i++) {                encode.add(COSInteger.ZERO);                encode.add(COSInteger.get(sizeValues.getInt(i) - 1));            }        }    }    return encode;}
private COSArray pdfbox_f3444_0()
{    if (decode == null) {        decode = (COSArray) getCOSObject().getDictionaryObject(COSName.DECODE);                if (decode == null) {            decode = getRangeValues();        }    }    return decode;}
public PDRange pdfbox_f3445_0(int paramNum)
{    PDRange retval = null;    COSArray encodeValues = getEncodeValues();    if (encodeValues != null && encodeValues.size() >= paramNum * 2 + 1) {        retval = new PDRange(encodeValues, paramNum);    }    return retval;}
public void pdfbox_f3446_0(COSArray encodeValues)
{    encode = encodeValues;    getCOSObject().setItem(COSName.ENCODE, encodeValues);}
public PDRange pdfbox_f3447_0(int paramNum)
{    PDRange retval = null;    COSArray decodeValues = getDecodeValues();    if (decodeValues != null && decodeValues.size() >= paramNum * 2 + 1) {        retval = new PDRange(decodeValues, paramNum);    }    return retval;}
public void pdfbox_f3448_0(COSArray decodeValues)
{    decode = decodeValues;    getCOSObject().setItem(COSName.DECODE, decodeValues);}
 float[] pdfbox_f3449_0()
{    return rinterpol(new int[numberOfInputValues], 0);}
private float[] pdfbox_f3450_0(int[] coord, int step)
{    float[] resultSample = new float[numberOfOutputValues];    if (step == in.length - 1) {                if (inPrev[step] == inNext[step]) {            coord[step] = inPrev[step];            int[] tmpSample = getSamples()[calcSampleIndex(coord)];            for (int i = 0; i < numberOfOutputValues; ++i) {                resultSample[i] = tmpSample[i];            }            return resultSample;        }        coord[step] = inPrev[step];        int[] sample1 = getSamples()[calcSampleIndex(coord)];        coord[step] = inNext[step];        int[] sample2 = getSamples()[calcSampleIndex(coord)];        for (int i = 0; i < numberOfOutputValues; ++i) {            resultSample[i] = interpolate(in[step], inPrev[step], inNext[step], sample1[i], sample2[i]);        }        return resultSample;    } else {                if (inPrev[step] == inNext[step]) {            coord[step] = inPrev[step];            return rinterpol(coord, step + 1);        }        coord[step] = inPrev[step];        float[] sample1 = rinterpol(coord, step + 1);        coord[step] = inNext[step];        float[] sample2 = rinterpol(coord, step + 1);        for (int i = 0; i < numberOfOutputValues; ++i) {            resultSample[i] = interpolate(in[step], inPrev[step], inNext[step], sample1[i], sample2[i]);        }        return resultSample;    }}
private int pdfbox_f3451_0(int[] vector)
{            float[] sizeValues = getSize().toFloatArray();    int index = 0;    int sizeProduct = 1;    int dimension = vector.length;    for (int i = dimension - 2; i >= 0; --i) {        sizeProduct *= sizeValues[i];    }    for (int i = dimension - 1; i >= 0; --i) {        index += sizeProduct * vector[i];        if (i - 1 >= 0) {            sizeProduct /= sizeValues[i - 1];        }    }    return index;}
private int[][] pdfbox_f3452_1()
{    if (samples == null) {        int arraySize = 1;        int nIn = getNumberOfInputParameters();        int nOut = getNumberOfOutputParameters();        COSArray sizes = getSize();        for (int i = 0; i < nIn; i++) {            arraySize *= sizes.getInt(i);        }        samples = new int[arraySize][nOut];        int bitsPerSample = getBitsPerSample();        int index = 0;        try {                        try (ImageInputStream mciis = new MemoryCacheImageInputStream(getPDStream().createInputStream())) {                for (int i = 0; i < arraySize; i++) {                    for (int k = 0; k < nOut; k++) {                                                samples[index][k] = (int) mciis.readBits(bitsPerSample);                    }                    index++;                }            }        } catch (IOException exception) {                    }    }    return samples;}
public float[] pdfbox_f3453_0(float[] input) throws IOException
{            float[] sizeValues = getSize().toFloatArray();    int bitsPerSample = getBitsPerSample();    float maxSample = (float) (Math.pow(2, bitsPerSample) - 1.0);    int numberOfInputValues = input.length;    int numberOfOutputValues = getNumberOfOutputParameters();    int[] inputPrev = new int[numberOfInputValues];    int[] inputNext = new int[numberOfInputValues];        input = input.clone();    for (int i = 0; i < numberOfInputValues; i++) {        PDRange domain = getDomainForInput(i);        PDRange encodeValues = getEncodeForParameter(i);        input[i] = clipToRange(input[i], domain.getMin(), domain.getMax());        input[i] = interpolate(input[i], domain.getMin(), domain.getMax(), encodeValues.getMin(), encodeValues.getMax());        input[i] = clipToRange(input[i], 0, sizeValues[i] - 1);        inputPrev[i] = (int) Math.floor(input[i]);        inputNext[i] = (int) Math.ceil(input[i]);    }    float[] outputValues = new Rinterpol(input, inputPrev, inputNext).rinterpolate();    for (int i = 0; i < numberOfOutputValues; i++) {        PDRange range = getRangeForOutput(i);        PDRange decodeValues = getDecodeForParameter(i);        outputValues[i] = interpolate(outputValues[i], 0, maxSample, decodeValues.getMin(), decodeValues.getMax());        outputValues[i] = clipToRange(outputValues[i], range.getMin(), range.getMax());    }    return outputValues;}
public int pdfbox_f3454_0()
{    return 2;}
public float[] pdfbox_f3455_0(float[] input) throws IOException
{            float xToN = (float) Math.pow(input[0], exponent);    float[] result = new float[Math.min(c0.size(), c1.size())];    for (int j = 0; j < result.length; j++) {        float c0j = ((COSNumber) c0.get(j)).floatValue();        float c1j = ((COSNumber) c1.get(j)).floatValue();        result[j] = c0j + xToN * (c1j - c0j);    }    return clipToRange(result);}
public COSArray pdfbox_f3456_0()
{    return c0;}
public COSArray pdfbox_f3457_0()
{    return c1;}
public float pdfbox_f3458_0()
{    return exponent;}
public String pdfbox_f3459_0()
{    return "FunctionType2{" + "C0: " + getC0() + " " + "C1: " + getC1() + " " + "N: " + getN() + "}";}
public int pdfbox_f3460_0()
{    return 3;}
public float[] pdfbox_f3461_0(float[] input) throws IOException
{                PDFunction function = null;    float x = input[0];    PDRange domain = getDomainForInput(0);        x = clipToRange(x, domain.getMin(), domain.getMax());    if (functionsArray == null) {        COSArray ar = getFunctions();        functionsArray = new PDFunction[ar.size()];        for (int i = 0; i < ar.size(); ++i) {            functionsArray[i] = PDFunction.create(ar.getObject(i));        }    }    if (functionsArray.length == 1) {                function = functionsArray[0];        PDRange encRange = getEncodeForParameter(0);        x = interpolate(x, domain.getMin(), domain.getMax(), encRange.getMin(), encRange.getMax());    } else {        if (boundsValues == null) {            boundsValues = getBounds().toFloatArray();        }        int boundsSize = boundsValues.length;                        float[] partitionValues = new float[boundsSize + 2];        int partitionValuesSize = partitionValues.length;        partitionValues[0] = domain.getMin();        partitionValues[partitionValuesSize - 1] = domain.getMax();        System.arraycopy(boundsValues, 0, partitionValues, 1, boundsSize);                for (int i = 0; i < partitionValuesSize - 1; i++) {            if (x >= partitionValues[i] && (x < partitionValues[i + 1] || (i == partitionValuesSize - 2 && Float.compare(x, partitionValues[i + 1]) == 0))) {                function = functionsArray[i];                PDRange encRange = getEncodeForParameter(i);                x = interpolate(x, partitionValues[i], partitionValues[i + 1], encRange.getMin(), encRange.getMax());                break;            }        }        if (function == null) {            throw new IOException("partition not found in type 3 function");        }    }    float[] functionValues = new float[] { x };        float[] functionResult = function.eval(functionValues);        return clipToRange(functionResult);}
public COSArray pdfbox_f3462_0()
{    if (functions == null) {        functions = (COSArray) (getCOSObject().getDictionaryObject(COSName.FUNCTIONS));    }    return functions;}
public COSArray pdfbox_f3463_0()
{    if (bounds == null) {        bounds = (COSArray) (getCOSObject().getDictionaryObject(COSName.BOUNDS));    }    return bounds;}
public COSArray pdfbox_f3464_0()
{    if (encode == null) {        encode = (COSArray) (getCOSObject().getDictionaryObject(COSName.ENCODE));    }    return encode;}
private PDRange pdfbox_f3465_0(int n)
{    COSArray encodeValues = getEncode();    return new PDRange(encodeValues, n);}
public int pdfbox_f3466_0()
{    return 4;}
public float[] pdfbox_f3467_0(float[] input) throws IOException
{        ExecutionContext context = new ExecutionContext(OPERATORS);    for (int i = 0; i < input.length; i++) {        PDRange domain = getDomainForInput(i);        float value = clipToRange(input[i], domain.getMin(), domain.getMax());        context.getStack().push(value);    }        instructions.execute(context);        int numberOfOutputValues = getNumberOfOutputParameters();    int numberOfActualOutputValues = context.getStack().size();    if (numberOfActualOutputValues < numberOfOutputValues) {        throw new IllegalStateException("The type 4 function returned " + numberOfActualOutputValues + " values but the Range entry indicates that " + numberOfOutputValues + " values be returned.");    }    float[] outputValues = new float[numberOfOutputValues];    for (int i = numberOfOutputValues - 1; i >= 0; i--) {        PDRange range = getRangeForOutput(i);        outputValues[i] = context.popReal();        outputValues[i] = clipToRange(outputValues[i], range.getMin(), range.getMax());    }        return outputValues;}
public int pdfbox_f3468_0()
{        throw new UnsupportedOperationException();}
public float[] pdfbox_f3469_0(float[] input) throws IOException
{    return input;}
public String pdfbox_f3470_0()
{    return "FunctionTypeIdentity";}
public void pdfbox_f3471_0(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(Math.abs(num.intValue()));    } else {        context.getStack().push(Math.abs(num.floatValue()));    }}
public void pdfbox_f3472_0(ExecutionContext context)
{    Number num2 = context.popNumber();    Number num1 = context.popNumber();    if (num1 instanceof Integer && num2 instanceof Integer) {        long sum = num1.longValue() + num2.longValue();        if (sum < Integer.MIN_VALUE || sum > Integer.MAX_VALUE) {            context.getStack().push((float) sum);        } else {            context.getStack().push((int) sum);        }    } else {        float sum = num1.floatValue() + num2.floatValue();        context.getStack().push(sum);    }}
public void pdfbox_f3473_0(ExecutionContext context)
{    float den = context.popReal();    float num = context.popReal();    float atan = (float) Math.atan2(num, den);    atan = (float) Math.toDegrees(atan) % 360;    if (atan < 0) {        atan = atan + 360;    }    context.getStack().push(atan);}
public void pdfbox_f3474_0(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num);    } else {        context.getStack().push((float) Math.ceil(num.doubleValue()));    }}
public void pdfbox_f3475_0(ExecutionContext context)
{    float angle = context.popReal();    float cos = (float) Math.cos(Math.toRadians(angle));    context.getStack().push(cos);}
public void pdfbox_f3476_0(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push(num.intValue());}
public void pdfbox_f3477_0(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push(num.floatValue());}
public void pdfbox_f3478_0(ExecutionContext context)
{    Number num2 = context.popNumber();    Number num1 = context.popNumber();    context.getStack().push(num1.floatValue() / num2.floatValue());}
public void pdfbox_f3479_0(ExecutionContext context)
{    Number exp = context.popNumber();    Number base = context.popNumber();    double value = Math.pow(base.doubleValue(), exp.doubleValue());    context.getStack().push((float) value);}
public void pdfbox_f3480_0(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num);    } else {        context.getStack().push((float) Math.floor(num.doubleValue()));    }}
public void pdfbox_f3481_0(ExecutionContext context)
{    int num2 = context.popInt();    int num1 = context.popInt();    context.getStack().push(num1 / num2);}
public void pdfbox_f3482_0(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push((float) Math.log(num.doubleValue()));}
public void pdfbox_f3483_0(ExecutionContext context)
{    Number num = context.popNumber();    context.getStack().push((float) Math.log10(num.doubleValue()));}
public void pdfbox_f3484_0(ExecutionContext context)
{    int int2 = context.popInt();    int int1 = context.popInt();    context.getStack().push(int1 % int2);}
public void pdfbox_f3485_0(ExecutionContext context)
{    Number num2 = context.popNumber();    Number num1 = context.popNumber();    if (num1 instanceof Integer && num2 instanceof Integer) {        long result = num1.longValue() * num2.longValue();        if (result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE) {            context.getStack().push((int) result);        } else {            context.getStack().push((float) result);        }    } else {        double result = num1.doubleValue() * num2.doubleValue();        context.getStack().push((float) result);    }}
public void pdfbox_f3486_0(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        int v = num.intValue();        if (v == Integer.MIN_VALUE) {            context.getStack().push(-num.floatValue());        } else {            context.getStack().push(-num.intValue());        }    } else {        context.getStack().push(-num.floatValue());    }}
public void pdfbox_f3487_0(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num.intValue());    } else {        context.getStack().push((float) Math.round(num.doubleValue()));    }}
public void pdfbox_f3488_0(ExecutionContext context)
{    float angle = context.popReal();    float sin = (float) Math.sin(Math.toRadians(angle));    context.getStack().push(sin);}
public void pdfbox_f3489_0(ExecutionContext context)
{    float num = context.popReal();    if (num < 0) {        throw new IllegalArgumentException("argument must be nonnegative");    }    context.getStack().push((float) Math.sqrt(num));}
public void pdfbox_f3490_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Number num2 = context.popNumber();    Number num1 = context.popNumber();    if (num1 instanceof Integer && num2 instanceof Integer) {        long result = num1.longValue() - num2.longValue();        if (result < Integer.MIN_VALUE || result > Integer.MAX_VALUE) {            stack.push((float) result);        } else {            stack.push((int) result);        }    } else {        float result = num1.floatValue() - num2.floatValue();        stack.push(result);    }}
public void pdfbox_f3491_0(ExecutionContext context)
{    Number num = context.popNumber();    if (num instanceof Integer) {        context.getStack().push(num.intValue());    } else {        context.getStack().push((float) (int) (num.floatValue()));    }}
public void pdfbox_f3492_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op2 = stack.pop();    Object op1 = stack.pop();    if (op1 instanceof Boolean && op2 instanceof Boolean) {        boolean bool1 = (Boolean) op1;        boolean bool2 = (Boolean) op2;        boolean result = applyForBoolean(bool1, bool2);        stack.push(result);    } else if (op1 instanceof Integer && op2 instanceof Integer) {        int int1 = (Integer) op1;        int int2 = (Integer) op2;        int result = applyforInteger(int1, int2);        stack.push(result);    } else {        throw new ClassCastException("Operands must be bool/bool or int/int");    }}
protected boolean pdfbox_f3493_0(boolean bool1, boolean bool2)
{    return bool1 && bool2;}
protected int pdfbox_f3494_0(int int1, int int2)
{    return int1 & int2;}
public void pdfbox_f3495_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int shift = (Integer) stack.pop();    int int1 = (Integer) stack.pop();    if (shift < 0) {        int result = int1 >> Math.abs(shift);        stack.push(result);    } else {        int result = int1 << shift;        stack.push(result);    }}
public void pdfbox_f3496_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.push(Boolean.FALSE);}
public void pdfbox_f3497_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op1 = stack.pop();    if (op1 instanceof Boolean) {        boolean bool1 = (Boolean) op1;        boolean result = !bool1;        stack.push(result);    } else if (op1 instanceof Integer) {        int int1 = (Integer) op1;        int result = -int1;        stack.push(result);    } else {        throw new ClassCastException("Operand must be bool or int");    }}
protected boolean pdfbox_f3498_0(boolean bool1, boolean bool2)
{    return bool1 || bool2;}
protected int pdfbox_f3499_0(int int1, int int2)
{    return int1 | int2;}
public void pdfbox_f3500_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.push(Boolean.TRUE);}
protected boolean pdfbox_f3501_0(boolean bool1, boolean bool2)
{    return bool1 ^ bool2;}
protected int pdfbox_f3502_0(int int1, int int2)
{    return int1 ^ int2;}
public void pdfbox_f3503_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    InstructionSequence proc = (InstructionSequence) stack.pop();    Boolean condition = (Boolean) stack.pop();    if (condition) {        proc.execute(context);    }}
public void pdfbox_f3504_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    InstructionSequence proc2 = (InstructionSequence) stack.pop();    InstructionSequence proc1 = (InstructionSequence) stack.pop();    Boolean condition = (Boolean) stack.pop();    if (condition) {        proc1.execute(context);    } else {        proc2.execute(context);    }}
public Stack<Object> pdfbox_f3505_0()
{    return this.stack;}
public Operators pdfbox_f3506_0()
{    return this.operators;}
public Number pdfbox_f3507_0()
{    return (Number) stack.pop();}
public int pdfbox_f3508_0()
{    return (Integer) stack.pop();}
public float pdfbox_f3509_0()
{    return ((Number) stack.pop()).floatValue();}
public void pdfbox_f3510_0(String name)
{    this.instructions.add(name);}
public void pdfbox_f3511_0(int value)
{    this.instructions.add(value);}
public void pdfbox_f3512_0(float value)
{    this.instructions.add(value);}
public void pdfbox_f3513_0(boolean value)
{    this.instructions.add(value);}
public void pdfbox_f3514_0(InstructionSequence child)
{    this.instructions.add(child);}
public void pdfbox_f3515_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    for (Object o : instructions) {        if (o instanceof String) {            String name = (String) o;            Operator cmd = context.getOperators().getOperator(name);            if (cmd != null) {                cmd.execute(context);            } else {                throw new UnsupportedOperationException("Unknown operator or name: " + name);            }        } else {            stack.push(o);        }    }        while (!stack.isEmpty() && stack.peek() instanceof InstructionSequence) {        InstructionSequence nested = (InstructionSequence) stack.pop();        nested.execute(context);    }}
public InstructionSequence pdfbox_f3516_0()
{    return this.mainSequence;}
public static InstructionSequence pdfbox_f3517_0(CharSequence text)
{    InstructionSequenceBuilder builder = new InstructionSequenceBuilder();    Parser.parse(text, builder);    return builder.getInstructionSequence();}
private InstructionSequence pdfbox_f3518_0()
{    return this.seqStack.peek();}
public void pdfbox_f3519_0(CharSequence text)
{    String token = text.toString();    token(token);}
private void pdfbox_f3520_0(String token)
{    if ("{".equals(token)) {        InstructionSequence child = new InstructionSequence();        getCurrentSequence().addProc(child);        this.seqStack.push(child);    } else if ("}".equals(token)) {        this.seqStack.pop();    } else {        Matcher m = INTEGER_PATTERN.matcher(token);        if (m.matches()) {            getCurrentSequence().addInteger(parseInt(token));            return;        }        m = REAL_PATTERN.matcher(token);        if (m.matches()) {            getCurrentSequence().addReal(parseReal(token));            return;        }                getCurrentSequence().addName(token);    }}
public static int pdfbox_f3521_0(String token)
{    return Integer.parseInt(token);}
public static float pdfbox_f3522_0(String token)
{    return Float.parseFloat(token);}
public Operator pdfbox_f3523_0(String operatorName)
{    return this.operators.get(operatorName);}
public static void pdfbox_f3524_0(CharSequence input, SyntaxHandler handler)
{    Tokenizer tokenizer = new Tokenizer(input, handler);    tokenizer.tokenize();}
public void pdfbox_f3525_0(CharSequence text)
{}
public void pdfbox_f3526_0(CharSequence text)
{}
public void pdfbox_f3527_0(CharSequence text)
{}
private boolean pdfbox_f3528_0()
{    return index < input.length();}
private char pdfbox_f3529_0()
{    return input.charAt(index);}
private char pdfbox_f3530_0()
{    index++;    if (!hasMore()) {        return EOT;    } else {        return currentChar();    }}
private char pdfbox_f3531_0()
{    if (index < input.length() - 1) {        return input.charAt(index + 1);    } else {        return EOT;    }}
private State pdfbox_f3532_0()
{    char ch = currentChar();    switch(ch) {        case CR:        case LF:        case         FF:            state = State.NEWLINE;            break;        case NUL:        case TAB:        case SPACE:            state = State.WHITESPACE;            break;        case '%':            state = State.COMMENT;            break;        default:            state = State.TOKEN;    }    return state;}
private void pdfbox_f3533_0()
{    while (hasMore()) {        buffer.setLength(0);        nextState();        switch(state) {            case NEWLINE:                scanNewLine();                break;            case WHITESPACE:                scanWhitespace();                break;            case COMMENT:                scanComment();                break;            default:                scanToken();        }    }}
private void pdfbox_f3534_0()
{    assert state == State.NEWLINE;    char ch = currentChar();    buffer.append(ch);    if (ch == CR && peek() == LF) {                buffer.append(nextChar());    }    handler.newLine(buffer);    nextChar();}
private void pdfbox_f3535_0()
{    assert state == State.WHITESPACE;    buffer.append(currentChar());    loop: while (hasMore()) {        char ch = nextChar();        switch(ch) {            case NUL:            case TAB:            case SPACE:                buffer.append(ch);                break;            default:                break loop;        }    }    handler.whitespace(buffer);}
private void pdfbox_f3536_0()
{    assert state == State.COMMENT;    buffer.append(currentChar());    loop: while (hasMore()) {        char ch = nextChar();        switch(ch) {            case CR:            case LF:            case FF:                break loop;            default:                buffer.append(ch);        }    }        handler.comment(buffer);}
private void pdfbox_f3537_0()
{    assert state == State.TOKEN;    char ch = currentChar();    buffer.append(ch);    switch(ch) {        case '{':        case '}':            handler.token(buffer);            nextChar();            return;        default:    }    loop: while (hasMore()) {        ch = nextChar();        switch(ch) {            case NUL:            case TAB:            case SPACE:            case CR:            case LF:            case FF:            case EOT:            case '{':            case '}':                break loop;            default:                buffer.append(ch);        }    }        handler.token(buffer);}
public void pdfbox_f3538_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op2 = stack.pop();    Object op1 = stack.pop();    boolean result = isEqual(op1, op2);    stack.push(result);}
protected boolean pdfbox_f3539_0(Object op1, Object op2)
{    boolean result;    if (op1 instanceof Number && op2 instanceof Number) {        Number num1 = (Number) op1;        Number num2 = (Number) op2;        result = Float.compare(num1.floatValue(), num2.floatValue()) == 0;    } else {        result = op1.equals(op2);    }    return result;}
public void pdfbox_f3540_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object op2 = stack.pop();    Object op1 = stack.pop();    Number num1 = (Number) op1;    Number num2 = (Number) op2;    boolean result = compare(num1, num2);    stack.push(result);}
protected boolean pdfbox_f3541_0(Number num1, Number num2)
{    return num1.floatValue() >= num2.floatValue();}
protected boolean pdfbox_f3542_0(Number num1, Number num2)
{    return num1.floatValue() > num2.floatValue();}
protected boolean pdfbox_f3543_0(Number num1, Number num2)
{    return num1.floatValue() <= num2.floatValue();}
protected boolean pdfbox_f3544_0(Number num1, Number num2)
{    return num1.floatValue() < num2.floatValue();}
protected boolean pdfbox_f3545_0(Object op1, Object op2)
{    boolean result = super.isEqual(op1, op2);    return !result;}
public void pdfbox_f3546_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int n = ((Number) stack.pop()).intValue();    if (n > 0) {        int size = stack.size();                List<Object> copy = new java.util.ArrayList<>(stack.subList(size - n, size));        stack.addAll(copy);    }}
public void pdfbox_f3547_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.push(stack.peek());}
public void pdfbox_f3548_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    Object any2 = stack.pop();    Object any1 = stack.pop();    stack.push(any2);    stack.push(any1);}
public void pdfbox_f3549_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int n = ((Number) stack.pop()).intValue();    if (n < 0) {        throw new IllegalArgumentException("rangecheck: " + n);    }    int size = stack.size();    stack.push(stack.get(size - n - 1));}
public void pdfbox_f3550_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    stack.pop();}
public void pdfbox_f3551_0(ExecutionContext context)
{    Stack<Object> stack = context.getStack();    int j = ((Number) stack.pop()).intValue();    int n = ((Number) stack.pop()).intValue();    if (j == 0) {                return;    }    if (n < 0) {        throw new IllegalArgumentException("rangecheck: " + n);    }    LinkedList<Object> rolled = new LinkedList<>();    LinkedList<Object> moved = new LinkedList<>();    if (j < 0) {                int n1 = n + j;        for (int i = 0; i < n1; i++) {            moved.addFirst(stack.pop());        }        for (int i = j; i < 0; i++) {            rolled.addFirst(stack.pop());        }        stack.addAll(moved);        stack.addAll(rolled);    } else {                int n1 = n - j;        for (int i = j; i > 0; i--) {            rolled.addFirst(stack.pop());        }        for (int i = 0; i < n1; i++) {            moved.addFirst(stack.pop());        }        stack.addAll(rolled);        stack.addAll(moved);    }}
public COSDictionary pdfbox_f3552_0()
{    return this.dictionary;}
public boolean pdfbox_f3553_0(Object obj)
{    if (this == obj) {        return true;    }    if (obj instanceof PDDictionaryWrapper) {        return this.dictionary.equals(((PDDictionaryWrapper) obj).dictionary);    }    return false;}
public int pdfbox_f3554_0()
{    return this.dictionary.hashCode();}
public InputStream pdfbox_f3555_0() throws IOException
{    return createInputStream();}
public void pdfbox_f3556_0(byte[] xmp) throws IOException
{    try (OutputStream os = createOutputStream()) {        os.write(xmp);    }}
public COSDictionary pdfbox_f3557_0()
{    return node;}
public PDNameTreeNode<T> pdfbox_f3558_0()
{    return parent;}
public void pdfbox_f3559_0(PDNameTreeNode<T> parentNode)
{    parent = parentNode;    calculateLimits();}
public boolean pdfbox_f3560_0()
{    return parent == null;}
public List<PDNameTreeNode<T>> pdfbox_f3561_0()
{    List<PDNameTreeNode<T>> retval = null;    COSArray kids = (COSArray) node.getDictionaryObject(COSName.KIDS);    if (kids != null) {        List<PDNameTreeNode<T>> pdObjects = new ArrayList<>();        for (int i = 0; i < kids.size(); i++) {            pdObjects.add(createChildNode((COSDictionary) kids.getObject(i)));        }        retval = new COSArrayList<>(pdObjects, kids);    }    return retval;}
public void pdfbox_f3562_0(List<? extends PDNameTreeNode<T>> kids)
{    if (kids != null && kids.size() > 0) {        for (PDNameTreeNode<T> kidsNode : kids) {            kidsNode.setParent(this);        }        node.setItem(COSName.KIDS, COSArrayList.converterToCOSArray(kids));                if (isRootNode()) {            node.setItem(COSName.NAMES, null);        }    } else {                node.setItem(COSName.KIDS, null);                node.setItem(COSName.LIMITS, null);    }    calculateLimits();}
private void pdfbox_f3563_1()
{    if (isRootNode()) {        node.setItem(COSName.LIMITS, null);    } else {        List<PDNameTreeNode<T>> kids = getKids();        if (kids != null && kids.size() > 0) {            PDNameTreeNode<T> firstKid = kids.get(0);            PDNameTreeNode<T> lastKid = kids.get(kids.size() - 1);            String lowerLimit = firstKid.getLowerLimit();            setLowerLimit(lowerLimit);            String upperLimit = lastKid.getUpperLimit();            setUpperLimit(upperLimit);        } else {            try {                Map<String, T> names = getNames();                if (names != null && names.size() > 0) {                    Set<String> strings = names.keySet();                    String[] keys = strings.toArray(new String[strings.size()]);                    String lowerLimit = keys[0];                    setLowerLimit(lowerLimit);                    String upperLimit = keys[keys.length - 1];                    setUpperLimit(upperLimit);                } else {                    node.setItem(COSName.LIMITS, null);                }            } catch (IOException exception) {                node.setItem(COSName.LIMITS, null);                            }        }    }}
public T pdfbox_f3564_1(String name) throws IOException
{    T retval = null;    Map<String, T> names = getNames();    if (names != null) {        retval = names.get(name);    } else {        List<PDNameTreeNode<T>> kids = getKids();        if (kids != null) {            for (int i = 0; i < kids.size() && retval == null; i++) {                PDNameTreeNode<T> childNode = kids.get(i);                String upperLimit = childNode.getUpperLimit();                String lowerLimit = childNode.getLowerLimit();                if (upperLimit == null || lowerLimit == null || upperLimit.compareTo(lowerLimit) < 0 || (lowerLimit.compareTo(name) <= 0 && upperLimit.compareTo(name) >= 0)) {                    retval = childNode.getValue(name);                }            }        } else {                    }    }    return retval;}
public Map<String, T> pdfbox_f3565_0() throws IOException
{    COSArray namesArray = (COSArray) node.getDictionaryObject(COSName.NAMES);    if (namesArray != null) {        Map<String, T> names = new LinkedHashMap<>();        for (int i = 0; i < namesArray.size(); i += 2) {            COSString key = (COSString) namesArray.getObject(i);            COSBase cosValue = namesArray.getObject(i + 1);            names.put(key.getString(), convertCOSToPD(cosValue));        }        return Collections.unmodifiableMap(names);    } else {        return null;    }}
public void pdfbox_f3566_0(Map<String, T> names)
{    if (names == null) {        node.setItem(COSName.NAMES, (COSObjectable) null);        node.setItem(COSName.LIMITS, (COSObjectable) null);    } else {        COSArray array = new COSArray();        List<String> keys = new ArrayList<>(names.keySet());        Collections.sort(keys);        for (String key : keys) {            array.add(new COSString(key));            array.add(names.get(key));        }        node.setItem(COSName.NAMES, array);        calculateLimits();    }}
public String pdfbox_f3567_0()
{    String retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null) {        retval = arr.getString(1);    }    return retval;}
private void pdfbox_f3568_0(String upper)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    arr.setString(1, upper);}
public String pdfbox_f3569_0()
{    String retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null) {        retval = arr.getString(0);    }    return retval;}
private void pdfbox_f3570_0(String lower)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    arr.setString(0, lower);}
public COSDictionary pdfbox_f3571_0()
{    return node;}
public List<PDNumberTreeNode> pdfbox_f3572_0()
{    List<PDNumberTreeNode> retval = null;    COSArray kids = (COSArray) node.getDictionaryObject(COSName.KIDS);    if (kids != null) {        List<PDNumberTreeNode> pdObjects = new ArrayList<>();        for (int i = 0; i < kids.size(); i++) {            pdObjects.add(createChildNode((COSDictionary) kids.getObject(i)));        }        retval = new COSArrayList<>(pdObjects, kids);    }    return retval;}
public void pdfbox_f3573_0(List<? extends PDNumberTreeNode> kids)
{    if (kids != null && !kids.isEmpty()) {        PDNumberTreeNode firstKid = kids.get(0);        PDNumberTreeNode lastKid = kids.get(kids.size() - 1);        Integer lowerLimit = firstKid.getLowerLimit();        this.setLowerLimit(lowerLimit);        Integer upperLimit = lastKid.getUpperLimit();        this.setUpperLimit(upperLimit);    } else if (node.getDictionaryObject(COSName.NUMS) == null) {                node.setItem(COSName.LIMITS, null);    }    node.setItem(COSName.KIDS, COSArrayList.converterToCOSArray(kids));}
public Object pdfbox_f3574_1(Integer index) throws IOException
{    Map<Integer, COSObjectable> numbers = getNumbers();    if (numbers != null) {        return numbers.get(index);    }    Object retval = null;    List<PDNumberTreeNode> kids = getKids();    if (kids != null) {        for (int i = 0; i < kids.size() && retval == null; i++) {            PDNumberTreeNode childNode = kids.get(i);            if (childNode.getLowerLimit().compareTo(index) <= 0 && childNode.getUpperLimit().compareTo(index) >= 0) {                retval = childNode.getValue(index);            }        }    } else {            }    return retval;}
public Map<Integer, COSObjectable> pdfbox_f3575_1() throws IOException
{    Map<Integer, COSObjectable> indices = null;    COSBase numBase = node.getDictionaryObject(COSName.NUMS);    if (numBase instanceof COSArray) {        COSArray numbersArray = (COSArray) numBase;        indices = new HashMap<>();        for (int i = 0; i < numbersArray.size(); i += 2) {            COSBase base = numbersArray.getObject(i);            if (!(base instanceof COSInteger)) {                                return null;            }            COSInteger key = (COSInteger) base;            COSBase cosValue = numbersArray.getObject(i + 1);            indices.put(key.intValue(), cosValue == null ? null : convertCOSToPD(cosValue));        }        indices = Collections.unmodifiableMap(indices);    }    return indices;}
protected COSObjectable pdfbox_f3576_0(COSBase base) throws IOException
{        try {        return valueType.getDeclaredConstructor(base.getClass()).newInstance(base);    } catch (Exception t) {        throw new IOException("Error while trying to create value in number tree:" + t.getMessage(), t);    }}
protected PDNumberTreeNode pdfbox_f3577_0(COSDictionary dic)
{    return new PDNumberTreeNode(dic, valueType);}
public void pdfbox_f3578_0(Map<Integer, ? extends COSObjectable> numbers)
{    if (numbers == null) {        node.setItem(COSName.NUMS, (COSObjectable) null);        node.setItem(COSName.LIMITS, (COSObjectable) null);    } else {        List<Integer> keys = new ArrayList<>(numbers.keySet());        Collections.sort(keys);        COSArray array = new COSArray();        for (Integer key : keys) {            array.add(COSInteger.get(key));            COSObjectable obj = numbers.get(key);            array.add(obj == null ? COSNull.NULL : obj);        }        Integer lower = null;        Integer upper = null;        if (!keys.isEmpty()) {            lower = keys.get(0);            upper = keys.get(keys.size() - 1);        }        setUpperLimit(upper);        setLowerLimit(lower);        node.setItem(COSName.NUMS, array);    }}
public Integer pdfbox_f3579_0()
{    Integer retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null && arr.get(0) != null) {        retval = arr.getInt(1);    }    return retval;}
private void pdfbox_f3580_0(Integer upper)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    if (upper != null) {        arr.setInt(1, upper);    } else {        arr.set(1, null);    }}
public Integer pdfbox_f3581_0()
{    Integer retval = null;    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr != null && arr.get(0) != null) {        retval = arr.getInt(0);    }    return retval;}
private void pdfbox_f3582_0(Integer lower)
{    COSArray arr = (COSArray) node.getDictionaryObject(COSName.LIMITS);    if (arr == null) {        arr = new COSArray();        arr.add(null);        arr.add(null);        node.setItem(COSName.LIMITS, arr);    }    if (lower != null) {        arr.setInt(0, lower);    } else {        arr.set(0, null);    }}
public static PDObjectStream pdfbox_f3583_0(PDDocument document)
{    COSStream cosStream = document.getDocument().createCOSStream();    PDObjectStream strm = new PDObjectStream(cosStream);    strm.getCOSObject().setItem(COSName.TYPE, COSName.OBJ_STM);    return strm;}
public String pdfbox_f3584_0()
{    return getCOSObject().getNameAsString(COSName.TYPE);}
public int pdfbox_f3585_0()
{    return getCOSObject().getInt(COSName.N, 0);}
public void pdfbox_f3586_0(int n)
{    getCOSObject().setInt(COSName.N, n);}
public int pdfbox_f3587_0()
{    return getCOSObject().getInt(COSName.FIRST, 0);}
public void pdfbox_f3588_0(int n)
{    getCOSObject().setInt(COSName.FIRST, n);}
public PDObjectStream pdfbox_f3589_0()
{    PDObjectStream retval = null;    COSStream stream = (COSStream) getCOSObject().getDictionaryObject(COSName.EXTENDS);    if (stream != null) {        retval = new PDObjectStream(stream);    }    return retval;}
public void pdfbox_f3590_0(PDObjectStream stream)
{    getCOSObject().setItem(COSName.EXTENDS, stream);}
public COSDictionary pdfbox_f3591_0()
{    return root;}
public String pdfbox_f3592_0()
{    return root.getNameAsString(KEY_STYLE);}
public void pdfbox_f3593_0(String style)
{    if (style != null) {        root.setName(KEY_STYLE, style);    } else {        root.removeItem(KEY_STYLE);    }}
public int pdfbox_f3594_0()
{    return root.getInt(KEY_START, 1);}
public void pdfbox_f3595_0(int start)
{    if (start <= 0) {        throw new IllegalArgumentException("The page numbering start value must be a positive integer");    }    root.setInt(KEY_START, start);}
public String pdfbox_f3596_0()
{    return root.getString(KEY_PREFIX);}
public void pdfbox_f3597_0(String prefix)
{    if (prefix != null) {        root.setString(KEY_PREFIX, prefix);    } else {        root.removeItem(KEY_PREFIX);    }}
private void pdfbox_f3598_0(PDNumberTreeNode node) throws IOException
{    if (node.getKids() != null) {        List<PDNumberTreeNode> kids = node.getKids();        for (PDNumberTreeNode kid : kids) {            findLabels(kid);        }    } else if (node.getNumbers() != null) {        Map<Integer, COSObjectable> numbers = node.getNumbers();        for (Entry<Integer, COSObjectable> i : numbers.entrySet()) {            if (i.getKey() >= 0) {                labels.put(i.getKey(), (PDPageLabelRange) i.getValue());            }        }    }}
public int pdfbox_f3599_0()
{    return labels.size();}
public PDPageLabelRange pdfbox_f3600_0(int startPage)
{    return labels.get(startPage);}
public void pdfbox_f3601_0(int startPage, PDPageLabelRange item)
{    if (startPage < 0) {        throw new IllegalArgumentException("startPage parameter of setLabelItem may not be < 0");    }    labels.put(startPage, item);}
public COSBase pdfbox_f3602_0()
{    COSDictionary dict = new COSDictionary();    COSArray arr = new COSArray();    for (Entry<Integer, PDPageLabelRange> i : labels.entrySet()) {        arr.add(COSInteger.get(i.getKey()));        arr.add(i.getValue());    }    dict.setItem(COSName.NUMS, arr);    return dict;}
public Map<String, Integer> pdfbox_f3603_0()
{    final Map<String, Integer> labelMap = new HashMap<>(doc.getNumberOfPages());    computeLabels((pageIndex, label) -> labelMap.put(label, pageIndex));    return labelMap;}
public String[] pdfbox_f3604_0()
{    final String[] map = new String[doc.getNumberOfPages()];    computeLabels((pageIndex, label) -> {        if (pageIndex < doc.getNumberOfPages()) {            map[pageIndex] = label;        }    });    return map;}
public NavigableSet<Integer> pdfbox_f3605_0()
{    return new TreeSet<>(labels.keySet());}
private void pdfbox_f3606_0(LabelHandler handler)
{    Iterator<Entry<Integer, PDPageLabelRange>> iterator = labels.entrySet().iterator();    if (!iterator.hasNext()) {        return;    }    int pageIndex = 0;    Entry<Integer, PDPageLabelRange> lastEntry = iterator.next();    while (iterator.hasNext()) {        Entry<Integer, PDPageLabelRange> entry = iterator.next();        int numPages = entry.getKey() - lastEntry.getKey();        LabelGenerator gen = new LabelGenerator(lastEntry.getValue(), numPages);        while (gen.hasNext()) {            handler.newLabel(pageIndex, gen.next());            pageIndex++;        }        lastEntry = entry;    }    LabelGenerator gen = new LabelGenerator(lastEntry.getValue(), doc.getNumberOfPages() - lastEntry.getKey());    while (gen.hasNext()) {        handler.newLabel(pageIndex, gen.next());        pageIndex++;    }}
public boolean pdfbox_f3607_0()
{    return currentPage < numPages;}
public String pdfbox_f3608_0()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    StringBuilder buf = new StringBuilder();    if (labelInfo.getPrefix() != null) {        String label = labelInfo.getPrefix();                while (label.lastIndexOf(0) != -1) {            label = label.substring(0, label.length() - 1);        }        buf.append(label);    }    if (labelInfo.getStyle() != null) {        buf.append(getNumber(labelInfo.getStart() + currentPage, labelInfo.getStyle()));    }    currentPage++;    return buf.toString();}
private String pdfbox_f3609_0(int pageIndex, String style)
{    if (style != null) {        switch(style) {            case PDPageLabelRange.STYLE_DECIMAL:                return Integer.toString(pageIndex);            case PDPageLabelRange.STYLE_LETTERS_LOWER:                return makeLetterLabel(pageIndex);            case PDPageLabelRange.STYLE_LETTERS_UPPER:                return makeLetterLabel(pageIndex).toUpperCase();            case PDPageLabelRange.STYLE_ROMAN_LOWER:                return makeRomanLabel(pageIndex);            case PDPageLabelRange.STYLE_ROMAN_UPPER:                return makeRomanLabel(pageIndex).toUpperCase();            default:                break;        }    }        return Integer.toString(pageIndex);}
private static String pdfbox_f3610_0(int pageIndex)
{    StringBuilder buf = new StringBuilder();    int power = 0;    while (power < 3 && pageIndex > 0) {        buf.insert(0, ROMANS[power][pageIndex % 10]);        pageIndex /= 10;        power++;    }        for (int i = 0; i < pageIndex; i++) {        buf.insert(0, 'm');    }    return buf.toString();}
private static String pdfbox_f3611_0(int num)
{    StringBuilder buf = new StringBuilder();    int numLetters = num / 26 + Integer.signum(num % 26);    int letter = num % 26 + 26 * (1 - Integer.signum(num % 26)) + 'a' - 1;    for (int i = 0; i < numLetters; i++) {        buf.appendCodePoint(letter);    }    return buf.toString();}
public void pdfbox_f3612_0()
{        throw new UnsupportedOperationException();}
public COSBase pdfbox_f3613_0()
{    return rangeArray;}
public COSArray pdfbox_f3614_0()
{    return rangeArray;}
public float pdfbox_f3615_0()
{    COSNumber min = (COSNumber) rangeArray.getObject(startingIndex * 2);    return min.floatValue();}
public void pdfbox_f3616_0(float min)
{    rangeArray.set(startingIndex * 2, new COSFloat(min));}
public float pdfbox_f3617_0()
{    COSNumber max = (COSNumber) rangeArray.getObject(startingIndex * 2 + 1);    return max.floatValue();}
public void pdfbox_f3618_0(float max)
{    rangeArray.set(startingIndex * 2 + 1, new COSFloat(max));}
public String pdfbox_f3619_0()
{    return "PDRange{" + getMin() + ", " + getMax() + '}';}
public boolean pdfbox_f3620_0(float x, float y)
{    float llx = getLowerLeftX();    float urx = getUpperRightX();    float lly = getLowerLeftY();    float ury = getUpperRightY();    return x >= llx && x <= urx && y >= lly && y <= ury;}
public PDRectangle pdfbox_f3621_0()
{    PDRectangle retval = new PDRectangle();    retval.setUpperRightX(getWidth());    retval.setUpperRightY(getHeight());    return retval;}
public COSArray pdfbox_f3622_0()
{    return rectArray;}
public float pdfbox_f3623_0()
{    return ((COSNumber) rectArray.get(0)).floatValue();}
public void pdfbox_f3624_0(float value)
{    rectArray.set(0, new COSFloat(value));}
public float pdfbox_f3625_0()
{    return ((COSNumber) rectArray.get(1)).floatValue();}
public void pdfbox_f3626_0(float value)
{    rectArray.set(1, new COSFloat(value));}
public float pdfbox_f3627_0()
{    return ((COSNumber) rectArray.get(2)).floatValue();}
public void pdfbox_f3628_0(float value)
{    rectArray.set(2, new COSFloat(value));}
public float pdfbox_f3629_0()
{    return ((COSNumber) rectArray.get(3)).floatValue();}
public void pdfbox_f3630_0(float value)
{    rectArray.set(3, new COSFloat(value));}
public float pdfbox_f3631_0()
{    return getUpperRightX() - getLowerLeftX();}
public float pdfbox_f3632_0()
{    return getUpperRightY() - getLowerLeftY();}
public GeneralPath pdfbox_f3633_0(Matrix matrix)
{    float x1 = getLowerLeftX();    float y1 = getLowerLeftY();    float x2 = getUpperRightX();    float y2 = getUpperRightY();    Point2D.Float p0 = matrix.transformPoint(x1, y1);    Point2D.Float p1 = matrix.transformPoint(x2, y1);    Point2D.Float p2 = matrix.transformPoint(x2, y2);    Point2D.Float p3 = matrix.transformPoint(x1, y2);    GeneralPath path = new GeneralPath();    path.moveTo(p0.getX(), p0.getY());    path.lineTo(p1.getX(), p1.getY());    path.lineTo(p2.getX(), p2.getY());    path.lineTo(p3.getX(), p3.getY());    path.closePath();    return path;}
public COSBase pdfbox_f3634_0()
{    return rectArray;}
public GeneralPath pdfbox_f3635_0()
{    float x1 = getLowerLeftX();    float y1 = getLowerLeftY();    float x2 = getUpperRightX();    float y2 = getUpperRightY();    GeneralPath path = new GeneralPath();    path.moveTo(x1, y1);    path.lineTo(x2, y1);    path.lineTo(x2, y2);    path.lineTo(x1, y2);    path.closePath();    return path;}
public String pdfbox_f3636_0()
{    return "[" + getLowerLeftX() + "," + getLowerLeftY() + "," + getUpperRightX() + "," + getUpperRightY() + "]";}
public void pdfbox_f3637_0()
{    List<COSName> filters = getFilters();    if (filters == null) {        if (stream.getLength() > 0) {            OutputStream out = null;            try {                byte[] bytes = IOUtils.toByteArray(stream.createInputStream());                out = stream.createOutputStream(COSName.FLATE_DECODE);                out.write(bytes);            } catch (IOException e) {                                throw new RuntimeException(e);            } finally {                IOUtils.closeQuietly(out);            }        } else {            filters = new ArrayList<>();            filters.add(COSName.FLATE_DECODE);            setFilters(filters);        }    }}
public COSStream pdfbox_f3638_0()
{    return stream;}
public OutputStream pdfbox_f3639_0() throws IOException
{    return stream.createOutputStream();}
public OutputStream pdfbox_f3640_0(COSName filter) throws IOException
{    return stream.createOutputStream(filter);}
public COSInputStream pdfbox_f3641_0() throws IOException
{    return stream.createInputStream();}
public COSInputStream pdfbox_f3642_0(DecodeOptions options) throws IOException
{    return stream.createInputStream(options);}
public InputStream pdfbox_f3643_0(List<String> stopFilters) throws IOException
{    InputStream is = stream.createRawInputStream();    ByteArrayOutputStream os = new ByteArrayOutputStream();    List<COSName> filters = getFilters();    if (filters != null) {        for (int i = 0; i < filters.size(); i++) {            COSName nextFilter = filters.get(i);            if ((stopFilters != null) && stopFilters.contains(nextFilter.getName())) {                break;            } else {                Filter filter = FilterFactory.INSTANCE.getFilter(nextFilter);                filter.decode(is, os, stream, i);                IOUtils.closeQuietly(is);                is = new ByteArrayInputStream(os.toByteArray());                os.reset();            }        }    }    return is;}
public int pdfbox_f3644_0()
{    return stream.getInt(COSName.LENGTH, 0);}
public List<COSName> pdfbox_f3645_0()
{    List<COSName> retval = null;    COSBase filters = stream.getFilters();    if (filters instanceof COSName) {        COSName name = (COSName) filters;        retval = new COSArrayList<>(name, name, stream, COSName.FILTER);    } else if (filters instanceof COSArray) {        retval = (List<COSName>) ((COSArray) filters).toList();    }    return retval;}
public void pdfbox_f3646_0(List<COSName> filters)
{    COSBase obj = COSArrayList.converterToCOSArray(filters);    stream.setItem(COSName.FILTER, obj);}
public List<Object> pdfbox_f3647_0() throws IOException
{    List<Object> retval = null;    COSBase dp = stream.getDictionaryObject(COSName.DECODE_PARMS);    if (dp == null) {                        dp = stream.getDictionaryObject(COSName.DP);    }    if (dp instanceof COSDictionary) {        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap((COSDictionary) dp);        retval = new COSArrayList<Object>(map, dp, stream, COSName.DECODE_PARMS);    } else if (dp instanceof COSArray) {        COSArray array = (COSArray) dp;        List<Object> actuals = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            actuals.add(COSDictionaryMap.convertBasicTypesToMap((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(actuals, array);    }    return retval;}
public void pdfbox_f3648_0(List<?> decodeParams)
{    stream.setItem(COSName.DECODE_PARMS, COSArrayList.converterToCOSArray(decodeParams));}
public PDFileSpecification pdfbox_f3649_0() throws IOException
{    COSBase f = stream.getDictionaryObject(COSName.F);    return PDFileSpecification.createFS(f);}
public void pdfbox_f3650_0(PDFileSpecification f)
{    stream.setItem(COSName.F, f);}
public List<String> pdfbox_f3651_0()
{    List<String> retval = null;    COSBase filters = stream.getDictionaryObject(COSName.F_FILTER);    if (filters instanceof COSName) {        COSName name = (COSName) filters;        retval = new COSArrayList<>(name.getName(), name, stream, COSName.F_FILTER);    } else if (filters instanceof COSArray) {        retval = COSArrayList.convertCOSNameCOSArrayToList((COSArray) filters);    }    return retval;}
public void pdfbox_f3652_0(List<String> filters)
{    COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray(filters);    stream.setItem(COSName.F_FILTER, obj);}
public List<Object> pdfbox_f3653_0() throws IOException
{    List<Object> retval = null;    COSBase dp = stream.getDictionaryObject(COSName.F_DECODE_PARMS);    if (dp instanceof COSDictionary) {        Map<?, ?> map = COSDictionaryMap.convertBasicTypesToMap((COSDictionary) dp);        retval = new COSArrayList<Object>(map, dp, stream, COSName.F_DECODE_PARMS);    } else if (dp instanceof COSArray) {        COSArray array = (COSArray) dp;        List<Object> actuals = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            actuals.add(COSDictionaryMap.convertBasicTypesToMap((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(actuals, array);    }    return retval;}
public void pdfbox_f3654_0(List<?> decodeParams)
{    stream.setItem("FDecodeParams", COSArrayList.converterToCOSArray(decodeParams));}
public byte[] pdfbox_f3655_0() throws IOException
{    ByteArrayOutputStream output = new ByteArrayOutputStream();    try (InputStream is = createInputStream()) {        IOUtils.copy(is, output);    }    return output.toByteArray();}
public PDMetadata pdfbox_f3656_0()
{    PDMetadata retval = null;    COSBase mdStream = stream.getDictionaryObject(COSName.METADATA);    if (mdStream != null) {        if (mdStream instanceof COSStream) {            retval = new PDMetadata((COSStream) mdStream);        } else if (mdStream instanceof COSNull) {                } else {            throw new IllegalStateException("Expected a COSStream but was a " + mdStream.getClass().getSimpleName());        }    }    return retval;}
public void pdfbox_f3657_0(PDMetadata meta)
{    stream.setItem(COSName.METADATA, meta);}
public int pdfbox_f3658_0()
{    return this.stream.getInt(COSName.DL);}
public void pdfbox_f3659_0(int decodedStreamLength)
{    this.stream.setInt(COSName.DL, decodedStreamLength);}
public String pdfbox_f3660_0()
{    return this.getCOSObject().getNameAsString(COSName.TYPE);}
public PDFont pdfbox_f3661_0(COSObject indirect) throws IOException
{    SoftReference<PDFont> font = fonts.get(indirect);    if (font != null) {        return font.get();    }    return null;}
public void pdfbox_f3662_0(COSObject indirect, PDFont font) throws IOException
{    fonts.put(indirect, new SoftReference<>(font));}
public PDColorSpace pdfbox_f3663_0(COSObject indirect) throws IOException
{    SoftReference<PDColorSpace> colorSpace = colorSpaces.get(indirect);    if (colorSpace != null) {        return colorSpace.get();    }    return null;}
public void pdfbox_f3664_0(COSObject indirect, PDColorSpace colorSpace) throws IOException
{    colorSpaces.put(indirect, new SoftReference<>(colorSpace));}
public PDExtendedGraphicsState pdfbox_f3665_0(COSObject indirect)
{    SoftReference<PDExtendedGraphicsState> extGState = extGStates.get(indirect);    if (extGState != null) {        return extGState.get();    }    return null;}
public void pdfbox_f3666_0(COSObject indirect, PDExtendedGraphicsState extGState)
{    extGStates.put(indirect, new SoftReference<>(extGState));}
public PDShading pdfbox_f3667_0(COSObject indirect) throws IOException
{    SoftReference<PDShading> shading = shadings.get(indirect);    if (shading != null) {        return shading.get();    }    return null;}
public void pdfbox_f3668_0(COSObject indirect, PDShading shading) throws IOException
{    shadings.put(indirect, new SoftReference<>(shading));}
public PDAbstractPattern pdfbox_f3669_0(COSObject indirect) throws IOException
{    SoftReference<PDAbstractPattern> pattern = patterns.get(indirect);    if (pattern != null) {        return pattern.get();    }    return null;}
public void pdfbox_f3670_0(COSObject indirect, PDAbstractPattern pattern) throws IOException
{    patterns.put(indirect, new SoftReference<>(pattern));}
public PDPropertyList pdfbox_f3671_0(COSObject indirect)
{    SoftReference<PDPropertyList> propertyList = properties.get(indirect);    if (propertyList != null) {        return propertyList.get();    }    return null;}
public void pdfbox_f3672_0(COSObject indirect, PDPropertyList propertyList)
{    properties.put(indirect, new SoftReference<>(propertyList));}
public PDXObject pdfbox_f3673_0(COSObject indirect) throws IOException
{    SoftReference<PDXObject> xobject = xobjects.get(indirect);    if (xobject != null) {        return xobject.get();    }    return null;}
public void pdfbox_f3674_0(COSObject indirect, PDXObject xobject) throws IOException
{    xobjects.put(indirect, new SoftReference<>(xobject));}
public static PDAttributeObject pdfbox_f3675_0(COSDictionary dictionary)
{    String owner = dictionary.getNameAsString(COSName.O);    if (owner != null) {        switch(owner) {            case PDUserAttributeObject.OWNER_USER_PROPERTIES:                return new PDUserAttributeObject(dictionary);            case PDListAttributeObject.OWNER_LIST:                return new PDListAttributeObject(dictionary);            case PDPrintFieldAttributeObject.OWNER_PRINT_FIELD:                return new PDPrintFieldAttributeObject(dictionary);            case PDTableAttributeObject.OWNER_TABLE:                return new PDTableAttributeObject(dictionary);            case PDLayoutAttributeObject.OWNER_LAYOUT:                return new PDLayoutAttributeObject(dictionary);            case PDExportFormatAttributeObject.OWNER_XML_1_00:            case PDExportFormatAttributeObject.OWNER_HTML_3_20:            case PDExportFormatAttributeObject.OWNER_HTML_4_01:            case PDExportFormatAttributeObject.OWNER_OEB_1_00:            case PDExportFormatAttributeObject.OWNER_RTF_1_05:            case PDExportFormatAttributeObject.OWNER_CSS_1_00:            case PDExportFormatAttributeObject.OWNER_CSS_2_00:                return new PDExportFormatAttributeObject(dictionary);            default:                break;        }    }    return new PDDefaultAttributeObject(dictionary);}
private PDStructureElement pdfbox_f3676_0()
{    return this.structureElement;}
protected void pdfbox_f3677_0(PDStructureElement structureElement)
{    this.structureElement = structureElement;}
public String pdfbox_f3678_0()
{    return this.getCOSObject().getNameAsString(COSName.O);}
protected void pdfbox_f3679_0(String owner)
{    this.getCOSObject().setName(COSName.O, owner);}
public boolean pdfbox_f3680_0()
{        return (this.getCOSObject().size() == 1) && (this.getOwner() != null);}
protected void pdfbox_f3681_0(COSBase oldBase, COSBase newBase)
{    if (this.isValueChanged(oldBase, newBase)) {        this.notifyChanged();    }}
private boolean pdfbox_f3682_0(COSBase oldValue, COSBase newValue)
{    if (oldValue == null) {        return newValue != null;    }    return !oldValue.equals(newValue);}
protected void pdfbox_f3683_0()
{    if (this.getStructureElement() != null) {        this.getStructureElement().attributeChanged(this);    }}
public String pdfbox_f3684_0()
{    return "O=" + this.getOwner();}
protected static String pdfbox_f3685_0(Object[] array)
{    StringBuilder sb = new StringBuilder("[");    for (int i = 0; i < array.length; i++) {        if (i > 0) {            sb.append(", ");        }        sb.append(array[i]);    }    return sb.append(']').toString();}
protected static String pdfbox_f3686_0(float[] array)
{    StringBuilder sb = new StringBuilder("[");    for (int i = 0; i < array.length; i++) {        if (i > 0) {            sb.append(", ");        }        sb.append(array[i]);    }    return sb.append(']').toString();}
public List<String> pdfbox_f3687_0()
{    List<String> attrNames = new ArrayList<>();    for (Entry<COSName, COSBase> entry : this.getCOSObject().entrySet()) {        COSName key = entry.getKey();        if (!COSName.O.equals(key)) {            attrNames.add(key.getName());        }    }    return attrNames;}
public COSBase pdfbox_f3688_0(String attrName)
{    return this.getCOSObject().getDictionaryObject(attrName);}
protected COSBase pdfbox_f3689_0(String attrName, COSBase defaultValue)
{    COSBase value = this.getCOSObject().getDictionaryObject(attrName);    if (value == null) {        return defaultValue;    }    return value;}
public void pdfbox_f3690_0(String attrName, COSBase attrValue)
{    COSBase old = this.getAttributeValue(attrName);    this.getCOSObject().setItem(COSName.getPDFName(attrName), attrValue);    this.potentiallyNotifyChanged(old, attrValue);}
public String pdfbox_f3691_0()
{    StringBuilder sb = new StringBuilder().append(super.toString()).append(", attributes={");    Iterator<String> it = this.getAttributeNames().iterator();    while (it.hasNext()) {        String name = it.next();        sb.append(name).append('=').append(this.getAttributeValue(name));        if (it.hasNext()) {            sb.append(", ");        }    }    return sb.append('}').toString();}
public COSDictionary pdfbox_f3692_0()
{    return this.dictionary;}
public PDPage pdfbox_f3693_0()
{    COSDictionary pg = (COSDictionary) this.getCOSObject().getDictionaryObject(COSName.PG);    if (pg != null) {        return new PDPage(pg);    }    return null;}
public void pdfbox_f3694_0(PDPage page)
{    this.getCOSObject().setItem(COSName.PG, page);}
public int pdfbox_f3695_0()
{    return this.getCOSObject().getInt(COSName.MCID);}
public void pdfbox_f3696_0(int mcid)
{    this.getCOSObject().setInt(COSName.MCID, mcid);}
public String pdfbox_f3697_0()
{    return "mcid=" + this.getMCID();}
public COSDictionary pdfbox_f3698_0()
{    return dictionary;}
public boolean pdfbox_f3699_0()
{    return dictionary.getBoolean("Marked", false);}
public void pdfbox_f3700_0(boolean value)
{    dictionary.setBoolean("Marked", value);}
public boolean pdfbox_f3701_0()
{    return dictionary.getBoolean("UserProperties", false);}
public void pdfbox_f3702_0(boolean userProps)
{    dictionary.setBoolean("UserProperties", userProps);}
public boolean pdfbox_f3703_0()
{    return dictionary.getBoolean("Suspects", false);}
public void pdfbox_f3704_0(boolean suspect)
{    dictionary.setBoolean("Suspects", false);}
public COSDictionary pdfbox_f3705_0()
{    return this.dictionary;}
public COSObjectable pdfbox_f3706_1()
{    COSBase obj = this.getCOSObject().getDictionaryObject(COSName.OBJ);    if (!(obj instanceof COSDictionary)) {        return null;    }    try {        if (obj instanceof COSStream) {                        PDXObject xobject = PDXObject.createXObject(obj, null);            if (xobject != null) {                return xobject;            }        }        COSDictionary objDictionary = (COSDictionary) obj;        PDAnnotation annotation = PDAnnotation.createAnnotation(obj);        /*             * COSName.TYPE is optional, so if annotation is of type unknown and             * COSName.TYPE is not COSName.ANNOT it still may be an annotation.             * TODO shall we return the annotation object instead of null?             * what else can be the target of the object reference?             */        if (!(annotation instanceof PDAnnotationUnknown) || COSName.ANNOT.equals(objDictionary.getDictionaryObject(COSName.TYPE))) {            return annotation;        }    } catch (IOException exception) {                }    return null;}
public void pdfbox_f3707_0(PDAnnotation annotation)
{    this.getCOSObject().setItem(COSName.OBJ, annotation);}
public void pdfbox_f3708_0(PDXObject xobject)
{    this.getCOSObject().setItem(COSName.OBJ, xobject);}
public COSBase pdfbox_f3709_0()
{    return obj.getCOSObject();}
public String pdfbox_f3710_0()
{    return obj.toString();}
public String pdfbox_f3711_0()
{    return this.getCOSObject().getNameAsString(COSName.S);}
public final void pdfbox_f3712_0(String structureType)
{    this.getCOSObject().setName(COSName.S, structureType);}
public PDStructureNode pdfbox_f3713_0()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.P);    if (base instanceof COSDictionary) {        return PDStructureNode.create((COSDictionary) base);    }    return null;}
public final void pdfbox_f3714_0(PDStructureNode structureNode)
{    this.getCOSObject().setItem(COSName.P, structureNode);}
public String pdfbox_f3715_0()
{    return this.getCOSObject().getString(COSName.ID);}
public void pdfbox_f3716_0(String id)
{    this.getCOSObject().setString(COSName.ID, id);}
public PDPage pdfbox_f3717_0()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.PG);    if (base instanceof COSDictionary) {        return new PDPage((COSDictionary) base);    }    return null;}
public void pdfbox_f3718_0(PDPage page)
{    this.getCOSObject().setItem(COSName.PG, page);}
public Revisions<PDAttributeObject> pdfbox_f3719_0()
{    Revisions<PDAttributeObject> attributes = new Revisions<>();    COSBase a = this.getCOSObject().getDictionaryObject(COSName.A);    if (a instanceof COSArray) {        COSArray aa = (COSArray) a;        Iterator<COSBase> it = aa.iterator();        PDAttributeObject ao = null;        while (it.hasNext()) {            COSBase item = it.next();            if (item instanceof COSObject) {                item = ((COSObject) item).getObject();            }            if (item instanceof COSDictionary) {                ao = PDAttributeObject.create((COSDictionary) item);                ao.setStructureElement(this);                attributes.addObject(ao, 0);            } else if (item instanceof COSInteger) {                attributes.setRevisionNumber(ao, ((COSNumber) item).intValue());            }        }    }    if (a instanceof COSDictionary) {        PDAttributeObject ao = PDAttributeObject.create((COSDictionary) a);        ao.setStructureElement(this);        attributes.addObject(ao, 0);    }    return attributes;}
public void pdfbox_f3720_0(Revisions<PDAttributeObject> attributes)
{    COSName key = COSName.A;    if ((attributes.size() == 1) && (attributes.getRevisionNumber(0) == 0)) {        PDAttributeObject attributeObject = attributes.getObject(0);        attributeObject.setStructureElement(this);        this.getCOSObject().setItem(key, attributeObject);        return;    }    COSArray array = new COSArray();    for (int i = 0; i < attributes.size(); i++) {        PDAttributeObject attributeObject = attributes.getObject(i);        attributeObject.setStructureElement(this);        int revisionNumber = attributes.getRevisionNumber(i);        if (revisionNumber < 0) {            throw new IllegalArgumentException("The revision number shall be > -1");        }        array.add(attributeObject);        array.add(COSInteger.get(revisionNumber));    }    this.getCOSObject().setItem(key, array);}
public void pdfbox_f3721_0(PDAttributeObject attributeObject)
{    COSName key = COSName.A;    attributeObject.setStructureElement(this);    COSBase a = this.getCOSObject().getDictionaryObject(key);    COSArray array;    if (a instanceof COSArray) {        array = (COSArray) a;    } else {        array = new COSArray();        if (a != null) {            array.add(a);            array.add(COSInteger.get(0));        }    }    this.getCOSObject().setItem(key, array);    array.add(attributeObject);    array.add(COSInteger.get(this.getRevisionNumber()));}
public void pdfbox_f3722_0(PDAttributeObject attributeObject)
{    COSName key = COSName.A;    COSBase a = this.getCOSObject().getDictionaryObject(key);    if (a instanceof COSArray) {        COSArray array = (COSArray) a;        array.remove(attributeObject.getCOSObject());        if ((array.size() == 2) && (array.getInt(1) == 0)) {            this.getCOSObject().setItem(key, array.getObject(0));        }    } else {        COSBase directA = a;        if (a instanceof COSObject) {            directA = ((COSObject) a).getObject();        }        if (attributeObject.getCOSObject().equals(directA)) {            this.getCOSObject().setItem(key, null);        }    }    attributeObject.setStructureElement(null);}
public void pdfbox_f3723_0(PDAttributeObject attributeObject)
{    COSName key = COSName.A;    COSBase a = this.getCOSObject().getDictionaryObject(key);    if (a instanceof COSArray) {        COSArray array = (COSArray) a;        for (int i = 0; i < array.size(); i++) {            COSBase entry = array.getObject(i);            if (entry.equals(attributeObject.getCOSObject())) {                COSBase next = array.get(i + 1);                if (next instanceof COSInteger) {                    array.set(i + 1, COSInteger.get(this.getRevisionNumber()));                }            }        }    } else {        COSArray array = new COSArray();        array.add(a);        array.add(COSInteger.get(this.getRevisionNumber()));        this.getCOSObject().setItem(key, array);    }}
public Revisions<String> pdfbox_f3724_0()
{    COSName key = COSName.C;    Revisions<String> classNames = new Revisions<>();    COSBase c = this.getCOSObject().getDictionaryObject(key);    if (c instanceof COSName) {        classNames.addObject(((COSName) c).getName(), 0);    }    if (c instanceof COSArray) {        COSArray array = (COSArray) c;        Iterator<COSBase> it = array.iterator();        String className = null;        while (it.hasNext()) {            COSBase item = it.next();            if (item instanceof COSObject) {                item = ((COSObject) item).getObject();            }            if (item instanceof COSName) {                className = ((COSName) item).getName();                classNames.addObject(className, 0);            } else if (item instanceof COSInteger) {                classNames.setRevisionNumber(className, ((COSNumber) item).intValue());            }        }    }    return classNames;}
public void pdfbox_f3725_0(Revisions<String> classNames)
{    if (classNames == null) {        return;    }    COSName key = COSName.C;    if ((classNames.size() == 1) && (classNames.getRevisionNumber(0) == 0)) {        String className = classNames.getObject(0);        this.getCOSObject().setName(key, className);        return;    }    COSArray array = new COSArray();    for (int i = 0; i < classNames.size(); i++) {        String className = classNames.getObject(i);        int revisionNumber = classNames.getRevisionNumber(i);        if (revisionNumber < 0) {            throw new IllegalArgumentException("The revision number shall be > -1");        }        array.add(COSName.getPDFName(className));        array.add(COSInteger.get(revisionNumber));    }    this.getCOSObject().setItem(key, array);}
public void pdfbox_f3726_0(String className)
{    if (className == null) {        return;    }    COSName key = COSName.C;    COSBase c = this.getCOSObject().getDictionaryObject(key);    COSArray array;    if (c instanceof COSArray) {        array = (COSArray) c;    } else {        array = new COSArray();        if (c != null) {            array.add(c);            array.add(COSInteger.get(0));        }    }    this.getCOSObject().setItem(key, array);    array.add(COSName.getPDFName(className));    array.add(COSInteger.get(this.getRevisionNumber()));}
public void pdfbox_f3727_0(String className)
{    if (className == null) {        return;    }    COSName key = COSName.C;    COSBase c = this.getCOSObject().getDictionaryObject(key);    COSName name = COSName.getPDFName(className);    if (c instanceof COSArray) {        COSArray array = (COSArray) c;        array.remove(name);        if ((array.size() == 2) && (array.getInt(1) == 0)) {            this.getCOSObject().setItem(key, array.getObject(0));        }    } else {        COSBase directC = c;        if (c instanceof COSObject) {            directC = ((COSObject) c).getObject();        }        if (name.equals(directC)) {            this.getCOSObject().setItem(key, null);        }    }}
public int pdfbox_f3728_0()
{    return this.getCOSObject().getInt(COSName.R, 0);}
public void pdfbox_f3729_0(int revisionNumber)
{    if (revisionNumber < 0) {        throw new IllegalArgumentException("The revision number shall be > -1");    }    this.getCOSObject().setInt(COSName.R, revisionNumber);}
public void pdfbox_f3730_0()
{    this.setRevisionNumber(this.getRevisionNumber() + 1);}
public String pdfbox_f3731_0()
{    return this.getCOSObject().getString(COSName.T);}
public void pdfbox_f3732_0(String title)
{    this.getCOSObject().setString(COSName.T, title);}
public String pdfbox_f3733_0()
{    return this.getCOSObject().getString(COSName.LANG);}
public void pdfbox_f3734_0(String language)
{    this.getCOSObject().setString(COSName.LANG, language);}
public String pdfbox_f3735_0()
{    return this.getCOSObject().getString(COSName.ALT);}
public void pdfbox_f3736_0(String alternateDescription)
{    this.getCOSObject().setString(COSName.ALT, alternateDescription);}
public String pdfbox_f3737_0()
{    return this.getCOSObject().getString(COSName.E);}
public void pdfbox_f3738_0(String expandedForm)
{    this.getCOSObject().setString(COSName.E, expandedForm);}
public String pdfbox_f3739_0()
{    return this.getCOSObject().getString(COSName.ACTUAL_TEXT);}
public void pdfbox_f3740_0(String actualText)
{    this.getCOSObject().setString(COSName.ACTUAL_TEXT, actualText);}
public String pdfbox_f3741_0()
{    String type = this.getStructureType();    Map<String, Object> roleMap = getRoleMap();    if (roleMap.containsKey(type)) {        Object mappedValue = getRoleMap().get(type);        if (mappedValue instanceof String) {            type = (String) mappedValue;        }    }    return type;}
public void pdfbox_f3742_0(PDMarkedContent markedContent)
{    if (markedContent == null) {        return;    }    this.appendKid(COSInteger.get(markedContent.getMCID()));}
public void pdfbox_f3743_0(PDMarkedContentReference markedContentReference)
{    this.appendObjectableKid(markedContentReference);}
public void pdfbox_f3744_0(PDObjectReference objectReference)
{    this.appendObjectableKid(objectReference);}
public void pdfbox_f3745_0(COSInteger markedContentIdentifier, Object refKid)
{    this.insertBefore((COSBase) markedContentIdentifier, refKid);}
public void pdfbox_f3746_0(PDMarkedContentReference markedContentReference, Object refKid)
{    this.insertObjectableBefore(markedContentReference, refKid);}
public void pdfbox_f3747_0(PDObjectReference objectReference, Object refKid)
{    this.insertObjectableBefore(objectReference, refKid);}
public void pdfbox_f3748_0(COSInteger markedContentIdentifier)
{    this.removeKid((COSBase) markedContentIdentifier);}
public void pdfbox_f3749_0(PDMarkedContentReference markedContentReference)
{    this.removeObjectableKid(markedContentReference);}
public void pdfbox_f3750_0(PDObjectReference objectReference)
{    this.removeObjectableKid(objectReference);}
private PDStructureTreeRoot pdfbox_f3751_0()
{    PDStructureNode parent = this.getParent();    while (parent instanceof PDStructureElement) {        parent = ((PDStructureElement) parent).getParent();    }    if (parent instanceof PDStructureTreeRoot) {        return (PDStructureTreeRoot) parent;    }    return null;}
private Map<String, Object> pdfbox_f3752_0()
{    PDStructureTreeRoot root = this.getStructureTreeRoot();    if (root != null) {        return root.getRoleMap();    }    return Collections.emptyMap();}
public static PDStructureNode pdfbox_f3753_0(COSDictionary node)
{    String type = node.getNameAsString(COSName.TYPE);    if ("StructTreeRoot".equals(type)) {        return new PDStructureTreeRoot(node);    }    if (type == null || "StructElem".equals(type)) {        return new PDStructureElement(node);    }    throw new IllegalArgumentException("Dictionary must not include a Type entry with a value that is neither StructTreeRoot nor StructElem.");}
public COSDictionary pdfbox_f3754_0()
{    return dictionary;}
public String pdfbox_f3755_0()
{    return this.getCOSObject().getNameAsString(COSName.TYPE);}
public List<Object> pdfbox_f3756_0()
{    List<Object> kidObjects = new ArrayList<>();    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k instanceof COSArray) {        for (COSBase kid : (COSArray) k) {            Object kidObject = this.createObject(kid);            if (kidObject != null) {                kidObjects.add(kidObject);            }        }    } else {        Object kidObject = this.createObject(k);        if (kidObject != null) {            kidObjects.add(kidObject);        }    }    return kidObjects;}
public void pdfbox_f3757_0(List<Object> kids)
{    this.getCOSObject().setItem(COSName.K, COSArrayList.converterToCOSArray(kids));}
public void pdfbox_f3758_0(PDStructureElement structureElement)
{    this.appendObjectableKid(structureElement);    structureElement.setParent(this);}
protected void pdfbox_f3759_0(COSObjectable objectable)
{    if (objectable == null) {        return;    }    this.appendKid(objectable.getCOSObject());}
protected void pdfbox_f3760_0(COSBase object)
{    if (object == null) {        return;    }    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k == null) {                this.getCOSObject().setItem(COSName.K, object);    } else if (k instanceof COSArray) {                COSArray array = (COSArray) k;        array.add(object);    } else {                COSArray array = new COSArray();        array.add(k);        array.add(object);        this.getCOSObject().setItem(COSName.K, array);    }}
public void pdfbox_f3761_0(PDStructureElement newKid, Object refKid)
{    this.insertObjectableBefore(newKid, refKid);}
protected void pdfbox_f3762_0(COSObjectable newKid, Object refKid)
{    if (newKid == null) {        return;    }    this.insertBefore(newKid.getCOSObject(), refKid);}
protected void pdfbox_f3763_0(COSBase newKid, Object refKid)
{    if (newKid == null || refKid == null) {        return;    }    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k == null) {        return;    }    COSBase refKidBase = null;    if (refKid instanceof COSObjectable) {        refKidBase = ((COSObjectable) refKid).getCOSObject();    } else if (refKid instanceof COSInteger) {        refKidBase = (COSBase) refKid;    }    if (k instanceof COSArray) {        COSArray array = (COSArray) k;        int refIndex = array.indexOfObject(refKidBase);        array.add(refIndex, newKid.getCOSObject());    } else {        boolean onlyKid = k.equals(refKidBase);        if (!onlyKid && (k instanceof COSObject)) {            COSBase kObj = ((COSObject) k).getObject();            onlyKid = kObj.equals(refKidBase);        }        if (onlyKid) {            COSArray array = new COSArray();            array.add(newKid);            array.add(refKidBase);            this.getCOSObject().setItem(COSName.K, array);        }    }}
public boolean pdfbox_f3764_0(PDStructureElement structureElement)
{    boolean removed = this.removeObjectableKid(structureElement);    if (removed) {        structureElement.setParent(null);    }    return removed;}
protected boolean pdfbox_f3765_0(COSObjectable objectable)
{    if (objectable == null) {        return false;    }    return this.removeKid(objectable.getCOSObject());}
protected boolean pdfbox_f3766_0(COSBase object)
{    if (object == null) {        return false;    }    COSBase k = this.getCOSObject().getDictionaryObject(COSName.K);    if (k == null) {                return false;    } else if (k instanceof COSArray) {                COSArray array = (COSArray) k;        boolean removed = array.removeObject(object);                if (array.size() == 1) {            this.getCOSObject().setItem(COSName.K, array.getObject(0));        }        return removed;    } else {                boolean onlyKid = k.equals(object);        if (!onlyKid && (k instanceof COSObject)) {            COSBase kObj = ((COSObject) k).getObject();            onlyKid = kObj.equals(object);        }        if (onlyKid) {            this.getCOSObject().setItem(COSName.K, null);            return true;        }        return false;    }}
protected Object pdfbox_f3767_0(COSBase kid)
{    COSDictionary kidDic = null;    if (kid instanceof COSDictionary) {        kidDic = (COSDictionary) kid;    } else if (kid instanceof COSObject) {        COSBase base = ((COSObject) kid).getObject();        if (base instanceof COSDictionary) {            kidDic = (COSDictionary) base;        }    }    if (kidDic != null) {        return createObjectFromDic(kidDic);    } else if (kid instanceof COSInteger) {                COSInteger mcid = (COSInteger) kid;        return mcid.intValue();    }    return null;}
private COSObjectable pdfbox_f3768_0(COSDictionary kidDic)
{    String type = kidDic.getNameAsString(COSName.TYPE);    if (type == null) {                return new PDStructureElement(kidDic);    }    switch(type) {        case PDStructureElement.TYPE:                        return new PDStructureElement(kidDic);        case PDObjectReference.TYPE:                        return new PDObjectReference(kidDic);        case PDMarkedContentReference.TYPE:                        return new PDMarkedContentReference(kidDic);        default:            return null;    }}
public COSBase pdfbox_f3769_0()
{    return this.getCOSObject().getDictionaryObject(COSName.K);}
public void pdfbox_f3770_0(COSBase k)
{    this.getCOSObject().setItem(COSName.K, k);}
public PDNameTreeNode<PDStructureElement> pdfbox_f3771_0()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.ID_TREE);    if (base instanceof COSDictionary) {        return new PDStructureElementNameTreeNode((COSDictionary) base);    }    return null;}
public void pdfbox_f3772_0(PDNameTreeNode<PDStructureElement> idTree)
{    this.getCOSObject().setItem(COSName.ID_TREE, idTree);}
public PDNumberTreeNode pdfbox_f3773_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.PARENT_TREE);    if (base instanceof COSDictionary) {        return new PDNumberTreeNode((COSDictionary) base, PDParentTreeValue.class);    }    return null;}
public void pdfbox_f3774_0(PDNumberTreeNode parentTree)
{    this.getCOSObject().setItem(COSName.PARENT_TREE, parentTree);}
public int pdfbox_f3775_0()
{    return this.getCOSObject().getInt(COSName.PARENT_TREE_NEXT_KEY);}
public void pdfbox_f3776_0(int parentTreeNextkey)
{    this.getCOSObject().setInt(COSName.PARENT_TREE_NEXT_KEY, parentTreeNextkey);}
public Map<String, Object> pdfbox_f3777_1()
{    COSBase rm = this.getCOSObject().getDictionaryObject(COSName.ROLE_MAP);    if (rm instanceof COSDictionary) {        try {            return COSDictionaryMap.convertBasicTypesToMap((COSDictionary) rm);        } catch (IOException e) {                    }    }    return new HashMap<>();}
public void pdfbox_f3778_0(Map<String, String> roleMap)
{    COSDictionary rmDic = new COSDictionary();    for (Map.Entry<String, String> entry : roleMap.entrySet()) {        rmDic.setName(entry.getKey(), entry.getValue());    }    this.getCOSObject().setItem(COSName.ROLE_MAP, rmDic);}
public List<PDUserProperty> pdfbox_f3779_0()
{    COSArray p = (COSArray) this.getCOSObject().getDictionaryObject(COSName.P);    List<PDUserProperty> properties = new ArrayList<>(p.size());    for (int i = 0; i < p.size(); i++) {        properties.add(new PDUserProperty((COSDictionary) p.getObject(i), this));    }    return properties;}
public void pdfbox_f3780_0(List<PDUserProperty> userProperties)
{    COSArray p = new COSArray();    for (PDUserProperty userProperty : userProperties) {        p.add(userProperty);    }    this.getCOSObject().setItem(COSName.P, p);}
public void pdfbox_f3781_0(PDUserProperty userProperty)
{    COSArray p = (COSArray) this.getCOSObject().getDictionaryObject(COSName.P);    p.add(userProperty);    this.notifyChanged();}
public void pdfbox_f3782_0(PDUserProperty userProperty)
{    if (userProperty == null) {        return;    }    COSArray p = (COSArray) this.getCOSObject().getDictionaryObject(COSName.P);    p.remove(userProperty.getCOSObject());    this.notifyChanged();}
public void pdfbox_f3783_0(PDUserProperty userProperty)
{}
public String pdfbox_f3784_0()
{    return super.toString() + ", userProperties=" + this.getOwnerUserProperties();}
public String pdfbox_f3785_0()
{    return this.getCOSObject().getNameAsString(COSName.N);}
public void pdfbox_f3786_0(String name)
{    this.potentiallyNotifyChanged(this.getName(), name);    this.getCOSObject().setName(COSName.N, name);}
public COSBase pdfbox_f3787_0()
{    return this.getCOSObject().getDictionaryObject(COSName.V);}
public void pdfbox_f3788_0(COSBase value)
{    this.potentiallyNotifyChanged(this.getValue(), value);    this.getCOSObject().setItem(COSName.V, value);}
public String pdfbox_f3789_0()
{    return this.getCOSObject().getString(COSName.F);}
public void pdfbox_f3790_0(String formattedValue)
{    this.potentiallyNotifyChanged(this.getFormattedValue(), formattedValue);    this.getCOSObject().setString(COSName.F, formattedValue);}
public boolean pdfbox_f3791_0()
{    return this.getCOSObject().getBoolean(COSName.H, false);}
public void pdfbox_f3792_0(boolean hidden)
{    this.potentiallyNotifyChanged(this.isHidden(), hidden);    this.getCOSObject().setBoolean(COSName.H, hidden);}
public String pdfbox_f3793_0()
{    return "Name=" + this.getName() + ", Value=" + this.getValue() + ", FormattedValue=" + this.getFormattedValue() + ", Hidden=" + this.isHidden();}
private void pdfbox_f3794_0(Object oldEntry, Object newEntry)
{    if (this.isEntryChanged(oldEntry, newEntry)) {        this.userAttributeObject.userPropertyChanged(this);    }}
private boolean pdfbox_f3795_0(Object oldEntry, Object newEntry)
{    if (oldEntry == null) {        return newEntry != null;    }    return !oldEntry.equals(newEntry);}
public int pdfbox_f3796_0()
{    final int prime = 31;    int result = super.hashCode();    result = prime * result + ((userAttributeObject == null) ? 0 : userAttributeObject.hashCode());    return result;}
public boolean pdfbox_f3797_0(Object obj)
{    if (this == obj) {        return true;    }    if (!super.equals(obj)) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PDUserProperty other = (PDUserProperty) obj;    if (userAttributeObject == null) {        if (other.userAttributeObject != null) {            return false;        }    } else if (!userAttributeObject.equals(other.userAttributeObject)) {        return false;    }    return true;}
private List<T> pdfbox_f3798_0()
{    if (this.objects == null) {        this.objects = new ArrayList<>();    }    return this.objects;}
private List<Integer> pdfbox_f3799_0()
{    if (this.revisionNumbers == null) {        this.revisionNumbers = new ArrayList<>();    }    return this.revisionNumbers;}
public T pdfbox_f3800_0(int index)
{    return this.getObjects().get(index);}
public int pdfbox_f3801_0(int index)
{    return this.getRevisionNumbers().get(index);}
public void pdfbox_f3802_0(T object, int revisionNumber)
{    this.getObjects().add(object);    this.getRevisionNumbers().add(revisionNumber);}
protected void pdfbox_f3803_0(T object, int revisionNumber)
{    int index = this.getObjects().indexOf(object);    if (index > -1) {        this.getRevisionNumbers().set(index, revisionNumber);    }}
public int pdfbox_f3804_0()
{    return this.getObjects().size();}
public String pdfbox_f3805_0()
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < this.getObjects().size(); i++) {        if (i > 0) {            sb.append("; ");        }        sb.append("object=").append(this.getObjects().get(i)).append(", revisionNumber=").append(this.getRevisionNumber(i));    }    return sb.toString();}
public static PDMarkedContent pdfbox_f3806_0(COSName tag, COSDictionary properties)
{    if (COSName.ARTIFACT.equals(tag)) {        return new PDArtifactMarkedContent(properties);    }    return new PDMarkedContent(tag, properties);}
public String pdfbox_f3807_0()
{    return this.tag;}
public COSDictionary pdfbox_f3808_0()
{    return this.properties;}
public int pdfbox_f3809_0()
{    return this.getProperties() == null ? -1 : this.getProperties().getInt(COSName.MCID);}
public String pdfbox_f3810_0()
{    return this.getProperties() == null ? null : this.getProperties().getNameAsString(COSName.LANG);}
public String pdfbox_f3811_0()
{    return this.getProperties() == null ? null : this.getProperties().getString(COSName.ACTUAL_TEXT);}
public String pdfbox_f3812_0()
{    return this.getProperties() == null ? null : this.getProperties().getString(COSName.ALT);}
public String pdfbox_f3813_0()
{    return this.getProperties() == null ? null : this.getProperties().getString(COSName.E);}
public List<Object> pdfbox_f3814_0()
{    return this.contents;}
public void pdfbox_f3815_0(TextPosition text)
{    this.getContents().add(text);}
public void pdfbox_f3816_0(PDMarkedContent markedContent)
{    this.getContents().add(markedContent);}
public void pdfbox_f3817_0(PDXObject xobject)
{    this.getContents().add(xobject);}
public String pdfbox_f3818_0()
{    return "tag=" + this.tag + ", properties=" + this.properties + ", contents=" + this.contents;}
public static PDPropertyList pdfbox_f3819_0(COSDictionary dict)
{    if (COSName.OCG.equals(dict.getItem(COSName.TYPE))) {        return new PDOptionalContentGroup(dict);    } else if (COSName.OCMD.equals(dict.getItem(COSName.TYPE))) {        return new PDOptionalContentMembershipDictionary(dict);    } else {                return new PDPropertyList(dict);    }}
public COSDictionary pdfbox_f3820_0()
{    return dict;}
public COSDictionary pdfbox_f3821_0()
{    return dictionary;}
public PDColor pdfbox_f3822_0()
{    COSArray colorValues = (COSArray) dictionary.getDictionaryObject(COSName.C);    if (colorValues == null) {        colorValues = new COSArray();        colorValues.add(COSInteger.ZERO);        colorValues.add(COSInteger.ZERO);        colorValues.add(COSInteger.ZERO);        dictionary.setItem(COSName.C, colorValues);    }    return new PDColor(colorValues.toFloatArray(), PDDeviceRGB.INSTANCE);}
public void pdfbox_f3823_0(PDColor color)
{    COSArray values = null;    if (color != null) {        values = color.toCOSArray();    }    dictionary.setItem(COSName.C, values);}
public float pdfbox_f3824_0()
{    return dictionary.getFloat(COSName.W, 1);}
public void pdfbox_f3825_0(float width)
{    dictionary.setFloat(COSName.W, width);}
public String pdfbox_f3826_0()
{    return dictionary.getNameAsString(COSName.S, GUIDELINE_STYLE_SOLID);}
public void pdfbox_f3827_0(String style)
{    dictionary.setName(COSName.S, style);}
public PDLineDashPattern pdfbox_f3828_0()
{    PDLineDashPattern pattern;    COSArray d = (COSArray) dictionary.getDictionaryObject(COSName.D);    if (d == null) {        d = new COSArray();        d.add(COSInteger.THREE);        dictionary.setItem(COSName.D, d);    }    COSArray lineArray = new COSArray();    lineArray.add(d);        pattern = new PDLineDashPattern(lineArray, 0);    return pattern;}
public void pdfbox_f3829_0(COSArray dashArray)
{    COSArray array = null;    if (dashArray != null) {        array = dashArray;    }    dictionary.setItem(COSName.D, array);}
public String pdfbox_f3830_0()
{    return this.getProperties().getNameAsString(COSName.TYPE);}
public PDRectangle pdfbox_f3831_0()
{    PDRectangle retval = null;    COSArray a = (COSArray) this.getProperties().getDictionaryObject(COSName.BBOX);    if (a != null) {        retval = new PDRectangle(a);    }    return retval;}
public boolean pdfbox_f3832_0()
{    return this.isAttached("Top");}
public boolean pdfbox_f3833_0()
{    return this.isAttached("Bottom");}
public boolean pdfbox_f3834_0()
{    return this.isAttached("Left");}
public boolean pdfbox_f3835_0()
{    return this.isAttached("Right");}
public String pdfbox_f3836_0()
{    return this.getProperties().getNameAsString(COSName.SUBTYPE);}
private boolean pdfbox_f3837_0(String edge)
{    COSArray a = (COSArray) this.getProperties().getDictionaryObject(COSName.ATTACHED);    if (a != null) {        for (int i = 0; i < a.size(); i++) {            if (edge.equals(a.getName(i))) {                return true;            }        }    }    return false;}
public String pdfbox_f3838_0()
{    return this.getName(PDListAttributeObject.LIST_NUMBERING, PDListAttributeObject.LIST_NUMBERING_NONE);}
public void pdfbox_f3839_0(String listNumbering)
{    this.setName(PDListAttributeObject.LIST_NUMBERING, listNumbering);}
public int pdfbox_f3840_0()
{    return this.getInteger(PDTableAttributeObject.ROW_SPAN, 1);}
public void pdfbox_f3841_0(int rowSpan)
{    this.setInteger(PDTableAttributeObject.ROW_SPAN, rowSpan);}
public int pdfbox_f3842_0()
{    return this.getInteger(PDTableAttributeObject.COL_SPAN, 1);}
public void pdfbox_f3843_0(int colSpan)
{    this.setInteger(PDTableAttributeObject.COL_SPAN, colSpan);}
public String[] pdfbox_f3844_0()
{    return this.getArrayOfString(PDTableAttributeObject.HEADERS);}
public void pdfbox_f3845_0(String[] headers)
{    this.setArrayOfString(PDTableAttributeObject.HEADERS, headers);}
public String pdfbox_f3846_0()
{    return this.getName(PDTableAttributeObject.SCOPE);}
public void pdfbox_f3847_0(String scope)
{    this.setName(PDTableAttributeObject.SCOPE, scope);}
public String pdfbox_f3848_0()
{    return this.getString(PDTableAttributeObject.SUMMARY);}
public void pdfbox_f3849_0(String summary)
{    this.setString(PDTableAttributeObject.SUMMARY, summary);}
public String pdfbox_f3850_0()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(PDListAttributeObject.LIST_NUMBERING)) {        sb.append(", ListNumbering=").append(this.getListNumbering());    }    if (this.isSpecified(PDTableAttributeObject.ROW_SPAN)) {        sb.append(", RowSpan=").append(String.valueOf(this.getRowSpan()));    }    if (this.isSpecified(PDTableAttributeObject.COL_SPAN)) {        sb.append(", ColSpan=").append(String.valueOf(this.getColSpan()));    }    if (this.isSpecified(PDTableAttributeObject.HEADERS)) {        sb.append(", Headers=").append(arrayToString(this.getHeaders()));    }    if (this.isSpecified(PDTableAttributeObject.SCOPE)) {        sb.append(", Scope=").append(this.getScope());    }    if (this.isSpecified(PDTableAttributeObject.SUMMARY)) {        sb.append(", Summary=").append(this.getSummary());    }    return sb.toString();}
public PDGamma pdfbox_f3851_0()
{    return this.getColourByIndex(0);}
public void pdfbox_f3852_0(PDGamma colour)
{    this.setColourByIndex(0, colour);}
public PDGamma pdfbox_f3853_0()
{    return this.getColourByIndex(1);}
public void pdfbox_f3854_0(PDGamma colour)
{    this.setColourByIndex(1, colour);}
public PDGamma pdfbox_f3855_0()
{    return this.getColourByIndex(2);}
public void pdfbox_f3856_0(PDGamma colour)
{    this.setColourByIndex(2, colour);}
public PDGamma pdfbox_f3857_0()
{    return this.getColourByIndex(3);}
public void pdfbox_f3858_0(PDGamma colour)
{    this.setColourByIndex(3, colour);}
public COSBase pdfbox_f3859_0()
{    return this.array;}
private PDGamma pdfbox_f3860_0(int index)
{    PDGamma retval = null;    COSBase item = this.array.getObject(index);    if (item instanceof COSArray) {        retval = new PDGamma((COSArray) item);    }    return retval;}
private void pdfbox_f3861_0(int index, PDGamma colour)
{    COSBase base;    if (colour == null) {        base = COSNull.NULL;    } else {        base = colour.getCOSArray();    }    this.array.set(index, base);}
public String pdfbox_f3862_0()
{    return this.getName(PLACEMENT, PLACEMENT_INLINE);}
public void pdfbox_f3863_0(String placement)
{    this.setName(PLACEMENT, placement);}
public String pdfbox_f3864_0()
{    return this.getName(WRITING_MODE, WRITING_MODE_LRTB);}
public void pdfbox_f3865_0(String writingMode)
{    this.setName(WRITING_MODE, writingMode);}
public PDGamma pdfbox_f3866_0()
{    return this.getColor(BACKGROUND_COLOR);}
public void pdfbox_f3867_0(PDGamma backgroundColor)
{    this.setColor(BACKGROUND_COLOR, backgroundColor);}
public Object pdfbox_f3868_0()
{    return this.getColorOrFourColors(BORDER_COLOR);}
public void pdfbox_f3869_0(PDGamma borderColor)
{    this.setColor(BORDER_COLOR, borderColor);}
public void pdfbox_f3870_0(PDFourColours borderColors)
{    this.setFourColors(BORDER_COLOR, borderColors);}
public Object pdfbox_f3871_0()
{    return this.getNameOrArrayOfName(BORDER_STYLE, BORDER_STYLE_NONE);}
public void pdfbox_f3872_0(String borderStyle)
{    this.setName(BORDER_STYLE, borderStyle);}
public void pdfbox_f3873_0(String[] borderStyles)
{    this.setArrayOfName(BORDER_STYLE, borderStyles);}
public Object pdfbox_f3874_0()
{    return this.getNumberOrArrayOfNumber(BORDER_THICKNESS, UNSPECIFIED);}
public void pdfbox_f3875_0(float borderThickness)
{    this.setNumber(BORDER_THICKNESS, borderThickness);}
public void pdfbox_f3876_0(int borderThickness)
{    this.setNumber(BORDER_THICKNESS, borderThickness);}
public void pdfbox_f3877_0(float[] borderThicknesses)
{    this.setArrayOfNumber(BORDER_THICKNESS, borderThicknesses);}
public Object pdfbox_f3878_0()
{    return this.getNumberOrArrayOfNumber(PADDING, 0.f);}
public void pdfbox_f3879_0(float padding)
{    this.setNumber(PADDING, padding);}
public void pdfbox_f3880_0(int padding)
{    this.setNumber(PADDING, padding);}
public void pdfbox_f3881_0(float[] paddings)
{    this.setArrayOfNumber(PADDING, paddings);}
public PDGamma pdfbox_f3882_0()
{    return this.getColor(COLOR);}
public void pdfbox_f3883_0(PDGamma color)
{    this.setColor(COLOR, color);}
public float pdfbox_f3884_0()
{    return this.getNumber(SPACE_BEFORE, 0.f);}
public void pdfbox_f3885_0(float spaceBefore)
{    this.setNumber(SPACE_BEFORE, spaceBefore);}
public void pdfbox_f3886_0(int spaceBefore)
{    this.setNumber(SPACE_BEFORE, spaceBefore);}
public float pdfbox_f3887_0()
{    return this.getNumber(SPACE_AFTER, 0.f);}
public void pdfbox_f3888_0(float spaceAfter)
{    this.setNumber(SPACE_AFTER, spaceAfter);}
public void pdfbox_f3889_0(int spaceAfter)
{    this.setNumber(SPACE_AFTER, spaceAfter);}
public float pdfbox_f3890_0()
{    return this.getNumber(START_INDENT, 0.f);}
public void pdfbox_f3891_0(float startIndent)
{    this.setNumber(START_INDENT, startIndent);}
public void pdfbox_f3892_0(int startIndent)
{    this.setNumber(START_INDENT, startIndent);}
public float pdfbox_f3893_0()
{    return this.getNumber(END_INDENT, 0.f);}
public void pdfbox_f3894_0(float endIndent)
{    this.setNumber(END_INDENT, endIndent);}
public void pdfbox_f3895_0(int endIndent)
{    this.setNumber(END_INDENT, endIndent);}
public float pdfbox_f3896_0()
{    return this.getNumber(TEXT_INDENT, 0.f);}
public void pdfbox_f3897_0(float textIndent)
{    this.setNumber(TEXT_INDENT, textIndent);}
public void pdfbox_f3898_0(int textIndent)
{    this.setNumber(TEXT_INDENT, textIndent);}
public String pdfbox_f3899_0()
{    return this.getName(TEXT_ALIGN, TEXT_ALIGN_START);}
public void pdfbox_f3900_0(String textIndent)
{    this.setName(TEXT_ALIGN, textIndent);}
public PDRectangle pdfbox_f3901_0()
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(BBOX);    if (array != null) {        return new PDRectangle(array);    }    return null;}
public void pdfbox_f3902_0(PDRectangle bbox)
{    String name = BBOX;    COSBase oldValue = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, bbox);    COSBase newValue = bbox == null ? null : bbox.getCOSObject();    this.potentiallyNotifyChanged(oldValue, newValue);}
public Object pdfbox_f3903_0()
{    return this.getNumberOrName(WIDTH, WIDTH_AUTO);}
public void pdfbox_f3904_0()
{    this.setName(WIDTH, WIDTH_AUTO);}
public void pdfbox_f3905_0(float width)
{    this.setNumber(WIDTH, width);}
public void pdfbox_f3906_0(int width)
{    this.setNumber(WIDTH, width);}
public Object pdfbox_f3907_0()
{    return this.getNumberOrName(HEIGHT, HEIGHT_AUTO);}
public void pdfbox_f3908_0()
{    this.setName(HEIGHT, HEIGHT_AUTO);}
public void pdfbox_f3909_0(float height)
{    this.setNumber(HEIGHT, height);}
public void pdfbox_f3910_0(int height)
{    this.setNumber(HEIGHT, height);}
public String pdfbox_f3911_0()
{    return this.getName(BLOCK_ALIGN, BLOCK_ALIGN_BEFORE);}
public void pdfbox_f3912_0(String blockAlign)
{    this.setName(BLOCK_ALIGN, blockAlign);}
public String pdfbox_f3913_0()
{    return this.getName(INLINE_ALIGN, INLINE_ALIGN_START);}
public void pdfbox_f3914_0(String inlineAlign)
{    this.setName(INLINE_ALIGN, inlineAlign);}
public Object pdfbox_f3915_0()
{    return this.getNameOrArrayOfName(T_BORDER_STYLE, BORDER_STYLE_NONE);}
public void pdfbox_f3916_0(String tBorderStyle)
{    this.setName(T_BORDER_STYLE, tBorderStyle);}
public void pdfbox_f3917_0(String[] tBorderStyles)
{    this.setArrayOfName(T_BORDER_STYLE, tBorderStyles);}
public Object pdfbox_f3918_0()
{    return this.getNumberOrArrayOfNumber(T_PADDING, 0.f);}
public void pdfbox_f3919_0(float tPadding)
{    this.setNumber(T_PADDING, tPadding);}
public void pdfbox_f3920_0(int tPadding)
{    this.setNumber(T_PADDING, tPadding);}
public void pdfbox_f3921_0(float[] tPaddings)
{    this.setArrayOfNumber(T_PADDING, tPaddings);}
public float pdfbox_f3922_0()
{    return this.getNumber(BASELINE_SHIFT, 0.f);}
public void pdfbox_f3923_0(float baselineShift)
{    this.setNumber(BASELINE_SHIFT, baselineShift);}
public void pdfbox_f3924_0(int baselineShift)
{    this.setNumber(BASELINE_SHIFT, baselineShift);}
public Object pdfbox_f3925_0()
{    return this.getNumberOrName(LINE_HEIGHT, LINE_HEIGHT_NORMAL);}
public void pdfbox_f3926_0()
{    this.setName(LINE_HEIGHT, LINE_HEIGHT_NORMAL);}
public void pdfbox_f3927_0()
{    this.setName(LINE_HEIGHT, LINE_HEIGHT_AUTO);}
public void pdfbox_f3928_0(float lineHeight)
{    this.setNumber(LINE_HEIGHT, lineHeight);}
public void pdfbox_f3929_0(int lineHeight)
{    this.setNumber(LINE_HEIGHT, lineHeight);}
public PDGamma pdfbox_f3930_0()
{    return this.getColor(TEXT_DECORATION_COLOR);}
public void pdfbox_f3931_0(PDGamma textDecorationColor)
{    this.setColor(TEXT_DECORATION_COLOR, textDecorationColor);}
public float pdfbox_f3932_0()
{    return this.getNumber(TEXT_DECORATION_THICKNESS);}
public void pdfbox_f3933_0(float textDecorationThickness)
{    this.setNumber(TEXT_DECORATION_THICKNESS, textDecorationThickness);}
public void pdfbox_f3934_0(int textDecorationThickness)
{    this.setNumber(TEXT_DECORATION_THICKNESS, textDecorationThickness);}
public String pdfbox_f3935_0()
{    return this.getName(TEXT_DECORATION_TYPE, TEXT_DECORATION_TYPE_NONE);}
public void pdfbox_f3936_0(String textDecorationType)
{    this.setName(TEXT_DECORATION_TYPE, textDecorationType);}
public String pdfbox_f3937_0()
{    return this.getName(RUBY_ALIGN, RUBY_ALIGN_DISTRIBUTE);}
public void pdfbox_f3938_0(String rubyAlign)
{    this.setName(RUBY_ALIGN, rubyAlign);}
public String pdfbox_f3939_0()
{    return this.getName(RUBY_POSITION, RUBY_POSITION_BEFORE);}
public void pdfbox_f3940_0(String rubyPosition)
{    this.setName(RUBY_POSITION, rubyPosition);}
public String pdfbox_f3941_0()
{    return this.getName(GLYPH_ORIENTATION_VERTICAL, GLYPH_ORIENTATION_VERTICAL_AUTO);}
public void pdfbox_f3942_0(String glyphOrientationVertical)
{    this.setName(GLYPH_ORIENTATION_VERTICAL, glyphOrientationVertical);}
public int pdfbox_f3943_0()
{    return this.getInteger(COLUMN_COUNT, 1);}
public void pdfbox_f3944_0(int columnCount)
{    this.setInteger(COLUMN_COUNT, columnCount);}
public Object pdfbox_f3945_0()
{    return this.getNumberOrArrayOfNumber(COLUMN_GAP, UNSPECIFIED);}
public void pdfbox_f3946_0(float columnGap)
{    this.setNumber(COLUMN_GAP, columnGap);}
public void pdfbox_f3947_0(int columnGap)
{    this.setNumber(COLUMN_GAP, columnGap);}
public void pdfbox_f3948_0(float[] columnGaps)
{    this.setArrayOfNumber(COLUMN_GAP, columnGaps);}
public Object pdfbox_f3949_0()
{    return this.getNumberOrArrayOfNumber(COLUMN_WIDTHS, UNSPECIFIED);}
public void pdfbox_f3950_0(float columnWidth)
{    this.setNumber(COLUMN_WIDTHS, columnWidth);}
public void pdfbox_f3951_0(int columnWidth)
{    this.setNumber(COLUMN_WIDTHS, columnWidth);}
public void pdfbox_f3952_0(float[] columnWidths)
{    this.setArrayOfNumber(COLUMN_WIDTHS, columnWidths);}
public String pdfbox_f3953_0()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(PLACEMENT)) {        sb.append(", Placement=").append(this.getPlacement());    }    if (this.isSpecified(WRITING_MODE)) {        sb.append(", WritingMode=").append(this.getWritingMode());    }    if (this.isSpecified(BACKGROUND_COLOR)) {        sb.append(", BackgroundColor=").append(this.getBackgroundColor());    }    if (this.isSpecified(BORDER_COLOR)) {        sb.append(", BorderColor=").append(this.getBorderColors());    }    if (this.isSpecified(BORDER_STYLE)) {        Object borderStyle = this.getBorderStyle();        sb.append(", BorderStyle=");        if (borderStyle instanceof String[]) {            sb.append(arrayToString((String[]) borderStyle));        } else {            sb.append(borderStyle);        }    }    if (this.isSpecified(BORDER_THICKNESS)) {        Object borderThickness = this.getBorderThickness();        sb.append(", BorderThickness=");        if (borderThickness instanceof float[]) {            sb.append(arrayToString((float[]) borderThickness));        } else {            sb.append(String.valueOf(borderThickness));        }    }    if (this.isSpecified(PADDING)) {        Object padding = this.getPadding();        sb.append(", Padding=");        if (padding instanceof float[]) {            sb.append(arrayToString((float[]) padding));        } else {            sb.append(String.valueOf(padding));        }    }    if (this.isSpecified(COLOR)) {        sb.append(", Color=").append(this.getColor());    }    if (this.isSpecified(SPACE_BEFORE)) {        sb.append(", SpaceBefore=").append(String.valueOf(this.getSpaceBefore()));    }    if (this.isSpecified(SPACE_AFTER)) {        sb.append(", SpaceAfter=").append(String.valueOf(this.getSpaceAfter()));    }    if (this.isSpecified(START_INDENT)) {        sb.append(", StartIndent=").append(String.valueOf(this.getStartIndent()));    }    if (this.isSpecified(END_INDENT)) {        sb.append(", EndIndent=").append(String.valueOf(this.getEndIndent()));    }    if (this.isSpecified(TEXT_INDENT)) {        sb.append(", TextIndent=").append(String.valueOf(this.getTextIndent()));    }    if (this.isSpecified(TEXT_ALIGN)) {        sb.append(", TextAlign=").append(this.getTextAlign());    }    if (this.isSpecified(BBOX)) {        sb.append(", BBox=").append(this.getBBox());    }    if (this.isSpecified(WIDTH)) {        Object width = this.getWidth();        sb.append(", Width=");        if (width instanceof Float) {            sb.append(String.valueOf(width));        } else {            sb.append(width);        }    }    if (this.isSpecified(HEIGHT)) {        Object height = this.getHeight();        sb.append(", Height=");        if (height instanceof Float) {            sb.append(String.valueOf(height));        } else {            sb.append(height);        }    }    if (this.isSpecified(BLOCK_ALIGN)) {        sb.append(", BlockAlign=").append(this.getBlockAlign());    }    if (this.isSpecified(INLINE_ALIGN)) {        sb.append(", InlineAlign=").append(this.getInlineAlign());    }    if (this.isSpecified(T_BORDER_STYLE)) {        Object tBorderStyle = this.getTBorderStyle();        sb.append(", TBorderStyle=");        if (tBorderStyle instanceof String[]) {            sb.append(arrayToString((String[]) tBorderStyle));        } else {            sb.append(tBorderStyle);        }    }    if (this.isSpecified(T_PADDING)) {        Object tPadding = this.getTPadding();        sb.append(", TPadding=");        if (tPadding instanceof float[]) {            sb.append(arrayToString((float[]) tPadding));        } else {            sb.append(String.valueOf(tPadding));        }    }    if (this.isSpecified(BASELINE_SHIFT)) {        sb.append(", BaselineShift=").append(String.valueOf(this.getBaselineShift()));    }    if (this.isSpecified(LINE_HEIGHT)) {        Object lineHeight = this.getLineHeight();        sb.append(", LineHeight=");        if (lineHeight instanceof Float) {            sb.append(String.valueOf(lineHeight));        } else {            sb.append(lineHeight);        }    }    if (this.isSpecified(TEXT_DECORATION_COLOR)) {        sb.append(", TextDecorationColor=").append(this.getTextDecorationColor());    }    if (this.isSpecified(TEXT_DECORATION_THICKNESS)) {        sb.append(", TextDecorationThickness=").append(String.valueOf(this.getTextDecorationThickness()));    }    if (this.isSpecified(TEXT_DECORATION_TYPE)) {        sb.append(", TextDecorationType=").append(this.getTextDecorationType());    }    if (this.isSpecified(RUBY_ALIGN)) {        sb.append(", RubyAlign=").append(this.getRubyAlign());    }    if (this.isSpecified(RUBY_POSITION)) {        sb.append(", RubyPosition=").append(this.getRubyPosition());    }    if (this.isSpecified(GLYPH_ORIENTATION_VERTICAL)) {        sb.append(", GlyphOrientationVertical=").append(this.getGlyphOrientationVertical());    }    if (this.isSpecified(COLUMN_COUNT)) {        sb.append(", ColumnCount=").append(String.valueOf(this.getColumnCount()));    }    if (this.isSpecified(COLUMN_GAP)) {        Object columnGap = this.getColumnGap();        sb.append(", ColumnGap=");        if (columnGap instanceof float[]) {            sb.append(arrayToString((float[]) columnGap));        } else {            sb.append(String.valueOf(columnGap));        }    }    if (this.isSpecified(COLUMN_WIDTHS)) {        Object columnWidth = this.getColumnWidths();        sb.append(", ColumnWidths=");        if (columnWidth instanceof float[]) {            sb.append(arrayToString((float[]) columnWidth));        } else {            sb.append(String.valueOf(columnWidth));        }    }    return sb.toString();}
public String pdfbox_f3954_0()
{    return this.getName(LIST_NUMBERING, LIST_NUMBERING_NONE);}
public void pdfbox_f3955_0(String listNumbering)
{    this.setName(LIST_NUMBERING, listNumbering);}
public String pdfbox_f3956_0()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(LIST_NUMBERING)) {        sb.append(", ListNumbering=").append(this.getListNumbering());    }    return sb.toString();}
public String pdfbox_f3957_0()
{    return this.getName(ROLE);}
public void pdfbox_f3958_0(String role)
{    this.setName(ROLE, role);}
public String pdfbox_f3959_0()
{    return this.getName(CHECKED, CHECKED_STATE_OFF);}
public void pdfbox_f3960_0(String checkedState)
{    this.setName(CHECKED, checkedState);}
public String pdfbox_f3961_0()
{    return this.getString(DESC);}
public void pdfbox_f3962_0(String alternateName)
{    this.setString(DESC, alternateName);}
public String pdfbox_f3963_0()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(ROLE)) {        sb.append(", Role=").append(this.getRole());    }    if (this.isSpecified(CHECKED)) {        sb.append(", Checked=").append(this.getCheckedState());    }    if (this.isSpecified(DESC)) {        sb.append(", Desc=").append(this.getAlternateName());    }    return sb.toString();}
public boolean pdfbox_f3964_0(String name)
{    return this.getCOSObject().getDictionaryObject(name) != null;}
protected String pdfbox_f3965_0(String name)
{    return this.getCOSObject().getString(name);}
protected void pdfbox_f3966_0(String name, String value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setString(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected String[] pdfbox_f3967_0(String name)
{    COSBase v = this.getCOSObject().getDictionaryObject(name);    if (v instanceof COSArray) {        COSArray array = (COSArray) v;        String[] strings = new String[array.size()];        for (int i = 0; i < array.size(); i++) {            strings[i] = ((COSName) array.getObject(i)).getName();        }        return strings;    }    return null;}
protected void pdfbox_f3968_0(String name, String[] values)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    COSArray array = new COSArray();    for (String value : values) {        array.add(new COSString(value));    }    this.getCOSObject().setItem(name, array);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected String pdfbox_f3969_0(String name)
{    return this.getCOSObject().getNameAsString(name);}
protected String pdfbox_f3970_0(String name, String defaultValue)
{    return this.getCOSObject().getNameAsString(name, defaultValue);}
protected Object pdfbox_f3971_0(String name, String defaultValue)
{    COSBase v = this.getCOSObject().getDictionaryObject(name);    if (v instanceof COSArray) {        COSArray array = (COSArray) v;        String[] names = new String[array.size()];        for (int i = 0; i < array.size(); i++) {            COSBase item = array.getObject(i);            if (item instanceof COSName) {                names[i] = ((COSName) item).getName();            }        }        return names;    }    if (v instanceof COSName) {        return ((COSName) v).getName();    }    return defaultValue;}
protected void pdfbox_f3972_0(String name, String value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setName(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected void pdfbox_f3973_0(String name, String[] values)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    COSArray array = new COSArray();    for (String value : values) {        array.add(COSName.getPDFName(value));    }    this.getCOSObject().setItem(name, array);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected Object pdfbox_f3974_0(String name, String defaultValue)
{    COSBase value = this.getCOSObject().getDictionaryObject(name);    if (value instanceof COSNumber) {        return ((COSNumber) value).floatValue();    }    if (value instanceof COSName) {        return ((COSName) value).getName();    }    return defaultValue;}
protected int pdfbox_f3975_0(String name, int defaultValue)
{    return this.getCOSObject().getInt(name, defaultValue);}
protected void pdfbox_f3976_0(String name, int value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setInt(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected float pdfbox_f3977_0(String name, float defaultValue)
{    return this.getCOSObject().getFloat(name, defaultValue);}
protected float pdfbox_f3978_0(String name)
{    return this.getCOSObject().getFloat(name);}
protected Object pdfbox_f3979_0(String name, float defaultValue)
{    COSBase v = this.getCOSObject().getDictionaryObject(name);    if (v instanceof COSArray) {        COSArray array = (COSArray) v;        float[] values = new float[array.size()];        for (int i = 0; i < array.size(); i++) {            COSBase item = array.getObject(i);            if (item instanceof COSNumber) {                values[i] = ((COSNumber) item).floatValue();            }        }        return values;    }    if (v instanceof COSNumber) {        return ((COSNumber) v).floatValue();    }    if (Float.compare(defaultValue, UNSPECIFIED) == 0) {        return null;    }    return defaultValue;}
protected void pdfbox_f3980_0(String name, float value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setFloat(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected void pdfbox_f3981_0(String name, int value)
{    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setInt(name, value);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected void pdfbox_f3982_0(String name, float[] values)
{    COSArray array = new COSArray();    for (float value : values) {        array.add(new COSFloat(value));    }    COSBase oldBase = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, array);    COSBase newBase = this.getCOSObject().getDictionaryObject(name);    this.potentiallyNotifyChanged(oldBase, newBase);}
protected PDGamma pdfbox_f3983_0(String name)
{    COSArray c = (COSArray) this.getCOSObject().getDictionaryObject(name);    if (c != null) {        return new PDGamma(c);    }    return null;}
protected Object pdfbox_f3984_0(String name)
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(name);    if (array == null) {        return null;    }    if (array.size() == 3) {                return new PDGamma(array);    } else if (array.size() == 4) {        return new PDFourColours(array);    }    return null;}
protected void pdfbox_f3985_0(String name, PDGamma value)
{    COSBase oldValue = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, value);    COSBase newValue = value == null ? null : value.getCOSObject();    this.potentiallyNotifyChanged(oldValue, newValue);}
protected void pdfbox_f3986_0(String name, PDFourColours value)
{    COSBase oldValue = this.getCOSObject().getDictionaryObject(name);    this.getCOSObject().setItem(name, value);    COSBase newValue = value == null ? null : value.getCOSObject();    this.potentiallyNotifyChanged(oldValue, newValue);}
public int pdfbox_f3987_0()
{    return this.getInteger(ROW_SPAN, 1);}
public void pdfbox_f3988_0(int rowSpan)
{    this.setInteger(ROW_SPAN, rowSpan);}
public int pdfbox_f3989_0()
{    return this.getInteger(COL_SPAN, 1);}
public void pdfbox_f3990_0(int colSpan)
{    this.setInteger(COL_SPAN, colSpan);}
public String[] pdfbox_f3991_0()
{    return this.getArrayOfString(HEADERS);}
public void pdfbox_f3992_0(String[] headers)
{    this.setArrayOfString(HEADERS, headers);}
public String pdfbox_f3993_0()
{    return this.getName(SCOPE);}
public void pdfbox_f3994_0(String scope)
{    this.setName(SCOPE, scope);}
public String pdfbox_f3995_0()
{    return this.getString(SUMMARY);}
public void pdfbox_f3996_0(String summary)
{    this.setString(SUMMARY, summary);}
public String pdfbox_f3997_0()
{    StringBuilder sb = new StringBuilder().append(super.toString());    if (this.isSpecified(ROW_SPAN)) {        sb.append(", RowSpan=").append(String.valueOf(this.getRowSpan()));    }    if (this.isSpecified(COL_SPAN)) {        sb.append(", ColSpan=").append(String.valueOf(this.getColSpan()));    }    if (this.isSpecified(HEADERS)) {        sb.append(", Headers=").append(arrayToString(this.getHeaders()));    }    if (this.isSpecified(SCOPE)) {        sb.append(", Scope=").append(this.getScope());    }    if (this.isSpecified(SUMMARY)) {        sb.append(", Summary=").append(this.getSummary());    }    return sb.toString();}
private boolean pdfbox_f3998_0(int bit)
{    return (bytes & (1 << (bit - 1))) != 0;}
private boolean pdfbox_f3999_0(int bit, boolean value)
{    int permissions = bytes;    if (value) {        permissions = permissions | (1 << (bit - 1));    } else {        permissions = permissions & (~(1 << (bit - 1)));    }    bytes = permissions;    return (bytes & (1 << (bit - 1))) != 0;}
public boolean pdfbox_f4000_0()
{    return (this.canAssembleDocument() && this.canExtractContent() && this.canExtractForAccessibility() && this.canFillInForm() && this.canModify() && this.canModifyAnnotations() && this.canPrint() && this.canPrintDegraded());}
public static AccessPermission pdfbox_f4001_0()
{    AccessPermission ret = new AccessPermission();    ret.setCanAssembleDocument(true);    ret.setCanExtractContent(true);    ret.setCanExtractForAccessibility(true);    ret.setCanFillInForm(true);    ret.setCanModify(true);    ret.setCanModifyAnnotations(true);    ret.setCanPrint(true);    ret.setCanPrintDegraded(true);    return ret;}
public int pdfbox_f4002_0()
{    setPermissionBit(1, true);    setPermissionBit(7, false);    setPermissionBit(8, false);    for (int i = 13; i <= 32; i++) {        setPermissionBit(i, false);    }    return bytes;}
public int pdfbox_f4003_0()
{    return bytes;}
public boolean pdfbox_f4004_0()
{    return isPermissionBitOn(PRINT_BIT);}
public void pdfbox_f4005_0(boolean allowPrinting)
{    if (!readOnly) {        setPermissionBit(PRINT_BIT, allowPrinting);    }}
public boolean pdfbox_f4006_0()
{    return isPermissionBitOn(MODIFICATION_BIT);}
public void pdfbox_f4007_0(boolean allowModifications)
{    if (!readOnly) {        setPermissionBit(MODIFICATION_BIT, allowModifications);    }}
public boolean pdfbox_f4008_0()
{    return isPermissionBitOn(EXTRACT_BIT);}
public void pdfbox_f4009_0(boolean allowExtraction)
{    if (!readOnly) {        setPermissionBit(EXTRACT_BIT, allowExtraction);    }}
public boolean pdfbox_f4010_0()
{    return isPermissionBitOn(MODIFY_ANNOTATIONS_BIT);}
public void pdfbox_f4011_0(boolean allowAnnotationModification)
{    if (!readOnly) {        setPermissionBit(MODIFY_ANNOTATIONS_BIT, allowAnnotationModification);    }}
public boolean pdfbox_f4012_0()
{    return isPermissionBitOn(FILL_IN_FORM_BIT);}
public void pdfbox_f4013_0(boolean allowFillingInForm)
{    if (!readOnly) {        setPermissionBit(FILL_IN_FORM_BIT, allowFillingInForm);    }}
public boolean pdfbox_f4014_0()
{    return isPermissionBitOn(EXTRACT_FOR_ACCESSIBILITY_BIT);}
public void pdfbox_f4015_0(boolean allowExtraction)
{    if (!readOnly) {        setPermissionBit(EXTRACT_FOR_ACCESSIBILITY_BIT, allowExtraction);    }}
public boolean pdfbox_f4016_0()
{    return isPermissionBitOn(ASSEMBLE_DOCUMENT_BIT);}
public void pdfbox_f4017_0(boolean allowAssembly)
{    if (!readOnly) {        setPermissionBit(ASSEMBLE_DOCUMENT_BIT, allowAssembly);    }}
public boolean pdfbox_f4018_0()
{    return isPermissionBitOn(DEGRADED_PRINT_BIT);}
public void pdfbox_f4019_0(boolean canPrintDegraded)
{    if (!readOnly) {        setPermissionBit(DEGRADED_PRINT_BIT, canPrintDegraded);    }}
public void pdfbox_f4020_0()
{    readOnly = true;}
public boolean pdfbox_f4021_0()
{    return readOnly;}
protected boolean pdfbox_f4022_0()
{    if (canFillInForm()) {        return true;    }    if (canExtractForAccessibility()) {        return true;    }    if (canAssembleDocument()) {        return true;    }    return canPrintDegraded();}
 static MessageDigest pdfbox_f4023_0()
{    try {        return MessageDigest.getInstance("MD5");    } catch (NoSuchAlgorithmException e) {                throw new RuntimeException(e);    }}
 static MessageDigest pdfbox_f4024_0()
{    try {        return MessageDigest.getInstance("SHA-1");    } catch (NoSuchAlgorithmException e) {                throw new RuntimeException(e);    }}
 static MessageDigest pdfbox_f4025_0()
{    try {        return MessageDigest.getInstance("SHA-256");    } catch (NoSuchAlgorithmException e) {                throw new RuntimeException(e);    }}
public COSDictionary pdfbox_f4026_0()
{    return cryptFilterDictionary;}
public void pdfbox_f4027_0(int length)
{    cryptFilterDictionary.setInt(COSName.LENGTH, length);}
public int pdfbox_f4028_0()
{    return cryptFilterDictionary.getInt(COSName.LENGTH, 40);}
public void pdfbox_f4029_0(COSName cfm)
{    cryptFilterDictionary.setItem(COSName.CFM, cfm);}
public COSName pdfbox_f4030_0()
{    return (COSName) cryptFilterDictionary.getDictionaryObject(COSName.CFM);}
public SecurityHandler pdfbox_f4031_0() throws IOException
{    if (securityHandler == null) {        throw new IOException("No security handler for filter " + getFilter());    }    return securityHandler;}
public void pdfbox_f4032_0(SecurityHandler securityHandler)
{    this.securityHandler = securityHandler;}
public boolean pdfbox_f4033_0()
{    return securityHandler == null;}
public COSDictionary pdfbox_f4034_0()
{    return dictionary;}
public void pdfbox_f4035_0(String filter)
{    dictionary.setItem(COSName.FILTER, COSName.getPDFName(filter));}
public final String pdfbox_f4036_0()
{    return dictionary.getNameAsString(COSName.FILTER);}
public String pdfbox_f4037_0()
{    return dictionary.getNameAsString(COSName.SUB_FILTER);}
public void pdfbox_f4038_0(String subfilter)
{    dictionary.setName(COSName.SUB_FILTER, subfilter);}
public void pdfbox_f4039_0(int version)
{    dictionary.setInt(COSName.V, version);}
public int pdfbox_f4040_0()
{    return dictionary.getInt(COSName.V, 0);}
public void pdfbox_f4041_0(int length)
{    dictionary.setInt(COSName.LENGTH, length);}
public int pdfbox_f4042_0()
{    return dictionary.getInt(COSName.LENGTH, 40);}
public void pdfbox_f4043_0(int revision)
{    dictionary.setInt(COSName.R, revision);}
public int pdfbox_f4044_0()
{    return dictionary.getInt(COSName.R, DEFAULT_VERSION);}
public void pdfbox_f4045_0(byte[] o) throws IOException
{    dictionary.setItem(COSName.O, new COSString(o));}
public byte[] pdfbox_f4046_0() throws IOException
{    byte[] o = null;    COSString owner = (COSString) dictionary.getDictionaryObject(COSName.O);    if (owner != null) {        o = owner.getBytes();    }    return o;}
public void pdfbox_f4047_0(byte[] u) throws IOException
{    dictionary.setItem(COSName.U, new COSString(u));}
public byte[] pdfbox_f4048_0() throws IOException
{    byte[] u = null;    COSString user = (COSString) dictionary.getDictionaryObject(COSName.U);    if (user != null) {        u = user.getBytes();    }    return u;}
public void pdfbox_f4049_0(byte[] oe) throws IOException
{    dictionary.setItem(COSName.OE, new COSString(oe));}
public byte[] pdfbox_f4050_0() throws IOException
{    byte[] oe = null;    COSString ownerEncryptionKey = (COSString) dictionary.getDictionaryObject(COSName.OE);    if (ownerEncryptionKey != null) {        oe = ownerEncryptionKey.getBytes();    }    return oe;}
public void pdfbox_f4051_0(byte[] ue) throws IOException
{    dictionary.setItem(COSName.UE, new COSString(ue));}
public byte[] pdfbox_f4052_0() throws IOException
{    byte[] ue = null;    COSString userEncryptionKey = (COSString) dictionary.getDictionaryObject(COSName.UE);    if (userEncryptionKey != null) {        ue = userEncryptionKey.getBytes();    }    return ue;}
public void pdfbox_f4053_0(int permissions)
{    dictionary.setInt(COSName.P, permissions);}
public int pdfbox_f4054_0()
{    return dictionary.getInt(COSName.P, 0);}
public boolean pdfbox_f4055_0()
{        boolean encryptMetaData = true;    COSBase value = dictionary.getDictionaryObject(COSName.ENCRYPT_META_DATA);    if (value instanceof COSBoolean) {        encryptMetaData = ((COSBoolean) value).getValue();    }    return encryptMetaData;}
public void pdfbox_f4056_0(byte[][] recipients) throws IOException
{    COSArray array = new COSArray();    for (byte[] recipient : recipients) {        COSString recip = new COSString(recipient);        array.add(recip);    }    dictionary.setItem(COSName.RECIPIENTS, array);    array.setDirect(true);}
public int pdfbox_f4057_0()
{    COSArray array = (COSArray) dictionary.getItem(COSName.RECIPIENTS);    return array.size();}
public COSString pdfbox_f4058_0(int i)
{    COSArray array = (COSArray) dictionary.getItem(COSName.RECIPIENTS);    return (COSString) array.get(i);}
public PDCryptFilterDictionary pdfbox_f4059_0()
{    return getCryptFilterDictionary(COSName.STD_CF);}
public PDCryptFilterDictionary pdfbox_f4060_0()
{    return getCryptFilterDictionary(COSName.DEFAULT_CRYPT_FILTER);}
public PDCryptFilterDictionary pdfbox_f4061_0(COSName cryptFilterName)
{        COSBase base = dictionary.getDictionaryObject(COSName.CF);    if (base instanceof COSDictionary) {        COSBase base2 = ((COSDictionary) base).getDictionaryObject(cryptFilterName);        if (base2 instanceof COSDictionary) {            return new PDCryptFilterDictionary((COSDictionary) base2);        }    }    return null;}
public void pdfbox_f4062_0(COSName cryptFilterName, PDCryptFilterDictionary cryptFilterDictionary)
{    COSDictionary cfDictionary = dictionary.getCOSDictionary(COSName.CF);    if (cfDictionary == null) {        cfDictionary = new COSDictionary();        dictionary.setItem(COSName.CF, cfDictionary);    }        cfDictionary.setDirect(true);    cfDictionary.setItem(cryptFilterName, cryptFilterDictionary.getCOSObject());}
public void pdfbox_f4063_0(PDCryptFilterDictionary cryptFilterDictionary)
{        cryptFilterDictionary.getCOSObject().setDirect(true);    setCryptFilterDictionary(COSName.STD_CF, cryptFilterDictionary);}
public void pdfbox_f4064_0(PDCryptFilterDictionary defaultFilterDictionary)
{        defaultFilterDictionary.getCOSObject().setDirect(true);    setCryptFilterDictionary(COSName.DEFAULT_CRYPT_FILTER, defaultFilterDictionary);}
public COSName pdfbox_f4065_0()
{    COSName stmF = (COSName) dictionary.getDictionaryObject(COSName.STM_F);    if (stmF == null) {        stmF = COSName.IDENTITY;    }    return stmF;}
public void pdfbox_f4066_0(COSName streamFilterName)
{    dictionary.setItem(COSName.STM_F, streamFilterName);}
public COSName pdfbox_f4067_0()
{    COSName strF = (COSName) dictionary.getDictionaryObject(COSName.STR_F);    if (strF == null) {        strF = COSName.IDENTITY;    }    return strF;}
public void pdfbox_f4068_0(COSName stringFilterName)
{    dictionary.setItem(COSName.STR_F, stringFilterName);}
public void pdfbox_f4069_0(byte[] perms) throws IOException
{    dictionary.setItem(COSName.PERMS, new COSString(perms));}
public byte[] pdfbox_f4070_0() throws IOException
{    byte[] perms = null;    COSString permsCosString = (COSString) dictionary.getDictionaryObject(COSName.PERMS);    if (permsCosString != null) {        perms = permsCosString.getBytes();    }    return perms;}
public void pdfbox_f4071_0()
{    dictionary.setItem(COSName.CF, null);    dictionary.setItem(COSName.STM_F, null);    dictionary.setItem(COSName.STR_F, null);}
public void pdfbox_f4072_0(int l)
{    if (l != 40 && l != 128 && l != 256) {        throw new IllegalArgumentException("Invalid key length '" + l + "' value must be 40, 128 or 256!");    }    encryptionKeyLength = l;}
public int pdfbox_f4073_0()
{    return encryptionKeyLength;}
public X509Certificate pdfbox_f4074_0() throws KeyStoreException
{    if (keyStore.size() == 1) {        Enumeration<String> aliases = keyStore.aliases();        String keyStoreAlias = aliases.nextElement();        return (X509Certificate) keyStore.getCertificate(keyStoreAlias);    } else {        if (keyStore.containsAlias(alias)) {            return (X509Certificate) keyStore.getCertificate(alias);        }        throw new KeyStoreException("the keystore does not contain the given alias");    }}
public String pdfbox_f4075_0()
{    return password;}
public Key pdfbox_f4076_0() throws KeyStoreException
{    try {        if (keyStore.size() == 1) {            Enumeration<String> aliases = keyStore.aliases();            String keyStoreAlias = aliases.nextElement();            return keyStore.getKey(keyStoreAlias, password.toCharArray());        } else {            if (keyStore.containsAlias(alias)) {                return keyStore.getKey(alias, password.toCharArray());            }            throw new KeyStoreException("the keystore does not contain the given alias");        }    } catch (UnrecoverableKeyException ex) {        throw new KeyStoreException("the private key is not recoverable", ex);    } catch (NoSuchAlgorithmException ex) {        throw new KeyStoreException("the algorithm necessary to recover the key is not available", ex);    }}
public void pdfbox_f4077_0(PublicKeyRecipient recipient)
{    recipients.add(recipient);}
public boolean pdfbox_f4078_0(PublicKeyRecipient recipient)
{    return recipients.remove(recipient);}
public Iterator<PublicKeyRecipient> pdfbox_f4079_0()
{    return recipients.iterator();}
public X509Certificate pdfbox_f4080_0()
{    return decryptionCertificate;}
public void pdfbox_f4081_0(X509Certificate decryptionCertificate)
{    this.decryptionCertificate = decryptionCertificate;}
public int pdfbox_f4082_0()
{    return recipients.size();}
public X509Certificate pdfbox_f4083_0()
{    return x509;}
public void pdfbox_f4084_0(X509Certificate aX509)
{    this.x509 = aX509;}
public AccessPermission pdfbox_f4085_0()
{    return permission;}
public void pdfbox_f4086_0(AccessPermission permissions)
{    this.permission = permissions;}
public void pdfbox_f4087_0(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException
{    if (!(decryptionMaterial instanceof PublicKeyDecryptionMaterial)) {        throw new IOException("Provided decryption material is not compatible with the document");    }    setDecryptMetadata(encryption.isEncryptMetaData());    if (encryption.getLength() != 0) {        this.keyLength = encryption.getLength();    }    PublicKeyDecryptionMaterial material = (PublicKeyDecryptionMaterial) decryptionMaterial;    try {        boolean foundRecipient = false;        X509Certificate certificate = material.getCertificate();        X509CertificateHolder materialCert = null;        if (certificate != null) {            materialCert = new X509CertificateHolder(certificate.getEncoded());        }                        byte[] envelopedData = null;                COSArray array = (COSArray) encryption.getCOSObject().getItem(COSName.RECIPIENTS);        if (array == null) {            PDCryptFilterDictionary defaultCryptFilterDictionary = encryption.getDefaultCryptFilterDictionary();            array = (COSArray) defaultCryptFilterDictionary.getCOSObject().getItem(COSName.RECIPIENTS);        }        byte[][] recipientFieldsBytes = new byte[array.size()][];                int recipientFieldsLength = 0;        StringBuilder extraInfo = new StringBuilder();        for (int i = 0; i < array.size(); i++) {            COSString recipientFieldString = (COSString) array.getObject(i);            byte[] recipientBytes = recipientFieldString.getBytes();            CMSEnvelopedData data = new CMSEnvelopedData(recipientBytes);            Collection<RecipientInformation> recipCertificatesIt = data.getRecipientInfos().getRecipients();            int j = 0;            for (RecipientInformation ri : recipCertificatesIt) {                                                RecipientId rid = ri.getRID();                if (!foundRecipient && rid.match(materialCert)) {                    foundRecipient = true;                    PrivateKey privateKey = (PrivateKey) material.getPrivateKey();                                                            envelopedData = ri.getContent(new JceKeyTransEnvelopedRecipient(privateKey));                    break;                }                j++;                if (certificate != null) {                    extraInfo.append('\n');                    extraInfo.append(j);                    extraInfo.append(": ");                    if (rid instanceof KeyTransRecipientId) {                        appendCertInfo(extraInfo, (KeyTransRecipientId) rid, certificate, materialCert);                    }                }            }            recipientFieldsBytes[i] = recipientBytes;            recipientFieldsLength += recipientBytes.length;        }        if (!foundRecipient || envelopedData == null) {            throw new IOException("The certificate matches none of " + array.size() + " recipient entries" + extraInfo.toString());        }        if (envelopedData.length != 24) {            throw new IOException("The enveloped data does not contain 24 bytes");        }                                byte[] accessBytes = new byte[4];        System.arraycopy(envelopedData, 20, accessBytes, 0, 4);        AccessPermission currentAccessPermission = new AccessPermission(accessBytes);        currentAccessPermission.setReadOnly();        setCurrentAccessPermission(currentAccessPermission);                byte[] sha1Input = new byte[recipientFieldsLength + 20];                System.arraycopy(envelopedData, 0, sha1Input, 0, 20);                int sha1InputOffset = 20;        for (byte[] recipientFieldsByte : recipientFieldsBytes) {            System.arraycopy(recipientFieldsByte, 0, sha1Input, sha1InputOffset, recipientFieldsByte.length);            sha1InputOffset += recipientFieldsByte.length;        }        byte[] mdResult;        if (encryption.getVersion() == 4 || encryption.getVersion() == 5) {            mdResult = MessageDigests.getSHA256().digest(sha1Input);                                                PDCryptFilterDictionary defaultCryptFilterDictionary = encryption.getDefaultCryptFilterDictionary();            if (defaultCryptFilterDictionary != null) {                COSName cryptFilterMethod = defaultCryptFilterDictionary.getCryptFilterMethod();                setAES(COSName.AESV2.equals(cryptFilterMethod) || COSName.AESV3.equals(cryptFilterMethod));            }        } else {            mdResult = MessageDigests.getSHA1().digest(sha1Input);        }                encryptionKey = new byte[this.keyLength / 8];        System.arraycopy(mdResult, 0, encryptionKey, 0, this.keyLength / 8);    } catch (CMSException | KeyStoreException | CertificateEncodingException e) {        throw new IOException(e);    }}
private void pdfbox_f4088_0(StringBuilder extraInfo, KeyTransRecipientId ktRid, X509Certificate certificate, X509CertificateHolder materialCert)
{    BigInteger ridSerialNumber = ktRid.getSerialNumber();    if (ridSerialNumber != null) {        String certSerial = "unknown";        BigInteger certSerialNumber = certificate.getSerialNumber();        if (certSerialNumber != null) {            certSerial = certSerialNumber.toString(16);        }        extraInfo.append("serial-#: rid ");        extraInfo.append(ridSerialNumber.toString(16));        extraInfo.append(" vs. cert ");        extraInfo.append(certSerial);        extraInfo.append(" issuer: rid \'");        extraInfo.append(ktRid.getIssuer());        extraInfo.append("\' vs. cert \'");        extraInfo.append(materialCert == null ? "null" : materialCert.getIssuer());        extraInfo.append("\' ");    }}
public void pdfbox_f4089_0(PDDocument doc) throws IOException
{    try {        PDEncryption dictionary = doc.getEncryption();        if (dictionary == null) {            dictionary = new PDEncryption();        }        dictionary.setFilter(FILTER);        dictionary.setLength(this.keyLength);        int version = computeVersionNumber();        dictionary.setVersion(version);                dictionary.removeV45filters();                byte[] seed = new byte[20];        KeyGenerator key;        try {            key = KeyGenerator.getInstance("AES");        } catch (NoSuchAlgorithmException e) {                        throw new RuntimeException(e);        }        key.init(192, new SecureRandom());        SecretKey sk = key.generateKey();                System.arraycopy(sk.getEncoded(), 0, seed, 0, 20);        byte[][] recipientsFields = computeRecipientsField(seed);        int shaInputLength = seed.length;        for (byte[] field : recipientsFields) {            shaInputLength += field.length;        }        byte[] shaInput = new byte[shaInputLength];        System.arraycopy(seed, 0, shaInput, 0, 20);        int shaInputOffset = 20;        for (byte[] recipientsField : recipientsFields) {            System.arraycopy(recipientsField, 0, shaInput, shaInputOffset, recipientsField.length);            shaInputOffset += recipientsField.length;        }        byte[] mdResult;        if (version == 4 || version == 5) {            dictionary.setSubFilter(SUBFILTER5);            mdResult = MessageDigests.getSHA256().digest(shaInput);            COSName aesVName = version == 5 ? COSName.AESV3 : COSName.AESV2;            prepareEncryptionDictAES(dictionary, aesVName, recipientsFields);        } else {            dictionary.setSubFilter(SUBFILTER4);            mdResult = MessageDigests.getSHA1().digest(shaInput);            dictionary.setRecipients(recipientsFields);        }        this.encryptionKey = new byte[this.keyLength / 8];        System.arraycopy(mdResult, 0, this.encryptionKey, 0, this.keyLength / 8);        doc.setEncryptionDictionary(dictionary);        doc.getDocument().setEncryptionDictionary(dictionary.getCOSObject());    } catch (GeneralSecurityException e) {        throw new IOException(e);    }}
private int pdfbox_f4090_0()
{    switch(keyLength) {        case 40:            return 1;        case 128:                        return 2;                case 256:            return 5;        default:            throw new IllegalArgumentException("key length must be 40, 128 or 256");    }}
private void pdfbox_f4091_0(PDEncryption encryptionDictionary, COSName aesVName, byte[][] recipients)
{    PDCryptFilterDictionary cryptFilterDictionary = new PDCryptFilterDictionary();    cryptFilterDictionary.setCryptFilterMethod(aesVName);    cryptFilterDictionary.setLength(keyLength);    COSArray array = new COSArray();    for (byte[] recipient : recipients) {        array.add(new COSString(recipient));    }    cryptFilterDictionary.getCOSObject().setItem(COSName.RECIPIENTS, array);    array.setDirect(true);    encryptionDictionary.setDefaultCryptFilterDictionary(cryptFilterDictionary);    encryptionDictionary.setStreamFilterName(COSName.DEFAULT_CRYPT_FILTER);    encryptionDictionary.setStringFilterName(COSName.DEFAULT_CRYPT_FILTER);    cryptFilterDictionary.getCOSObject().setDirect(true);    setAES(true);}
private byte[][] pdfbox_f4092_0(byte[] seed) throws GeneralSecurityException, IOException
{    byte[][] recipientsField = new byte[policy.getNumberOfRecipients()][];    Iterator<PublicKeyRecipient> it = policy.getRecipientsIterator();    int i = 0;    while (it.hasNext()) {        PublicKeyRecipient recipient = it.next();        X509Certificate certificate = recipient.getX509();        int permission = recipient.getPermission().getPermissionBytesForPublicKey();        byte[] pkcs7input = new byte[24];        byte one = (byte) (permission);        byte two = (byte) (permission >>> 8);        byte three = (byte) (permission >>> 16);        byte four = (byte) (permission >>> 24);                System.arraycopy(seed, 0, pkcs7input, 0, 20);        pkcs7input[20] = four;        pkcs7input[21] = three;        pkcs7input[22] = two;        pkcs7input[23] = one;        ASN1Primitive obj = createDERForRecipient(pkcs7input, certificate);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        obj.encodeTo(baos, ASN1Encoding.DER);        recipientsField[i] = baos.toByteArray();        i++;    }    return recipientsField;}
private ASN1Primitive pdfbox_f4093_0(byte[] in, X509Certificate cert) throws IOException, GeneralSecurityException
{    String algorithm = PKCSObjectIdentifiers.RC2_CBC.getId();    AlgorithmParameterGenerator apg;    KeyGenerator keygen;    Cipher cipher;    try {        apg = AlgorithmParameterGenerator.getInstance(algorithm, SecurityProvider.getProvider());        keygen = KeyGenerator.getInstance(algorithm, SecurityProvider.getProvider());        cipher = Cipher.getInstance(algorithm, SecurityProvider.getProvider());    } catch (NoSuchAlgorithmException e) {                throw new IOException("Could not find a suitable javax.crypto provider for algorithm " + algorithm + "; possible reason: using an unsigned .jar file", e);    } catch (NoSuchPaddingException e) {                throw new RuntimeException("Could not find a suitable javax.crypto provider", e);    }    AlgorithmParameters parameters = apg.generateParameters();    ASN1Primitive object;    try (ASN1InputStream input = new ASN1InputStream(parameters.getEncoded("ASN.1"))) {        object = input.readObject();    }    keygen.init(128);    SecretKey secretkey = keygen.generateKey();    cipher.init(1, secretkey, parameters);    byte[] bytes = cipher.doFinal(in);    KeyTransRecipientInfo recipientInfo = computeRecipientInfo(cert, secretkey.getEncoded());    DERSet set = new DERSet(new RecipientInfo(recipientInfo));    AlgorithmIdentifier algorithmId = new AlgorithmIdentifier(new ASN1ObjectIdentifier(algorithm), object);    EncryptedContentInfo encryptedInfo = new EncryptedContentInfo(PKCSObjectIdentifiers.data, algorithmId, new DEROctetString(bytes));    EnvelopedData enveloped = new EnvelopedData(null, set, encryptedInfo, (ASN1Set) null);    ContentInfo contentInfo = new ContentInfo(PKCSObjectIdentifiers.envelopedData, enveloped);    return contentInfo.toASN1Primitive();}
private KeyTransRecipientInfo pdfbox_f4094_0(X509Certificate x509certificate, byte[] abyte0) throws IOException, CertificateEncodingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException
{    TBSCertificate certificate;    try (ASN1InputStream input = new ASN1InputStream(x509certificate.getTBSCertificate())) {        certificate = TBSCertificate.getInstance(input.readObject());    }    AlgorithmIdentifier algorithmId = certificate.getSubjectPublicKeyInfo().getAlgorithm();    IssuerAndSerialNumber serial = new IssuerAndSerialNumber(certificate.getIssuer(), certificate.getSerialNumber().getValue());    Cipher cipher;    try {        cipher = Cipher.getInstance(algorithmId.getAlgorithm().getId(), SecurityProvider.getProvider());    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {                throw new RuntimeException("Could not find a suitable javax.crypto provider", e);    }    cipher.init(1, x509certificate.getPublicKey());    DEROctetString octets = new DEROctetString(cipher.doFinal(abyte0));    RecipientIdentifier recipientId = new RecipientIdentifier(serial);    return new KeyTransRecipientInfo(recipientId, algorithmId, octets);}
public boolean pdfbox_f4095_0()
{    return policy != null;}
public void pdfbox_f4096_0(byte[] key)
{    b = 0;    c = 0;    if (key.length < 1 || key.length > 32) {        throw new IllegalArgumentException("number of bytes must be between 1 and 32");    }    for (int i = 0; i < salt.length; i++) {        salt[i] = i;    }    int keyIndex = 0;    int saltIndex = 0;    for (int i = 0; i < salt.length; i++) {        saltIndex = (fixByte(key[keyIndex]) + salt[i] + saltIndex) % 256;        swap(salt, i, saltIndex);        keyIndex = (keyIndex + 1) % key.length;    }}
private static int pdfbox_f4097_0(byte aByte)
{    return aByte < 0 ? 256 + aByte : aByte;}
private static void pdfbox_f4098_0(int[] data, int firstIndex, int secondIndex)
{    int tmp = data[firstIndex];    data[firstIndex] = data[secondIndex];    data[secondIndex] = tmp;}
public void pdfbox_f4099_0(byte aByte, OutputStream output) throws IOException
{    b = (b + 1) % 256;    c = (salt[b] + c) % 256;    swap(salt, b, c);    int saltIndex = (salt[b] + salt[c]) % 256;    output.write(aByte ^ (byte) salt[saltIndex]);}
public void pdfbox_f4100_0(byte[] data, OutputStream output) throws IOException
{    for (byte aData : data) {        write(aData, output);    }}
public void pdfbox_f4101_0(InputStream data, OutputStream output) throws IOException
{    byte[] buffer = new byte[1024];    int amountRead;    while ((amountRead = data.read(buffer)) != -1) {        write(buffer, 0, amountRead, output);    }}
public void pdfbox_f4102_0(byte[] data, int offset, int len, OutputStream output) throws IOException
{    for (int i = offset; i < offset + len; i++) {        write(data[i], output);    }}
 static String pdfbox_f4103_0(String str)
{    return saslPrep(str, true);}
 static String pdfbox_f4104_0(String str)
{    return saslPrep(str, false);}
private static String pdfbox_f4105_0(String str, boolean allowUnassigned)
{    char[] chars = str.toCharArray();        for (int i = 0; i < str.length(); i++) {        char ch = str.charAt(i);        if (nonAsciiSpace(ch)) {            chars[i] = ' ';        }    }    int length = 0;    for (int i = 0; i < str.length(); i++) {        char ch = chars[i];        if (!mappedToNothing(ch)) {            chars[length++] = ch;        }    }        String normalized = Normalizer.normalize(CharBuffer.wrap(chars, 0, length), Normalizer.Form.NFKC);    boolean containsRandALCat = false;    boolean containsLCat = false;    boolean initialRandALCat = false;    int i = 0;    while (i < normalized.length()) {        final int codepoint = normalized.codePointAt(i);                if (prohibited(codepoint)) {            throw new IllegalArgumentException("Prohibited character '" + Character.getName(codepoint) + "' at position " + i);        }                final byte directionality = Character.getDirectionality(codepoint);        final boolean isRandALcat = directionality == Character.DIRECTIONALITY_RIGHT_TO_LEFT || directionality == Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC;        containsRandALCat |= isRandALcat;        containsLCat |= directionality == Character.DIRECTIONALITY_LEFT_TO_RIGHT;        initialRandALCat |= i == 0 && isRandALcat;        if (!allowUnassigned && !Character.isDefined(codepoint)) {            throw new IllegalArgumentException("Character at position " + i + " is unassigned");        }        i += Character.charCount(codepoint);        if (initialRandALCat && i >= normalized.length() && !isRandALcat) {            throw new IllegalArgumentException("First character is RandALCat, but last character is not");        }    }    if (containsRandALCat && containsLCat) {        throw new IllegalArgumentException("Contains both RandALCat characters and LCat characters");    }    return normalized;}
 static boolean pdfbox_f4106_0(int codepoint)
{    return nonAsciiSpace((char) codepoint) || asciiControl((char) codepoint) || nonAsciiControl(codepoint) || privateUse(codepoint) || nonCharacterCodePoint(codepoint) || surrogateCodePoint(codepoint) || inappropriateForPlainText(codepoint) || inappropriateForCanonical(codepoint) || changeDisplayProperties(codepoint) || tagging(codepoint);}
private static boolean pdfbox_f4107_0(int codepoint)
{    return codepoint == 0xE0001 || 0xE0020 <= codepoint && codepoint <= 0xE007F;}
private static boolean pdfbox_f4108_0(int codepoint)
{    return codepoint == 0x0340 || codepoint == 0x0341 || codepoint == 0x200E || codepoint == 0x200F || codepoint == 0x202A || codepoint == 0x202B || codepoint == 0x202C || codepoint == 0x202D || codepoint == 0x202E || codepoint == 0x206A || codepoint == 0x206B || codepoint == 0x206C || codepoint == 0x206D || codepoint == 0x206E || codepoint == 0x206F;}
private static boolean pdfbox_f4109_0(int codepoint)
{    return 0x2FF0 <= codepoint && codepoint <= 0x2FFB;}
private static boolean pdfbox_f4110_0(int codepoint)
{    return codepoint == 0xFFF9 || codepoint == 0xFFFA || codepoint == 0xFFFB || codepoint == 0xFFFC || codepoint == 0xFFFD;}
private static boolean pdfbox_f4111_0(int codepoint)
{    return 0xD800 <= codepoint && codepoint <= 0xDFFF;}
private static boolean pdfbox_f4112_0(int codepoint)
{    return 0xFDD0 <= codepoint && codepoint <= 0xFDEF || 0xFFFE <= codepoint && codepoint <= 0xFFFF || 0x1FFFE <= codepoint && codepoint <= 0x1FFFF || 0x2FFFE <= codepoint && codepoint <= 0x2FFFF || 0x3FFFE <= codepoint && codepoint <= 0x3FFFF || 0x4FFFE <= codepoint && codepoint <= 0x4FFFF || 0x5FFFE <= codepoint && codepoint <= 0x5FFFF || 0x6FFFE <= codepoint && codepoint <= 0x6FFFF || 0x7FFFE <= codepoint && codepoint <= 0x7FFFF || 0x8FFFE <= codepoint && codepoint <= 0x8FFFF || 0x9FFFE <= codepoint && codepoint <= 0x9FFFF || 0xAFFFE <= codepoint && codepoint <= 0xAFFFF || 0xBFFFE <= codepoint && codepoint <= 0xBFFFF || 0xCFFFE <= codepoint && codepoint <= 0xCFFFF || 0xDFFFE <= codepoint && codepoint <= 0xDFFFF || 0xEFFFE <= codepoint && codepoint <= 0xEFFFF || 0xFFFFE <= codepoint && codepoint <= 0xFFFFF || 0x10FFFE <= codepoint && codepoint <= 0x10FFFF;}
private static boolean pdfbox_f4113_0(int codepoint)
{    return 0xE000 <= codepoint && codepoint <= 0xF8FF || 0xF0000 <= codepoint && codepoint <= 0xFFFFD || 0x100000 <= codepoint && codepoint <= 0x10FFFD;}
private static boolean pdfbox_f4114_0(int codepoint)
{    return 0x0080 <= codepoint && codepoint <= 0x009F || codepoint == 0x06DD || codepoint == 0x070F || codepoint == 0x180E || codepoint == 0x200C || codepoint == 0x200D || codepoint == 0x2028 || codepoint == 0x2029 || codepoint == 0x2060 || codepoint == 0x2061 || codepoint == 0x2062 || codepoint == 0x2063 || 0x206A <= codepoint && codepoint <= 0x206F || codepoint == 0xFEFF || 0xFFF9 <= codepoint && codepoint <= 0xFFFC || 0x1D173 <= codepoint && codepoint <= 0x1D17A;}
private static boolean pdfbox_f4115_0(char ch)
{    return '\u0000' <= ch && ch <= '\u001F' || ch == '\u007F';}
private static boolean pdfbox_f4116_0(char ch)
{    return ch == '\u00A0' || ch == '\u1680' || '\u2000' <= ch && ch <= '\u200B' || ch == '\u202F' || ch == '\u205F' || ch == '\u3000';}
private static boolean pdfbox_f4117_0(char ch)
{    return ch == '\u00AD' || ch == '\u034F' || ch == '\u1806' || ch == '\u180B' || ch == '\u180C' || ch == '\u180D' || ch == '\u200B' || ch == '\u200C' || ch == '\u200D' || ch == '\u2060' || '\uFE00' <= ch && ch <= '\uFE0F' || ch == '\uFEFF';}
protected void pdfbox_f4118_0(boolean decryptMetadata)
{    this.decryptMetadata = decryptMetadata;}
protected void pdfbox_f4119_0(COSName stringFilterName)
{    this.stringFilterName = stringFilterName;}
protected void pdfbox_f4120_0(COSName streamFilterName)
{    this.streamFilterName = streamFilterName;}
private void pdfbox_f4121_0(long objectNumber, long genNumber, InputStream data, OutputStream output, boolean decrypt) throws IOException
{        if (useAES && encryptionKey.length == 32) {        encryptDataAES256(data, output, decrypt);    } else {        byte[] finalKey = calcFinalKey(objectNumber, genNumber);        if (useAES) {            encryptDataAESother(finalKey, data, output, decrypt);        } else {            encryptDataRC4(finalKey, data, output);        }    }    output.flush();}
private byte[] pdfbox_f4122_0(long objectNumber, long genNumber)
{    byte[] newKey = new byte[encryptionKey.length + 5];    System.arraycopy(encryptionKey, 0, newKey, 0, encryptionKey.length);                    newKey[newKey.length - 5] = (byte) (objectNumber & 0xff);    newKey[newKey.length - 4] = (byte) (objectNumber >> 8 & 0xff);    newKey[newKey.length - 3] = (byte) (objectNumber >> 16 & 0xff);    newKey[newKey.length - 2] = (byte) (genNumber & 0xff);    newKey[newKey.length - 1] = (byte) (genNumber >> 8 & 0xff);        MessageDigest md = MessageDigests.getMD5();    md.update(newKey);    if (useAES) {        md.update(AES_SALT);    }    byte[] digestedKey = md.digest();        int length = Math.min(newKey.length, 16);    byte[] finalKey = new byte[length];    System.arraycopy(digestedKey, 0, finalKey, 0, length);    return finalKey;}
protected void pdfbox_f4123_0(byte[] finalKey, InputStream input, OutputStream output) throws IOException
{    rc4.setKey(finalKey);    rc4.write(input, output);}
protected void pdfbox_f4124_0(byte[] finalKey, byte[] input, OutputStream output) throws IOException
{    rc4.setKey(finalKey);    rc4.write(input, output);}
private void pdfbox_f4125_0(byte[] finalKey, InputStream data, OutputStream output, boolean decrypt) throws IOException
{    byte[] iv = new byte[16];    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {        return;    }    try {        Cipher decryptCipher;        try {            decryptCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");        } catch (NoSuchAlgorithmException e) {                        throw new RuntimeException(e);        }        SecretKey aesKey = new SecretKeySpec(finalKey, "AES");        IvParameterSpec ips = new IvParameterSpec(iv);        decryptCipher.init(decrypt ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE, aesKey, ips);        byte[] buffer = new byte[256];        int n;        while ((n = data.read(buffer)) != -1) {            byte[] dst = decryptCipher.update(buffer, 0, n);            if (dst != null) {                output.write(dst);            }        }        output.write(decryptCipher.doFinal());    } catch (InvalidKeyException | InvalidAlgorithmParameterException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException e) {        throw new IOException(e);    }}
private void pdfbox_f4126_1(InputStream data, OutputStream output, boolean decrypt) throws IOException
{    byte[] iv = new byte[16];    if (!prepareAESInitializationVector(decrypt, iv, data, output)) {        return;    }    Cipher cipher;    try {        cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");        SecretKeySpec keySpec = new SecretKeySpec(encryptionKey, "AES");        IvParameterSpec ivSpec = new IvParameterSpec(iv);        cipher.init(decrypt ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE, keySpec, ivSpec);    } catch (GeneralSecurityException e) {        throw new IOException(e);    }    try (CipherInputStream cis = new CipherInputStream(data, cipher)) {        IOUtils.copy(cis, output);    } catch (IOException exception) {                if (!(exception.getCause() instanceof GeneralSecurityException)) {            throw exception;        }            }}
private boolean pdfbox_f4127_0(boolean decrypt, byte[] iv, InputStream data, OutputStream output) throws IOException
{    if (decrypt) {                int ivSize = data.read(iv);        if (ivSize == -1) {            return false;        }        if (ivSize != iv.length) {            throw new IOException("AES initialization vector not fully read: only " + ivSize + " bytes read instead of " + iv.length);        }    } else {                SecureRandom rnd = new SecureRandom();        rnd.nextBytes(iv);        output.write(iv);    }    return true;}
public void pdfbox_f4128_0(COSBase obj, long objNum, long genNum) throws IOException
{    if (!(obj instanceof COSString || obj instanceof COSDictionary || obj instanceof COSArray)) {        return;    }        if (obj instanceof COSString) {        if (objects.contains(obj)) {            return;        }        objects.add(obj);        decryptString((COSString) obj, objNum, genNum);    } else if (obj instanceof COSStream) {        if (objects.contains(obj)) {            return;        }        objects.add(obj);        decryptStream((COSStream) obj, objNum, genNum);    } else if (obj instanceof COSDictionary) {        decryptDictionary((COSDictionary) obj, objNum, genNum);    } else if (obj instanceof COSArray) {        decryptArray((COSArray) obj, objNum, genNum);    }}
public void pdfbox_f4129_1(COSStream stream, long objNum, long genNum) throws IOException
{        if (COSName.IDENTITY.equals(streamFilterName)) {        return;    }    COSBase type = stream.getCOSName(COSName.TYPE);    if (!decryptMetadata && COSName.METADATA.equals(type)) {        return;    }        if (COSName.XREF.equals(type)) {        return;    }    if (COSName.METADATA.equals(type)) {        byte[] buf;                try (InputStream is = stream.createRawInputStream()) {            buf = new byte[10];            long isResult = is.read(buf);            if (Long.compare(isResult, buf.length) != 0) {                            }        }        if (Arrays.equals(buf, "<?xpacket ".getBytes(Charsets.ISO_8859_1))) {                                    return;        }    }    decryptDictionary(stream, objNum, genNum);    byte[] encrypted = IOUtils.toByteArray(stream.createRawInputStream());    ByteArrayInputStream encryptedStream = new ByteArrayInputStream(encrypted);    try (OutputStream output = stream.createRawOutputStream()) {        encryptData(objNum, genNum, encryptedStream, output, true);    }}
public void pdfbox_f4130_0(COSStream stream, long objNum, int genNum) throws IOException
{    byte[] rawData = IOUtils.toByteArray(stream.createRawInputStream());    ByteArrayInputStream encryptedStream = new ByteArrayInputStream(rawData);    try (OutputStream output = stream.createRawOutputStream()) {        encryptData(objNum, genNum, encryptedStream, output, false);    }}
private void pdfbox_f4131_0(COSDictionary dictionary, long objNum, long genNum) throws IOException
{    if (dictionary.getItem(COSName.CF) != null) {                return;    }    COSBase type = dictionary.getDictionaryObject(COSName.TYPE);    boolean isSignature = COSName.SIG.equals(type) || COSName.DOC_TIME_STAMP.equals(type) ||     (dictionary.getDictionaryObject(COSName.CONTENTS) instanceof COSString && dictionary.getDictionaryObject(COSName.BYTERANGE) instanceof COSArray);    for (Map.Entry<COSName, COSBase> entry : dictionary.entrySet()) {        if (isSignature && COSName.CONTENTS.equals(entry.getKey())) {                        continue;        }        COSBase value = entry.getValue();                if (value instanceof COSString || value instanceof COSArray || value instanceof COSDictionary) {            decrypt(value, objNum, genNum);        }    }}
private void pdfbox_f4132_1(COSString string, long objNum, long genNum) throws IOException
{        if (COSName.IDENTITY.equals(stringFilterName)) {        return;    }    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    try {        encryptData(objNum, genNum, data, outputStream, true);        string.setValue(outputStream.toByteArray());    } catch (IOException ex) {            }}
public void pdfbox_f4133_0(COSString string, long objNum, int genNum) throws IOException
{    ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());    ByteArrayOutputStream buffer = new ByteArrayOutputStream();    encryptData(objNum, genNum, data, buffer, false);    string.setValue(buffer.toByteArray());}
private void pdfbox_f4134_0(COSArray array, long objNum, long genNum) throws IOException
{    for (int i = 0; i < array.size(); i++) {        decrypt(array.get(i), objNum, genNum);    }}
public int pdfbox_f4135_0()
{    return keyLength;}
public void pdfbox_f4136_0(int keyLen)
{    this.keyLength = keyLen;}
public void pdfbox_f4137_0(AccessPermission currentAccessPermission)
{    this.currentAccessPermission = currentAccessPermission;}
public AccessPermission pdfbox_f4138_0()
{    return currentAccessPermission;}
public boolean pdfbox_f4139_0()
{    return useAES;}
public void pdfbox_f4140_0(boolean aesValue)
{    useAES = aesValue;}
public void pdfbox_f4141_0(String name, Class<? extends SecurityHandler> securityHandler, Class<? extends ProtectionPolicy> protectionPolicy)
{    if (nameToHandler.containsKey(name)) {        throw new IllegalStateException("The security handler name is already registered");    }    nameToHandler.put(name, securityHandler);    policyToHandler.put(protectionPolicy, securityHandler);}
public SecurityHandler pdfbox_f4142_0(ProtectionPolicy policy)
{    Class<? extends SecurityHandler> handlerClass = policyToHandler.get(policy.getClass());    if (handlerClass == null) {        return null;    }    Class<?>[] argsClasses = { policy.getClass() };    Object[] args = { policy };    return newSecurityHandler(handlerClass, argsClasses, args);}
public SecurityHandler pdfbox_f4143_0(String name)
{    Class<? extends SecurityHandler> handlerClass = nameToHandler.get(name);    if (handlerClass == null) {        return null;    }    Class<?>[] argsClasses = {};    Object[] args = {};    return newSecurityHandler(handlerClass, argsClasses, args);}
private SecurityHandler pdfbox_f4144_0(Class<? extends SecurityHandler> handlerClass, Class<?>[] argsClasses, Object[] args)
{    try {        Constructor<? extends SecurityHandler> ctor = handlerClass.getDeclaredConstructor(argsClasses);        return ctor.newInstance(args);    } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {                throw new RuntimeException(e);    }}
public static Provider pdfbox_f4145_0() throws IOException
{        if (provider == null) {        try {            Class<Provider> providerClass = (Class<Provider>) Class.forName("org.bouncycastle.jce.provider.BouncyCastleProvider");            provider = providerClass.getDeclaredConstructor().newInstance();        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException ex) {            throw new IOException(ex);        }    }    return provider;}
public static void pdfbox_f4146_0(Provider provider)
{    SecurityProvider.provider = provider;}
public String pdfbox_f4147_0()
{    return password;}
public AccessPermission pdfbox_f4148_0()
{    return permissions;}
public void pdfbox_f4149_0(AccessPermission permissions)
{    this.permissions = permissions;}
public String pdfbox_f4150_0()
{    return ownerPassword;}
public void pdfbox_f4151_0(String ownerPassword)
{    this.ownerPassword = ownerPassword;}
public String pdfbox_f4152_0()
{    return userPassword;}
public void pdfbox_f4153_0(String userPassword)
{    this.userPassword = userPassword;}
public boolean pdfbox_f4154_0()
{    return this.preferAES;}
public void pdfbox_f4155_0(boolean preferAES)
{    this.preferAES = preferAES;}
private int pdfbox_f4156_0()
{    if (keyLength == 40) {        return DEFAULT_VERSION;    } else if (keyLength == 128 && policy.isPreferAES()) {        return 4;    } else if (keyLength == 256) {        return 5;    }    return 2;}
private int pdfbox_f4157_0(int version)
{    if (version < 2 && !policy.getPermissions().hasAnyRevision3PermissionSet()) {        return 2;    }    if (version == 5) {                return 6;    }    if (version == 4) {        return 4;    }    if (version == 2 || version == 3 || policy.getPermissions().hasAnyRevision3PermissionSet()) {        return 3;    }    return 4;}
public void pdfbox_f4158_0(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException
{    if (!(decryptionMaterial instanceof StandardDecryptionMaterial)) {        throw new IOException("Decryption material is not compatible with the document");    }        if (encryption.getVersion() >= 4) {        setStreamFilterName(encryption.getStreamFilterName());        setStringFilterName(encryption.getStreamFilterName());    }    setDecryptMetadata(encryption.isEncryptMetaData());    StandardDecryptionMaterial material = (StandardDecryptionMaterial) decryptionMaterial;    String password = material.getPassword();    if (password == null) {        password = "";    }    int dicPermissions = encryption.getPermissions();    int dicRevision = encryption.getRevision();    int dicLength = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);        boolean encryptMetadata = encryption.isEncryptMetaData();    byte[] userKey = encryption.getUserKey();    byte[] ownerKey = encryption.getOwnerKey();    byte[] ue = null, oe = null;    Charset passwordCharset = Charsets.ISO_8859_1;    if (dicRevision == 6 || dicRevision == 5) {        passwordCharset = Charsets.UTF_8;        ue = encryption.getUserEncryptionKey();        oe = encryption.getOwnerEncryptionKey();    }    if (dicRevision == 6) {                password = SaslPrep.saslPrepQuery(password);    }    AccessPermission currentAccessPermission;    if (isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {        currentAccessPermission = AccessPermission.getOwnerAccessPermission();        setCurrentAccessPermission(currentAccessPermission);        byte[] computedPassword;        if (dicRevision == 6 || dicRevision == 5) {            computedPassword = password.getBytes(passwordCharset);        } else {            computedPassword = getUserPassword(password.getBytes(passwordCharset), ownerKey, dicRevision, dicLength);        }        encryptionKey = computeEncryptedKey(computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, true);    } else if (isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata)) {        currentAccessPermission = new AccessPermission(dicPermissions);        currentAccessPermission.setReadOnly();        setCurrentAccessPermission(currentAccessPermission);        encryptionKey = computeEncryptedKey(password.getBytes(passwordCharset), ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, false);    } else {        throw new InvalidPasswordException("Cannot decrypt PDF, the password is incorrect");    }    if (dicRevision == 6 || dicRevision == 5) {        validatePerms(encryption, dicPermissions, encryptMetadata);    }    if (encryption.getVersion() == 4 || encryption.getVersion() == 5) {                                PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();        if (stdCryptFilterDictionary != null) {            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();            setAES(COSName.AESV2.equals(cryptFilterMethod) || COSName.AESV3.equals(cryptFilterMethod));        }    }}
private byte[] pdfbox_f4159_0(COSArray documentIDArray)
{            byte[] documentIDBytes;    if (documentIDArray != null && documentIDArray.size() >= 1) {        COSString id = (COSString) documentIDArray.getObject(0);        documentIDBytes = id.getBytes();    } else {        documentIDBytes = new byte[0];    }    return documentIDBytes;}
private void pdfbox_f4160_1(PDEncryption encryption, int dicPermissions, boolean encryptMetadata) throws IOException
{    try {                        Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(encryptionKey, "AES"));        byte[] perms = cipher.doFinal(encryption.getPerms());                if (perms[9] != 'a' || perms[10] != 'd' || perms[11] != 'b') {                    }                        int permsP = perms[0] & 0xFF | (perms[1] & 0xFF) << 8 | (perms[2] & 0xFF) << 16 | (perms[3] & 0xFF) << 24;        if (permsP != dicPermissions) {                    }        if (encryptMetadata && perms[8] != 'T' || !encryptMetadata && perms[8] != 'F') {                    }    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
public void pdfbox_f4161_0(PDDocument document) throws IOException
{    PDEncryption encryptionDictionary = document.getEncryption();    if (encryptionDictionary == null) {        encryptionDictionary = new PDEncryption();    }    int version = computeVersionNumber();    int revision = computeRevisionNumber(version);    encryptionDictionary.setFilter(FILTER);    encryptionDictionary.setVersion(version);    if (version != 4 && version != 5) {                encryptionDictionary.removeV45filters();    }    encryptionDictionary.setRevision(revision);    encryptionDictionary.setLength(keyLength);    String ownerPassword = policy.getOwnerPassword();    String userPassword = policy.getUserPassword();    if (ownerPassword == null) {        ownerPassword = "";    }    if (userPassword == null) {        userPassword = "";    }        if (ownerPassword.isEmpty()) {        ownerPassword = userPassword;    }    int permissionInt = policy.getPermissions().getPermissionBytes();    encryptionDictionary.setPermissions(permissionInt);    int length = keyLength / 8;    if (revision == 6) {                ownerPassword = SaslPrep.saslPrepStored(ownerPassword);        userPassword = SaslPrep.saslPrepStored(userPassword);        prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);    } else {        prepareEncryptionDictRev2345(ownerPassword, userPassword, encryptionDictionary, permissionInt, document, revision, length);    }    document.setEncryptionDictionary(encryptionDictionary);    document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSObject());}
private void pdfbox_f4162_0(String ownerPassword, String userPassword, PDEncryption encryptionDictionary, int permissionInt) throws IOException
{    try {        SecureRandom rnd = new SecureRandom();        Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");                encryptionKey = new byte[32];        rnd.nextBytes(encryptionKey);                byte[] userPasswordBytes = truncate127(userPassword.getBytes(Charsets.UTF_8));        byte[] userValidationSalt = new byte[8];        byte[] userKeySalt = new byte[8];        rnd.nextBytes(userValidationSalt);        rnd.nextBytes(userKeySalt);        byte[] hashU = computeHash2B(concat(userPasswordBytes, userValidationSalt), userPasswordBytes, null);        byte[] u = concat(hashU, userValidationSalt, userKeySalt);                byte[] hashUE = computeHash2B(concat(userPasswordBytes, userKeySalt), userPasswordBytes, null);        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashUE, "AES"),         new IvParameterSpec(new byte[16]));        byte[] ue = cipher.doFinal(encryptionKey);                byte[] ownerPasswordBytes = truncate127(ownerPassword.getBytes(Charsets.UTF_8));        byte[] ownerValidationSalt = new byte[8];        byte[] ownerKeySalt = new byte[8];        rnd.nextBytes(ownerValidationSalt);        rnd.nextBytes(ownerKeySalt);        byte[] hashO = computeHash2B(concat(ownerPasswordBytes, ownerValidationSalt, u), ownerPasswordBytes, u);        byte[] o = concat(hashO, ownerValidationSalt, ownerKeySalt);                byte[] hashOE = computeHash2B(concat(ownerPasswordBytes, ownerKeySalt, u), ownerPasswordBytes, u);        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashOE, "AES"),         new IvParameterSpec(new byte[16]));        byte[] oe = cipher.doFinal(encryptionKey);                encryptionDictionary.setUserKey(u);        encryptionDictionary.setUserEncryptionKey(ue);        encryptionDictionary.setOwnerKey(o);        encryptionDictionary.setOwnerEncryptionKey(oe);        prepareEncryptionDictAES(encryptionDictionary, COSName.AESV3);                byte[] perms = new byte[16];        perms[0] = (byte) permissionInt;        perms[1] = (byte) (permissionInt >>> 8);        perms[2] = (byte) (permissionInt >>> 16);        perms[3] = (byte) (permissionInt >>> 24);        perms[4] = (byte) 0xFF;        perms[5] = (byte) 0xFF;        perms[6] = (byte) 0xFF;        perms[7] = (byte) 0xFF;                perms[8] = 'T';        perms[9] = 'a';        perms[10] = 'd';        perms[11] = 'b';        for (int i = 12; i <= 15; i++) {            perms[i] = (byte) rnd.nextInt();        }        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptionKey, "AES"),         new IvParameterSpec(new byte[16]));        byte[] permsEnc = cipher.doFinal(perms);        encryptionDictionary.setPerms(permsEnc);    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
private void pdfbox_f4163_0(String ownerPassword, String userPassword, PDEncryption encryptionDictionary, int permissionInt, PDDocument document, int revision, int length) throws IOException
{    COSArray idArray = document.getDocument().getDocumentID();        if (idArray == null || idArray.size() < 2) {        MessageDigest md = MessageDigests.getMD5();        BigInteger time = BigInteger.valueOf(System.currentTimeMillis());        md.update(time.toByteArray());        md.update(ownerPassword.getBytes(Charsets.ISO_8859_1));        md.update(userPassword.getBytes(Charsets.ISO_8859_1));        md.update(document.getDocument().toString().getBytes(Charsets.ISO_8859_1));        byte[] id = md.digest(this.toString().getBytes(Charsets.ISO_8859_1));        COSString idString = new COSString(id);        idArray = new COSArray();        idArray.add(idString);        idArray.add(idString);        document.getDocument().setDocumentID(idArray);    }    COSString id = (COSString) idArray.getObject(0);    byte[] ownerBytes = computeOwnerPassword(ownerPassword.getBytes(Charsets.ISO_8859_1), userPassword.getBytes(Charsets.ISO_8859_1), revision, length);    byte[] userBytes = computeUserPassword(userPassword.getBytes(Charsets.ISO_8859_1), ownerBytes, permissionInt, id.getBytes(), revision, length, true);    encryptionKey = computeEncryptedKey(userPassword.getBytes(Charsets.ISO_8859_1), ownerBytes, null, null, null, permissionInt, id.getBytes(), revision, length, true, false);    encryptionDictionary.setOwnerKey(ownerBytes);    encryptionDictionary.setUserKey(userBytes);    if (revision == 4) {        prepareEncryptionDictAES(encryptionDictionary, COSName.AESV2);    }}
private void pdfbox_f4164_0(PDEncryption encryptionDictionary, COSName aesVName)
{    PDCryptFilterDictionary cryptFilterDictionary = new PDCryptFilterDictionary();    cryptFilterDictionary.setCryptFilterMethod(aesVName);    cryptFilterDictionary.setLength(keyLength);    encryptionDictionary.setStdCryptFilterDictionary(cryptFilterDictionary);    encryptionDictionary.setStreamFilterName(COSName.STD_CF);    encryptionDictionary.setStringFilterName(COSName.STD_CF);    setAES(true);}
public boolean pdfbox_f4165_0(byte[] ownerPassword, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    if (encRevision == 6 || encRevision == 5) {        byte[] truncatedOwnerPassword = truncate127(ownerPassword);        byte[] oHash = new byte[32];        byte[] oValidationSalt = new byte[8];        System.arraycopy(owner, 0, oHash, 0, 32);        System.arraycopy(owner, 32, oValidationSalt, 0, 8);        byte[] hash;        if (encRevision == 5) {            hash = computeSHA256(truncatedOwnerPassword, oValidationSalt, user);        } else {            hash = computeHash2A(truncatedOwnerPassword, oValidationSalt, user);        }        return Arrays.equals(hash, oHash);    } else {        byte[] userPassword = getUserPassword(ownerPassword, owner, encRevision, keyLengthInBytes);        return isUserPassword(userPassword, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);    }}
public byte[] pdfbox_f4166_0(byte[] ownerPassword, byte[] owner, int encRevision, int length) throws IOException
{    ByteArrayOutputStream result = new ByteArrayOutputStream();    byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);    if (encRevision == 2) {        encryptDataRC4(rc4Key, owner, result);    } else if (encRevision == 3 || encRevision == 4) {        byte[] iterationKey = new byte[rc4Key.length];        byte[] otemp = new byte[owner.length];        System.arraycopy(owner, 0, otemp, 0, owner.length);        for (int i = 19; i >= 0; i--) {            System.arraycopy(rc4Key, 0, iterationKey, 0, rc4Key.length);            for (int j = 0; j < iterationKey.length; j++) {                iterationKey[j] = (byte) (iterationKey[j] ^ (byte) i);            }            result.reset();            encryptDataRC4(iterationKey, otemp, result);            otemp = result.toByteArray();        }    }    return result.toByteArray();}
public byte[] pdfbox_f4167_0(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata, boolean isOwnerPassword) throws IOException
{    if (encRevision == 6 || encRevision == 5) {        return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);    } else {        return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, keyLengthInBytes, encRevision);    }}
private byte[] pdfbox_f4168_0(byte[] password, byte[] o, int permissions, byte[] id, boolean encryptMetadata, int length, int encRevision)
{            byte[] padded = truncateOrPad(password);    MessageDigest md = MessageDigests.getMD5();    md.update(padded);    md.update(o);    md.update((byte) permissions);    md.update((byte) (permissions >>> 8));    md.update((byte) (permissions >>> 16));    md.update((byte) (permissions >>> 24));    md.update(id);        if (encRevision == 4 && !encryptMetadata) {        md.update(new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff });    }    byte[] digest = md.digest();    if (encRevision == 3 || encRevision == 4) {        for (int i = 0; i < 50; i++) {            md.update(digest, 0, length);            digest = md.digest();        }    }    byte[] result = new byte[length];    System.arraycopy(digest, 0, result, 0, length);    return result;}
private byte[] pdfbox_f4169_0(byte[] password, boolean isOwnerPassword, byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) throws IOException
{    byte[] hash, fileKeyEnc;    if (isOwnerPassword) {        byte[] oKeySalt = new byte[8];        System.arraycopy(o, 40, oKeySalt, 0, 8);        if (encRevision == 5) {            hash = computeSHA256(password, oKeySalt, u);        } else {            hash = computeHash2A(password, oKeySalt, u);        }        fileKeyEnc = oe;    } else {        byte[] uKeySalt = new byte[8];        System.arraycopy(u, 40, uKeySalt, 0, 8);        if (encRevision == 5) {            hash = computeSHA256(password, uKeySalt, null);        } else {            hash = computeHash2A(password, uKeySalt, null);        }        fileKeyEnc = ue;    }    try {        Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, "AES"), new IvParameterSpec(new byte[16]));        return cipher.doFinal(fileKeyEnc);    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
public byte[] pdfbox_f4170_0(byte[] password, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    ByteArrayOutputStream result = new ByteArrayOutputStream();    byte[] encKey = computeEncryptedKey(password, owner, null, null, null, permissions, id, encRevision, keyLengthInBytes, encryptMetadata, true);    if (encRevision == 2) {        encryptDataRC4(encKey, ENCRYPT_PADDING, result);    } else if (encRevision == 3 || encRevision == 4) {        MessageDigest md = MessageDigests.getMD5();        md.update(ENCRYPT_PADDING);        md.update(id);        result.write(md.digest());        byte[] iterationKey = new byte[encKey.length];        for (int i = 0; i < 20; i++) {            System.arraycopy(encKey, 0, iterationKey, 0, iterationKey.length);            for (int j = 0; j < iterationKey.length; j++) {                iterationKey[j] = (byte) (iterationKey[j] ^ i);            }            ByteArrayInputStream input = new ByteArrayInputStream(result.toByteArray());            result.reset();            encryptDataRC4(iterationKey, input, result);        }        byte[] finalResult = new byte[32];        System.arraycopy(result.toByteArray(), 0, finalResult, 0, 16);        System.arraycopy(ENCRYPT_PADDING, 0, finalResult, 16, 16);        result.reset();        result.write(finalResult);    }    return result.toByteArray();}
public byte[] pdfbox_f4171_0(byte[] ownerPassword, byte[] userPassword, int encRevision, int length) throws IOException
{    if (encRevision == 2 && length != 5) {        throw new IOException("Expected length=5 actual=" + length);    }    byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);    byte[] paddedUser = truncateOrPad(userPassword);    ByteArrayOutputStream encrypted = new ByteArrayOutputStream();    encryptDataRC4(rc4Key, new ByteArrayInputStream(paddedUser), encrypted);    if (encRevision == 3 || encRevision == 4) {        byte[] iterationKey = new byte[rc4Key.length];        for (int i = 1; i < 20; i++) {            System.arraycopy(rc4Key, 0, iterationKey, 0, rc4Key.length);            for (int j = 0; j < iterationKey.length; j++) {                iterationKey[j] = (byte) (iterationKey[j] ^ (byte) i);            }            ByteArrayInputStream input = new ByteArrayInputStream(encrypted.toByteArray());            encrypted.reset();            encryptDataRC4(iterationKey, input, encrypted);        }    }    return encrypted.toByteArray();}
private byte[] pdfbox_f4172_0(byte[] ownerPassword, int encRevision, int length)
{    MessageDigest md = MessageDigests.getMD5();    byte[] digest = md.digest(truncateOrPad(ownerPassword));    if (encRevision == 3 || encRevision == 4) {        for (int i = 0; i < 50; i++) {                                                md.update(digest, 0, length);            digest = md.digest();        }    }    byte[] rc4Key = new byte[length];    System.arraycopy(digest, 0, rc4Key, 0, length);    return rc4Key;}
private byte[] pdfbox_f4173_0(byte[] password)
{    byte[] padded = new byte[ENCRYPT_PADDING.length];    int bytesBeforePad = Math.min(password.length, padded.length);    System.arraycopy(password, 0, padded, 0, bytesBeforePad);    System.arraycopy(ENCRYPT_PADDING, 0, padded, bytesBeforePad, ENCRYPT_PADDING.length - bytesBeforePad);    return padded;}
public boolean pdfbox_f4174_0(byte[] password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    switch(encRevision) {        case 2:        case 3:        case 4:            return isUserPassword234(password, user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);        case 5:        case 6:            return isUserPassword56(password, user, encRevision);        default:            throw new IOException("Unknown Encryption Revision " + encRevision);    }}
private boolean pdfbox_f4175_0(byte[] password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int length, boolean encryptMetadata) throws IOException
{    byte[] passwordBytes = computeUserPassword(password, owner, permissions, id, encRevision, length, encryptMetadata);    if (encRevision == 2) {        return Arrays.equals(user, passwordBytes);    } else {                return Arrays.equals(Arrays.copyOf(user, 16), Arrays.copyOf(passwordBytes, 16));    }}
private boolean pdfbox_f4176_0(byte[] password, byte[] user, int encRevision) throws IOException
{    byte[] truncatedPassword = truncate127(password);    byte[] uHash = new byte[32];    byte[] uValidationSalt = new byte[8];    System.arraycopy(user, 0, uHash, 0, 32);    System.arraycopy(user, 32, uValidationSalt, 0, 8);    byte[] hash;    if (encRevision == 5) {        hash = computeSHA256(truncatedPassword, uValidationSalt, null);    } else {        hash = computeHash2A(truncatedPassword, uValidationSalt, null);    }    return Arrays.equals(hash, uHash);}
public boolean pdfbox_f4177_0(String password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    if (encRevision == 6 || encRevision == 5) {        return isUserPassword(password.getBytes(Charsets.UTF_8), user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);    } else {        return isUserPassword(password.getBytes(Charsets.ISO_8859_1), user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);    }}
public boolean pdfbox_f4178_0(String password, byte[] user, byte[] owner, int permissions, byte[] id, int encRevision, int keyLengthInBytes, boolean encryptMetadata) throws IOException
{    return isOwnerPassword(password.getBytes(Charsets.ISO_8859_1), user, owner, permissions, id, encRevision, keyLengthInBytes, encryptMetadata);}
private byte[] pdfbox_f4179_0(byte[] password, byte[] salt, byte[] u) throws IOException
{    byte[] userKey;    if (u == null) {        userKey = new byte[0];    } else if (u.length < 48) {        throw new IOException("Bad U length");    } else if (u.length > 48) {                userKey = new byte[48];        System.arraycopy(u, 0, userKey, 0, 48);    } else {        userKey = u;    }    byte[] truncatedPassword = truncate127(password);    byte[] input = concat(truncatedPassword, salt, userKey);    return computeHash2B(input, truncatedPassword, userKey);}
private static byte[] pdfbox_f4180_0(byte[] input, byte[] password, byte[] userKey) throws IOException
{    try {        MessageDigest md = MessageDigest.getInstance("SHA-256");        byte[] k = md.digest(input);        byte[] e = null;        for (int round = 0; round < 64 || ((int) e[e.length - 1] & 0xFF) > round - 32; round++) {            byte[] k1;            if (userKey != null && userKey.length >= 48) {                k1 = new byte[64 * (password.length + k.length + 48)];            } else {                k1 = new byte[64 * (password.length + k.length)];            }            int pos = 0;            for (int i = 0; i < 64; i++) {                System.arraycopy(password, 0, k1, pos, password.length);                pos += password.length;                System.arraycopy(k, 0, k1, pos, k.length);                pos += k.length;                if (userKey != null && userKey.length >= 48) {                    System.arraycopy(userKey, 0, k1, pos, 48);                    pos += 48;                }            }            byte[] kFirst = new byte[16];            byte[] kSecond = new byte[16];            System.arraycopy(k, 0, kFirst, 0, 16);            System.arraycopy(k, 16, kSecond, 0, 16);            Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");            SecretKeySpec keySpec = new SecretKeySpec(kFirst, "AES");            IvParameterSpec ivSpec = new IvParameterSpec(kSecond);            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);            e = cipher.doFinal(k1);            byte[] eFirst = new byte[16];            System.arraycopy(e, 0, eFirst, 0, 16);            BigInteger bi = new BigInteger(1, eFirst);            BigInteger remainder = bi.mod(new BigInteger("3"));            String nextHash = HASHES_2B[remainder.intValue()];            md = MessageDigest.getInstance(nextHash);            k = md.digest(e);        }        if (k.length > 32) {            byte[] kTrunc = new byte[32];            System.arraycopy(k, 0, kTrunc, 0, 32);            return kTrunc;        } else {            return k;        }    } catch (GeneralSecurityException e) {        logIfStrongEncryptionMissing();        throw new IOException(e);    }}
private static byte[] pdfbox_f4181_0(byte[] input, byte[] password, byte[] userKey) throws IOException
{    try {        MessageDigest md = MessageDigest.getInstance("SHA-256");        md.update(input);        md.update(password);        return userKey == null ? md.digest() : md.digest(userKey);    } catch (NoSuchAlgorithmException e) {        throw new IOException(e);    }}
private static byte[] pdfbox_f4182_0(byte[] a, byte[] b)
{    byte[] o = new byte[a.length + b.length];    System.arraycopy(a, 0, o, 0, a.length);    System.arraycopy(b, 0, o, a.length, b.length);    return o;}
private static byte[] pdfbox_f4183_0(byte[] a, byte[] b, byte[] c)
{    byte[] o = new byte[a.length + b.length + c.length];    System.arraycopy(a, 0, o, 0, a.length);    System.arraycopy(b, 0, o, a.length, b.length);    System.arraycopy(c, 0, o, a.length + b.length, c.length);    return o;}
private static byte[] pdfbox_f4184_0(byte[] in)
{    if (in.length <= 127) {        return in;    }    byte[] trunc = new byte[127];    System.arraycopy(in, 0, trunc, 0, 127);    return trunc;}
private static void pdfbox_f4185_1()
{    try {        if (Cipher.getMaxAllowedKeyLength("AES") != Integer.MAX_VALUE) {                    }    } catch (NoSuchAlgorithmException ex) {            }}
public boolean pdfbox_f4186_0()
{    return policy != null;}
public static FDFAnnotation pdfbox_f4187_1(COSDictionary fdfDic) throws IOException
{    FDFAnnotation retval = null;    if (fdfDic != null) {        if (FDFAnnotationText.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationText(fdfDic);        } else if (FDFAnnotationCaret.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationCaret(fdfDic);        } else if (FDFAnnotationFreeText.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationFreeText(fdfDic);        } else if (FDFAnnotationFileAttachment.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationFileAttachment(fdfDic);        } else if (FDFAnnotationHighlight.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationHighlight(fdfDic);        } else if (FDFAnnotationInk.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationInk(fdfDic);        } else if (FDFAnnotationLine.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationLine(fdfDic);        } else if (FDFAnnotationLink.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationLink(fdfDic);        } else if (FDFAnnotationCircle.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationCircle(fdfDic);        } else if (FDFAnnotationSquare.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationSquare(fdfDic);        } else if (FDFAnnotationPolygon.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationPolygon(fdfDic);        } else if (FDFAnnotationPolyline.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationPolyline(fdfDic);        } else if (FDFAnnotationSound.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationSound(fdfDic);        } else if (FDFAnnotationSquiggly.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationSquiggly(fdfDic);        } else if (FDFAnnotationStamp.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationStamp(fdfDic);        } else if (FDFAnnotationStrikeOut.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationStrikeOut(fdfDic);        } else if (FDFAnnotationUnderline.SUBTYPE.equals(fdfDic.getNameAsString(COSName.SUBTYPE))) {            retval = new FDFAnnotationUnderline(fdfDic);        } else {                    }    }    return retval;}
public COSDictionary pdfbox_f4188_0()
{    return annot;}
public Integer pdfbox_f4189_0()
{    Integer retval = null;    COSNumber page = (COSNumber) annot.getDictionaryObject(COSName.PAGE);    if (page != null) {        retval = page.intValue();    }    return retval;}
public final void pdfbox_f4190_0(int page)
{    annot.setInt(COSName.PAGE, page);}
public Color pdfbox_f4191_0()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.C);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
public final void pdfbox_f4192_0(Color c)
{    COSArray color = null;    if (c != null) {        float[] colors = c.getRGBColorComponents(null);        color = new COSArray();        color.setFloatArray(colors);    }    annot.setItem(COSName.C, color);}
public String pdfbox_f4193_0()
{    return annot.getString(COSName.M);}
public final void pdfbox_f4194_0(String date)
{    annot.setString(COSName.M, date);}
public boolean pdfbox_f4195_0()
{    return annot.getFlag(COSName.F, FLAG_INVISIBLE);}
public final void pdfbox_f4196_0(boolean invisible)
{    annot.setFlag(COSName.F, FLAG_INVISIBLE, invisible);}
public boolean pdfbox_f4197_0()
{    return annot.getFlag(COSName.F, FLAG_HIDDEN);}
public final void pdfbox_f4198_0(boolean hidden)
{    annot.setFlag(COSName.F, FLAG_HIDDEN, hidden);}
public boolean pdfbox_f4199_0()
{    return annot.getFlag(COSName.F, FLAG_PRINTED);}
public final void pdfbox_f4200_0(boolean printed)
{    annot.setFlag(COSName.F, FLAG_PRINTED, printed);}
public boolean pdfbox_f4201_0()
{    return annot.getFlag(COSName.F, FLAG_NO_ZOOM);}
public final void pdfbox_f4202_0(boolean noZoom)
{    annot.setFlag(COSName.F, FLAG_NO_ZOOM, noZoom);}
public boolean pdfbox_f4203_0()
{    return annot.getFlag(COSName.F, FLAG_NO_ROTATE);}
public final void pdfbox_f4204_0(boolean noRotate)
{    annot.setFlag(COSName.F, FLAG_NO_ROTATE, noRotate);}
public boolean pdfbox_f4205_0()
{    return annot.getFlag(COSName.F, FLAG_NO_VIEW);}
public final void pdfbox_f4206_0(boolean noView)
{    annot.setFlag(COSName.F, FLAG_NO_VIEW, noView);}
public boolean pdfbox_f4207_0()
{    return annot.getFlag(COSName.F, FLAG_READ_ONLY);}
public final void pdfbox_f4208_0(boolean readOnly)
{    annot.setFlag(COSName.F, FLAG_READ_ONLY, readOnly);}
public boolean pdfbox_f4209_0()
{    return annot.getFlag(COSName.F, FLAG_LOCKED);}
public final void pdfbox_f4210_0(boolean locked)
{    annot.setFlag(COSName.F, FLAG_LOCKED, locked);}
public boolean pdfbox_f4211_0()
{    return annot.getFlag(COSName.F, FLAG_TOGGLE_NO_VIEW);}
public final void pdfbox_f4212_0(boolean toggleNoView)
{    annot.setFlag(COSName.F, FLAG_TOGGLE_NO_VIEW, toggleNoView);}
public final void pdfbox_f4213_0(String name)
{    annot.setString(COSName.NM, name);}
public String pdfbox_f4214_0()
{    return annot.getString(COSName.NM);}
public final void pdfbox_f4215_0(PDRectangle rectangle)
{    annot.setItem(COSName.RECT, rectangle);}
public PDRectangle pdfbox_f4216_0()
{    PDRectangle retval = null;    COSArray rectArray = (COSArray) annot.getDictionaryObject(COSName.RECT);    if (rectArray != null) {        retval = new PDRectangle(rectArray);    }    return retval;}
public final void pdfbox_f4217_0(String contents)
{    annot.setString(COSName.CONTENTS, contents);}
public String pdfbox_f4218_0()
{    return annot.getString(COSName.CONTENTS);}
public final void pdfbox_f4219_0(String title)
{    annot.setString(COSName.T, title);}
public String pdfbox_f4220_0()
{    return annot.getString(COSName.T);}
public Calendar pdfbox_f4221_0() throws IOException
{    return annot.getDate(COSName.CREATION_DATE);}
public final void pdfbox_f4222_0(Calendar date)
{    annot.setDate(COSName.CREATION_DATE, date);}
public final void pdfbox_f4223_0(float opacity)
{    annot.setFloat(COSName.CA, opacity);}
public float pdfbox_f4224_0()
{    return annot.getFloat(COSName.CA, 1f);}
public final void pdfbox_f4225_0(String subject)
{    annot.setString(COSName.SUBJ, subject);}
public String pdfbox_f4226_0()
{    return annot.getString(COSName.SUBJ);}
public final void pdfbox_f4227_0(String intent)
{    annot.setName(COSName.IT, intent);}
public String pdfbox_f4228_0()
{    return annot.getNameAsString(COSName.IT);}
public String pdfbox_f4229_0()
{    return getStringOrStream(annot.getDictionaryObject(COSName.RC));}
public final void pdfbox_f4230_0(String rc)
{    annot.setItem(COSName.RC, new COSString(rc));}
public final void pdfbox_f4231_0(PDBorderStyleDictionary bs)
{    annot.setItem(COSName.BS, bs);}
public PDBorderStyleDictionary pdfbox_f4232_0()
{    COSDictionary bs = (COSDictionary) annot.getDictionaryObject(COSName.BS);    if (bs != null) {        return new PDBorderStyleDictionary(bs);    } else {        return null;    }}
public final void pdfbox_f4233_0(PDBorderEffectDictionary be)
{    annot.setItem(COSName.BE, be);}
public PDBorderEffectDictionary pdfbox_f4234_0()
{    COSDictionary be = (COSDictionary) annot.getDictionaryObject(COSName.BE);    if (be != null) {        return new PDBorderEffectDictionary(be);    } else {        return null;    }}
protected final String pdfbox_f4235_0(COSBase base)
{    if (base == null) {        return "";    } else if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return "";    }}
private String pdfbox_f4236_0(Node node, boolean root)
{    String subString = "";    NodeList nodelist = node.getChildNodes();    for (int i = 0; i < nodelist.getLength(); i++) {        Node child = nodelist.item(i);        if (child instanceof Element) {            subString += richContentsToString(child, false);        } else if (child instanceof CDATASection) {            subString += "<![CDATA[" + ((CDATASection) child).getData() + "]]>";        } else if (child instanceof Text) {            String cdata = ((Text) child).getData();            if (cdata != null) {                cdata = cdata.replace("&", "&amp;").replace("<", "&lt;");            }            subString += cdata;        }    }    if (root) {        return subString;    }    NamedNodeMap attributes = node.getAttributes();    StringBuilder builder = new StringBuilder();    for (int i = 0; i < attributes.getLength(); i++) {        Node attribute = attributes.item(i);        String attributeNodeValue = attribute.getNodeValue();        if (attributeNodeValue != null) {            attributeNodeValue = attributeNodeValue.replace("\"", "&quot;");        }        builder.append(String.format(" %s=\"%s\"", attribute.getNodeName(), attributeNodeValue));    }    return String.format("<%s%s>%s</%s>", node.getNodeName(), builder.toString(), subString, node.getNodeName());}
private void pdfbox_f4237_0(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
public final void pdfbox_f4238_0(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
public PDRectangle pdfbox_f4239_0()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
public final void pdfbox_f4240_0(String symbol)
{    String newSymbol = "None";    if ("paragraph".equals(symbol)) {        newSymbol = "P";    }    annot.setString(COSName.SY, newSymbol);}
public String pdfbox_f4241_0()
{    return annot.getString(COSName.SY);}
private void pdfbox_f4242_0(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
public final void pdfbox_f4243_0(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
public Color pdfbox_f4244_0()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
public final void pdfbox_f4245_0(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
public PDRectangle pdfbox_f4246_0()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
private void pdfbox_f4247_0(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
private void pdfbox_f4248_0(Element element) throws IOException
{    String callout = element.getAttribute("callout");    if (callout != null && !callout.isEmpty()) {        String[] calloutValues = callout.split(",");        float[] values = new float[calloutValues.length];        for (int i = 0; i < calloutValues.length; i++) {            values[i] = Float.parseFloat(calloutValues[i]);        }        setCallout(values);    }}
public final void pdfbox_f4249_0(float[] callout)
{    COSArray newCallout = new COSArray();    newCallout.setFloatArray(callout);    annot.setItem(COSName.CL, newCallout);}
public float[] pdfbox_f4250_0()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CL);    if (array != null) {        return array.toFloatArray();    } else {        return null;    }}
public final void pdfbox_f4251_0(String justification)
{    int quadding = 0;    if ("centered".equals(justification)) {        quadding = 1;    } else if ("right".equals(justification)) {        quadding = 2;    }    annot.setInt(COSName.Q, quadding);}
public String pdfbox_f4252_0()
{    return "" + annot.getInt(COSName.Q, 0);}
public final void pdfbox_f4253_0(int rotation)
{    annot.setInt(COSName.ROTATE, rotation);}
public String pdfbox_f4254_0()
{    return annot.getString(COSName.ROTATE);}
public final void pdfbox_f4255_0(String appearance)
{    annot.setString(COSName.DA, appearance);}
public String pdfbox_f4256_0()
{    return annot.getString(COSName.DA);}
public final void pdfbox_f4257_0(String style)
{    annot.setString(COSName.DS, style);}
public String pdfbox_f4258_0()
{    return annot.getString(COSName.DS);}
public final void pdfbox_f4259_0(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
public PDRectangle pdfbox_f4260_0()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
public final void pdfbox_f4261_0(String style)
{    annot.setName(COSName.LE, style);}
public String pdfbox_f4262_0()
{    return annot.getNameAsString(COSName.LE);}
public final void pdfbox_f4263_0(List<float[]> inklist)
{    COSArray newInklist = new COSArray();    for (float[] array : inklist) {        COSArray newArray = new COSArray();        newArray.setFloatArray(array);        newInklist.add(newArray);    }    annot.setItem(COSName.INKLIST, newInklist);}
public List<float[]> pdfbox_f4264_0()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.INKLIST);    if (array != null) {        List<float[]> retval = new ArrayList<>();        for (COSBase entry : array) {            retval.add(((COSArray) entry).toFloatArray());        }        return retval;    } else {                return null;    }}
public final void pdfbox_f4265_0(float[] line)
{    COSArray newLine = new COSArray();    newLine.setFloatArray(line);    annot.setItem(COSName.L, newLine);}
public float[] pdfbox_f4266_0()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.L);    if (array != null) {        return array.toFloatArray();    } else {                return null;    }}
public final void pdfbox_f4267_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        annot.setItem(COSName.LE, array);    } else {        array.setName(0, actualStyle);    }}
public String pdfbox_f4268_0()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(0);    }    return retval;}
public final void pdfbox_f4269_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        annot.setItem(COSName.LE, array);    } else {        array.setName(1, actualStyle);    }}
public String pdfbox_f4270_0()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(1);    }    return retval;}
public final void pdfbox_f4271_0(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
public Color pdfbox_f4272_0()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
public final void pdfbox_f4273_0(boolean cap)
{    annot.setBoolean(COSName.CAP, cap);}
public boolean pdfbox_f4274_0()
{    return annot.getBoolean(COSName.CAP, false);}
public float pdfbox_f4275_0()
{    return annot.getFloat(COSName.LL);}
public final void pdfbox_f4276_0(float leaderLength)
{    annot.setFloat(COSName.LL, leaderLength);}
public float pdfbox_f4277_0()
{    return annot.getFloat(COSName.LLE);}
public final void pdfbox_f4278_0(float leaderExtend)
{    annot.setFloat(COSName.LLE, leaderExtend);}
public float pdfbox_f4279_0()
{    return annot.getFloat(COSName.LLO);}
public final void pdfbox_f4280_0(float leaderOffset)
{    annot.setFloat(COSName.LLO, leaderOffset);}
public String pdfbox_f4281_0()
{    return annot.getString(COSName.CP);}
public final void pdfbox_f4282_0(String captionStyle)
{    annot.setString(COSName.CP, captionStyle);}
public final void pdfbox_f4283_0(float offset)
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { offset, 0.f });        annot.setItem(COSName.CO, array);    } else {        array.set(0, new COSFloat(offset));    }}
public float pdfbox_f4284_0()
{    float retval = 0.f;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[0];    }    return retval;}
public final void pdfbox_f4285_0(float offset)
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { 0.f, offset });        annot.setItem(COSName.CO, array);    } else {        array.set(1, new COSFloat(offset));    }}
public float pdfbox_f4286_0()
{    float retval = 0.f;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[1];    }    return retval;}
private void pdfbox_f4287_1(Element element) throws IOException
{    XPath xpath = XPathFactory.newInstance().newXPath();    try {        String vertices = xpath.evaluate("vertices", element);        if (vertices == null || vertices.isEmpty()) {            throw new IOException("Error: missing element 'vertices'");        }        String[] verticesValues = vertices.split(",|;");        float[] values = new float[verticesValues.length];        for (int i = 0; i < verticesValues.length; i++) {            values[i] = Float.parseFloat(verticesValues[i]);        }        setVertices(values);    } catch (XPathExpressionException e) {            }}
public final void pdfbox_f4288_0(float[] vertices)
{    COSArray newVertices = new COSArray();    newVertices.setFloatArray(vertices);    annot.setItem(COSName.VERTICES, newVertices);}
public float[] pdfbox_f4289_0()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.VERTICES);    if (array != null) {        return array.toFloatArray();    } else {                return null;    }}
public final void pdfbox_f4290_0(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
public Color pdfbox_f4291_0()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
private void pdfbox_f4292_1(Element element) throws IOException
{    XPath xpath = XPathFactory.newInstance().newXPath();    try {        String vertices = xpath.evaluate("vertices[1]", element);        if (vertices == null || vertices.isEmpty()) {            throw new IOException("Error: missing element 'vertices'");        }        String[] verticesValues = vertices.split(",|;");        float[] values = new float[verticesValues.length];        for (int i = 0; i < verticesValues.length; i++) {            values[i] = Float.parseFloat(verticesValues[i]);        }        setVertices(values);    } catch (XPathExpressionException e) {            }}
private void pdfbox_f4293_0(Element element)
{    String startStyle = element.getAttribute("head");    if (startStyle != null && !startStyle.isEmpty()) {        setStartPointEndingStyle(startStyle);    }    String endStyle = element.getAttribute("tail");    if (endStyle != null && !endStyle.isEmpty()) {        setEndPointEndingStyle(endStyle);    }    String color = element.getAttribute("interior-color");    if (color != null && color.length() == 7 && color.charAt(0) == '#') {        int colorValue = Integer.parseInt(color.substring(1, 7), 16);        setInteriorColor(new Color(colorValue));    }}
public void pdfbox_f4294_0(float[] vertices)
{    COSArray newVertices = new COSArray();    newVertices.setFloatArray(vertices);    annot.setItem(COSName.VERTICES, newVertices);}
public float[] pdfbox_f4295_0()
{    COSArray array = (COSArray) annot.getDictionaryObject(COSName.VERTICES);    if (array != null) {        return array.toFloatArray();    } else {                return null;    }}
public void pdfbox_f4296_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        annot.setItem(COSName.LE, array);    } else {        array.setName(0, actualStyle);    }}
public String pdfbox_f4297_0()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(0);    }    return retval;}
public void pdfbox_f4298_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array == null) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        annot.setItem(COSName.LE, array);    } else {        array.setName(1, actualStyle);    }}
public String pdfbox_f4299_0()
{    String retval = PDAnnotationLine.LE_NONE;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.LE);    if (array != null) {        retval = array.getName(1);    }    return retval;}
public void pdfbox_f4300_0(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
public Color pdfbox_f4301_0()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
private void pdfbox_f4302_0(Element element) throws IOException
{    String fringe = element.getAttribute("fringe");    if (fringe != null && !fringe.isEmpty()) {        String[] fringeValues = fringe.split(",");        if (fringeValues.length != 4) {            throw new IOException("Error: wrong amount of numbers in attribute 'fringe'");        }        PDRectangle rect = new PDRectangle();        rect.setLowerLeftX(Float.parseFloat(fringeValues[0]));        rect.setLowerLeftY(Float.parseFloat(fringeValues[1]));        rect.setUpperRightX(Float.parseFloat(fringeValues[2]));        rect.setUpperRightY(Float.parseFloat(fringeValues[3]));        setFringe(rect);    }}
public final void pdfbox_f4303_0(Color color)
{    COSArray array = null;    if (color != null) {        float[] colors = color.getRGBColorComponents(null);        array = new COSArray();        array.setFloatArray(colors);    }    annot.setItem(COSName.IC, array);}
public Color pdfbox_f4304_0()
{    Color retval = null;    COSArray array = (COSArray) annot.getDictionaryObject(COSName.IC);    if (array != null) {        float[] rgb = array.toFloatArray();        if (rgb.length >= 3) {            retval = new Color(rgb[0], rgb[1], rgb[2]);        }    }    return retval;}
public final void pdfbox_f4305_0(PDRectangle fringe)
{    annot.setItem(COSName.RD, fringe);}
public PDRectangle pdfbox_f4306_0()
{    COSArray rd = (COSArray) annot.getDictionaryObject(COSName.RD);    if (rd != null) {        return new PDRectangle(rd);    } else {        return null;    }}
private COSDictionary pdfbox_f4307_1(Element appearanceXML) throws IOException
{    COSDictionary dictionary = new COSDictionary();        dictionary.setItem(COSName.N, new COSStream());        NodeList nodeList = appearanceXML.getChildNodes();    String parentAttrKey = appearanceXML.getAttribute("KEY");            if (!"AP".equals(appearanceXML.getAttribute("KEY"))) {                return dictionary;    }    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            if ("STREAM".equalsIgnoreCase(child.getTagName())) {                                dictionary.setItem(child.getAttribute("KEY"), parseStreamElement(child));                            } else {                            }        }    }    return dictionary;}
private COSStream pdfbox_f4308_1(Element streamEl) throws IOException
{        COSStream stream = new COSStream();    NodeList nodeList = streamEl.getChildNodes();    String parentAttrKey = streamEl.getAttribute("KEY");    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            String childAttrKey = child.getAttribute("KEY");            String childAttrVal = child.getAttribute("VAL");                        if ("INT".equalsIgnoreCase(child.getTagName())) {                if (!"Length".equals(childAttrKey)) {                    stream.setInt(COSName.getPDFName(childAttrKey), Integer.parseInt(childAttrVal));                                    }            } else if ("FIXED".equalsIgnoreCase(child.getTagName())) {                stream.setFloat(COSName.getPDFName(childAttrKey), Float.parseFloat(childAttrVal));                            } else if ("NAME".equalsIgnoreCase(child.getTagName())) {                stream.setName(COSName.getPDFName(childAttrKey), childAttrVal);                            } else if ("BOOL".equalsIgnoreCase(child.getTagName())) {                stream.setBoolean(COSName.getPDFName(childAttrKey), Boolean.parseBoolean(childAttrVal));                            } else if ("ARRAY".equalsIgnoreCase(child.getTagName())) {                stream.setItem(COSName.getPDFName(childAttrKey), parseArrayElement(child));                            } else if ("DICT".equalsIgnoreCase(child.getTagName())) {                stream.setItem(COSName.getPDFName(childAttrKey), parseDictElement(child));                            } else if ("STREAM".equalsIgnoreCase(child.getTagName())) {                stream.setItem(COSName.getPDFName(childAttrKey), parseStreamElement(child));                            } else if ("DATA".equalsIgnoreCase(child.getTagName())) {                                if ("HEX".equals(child.getAttribute("ENCODING"))) {                    try (OutputStream os = stream.createRawOutputStream()) {                        os.write(Hex.decodeHex(child.getTextContent()));                                            }                } else if ("ASCII".equals(child.getAttribute("ENCODING"))) {                    try (OutputStream os = stream.createOutputStream()) {                                                os.write(child.getTextContent().getBytes());                                            }                } else {                                    }            } else {                            }        }    }    return stream;}
private COSArray pdfbox_f4309_1(Element arrayEl) throws IOException
{        COSArray array = new COSArray();    NodeList nodeList = arrayEl.getChildNodes();    String parentAttrKey = arrayEl.getAttribute("KEY");    if ("BBox".equals(parentAttrKey)) {        if (nodeList.getLength() < 4) {            throw new IOException("BBox does not have enough coordinates, only has: " + nodeList.getLength());        }    } else if ("Matrix".equals(parentAttrKey)) {        if (nodeList.getLength() < 6) {            throw new IOException("Matrix does not have enough coordinates, only has: " + nodeList.getLength());        }    }    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            String childAttrKey = child.getAttribute("KEY");            String childAttrVal = child.getAttribute("VAL");                        if ("INT".equalsIgnoreCase(child.getTagName())) {                                array.add(COSFloat.get(childAttrVal));            } else if ("FIXED".equalsIgnoreCase(child.getTagName())) {                                array.add(COSInteger.get(childAttrVal));            } else if ("NAME".equalsIgnoreCase(child.getTagName())) {                                array.add(COSName.getPDFName(childAttrVal));            } else if ("BOOL".equalsIgnoreCase(child.getTagName())) {                                array.add(COSBoolean.getBoolean(Boolean.parseBoolean(childAttrVal)));            } else if ("DICT".equalsIgnoreCase(child.getTagName())) {                                array.add(parseDictElement(child));            } else if ("STREAM".equalsIgnoreCase(child.getTagName())) {                                array.add(parseStreamElement(child));            } else if ("ARRAY".equalsIgnoreCase(child.getTagName())) {                                array.add(parseArrayElement(child));            } else {                            }        }    }    return array;}
private COSDictionary pdfbox_f4310_1(Element dictEl) throws IOException
{        COSDictionary dict = new COSDictionary();    NodeList nodeList = dictEl.getChildNodes();    String parentAttrKey = dictEl.getAttribute("KEY");    for (int i = 0; i < nodeList.getLength(); i++) {        Node node = nodeList.item(i);        if (node instanceof Element) {            Element child = (Element) node;            String childAttrKey = child.getAttribute("KEY");            String childAttrVal = child.getAttribute("VAL");            if ("DICT".equals(child.getTagName())) {                                dict.setItem(COSName.getPDFName(childAttrKey), parseDictElement(child));                            } else if ("STREAM".equals(child.getTagName())) {                                dict.setItem(COSName.getPDFName(childAttrKey), parseStreamElement(child));            } else if ("NAME".equals(child.getTagName())) {                                dict.setName(COSName.getPDFName(childAttrKey), childAttrVal);                            } else if ("INT".equalsIgnoreCase(child.getTagName())) {                dict.setInt(COSName.getPDFName(childAttrKey), Integer.parseInt(childAttrVal));                            } else if ("FIXED".equalsIgnoreCase(child.getTagName())) {                dict.setFloat(COSName.getPDFName(childAttrKey), Float.parseFloat(childAttrVal));                            } else if ("BOOL".equalsIgnoreCase(child.getTagName())) {                dict.setBoolean(COSName.getPDFName(childAttrKey), Boolean.parseBoolean(childAttrVal));                            } else if ("ARRAY".equalsIgnoreCase(child.getTagName())) {                dict.setItem(COSName.getPDFName(childAttrKey), parseArrayElement(child));                            } else {                            }        }    }    return dict;}
public final void pdfbox_f4311_0(String icon)
{    annot.setName(COSName.NAME, icon);}
public String pdfbox_f4312_0()
{    return annot.getNameAsString(COSName.NAME, PDAnnotationText.NAME_NOTE);}
public String pdfbox_f4313_0()
{    return annot.getString(COSName.STATE);}
public final void pdfbox_f4314_0(String state)
{    annot.setString(COSName.STATE, state);}
public String pdfbox_f4315_0()
{    return annot.getString(COSName.STATE_MODEL);}
public final void pdfbox_f4316_0(String stateModel)
{    annot.setString(COSName.STATE_MODEL, stateModel);}
public void pdfbox_f4317_0(float[] coords)
{    COSArray newQuadPoints = new COSArray();    newQuadPoints.setFloatArray(coords);    annot.setItem(COSName.QUADPOINTS, newQuadPoints);}
public float[] pdfbox_f4318_0()
{    COSArray quadPoints = (COSArray) annot.getItem(COSName.QUADPOINTS);    if (quadPoints != null) {        return quadPoints.toFloatArray();    } else {                return null;    }}
public void pdfbox_f4319_0(Writer output) throws IOException
{    FDFDictionary fdf = getFDF();    fdf.writeXML(output);}
public COSDictionary pdfbox_f4320_0()
{    return catalog;}
public String pdfbox_f4321_0()
{    return catalog.getNameAsString(COSName.VERSION);}
public void pdfbox_f4322_0(String version)
{    catalog.setName(COSName.VERSION, version);}
public FDFDictionary pdfbox_f4323_0()
{    COSDictionary fdf = (COSDictionary) catalog.getDictionaryObject(COSName.FDF);    FDFDictionary retval;    if (fdf != null) {        retval = new FDFDictionary(fdf);    } else {        retval = new FDFDictionary();        setFDF(retval);    }    return retval;}
public final void pdfbox_f4324_0(FDFDictionary fdf)
{    catalog.setItem(COSName.FDF, fdf);}
public PDSignature pdfbox_f4325_0()
{    PDSignature signature = null;    COSDictionary sig = (COSDictionary) catalog.getDictionaryObject(COSName.SIG);    if (sig != null) {        signature = new PDSignature(sig);    }    return signature;}
public void pdfbox_f4326_0(PDSignature sig)
{    catalog.setItem(COSName.SIG, sig);}
public void pdfbox_f4327_0(Writer output) throws IOException
{    PDFileSpecification fs = this.getFile();    if (fs != null) {        output.write("<f href=\"" + fs.getFile() + "\" />\n");    }    COSArray ids = this.getID();    if (ids != null) {        COSString original = (COSString) ids.getObject(0);        COSString modified = (COSString) ids.getObject(1);        output.write("<ids original=\"" + original.toHexString() + "\" ");        output.write("modified=\"" + modified.toHexString() + "\" />\n");    }    List<FDFField> fields = getFields();    if (fields != null && fields.size() > 0) {        output.write("<fields>\n");        for (FDFField field : fields) {            field.writeXML(output);        }        output.write("</fields>\n");    }}
public COSDictionary pdfbox_f4328_0()
{    return fdf;}
public PDFileSpecification pdfbox_f4329_0() throws IOException
{    return PDFileSpecification.createFS(fdf.getDictionaryObject(COSName.F));}
public final void pdfbox_f4330_0(PDFileSpecification fs)
{    fdf.setItem(COSName.F, fs);}
public COSArray pdfbox_f4331_0()
{    return (COSArray) fdf.getDictionaryObject(COSName.ID);}
public final void pdfbox_f4332_0(COSArray id)
{    fdf.setItem(COSName.ID, id);}
public List<FDFField> pdfbox_f4333_0()
{    List<FDFField> retval = null;    COSArray fieldArray = (COSArray) fdf.getDictionaryObject(COSName.FIELDS);    if (fieldArray != null) {        List<FDFField> fields = new ArrayList<>();        for (int i = 0; i < fieldArray.size(); i++) {            fields.add(new FDFField((COSDictionary) fieldArray.getObject(i)));        }        retval = new COSArrayList<>(fields, fieldArray);    }    return retval;}
public final void pdfbox_f4334_0(List<FDFField> fields)
{    fdf.setItem(COSName.FIELDS, COSArrayList.converterToCOSArray(fields));}
public String pdfbox_f4335_0()
{    return fdf.getString(COSName.STATUS);}
public void pdfbox_f4336_0(String status)
{    fdf.setString(COSName.STATUS, status);}
public List<FDFPage> pdfbox_f4337_0()
{    List<FDFPage> retval = null;    COSArray pageArray = (COSArray) fdf.getDictionaryObject(COSName.PAGES);    if (pageArray != null) {        List<FDFPage> pages = new ArrayList<>();        for (int i = 0; i < pageArray.size(); i++) {            pages.add(new FDFPage((COSDictionary) pageArray.get(i)));        }        retval = new COSArrayList<>(pages, pageArray);    }    return retval;}
public void pdfbox_f4338_0(List<FDFPage> pages)
{    fdf.setItem(COSName.PAGES, COSArrayList.converterToCOSArray(pages));}
public String pdfbox_f4339_0()
{    String encoding = fdf.getNameAsString(COSName.ENCODING);    if (encoding == null) {        encoding = "PDFDocEncoding";    }    return encoding;}
public void pdfbox_f4340_0(String encoding)
{    fdf.setName(COSName.ENCODING, encoding);}
public List<FDFAnnotation> pdfbox_f4341_0() throws IOException
{    List<FDFAnnotation> retval = null;    COSArray annotArray = (COSArray) fdf.getDictionaryObject(COSName.ANNOTS);    if (annotArray != null) {        List<FDFAnnotation> annots = new ArrayList<>();        for (int i = 0; i < annotArray.size(); i++) {            annots.add(FDFAnnotation.create((COSDictionary) annotArray.getObject(i)));        }        retval = new COSArrayList<>(annots, annotArray);    }    return retval;}
public final void pdfbox_f4342_0(List<FDFAnnotation> annots)
{    fdf.setItem(COSName.ANNOTS, COSArrayList.converterToCOSArray(annots));}
public COSStream pdfbox_f4343_0()
{    return (COSStream) fdf.getDictionaryObject(COSName.DIFFERENCES);}
public void pdfbox_f4344_0(COSStream diff)
{    fdf.setItem(COSName.DIFFERENCES, diff);}
public String pdfbox_f4345_0()
{    return fdf.getString(COSName.TARGET);}
public void pdfbox_f4346_0(String target)
{    fdf.setString(COSName.TARGET, target);}
public List<PDFileSpecification> pdfbox_f4347_0() throws IOException
{    List<PDFileSpecification> retval = null;    COSArray embeddedArray = (COSArray) fdf.getDictionaryObject(COSName.EMBEDDED_FDFS);    if (embeddedArray != null) {        List<PDFileSpecification> embedded = new ArrayList<>();        for (int i = 0; i < embeddedArray.size(); i++) {            embedded.add(PDFileSpecification.createFS(embeddedArray.get(i)));        }        retval = new COSArrayList<>(embedded, embeddedArray);    }    return retval;}
public void pdfbox_f4348_0(List<PDFileSpecification> embedded)
{    fdf.setItem(COSName.EMBEDDED_FDFS, COSArrayList.converterToCOSArray(embedded));}
public FDFJavaScript pdfbox_f4349_0()
{    FDFJavaScript fs = null;    COSDictionary dic = (COSDictionary) fdf.getDictionaryObject(COSName.JAVA_SCRIPT);    if (dic != null) {        fs = new FDFJavaScript(dic);    }    return fs;}
public void pdfbox_f4350_0(FDFJavaScript js)
{    fdf.setItem(COSName.JAVA_SCRIPT, js);}
public void pdfbox_f4351_0(Writer output) throws IOException
{    output.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");    output.write("<xfdf xmlns=\"http://ns.adobe.com/xfdf/\" xml:space=\"preserve\">\n");    getCatalog().writeXML(output);    output.write("</xfdf>\n");}
public COSDocument pdfbox_f4352_0()
{    return document;}
public FDFCatalog pdfbox_f4353_0()
{    FDFCatalog retval = null;    COSDictionary trailer = document.getTrailer();    COSDictionary root = trailer.getCOSDictionary(COSName.ROOT);    if (root == null) {        retval = new FDFCatalog();        setCatalog(retval);    } else {        retval = new FDFCatalog(root);    }    return retval;}
public final void pdfbox_f4354_0(FDFCatalog cat)
{    COSDictionary trailer = document.getTrailer();    trailer.setItem(COSName.ROOT, cat);}
public static FDFDocument pdfbox_f4355_0(String filename) throws IOException
{    FDFParser parser = new FDFParser(filename);    parser.parse();    return new FDFDocument(parser.getDocument());}
public static FDFDocument pdfbox_f4356_0(File file) throws IOException
{    FDFParser parser = new FDFParser(file);    parser.parse();    return new FDFDocument(parser.getDocument());}
public static FDFDocument pdfbox_f4357_0(InputStream input) throws IOException
{    FDFParser parser = new FDFParser(input);    parser.parse();    return new FDFDocument(parser.getDocument());}
public static FDFDocument pdfbox_f4358_0(String filename) throws IOException
{    return loadXFDF(new BufferedInputStream(new FileInputStream(filename)));}
public static FDFDocument pdfbox_f4359_0(File file) throws IOException
{    return loadXFDF(new BufferedInputStream(new FileInputStream(file)));}
public static FDFDocument pdfbox_f4360_0(InputStream input) throws IOException
{    return new FDFDocument(XMLUtil.parse(input));}
public void pdfbox_f4361_0(File fileName) throws IOException
{    save(new FileOutputStream(fileName));}
public void pdfbox_f4362_0(String fileName) throws IOException
{    save(new FileOutputStream(fileName));}
public void pdfbox_f4363_0(OutputStream output) throws IOException
{    try (COSWriter writer = new COSWriter(output)) {        writer.write(this);    }}
public void pdfbox_f4364_0(File fileName) throws IOException
{    saveXFDF(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), "UTF-8")));}
public void pdfbox_f4365_0(String fileName) throws IOException
{    saveXFDF(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), "UTF-8")));}
public void pdfbox_f4366_0(Writer output) throws IOException
{    try {        writeXML(output);    } finally {        if (output != null) {            output.close();        }    }}
public void pdfbox_f4367_0() throws IOException
{    document.close();}
public void pdfbox_f4368_0(Writer output) throws IOException
{    output.write("<field name=\"" + getPartialFieldName() + "\">\n");    Object value = getValue();    if (value instanceof String) {        output.write("<value>" + escapeXML((String) value) + "</value>\n");    } else if (value instanceof List) {        List<String> items = (List<String>) value;        for (String item : items) {            output.write("<value>" + escapeXML((String) item) + "</value>\n");        }    }    String rt = getRichText();    if (rt != null) {        output.write("<value-richtext>" + escapeXML(rt) + "</value-richtext>\n");    }    List<FDFField> kids = getKids();    if (kids != null) {        for (FDFField kid : kids) {            kid.writeXML(output);        }    }    output.write("</field>\n");}
public COSDictionary pdfbox_f4369_0()
{    return field;}
public List<FDFField> pdfbox_f4370_0()
{    COSArray kids = (COSArray) field.getDictionaryObject(COSName.KIDS);    List<FDFField> retval = null;    if (kids != null) {        List<FDFField> actuals = new ArrayList<>();        for (int i = 0; i < kids.size(); i++) {            actuals.add(new FDFField((COSDictionary) kids.getObject(i)));        }        retval = new COSArrayList<>(actuals, kids);    }    return retval;}
public final void pdfbox_f4371_0(List<FDFField> kids)
{    field.setItem(COSName.KIDS, COSArrayList.converterToCOSArray(kids));}
public String pdfbox_f4372_0()
{    return field.getString(COSName.T);}
public void pdfbox_f4373_0(String partial)
{    field.setString(COSName.T, partial);}
public Object pdfbox_f4374_0() throws IOException
{    COSBase value = field.getDictionaryObject(COSName.V);    if (value instanceof COSName) {        return ((COSName) value).getName();    } else if (value instanceof COSArray) {        return COSArrayList.convertCOSStringCOSArrayToList((COSArray) value);    } else if (value instanceof COSString) {        return ((COSString) value).getString();    } else if (value instanceof COSStream) {        return ((COSStream) value).toTextString();    } else if (value != null) {        throw new IOException("Error:Unknown type for field import" + value);    } else {        return null;    }}
public COSBase pdfbox_f4375_0() throws IOException
{    COSBase value = field.getDictionaryObject(COSName.V);    if (value instanceof COSName) {        return value;    } else if (value instanceof COSArray) {        return value;    } else if (value instanceof COSString || value instanceof COSStream) {        return value;    } else if (value != null) {        throw new IOException("Error:Unknown type for field import" + value);    } else {        return null;    }}
public void pdfbox_f4376_0(Object value) throws IOException
{    COSBase cos = null;    if (value instanceof List) {        cos = COSArrayList.convertStringListToCOSStringCOSArray((List<String>) value);    } else if (value instanceof String) {        cos = new COSString((String) value);    } else if (value instanceof COSObjectable) {        cos = ((COSObjectable) value).getCOSObject();    } else if (value != null) {        throw new IOException("Error:Unknown type for field import" + value);    }    field.setItem(COSName.V, cos);}
public void pdfbox_f4377_0(COSBase value)
{    field.setItem(COSName.V, value);}
public Integer pdfbox_f4378_0()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.FF);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
public void pdfbox_f4379_0(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.FF, value);}
public void pdfbox_f4380_0(int ff)
{    field.setInt(COSName.FF, ff);}
public Integer pdfbox_f4381_0()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.SET_FF);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
public void pdfbox_f4382_0(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.SET_FF, value);}
public void pdfbox_f4383_0(int ff)
{    field.setInt(COSName.SET_FF, ff);}
public Integer pdfbox_f4384_0()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.CLR_FF);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
public void pdfbox_f4385_0(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.CLR_FF, value);}
public void pdfbox_f4386_0(int ff)
{    field.setInt(COSName.CLR_FF, ff);}
public Integer pdfbox_f4387_0()
{    Integer retval = null;    COSNumber f = (COSNumber) field.getDictionaryObject("F");    if (f != null) {        retval = f.intValue();    }    return retval;}
public void pdfbox_f4388_0(Integer f)
{    COSInteger value = null;    if (f != null) {        value = COSInteger.get(f);    }    field.setItem(COSName.F, value);}
public void pdfbox_f4389_0(int f)
{    field.setInt(COSName.F, f);}
public Integer pdfbox_f4390_0()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.SET_F);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
public void pdfbox_f4391_0(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.SET_F, value);}
public void pdfbox_f4392_0(int ff)
{    field.setInt(COSName.SET_F, ff);}
public Integer pdfbox_f4393_0()
{    Integer retval = null;    COSNumber ff = (COSNumber) field.getDictionaryObject(COSName.CLR_F);    if (ff != null) {        retval = ff.intValue();    }    return retval;}
public void pdfbox_f4394_0(Integer ff)
{    COSInteger value = null;    if (ff != null) {        value = COSInteger.get(ff);    }    field.setItem(COSName.CLR_F, value);}
public void pdfbox_f4395_0(int ff)
{    field.setInt(COSName.CLR_F, ff);}
public PDAppearanceDictionary pdfbox_f4396_0()
{    PDAppearanceDictionary retval = null;    COSDictionary dict = (COSDictionary) field.getDictionaryObject(COSName.AP);    if (dict != null) {        retval = new PDAppearanceDictionary(dict);    }    return retval;}
public void pdfbox_f4397_0(PDAppearanceDictionary ap)
{    field.setItem(COSName.AP, ap);}
public FDFNamedPageReference pdfbox_f4398_0()
{    FDFNamedPageReference retval = null;    COSDictionary ref = (COSDictionary) field.getDictionaryObject(COSName.AP_REF);    if (ref != null) {        retval = new FDFNamedPageReference(ref);    }    return retval;}
public void pdfbox_f4399_0(FDFNamedPageReference ref)
{    field.setItem(COSName.AP_REF, ref);}
public FDFIconFit pdfbox_f4400_0()
{    FDFIconFit retval = null;    COSDictionary dic = (COSDictionary) field.getDictionaryObject(COSName.IF);    if (dic != null) {        retval = new FDFIconFit(dic);    }    return retval;}
public void pdfbox_f4401_0(FDFIconFit fit)
{    field.setItem(COSName.IF, fit);}
public List<Object> pdfbox_f4402_0()
{    List<Object> retval = null;    COSArray array = (COSArray) field.getDictionaryObject(COSName.OPT);    if (array != null) {        List<Object> objects = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            COSBase next = array.getObject(i);            if (next instanceof COSString) {                objects.add(((COSString) next).getString());            } else {                COSArray value = (COSArray) next;                objects.add(new FDFOptionElement(value));            }        }        retval = new COSArrayList<>(objects, array);    }    return retval;}
public void pdfbox_f4403_0(List<Object> options)
{    COSArray value = COSArrayList.converterToCOSArray(options);    field.setItem(COSName.OPT, value);}
public PDAction pdfbox_f4404_0()
{    return PDActionFactory.createAction((COSDictionary) field.getDictionaryObject(COSName.A));}
public void pdfbox_f4405_0(PDAction a)
{    field.setItem(COSName.A, a);}
public PDAdditionalActions pdfbox_f4406_0()
{    PDAdditionalActions retval = null;    COSDictionary dict = (COSDictionary) field.getDictionaryObject(COSName.AA);    if (dict != null) {        retval = new PDAdditionalActions(dict);    }    return retval;}
public void pdfbox_f4407_0(PDAdditionalActions aa)
{    field.setItem(COSName.AA, aa);}
public String pdfbox_f4408_0()
{    COSBase rv = field.getDictionaryObject(COSName.RV);    if (rv == null) {        return null;    } else if (rv instanceof COSString) {        return ((COSString) rv).getString();    } else {        return ((COSStream) rv).toTextString();    }}
public void pdfbox_f4409_0(COSString rv)
{    field.setItem(COSName.RV, rv);}
public void pdfbox_f4410_0(COSStream rv)
{    field.setItem(COSName.RV, rv);}
private String pdfbox_f4411_0(String input)
{    StringBuilder escapedXML = new StringBuilder();    for (int i = 0; i < input.length(); i++) {        char c = input.charAt(i);        switch(c) {            case '<':                escapedXML.append("&lt;");                break;            case '>':                escapedXML.append("&gt;");                break;            case '\"':                escapedXML.append("&quot;");                break;            case '&':                escapedXML.append("&amp;");                break;            case '\'':                escapedXML.append("&apos;");                break;            default:                if (c > 0x7e) {                    escapedXML.append("&#").append((int) c).append(";");                } else {                    escapedXML.append(c);                }        }    }    return escapedXML.toString();}
public COSDictionary pdfbox_f4412_0()
{    return fit;}
public String pdfbox_f4413_0()
{    String retval = fit.getNameAsString(COSName.SW);    if (retval == null) {        retval = SCALE_OPTION_ALWAYS;    }    return retval;}
public void pdfbox_f4414_0(String option)
{    fit.setName(COSName.SW, option);}
public String pdfbox_f4415_0()
{    String retval = fit.getNameAsString(COSName.S);    if (retval == null) {        retval = SCALE_TYPE_PROPORTIONAL;    }    return retval;}
public void pdfbox_f4416_0(String scale)
{    fit.setName(COSName.S, scale);}
public PDRange pdfbox_f4417_0()
{    PDRange retval = null;    COSArray array = (COSArray) fit.getDictionaryObject(COSName.A);    if (array == null) {        retval = new PDRange();        retval.setMin(.5f);        retval.setMax(.5f);        setFractionalSpaceToAllocate(retval);    } else {        retval = new PDRange(array);    }    return retval;}
public void pdfbox_f4418_0(PDRange space)
{    fit.setItem(COSName.A, space);}
public boolean pdfbox_f4419_0()
{    return fit.getBoolean(COSName.FB, false);}
public void pdfbox_f4420_0(boolean value)
{    fit.setBoolean(COSName.FB, value);}
public COSDictionary pdfbox_f4421_0()
{    return dictionary;}
public String pdfbox_f4422_0()
{    COSBase base = dictionary.getDictionaryObject(COSName.BEFORE);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
public void pdfbox_f4423_0(String before)
{    dictionary.setItem(COSName.BEFORE, new COSString(before));}
public String pdfbox_f4424_0()
{    COSBase base = dictionary.getDictionaryObject(COSName.AFTER);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
public void pdfbox_f4425_0(String after)
{    dictionary.setItem(COSName.AFTER, new COSString(after));}
public Map<String, PDActionJavaScript> pdfbox_f4426_0()
{    Map<String, PDActionJavaScript> map = new LinkedHashMap<>();    COSArray array = (COSArray) dictionary.getDictionaryObject(COSName.DOC);    if (array == null) {        return null;    }    for (int i = 0; i < array.size(); i++) {        PDActionFactory.createAction((COSDictionary) array.getObject(i));    }    return map;}
public void pdfbox_f4427_0(Map<String, PDActionJavaScript> map)
{    COSArray array = new COSArray();    for (Map.Entry<String, PDActionJavaScript> entry : map.entrySet()) {        array.add(new COSString(entry.getKey()));        array.add(entry.getValue());    }    dictionary.setItem(COSName.DOC, array);}
public COSDictionary pdfbox_f4428_0()
{    return ref;}
public String pdfbox_f4429_0()
{    return ref.getString(COSName.NAME);}
public void pdfbox_f4430_0(String name)
{    ref.setString(COSName.NAME, name);}
public PDFileSpecification pdfbox_f4431_0() throws IOException
{    return PDFileSpecification.createFS(ref.getDictionaryObject(COSName.F));}
public void pdfbox_f4432_0(PDFileSpecification fs)
{    ref.setItem(COSName.F, fs);}
public COSBase pdfbox_f4433_0()
{    return option;}
public COSArray pdfbox_f4434_0()
{    return option;}
public String pdfbox_f4435_0()
{    return ((COSString) option.getObject(0)).getString();}
public void pdfbox_f4436_0(String opt)
{    option.set(0, new COSString(opt));}
public String pdfbox_f4437_0()
{    return ((COSString) option.getObject(1)).getString();}
public void pdfbox_f4438_0(String da)
{    option.set(1, new COSString(da));}
public COSDictionary pdfbox_f4439_0()
{    return page;}
public List<FDFTemplate> pdfbox_f4440_0()
{    List<FDFTemplate> retval = null;    COSArray array = (COSArray) page.getDictionaryObject(COSName.TEMPLATES);    if (array != null) {        List<FDFTemplate> objects = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            objects.add(new FDFTemplate((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(objects, array);    }    return retval;}
public void pdfbox_f4441_0(List<FDFTemplate> templates)
{    page.setItem(COSName.TEMPLATES, COSArrayList.converterToCOSArray(templates));}
public FDFPageInfo pdfbox_f4442_0()
{    FDFPageInfo retval = null;    COSDictionary dict = page.getCOSDictionary(COSName.INFO);    if (dict != null) {        retval = new FDFPageInfo(dict);    }    return retval;}
public void pdfbox_f4443_0(FDFPageInfo info)
{    page.setItem(COSName.INFO, info);}
public COSDictionary pdfbox_f4444_0()
{    return pageInfo;}
public COSDictionary pdfbox_f4445_0()
{    return template;}
public FDFNamedPageReference pdfbox_f4446_0()
{    FDFNamedPageReference retval = null;    COSDictionary dict = (COSDictionary) template.getDictionaryObject(COSName.TREF);    if (dict != null) {        retval = new FDFNamedPageReference(dict);    }    return retval;}
public void pdfbox_f4447_0(FDFNamedPageReference tRef)
{    template.setItem(COSName.TREF, tRef);}
public List<FDFField> pdfbox_f4448_0()
{    List<FDFField> retval = null;    COSArray array = (COSArray) template.getDictionaryObject(COSName.FIELDS);    if (array != null) {        List<FDFField> fields = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            fields.add(new FDFField((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(fields, array);    }    return retval;}
public void pdfbox_f4449_0(List<FDFField> fields)
{    template.setItem(COSName.FIELDS, COSArrayList.converterToCOSArray(fields));}
public boolean pdfbox_f4450_0()
{    return template.getBoolean(COSName.RENAME, false);}
public void pdfbox_f4451_0(boolean value)
{    template.setBoolean(COSName.RENAME, value);}
public FontBoxFont pdfbox_f4452_0()
{    return ttf;}
public boolean pdfbox_f4453_0()
{    return getFont() != null;}
public String pdfbox_f4454_0()
{    return registry;}
public String pdfbox_f4455_0()
{    return ordering;}
public int pdfbox_f4456_0()
{    return supplement;}
public String pdfbox_f4457_0()
{    return getRegistry() + "-" + getOrdering() + "-" + getSupplement();}
public static CMap pdfbox_f4458_0(String cMapName) throws IOException
{    CMap cmap = cMapCache.get(cMapName);    if (cmap != null) {        return cmap;    }    CMapParser parser = new CMapParser();    CMap targetCmap = parser.parsePredefined(cMapName);        cMapCache.put(targetCmap.getName(), targetCmap);    return targetCmap;}
public static CMap pdfbox_f4459_0(InputStream cMapStream) throws IOException
{    CMap targetCmap = null;    if (cMapStream != null) {        CMapParser parser = new CMapParser();        targetCmap = parser.parse(cMapStream);    }    return targetCmap;}
public COSBase pdfbox_f4460_0()
{    throw new UnsupportedOperationException("Built-in encodings cannot be serialized");}
public String pdfbox_f4461_0()
{    return "built-in (TTF)";}
private void pdfbox_f4462_0()
{        COSBase base = encoding.getDictionaryObject(COSName.DIFFERENCES);    if (!(base instanceof COSArray)) {        return;    }    COSArray diffArray = (COSArray) base;    int currentIndex = -1;    for (int i = 0; i < diffArray.size(); i++) {        COSBase next = diffArray.getObject(i);        if (next instanceof COSNumber) {            currentIndex = ((COSNumber) next).intValue();        } else if (next instanceof COSName) {            COSName name = (COSName) next;            overwrite(currentIndex, name.getName());            this.differences.put(currentIndex, name.getName());            currentIndex++;        }    }}
public Encoding pdfbox_f4463_0()
{    return baseEncoding;}
public Map<Integer, String> pdfbox_f4464_0()
{    return differences;}
public COSBase pdfbox_f4465_0()
{    return encoding;}
public String pdfbox_f4466_0()
{    return baseEncoding.getEncodingName() + " with differences";}
public static Encoding pdfbox_f4467_0(COSName name)
{    if (COSName.STANDARD_ENCODING.equals(name)) {        return StandardEncoding.INSTANCE;    } else if (COSName.WIN_ANSI_ENCODING.equals(name)) {        return WinAnsiEncoding.INSTANCE;    } else if (COSName.MAC_ROMAN_ENCODING.equals(name)) {        return MacRomanEncoding.INSTANCE;    } else if (COSName.MAC_EXPERT_ENCODING.equals(name)) {        return MacExpertEncoding.INSTANCE;    } else {        return null;    }}
public Map<Integer, String> pdfbox_f4468_0()
{    return Collections.unmodifiableMap(codeToName);}
public Map<String, Integer> pdfbox_f4469_0()
{    return Collections.unmodifiableMap(inverted);}
protected void pdfbox_f4470_0(int code, String name)
{    codeToName.put(code, name);    if (!inverted.containsKey(name)) {        inverted.put(name, code);    }}
protected void pdfbox_f4471_0(int code, String name)
{        String oldName = codeToName.get(code);    if (oldName != null) {        Integer oldCode = inverted.get(oldName);        if (oldCode != null && oldCode == code) {            inverted.remove(oldName);        }    }    inverted.put(name, code);    codeToName.put(code, name);}
public boolean pdfbox_f4472_0(String name)
{        if (names == null) {        synchronized (this) {                        Set<String> tmpSet = new HashSet<>(codeToName.values());                        names = tmpSet;                }        }    return names.contains(name);}
public boolean pdfbox_f4473_0(int code)
{    return codeToName.containsKey(code);}
public String pdfbox_f4474_0(int code)
{    String name = codeToName.get(code);    if (name != null) {        return name;    }    return ".notdef";}
private static GlyphList pdfbox_f4475_0(String filename, int numberOfEntries)
{    String path = "/org/apache/pdfbox/resources/glyphlist/";    try {        return new GlyphList(GlyphList.class.getResourceAsStream(path + filename), numberOfEntries);    } catch (IOException e) {        throw new RuntimeException(e);    }}
public static GlyphList pdfbox_f4476_0()
{    return DEFAULT;}
public static GlyphList pdfbox_f4477_0()
{    return ZAPF_DINGBATS;}
private void pdfbox_f4478_1(InputStream input) throws IOException
{    try (BufferedReader in = new BufferedReader(new InputStreamReader(input, "ISO-8859-1"))) {        while (in.ready()) {            String line = in.readLine();            if (line != null && !line.startsWith("#")) {                String[] parts = line.split(";");                if (parts.length < 2) {                    throw new IOException("Invalid glyph list entry: " + line);                }                String name = parts[0];                String[] unicodeList = parts[1].split(" ");                if (nameToUnicode.containsKey(name)) {                                    }                int[] codePoints = new int[unicodeList.length];                int index = 0;                for (String hex : unicodeList) {                    codePoints[index++] = Integer.parseInt(hex, 16);                }                String string = new String(codePoints, 0, codePoints.length);                                nameToUnicode.put(name, string);                                                                final boolean forceOverride = WinAnsiEncoding.INSTANCE.contains(name) || MacRomanEncoding.INSTANCE.contains(name) || MacExpertEncoding.INSTANCE.contains(name) || SymbolEncoding.INSTANCE.contains(name) || ZapfDingbatsEncoding.INSTANCE.contains(name);                if (!unicodeToName.containsKey(string) || forceOverride) {                    unicodeToName.put(string, name);                }            }        }    }}
public String pdfbox_f4479_0(int codePoint)
{    String name = unicodeToName.get(new String(new int[] { codePoint }, 0, 1));    if (name == null) {        return ".notdef";    }    return name;}
public String pdfbox_f4480_0(String unicodeSequence)
{    String name = unicodeToName.get(unicodeSequence);    if (name == null) {        return ".notdef";    }    return name;}
public String pdfbox_f4481_1(String name)
{    if (name == null) {        return null;    }    String unicode = nameToUnicode.get(name);    if (unicode != null) {        return unicode;    }        unicode = uniNameToUnicodeCache.get(name);    if (unicode == null) {                if (name.indexOf('.') > 0) {            unicode = toUnicode(name.substring(0, name.indexOf('.')));        } else if (name.startsWith("uni") && name.length() == 7) {                        int nameLength = name.length();            StringBuilder uniStr = new StringBuilder();            try {                for (int chPos = 3; chPos + 4 <= nameLength; chPos += 4) {                    int codePoint = Integer.parseInt(name.substring(chPos, chPos + 4), 16);                    if (codePoint > 0xD7FF && codePoint < 0xE000) {                                            } else {                        uniStr.append((char) codePoint);                    }                }                unicode = uniStr.toString();            } catch (NumberFormatException nfe) {                            }        } else if (name.startsWith("u") && name.length() == 5) {                        try {                int codePoint = Integer.parseInt(name.substring(1), 16);                if (codePoint > 0xD7FF && codePoint < 0xE000) {                                    } else {                    unicode = String.valueOf((char) codePoint);                }            } catch (NumberFormatException nfe) {                            }        }        if (unicode != null) {                        uniNameToUnicodeCache.put(name, unicode);        }    }    return unicode;}
public COSBase pdfbox_f4482_0()
{    return COSName.MAC_EXPERT_ENCODING;}
public String pdfbox_f4483_0()
{    return "MacExpertEncoding";}
public COSBase pdfbox_f4484_0()
{    return null;}
public COSBase pdfbox_f4485_0()
{    return COSName.MAC_ROMAN_ENCODING;}
public String pdfbox_f4486_0()
{    return "MacRomanEncoding";}
public COSBase pdfbox_f4487_0()
{    return COSName.STANDARD_ENCODING;}
public String pdfbox_f4488_0()
{    return "StandardEncoding";}
public COSBase pdfbox_f4489_0()
{    return COSName.getPDFName("SymbolEncoding");}
public String pdfbox_f4490_0()
{    return "SymbolEncoding";}
public static Type1Encoding pdfbox_f4491_0(org.apache.fontbox.encoding.Encoding encoding)
{        Map<Integer, String> codeToName = encoding.getCodeToNameMap();    Type1Encoding enc = new Type1Encoding();    for (Map.Entry<Integer, String> entry : codeToName.entrySet()) {        enc.add(entry.getKey(), entry.getValue());    }    return enc;}
public COSBase pdfbox_f4492_0()
{    return null;}
public String pdfbox_f4493_0()
{    return "built-in (Type 1)";}
public COSBase pdfbox_f4494_0()
{    return COSName.WIN_ANSI_ENCODING;}
public String pdfbox_f4495_0()
{    return "WinAnsiEncoding";}
public COSBase pdfbox_f4496_0()
{    return COSName.getPDFName("ZapfDingbatsEncoding");}
public String pdfbox_f4497_0()
{    return "ZapfDingbatsEncoding";}
public String pdfbox_f4498_0()
{    return postScriptName;}
public FontFormat pdfbox_f4499_0()
{    return format;}
public CIDSystemInfo pdfbox_f4500_0()
{    return cidSystemInfo;}
public FontBoxFont pdfbox_f4501_0()
{    FontBoxFont cached = parent.cache.getFont(this);    if (cached != null) {        return cached;    } else {        FontBoxFont font;        switch(format) {            case PFB:                font = getType1Font(postScriptName, file);                break;            case TTF:                font = getTrueTypeFont(postScriptName, file);                break;            case OTF:                font = getOTFFont(postScriptName, file);                break;            default:                throw new RuntimeException("can't happen");        }        if (font != null) {            parent.cache.addFont(this, font);        }        return font;    }}
public int pdfbox_f4502_0()
{    return sFamilyClass;}
public int pdfbox_f4503_0()
{    return usWeightClass;}
public int pdfbox_f4504_0()
{    return ulCodePageRange1;}
public int pdfbox_f4505_0()
{    return ulCodePageRange2;}
public int pdfbox_f4506_0()
{    return macStyle;}
public PDPanoseClassification pdfbox_f4507_0()
{    return panose;}
public String pdfbox_f4508_0()
{    return super.toString() + " " + file;}
private TrueTypeFont pdfbox_f4509_1(String postScriptName, File file)
{    try {        TrueTypeFont ttf = readTrueTypeFont(postScriptName, file);        if (LOG.isDebugEnabled()) {                    }        return ttf;    } catch (NullPointerException | IOException e) {                    }    return null;}
private TrueTypeFont pdfbox_f4510_0(String postScriptName, File file) throws IOException
{    if (file.getName().toLowerCase().endsWith(".ttc")) {        @SuppressWarnings("squid:S2095")        TrueTypeCollection         ttc = new TrueTypeCollection(file);        TrueTypeFont ttf = ttc.getFontByName(postScriptName);        if (ttf == null) {            ttc.close();            throw new IOException("Font " + postScriptName + " not found in " + file);        }        return ttf;    } else {        TTFParser ttfParser = new TTFParser(false, true);        return ttfParser.parse(file);    }}
private OpenTypeFont pdfbox_f4511_1(String postScriptName, File file)
{    try {                OTFParser parser = new OTFParser(false, true);        OpenTypeFont otf = parser.parse(file);        if (LOG.isDebugEnabled()) {                    }        return otf;    } catch (IOException e) {            }    return null;}
private Type1Font pdfbox_f4512_1(String postScriptName, File file)
{    try (InputStream input = new FileInputStream(file)) {        Type1Font type1 = Type1Font.createWithPFB(input);        if (LOG.isDebugEnabled()) {                    }        return type1;    } catch (IOException e) {            }    return null;}
private void pdfbox_f4513_1(List<File> files)
{    for (File file : files) {        try {            if (file.getPath().toLowerCase().endsWith(".ttf") || file.getPath().toLowerCase().endsWith(".otf")) {                addTrueTypeFont(file);            } else if (file.getPath().toLowerCase().endsWith(".ttc") || file.getPath().toLowerCase().endsWith(".otc")) {                addTrueTypeCollection(file);            } else if (file.getPath().toLowerCase().endsWith(".pfb")) {                addType1Font(file);            }        } catch (IOException e) {                    }    }}
private File pdfbox_f4514_0()
{    String path = System.getProperty("pdfbox.fontcache");    if (path == null || !new File(path).isDirectory() || !new File(path).canWrite()) {        path = System.getProperty("user.home");        if (path == null || !new File(path).isDirectory() || !new File(path).canWrite()) {            path = System.getProperty("java.io.tmpdir");        }    }    return new File(path, ".pdfbox.cache");}
private void pdfbox_f4515_1()
{    try {        File file = getDiskCacheFile();        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {            for (FSFontInfo fontInfo : fontInfoList) {                writeFontInfo(writer, fontInfo);            }        } catch (IOException e) {                                            }    } catch (SecurityException e) {            }}
private void pdfbox_f4516_0(BufferedWriter writer, FSFontInfo fontInfo) throws IOException
{    writer.write(fontInfo.postScriptName.trim());    writer.write("|");    writer.write(fontInfo.format.toString());    writer.write("|");    if (fontInfo.cidSystemInfo != null) {        writer.write(fontInfo.cidSystemInfo.getRegistry() + '-' + fontInfo.cidSystemInfo.getOrdering() + '-' + fontInfo.cidSystemInfo.getSupplement());    }    writer.write("|");    if (fontInfo.usWeightClass > -1) {        writer.write(Integer.toHexString(fontInfo.usWeightClass));    }    writer.write("|");    if (fontInfo.sFamilyClass > -1) {        writer.write(Integer.toHexString(fontInfo.sFamilyClass));    }    writer.write("|");    writer.write(Integer.toHexString(fontInfo.ulCodePageRange1));    writer.write("|");    writer.write(Integer.toHexString(fontInfo.ulCodePageRange2));    writer.write("|");    if (fontInfo.macStyle > -1) {        writer.write(Integer.toHexString(fontInfo.macStyle));    }    writer.write("|");    if (fontInfo.panose != null) {        byte[] bytes = fontInfo.panose.getBytes();        for (int i = 0; i < 10; i++) {            String str = Integer.toHexString(bytes[i]);            if (str.length() == 1) {                writer.write('0');            }            writer.write(str);        }    }    writer.write("|");    writer.write(fontInfo.file.getAbsolutePath());    writer.newLine();}
private List<FSFontInfo> pdfbox_f4517_1(List<File> files)
{    Set<String> pending = new HashSet<>();    for (File file : files) {        pending.add(file.getAbsolutePath());    }    List<FSFontInfo> results = new ArrayList<>();        File file = null;    boolean fileExists = false;    try {        file = getDiskCacheFile();        fileExists = file.exists();    } catch (SecurityException e) {            }    if (fileExists) {        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {            String line;            while ((line = reader.readLine()) != null) {                String[] parts = line.split("\\|", 10);                if (parts.length < 10) {                                        continue;                }                String postScriptName;                FontFormat format;                CIDSystemInfo cidSystemInfo = null;                int usWeightClass = -1;                int sFamilyClass = -1;                int ulCodePageRange1;                int ulCodePageRange2;                int macStyle = -1;                byte[] panose = null;                File fontFile;                postScriptName = parts[0];                format = FontFormat.valueOf(parts[1]);                if (parts[2].length() > 0) {                    String[] ros = parts[2].split("-");                    cidSystemInfo = new CIDSystemInfo(ros[0], ros[1], Integer.parseInt(ros[2]));                }                if (parts[3].length() > 0) {                    usWeightClass = (int) Long.parseLong(parts[3], 16);                }                if (parts[4].length() > 0) {                    sFamilyClass = (int) Long.parseLong(parts[4], 16);                }                ulCodePageRange1 = (int) Long.parseLong(parts[5], 16);                ulCodePageRange2 = (int) Long.parseLong(parts[6], 16);                if (parts[7].length() > 0) {                    macStyle = (int) Long.parseLong(parts[7], 16);                }                if (parts[8].length() > 0) {                    panose = new byte[10];                    for (int i = 0; i < 10; i++) {                        String str = parts[8].substring(i * 2, i * 2 + 2);                        int b = Integer.parseInt(str, 16);                        panose[i] = (byte) (b & 0xff);                    }                }                fontFile = new File(parts[9]);                if (fontFile.exists()) {                    FSFontInfo info = new FSFontInfo(fontFile, format, postScriptName, cidSystemInfo, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this);                    results.add(info);                } else {                                    }                pending.remove(fontFile.getAbsolutePath());            }        } catch (IOException e) {                        return null;        }    }    if (!pending.isEmpty()) {                        return null;    }    return results;}
private void pdfbox_f4518_1(final File ttcFile) throws IOException
{    try (TrueTypeCollection ttc = new TrueTypeCollection(ttcFile)) {        ttc.processAllFonts(ttf -> addTrueTypeFontImpl(ttf, ttcFile));    } catch (NullPointerException | IOException e) {                    }}
private void pdfbox_f4519_1(File ttfFile) throws IOException
{    try {        if (ttfFile.getPath().endsWith(".otf")) {            OTFParser parser = new OTFParser(false, true);            OpenTypeFont otf = parser.parse(ttfFile);            addTrueTypeFontImpl(otf, ttfFile);        } else {            TTFParser parser = new TTFParser(false, true);            TrueTypeFont ttf = parser.parse(ttfFile);            addTrueTypeFontImpl(ttf, ttfFile);        }    } catch (NullPointerException | IOException e) {                    }}
private void pdfbox_f4520_1(TrueTypeFont ttf, File file) throws IOException
{    try {                if (ttf.getName() != null && ttf.getName().contains("|")) {            fontInfoList.add(new FSIgnored(file, FontFormat.TTF, "*skippipeinname*"));                    } else if (ttf.getName() != null) {                        if (ttf.getHeader() == null) {                fontInfoList.add(new FSIgnored(file, FontFormat.TTF, ttf.getName()));                return;            }            int macStyle = ttf.getHeader().getMacStyle();            int sFamilyClass = -1;            int usWeightClass = -1;            int ulCodePageRange1 = 0;            int ulCodePageRange2 = 0;            byte[] panose = null;                        if (ttf.getOS2Windows() != null) {                sFamilyClass = ttf.getOS2Windows().getFamilyClass();                usWeightClass = ttf.getOS2Windows().getWeightClass();                ulCodePageRange1 = (int) ttf.getOS2Windows().getCodePageRange1();                ulCodePageRange2 = (int) ttf.getOS2Windows().getCodePageRange2();                panose = ttf.getOS2Windows().getPanose();            }            String format;            if (ttf instanceof OpenTypeFont && ((OpenTypeFont) ttf).isPostScript()) {                format = "OTF";                CFFFont cff = ((OpenTypeFont) ttf).getCFF().getFont();                CIDSystemInfo ros = null;                if (cff instanceof CFFCIDFont) {                    CFFCIDFont cidFont = (CFFCIDFont) cff;                    String registry = cidFont.getRegistry();                    String ordering = cidFont.getOrdering();                    int supplement = cidFont.getSupplement();                    ros = new CIDSystemInfo(registry, ordering, supplement);                }                fontInfoList.add(new FSFontInfo(file, FontFormat.OTF, ttf.getName(), ros, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this));            } else {                CIDSystemInfo ros = null;                if (ttf.getTableMap().containsKey("gcid")) {                                        byte[] bytes = ttf.getTableBytes(ttf.getTableMap().get("gcid"));                    String reg = new String(bytes, 10, 64, Charsets.US_ASCII);                    String registryName = reg.substring(0, reg.indexOf('\0'));                    String ord = new String(bytes, 76, 64, Charsets.US_ASCII);                    String orderName = ord.substring(0, ord.indexOf('\0'));                    int supplementVersion = bytes[140] << 8 & (bytes[141] & 0xFF);                    ros = new CIDSystemInfo(registryName, orderName, supplementVersion);                }                format = "TTF";                fontInfoList.add(new FSFontInfo(file, FontFormat.TTF, ttf.getName(), ros, usWeightClass, sFamilyClass, ulCodePageRange1, ulCodePageRange2, macStyle, panose, this));            }            if (LOG.isTraceEnabled()) {                NamingTable name = ttf.getNaming();                if (name != null) {                    LOG.trace(format + ": '" + name.getPostScriptName() + "' / '" + name.getFontFamily() + "' / '" + name.getFontSubFamily() + "'");                }            }        } else {            fontInfoList.add(new FSIgnored(file, FontFormat.TTF, "*skipnoname*"));                    }    } catch (IOException e) {        fontInfoList.add(new FSIgnored(file, FontFormat.TTF, "*skipexception*"));            } finally {        ttf.close();    }}
private void pdfbox_f4521_1(File pfbFile) throws IOException
{    try (InputStream input = new FileInputStream(pfbFile)) {        Type1Font type1 = Type1Font.createWithPFB(input);        if (type1.getName() != null && type1.getName().contains("|")) {            fontInfoList.add(new FSIgnored(pfbFile, FontFormat.PFB, "*skippipeinname*"));                        return;        }        fontInfoList.add(new FSFontInfo(pfbFile, FontFormat.PFB, type1.getName(), null, -1, -1, 0, 0, -1, null, this));        if (LOG.isTraceEnabled()) {            LOG.trace("PFB: '" + type1.getName() + "' / '" + type1.getFamilyName() + "' / '" + type1.getWeight() + "'");        }    } catch (IOException e) {            }}
public String pdfbox_f4522_0()
{    StringBuilder sb = new StringBuilder();    for (FSFontInfo info : fontInfoList) {        sb.append(info.getFormat());        sb.append(": ");        sb.append(info.getPostScriptName());        sb.append(": ");        sb.append(info.file.getPath());        sb.append('\n');    }    return sb.toString();}
public List<? extends FontInfo> pdfbox_f4523_0()
{    return fontInfoList;}
public void pdfbox_f4524_0(FontInfo info, FontBoxFont font)
{    cache.put(info, new SoftReference<>(font));}
public FontBoxFont pdfbox_f4525_0(FontInfo info)
{    SoftReference<FontBoxFont> reference = cache.get(info);    return reference != null ? reference.get() : null;}
 final int pdfbox_f4526_0()
{    int usWeightClass = getWeightClass();    switch(usWeightClass) {        case -1:            return 0;        case 0:            return 0;        case 100:            return 2;        case 200:            return 3;        case 300:            return 4;        case 400:            return 5;        case 500:            return 6;        case 600:            return 7;        case 700:            return 8;        case 800:            return 9;        case 900:            return 10;        default:            return 0;    }}
 final long pdfbox_f4527_0()
{    long range1 = getCodePageRange1() & 0x00000000ffffffffL;    long range2 = getCodePageRange2() & 0x00000000ffffffffL;    return range2 << 32 | range1;}
public String pdfbox_f4528_0()
{    return getPostScriptName() + " (" + getFormat() + ", mac: 0x" + Integer.toHexString(getMacStyle()) + ", os/2: 0x" + Integer.toHexString(getFamilyClass()) + ", cid: " + getCIDSystemInfo() + ")";}
public synchronized void pdfbox_f4529_0(FontProvider fontProvider)
{    fontInfoByName = createFontInfoByName(fontProvider.getFontInfo());    this.fontProvider = fontProvider;}
public synchronized FontProvider pdfbox_f4530_0()
{    if (fontProvider == null) {        setProvider(DefaultFontProvider.INSTANCE);    }    return fontProvider;}
public FontCache pdfbox_f4531_0()
{    return fontCache;}
private Map<String, FontInfo> pdfbox_f4532_0(List<? extends FontInfo> fontInfoList)
{    Map<String, FontInfo> map = new LinkedHashMap<>();    for (FontInfo info : fontInfoList) {        for (String name : getPostScriptNames(info.getPostScriptName())) {            map.put(name, info);        }    }    return map;}
private Set<String> pdfbox_f4533_0(String postScriptName)
{    Set<String> names = new HashSet<>();        names.add(postScriptName);        names.add(postScriptName.replaceAll("-", ""));    return names;}
private List<String> pdfbox_f4534_0(String postScriptName)
{    return new ArrayList<>(substitutes.get(postScriptName));}
public void pdfbox_f4535_0(String match, String replace)
{    if (!substitutes.containsKey(match)) {        substitutes.put(match, new ArrayList<String>());    }    substitutes.get(match).add(replace);}
private List<String> pdfbox_f4536_0(String postScriptName)
{    List<String> subs = substitutes.get(postScriptName.replaceAll(" ", ""));    if (subs != null) {        return subs;    } else {        return Collections.emptyList();    }}
private String pdfbox_f4537_0(PDFontDescriptor fontDescriptor)
{    String fontName;    if (fontDescriptor != null) {                boolean isBold = false;        String name = fontDescriptor.getFontName();        if (name != null) {            String lower = fontDescriptor.getFontName().toLowerCase();            isBold = lower.contains("bold") || lower.contains("black") || lower.contains("heavy");        }                if (fontDescriptor.isFixedPitch()) {            fontName = "Courier";            if (isBold && fontDescriptor.isItalic()) {                fontName += "-BoldOblique";            } else if (isBold) {                fontName += "-Bold";            } else if (fontDescriptor.isItalic()) {                fontName += "-Oblique";            }        } else if (fontDescriptor.isSerif()) {            fontName = "Times";            if (isBold && fontDescriptor.isItalic()) {                fontName += "-BoldItalic";            } else if (isBold) {                fontName += "-Bold";            } else if (fontDescriptor.isItalic()) {                fontName += "-Italic";            } else {                fontName += "-Roman";            }        } else {            fontName = "Helvetica";            if (isBold && fontDescriptor.isItalic()) {                fontName += "-BoldOblique";            } else if (isBold) {                fontName += "-Bold";            } else if (fontDescriptor.isItalic()) {                fontName += "-Oblique";            }        }    } else {                fontName = "Times-Roman";    }    return fontName;}
public FontMapping<TrueTypeFont> pdfbox_f4538_0(String baseFont, PDFontDescriptor fontDescriptor)
{    TrueTypeFont ttf = (TrueTypeFont) findFont(FontFormat.TTF, baseFont);    if (ttf != null) {        return new FontMapping<>(ttf, false);    } else {                String fontName = getFallbackFontName(fontDescriptor);        ttf = (TrueTypeFont) findFont(FontFormat.TTF, fontName);        if (ttf == null) {                        ttf = lastResortFont;        }        return new FontMapping<>(ttf, true);    }}
public FontMapping<FontBoxFont> pdfbox_f4539_0(String baseFont, PDFontDescriptor fontDescriptor)
{    FontBoxFont font = findFontBoxFont(baseFont);    if (font != null) {        return new FontMapping<>(font, false);    } else {                String fallbackName = getFallbackFontName(fontDescriptor);        font = findFontBoxFont(fallbackName);        if (font == null) {                        font = lastResortFont;        }        return new FontMapping<>(font, true);    }}
private FontBoxFont pdfbox_f4540_0(String postScriptName)
{    Type1Font t1 = (Type1Font) findFont(FontFormat.PFB, postScriptName);    if (t1 != null) {        return t1;    }    TrueTypeFont ttf = (TrueTypeFont) findFont(FontFormat.TTF, postScriptName);    if (ttf != null) {        return ttf;    }    OpenTypeFont otf = (OpenTypeFont) findFont(FontFormat.OTF, postScriptName);    if (otf != null) {        return otf;    }    return null;}
private FontBoxFont pdfbox_f4541_0(FontFormat format, String postScriptName)
{        if (postScriptName == null) {        return null;    }        if (fontProvider == null) {        getProvider();    }        FontInfo info = getFont(format, postScriptName);    if (info != null) {        return info.getFont();    }        info = getFont(format, postScriptName.replaceAll("-", ""));    if (info != null) {        return info.getFont();    }        for (String substituteName : getSubstitutes(postScriptName)) {        info = getFont(format, substituteName);        if (info != null) {            return info.getFont();        }    }        info = getFont(format, postScriptName.replaceAll(",", "-"));    if (info != null) {        return info.getFont();    }        info = getFont(format, postScriptName + "-Regular");    if (info != null) {        return info.getFont();    }        return null;}
private FontInfo pdfbox_f4542_0(FontFormat format, String postScriptName)
{        if (postScriptName.contains("+")) {        postScriptName = postScriptName.substring(postScriptName.indexOf('+') + 1);    }        FontInfo info = fontInfoByName.get(postScriptName);    if (info != null && info.getFormat() == format) {        return info;    }    return null;}
public CIDFontMapping pdfbox_f4543_0(String baseFont, PDFontDescriptor fontDescriptor, PDCIDSystemInfo cidSystemInfo)
{        OpenTypeFont otf1 = (OpenTypeFont) findFont(FontFormat.OTF, baseFont);    if (otf1 != null) {        return new CIDFontMapping(otf1, null, false);    }        TrueTypeFont ttf = (TrueTypeFont) findFont(FontFormat.TTF, baseFont);    if (ttf != null) {        return new CIDFontMapping(null, ttf, false);    }    if (cidSystemInfo != null) {                                String collection = cidSystemInfo.getRegistry() + "-" + cidSystemInfo.getOrdering();        if (collection.equals("Adobe-GB1") || collection.equals("Adobe-CNS1") || collection.equals("Adobe-Japan1") || collection.equals("Adobe-Korea1")) {                        PriorityQueue<FontMatch> queue = getFontMatches(fontDescriptor, cidSystemInfo);            FontMatch bestMatch = queue.poll();            if (bestMatch != null) {                FontBoxFont font = bestMatch.info.getFont();                if (font instanceof OpenTypeFont) {                    return new CIDFontMapping((OpenTypeFont) font, null, true);                } else if (font != null) {                    return new CIDFontMapping(null, font, true);                }            }        }    }        return new CIDFontMapping(null, lastResortFont, true);}
private PriorityQueue<FontMatch> pdfbox_f4544_0(PDFontDescriptor fontDescriptor, PDCIDSystemInfo cidSystemInfo)
{    PriorityQueue<FontMatch> queue = new PriorityQueue<>(20);    for (FontInfo info : fontInfoByName.values()) {                if (cidSystemInfo != null && !isCharSetMatch(cidSystemInfo, info)) {            continue;        }        FontMatch match = new FontMatch(info);                if (fontDescriptor.getPanose() != null && info.getPanose() != null) {            PDPanoseClassification panose = fontDescriptor.getPanose().getPanose();            if (panose.getFamilyKind() == info.getPanose().getFamilyKind()) {                if (panose.getFamilyKind() == 0 && (info.getPostScriptName().toLowerCase().contains("barcode") || info.getPostScriptName().startsWith("Code")) && !probablyBarcodeFont(fontDescriptor)) {                                        continue;                }                                if (panose.getSerifStyle() == info.getPanose().getSerifStyle()) {                                        match.score += 2;                } else if (panose.getSerifStyle() >= 2 && panose.getSerifStyle() <= 5 && info.getPanose().getSerifStyle() >= 2 && info.getPanose().getSerifStyle() <= 5) {                                        match.score += 1;                } else if (panose.getSerifStyle() >= 11 && panose.getSerifStyle() <= 13 && info.getPanose().getSerifStyle() >= 11 && info.getPanose().getSerifStyle() <= 13) {                                        match.score += 1;                } else if (panose.getSerifStyle() != 0 && info.getPanose().getSerifStyle() != 0) {                                        match.score -= 1;                }                                int weight = info.getPanose().getWeight();                int weightClass = info.getWeightClassAsPanose();                if (Math.abs(weight - weightClass) > 2) {                                        weight = weightClass;                }                if (panose.getWeight() == weight) {                                        match.score += 2;                } else if (panose.getWeight() > 1 && weight > 1) {                    float dist = Math.abs(panose.getWeight() - weight);                    match.score += 1 - dist * 0.5;                }                                    }        } else if (fontDescriptor.getFontWeight() > 0 && info.getWeightClass() > 0) {                        float dist = Math.abs(fontDescriptor.getFontWeight() - info.getWeightClass());            match.score += 1 - (dist / 100) * 0.5;        }                        queue.add(match);    }    return queue;}
private boolean pdfbox_f4545_0(PDFontDescriptor fontDescriptor)
{    String ff = fontDescriptor.getFontFamily();    if (ff == null) {        ff = "";    }    String fn = fontDescriptor.getFontName();    if (fn == null) {        fn = "";    }    return ff.startsWith("Code") || ff.toLowerCase().contains("barcode") || fn.startsWith("Code") || fn.toLowerCase().contains("barcode");}
private boolean pdfbox_f4546_0(PDCIDSystemInfo cidSystemInfo, FontInfo info)
{    if (info.getCIDSystemInfo() != null) {        return info.getCIDSystemInfo().getRegistry().equals(cidSystemInfo.getRegistry()) && info.getCIDSystemInfo().getOrdering().equals(cidSystemInfo.getOrdering());    } else {        long codePageRange = info.getCodePageRange();        long JIS_JAPAN = 1 << 17;        long CHINESE_SIMPLIFIED = 1 << 18;        long KOREAN_WANSUNG = 1 << 19;        long CHINESE_TRADITIONAL = 1 << 20;        long KOREAN_JOHAB = 1 << 21;        if (cidSystemInfo.getOrdering().equals("GB1") && (codePageRange & CHINESE_SIMPLIFIED) == CHINESE_SIMPLIFIED) {            return true;        } else if (cidSystemInfo.getOrdering().equals("CNS1") && (codePageRange & CHINESE_TRADITIONAL) == CHINESE_TRADITIONAL) {            return true;        } else if (cidSystemInfo.getOrdering().equals("Japan1") && (codePageRange & JIS_JAPAN) == JIS_JAPAN) {            return true;        } else {            return cidSystemInfo.getOrdering().equals("Korea1") && (codePageRange & KOREAN_WANSUNG) == KOREAN_WANSUNG || (codePageRange & KOREAN_JOHAB) == KOREAN_JOHAB;        }    }}
public int pdfbox_f4547_0(FontMatch match)
{    return Double.compare(match.score, this.score);}
private FontMatch pdfbox_f4548_0(PriorityQueue<FontMatch> queue)
{    FontMatch bestMatch = queue.peek();    System.out.println("-------");    while (!queue.isEmpty()) {        FontMatch match = queue.poll();        FontInfo info = match.info;        System.out.println(match.score + " | " + info.getMacStyle() + " " + info.getFamilyClass() + " " + info.getPanose() + " " + info.getCIDSystemInfo() + " " + info.getPostScriptName() + " " + info.getFormat());    }    System.out.println("-------");    return bestMatch;}
public static FontMapper pdfbox_f4549_0()
{    if (instance == null) {        instance = DefaultFontMapper.INSTANCE;    }    return instance;}
public static synchronized void pdfbox_f4550_0(FontMapper fontMapper)
{    instance = fontMapper;}
public T pdfbox_f4551_0()
{    return font;}
public boolean pdfbox_f4552_0()
{    return isFallback;}
private void pdfbox_f4553_0()
{    widths = new HashMap<>();    COSBase wBase = dict.getDictionaryObject(COSName.W);    if (wBase instanceof COSArray) {        COSArray wArray = (COSArray) wBase;        int size = wArray.size();        int counter = 0;        while (counter < size) {            COSNumber firstCode = (COSNumber) wArray.getObject(counter++);            COSBase next = wArray.getObject(counter++);            if (next instanceof COSArray) {                COSArray array = (COSArray) next;                int startRange = firstCode.intValue();                int arraySize = array.size();                for (int i = 0; i < arraySize; i++) {                    COSNumber width = (COSNumber) array.getObject(i);                    widths.put(startRange + i, width.floatValue());                }            } else {                COSNumber secondCode = (COSNumber) next;                COSNumber rangeWidth = (COSNumber) wArray.getObject(counter++);                int startRange = firstCode.intValue();                int endRange = secondCode.intValue();                float width = rangeWidth.floatValue();                for (int i = startRange; i <= endRange; i++) {                    widths.put(i, width);                }            }        }    }}
private void pdfbox_f4554_0()
{        COSBase dw2Base = dict.getDictionaryObject(COSName.DW2);    if (dw2Base instanceof COSArray) {        COSArray dw2Array = (COSArray) dw2Base;        COSBase base0 = dw2Array.getObject(0);        COSBase base1 = dw2Array.getObject(1);        if (base0 instanceof COSNumber && base1 instanceof COSNumber) {            dw2[0] = ((COSNumber) base0).floatValue();            dw2[1] = ((COSNumber) base1).floatValue();        }    }        COSBase w2Base = dict.getDictionaryObject(COSName.W2);    if (w2Base instanceof COSArray) {        COSArray w2Array = (COSArray) w2Base;        for (int i = 0; i < w2Array.size(); i++) {            COSNumber c = (COSNumber) w2Array.getObject(i);            COSBase next = w2Array.getObject(++i);            if (next instanceof COSArray) {                COSArray array = (COSArray) next;                for (int j = 0; j < array.size(); j++) {                    int cid = c.intValue() + j / 3;                    COSNumber w1y = (COSNumber) array.getObject(j);                    COSNumber v1x = (COSNumber) array.getObject(++j);                    COSNumber v1y = (COSNumber) array.getObject(++j);                    verticalDisplacementY.put(cid, w1y.floatValue());                    positionVectors.put(cid, new Vector(v1x.floatValue(), v1y.floatValue()));                }            } else {                int first = c.intValue();                int last = ((COSNumber) next).intValue();                COSNumber w1y = (COSNumber) w2Array.getObject(++i);                COSNumber v1x = (COSNumber) w2Array.getObject(++i);                COSNumber v1y = (COSNumber) w2Array.getObject(++i);                for (int cid = first; cid <= last; cid++) {                    verticalDisplacementY.put(cid, w1y.floatValue());                    positionVectors.put(cid, new Vector(v1x.floatValue(), v1y.floatValue()));                }            }        }    }}
public COSDictionary pdfbox_f4555_0()
{    return dict;}
public String pdfbox_f4556_0()
{    return dict.getNameAsString(COSName.BASE_FONT);}
public String pdfbox_f4557_0()
{    return getBaseFont();}
public PDFontDescriptor pdfbox_f4558_0()
{    if (fontDescriptor == null) {        COSDictionary fd = (COSDictionary) dict.getDictionaryObject(COSName.FONT_DESC);        if (fd != null) {            fontDescriptor = new PDFontDescriptor(fd);        }    }    return fontDescriptor;}
public final PDType0Font pdfbox_f4559_0()
{    return parent;}
private float pdfbox_f4560_0()
{    if (Float.compare(defaultWidth, 0) == 0) {        COSBase base = dict.getDictionaryObject(COSName.DW);        if (base instanceof COSNumber) {            defaultWidth = ((COSNumber) base).floatValue();        } else {            defaultWidth = 1000;        }    }    return defaultWidth;}
private Vector pdfbox_f4561_0(int cid)
{    return new Vector(getWidthForCID(cid) / 2, dw2[0]);}
private float pdfbox_f4562_0(int cid)
{    Float width = widths.get(cid);    if (width == null) {        width = getDefaultWidth();    }    return width;}
public boolean pdfbox_f4563_0(int code) throws IOException
{    return widths.get(codeToCID(code)) != null;}
public Vector pdfbox_f4564_0(int code)
{    int cid = codeToCID(code);    Vector v = positionVectors.get(cid);    if (v == null) {        v = getDefaultPositionVector(cid);    }    return v;}
public float pdfbox_f4565_0(int code)
{    int cid = codeToCID(code);    Float w1y = verticalDisplacementY.get(cid);    if (w1y == null) {        w1y = dw2[1];    }    return w1y;}
public float pdfbox_f4566_0(int code) throws IOException
{        return getWidthForCID(codeToCID(code));}
public float pdfbox_f4567_0()
{    if (Float.compare(averageWidth, 0) == 0) {        float totalWidths = 0.0f;        int characterCount = 0;        if (widths != null) {            for (Float width : widths.values()) {                if (width > 0) {                    totalWidths += width;                    ++characterCount;                }            }        }        averageWidth = totalWidths / characterCount;        if (averageWidth <= 0 || Float.isNaN(averageWidth)) {            averageWidth = getDefaultWidth();        }    }    return averageWidth;}
public PDCIDSystemInfo pdfbox_f4568_0()
{    COSBase base = dict.getDictionaryObject(COSName.CIDSYSTEMINFO);    if (base instanceof COSDictionary) {        return new PDCIDSystemInfo((COSDictionary) base);    }    return null;}
 final int[] pdfbox_f4569_0() throws IOException
{    int[] cid2gid = null;    COSBase map = dict.getDictionaryObject(COSName.CID_TO_GID_MAP);    if (map instanceof COSStream) {        COSStream stream = (COSStream) map;        InputStream is = stream.createInputStream();        byte[] mapAsBytes = IOUtils.toByteArray(is);        IOUtils.closeQuietly(is);        int numberOfInts = mapAsBytes.length / 2;        cid2gid = new int[numberOfInts];        int offset = 0;        for (int index = 0; index < numberOfInts; index++) {            int gid = (mapAsBytes[offset] & 0xff) << 8 | mapAsBytes[offset + 1] & 0xff;            cid2gid[index] = gid;            offset += 2;        }    }    return cid2gid;}
public final Matrix pdfbox_f4570_1()
{    if (fontMatrix == null) {        List<Number> numbers;        if (cidFont != null) {            numbers = cidFont.getFontMatrix();        } else {            try {                numbers = t1Font.getFontMatrix();            } catch (IOException e) {                                return new Matrix(0.001f, 0, 0, 0.001f, 0, 0);            }        }        if (numbers != null && numbers.size() == 6) {            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());        } else {            fontMatrix = new Matrix(0.001f, 0, 0, 0.001f, 0, 0);        }    }    return fontMatrix;}
public BoundingBox pdfbox_f4571_0()
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
private BoundingBox pdfbox_f4572_1()
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (bbox != null && (Float.compare(bbox.getLowerLeftX(), 0) != 0 || Float.compare(bbox.getLowerLeftY(), 0) != 0 || Float.compare(bbox.getUpperRightX(), 0) != 0 || Float.compare(bbox.getUpperRightY(), 0) != 0)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    if (cidFont != null) {        return cidFont.getFontBBox();    } else {        try {            return t1Font.getFontBBox();        } catch (IOException e) {                        return new BoundingBox();        }    }}
public CFFFont pdfbox_f4573_0()
{    if (cidFont != null) {        return cidFont;    } else if (t1Font instanceof CFFType1Font) {        return (CFFType1Font) t1Font;    } else {        return null;    }}
public FontBoxFont pdfbox_f4574_0()
{    if (cidFont != null) {        return cidFont;    } else {        return t1Font;    }}
public Type2CharString pdfbox_f4575_0(int cid) throws IOException
{    if (cidFont != null) {        return cidFont.getType2CharString(cid);    } else if (t1Font instanceof CFFType1Font) {        return ((CFFType1Font) t1Font).getType2CharString(cid);    } else {        return null;    }}
private String pdfbox_f4576_0(int code) throws IOException
{    String unicodes = parent.toUnicode(code);    if (unicodes == null) {        return ".notdef";    }    return getUniNameOfCodePoint(unicodes.codePointAt(0));}
public GeneralPath pdfbox_f4577_0(int code) throws IOException
{    int cid = codeToCID(code);    if (cid2gid != null && isEmbedded) {                cid = cid2gid[cid];    }    Type2CharString charstring = getType2CharString(cid);    if (charstring != null) {        return charstring.getPath();    } else if (isEmbedded && t1Font instanceof CFFType1Font) {        return ((CFFType1Font) t1Font).getType2CharString(cid).getPath();    } else {        return t1Font.getPath(getGlyphName(code));    }}
public GeneralPath pdfbox_f4578_0(int code) throws IOException
{    return getPath(code);}
public boolean pdfbox_f4579_0(int code) throws IOException
{    int cid = codeToCID(code);    Type2CharString charstring = getType2CharString(cid);    if (charstring != null) {        return charstring.getGID() != 0;    } else if (isEmbedded && t1Font instanceof CFFType1Font) {        return ((CFFType1Font) t1Font).getType2CharString(cid).getGID() != 0;    } else {        return t1Font.hasGlyph(getGlyphName(code));    }}
public int pdfbox_f4580_0(int code)
{    return parent.getCMap().toCID(code);}
public int pdfbox_f4581_0(int code)
{    int cid = codeToCID(code);    if (cidFont != null) {                return cidFont.getCharset().getGIDForCID(cid);    } else {                return cid;    }}
public byte[] pdfbox_f4582_0(int unicode)
{        throw new UnsupportedOperationException();}
public byte[] pdfbox_f4583_0(int glyphId)
{    throw new UnsupportedOperationException();}
public float pdfbox_f4584_0(int code) throws IOException
{    int cid = codeToCID(code);    float width;    if (cidFont != null) {        width = getType2CharString(cid).getWidth();    } else if (isEmbedded && t1Font instanceof CFFType1Font) {        width = ((CFFType1Font) t1Font).getType2CharString(cid).getWidth();    } else {        width = t1Font.getWidth(getGlyphName(code));    }    Point2D p = new Point2D.Float(width, 0);    fontMatrixTransform.transform(p, p);    return (float) p.getX();}
public boolean pdfbox_f4585_0()
{    return isEmbedded;}
public boolean pdfbox_f4586_0()
{    return isDamaged;}
public float pdfbox_f4587_0(int code) throws IOException
{    int cid = codeToCID(code);    float height;    if (!glyphHeights.containsKey(cid)) {        height = (float) getType2CharString(cid).getBounds().getHeight();        glyphHeights.put(cid, height);    } else {        height = glyphHeights.get(cid);    }    return height;}
public float pdfbox_f4588_0()
{    if (avgWidth == null) {        avgWidth = getAverageCharacterWidth();    }    return avgWidth;}
private float pdfbox_f4589_0()
{        return 500;}
public byte[] pdfbox_f4590_0() throws IOException
{    return getFontDescriptor().getFontFile3().toByteArray();}
private TrueTypeFont pdfbox_f4591_1() throws IOException
{    TrueTypeFont ttfFont;    CIDFontMapping mapping = FontMappers.instance().getCIDFont(getBaseFont(), getFontDescriptor(), getCIDSystemInfo());    if (mapping.isCIDFont()) {        ttfFont = mapping.getFont();    } else {        ttfFont = (TrueTypeFont) mapping.getTrueTypeFont();    }    if (mapping.isFallback()) {            }    return ttfFont;}
public Matrix pdfbox_f4592_0()
{    if (fontMatrix == null) {                fontMatrix = new Matrix(0.001f, 0, 0, 0.001f, 0, 0);    }    return fontMatrix;}
public BoundingBox pdfbox_f4593_0() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
private BoundingBox pdfbox_f4594_0() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (bbox != null && (Float.compare(bbox.getLowerLeftX(), 0) != 0 || Float.compare(bbox.getLowerLeftY(), 0) != 0 || Float.compare(bbox.getUpperRightX(), 0) != 0 || Float.compare(bbox.getUpperRightY(), 0) != 0)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return ttf.getFontBBox();}
public int pdfbox_f4595_0(int code)
{    CMap cMap = parent.getCMap();        if (!cMap.hasCIDMappings() && cMap.hasUnicodeMappings()) {                return cMap.toUnicode(code).codePointAt(0);    }    return cMap.toCID(code);}
public int pdfbox_f4596_1(int code) throws IOException
{    if (!isEmbedded) {                if (cid2gid != null && !isDamaged) {                                    int cid = codeToCID(code);            return cid2gid[cid];        } else {                        String unicode = parent.toUnicode(code);            if (unicode == null) {                if (!noMapping.contains(code)) {                                        noMapping.add(code);                                    }                                return codeToCID(code);            } else if (unicode.length() > 1) {                            }                        return cmap.getGlyphId(unicode.codePointAt(0));        }    } else {                                int cid = codeToCID(code);        if (cid2gid != null) {                        if (cid < cid2gid.length) {                return cid2gid[cid];            } else {                return 0;            }        } else {                        if (cid < ttf.getNumberOfGlyphs()) {                return cid;            } else {                                return 0;            }        }    }}
public float pdfbox_f4597_0(int code) throws IOException
{        return (ttf.getHorizontalHeader().getAscender() + -ttf.getHorizontalHeader().getDescender()) /     ttf.getUnitsPerEm();}
public float pdfbox_f4598_0(int code) throws IOException
{    int gid = codeToGID(code);    int width = ttf.getAdvanceWidth(gid);    int unitsPerEM = ttf.getUnitsPerEm();    if (unitsPerEM != 1000) {        width *= 1000f / unitsPerEM;    }    return width;}
public byte[] pdfbox_f4599_0(int unicode)
{    int cid = -1;    if (isEmbedded) {                if (parent.getCMap().getName().startsWith("Identity-")) {            if (cmap != null) {                cid = cmap.getGlyphId(unicode);            }        } else {                        if (parent.getCMapUCS2() != null) {                cid = parent.getCMapUCS2().toCID(unicode);            }        }                if (cid == -1) {                                    cid = 0;        }    } else {                cid = cmap.getGlyphId(unicode);    }    if (cid == 0) {        throw new IllegalArgumentException(String.format("No glyph for U+%04X (%c) in font %s", unicode, (char) unicode, getName()));    }    return encodeGlyphId(cid);}
public byte[] pdfbox_f4600_0(int glyphId)
{        return new byte[] { (byte) (glyphId >> 8 & 0xff), (byte) (glyphId & 0xff) };}
public boolean pdfbox_f4601_0()
{    return isEmbedded;}
public boolean pdfbox_f4602_0()
{    return isDamaged;}
public TrueTypeFont pdfbox_f4603_0()
{    return ttf;}
public GeneralPath pdfbox_f4604_0(int code) throws IOException
{    if (ttf instanceof OpenTypeFont && ((OpenTypeFont) ttf).isPostScript()) {                        int cid = codeToGID(code);        Type2CharString charstring = ((OpenTypeFont) ttf).getCFF().getFont().getType2CharString(cid);        return charstring.getPath();    } else {        int gid = codeToGID(code);        GlyphData glyph = ttf.getGlyph().getGlyph(gid);        if (glyph != null) {            return glyph.getPath();        }        return new GeneralPath();    }}
public GeneralPath pdfbox_f4605_0(int code) throws IOException
{    boolean hasScaling = ttf.getUnitsPerEm() != 1000;    float scale = 1000f / ttf.getUnitsPerEm();    int gid = codeToGID(code);    GeneralPath path = getPath(code);        if (gid == 0 && !isEmbedded()) {        path = null;    }    if (path == null) {                return new GeneralPath();    } else {        if (hasScaling) {            path.transform(AffineTransform.getScaleInstance(scale, scale));        }        return path;    }}
public boolean pdfbox_f4606_0(int code) throws IOException
{    return codeToGID(code) != 0;}
protected void pdfbox_f4607_0(InputStream ttfSubset, String tag, Map<Integer, Integer> gidToCid) throws IOException
{        Map<Integer, Integer> cidToGid = new HashMap<>(gidToCid.size());    for (Map.Entry<Integer, Integer> entry : gidToCid.entrySet()) {        int newGID = entry.getKey();        int oldGID = entry.getValue();        cidToGid.put(oldGID, newGID);    }        buildToUnicodeCMap(gidToCid);        if (vertical) {        buildVerticalMetrics(cidToGid);    }        buildFontFile2(ttfSubset);    addNameTag(tag);    buildWidths(cidToGid);    buildCIDToGIDMap(cidToGid);    buildCIDSet(cidToGid);}
private void pdfbox_f4608_0(Map<Integer, Integer> newGIDToOldCID) throws IOException
{    ToUnicodeWriter toUniWriter = new ToUnicodeWriter();    boolean hasSurrogates = false;    for (int gid = 1, max = ttf.getMaximumProfile().getNumGlyphs(); gid <= max; gid++) {                int cid;        if (newGIDToOldCID != null) {            if (!newGIDToOldCID.containsKey(gid)) {                continue;            } else {                cid = newGIDToOldCID.get(gid);            }        } else {            cid = gid;        }                        List<Integer> codes = cmapLookup.getCharCodes(cid);        if (codes != null) {                        int codePoint = codes.get(0);            if (codePoint > 0xFFFF) {                hasSurrogates = true;            }            toUniWriter.add(cid, new String(new int[] { codePoint }, 0, 1));        }    }    ByteArrayOutputStream out = new ByteArrayOutputStream();    toUniWriter.writeTo(out);    InputStream cMapStream = new ByteArrayInputStream(out.toByteArray());    PDStream stream = new PDStream(document, cMapStream, COSName.FLATE_DECODE);        if (hasSurrogates) {        float version = document.getVersion();        if (version < 1.5) {            document.setVersion(1.5f);        }    }    dict.setItem(COSName.TO_UNICODE, stream);}
private COSDictionary pdfbox_f4609_0(String registry, String ordering, int supplement)
{    COSDictionary info = new COSDictionary();    info.setString(COSName.REGISTRY, registry);    info.setString(COSName.ORDERING, ordering);    info.setInt(COSName.SUPPLEMENT, supplement);    return info;}
private COSDictionary pdfbox_f4610_0() throws IOException
{    COSDictionary cidFont = new COSDictionary();        cidFont.setItem(COSName.TYPE, COSName.FONT);    cidFont.setItem(COSName.SUBTYPE, COSName.CID_FONT_TYPE2);        cidFont.setName(COSName.BASE_FONT, fontDescriptor.getFontName());        COSDictionary info = toCIDSystemInfo("Adobe", "Identity", 0);    cidFont.setItem(COSName.CIDSYSTEMINFO, info);        cidFont.setItem(COSName.FONT_DESC, fontDescriptor.getCOSObject());        buildWidths(cidFont);        if (vertical) {        buildVerticalMetrics(cidFont);    }        cidFont.setItem(COSName.CID_TO_GID_MAP, COSName.IDENTITY);    return cidFont;}
private void pdfbox_f4611_0(String tag) throws IOException
{    String name = fontDescriptor.getFontName();    String newName = tag + name;    dict.setName(COSName.BASE_FONT, newName);    fontDescriptor.setFontName(newName);    cidFont.setName(COSName.BASE_FONT, newName);}
private void pdfbox_f4612_0(Map<Integer, Integer> cidToGid) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    int cidMax = Collections.max(cidToGid.keySet());    for (int i = 0; i <= cidMax; i++) {        int gid;        if (cidToGid.containsKey(i)) {            gid = cidToGid.get(i);        } else {            gid = 0;        }        out.write(new byte[] { (byte) (gid >> 8 & 0xff), (byte) (gid & 0xff) });    }    InputStream input = new ByteArrayInputStream(out.toByteArray());    PDStream stream = new PDStream(document, input, COSName.FLATE_DECODE);    cidFont.setItem(COSName.CID_TO_GID_MAP, stream);}
private void pdfbox_f4613_0(Map<Integer, Integer> cidToGid) throws IOException
{    int cidMax = Collections.max(cidToGid.keySet());    byte[] bytes = new byte[cidMax / 8 + 1];    for (int cid = 0; cid <= cidMax; cid++) {        int mask = 1 << 7 - cid % 8;        bytes[cid / 8] |= mask;    }    InputStream input = new ByteArrayInputStream(bytes);    PDStream stream = new PDStream(document, input, COSName.FLATE_DECODE);    fontDescriptor.setCIDSet(stream);}
private void pdfbox_f4614_0(Map<Integer, Integer> cidToGid) throws IOException
{    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    COSArray widths = new COSArray();    COSArray ws = new COSArray();    int prev = Integer.MIN_VALUE;        Set<Integer> keys = new TreeSet<>(cidToGid.keySet());    for (int cid : keys) {        int gid = cidToGid.get(cid);        long width = Math.round(ttf.getHorizontalMetrics().getAdvanceWidth(gid) * scaling);        if (width == 1000) {                        continue;        }                if (prev != cid - 1) {            ws = new COSArray();                        widths.add(COSInteger.get(cid));            widths.add(ws);        }                ws.add(COSInteger.get(width));        prev = cid;    }    cidFont.setItem(COSName.W, widths);}
private boolean pdfbox_f4615_1(COSDictionary cidFont) throws IOException
{    VerticalHeaderTable vhea = ttf.getVerticalHeader();    if (vhea == null) {                return false;    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    long v = Math.round(vhea.getAscender() * scaling);    long w1 = Math.round(-vhea.getAdvanceHeightMax() * scaling);    if (v != 880 || w1 != -1000) {        COSArray cosDw2 = new COSArray();        cosDw2.add(COSInteger.get(v));        cosDw2.add(COSInteger.get(w1));        cidFont.setItem(COSName.DW2, cosDw2);    }    return true;}
private void pdfbox_f4616_0(Map<Integer, Integer> cidToGid) throws IOException
{    if (!buildVerticalHeader(cidFont)) {        return;    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    VerticalHeaderTable vhea = ttf.getVerticalHeader();    VerticalMetricsTable vmtx = ttf.getVerticalMetrics();    GlyphTable glyf = ttf.getGlyph();    HorizontalMetricsTable hmtx = ttf.getHorizontalMetrics();    long v_y = Math.round(vhea.getAscender() * scaling);    long w1 = Math.round(-vhea.getAdvanceHeightMax() * scaling);    COSArray heights = new COSArray();    COSArray w2 = new COSArray();    int prev = Integer.MIN_VALUE;        Set<Integer> keys = new TreeSet<>(cidToGid.keySet());    for (int cid : keys) {                        GlyphData glyph = glyf.getGlyph(cid);        if (glyph == null) {            continue;        }        long height = Math.round((glyph.getYMaximum() + vmtx.getTopSideBearing(cid)) * scaling);        long advance = Math.round(-vmtx.getAdvanceHeight(cid) * scaling);        if (height == v_y && advance == w1) {                        continue;        }                if (prev != cid - 1) {            w2 = new COSArray();                        heights.add(COSInteger.get(cid));            heights.add(w2);        }                w2.add(COSInteger.get(advance));        long width = Math.round(hmtx.getAdvanceWidth(cid) * scaling);                w2.add(COSInteger.get(width / 2));                w2.add(COSInteger.get(height));        prev = cid;    }    cidFont.setItem(COSName.W2, heights);}
private void pdfbox_f4617_0(COSDictionary cidFont) throws IOException
{    int cidMax = ttf.getNumberOfGlyphs();    int[] gidwidths = new int[cidMax * 2];    for (int cid = 0; cid < cidMax; cid++) {        gidwidths[cid * 2] = cid;        gidwidths[cid * 2 + 1] = ttf.getHorizontalMetrics().getAdvanceWidth(cid);    }    cidFont.setItem(COSName.W, getWidths(gidwidths));}
private COSArray pdfbox_f4618_0(int[] widths) throws IOException
{    if (widths.length == 0) {        throw new IllegalArgumentException("length of widths must be > 0");    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    long lastCid = widths[0];    long lastValue = Math.round(widths[1] * scaling);    COSArray inner = new COSArray();    COSArray outer = new COSArray();    outer.add(COSInteger.get(lastCid));    State state = State.FIRST;    for (int i = 2; i < widths.length; i += 2) {        long cid = widths[i];        long value = Math.round(widths[i + 1] * scaling);        switch(state) {            case FIRST:                if (cid == lastCid + 1 && value == lastValue) {                    state = State.SERIAL;                } else if (cid == lastCid + 1) {                    state = State.BRACKET;                    inner = new COSArray();                    inner.add(COSInteger.get(lastValue));                } else {                    inner = new COSArray();                    inner.add(COSInteger.get(lastValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case BRACKET:                if (cid == lastCid + 1 && value == lastValue) {                    state = State.SERIAL;                    outer.add(inner);                    outer.add(COSInteger.get(lastCid));                } else if (cid == lastCid + 1) {                    inner.add(COSInteger.get(lastValue));                } else {                    state = State.FIRST;                    inner.add(COSInteger.get(lastValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case SERIAL:                if (cid != lastCid + 1 || value != lastValue) {                    outer.add(COSInteger.get(lastCid));                    outer.add(COSInteger.get(lastValue));                    outer.add(COSInteger.get(cid));                    state = State.FIRST;                }                break;        }        lastValue = value;        lastCid = cid;    }    switch(state) {        case FIRST:            inner = new COSArray();            inner.add(COSInteger.get(lastValue));            outer.add(inner);            break;        case BRACKET:            inner.add(COSInteger.get(lastValue));            outer.add(inner);            break;        case SERIAL:            outer.add(COSInteger.get(lastCid));            outer.add(COSInteger.get(lastValue));            break;    }    return outer;}
private void pdfbox_f4619_0(COSDictionary cidFont) throws IOException
{    if (!buildVerticalHeader(cidFont)) {        return;    }    int cidMax = ttf.getNumberOfGlyphs();    int[] gidMetrics = new int[cidMax * 4];    for (int cid = 0; cid < cidMax; cid++) {        GlyphData glyph = ttf.getGlyph().getGlyph(cid);        if (glyph == null) {            gidMetrics[cid * 4] = Integer.MIN_VALUE;        } else {            gidMetrics[cid * 4] = cid;            gidMetrics[cid * 4 + 1] = ttf.getVerticalMetrics().getAdvanceHeight(cid);            gidMetrics[cid * 4 + 2] = ttf.getHorizontalMetrics().getAdvanceWidth(cid);            gidMetrics[cid * 4 + 3] = glyph.getYMaximum() + ttf.getVerticalMetrics().getTopSideBearing(cid);        }    }    cidFont.setItem(COSName.W2, getVerticalMetrics(gidMetrics));}
private COSArray pdfbox_f4620_0(int[] values) throws IOException
{    if (values.length == 0) {        throw new IllegalArgumentException("length of values must be > 0");    }    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    long lastCid = values[0];    long lastW1Value = Math.round(-values[1] * scaling);    long lastVxValue = Math.round(values[2] * scaling / 2f);    long lastVyValue = Math.round(values[3] * scaling);    COSArray inner = new COSArray();    COSArray outer = new COSArray();    outer.add(COSInteger.get(lastCid));    State state = State.FIRST;    for (int i = 4; i < values.length; i += 4) {        long cid = values[i];        if (cid == Integer.MIN_VALUE) {                        continue;        }        long w1Value = Math.round(-values[i + 1] * scaling);        long vxValue = Math.round(values[i + 2] * scaling / 2);        long vyValue = Math.round(values[i + 3] * scaling);        switch(state) {            case FIRST:                if (cid == lastCid + 1 && w1Value == lastW1Value && vxValue == lastVxValue && vyValue == lastVyValue) {                    state = State.SERIAL;                } else if (cid == lastCid + 1) {                    state = State.BRACKET;                    inner = new COSArray();                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                } else {                    inner = new COSArray();                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case BRACKET:                if (cid == lastCid + 1 && w1Value == lastW1Value && vxValue == lastVxValue && vyValue == lastVyValue) {                    state = State.SERIAL;                    outer.add(inner);                    outer.add(COSInteger.get(lastCid));                } else if (cid == lastCid + 1) {                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                } else {                    state = State.FIRST;                    inner.add(COSInteger.get(lastW1Value));                    inner.add(COSInteger.get(lastVxValue));                    inner.add(COSInteger.get(lastVyValue));                    outer.add(inner);                    outer.add(COSInteger.get(cid));                }                break;            case SERIAL:                if (cid != lastCid + 1 || w1Value != lastW1Value || vxValue != lastVxValue || vyValue != lastVyValue) {                    outer.add(COSInteger.get(lastCid));                    outer.add(COSInteger.get(lastW1Value));                    outer.add(COSInteger.get(lastVxValue));                    outer.add(COSInteger.get(lastVyValue));                    outer.add(COSInteger.get(cid));                    state = State.FIRST;                }                break;        }        lastW1Value = w1Value;        lastVxValue = vxValue;        lastVyValue = vyValue;        lastCid = cid;    }    switch(state) {        case FIRST:            inner = new COSArray();            inner.add(COSInteger.get(lastW1Value));            inner.add(COSInteger.get(lastVxValue));            inner.add(COSInteger.get(lastVyValue));            outer.add(inner);            break;        case BRACKET:            inner.add(COSInteger.get(lastW1Value));            inner.add(COSInteger.get(lastVxValue));            inner.add(COSInteger.get(lastVyValue));            outer.add(inner);            break;        case SERIAL:            outer.add(COSInteger.get(lastCid));            outer.add(COSInteger.get(lastW1Value));            outer.add(COSInteger.get(lastVxValue));            outer.add(COSInteger.get(lastVyValue));            break;    }    return outer;}
public PDCIDFont pdfbox_f4621_0() throws IOException
{    return new PDCIDFontType2(cidFont, parent, ttf);}
public String pdfbox_f4622_0()
{    return dictionary.getNameAsString(COSName.REGISTRY);}
public String pdfbox_f4623_0()
{    return dictionary.getNameAsString(COSName.ORDERING);}
public int pdfbox_f4624_0()
{    return dictionary.getInt(COSName.SUPPLEMENT);}
public COSBase pdfbox_f4625_0()
{    return dictionary;}
public String pdfbox_f4626_0()
{    return getRegistry() + "-" + getOrdering() + "-" + getSupplement();}
private PDFontDescriptor pdfbox_f4627_0()
{    COSDictionary fd = (COSDictionary) dict.getDictionaryObject(COSName.FONT_DESC);    if (fd != null) {        return new PDFontDescriptor(fd);    } else if (afmStandard14 != null) {                return PDType1FontEmbedder.buildFontDescriptor(afmStandard14);    } else {        return null;    }}
private CMap pdfbox_f4628_1()
{    COSBase toUnicode = dict.getDictionaryObject(COSName.TO_UNICODE);    if (toUnicode == null) {        return null;    }    CMap cmap = null;    try {        cmap = readCMap(toUnicode);        if (cmap != null && !cmap.hasUnicodeMappings()) {                        String cmapName = cmap.getName() != null ? cmap.getName() : "";            String ordering = cmap.getOrdering() != null ? cmap.getOrdering() : "";            COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);            if (            cmapName.contains("Identity") ||             ordering.contains("Identity") ||             COSName.IDENTITY_H.equals(encoding) || COSName.IDENTITY_V.equals(encoding)) {                                cmap = CMapManager.getPredefinedCMap(COSName.IDENTITY_H.getName());            }        }    } catch (IOException ex) {            }    return cmap;}
protected final FontMetrics pdfbox_f4629_0()
{    return afmStandard14;}
public PDFontDescriptor pdfbox_f4630_0()
{    return fontDescriptor;}
protected final void pdfbox_f4631_0(PDFontDescriptor fontDescriptor)
{    this.fontDescriptor = fontDescriptor;}
protected final CMap pdfbox_f4632_0(COSBase base) throws IOException
{    if (base instanceof COSName) {                String name = ((COSName) base).getName();        return CMapManager.getPredefinedCMap(name);    } else if (base instanceof COSStream) {                InputStream input = null;        try {            input = ((COSStream) base).createInputStream();            return CMapManager.parseCMap(input);        } finally {            IOUtils.closeQuietly(input);        }    } else {        throw new IOException("Expected Name or Stream");    }}
public COSDictionary pdfbox_f4633_0()
{    return dict;}
public Vector pdfbox_f4634_0(int code)
{    throw new UnsupportedOperationException("Horizontal fonts have no position vector");}
public Vector pdfbox_f4635_0(int code) throws IOException
{    return new Vector(getWidth(code) / 1000, 0);}
public float pdfbox_f4636_0(int code) throws IOException
{    Float width = codeToWidthMap.get(code);    if (width != null) {        return width;    }        if (dict.getDictionaryObject(COSName.WIDTHS) != null || dict.containsKey(COSName.MISSING_WIDTH)) {        int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);        int lastChar = dict.getInt(COSName.LAST_CHAR, -1);        int siz = getWidths().size();        int idx = code - firstChar;        if (siz > 0 && code >= firstChar && code <= lastChar && idx < siz) {            width = getWidths().get(idx);            if (width == null) {                width = 0f;            }            codeToWidthMap.put(code, width);            return width;        }        PDFontDescriptor fd = getFontDescriptor();        if (fd != null) {                        width = fd.getMissingWidth();            codeToWidthMap.put(code, width);            return width;        }    }        if (isStandard14()) {        width = getStandard14Width(code);        codeToWidthMap.put(code, width);        return width;    }        width = getWidthFromFont(code);    codeToWidthMap.put(code, width);    return width;}
public final byte[] pdfbox_f4637_0(String text) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    int offset = 0;    while (offset < text.length()) {        int codePoint = text.codePointAt(offset);                byte[] bytes = encode(codePoint);        out.write(bytes);        offset += Character.charCount(codePoint);    }    return out.toByteArray();}
public float pdfbox_f4638_0(String text) throws IOException
{    byte[] bytes = encode(text);    ByteArrayInputStream in = new ByteArrayInputStream(bytes);    float width = 0;    while (in.available() > 0) {        int code = readCode(in);        width += getWidth(code);    }    return width;}
public float pdfbox_f4639_0()
{    float average;    if (Float.compare(avgFontWidth, 0.0f) != 0) {        average = avgFontWidth;    } else {        float totalWidth = 0.0f;        float characterCount = 0.0f;        COSArray widths = (COSArray) dict.getDictionaryObject(COSName.WIDTHS);        if (widths != null) {            for (int i = 0; i < widths.size(); i++) {                COSNumber fontWidth = (COSNumber) widths.getObject(i);                if (fontWidth.floatValue() > 0) {                    totalWidth += fontWidth.floatValue();                    characterCount += 1;                }            }        }        if (totalWidth > 0) {            average = totalWidth / characterCount;        } else {            average = 0;        }        avgFontWidth = average;    }    return average;}
public String pdfbox_f4640_0(int code, GlyphList customGlyphList) throws IOException
{    return toUnicode(code);}
public String pdfbox_f4641_0(int code) throws IOException
{        if (toUnicodeCMap != null) {        if (toUnicodeCMap.getName() != null && toUnicodeCMap.getName().startsWith("Identity-") && (dict.getDictionaryObject(COSName.TO_UNICODE) instanceof COSName || !toUnicodeCMap.hasUnicodeMappings())) {                        return new String(new char[] { (char) code });        } else {                        return toUnicodeCMap.toUnicode(code);        }    }        return null;}
public String pdfbox_f4642_0()
{    return dict.getNameAsString(COSName.TYPE);}
public String pdfbox_f4643_0()
{    return dict.getNameAsString(COSName.SUBTYPE);}
protected final List<Float> pdfbox_f4644_0()
{    if (widths == null) {        COSArray array = (COSArray) dict.getDictionaryObject(COSName.WIDTHS);        if (array != null) {            widths = COSArrayList.convertFloatCOSArrayToList(array);        } else {            widths = Collections.emptyList();        }    }    return widths;}
public Matrix pdfbox_f4645_0()
{    return DEFAULT_FONT_MATRIX;}
public float pdfbox_f4646_1()
{    if (Float.compare(fontWidthOfSpace, -1f) == 0) {        COSBase toUnicode = dict.getDictionaryObject(COSName.TO_UNICODE);        try {            if (toUnicode != null && toUnicodeCMap != null) {                int spaceMapping = toUnicodeCMap.getSpaceMapping();                if (spaceMapping > -1) {                    fontWidthOfSpace = getWidth(spaceMapping);                }            } else {                fontWidthOfSpace = getWidth(32);            }                        if (fontWidthOfSpace <= 0) {                fontWidthOfSpace = getWidthFromFont(32);            }                        if (fontWidthOfSpace <= 0) {                fontWidthOfSpace = getAverageFontWidth();            }        } catch (Exception e) {                        fontWidthOfSpace = 250f;        }    }    return fontWidthOfSpace;}
public boolean pdfbox_f4647_0()
{        if (isEmbedded()) {        return false;    }        return Standard14Fonts.containsName(getName());}
public boolean pdfbox_f4648_0(Object other)
{    return other instanceof PDFont && ((PDFont) other).getCOSObject() == this.getCOSObject();}
public int pdfbox_f4649_0()
{    return this.getCOSObject().hashCode();}
public String pdfbox_f4650_0()
{    return getClass().getSimpleName() + " " + getName();}
public boolean pdfbox_f4651_0()
{    return isFlagBitOn(FLAG_FIXED_PITCH);}
public void pdfbox_f4652_0(boolean flag)
{    setFlagBit(FLAG_FIXED_PITCH, flag);}
public boolean pdfbox_f4653_0()
{    return isFlagBitOn(FLAG_SERIF);}
public void pdfbox_f4654_0(boolean flag)
{    setFlagBit(FLAG_SERIF, flag);}
public boolean pdfbox_f4655_0()
{    return isFlagBitOn(FLAG_SYMBOLIC);}
public void pdfbox_f4656_0(boolean flag)
{    setFlagBit(FLAG_SYMBOLIC, flag);}
public boolean pdfbox_f4657_0()
{    return isFlagBitOn(FLAG_SCRIPT);}
public void pdfbox_f4658_0(boolean flag)
{    setFlagBit(FLAG_SCRIPT, flag);}
public boolean pdfbox_f4659_0()
{    return isFlagBitOn(FLAG_NON_SYMBOLIC);}
public void pdfbox_f4660_0(boolean flag)
{    setFlagBit(FLAG_NON_SYMBOLIC, flag);}
public boolean pdfbox_f4661_0()
{    return isFlagBitOn(FLAG_ITALIC);}
public void pdfbox_f4662_0(boolean flag)
{    setFlagBit(FLAG_ITALIC, flag);}
public boolean pdfbox_f4663_0()
{    return isFlagBitOn(FLAG_ALL_CAP);}
public void pdfbox_f4664_0(boolean flag)
{    setFlagBit(FLAG_ALL_CAP, flag);}
public boolean pdfbox_f4665_0()
{    return isFlagBitOn(FLAG_SMALL_CAP);}
public void pdfbox_f4666_0(boolean flag)
{    setFlagBit(FLAG_SMALL_CAP, flag);}
public boolean pdfbox_f4667_0()
{    return isFlagBitOn(FLAG_FORCE_BOLD);}
public void pdfbox_f4668_0(boolean flag)
{    setFlagBit(FLAG_FORCE_BOLD, flag);}
private boolean pdfbox_f4669_0(int bit)
{    return (getFlags() & bit) != 0;}
private void pdfbox_f4670_0(int bit, boolean value)
{    int flags = getFlags();    if (value) {        flags = flags | bit;    } else {        flags = flags & (~bit);    }    setFlags(flags);}
public COSDictionary pdfbox_f4671_0()
{    return dic;}
public String pdfbox_f4672_0()
{    String retval = null;    COSBase base = dic.getDictionaryObject(COSName.FONT_NAME);    if (base instanceof COSName) {        retval = ((COSName) base).getName();    }    return retval;}
public void pdfbox_f4673_0(String fontName)
{    COSName name = null;    if (fontName != null) {        name = COSName.getPDFName(fontName);    }    dic.setItem(COSName.FONT_NAME, name);}
public String pdfbox_f4674_0()
{    String retval = null;    COSString name = (COSString) dic.getDictionaryObject(COSName.FONT_FAMILY);    if (name != null) {        retval = name.getString();    }    return retval;}
public void pdfbox_f4675_0(String fontFamily)
{    COSString name = null;    if (fontFamily != null) {        name = new COSString(fontFamily);    }    dic.setItem(COSName.FONT_FAMILY, name);}
public float pdfbox_f4676_0()
{    return dic.getFloat(COSName.FONT_WEIGHT, 0);}
public void pdfbox_f4677_0(float fontWeight)
{    dic.setFloat(COSName.FONT_WEIGHT, fontWeight);}
public String pdfbox_f4678_0()
{    String retval = null;    COSName name = (COSName) dic.getDictionaryObject(COSName.FONT_STRETCH);    if (name != null) {        retval = name.getName();    }    return retval;}
public void pdfbox_f4679_0(String fontStretch)
{    COSName name = null;    if (fontStretch != null) {        name = COSName.getPDFName(fontStretch);    }    dic.setItem(COSName.FONT_STRETCH, name);}
public int pdfbox_f4680_0()
{    if (flags == -1) {        flags = dic.getInt(COSName.FLAGS, 0);    }    return flags;}
public void pdfbox_f4681_0(int flags)
{    dic.setInt(COSName.FLAGS, flags);    this.flags = flags;}
public PDRectangle pdfbox_f4682_0()
{    COSArray rect = (COSArray) dic.getDictionaryObject(COSName.FONT_BBOX);    PDRectangle retval = null;    if (rect != null) {        retval = new PDRectangle(rect);    }    return retval;}
public void pdfbox_f4683_0(PDRectangle rect)
{    COSArray array = null;    if (rect != null) {        array = rect.getCOSArray();    }    dic.setItem(COSName.FONT_BBOX, array);}
public float pdfbox_f4684_0()
{    return dic.getFloat(COSName.ITALIC_ANGLE, 0);}
public void pdfbox_f4685_0(float angle)
{    dic.setFloat(COSName.ITALIC_ANGLE, angle);}
public float pdfbox_f4686_0()
{    return dic.getFloat(COSName.ASCENT, 0);}
public void pdfbox_f4687_0(float ascent)
{    dic.setFloat(COSName.ASCENT, ascent);}
public float pdfbox_f4688_0()
{    return dic.getFloat(COSName.DESCENT, 0);}
public void pdfbox_f4689_0(float descent)
{    dic.setFloat(COSName.DESCENT, descent);}
public float pdfbox_f4690_0()
{    return dic.getFloat(COSName.LEADING, 0);}
public void pdfbox_f4691_0(float leading)
{    dic.setFloat(COSName.LEADING, leading);}
public float pdfbox_f4692_0()
{    if (Float.compare(capHeight, Float.NEGATIVE_INFINITY) == 0) {        /* We observed a negative value being returned with             * the Scheherazade font. PDFBOX-429 was logged for this.             * We are not sure if returning the absolute value             * is the correct fix, but it seems to work.  */        capHeight = java.lang.Math.abs(dic.getFloat(COSName.CAP_HEIGHT, 0));    }    return capHeight;}
public void pdfbox_f4693_0(float capHeight)
{    dic.setFloat(COSName.CAP_HEIGHT, capHeight);    this.capHeight = capHeight;}
public float pdfbox_f4694_0()
{    if (Float.compare(xHeight, Float.NEGATIVE_INFINITY) == 0) {        /* We observed a negative value being returned with             * the Scheherazade font. PDFBOX-429 was logged for this.             * We are not sure if returning the absolute value             * is the correct fix, but it seems to work.  */        xHeight = java.lang.Math.abs(dic.getFloat(COSName.XHEIGHT, 0));    }    return xHeight;}
public void pdfbox_f4695_0(float xHeight)
{    dic.setFloat(COSName.XHEIGHT, xHeight);    this.xHeight = xHeight;}
public float pdfbox_f4696_0()
{    return dic.getFloat(COSName.STEM_V, 0);}
public void pdfbox_f4697_0(float stemV)
{    dic.setFloat(COSName.STEM_V, stemV);}
public float pdfbox_f4698_0()
{    return dic.getFloat(COSName.STEM_H, 0);}
public void pdfbox_f4699_0(float stemH)
{    dic.setFloat(COSName.STEM_H, stemH);}
public float pdfbox_f4700_0()
{    return dic.getFloat(COSName.AVG_WIDTH, 0);}
public void pdfbox_f4701_0(float averageWidth)
{    dic.setFloat(COSName.AVG_WIDTH, averageWidth);}
public float pdfbox_f4702_0()
{    return dic.getFloat(COSName.MAX_WIDTH, 0);}
public void pdfbox_f4703_0(float maxWidth)
{    dic.setFloat(COSName.MAX_WIDTH, maxWidth);}
public boolean pdfbox_f4704_0()
{    return dic.containsKey(COSName.WIDTHS) || dic.containsKey(COSName.MISSING_WIDTH);}
public boolean pdfbox_f4705_0()
{    return dic.containsKey(COSName.MISSING_WIDTH);}
public float pdfbox_f4706_0()
{    return dic.getFloat(COSName.MISSING_WIDTH, 0);}
public void pdfbox_f4707_0(float missingWidth)
{    dic.setFloat(COSName.MISSING_WIDTH, missingWidth);}
public String pdfbox_f4708_0()
{    String retval = null;    COSString name = (COSString) dic.getDictionaryObject(COSName.CHAR_SET);    if (name != null) {        retval = name.getString();    }    return retval;}
public void pdfbox_f4709_0(String charSet)
{    COSString name = null;    if (charSet != null) {        name = new COSString(charSet);    }    dic.setItem(COSName.CHAR_SET, name);}
public PDStream pdfbox_f4710_0()
{    PDStream retval = null;    COSBase obj = dic.getDictionaryObject(COSName.FONT_FILE);    if (obj instanceof COSStream) {        retval = new PDStream((COSStream) obj);    }    return retval;}
public void pdfbox_f4711_0(PDStream type1Stream)
{    dic.setItem(COSName.FONT_FILE, type1Stream);}
public PDStream pdfbox_f4712_0()
{    PDStream retval = null;    COSBase obj = dic.getDictionaryObject(COSName.FONT_FILE2);    if (obj instanceof COSStream) {        retval = new PDStream((COSStream) obj);    }    return retval;}
public void pdfbox_f4713_0(PDStream ttfStream)
{    dic.setItem(COSName.FONT_FILE2, ttfStream);}
public PDStream pdfbox_f4714_0()
{    PDStream retval = null;    COSBase obj = dic.getDictionaryObject(COSName.FONT_FILE3);    if (obj instanceof COSStream) {        retval = new PDStream((COSStream) obj);    }    return retval;}
public void pdfbox_f4715_0(PDStream stream)
{    dic.setItem(COSName.FONT_FILE3, stream);}
public PDStream pdfbox_f4716_0()
{    COSObjectable cidSet = dic.getDictionaryObject(COSName.CID_SET);    if (cidSet instanceof COSStream) {        return new PDStream((COSStream) cidSet);    }    return null;}
public void pdfbox_f4717_0(PDStream stream)
{    dic.setItem(COSName.CID_SET, stream);}
public PDPanose pdfbox_f4718_0()
{    COSDictionary style = (COSDictionary) dic.getDictionaryObject(COSName.STYLE);    if (style != null) {        COSString panose = (COSString) style.getDictionaryObject(COSName.PANOSE);        byte[] bytes = panose.getBytes();        return new PDPanose(bytes);    }    return null;}
public static PDFont pdfbox_f4719_0(COSDictionary dictionary) throws IOException
{    return createFont(dictionary, null);}
public static PDFont pdfbox_f4720_1(COSDictionary dictionary, ResourceCache resourceCache) throws IOException
{    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);    if (!COSName.FONT.equals(type)) {            }    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);    if (COSName.TYPE1.equals(subType)) {        COSBase fd = dictionary.getDictionaryObject(COSName.FONT_DESC);        if (fd instanceof COSDictionary && ((COSDictionary) fd).containsKey(COSName.FONT_FILE3)) {            return new PDType1CFont(dictionary);        }        return new PDType1Font(dictionary);    } else if (COSName.MM_TYPE1.equals(subType)) {        COSBase fd = dictionary.getDictionaryObject(COSName.FONT_DESC);        if (fd instanceof COSDictionary && ((COSDictionary) fd).containsKey(COSName.FONT_FILE3)) {            return new PDType1CFont(dictionary);        }        return new PDMMType1Font(dictionary);    } else if (COSName.TRUE_TYPE.equals(subType)) {        return new PDTrueTypeFont(dictionary);    } else if (COSName.TYPE3.equals(subType)) {        return new PDType3Font(dictionary, resourceCache);    } else if (COSName.TYPE0.equals(subType)) {        return new PDType0Font(dictionary);    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {        throw new IllegalArgumentException("Type 0 descendant font not allowed");    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {        throw new IllegalArgumentException("Type 2 descendant font not allowed");    } else {                                return new PDType1Font(dictionary);    }}
 static PDCIDFont pdfbox_f4721_0(COSDictionary dictionary, PDType0Font parent) throws IOException
{    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);    if (!COSName.FONT.equals(type)) {        throw new IllegalArgumentException("Expected 'Font' dictionary but found '" + type.getName() + "'");    }    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);    if (COSName.CID_FONT_TYPE0.equals(subType)) {        return new PDCIDFontType0(dictionary, parent);    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {        return new PDCIDFontType2(dictionary, parent);    } else {        throw new IOException("Invalid font type: " + type);    }}
public static PDFont pdfbox_f4722_0() throws IOException
{    COSDictionary dict = new COSDictionary();    dict.setItem(COSName.TYPE, COSName.FONT);    dict.setItem(COSName.SUBTYPE, COSName.TRUE_TYPE);    dict.setString(COSName.BASE_FONT, "Arial");    return createFont(dict);}
public int pdfbox_f4723_0()
{    return bytes[0] << 8 | bytes[1];}
public PDPanoseClassification pdfbox_f4724_0()
{    byte[] panose = Arrays.copyOfRange(bytes, 2, 12);    return new PDPanoseClassification(panose);}
public int pdfbox_f4725_0()
{    return bytes[0];}
public int pdfbox_f4726_0()
{    return bytes[1];}
public int pdfbox_f4727_0()
{    return bytes[2];}
public int pdfbox_f4728_0()
{    return bytes[3];}
public int pdfbox_f4729_0()
{    return bytes[4];}
public int pdfbox_f4730_0()
{    return bytes[5];}
public int pdfbox_f4731_0()
{    return bytes[6];}
public int pdfbox_f4732_0()
{    return bytes[7];}
public int pdfbox_f4733_0()
{    return bytes[8];}
public int pdfbox_f4734_0()
{    return bytes[9];}
public byte[] pdfbox_f4735_0()
{    return bytes;}
public String pdfbox_f4736_0()
{    return "{ FamilyKind = " + getFamilyKind() + ", " + "SerifStyle = " + getSerifStyle() + ", " + "Weight = " + getWeight() + ", " + "Proportion = " + getProportion() + ", " + "Contrast = " + getContrast() + ", " + "StrokeVariation = " + getStrokeVariation() + ", " + "ArmStyle = " + getArmStyle() + ", " + "Letterform = " + getLetterform() + ", " + "Midline = " + getMidline() + ", " + "XHeight = " + getXHeight() + "}";}
protected void pdfbox_f4737_1() throws IOException
{    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);    if (encoding != null) {        if (encoding instanceof COSName) {            COSName encodingName = (COSName) encoding;            this.encoding = Encoding.getInstance(encodingName);            if (this.encoding == null) {                                                this.encoding = readEncodingFromFont();            }        } else if (encoding instanceof COSDictionary) {            COSDictionary encodingDict = (COSDictionary) encoding;            Encoding builtIn = null;            Boolean symbolic = getSymbolicFlag();            boolean isFlaggedAsSymbolic = symbolic != null && symbolic;            COSName baseEncoding = encodingDict.getCOSName(COSName.BASE_ENCODING);            boolean hasValidBaseEncoding = baseEncoding != null && Encoding.getInstance(baseEncoding) != null;            if (!hasValidBaseEncoding && isFlaggedAsSymbolic) {                builtIn = readEncodingFromFont();            }            if (symbolic == null) {                symbolic = false;            }            this.encoding = new DictionaryEncoding(encodingDict, !symbolic, builtIn);        }    } else {        this.encoding = readEncodingFromFont();    }        String standard14Name = Standard14Fonts.getMappedFontName(getName());        if ("ZapfDingbats".equals(standard14Name)) {        glyphList = GlyphList.getZapfDingbats();    } else {                glyphList = GlyphList.getAdobeGlyphList();    }}
public Encoding pdfbox_f4738_0()
{    return encoding;}
public GlyphList pdfbox_f4739_0()
{    return glyphList;}
public final boolean pdfbox_f4740_0()
{    if (isSymbolic == null) {        Boolean result = isFontSymbolic();        if (result != null) {            isSymbolic = result;        } else {                        isSymbolic = true;        }    }    return isSymbolic;}
protected Boolean pdfbox_f4741_0()
{    Boolean result = getSymbolicFlag();    if (result != null) {        return result;    } else if (isStandard14()) {        String mappedName = Standard14Fonts.getMappedFontName(getName());        return mappedName.equals("Symbol") || mappedName.equals("ZapfDingbats");    } else {        if (encoding == null) {                        if (!(this instanceof PDTrueTypeFont)) {                throw new IllegalStateException("PDFBox bug: encoding should not be null!");            }                        return true;        } else if (encoding instanceof WinAnsiEncoding || encoding instanceof MacRomanEncoding || encoding instanceof StandardEncoding) {            return false;        } else if (encoding instanceof DictionaryEncoding) {                        for (String name : ((DictionaryEncoding) encoding).getDifferences().values()) {                if (".notdef".equals(name)) {                                } else if (!(WinAnsiEncoding.INSTANCE.contains(name) && MacRomanEncoding.INSTANCE.contains(name) && StandardEncoding.INSTANCE.contains(name))) {                    return true;                }            }            return false;        } else {                        return null;        }    }}
protected final Boolean pdfbox_f4742_0()
{    if (getFontDescriptor() != null) {                return getFontDescriptor().isSymbolic();    }    return null;}
public String pdfbox_f4743_0(int code) throws IOException
{    return toUnicode(code, GlyphList.getAdobeGlyphList());}
public String pdfbox_f4744_1(int code, GlyphList customGlyphList) throws IOException
{            GlyphList unicodeGlyphList;    if (this.glyphList == GlyphList.getAdobeGlyphList()) {        unicodeGlyphList = customGlyphList;    } else {        unicodeGlyphList = this.glyphList;    }        String unicode = super.toUnicode(code);    if (unicode != null) {        return unicode;    }                        String name = null;    if (encoding != null) {        name = encoding.getName(code);        unicode = unicodeGlyphList.toUnicode(name);        if (unicode != null) {            return unicode;        }    }        if (LOG.isWarnEnabled() && !noUnicode.contains(code)) {                noUnicode.add(code);        if (name != null) {                    } else {                    }    }    return null;}
public boolean pdfbox_f4745_0()
{    return false;}
protected final float pdfbox_f4746_0(int code)
{    if (getStandard14AFM() != null) {        String nameInAFM = getEncoding().getName(code);                if (".notdef".equals(nameInAFM)) {            return 250f;        }        return getStandard14AFM().getCharacterWidth(nameInAFM);    }    throw new IllegalStateException("No AFM");}
public boolean pdfbox_f4747_0()
{        if (getEncoding() instanceof DictionaryEncoding) {        DictionaryEncoding dictionary = (DictionaryEncoding) getEncoding();        if (dictionary.getDifferences().size() > 0) {                                    Encoding baseEncoding = dictionary.getBaseEncoding();            for (Map.Entry<Integer, String> entry : dictionary.getDifferences().entrySet()) {                if (!entry.getValue().equals(baseEncoding.getName(entry.getKey()))) {                    return false;                }            }        }    }    return super.isStandard14();}
protected boolean pdfbox_f4748_0(PDRectangle bbox)
{    return bbox != null && (Float.compare(bbox.getLowerLeftX(), 0) != 0 || Float.compare(bbox.getLowerLeftY(), 0) != 0 || Float.compare(bbox.getUpperRightX(), 0) != 0 || Float.compare(bbox.getUpperRightY(), 0) != 0);}
public void pdfbox_f4749_0(int codePoint)
{    throw new UnsupportedOperationException();}
public void pdfbox_f4750_0() throws IOException
{        throw new UnsupportedOperationException();}
public boolean pdfbox_f4751_0()
{    return false;}
public boolean pdfbox_f4752_0(int code) throws IOException
{    if (dict.containsKey(COSName.WIDTHS)) {        int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);        if (code >= firstChar && code - firstChar < getWidths().size()) {            return true;        }    }    return false;}
public static PDTrueTypeFont pdfbox_f4753_0(PDDocument doc, File file, Encoding encoding) throws IOException
{    return new PDTrueTypeFont(doc, new TTFParser().parse(file), encoding, true);}
public static PDTrueTypeFont pdfbox_f4754_0(PDDocument doc, InputStream input, Encoding encoding) throws IOException
{    return new PDTrueTypeFont(doc, new TTFParser().parse(input), encoding, true);}
public static PDTrueTypeFont pdfbox_f4755_0(PDDocument doc, TrueTypeFont ttf, Encoding encoding) throws IOException
{    return new PDTrueTypeFont(doc, ttf, encoding, false);}
public final String pdfbox_f4756_0()
{    return dict.getNameAsString(COSName.BASE_FONT);}
protected Encoding pdfbox_f4757_0() throws IOException
{    if (!isEmbedded() && getStandard14AFM() != null) {                return new Type1Encoding(getStandard14AFM());    } else {                if (getSymbolicFlag() != null && !getSymbolicFlag()) {            return StandardEncoding.INSTANCE;        }                String standard14Name = Standard14Fonts.getMappedFontName(getName());                if (isStandard14() && !standard14Name.equals("Symbol") && !standard14Name.equals("ZapfDingbats")) {            return StandardEncoding.INSTANCE;        }                PostScriptTable post = ttf.getPostScript();        Map<Integer, String> codeToName = new HashMap<>();        for (int code = 0; code <= 256; code++) {            int gid = codeToGID(code);            if (gid > 0) {                String name = null;                if (post != null) {                    name = post.getName(gid);                }                if (name == null) {                                        name = Integer.toString(gid);                }                codeToName.put(code, name);            }        }        return new BuiltInEncoding(codeToName);    }}
public int pdfbox_f4758_0(InputStream in) throws IOException
{    return in.read();}
public String pdfbox_f4759_0()
{    return getBaseFont();}
public BoundingBox pdfbox_f4760_0() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
private BoundingBox pdfbox_f4761_0() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (bbox != null) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return ttf.getFontBBox();}
public boolean pdfbox_f4762_0()
{    return isDamaged;}
public TrueTypeFont pdfbox_f4763_0()
{    return ttf;}
public float pdfbox_f4764_0(int code) throws IOException
{    int gid = codeToGID(code);    float width = ttf.getAdvanceWidth(gid);    float unitsPerEM = ttf.getUnitsPerEm();    if (Float.compare(unitsPerEM, 1000) != 0) {        width *= 1000f / unitsPerEM;    }    return width;}
public float pdfbox_f4765_0(int code) throws IOException
{    int gid = codeToGID(code);    GlyphData glyph = ttf.getGlyph().getGlyph(gid);    if (glyph != null) {        return glyph.getBoundingBox().getHeight();    }    return 0;}
protected byte[] pdfbox_f4766_0(int unicode) throws IOException
{    if (encoding != null) {        if (!encoding.contains(getGlyphList().codePointToName(unicode))) {            throw new IllegalArgumentException(String.format("U+%04X is not available in this font's encoding: %s", unicode, encoding.getEncodingName()));        }        String name = getGlyphList().codePointToName(unicode);        Map<String, Integer> inverted = encoding.getNameToCodeMap();        if (!ttf.hasGlyph(name)) {                        String uniName = getUniNameOfCodePoint(unicode);            if (!ttf.hasGlyph(uniName)) {                throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));            }        }        int code = inverted.get(name);        return new byte[] { (byte) code };    } else {                String name = getGlyphList().codePointToName(unicode);        if (!ttf.hasGlyph(name)) {            throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));        }        int gid = ttf.nameToGID(name);        Integer code = getGIDToCode().get(gid);        if (code == null) {            throw new IllegalArgumentException(String.format("U+%04X is not available in this font's Encoding", unicode));        }        return new byte[] { (byte) (int) code };    }}
protected Map<Integer, Integer> pdfbox_f4767_0() throws IOException
{    if (gidToCode != null) {        return gidToCode;    }    gidToCode = new HashMap<>();    for (int code = 0; code <= 255; code++) {        int gid = codeToGID(code);        if (!gidToCode.containsKey(gid)) {            gidToCode.put(gid, code);        }    }    return gidToCode;}
public boolean pdfbox_f4768_0()
{    return isEmbedded;}
public GeneralPath pdfbox_f4769_0(int code) throws IOException
{    int gid = codeToGID(code);    GlyphData glyph = ttf.getGlyph().getGlyph(gid);        if (glyph == null) {        return new GeneralPath();    } else {        return glyph.getPath();    }}
public GeneralPath pdfbox_f4770_0(String name) throws IOException
{        int gid = ttf.nameToGID(name);    if (gid == 0) {        try {                        gid = Integer.parseInt(name);            if (gid > ttf.getNumberOfGlyphs()) {                gid = 0;            }        } catch (NumberFormatException e) {            gid = 0;        }    }        if (gid == 0) {        return new GeneralPath();    }    GlyphData glyph = ttf.getGlyph().getGlyph(gid);    if (glyph != null) {        return glyph.getPath();    } else {        return new GeneralPath();    }}
public GeneralPath pdfbox_f4771_0(int code) throws IOException
{    boolean hasScaling = ttf.getUnitsPerEm() != 1000;    float scale = 1000f / ttf.getUnitsPerEm();    int gid = codeToGID(code);    GeneralPath path = getPath(code);        if (gid == 0 && !isEmbedded() && !isStandard14()) {        path = null;    }    if (path == null) {                return new GeneralPath();    } else {        if (hasScaling) {            path.transform(AffineTransform.getScaleInstance(scale, scale));        }        return path;    }}
public boolean pdfbox_f4772_0(String name) throws IOException
{    int gid = ttf.nameToGID(name);    return !(gid == 0 || gid >= ttf.getMaximumProfile().getNumGlyphs());}
public FontBoxFont pdfbox_f4773_0()
{    return ttf;}
public boolean pdfbox_f4774_0(int code) throws IOException
{    return codeToGID(code) != 0;}
public int pdfbox_f4775_0(int code) throws IOException
{    extractCmapTable();    int gid = 0;    if (    !isSymbolic()) {        String name = encoding.getName(code);        if (".notdef".equals(name)) {            return 0;        } else {                        if (cmapWinUnicode != null) {                String unicode = GlyphList.getAdobeGlyphList().toUnicode(name);                if (unicode != null) {                    int uni = unicode.codePointAt(0);                    gid = cmapWinUnicode.getGlyphId(uni);                }            }                        if (gid == 0 && cmapMacRoman != null) {                Integer macCode = INVERTED_MACOS_ROMAN.get(name);                if (macCode != null) {                    gid = cmapMacRoman.getGlyphId(macCode);                }            }                        if (gid == 0) {                gid = ttf.nameToGID(name);            }        }    } else     {                if (cmapWinSymbol != null) {            gid = cmapWinSymbol.getGlyphId(code);            if (code >= 0 && code <= 0xFF) {                                if (gid == 0) {                                        gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F000);                }                if (gid == 0) {                                        gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F100);                }                if (gid == 0) {                                        gid = cmapWinSymbol.getGlyphId(code + START_RANGE_F200);                }            }        }                if (gid == 0 && cmapMacRoman != null) {            gid = cmapMacRoman.getGlyphId(code);        }                if (gid == 0 && cmapWinUnicode != null && encoding != null) {            String name = encoding.getName(code);            if (".notdef".equals(name)) {                return 0;            }            String unicode = GlyphList.getAdobeGlyphList().toUnicode(name);            if (unicode != null) {                int uni = unicode.codePointAt(0);                gid = cmapWinUnicode.getGlyphId(uni);            }        }    }    return gid;}
private void pdfbox_f4776_0() throws IOException
{    if (cmapInitialized) {        return;    }    CmapTable cmapTable = ttf.getCmap();    if (cmapTable != null) {                CmapSubtable[] cmaps = cmapTable.getCmaps();        for (CmapSubtable cmap : cmaps) {            if (CmapTable.PLATFORM_WINDOWS == cmap.getPlatformId()) {                if (CmapTable.ENCODING_WIN_UNICODE_BMP == cmap.getPlatformEncodingId()) {                    cmapWinUnicode = cmap;                } else if (CmapTable.ENCODING_WIN_SYMBOL == cmap.getPlatformEncodingId()) {                    cmapWinSymbol = cmap;                }            } else if (CmapTable.PLATFORM_MACINTOSH == cmap.getPlatformId() && CmapTable.ENCODING_MAC_ROMAN == cmap.getPlatformEncodingId()) {                cmapMacRoman = cmap;            }        }    }    cmapInitialized = true;}
private void pdfbox_f4777_0(COSDictionary font, GlyphList glyphList) throws IOException
{    float scaling = 1000f / ttf.getHeader().getUnitsPerEm();    HorizontalMetricsTable hmtx = ttf.getHorizontalMetrics();    Map<Integer, String> codeToName = getFontEncoding().getCodeToNameMap();    int firstChar = Collections.min(codeToName.keySet());    int lastChar = Collections.max(codeToName.keySet());    List<Integer> widths = new ArrayList<>(lastChar - firstChar + 1);    for (int i = 0; i < lastChar - firstChar + 1; i++) {        widths.add(0);    }        for (Map.Entry<Integer, String> entry : codeToName.entrySet()) {        int code = entry.getKey();        String name = entry.getValue();        if (code >= firstChar && code <= lastChar) {            String uni = glyphList.toUnicode(name);            int charCode = uni.codePointAt(0);            int gid = cmapLookup.getGlyphId(charCode);            widths.set(entry.getKey() - firstChar, Math.round(hmtx.getAdvanceWidth(gid) * scaling));        }    }    font.setInt(COSName.FIRST_CHAR, firstChar);    font.setInt(COSName.LAST_CHAR, lastChar);    font.setItem(COSName.WIDTHS, COSArrayList.converterToCOSArray(widths));}
public Encoding pdfbox_f4778_0()
{    return fontEncoding;}
protected void pdfbox_f4779_0(InputStream ttfSubset, String tag, Map<Integer, Integer> gidToCid) throws IOException
{        throw new UnsupportedOperationException();}
public static PDType0Font pdfbox_f4780_0(PDDocument doc, File file) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(file), true, true, false);}
public static PDType0Font pdfbox_f4781_0(PDDocument doc, InputStream input) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), true, true, false);}
public static PDType0Font pdfbox_f4782_0(PDDocument doc, InputStream input, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), embedSubset, true, false);}
public static PDType0Font pdfbox_f4783_0(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, ttf, embedSubset, false, false);}
public static PDType0Font pdfbox_f4784_0(PDDocument doc, File file) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(file), true, true, true);}
public static PDType0Font pdfbox_f4785_0(PDDocument doc, InputStream input) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), true, true, true);}
public static PDType0Font pdfbox_f4786_0(PDDocument doc, InputStream input, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, new TTFParser().parse(input), embedSubset, true, true);}
public static PDType0Font pdfbox_f4787_0(PDDocument doc, TrueTypeFont ttf, boolean embedSubset) throws IOException
{    return new PDType0Font(doc, ttf, embedSubset, false, true);}
public void pdfbox_f4788_0(int codePoint)
{    if (!willBeSubset()) {        throw new IllegalStateException("This font was created with subsetting disabled");    }    embedder.addToSubset(codePoint);}
public void pdfbox_f4789_0(Set<Integer> glyphIds)
{    if (!willBeSubset()) {        throw new IllegalStateException("This font was created with subsetting disabled");    }    embedder.addGlyphIds(glyphIds);}
public void pdfbox_f4790_0() throws IOException
{    if (!willBeSubset()) {        throw new IllegalStateException("This font was created with subsetting disabled");    }    embedder.subset();    if (ttf != null) {        ttf.close();        ttf = null;    }}
public boolean pdfbox_f4791_0()
{    return embedder != null && embedder.needsSubset();}
private void pdfbox_f4792_1() throws IOException
{    COSBase encoding = dict.getDictionaryObject(COSName.ENCODING);    if (encoding instanceof COSName) {                COSName encodingName = (COSName) encoding;        cMap = CMapManager.getPredefinedCMap(encodingName.getName());        if (cMap != null) {            isCMapPredefined = true;        } else {            throw new IOException("Missing required CMap");        }    } else if (encoding != null) {        cMap = readCMap(encoding);        if (cMap == null) {            throw new IOException("Missing required CMap");        } else if (!cMap.hasCIDMappings()) {                    }    }        PDCIDSystemInfo ros = descendantFont.getCIDSystemInfo();    if (ros != null) {        isDescendantCJK = "Adobe".equals(ros.getRegistry()) && ("GB1".equals(ros.getOrdering()) || "CNS1".equals(ros.getOrdering()) || "Japan1".equals(ros.getOrdering()) || "Korea1".equals(ros.getOrdering()));    }}
private void pdfbox_f4793_0() throws IOException
{                COSName name = dict.getCOSName(COSName.ENCODING);    if (isCMapPredefined && !(name == COSName.IDENTITY_H || name == COSName.IDENTITY_V) || isDescendantCJK) {                                                        String strName = null;        if (isDescendantCJK) {            strName = descendantFont.getCIDSystemInfo().getRegistry() + "-" + descendantFont.getCIDSystemInfo().getOrdering() + "-" + descendantFont.getCIDSystemInfo().getSupplement();        } else if (name != null) {            strName = name.getName();        }                if (strName != null) {            CMap prdCMap = CMapManager.getPredefinedCMap(strName);            String ucs2Name = prdCMap.getRegistry() + "-" + prdCMap.getOrdering() + "-UCS2";            cMapUCS2 = CMapManager.getPredefinedCMap(ucs2Name);        }    }}
public String pdfbox_f4794_0()
{    return dict.getNameAsString(COSName.BASE_FONT);}
public PDCIDFont pdfbox_f4795_0()
{    return descendantFont;}
public CMap pdfbox_f4796_0()
{    return cMap;}
public CMap pdfbox_f4797_0()
{    return cMapUCS2;}
public PDFontDescriptor pdfbox_f4798_0()
{    return descendantFont.getFontDescriptor();}
public Matrix pdfbox_f4799_0()
{    return descendantFont.getFontMatrix();}
public boolean pdfbox_f4800_0()
{    return cMap.getWMode() == 1;}
public float pdfbox_f4801_0(int code) throws IOException
{    return descendantFont.getHeight(code);}
protected byte[] pdfbox_f4802_0(int unicode) throws IOException
{    return descendantFont.encode(unicode);}
public boolean pdfbox_f4803_0(int code) throws IOException
{    return descendantFont.hasExplicitWidth(code);}
public float pdfbox_f4804_0()
{    return descendantFont.getAverageFontWidth();}
public Vector pdfbox_f4805_0(int code)
{        return descendantFont.getPositionVector(code).scale(-1 / 1000f);}
public Vector pdfbox_f4806_0(int code) throws IOException
{    if (isVertical()) {        return new Vector(0, descendantFont.getVerticalDisplacementVectorY(code) / 1000f);    } else {        return super.getDisplacement(code);    }}
public float pdfbox_f4807_0(int code) throws IOException
{    return descendantFont.getWidth(code);}
protected float pdfbox_f4808_0(int code)
{    throw new UnsupportedOperationException("not suppported");}
public float pdfbox_f4809_0(int code) throws IOException
{    return descendantFont.getWidthFromFont(code);}
public boolean pdfbox_f4810_0()
{    return descendantFont.isEmbedded();}
public String pdfbox_f4811_1(int code) throws IOException
{        String unicode = super.toUnicode(code);    if (unicode != null) {        return unicode;    }    if ((isCMapPredefined || isDescendantCJK) && cMapUCS2 != null) {                                int cid = codeToCID(code);                return cMapUCS2.toUnicode(cid);    } else {        if (LOG.isWarnEnabled() && !noUnicode.contains(code)) {                        String cid = "CID+" + codeToCID(code);                                    noUnicode.add(code);        }        return null;    }}
public String pdfbox_f4812_0()
{    return getBaseFont();}
public BoundingBox pdfbox_f4813_0() throws IOException
{        return descendantFont.getBoundingBox();}
public int pdfbox_f4814_0(InputStream in) throws IOException
{    return cMap.readCode(in);}
public int pdfbox_f4815_0(int code)
{    return descendantFont.codeToCID(code);}
public int pdfbox_f4816_0(int code) throws IOException
{    return descendantFont.codeToGID(code);}
public boolean pdfbox_f4817_0()
{    return false;}
public boolean pdfbox_f4818_0()
{    return descendantFont.isDamaged();}
public String pdfbox_f4819_0()
{    String descendant = null;    if (getDescendantFont() != null) {        descendant = getDescendantFont().getClass().getSimpleName();    }    return getClass().getSimpleName() + "/" + descendant + ", PostScript name: " + getBaseFont();}
public GeneralPath pdfbox_f4820_0(int code) throws IOException
{    return descendantFont.getPath(code);}
public GeneralPath pdfbox_f4821_0(int code) throws IOException
{    return descendantFont.getNormalizedPath(code);}
public boolean pdfbox_f4822_0(int code) throws IOException
{    return descendantFont.hasGlyph(code);}
public GsubData pdfbox_f4823_0()
{    return gsubData;}
public byte[] pdfbox_f4824_0(int glyphId)
{    return descendantFont.encodeGlyphId(glyphId);}
public CmapLookup pdfbox_f4825_0()
{    return cmapLookup;}
public FontBoxFont pdfbox_f4826_0()
{    return genericFont;}
public final String pdfbox_f4827_0()
{    return dict.getNameAsString(COSName.BASE_FONT);}
public GeneralPath pdfbox_f4828_0(String name) throws IOException
{        if (name.equals(".notdef") && !isEmbedded() && !isStandard14()) {        return new GeneralPath();    } else {        return genericFont.getPath(name);    }}
public boolean pdfbox_f4829_0(int code) throws IOException
{    String name = getEncoding().getName(code);    name = getNameInFont(name);    return hasGlyph(name);}
public GeneralPath pdfbox_f4830_0(int code) throws IOException
{    String name = getEncoding().getName(code);    name = getNameInFont(name);    return getPath(name);}
public GeneralPath pdfbox_f4831_0(int code) throws IOException
{    String name = getEncoding().getName(code);    name = getNameInFont(name);    GeneralPath path = getPath(name);    if (path == null) {        return getPath(".notdef");    }    return path;}
public boolean pdfbox_f4832_0(String name) throws IOException
{    return genericFont.hasGlyph(name);}
public final String pdfbox_f4833_0()
{    return getBaseFont();}
public BoundingBox pdfbox_f4834_0() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
private BoundingBox pdfbox_f4835_0() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (isNonZeroBoundingBox(bbox)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return genericFont.getFontBBox();}
public String pdfbox_f4836_0(int code)
{    return getEncoding().getName(code);}
protected Encoding pdfbox_f4837_0() throws IOException
{    if (!isEmbedded() && getStandard14AFM() != null) {                return new Type1Encoding(getStandard14AFM());    } else {                if (genericFont instanceof EncodedFont) {            return Type1Encoding.fromFontBox(((EncodedFont) genericFont).getEncoding());        } else {                        return StandardEncoding.INSTANCE;        }    }}
public int pdfbox_f4838_0(InputStream in) throws IOException
{    return in.read();}
public final Matrix pdfbox_f4839_1()
{    if (fontMatrix == null) {        List<Number> numbers = null;        try {            numbers = genericFont.getFontMatrix();        } catch (IOException e) {                        fontMatrix = DEFAULT_FONT_MATRIX;        }        if (numbers != null && numbers.size() == 6) {            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());        } else {            return super.getFontMatrix();        }    }    return fontMatrix;}
public boolean pdfbox_f4840_0()
{    return isDamaged;}
public float pdfbox_f4841_0(int code) throws IOException
{    String name = codeToName(code);    name = getNameInFont(name);    float width = genericFont.getWidth(name);    Point2D p = new Point2D.Float(width, 0);    fontMatrixTransform.transform(p, p);    return (float) p.getX();}
public boolean pdfbox_f4842_0()
{    return isEmbedded;}
public float pdfbox_f4843_0(int code) throws IOException
{    String name = codeToName(code);    float height;    if (!glyphHeights.containsKey(name)) {                height = (float) cffFont.getType1CharString(name).getBounds().getHeight();        glyphHeights.put(name, height);    } else {        height = glyphHeights.get(name);    }    return height;}
protected byte[] pdfbox_f4844_0(int unicode) throws IOException
{    String name = getGlyphList().codePointToName(unicode);    if (!encoding.contains(name)) {        throw new IllegalArgumentException(String.format("U+%04X ('%s') is not available in this font's encoding: %s", unicode, name, encoding.getEncodingName()));    }    String nameInFont = getNameInFont(name);    Map<String, Integer> inverted = encoding.getNameToCodeMap();    if (nameInFont.equals(".notdef") || !genericFont.hasGlyph(nameInFont)) {        throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));    }    int code = inverted.get(name);    return new byte[] { (byte) code };}
public float pdfbox_f4845_0(String string) throws IOException
{    float width = 0;    for (int i = 0; i < string.length(); i++) {        int codePoint = string.codePointAt(i);        String name = getGlyphList().codePointToName(codePoint);        width += cffFont.getType1CharString(name).getWidth();    }    return width;}
public float pdfbox_f4846_0()
{    if (avgWidth == null) {        avgWidth = getAverageCharacterWidth();    }    return avgWidth;}
public CFFType1Font pdfbox_f4847_0()
{    return cffFont;}
private float pdfbox_f4848_0()
{        return 500;}
private String pdfbox_f4849_0(String name) throws IOException
{    if (isEmbedded() || genericFont.hasGlyph(name)) {        return name;    } else {                String unicodes = getGlyphList().toUnicode(name);        if (unicodes != null && unicodes.length() == 1) {            String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));            if (genericFont.hasGlyph(uniName)) {                return uniName;            }        }    }    return ".notdef";}
public byte[] pdfbox_f4850_0() throws IOException
{    return getFontDescriptor().getFontFile3().toByteArray();}
private int pdfbox_f4851_1(byte[] bytes, int length1)
{        int offset = Math.max(0, length1 - 4);    if (offset <= 0 || offset > bytes.length - 4) {        offset = bytes.length - 4;    }    offset = findBinaryOffsetAfterExec(bytes, offset);    if (offset == 0 && length1 > 0) {                offset = findBinaryOffsetAfterExec(bytes, bytes.length - 4);    }    if (length1 - offset != 0 && offset > 0) {        if (LOG.isWarnEnabled()) {                    }        return offset;    }    return length1;}
private static int pdfbox_f4852_0(byte[] bytes, int startOffset)
{    int offset = startOffset;    while (offset > 0) {        if (bytes[offset + 0] == 'e' && bytes[offset + 1] == 'x' && bytes[offset + 2] == 'e' && bytes[offset + 3] == 'c') {            offset += 4;                        while (offset < bytes.length && (bytes[offset] == '\r' || bytes[offset] == '\n' || bytes[offset] == ' ' || bytes[offset] == '\t')) {                offset++;            }            break;        }        offset--;    }    return offset;}
private int pdfbox_f4853_1(byte[] bytes, int length1, int length2)
{        if (length2 < 0 || length2 > bytes.length - length1) {                return bytes.length - length1;    }    return length2;}
public final String pdfbox_f4854_0()
{    return dict.getNameAsString(COSName.BASE_FONT);}
public float pdfbox_f4855_0(int code) throws IOException
{    String name = codeToName(code);    if (getStandard14AFM() != null) {        String afmName = getEncoding().getName(code);                return getStandard14AFM().getCharacterHeight(afmName);    } else {                return (float) genericFont.getPath(name).getBounds().getHeight();    }}
protected byte[] pdfbox_f4856_0(int unicode) throws IOException
{    byte[] bytes = codeToBytesMap.get(unicode);    if (bytes != null) {        return bytes;    }    String name = getGlyphList().codePointToName(unicode);    if (isStandard14()) {                if (!encoding.contains(name)) {            throw new IllegalArgumentException(String.format("U+%04X ('%s') is not available in this font %s encoding: %s", unicode, name, getName(), encoding.getEncodingName()));        }        if (".notdef".equals(name)) {            throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s", unicode, getName()));        }    } else {        if (!encoding.contains(name)) {            throw new IllegalArgumentException(String.format("U+%04X ('%s') is not available in this font %s (generic: %s) encoding: %s", unicode, name, getName(), genericFont.getName(), encoding.getEncodingName()));        }        String nameInFont = getNameInFont(name);        if (".notdef".equals(nameInFont) || !genericFont.hasGlyph(nameInFont)) {            throw new IllegalArgumentException(String.format("No glyph for U+%04X in font %s (generic: %s)", unicode, getName(), genericFont.getName()));        }    }    Map<String, Integer> inverted = encoding.getNameToCodeMap();    int code = inverted.get(name);    bytes = new byte[] { (byte) code };    codeToBytesMap.put(unicode, bytes);    return bytes;}
public float pdfbox_f4857_0(int code) throws IOException
{    String name = codeToName(code);        if (!isEmbedded && name.equals(".notdef")) {        return 250;    }    float width = genericFont.getWidth(name);    Point2D p = new Point2D.Float(width, 0);    fontMatrixTransform.transform(p, p);    return (float) p.getX();}
public boolean pdfbox_f4858_0()
{    return isEmbedded;}
public float pdfbox_f4859_0()
{    if (getStandard14AFM() != null) {        return getStandard14AFM().getAverageCharacterWidth();    } else {        return super.getAverageFontWidth();    }}
public int pdfbox_f4860_0(InputStream in) throws IOException
{    return in.read();}
protected Encoding pdfbox_f4861_0() throws IOException
{    if (!isEmbedded() && getStandard14AFM() != null) {                return new Type1Encoding(getStandard14AFM());    } else {                if (genericFont instanceof EncodedFont) {            return Type1Encoding.fromFontBox(((EncodedFont) genericFont).getEncoding());        } else {                        return StandardEncoding.INSTANCE;        }    }}
public Type1Font pdfbox_f4862_0()
{    return type1font;}
public FontBoxFont pdfbox_f4863_0()
{    return genericFont;}
public String pdfbox_f4864_0()
{    return getBaseFont();}
public BoundingBox pdfbox_f4865_0() throws IOException
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
private BoundingBox pdfbox_f4866_0() throws IOException
{    if (getFontDescriptor() != null) {        PDRectangle bbox = getFontDescriptor().getFontBoundingBox();        if (isNonZeroBoundingBox(bbox)) {            return new BoundingBox(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getUpperRightX(), bbox.getUpperRightY());        }    }    return genericFont.getFontBBox();}
public String pdfbox_f4867_0(int code) throws IOException
{    String name = getEncoding().getName(code);    return getNameInFont(name);}
private String pdfbox_f4868_0(String name) throws IOException
{    if (isEmbedded() || genericFont.hasGlyph(name)) {        return name;    }        String altName = ALT_NAMES.get(name);    if (altName != null && !name.equals(".notdef") && genericFont.hasGlyph(altName)) {        return altName;    }        String unicodes = getGlyphList().toUnicode(name);    if (unicodes != null && unicodes.length() == 1) {        String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));        if (genericFont.hasGlyph(uniName)) {            return uniName;        }                if ("SymbolMT".equals(genericFont.getName())) {            Integer code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);            if (code != null) {                uniName = getUniNameOfCodePoint(code + 0xF000);                if (genericFont.hasGlyph(uniName)) {                    return uniName;                }            }        }    }    return ".notdef";}
public GeneralPath pdfbox_f4869_0(String name) throws IOException
{        if (name.equals(".notdef") && !isEmbedded) {        return new GeneralPath();    } else {        return genericFont.getPath(getNameInFont(name));    }}
public GeneralPath pdfbox_f4870_0(int code) throws IOException
{    String name = getEncoding().getName(code);    return getPath(name);}
public GeneralPath pdfbox_f4871_0(int code) throws IOException
{    String name = getEncoding().getName(code);    GeneralPath path = getPath(name);    if (path == null) {        return getPath(".notdef");    }    return path;}
public boolean pdfbox_f4872_0(String name) throws IOException
{    return genericFont.hasGlyph(getNameInFont(name));}
public boolean pdfbox_f4873_0(int code) throws IOException
{    return !getEncoding().getName(code).equals(".notdef");}
public final Matrix pdfbox_f4874_1()
{    if (fontMatrix == null) {                        List<Number> numbers = null;        try {            numbers = genericFont.getFontMatrix();        } catch (IOException e) {                        fontMatrix = DEFAULT_FONT_MATRIX;        }        if (numbers != null && numbers.size() == 6) {            fontMatrix = new Matrix(numbers.get(0).floatValue(), numbers.get(1).floatValue(), numbers.get(2).floatValue(), numbers.get(3).floatValue(), numbers.get(4).floatValue(), numbers.get(5).floatValue());        } else {            return super.getFontMatrix();        }    }    return fontMatrix;}
public boolean pdfbox_f4875_0()
{    return isDamaged;}
 static PDFontDescriptor pdfbox_f4876_0(Type1Font type1)
{    boolean isSymbolic = type1.getEncoding() instanceof org.apache.fontbox.encoding.BuiltInEncoding;    PDFontDescriptor fd = new PDFontDescriptor();    fd.setFontName(type1.getName());    fd.setFontFamily(type1.getFamilyName());    fd.setNonSymbolic(!isSymbolic);    fd.setSymbolic(isSymbolic);    fd.setFontBoundingBox(new PDRectangle(type1.getFontBBox()));    fd.setItalicAngle(type1.getItalicAngle());    fd.setAscent(type1.getFontBBox().getUpperRightY());    fd.setDescent(type1.getFontBBox().getLowerLeftY());    fd.setCapHeight(type1.getBlueValues().get(2).floatValue());        fd.setStemV(0);    return fd;}
 static PDFontDescriptor pdfbox_f4877_0(FontMetrics metrics)
{    boolean isSymbolic = metrics.getEncodingScheme().equals("FontSpecific");    PDFontDescriptor fd = new PDFontDescriptor();    fd.setFontName(metrics.getFontName());    fd.setFontFamily(metrics.getFamilyName());    fd.setNonSymbolic(!isSymbolic);    fd.setSymbolic(isSymbolic);    fd.setFontBoundingBox(new PDRectangle(metrics.getFontBBox()));    fd.setItalicAngle(metrics.getItalicAngle());    fd.setAscent(metrics.getAscender());    fd.setDescent(metrics.getDescender());    fd.setCapHeight(metrics.getCapHeight());    fd.setXHeight(metrics.getXHeight());    fd.setAverageWidth(metrics.getAverageCharacterWidth());    fd.setCharacterSet(metrics.getCharacterSet());        fd.setStemV(0);    return fd;}
public Encoding pdfbox_f4878_0()
{    return fontEncoding;}
public GlyphList pdfbox_f4879_0()
{    return GlyphList.getAdobeGlyphList();}
public Type1Font pdfbox_f4880_0()
{    return type1;}
public COSStream pdfbox_f4881_0()
{    return charStream;}
public PDType3Font pdfbox_f4882_0()
{    return font;}
public PDStream pdfbox_f4883_0()
{    return new PDStream(charStream);}
public InputStream pdfbox_f4884_0() throws IOException
{    return charStream.createInputStream();}
public PDResources pdfbox_f4885_0()
{    return font.getResources();}
public PDRectangle pdfbox_f4886_0()
{    return font.getFontBBox();}
public PDRectangle pdfbox_f4887_0() throws IOException
{    List<COSBase> arguments = new ArrayList<>();    PDFStreamParser parser = new PDFStreamParser(getContents());    Object token = parser.parseNextToken();    while (token != null) {        if (token instanceof COSObject) {            arguments.add(((COSObject) token).getObject());        } else if (token instanceof Operator) {            if (((Operator) token).getName().equals("d1") && arguments.size() == 6) {                for (int i = 0; i < 6; ++i) {                    if (!(arguments.get(i) instanceof COSNumber)) {                        return null;                    }                }                return new PDRectangle(((COSNumber) arguments.get(2)).floatValue(), ((COSNumber) arguments.get(3)).floatValue(), ((COSNumber) arguments.get(4)).floatValue() - ((COSNumber) arguments.get(2)).floatValue(), ((COSNumber) arguments.get(5)).floatValue() - ((COSNumber) arguments.get(3)).floatValue());            } else {                return null;            }        } else {            arguments.add((COSBase) token);        }        token = parser.parseNextToken();    }    return null;}
public Matrix pdfbox_f4888_0()
{    return font.getFontMatrix();}
public float pdfbox_f4889_0() throws IOException
{    List<COSBase> arguments = new ArrayList<>();    PDFStreamParser parser = new PDFStreamParser(getContents());    Object token = parser.parseNextToken();    while (token != null) {        if (token instanceof COSObject) {            arguments.add(((COSObject) token).getObject());        } else if (token instanceof Operator) {            return parseWidth((Operator) token, arguments);        } else {            arguments.add((COSBase) token);        }        token = parser.parseNextToken();    }    throw new IOException("Unexpected end of stream");}
private float pdfbox_f4890_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (operator.getName().equals("d0") || operator.getName().equals("d1")) {        COSBase obj = arguments.get(0);        if (obj instanceof COSNumber) {            return ((COSNumber) obj).floatValue();        }        throw new IOException("Unexpected argument type: " + obj.getClass().getName());    } else {        throw new IOException("First operator must be d0 or d1");    }}
public String pdfbox_f4891_0()
{    return dict.getNameAsString(COSName.NAME);}
protected final void pdfbox_f4892_1() throws IOException
{    COSBase encodingBase = dict.getDictionaryObject(COSName.ENCODING);    if (encodingBase instanceof COSName) {        COSName encodingName = (COSName) encodingBase;        encoding = Encoding.getInstance(encodingName);        if (encoding == null) {                    }    } else if (encodingBase instanceof COSDictionary) {        encoding = new DictionaryEncoding((COSDictionary) encodingBase);    }    glyphList = GlyphList.getAdobeGlyphList();}
protected Encoding pdfbox_f4893_0() throws IOException
{        throw new UnsupportedOperationException("not supported for Type 3 fonts");}
protected Boolean pdfbox_f4894_0()
{    return false;}
public GeneralPath pdfbox_f4895_0(String name) throws IOException
{        throw new UnsupportedOperationException("not supported for Type 3 fonts");}
public boolean pdfbox_f4896_0(String name) throws IOException
{    COSBase base = getCharProcs().getDictionaryObject(COSName.getPDFName(name));    return base instanceof COSStream;}
public FontBoxFont pdfbox_f4897_0()
{        throw new UnsupportedOperationException("not supported for Type 3 fonts");}
public Vector pdfbox_f4898_0(int code) throws IOException
{    return getFontMatrix().transform(new Vector(getWidth(code), 0));}
public float pdfbox_f4899_0(int code) throws IOException
{    int firstChar = dict.getInt(COSName.FIRST_CHAR, -1);    int lastChar = dict.getInt(COSName.LAST_CHAR, -1);    if (!getWidths().isEmpty() && code >= firstChar && code <= lastChar) {        Float w = getWidths().get(code - firstChar);        return w == null ? 0 : w;    } else {        PDFontDescriptor fd = getFontDescriptor();        if (fd != null) {            return fd.getMissingWidth();        } else {            return getWidthFromFont(code);        }    }}
public float pdfbox_f4900_0(int code) throws IOException
{    PDType3CharProc charProc = getCharProc(code);    if (charProc == null || charProc.getContentStream() == null || charProc.getContentStream().getLength() == 0) {        return 0;    }    return charProc.getWidth();}
public boolean pdfbox_f4901_0()
{    return true;}
public float pdfbox_f4902_0(int code) throws IOException
{    PDFontDescriptor desc = getFontDescriptor();    if (desc != null) {                                PDRectangle bbox = desc.getFontBoundingBox();        float retval = 0;        if (bbox != null) {            retval = bbox.getHeight() / 2;        }        if (Float.compare(retval, 0) == 0) {            retval = desc.getCapHeight();        }        if (Float.compare(retval, 0) == 0) {            retval = desc.getAscent();        }        if (Float.compare(retval, 0) == 0) {            retval = desc.getXHeight();            if (retval > 0) {                retval -= desc.getDescent();            }        }        return retval;    }    return 0;}
protected byte[] pdfbox_f4903_0(int unicode) throws IOException
{    throw new UnsupportedOperationException("Not implemented: Type3");}
public int pdfbox_f4904_0(InputStream in) throws IOException
{    return in.read();}
public Matrix pdfbox_f4905_0()
{    if (fontMatrix == null) {        COSBase base = dict.getDictionaryObject(COSName.FONT_MATRIX);        if (base instanceof COSArray) {            fontMatrix = new Matrix((COSArray) base);        } else {            return super.getFontMatrix();        }    }    return fontMatrix;}
public boolean pdfbox_f4906_0()
{        return false;}
public PDResources pdfbox_f4907_0()
{    if (resources == null) {        COSBase base = dict.getDictionaryObject(COSName.RESOURCES);        if (base instanceof COSDictionary) {            this.resources = new PDResources((COSDictionary) base, resourceCache);        }    }    return resources;}
public PDRectangle pdfbox_f4908_0()
{    COSBase base = dict.getDictionaryObject(COSName.FONT_BBOX);    PDRectangle retval = null;    if (base instanceof COSArray) {        retval = new PDRectangle((COSArray) base);    }    return retval;}
public BoundingBox pdfbox_f4909_0()
{    if (fontBBox == null) {        fontBBox = generateBoundingBox();    }    return fontBBox;}
private BoundingBox pdfbox_f4910_1()
{    PDRectangle rect = getFontBBox();    if (!isNonZeroBoundingBox(rect)) {                COSDictionary cp = getCharProcs();        for (COSName name : cp.keySet()) {            COSBase base = cp.getDictionaryObject(name);            if (base instanceof COSStream) {                PDType3CharProc charProc = new PDType3CharProc(this, (COSStream) base);                try {                    PDRectangle glyphBBox = charProc.getGlyphBBox();                    if (glyphBBox == null) {                        continue;                    }                    rect.setLowerLeftX(Math.min(rect.getLowerLeftX(), glyphBBox.getLowerLeftX()));                    rect.setLowerLeftY(Math.min(rect.getLowerLeftY(), glyphBBox.getLowerLeftY()));                    rect.setUpperRightX(Math.max(rect.getUpperRightX(), glyphBBox.getUpperRightX()));                    rect.setUpperRightY(Math.max(rect.getUpperRightY(), glyphBBox.getUpperRightY()));                } catch (IOException ex) {                                                        }            }        }    }    return new BoundingBox(rect.getLowerLeftX(), rect.getLowerLeftY(), rect.getUpperRightX(), rect.getUpperRightY());}
public COSDictionary pdfbox_f4911_0()
{    if (charProcs == null) {        charProcs = (COSDictionary) dict.getDictionaryObject(COSName.CHAR_PROCS);    }    return charProcs;}
public PDType3CharProc pdfbox_f4912_0(int code)
{    String name = getEncoding().getName(code);    COSBase base = getCharProcs().getDictionaryObject(COSName.getPDFName(name));    if (base instanceof COSStream) {        return new PDType3CharProc(this, (COSStream) base);    }    return null;}
private static void pdfbox_f4913_0(String fontName) throws IOException
{    addAFM(fontName, fontName);}
private static void pdfbox_f4914_0(String fontName, String afmName) throws IOException
{    STANDARD_14_NAMES.add(fontName);    STANDARD_14_MAPPING.put(fontName, afmName);    if (STANDARD14_AFM_MAP.containsKey(afmName)) {        STANDARD14_AFM_MAP.put(fontName, STANDARD14_AFM_MAP.get(afmName));    }    String resourceName = "/org/apache/pdfbox/resources/afm/" + afmName + ".afm";    try (InputStream afmStream = PDType1Font.class.getResourceAsStream(resourceName)) {        if (afmStream == null) {            throw new IOException(resourceName + " not found");        }        AFMParser parser = new AFMParser(afmStream);        FontMetrics metric = parser.parse(true);        STANDARD14_AFM_MAP.put(fontName, metric);    }}
public static FontMetrics pdfbox_f4915_0(String baseName)
{    return STANDARD14_AFM_MAP.get(baseName);}
public static boolean pdfbox_f4916_0(String baseName)
{    return STANDARD_14_NAMES.contains(baseName);}
public static Set<String> pdfbox_f4917_0()
{    return Collections.unmodifiableSet(STANDARD_14_NAMES);}
public static String pdfbox_f4918_0(String baseName)
{    return STANDARD_14_MAPPING.get(baseName);}
public void pdfbox_f4919_0(int wMode)
{    this.wMode = wMode;}
public void pdfbox_f4920_0(int cid, String text)
{    if (cid < 0 || cid > 0xFFFF) {        throw new IllegalArgumentException("CID is not valid");    }    if (text == null || text.isEmpty()) {        throw new IllegalArgumentException("Text is null or empty");    }    cidToUnicode.put(cid, text);}
public void pdfbox_f4921_0(OutputStream out) throws IOException
{    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, Charsets.US_ASCII));    writeLine(writer, "/CIDInit /ProcSet findresource begin");    writeLine(writer, "12 dict begin\n");    writeLine(writer, "begincmap");    writeLine(writer, "/CIDSystemInfo");    writeLine(writer, "<< /Registry (Adobe)");    writeLine(writer, "/Ordering (UCS)");    writeLine(writer, "/Supplement 0");    writeLine(writer, ">> def\n");    writeLine(writer, "/CMapName /Adobe-Identity-UCS" + " def");        writeLine(writer, "/CMapType 2 def\n");    if (wMode != 0) {        writeLine(writer, "/WMode /" + wMode + " def");    }        writeLine(writer, "1 begincodespacerange");    writeLine(writer, "<0000> <FFFF>");    writeLine(writer, "endcodespacerange\n");        List<Integer> srcFrom = new ArrayList<>();    List<Integer> srcTo = new ArrayList<>();    List<String> dstString = new ArrayList<>();    int srcPrev = -1;    String dstPrev = "";    int srcCode1 = -1;    for (Map.Entry<Integer, String> entry : cidToUnicode.entrySet()) {        int cid = entry.getKey();        String text = entry.getValue();        if (        cid == srcPrev + 1 &&         dstPrev.codePointCount(0, dstPrev.length()) == 1 &&         text.codePointAt(0) == dstPrev.codePointAt(0) + 1 &&         dstPrev.codePointAt(0) + 1 <= 255 - (cid - srcCode1)) {                        srcTo.set(srcTo.size() - 1, cid);        } else {                        srcCode1 = cid;            srcFrom.add(cid);            srcTo.add(cid);            dstString.add(text);        }        srcPrev = cid;        dstPrev = text;    }        int batchCount = (int) Math.ceil(srcFrom.size() / (double) MAX_ENTRIES_PER_OPERATOR);    for (int batch = 0; batch < batchCount; batch++) {        int count = batch == batchCount - 1 ? srcFrom.size() - MAX_ENTRIES_PER_OPERATOR * batch : MAX_ENTRIES_PER_OPERATOR;        writer.write(count + " beginbfrange\n");        for (int j = 0; j < count; j++) {            int index = batch * MAX_ENTRIES_PER_OPERATOR + j;            writer.write('<');            writer.write(Hex.getChars(srcFrom.get(index).shortValue()));            writer.write("> ");            writer.write('<');            writer.write(Hex.getChars(srcTo.get(index).shortValue()));            writer.write("> ");            writer.write('<');            writer.write(Hex.getCharsUTF16BE(dstString.get(index)));            writer.write(">\n");        }        writeLine(writer, "endbfrange\n");    }        writeLine(writer, "endcmap");    writeLine(writer, "CMapName currentdict /CMap defineresource pop");    writeLine(writer, "end");    writeLine(writer, "end");    writer.flush();}
private void pdfbox_f4922_0(BufferedWriter writer, String text) throws IOException
{    writer.write(text);    writer.write('\n');}
public final void pdfbox_f4923_0(InputStream ttfStream) throws IOException
{    PDStream stream = new PDStream(document, ttfStream, COSName.FLATE_DECODE);        try (InputStream input = stream.createInputStream()) {        ttf = new TTFParser().parseEmbedded(input);        if (!isEmbeddingPermitted(ttf)) {            throw new IOException("This font does not permit embedding");        }        if (fontDescriptor == null) {            fontDescriptor = createFontDescriptor(ttf);        }    }    stream.getCOSObject().setLong(COSName.LENGTH1, ttf.getOriginalDataSize());    fontDescriptor.setFontFile2(stream);}
private boolean pdfbox_f4924_0(TrueTypeFont ttf) throws IOException
{    if (ttf.getOS2Windows() != null) {        int fsType = ttf.getOS2Windows().getFsType();                int exclusive = fsType & 0x8;        if ((exclusive & OS2WindowsMetricsTable.FSTYPE_RESTRICTED) == OS2WindowsMetricsTable.FSTYPE_RESTRICTED) {                        return false;        } else if ((exclusive & OS2WindowsMetricsTable.FSTYPE_BITMAP_ONLY) == OS2WindowsMetricsTable.FSTYPE_BITMAP_ONLY) {                        return false;        }    }    return true;}
private boolean pdfbox_f4925_0(TrueTypeFont ttf) throws IOException
{    if (ttf.getOS2Windows() != null) {        int fsType = ttf.getOS2Windows().getFsType();        if ((fsType & OS2WindowsMetricsTable.FSTYPE_NO_SUBSETTING) == OS2WindowsMetricsTable.FSTYPE_NO_SUBSETTING) {            return false;        }    }    return true;}
private PDFontDescriptor pdfbox_f4926_0(TrueTypeFont ttf) throws IOException
{    PDFontDescriptor fd = new PDFontDescriptor();    fd.setFontName(ttf.getName());    OS2WindowsMetricsTable os2 = ttf.getOS2Windows();    PostScriptTable post = ttf.getPostScript();        fd.setFixedPitch(post.getIsFixedPitch() > 0 || ttf.getHorizontalHeader().getNumberOfHMetrics() == 1);    int fsSelection = os2.getFsSelection();    fd.setItalic(((fsSelection & (ITALIC | OBLIQUE)) != 0));    switch(os2.getFamilyClass()) {        case OS2WindowsMetricsTable.FAMILY_CLASS_CLAREDON_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_FREEFORM_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_MODERN_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_OLDSTYLE_SERIFS:        case OS2WindowsMetricsTable.FAMILY_CLASS_SLAB_SERIFS:            fd.setSerif(true);            break;        case OS2WindowsMetricsTable.FAMILY_CLASS_SCRIPTS:            fd.setScript(true);            break;        default:            break;    }    fd.setFontWeight(os2.getWeightClass());    fd.setSymbolic(true);    fd.setNonSymbolic(false);        fd.setItalicAngle(post.getItalicAngle());        HeaderTable header = ttf.getHeader();    PDRectangle rect = new PDRectangle();    float scaling = 1000f / header.getUnitsPerEm();    rect.setLowerLeftX(header.getXMin() * scaling);    rect.setLowerLeftY(header.getYMin() * scaling);    rect.setUpperRightX(header.getXMax() * scaling);    rect.setUpperRightY(header.getYMax() * scaling);    fd.setFontBoundingBox(rect);        HorizontalHeaderTable hHeader = ttf.getHorizontalHeader();    fd.setAscent(hHeader.getAscender() * scaling);    fd.setDescent(hHeader.getDescender() * scaling);        if (os2.getVersion() >= 1.2) {        fd.setCapHeight(os2.getCapHeight() * scaling);        fd.setXHeight(os2.getHeight() * scaling);    } else {        GeneralPath capHPath = ttf.getPath("H");        if (capHPath != null) {            fd.setCapHeight(Math.round(capHPath.getBounds2D().getMaxY()) * scaling);        } else {                        fd.setCapHeight((os2.getTypoAscender() + os2.getTypoDescender()) * scaling);        }        GeneralPath xPath = ttf.getPath("x");        if (xPath != null) {            fd.setXHeight(Math.round(xPath.getBounds2D().getMaxY()) * scaling);        } else {                        fd.setXHeight(os2.getTypoAscender() / 2.0f * scaling);        }    }        fd.setStemV(fd.getFontBoundingBox().getWidth() * .13f);    return fd;}
public TrueTypeFont pdfbox_f4927_0()
{    return ttf;}
public PDFontDescriptor pdfbox_f4928_0()
{    return fontDescriptor;}
public void pdfbox_f4929_0(int codePoint)
{    subsetCodePoints.add(codePoint);}
public void pdfbox_f4930_0(Set<Integer> glyphIds)
{    allGlyphIds.addAll(glyphIds);}
public void pdfbox_f4931_0() throws IOException
{    if (!isSubsettingPermitted(ttf)) {        throw new IOException("This font does not permit subsetting");    }    if (!embedSubset) {        throw new IllegalStateException("Subsetting is disabled");    }        List<String> tables = new ArrayList<>();    tables.add("head");    tables.add("hhea");    tables.add("loca");    tables.add("maxp");    tables.add("cvt ");    tables.add("prep");    tables.add("glyf");    tables.add("hmtx");    tables.add("fpgm");        tables.add("gasp");        TTFSubsetter subsetter = new TTFSubsetter(ttf, tables);    subsetter.addAll(subsetCodePoints);    if (!allGlyphIds.isEmpty()) {        subsetter.addGlyphIds(allGlyphIds);    }        Map<Integer, Integer> gidToCid = subsetter.getGIDMap();    String tag = getTag(gidToCid);    subsetter.setPrefix(tag);        ByteArrayOutputStream out = new ByteArrayOutputStream();    subsetter.writeToStream(out);        buildSubset(new ByteArrayInputStream(out.toByteArray()), tag, gidToCid);    ttf.close();}
public boolean pdfbox_f4932_0()
{    return embedSubset;}
public String pdfbox_f4933_0(Map<Integer, Integer> gidToCid)
{        long num = gidToCid.hashCode();        StringBuilder sb = new StringBuilder();    do {        long div = num / 25;        int mod = (int) (num % 25);        sb.append(BASE25.charAt(mod));        num = div;    } while (num != 0 && sb.length() < 6);        while (sb.length() < 6) {        sb.insert(0, 'A');    }    sb.append('+');    return sb.toString();}
 static String pdfbox_f4934_0(int codePoint)
{    String hex = Integer.toString(codePoint, 16).toUpperCase(Locale.US);    switch(hex.length()) {        case 1:            return "uni000" + hex;        case 2:            return "uni00" + hex;        case 3:            return "uni0" + hex;        default:            return "uni" + hex;    }}
public static Composite pdfbox_f4935_1(BlendMode blendMode, float constantAlpha)
{    if (constantAlpha < 0) {                constantAlpha = 0;    } else if (constantAlpha > 1) {                constantAlpha = 1;    }    if (blendMode == BlendMode.NORMAL) {        return AlphaComposite.getInstance(AlphaComposite.SRC_OVER, constantAlpha);    } else {        return new BlendComposite(blendMode, constantAlpha);    }}
public CompositeContext pdfbox_f4936_0(ColorModel srcColorModel, ColorModel dstColorModel, RenderingHints hints)
{    return new BlendCompositeContext(srcColorModel, dstColorModel, hints);}
public void pdfbox_f4937_0()
{}
public void pdfbox_f4938_0(Raster src, Raster dstIn, WritableRaster dstOut)
{    int x0 = src.getMinX();    int y0 = src.getMinY();    int width = Math.min(Math.min(src.getWidth(), dstIn.getWidth()), dstOut.getWidth());    int height = Math.min(Math.min(src.getHeight(), dstIn.getHeight()), dstOut.getHeight());    int x1 = x0 + width;    int y1 = y0 + height;    int dstInXShift = dstIn.getMinX() - x0;    int dstInYShift = dstIn.getMinY() - y0;    int dstOutXShift = dstOut.getMinX() - x0;    int dstOutYShift = dstOut.getMinY() - y0;    ColorSpace srcColorSpace = srcColorModel.getColorSpace();    int numSrcColorComponents = srcColorModel.getNumColorComponents();    int numSrcComponents = src.getNumBands();    boolean srcHasAlpha = (numSrcComponents > numSrcColorComponents);    ColorSpace dstColorSpace = dstColorModel.getColorSpace();    int numDstColorComponents = dstColorModel.getNumColorComponents();    int numDstComponents = dstIn.getNumBands();    boolean dstHasAlpha = (numDstComponents > numDstColorComponents);    int srcColorSpaceType = srcColorSpace.getType();    int dstColorSpaceType = dstColorSpace.getType();    boolean subtractive = (dstColorSpaceType != ColorSpace.TYPE_RGB) && (dstColorSpaceType != ColorSpace.TYPE_GRAY);    boolean blendModeIsSeparable = blendMode instanceof SeparableBlendMode;    SeparableBlendMode separableBlendMode = blendModeIsSeparable ? (SeparableBlendMode) blendMode : null;    NonSeparableBlendMode nonSeparableBlendMode = !blendModeIsSeparable ? (NonSeparableBlendMode) blendMode : null;    boolean needsColorConversion = !srcColorSpace.equals(dstColorSpace);    Object srcPixel = null;    Object dstPixel = null;    float[] srcComponents = new float[numSrcComponents];            float[] dstComponents = null;    float[] srcColor = new float[numSrcColorComponents];    float[] srcConverted;    float[] dstConverted;    float[] rgbResult = blendModeIsSeparable ? null : new float[dstHasAlpha ? 4 : 3];    for (int y = y0; y < y1; y++) {        for (int x = x0; x < x1; x++) {            srcPixel = src.getDataElements(x, y, srcPixel);            dstPixel = dstIn.getDataElements(dstInXShift + x, dstInYShift + y, dstPixel);            srcComponents = srcColorModel.getNormalizedComponents(srcPixel, srcComponents, 0);            dstComponents = dstColorModel.getNormalizedComponents(dstPixel, dstComponents, 0);            float srcAlpha = srcHasAlpha ? srcComponents[numSrcColorComponents] : 1.0f;            float dstAlpha = dstHasAlpha ? dstComponents[numDstColorComponents] : 1.0f;            srcAlpha = srcAlpha * constantAlpha;            float resultAlpha = dstAlpha + srcAlpha - srcAlpha * dstAlpha;            float srcAlphaRatio = (resultAlpha > 0) ? srcAlpha / resultAlpha : 0;            if (separableBlendMode != null) {                                System.arraycopy(srcComponents, 0, srcColor, 0, numSrcColorComponents);                if (needsColorConversion) {                                        float[] cieXYZ = srcColorSpace.toCIEXYZ(srcColor);                    srcConverted = dstColorSpace.fromCIEXYZ(cieXYZ);                } else {                    srcConverted = srcColor;                }                for (int k = 0; k < numDstColorComponents; k++) {                    float srcValue = srcConverted[k];                    float dstValue = dstComponents[k];                    if (subtractive) {                        srcValue = 1 - srcValue;                        dstValue = 1 - dstValue;                    }                    float value = separableBlendMode.blendChannel(srcValue, dstValue);                    value = srcValue + dstAlpha * (value - srcValue);                    value = dstValue + srcAlphaRatio * (value - dstValue);                    if (subtractive) {                        value = 1 - value;                    }                    dstComponents[k] = value;                }            } else {                if (srcColorSpaceType == ColorSpace.TYPE_RGB) {                    srcConverted = srcComponents;                } else {                    srcConverted = srcColorSpace.toRGB(srcComponents);                }                if (dstColorSpaceType == ColorSpace.TYPE_RGB) {                    dstConverted = dstComponents;                } else {                    dstConverted = dstColorSpace.toRGB(dstComponents);                }                nonSeparableBlendMode.blend(srcConverted, dstConverted, rgbResult);                for (int k = 0; k < 3; k++) {                    float srcValue = srcConverted[k];                    float dstValue = dstConverted[k];                    float value = rgbResult[k];                    value = Math.max(Math.min(value, 1.0f), 0.0f);                    value = srcValue + dstAlpha * (value - srcValue);                    value = dstValue + srcAlphaRatio * (value - dstValue);                    rgbResult[k] = value;                }                if (dstColorSpaceType == ColorSpace.TYPE_RGB) {                    System.arraycopy(rgbResult, 0, dstComponents, 0, dstComponents.length);                } else {                    float[] temp = dstColorSpace.fromRGB(rgbResult);                    System.arraycopy(temp, 0, dstComponents, 0, Math.min(dstComponents.length, temp.length));                }            }            if (dstHasAlpha) {                dstComponents[numDstColorComponents] = resultAlpha;            }            dstPixel = dstColorModel.getDataElements(dstComponents, 0, dstPixel);            dstOut.setDataElements(dstOutXShift + x, dstOutYShift + y, dstPixel);        }    }}
public float pdfbox_f4939_0(float srcValue, float dstValue)
{    return srcValue;}
public float pdfbox_f4940_0(float srcValue, float dstValue)
{    return srcValue * dstValue;}
public float pdfbox_f4941_0(float srcValue, float dstValue)
{    return srcValue + dstValue - srcValue * dstValue;}
public float pdfbox_f4942_0(float srcValue, float dstValue)
{    return (dstValue <= 0.5) ? 2 * dstValue * srcValue : 2 * (srcValue + dstValue - srcValue * dstValue) - 1;}
public float pdfbox_f4943_0(float srcValue, float dstValue)
{    return Math.min(srcValue, dstValue);}
public float pdfbox_f4944_0(float srcValue, float dstValue)
{    return Math.max(srcValue, dstValue);}
public float pdfbox_f4945_0(float srcValue, float dstValue)
{        if (Float.compare(dstValue, 0) == 0) {        return 0;    }    if (dstValue >= 1 - srcValue) {        return 1;    }    return dstValue / (1 - srcValue);}
public float pdfbox_f4946_0(float srcValue, float dstValue)
{        if (Float.compare(dstValue, 1) == 0) {        return 1;    }    if (1 - dstValue >= srcValue) {        return 0;    }    return 1 - (1 - dstValue) / srcValue;}
public float pdfbox_f4947_0(float srcValue, float dstValue)
{    return (srcValue <= 0.5) ? 2 * dstValue * srcValue : 2 * (srcValue + dstValue - srcValue * dstValue) - 1;}
public float pdfbox_f4948_0(float srcValue, float dstValue)
{    if (srcValue <= 0.5) {        return dstValue - (1 - 2 * srcValue) * dstValue * (1 - dstValue);    } else {        float d = (dstValue <= 0.25) ? ((16 * dstValue - 12) * dstValue + 4) * dstValue : (float) Math.sqrt(dstValue);        return dstValue + (2 * srcValue - 1) * (d - dstValue);    }}
public float pdfbox_f4949_0(float srcValue, float dstValue)
{    return Math.abs(dstValue - srcValue);}
public float pdfbox_f4950_0(float srcValue, float dstValue)
{    return dstValue + srcValue - 2 * dstValue * srcValue;}
public void pdfbox_f4951_0(float[] srcValues, float[] dstValues, float[] result)
{    float[] temp = new float[3];    getSaturationRGB(dstValues, srcValues, temp);    getLuminosityRGB(dstValues, temp, result);}
public void pdfbox_f4952_0(float[] srcValues, float[] dstValues, float[] result)
{    getSaturationRGB(srcValues, dstValues, result);}
public void pdfbox_f4953_0(float[] srcValues, float[] dstValues, float[] result)
{    getLuminosityRGB(dstValues, srcValues, result);}
public void pdfbox_f4954_0(float[] srcValues, float[] dstValues, float[] result)
{    getLuminosityRGB(srcValues, dstValues, result);}
public static BlendMode pdfbox_f4955_0(COSBase cosBlendMode)
{    BlendMode result = null;    if (cosBlendMode instanceof COSName) {        result = BLEND_MODES.get(cosBlendMode);    } else if (cosBlendMode instanceof COSArray) {        COSArray cosBlendModeArray = (COSArray) cosBlendMode;        for (int i = 0; i < cosBlendModeArray.size(); i++) {            result = BLEND_MODES.get(cosBlendModeArray.getObject(i));            if (result != null) {                break;            }        }    }    if (result != null) {        return result;    }    return BlendMode.NORMAL;}
public static COSName pdfbox_f4956_0(BlendMode bm)
{    return BLEND_MODE_NAMES.get(bm);}
private static int pdfbox_f4957_0(float val)
{    return (int) Math.floor(val >= 1.0 ? 255 : val * 255.0);}
private static void pdfbox_f4958_0(float[] srcValues, float[] dstValues, float[] result)
{    int minb;    int maxb;    int mins;    int maxs;    int y;    int scale;    int r;    int g;    int b;    int rd = get255Value(dstValues[0]);    int gd = get255Value(dstValues[1]);    int bd = get255Value(dstValues[2]);    int rs = get255Value(srcValues[0]);    int gs = get255Value(srcValues[1]);    int bs = get255Value(srcValues[2]);    minb = Math.min(rd, Math.min(gd, bd));    maxb = Math.max(rd, Math.max(gd, bd));    if (minb == maxb) {        /* backdrop has zero saturation, avoid divide by 0 */        result[0] = gd / 255.0f;        result[1] = gd / 255.0f;        result[2] = gd / 255.0f;        return;    }    mins = Math.min(rs, Math.min(gs, bs));    maxs = Math.max(rs, Math.max(gs, bs));    scale = ((maxs - mins) << 16) / (maxb - minb);    y = (rd * 77 + gd * 151 + bd * 28 + 0x80) >> 8;    r = y + ((((rd - y) * scale) + 0x8000) >> 16);    g = y + ((((gd - y) * scale) + 0x8000) >> 16);    b = y + ((((bd - y) * scale) + 0x8000) >> 16);    if (((r | g | b) & 0x100) == 0x100) {        int scalemin;        int scalemax;        int min;        int max;        min = Math.min(r, Math.min(g, b));        max = Math.max(r, Math.max(g, b));        if (min < 0) {            scalemin = (y << 16) / (y - min);        } else {            scalemin = 0x10000;        }        if (max > 255) {            scalemax = ((255 - y) << 16) / (max - y);        } else {            scalemax = 0x10000;        }        scale = Math.min(scalemin, scalemax);        r = y + (((r - y) * scale + 0x8000) >> 16);        g = y + (((g - y) * scale + 0x8000) >> 16);        b = y + (((b - y) * scale + 0x8000) >> 16);    }    result[0] = r / 255.0f;    result[1] = g / 255.0f;    result[2] = b / 255.0f;}
private static void pdfbox_f4959_0(float[] srcValues, float[] dstValues, float[] result)
{    int delta;    int scale;    int r;    int g;    int b;    int y;    int rd = get255Value(dstValues[0]);    int gd = get255Value(dstValues[1]);    int bd = get255Value(dstValues[2]);    int rs = get255Value(srcValues[0]);    int gs = get255Value(srcValues[1]);    int bs = get255Value(srcValues[2]);    delta = ((rs - rd) * 77 + (gs - gd) * 151 + (bs - bd) * 28 + 0x80) >> 8;    r = rd + delta;    g = gd + delta;    b = bd + delta;    if (((r | g | b) & 0x100) == 0x100) {        y = (rs * 77 + gs * 151 + bs * 28 + 0x80) >> 8;        if (delta > 0) {            int max;            max = Math.max(r, Math.max(g, b));            scale = max == y ? 0 : ((255 - y) << 16) / (max - y);        } else {            int min;            min = Math.min(r, Math.min(g, b));            scale = y == min ? 0 : (y << 16) / (y - min);        }        r = y + (((r - y) * scale + 0x8000) >> 16);        g = y + (((g - y) * scale + 0x8000) >> 16);        b = y + (((b - y) * scale + 0x8000) >> 16);    }    result[0] = r / 255.0f;    result[1] = g / 255.0f;    result[2] = b / 255.0f;}
private static Map<COSName, BlendMode> pdfbox_f4960_0()
{    Map<COSName, BlendMode> map = new HashMap<>(13);    map.put(COSName.NORMAL, BlendMode.NORMAL);        map.put(COSName.COMPATIBLE, BlendMode.NORMAL);    map.put(COSName.MULTIPLY, BlendMode.MULTIPLY);    map.put(COSName.SCREEN, BlendMode.SCREEN);    map.put(COSName.OVERLAY, BlendMode.OVERLAY);    map.put(COSName.DARKEN, BlendMode.DARKEN);    map.put(COSName.LIGHTEN, BlendMode.LIGHTEN);    map.put(COSName.COLOR_DODGE, BlendMode.COLOR_DODGE);    map.put(COSName.COLOR_BURN, BlendMode.COLOR_BURN);    map.put(COSName.HARD_LIGHT, BlendMode.HARD_LIGHT);    map.put(COSName.SOFT_LIGHT, BlendMode.SOFT_LIGHT);    map.put(COSName.DIFFERENCE, BlendMode.DIFFERENCE);    map.put(COSName.EXCLUSION, BlendMode.EXCLUSION);    map.put(COSName.HUE, BlendMode.HUE);    map.put(COSName.SATURATION, BlendMode.SATURATION);    map.put(COSName.LUMINOSITY, BlendMode.LUMINOSITY);    map.put(COSName.COLOR, BlendMode.COLOR);    return map;}
private static Map<BlendMode, COSName> pdfbox_f4961_0()
{    Map<BlendMode, COSName> map = new HashMap<>(13);    map.put(BlendMode.NORMAL, COSName.NORMAL);        map.put(BlendMode.COMPATIBLE, COSName.NORMAL);    map.put(BlendMode.MULTIPLY, COSName.MULTIPLY);    map.put(BlendMode.SCREEN, COSName.SCREEN);    map.put(BlendMode.OVERLAY, COSName.OVERLAY);    map.put(BlendMode.DARKEN, COSName.DARKEN);    map.put(BlendMode.LIGHTEN, COSName.LIGHTEN);    map.put(BlendMode.COLOR_DODGE, COSName.COLOR_DODGE);    map.put(BlendMode.COLOR_BURN, COSName.COLOR_BURN);    map.put(BlendMode.HARD_LIGHT, COSName.HARD_LIGHT);    map.put(BlendMode.SOFT_LIGHT, COSName.SOFT_LIGHT);    map.put(BlendMode.DIFFERENCE, COSName.DIFFERENCE);    map.put(BlendMode.EXCLUSION, COSName.EXCLUSION);    map.put(BlendMode.HUE, COSName.HUE);    map.put(BlendMode.SATURATION, COSName.SATURATION);    map.put(BlendMode.LUMINOSITY, COSName.LUMINOSITY);    map.put(BlendMode.COLOR, COSName.COLOR);    return map;}
public String pdfbox_f4962_0()
{    return COSName.CALGRAY.getName();}
public int pdfbox_f4963_0()
{    return 1;}
public float[] pdfbox_f4964_0(int bitsPerComponent)
{    return new float[] { 0, 1 };}
public PDColor pdfbox_f4965_0()
{    return initialColor;}
public float[] pdfbox_f4966_0(float[] value)
{        if (isWhitePoint()) {        float a = value[0];        float[] result = map1.get(a);        if (result != null) {            return result.clone();        }        float gamma = getGamma();        float powAG = (float) Math.pow(a, gamma);        result = convXYZtoRGB(powAG, powAG, powAG);        map1.put(a, result.clone());        return result;    } else {        return new float[] { value[0], value[0], value[0] };    }}
public float pdfbox_f4967_0()
{    float retval = 1.0f;    COSNumber gamma = (COSNumber) dictionary.getDictionaryObject(COSName.GAMMA);    if (gamma != null) {        retval = gamma.floatValue();    }    return retval;}
public void pdfbox_f4968_0(float value)
{    dictionary.setItem(COSName.GAMMA, new COSFloat(value));}
public String pdfbox_f4969_0()
{    return COSName.CALRGB.getName();}
public int pdfbox_f4970_0()
{    return 3;}
public float[] pdfbox_f4971_0(int bitsPerComponent)
{    return new float[] { 0, 1, 0, 1, 0, 1 };}
public PDColor pdfbox_f4972_0()
{    return initialColor;}
public float[] pdfbox_f4973_0(float[] value)
{    if (isWhitePoint()) {        float a = value[0];        float b = value[1];        float c = value[2];        PDGamma gamma = getGamma();        float powAR = (float) Math.pow(a, gamma.getR());        float powBG = (float) Math.pow(b, gamma.getG());        float powCB = (float) Math.pow(c, gamma.getB());        float[] matrix = getMatrix();        float mXA = matrix[0];        float mYA = matrix[1];        float mZA = matrix[2];        float mXB = matrix[3];        float mYB = matrix[4];        float mZB = matrix[5];        float mXC = matrix[6];        float mYC = matrix[7];        float mZC = matrix[8];        float x = mXA * powAR + mXB * powBG + mXC * powCB;        float y = mYA * powAR + mYB * powBG + mYC * powCB;        float z = mZA * powAR + mZB * powBG + mZC * powCB;        return convXYZtoRGB(x, y, z);    } else {                return new float[] { value[0], value[1], value[2] };    }}
public final PDGamma pdfbox_f4974_0()
{    COSArray gammaArray = (COSArray) dictionary.getDictionaryObject(COSName.GAMMA);    if (gammaArray == null) {        gammaArray = new COSArray();        gammaArray.add(new COSFloat(1.0f));        gammaArray.add(new COSFloat(1.0f));        gammaArray.add(new COSFloat(1.0f));        dictionary.setItem(COSName.GAMMA, gammaArray);    }    return new PDGamma(gammaArray);}
public final float[] pdfbox_f4975_0()
{    COSArray matrix = (COSArray) dictionary.getDictionaryObject(COSName.MATRIX);    if (matrix == null) {        return new float[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 };    } else {        return matrix.toFloatArray();    }}
public final void pdfbox_f4976_0(PDGamma gamma)
{    COSArray gammaArray = null;    if (gamma != null) {        gammaArray = gamma.getCOSArray();    }    dictionary.setItem(COSName.GAMMA, gammaArray);}
public final void pdfbox_f4977_0(Matrix matrix)
{    COSArray matrixArray = null;    if (matrix != null) {                float[][] values = matrix.getValues();        matrixArray = new COSArray();        matrixArray.add(new COSFloat(values[0][0]));        matrixArray.add(new COSFloat(values[0][1]));        matrixArray.add(new COSFloat(values[0][2]));        matrixArray.add(new COSFloat(values[1][0]));        matrixArray.add(new COSFloat(values[1][1]));        matrixArray.add(new COSFloat(values[1][2]));        matrixArray.add(new COSFloat(values[2][0]));        matrixArray.add(new COSFloat(values[2][1]));        matrixArray.add(new COSFloat(values[2][2]));    }    dictionary.setItem(COSName.MATRIX, matrixArray);}
public BufferedImage pdfbox_f4978_0(WritableRaster raster) throws IOException
{                int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();        float[] abc = new float[3];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, abc);                        abc[0] /= 255;            abc[1] /= 255;            abc[2] /= 255;            float[] rgb = toRGB(abc);                        rgb[0] *= 255;            rgb[1] *= 255;            rgb[2] *= 255;            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
public String pdfbox_f4979_0()
{        return getName();}
protected boolean pdfbox_f4980_0()
{    return Float.compare(wpX, 1) == 0 && Float.compare(wpY, 1) == 0 && Float.compare(wpZ, 1) == 0;}
private void pdfbox_f4981_0(PDTristimulus whitepoint)
{    wpX = whitepoint.getX();    wpY = whitepoint.getY();    wpZ = whitepoint.getZ();}
protected float[] pdfbox_f4982_0(float x, float y, float z)
{        if (x < 0) {        x = 0;    }    if (y < 0) {        y = 0;    }    if (z < 0) {        z = 0;    }    return CIEXYZ.toRGB(new float[] { x, y, z });}
public final PDTristimulus pdfbox_f4983_0()
{    COSArray wp = (COSArray) dictionary.getDictionaryObject(COSName.WHITE_POINT);    if (wp == null) {        wp = new COSArray();        wp.add(new COSFloat(1.0f));        wp.add(new COSFloat(1.0f));        wp.add(new COSFloat(1.0f));    }    return new PDTristimulus(wp);}
public final PDTristimulus pdfbox_f4984_0()
{    COSArray bp = (COSArray) dictionary.getDictionaryObject(COSName.BLACK_POINT);    if (bp == null) {        bp = new COSArray();        bp.add(new COSFloat(0.0f));        bp.add(new COSFloat(0.0f));        bp.add(new COSFloat(0.0f));    }    return new PDTristimulus(bp);}
public void pdfbox_f4985_0(PDTristimulus whitepoint)
{    COSBase wpArray = whitepoint.getCOSObject();    if (wpArray != null) {        dictionary.setItem(COSName.WHITE_POINT, wpArray);    }    fillWhitepointCache(whitepoint);}
public void pdfbox_f4986_0(PDTristimulus blackpoint)
{    COSBase bpArray = null;    if (blackpoint != null) {        bpArray = blackpoint.getCOSObject();    }    dictionary.setItem(COSName.BLACK_POINT, bpArray);}
public float[] pdfbox_f4987_0()
{    if (colorSpace instanceof PDPattern || colorSpace == null) {                return components.clone();    }        return Arrays.copyOf(components, colorSpace.getNumberOfComponents());}
public COSName pdfbox_f4988_0()
{    return patternName;}
public boolean pdfbox_f4989_0()
{    return patternName != null;}
public int pdfbox_f4990_0() throws IOException
{    float[] floats = colorSpace.toRGB(components);    int r = Math.round(floats[0] * 255);    int g = Math.round(floats[1] * 255);    int b = Math.round(floats[2] * 255);    int rgb = r;    rgb = (rgb << 8) + g;    rgb = (rgb << 8) + b;    return rgb;}
public COSArray pdfbox_f4991_0()
{    COSArray array = new COSArray();    array.setFloatArray(components);    if (patternName != null) {        array.add(patternName);    }    return array;}
public PDColorSpace pdfbox_f4992_0()
{    return colorSpace;}
public String pdfbox_f4993_0()
{    return "PDColor{components=" + Arrays.toString(components) + ", patternName=" + patternName + ", colorSpace=" + colorSpace + '}';}
public static PDColorSpace pdfbox_f4994_0(COSBase colorSpace) throws IOException
{    return create(colorSpace, null);}
public static PDColorSpace pdfbox_f4995_0(COSBase colorSpace, PDResources resources) throws IOException
{    return create(colorSpace, resources, false);}
public static PDColorSpace pdfbox_f4996_0(COSBase colorSpace, PDResources resources, boolean wasDefault) throws IOException
{    if (colorSpace instanceof COSObject) {        return createFromCOSObject((COSObject) colorSpace, resources);    } else if (colorSpace instanceof COSName) {        COSName name = (COSName) colorSpace;                if (resources != null) {            COSName defaultName = null;            if (name.equals(COSName.DEVICECMYK) && resources.hasColorSpace(COSName.DEFAULT_CMYK)) {                defaultName = COSName.DEFAULT_CMYK;            } else if (name.equals(COSName.DEVICERGB) && resources.hasColorSpace(COSName.DEFAULT_RGB)) {                defaultName = COSName.DEFAULT_RGB;            } else if (name.equals(COSName.DEVICEGRAY) && resources.hasColorSpace(COSName.DEFAULT_GRAY)) {                defaultName = COSName.DEFAULT_GRAY;            }            if (resources.hasColorSpace(defaultName) && !wasDefault) {                return resources.getColorSpace(defaultName, true);            }        }                if (name == COSName.DEVICECMYK) {            return PDDeviceCMYK.INSTANCE;        } else if (name == COSName.DEVICERGB) {            return PDDeviceRGB.INSTANCE;        } else if (name == COSName.DEVICEGRAY) {            return PDDeviceGray.INSTANCE;        } else if (name == COSName.PATTERN) {            return new PDPattern(resources);        } else if (resources != null) {            if (!resources.hasColorSpace(name)) {                throw new MissingResourceException("Missing color space: " + name.getName());            }            return resources.getColorSpace(name);        } else {            throw new MissingResourceException("Unknown color space: " + name.getName());        }    } else if (colorSpace instanceof COSArray) {        COSArray array = (COSArray) colorSpace;        if (array.size() == 0) {            throw new IOException("Colorspace array is empty");        }        COSBase base = array.getObject(0);        if (!(base instanceof COSName)) {            throw new IOException("First element in colorspace array must be a name");        }        COSName name = (COSName) base;        if (name == COSName.CALGRAY) {            return new PDCalGray(array);        } else if (name == COSName.CALRGB) {            return new PDCalRGB(array);        } else if (name == COSName.DEVICEN) {            return new PDDeviceN(array);        } else if (name == COSName.INDEXED) {            return new PDIndexed(array, resources);        } else if (name == COSName.SEPARATION) {            return new PDSeparation(array);        } else if (name == COSName.ICCBASED) {            return PDICCBased.create(array, resources);        } else if (name == COSName.LAB) {            return new PDLab(array);        } else if (name == COSName.PATTERN) {            if (array.size() == 1) {                return new PDPattern(resources);            } else {                return new PDPattern(resources, PDColorSpace.create(array.get(1)));            }        } else if (name == COSName.DEVICECMYK || name == COSName.DEVICERGB || name == COSName.DEVICEGRAY) {                        return create(name, resources, wasDefault);        } else {            throw new IOException("Invalid color space kind: " + name);        }    } else {        throw new IOException("Expected a name or array but got: " + colorSpace);    }}
private static PDColorSpace pdfbox_f4997_0(COSObject colorSpace, PDResources resources) throws IOException
{    PDColorSpace cs;    if (resources != null && resources.getResourceCache() != null) {        ResourceCache resourceCache = resources.getResourceCache();        cs = resourceCache.getColorSpace(colorSpace);        if (cs != null) {            return cs;        }    }    cs = create(colorSpace.getObject(), resources);    if (resources != null && resources.getResourceCache() != null && cs != null) {        ResourceCache resourceCache = resources.getResourceCache();        resourceCache.put(colorSpace, cs);    }    return cs;}
protected BufferedImage pdfbox_f4998_0(WritableRaster raster, ColorSpace colorSpace)
{                    ColorModel colorModel = new ComponentColorModel(colorSpace, false, false, Transparency.OPAQUE, raster.getDataBuffer().getDataType());    BufferedImage src = new BufferedImage(colorModel, raster, false, null);    BufferedImage dest = new BufferedImage(raster.getWidth(), raster.getHeight(), BufferedImage.TYPE_INT_RGB);    ColorConvertOp op = new ColorConvertOp(null);    op.filter(src, dest);    return dest;}
public COSBase pdfbox_f4999_0()
{    return array;}
protected void pdfbox_f5000_0() throws IOException
{        if (awtColorSpace != null) {        return;    }    synchronized (this) {                if (awtColorSpace != null) {            return;        }                ICC_Profile iccProfile = getICCProfile();        if (iccProfile == null) {            throw new IOException("Default CMYK color profile could not be loaded");        }        awtColorSpace = new ICC_ColorSpace(iccProfile);                                awtColorSpace.toRGB(new float[] { 0, 0, 0, 0 });        usePureJavaCMYKConversion = System.getProperty("org.apache.pdfbox.rendering.UsePureJavaCMYKConversion") != null;    }}
protected ICC_Profile pdfbox_f5001_0() throws IOException
{                    String name = "/org/apache/pdfbox/resources/icc/ISOcoated_v2_300_bas.icc";    try (InputStream is = PDDeviceCMYK.class.getResourceAsStream(name)) {        if (is == null) {            throw new IOException("Error loading resource: " + name);        }        return ICC_Profile.getInstance(is);    }}
public String pdfbox_f5002_0()
{    return COSName.DEVICECMYK.getName();}
public int pdfbox_f5003_0()
{    return 4;}
public float[] pdfbox_f5004_0(int bitsPerComponent)
{    return new float[] { 0, 1, 0, 1, 0, 1, 0, 1 };}
public PDColor pdfbox_f5005_0()
{    return initialColor;}
public float[] pdfbox_f5006_0(float[] value) throws IOException
{    init();    return awtColorSpace.toRGB(value);}
public BufferedImage pdfbox_f5007_0(WritableRaster raster) throws IOException
{    init();    return toRGBImageAWT(raster, awtColorSpace);}
protected BufferedImage pdfbox_f5008_0(WritableRaster raster, ColorSpace colorSpace)
{    if (usePureJavaCMYKConversion) {        BufferedImage dest = new BufferedImage(raster.getWidth(), raster.getHeight(), BufferedImage.TYPE_INT_RGB);        ColorSpace destCS = dest.getColorModel().getColorSpace();        WritableRaster destRaster = dest.getRaster();        float[] srcValues = new float[4];        float[] lastValues = new float[] { -1.0f, -1.0f, -1.0f, -1.0f };        float[] destValues = new float[3];        int width = raster.getWidth();        int startX = raster.getMinX();        int height = raster.getHeight();        int startY = raster.getMinY();        for (int x = startX; x < width + startX; x++) {            for (int y = startY; y < height + startY; y++) {                raster.getPixel(x, y, srcValues);                                if (!Arrays.equals(lastValues, srcValues)) {                    for (int k = 0; k < 4; k++) {                        lastValues[k] = srcValues[k];                        srcValues[k] = srcValues[k] / 255f;                    }                                        destValues = destCS.fromCIEXYZ(colorSpace.toCIEXYZ(srcValues));                    for (int k = 0; k < destValues.length; k++) {                        destValues[k] = destValues[k] * 255f;                    }                }                destRaster.setPixel(x, y, destValues);            }        }        return dest;    } else {        return super.toRGBImageAWT(raster, colorSpace);    }}
public String pdfbox_f5009_0()
{    return getName();}
public COSBase pdfbox_f5010_0()
{    return COSName.getPDFName(getName());}
public String pdfbox_f5011_0()
{    return COSName.DEVICEGRAY.getName();}
public int pdfbox_f5012_0()
{    return 1;}
public float[] pdfbox_f5013_0(int bitsPerComponent)
{    return new float[] { 0, 1 };}
public PDColor pdfbox_f5014_0()
{    return initialColor;}
public float[] pdfbox_f5015_0(float[] value)
{    return new float[] { value[0], value[0], value[0] };}
public BufferedImage pdfbox_f5016_0(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    int[] gray = new int[1];    int[] rgb = new int[3];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, gray);            rgb[0] = gray[0];            rgb[1] = gray[0];            rgb[2] = gray[0];            image.getRaster().setPixel(x, y, rgb);        }    }    return image;}
private void pdfbox_f5017_0() throws IOException
{        if (attributes == null) {        return;    }        List<String> colorantNames = getColorantNames();    numColorants = colorantNames.size();        colorantToComponent = new int[numColorants];    for (int c = 0; c < numColorants; c++) {        colorantToComponent[c] = -1;    }    if (attributes.getProcess() != null) {        List<String> components = attributes.getProcess().getComponents();                for (int c = 0; c < numColorants; c++) {            colorantToComponent[c] = components.indexOf(colorantNames.get(c));        }                processColorSpace = attributes.getProcess().getColorSpace();    }        spotColorSpaces = new PDSeparation[numColorants];        Map<String, PDSeparation> spotColorants = attributes.getColorants();        for (int c = 0; c < numColorants; c++) {        String name = colorantNames.get(c);        PDSeparation spot = spotColorants.get(name);        if (spot != null) {                        spotColorSpaces[c] = spot;                        if (!isNChannel()) {                colorantToComponent[c] = -1;            }        } else {                        spotColorSpaces[c] = null;        }    }}
public BufferedImage pdfbox_f5018_0(WritableRaster raster) throws IOException
{    if (attributes != null) {        return toRGBWithAttributes(raster);    } else {        return toRGBWithTintTransform(raster);    }}
private BufferedImage pdfbox_f5019_0(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();        Graphics2D g = rgbImage.createGraphics();    g.setBackground(Color.WHITE);    g.clearRect(0, 0, width, height);    g.dispose();        for (int c = 0; c < numColorants; c++) {        PDColorSpace componentColorSpace;        if (colorantToComponent[c] >= 0) {                        componentColorSpace = processColorSpace;        } else if (spotColorSpaces[c] == null) {                        return toRGBWithTintTransform(raster);        } else {                        componentColorSpace = spotColorSpaces[c];        }                WritableRaster componentRaster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, width, height, componentColorSpace.getNumberOfComponents(), new Point(0, 0));        int[] samples = new int[numColorants];        int[] componentSamples = new int[componentColorSpace.getNumberOfComponents()];        boolean isProcessColorant = colorantToComponent[c] >= 0;        int componentIndex = colorantToComponent[c];        for (int y = 0; y < height; y++) {            for (int x = 0; x < width; x++) {                raster.getPixel(x, y, samples);                if (isProcessColorant) {                                        componentSamples[componentIndex] = samples[c];                } else {                                        componentSamples[0] = samples[c];                }                componentRaster.setPixel(x, y, componentSamples);            }        }                BufferedImage rgbComponentImage = componentColorSpace.toRGBImage(componentRaster);        WritableRaster rgbComponentRaster = rgbComponentImage.getRaster();                int[] rgbChannel = new int[3];        int[] rgbComposite = new int[3];        for (int y = 0; y < height; y++) {            for (int x = 0; x < width; x++) {                rgbComponentRaster.getPixel(x, y, rgbChannel);                rgbRaster.getPixel(x, y, rgbComposite);                                rgbChannel[0] = rgbChannel[0] * rgbComposite[0] >> 8;                rgbChannel[1] = rgbChannel[1] * rgbComposite[1] >> 8;                rgbChannel[2] = rgbChannel[2] * rgbComposite[2] >> 8;                rgbRaster.setPixel(x, y, rgbChannel);            }        }    }    return rgbImage;}
private BufferedImage pdfbox_f5020_0(WritableRaster raster) throws IOException
{        Map<String, int[]> map1 = new HashMap<>();    String key;    int width = raster.getWidth();    int height = raster.getHeight();            BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    int[] rgb = new int[3];    int numSrcComponents = getColorantNames().size();    float[] src = new float[numSrcComponents];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, src);                        key = Float.toString(src[0]);            for (int s = 1; s < numSrcComponents; s++) {                key += "#" + Float.toString(src[s]);            }            int[] pxl = map1.get(key);            if (pxl != null) {                rgbRaster.setPixel(x, y, pxl);                continue;            }                        for (int s = 0; s < numSrcComponents; s++) {                src[s] = src[s] / 255;            }                        float[] result = tintTransform.eval(src);                        float[] rgbFloat = alternateColorSpace.toRGB(result);            for (int s = 0; s < 3; s++) {                                rgb[s] = (int) (rgbFloat[s] * 255f);            }                        map1.put(key, rgb.clone());            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
public float[] pdfbox_f5021_0(float[] value) throws IOException
{    if (attributes != null) {        return toRGBWithAttributes(value);    } else {        return toRGBWithTintTransform(value);    }}
private float[] pdfbox_f5022_0(float[] value) throws IOException
{    float[] rgbValue = new float[] { 1, 1, 1 };        for (int c = 0; c < numColorants; c++) {        PDColorSpace componentColorSpace;        if (colorantToComponent[c] >= 0) {                        componentColorSpace = processColorSpace;        } else if (spotColorSpaces[c] == null) {                        return toRGBWithTintTransform(value);        } else {                        componentColorSpace = spotColorSpaces[c];        }                boolean isProcessColorant = colorantToComponent[c] >= 0;        float[] componentSamples = new float[componentColorSpace.getNumberOfComponents()];        int componentIndex = colorantToComponent[c];        if (isProcessColorant) {                        componentSamples[componentIndex] = value[c];        } else {                        componentSamples[0] = value[c];        }                float[] rgbComponent = componentColorSpace.toRGB(componentSamples);                        rgbValue[0] *= rgbComponent[0];        rgbValue[1] *= rgbComponent[1];        rgbValue[2] *= rgbComponent[2];    }    return rgbValue;}
private float[] pdfbox_f5023_0(float[] value) throws IOException
{            float[] altValue = tintTransform.eval(value);        return alternateColorSpace.toRGB(altValue);}
public boolean pdfbox_f5024_0()
{    return attributes != null && attributes.isNChannel();}
public String pdfbox_f5025_0()
{    return COSName.DEVICEN.getName();}
public final int pdfbox_f5026_0()
{    return getColorantNames().size();}
public float[] pdfbox_f5027_0(int bitsPerComponent)
{    int n = getNumberOfComponents();    float[] decode = new float[n * 2];    for (int i = 0; i < n; i++) {        decode[i * 2 + 1] = 1;    }    return decode;}
public PDColor pdfbox_f5028_0()
{    return initialColor;}
public List<String> pdfbox_f5029_0()
{    COSArray names = (COSArray) array.getObject(COLORANT_NAMES);    return COSArrayList.convertCOSNameCOSArrayToList(names);}
public PDDeviceNAttributes pdfbox_f5030_0()
{    return attributes;}
public void pdfbox_f5031_0(List<String> names)
{    COSArray namesArray = COSArrayList.convertStringListToCOSNameCOSArray(names);    array.set(COLORANT_NAMES, namesArray);}
public void pdfbox_f5032_0(PDDeviceNAttributes attributes)
{    this.attributes = attributes;    if (attributes == null) {        array.remove(DEVICEN_ATTRIBUTES);    } else {                while (array.size() <= DEVICEN_ATTRIBUTES) {            array.add(COSNull.NULL);        }        array.set(DEVICEN_ATTRIBUTES, attributes.getCOSDictionary());    }}
public PDColorSpace pdfbox_f5033_0() throws IOException
{    if (alternateColorSpace == null) {        alternateColorSpace = PDColorSpace.create(array.getObject(ALTERNATE_CS));    }    return alternateColorSpace;}
public void pdfbox_f5034_0(PDColorSpace cs)
{    alternateColorSpace = cs;    COSBase space = null;    if (cs != null) {        space = cs.getCOSObject();    }    array.set(ALTERNATE_CS, space);}
public PDFunction pdfbox_f5035_0() throws IOException
{    if (tintTransform == null) {        tintTransform = PDFunction.create(array.getObject(TINT_TRANSFORM));    }    return tintTransform;}
public void pdfbox_f5036_0(PDFunction tint)
{    tintTransform = tint;    array.set(TINT_TRANSFORM, tint);}
public String pdfbox_f5037_0()
{    StringBuilder sb = new StringBuilder(getName());    sb.append('{');    for (String col : getColorantNames()) {        sb.append('\"');        sb.append(col);        sb.append("\" ");    }    sb.append(alternateColorSpace.getName());    sb.append(' ');    sb.append(tintTransform);    sb.append(' ');    if (attributes != null) {        sb.append(attributes);    }    sb.append('}');    return sb.toString();}
public COSDictionary pdfbox_f5038_0()
{    return dictionary;}
public Map<String, PDSeparation> pdfbox_f5039_0() throws IOException
{    Map<String, PDSeparation> actuals = new HashMap<>();    COSDictionary colorants = dictionary.getCOSDictionary(COSName.COLORANTS);    if (colorants == null) {        colorants = new COSDictionary();        dictionary.setItem(COSName.COLORANTS, colorants);    }    for (COSName name : colorants.keySet()) {        COSBase value = colorants.getDictionaryObject(name);        actuals.put(name.getName(), (PDSeparation) PDColorSpace.create(value));    }    return new COSDictionaryMap<>(actuals, colorants);}
public PDDeviceNProcess pdfbox_f5040_0()
{    COSDictionary process = dictionary.getCOSDictionary(COSName.PROCESS);    if (process == null) {        return null;    }    return new PDDeviceNProcess(process);}
public boolean pdfbox_f5041_0()
{    return "NChannel".equals(dictionary.getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f5042_0(Map<String, PDColorSpace> colorants)
{    COSDictionary colorantDict = null;    if (colorants != null) {        colorantDict = COSDictionaryMap.convert(colorants);    }    dictionary.setItem(COSName.COLORANTS, colorantDict);}
public String pdfbox_f5043_1()
{    StringBuilder sb = new StringBuilder(dictionary.getNameAsString(COSName.SUBTYPE));    sb.append('{');    PDDeviceNProcess process = getProcess();    if (process != null) {        sb.append(getProcess());        sb.append(' ');    }    Map<String, PDSeparation> colorants;    try {        colorants = getColorants();        sb.append("Colorants{");        for (Map.Entry<String, PDSeparation> col : colorants.entrySet()) {            sb.append('\"');            sb.append(col.getKey());            sb.append("\": ");            sb.append(col.getValue());            sb.append(' ');        }        sb.append('}');    } catch (IOException e) {                sb.append("ERROR");    }    sb.append('}');    return sb.toString();}
public COSDictionary pdfbox_f5044_0()
{    return dictionary;}
public PDColorSpace pdfbox_f5045_0() throws IOException
{    COSBase cosColorSpace = dictionary.getDictionaryObject(COSName.COLORSPACE);    if (cosColorSpace == null) {                return null;    }    return PDColorSpace.create(cosColorSpace);}
public List<String> pdfbox_f5046_0()
{    List<String> components = new ArrayList<>();    COSArray cosComponents = (COSArray) dictionary.getDictionaryObject(COSName.COMPONENTS);    if (cosComponents == null) {        return components;    }    for (COSBase name : cosComponents) {        components.add(((COSName) name).getName());    }    return components;}
public String pdfbox_f5047_1()
{    StringBuilder sb = new StringBuilder("Process{");    try {        sb.append(getColorSpace());        for (String component : getComponents()) {            sb.append(" \"");            sb.append(component);            sb.append('\"');        }    } catch (IOException e) {                sb.append("ERROR");    }    sb.append('}');    return sb.toString();}
private void pdfbox_f5048_0()
{        if (awtColorSpace != null) {        return;    }    synchronized (this) {                if (awtColorSpace != null) {            return;        }        awtColorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB);                                awtColorSpace.toRGB(new float[] { 0, 0, 0, 0 });    }}
public String pdfbox_f5049_0()
{    return COSName.DEVICERGB.getName();}
public int pdfbox_f5050_0()
{    return 3;}
public float[] pdfbox_f5051_0(int bitsPerComponent)
{    return new float[] { 0, 1, 0, 1, 0, 1 };}
public PDColor pdfbox_f5052_0()
{    return initialColor;}
public float[] pdfbox_f5053_0(float[] value)
{    return value;}
public BufferedImage pdfbox_f5054_0(WritableRaster raster) throws IOException
{    init();                            BufferedImage image = new BufferedImage(raster.getWidth(), raster.getHeight(), BufferedImage.TYPE_INT_RGB);    image.setData(raster);    return image;}
public COSBase pdfbox_f5055_0()
{    return values;}
public COSArray pdfbox_f5056_0()
{    return values;}
public float pdfbox_f5057_0()
{    return ((COSNumber) values.get(0)).floatValue();}
public void pdfbox_f5058_0(float r)
{    values.set(0, new COSFloat(r));}
public float pdfbox_f5059_0()
{    return ((COSNumber) values.get(1)).floatValue();}
public void pdfbox_f5060_0(float g)
{    values.set(1, new COSFloat(g));}
public float pdfbox_f5061_0()
{    return ((COSNumber) values.get(2)).floatValue();}
public void pdfbox_f5062_0(float b)
{    values.set(2, new COSFloat(b));}
public static PDICCBased pdfbox_f5063_0(COSArray iccArray, PDResources resources) throws IOException
{    checkArray(iccArray);    COSBase base = iccArray.get(1);    COSObject indirect = null;    if (base instanceof COSObject) {        indirect = (COSObject) base;    }    if (indirect != null && resources != null && resources.getResourceCache() != null) {        PDColorSpace space = resources.getResourceCache().getColorSpace(indirect);        if (space != null && space instanceof PDICCBased) {            return (PDICCBased) space;        }    }    PDICCBased space = new PDICCBased(iccArray);    if (indirect != null && resources != null && resources.getResourceCache() != null) {        resources.getResourceCache().put(indirect, space);    }    return space;}
private static void pdfbox_f5064_0(COSArray iccArray) throws IOException
{    if (iccArray.size() < 2) {        throw new IOException("ICCBased colorspace array must have two elements");    }    if (!(iccArray.getObject(1) instanceof COSStream)) {        throw new IOException("ICCBased colorspace array must have a stream as second element");    }}
public String pdfbox_f5065_0()
{    return COSName.ICCBASED.getName();}
public PDStream pdfbox_f5066_0()
{    return stream;}
private void pdfbox_f5067_1() throws IOException
{    if (useOnlyAlternateColorSpace) {        try {            fallbackToAlternateColorSpace(null);            return;        } catch (IOException e) {                    }    }    try (InputStream input = this.stream.createInputStream()) {                        ICC_Profile profile;        synchronized (LOG) {            profile = ICC_Profile.getInstance(input);            if (is_sRGB(profile)) {                isRGB = true;                awtColorSpace = (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_sRGB);                iccProfile = awtColorSpace.getProfile();            } else {                profile = ensureDisplayProfile(profile);                awtColorSpace = new ICC_ColorSpace(profile);                iccProfile = profile;            }                        float[] initial = new float[getNumberOfComponents()];            for (int c = 0; c < getNumberOfComponents(); c++) {                initial[c] = Math.max(0, getRangeForComponent(c).getMin());            }            initialColor = new PDColor(initial, this);            if (IS_KCMS) {                                                                                new Color(awtColorSpace, new float[getNumberOfComponents()], 1f);            } else {                                new ComponentColorModel(awtColorSpace, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);            }        }    } catch (ProfileDataException | CMMException | IllegalArgumentException | ArrayIndexOutOfBoundsException | IOException e) {        fallbackToAlternateColorSpace(e);    }}
private void pdfbox_f5068_1(Exception e) throws IOException
{    awtColorSpace = null;    alternateColorSpace = getAlternateColorSpace();    if (alternateColorSpace.equals(PDDeviceRGB.INSTANCE)) {        isRGB = true;    }    if (e != null) {            }    initialColor = alternateColorSpace.getInitialColor();}
private boolean pdfbox_f5069_0(ICC_Profile profile)
{    byte[] bytes = Arrays.copyOfRange(profile.getData(ICC_Profile.icSigHead), ICC_Profile.icHdrModel, ICC_Profile.icHdrModel + 7);    String deviceModel = new String(bytes, Charsets.US_ASCII).trim();    return deviceModel.equals("sRGB");}
private static ICC_Profile pdfbox_f5070_1(ICC_Profile profile)
{    if (profile.getProfileClass() != ICC_Profile.CLASS_DISPLAY) {                byte[] profileData = profile.getData();        if (profileData[ICC_Profile.icHdrRenderingIntent] == ICC_Profile.icPerceptual) {                        intToBigEndian(ICC_Profile.icSigDisplayClass, profileData, ICC_Profile.icHdrDeviceClass);            return ICC_Profile.getInstance(profileData);        }    }    return profile;}
private static void pdfbox_f5071_0(int value, byte[] array, int index)
{    array[index] = (byte) (value >> 24);    array[index + 1] = (byte) (value >> 16);    array[index + 2] = (byte) (value >> 8);    array[index + 3] = (byte) (value);}
public float[] pdfbox_f5072_0(float[] value) throws IOException
{    if (isRGB) {        return value;    }    if (awtColorSpace != null) {                return awtColorSpace.toRGB(clampColors(awtColorSpace, value));    } else {        return alternateColorSpace.toRGB(value);    }}
private float[] pdfbox_f5073_0(ICC_ColorSpace cs, float[] value)
{    float[] result = new float[value.length];    for (int i = 0; i < value.length; ++i) {        float minValue = cs.getMinValue(i);        float maxValue = cs.getMaxValue(i);        result[i] = value[i] < minValue ? minValue : (value[i] > maxValue ? maxValue : value[i]);    }    return result;}
public BufferedImage pdfbox_f5074_0(WritableRaster raster) throws IOException
{    if (awtColorSpace != null) {        return toRGBImageAWT(raster, awtColorSpace);    } else {        return alternateColorSpace.toRGBImage(raster);    }}
public int pdfbox_f5075_0()
{    if (numberOfComponents < 0) {        numberOfComponents = stream.getCOSObject().getInt(COSName.N);    }    return numberOfComponents;}
public float[] pdfbox_f5076_0(int bitsPerComponent)
{    if (awtColorSpace != null) {        int n = getNumberOfComponents();        float[] decode = new float[n * 2];        for (int i = 0; i < n; i++) {            decode[i * 2] = awtColorSpace.getMinValue(i);            decode[i * 2 + 1] = awtColorSpace.getMaxValue(i);        }        return decode;    } else {        return alternateColorSpace.getDefaultDecode(bitsPerComponent);    }}
public PDColor pdfbox_f5077_0()
{    return initialColor;}
public PDColorSpace pdfbox_f5078_0() throws IOException
{    COSBase alternate = stream.getCOSObject().getDictionaryObject(COSName.ALTERNATE);    COSArray alternateArray;    if (alternate == null) {        alternateArray = new COSArray();        int numComponents = getNumberOfComponents();        COSName csName;        switch(numComponents) {            case 1:                csName = COSName.DEVICEGRAY;                break;            case 3:                csName = COSName.DEVICERGB;                break;            case 4:                csName = COSName.DEVICECMYK;                break;            default:                throw new IOException("Unknown color space number of components:" + numComponents);        }        alternateArray.add(csName);    } else {        if (alternate instanceof COSArray) {            alternateArray = (COSArray) alternate;        } else if (alternate instanceof COSName) {            alternateArray = new COSArray();            alternateArray.add(alternate);        } else {            throw new IOException("Error: expected COSArray or COSName and not " + alternate.getClass().getName());        }    }    return PDColorSpace.create(alternateArray);}
public PDRange pdfbox_f5079_0(int n)
{    COSArray rangeArray = (COSArray) stream.getCOSObject().getDictionaryObject(COSName.RANGE);    if (rangeArray == null || rangeArray.size() < getNumberOfComponents() * 2) {                return new PDRange();    }    return new PDRange(rangeArray, n);}
public COSStream pdfbox_f5080_0()
{    return (COSStream) stream.getCOSObject().getDictionaryObject(COSName.METADATA);}
public int pdfbox_f5081_0()
{    if (iccProfile != null) {        return iccProfile.getColorSpaceType();    }        switch(alternateColorSpace.getNumberOfComponents()) {        case 1:            return ICC_ColorSpace.TYPE_GRAY;        case 3:            return ICC_ColorSpace.TYPE_RGB;        case 4:            return ICC_ColorSpace.TYPE_CMYK;        default:                        return -1;    }}
public void pdfbox_f5082_0(int n)
{    numberOfComponents = n;    stream.getCOSObject().setInt(COSName.N, n);}
public void pdfbox_f5083_0(List<PDColorSpace> list)
{    COSArray altArray = null;    if (list != null) {        altArray = COSArrayList.converterToCOSArray(list);    }    stream.getCOSObject().setItem(COSName.ALTERNATE, altArray);}
public void pdfbox_f5084_0(PDRange range, int n)
{    COSArray rangeArray = (COSArray) stream.getCOSObject().getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = new COSArray();        stream.getCOSObject().setItem(COSName.RANGE, rangeArray);    }        while (rangeArray.size() < (n + 1) * 2) {        rangeArray.add(new COSFloat(0));        rangeArray.add(new COSFloat(1));    }    rangeArray.set(n * 2, new COSFloat(range.getMin()));    rangeArray.set(n * 2 + 1, new COSFloat(range.getMax()));}
public void pdfbox_f5085_0(COSStream metadata)
{    stream.getCOSObject().setItem(COSName.METADATA, metadata);}
public String pdfbox_f5086_0()
{    return getName() + "{numberOfComponents: " + getNumberOfComponents() + "}";}
public String pdfbox_f5087_0()
{    return COSName.INDEXED.getName();}
public int pdfbox_f5088_0()
{    return 1;}
public float[] pdfbox_f5089_0(int bitsPerComponent)
{    return new float[] { 0, (float) Math.pow(2, bitsPerComponent) - 1 };}
public PDColor pdfbox_f5090_0()
{    return initialColor;}
private void pdfbox_f5091_0() throws IOException
{    int numBaseComponents = baseColorSpace.getNumberOfComponents();            WritableRaster baseRaster;    try {        baseRaster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, actualMaxIndex + 1, 1, numBaseComponents, new Point(0, 0));    } catch (IllegalArgumentException ex) {                throw new IOException(ex);    }    int[] base = new int[numBaseComponents];    for (int i = 0, n = actualMaxIndex; i <= n; i++) {        for (int c = 0; c < numBaseComponents; c++) {            base[c] = (int) (colorTable[i][c] * 255f);        }        baseRaster.setPixel(i, 0, base);    }        BufferedImage rgbImage = baseColorSpace.toRGBImage(baseRaster);    WritableRaster rgbRaster = rgbImage.getRaster();        rgbColorTable = new int[actualMaxIndex + 1][3];    int[] nil = null;    for (int i = 0, n = actualMaxIndex; i <= n; i++) {        rgbColorTable[i] = rgbRaster.getPixel(i, 0, nil);    }}
public float[] pdfbox_f5092_0(float[] value)
{    if (value.length > 1) {        throw new IllegalArgumentException("Indexed color spaces must have one color value");    }        int index = Math.round(value[0]);    index = Math.max(index, 0);    index = Math.min(index, actualMaxIndex);        int[] rgb = rgbColorTable[index];    return new float[] { rgb[0] / 255f, rgb[1] / 255f, rgb[2] / 255f };}
public BufferedImage pdfbox_f5093_0(WritableRaster raster) throws IOException
{        int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    int[] src = new int[1];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, src);                        int index = Math.min(src[0], actualMaxIndex);            rgbRaster.setPixel(x, y, rgbColorTable[index]);        }    }    return rgbImage;}
public PDColorSpace pdfbox_f5094_0()
{    return baseColorSpace;}
private int pdfbox_f5095_0()
{    return ((COSNumber) array.getObject(2)).intValue();}
private byte[] pdfbox_f5096_0() throws IOException
{    if (lookupData == null) {        COSBase lookupTable = array.getObject(3);        if (lookupTable instanceof COSString) {            lookupData = ((COSString) lookupTable).getBytes();        } else if (lookupTable instanceof COSStream) {            lookupData = new PDStream((COSStream) lookupTable).toByteArray();        } else if (lookupTable == null) {            lookupData = new byte[0];        } else {            throw new IOException("Error: Unknown type for lookup table " + lookupTable);        }    }    return lookupData;}
private void pdfbox_f5097_0() throws IOException
{    byte[] lookupData = getLookupData();    int maxIndex = Math.min(getHival(), 255);    int numComponents = baseColorSpace.getNumberOfComponents();        if (lookupData.length / numComponents < maxIndex + 1) {        maxIndex = lookupData.length / numComponents - 1;    }        actualMaxIndex = maxIndex;    colorTable = new float[maxIndex + 1][numComponents];    for (int i = 0, offset = 0; i <= maxIndex; i++) {        for (int c = 0; c < numComponents; c++) {            colorTable[i][c] = (lookupData[offset] & 0xff) / 255f;            offset++;        }    }}
public void pdfbox_f5098_0(PDColorSpace base)
{    array.set(1, base.getCOSObject());    baseColorSpace = base;}
public void pdfbox_f5099_0(int high)
{    array.set(2, high);}
public String pdfbox_f5100_0()
{    return "Indexed{base:" + baseColorSpace + " " + "hival:" + getHival() + " " + "lookup:(" + colorTable.length + " entries)}";}
public String pdfbox_f5101_0()
{    return "JPX";}
public int pdfbox_f5102_0()
{    return awtColorSpace.getNumComponents();}
public float[] pdfbox_f5103_0(int bitsPerComponent)
{    int n = getNumberOfComponents();    float[] decode = new float[n * 2];    for (int i = 0; i < n; i++) {        decode[i * 2] = awtColorSpace.getMinValue(i);        decode[i * 2 + 1] = awtColorSpace.getMaxValue(i);    }    return decode;}
public PDColor pdfbox_f5104_0()
{    throw new UnsupportedOperationException("JPX color spaces don't support drawing");}
public float[] pdfbox_f5105_0(float[] value)
{    throw new UnsupportedOperationException("JPX color spaces don't support drawing");}
public BufferedImage pdfbox_f5106_0(WritableRaster raster) throws IOException
{    return toRGBImageAWT(raster, awtColorSpace);}
public COSBase pdfbox_f5107_0()
{    throw new UnsupportedOperationException("JPX color spaces don't have COS objects");}
public String pdfbox_f5108_0()
{    return COSName.LAB.getName();}
public BufferedImage pdfbox_f5109_0(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    float minA = getARange().getMin();    float maxA = getARange().getMax();    float minB = getBRange().getMin();    float maxB = getBRange().getMax();        float[] abc = new float[3];    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, abc);                        abc[0] /= 255;            abc[1] /= 255;            abc[2] /= 255;                        abc[0] *= 100;            abc[1] = minA + (abc[1] * (maxA - minA));            abc[2] = minB + (abc[2] * (maxB - minB));            float[] rgb = toRGB(abc);                        rgb[0] *= 255;            rgb[1] *= 255;            rgb[2] *= 255;            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
public float[] pdfbox_f5110_0(float[] value)
{            float lstar = (value[0] + 16f) * (1f / 116f);            float x = wpX * inverse(lstar + value[1] * (1f / 500f));    float y = wpY * inverse(lstar);    float z = wpZ * inverse(lstar - value[2] * (1f / 200f));    return convXYZtoRGB(x, y, z);}
private float pdfbox_f5111_0(float x)
{    if (x > 6.0 / 29.0) {        return x * x * x;    } else {        return (108f / 841f) * (x - (4f / 29f));    }}
public int pdfbox_f5112_0()
{    return 3;}
public float[] pdfbox_f5113_0(int bitsPerComponent)
{    PDRange a = getARange();    PDRange b = getARange();    return new float[] { 0, 100, a.getMin(), a.getMax(), b.getMin(), b.getMax() };}
public PDColor pdfbox_f5114_0()
{    if (initialColor == null) {        initialColor = new PDColor(new float[] { 0, Math.max(0, getARange().getMin()), Math.max(0, getBRange().getMin()) }, this);    }    return initialColor;}
private COSArray pdfbox_f5115_0()
{    COSArray range = new COSArray();    range.add(new COSFloat(-100));    range.add(new COSFloat(100));    range.add(new COSFloat(-100));    range.add(new COSFloat(100));    return range;}
public PDRange pdfbox_f5116_0()
{    COSArray rangeArray = (COSArray) dictionary.getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = getDefaultRangeArray();    }    return new PDRange(rangeArray, 0);}
public PDRange pdfbox_f5117_0()
{    COSArray rangeArray = (COSArray) dictionary.getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = getDefaultRangeArray();    }    return new PDRange(rangeArray, 1);}
public void pdfbox_f5118_0(PDRange range)
{    setComponentRangeArray(range, 0);}
public void pdfbox_f5119_0(PDRange range)
{    setComponentRangeArray(range, 2);}
private void pdfbox_f5120_0(PDRange range, int index)
{    COSArray rangeArray = (COSArray) dictionary.getDictionaryObject(COSName.RANGE);    if (rangeArray == null) {        rangeArray = getDefaultRangeArray();    }    if (range == null) {                rangeArray.set(index, new COSFloat(-100));        rangeArray.set(index + 1, new COSFloat(100));    } else {        rangeArray.set(index, new COSFloat(range.getMin()));        rangeArray.set(index + 1, new COSFloat(range.getMax()));    }    dictionary.setItem(COSName.RANGE, rangeArray);    initialColor = null;}
public COSBase pdfbox_f5121_0()
{    return dictionary;}
public COSStream pdfbox_f5122_0()
{    return (COSStream) dictionary.getDictionaryObject(COSName.DEST_OUTPUT_PROFILE);}
public String pdfbox_f5123_0()
{    return dictionary.getString(COSName.INFO);}
public void pdfbox_f5124_0(String value)
{    dictionary.setString(COSName.INFO, value);}
public String pdfbox_f5125_0()
{    return dictionary.getString(COSName.OUTPUT_CONDITION);}
public void pdfbox_f5126_0(String value)
{    dictionary.setString(COSName.OUTPUT_CONDITION, value);}
public String pdfbox_f5127_0()
{    return dictionary.getString(COSName.OUTPUT_CONDITION_IDENTIFIER);}
public void pdfbox_f5128_0(String value)
{    dictionary.setString(COSName.OUTPUT_CONDITION_IDENTIFIER, value);}
public String pdfbox_f5129_0()
{    return dictionary.getString(COSName.REGISTRY_NAME);}
public void pdfbox_f5130_0(String value)
{    dictionary.setString(COSName.REGISTRY_NAME, value);}
private PDStream pdfbox_f5131_0(PDDocument doc, InputStream colorProfile) throws IOException
{    ICC_Profile icc = ICC_Profile.getInstance(colorProfile);    PDStream stream = new PDStream(doc, new ByteArrayInputStream(icc.getData()), COSName.FLATE_DECODE);    stream.getCOSObject().setInt(COSName.N, icc.getNumComponents());    return stream;}
public String pdfbox_f5132_0()
{    return COSName.PATTERN.getName();}
public int pdfbox_f5133_0()
{    throw new UnsupportedOperationException();}
public float[] pdfbox_f5134_0(int bitsPerComponent)
{    throw new UnsupportedOperationException();}
public PDColor pdfbox_f5135_0()
{    return EMPTY_PATTERN;}
public float[] pdfbox_f5136_0(float[] value)
{    throw new UnsupportedOperationException();}
public BufferedImage pdfbox_f5137_0(WritableRaster raster) throws IOException
{    throw new UnsupportedOperationException();}
public PDAbstractPattern pdfbox_f5138_0(PDColor color) throws IOException
{    PDAbstractPattern pattern = resources.getPattern(color.getPatternName());    if (pattern == null) {        throw new IOException("pattern " + color.getPatternName() + " was not found");    } else {        return pattern;    }}
public PDColorSpace pdfbox_f5139_0()
{    return underlyingColorSpace;}
public String pdfbox_f5140_0()
{    return "Pattern";}
public String pdfbox_f5141_0()
{    return COSName.SEPARATION.getName();}
public int pdfbox_f5142_0()
{    return 1;}
public float[] pdfbox_f5143_0(int bitsPerComponent)
{    return new float[] { 0, 1 };}
public PDColor pdfbox_f5144_0()
{    return initialColor;}
public float[] pdfbox_f5145_0(float[] value) throws IOException
{    if (toRGBMap == null) {        toRGBMap = new HashMap<>();    }    int key = (int) (value[0] * 255);    float[] retval = toRGBMap.get(key);    if (retval != null) {        return retval;    }    float[] altColor = tintTransform.eval(value);    retval = alternateColorSpace.toRGB(altColor);    toRGBMap.put(key, retval);    return retval;}
public BufferedImage pdfbox_f5146_0(WritableRaster raster) throws IOException
{    if (alternateColorSpace instanceof PDLab) {                return toRGBImage2(raster);    }            WritableRaster altRaster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, raster.getWidth(), raster.getHeight(), alternateColorSpace.getNumberOfComponents(), new Point(0, 0));    int numAltComponents = alternateColorSpace.getNumberOfComponents();    int width = raster.getWidth();    int height = raster.getHeight();    float[] samples = new float[1];    Map<Integer, int[]> calculatedValues = new HashMap<>();    Integer hash;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, samples);            hash = Float.floatToIntBits(samples[0]);            int[] alt = calculatedValues.get(hash);            if (alt == null) {                alt = new int[numAltComponents];                tintTransform(samples, alt);                calculatedValues.put(hash, alt);            }            altRaster.setPixel(x, y, alt);        }    }        return alternateColorSpace.toRGBImage(altRaster);}
private BufferedImage pdfbox_f5147_0(WritableRaster raster) throws IOException
{    int width = raster.getWidth();    int height = raster.getHeight();    BufferedImage rgbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    WritableRaster rgbRaster = rgbImage.getRaster();    float[] samples = new float[1];    Map<Integer, int[]> calculatedValues = new HashMap<>();    Integer hash;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            raster.getPixel(x, y, samples);            int[] rgb = calculatedValues.get(hash = Float.floatToIntBits(samples[0]));            if (rgb == null) {                samples[0] /= 255;                float[] altColor = tintTransform.eval(samples);                float[] fltab = alternateColorSpace.toRGB(altColor);                rgb = new int[3];                rgb[0] = (int) (fltab[0] * 255);                rgb[1] = (int) (fltab[1] * 255);                rgb[2] = (int) (fltab[2] * 255);                calculatedValues.put(hash, rgb);            }            rgbRaster.setPixel(x, y, rgb);        }    }    return rgbImage;}
protected void pdfbox_f5148_0(float[] samples, int[] alt) throws IOException
{        samples[0] /= 255;    float[] result = tintTransform.eval(samples);    for (int s = 0; s < alt.length; s++) {                alt[s] = (int) (result[s] * 255);    }}
public PDColorSpace pdfbox_f5149_0()
{    return alternateColorSpace;}
public String pdfbox_f5150_0()
{    COSName name = (COSName) array.getObject(COLORANT_NAMES);    return name.getName();}
public void pdfbox_f5151_0(String name)
{    array.set(1, COSName.getPDFName(name));}
public void pdfbox_f5152_0(PDColorSpace colorSpace)
{    alternateColorSpace = colorSpace;    COSBase space = null;    if (colorSpace != null) {        space = colorSpace.getCOSObject();    }    array.set(ALTERNATE_CS, space);}
public void pdfbox_f5153_0(PDFunction tint)
{    tintTransform = tint;    array.set(TINT_TRANSFORM, tint);}
public String pdfbox_f5154_0()
{    return getName() + "{" + "\"" + getColorantName() + "\"" + " " + alternateColorSpace.getName() + " " + tintTransform + "}";}
public COSBase pdfbox_f5155_0()
{    return array;}
public COSBase pdfbox_f5156_0()
{    return values;}
public float pdfbox_f5157_0()
{    return ((COSNumber) values.get(0)).floatValue();}
public void pdfbox_f5158_0(float x)
{    values.set(0, new COSFloat(x));}
public float pdfbox_f5159_0()
{    return ((COSNumber) values.get(1)).floatValue();}
public void pdfbox_f5160_0(float y)
{    values.set(1, new COSFloat(y));}
public float pdfbox_f5161_0()
{    return ((COSNumber) values.get(2)).floatValue();}
public void pdfbox_f5162_0(float z)
{    values.set(2, new COSFloat(z));}
public int pdfbox_f5163_0()
{    return getCOSObject().getInt(COSName.FORMTYPE, 1);}
public void pdfbox_f5164_0(int formType)
{    getCOSObject().setInt(COSName.FORMTYPE, formType);}
public PDTransparencyGroupAttributes pdfbox_f5165_0()
{    if (group == null) {        COSDictionary dic = (COSDictionary) getCOSObject().getDictionaryObject(COSName.GROUP);        if (dic != null) {            group = new PDTransparencyGroupAttributes(dic);        }    }    return group;}
public PDStream pdfbox_f5166_0()
{    return new PDStream(getCOSObject());}
public InputStream pdfbox_f5167_0() throws IOException
{    return getCOSObject().createInputStream();}
public PDResources pdfbox_f5168_0()
{    COSDictionary resources = getCOSObject().getCOSDictionary(COSName.RESOURCES);    if (resources != null) {        return new PDResources(resources, cache);    }    if (getCOSObject().containsKey(COSName.RESOURCES)) {                return new PDResources();    }    return null;}
public void pdfbox_f5169_0(PDResources resources)
{    getCOSObject().setItem(COSName.RESOURCES, resources);}
public PDRectangle pdfbox_f5170_0()
{    PDRectangle retval = null;    COSArray array = (COSArray) getCOSObject().getDictionaryObject(COSName.BBOX);    if (array != null) {        retval = new PDRectangle(array);    }    return retval;}
public void pdfbox_f5171_0(PDRectangle bbox)
{    if (bbox == null) {        getCOSObject().removeItem(COSName.BBOX);    } else {        getCOSObject().setItem(COSName.BBOX, bbox.getCOSArray());    }}
public Matrix pdfbox_f5172_0()
{    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));}
public void pdfbox_f5173_0(AffineTransform transform)
{    COSArray matrix = new COSArray();    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        matrix.add(new COSFloat((float) v));    }    getCOSObject().setItem(COSName.MATRIX, matrix);}
public int pdfbox_f5174_0()
{    return getCOSObject().getInt(COSName.STRUCT_PARENTS);}
public void pdfbox_f5175_0(int structParent)
{    getCOSObject().setInt(COSName.STRUCT_PARENTS, structParent);}
public COSDictionary pdfbox_f5176_0()
{    return dictionary;}
public PDColorSpace pdfbox_f5177_0() throws IOException
{    return getColorSpace(null);}
public PDColorSpace pdfbox_f5178_0(PDResources resources) throws IOException
{    if (colorSpace == null && getCOSObject().containsKey(COSName.CS)) {        colorSpace = PDColorSpace.create(getCOSObject().getDictionaryObject(COSName.CS), resources);    }    return colorSpace;}
public boolean pdfbox_f5179_0()
{    return getCOSObject().getBoolean(COSName.I, false);}
public boolean pdfbox_f5180_0()
{    return getCOSObject().getBoolean(COSName.K, false);}
public static PDImageXObject pdfbox_f5181_0(PDDocument document, BufferedImage image) throws IOException
{    if (image.getType() != BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() != 1) {        throw new IllegalArgumentException("Only 1-bit b/w images supported");    }    int height = image.getHeight();    int width = image.getWidth();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    try (MemoryCacheImageOutputStream mcios = new MemoryCacheImageOutputStream(bos)) {        for (int y = 0; y < height; ++y) {            for (int x = 0; x < width; ++x) {                                mcios.writeBits(~(image.getRGB(x, y) & 1), 1);            }            if (mcios.getBitOffset() != 0) {                mcios.writeBits(0, 8 - mcios.getBitOffset());            }        }        mcios.flush();    }    return prepareImageXObject(document, bos.toByteArray(), width, height, PDDeviceGray.INSTANCE);}
public static PDImageXObject pdfbox_f5182_0(PDDocument document, byte[] byteArray) throws IOException
{    return createFromByteArray(document, byteArray, 0);}
public static PDImageXObject pdfbox_f5183_0(PDDocument document, byte[] byteArray, int number) throws IOException
{    try (RandomAccess raf = new RandomAccessBuffer(byteArray)) {        return createFromRandomAccessImpl(document, raf, number);    }}
private static PDImageXObject pdfbox_f5184_0(PDDocument document, byte[] byteArray, int width, int height, PDColorSpace initColorSpace) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Filter filter = FilterFactory.INSTANCE.getFilter(COSName.CCITTFAX_DECODE);    COSDictionary dict = new COSDictionary();    dict.setInt(COSName.COLUMNS, width);    dict.setInt(COSName.ROWS, height);    filter.encode(new ByteArrayInputStream(byteArray), baos, dict, 0);    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(baos.toByteArray());    PDImageXObject image = new PDImageXObject(document, encodedByteStream, COSName.CCITTFAX_DECODE, width, height, 1, initColorSpace);    dict.setInt(COSName.K, -1);    image.getCOSObject().setItem(COSName.DECODE_PARMS, dict);    return image;}
public static PDImageXObject pdfbox_f5185_0(PDDocument document, File file) throws IOException
{    return createFromFile(document, file, 0);}
public static PDImageXObject pdfbox_f5186_0(PDDocument document, File file, int number) throws IOException
{    try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {        return createFromRandomAccessImpl(document, raf, number);    }}
private static PDImageXObject pdfbox_f5187_0(PDDocument document, RandomAccess reader, int number) throws IOException
{    COSDictionary decodeParms = new COSDictionary();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    extractFromTiff(reader, bos, decodeParms, number);    if (bos.size() == 0) {        return null;    }    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(bos.toByteArray());    PDImageXObject pdImage = new PDImageXObject(document, encodedByteStream, COSName.CCITTFAX_DECODE, decodeParms.getInt(COSName.COLUMNS), decodeParms.getInt(COSName.ROWS), 1, PDDeviceGray.INSTANCE);    COSDictionary dict = pdImage.getCOSObject();    dict.setItem(COSName.DECODE_PARMS, decodeParms);    return pdImage;}
private static void pdfbox_f5188_0(RandomAccess reader, OutputStream os, COSDictionary params, int number) throws IOException
{    try {                reader.seek(0);        char endianess = (char) reader.read();        if ((char) reader.read() != endianess) {            throw new IOException("Not a valid tiff file");        }                if (endianess != 'M' && endianess != 'I') {            throw new IOException("Not a valid tiff file");        }        int magicNumber = readshort(endianess, reader);        if (magicNumber != 42) {            throw new IOException("Not a valid tiff file");        }                int address = readlong(endianess, reader);        reader.seek(address);                for (int i = 0; i < number; i++) {            int numtags = readshort(endianess, reader);            if (numtags > 50) {                throw new IOException("Not a valid tiff file");            }            reader.seek(address + 2 + numtags * 12);            address = readlong(endianess, reader);            if (address == 0) {                return;            }            reader.seek(address);        }        int numtags = readshort(endianess, reader);                if (numtags > 50) {            throw new IOException("Not a valid tiff file");        }                                                int k = -1000;        int dataoffset = 0;        int datalength = 0;        for (int i = 0; i < numtags; i++) {            int tag = readshort(endianess, reader);            int type = readshort(endianess, reader);            int count = readlong(endianess, reader);            int val;                        switch(type) {                case                 1:                    val = reader.read();                    reader.read();                    reader.read();                    reader.read();                    break;                case                 3:                    val = readshort(endianess, reader);                    reader.read();                    reader.read();                    break;                default:                                        val = readlong(endianess, reader);                    break;            }            switch(tag) {                case 256:                    {                        params.setInt(COSName.COLUMNS, val);                        break;                    }                case 257:                    {                        params.setInt(COSName.ROWS, val);                        break;                    }                case 259:                    {                        if (val == 4) {                            k = -1;                        }                        if (val == 3) {                            k = 0;                        }                                                break;                    }                case 262:                    {                        if (val == 1) {                            params.setBoolean(COSName.BLACK_IS_1, true);                        }                        break;                    }                case 266:                    {                        if (val != 1) {                            throw new IOException("FillOrder " + val + " is not supported");                        }                        break;                    }                case 273:                    {                        if (count == 1) {                            dataoffset = val;                        }                        break;                    }                case 274:                    {                                                if (val != 1) {                            throw new IOException("Orientation " + val + " is not supported");                        }                        break;                    }                case 279:                    {                        if (count == 1) {                            datalength = val;                        }                        break;                    }                case 292:                    {                        if ((val & 1) != 0) {                                                        k = 50;                        }                                                if ((val & 4) != 0) {                            throw new IOException("CCITT Group 3 'uncompressed mode' is not supported");                        }                        if ((val & 2) != 0) {                            throw new IOException("CCITT Group 3 'fill bits before EOL' is not supported");                        }                        break;                    }                case 324:                    {                        if (count == 1) {                            dataoffset = val;                        }                        break;                    }                case 325:                    {                        if (count == 1) {                            datalength = val;                        }                        break;                    }                default:                    {                                        }            }        }        if (k == -1000) {            throw new IOException("First image in tiff is not CCITT T4 or T6 compressed");        }        if (dataoffset == 0) {            throw new IOException("First image in tiff is not a single tile/strip");        }        params.setInt(COSName.K, k);        reader.seek(dataoffset);        byte[] buf = new byte[8192];        int amountRead;        while ((amountRead = reader.read(buf, 0, Math.min(8192, datalength))) > 0) {            datalength -= amountRead;            os.write(buf, 0, amountRead);        }    } finally {        os.close();    }}
private static int pdfbox_f5189_0(char endianess, RandomAccess raf) throws IOException
{    if (endianess == 'I') {        return raf.read() | (raf.read() << 8);    }    return (raf.read() << 8) | raf.read();}
private static int pdfbox_f5190_0(char endianess, RandomAccess raf) throws IOException
{    if (endianess == 'I') {        return raf.read() | (raf.read() << 8) | (raf.read() << 16) | (raf.read() << 24);    }    return (raf.read() << 24) | (raf.read() << 16) | (raf.read() << 8) | raf.read();}
public static PDImageXObject pdfbox_f5191_0(PDDocument document, InputStream stream) throws IOException
{    return createFromByteArray(document, IOUtils.toByteArray(stream));}
public static PDImageXObject pdfbox_f5192_0(PDDocument document, byte[] byteArray) throws IOException
{        ByteArrayInputStream byteStream = new ByteArrayInputStream(byteArray);        Raster raster = readJPEGRaster(byteStream);    byteStream.reset();    PDColorSpace colorSpace;    switch(raster.getNumDataElements()) {        case 1:            colorSpace = PDDeviceGray.INSTANCE;            break;        case 3:            colorSpace = PDDeviceRGB.INSTANCE;            break;        case 4:            colorSpace = PDDeviceCMYK.INSTANCE;            break;        default:            throw new UnsupportedOperationException("number of data elements not supported: " + raster.getNumDataElements());    }        PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, raster.getWidth(), raster.getHeight(), 8, colorSpace);    if (colorSpace instanceof PDDeviceCMYK) {        COSArray decode = new COSArray();        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        decode.add(COSInteger.ONE);        decode.add(COSInteger.ZERO);        pdImage.setDecode(decode);    }    return pdImage;}
private static Raster pdfbox_f5193_0(InputStream stream) throws IOException
{        Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName("JPEG");    ImageReader reader = null;    while (readers.hasNext()) {        reader = readers.next();        if (reader.canReadRaster()) {            break;        }    }    if (reader == null) {        throw new MissingImageReaderException("Cannot read JPEG image: a suitable JAI I/O image filter is not installed");    }    try (ImageInputStream iis = ImageIO.createImageInputStream(stream)) {        reader.setInput(iis);        ImageIO.setUseCache(false);        return reader.readRaster(0, null);    } finally {        reader.dispose();    }}
public static PDImageXObject pdfbox_f5194_0(PDDocument document, BufferedImage image) throws IOException
{    return createFromImage(document, image, 0.75f);}
public static PDImageXObject pdfbox_f5195_0(PDDocument document, BufferedImage image, float quality) throws IOException
{    return createFromImage(document, image, quality, 72);}
public static PDImageXObject pdfbox_f5196_0(PDDocument document, BufferedImage image, float quality, int dpi) throws IOException
{    return createJPEG(document, image, quality, dpi);}
private static BufferedImage pdfbox_f5197_0(BufferedImage image) throws IOException
{    if (!image.getColorModel().hasAlpha()) {        return null;    }    if (image.getTransparency() == Transparency.BITMASK) {        throw new UnsupportedOperationException("BITMASK Transparency JPEG compression is not" + " useful, use LosslessImageFactory instead");    }    WritableRaster alphaRaster = image.getAlphaRaster();    if (alphaRaster == null) {                return null;    }    BufferedImage alphaImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);    alphaImage.setData(alphaRaster);    return alphaImage;}
private static PDImageXObject pdfbox_f5198_0(PDDocument document, BufferedImage image, float quality, int dpi) throws IOException
{        BufferedImage awtColorImage = getColorImage(image);    BufferedImage awtAlphaImage = getAlphaImage(image);        ByteArrayOutputStream baos = new ByteArrayOutputStream();    encodeImageToJPEGStream(awtColorImage, quality, dpi, baos);    ByteArrayInputStream byteStream = new ByteArrayInputStream(baos.toByteArray());    PDImageXObject pdImage = new PDImageXObject(document, byteStream, COSName.DCT_DECODE, awtColorImage.getWidth(), awtColorImage.getHeight(), awtColorImage.getColorModel().getComponentSize(0), getColorSpaceFromAWT(awtColorImage));        if (awtAlphaImage != null) {        PDImage xAlpha = JPEGFactory.createFromImage(document, awtAlphaImage, quality);        pdImage.getCOSObject().setItem(COSName.SMASK, xAlpha);    }    return pdImage;}
private static ImageWriter pdfbox_f5199_0() throws IOException
{    ImageWriter writer = null;    Iterator<ImageWriter> writers = ImageIO.getImageWritersBySuffix("jpeg");    while (writers.hasNext()) {        if (writer != null) {            writer.dispose();        }        writer = writers.next();        if (writer == null) {            continue;        }                if (writer.getDefaultWriteParam() instanceof JPEGImageWriteParam) {            return writer;        }    }    throw new IOException("No ImageWriter found for JPEG format");}
private static void pdfbox_f5200_0(BufferedImage image, float quality, int dpi, OutputStream out) throws IOException
{        ImageOutputStream ios = null;    ImageWriter imageWriter = null;    try {                imageWriter = getJPEGImageWriter();        ios = ImageIO.createImageOutputStream(out);        imageWriter.setOutput(ios);                JPEGImageWriteParam jpegParam = (JPEGImageWriteParam) imageWriter.getDefaultWriteParam();        jpegParam.setCompressionMode(JPEGImageWriteParam.MODE_EXPLICIT);        jpegParam.setCompressionQuality(quality);                ImageTypeSpecifier imageTypeSpecifier = new ImageTypeSpecifier(image);        IIOMetadata data = imageWriter.getDefaultImageMetadata(imageTypeSpecifier, jpegParam);        Element tree = (Element) data.getAsTree("javax_imageio_jpeg_image_1.0");        Element jfif = (Element) tree.getElementsByTagName("app0JFIF").item(0);        jfif.setAttribute("Xdensity", Integer.toString(dpi));        jfif.setAttribute("Ydensity", Integer.toString(dpi));                jfif.setAttribute("resUnits", "1");                imageWriter.write(data, new IIOImage(image, null, null), jpegParam);    } finally {                IOUtils.closeQuietly(out);        if (ios != null) {            ios.close();        }        if (imageWriter != null) {            imageWriter.dispose();        }    }}
private static PDColorSpace pdfbox_f5201_0(BufferedImage awtImage)
{    if (awtImage.getColorModel().getNumComponents() == 1) {                return PDDeviceGray.INSTANCE;    }    ColorSpace awtColorSpace = awtImage.getColorModel().getColorSpace();    if (awtColorSpace instanceof ICC_ColorSpace && !awtColorSpace.isCS_sRGB()) {        throw new UnsupportedOperationException("ICC color spaces not implemented");    }    switch(awtColorSpace.getType()) {        case ColorSpace.TYPE_RGB:            return PDDeviceRGB.INSTANCE;        case ColorSpace.TYPE_GRAY:            return PDDeviceGray.INSTANCE;        case ColorSpace.TYPE_CMYK:            return PDDeviceCMYK.INSTANCE;        default:            throw new UnsupportedOperationException("color space not implemented: " + awtColorSpace.getType());    }}
private static BufferedImage pdfbox_f5202_0(BufferedImage image)
{    if (!image.getColorModel().hasAlpha()) {        return image;    }    if (image.getColorModel().getColorSpace().getType() != ColorSpace.TYPE_RGB) {        throw new UnsupportedOperationException("only RGB color spaces are implemented");    }                        BufferedImage rgbImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);    return new ColorConvertOp(null).filter(image, rgbImage);}
public static PDImageXObject pdfbox_f5203_0(PDDocument document, BufferedImage image) throws IOException
{    if ((image.getType() == BufferedImage.TYPE_BYTE_GRAY && image.getColorModel().getPixelSize() <= 8) || (image.getType() == BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() == 1)) {        return createFromGrayImage(image, document);    } else {                if (usePredictorEncoder) {            PDImageXObject pdImageXObject = new PredictorEncoder(document, image).encode();            if (pdImageXObject != null) {                if (pdImageXObject.getColorSpace() == PDDeviceRGB.INSTANCE && pdImageXObject.getBitsPerComponent() < 16 && image.getWidth() * image.getHeight() <= 50 * 50) {                                        PDImageXObject pdImageXObjectClassic = createFromRGBImage(image, document);                    if (pdImageXObjectClassic.getCOSObject().getLength() < pdImageXObject.getCOSObject().getLength()) {                        pdImageXObject.getCOSObject().close();                        return pdImageXObjectClassic;                    } else {                        pdImageXObjectClassic.getCOSObject().close();                    }                }                return pdImageXObject;            }        }                return createFromRGBImage(image, document);    }}
private static PDImageXObject pdfbox_f5204_0(BufferedImage image, PDDocument document) throws IOException
{    int height = image.getHeight();    int width = image.getWidth();    int[] rgbLineBuffer = new int[width];    int bpc = image.getColorModel().getPixelSize();    ByteArrayOutputStream baos = new ByteArrayOutputStream(((width * bpc / 8) + (width * bpc % 8 != 0 ? 1 : 0)) * height);    try (MemoryCacheImageOutputStream mcios = new MemoryCacheImageOutputStream(baos)) {        for (int y = 0; y < height; ++y) {            for (int pixel : image.getRGB(0, y, width, 1, rgbLineBuffer, 0, width)) {                mcios.writeBits(pixel & 0xFF, bpc);            }            int bitOffset = mcios.getBitOffset();            if (bitOffset != 0) {                mcios.writeBits(0, 8 - bitOffset);            }        }        mcios.flush();    }    return prepareImageXObject(document, baos.toByteArray(), image.getWidth(), image.getHeight(), bpc, PDDeviceGray.INSTANCE);}
private static PDImageXObject pdfbox_f5205_0(BufferedImage image, PDDocument document) throws IOException
{    int height = image.getHeight();    int width = image.getWidth();    int[] rgbLineBuffer = new int[width];    int bpc = 8;    PDDeviceColorSpace deviceColorSpace = PDDeviceRGB.INSTANCE;    byte[] imageData = new byte[width * height * 3];    int byteIdx = 0;    int alphaByteIdx = 0;    int alphaBitPos = 7;    int transparency = image.getTransparency();    int apbc = transparency == Transparency.BITMASK ? 1 : 8;    byte[] alphaImageData;    if (transparency != Transparency.OPAQUE) {        alphaImageData = new byte[((width * apbc / 8) + (width * apbc % 8 != 0 ? 1 : 0)) * height];    } else {        alphaImageData = new byte[0];    }    for (int y = 0; y < height; ++y) {        for (int pixel : image.getRGB(0, y, width, 1, rgbLineBuffer, 0, width)) {            imageData[byteIdx++] = (byte) ((pixel >> 16) & 0xFF);            imageData[byteIdx++] = (byte) ((pixel >> 8) & 0xFF);            imageData[byteIdx++] = (byte) (pixel & 0xFF);            if (transparency != Transparency.OPAQUE) {                                if (transparency == Transparency.BITMASK) {                                        alphaImageData[alphaByteIdx] |= ((pixel >> 24) & 1) << alphaBitPos;                    if (--alphaBitPos < 0) {                        alphaBitPos = 7;                        ++alphaByteIdx;                    }                } else {                                        alphaImageData[alphaByteIdx++] = (byte) ((pixel >> 24) & 0xFF);                }            }        }                if (transparency == Transparency.BITMASK && alphaBitPos != 7) {            alphaBitPos = 7;            ++alphaByteIdx;        }    }    PDImageXObject pdImage = prepareImageXObject(document, imageData, image.getWidth(), image.getHeight(), bpc, deviceColorSpace);    if (transparency != Transparency.OPAQUE) {        PDImageXObject pdMask = prepareImageXObject(document, alphaImageData, image.getWidth(), image.getHeight(), apbc, PDDeviceGray.INSTANCE);        pdImage.getCOSObject().setItem(COSName.SMASK, pdMask);    }    return pdImage;}
 static PDImageXObject pdfbox_f5206_0(PDDocument document, byte[] byteArray, int width, int height, int bitsPerComponent, PDColorSpace initColorSpace) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream(byteArray.length / 2);    Filter filter = FilterFactory.INSTANCE.getFilter(COSName.FLATE_DECODE);    filter.encode(new ByteArrayInputStream(byteArray), baos, new COSDictionary(), 0);    ByteArrayInputStream encodedByteStream = new ByteArrayInputStream(baos.toByteArray());    return new PDImageXObject(document, encodedByteStream, COSName.FLATE_DECODE, width, height, bitsPerComponent, initColorSpace);}
 PDImageXObject pdfbox_f5207_0() throws IOException
{    Raster imageRaster = image.getRaster();    final int elementsInRowPerPixel;            Object prevRow;    Object transferRow;    switch(imageType) {        case BufferedImage.TYPE_CUSTOM:            {                switch(imageRaster.getTransferType()) {                    case DataBuffer.TYPE_USHORT:                        elementsInRowPerPixel = componentsPerPixel;                        prevRow = new short[width * elementsInRowPerPixel];                        transferRow = new short[width * elementsInRowPerPixel];                        break;                    case DataBuffer.TYPE_BYTE:                        elementsInRowPerPixel = componentsPerPixel;                        prevRow = new byte[width * elementsInRowPerPixel];                        transferRow = new byte[width * elementsInRowPerPixel];                        break;                    default:                        return null;                }                break;            }        case BufferedImage.TYPE_3BYTE_BGR:        case BufferedImage.TYPE_4BYTE_ABGR:            {                elementsInRowPerPixel = componentsPerPixel;                prevRow = new byte[width * elementsInRowPerPixel];                transferRow = new byte[width * elementsInRowPerPixel];                break;            }        case BufferedImage.TYPE_INT_BGR:        case BufferedImage.TYPE_INT_ARGB:        case BufferedImage.TYPE_INT_RGB:            {                elementsInRowPerPixel = 1;                prevRow = new int[width * elementsInRowPerPixel];                transferRow = new int[width * elementsInRowPerPixel];                break;            }        default:                        return null;    }    final int elementsInTransferRow = width * elementsInRowPerPixel;        ByteArrayOutputStream stream = new ByteArrayOutputStream(height * width * bytesPerPixel / 2);    Deflater deflater = new Deflater(Filter.getCompressionLevel());    DeflaterOutputStream zip = new DeflaterOutputStream(stream, deflater);    int alphaPtr = 0;    for (int rowNum = 0; rowNum < height; rowNum++) {        imageRaster.getDataElements(0, rowNum, width, 1, transferRow);                int writerPtr = 1;        Arrays.fill(aValues, (byte) 0);        Arrays.fill(cValues, (byte) 0);        final byte[] transferRowByte;        final byte[] prevRowByte;        final int[] transferRowInt;        final int[] prevRowInt;        final short[] transferRowShort;        final short[] prevRowShort;        if (transferRow instanceof byte[]) {            transferRowByte = (byte[]) transferRow;            prevRowByte = (byte[]) prevRow;            transferRowInt = prevRowInt = null;            transferRowShort = prevRowShort = null;        } else if (transferRow instanceof int[]) {            transferRowInt = (int[]) transferRow;            prevRowInt = (int[]) prevRow;            transferRowShort = prevRowShort = null;            transferRowByte = prevRowByte = null;        } else {                        transferRowShort = (short[]) transferRow;            prevRowShort = (short[]) prevRow;            transferRowInt = prevRowInt = null;            transferRowByte = prevRowByte = null;        }        for (int indexInTransferRow = 0; indexInTransferRow < elementsInTransferRow; indexInTransferRow += elementsInRowPerPixel, alphaPtr += bytesPerComponent) {                        if (transferRowByte != null) {                copyImageBytes(transferRowByte, indexInTransferRow, xValues, alphaImageData, alphaPtr);                copyImageBytes(prevRowByte, indexInTransferRow, bValues, null, 0);            } else if (transferRowInt != null) {                copyIntToBytes(transferRowInt, indexInTransferRow, xValues, alphaImageData, alphaPtr);                copyIntToBytes(prevRowInt, indexInTransferRow, bValues, null, 0);            } else {                                copyShortsToBytes(transferRowShort, indexInTransferRow, xValues, alphaImageData, alphaPtr);                copyShortsToBytes(prevRowShort, indexInTransferRow, bValues, null, 0);            }                        int length = xValues.length;            for (int bytePtr = 0; bytePtr < length; bytePtr++) {                int x = xValues[bytePtr] & 0xFF;                int a = aValues[bytePtr] & 0xFF;                int b = bValues[bytePtr] & 0xFF;                int c = cValues[bytePtr] & 0xFF;                dataRawRowNone[writerPtr] = (byte) x;                dataRawRowSub[writerPtr] = pngFilterSub(x, a);                dataRawRowUp[writerPtr] = pngFilterUp(x, b);                dataRawRowAverage[writerPtr] = pngFilterAverage(x, a, b);                dataRawRowPaeth[writerPtr] = pngFilterPaeth(x, a, b, c);                writerPtr++;            }                        System.arraycopy(xValues, 0, aValues, 0, bytesPerPixel);            System.arraycopy(bValues, 0, cValues, 0, bytesPerPixel);        }        byte[] rowToWrite = chooseDataRowToWrite();                zip.write(rowToWrite, 0, rowToWrite.length);                Object temp = prevRow;        prevRow = transferRow;        transferRow = temp;    }    zip.close();    deflater.end();    return preparePredictorPDImage(stream, bytesPerComponent * 8);}
private void pdfbox_f5208_0(int[] transferRow, int indexInTranferRow, byte[] targetValues, byte[] alphaImageData, int alphaPtr)
{    int val = transferRow[indexInTranferRow];    byte b0 = (byte) (val & 0xFF);    byte b1 = (byte) ((val >> 8) & 0xFF);    byte b2 = (byte) ((val >> 16) & 0xFF);    switch(imageType) {        case BufferedImage.TYPE_INT_BGR:            targetValues[0] = b0;            targetValues[1] = b1;            targetValues[2] = b2;            break;        case BufferedImage.TYPE_INT_ARGB:            targetValues[0] = b2;            targetValues[1] = b1;            targetValues[2] = b0;            if (alphaImageData != null) {                byte b3 = (byte) ((val >> 24) & 0xFF);                alphaImageData[alphaPtr] = b3;            }            break;        case BufferedImage.TYPE_INT_RGB:            targetValues[0] = b2;            targetValues[1] = b1;            targetValues[2] = b0;            break;    }}
private void pdfbox_f5209_0(byte[] transferRow, int indexInTranferRow, byte[] targetValues, byte[] alphaImageData, int alphaPtr)
{    System.arraycopy(transferRow, indexInTranferRow, targetValues, 0, targetValues.length);    if (alphaImageData != null) {        alphaImageData[alphaPtr] = transferRow[indexInTranferRow + targetValues.length];    }}
private static void pdfbox_f5210_0(short[] transferRow, int indexInTranferRow, byte[] targetValues, byte[] alphaImageData, int alphaPtr)
{    int itr = indexInTranferRow;    for (int i = 0; i < targetValues.length; i += 2) {        short val = transferRow[itr++];        targetValues[i] = (byte) ((val >> 8) & 0xFF);        targetValues[i + 1] = (byte) (val & 0xFF);    }    if (alphaImageData != null) {        short alpha = transferRow[itr];        alphaImageData[alphaPtr] = (byte) ((alpha >> 8) & 0xFF);        alphaImageData[alphaPtr + 1] = (byte) (alpha & 0xFF);    }}
private PDImageXObject pdfbox_f5211_0(ByteArrayOutputStream stream, int bitsPerComponent) throws IOException
{    int h = image.getHeight();    int w = image.getWidth();    ColorSpace srcCspace = image.getColorModel().getColorSpace();    int srcCspaceType = srcCspace.getType();    PDColorSpace pdColorSpace = srcCspaceType == ColorSpace.TYPE_CMYK ? PDDeviceCMYK.INSTANCE : (srcCspaceType == ColorSpace.TYPE_GRAY ? PDDeviceGray.INSTANCE : PDDeviceRGB.INSTANCE);        if (srcCspace instanceof ICC_ColorSpace) {        ICC_Profile profile = ((ICC_ColorSpace) srcCspace).getProfile();                if (profile != ICC_Profile.getInstance(ColorSpace.CS_sRGB)) {            PDICCBased pdProfile = new PDICCBased(document);            try (OutputStream outputStream = pdProfile.getPDStream().createOutputStream(COSName.FLATE_DECODE)) {                outputStream.write(profile.getData());            }            pdProfile.getPDStream().getCOSObject().setInt(COSName.N, srcCspace.getNumComponents());            pdProfile.getPDStream().getCOSObject().setItem(COSName.ALTERNATE, srcCspaceType == ColorSpace.TYPE_GRAY ? COSName.DEVICEGRAY : (srcCspaceType == ColorSpace.TYPE_CMYK ? COSName.DEVICECMYK : COSName.DEVICERGB));            pdColorSpace = pdProfile;        }    }    PDImageXObject imageXObject = new PDImageXObject(document, new ByteArrayInputStream(stream.toByteArray()), COSName.FLATE_DECODE, w, h, bitsPerComponent, pdColorSpace);    COSDictionary decodeParms = new COSDictionary();    decodeParms.setItem(COSName.BITS_PER_COMPONENT, COSInteger.get(bitsPerComponent));    decodeParms.setItem(COSName.PREDICTOR, COSInteger.get(15));    decodeParms.setItem(COSName.COLUMNS, COSInteger.get(w));    decodeParms.setItem(COSName.COLORS, COSInteger.get(srcCspace.getNumComponents()));    imageXObject.getCOSObject().setItem(COSName.DECODE_PARMS, decodeParms);    if (image.getTransparency() != Transparency.OPAQUE) {        PDImageXObject pdMask = prepareImageXObject(document, alphaImageData, image.getWidth(), image.getHeight(), 8 * bytesPerComponent, PDDeviceGray.INSTANCE);        imageXObject.getCOSObject().setItem(COSName.SMASK, pdMask);    }    return imageXObject;}
private byte[] pdfbox_f5212_0()
{    byte[] rowToWrite = dataRawRowNone;    long estCompressSum = estCompressSum(dataRawRowNone);    long estCompressSumSub = estCompressSum(dataRawRowSub);    long estCompressSumUp = estCompressSum(dataRawRowUp);    long estCompressSumAvg = estCompressSum(dataRawRowAverage);    long estCompressSumPaeth = estCompressSum(dataRawRowPaeth);    if (estCompressSum > estCompressSumSub) {        rowToWrite = dataRawRowSub;        estCompressSum = estCompressSumSub;    }    if (estCompressSum > estCompressSumUp) {        rowToWrite = dataRawRowUp;        estCompressSum = estCompressSumUp;    }    if (estCompressSum > estCompressSumAvg) {        rowToWrite = dataRawRowAverage;        estCompressSum = estCompressSumAvg;    }    if (estCompressSum > estCompressSumPaeth) {        rowToWrite = dataRawRowPaeth;    }    return rowToWrite;}
private static byte pdfbox_f5213_0(int x, int a)
{    return (byte) ((x & 0xFF) - (a & 0xFF));}
private static byte pdfbox_f5214_0(int x, int b)
{        return pngFilterSub(x, b);}
private static byte pdfbox_f5215_0(int x, int a, int b)
{    return (byte) (x - ((b + a) / 2));}
private static byte pdfbox_f5216_0(int x, int a, int b, int c)
{    int p = a + b - c;    int pa = Math.abs(p - a);    int pb = Math.abs(p - b);    int pc = Math.abs(p - c);    final int pr;    if (pa <= pb && pa <= pc) {        pr = a;    } else if (pb <= pc) {        pr = b;    } else {        pr = c;    }    int r = x - pr;    return (byte) (r);}
private static long pdfbox_f5217_0(byte[] dataRawRowSub)
{    long sum = 0;    for (byte aDataRawRowSub : dataRawRowSub) {                sum += Math.abs(aDataRawRowSub);    }    return sum;}
public static PDImageXObject pdfbox_f5218_0(COSStream cosStream) throws IOException
{        PDStream pdStream = new PDStream(cosStream);    return new PDImageXObject(pdStream, null);}
private static COSStream pdfbox_f5219_0(PDDocument document, InputStream rawInput) throws IOException
{    COSStream stream = document.getDocument().createCOSStream();    try (OutputStream output = stream.createRawOutputStream()) {        IOUtils.copy(rawInput, output);    }    return stream;}
public static PDImageXObject pdfbox_f5220_0(String imagePath, PDDocument doc) throws IOException
{    return createFromFileByExtension(new File(imagePath), doc);}
public static PDImageXObject pdfbox_f5221_0(File file, PDDocument doc) throws IOException
{    String name = file.getName();    int dot = file.getName().lastIndexOf('.');    if (dot == -1) {        throw new IllegalArgumentException("Image type not supported: " + name);    }    String ext = name.substring(dot + 1).toLowerCase();    if ("jpg".equals(ext) || "jpeg".equals(ext)) {        try (FileInputStream fis = new FileInputStream(file)) {            return JPEGFactory.createFromStream(doc, fis);        }    }    if ("tif".equals(ext) || "tiff".equals(ext)) {        return CCITTFactory.createFromFile(doc, file);    }    if ("gif".equals(ext) || "bmp".equals(ext) || "png".equals(ext)) {        BufferedImage bim = ImageIO.read(file);        return LosslessFactory.createFromImage(doc, bim);    }    throw new IllegalArgumentException("Image type not supported: " + name);}
public static PDImageXObject pdfbox_f5222_1(File file, PDDocument doc) throws IOException
{    FileType fileType = null;    try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(file))) {        fileType = FileTypeDetector.detectFileType(bufferedInputStream);    } catch (IOException e) {        throw new IOException("Could not determine file type: " + file.getName(), e);    }    if (fileType == null) {        throw new IllegalArgumentException("Image type not supported: " + file.getName());    }    if (fileType.equals(FileType.JPEG)) {        try (FileInputStream fis = new FileInputStream(file)) {            return JPEGFactory.createFromStream(doc, fis);        }    }    if (fileType.equals(FileType.TIFF)) {        try {            return CCITTFactory.createFromFile(doc, file);        } catch (IOException ex) {                                                            fileType = FileType.PNG;        }    }    if (fileType.equals(FileType.BMP) || fileType.equals(FileType.GIF) || fileType.equals(FileType.PNG)) {        BufferedImage bim = ImageIO.read(file);        return LosslessFactory.createFromImage(doc, bim);    }    throw new IllegalArgumentException("Image type " + fileType + " not supported: " + file.getName());}
public static PDImageXObject pdfbox_f5223_1(PDDocument document, byte[] byteArray, String name) throws IOException
{    FileType fileType;    try {        fileType = FileTypeDetector.detectFileType(byteArray);    } catch (IOException e) {        throw new IOException("Could not determine file type: " + name, e);    }    if (fileType == null) {        throw new IllegalArgumentException("Image type not supported: " + name);    }    if (fileType.equals(FileType.JPEG)) {        return JPEGFactory.createFromByteArray(document, byteArray);    }    if (fileType.equals(FileType.PNG)) {                PDImageXObject image = PNGConverter.convertPNGImage(document, byteArray);        if (image != null) {            return image;        }    }    if (fileType.equals(FileType.TIFF)) {        try {            return CCITTFactory.createFromByteArray(document, byteArray);        } catch (IOException ex) {                                                            fileType = FileType.PNG;        }    }    if (fileType.equals(FileType.BMP) || fileType.equals(FileType.GIF) || fileType.equals(FileType.PNG)) {        ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);        BufferedImage bim = ImageIO.read(bais);        return LosslessFactory.createFromImage(document, bim);    }    throw new IllegalArgumentException("Image type " + fileType + " not supported: " + name);}
public PDMetadata pdfbox_f5224_0()
{    COSStream cosStream = getCOSObject().getCOSStream(COSName.METADATA);    if (cosStream != null) {        return new PDMetadata(cosStream);    }    return null;}
public void pdfbox_f5225_0(PDMetadata meta)
{    getCOSObject().setItem(COSName.METADATA, meta);}
public int pdfbox_f5226_0()
{    return getCOSObject().getInt(COSName.STRUCT_PARENT);}
public void pdfbox_f5227_0(int key)
{    getCOSObject().setInt(COSName.STRUCT_PARENT, key);}
public BufferedImage pdfbox_f5228_0() throws IOException
{    return getImage(null, 1);}
public BufferedImage pdfbox_f5229_0(Rectangle region, int subsampling) throws IOException
{    if (region == null && subsampling == cachedImageSubsampling && cachedImage != null) {        BufferedImage cached = cachedImage.get();        if (cached != null) {            return cached;        }    }        BufferedImage image = SampledImageReader.getRGBImage(this, region, subsampling, getColorKeyMask());        PDImageXObject softMask = getSoftMask();    if (softMask != null) {        float[] matte = extractMatte(softMask);        image = applyMask(image, softMask.getOpaqueImage(), true, matte);    } else {                PDImageXObject mask = getMask();        if (mask != null && mask.isStencil()) {            image = applyMask(image, mask.getOpaqueImage(), false, null);        }    }    if (region == null && subsampling <= cachedImageSubsampling) {                        cachedImageSubsampling = subsampling;        cachedImage = new SoftReference<>(image);    }    return image;}
private float[] pdfbox_f5230_0(PDImageXObject softMask) throws IOException
{    COSBase base = softMask.getCOSObject().getItem(COSName.MATTE);    float[] matte = null;    if (base instanceof COSArray) {                        matte = ((COSArray) base).toFloatArray();                matte = getColorSpace().toRGB(matte);    }    return matte;}
public BufferedImage pdfbox_f5231_0(Paint paint) throws IOException
{    if (!isStencil()) {        throw new IllegalStateException("Image is not a stencil");    }    return SampledImageReader.getStencilImage(this, paint);}
public BufferedImage pdfbox_f5232_0() throws IOException
{    return SampledImageReader.getRGBImage(this, null);}
private BufferedImage pdfbox_f5233_0(BufferedImage image, BufferedImage mask, boolean isSoft, float[] matte) throws IOException
{    if (mask == null) {        return image;    }    int width = image.getWidth();    int height = image.getHeight();        if (mask.getWidth() < width || mask.getHeight() < height) {        mask = scaleImage(mask, width, height);    } else if (mask.getWidth() > width || mask.getHeight() > height) {        width = mask.getWidth();        height = mask.getHeight();        image = scaleImage(image, width, height);    } else if (image.getRaster().getPixel(0, 0, (int[]) null).length < 3) {                image = scaleImage(image, width, height);    }        BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    WritableRaster src = image.getRaster();    WritableRaster dest = masked.getRaster();    WritableRaster alpha = mask.getRaster();    float[] rgb = new float[4];    float[] rgba = new float[4];    float[] alphaPixel = null;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            src.getPixel(x, y, rgb);            rgba[0] = rgb[0];            rgba[1] = rgb[1];            rgba[2] = rgb[2];            alphaPixel = alpha.getPixel(x, y, alphaPixel);            if (isSoft) {                rgba[3] = alphaPixel[0];                if (matte != null && Float.compare(alphaPixel[0], 0) != 0) {                    rgba[0] = clampColor(((rgba[0] / 255 - matte[0]) / (alphaPixel[0] / 255) + matte[0]) * 255);                    rgba[1] = clampColor(((rgba[1] / 255 - matte[1]) / (alphaPixel[0] / 255) + matte[1]) * 255);                    rgba[2] = clampColor(((rgba[2] / 255 - matte[2]) / (alphaPixel[0] / 255) + matte[2]) * 255);                }            } else {                rgba[3] = 255 - alphaPixel[0];            }            dest.setPixel(x, y, rgba);        }    }    return masked;}
private float pdfbox_f5234_0(float color)
{    return color < 0 ? 0 : (color > 255 ? 255 : color);}
private BufferedImage pdfbox_f5235_0(BufferedImage image, int width, int height)
{    BufferedImage image2 = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    Graphics2D g = image2.createGraphics();    if (getInterpolate()) {        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);    }    g.drawImage(image, 0, 0, width, height, 0, 0, image.getWidth(), image.getHeight(), null);    g.dispose();    return image2;}
public PDImageXObject pdfbox_f5236_0() throws IOException
{    COSBase mask = getCOSObject().getDictionaryObject(COSName.MASK);    if (mask instanceof COSArray) {                return null;    } else {        COSStream cosStream = getCOSObject().getCOSStream(COSName.MASK);        if (cosStream != null) {                        return new PDImageXObject(new PDStream(cosStream), null);        }        return null;    }}
public COSArray pdfbox_f5237_0()
{    COSBase mask = getCOSObject().getDictionaryObject(COSName.MASK);    if (mask instanceof COSArray) {        return (COSArray) mask;    }    return null;}
public PDImageXObject pdfbox_f5238_0() throws IOException
{    COSStream cosStream = getCOSObject().getCOSStream(COSName.SMASK);    if (cosStream != null) {                return new PDImageXObject(new PDStream(cosStream), null);    }    return null;}
public int pdfbox_f5239_0()
{    if (isStencil()) {        return 1;    } else {        return getCOSObject().getInt(COSName.BITS_PER_COMPONENT, COSName.BPC);    }}
public void pdfbox_f5240_0(int bpc)
{    getCOSObject().setInt(COSName.BITS_PER_COMPONENT, bpc);}
public PDColorSpace pdfbox_f5241_0() throws IOException
{    if (colorSpace == null) {        COSBase cosBase = getCOSObject().getItem(COSName.COLORSPACE, COSName.CS);        if (cosBase != null) {            COSObject indirect = null;            if (cosBase instanceof COSObject && resources != null && resources.getResourceCache() != null) {                                                indirect = (COSObject) cosBase;                colorSpace = resources.getResourceCache().getColorSpace(indirect);                if (colorSpace != null) {                    return colorSpace;                }            }            colorSpace = PDColorSpace.create(cosBase, resources);            if (indirect != null) {                resources.getResourceCache().put(indirect, colorSpace);            }        } else if (isStencil()) {                        return PDDeviceGray.INSTANCE;        } else {                        throw new IOException("could not determine color space");        }    }    return colorSpace;}
public InputStream pdfbox_f5242_0() throws IOException
{    return getStream().createInputStream();}
public InputStream pdfbox_f5243_0(DecodeOptions options) throws IOException
{    return getStream().createInputStream(options);}
public InputStream pdfbox_f5244_0(List<String> stopFilters) throws IOException
{    return getStream().createInputStream(stopFilters);}
public boolean pdfbox_f5245_0()
{    return getStream().getCOSObject().getLength() == 0;}
public void pdfbox_f5246_0(PDColorSpace cs)
{    getCOSObject().setItem(COSName.COLORSPACE, cs != null ? cs.getCOSObject() : null);    colorSpace = null;    cachedImage = null;}
public int pdfbox_f5247_0()
{    return getCOSObject().getInt(COSName.HEIGHT);}
public void pdfbox_f5248_0(int h)
{    getCOSObject().setInt(COSName.HEIGHT, h);}
public int pdfbox_f5249_0()
{    return getCOSObject().getInt(COSName.WIDTH);}
public void pdfbox_f5250_0(int w)
{    getCOSObject().setInt(COSName.WIDTH, w);}
public boolean pdfbox_f5251_0()
{    return getCOSObject().getBoolean(COSName.INTERPOLATE, false);}
public void pdfbox_f5252_0(boolean value)
{    getCOSObject().setBoolean(COSName.INTERPOLATE, value);}
public void pdfbox_f5253_0(COSArray decode)
{    getCOSObject().setItem(COSName.DECODE, decode);}
public COSArray pdfbox_f5254_0()
{    COSBase decode = getCOSObject().getDictionaryObject(COSName.DECODE);    if (decode instanceof COSArray) {        return (COSArray) decode;    }    return null;}
public boolean pdfbox_f5255_0()
{    return getCOSObject().getBoolean(COSName.IMAGE_MASK, false);}
public void pdfbox_f5256_0(boolean isStencil)
{    getCOSObject().setBoolean(COSName.IMAGE_MASK, isStencil);}
public String pdfbox_f5257_1()
{    List<COSName> filters = getStream().getFilters();    if (filters == null) {        return "png";    } else if (filters.contains(COSName.DCT_DECODE)) {        return "jpg";    } else if (filters.contains(COSName.JPX_DECODE)) {        return "jpx";    } else if (filters.contains(COSName.CCITTFAX_DECODE)) {        return "tiff";    } else if (filters.contains(COSName.FLATE_DECODE) || filters.contains(COSName.LZW_DECODE) || filters.contains(COSName.RUN_LENGTH_DECODE)) {        return "png";    } else if (filters.contains(COSName.JBIG2_DECODE)) {        return "jb2";    } else {                return null;    }}
public COSBase pdfbox_f5258_0()
{    return parameters;}
public int pdfbox_f5259_0()
{    if (isStencil()) {        return 1;    } else {        return parameters.getInt(COSName.BPC, COSName.BITS_PER_COMPONENT, -1);    }}
public void pdfbox_f5260_0(int bitsPerComponent)
{    parameters.setInt(COSName.BPC, bitsPerComponent);}
public PDColorSpace pdfbox_f5261_0() throws IOException
{    COSBase cs = parameters.getDictionaryObject(COSName.CS, COSName.COLORSPACE);    if (cs != null) {        return createColorSpace(cs);    } else if (isStencil()) {                return PDDeviceGray.INSTANCE;    } else {                throw new IOException("could not determine inline image color space");    }}
private COSBase pdfbox_f5262_0(COSBase cs)
{    if (COSName.RGB.equals(cs)) {        return COSName.DEVICERGB;    }    if (COSName.CMYK.equals(cs)) {        return COSName.DEVICECMYK;    }    if (COSName.G.equals(cs)) {        return COSName.DEVICEGRAY;    }    return cs;}
private PDColorSpace pdfbox_f5263_0(COSBase cs) throws IOException
{    if (cs instanceof COSName) {        return PDColorSpace.create(toLongName(cs), resources);    }    if (cs instanceof COSArray && ((COSArray) cs).size() > 1) {        COSArray srcArray = (COSArray) cs;        COSBase csType = srcArray.get(0);        if (COSName.I.equals(csType) || COSName.INDEXED.equals(csType)) {            COSArray dstArray = new COSArray();            dstArray.addAll(srcArray);            dstArray.set(0, COSName.INDEXED);            dstArray.set(1, toLongName(srcArray.get(1)));            return PDColorSpace.create(dstArray, resources);        }        throw new IOException("Illegal type of inline image color space: " + csType);    }    throw new IOException("Illegal type of object for inline image color space: " + cs);}
public void pdfbox_f5264_0(PDColorSpace colorSpace)
{    COSBase base = null;    if (colorSpace != null) {        base = colorSpace.getCOSObject();    }    parameters.setItem(COSName.CS, base);}
public int pdfbox_f5265_0()
{    return parameters.getInt(COSName.H, COSName.HEIGHT, -1);}
public void pdfbox_f5266_0(int height)
{    parameters.setInt(COSName.H, height);}
public int pdfbox_f5267_0()
{    return parameters.getInt(COSName.W, COSName.WIDTH, -1);}
public void pdfbox_f5268_0(int width)
{    parameters.setInt(COSName.W, width);}
public boolean pdfbox_f5269_0()
{    return parameters.getBoolean(COSName.I, COSName.INTERPOLATE, false);}
public void pdfbox_f5270_0(boolean value)
{    parameters.setBoolean(COSName.I, value);}
public List<String> pdfbox_f5271_0()
{    List<String> names = null;    COSBase filters = parameters.getDictionaryObject(COSName.F, COSName.FILTER);    if (filters instanceof COSName) {        COSName name = (COSName) filters;        names = new COSArrayList<>(name.getName(), name, parameters, COSName.FILTER);    } else if (filters instanceof COSArray) {        names = COSArrayList.convertCOSNameCOSArrayToList((COSArray) filters);    }    return names;}
public void pdfbox_f5272_0(List<String> filters)
{    COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray(filters);    parameters.setItem(COSName.F, obj);}
public void pdfbox_f5273_0(COSArray decode)
{    parameters.setItem(COSName.D, decode);}
public COSArray pdfbox_f5274_0()
{    return (COSArray) parameters.getDictionaryObject(COSName.D, COSName.DECODE);}
public boolean pdfbox_f5275_0()
{    return parameters.getBoolean(COSName.IM, COSName.IMAGE_MASK, false);}
public void pdfbox_f5276_0(boolean isStencil)
{    parameters.setBoolean(COSName.IM, isStencil);}
public InputStream pdfbox_f5277_0() throws IOException
{    return new ByteArrayInputStream(decodedData);}
public InputStream pdfbox_f5278_0(DecodeOptions options) throws IOException
{        return createInputStream();}
public InputStream pdfbox_f5279_0(List<String> stopFilters) throws IOException
{    List<String> filters = getFilters();    ByteArrayInputStream in = new ByteArrayInputStream(rawData);    ByteArrayOutputStream out = new ByteArrayOutputStream(rawData.length);    for (int i = 0; filters != null && i < filters.size(); i++) {                out.reset();        if (stopFilters.contains(filters.get(i))) {            break;        } else {            Filter filter = FilterFactory.INSTANCE.getFilter(filters.get(i));            filter.decode(in, out, parameters, i);            in = new ByteArrayInputStream(out.toByteArray());        }    }    return new ByteArrayInputStream(out.toByteArray());}
public boolean pdfbox_f5280_0()
{    return decodedData.length == 0;}
public byte[] pdfbox_f5281_0()
{    return decodedData;}
public BufferedImage pdfbox_f5282_0() throws IOException
{    return SampledImageReader.getRGBImage(this, null);}
public BufferedImage pdfbox_f5283_0(Rectangle region, int subsampling) throws IOException
{    return SampledImageReader.getRGBImage(this, region, subsampling, null);}
public BufferedImage pdfbox_f5284_0(Paint paint) throws IOException
{    if (!isStencil()) {        throw new IllegalStateException("Image is not a stencil");    }    return SampledImageReader.getStencilImage(this, paint);}
public String pdfbox_f5285_0()
{        return null;}
 static PDImageXObject pdfbox_f5286_0(PDDocument doc, byte[] imageData) throws IOException
{    PNGConverterState state = parsePNGChunks(imageData);    if (!checkConverterState(state)) {                return null;    }    return convertPng(doc, state);}
private static PDImageXObject pdfbox_f5287_1(PDDocument doc, PNGConverterState state) throws IOException
{    Chunk ihdr = state.IHDR;    int ihdrStart = ihdr.start;    int width = readInt(ihdr.bytes, ihdrStart);    int height = readInt(ihdr.bytes, ihdrStart + 4);    int bitDepth = ihdr.bytes[ihdrStart + 8] & 0xFF;    int colorType = ihdr.bytes[ihdrStart + 9] & 0xFF;    int compressionMethod = ihdr.bytes[ihdrStart + 10] & 0xFF;    int filterMethod = ihdr.bytes[ihdrStart + 11] & 0xFF;    int interlaceMethod = ihdr.bytes[ihdrStart + 12] & 0xFF;    if (bitDepth != 1 && bitDepth != 2 && bitDepth != 4 && bitDepth != 8 && bitDepth != 16) {                return null;    }    if (width <= 0 || height <= 0) {                return null;    }    if (compressionMethod != 0) {                return null;    }    if (filterMethod != 0) {                return null;    }    if (interlaceMethod != 0) {                return null;    }    state.width = width;    state.height = height;    state.bitsPerComponent = bitDepth;    switch(colorType) {        case 0:                                    return null;        case 2:                        if (state.tRNS != null) {                                return null;            }            return buildImageObject(doc, state);        case 3:                        return buildIndexImage(doc, state);        case 4:                                    return null;        case 6:                                    return null;        default:                        return null;    }}
private static PDImageXObject pdfbox_f5288_1(PDDocument doc, PNGConverterState state) throws IOException
{    Chunk plte = state.PLTE;    if (plte == null) {                return null;    }    if (plte.length % 3 != 0) {                return null;    }    if (state.bitsPerComponent > 8) {                return null;    }    PDImageXObject image = buildImageObject(doc, state);    if (image == null) {        return null;    }    int highVal = (plte.length / 3) - 1;    if (highVal > 255) {                return null;    }    setupIndexedColorSpace(doc, plte, image, highVal);    if (state.tRNS != null) {        image.getCOSObject().setItem(COSName.SMASK, buildTransparencyMaskFromIndexedData(doc, image, state));    }    return image;}
private static PDImageXObject pdfbox_f5289_0(PDDocument doc, PDImageXObject image, PNGConverterState state) throws IOException
{    Filter flateDecode = FilterFactory.INSTANCE.getFilter(COSName.FLATE_DECODE);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    COSDictionary decodeParams = buildDecodeParams(state, PDDeviceGray.INSTANCE);    COSDictionary imageDict = new COSDictionary();    imageDict.setItem(COSName.FILTER, COSName.FLATE_DECODE);    imageDict.setItem(COSName.DECODE_PARMS, decodeParams);    flateDecode.decode(getIDATInputStream(state), outputStream, imageDict, 0);    int length = image.getWidth() * image.getHeight();    byte[] bytes = new byte[length];    byte[] transparencyTable = state.tRNS.getData();    byte[] decodedIDAT = outputStream.toByteArray();    try (ImageInputStream iis = new MemoryCacheImageInputStream(new ByteArrayInputStream(decodedIDAT))) {        int bitsPerComponent = state.bitsPerComponent;        int w = 0;        int neededBits = bitsPerComponent * state.width;        int bitPadding = neededBits % 8;        for (int i = 0; i < bytes.length; i++) {            int idx = (int) iis.readBits(bitsPerComponent);            byte v;            if (idx < transparencyTable.length) {                                v = transparencyTable[idx];            } else {                                v = (byte) 0xFF;            }            bytes[i] = v;            w++;            if (w == state.width) {                w = 0;                iis.readBits(bitPadding);            }        }    }    return LosslessFactory.prepareImageXObject(doc, bytes, image.getWidth(), image.getHeight(), 8, PDDeviceGray.INSTANCE);}
private static void pdfbox_f5290_0(PDDocument doc, Chunk lookupTable, PDImageXObject image, int highVal) throws IOException
{    COSArray indexedArray = new COSArray();    indexedArray.add(COSName.INDEXED);    indexedArray.add(image.getColorSpace());    ((COSDictionary) image.getCOSObject().getItem(COSName.DECODE_PARMS)).setItem(COSName.COLORS, COSInteger.ONE);    indexedArray.add(COSInteger.get(highVal));    PDStream colorTable = new PDStream(doc);    try (OutputStream colorTableStream = colorTable.createOutputStream(COSName.FLATE_DECODE)) {        colorTableStream.write(lookupTable.bytes, lookupTable.start, lookupTable.length);    }    indexedArray.add(colorTable);    PDIndexed indexed = new PDIndexed(indexedArray);    image.setColorSpace(indexed);}
private static PDImageXObject pdfbox_f5291_1(PDDocument document, PNGConverterState state) throws IOException
{    InputStream encodedByteStream = getIDATInputStream(state);    PDColorSpace colorSpace = PDDeviceRGB.INSTANCE;    PDImageXObject imageXObject = new PDImageXObject(document, encodedByteStream, COSName.FLATE_DECODE, state.width, state.height, state.bitsPerComponent, colorSpace);    COSDictionary decodeParams = buildDecodeParams(state, colorSpace);    imageXObject.getCOSObject().setItem(COSName.DECODE_PARMS, decodeParams);            boolean hasICCColorProfile = state.sRGB != null || state.iCCP != null;    if (state.gAMA != null && !hasICCColorProfile) {        if (state.gAMA.length != 4) {                        return null;        }        float gamma = readPNGFloat(state.gAMA.bytes, state.gAMA.start);                if (Math.abs(gamma - (1 / 2.2f)) > 0.00001) {                        return null;        }    }    if (state.sRGB != null) {        if (state.sRGB.length != 1) {                        return null;        }                int renderIntent = state.sRGB.bytes[state.sRGB.start];        COSName value = mapPNGRenderIntent(renderIntent);        imageXObject.getCOSObject().setItem(COSName.INTENT, value);    }    if (state.cHRM != null && !hasICCColorProfile) {        if (state.cHRM.length != 32) {                        return null;        }                return null;    }        if (state.iCCP != null || state.sRGB != null) {                PDICCBased profile = new PDICCBased(document);        COSStream cosStream = profile.getPDStream().getCOSObject();        cosStream.setInt(COSName.N, colorSpace.getNumberOfComponents());        cosStream.setItem(COSName.ALTERNATE, colorSpace.getNumberOfComponents() == 1 ? COSName.DEVICEGRAY : COSName.DEVICERGB);        if (state.iCCP != null) {                        int iccProfileDataStart = 0;            while (iccProfileDataStart < 80 && iccProfileDataStart < state.iCCP.length) {                if (state.iCCP.bytes[state.iCCP.start + iccProfileDataStart] == 0)                    break;                iccProfileDataStart++;            }            if (iccProfileDataStart >= state.iCCP.length) {                                return null;            }            byte compressionMethod = state.iCCP.bytes[state.iCCP.start + iccProfileDataStart];            if (compressionMethod != 0) {                                return null;            }                        iccProfileDataStart++;            try (OutputStream rawOutputStream = cosStream.createRawOutputStream()) {                rawOutputStream.write(state.iCCP.bytes, state.iCCP.start + iccProfileDataStart, state.iCCP.length - iccProfileDataStart);            }        } else {                        ICC_Profile rgbProfile = ICC_Profile.getInstance(ColorSpace.CS_sRGB);            try (OutputStream outputStream = cosStream.createRawOutputStream()) {                outputStream.write(rgbProfile.getData());            }        }        imageXObject.setColorSpace(profile);    }    return imageXObject;}
private static COSDictionary pdfbox_f5292_0(PNGConverterState state, PDColorSpace colorSpace)
{    COSDictionary decodeParms = new COSDictionary();    decodeParms.setItem(COSName.BITS_PER_COMPONENT, COSInteger.get(state.bitsPerComponent));    decodeParms.setItem(COSName.PREDICTOR, COSInteger.get(15));    decodeParms.setItem(COSName.COLUMNS, COSInteger.get(state.width));    decodeParms.setItem(COSName.COLORS, COSInteger.get(colorSpace.getNumberOfComponents()));    return decodeParms;}
private static InputStream pdfbox_f5293_0(PNGConverterState state)
{    MultipleInputStream inputStream = new MultipleInputStream();    for (Chunk idat : state.IDATs) {        inputStream.inputStreams.add(new ByteArrayInputStream(idat.bytes, idat.start, idat.length));    }    return inputStream;}
private boolean pdfbox_f5294_0()
{    if (currentStream == null) {        if (currentStreamIdx >= inputStreams.size()) {            return false;        }        currentStream = inputStreams.get(currentStreamIdx++);    }    return true;}
public int pdfbox_f5295_0() throws IOException
{    throw new IllegalStateException("Only bulk reads are expected!");}
public int pdfbox_f5296_0() throws IOException
{    if (!ensureStream()) {        return 0;    }    return 1;}
public int pdfbox_f5297_0(byte[] b, int off, int len) throws IOException
{    if (!ensureStream()) {        return -1;    }    int ret = currentStream.read(b, off, len);    if (ret == -1) {        currentStream = null;        return read(b, off, len);    }    return ret;}
 static COSName pdfbox_f5298_0(int renderIntent)
{    COSName value;    switch(renderIntent) {        case 0:            value = COSName.PERCEPTUAL;            break;        case 1:            value = COSName.RELATIVE_COLORIMETRIC;            break;        case 2:            value = COSName.SATURATION;            break;        case 3:            value = COSName.ABSOLUTE_COLORIMETRIC;            break;        default:            value = null;            break;    }    return value;}
 static boolean pdfbox_f5299_1(PNGConverterState state)
{    if (state == null) {        return false;    }    if (state.IHDR == null || !checkChunkSane(state.IHDR)) {                return false;    }    if (!checkChunkSane(state.PLTE)) {                return false;    }    if (!checkChunkSane(state.iCCP)) {                return false;    }    if (!checkChunkSane(state.tRNS)) {                return false;    }    if (!checkChunkSane(state.sRGB)) {                return false;    }    if (!checkChunkSane(state.cHRM)) {                return false;    }    if (!checkChunkSane(state.gAMA)) {                return false;    }        if (state.IDATs.isEmpty()) {                return false;    }    for (Chunk idat : state.IDATs) {        if (!checkChunkSane(idat)) {                        return false;        }    }    return true;}
 static boolean pdfbox_f5300_1(Chunk chunk)
{    if (chunk == null) {                return true;    }    if (chunk.start + chunk.length > chunk.bytes.length) {        return false;    }    if (chunk.start < 4) {        return false;    }        int ourCRC = crc(chunk.bytes, chunk.start - 4, chunk.length + 4);    if (ourCRC != chunk.crc) {                return false;    }    return true;}
 byte[] pdfbox_f5301_0()
{    return Arrays.copyOfRange(bytes, start, start + length);}
private static int pdfbox_f5302_0(byte[] data, int offset)
{    int b1 = (data[offset] & 0xFF) << 24;    int b2 = (data[offset + 1] & 0xFF) << 16;    int b3 = (data[offset + 2] & 0xFF) << 8;    int b4 = (data[offset + 3] & 0xFF);    return b1 | b2 | b3 | b4;}
private static float pdfbox_f5303_0(byte[] bytes, int offset)
{    int v = readInt(bytes, offset);    return v / 100000f;}
private static PNGConverterState pdfbox_f5304_1(byte[] imageData)
{    if (imageData.length < 20) {                return null;    }    PNGConverterState state = new PNGConverterState();    int ptr = 8;    int firstChunkType = readInt(imageData, ptr + 4);    if (firstChunkType != CHUNK_IHDR) {                return null;    }    while (ptr + 12 <= imageData.length) {        int chunkLength = readInt(imageData, ptr);        int chunkType = readInt(imageData, ptr + 4);        ptr += 8;        if (ptr + chunkLength + 4 > imageData.length) {                        return null;        }        Chunk chunk = new Chunk();        chunk.chunkType = chunkType;        chunk.bytes = imageData;        chunk.start = ptr;        chunk.length = chunkLength;        switch(chunkType) {            case CHUNK_IHDR:                if (state.IHDR != null) {                                        return null;                }                state.IHDR = chunk;                break;            case CHUNK_IDAT:                                state.IDATs.add(chunk);                break;            case CHUNK_PLTE:                                if (state.PLTE != null) {                                        return null;                }                state.PLTE = chunk;                break;            case CHUNK_IEND:                                return state;            case CHUNK_TRNS:                                if (state.tRNS != null) {                                        return null;                }                state.tRNS = chunk;                break;            case CHUNK_GAMA:                                state.gAMA = chunk;                break;            case CHUNK_CHRM:                                state.cHRM = chunk;                break;            case CHUNK_ICCP:                                state.iCCP = chunk;                break;            case CHUNK_SBIT:                                break;            case CHUNK_SRGB:                                state.sRGB = chunk;                break;            case CHUNK_TEXT:            case CHUNK_ZTXT:            case CHUNK_ITXT:                                break;            case CHUNK_KBKG:                                break;            case CHUNK_HIST:                                break;            case CHUNK_PHYS:                                break;            case CHUNK_SPLT:                                break;            case CHUNK_TIME:                                break;            default:                                break;        }        ptr += chunkLength;                chunk.crc = readInt(imageData, ptr);        ptr += 4;    }        return null;}
private static void pdfbox_f5305_0()
{    int c;    for (int n = 0; n < 256; n++) {        c = n;        for (int k = 0; k < 8; k++) {            if ((c & 1) != 0) {                c = 0xEDB88320 ^ (c >>> 1);            } else {                c = c >>> 1;            }        }        CRC_TABLE[n] = c;    }}
private static int pdfbox_f5306_0(byte[] buf, int offset, int len)
{    int c = -1;    int end = offset + len;    for (int n = offset; n < end; n++) {        c = CRC_TABLE[(c ^ buf[n]) & 0xff] ^ (c >>> 8);    }    return c;}
 static int pdfbox_f5307_0(byte[] buf, int offset, int len)
{    return ~updateCrc(buf, offset, len);}
public static BufferedImage pdfbox_f5308_1(PDImage pdImage, Paint paint) throws IOException
{    int width = pdImage.getWidth();    int height = pdImage.getHeight();        BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    Graphics2D g = masked.createGraphics();                    g.setPaint(paint);    g.fillRect(0, 0, width, height);    g.dispose();        WritableRaster raster = masked.getRaster();    final int[] transparent = new int[4];        try (InputStream iis = pdImage.createInputStream()) {        final float[] decode = getDecodeArray(pdImage);        int value = decode[0] < decode[1] ? 1 : 0;        int rowLen = width / 8;        if (width % 8 > 0) {            rowLen++;        }        byte[] buff = new byte[rowLen];        for (int y = 0; y < height; y++) {            int x = 0;            int readLen = iis.read(buff);            for (int r = 0; r < rowLen && r < readLen; r++) {                int byteValue = buff[r];                int mask = 128;                int shift = 7;                for (int i = 0; i < 8; i++) {                    int bit = (byteValue & mask) >> shift;                    mask >>= 1;                    --shift;                    if (bit == value) {                        raster.setPixel(x, y, transparent);                    }                    x++;                    if (x == width) {                        break;                    }                }            }            if (readLen != rowLen) {                                break;            }        }    }    return masked;}
public static BufferedImage pdfbox_f5309_0(PDImage pdImage, COSArray colorKey) throws IOException
{    return getRGBImage(pdImage, null, 1, colorKey);}
private static Rectangle pdfbox_f5310_0(PDImage pdImage, Rectangle region)
{    if (region == null) {        return new Rectangle(0, 0, pdImage.getWidth(), pdImage.getHeight());    } else {        int x = Math.max(0, region.x);        int y = Math.max(0, region.y);        int width = Math.min(region.width, pdImage.getWidth() - x);        int height = Math.min(region.height, pdImage.getHeight() - y);        return new Rectangle(x, y, width, height);    }}
public static BufferedImage pdfbox_f5311_0(PDImage pdImage, Rectangle region, int subsampling, COSArray colorKey) throws IOException
{    if (pdImage.isEmpty()) {        throw new IOException("Image stream is empty");    }    Rectangle clipped = clipRegion(pdImage, region);        final PDColorSpace colorSpace = pdImage.getColorSpace();    final int numComponents = colorSpace.getNumberOfComponents();    final int width = (int) Math.ceil(clipped.getWidth() / subsampling);    final int height = (int) Math.ceil(clipped.getHeight() / subsampling);    final int bitsPerComponent = pdImage.getBitsPerComponent();    final float[] decode = getDecodeArray(pdImage);    if (width <= 0 || height <= 0 || pdImage.getWidth() <= 0 || pdImage.getHeight() <= 0) {        throw new IOException("image width and height must be positive");    }    try {        if (bitsPerComponent == 1 && colorKey == null && numComponents == 1) {            return from1Bit(pdImage, clipped, subsampling, width, height);        }                                                WritableRaster raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, width, height, numComponents, new Point(0, 0));        final float[] defaultDecode = pdImage.getColorSpace().getDefaultDecode(8);        if (bitsPerComponent == 8 && Arrays.equals(decode, defaultDecode) && colorKey == null) {                        return from8bit(pdImage, raster, clipped, subsampling, width, height);        }        return fromAny(pdImage, raster, colorKey, clipped, subsampling, width, height);    } catch (NegativeArraySizeException ex) {        throw new IOException(ex);    }}
private static BufferedImage pdfbox_f5312_1(PDImage pdImage, Rectangle clipped, final int subsampling, final int width, final int height) throws IOException
{    int currentSubsampling = subsampling;    final PDColorSpace colorSpace = pdImage.getColorSpace();    final float[] decode = getDecodeArray(pdImage);    BufferedImage bim = null;    WritableRaster raster;    byte[] output;    DecodeOptions options = new DecodeOptions(currentSubsampling);    options.setSourceRegion(clipped);        try (InputStream iis = pdImage.createInputStream(options)) {        final int inputWidth;        final int startx;        final int starty;        final int scanWidth;        final int scanHeight;        if (options.isFilterSubsampled()) {                        inputWidth = width;            startx = 0;            starty = 0;            scanWidth = width;            scanHeight = height;            currentSubsampling = 1;        } else {                        inputWidth = pdImage.getWidth();            startx = clipped.x;            starty = clipped.y;            scanWidth = clipped.width;            scanHeight = clipped.height;        }        if (colorSpace instanceof PDDeviceGray) {                                                bim = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);            raster = bim.getRaster();        } else {            raster = Raster.createBandedRaster(DataBuffer.TYPE_BYTE, width, height, 1, new Point(0, 0));        }        output = ((DataBufferByte) raster.getDataBuffer()).getData();        final boolean isIndexed = colorSpace instanceof PDIndexed;        int rowLen = inputWidth / 8;        if (inputWidth % 8 > 0) {            rowLen++;        }                byte value0;        byte value1;        if (isIndexed || decode[0] < decode[1]) {            value0 = 0;            value1 = (byte) 255;        } else {            value0 = (byte) 255;            value1 = 0;        }        byte[] buff = new byte[rowLen];        int idx = 0;        for (int y = 0; y < starty + scanHeight; y++) {            int x = 0;            int readLen = iis.read(buff);            if (y < starty || y % currentSubsampling > 0) {                continue;            }            for (int r = 0; r < rowLen && r < readLen; r++) {                int value = buff[r];                int mask = 128;                for (int i = 0; i < 8; i++) {                    if (x >= startx + scanWidth) {                        break;                    }                    int bit = value & mask;                    mask >>= 1;                    if (x >= startx && x % currentSubsampling == 0) {                        output[idx++] = bit == 0 ? value0 : value1;                    }                    x++;                }            }            if (readLen != rowLen) {                                break;            }        }        if (bim != null) {            return bim;        }                return colorSpace.toRGBImage(raster);    }}
private static BufferedImage pdfbox_f5313_1(PDImage pdImage, WritableRaster raster, Rectangle clipped, final int subsampling, final int width, final int height) throws IOException
{    int currentSubsampling = subsampling;    DecodeOptions options = new DecodeOptions(currentSubsampling);    options.setSourceRegion(clipped);    try (InputStream input = pdImage.createInputStream(options)) {        final int inputWidth;        final int startx;        final int starty;        final int scanWidth;        final int scanHeight;        if (options.isFilterSubsampled()) {                        inputWidth = width;            startx = 0;            starty = 0;            scanWidth = width;            scanHeight = height;            currentSubsampling = 1;        } else {                        inputWidth = pdImage.getWidth();            startx = clipped.x;            starty = clipped.y;            scanWidth = clipped.width;            scanHeight = clipped.height;        }        final int numComponents = pdImage.getColorSpace().getNumberOfComponents();                byte[] bank = ((DataBufferByte) raster.getDataBuffer()).getData();        if (startx == 0 && starty == 0 && scanWidth == width && scanHeight == height && currentSubsampling == 1) {                        long inputResult = input.read(bank);            if (Long.compare(inputResult, width * height * (long) numComponents) != 0) {                            }            return pdImage.getColorSpace().toRGBImage(raster);        }                        byte[] tempBytes = new byte[numComponents * inputWidth];                                int i = 0;        for (int y = 0; y < starty + scanHeight; ++y) {            long inputResult = input.read(tempBytes);            if (Long.compare(inputResult, tempBytes.length) != 0) {                            }            if (y < starty || y % currentSubsampling > 0) {                continue;            }            if (currentSubsampling == 1) {                                                System.arraycopy(tempBytes, startx * numComponents, bank, y * inputWidth * numComponents, scanWidth * numComponents);            } else {                for (int x = startx; x < startx + scanWidth; x += currentSubsampling) {                    for (int c = 0; c < numComponents; c++) {                        bank[i] = tempBytes[x * numComponents + c];                        ++i;                    }                }            }        }                return pdImage.getColorSpace().toRGBImage(raster);    }}
private static BufferedImage pdfbox_f5314_0(PDImage pdImage, WritableRaster raster, COSArray colorKey, Rectangle clipped, final int subsampling, final int width, final int height) throws IOException
{    int currentSubsampling = subsampling;    final PDColorSpace colorSpace = pdImage.getColorSpace();    final int numComponents = colorSpace.getNumberOfComponents();    final int bitsPerComponent = pdImage.getBitsPerComponent();    final float[] decode = getDecodeArray(pdImage);    DecodeOptions options = new DecodeOptions(currentSubsampling);    options.setSourceRegion(clipped);        try (ImageInputStream iis = new MemoryCacheImageInputStream(pdImage.createInputStream(options))) {        final int inputWidth;        final int startx;        final int starty;        final int scanWidth;        final int scanHeight;        if (options.isFilterSubsampled()) {                        inputWidth = width;            startx = 0;            starty = 0;            scanWidth = width;            scanHeight = height;            currentSubsampling = 1;        } else {                        inputWidth = pdImage.getWidth();            startx = clipped.x;            starty = clipped.y;            scanWidth = clipped.width;            scanHeight = clipped.height;        }        final float sampleMax = (float) Math.pow(2, bitsPerComponent) - 1f;        final boolean isIndexed = colorSpace instanceof PDIndexed;                float[] colorKeyRanges = null;        BufferedImage colorKeyMask = null;        if (colorKey != null) {            colorKeyRanges = colorKey.toFloatArray();            colorKeyMask = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);        }                int padding = 0;        if (inputWidth * numComponents * bitsPerComponent % 8 > 0) {            padding = 8 - (inputWidth * numComponents * bitsPerComponent % 8);        }                byte[] srcColorValues = new byte[numComponents];        byte[] alpha = new byte[1];        for (int y = 0; y < starty + scanHeight; y++) {            for (int x = 0; x < startx + scanWidth; x++) {                boolean isMasked = true;                for (int c = 0; c < numComponents; c++) {                    int value = (int) iis.readBits(bitsPerComponent);                                        if (colorKeyRanges != null) {                        isMasked &= value >= colorKeyRanges[c * 2] && value <= colorKeyRanges[c * 2 + 1];                    }                                        final float dMin = decode[c * 2];                    final float dMax = decode[(c * 2) + 1];                                        float output = dMin + (value * ((dMax - dMin) / sampleMax));                    if (isIndexed) {                                                                                                srcColorValues[c] = (byte) Math.round(output);                    } else {                                                int outputByte = Math.round(((output - Math.min(dMin, dMax)) / Math.abs(dMax - dMin)) * 255f);                        srcColorValues[c] = (byte) outputByte;                    }                }                                if (x >= startx && y >= starty && x % currentSubsampling == 0 && y % currentSubsampling == 0) {                    raster.setDataElements((x - startx) / currentSubsampling, (y - starty) / currentSubsampling, srcColorValues);                                        if (colorKeyMask != null) {                        alpha[0] = (byte) (isMasked ? 255 : 0);                        colorKeyMask.getRaster().setDataElements((x - startx) / currentSubsampling, (y - starty) / currentSubsampling, alpha);                    }                }            }                        iis.readBits(padding);        }                BufferedImage rgbImage = colorSpace.toRGBImage(raster);                if (colorKeyMask != null) {            return applyColorKeyMask(rgbImage, colorKeyMask);        } else {            return rgbImage;        }    }}
private static BufferedImage pdfbox_f5315_0(BufferedImage image, BufferedImage mask) throws IOException
{    int width = image.getWidth();    int height = image.getHeight();        BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    WritableRaster src = image.getRaster();    WritableRaster dest = masked.getRaster();    WritableRaster alpha = mask.getRaster();    float[] rgb = new float[3];    float[] rgba = new float[4];    float[] alphaPixel = null;    for (int y = 0; y < height; y++) {        for (int x = 0; x < width; x++) {            src.getPixel(x, y, rgb);            rgba[0] = rgb[0];            rgba[1] = rgb[1];            rgba[2] = rgb[2];            alphaPixel = alpha.getPixel(x, y, alphaPixel);            rgba[3] = 255 - alphaPixel[0];            dest.setPixel(x, y, rgba);        }    }    return masked;}
private static float[] pdfbox_f5316_1(PDImage pdImage) throws IOException
{    final COSArray cosDecode = pdImage.getDecode();    float[] decode = null;    if (cosDecode != null) {        int numberOfComponents = pdImage.getColorSpace().getNumberOfComponents();        if (cosDecode.size() != numberOfComponents * 2) {            if (pdImage.isStencil() && cosDecode.size() >= 2 && cosDecode.get(0) instanceof COSNumber && cosDecode.get(1) instanceof COSNumber) {                float decode0 = ((COSNumber) cosDecode.get(0)).floatValue();                float decode1 = ((COSNumber) cosDecode.get(1)).floatValue();                if (decode0 >= 0 && decode0 <= 1 && decode1 >= 0 && decode1 <= 1) {                                        return new float[] { decode0, decode1 };                }            }                    } else {            decode = cosDecode.toFloatArray();        }    }        if (decode == null) {        return pdImage.getColorSpace().getDefaultDecode(pdImage.getBitsPerComponent());    }    return decode;}
public static RenderState pdfbox_f5317_0(COSName state)
{    if (state == null) {        return null;    }    return RenderState.valueOf(state.getName().toUpperCase());}
public COSName pdfbox_f5318_0()
{    return this.name;}
public String pdfbox_f5319_0()
{    return dict.getString(COSName.NAME);}
public final void pdfbox_f5320_0(String name)
{    dict.setString(COSName.NAME, name);}
public RenderState pdfbox_f5321_0(RenderDestination destination)
{    COSName state = null;    COSDictionary usage = (COSDictionary) dict.getDictionaryObject("Usage");    if (usage != null) {        if (RenderDestination.PRINT.equals(destination)) {            COSDictionary print = (COSDictionary) usage.getDictionaryObject("Print");            state = print == null ? null : (COSName) print.getDictionaryObject("PrintState");        } else if (RenderDestination.VIEW.equals(destination)) {            COSDictionary view = (COSDictionary) usage.getDictionaryObject("View");            state = view == null ? null : (COSName) view.getDictionaryObject("ViewState");        }                if (state == null) {            COSDictionary export = (COSDictionary) usage.getDictionaryObject("Export");            state = export == null ? null : (COSName) export.getDictionaryObject("ExportState");        }    }    return state == null ? null : RenderState.valueOf(state);}
public String pdfbox_f5322_0()
{    return super.toString() + " (" + getName() + ")";}
public List<PDPropertyList> pdfbox_f5323_0()
{    List<PDPropertyList> list = new ArrayList<>();    COSBase base = dict.getDictionaryObject(COSName.OCGS);    if (base instanceof COSDictionary) {        list.add(PDPropertyList.create((COSDictionary) base));    } else if (base instanceof COSArray) {        COSArray ar = (COSArray) base;        for (int i = 0; i < ar.size(); ++i) {            COSBase elem = ar.getObject(i);            if (elem instanceof COSDictionary) {                list.add(PDPropertyList.create((COSDictionary) elem));            }        }    }    return list;}
public void pdfbox_f5324_0(List<PDPropertyList> ocgs)
{    COSArray ar = new COSArray();    for (PDPropertyList prop : ocgs) {        ar.add(prop);    }    dict.setItem(COSName.OCGS, ar);}
public COSName pdfbox_f5325_0()
{    return dict.getCOSName(COSName.P, COSName.ANY_ON);}
public void pdfbox_f5326_0(COSName visibilityPolicy)
{    dict.setItem(COSName.P, visibilityPolicy);}
public COSName pdfbox_f5327_0()
{    return this.name;}
public static BaseState pdfbox_f5328_0(COSName state)
{    if (state == null) {        return BaseState.ON;    }    return BaseState.valueOf(state.getName().toUpperCase());}
public COSBase pdfbox_f5329_0()
{    return this.dict;}
private COSArray pdfbox_f5330_0()
{    COSArray ocgs = this.dict.getCOSArray(COSName.OCGS);    if (ocgs == null) {        ocgs = new COSArray();                this.dict.setItem(COSName.OCGS, ocgs);    }    return ocgs;}
private COSDictionary pdfbox_f5331_0()
{    COSBase base = this.dict.getDictionaryObject(COSName.D);    if (base instanceof COSDictionary) {        return (COSDictionary) base;    }    COSDictionary d = new COSDictionary();        d.setString(COSName.NAME, "Top");        this.dict.setItem(COSName.D, d);    return d;}
public PDOptionalContentGroup pdfbox_f5332_0(String name)
{    COSArray ocgs = getOCGs();    for (COSBase o : ocgs) {        COSDictionary ocg = toDictionary(o);        String groupName = ocg.getString(COSName.NAME);        if (groupName.equals(name)) {            return new PDOptionalContentGroup(ocg);        }    }    return null;}
public void pdfbox_f5333_0(PDOptionalContentGroup ocg)
{    COSArray ocgs = getOCGs();    ocgs.add(ocg.getCOSObject());        COSArray order = (COSArray) getD().getDictionaryObject(COSName.ORDER);    if (order == null) {        order = new COSArray();        getD().setItem(COSName.ORDER, order);    }    order.add(ocg);}
public Collection<PDOptionalContentGroup> pdfbox_f5334_0()
{    Collection<PDOptionalContentGroup> coll = new ArrayList<>();    COSArray ocgs = getOCGs();    for (COSBase base : ocgs) {        coll.add(new PDOptionalContentGroup(toDictionary(base)));    }    return coll;}
public BaseState pdfbox_f5335_0()
{    COSDictionary d = getD();    COSName name = (COSName) d.getItem(COSName.BASE_STATE);    return BaseState.valueOf(name);}
public void pdfbox_f5336_0(BaseState state)
{    COSDictionary d = getD();    d.setItem(COSName.BASE_STATE, state.getName());}
public String[] pdfbox_f5337_0()
{    COSArray ocgs = (COSArray) dict.getDictionaryObject(COSName.OCGS);    int size = ocgs.size();    String[] groups = new String[size];    for (int i = 0; i < size; i++) {        COSBase obj = ocgs.get(i);        COSDictionary ocg = toDictionary(obj);        groups[i] = ocg.getString(COSName.NAME);    }    return groups;}
public boolean pdfbox_f5338_0(String groupName)
{    String[] layers = getGroupNames();    for (String layer : layers) {        if (layer.equals(groupName)) {            return true;        }    }    return false;}
public boolean pdfbox_f5339_0(String groupName)
{    boolean result = false;    COSArray ocgs = getOCGs();    for (COSBase o : ocgs) {        COSDictionary ocg = toDictionary(o);        String name = ocg.getString(COSName.NAME);        if (groupName.equals(name) && isGroupEnabled(new PDOptionalContentGroup(ocg))) {            result = true;        }    }    return result;}
public boolean pdfbox_f5340_0(PDOptionalContentGroup group)
{            PDOptionalContentProperties.BaseState baseState = getBaseState();    boolean enabled = !baseState.equals(BaseState.OFF);    if (group == null) {        return enabled;    }    COSDictionary d = getD();    COSBase base = d.getDictionaryObject(COSName.ON);    if (base instanceof COSArray) {        for (COSBase o : (COSArray) base) {            COSDictionary dictionary = toDictionary(o);            if (dictionary == group.getCOSObject()) {                return true;            }        }    }    base = d.getDictionaryObject(COSName.OFF);    if (base instanceof COSArray) {        for (COSBase o : (COSArray) base) {            COSDictionary dictionary = toDictionary(o);            if (dictionary == group.getCOSObject()) {                return false;            }        }    }    return enabled;}
private COSDictionary pdfbox_f5341_0(COSBase o)
{    if (o instanceof COSObject) {        return (COSDictionary) ((COSObject) o).getObject();    } else {        return (COSDictionary) o;    }}
public boolean pdfbox_f5342_0(String groupName, boolean enable)
{    boolean result = false;    COSArray ocgs = getOCGs();    for (COSBase o : ocgs) {        COSDictionary ocg = toDictionary(o);        String name = ocg.getString(COSName.NAME);        if (groupName.equals(name) && setGroupEnabled(new PDOptionalContentGroup(ocg), enable)) {            result = true;        }    }    return result;}
public boolean pdfbox_f5343_0(PDOptionalContentGroup group, boolean enable)
{    COSArray on;    COSArray off;    COSDictionary d = getD();    COSBase base = d.getDictionaryObject(COSName.ON);    if (!(base instanceof COSArray)) {        on = new COSArray();        d.setItem(COSName.ON, on);    } else {        on = (COSArray) base;    }    base = d.getDictionaryObject(COSName.OFF);    if (!(base instanceof COSArray)) {        off = new COSArray();        d.setItem(COSName.OFF, off);    } else {        off = (COSArray) base;    }    boolean found = false;    if (enable) {        for (COSBase o : off) {            COSDictionary groupDictionary = toDictionary(o);            if (groupDictionary == group.getCOSObject()) {                                off.remove(o);                on.add(o);                found = true;                break;            }        }    } else {        for (COSBase o : on) {            COSDictionary groupDictionary = toDictionary(o);            if (groupDictionary == group.getCOSObject()) {                                on.remove(o);                off.add(o);                found = true;                break;            }        }    }    if (!found) {        if (enable) {            on.add(group.getCOSObject());        } else {            off.add(group.getCOSObject());        }    }    return found;}
public static PDAbstractPattern pdfbox_f5344_0(COSDictionary dictionary) throws IOException
{    PDAbstractPattern pattern;    int patternType = dictionary.getInt(COSName.PATTERN_TYPE, 0);    switch(patternType) {        case TYPE_TILING_PATTERN:            pattern = new PDTilingPattern(dictionary);            break;        case TYPE_SHADING_PATTERN:            pattern = new PDShadingPattern(dictionary);            break;        default:            throw new IOException("Error: Unknown pattern type " + patternType);    }    return pattern;}
public COSDictionary pdfbox_f5345_0()
{    return patternDictionary;}
public void pdfbox_f5346_0(int paintType)
{    patternDictionary.setInt(COSName.PAINT_TYPE, paintType);}
public String pdfbox_f5347_0()
{    return COSName.PATTERN.getName();}
public void pdfbox_f5348_0(int patternType)
{    patternDictionary.setInt(COSName.PATTERN_TYPE, patternType);}
public Matrix pdfbox_f5349_0()
{    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));}
public void pdfbox_f5350_0(AffineTransform transform)
{    COSArray matrix = new COSArray();    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        matrix.add(new COSFloat((float) v));    }    getCOSObject().setItem(COSName.MATRIX, matrix);}
public int pdfbox_f5351_0()
{    return PDAbstractPattern.TYPE_SHADING_PATTERN;}
public PDExtendedGraphicsState pdfbox_f5352_0()
{    if (extendedGraphicsState == null) {        COSBase base = getCOSObject().getDictionaryObject(COSName.EXT_G_STATE);        if (base instanceof COSDictionary) {            extendedGraphicsState = new PDExtendedGraphicsState((COSDictionary) base);        }    }    return extendedGraphicsState;}
public void pdfbox_f5353_0(PDExtendedGraphicsState extendedGraphicsState)
{    this.extendedGraphicsState = extendedGraphicsState;    getCOSObject().setItem(COSName.EXT_G_STATE, extendedGraphicsState);}
public PDShading pdfbox_f5354_0() throws IOException
{    if (shading == null) {        COSBase base = getCOSObject().getDictionaryObject(COSName.SHADING);        if (base instanceof COSDictionary) {            shading = PDShading.create((COSDictionary) base);        }    }    return shading;}
public void pdfbox_f5355_0(PDShading shadingResources)
{    shading = shadingResources;    getCOSObject().setItem(COSName.SHADING, shadingResources);}
public int pdfbox_f5356_0()
{    return PDAbstractPattern.TYPE_TILING_PATTERN;}
public void pdfbox_f5357_0(int paintType)
{    getCOSObject().setInt(COSName.PAINT_TYPE, paintType);}
public int pdfbox_f5358_0()
{    return getCOSObject().getInt(COSName.PAINT_TYPE, 0);}
public void pdfbox_f5359_0(int tilingType)
{    getCOSObject().setInt(COSName.TILING_TYPE, tilingType);}
public int pdfbox_f5360_0()
{    return getCOSObject().getInt(COSName.TILING_TYPE, 0);}
public void pdfbox_f5361_0(float xStep)
{    getCOSObject().setFloat(COSName.X_STEP, xStep);}
public float pdfbox_f5362_0()
{    return getCOSObject().getFloat(COSName.X_STEP, 0);}
public void pdfbox_f5363_0(float yStep)
{    getCOSObject().setFloat(COSName.Y_STEP, yStep);}
public float pdfbox_f5364_0()
{    return getCOSObject().getFloat(COSName.Y_STEP, 0);}
public PDStream pdfbox_f5365_0()
{    return new PDStream((COSStream) getCOSObject());}
public InputStream pdfbox_f5366_0() throws IOException
{    COSDictionary dict = getCOSObject();    if (dict instanceof COSStream) {        return ((COSStream) getCOSObject()).createInputStream();    }    return null;}
public PDResources pdfbox_f5367_0()
{    PDResources retval = null;    COSBase base = getCOSObject().getDictionaryObject(COSName.RESOURCES);    if (base instanceof COSDictionary) {        retval = new PDResources((COSDictionary) base);    }    return retval;}
public final void pdfbox_f5368_0(PDResources resources)
{    getCOSObject().setItem(COSName.RESOURCES, resources);}
public PDRectangle pdfbox_f5369_0()
{    PDRectangle retval = null;    COSBase base = getCOSObject().getDictionaryObject(COSName.BBOX);    if (base instanceof COSArray) {        retval = new PDRectangle((COSArray) base);    }    return retval;}
public void pdfbox_f5370_0(PDRectangle bbox)
{    if (bbox == null) {        getCOSObject().removeItem(COSName.BBOX);    } else {        getCOSObject().setItem(COSName.BBOX, bbox.getCOSArray());    }}
public COSBase pdfbox_f5371_0()
{    return fontSetting;}
public PDFont pdfbox_f5372_0() throws IOException
{    PDFont retval = null;    COSBase font = fontSetting.getObject(0);    if (font instanceof COSDictionary) {        retval = PDFontFactory.createFont((COSDictionary) font);    }    return retval;}
public void pdfbox_f5373_0(PDFont font)
{    fontSetting.set(0, font);}
public float pdfbox_f5374_0()
{    COSNumber size = (COSNumber) fontSetting.get(1);    return size.floatValue();}
public void pdfbox_f5375_0(float size)
{    fontSetting.set(1, new COSFloat(size));}
public COSBase pdfbox_f5376_0()
{    COSArray cos = new COSArray();    COSArray patternArray = new COSArray();    patternArray.setFloatArray(array);    cos.add(patternArray);    cos.add(COSInteger.get(phase));    return cos;}
public int pdfbox_f5377_0()
{    return phase;}
public float[] pdfbox_f5378_0()
{    return array.clone();}
public String pdfbox_f5379_0()
{    return "PDLineDashPattern{array=" + Arrays.toString(array) + ", phase=" + phase + "}";}
public static PDXObject pdfbox_f5380_0(COSBase base, PDResources resources) throws IOException
{    if (base == null) {                return null;    }    if (!(base instanceof COSStream)) {        throw new IOException("Unexpected object type: " + base.getClass().getName());    }    COSStream stream = (COSStream) base;    String subtype = stream.getNameAsString(COSName.SUBTYPE);    if (COSName.IMAGE.getName().equals(subtype)) {        return new PDImageXObject(new PDStream(stream), resources);    } else if (COSName.FORM.getName().equals(subtype)) {        ResourceCache cache = resources != null ? resources.getResourceCache() : null;        COSDictionary group = (COSDictionary) stream.getDictionaryObject(COSName.GROUP);        if (group != null && COSName.TRANSPARENCY.equals(group.getCOSName(COSName.S))) {            return new PDTransparencyGroup(stream, cache);        }        return new PDFormXObject(stream, cache);    } else if (COSName.PS.getName().equals(subtype)) {        return new PDPostScriptXObject(stream);    } else {        throw new IOException("Invalid XObject Subtype: " + subtype);    }}
public final COSStream pdfbox_f5381_0()
{    return stream.getCOSObject();}
public final PDStream pdfbox_f5382_0()
{    return stream;}
private int[] pdfbox_f5383_0() throws IOException
{    int[] map = new int[factor + 1];    if (factor == 0 || Float.compare(d1d0, 0) == 0) {        float[] values = axialShadingType.evalFunction(domain[0]);        map[0] = convertToRGB(values);    } else {        for (int i = 0; i <= factor; i++) {            float t = domain[0] + d1d0 * i / factor;            float[] values = axialShadingType.evalFunction(t);            map[i] = convertToRGB(values);        }    }    return map;}
public void pdfbox_f5384_0()
{    super.dispose();    axialShadingType = null;}
public ColorModel pdfbox_f5385_0()
{    return super.getColorModel();}
public Raster pdfbox_f5386_0(int x, int y, int w, int h)
{        WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    boolean useBackground;    int[] data = new int[w * h * 4];    for (int j = 0; j < h; j++) {        for (int i = 0; i < w; i++) {            useBackground = false;            float[] values = new float[] { x + i, y + j };            rat.transform(values, 0, values, 0, 1);            double inputValue = x1x0 * (values[0] - coords[0]) + y1y0 * (values[1] - coords[1]);                        if (Double.compare(denom, 0) == 0) {                if (getBackground() == null) {                    continue;                }                useBackground = true;            } else {                inputValue /= denom;            }                        if (inputValue < 0) {                                if (extend[0]) {                    inputValue = 0;                } else {                    if (getBackground() == null) {                        continue;                    }                    useBackground = true;                }            } else             if (inputValue > 1) {                                if (extend[1]) {                    inputValue = 1;                } else {                    if (getBackground() == null) {                        continue;                    }                    useBackground = true;                }            }            int value;            if (useBackground) {                                value = getRgbBackground();            } else {                int key = (int) (inputValue * factor);                value = colorTable[key];            }            int index = (j * w + i) * 4;            data[index] = value & 255;            value >>= 8;            data[index + 1] = value & 255;            value >>= 8;            data[index + 2] = value & 255;            data[index + 3] = 255;        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
public float[] pdfbox_f5387_0()
{    return coords;}
public float[] pdfbox_f5388_0()
{    return domain;}
public boolean[] pdfbox_f5389_0()
{    return extend;}
public PDFunction pdfbox_f5390_0() throws IOException
{    return axialShadingType.getFunction();}
public int pdfbox_f5391_0()
{    return 0;}
public PaintContext pdfbox_f5392_1(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new AxialShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
private Point2D[][] pdfbox_f5393_0(Point2D[] points)
{    Point2D[][] fourRows = new Point2D[4][4];    fourRows[2] = new Point2D[] { points[0], points[1], points[2], points[3] };        fourRows[1] = new Point2D[] { points[3], points[4], points[5], points[6] };        fourRows[3] = new Point2D[] { points[9], points[8], points[7], points[6] };        fourRows[0] = new Point2D[] { points[0], points[11], points[10], points[9] };        return fourRows;}
private int[] pdfbox_f5394_0()
{    int[] l = { 4, 4 };        if (isEdgeALine(controlPoints[0]) && isEdgeALine(controlPoints[1])) {        double lc1 = getLen(controlPoints[0][0], controlPoints[0][3]), lc2 = getLen(controlPoints[1][0], controlPoints[1][3]);                if (lc1 > 800 || lc2 > 800) {                } else if (lc1 > 400 || lc2 > 400) {            l[0] = 3;        } else if (lc1 > 200 || lc2 > 200) {            l[0] = 2;        } else {            l[0] = 1;        }    }        if (isEdgeALine(controlPoints[2]) && isEdgeALine(controlPoints[3])) {        double ld1 = getLen(controlPoints[2][0], controlPoints[2][3]), ld2 = getLen(controlPoints[3][0], controlPoints[3][3]);        if (ld1 > 800 || ld2 > 800) {                } else if (ld1 > 400 || ld2 > 400) {            l[1] = 3;        } else if (ld1 > 200 || ld2 > 200) {            l[1] = 2;        } else {            l[1] = 1;        }    }    return l;}
private List<ShadedTriangle> pdfbox_f5395_0()
{        CubicBezierCurve eC1 = new CubicBezierCurve(controlPoints[0], level[0]);    CubicBezierCurve eC2 = new CubicBezierCurve(controlPoints[1], level[0]);    CubicBezierCurve eD1 = new CubicBezierCurve(controlPoints[2], level[1]);    CubicBezierCurve eD2 = new CubicBezierCurve(controlPoints[3], level[1]);    CoordinateColorPair[][] patchCC = getPatchCoordinatesColor(eC1, eC2, eD1, eD2);    return getShadedTriangles(patchCC);}
protected Point2D[] pdfbox_f5396_0()
{    return controlPoints[1].clone();}
protected Point2D[] pdfbox_f5397_0()
{    Point2D[] implicitEdge = new Point2D[4];    implicitEdge[0] = controlPoints[3][3];    implicitEdge[1] = controlPoints[3][2];    implicitEdge[2] = controlPoints[3][1];    implicitEdge[3] = controlPoints[3][0];    return implicitEdge;}
protected Point2D[] pdfbox_f5398_0()
{    Point2D[] implicitEdge = new Point2D[4];    implicitEdge[0] = controlPoints[0][3];    implicitEdge[1] = controlPoints[0][2];    implicitEdge[2] = controlPoints[0][1];    implicitEdge[3] = controlPoints[0][0];    return implicitEdge;}
private CoordinateColorPair[][] pdfbox_f5399_0(CubicBezierCurve c1, CubicBezierCurve c2, CubicBezierCurve d1, CubicBezierCurve d2)
{    Point2D[] curveC1 = c1.getCubicBezierCurve();    Point2D[] curveC2 = c2.getCubicBezierCurve();    Point2D[] curveD1 = d1.getCubicBezierCurve();    Point2D[] curveD2 = d2.getCubicBezierCurve();    int numberOfColorComponents = cornerColor[0].length;    int szV = curveD1.length;    int szU = curveC1.length;    CoordinateColorPair[][] patchCC = new CoordinateColorPair[szV][szU];    double stepV = (double) 1 / (szV - 1);    double stepU = (double) 1 / (szU - 1);    double v = -stepV;    for (int i = 0; i < szV; i++) {                v += stepV;        double u = -stepU;        for (int j = 0; j < szU; j++) {            u += stepU;            double scx = (1 - v) * curveC1[j].getX() + v * curveC2[j].getX();            double scy = (1 - v) * curveC1[j].getY() + v * curveC2[j].getY();            double sdx = (1 - u) * curveD1[i].getX() + u * curveD2[i].getX();            double sdy = (1 - u) * curveD1[i].getY() + u * curveD2[i].getY();            double sbx = (1 - v) * ((1 - u) * controlPoints[0][0].getX() + u * controlPoints[0][3].getX()) + v * ((1 - u) * controlPoints[1][0].getX() + u * controlPoints[1][3].getX());            double sby = (1 - v) * ((1 - u) * controlPoints[0][0].getY() + u * controlPoints[0][3].getY()) + v * ((1 - u) * controlPoints[1][0].getY() + u * controlPoints[1][3].getY());            double sx = scx + sdx - sbx;            double sy = scy + sdy - sby;                        Point2D tmpC = new Point2D.Double(sx, sy);            float[] paramSC = new float[numberOfColorComponents];            for (int ci = 0; ci < numberOfColorComponents; ci++) {                paramSC[ci] = (float) ((1 - v) * ((1 - u) * cornerColor[0][ci] + u * cornerColor[3][ci]) +                 v * ((1 - u) * cornerColor[1][ci] + u * cornerColor[2][ci]));            }            patchCC[i][j] = new CoordinateColorPair(tmpC, paramSC);        }    }    return patchCC;}
 int pdfbox_f5400_0()
{    return level;}
private Point2D[] pdfbox_f5401_0(int l)
{    if (l < 0) {        l = 0;    }    int sz = (1 << l) + 1;    Point2D[] res = new Point2D[sz];    double step = (double) 1 / (sz - 1);    double t = -step;    for (int i = 0; i < sz; i++) {        t += step;        double tmpX = (1 - t) * (1 - t) * (1 - t) * controlPoints[0].getX() + 3 * t * (1 - t) * (1 - t) * controlPoints[1].getX() + 3 * t * t * (1 - t) * controlPoints[2].getX() + t * t * t * controlPoints[3].getX();        double tmpY = (1 - t) * (1 - t) * (1 - t) * controlPoints[0].getY() + 3 * t * (1 - t) * (1 - t) * controlPoints[1].getY() + 3 * t * t * (1 - t) * controlPoints[2].getY() + t * t * t * controlPoints[3].getY();        res[i] = new Point2D.Double(tmpX, tmpY);    }    return res;}
 Point2D[] pdfbox_f5402_0()
{    return curve;}
public String pdfbox_f5403_0()
{    StringBuilder sb = new StringBuilder();    for (Point2D p : controlPoints) {        if (sb.length() > 0) {            sb.append(' ');        }        sb.append(p);    }    return "Cubic Bezier curve{control points p0, p1, p2, p3: " + sb + "}";}
protected Vertex pdfbox_f5404_1(ImageInputStream input, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRangeTab, Matrix matrix, AffineTransform xform) throws IOException
{    float[] colorComponentTab = new float[numberOfColorComponents];    long x = input.readBits(bitsPerCoordinate);    long y = input.readBits(bitsPerCoordinate);    float dstX = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());    float dstY = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());        Point2D p = matrix.transformPoint(dstX, dstY);    xform.transform(p, p);    for (int n = 0; n < numberOfColorComponents; ++n) {        int color = (int) input.readBits(bitsPerColorComponent);        colorComponentTab[n] = interpolate(color, maxSrcColor, colRangeTab[n].getMin(), colRangeTab[n].getMax());            }                int bitOffset = input.getBitOffset();    if (bitOffset != 0) {        input.readBits(8 - bitOffset);    }    return new Vertex(p, colorComponentTab);}
 final void pdfbox_f5405_0(List<ShadedTriangle> triangleList)
{    this.triangleList = triangleList;}
protected Map<Point, Integer> pdfbox_f5406_0(Rectangle deviceBounds) throws IOException
{    Map<Point, Integer> map = new HashMap<>();    super.calcPixelTable(triangleList, map, deviceBounds);    return map;}
public void pdfbox_f5407_0()
{    triangleList = null;    super.dispose();}
private float pdfbox_f5408_0(float src, long srcMax, float dstMin, float dstMax)
{    return dstMin + (src * (dstMax - dstMin) / srcMax);}
protected boolean pdfbox_f5409_0()
{    return triangleList.isEmpty();}
public int pdfbox_f5410_0()
{    return 89 * (623 + this.x) + this.y;}
public boolean pdfbox_f5411_1(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        if (obj instanceof Point2D) {                                }        return false;    }    final IntPoint other = (IntPoint) obj;    return this.x == other.x && this.y == other.y;}
private Set<Point> pdfbox_f5412_0(int x0, int y0, int x1, int y1)
{    Set<Point> points = new HashSet<>(3);    int dx = Math.abs(x1 - x0);    int dy = Math.abs(y1 - y0);    int sx = x0 < x1 ? 1 : -1;    int sy = y0 < y1 ? 1 : -1;    int err = dx - dy;    while (true) {        points.add(new IntPoint(x0, y0));        if (x0 == x1 && y0 == y1) {            break;        }        int e2 = 2 * err;        if (e2 > -dy) {            err -= dy;            x0 += sx;        }        if (e2 < dx) {            err += dx;            y0 += sy;        }    }    return points;}
protected float[] pdfbox_f5413_0(Point p)
{    int numberOfColorComponents = color0.length;    float[] pc = new float[numberOfColorComponents];    if (point0.x == point1.x && point0.y == point1.y) {        return color0;    } else if (point0.x == point1.x) {        float l = point1.y - point0.y;        for (int i = 0; i < numberOfColorComponents; i++) {            pc[i] = (color0[i] * (point1.y - p.y) / l + color1[i] * (p.y - point0.y) / l);        }    } else {        float l = point1.x - point0.x;        for (int i = 0; i < numberOfColorComponents; i++) {            pc[i] = (color0[i] * (point1.x - p.x) / l + color1[i] * (p.x - point0.x) / l);        }    }    return pc;}
protected float[][] pdfbox_f5414_0()
{    int numberOfColorComponents = cornerColor[0].length;    float[][] implicitCornerColor = new float[2][numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; i++) {        implicitCornerColor[0][i] = cornerColor[1][i];        implicitCornerColor[1][i] = cornerColor[2][i];    }    return implicitCornerColor;}
protected float[][] pdfbox_f5415_0()
{    int numberOfColorComponents = cornerColor[0].length;    float[][] implicitCornerColor = new float[2][numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; i++) {        implicitCornerColor[0][i] = cornerColor[2][i];        implicitCornerColor[1][i] = cornerColor[3][i];    }    return implicitCornerColor;}
protected float[][] pdfbox_f5416_0()
{    int numberOfColorComponents = cornerColor[0].length;    float[][] implicitCornerColor = new float[2][numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; i++) {        implicitCornerColor[0][i] = cornerColor[3][i];        implicitCornerColor[1][i] = cornerColor[0][i];    }    return implicitCornerColor;}
protected double pdfbox_f5417_0(Point2D ps, Point2D pe)
{    double x = pe.getX() - ps.getX();    double y = pe.getY() - ps.getY();    return Math.sqrt(x * x + y * y);}
protected boolean pdfbox_f5418_0(Point2D[] ctl)
{    double ctl1 = Math.abs(edgeEquationValue(ctl[1], ctl[0], ctl[3]));    double ctl2 = Math.abs(edgeEquationValue(ctl[2], ctl[0], ctl[3]));    double x = Math.abs(ctl[0].getX() - ctl[3].getX());    double y = Math.abs(ctl[0].getY() - ctl[3].getY());    return (ctl1 <= x && ctl2 <= x) || (ctl1 <= y && ctl2 <= y);}
protected double pdfbox_f5419_0(Point2D p, Point2D p1, Point2D p2)
{    return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) - (p2.getX() - p1.getX()) * (p.getY() - p1.getY());}
protected List<ShadedTriangle> pdfbox_f5420_0(CoordinateColorPair[][] patchCC)
{    List<ShadedTriangle> list = new ArrayList<>();    int szV = patchCC.length;    int szU = patchCC[0].length;    for (int i = 1; i < szV; i++) {        for (int j = 1; j < szU; j++) {            Point2D p0 = patchCC[i - 1][j - 1].coordinate, p1 = patchCC[i - 1][j].coordinate, p2 = patchCC[i][j].coordinate, p3 = patchCC[i][j - 1].coordinate;            boolean ll = true;            if (overlaps(p0, p1) || overlaps(p0, p3)) {                ll = false;            } else {                                Point2D[] llCorner = { p0, p1, p3 };                float[][] llColor = { patchCC[i - 1][j - 1].color, patchCC[i - 1][j].color, patchCC[i][j - 1].color };                                ShadedTriangle tmpll = new ShadedTriangle(llCorner, llColor);                list.add(tmpll);            }            if (ll && (overlaps(p2, p1) || overlaps(p2, p3))) {            } else {                                Point2D[] urCorner = { p3, p1, p2 };                float[][] urColor = { patchCC[i][j - 1].color, patchCC[i - 1][j].color, patchCC[i][j].color };                                ShadedTriangle tmpur = new ShadedTriangle(urCorner, urColor);                list.add(tmpur);            }        }    }    return list;}
private boolean pdfbox_f5421_0(Point2D p0, Point2D p1)
{    return Math.abs(p0.getX() - p1.getX()) < 0.001 && Math.abs(p0.getY() - p1.getY()) < 0.001;}
 final List<Patch> pdfbox_f5422_1(PDShadingType6 shadingType, AffineTransform xform, Matrix matrix, int controlPoints) throws IOException
{    COSDictionary dict = shadingType.getCOSObject();    if (!(dict instanceof COSStream)) {        return Collections.emptyList();    }    PDRange rangeX = shadingType.getDecodeForParameter(0);    PDRange rangeY = shadingType.getDecodeForParameter(1);    if (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0 || Float.compare(rangeY.getMin(), rangeY.getMax()) == 0) {        return Collections.emptyList();    }    int bitsPerFlag = shadingType.getBitsPerFlag();    PDRange[] colRange = new PDRange[numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; ++i) {        colRange[i] = shadingType.getDecodeForParameter(2 + i);        if (colRange[i] == null) {            throw new IOException("Range missing in shading /Decode entry");        }    }    List<Patch> list = new ArrayList<>();    long maxSrcCoord = (long) Math.pow(2, bitsPerCoordinate) - 1;    long maxSrcColor = (long) Math.pow(2, bitsPerColorComponent) - 1;    COSStream cosStream = (COSStream) dict;    try (ImageInputStream mciis = new MemoryCacheImageInputStream(cosStream.createInputStream())) {        Point2D[] implicitEdge = new Point2D[4];        float[][] implicitCornerColor = new float[2][numberOfColorComponents];        byte flag = 0;        try {            flag = (byte) (mciis.readBits(bitsPerFlag) & 3);        } catch (EOFException ex) {                    }        boolean eof = false;        while (!eof) {            try {                boolean isFree = (flag == 0);                Patch current = readPatch(mciis, isFree, implicitEdge, implicitCornerColor, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform, controlPoints);                if (current == null) {                    break;                }                list.add(current);                flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                switch(flag) {                    case 0:                        break;                    case 1:                        implicitEdge = current.getFlag1Edge();                        implicitCornerColor = current.getFlag1Color();                        break;                    case 2:                        implicitEdge = current.getFlag2Edge();                        implicitCornerColor = current.getFlag2Color();                        break;                    case 3:                        implicitEdge = current.getFlag3Edge();                        implicitCornerColor = current.getFlag3Color();                        break;                    default:                                                break;                }            } catch (EOFException ex) {                eof = true;            }        }    }    return list;}
protected Patch pdfbox_f5423_1(ImageInputStream input, boolean isFree, Point2D[] implicitEdge, float[][] implicitCornerColor, long maxSrcCoord, long maxSrcColor, PDRange rangeX, PDRange rangeY, PDRange[] colRange, Matrix matrix, AffineTransform xform, int controlPoints) throws IOException
{    float[][] color = new float[4][numberOfColorComponents];    Point2D[] points = new Point2D[controlPoints];    int pStart = 4, cStart = 2;    if (isFree) {        pStart = 0;        cStart = 0;    } else {        points[0] = implicitEdge[0];        points[1] = implicitEdge[1];        points[2] = implicitEdge[2];        points[3] = implicitEdge[3];        for (int i = 0; i < numberOfColorComponents; i++) {            color[0][i] = implicitCornerColor[0][i];            color[1][i] = implicitCornerColor[1][i];        }    }    try {        for (int i = pStart; i < controlPoints; i++) {            long x = input.readBits(bitsPerCoordinate);            long y = input.readBits(bitsPerCoordinate);            float px = interpolate(x, maxSrcCoord, rangeX.getMin(), rangeX.getMax());            float py = interpolate(y, maxSrcCoord, rangeY.getMin(), rangeY.getMax());            Point2D p = matrix.transformPoint(px, py);            xform.transform(p, p);            points[i] = p;        }        for (int i = cStart; i < 4; i++) {            for (int j = 0; j < numberOfColorComponents; j++) {                long c = input.readBits(bitsPerColorComponent);                color[i][j] = interpolate(c, maxSrcColor, colRange[j].getMin(), colRange[j].getMax());            }        }    } catch (EOFException ex) {                return null;    }    return generatePatch(points, color);}
private float pdfbox_f5424_0(float x, long maxValue, float rangeMin, float rangeMax)
{    return rangeMin + (x / maxValue) * (rangeMax - rangeMin);}
protected Map<Point, Integer> pdfbox_f5425_0(Rectangle deviceBounds) throws IOException
{    Map<Point, Integer> map = new HashMap<>();    for (Patch it : patchList) {        super.calcPixelTable(it.listOfTriangles, map, deviceBounds);    }    return map;}
public void pdfbox_f5426_0()
{    patchList = null;    super.dispose();}
protected boolean pdfbox_f5427_0()
{    return patchList.isEmpty();}
public COSDictionary pdfbox_f5428_0()
{    return dictionary;}
public String pdfbox_f5429_0()
{    return COSName.SHADING.getName();}
public void pdfbox_f5430_0(int shadingType)
{    dictionary.setInt(COSName.SHADING_TYPE, shadingType);}
public void pdfbox_f5431_0(COSArray newBackground)
{    background = newBackground;    dictionary.setItem(COSName.BACKGROUND, newBackground);}
public COSArray pdfbox_f5432_0()
{    if (background == null) {        background = (COSArray) dictionary.getDictionaryObject(COSName.BACKGROUND);    }    return background;}
public PDRectangle pdfbox_f5433_0()
{    if (bBox == null) {        COSArray array = (COSArray) dictionary.getDictionaryObject(COSName.BBOX);        if (array != null) {            bBox = new PDRectangle(array);        }    }    return bBox;}
public void pdfbox_f5434_0(PDRectangle newBBox)
{    bBox = newBBox;    if (bBox == null) {        dictionary.removeItem(COSName.BBOX);    } else {        dictionary.setItem(COSName.BBOX, bBox.getCOSArray());    }}
public void pdfbox_f5435_0(boolean antiAlias)
{    dictionary.setBoolean(COSName.ANTI_ALIAS, antiAlias);}
public boolean pdfbox_f5436_0()
{    return dictionary.getBoolean(COSName.ANTI_ALIAS, false);}
public PDColorSpace pdfbox_f5437_0() throws IOException
{    if (colorSpace == null) {        COSBase colorSpaceDictionary = dictionary.getDictionaryObject(COSName.CS, COSName.COLORSPACE);        colorSpace = PDColorSpace.create(colorSpaceDictionary);    }    return colorSpace;}
public void pdfbox_f5438_0(PDColorSpace colorSpace)
{    this.colorSpace = colorSpace;    if (colorSpace != null) {        dictionary.setItem(COSName.COLORSPACE, colorSpace.getCOSObject());    } else {        dictionary.removeItem(COSName.COLORSPACE);    }}
public static PDShading pdfbox_f5439_0(COSDictionary shadingDictionary) throws IOException
{    PDShading shading = null;    int shadingType = shadingDictionary.getInt(COSName.SHADING_TYPE, 0);    switch(shadingType) {        case SHADING_TYPE1:            shading = new PDShadingType1(shadingDictionary);            break;        case SHADING_TYPE2:            shading = new PDShadingType2(shadingDictionary);            break;        case SHADING_TYPE3:            shading = new PDShadingType3(shadingDictionary);            break;        case SHADING_TYPE4:            shading = new PDShadingType4(shadingDictionary);            break;        case SHADING_TYPE5:            shading = new PDShadingType5(shadingDictionary);            break;        case SHADING_TYPE6:            shading = new PDShadingType6(shadingDictionary);            break;        case SHADING_TYPE7:            shading = new PDShadingType7(shadingDictionary);            break;        default:            throw new IOException("Error: Unknown shading type " + shadingType);    }    return shading;}
public void pdfbox_f5440_0(PDFunction newFunction)
{    functionArray = null;    function = newFunction;    getCOSObject().setItem(COSName.FUNCTION, newFunction);}
public void pdfbox_f5441_0(COSArray newFunctions)
{    functionArray = null;    function = null;    getCOSObject().setItem(COSName.FUNCTION, newFunctions);}
public PDFunction pdfbox_f5442_0() throws IOException
{    if (function == null) {        COSBase dictionaryFunctionObject = getCOSObject().getDictionaryObject(COSName.FUNCTION);        if (dictionaryFunctionObject != null) {            function = PDFunction.create(dictionaryFunctionObject);        }    }    return function;}
private PDFunction[] pdfbox_f5443_0() throws IOException
{    if (functionArray == null) {        COSBase functionObject = getCOSObject().getDictionaryObject(COSName.FUNCTION);        if (functionObject instanceof COSDictionary) {            functionArray = new PDFunction[1];            functionArray[0] = PDFunction.create(functionObject);        } else if (functionObject instanceof COSArray) {            COSArray functionCOSArray = (COSArray) functionObject;            int numberOfFunctions = functionCOSArray.size();            functionArray = new PDFunction[numberOfFunctions];            for (int i = 0; i < numberOfFunctions; i++) {                functionArray[i] = PDFunction.create(functionCOSArray.get(i));            }        } else {            throw new IOException("mandatory /Function element must be a dictionary or an array");        }    }    return functionArray;}
public float[] pdfbox_f5444_0(float inputValue) throws IOException
{    return evalFunction(new float[] { inputValue });}
public float[] pdfbox_f5445_0(float[] input) throws IOException
{    PDFunction[] functions = getFunctionsArray();    int numberOfFunctions = functions.length;    float[] returnValues;    if (numberOfFunctions == 1) {        returnValues = functions[0].eval(input);    } else {        returnValues = new float[numberOfFunctions];        for (int i = 0; i < numberOfFunctions; i++) {            float[] newValue = functions[i].eval(input);            returnValues[i] = newValue[0];        }    }        for (int i = 0; i < returnValues.length; ++i) {        if (returnValues[i] < 0) {            returnValues[i] = 0;        } else if (returnValues[i] > 1) {            returnValues[i] = 1;        }    }    return returnValues;}
public int pdfbox_f5446_0()
{    return PDShading.SHADING_TYPE1;}
public Matrix pdfbox_f5447_0()
{    return Matrix.createMatrix(getCOSObject().getDictionaryObject(COSName.MATRIX));}
public void pdfbox_f5448_0(AffineTransform transform)
{    COSArray matrix = new COSArray();    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        matrix.add(new COSFloat((float) v));    }    getCOSObject().setItem(COSName.MATRIX, matrix);}
public COSArray pdfbox_f5449_0()
{    if (domain == null) {        domain = (COSArray) getCOSObject().getDictionaryObject(COSName.DOMAIN);    }    return domain;}
public void pdfbox_f5450_0(COSArray newDomain)
{    domain = newDomain;    getCOSObject().setItem(COSName.DOMAIN, newDomain);}
public Paint pdfbox_f5451_0(Matrix matrix)
{    return new Type1ShadingPaint(this, matrix);}
public int pdfbox_f5452_0()
{    return PDShading.SHADING_TYPE2;}
public COSArray pdfbox_f5453_0()
{    if (extend == null) {        extend = (COSArray) getCOSObject().getDictionaryObject(COSName.EXTEND);    }    return extend;}
public void pdfbox_f5454_0(COSArray newExtend)
{    extend = newExtend;    getCOSObject().setItem(COSName.EXTEND, newExtend);}
public COSArray pdfbox_f5455_0()
{    if (domain == null) {        domain = (COSArray) getCOSObject().getDictionaryObject(COSName.DOMAIN);    }    return domain;}
public void pdfbox_f5456_0(COSArray newDomain)
{    domain = newDomain;    getCOSObject().setItem(COSName.DOMAIN, newDomain);}
public COSArray pdfbox_f5457_0()
{    if (coords == null) {        coords = (COSArray) getCOSObject().getDictionaryObject(COSName.COORDS);    }    return coords;}
public void pdfbox_f5458_0(COSArray newCoords)
{    coords = newCoords;    getCOSObject().setItem(COSName.COORDS, newCoords);}
public Paint pdfbox_f5459_0(Matrix matrix)
{    return new AxialShadingPaint(this, matrix);}
public int pdfbox_f5460_0()
{    return PDShading.SHADING_TYPE3;}
public Paint pdfbox_f5461_0(Matrix matrix)
{    return new RadialShadingPaint(this, matrix);}
public int pdfbox_f5462_0()
{    return PDShading.SHADING_TYPE4;}
public int pdfbox_f5463_0()
{    return getCOSObject().getInt(COSName.BITS_PER_FLAG, -1);}
public void pdfbox_f5464_0(int bitsPerFlag)
{    getCOSObject().setInt(COSName.BITS_PER_FLAG, bitsPerFlag);}
public Paint pdfbox_f5465_0(Matrix matrix)
{    return new Type4ShadingPaint(this, matrix);}
public int pdfbox_f5466_0()
{    return PDShading.SHADING_TYPE5;}
public int pdfbox_f5467_0()
{    return getCOSObject().getInt(COSName.VERTICES_PER_ROW, -1);}
public void pdfbox_f5468_0(int verticesPerRow)
{    getCOSObject().setInt(COSName.VERTICES_PER_ROW, verticesPerRow);}
public Paint pdfbox_f5469_0(Matrix matrix)
{    return new Type5ShadingPaint(this, matrix);}
public int pdfbox_f5470_0()
{    return PDShading.SHADING_TYPE6;}
public Paint pdfbox_f5471_0(Matrix matrix)
{    return new Type6ShadingPaint(this, matrix);}
public int pdfbox_f5472_0()
{    return PDShading.SHADING_TYPE7;}
public Paint pdfbox_f5473_0(Matrix matrix)
{    return new Type7ShadingPaint(this, matrix);}
public int pdfbox_f5474_0()
{    return getCOSObject().getInt(COSName.BITS_PER_COMPONENT, -1);}
public void pdfbox_f5475_0(int bitsPerComponent)
{    getCOSObject().setInt(COSName.BITS_PER_COMPONENT, bitsPerComponent);}
public int pdfbox_f5476_0()
{    return getCOSObject().getInt(COSName.BITS_PER_COORDINATE, -1);}
public void pdfbox_f5477_0(int bitsPerComponent)
{    getCOSObject().setInt(COSName.BITS_PER_COORDINATE, bitsPerComponent);}
private COSArray pdfbox_f5478_0()
{    if (decode == null) {        decode = (COSArray) getCOSObject().getDictionaryObject(COSName.DECODE);    }    return decode;}
public void pdfbox_f5479_0(COSArray decodeValues)
{    decode = decodeValues;    getCOSObject().setItem(COSName.DECODE, decodeValues);}
public PDRange pdfbox_f5480_0(int paramNum)
{    PDRange retval = null;    COSArray decodeValues = getDecodeValues();    if (decodeValues != null && decodeValues.size() >= paramNum * 2 + 1) {        retval = new PDRange(decodeValues, paramNum);    }    return retval;}
private int[] pdfbox_f5481_0() throws IOException
{    int[] map = new int[factor + 1];    if (factor == 0 || Float.compare(d1d0, 0) == 0) {        float[] values = radialShadingType.evalFunction(domain[0]);        map[0] = convertToRGB(values);    } else {        for (int i = 0; i <= factor; i++) {            float t = domain[0] + d1d0 * i / factor;            float[] values = radialShadingType.evalFunction(t);            map[i] = convertToRGB(values);        }    }    return map;}
public void pdfbox_f5482_0()
{    super.dispose();    radialShadingType = null;}
public ColorModel pdfbox_f5483_0()
{    return super.getColorModel();}
public Raster pdfbox_f5484_0(int x, int y, int w, int h)
{        WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    float inputValue = -1;    boolean useBackground;    int[] data = new int[w * h * 4];    for (int j = 0; j < h; j++) {        for (int i = 0; i < w; i++) {            float[] values = new float[] { x + i, y + j };            rat.transform(values, 0, values, 0, 1);            useBackground = false;            float[] inputValues = calculateInputValues(values[0], values[1]);            if (Float.isNaN(inputValues[0]) && Float.isNaN(inputValues[1])) {                if (getBackground() == null) {                    continue;                }                useBackground = true;            } else {                                if (inputValues[0] >= 0 && inputValues[0] <= 1) {                                        if (inputValues[1] >= 0 && inputValues[1] <= 1) {                        inputValue = Math.max(inputValues[0], inputValues[1]);                    } else                     {                        inputValue = inputValues[0];                    }                } else {                                        if (inputValues[1] >= 0 && inputValues[1] <= 1) {                        inputValue = inputValues[1];                    } else                     {                        if (extend[0] && extend[1]) {                            inputValue = Math.max(inputValues[0], inputValues[1]);                        } else if (extend[0]) {                            inputValue = inputValues[0];                        } else if (extend[1]) {                            inputValue = inputValues[1];                        } else if (getBackground() != null) {                            useBackground = true;                        } else {                            continue;                        }                    }                }                                if (inputValue > 1) {                                        if (extend[1] && coords[5] > 0) {                        inputValue = 1;                    } else {                        if (getBackground() == null) {                            continue;                        }                        useBackground = true;                    }                } else                 if (inputValue < 0) {                                        if (extend[0] && coords[2] > 0) {                        inputValue = 0;                    } else {                        if (getBackground() == null) {                            continue;                        }                        useBackground = true;                    }                }            }            int value;            if (useBackground) {                                value = getRgbBackground();            } else {                int key = (int) (inputValue * factor);                value = colorTable[key];            }            int index = (j * w + i) * 4;            data[index] = value & 255;            value >>= 8;            data[index + 1] = value & 255;            value >>= 8;            data[index + 2] = value & 255;            data[index + 3] = 255;        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
private float[] pdfbox_f5485_0(double x, double y)
{                                                                    double p = -(x - coords[0]) * x1x0 - (y - coords[1]) * y1y0 - coords[2] * r1r0;    double q = (Math.pow(x - coords[0], 2) + Math.pow(y - coords[1], 2) - r0pow2);    double root = Math.sqrt(p * p - denom * q);    float root1 = (float) ((-p + root) / denom);    float root2 = (float) ((-p - root) / denom);    if (denom < 0) {        return new float[] { root1, root2 };    } else {        return new float[] { root2, root1 };    }}
public float[] pdfbox_f5486_0()
{    return coords;}
public float[] pdfbox_f5487_0()
{    return domain;}
public boolean[] pdfbox_f5488_0()
{    return extend;}
public PDFunction pdfbox_f5489_0() throws IOException
{    return radialShadingType.getFunction();}
public int pdfbox_f5490_0()
{    return 0;}
public PaintContext pdfbox_f5491_1(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new RadialShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
private int pdfbox_f5492_0(Point2D[] p)
{    Set<Point> set = new HashSet<>();    for (Point2D itp : p) {        Point np = new Point((int) Math.round(itp.getX() * 1000), (int) Math.round(itp.getY() * 1000));        set.add(np);    }    return set.size();}
public int pdfbox_f5493_0()
{    return degree;}
public int[] pdfbox_f5494_0()
{    int[] boundary = new int[4];    int x0 = (int) Math.round(corner[0].getX());    int x1 = (int) Math.round(corner[1].getX());    int x2 = (int) Math.round(corner[2].getX());    int y0 = (int) Math.round(corner[0].getY());    int y1 = (int) Math.round(corner[1].getY());    int y2 = (int) Math.round(corner[2].getY());    boundary[0] = Math.min(Math.min(x0, x1), x2);    boundary[1] = Math.max(Math.max(x0, x1), x2);    boundary[2] = Math.min(Math.min(y0, y1), y2);    boundary[3] = Math.max(Math.max(y0, y1), y2);    return boundary;}
public Line pdfbox_f5495_0()
{    return line;}
public boolean pdfbox_f5496_0(Point2D p)
{    if (degree == 1) {        return overlaps(corner[0], p) || overlaps(corner[1], p) || overlaps(corner[2], p);    } else if (degree == 2) {        Point tp = new Point((int) Math.round(p.getX()), (int) Math.round(p.getY()));        return line.linePoints.contains(tp);    }    /*         the following code judges whether a point is contained in a normal triangle,          taking the on edge case as contained         */    double pv0 = edgeEquationValue(p, corner[1], corner[2]);    /*         if corner[0] and point p are on different sides of line from corner[1] to corner[2],          p is outside of the triangle         */    if (pv0 * v0 < 0) {        return false;    }    double pv1 = edgeEquationValue(p, corner[2], corner[0]);    /*         if vertex corner[1] and point p are on different sides of line from corner[2] to corner[0],          p is outside of the triangle         */    if (pv1 * v1 < 0) {        return false;    }    double pv2 = edgeEquationValue(p, corner[0], corner[1]);        return pv2 * v2 >= 0;}
private boolean pdfbox_f5497_0(Point2D p0, Point2D p1)
{    return Math.abs(p0.getX() - p1.getX()) < 0.001 && Math.abs(p0.getY() - p1.getY()) < 0.001;}
private double pdfbox_f5498_0(Point2D p, Point2D p1, Point2D p2)
{    return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) - (p2.getX() - p1.getX()) * (p.getY() - p1.getY());}
private double pdfbox_f5499_0(Point2D a, Point2D b, Point2D c)
{    return Math.abs((c.getX() - b.getX()) * (c.getY() - a.getY()) - (c.getX() - a.getX()) * (c.getY() - b.getY())) / 2.0;}
public float[] pdfbox_f5500_0(Point2D p)
{    int numberOfColorComponents = color[0].length;    float[] pCol = new float[numberOfColorComponents];    switch(degree) {        case 1:            for (int i = 0; i < numberOfColorComponents; i++) {                                pCol[i] = (color[0][i] + color[1][i] + color[2][i]) / 3.0f;            }            break;        case 2:                        Point tp = new Point((int) Math.round(p.getX()), (int) Math.round(p.getY()));            return line.calcColor(tp);        default:            float aw = (float) (getArea(p, corner[1], corner[2]) / area);            float bw = (float) (getArea(p, corner[2], corner[0]) / area);            float cw = (float) (getArea(p, corner[0], corner[1]) / area);            for (int i = 0; i < numberOfColorComponents; i++) {                                pCol[i] = color[0][i] * aw + color[1][i] * bw + color[2][i] * cw;            }            break;    }    return pCol;}
public String pdfbox_f5501_0()
{    return corner[0] + " " + corner[1] + " " + corner[2];}
 PDColorSpace pdfbox_f5502_0()
{    return shadingColorSpace;}
 PDShading pdfbox_f5503_0()
{    return shading;}
 float[] pdfbox_f5504_0()
{    return background;}
 int pdfbox_f5505_0()
{    return rgbBackground;}
 final int pdfbox_f5506_0(float[] values) throws IOException
{    int normRGBValues;    float[] rgbValues = shadingColorSpace.toRGB(values);    normRGBValues = (int) (rgbValues[0] * 255);    normRGBValues |= (int) (rgbValues[1] * 255) << 8;    normRGBValues |= (int) (rgbValues[2] * 255) << 16;    return normRGBValues;}
 ColorModel pdfbox_f5507_0()
{    return outputColorModel;}
 void pdfbox_f5508_0()
{    outputColorModel = null;    shadingColorSpace = null;}
public T pdfbox_f5509_0()
{    return shading;}
public Matrix pdfbox_f5510_0()
{    return matrix;}
private Point2D[][] pdfbox_f5511_0(Point2D[] tcp)
{    Point2D[][] square = new Point2D[4][4];    for (int i = 0; i <= 3; i++) {        square[0][i] = tcp[i];        square[3][i] = tcp[9 - i];    }    for (int i = 1; i <= 2; i++) {        square[i][0] = tcp[12 - i];        square[i][2] = tcp[12 + i];        square[i][3] = tcp[3 + i];    }    square[1][1] = tcp[12];    square[2][1] = tcp[15];    return square;}
private int[] pdfbox_f5512_0()
{    int[] l = { 4, 4 };    Point2D[] ctlC1 = new Point2D[4];    Point2D[] ctlC2 = new Point2D[4];    for (int j = 0; j < 4; j++) {        ctlC1[j] = controlPoints[j][0];        ctlC2[j] = controlPoints[j][3];    }        if (isEdgeALine(ctlC1) && isEdgeALine(ctlC2)) {        /*             if any of the 4 inner control points is out of the patch formed by the 4 edges,              keep the high dividing level,              otherwise, determine the dividing level by the lengths of edges             */        if (isOnSameSideCC(controlPoints[1][1]) || isOnSameSideCC(controlPoints[1][2]) || isOnSameSideCC(controlPoints[2][1]) || isOnSameSideCC(controlPoints[2][2])) {                } else {                        double lc1 = getLen(ctlC1[0], ctlC1[3]), lc2 = getLen(ctlC2[0], ctlC2[3]);            if (lc1 > 800 || lc2 > 800) {                        } else if (lc1 > 400 || lc2 > 400) {                l[0] = 3;            } else if (lc1 > 200 || lc2 > 200) {                l[0] = 2;            } else {                l[0] = 1;            }        }    }        if (isEdgeALine(controlPoints[0]) && isEdgeALine(controlPoints[3])) {        if (isOnSameSideDD(controlPoints[1][1]) || isOnSameSideDD(controlPoints[1][2]) || isOnSameSideDD(controlPoints[2][1]) || isOnSameSideDD(controlPoints[2][2])) {                } else {            double ld1 = getLen(controlPoints[0][0], controlPoints[0][3]);            double ld2 = getLen(controlPoints[3][0], controlPoints[3][3]);            if (ld1 > 800 || ld2 > 800) {                        } else if (ld1 > 400 || ld2 > 400) {                l[1] = 3;            } else if (ld1 > 200 || ld2 > 200) {                l[1] = 2;            } else {                l[1] = 1;            }        }    }    return l;}
private boolean pdfbox_f5513_0(Point2D p)
{    double cc = edgeEquationValue(p, controlPoints[0][0], controlPoints[3][0]) * edgeEquationValue(p, controlPoints[0][3], controlPoints[3][3]);    return cc > 0;}
private boolean pdfbox_f5514_0(Point2D p)
{    double dd = edgeEquationValue(p, controlPoints[0][0], controlPoints[0][3]) * edgeEquationValue(p, controlPoints[3][0], controlPoints[3][3]);    return dd > 0;}
private List<ShadedTriangle> pdfbox_f5515_0()
{    CoordinateColorPair[][] patchCC = getPatchCoordinatesColor();    return getShadedTriangles(patchCC);}
protected Point2D[] pdfbox_f5516_0()
{    Point2D[] implicitEdge = new Point2D[4];    for (int i = 0; i < 4; i++) {        implicitEdge[i] = controlPoints[i][3];    }    return implicitEdge;}
protected Point2D[] pdfbox_f5517_0()
{    Point2D[] implicitEdge = new Point2D[4];    for (int i = 0; i < 4; i++) {        implicitEdge[i] = controlPoints[3][3 - i];    }    return implicitEdge;}
protected Point2D[] pdfbox_f5518_0()
{    Point2D[] implicitEdge = new Point2D[4];    for (int i = 0; i < 4; i++) {        implicitEdge[i] = controlPoints[3 - i][0];    }    return implicitEdge;}
private CoordinateColorPair[][] pdfbox_f5519_0()
{    int numberOfColorComponents = cornerColor[0].length;    double[][] bernsteinPolyU = getBernsteinPolynomials(level[0]);    int szU = bernsteinPolyU[0].length;    double[][] bernsteinPolyV = getBernsteinPolynomials(level[1]);    int szV = bernsteinPolyV[0].length;    CoordinateColorPair[][] patchCC = new CoordinateColorPair[szV][szU];    double stepU = 1.0 / (szU - 1);    double stepV = 1.0 / (szV - 1);    double v = -stepV;    for (int k = 0; k < szV; k++) {                v += stepV;        double u = -stepU;        for (int l = 0; l < szU; l++) {            double tmpx = 0.0;            double tmpy = 0.0;                        for (int i = 0; i < 4; i++) {                for (int j = 0; j < 4; j++) {                    tmpx += controlPoints[i][j].getX() * bernsteinPolyU[i][l] * bernsteinPolyV[j][k];                    tmpy += controlPoints[i][j].getY() * bernsteinPolyU[i][l] * bernsteinPolyV[j][k];                }            }            Point2D tmpC = new Point2D.Double(tmpx, tmpy);            u += stepU;            float[] paramSC = new float[numberOfColorComponents];            for (int ci = 0; ci < numberOfColorComponents; ci++) {                paramSC[ci] = (float) ((1 - v) * ((1 - u) * cornerColor[0][ci] + u * cornerColor[3][ci]) +                 v * ((1 - u) * cornerColor[1][ci] + u * cornerColor[2][ci]));            }            patchCC[k][l] = new CoordinateColorPair(tmpC, paramSC);        }    }    return patchCC;}
private double[][] pdfbox_f5520_0(int lvl)
{    int sz = (1 << lvl) + 1;    double[][] poly = new double[4][sz];    double step = 1.0 / (sz - 1);    double t = -step;    for (int i = 0; i < sz; i++) {        t += step;        poly[0][i] = (1 - t) * (1 - t) * (1 - t);        poly[1][i] = 3 * t * (1 - t) * (1 - t);        poly[2][i] = 3 * t * t * (1 - t);        poly[3][i] = t * t * t;    }    return poly;}
protected final void pdfbox_f5521_0(Rectangle deviceBounds) throws IOException
{    pixelTable = calcPixelTable(deviceBounds);}
protected void pdfbox_f5522_0(List<ShadedTriangle> triangleList, Map<Point, Integer> map, Rectangle deviceBounds) throws IOException
{    for (ShadedTriangle tri : triangleList) {        int degree = tri.getDeg();        if (degree == 2) {            Line line = tri.getLine();            for (Point p : line.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(line.calcColor(p)));            }        } else {            int[] boundary = tri.getBoundary();            boundary[0] = Math.max(boundary[0], deviceBounds.x);            boundary[1] = Math.min(boundary[1], deviceBounds.x + deviceBounds.width);            boundary[2] = Math.max(boundary[2], deviceBounds.y);            boundary[3] = Math.min(boundary[3], deviceBounds.y + deviceBounds.height);            for (int x = boundary[0]; x <= boundary[1]; x++) {                for (int y = boundary[2]; y <= boundary[3]; y++) {                    Point p = new IntPoint(x, y);                    if (tri.contains(p)) {                        map.put(p, evalFunctionAndConvertToRGB(tri.calcColor(p)));                    }                }            }                                    Point p0 = new IntPoint((int) Math.round(tri.corner[0].getX()), (int) Math.round(tri.corner[0].getY()));            Point p1 = new IntPoint((int) Math.round(tri.corner[1].getX()), (int) Math.round(tri.corner[1].getY()));            Point p2 = new IntPoint((int) Math.round(tri.corner[2].getX()), (int) Math.round(tri.corner[2].getY()));            Line l1 = new Line(p0, p1, tri.color[0], tri.color[1]);            Line l2 = new Line(p1, p2, tri.color[1], tri.color[2]);            Line l3 = new Line(p2, p0, tri.color[2], tri.color[0]);            for (Point p : l1.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(l1.calcColor(p)));            }            for (Point p : l2.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(l2.calcColor(p)));            }            for (Point p : l3.linePoints) {                map.put(p, evalFunctionAndConvertToRGB(l3.calcColor(p)));            }        }    }}
private int pdfbox_f5523_0(float[] values) throws IOException
{    if (hasFunction) {        values = getShading().evalFunction(values);    }    return convertToRGB(values);}
public final ColorModel pdfbox_f5524_0()
{    return super.getColorModel();}
public void pdfbox_f5525_0()
{    super.dispose();}
public final Raster pdfbox_f5526_0(int x, int y, int w, int h)
{    WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    int[] data = new int[w * h * 4];    if (!isDataEmpty() || getBackground() != null) {        for (int row = 0; row < h; row++) {            for (int col = 0; col < w; col++) {                Point p = new IntPoint(x + col, y + row);                int value;                Integer v = pixelTable.get(p);                if (v != null) {                    value = v;                } else {                    if (getBackground() == null) {                        continue;                    }                    value = getRgbBackground();                }                int index = (row * w + col) * 4;                data[index] = value & 255;                value >>= 8;                data[index + 1] = value & 255;                value >>= 8;                data[index + 2] = value & 255;                data[index + 3] = 255;            }        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
public void pdfbox_f5527_0()
{    super.dispose();    type1ShadingType = null;}
public ColorModel pdfbox_f5528_0()
{    return super.getColorModel();}
public Raster pdfbox_f5529_1(int x, int y, int w, int h)
{    WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);    int[] data = new int[w * h * 4];    for (int j = 0; j < h; j++) {        for (int i = 0; i < w; i++) {            int index = (j * w + i) * 4;            boolean useBackground = false;            float[] values = new float[] { x + i, y + j };            rat.transform(values, 0, values, 0, 1);            if (values[0] < domain[0] || values[0] > domain[1] || values[1] < domain[2] || values[1] > domain[3]) {                if (getBackground() == null) {                    continue;                }                useBackground = true;            }                        if (useBackground) {                values = getBackground();            } else {                try {                    values = type1ShadingType.evalFunction(values);                } catch (IOException e) {                                    }            }                        PDColorSpace shadingColorSpace = getShadingColorSpace();            if (shadingColorSpace != null) {                try {                    values = shadingColorSpace.toRGB(values);                } catch (IOException e) {                                    }            }            data[index] = (int) (values[0] * 255);            data[index + 1] = (int) (values[1] * 255);            data[index + 2] = (int) (values[2] * 255);            data[index + 3] = 255;        }    }    raster.setPixels(0, 0, w, h, data);    return raster;}
public float[] pdfbox_f5530_0()
{    return domain;}
public int pdfbox_f5531_0()
{    return 0;}
public PaintContext pdfbox_f5532_1(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type1ShadingContext(shading, cm, xform, matrix);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
private List<ShadedTriangle> pdfbox_f5533_1(PDShadingType4 freeTriangleShadingType, AffineTransform xform, Matrix matrix) throws IOException
{    COSDictionary dict = freeTriangleShadingType.getCOSObject();    if (!(dict instanceof COSStream)) {        return Collections.emptyList();    }    PDRange rangeX = freeTriangleShadingType.getDecodeForParameter(0);    PDRange rangeY = freeTriangleShadingType.getDecodeForParameter(1);    if (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0 || Float.compare(rangeY.getMin(), rangeY.getMax()) == 0) {        return Collections.emptyList();    }    PDRange[] colRange = new PDRange[numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; ++i) {        colRange[i] = freeTriangleShadingType.getDecodeForParameter(2 + i);    }    List<ShadedTriangle> list = new ArrayList<>();    long maxSrcCoord = (long) Math.pow(2, bitsPerCoordinate) - 1;    long maxSrcColor = (long) Math.pow(2, bitsPerColorComponent) - 1;    COSStream stream = (COSStream) dict;    try (ImageInputStream mciis = new MemoryCacheImageInputStream(stream.createInputStream())) {        byte flag = (byte) 0;        try {            flag = (byte) (mciis.readBits(bitsPerFlag) & 3);        } catch (EOFException ex) {                    }        boolean eof = false;        while (!eof) {            Vertex p0, p1, p2;            Point2D[] ps;            float[][] cs;            int lastIndex;            try {                switch(flag) {                    case 0:                        p0 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                        flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                        if (flag != 0) {                                                    }                        p1 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                        mciis.readBits(bitsPerFlag);                        if (flag != 0) {                                                    }                        p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                        ps = new Point2D[] { p0.point, p1.point, p2.point };                        cs = new float[][] { p0.color, p1.color, p2.color };                        list.add(new ShadedTriangle(ps, cs));                        flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                        break;                    case 1:                    case 2:                        lastIndex = list.size() - 1;                        if (lastIndex < 0) {                                                    } else {                            ShadedTriangle preTri = list.get(lastIndex);                            p2 = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                            ps = new Point2D[] { flag == 1 ? preTri.corner[1] : preTri.corner[0], preTri.corner[2], p2.point };                            cs = new float[][] { flag == 1 ? preTri.color[1] : preTri.color[0], preTri.color[2], p2.color };                            list.add(new ShadedTriangle(ps, cs));                            flag = (byte) (mciis.readBits(bitsPerFlag) & 3);                        }                        break;                    default:                                                break;                }            } catch (EOFException ex) {                eof = true;            }        }    }    return list;}
public int pdfbox_f5534_0()
{    return 0;}
public PaintContext pdfbox_f5535_1(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type4ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
private List<ShadedTriangle> pdfbox_f5536_0(PDShadingType5 latticeTriangleShadingType, AffineTransform xform, Matrix matrix) throws IOException
{    COSDictionary dict = latticeTriangleShadingType.getCOSObject();    if (!(dict instanceof COSStream)) {        return Collections.emptyList();    }    PDRange rangeX = latticeTriangleShadingType.getDecodeForParameter(0);    PDRange rangeY = latticeTriangleShadingType.getDecodeForParameter(1);    if (Float.compare(rangeX.getMin(), rangeX.getMax()) == 0 || Float.compare(rangeY.getMin(), rangeY.getMax()) == 0) {        return Collections.emptyList();    }    int numPerRow = latticeTriangleShadingType.getVerticesPerRow();    PDRange[] colRange = new PDRange[numberOfColorComponents];    for (int i = 0; i < numberOfColorComponents; ++i) {        colRange[i] = latticeTriangleShadingType.getDecodeForParameter(2 + i);    }    List<Vertex> vlist = new ArrayList<>();    long maxSrcCoord = (long) Math.pow(2, bitsPerCoordinate) - 1;    long maxSrcColor = (long) Math.pow(2, bitsPerColorComponent) - 1;    COSStream cosStream = (COSStream) dict;    try (ImageInputStream mciis = new MemoryCacheImageInputStream(cosStream.createInputStream())) {        boolean eof = false;        while (!eof) {            Vertex p;            try {                p = readVertex(mciis, maxSrcCoord, maxSrcColor, rangeX, rangeY, colRange, matrix, xform);                vlist.add(p);            } catch (EOFException ex) {                eof = true;            }        }    }    int rowNum = vlist.size() / numPerRow;    Vertex[][] latticeArray = new Vertex[rowNum][numPerRow];    List<ShadedTriangle> list = new ArrayList<>();    if (rowNum < 2) {                return list;    }    for (int i = 0; i < rowNum; i++) {        for (int j = 0; j < numPerRow; j++) {            latticeArray[i][j] = vlist.get(i * numPerRow + j);        }    }    for (int i = 0; i < rowNum - 1; i++) {        for (int j = 0; j < numPerRow - 1; j++) {            Point2D[] ps = new Point2D[] { latticeArray[i][j].point, latticeArray[i][j + 1].point, latticeArray[i + 1][j].point };            float[][] cs = new float[][] { latticeArray[i][j].color, latticeArray[i][j + 1].color, latticeArray[i + 1][j].color };            list.add(new ShadedTriangle(ps, cs));            ps = new Point2D[] { latticeArray[i][j + 1].point, latticeArray[i + 1][j].point, latticeArray[i + 1][j + 1].point };            cs = new float[][] { latticeArray[i][j + 1].color, latticeArray[i + 1][j].color, latticeArray[i + 1][j + 1].color };            list.add(new ShadedTriangle(ps, cs));        }    }    return list;}
public int pdfbox_f5537_0()
{    return 0;}
public PaintContext pdfbox_f5538_1(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type5ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
protected Patch pdfbox_f5539_0(Point2D[] points, float[][] color)
{    return new CoonsPatch(points, color);}
public int pdfbox_f5540_0()
{    return 0;}
public PaintContext pdfbox_f5541_1(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type6ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
protected Patch pdfbox_f5542_0(Point2D[] points, float[][] color)
{    return new TensorPatch(points, color);}
public int pdfbox_f5543_0()
{    return 0;}
public PaintContext pdfbox_f5544_1(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    try {        return new Type7ShadingContext(shading, cm, xform, matrix, deviceBounds);    } catch (IOException e) {                return new Color(0, 0, 0, 0).createContext(cm, deviceBounds, userBounds, xform, hints);    }}
public String pdfbox_f5545_0()
{    StringBuilder sb = new StringBuilder();    for (float f : color) {        if (sb.length() > 0) {            sb.append(' ');        }        sb.append(String.format("%3.2f", f));    }    return "Vertex{ " + point + ", colors=[" + sb + "] }";}
public void pdfbox_f5546_0(PDGraphicsState gs) throws IOException
{    for (COSName key : dict.keySet()) {        if (key.equals(COSName.LW)) {            gs.setLineWidth(defaultIfNull(getLineWidth(), 1));        } else if (key.equals(COSName.LC)) {            gs.setLineCap(getLineCapStyle());        } else if (key.equals(COSName.LJ)) {            gs.setLineJoin(getLineJoinStyle());        } else if (key.equals(COSName.ML)) {            gs.setMiterLimit(defaultIfNull(getMiterLimit(), 10));        } else if (key.equals(COSName.D)) {            gs.setLineDashPattern(getLineDashPattern());        } else if (key.equals(COSName.RI)) {            gs.setRenderingIntent(getRenderingIntent());        } else if (key.equals(COSName.OPM)) {            gs.setOverprintMode(defaultIfNull(getOverprintMode(), 0));        } else if (key.equals(COSName.OP)) {            gs.setOverprint(getStrokingOverprintControl());        } else if (key.equals(COSName.OP_NS)) {            gs.setNonStrokingOverprint(getNonStrokingOverprintControl());        } else if (key.equals(COSName.FONT)) {            PDFontSetting setting = getFontSetting();            if (setting != null) {                gs.getTextState().setFont(setting.getFont());                gs.getTextState().setFontSize(setting.getFontSize());            }        } else if (key.equals(COSName.FL)) {            gs.setFlatness(defaultIfNull(getFlatnessTolerance(), 1.0f));        } else if (key.equals(COSName.SM)) {            gs.setSmoothness(defaultIfNull(getSmoothnessTolerance(), 0));        } else if (key.equals(COSName.SA)) {            gs.setStrokeAdjustment(getAutomaticStrokeAdjustment());        } else if (key.equals(COSName.CA)) {            gs.setAlphaConstant(defaultIfNull(getStrokingAlphaConstant(), 1.0f));        } else if (key.equals(COSName.CA_NS)) {            gs.setNonStrokeAlphaConstant(defaultIfNull(getNonStrokingAlphaConstant(), 1.0f));        } else if (key.equals(COSName.AIS)) {            gs.setAlphaSource(getAlphaSourceFlag());        } else if (key.equals(COSName.TK)) {            gs.getTextState().setKnockoutFlag(getTextKnockoutFlag());        } else if (key.equals(COSName.SMASK)) {            PDSoftMask softmask = getSoftMask();            if (softmask != null) {                                                softmask.setInitialTransformationMatrix(gs.getCurrentTransformationMatrix().clone());            }            gs.setSoftMask(softmask);        } else if (key.equals(COSName.BM)) {            gs.setBlendMode(getBlendMode());        } else if (key.equals(COSName.TR)) {            if (dict.containsKey(COSName.TR2)) {                                continue;            }            gs.setTransfer(getTransfer());        } else if (key.equals(COSName.TR2)) {            gs.setTransfer(getTransfer2());        }    }}
private float pdfbox_f5547_0(Float standardValue, float defaultValue)
{    return standardValue != null ? standardValue : defaultValue;}
public COSDictionary pdfbox_f5548_0()
{    return dict;}
public Float pdfbox_f5549_0()
{    return getFloatItem(COSName.LW);}
public void pdfbox_f5550_0(Float width)
{    setFloatItem(COSName.LW, width);}
public int pdfbox_f5551_0()
{    return dict.getInt(COSName.LC);}
public void pdfbox_f5552_0(int style)
{    dict.setInt(COSName.LC, style);}
public int pdfbox_f5553_0()
{    return dict.getInt(COSName.LJ);}
public void pdfbox_f5554_0(int style)
{    dict.setInt(COSName.LJ, style);}
public Float pdfbox_f5555_0()
{    return getFloatItem(COSName.ML);}
public void pdfbox_f5556_0(Float miterLimit)
{    setFloatItem(COSName.ML, miterLimit);}
public PDLineDashPattern pdfbox_f5557_0()
{    PDLineDashPattern retval = null;    COSBase dp = dict.getDictionaryObject(COSName.D);    if (dp instanceof COSArray && ((COSArray) dp).size() == 2) {        COSBase dashArray = ((COSArray) dp).getObject(0);        COSBase phase = ((COSArray) dp).getObject(1);        if (dashArray instanceof COSArray && phase instanceof COSNumber) {            retval = new PDLineDashPattern((COSArray) dashArray, ((COSNumber) phase).intValue());        }    }    return retval;}
public void pdfbox_f5558_0(PDLineDashPattern dashPattern)
{    dict.setItem(COSName.D, dashPattern.getCOSObject());}
public RenderingIntent pdfbox_f5559_0()
{    String ri = dict.getNameAsString("RI");    if (ri != null) {        return RenderingIntent.fromString(ri);    } else {        return null;    }}
public void pdfbox_f5560_0(String ri)
{    dict.setName("RI", ri);}
public boolean pdfbox_f5561_0()
{    return dict.getBoolean(COSName.OP, false);}
public void pdfbox_f5562_0(boolean op)
{    dict.setBoolean(COSName.OP, op);}
public boolean pdfbox_f5563_0()
{    return dict.getBoolean(COSName.OP_NS, getStrokingOverprintControl());}
public void pdfbox_f5564_0(boolean op)
{    dict.setBoolean(COSName.OP_NS, op);}
public Float pdfbox_f5565_0()
{    return getFloatItem(COSName.OPM);}
public void pdfbox_f5566_0(Float overprintMode)
{    setFloatItem(COSName.OPM, overprintMode);}
public PDFontSetting pdfbox_f5567_0()
{    PDFontSetting setting = null;    COSBase base = dict.getDictionaryObject(COSName.FONT);    if (base instanceof COSArray) {        COSArray font = (COSArray) base;        setting = new PDFontSetting(font);    }    return setting;}
public void pdfbox_f5568_0(PDFontSetting fs)
{    dict.setItem(COSName.FONT, fs);}
public Float pdfbox_f5569_0()
{    return getFloatItem(COSName.FL);}
public void pdfbox_f5570_0(Float flatness)
{    setFloatItem(COSName.FL, flatness);}
public Float pdfbox_f5571_0()
{    return getFloatItem(COSName.SM);}
public void pdfbox_f5572_0(Float smoothness)
{    setFloatItem(COSName.SM, smoothness);}
public boolean pdfbox_f5573_0()
{    return dict.getBoolean(COSName.SA, false);}
public void pdfbox_f5574_0(boolean sa)
{    dict.setBoolean(COSName.SA, sa);}
public Float pdfbox_f5575_0()
{    return getFloatItem(COSName.CA);}
public void pdfbox_f5576_0(Float alpha)
{    setFloatItem(COSName.CA, alpha);}
public Float pdfbox_f5577_0()
{    return getFloatItem(COSName.CA_NS);}
public void pdfbox_f5578_0(Float alpha)
{    setFloatItem(COSName.CA_NS, alpha);}
public boolean pdfbox_f5579_0()
{    return dict.getBoolean(COSName.AIS, false);}
public void pdfbox_f5580_0(boolean alpha)
{    dict.setBoolean(COSName.AIS, alpha);}
public BlendMode pdfbox_f5581_0()
{    return BlendMode.getInstance(dict.getDictionaryObject(COSName.BM));}
public void pdfbox_f5582_0(BlendMode bm)
{    dict.setItem(COSName.BM, BlendMode.getCOSName(bm));}
public PDSoftMask pdfbox_f5583_0()
{    if (!dict.containsKey(COSName.SMASK)) {        return null;    }    return PDSoftMask.create(dict.getDictionaryObject(COSName.SMASK));}
public boolean pdfbox_f5584_0()
{    return dict.getBoolean(COSName.TK, true);}
public void pdfbox_f5585_0(boolean tk)
{    dict.setBoolean(COSName.TK, tk);}
private Float pdfbox_f5586_0(COSName key)
{    Float retval = null;    COSBase base = dict.getDictionaryObject(key);    if (base instanceof COSNumber) {        COSNumber value = (COSNumber) base;        retval = value.floatValue();    }    return retval;}
private void pdfbox_f5587_0(COSName key, Float value)
{    if (value == null) {        dict.removeItem(key);    } else {        dict.setItem(key, new COSFloat(value));    }}
public COSBase pdfbox_f5588_0()
{    COSBase base = dict.getDictionaryObject(COSName.TR);    if (base instanceof COSArray && ((COSArray) base).size() != 4) {        return null;    }    return base;}
public void pdfbox_f5589_0(COSBase transfer)
{    dict.setItem(COSName.TR, transfer);}
public COSBase pdfbox_f5590_0()
{    COSBase base = dict.getDictionaryObject(COSName.TR2);    if (base instanceof COSArray && ((COSArray) base).size() != 4) {        return null;    }    return base;}
public void pdfbox_f5591_0(COSBase transfer2)
{    dict.setItem(COSName.TR2, transfer2);}
public Matrix pdfbox_f5592_0()
{    return currentTransformationMatrix;}
public void pdfbox_f5593_0(Matrix value)
{    currentTransformationMatrix = value;}
public float pdfbox_f5594_0()
{    return lineWidth;}
public void pdfbox_f5595_0(float value)
{    lineWidth = value;}
public int pdfbox_f5596_0()
{    return lineCap;}
public void pdfbox_f5597_0(int value)
{    lineCap = value;}
public int pdfbox_f5598_0()
{    return lineJoin;}
public void pdfbox_f5599_0(int value)
{    lineJoin = value;}
public float pdfbox_f5600_0()
{    return miterLimit;}
public void pdfbox_f5601_0(float value)
{    miterLimit = value;}
public boolean pdfbox_f5602_0()
{    return strokeAdjustment;}
public void pdfbox_f5603_0(boolean value)
{    strokeAdjustment = value;}
public double pdfbox_f5604_0()
{    return alphaConstant;}
public void pdfbox_f5605_0(double value)
{    alphaConstant = value;}
public double pdfbox_f5606_0()
{    return nonStrokingAlphaConstant;}
public void pdfbox_f5607_0(double value)
{    nonStrokingAlphaConstant = value;}
public boolean pdfbox_f5608_0()
{    return alphaSource;}
public void pdfbox_f5609_0(boolean value)
{    alphaSource = value;}
public PDSoftMask pdfbox_f5610_0()
{    return softMask;}
public void pdfbox_f5611_0(PDSoftMask softMask)
{    this.softMask = softMask;}
public BlendMode pdfbox_f5612_0()
{    return blendMode;}
public void pdfbox_f5613_0(BlendMode blendMode)
{    this.blendMode = blendMode;}
public boolean pdfbox_f5614_0()
{    return overprint;}
public void pdfbox_f5615_0(boolean value)
{    overprint = value;}
public boolean pdfbox_f5616_0()
{    return nonStrokingOverprint;}
public void pdfbox_f5617_0(boolean value)
{    nonStrokingOverprint = value;}
public double pdfbox_f5618_0()
{    return overprintMode;}
public void pdfbox_f5619_0(double value)
{    overprintMode = value;}
public double pdfbox_f5620_0()
{    return flatness;}
public void pdfbox_f5621_0(double value)
{    flatness = value;}
public double pdfbox_f5622_0()
{    return smoothness;}
public void pdfbox_f5623_0(double value)
{    smoothness = value;}
public PDTextState pdfbox_f5624_0()
{    return textState;}
public void pdfbox_f5625_0(PDTextState value)
{    textState = value;}
public PDLineDashPattern pdfbox_f5626_0()
{    return lineDashPattern;}
public void pdfbox_f5627_0(PDLineDashPattern value)
{    lineDashPattern = value;}
public RenderingIntent pdfbox_f5628_0()
{    return renderingIntent;}
public void pdfbox_f5629_0(RenderingIntent value)
{    renderingIntent = value;}
public PDGraphicsState pdfbox_f5630_0()
{    try {        PDGraphicsState clone = (PDGraphicsState) super.clone();        clone.textState = textState.clone();        clone.currentTransformationMatrix = currentTransformationMatrix.clone();                clone.strokingColor = strokingColor;                clone.nonStrokingColor = nonStrokingColor;                clone.lineDashPattern = lineDashPattern;                clone.clippingPath = clippingPath;        clone.isClippingPathDirty = false;        return clone;    } catch (CloneNotSupportedException e) {                throw new RuntimeException(e);    }}
public PDColor pdfbox_f5631_0()
{    return strokingColor;}
public void pdfbox_f5632_0(PDColor color)
{    strokingColor = color;}
public PDColor pdfbox_f5633_0()
{    return nonStrokingColor;}
public void pdfbox_f5634_0(PDColor color)
{    nonStrokingColor = color;}
public PDColorSpace pdfbox_f5635_0()
{    return strokingColorSpace;}
public void pdfbox_f5636_0(PDColorSpace colorSpace)
{    strokingColorSpace = colorSpace;}
public PDColorSpace pdfbox_f5637_0()
{    return nonStrokingColorSpace;}
public void pdfbox_f5638_0(PDColorSpace colorSpace)
{    nonStrokingColorSpace = colorSpace;}
public void pdfbox_f5639_0(GeneralPath path)
{    intersectClippingPath(new Area(path));}
public void pdfbox_f5640_0(Area area)
{        if (!isClippingPathDirty) {                Area cloned = new Area();        cloned.add(clippingPath);        clippingPath = cloned;        isClippingPathDirty = true;    }        clippingPath.intersect(area);}
public Area pdfbox_f5641_0()
{    return clippingPath;}
public Composite pdfbox_f5642_0()
{    return BlendComposite.getInstance(blendMode, (float) alphaConstant);}
public Composite pdfbox_f5643_0()
{    return BlendComposite.getInstance(blendMode, (float) nonStrokingAlphaConstant);}
public COSBase pdfbox_f5644_0()
{    return transfer;}
public void pdfbox_f5645_0(COSBase transfer)
{    this.transfer = transfer;}
public static PDSoftMask pdfbox_f5646_1(COSBase dictionary)
{    if (dictionary instanceof COSName) {        if (COSName.NONE.equals(dictionary)) {            return null;        } else {                        return null;        }    } else if (dictionary instanceof COSDictionary) {        return new PDSoftMask((COSDictionary) dictionary);    } else {                return null;    }}
public COSDictionary pdfbox_f5647_0()
{    return dictionary;}
public COSName pdfbox_f5648_0()
{    if (subType == null) {        subType = (COSName) getCOSObject().getDictionaryObject(COSName.S);    }    return subType;}
public PDTransparencyGroup pdfbox_f5649_0() throws IOException
{    if (group == null) {        COSBase cosGroup = getCOSObject().getDictionaryObject(COSName.G);        if (cosGroup != null) {            PDXObject x = PDXObject.createXObject(cosGroup, null);            if (x instanceof PDTransparencyGroup) {                group = (PDTransparencyGroup) x;            }        }    }    return group;}
public COSArray pdfbox_f5650_0()
{    if (backdropColor == null) {        backdropColor = (COSArray) getCOSObject().getDictionaryObject(COSName.BC);    }    return backdropColor;}
public PDFunction pdfbox_f5651_0() throws IOException
{    if (transferFunction == null) {        COSBase cosTF = getCOSObject().getDictionaryObject(COSName.TR);        if (cosTF != null) {            transferFunction = PDFunction.create(cosTF);        }    }    return transferFunction;}
 void pdfbox_f5652_0(Matrix ctm)
{    this.ctm = ctm;}
public Matrix pdfbox_f5653_0()
{    return ctm;}
public float pdfbox_f5654_0()
{    return characterSpacing;}
public void pdfbox_f5655_0(float value)
{    characterSpacing = value;}
public float pdfbox_f5656_0()
{    return wordSpacing;}
public void pdfbox_f5657_0(float value)
{    wordSpacing = value;}
public float pdfbox_f5658_0()
{    return horizontalScaling;}
public void pdfbox_f5659_0(float value)
{    horizontalScaling = value;}
public float pdfbox_f5660_0()
{    return leading;}
public void pdfbox_f5661_0(float value)
{    leading = value;}
public PDFont pdfbox_f5662_0()
{    return font;}
public void pdfbox_f5663_0(PDFont value)
{    font = value;}
public float pdfbox_f5664_0()
{    return fontSize;}
public void pdfbox_f5665_0(float value)
{    fontSize = value;}
public RenderingMode pdfbox_f5666_0()
{    return renderingMode;}
public void pdfbox_f5667_0(RenderingMode renderingMode)
{    this.renderingMode = renderingMode;}
public float pdfbox_f5668_0()
{    return rise;}
public void pdfbox_f5669_0(float value)
{    rise = value;}
public boolean pdfbox_f5670_0()
{    return knockout;}
public void pdfbox_f5671_0(boolean value)
{    knockout = value;}
public PDTextState pdfbox_f5672_0()
{    try {        return (PDTextState) super.clone();    } catch (CloneNotSupportedException e) {                throw new RuntimeException(e);    }}
public static RenderingIntent pdfbox_f5673_0(String value)
{    for (RenderingIntent instance : RenderingIntent.values()) {        if (instance.value.equals(value)) {            return instance;        }    }        return RELATIVE_COLORIMETRIC;}
public String pdfbox_f5674_0()
{    return value;}
public static RenderingMode pdfbox_f5675_0(int value)
{    return VALUES[value];}
public int pdfbox_f5676_0()
{    return value;}
public boolean pdfbox_f5677_0()
{    return this == FILL || this == FILL_STROKE || this == FILL_CLIP || this == FILL_STROKE_CLIP;}
public boolean pdfbox_f5678_0()
{    return this == STROKE || this == FILL_STROKE || this == STROKE_CLIP || this == FILL_STROKE_CLIP;}
public boolean pdfbox_f5679_0()
{    return this == FILL_CLIP || this == STROKE_CLIP || this == FILL_STROKE_CLIP || this == NEITHER_CLIP;}
public COSDictionary pdfbox_f5680_0()
{    return action;}
public final String pdfbox_f5681_0()
{    return action.getNameAsString(COSName.TYPE);}
protected final void pdfbox_f5682_0(String type)
{    action.setName(COSName.TYPE, type);}
public final String pdfbox_f5683_0()
{    return action.getNameAsString(COSName.S);}
protected final void pdfbox_f5684_0(String s)
{    action.setName(COSName.S, s);}
public List<PDAction> pdfbox_f5685_0()
{    List<PDAction> retval = null;    COSBase next = action.getDictionaryObject(COSName.NEXT);    if (next instanceof COSDictionary) {        PDAction pdAction = PDActionFactory.createAction((COSDictionary) next);        retval = new COSArrayList<>(pdAction, next, action, COSName.NEXT);    } else if (next instanceof COSArray) {        COSArray array = (COSArray) next;        List<PDAction> actions = new ArrayList<>();        for (int i = 0; i < array.size(); i++) {            actions.add(PDActionFactory.createAction((COSDictionary) array.getObject(i)));        }        retval = new COSArrayList<>(actions, array);    }    return retval;}
public void pdfbox_f5686_0(List<?> next)
{    action.setItem(COSName.NEXT, COSArrayList.converterToCOSArray(next));}
public PDDestination pdfbox_f5687_0() throws IOException
{    return PDDestination.create(getCOSObject().getDictionaryObject(COSName.D));}
public void pdfbox_f5688_0(PDDestination d)
{    if (d instanceof PDPageDestination) {        PDPageDestination pageDest = (PDPageDestination) d;        COSArray destArray = pageDest.getCOSObject();        if (destArray.size() >= 1) {            COSBase page = destArray.getObject(0);            if (!(page instanceof COSDictionary)) {                throw new IllegalArgumentException("Destination of a GoToE action must be " + "a page dictionary object");            }        }    }    getCOSObject().setItem(COSName.D, d);}
public PDFileSpecification pdfbox_f5689_0() throws IOException
{    return PDFileSpecification.createFS(getCOSObject().getDictionaryObject(COSName.F));}
public void pdfbox_f5690_0(PDFileSpecification fs)
{    getCOSObject().setItem(COSName.F, fs);}
public OpenMode pdfbox_f5691_0()
{    if (getCOSObject().getDictionaryObject(COSName.NEW_WINDOW) instanceof COSBoolean) {        COSBoolean b = (COSBoolean) getCOSObject().getDictionaryObject(COSName.NEW_WINDOW);        return b.getValue() ? OpenMode.NEW_WINDOW : OpenMode.SAME_WINDOW;    }    return OpenMode.USER_PREFERENCE;}
public void pdfbox_f5692_0(OpenMode value)
{    if (null == value) {        getCOSObject().removeItem(COSName.NEW_WINDOW);        return;    }    switch(value) {        case USER_PREFERENCE:            getCOSObject().removeItem(COSName.NEW_WINDOW);            break;        case SAME_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, false);            break;        case NEW_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, true);            break;        default:                        break;    }}
public PDTargetDirectory pdfbox_f5693_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.T);    if (base instanceof COSDictionary) {        return new PDTargetDirectory((COSDictionary) base);    }    return null;}
public void pdfbox_f5694_0(PDTargetDirectory targetDirectory)
{    getCOSObject().setItem(COSName.T, targetDirectory);}
public static PDAction pdfbox_f5695_0(COSDictionary action)
{    PDAction retval = null;    if (action != null) {        String type = action.getNameAsString(COSName.S);        if (type != null) {            switch(type) {                case PDActionJavaScript.SUB_TYPE:                    retval = new PDActionJavaScript(action);                    break;                case PDActionGoTo.SUB_TYPE:                    retval = new PDActionGoTo(action);                    break;                case PDActionLaunch.SUB_TYPE:                    retval = new PDActionLaunch(action);                    break;                case PDActionRemoteGoTo.SUB_TYPE:                    retval = new PDActionRemoteGoTo(action);                    break;                case PDActionURI.SUB_TYPE:                    retval = new PDActionURI(action);                    break;                case PDActionNamed.SUB_TYPE:                    retval = new PDActionNamed(action);                    break;                case PDActionSound.SUB_TYPE:                    retval = new PDActionSound(action);                    break;                case PDActionMovie.SUB_TYPE:                    retval = new PDActionMovie(action);                    break;                case PDActionImportData.SUB_TYPE:                    retval = new PDActionImportData(action);                    break;                case PDActionResetForm.SUB_TYPE:                    retval = new PDActionResetForm(action);                    break;                case PDActionHide.SUB_TYPE:                    retval = new PDActionHide(action);                    break;                case PDActionSubmitForm.SUB_TYPE:                    retval = new PDActionSubmitForm(action);                    break;                case PDActionThread.SUB_TYPE:                    retval = new PDActionThread(action);                    break;                case PDActionEmbeddedGoTo.SUB_TYPE:                    retval = new PDActionEmbeddedGoTo(action);                    break;                default:                    break;            }        }    }    return retval;}
public PDDestination pdfbox_f5696_0() throws IOException
{    return PDDestination.create(getCOSObject().getDictionaryObject(COSName.D));}
public void pdfbox_f5697_0(PDDestination d)
{    if (d instanceof PDPageDestination) {        PDPageDestination pageDest = (PDPageDestination) d;        COSArray destArray = pageDest.getCOSObject();        if (destArray.size() >= 1) {            COSBase page = destArray.getObject(0);            if (!(page instanceof COSDictionary)) {                throw new IllegalArgumentException("Destination of a GoTo action must be " + "a page dictionary object");            }        }    }    getCOSObject().setItem(COSName.D, d);}
public COSBase pdfbox_f5698_0()
{        return this.action.getDictionaryObject(COSName.T);}
public void pdfbox_f5699_0(COSBase t)
{    this.action.setItem(COSName.T, t);}
public boolean pdfbox_f5700_0()
{    return this.action.getBoolean(COSName.H, true);}
public void pdfbox_f5701_0(boolean h)
{    this.action.setItem(COSName.H, COSBoolean.getBoolean(h));}
public PDFileSpecification pdfbox_f5702_0() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
public void pdfbox_f5703_0(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
public final void pdfbox_f5704_0(String sAction)
{    action.setString(COSName.JS, sAction);}
public String pdfbox_f5705_0()
{    COSBase base = action.getDictionaryObject(COSName.JS);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
public PDFileSpecification pdfbox_f5706_0() throws IOException
{    return PDFileSpecification.createFS(getCOSObject().getDictionaryObject(COSName.F));}
public void pdfbox_f5707_0(PDFileSpecification fs)
{    getCOSObject().setItem(COSName.F, fs);}
public PDWindowsLaunchParams pdfbox_f5708_0()
{    COSDictionary win = (COSDictionary) action.getDictionaryObject("Win");    PDWindowsLaunchParams retval = null;    if (win != null) {        retval = new PDWindowsLaunchParams(win);    }    return retval;}
public void pdfbox_f5709_0(PDWindowsLaunchParams win)
{    action.setItem("Win", win);}
public String pdfbox_f5710_0()
{    return action.getString(COSName.F);}
public void pdfbox_f5711_0(String f)
{    action.setString(COSName.F, f);}
public String pdfbox_f5712_0()
{    return action.getString(COSName.D);}
public void pdfbox_f5713_0(String d)
{    action.setString(COSName.D, d);}
public String pdfbox_f5714_0()
{    return action.getString(COSName.O);}
public void pdfbox_f5715_0(String o)
{    action.setString(COSName.O, o);}
public String pdfbox_f5716_0()
{    return action.getString(COSName.P);}
public void pdfbox_f5717_0(String p)
{    action.setString(COSName.P, p);}
public OpenMode pdfbox_f5718_0()
{    if (getCOSObject().getDictionaryObject(COSName.NEW_WINDOW) instanceof COSBoolean) {        COSBoolean b = (COSBoolean) getCOSObject().getDictionaryObject(COSName.NEW_WINDOW);        return b.getValue() ? OpenMode.NEW_WINDOW : OpenMode.SAME_WINDOW;    }    return OpenMode.USER_PREFERENCE;}
public void pdfbox_f5719_0(OpenMode value)
{    if (null == value) {        getCOSObject().removeItem(COSName.NEW_WINDOW);        return;    }    switch(value) {        case USER_PREFERENCE:            getCOSObject().removeItem(COSName.NEW_WINDOW);            break;        case SAME_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, false);            break;        case NEW_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, true);            break;        default:                        break;    }}
public String pdfbox_f5720_0()
{    return action.getNameAsString("N");}
public void pdfbox_f5721_0(String name)
{    action.setName("N", name);}
public PDFileSpecification pdfbox_f5722_0() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
public void pdfbox_f5723_0(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
public COSBase pdfbox_f5724_0()
{    return action.getDictionaryObject(COSName.D);}
public void pdfbox_f5725_0(COSBase d)
{    action.setItem(COSName.D, d);}
public OpenMode pdfbox_f5726_0()
{    if (getCOSObject().getDictionaryObject(COSName.NEW_WINDOW) instanceof COSBoolean) {        COSBoolean b = (COSBoolean) getCOSObject().getDictionaryObject(COSName.NEW_WINDOW);        return b.getValue() ? OpenMode.NEW_WINDOW : OpenMode.SAME_WINDOW;    }    return OpenMode.USER_PREFERENCE;}
public void pdfbox_f5727_0(OpenMode value)
{    if (null == value) {        getCOSObject().removeItem(COSName.NEW_WINDOW);        return;    }    switch(value) {        case USER_PREFERENCE:            getCOSObject().removeItem(COSName.NEW_WINDOW);            break;        case SAME_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, false);            break;        case NEW_WINDOW:            getCOSObject().setBoolean(COSName.NEW_WINDOW, true);            break;        default:                        break;    }}
public COSArray pdfbox_f5728_0()
{    COSBase retval = this.action.getDictionaryObject(COSName.FIELDS);    return retval instanceof COSArray ? (COSArray) retval : null;}
public void pdfbox_f5729_0(COSArray array)
{    this.action.setItem(COSName.FIELDS, array);}
public int pdfbox_f5730_0()
{    return this.action.getInt(COSName.FLAGS, 0);}
public void pdfbox_f5731_0(int flags)
{    this.action.setInt(COSName.FLAGS, flags);}
public void pdfbox_f5732_0(COSStream sound)
{    action.setItem(COSName.SOUND, sound);}
public COSStream pdfbox_f5733_0()
{    COSBase base = action.getDictionaryObject(COSName.SOUND);    if (base instanceof COSStream) {        return (COSStream) base;    }    return null;}
public void pdfbox_f5734_0(float volume)
{    if (volume < -1 || volume > 1) {        throw new IllegalArgumentException("volume outside of the range 1.0 to 1.0");    }    action.setFloat(COSName.VOLUME, volume);}
public float pdfbox_f5735_0()
{    COSBase base = action.getDictionaryObject(COSName.VOLUME);    if (base instanceof COSNumber) {        float volume = ((COSNumber) base).floatValue();        if (volume < -1 || volume > 1) {            volume = 1;        }        return volume;    }    return 1;}
public void pdfbox_f5736_0(boolean synchronous)
{    action.setBoolean(COSName.SYNCHRONOUS, synchronous);}
public boolean pdfbox_f5737_0()
{    COSBase base = action.getDictionaryObject(COSName.SYNCHRONOUS);    if (base instanceof COSBoolean) {        return ((COSBoolean) base).getValue();    }    return false;}
public void pdfbox_f5738_0(boolean repeat)
{    action.setBoolean(COSName.REPEAT, repeat);}
public boolean pdfbox_f5739_0()
{    COSBase base = action.getDictionaryObject(COSName.REPEAT);    if (base instanceof COSBoolean) {        return ((COSBoolean) base).getValue();    }    return false;}
public void pdfbox_f5740_0(boolean mix)
{    action.setBoolean(COSName.MIX, mix);}
public boolean pdfbox_f5741_0()
{    COSBase base = action.getDictionaryObject(COSName.MIX);    if (base instanceof COSBoolean) {        return ((COSBoolean) base).getValue();    }    return false;}
public PDFileSpecification pdfbox_f5742_0() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
public void pdfbox_f5743_0(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
public COSArray pdfbox_f5744_0()
{    COSBase retval = this.action.getDictionaryObject(COSName.FIELDS);    return retval instanceof COSArray ? (COSArray) retval : null;}
public void pdfbox_f5745_0(COSArray array)
{    this.action.setItem(COSName.FIELDS, array);}
public int pdfbox_f5746_0()
{    return this.action.getInt(COSName.FLAGS, 0);}
public void pdfbox_f5747_0(int flags)
{    this.action.setInt(COSName.FLAGS, flags);}
public COSBase pdfbox_f5748_0()
{    return action.getDictionaryObject(COSName.D);}
public void pdfbox_f5749_0(COSBase d)
{    action.setItem(COSName.D, d);}
public PDFileSpecification pdfbox_f5750_0() throws IOException
{    return PDFileSpecification.createFS(action.getDictionaryObject(COSName.F));}
public void pdfbox_f5751_0(PDFileSpecification fs)
{    action.setItem(COSName.F, fs);}
public COSBase pdfbox_f5752_0()
{    return action.getDictionaryObject(COSName.B);}
public void pdfbox_f5753_0(COSBase b)
{    action.setItem(COSName.B, b);}
public String pdfbox_f5754_0()
{    COSBase base = action.getDictionaryObject(COSName.URI);    if (base instanceof COSString) {        byte[] bytes = ((COSString) base).getBytes();        if (bytes.length >= 2) {                        if ((bytes[0] & 0xFF) == 0xFE && (bytes[1] & 0xFF) == 0xFF) {                return action.getString(COSName.URI);            }                        if ((bytes[0] & 0xFF) == 0xFF && (bytes[1] & 0xFF) == 0xFE) {                return action.getString(COSName.URI);            }        }        return new String(bytes, Charsets.UTF_8);    }    return null;}
public void pdfbox_f5755_0(String uri)
{    action.setString(COSName.URI, uri);}
public boolean pdfbox_f5756_0()
{    return this.action.getBoolean("IsMap", false);}
public void pdfbox_f5757_0(boolean value)
{    this.action.setBoolean("IsMap", value);}
public COSDictionary pdfbox_f5758_0()
{    return actions;}
public PDAction pdfbox_f5759_0()
{    return PDActionFactory.createAction((COSDictionary) actions.getDictionaryObject(COSName.F));}
public void pdfbox_f5760_0(PDAction action)
{    actions.setItem(COSName.F, action);}
public COSDictionary pdfbox_f5761_0()
{    return actions;}
public PDAction pdfbox_f5762_0()
{    COSDictionary e = (COSDictionary) actions.getDictionaryObject("E");    PDAction retval = null;    if (e != null) {        retval = PDActionFactory.createAction(e);    }    return retval;}
public void pdfbox_f5763_0(PDAction e)
{    actions.setItem("E", e);}
public PDAction pdfbox_f5764_0()
{    COSDictionary x = (COSDictionary) actions.getDictionaryObject("X");    PDAction retval = null;    if (x != null) {        retval = PDActionFactory.createAction(x);    }    return retval;}
public void pdfbox_f5765_0(PDAction x)
{    actions.setItem("X", x);}
public PDAction pdfbox_f5766_0()
{    COSDictionary d = (COSDictionary) actions.getDictionaryObject(COSName.D);    PDAction retval = null;    if (d != null) {        retval = PDActionFactory.createAction(d);    }    return retval;}
public void pdfbox_f5767_0(PDAction d)
{    actions.setItem(COSName.D, d);}
public PDAction pdfbox_f5768_0()
{    COSDictionary u = (COSDictionary) actions.getDictionaryObject("U");    PDAction retval = null;    if (u != null) {        retval = PDActionFactory.createAction(u);    }    return retval;}
public void pdfbox_f5769_0(PDAction u)
{    actions.setItem("U", u);}
public PDAction pdfbox_f5770_0()
{    COSDictionary fo = (COSDictionary) actions.getDictionaryObject("Fo");    PDAction retval = null;    if (fo != null) {        retval = PDActionFactory.createAction(fo);    }    return retval;}
public void pdfbox_f5771_0(PDAction fo)
{    actions.setItem("Fo", fo);}
public PDAction pdfbox_f5772_0()
{    COSDictionary bl = (COSDictionary) actions.getDictionaryObject("Bl");    PDAction retval = null;    if (bl != null) {        retval = PDActionFactory.createAction(bl);    }    return retval;}
public void pdfbox_f5773_0(PDAction bl)
{    actions.setItem("Bl", bl);}
public PDAction pdfbox_f5774_0()
{    COSDictionary po = (COSDictionary) actions.getDictionaryObject("PO");    PDAction retval = null;    if (po != null) {        retval = PDActionFactory.createAction(po);    }    return retval;}
public void pdfbox_f5775_0(PDAction po)
{    actions.setItem("PO", po);}
public PDAction pdfbox_f5776_0()
{    COSDictionary pc = (COSDictionary) actions.getDictionaryObject("PC");    PDAction retval = null;    if (pc != null) {        retval = PDActionFactory.createAction(pc);    }    return retval;}
public void pdfbox_f5777_0(PDAction pc)
{    actions.setItem("PC", pc);}
public PDAction pdfbox_f5778_0()
{    COSDictionary pv = (COSDictionary) actions.getDictionaryObject("PV");    PDAction retval = null;    if (pv != null) {        retval = PDActionFactory.createAction(pv);    }    return retval;}
public void pdfbox_f5779_0(PDAction pv)
{    actions.setItem("PV", pv);}
public PDAction pdfbox_f5780_0()
{    COSDictionary pi = (COSDictionary) actions.getDictionaryObject("PI");    PDAction retval = null;    if (pi != null) {        retval = PDActionFactory.createAction(pi);    }    return retval;}
public void pdfbox_f5781_0(PDAction pi)
{    actions.setItem("PI", pi);}
public COSDictionary pdfbox_f5782_0()
{    return actions;}
public PDAction pdfbox_f5783_0()
{    COSDictionary wc = (COSDictionary) actions.getDictionaryObject("WC");    PDAction retval = null;    if (wc != null) {        retval = PDActionFactory.createAction(wc);    }    return retval;}
public void pdfbox_f5784_0(PDAction wc)
{    actions.setItem("WC", wc);}
public PDAction pdfbox_f5785_0()
{    COSDictionary ws = (COSDictionary) actions.getDictionaryObject("WS");    PDAction retval = null;    if (ws != null) {        retval = PDActionFactory.createAction(ws);    }    return retval;}
public void pdfbox_f5786_0(PDAction ws)
{    actions.setItem("WS", ws);}
public PDAction pdfbox_f5787_0()
{    COSDictionary ds = (COSDictionary) actions.getDictionaryObject("DS");    PDAction retval = null;    if (ds != null) {        retval = PDActionFactory.createAction(ds);    }    return retval;}
public void pdfbox_f5788_0(PDAction ds)
{    actions.setItem("DS", ds);}
public PDAction pdfbox_f5789_0()
{    COSDictionary wp = (COSDictionary) actions.getDictionaryObject("WP");    PDAction retval = null;    if (wp != null) {        retval = PDActionFactory.createAction(wp);    }    return retval;}
public void pdfbox_f5790_0(PDAction wp)
{    actions.setItem("WP", wp);}
public PDAction pdfbox_f5791_0()
{    COSDictionary dp = (COSDictionary) actions.getDictionaryObject("DP");    PDAction retval = null;    if (dp != null) {        retval = PDActionFactory.createAction(dp);    }    return retval;}
public void pdfbox_f5792_0(PDAction dp)
{    actions.setItem("DP", dp);}
public COSDictionary pdfbox_f5793_0()
{    return actions;}
public PDAction pdfbox_f5794_0()
{    COSDictionary k = (COSDictionary) actions.getDictionaryObject(COSName.K);    PDAction retval = null;    if (k != null) {        retval = PDActionFactory.createAction(k);    }    return retval;}
public void pdfbox_f5795_0(PDAction k)
{    actions.setItem(COSName.K, k);}
public PDAction pdfbox_f5796_0()
{    COSDictionary f = (COSDictionary) actions.getDictionaryObject(COSName.F);    PDAction retval = null;    if (f != null) {        retval = PDActionFactory.createAction(f);    }    return retval;}
public void pdfbox_f5797_0(PDAction f)
{    actions.setItem(COSName.F, f);}
public PDAction pdfbox_f5798_0()
{    COSDictionary v = (COSDictionary) actions.getDictionaryObject(COSName.V);    PDAction retval = null;    if (v != null) {        retval = PDActionFactory.createAction(v);    }    return retval;}
public void pdfbox_f5799_0(PDAction v)
{    actions.setItem(COSName.V, v);}
public PDAction pdfbox_f5800_0()
{    COSDictionary c = (COSDictionary) actions.getDictionaryObject(COSName.C);    PDAction retval = null;    if (c != null) {        retval = PDActionFactory.createAction(c);    }    return retval;}
public void pdfbox_f5801_0(PDAction c)
{    actions.setItem(COSName.C, c);}
public COSDictionary pdfbox_f5802_0()
{    return actions;}
public PDAction pdfbox_f5803_0()
{    COSDictionary o = (COSDictionary) actions.getDictionaryObject(COSName.O);    PDAction retval = null;    if (o != null) {        retval = PDActionFactory.createAction(o);    }    return retval;}
public void pdfbox_f5804_0(PDAction o)
{    actions.setItem(COSName.O, o);}
public PDAction pdfbox_f5805_0()
{    COSDictionary c = (COSDictionary) actions.getDictionaryObject("C");    PDAction retval = null;    if (c != null) {        retval = PDActionFactory.createAction(c);    }    return retval;}
public void pdfbox_f5806_0(PDAction c)
{    actions.setItem("C", c);}
public COSDictionary pdfbox_f5807_0()
{    return dict;}
public COSName pdfbox_f5808_0()
{    COSBase base = dict.getItem(COSName.R);    if (base instanceof COSName) {        return (COSName) base;    }    return null;}
public void pdfbox_f5809_0(COSName relationship)
{    if (!COSName.P.equals(relationship) && !COSName.C.equals(relationship)) {        throw new IllegalArgumentException("The only valid are P or C, not " + relationship.getName());    }    dict.setItem(COSName.R, relationship);}
public String pdfbox_f5810_0()
{    return dict.getString(COSName.N);}
public void pdfbox_f5811_0(String filename)
{    dict.setString(COSName.N, filename);}
public PDTargetDirectory pdfbox_f5812_0()
{    COSBase base = dict.getDictionaryObject(COSName.T);    if (base instanceof COSDictionary) {        return new PDTargetDirectory((COSDictionary) base);    }    return null;}
public void pdfbox_f5813_0(PDTargetDirectory targetDirectory)
{    dict.setItem(COSName.T, targetDirectory);}
public int pdfbox_f5814_0()
{    COSBase base = dict.getDictionaryObject(COSName.P);    if (base instanceof COSInteger) {        return ((COSInteger) base).intValue();    }    return -1;}
public void pdfbox_f5815_0(int pageNumber)
{    if (pageNumber < 0) {        dict.removeItem(COSName.P);    } else {        dict.setInt(COSName.P, pageNumber);    }}
public PDNamedDestination pdfbox_f5816_0()
{    COSBase base = dict.getDictionaryObject(COSName.P);    if (base instanceof COSString) {        return new PDNamedDestination((COSString) base);    }    return null;}
public void pdfbox_f5817_0(PDNamedDestination dest)
{    if (dest == null) {        dict.removeItem(COSName.P);    } else {        dict.setItem(COSName.P, dest);    }}
public int pdfbox_f5818_0()
{    COSBase base = dict.getDictionaryObject(COSName.A);    if (base instanceof COSInteger) {        return ((COSInteger) base).intValue();    }    return -1;}
public void pdfbox_f5819_0(int index)
{    if (index < 0) {        dict.removeItem(COSName.A);    } else {        dict.setInt(COSName.A, index);    }}
public String pdfbox_f5820_0()
{    COSBase base = dict.getDictionaryObject(COSName.A);    if (base instanceof COSString) {        return ((COSString) base).getString();    }    return null;}
public void pdfbox_f5821_0(String name)
{    dict.setString(COSName.A, name);}
public COSDictionary pdfbox_f5822_0()
{    return this.uriDictionary;}
public String pdfbox_f5823_0()
{    return this.getCOSObject().getString("Base");}
public void pdfbox_f5824_0(String base)
{    this.getCOSObject().setString("Base", base);}
public COSDictionary pdfbox_f5825_0()
{    return params;}
public String pdfbox_f5826_0()
{    return params.getString(COSName.F);}
public void pdfbox_f5827_0(String file)
{    params.setString(COSName.F, file);}
public String pdfbox_f5828_0()
{    return params.getString(COSName.D);}
public void pdfbox_f5829_0(String dir)
{    params.setString(COSName.D, dir);}
public String pdfbox_f5830_0()
{    return params.getString(COSName.O, OPERATION_OPEN);}
public void pdfbox_f5831_0(String op)
{    params.setString(COSName.D, op);}
public String pdfbox_f5832_0()
{    return params.getString(COSName.P);}
public void pdfbox_f5833_0(String param)
{    params.setString(COSName.P, param);}
 static AnnotationBorder pdfbox_f5834_0(PDAnnotation annotation, PDBorderStyleDictionary borderStyle)
{    AnnotationBorder ab = new AnnotationBorder();    if (borderStyle == null) {        COSArray border = annotation.getBorder();        if (border.size() >= 3 && border.getObject(2) instanceof COSNumber) {            ab.width = ((COSNumber) border.getObject(2)).floatValue();        }        if (border.size() > 3) {            COSBase base3 = border.getObject(3);            if (base3 instanceof COSArray) {                ab.dashArray = ((COSArray) base3).toFloatArray();            }        }    } else {        ab.width = borderStyle.getWidth();        if (borderStyle.getStyle().equals(PDBorderStyleDictionary.STYLE_DASHED)) {            ab.dashArray = borderStyle.getDashStyle().getDashArray();        }        if (borderStyle.getStyle().equals(PDBorderStyleDictionary.STYLE_UNDERLINE)) {            ab.underline = true;        }    }    if (ab.dashArray != null) {        boolean allZero = true;        for (float f : ab.dashArray) {            if (Float.compare(f, 0) != 0) {                allZero = false;                break;            }        }        if (allZero) {            ab.dashArray = null;        }    }    return ab;}
 void pdfbox_f5835_0(PDRectangle rd) throws IOException
{    rectWithDiff = applyRectDiff(rd, lineWidth / 2);    double left = rectWithDiff.getLowerLeftX();    double bottom = rectWithDiff.getLowerLeftY();    double right = rectWithDiff.getUpperRightX();    double top = rectWithDiff.getUpperRightY();    cloudyRectangleImpl(left, bottom, right, top, false);    finish();}
 void pdfbox_f5836_0(float[][] path) throws IOException
{    int n = path.length;    Point2D.Double[] polygon = new Point2D.Double[n];    for (int i = 0; i < n; i++) {        float[] array = path[i];        if (array.length == 2) {            polygon[i] = new Point2D.Double(array[0], array[1]);        } else if (array.length == 6) {                        polygon[i] = new Point2D.Double(array[4], array[5]);        }    }    cloudyPolygonImpl(polygon, false);    finish();}
 void pdfbox_f5837_0(PDRectangle rd) throws IOException
{    rectWithDiff = applyRectDiff(rd, 0);    double left = rectWithDiff.getLowerLeftX();    double bottom = rectWithDiff.getLowerLeftY();    double right = rectWithDiff.getUpperRightX();    double top = rectWithDiff.getUpperRightY();    cloudyEllipseImpl(left, bottom, right, top);    finish();}
 PDRectangle pdfbox_f5838_0()
{    return getRectangle();}
 PDRectangle pdfbox_f5839_0()
{    return new PDRectangle((float) bboxMinX, (float) bboxMinY, (float) (bboxMaxX - bboxMinX), (float) (bboxMaxY - bboxMinY));}
 AffineTransform pdfbox_f5840_0()
{    return AffineTransform.getTranslateInstance(-bboxMinX, -bboxMinY);}
 PDRectangle pdfbox_f5841_0()
{    if (annotRect == null) {        float d = (float) lineWidth / 2;        return new PDRectangle(d, d, (float) lineWidth, (float) lineWidth);    }    PDRectangle re = (rectWithDiff != null) ? rectWithDiff : annotRect;    float left = re.getLowerLeftX() - (float) bboxMinX;    float bottom = re.getLowerLeftY() - (float) bboxMinY;    float right = (float) bboxMaxX - re.getUpperRightX();    float top = (float) bboxMaxY - re.getUpperRightY();    return new PDRectangle(left, bottom, right - left, top - bottom);}
private static double pdfbox_f5842_0(double dx, double hypot)
{    if (Double.compare(hypot, 0.0) == 0) {        return 0;    }    return dx / hypot;}
private static double pdfbox_f5843_0(double dy, double hypot)
{    if (Double.compare(hypot, 0.0) == 0) {        return 0;    }    return dy / hypot;}
private void pdfbox_f5844_0(double left, double bottom, double right, double top, boolean isEllipse) throws IOException
{    double w = right - left;    double h = top - bottom;    if (intensity <= 0.0) {        output.addRect((float) left, (float) bottom, (float) w, (float) h);        bboxMinX = left;        bboxMinY = bottom;        bboxMaxX = right;        bboxMaxY = top;        return;    }        Point2D.Double[] polygon;    if (w < 1.0) {        polygon = new Point2D.Double[] { new Point2D.Double(left, bottom), new Point2D.Double(left, top), new Point2D.Double(left, bottom) };    } else if (h < 1.0) {        polygon = new Point2D.Double[] { new Point2D.Double(left, bottom), new Point2D.Double(right, bottom), new Point2D.Double(left, bottom) };    } else {        polygon = new Point2D.Double[] { new Point2D.Double(left, bottom), new Point2D.Double(right, bottom), new Point2D.Double(right, top), new Point2D.Double(left, top), new Point2D.Double(left, bottom) };    }    cloudyPolygonImpl(polygon, isEllipse);}
private void pdfbox_f5845_0(Point2D.Double[] vertices, boolean isEllipse) throws IOException
{    Point2D.Double[] polygon = removeZeroLengthSegments(vertices);    getPositivePolygon(polygon);    int numPoints = polygon.length;    if (numPoints < 2) {        return;    }    if (intensity <= 0.0) {        moveTo(polygon[0]);        for (int i = 1; i < numPoints; i++) {            lineTo(polygon[i]);        }        return;    }    double cloudRadius = isEllipse ? getEllipseCloudRadius() : getPolygonCloudRadius();    if (cloudRadius < 0.5) {        cloudRadius = 0.5;    }    final double k = Math.cos(ANGLE_34_DEG);    final double advIntermDefault = 2 * k * cloudRadius;    final double advCornerDefault = k * cloudRadius;    double[] array = new double[2];    double anglePrev = 0;                                    int n0 = computeParamsPolygon(advIntermDefault, advCornerDefault, k, cloudRadius, polygon[numPoints - 2].distance(polygon[0]), array);    double alphaPrev = (n0 == 0) ? array[0] : ANGLE_34_DEG;    for (int j = 0; j + 1 < numPoints; j++) {        Point2D.Double pt = polygon[j];        Point2D.Double ptNext = polygon[j + 1];        double length = pt.distance(ptNext);        if (Double.compare(length, 0.0) == 0) {            alphaPrev = ANGLE_34_DEG;            continue;        }                int n = computeParamsPolygon(advIntermDefault, advCornerDefault, k, cloudRadius, length, array);        if (n < 0) {            if (!outputStarted) {                moveTo(pt);            }            continue;        }        double alpha = array[0];        double dx = array[1];        double angleCur = Math.atan2(ptNext.y - pt.y, ptNext.x - pt.x);        if (j == 0) {            Point2D.Double ptPrev = polygon[numPoints - 2];            anglePrev = Math.atan2(pt.y - ptPrev.y, pt.x - ptPrev.x);        }        double cos = cosine(ptNext.x - pt.x, length);        double sin = sine(ptNext.y - pt.y, length);        double x = pt.x;        double y = pt.y;        addCornerCurl(anglePrev, angleCur, cloudRadius, pt.x, pt.y, alpha, alphaPrev, !outputStarted);                double adv = 2 * k * cloudRadius + 2 * dx;        x += adv * cos;        y += adv * sin;                int numInterm = n;        if (n >= 1) {            addFirstIntermediateCurl(angleCur, cloudRadius, alpha, x, y);            x += advIntermDefault * cos;            y += advIntermDefault * sin;            numInterm = n - 1;        }                Point2D.Double[] template = getIntermediateCurlTemplate(angleCur, cloudRadius);        for (int i = 0; i < numInterm; i++) {            outputCurlTemplate(template, x, y);            x += advIntermDefault * cos;            y += advIntermDefault * sin;        }        anglePrev = angleCur;        alphaPrev = (n == 0) ? alpha : ANGLE_34_DEG;    }}
private int pdfbox_f5846_0(double advInterm, double advCorner, double k, double r, double length, double[] array)
{    if (Double.compare(length, 0.0) == 0) {        array[0] = ANGLE_34_DEG;        array[1] = 0;        return -1;    }        int n = (int) Math.ceil((length - 2 * advCorner) / advInterm);        double e = length - (2 * advCorner + n * advInterm);        double dx = e / 2;        double arg = (k * r + dx) / r;    double alpha = (arg < -1.0 || arg > 1.0) ? 0.0 : Math.acos(arg);    array[0] = alpha;    array[1] = dx;    return n;}
private void pdfbox_f5847_0(double anglePrev, double angleCur, double radius, double cx, double cy, double alpha, double alphaPrev, boolean addMoveTo) throws IOException
{    double a = anglePrev + ANGLE_180_DEG + alphaPrev;    double b = anglePrev + ANGLE_180_DEG + alphaPrev - Math.toRadians(22);    getArcSegment(a, b, cx, cy, radius, radius, null, addMoveTo);    a = b;    b = angleCur - alpha;    getArc(a, b, radius, radius, cx, cy, null, false);}
private void pdfbox_f5848_0(double angleCur, double r, double alpha, double cx, double cy) throws IOException
{    double a = angleCur + ANGLE_180_DEG;    getArcSegment(a + alpha, a + alpha - ANGLE_30_DEG, cx, cy, r, r, null, false);    getArcSegment(a + alpha - ANGLE_30_DEG, a + ANGLE_90_DEG, cx, cy, r, r, null, false);    getArcSegment(a + ANGLE_90_DEG, a + ANGLE_180_DEG - ANGLE_34_DEG, cx, cy, r, r, null, false);}
private Point2D.Double[] pdfbox_f5849_0(double angleCur, double r) throws IOException
{    ArrayList<Point2D.Double> points = new ArrayList<>();    double a = angleCur + ANGLE_180_DEG;    getArcSegment(a + ANGLE_34_DEG, a + ANGLE_12_DEG, 0, 0, r, r, points, false);    getArcSegment(a + ANGLE_12_DEG, a + ANGLE_90_DEG, 0, 0, r, r, points, false);    getArcSegment(a + ANGLE_90_DEG, a + ANGLE_180_DEG - ANGLE_34_DEG, 0, 0, r, r, points, false);    return points.toArray(new Point2D.Double[points.size()]);}
private void pdfbox_f5850_0(Point2D.Double[] template, double x, double y) throws IOException
{    int n = template.length;    int i = 0;    if ((n % 3) == 1) {        Point2D.Double a = template[0];        moveTo(a.x + x, a.y + y);        i++;    }    for (; i + 2 < n; i += 3) {        Point2D.Double a = template[i];        Point2D.Double b = template[i + 1];        Point2D.Double c = template[i + 2];        curveTo(a.x + x, a.y + y, b.x + x, b.y + y, c.x + x, c.y + y);    }}
private PDRectangle pdfbox_f5851_0(PDRectangle rd, double min)
{    float rectLeft = annotRect.getLowerLeftX();    float rectBottom = annotRect.getLowerLeftY();    float rectRight = annotRect.getUpperRightX();    float rectTop = annotRect.getUpperRightY();        rectLeft = Math.min(rectLeft, rectRight);    rectBottom = Math.min(rectBottom, rectTop);    rectRight = Math.max(rectLeft, rectRight);    rectTop = Math.max(rectBottom, rectTop);    double rdLeft;    double rdBottom;    double rdRight;    double rdTop;    if (rd != null) {        rdLeft = Math.max(rd.getLowerLeftX(), min);        rdBottom = Math.max(rd.getLowerLeftY(), min);        rdRight = Math.max(rd.getUpperRightX(), min);        rdTop = Math.max(rd.getUpperRightY(), min);    } else {        rdLeft = min;        rdBottom = min;        rdRight = min;        rdTop = min;    }    rectLeft += rdLeft;    rectBottom += rdBottom;    rectRight -= rdRight;    rectTop -= rdTop;    return new PDRectangle(rectLeft, rectBottom, rectRight - rectLeft, rectTop - rectBottom);}
private void pdfbox_f5852_0(Point2D.Double[] points)
{    int len = points.length;    int n = len / 2;    for (int i = 0; i < n; i++) {        int j = len - i - 1;        Point2D.Double pi = points[i];        Point2D.Double pj = points[j];        points[i] = pj;        points[j] = pi;    }}
private void pdfbox_f5853_0(Point2D.Double[] points)
{    if (getPolygonDirection(points) < 0) {        reversePolygon(points);    }}
private double pdfbox_f5854_0(Point2D.Double[] points)
{    double a = 0;    int len = points.length;    for (int i = 0; i < len; i++) {        int j = (i + 1) % len;        a += points[i].x * points[j].y - points[i].y * points[j].x;    }    return a;}
private void pdfbox_f5855_0(double startAng, double endAng, double rx, double ry, double cx, double cy, ArrayList<Point2D.Double> out, boolean addMoveTo) throws IOException
{    final double angleIncr = Math.PI / 2;    double startx = rx * Math.cos(startAng) + cx;    double starty = ry * Math.sin(startAng) + cy;    double angleTodo = endAng - startAng;    while (angleTodo < 0) {        angleTodo += 2 * Math.PI;    }    double sweep = angleTodo;    double angleDone = 0;    if (addMoveTo) {        if (out != null) {            out.add(new Point2D.Double(startx, starty));        } else {            moveTo(startx, starty);        }    }    while (angleTodo > angleIncr) {        getArcSegment(startAng + angleDone, startAng + angleDone + angleIncr, cx, cy, rx, ry, out, false);        angleDone += angleIncr;        angleTodo -= angleIncr;    }    if (angleTodo > 0) {        getArcSegment(startAng + angleDone, startAng + sweep, cx, cy, rx, ry, out, false);    }}
private void pdfbox_f5856_0(double startAng, double endAng, double cx, double cy, double rx, double ry, ArrayList<Point2D.Double> out, boolean addMoveTo) throws IOException
{        double cosA = Math.cos(startAng);    double sinA = Math.sin(startAng);    double cosB = Math.cos(endAng);    double sinB = Math.sin(endAng);    double denom = Math.sin((endAng - startAng) / 2.0);    if (Double.compare(denom, 0.0) == 0) {                if (addMoveTo) {            double xs = cx + rx * cosA;            double ys = cy + ry * sinA;            if (out != null) {                out.add(new Point2D.Double(xs, ys));            } else {                moveTo(xs, ys);            }        }        return;    }    double bcp = 1.333333333 * (1 - Math.cos((endAng - startAng) / 2.0)) / denom;    double p1x = cx + rx * (cosA - bcp * sinA);    double p1y = cy + ry * (sinA + bcp * cosA);    double p2x = cx + rx * (cosB + bcp * sinB);    double p2y = cy + ry * (sinB - bcp * cosB);    double p3x = cx + rx * cosB;    double p3y = cy + ry * sinB;    if (addMoveTo) {        double xs = cx + rx * cosA;        double ys = cy + ry * sinA;        if (out != null) {            out.add(new Point2D.Double(xs, ys));        } else {            moveTo(xs, ys);        }    }    if (out != null) {        out.add(new Point2D.Double(p1x, p1y));        out.add(new Point2D.Double(p2x, p2y));        out.add(new Point2D.Double(p3x, p3y));    } else {        curveTo(p1x, p1y, p2x, p2y, p3x, p3y);    }}
private static Point2D.Double[] pdfbox_f5857_0(double left, double bottom, double right, double top)
{    Ellipse2D.Double ellipse = new Ellipse2D.Double(left, bottom, right - left, top - bottom);    final double flatness = 0.50;    PathIterator iterator = ellipse.getPathIterator(null, flatness);    double[] coords = new double[6];    ArrayList<Point2D.Double> points = new ArrayList<>();    while (!iterator.isDone()) {        switch(iterator.currentSegment(coords)) {            case PathIterator.SEG_MOVETO:            case PathIterator.SEG_LINETO:                points.add(new Point2D.Double(coords[0], coords[1]));                break;                        default:                break;        }        iterator.next();    }    int size = points.size();    final double closeTestLimit = 0.05;    if (size >= 2 && points.get(size - 1).distance(points.get(0)) > closeTestLimit) {        points.add(points.get(points.size() - 1));    }    return points.toArray(new Point2D.Double[points.size()]);}
private void pdfbox_f5858_0(final double leftOrig, final double bottomOrig, final double rightOrig, final double topOrig) throws IOException
{    if (intensity <= 0.0) {        drawBasicEllipse(leftOrig, bottomOrig, rightOrig, topOrig);        return;    }    double left = leftOrig;    double bottom = bottomOrig;    double right = rightOrig;    double top = topOrig;    double width = right - left;    double height = top - bottom;    double cloudRadius = getEllipseCloudRadius();        final double threshold1 = 0.50 * cloudRadius;    if (width < threshold1 && height < threshold1) {        drawBasicEllipse(left, bottom, right, top);        return;    }            final double threshold2 = 5;    if ((width < threshold2 && height > 20) || (width > 20 && height < threshold2)) {        cloudyRectangleImpl(left, bottom, right, top, true);        return;    }            double radiusAdj = Math.sin(ANGLE_12_DEG) * cloudRadius - 1.50;    if (width > 2 * radiusAdj) {        left += radiusAdj;        right -= radiusAdj;    } else {        double mid = (left + right) / 2;        left = mid - 0.10;        right = mid + 0.10;    }    if (height > 2 * radiusAdj) {        top -= radiusAdj;        bottom += radiusAdj;    } else {        double mid = (top + bottom) / 2;        top = mid + 0.10;        bottom = mid - 0.10;    }                    Point2D.Double[] flatPolygon = flattenEllipse(left, bottom, right, top);    int numPoints = flatPolygon.length;    if (numPoints < 2) {        return;    }    double totLen = 0;    for (int i = 1; i < numPoints; i++) {        totLen += flatPolygon[i - 1].distance(flatPolygon[i]);    }    final double k = Math.cos(ANGLE_34_DEG);    double curlAdvance = 2 * k * cloudRadius;    int n = (int) Math.ceil(totLen / curlAdvance);    if (n < 2) {        drawBasicEllipse(leftOrig, bottomOrig, rightOrig, topOrig);        return;    }    curlAdvance = totLen / n;    cloudRadius = curlAdvance / (2 * k);    if (cloudRadius < 0.5) {        cloudRadius = 0.5;        curlAdvance = 2 * k * cloudRadius;    } else if (cloudRadius < 3.0) {                        drawBasicEllipse(leftOrig, bottomOrig, rightOrig, topOrig);        return;    }                int centerPointsLength = n;    Point2D.Double[] centerPoints = new Point2D.Double[centerPointsLength];    int centerPointsIndex = 0;    double lengthRemain = 0;    final double comparisonToler = lineWidth * 0.10;    for (int i = 0; i + 1 < numPoints; i++) {        Point2D.Double p1 = flatPolygon[i];        Point2D.Double p2 = flatPolygon[i + 1];        double dx = p2.x - p1.x;        double dy = p2.y - p1.y;        double length = p1.distance(p2);        if (Double.compare(length, 0.0) == 0) {            continue;        }        double lengthTodo = length + lengthRemain;        if (lengthTodo >= curlAdvance - comparisonToler || i == numPoints - 2) {            double cos = cosine(dx, length);            double sin = sine(dy, length);            double d = curlAdvance - lengthRemain;            do {                double x = p1.x + d * cos;                double y = p1.y + d * sin;                if (centerPointsIndex < centerPointsLength) {                    centerPoints[centerPointsIndex++] = new Point2D.Double(x, y);                }                lengthTodo -= curlAdvance;                d += curlAdvance;            } while (lengthTodo >= curlAdvance - comparisonToler);            lengthRemain = lengthTodo;            if (lengthRemain < 0) {                lengthRemain = 0;            }        } else {            lengthRemain += length;        }    }                            numPoints = centerPointsIndex;    double anglePrev = 0;    double alphaPrev = 0;    for (int i = 0; i < numPoints; i++) {        int idxNext = i + 1;        if (i + 1 >= numPoints) {            idxNext = 0;        }        Point2D.Double pt = centerPoints[i];        Point2D.Double ptNext = centerPoints[idxNext];        if (i == 0) {            Point2D.Double ptPrev = centerPoints[numPoints - 1];            anglePrev = Math.atan2(pt.y - ptPrev.y, pt.x - ptPrev.x);            alphaPrev = computeParamsEllipse(ptPrev, pt, cloudRadius, curlAdvance);        }        double angleCur = Math.atan2(ptNext.y - pt.y, ptNext.x - pt.x);        double alpha = computeParamsEllipse(pt, ptNext, cloudRadius, curlAdvance);        addCornerCurl(anglePrev, angleCur, cloudRadius, pt.x, pt.y, alpha, alphaPrev, !outputStarted);        anglePrev = angleCur;        alphaPrev = alpha;    }}
private double pdfbox_f5859_0(Point2D.Double pt, Point2D.Double ptNext, double r, double curlAdv)
{    double length = pt.distance(ptNext);    if (Double.compare(length, 0.0) == 0) {        return ANGLE_34_DEG;    }    double e = length - curlAdv;    double arg = (curlAdv / 2 + e / 2) / r;    return (arg < -1.0 || arg > 1.0) ? 0.0 : Math.acos(arg);}
private Point2D.Double[] pdfbox_f5860_0(Point2D.Double[] polygon)
{    int np = polygon.length;    if (np <= 2) {        return polygon;    }    final double toler = 0.50;    int npNew = np;    Point2D.Double ptPrev = polygon[0];        for (int i = 1; i < np; i++) {        Point2D.Double pt = polygon[i];        if (Math.abs(pt.x - ptPrev.x) < toler && Math.abs(pt.y - ptPrev.y) < toler) {            polygon[i] = null;            npNew--;        }        ptPrev = pt;    }    if (npNew == np) {        return polygon;    }    Point2D.Double[] polygonNew = new Point2D.Double[npNew];    int j = 0;    for (int i = 0; i < np; i++) {        Point2D.Double pt = polygon[i];        if (pt != null) {            polygonNew[j++] = pt;        }    }    return polygonNew;}
private void pdfbox_f5861_0(double left, double bottom, double right, double top) throws IOException
{    double rx = Math.abs(right - left) / 2;    double ry = Math.abs(top - bottom) / 2;    double cx = (left + right) / 2;    double cy = (bottom + top) / 2;    getArc(0, 2 * Math.PI, rx, ry, cx, cy, null, true);}
private void pdfbox_f5862_0(double x, double y) throws IOException
{    bboxMinX = x;    bboxMinY = y;    bboxMaxX = x;    bboxMaxY = y;    outputStarted = true;        output.setLineJoinStyle(2);}
private void pdfbox_f5863_0(double x, double y)
{    bboxMinX = Math.min(bboxMinX, x);    bboxMinY = Math.min(bboxMinY, y);    bboxMaxX = Math.max(bboxMaxX, x);    bboxMaxY = Math.max(bboxMaxY, y);}
private void pdfbox_f5864_0(Point2D.Double p) throws IOException
{    moveTo(p.x, p.y);}
private void pdfbox_f5865_0(double x, double y) throws IOException
{    if (outputStarted) {        updateBBox(x, y);    } else {        beginOutput(x, y);    }    output.moveTo((float) x, (float) y);}
private void pdfbox_f5866_0(Point2D.Double p) throws IOException
{    lineTo(p.x, p.y);}
private void pdfbox_f5867_0(double x, double y) throws IOException
{    if (outputStarted) {        updateBBox(x, y);    } else {        beginOutput(x, y);    }    output.lineTo((float) x, (float) y);}
private void pdfbox_f5868_0(double ax, double ay, double bx, double by, double cx, double cy) throws IOException
{    updateBBox(ax, ay);    updateBBox(bx, by);    updateBBox(cx, cy);    output.curveTo((float) ax, (float) ay, (float) bx, (float) by, (float) cx, (float) cy);}
private void pdfbox_f5869_0() throws IOException
{    if (outputStarted) {        output.closePath();    }    if (lineWidth > 0) {        double d = lineWidth / 2;        bboxMinX -= d;        bboxMinY -= d;        bboxMaxX += d;        bboxMaxY += d;    }}
private double pdfbox_f5870_0()
{        return 4.75 * intensity + 0.5 * lineWidth;}
private double pdfbox_f5871_0()
{        return 4 * intensity + 0.5 * lineWidth;}
 PDAnnotation pdfbox_f5872_0()
{    return annotation;}
 PDColor pdfbox_f5873_0()
{    return annotation.getColor();}
 PDRectangle pdfbox_f5874_0()
{    return annotation.getRectangle();}
protected COSStream pdfbox_f5875_0()
{    return document == null ? new COSStream() : document.getDocument().createCOSStream();}
 PDAppearanceDictionary pdfbox_f5876_0()
{    PDAppearanceDictionary appearanceDictionary = annotation.getAppearance();    if (appearanceDictionary == null) {        appearanceDictionary = new PDAppearanceDictionary();        annotation.setAppearance(appearanceDictionary);    }    return appearanceDictionary;}
 PDAppearanceContentStream pdfbox_f5877_0() throws IOException
{    return getNormalAppearanceAsContentStream(false);}
 PDAppearanceContentStream pdfbox_f5878_0(boolean compress) throws IOException
{    PDAppearanceEntry appearanceEntry = getNormalAppearance();    return getAppearanceEntryAsContentStream(appearanceEntry, compress);}
 PDAppearanceEntry pdfbox_f5879_0()
{    PDAppearanceDictionary appearanceDictionary = getAppearance();    PDAppearanceEntry downAppearanceEntry = appearanceDictionary.getDownAppearance();    if (downAppearanceEntry.isSubDictionary()) {        downAppearanceEntry = new PDAppearanceEntry(createCOSStream());        appearanceDictionary.setDownAppearance(downAppearanceEntry);    }    return downAppearanceEntry;}
 PDAppearanceEntry pdfbox_f5880_0()
{    PDAppearanceDictionary appearanceDictionary = getAppearance();    PDAppearanceEntry rolloverAppearanceEntry = appearanceDictionary.getRolloverAppearance();    if (rolloverAppearanceEntry.isSubDictionary()) {        rolloverAppearanceEntry = new PDAppearanceEntry(createCOSStream());        appearanceDictionary.setRolloverAppearance(rolloverAppearanceEntry);    }    return rolloverAppearanceEntry;}
 PDRectangle pdfbox_f5881_0(PDRectangle rectangle, float padding)
{    return new PDRectangle(rectangle.getLowerLeftX() + padding, rectangle.getLowerLeftY() + padding, rectangle.getWidth() - 2 * padding, rectangle.getHeight() - 2 * padding);}
 PDRectangle pdfbox_f5882_0(PDRectangle rectangle, float[] differences)
{    if (differences == null || differences.length != 4) {        return rectangle;    }    return new PDRectangle(rectangle.getLowerLeftX() - differences[0], rectangle.getLowerLeftY() - differences[1], rectangle.getWidth() + differences[0] + differences[2], rectangle.getHeight() + differences[1] + differences[3]);}
 PDRectangle pdfbox_f5883_0(PDRectangle rectangle, float[] differences)
{    if (differences == null || differences.length != 4) {        return rectangle;    }    return new PDRectangle(rectangle.getLowerLeftX() + differences[0], rectangle.getLowerLeftY() + differences[1], rectangle.getWidth() - differences[0] - differences[2], rectangle.getHeight() - differences[1] - differences[3]);}
 void pdfbox_f5884_0(PDAppearanceContentStream contentStream, float opacity) throws IOException
{    if (opacity < 1) {        PDExtendedGraphicsState gs = new PDExtendedGraphicsState();        gs.setStrokingAlphaConstant(opacity);        gs.setNonStrokingAlphaConstant(opacity);        contentStream.setGraphicsStateParameters(gs);    }}
 void pdfbox_f5885_0(String style, final PDAppearanceContentStream cs, float x, float y, float width, boolean hasStroke, boolean hasBackground, boolean ending) throws IOException
{    int sign = ending ? -1 : 1;    switch(style) {        case PDAnnotationLine.LE_OPEN_ARROW:        case PDAnnotationLine.LE_CLOSED_ARROW:            drawArrow(cs, x + sign * width, y, sign * width * 9);            break;        case PDAnnotationLine.LE_BUTT:            cs.moveTo(x, y - width * 3);            cs.lineTo(x, y + width * 3);            break;        case PDAnnotationLine.LE_DIAMOND:            drawDiamond(cs, x, y, width * 3);            break;        case PDAnnotationLine.LE_SQUARE:            cs.addRect(x - width * 3, y - width * 3, width * 6, width * 6);            break;        case PDAnnotationLine.LE_CIRCLE:            drawCircle(cs, x, y, width * 3);            break;        case PDAnnotationLine.LE_R_OPEN_ARROW:        case PDAnnotationLine.LE_R_CLOSED_ARROW:            drawArrow(cs, x + (0 - sign) * width, y, (0 - sign) * width * 9);            break;        case PDAnnotationLine.LE_SLASH:                        cs.moveTo(x + (float) (Math.cos(Math.toRadians(60)) * width * 9), y + (float) (Math.sin(Math.toRadians(60)) * width * 9));            cs.lineTo(x + (float) (Math.cos(Math.toRadians(240)) * width * 9), y + (float) (Math.sin(Math.toRadians(240)) * width * 9));            break;        default:            return;    }    if (PDAnnotationLine.LE_R_CLOSED_ARROW.equals(style) || PDAnnotationLine.LE_CLOSED_ARROW.equals(style)) {        cs.closePath();    }    cs.drawShape(width, hasStroke,     INTERIOR_COLOR_STYLES.contains(style) ? hasBackground : false);}
 void pdfbox_f5886_0(PDAppearanceContentStream cs, float x, float y, float len) throws IOException
{                    cs.moveTo(x + (float) (Math.cos(ARROW_ANGLE) * len), y + (float) (Math.sin(ARROW_ANGLE) * len));    cs.lineTo(x, y);    cs.lineTo(x + (float) (Math.cos(ARROW_ANGLE) * len), y - (float) (Math.sin(ARROW_ANGLE) * len));}
 void pdfbox_f5887_0(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{    cs.moveTo(x - r, y);    cs.lineTo(x, y + r);    cs.lineTo(x + r, y);    cs.lineTo(x, y - r);    cs.closePath();}
 void pdfbox_f5888_0(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{        float magic = r * 0.551784f;    cs.moveTo(x, y + r);    cs.curveTo(x + magic, y + r, x + r, y + magic, x + r, y);    cs.curveTo(x + r, y - magic, x + magic, y - r, x, y - r);    cs.curveTo(x - magic, y - r, x - r, y - magic, x - r, y);    cs.curveTo(x - r, y + magic, x - magic, y + r, x, y + r);    cs.closePath();}
 void pdfbox_f5889_0(PDAppearanceContentStream cs, float x, float y, float r) throws IOException
{        float magic = r * 0.551784f;    cs.moveTo(x, y + r);    cs.curveTo(x - magic, y + r, x - r, y + magic, x - r, y);    cs.curveTo(x - r, y - magic, x - magic, y - r, x, y - r);    cs.curveTo(x + magic, y - r, x + r, y - magic, x + r, y);    cs.curveTo(x + r, y + magic, x + magic, y + r, x, y + r);    cs.closePath();}
private static Set<String> pdfbox_f5890_0()
{    Set<String> shortStyles = new HashSet<>();    shortStyles.add(PDAnnotationLine.LE_OPEN_ARROW);    shortStyles.add(PDAnnotationLine.LE_CLOSED_ARROW);    shortStyles.add(PDAnnotationLine.LE_SQUARE);    shortStyles.add(PDAnnotationLine.LE_CIRCLE);    shortStyles.add(PDAnnotationLine.LE_DIAMOND);    return Collections.unmodifiableSet(shortStyles);}
private static Set<String> pdfbox_f5891_0()
{    Set<String> interiorColorStyles = new HashSet<>();    interiorColorStyles.add(PDAnnotationLine.LE_CLOSED_ARROW);    interiorColorStyles.add(PDAnnotationLine.LE_CIRCLE);    interiorColorStyles.add(PDAnnotationLine.LE_DIAMOND);    interiorColorStyles.add(PDAnnotationLine.LE_R_CLOSED_ARROW);    interiorColorStyles.add(PDAnnotationLine.LE_SQUARE);    return Collections.unmodifiableSet(interiorColorStyles);}
private static Set<String> pdfbox_f5892_0()
{    Set<String> angledStyles = new HashSet<>();    angledStyles.add(PDAnnotationLine.LE_CLOSED_ARROW);    angledStyles.add(PDAnnotationLine.LE_OPEN_ARROW);    angledStyles.add(PDAnnotationLine.LE_R_CLOSED_ARROW);    angledStyles.add(PDAnnotationLine.LE_R_OPEN_ARROW);    angledStyles.add(PDAnnotationLine.LE_BUTT);    angledStyles.add(PDAnnotationLine.LE_SLASH);    return Collections.unmodifiableSet(angledStyles);}
private PDAppearanceEntry pdfbox_f5893_0()
{    PDAppearanceDictionary appearanceDictionary = getAppearance();    PDAppearanceEntry normalAppearanceEntry = appearanceDictionary.getNormalAppearance();    if (normalAppearanceEntry == null || normalAppearanceEntry.isSubDictionary()) {        normalAppearanceEntry = new PDAppearanceEntry(createCOSStream());        appearanceDictionary.setNormalAppearance(normalAppearanceEntry);    }    return normalAppearanceEntry;}
private PDAppearanceContentStream pdfbox_f5894_0(PDAppearanceEntry appearanceEntry, boolean compress) throws IOException
{    PDAppearanceStream appearanceStream = appearanceEntry.getAppearanceStream();    setTransformationMatrix(appearanceStream);        PDResources resources = appearanceStream.getResources();    if (resources == null) {        resources = new PDResources();        appearanceStream.setResources(resources);    }    return new PDAppearanceContentStream(appearanceStream, compress);}
private void pdfbox_f5895_0(PDAppearanceStream appearanceStream)
{    PDRectangle bbox = getRectangle();    appearanceStream.setBBox(bbox);    AffineTransform transform = AffineTransform.getTranslateInstance(-bbox.getLowerLeftX(), -bbox.getLowerLeftY());    appearanceStream.setMatrix(transform);}
 PDRectangle pdfbox_f5896_0(PDAnnotationSquareCircle annotation, float lineWidth)
{                            PDRectangle borderBox;    float[] rectDifferences = annotation.getRectDifferences();    if (rectDifferences.length == 0) {        borderBox = getPaddedRectangle(getRectangle(), lineWidth / 2);                annotation.setRectDifferences(lineWidth / 2);        annotation.setRectangle(addRectDifferences(getRectangle(), annotation.getRectDifferences()));                        annotation.getNormalAppearanceStream().setBBox(getRectangle());        AffineTransform transform = AffineTransform.getTranslateInstance(-getRectangle().getLowerLeftX(), -getRectangle().getLowerLeftY());        annotation.getNormalAppearanceStream().setMatrix(transform);    } else {        borderBox = applyRectDifferences(getRectangle(), rectDifferences);        borderBox = getPaddedRectangle(borderBox, lineWidth / 2);    }    return borderBox;}
public void pdfbox_f5897_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5898_1()
{    PDAnnotationCaret annotation = (PDAnnotationCaret) getAnnotation();    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        contentStream.setStrokingColor(getColor());        contentStream.setNonStrokingColor(getColor());        setOpacity(contentStream, annotation.getConstantOpacity());        PDRectangle rect = getRectangle();        PDRectangle bbox = new PDRectangle(rect.getWidth(), rect.getHeight());        if (!annotation.getCOSObject().containsKey(COSName.RD)) {                                                                                    float rd = Math.min(rect.getHeight() / 10, 5);            annotation.setRectDifferences(rd);            bbox = new PDRectangle(-rd, -rd, rect.getWidth() + 2 * rd, rect.getHeight() + 2 * rd);            Matrix matrix = annotation.getNormalAppearanceStream().getMatrix();            matrix.transformPoint(rd, rd);            annotation.getNormalAppearanceStream().setMatrix(matrix.createAffineTransform());            PDRectangle rect2 = new PDRectangle(rect.getLowerLeftX() - rd, rect.getLowerLeftY() - rd, rect.getWidth() + 2 * rd, rect.getHeight() + 2 * rd);            annotation.setRectangle(rect2);        }        annotation.getNormalAppearanceStream().setBBox(bbox);        float halfX = rect.getWidth() / 2;        float halfY = rect.getHeight() / 2;        contentStream.moveTo(0, 0);        contentStream.curveTo(halfX, 0, halfX, halfY, halfX, rect.getHeight());        contentStream.curveTo(halfX, halfY, halfX, 0, rect.getWidth(), 0);        contentStream.closePath();        contentStream.fill();            } catch (IOException e) {            }}
public void pdfbox_f5899_0()
{}
public void pdfbox_f5900_0()
{}
public void pdfbox_f5901_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5902_1()
{    float lineWidth = getLineWidth();    PDAnnotationCircle annotation = (PDAnnotationCircle) getAnnotation();    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(contentStream, annotation.getConstantOpacity());        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());            cloudyBorder.createCloudyEllipse(annotation.getRectDifference());            annotation.setRectangle(cloudyBorder.getRectangle());            annotation.setRectDifference(cloudyBorder.getRectDifference());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {                                    PDRectangle borderBox = handleBorderBox(annotation, lineWidth);                        float x0 = borderBox.getLowerLeftX();            float y0 = borderBox.getLowerLeftY();                        float x1 = borderBox.getUpperRightX();            float y1 = borderBox.getUpperRightY();                        float xm = x0 + borderBox.getWidth() / 2;            float ym = y0 + borderBox.getHeight() / 2;                                                float magic = 0.55555417f;                        float vOffset = borderBox.getHeight() / 2 * magic;            float hOffset = borderBox.getWidth() / 2 * magic;            contentStream.moveTo(xm, y1);            contentStream.curveTo((xm + hOffset), y1, x1, (ym + vOffset), x1, ym);            contentStream.curveTo(x1, (ym - vOffset), (xm + hOffset), y0, xm, y0);            contentStream.curveTo((xm - hOffset), y0, x0, (ym - vOffset), x0, ym);            contentStream.curveTo(x0, (ym + vOffset), (xm - hOffset), y1, xm, y1);            contentStream.closePath();        }        contentStream.drawShape(lineWidth, hasStroke, hasBackground);    } catch (IOException e) {            }}
public void pdfbox_f5903_0()
{}
public void pdfbox_f5904_0()
{}
 float pdfbox_f5905_0()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
public void pdfbox_f5906_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5907_1()
{    PDAnnotationFreeText annotation = (PDAnnotationFreeText) getAnnotation();    float[] pathsArray = new float[0];    if (PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent())) {        pathsArray = annotation.getCallout();        if (pathsArray == null || pathsArray.length != 4 && pathsArray.length != 6) {            pathsArray = new float[0];        }    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream(true)) {                boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getColor());        setOpacity(cs, annotation.getConstantOpacity());                        PDColor strokingColor = extractNonStrokingColor(annotation);        boolean hasStroke = cs.setStrokingColorOnDemand(strokingColor);        PDColor textColor = strokingColor;        String defaultStyleString = annotation.getDefaultStyleString();        if (defaultStyleString != null) {            Matcher m = COLOR_PATTERN.matcher(defaultStyleString);            if (m.find()) {                int color = Integer.parseInt(m.group(1), 16);                float r = ((color >> 16) & 0xFF) / 255f;                float g = ((color >> 8) & 0xFF) / 255f;                float b = (color & 0xFF) / 255f;                textColor = new PDColor(new float[] { r, g, b }, PDDeviceRGB.INSTANCE);            }        }        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);                for (int i = 0; i < pathsArray.length / 2; ++i) {            float x = pathsArray[i * 2];            float y = pathsArray[i * 2 + 1];            if (i == 0) {                if (SHORT_STYLES.contains(annotation.getLineEndingStyle())) {                                                            float x1 = pathsArray[2];                    float y1 = pathsArray[3];                    float len = (float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2)));                    if (Float.compare(len, 0) != 0) {                        x += (x1 - x) / len * ab.width;                        y += (y1 - y) / len * ab.width;                    }                }                cs.moveTo(x, y);            } else {                cs.lineTo(x, y);            }        }        if (pathsArray.length > 0) {            cs.stroke();        }                if (PDAnnotationFreeText.IT_FREE_TEXT_CALLOUT.equals(annotation.getIntent()) &&         !LE_NONE.equals(annotation.getLineEndingStyle()) && pathsArray.length >= 4) {            float x2 = pathsArray[2];            float y2 = pathsArray[3];            float x1 = pathsArray[0];            float y1 = pathsArray[1];            cs.saveGraphicsState();            if (ANGLED_STYLES.contains(annotation.getLineEndingStyle())) {                                                                                                double angle = Math.atan2(y2 - y1, x2 - x1);                cs.transform(Matrix.getRotateInstance(angle, x1, y1));            } else {                cs.transform(Matrix.getTranslateInstance(x1, y1));            }            drawStyle(annotation.getLineEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, false);            cs.restoreGraphicsState();        }        PDRectangle borderBox;        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {                                                borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());                        CloudyBorder cloudyBorder = new CloudyBorder(cs, borderEffect.getIntensity(), ab.width, getRectangle());            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());            annotation.setRectangle(cloudyBorder.getRectangle());            annotation.setRectDifference(cloudyBorder.getRectDifference());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {                                                                                                borderBox = applyRectDifferences(getRectangle(), annotation.getRectDifferences());            annotation.getNormalAppearanceStream().setBBox(borderBox);                        PDRectangle paddedRectangle = getPaddedRectangle(borderBox, ab.width / 2);            cs.addRect(paddedRectangle.getLowerLeftX(), paddedRectangle.getLowerLeftY(), paddedRectangle.getWidth(), paddedRectangle.getHeight());        }        cs.drawShape(ab.width, hasStroke, hasBackground);                        int rotation = annotation.getCOSObject().getInt(COSName.ROTATE, 0);        cs.transform(Matrix.getRotateInstance(Math.toRadians(rotation), 0, 0));        float xOffset;        float yOffset;        float width = rotation == 90 || rotation == 270 ? borderBox.getHeight() : borderBox.getWidth();                        PDFont font = PDType1Font.HELVETICA;        float clipY;        float clipWidth = width - ab.width * 4;        float clipHeight = rotation == 90 || rotation == 270 ? borderBox.getWidth() - ab.width * 4 : borderBox.getHeight() - ab.width * 4;        extractFontDetails(annotation);        if (document != null && document.getDocumentCatalog().getAcroForm() != null) {                                    PDResources defaultResources = document.getDocumentCatalog().getAcroForm().getDefaultResources();            if (defaultResources != null) {                PDFont defaultResourcesFont = defaultResources.getFont(fontName);                if (defaultResourcesFont != null) {                    font = defaultResourcesFont;                }            }        }                        float yDelta = 0.7896f;        switch(rotation) {            case 180:                xOffset = -borderBox.getUpperRightX() + ab.width * 2;                yOffset = -borderBox.getLowerLeftY() - ab.width * 2 - yDelta * fontSize;                clipY = -borderBox.getUpperRightY() + ab.width * 2;                break;            case 90:                xOffset = borderBox.getLowerLeftY() + ab.width * 2;                yOffset = -borderBox.getLowerLeftX() - ab.width * 2 - yDelta * fontSize;                clipY = -borderBox.getUpperRightX() + ab.width * 2;                break;            case 270:                xOffset = -borderBox.getUpperRightY() + ab.width * 2;                yOffset = borderBox.getUpperRightX() - ab.width * 2 - yDelta * fontSize;                clipY = borderBox.getLowerLeftX() + ab.width * 2;                break;            case 0:            default:                xOffset = borderBox.getLowerLeftX() + ab.width * 2;                yOffset = borderBox.getUpperRightY() - ab.width * 2 - yDelta * fontSize;                clipY = borderBox.getLowerLeftY() + ab.width * 2;                break;        }                cs.addRect(xOffset, clipY, clipWidth, clipHeight);        cs.clip();        cs.beginText();        cs.setFont(font, fontSize);        cs.setNonStrokingColor(textColor.getComponents());        AppearanceStyle appearanceStyle = new AppearanceStyle();        appearanceStyle.setFont(font);        appearanceStyle.setFontSize(fontSize);        PlainTextFormatter formatter = new PlainTextFormatter.Builder(cs).style(appearanceStyle).text(new PlainText(annotation.getContents())).width(width - ab.width * 4).wrapLines(true).initialOffset(xOffset, yOffset).build();        try {            formatter.format();        } catch (IllegalArgumentException ex) {            throw new IOException(ex);        }        cs.endText();        if (pathsArray.length > 0) {            PDRectangle rect = getRectangle();                                                                        float minX = Float.MAX_VALUE;            float minY = Float.MAX_VALUE;            float maxX = Float.MIN_VALUE;            float maxY = Float.MIN_VALUE;            for (int i = 0; i < pathsArray.length / 2; ++i) {                float x = pathsArray[i * 2];                float y = pathsArray[i * 2 + 1];                minX = Math.min(minX, x);                minY = Math.min(minY, y);                maxX = Math.max(maxX, x);                maxY = Math.max(maxY, y);            }                        rect.setLowerLeftX(Math.min(minX - ab.width * 10, rect.getLowerLeftX()));            rect.setLowerLeftY(Math.min(minY - ab.width * 10, rect.getLowerLeftY()));            rect.setUpperRightX(Math.max(maxX + ab.width * 10, rect.getUpperRightX()));            rect.setUpperRightY(Math.max(maxY + ab.width * 10, rect.getUpperRightY()));            annotation.setRectangle(rect);                        annotation.getNormalAppearanceStream().setBBox(getRectangle());                }    } catch (IOException ex) {            }}
private PDColor pdfbox_f5908_1(PDAnnotationFreeText annotation)
{                    PDColor strokingColor = new PDColor(new float[] { 0 }, PDDeviceGray.INSTANCE);    String defaultAppearance = annotation.getDefaultAppearance();    if (defaultAppearance == null) {        return strokingColor;    }    try {                PDFStreamParser parser = new PDFStreamParser(defaultAppearance.getBytes(Charsets.US_ASCII));        COSArray arguments = new COSArray();        COSArray colors = null;        Operator graphicOp = null;        for (Object token = parser.parseNextToken(); token != null; token = parser.parseNextToken()) {            if (token instanceof COSObject) {                arguments.add(((COSObject) token).getObject());            } else if (token instanceof Operator) {                Operator op = (Operator) token;                String name = op.getName();                if (OperatorName.NON_STROKING_GRAY.equals(name) || OperatorName.NON_STROKING_RGB.equals(name) || OperatorName.NON_STROKING_CMYK.equals(name)) {                    graphicOp = op;                    colors = arguments;                }                arguments = new COSArray();            } else {                arguments.add((COSBase) token);            }        }        if (graphicOp != null) {            switch(graphicOp.getName()) {                case OperatorName.NON_STROKING_GRAY:                    strokingColor = new PDColor(colors, PDDeviceGray.INSTANCE);                    break;                case OperatorName.NON_STROKING_RGB:                    strokingColor = new PDColor(colors, PDDeviceRGB.INSTANCE);                    break;                case OperatorName.NON_STROKING_CMYK:                    strokingColor = new PDColor(colors, PDDeviceCMYK.INSTANCE);                    break;                default:                    break;            }        }    } catch (IOException ex) {            }    return strokingColor;}
private void pdfbox_f5909_1(PDAnnotationFreeText annotation)
{    String defaultAppearance = annotation.getDefaultAppearance();    if (defaultAppearance == null && document != null && document.getDocumentCatalog().getAcroForm() != null) {        defaultAppearance = document.getDocumentCatalog().getAcroForm().getDefaultAppearance();    }    if (defaultAppearance == null) {        return;    }    try {                PDFStreamParser parser = new PDFStreamParser(defaultAppearance.getBytes(Charsets.US_ASCII));        COSArray arguments = new COSArray();        COSArray fontArguments = new COSArray();        for (Object token = parser.parseNextToken(); token != null; token = parser.parseNextToken()) {            if (token instanceof COSObject) {                arguments.add(((COSObject) token).getObject());            } else if (token instanceof Operator) {                Operator op = (Operator) token;                String name = op.getName();                if (OperatorName.SET_FONT_AND_SIZE.equals(name)) {                    fontArguments = arguments;                }                arguments = new COSArray();            } else {                arguments.add((COSBase) token);            }        }        if (fontArguments.size() >= 2) {            COSBase base = fontArguments.get(0);            if (base instanceof COSName) {                fontName = (COSName) base;            }            base = fontArguments.get(1);            if (base instanceof COSNumber) {                fontSize = ((COSNumber) base).floatValue();            }        }    } catch (IOException ex) {            }}
public void pdfbox_f5910_0()
{}
public void pdfbox_f5911_0()
{}
public void pdfbox_f5912_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5913_1()
{    PDAnnotationHighlight annotation = (PDAnnotationHighlight) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }                    float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }        float maxDelta = 0;    for (int i = 0; i < pathsArray.length / 8; ++i) {                                float delta = Math.max((pathsArray[i + 0] - pathsArray[i + 4]) / 4, (pathsArray[i + 1] - pathsArray[i + 5]) / 4);        maxDelta = Math.max(delta, maxDelta);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2 - maxDelta, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2 - maxDelta, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width + maxDelta, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width + maxDelta, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        PDExtendedGraphicsState r0 = new PDExtendedGraphicsState();        PDExtendedGraphicsState r1 = new PDExtendedGraphicsState();        r0.setAlphaSourceFlag(false);        r0.setStrokingAlphaConstant(annotation.getConstantOpacity());        r0.setNonStrokingAlphaConstant(annotation.getConstantOpacity());        r1.setAlphaSourceFlag(false);        r1.setBlendMode(BlendMode.MULTIPLY);        cs.setGraphicsStateParameters(r0);        cs.setGraphicsStateParameters(r1);                        PDFormXObject frm1 = new PDFormXObject(createCOSStream());        PDFormXObject frm2 = new PDFormXObject(createCOSStream());        frm1.setResources(new PDResources());        try (PDFormContentStream mwfofrmCS = new PDFormContentStream(frm1)) {            mwfofrmCS.drawForm(frm2);        }        frm1.setBBox(annotation.getRectangle());        COSDictionary groupDict = new COSDictionary();        groupDict.setItem(COSName.S, COSName.TRANSPARENCY);                frm1.getCOSObject().setItem(COSName.GROUP, groupDict);        cs.drawForm(frm1);        frm2.setBBox(annotation.getRectangle());        try (PDFormContentStream frm2CS = new PDFormContentStream(frm2)) {            frm2CS.setNonStrokingColor(color);            int of = 0;            while (of + 7 < pathsArray.length) {                                                                                                float delta = 0;                if (Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0 && Float.compare(pathsArray[of + 1], pathsArray[of + 3]) == 0 && Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0 && Float.compare(pathsArray[of + 5], pathsArray[of + 7]) == 0) {                                        delta = (pathsArray[of + 1] - pathsArray[of + 5]) / 4;                } else if (Float.compare(pathsArray[of + 1], pathsArray[of + 5]) == 0 && Float.compare(pathsArray[of + 0], pathsArray[of + 2]) == 0 && Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0 && Float.compare(pathsArray[of + 4], pathsArray[of + 6]) == 0) {                                        delta = (pathsArray[of + 0] - pathsArray[of + 4]) / 4;                }                frm2CS.moveTo(pathsArray[of + 4], pathsArray[of + 5]);                if (Float.compare(pathsArray[of + 0], pathsArray[of + 4]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 4] - delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] - delta, pathsArray[of + 0], pathsArray[of + 1]);                } else if (Float.compare(pathsArray[of + 5], pathsArray[of + 1]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 4] + delta, pathsArray[of + 5] + delta, pathsArray[of + 0] - delta, pathsArray[of + 1] + delta, pathsArray[of + 0], pathsArray[of + 1]);                } else {                    frm2CS.lineTo(pathsArray[of + 0], pathsArray[of + 1]);                }                frm2CS.lineTo(pathsArray[of + 2], pathsArray[of + 3]);                if (Float.compare(pathsArray[of + 2], pathsArray[of + 6]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 2] + delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] + delta, pathsArray[of + 6], pathsArray[of + 7]);                } else if (Float.compare(pathsArray[of + 3], pathsArray[of + 7]) == 0) {                                        frm2CS.curveTo(pathsArray[of + 2] - delta, pathsArray[of + 3] - delta, pathsArray[of + 6] + delta, pathsArray[of + 7] - delta, pathsArray[of + 6], pathsArray[of + 7]);                } else {                    frm2CS.lineTo(pathsArray[of + 6], pathsArray[of + 7]);                }                frm2CS.fill();                of += 8;            }        }    } catch (IOException ex) {            }}
public void pdfbox_f5914_0()
{}
public void pdfbox_f5915_0()
{}
public void pdfbox_f5916_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5917_1()
{    PDAnnotationInk ink = (PDAnnotationInk) getAnnotation();        AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());    PDColor color = ink.getColor();    if (color == null || color.getComponents().length == 0 || Float.compare(ab.width, 0) == 0) {        return;    }    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, ink.getConstantOpacity());        cs.setStrokingColor(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);        for (float[] pathArray : ink.getInkList()) {            int nPoints = pathArray.length / 2;                        for (int i = 0; i < nPoints; ++i) {                float x = pathArray[i * 2];                float y = pathArray[i * 2 + 1];                if (i == 0) {                    cs.moveTo(x, y);                } else {                    cs.lineTo(x, y);                }            }            cs.stroke();        }    } catch (IOException ex) {            }}
public void pdfbox_f5918_0()
{}
public void pdfbox_f5919_0()
{}
public void pdfbox_f5920_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5921_1()
{    PDAnnotationLine annotation = (PDAnnotationLine) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getLine();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    float ll = annotation.getLeaderLineLength();    float lle = annotation.getLeaderLineExtensionLength();    float llo = annotation.getLeaderLineOffsetLength();        float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }        if (ll < 0) {                llo = -llo;        lle = -lle;    }                float lineEndingSize = (ab.width < 1e-5) ? 1 : ab.width;                    rect.setLowerLeftX(Math.min(minX - Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + Math.max(lineEndingSize * 10, Math.abs(llo + ll + lle)), rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());                                                boolean hasStroke = cs.setStrokingColorOnDemand(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);        float x1 = pathsArray[0];        float y1 = pathsArray[1];        float x2 = pathsArray[2];        float y2 = pathsArray[3];                                float y = llo + ll;        String contents = annotation.getContents();        if (contents == null) {            contents = "";        }        cs.saveGraphicsState();        double angle = Math.atan2(y2 - y1, x2 - x1);        cs.transform(Matrix.getRotateInstance(angle, x1, y1));        float lineLength = (float) Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));                cs.moveTo(0, llo);        cs.lineTo(0, llo + ll + lle);        cs.moveTo(lineLength, llo);        cs.lineTo(lineLength, llo + ll + lle);        if (annotation.hasCaption() && !contents.isEmpty()) {                                                PDType1Font font = PDType1Font.HELVETICA;                                    float contentLength = 0;            try {                contentLength = font.getStringWidth(annotation.getContents()) / 1000 * FONT_SIZE;                                                } catch (IllegalArgumentException ex) {                                            }            float xOffset = (lineLength - contentLength) / 2;            float yOffset;            String captionPositioning = annotation.getCaptionPositioning();                        if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {                cs.moveTo(lineEndingSize, y);            } else {                cs.moveTo(0, y);            }            if ("Top".equals(captionPositioning)) {                                yOffset = 1.908f;            } else {                                                yOffset = -2.6f;                cs.lineTo(xOffset - lineEndingSize, y);                cs.moveTo(lineLength - xOffset + lineEndingSize, y);            }            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {                cs.lineTo(lineLength - lineEndingSize, y);            } else {                cs.lineTo(lineLength, y);            }            cs.drawShape(lineEndingSize, hasStroke, false);                        float captionHorizontalOffset = annotation.getCaptionHorizontalOffset();            float captionVerticalOffset = annotation.getCaptionVerticalOffset();                        if (contentLength > 0) {                cs.beginText();                cs.setFont(font, FONT_SIZE);                cs.newLineAtOffset(xOffset + captionHorizontalOffset, y + yOffset + captionVerticalOffset);                cs.showText(annotation.getContents());                cs.endText();            }            if (Float.compare(captionVerticalOffset, 0) != 0) {                                cs.moveTo(0 + lineLength / 2, y);                cs.lineTo(0 + lineLength / 2, y + captionVerticalOffset);                cs.drawShape(lineEndingSize, hasStroke, false);            }        } else {            if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {                cs.moveTo(lineEndingSize, y);            } else {                cs.moveTo(0, y);            }            if (SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {                cs.lineTo(lineLength - lineEndingSize, y);            } else {                cs.lineTo(lineLength, y);            }            cs.drawShape(lineEndingSize, hasStroke, false);        }        cs.restoreGraphicsState();                        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());                if (ab.width < 1e-5) {            hasStroke = false;        }                if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {            cs.saveGraphicsState();            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {                cs.transform(Matrix.getRotateInstance(angle, x1, y1));                drawStyle(annotation.getStartPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, false);            } else {                                                                                float xx1 = x1 - (float) (y * Math.sin(angle));                float yy1 = y1 + (float) (y * Math.cos(angle));                drawStyle(annotation.getStartPointEndingStyle(), cs, xx1, yy1, lineEndingSize, hasStroke, hasBackground, false);            }            cs.restoreGraphicsState();        }                if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {                        if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {                cs.transform(Matrix.getRotateInstance(angle, x2, y2));                drawStyle(annotation.getEndPointEndingStyle(), cs, 0, y, lineEndingSize, hasStroke, hasBackground, true);            } else {                                                                                float xx2 = x2 - (float) (y * Math.sin(angle));                float yy2 = y2 + (float) (y * Math.cos(angle));                drawStyle(annotation.getEndPointEndingStyle(), cs, xx2, yy2, lineEndingSize, hasStroke, hasBackground, true);            }        }    } catch (IOException ex) {            }}
public void pdfbox_f5922_0()
{}
public void pdfbox_f5923_0()
{}
public void pdfbox_f5924_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5926_0()
{}
public void pdfbox_f5927_0()
{}
 float pdfbox_f5928_0()
{    PDAnnotationLink annotation = (PDAnnotationLink) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
public void pdfbox_f5929_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5930_1()
{    PDAnnotationPolygon annotation = (PDAnnotationPolygon) getAnnotation();    float lineWidth = getLineWidth();    PDRectangle rect = annotation.getRectangle();            float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    float[][] pathArray = getPathArray(annotation);    if (pathArray == null) {        return;    }    for (int i = 0; i < pathArray.length; ++i) {        for (int j = 0; j < pathArray[i].length / 2; ++j) {            float x = pathArray[i][j * 2];            float y = pathArray[i][j * 2 + 1];            minX = Math.min(minX, x);            minY = Math.min(minY, y);            maxX = Math.max(maxX, x);            maxY = Math.max(maxY, y);        }    }    rect.setLowerLeftX(Math.min(minX - lineWidth, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - lineWidth, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + lineWidth, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + lineWidth, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(contentStream, annotation.getConstantOpacity());        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());            cloudyBorder.createCloudyPolygon(pathArray);            annotation.setRectangle(cloudyBorder.getRectangle());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {            for (int i = 0; i < pathArray.length; i++) {                float[] pointsArray = pathArray[i];                                if (i == 0 && pointsArray.length == 2) {                    contentStream.moveTo(pointsArray[0], pointsArray[1]);                } else {                                        if (pointsArray.length == 2) {                        contentStream.lineTo(pointsArray[0], pointsArray[1]);                    } else if (pointsArray.length == 6) {                        contentStream.curveTo(pointsArray[0], pointsArray[1], pointsArray[2], pointsArray[3], pointsArray[4], pointsArray[5]);                    }                }            }            contentStream.closePath();        }        contentStream.drawShape(lineWidth, hasStroke, hasBackground);    } catch (IOException e) {            }}
private float[][] pdfbox_f5931_0(PDAnnotationPolygon annotation)
{        float[][] pathArray = annotation.getPath();    if (pathArray == null) {                float[] verticesArray = annotation.getVertices();        if (verticesArray == null) {            return null;        }        int points = verticesArray.length / 2;        pathArray = new float[points][2];        for (int i = 0; i < points; ++i) {            pathArray[i][0] = verticesArray[i * 2];            pathArray[i][1] = verticesArray[i * 2 + 1];        }    }    return pathArray;}
public void pdfbox_f5932_0()
{}
public void pdfbox_f5933_0()
{}
 float pdfbox_f5934_0()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
public void pdfbox_f5935_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5936_1()
{    PDAnnotationPolyline annotation = (PDAnnotationPolyline) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getVertices();    if (pathsArray == null || pathsArray.length < 4) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0 || Float.compare(ab.width, 0) == 0) {        return;    }                float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }        rect.setLowerLeftX(Math.min(minX - ab.width * 10, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width * 10, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width * 10, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width * 10, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        boolean hasBackground = cs.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(cs, annotation.getConstantOpacity());        boolean hasStroke = cs.setStrokingColorOnDemand(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);        for (int i = 0; i < pathsArray.length / 2; ++i) {            float x = pathsArray[i * 2];            float y = pathsArray[i * 2 + 1];            if (i == 0) {                if (SHORT_STYLES.contains(annotation.getStartPointEndingStyle())) {                                                            float x1 = pathsArray[2];                    float y1 = pathsArray[3];                    float len = (float) (Math.sqrt(Math.pow(x - x1, 2) + Math.pow(y - y1, 2)));                    if (Float.compare(len, 0) != 0) {                        x += (x1 - x) / len * ab.width;                        y += (y1 - y) / len * ab.width;                    }                }                cs.moveTo(x, y);            } else {                if (i == pathsArray.length / 2 - 1 && SHORT_STYLES.contains(annotation.getEndPointEndingStyle())) {                                                            float x0 = pathsArray[pathsArray.length - 4];                    float y0 = pathsArray[pathsArray.length - 3];                    float len = (float) (Math.sqrt(Math.pow(x0 - x, 2) + Math.pow(y0 - y, 2)));                    if (Float.compare(len, 0) != 0) {                        x -= (x - x0) / len * ab.width;                        y -= (y - y0) / len * ab.width;                    }                }                cs.lineTo(x, y);            }        }        cs.stroke();                if (!LE_NONE.equals(annotation.getStartPointEndingStyle())) {                        float x2 = pathsArray[2];            float y2 = pathsArray[3];            float x1 = pathsArray[0];            float y1 = pathsArray[1];            cs.saveGraphicsState();            if (ANGLED_STYLES.contains(annotation.getStartPointEndingStyle())) {                double angle = Math.atan2(y2 - y1, x2 - x1);                cs.transform(Matrix.getRotateInstance(angle, x1, y1));            } else {                cs.transform(Matrix.getTranslateInstance(x1, y1));            }            drawStyle(annotation.getStartPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, false);            cs.restoreGraphicsState();        }        if (!LE_NONE.equals(annotation.getEndPointEndingStyle())) {                        float x1 = pathsArray[pathsArray.length - 4];            float y1 = pathsArray[pathsArray.length - 3];            float x2 = pathsArray[pathsArray.length - 2];            float y2 = pathsArray[pathsArray.length - 1];                        if (ANGLED_STYLES.contains(annotation.getEndPointEndingStyle())) {                double angle = Math.atan2(y2 - y1, x2 - x1);                cs.transform(Matrix.getRotateInstance(angle, x2, y2));            } else {                cs.transform(Matrix.getTranslateInstance(x2, y2));            }            drawStyle(annotation.getEndPointEndingStyle(), cs, 0, 0, ab.width, hasStroke, hasBackground, true);        }    } catch (IOException ex) {            }}
public void pdfbox_f5937_0()
{}
public void pdfbox_f5938_0()
{}
 float pdfbox_f5939_0()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
public void pdfbox_f5940_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5941_0()
{}
public void pdfbox_f5942_0()
{}
public void pdfbox_f5943_0()
{}
public void pdfbox_f5944_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5945_1()
{    float lineWidth = getLineWidth();    PDAnnotationSquare annotation = (PDAnnotationSquare) getAnnotation();    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        boolean hasStroke = contentStream.setStrokingColorOnDemand(getColor());        boolean hasBackground = contentStream.setNonStrokingColorOnDemand(annotation.getInteriorColor());        setOpacity(contentStream, annotation.getConstantOpacity());        contentStream.setBorderLine(lineWidth, annotation.getBorderStyle(), annotation.getBorder());        PDBorderEffectDictionary borderEffect = annotation.getBorderEffect();        if (borderEffect != null && borderEffect.getStyle().equals(PDBorderEffectDictionary.STYLE_CLOUDY)) {            CloudyBorder cloudyBorder = new CloudyBorder(contentStream, borderEffect.getIntensity(), lineWidth, getRectangle());            cloudyBorder.createCloudyRectangle(annotation.getRectDifference());            annotation.setRectangle(cloudyBorder.getRectangle());            annotation.setRectDifference(cloudyBorder.getRectDifference());            PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();            appearanceStream.setBBox(cloudyBorder.getBBox());            appearanceStream.setMatrix(cloudyBorder.getMatrix());        } else {            PDRectangle borderBox = handleBorderBox(annotation, lineWidth);            contentStream.addRect(borderBox.getLowerLeftX(), borderBox.getLowerLeftY(), borderBox.getWidth(), borderBox.getHeight());        }        contentStream.drawShape(lineWidth, hasStroke, hasBackground);    } catch (IOException e) {            }}
public void pdfbox_f5946_0()
{}
public void pdfbox_f5947_0()
{}
 float pdfbox_f5948_0()
{    PDAnnotationMarkup annotation = (PDAnnotationMarkup) getAnnotation();    PDBorderStyleDictionary bs = annotation.getBorderStyle();    if (bs != null) {        return bs.getWidth();    }    COSArray borderCharacteristics = annotation.getBorder();    if (borderCharacteristics.size() >= 3) {        COSBase base = borderCharacteristics.getObject(2);        if (base instanceof COSNumber) {            return ((COSNumber) base).floatValue();        }    }    return 1;}
public void pdfbox_f5949_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5950_1()
{    PDAnnotationSquiggly annotation = (PDAnnotationSquiggly) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    if (Float.compare(ab.width, 0) == 0) {                ab.width = 1.5f;    }                    float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width / 2, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width / 2, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());        cs.setStrokingColor(color);                for (int i = 0; i < pathsArray.length / 8; ++i) {                                                            float height = pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5];            cs.transform(new Matrix(height / 40f, 0, 0, height / 40f / 1.8f, pathsArray[i * 8 + 4], pathsArray[i * 8 + 5]));                                                PDFormXObject form = new PDFormXObject(createCOSStream());            form.setBBox(new PDRectangle(-0.5f, -0.5f, (pathsArray[i * 8 + 2] - pathsArray[i * 8]) / height * 40f + 0.5f, 13));            form.setResources(new PDResources());            form.setMatrix(AffineTransform.getTranslateInstance(0.5f, 0.5f));            cs.drawForm(form);            try (PDFormContentStream formCS = new PDFormContentStream(form)) {                PDTilingPattern pattern = new PDTilingPattern();                pattern.setBBox(new PDRectangle(0, 0, 10, 12));                pattern.setXStep(10);                pattern.setYStep(13);                pattern.setTilingType(PDTilingPattern.TILING_CONSTANT_SPACING_FASTER_TILING);                pattern.setPaintType(PDTilingPattern.PAINT_UNCOLORED);                try (PDPatternContentStream patternCS = new PDPatternContentStream(pattern)) {                                        patternCS.setLineCapStyle(1);                    patternCS.setLineJoinStyle(1);                    patternCS.setLineWidth(1);                    patternCS.setMiterLimit(10);                    patternCS.moveTo(0, 1);                    patternCS.lineTo(5, 11);                    patternCS.lineTo(10, 1);                    patternCS.stroke();                }                COSName patternName = form.getResources().add(pattern);                PDColorSpace patternColorSpace = new PDPattern(null, PDDeviceRGB.INSTANCE);                PDColor patternColor = new PDColor(color.getComponents(), patternName, patternColorSpace);                formCS.setNonStrokingColor(patternColor);                                formCS.addRect(0, 0, (pathsArray[i * 8 + 2] - pathsArray[i * 8]) / height * 40f, 12);                formCS.fill();            }        }    } catch (IOException ex) {            }}
public void pdfbox_f5951_0()
{}
public void pdfbox_f5952_0()
{}
public void pdfbox_f5953_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5954_1()
{    PDAnnotationStrikeout annotation = (PDAnnotationStrikeout) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    if (Float.compare(ab.width, 0) == 0) {                ab.width = 1.5f;    }                float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width / 2, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width / 2, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());        cs.setStrokingColor(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);                for (int i = 0; i < pathsArray.length / 8; ++i) {                                                                        float len0 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[i * 8 + 4], 2) + Math.pow(pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5], 2)));            float x0 = pathsArray[i * 8 + 4];            float y0 = pathsArray[i * 8 + 5];            if (Float.compare(len0, 0) != 0) {                                x0 += (pathsArray[i * 8] - pathsArray[i * 8 + 4]) / len0 * (len0 / 2 - ab.width);                y0 += (pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5]) / len0 * (len0 / 2 - ab.width);            }            float len1 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6], 2) + Math.pow(pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7], 2)));            float x1 = pathsArray[i * 8 + 6];            float y1 = pathsArray[i * 8 + 7];            if (Float.compare(len1, 0) != 0) {                                x1 += (pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6]) / len1 * (len1 / 2 - ab.width);                y1 += (pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7]) / len1 * (len1 / 2 - ab.width);            }            cs.moveTo(x0, y0);            cs.lineTo(x1, y1);        }        cs.stroke();    } catch (IOException ex) {            }}
public void pdfbox_f5955_0()
{}
public void pdfbox_f5956_0()
{}
public void pdfbox_f5957_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5958_1()
{    PDAnnotationText annotation = (PDAnnotationText) getAnnotation();    if (!SUPPORTED_NAMES.contains(annotation.getName())) {        return;    }    try (PDAppearanceContentStream contentStream = getNormalAppearanceAsContentStream()) {        PDColor bgColor = getColor();        if (bgColor == null) {                        contentStream.setNonStrokingColor(1f);        } else {            contentStream.setNonStrokingColor(bgColor);        }                setOpacity(contentStream, annotation.getConstantOpacity());        switch(annotation.getName()) {            case PDAnnotationText.NAME_NOTE:                drawNote(annotation, contentStream);                break;            case PDAnnotationText.NAME_CROSS:                drawCross(annotation, contentStream);                break;            case PDAnnotationText.NAME_CIRCLE:                drawCircles(annotation, contentStream);                break;            case PDAnnotationText.NAME_INSERT:                drawInsert(annotation, contentStream);                break;            case PDAnnotationText.NAME_HELP:                drawHelp(annotation, contentStream);                break;            case PDAnnotationText.NAME_PARAGRAPH:                drawParagraph(annotation, contentStream);                break;            case PDAnnotationText.NAME_NEW_PARAGRAPH:                drawNewParagraph(annotation, contentStream);                break;            case PDAnnotationText.NAME_STAR:                drawStar(annotation, contentStream);                break;            case PDAnnotationText.NAME_CHECK:                drawCheck(annotation, contentStream);                break;            case PDAnnotationText.NAME_RIGHT_ARROW:                drawRightArrow(annotation, contentStream);                break;            case PDAnnotationText.NAME_RIGHT_POINTER:                drawRightPointer(annotation, contentStream);                break;            case PDAnnotationText.NAME_CROSS_HAIRS:                drawCrossHairs(annotation, contentStream);                break;            case PDAnnotationText.NAME_UP_ARROW:                drawUpArrow(annotation, contentStream);                break;            case PDAnnotationText.NAME_UP_LEFT_ARROW:                drawUpLeftArrow(annotation, contentStream);                break;            case PDAnnotationText.NAME_COMMENT:                drawComment(annotation, contentStream);                break;            case PDAnnotationText.NAME_KEY:                drawKey(annotation, contentStream);                break;            default:                break;        }    } catch (IOException e) {            }}
private PDRectangle pdfbox_f5959_0(PDAnnotationText annotation, float width, float height)
{                            PDRectangle rect = getRectangle();    PDRectangle bbox;    if (!annotation.isNoZoom()) {        rect.setUpperRightX(rect.getLowerLeftX() + width);        rect.setLowerLeftY(rect.getUpperRightY() - height);        annotation.setRectangle(rect);    }    if (!annotation.getCOSObject().containsKey(COSName.F)) {                annotation.setNoRotate(true);        annotation.setNoZoom(true);    }    bbox = new PDRectangle(width, height);    annotation.getNormalAppearanceStream().setBBox(bbox);    return bbox;}
private void pdfbox_f5960_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 18, 20);    contentStream.setMiterLimit(4);        contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.61f);    contentStream.addRect(1, 1, bbox.getWidth() - 2, bbox.getHeight() - 2);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 2);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 2);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 3);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 3);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 4);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 4);    contentStream.moveTo(bbox.getWidth() / 4, bbox.getHeight() / 7 * 5);    contentStream.lineTo(bbox.getWidth() * 3 / 4 - 1, bbox.getHeight() / 7 * 5);    contentStream.fillAndStroke();}
private void pdfbox_f5961_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);                                float smallR = 6.36f;    float largeR = 9.756f;    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);    contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle(contentStream, bbox.getWidth() / 2, bbox.getHeight() / 2, smallR);    contentStream.fill();    contentStream.restoreGraphicsState();        contentStream.setLineWidth(0.59f);    drawCircle(contentStream, bbox.getWidth() / 2, bbox.getHeight() / 2, smallR);    drawCircle2(contentStream, bbox.getWidth() / 2, bbox.getHeight() / 2, largeR);    contentStream.fillAndStroke();}
private void pdfbox_f5962_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 17, 20);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(0);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.moveTo(bbox.getWidth() / 2 - 1, bbox.getHeight() - 2);    contentStream.lineTo(1, 1);    contentStream.lineTo(bbox.getWidth() - 2, 1);    contentStream.closeAndFillAndStroke();}
private void pdfbox_f5963_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 19, 19);        float min = Math.min(bbox.getWidth(), bbox.getHeight());            float small = min / 10;    float large = min / 5;    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.moveTo(small, large);    contentStream.lineTo(large, small);    contentStream.lineTo(min / 2, min / 2 - small);    contentStream.lineTo(min - large, small);    contentStream.lineTo(min - small, large);    contentStream.lineTo(min / 2 + small, min / 2);    contentStream.lineTo(min - small, min - large);    contentStream.lineTo(min - large, min - small);    contentStream.lineTo(min / 2, min / 2 + small);    contentStream.lineTo(large, min - small);    contentStream.lineTo(small, min - large);    contentStream.lineTo(min / 2 - small, min / 2);    contentStream.closeAndFillAndStroke();}
private void pdfbox_f5964_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.saveGraphicsState();            contentStream.transform(Matrix.getScaleInstance(0.001f * min / 2.25f, 0.001f * min / 2.25f));    contentStream.transform(Matrix.getTranslateInstance(500, 375));            GeneralPath path = PDType1Font.HELVETICA_BOLD.getPath("question");    addPath(contentStream, path);    contentStream.restoreGraphicsState();        drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fillAndStroke();}
private void pdfbox_f5965_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.saveGraphicsState();            contentStream.transform(Matrix.getScaleInstance(0.001f * min / 3, 0.001f * min / 3));    contentStream.transform(Matrix.getTranslateInstance(850, 900));            GeneralPath path = PDType1Font.HELVETICA.getPath("paragraph");    addPath(contentStream, path);    contentStream.restoreGraphicsState();    contentStream.fillAndStroke();    drawCircle(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.stroke();}
private void pdfbox_f5966_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 13, 20);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(0);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.moveTo(6.4995f, 20);    contentStream.lineTo(0.295f, 7.287f);    contentStream.lineTo(12.705f, 7.287f);    contentStream.closeAndFillAndStroke();            contentStream.transform(Matrix.getScaleInstance(0.001f * 4, 0.001f * 4));    contentStream.transform(Matrix.getTranslateInstance(200, 0));    addPath(contentStream, PDType1Font.HELVETICA_BOLD.getPath("N"));    contentStream.transform(Matrix.getTranslateInstance(1300, 0));    addPath(contentStream, PDType1Font.HELVETICA_BOLD.getPath("P"));    contentStream.fill();}
private void pdfbox_f5967_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 19);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 0.8f, 0.001f * min / 0.8f));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a35");    addPath(contentStream, path);    contentStream.fillAndStroke();}
private void pdfbox_f5968_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 19);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 0.8f, 0.001f * min / 0.8f));    contentStream.transform(Matrix.getTranslateInstance(0, 50));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a20");    addPath(contentStream, path);    contentStream.fillAndStroke();}
private void pdfbox_f5969_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 17);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 0.8f, 0.001f * min / 0.8f));    contentStream.transform(Matrix.getTranslateInstance(0, 50));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a174");    addPath(contentStream, path);    contentStream.fillAndStroke();}
private void pdfbox_f5970_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(0);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.61f);    contentStream.transform(Matrix.getScaleInstance(0.001f * min / 1.5f, 0.001f * min / 1.5f));    contentStream.transform(Matrix.getTranslateInstance(0, 50));            GeneralPath path = PDType1Font.SYMBOL.getPath("circleplus");    addPath(contentStream, path);    contentStream.fillAndStroke();}
private void pdfbox_f5971_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 17, 20);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.moveTo(1, 7);    contentStream.lineTo(5, 7);    contentStream.lineTo(5, 1);    contentStream.lineTo(12, 1);    contentStream.lineTo(12, 7);    contentStream.lineTo(16, 7);    contentStream.lineTo(8.5f, 19);    contentStream.closeAndFillAndStroke();}
private void pdfbox_f5972_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 17, 17);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);    contentStream.transform(Matrix.getRotateInstance(Math.toRadians(45), 8, -4));    contentStream.moveTo(1, 7);    contentStream.lineTo(5, 7);    contentStream.lineTo(5, 1);    contentStream.lineTo(12, 1);    contentStream.lineTo(12, 7);    contentStream.lineTo(16, 7);    contentStream.lineTo(8.5f, 19);    contentStream.closeAndFillAndStroke();}
private void pdfbox_f5973_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    PDRectangle bbox = adjustRectAndBBox(annotation, 20, 20);    float min = Math.min(bbox.getWidth(), bbox.getHeight());    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);        contentStream.setLineWidth(0.59f);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    drawCircle2(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.saveGraphicsState();            contentStream.transform(Matrix.getScaleInstance(0.001f * min / 1.3f, 0.001f * min / 1.3f));    contentStream.transform(Matrix.getTranslateInstance(200, 300));            GeneralPath path = PDType1Font.ZAPF_DINGBATS.getPath("a160");    addPath(contentStream, path);    contentStream.restoreGraphicsState();        drawCircle(contentStream, min / 2, min / 2, min / 2 - 1);    contentStream.fillAndStroke();}
private void pdfbox_f5974_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 18, 18);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);    contentStream.setLineWidth(200);        contentStream.saveGraphicsState();    contentStream.setLineWidth(1);    PDExtendedGraphicsState gs = new PDExtendedGraphicsState();    gs.setAlphaSourceFlag(false);    gs.setStrokingAlphaConstant(0.6f);    gs.setNonStrokingAlphaConstant(0.6f);    gs.setBlendMode(BlendMode.NORMAL);    contentStream.setGraphicsStateParameters(gs);    contentStream.setNonStrokingColor(1f);    contentStream.addRect(0.3f, 0.3f, 18 - 0.6f, 18 - 0.6f);    contentStream.fill();    contentStream.restoreGraphicsState();    contentStream.transform(Matrix.getScaleInstance(0.003f, 0.003f));    contentStream.transform(Matrix.getTranslateInstance(500, -300));            contentStream.moveTo(2549, 5269);    contentStream.curveTo(1307, 5269, 300, 4451, 300, 3441);    contentStream.curveTo(300, 3023, 474, 2640, 764, 2331);    contentStream.curveTo(633, 1985, 361, 1691, 357, 1688);    contentStream.curveTo(299, 1626, 283, 1537, 316, 1459);    contentStream.curveTo(350, 1382, 426, 1332, 510, 1332);    contentStream.curveTo(1051, 1332, 1477, 1558, 1733, 1739);    contentStream.curveTo(1987, 1659, 2261, 1613, 2549, 1613);    contentStream.curveTo(3792, 1613, 4799, 2431, 4799, 3441);    contentStream.curveTo(4799, 4451, 3792, 5269, 2549, 5269);    contentStream.closePath();        contentStream.moveTo(0.3f / 0.003f - 500, 0.3f / 0.003f + 300);    contentStream.lineTo(0.3f / 0.003f - 500, 0.3f / 0.003f + 300 + 17.4f / 0.003f);    contentStream.lineTo(0.3f / 0.003f - 500 + 17.4f / 0.003f, 0.3f / 0.003f + 300 + 17.4f / 0.003f);    contentStream.lineTo(0.3f / 0.003f - 500 + 17.4f / 0.003f, 0.3f / 0.003f + 300);    contentStream.closeAndFillAndStroke();}
private void pdfbox_f5975_0(PDAnnotationText annotation, final PDAppearanceContentStream contentStream) throws IOException
{    adjustRectAndBBox(annotation, 13, 18);    contentStream.setMiterLimit(4);    contentStream.setLineJoinStyle(1);    contentStream.setLineCapStyle(0);    contentStream.setLineWidth(200);    contentStream.transform(Matrix.getScaleInstance(0.003f, 0.003f));    contentStream.transform(Matrix.getRotateInstance(Math.toRadians(45), 2500, -800));            contentStream.moveTo(4799, 4004);    contentStream.curveTo(4799, 3149, 4107, 2457, 3253, 2457);    contentStream.curveTo(3154, 2457, 3058, 2466, 2964, 2484);    contentStream.lineTo(2753, 2246);    contentStream.curveTo(2713, 2201, 2656, 2175, 2595, 2175);    contentStream.lineTo(2268, 2175);    contentStream.lineTo(2268, 1824);    contentStream.curveTo(2268, 1707, 2174, 1613, 2057, 1613);    contentStream.lineTo(1706, 1613);    contentStream.lineTo(1706, 1261);    contentStream.curveTo(1706, 1145, 1611, 1050, 1495, 1050);    contentStream.lineTo(510, 1050);    contentStream.curveTo(394, 1050, 300, 1145, 300, 1261);    contentStream.lineTo(300, 1947);    contentStream.curveTo(300, 2003, 322, 2057, 361, 2097);    contentStream.lineTo(1783, 3519);    contentStream.curveTo(1733, 3671, 1706, 3834, 1706, 4004);    contentStream.curveTo(1706, 4858, 2398, 5550, 3253, 5550);    contentStream.curveTo(4109, 5550, 4799, 4860, 4799, 4004);    contentStream.closePath();    contentStream.moveTo(3253, 4425);    contentStream.curveTo(3253, 4192, 3441, 4004, 3674, 4004);    contentStream.curveTo(3907, 4004, 4096, 4192, 4096, 4425);    contentStream.curveTo(4096, 4658, 3907, 4847, 3674, 4847);    contentStream.curveTo(3441, 4847, 3253, 4658, 3253, 4425);    contentStream.fillAndStroke();}
private void pdfbox_f5976_0(final PDAppearanceContentStream contentStream, GeneralPath path) throws IOException
{    double curX = 0;    double curY = 0;    PathIterator it = path.getPathIterator(new AffineTransform());    double[] coords = new double[6];    while (!it.isDone()) {        int type = it.currentSegment(coords);        switch(type) {            case PathIterator.SEG_CLOSE:                contentStream.closePath();                break;            case PathIterator.SEG_CUBICTO:                contentStream.curveTo((float) coords[0], (float) coords[1], (float) coords[2], (float) coords[3], (float) coords[4], (float) coords[5]);                curX = coords[4];                curY = coords[5];                break;            case PathIterator.SEG_QUADTO:                                                                                double cp1x = curX + 2d / 3d * (coords[0] - curX);                double cp1y = curY + 2d / 3d * (coords[1] - curY);                double cp2x = coords[2] + 2d / 3d * (coords[0] - coords[2]);                double cp2y = coords[3] + 2d / 3d * (coords[1] - coords[3]);                contentStream.curveTo((float) cp1x, (float) cp1y, (float) cp2x, (float) cp2y, (float) coords[2], (float) coords[3]);                curX = coords[2];                curY = coords[3];                break;            case PathIterator.SEG_LINETO:                contentStream.lineTo((float) coords[0], (float) coords[1]);                curX = coords[0];                curY = coords[1];                break;            case PathIterator.SEG_MOVETO:                contentStream.moveTo((float) coords[0], (float) coords[1]);                curX = coords[0];                curY = coords[1];                break;            default:                break;        }        it.next();    }}
public void pdfbox_f5977_0()
{}
public void pdfbox_f5978_0()
{}
public void pdfbox_f5979_0()
{    generateNormalAppearance();    generateRolloverAppearance();    generateDownAppearance();}
public void pdfbox_f5980_1()
{    PDAnnotationUnderline annotation = (PDAnnotationUnderline) getAnnotation();    PDRectangle rect = annotation.getRectangle();    float[] pathsArray = annotation.getQuadPoints();    if (pathsArray == null) {        return;    }    AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(annotation, annotation.getBorderStyle());    PDColor color = annotation.getColor();    if (color == null || color.getComponents().length == 0) {        return;    }    if (Float.compare(ab.width, 0) == 0) {                ab.width = 1.5f;    }                    float minX = Float.MAX_VALUE;    float minY = Float.MAX_VALUE;    float maxX = Float.MIN_VALUE;    float maxY = Float.MIN_VALUE;    for (int i = 0; i < pathsArray.length / 2; ++i) {        float x = pathsArray[i * 2];        float y = pathsArray[i * 2 + 1];        minX = Math.min(minX, x);        minY = Math.min(minY, y);        maxX = Math.max(maxX, x);        maxY = Math.max(maxY, y);    }    rect.setLowerLeftX(Math.min(minX - ab.width / 2, rect.getLowerLeftX()));    rect.setLowerLeftY(Math.min(minY - ab.width / 2, rect.getLowerLeftY()));    rect.setUpperRightX(Math.max(maxX + ab.width / 2, rect.getUpperRightX()));    rect.setUpperRightY(Math.max(maxY + ab.width / 2, rect.getUpperRightY()));    annotation.setRectangle(rect);    try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream()) {        setOpacity(cs, annotation.getConstantOpacity());        cs.setStrokingColor(color);        if (ab.dashArray != null) {            cs.setLineDashPattern(ab.dashArray, 0);        }        cs.setLineWidth(ab.width);                for (int i = 0; i < pathsArray.length / 8; ++i) {                                                float len0 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8] - pathsArray[i * 8 + 4], 2) + Math.pow(pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5], 2)));            float x0 = pathsArray[i * 8 + 4];            float y0 = pathsArray[i * 8 + 5];            if (Float.compare(len0, 0) != 0) {                                x0 += (pathsArray[i * 8] - pathsArray[i * 8 + 4]) / len0 * len0 / 7;                y0 += (pathsArray[i * 8 + 1] - pathsArray[i * 8 + 5]) / len0 * (len0 / 7);            }            float len1 = (float) (Math.sqrt(Math.pow(pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6], 2) + Math.pow(pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7], 2)));            float x1 = pathsArray[i * 8 + 6];            float y1 = pathsArray[i * 8 + 7];            if (Float.compare(len1, 0) != 0) {                                x1 += (pathsArray[i * 8 + 2] - pathsArray[i * 8 + 6]) / len1 * len1 / 7;                y1 += (pathsArray[i * 8 + 3] - pathsArray[i * 8 + 7]) / len1 * len1 / 7;            }            cs.moveTo(x0, y0);            cs.lineTo(x1, y1);        }        cs.stroke();    } catch (IOException ex) {            }}
public void pdfbox_f5981_0()
{}
public void pdfbox_f5982_0()
{}
 PDFont pdfbox_f5983_0()
{    return font;}
public void pdfbox_f5984_0(PDFont font)
{    this.font = font;}
 float pdfbox_f5985_0()
{    return fontSize;}
public void pdfbox_f5986_0(float fontSize)
{    this.fontSize = fontSize;    leading = fontSize * 1.2f;}
 float pdfbox_f5987_0()
{    return leading;}
 void pdfbox_f5988_0(float leading)
{    this.leading = leading;}
 List<Paragraph> pdfbox_f5989_0()
{    return paragraphs;}
 String pdfbox_f5990_0()
{    return textContent;}
 List<Line> pdfbox_f5991_0(PDFont font, float fontSize, float width) throws IOException
{    BreakIterator iterator = BreakIterator.getLineInstance();    iterator.setText(textContent);    final float scale = fontSize / FONTSCALE;    int start = iterator.first();    int end = iterator.next();    float lineWidth = 0;    List<Line> textLines = new ArrayList<>();    Line textLine = new Line();    while (end != BreakIterator.DONE) {        String word = textContent.substring(start, end);        float wordWidth = font.getStringWidth(word) * scale;        lineWidth = lineWidth + wordWidth;                if (lineWidth >= width && Character.isWhitespace(word.charAt(word.length() - 1))) {            float whitespaceWidth = font.getStringWidth(word.substring(word.length() - 1)) * scale;            lineWidth = lineWidth - whitespaceWidth;        }        if (lineWidth >= width) {            textLine.setWidth(textLine.calculateWidth(font, fontSize));            textLines.add(textLine);            textLine = new Line();            lineWidth = font.getStringWidth(word) * scale;        }        AttributedString as = new AttributedString(word);        as.addAttribute(TextAttribute.WIDTH, wordWidth);        Word wordInstance = new Word(word);        wordInstance.setAttributes(as);        textLine.addWord(wordInstance);        start = end;        end = iterator.next();    }    textLine.setWidth(textLine.calculateWidth(font, fontSize));    textLines.add(textLine);    return textLines;}
 float pdfbox_f5992_0()
{    return lineWidth;}
 void pdfbox_f5993_0(float width)
{    lineWidth = width;}
 float pdfbox_f5994_0(PDFont font, float fontSize) throws IOException
{    final float scale = fontSize / FONTSCALE;    float calculatedWidth = 0f;    for (Word word : words) {        calculatedWidth = calculatedWidth + (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);        String text = word.getText();        if (words.indexOf(word) == words.size() - 1 && Character.isWhitespace(text.charAt(text.length() - 1))) {            float whitespaceWidth = font.getStringWidth(text.substring(text.length() - 1)) * scale;            calculatedWidth = calculatedWidth - whitespaceWidth;        }    }    return calculatedWidth;}
 List<Word> pdfbox_f5995_0()
{    return words;}
 float pdfbox_f5996_0(float width)
{    return (width - lineWidth) / (words.size() - 1);}
 void pdfbox_f5997_0(Word word)
{    words.add(word);}
 String pdfbox_f5998_0()
{    return textContent;}
 AttributedString pdfbox_f5999_0()
{    return attributedString;}
 void pdfbox_f6000_0(AttributedString as)
{    this.attributedString = as;}
 int pdfbox_f6001_0()
{    return alignment;}
public static TextAlign pdfbox_f6002_0(int alignment)
{    for (TextAlign textAlignment : TextAlign.values()) {        if (textAlignment.getTextAlign() == alignment) {            return textAlignment;        }    }    return TextAlign.LEFT;}
public Builder pdfbox_f6003_0(AppearanceStyle appearanceStyle)
{    this.appearanceStyle = appearanceStyle;    return this;}
public Builder pdfbox_f6004_0(boolean wrapLines)
{    this.wrapLines = wrapLines;    return this;}
public Builder pdfbox_f6005_0(float width)
{    this.width = width;    return this;}
public Builder pdfbox_f6006_0(int alignment)
{    this.textAlignment = TextAlign.valueOf(alignment);    return this;}
public Builder pdfbox_f6007_0(TextAlign alignment)
{    this.textAlignment = alignment;    return this;}
public Builder pdfbox_f6008_0(PlainText textContent)
{    this.textContent = textContent;    return this;}
public Builder pdfbox_f6009_0(float horizontalOffset, float verticalOffset)
{    this.horizontalOffset = horizontalOffset;    this.verticalOffset = verticalOffset;    return this;}
public PlainTextFormatter pdfbox_f6010_0()
{    return new PlainTextFormatter(this);}
public void pdfbox_f6011_0() throws IOException
{    if (textContent != null && !textContent.getParagraphs().isEmpty()) {        boolean isFirstParagraph = true;        for (Paragraph paragraph : textContent.getParagraphs()) {            if (wrapLines) {                List<Line> lines = paragraph.getLines(appearanceStyle.getFont(), appearanceStyle.getFontSize(), width);                processLines(lines, isFirstParagraph);                isFirstParagraph = false;            } else {                float startOffset = 0f;                float lineWidth = appearanceStyle.getFont().getStringWidth(paragraph.getText()) * appearanceStyle.getFontSize() / FONTSCALE;                if (lineWidth < width) {                    switch(textAlignment) {                        case CENTER:                            startOffset = (width - lineWidth) / 2;                            break;                        case RIGHT:                            startOffset = width - lineWidth;                            break;                        case JUSTIFY:                        default:                            startOffset = 0f;                    }                }                contents.newLineAtOffset(horizontalOffset + startOffset, verticalOffset);                contents.showText(paragraph.getText());            }        }    }}
private void pdfbox_f6012_0(List<Line> lines, boolean isFirstParagraph) throws IOException
{    float wordWidth;    float lastPos = 0f;    float startOffset = 0f;    float interWordSpacing = 0f;    for (Line line : lines) {        switch(textAlignment) {            case CENTER:                startOffset = (width - line.getWidth()) / 2;                break;            case RIGHT:                startOffset = width - line.getWidth();                break;            case JUSTIFY:                if (lines.indexOf(line) != lines.size() - 1) {                    interWordSpacing = line.getInterWordSpacing(width);                }                break;            default:                startOffset = 0f;        }        float offset = -lastPos + startOffset + horizontalOffset;        if (lines.indexOf(line) == 0 && isFirstParagraph) {            contents.newLineAtOffset(offset, verticalOffset);        } else {                        verticalOffset = verticalOffset - appearanceStyle.getLeading();            contents.newLineAtOffset(offset, -appearanceStyle.getLeading());        }        lastPos += offset;        List<Word> words = line.getWords();        for (Word word : words) {            contents.showText(word.getText());            wordWidth = (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);            if (words.indexOf(word) != words.size() - 1) {                contents.newLineAtOffset(wordWidth + interWordSpacing, 0f);                lastPos = lastPos + wordWidth + interWordSpacing;            }        }    }    horizontalOffset = horizontalOffset - lastPos;}
public static PDAnnotation pdfbox_f6013_1(COSBase base) throws IOException
{    PDAnnotation annot = null;    if (base instanceof COSDictionary) {        COSDictionary annotDic = (COSDictionary) base;        String subtype = annotDic.getNameAsString(COSName.SUBTYPE);        if (PDAnnotationFileAttachment.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationFileAttachment(annotDic);        } else if (PDAnnotationLine.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationLine(annotDic);        } else if (PDAnnotationLink.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationLink(annotDic);        } else if (PDAnnotationPopup.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationPopup(annotDic);        } else if (PDAnnotationRubberStamp.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationRubberStamp(annotDic);        } else if (PDAnnotationSquare.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationSquare(annotDic);        } else if (PDAnnotationCircle.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationCircle(annotDic);        } else if (PDAnnotationPolygon.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationPolygon(annotDic);        } else if (PDAnnotationPolyline.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationPolyline(annotDic);        } else if (PDAnnotationInk.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationInk(annotDic);        } else if (PDAnnotationText.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationText(annotDic);        } else if (PDAnnotationHighlight.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationHighlight(annotDic);        } else if (PDAnnotationUnderline.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationUnderline(annotDic);        } else if (PDAnnotationStrikeout.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationStrikeout(annotDic);        } else if (PDAnnotationSquiggly.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationSquiggly(annotDic);        } else if (PDAnnotationWidget.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationWidget(annotDic);        } else if (PDAnnotationFreeText.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationFreeText(annotDic);        } else if (PDAnnotationCaret.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationCaret(annotDic);        } else if (PDAnnotationSound.SUB_TYPE.equals(subtype)) {            annot = new PDAnnotationSound(annotDic);        } else {                                    annot = new PDAnnotationUnknown(annotDic);                    }    } else {        throw new IOException("Error: Unknown annotation type " + base);    }    return annot;}
protected final void pdfbox_f6014_0(String subType)
{    getCOSObject().setName(COSName.SUBTYPE, subType);}
public final String pdfbox_f6015_0()
{    return getCOSObject().getNameAsString(COSName.SUBTYPE);}
public PDRectangle pdfbox_f6016_1()
{    COSArray rectArray = (COSArray) dictionary.getDictionaryObject(COSName.RECT);    PDRectangle rectangle = null;    if (rectArray != null) {        if (rectArray.size() == 4 && rectArray.getObject(0) instanceof COSNumber && rectArray.getObject(1) instanceof COSNumber && rectArray.getObject(2) instanceof COSNumber && rectArray.getObject(3) instanceof COSNumber) {            rectangle = new PDRectangle(rectArray);        } else {                    }    }    return rectangle;}
public void pdfbox_f6017_0(PDRectangle rectangle)
{    dictionary.setItem(COSName.RECT, rectangle.getCOSArray());}
public int pdfbox_f6018_0()
{    return getCOSObject().getInt(COSName.F, 0);}
public void pdfbox_f6019_0(int flags)
{    getCOSObject().setInt(COSName.F, flags);}
public COSDictionary pdfbox_f6020_0()
{    return dictionary;}
public COSName pdfbox_f6021_0()
{    return getCOSObject().getCOSName(COSName.AS);}
public void pdfbox_f6022_0(String as)
{    getCOSObject().setName(COSName.AS, as);}
public PDAppearanceDictionary pdfbox_f6023_0()
{    COSBase base = dictionary.getDictionaryObject(COSName.AP);    if (base instanceof COSDictionary) {        return new PDAppearanceDictionary((COSDictionary) base);    }    return null;}
public void pdfbox_f6024_0(PDAppearanceDictionary appearance)
{    dictionary.setItem(COSName.AP, appearance);}
public PDAppearanceStream pdfbox_f6025_0()
{    PDAppearanceDictionary appearanceDict = getAppearance();    if (appearanceDict == null) {        return null;    }    PDAppearanceEntry normalAppearance = appearanceDict.getNormalAppearance();    if (normalAppearance == null) {        return null;    }    if (normalAppearance.isSubDictionary()) {        COSName state = getAppearanceState();        return normalAppearance.getSubDictionary().get(state);    } else {        return normalAppearance.getAppearanceStream();    }}
public boolean pdfbox_f6026_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_INVISIBLE);}
public void pdfbox_f6027_0(boolean invisible)
{    getCOSObject().setFlag(COSName.F, FLAG_INVISIBLE, invisible);}
public boolean pdfbox_f6028_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_HIDDEN);}
public void pdfbox_f6029_0(boolean hidden)
{    getCOSObject().setFlag(COSName.F, FLAG_HIDDEN, hidden);}
public boolean pdfbox_f6030_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_PRINTED);}
public void pdfbox_f6031_0(boolean printed)
{    getCOSObject().setFlag(COSName.F, FLAG_PRINTED, printed);}
public boolean pdfbox_f6032_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_NO_ZOOM);}
public void pdfbox_f6033_0(boolean noZoom)
{    getCOSObject().setFlag(COSName.F, FLAG_NO_ZOOM, noZoom);}
public boolean pdfbox_f6034_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_NO_ROTATE);}
public void pdfbox_f6035_0(boolean noRotate)
{    getCOSObject().setFlag(COSName.F, FLAG_NO_ROTATE, noRotate);}
public boolean pdfbox_f6036_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_NO_VIEW);}
public void pdfbox_f6037_0(boolean noView)
{    getCOSObject().setFlag(COSName.F, FLAG_NO_VIEW, noView);}
public boolean pdfbox_f6038_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_READ_ONLY);}
public void pdfbox_f6039_0(boolean readOnly)
{    getCOSObject().setFlag(COSName.F, FLAG_READ_ONLY, readOnly);}
public boolean pdfbox_f6040_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_LOCKED);}
public void pdfbox_f6041_0(boolean locked)
{    getCOSObject().setFlag(COSName.F, FLAG_LOCKED, locked);}
public boolean pdfbox_f6042_0()
{    return getCOSObject().getFlag(COSName.F, FLAG_TOGGLE_NO_VIEW);}
public void pdfbox_f6043_0(boolean toggleNoView)
{    getCOSObject().setFlag(COSName.F, FLAG_TOGGLE_NO_VIEW, toggleNoView);}
public String pdfbox_f6044_0()
{    return dictionary.getString(COSName.CONTENTS);}
public void pdfbox_f6045_0(String value)
{    dictionary.setString(COSName.CONTENTS, value);}
public String pdfbox_f6046_0()
{    return getCOSObject().getString(COSName.M);}
public void pdfbox_f6047_0(String m)
{    getCOSObject().setString(COSName.M, m);}
public void pdfbox_f6048_0(Calendar c)
{    getCOSObject().setDate(COSName.M, c);}
public String pdfbox_f6049_0()
{    return getCOSObject().getString(COSName.NM);}
public void pdfbox_f6050_0(String nm)
{    getCOSObject().setString(COSName.NM, nm);}
public int pdfbox_f6051_0()
{    return getCOSObject().getInt(COSName.STRUCT_PARENT);}
public void pdfbox_f6052_0(int structParent)
{    getCOSObject().setInt(COSName.STRUCT_PARENT, structParent);}
public PDPropertyList pdfbox_f6053_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.OC);    if (base instanceof COSDictionary) {        return PDPropertyList.create((COSDictionary) base);    }    return null;}
public void pdfbox_f6054_0(PDPropertyList oc)
{    getCOSObject().setItem(COSName.OC, oc);}
public COSArray pdfbox_f6055_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.BORDER);    COSArray border;    if (base instanceof COSArray) {        border = (COSArray) base;        if (border.size() < 3) {                        COSArray newBorder = new COSArray();            newBorder.addAll(border);            border = newBorder;                        while (border.size() < 3) {                border.add(COSInteger.ZERO);            }        }    } else {        border = new COSArray();        border.add(COSInteger.ZERO);        border.add(COSInteger.ZERO);        border.add(COSInteger.ONE);    }    return border;}
public void pdfbox_f6056_0(COSArray borderArray)
{    getCOSObject().setItem(COSName.BORDER, borderArray);}
public void pdfbox_f6057_0(PDColor c)
{    getCOSObject().setItem(COSName.C, c.toCOSArray());}
public PDColor pdfbox_f6058_0()
{    return getColor(COSName.C);}
protected PDColor pdfbox_f6059_0(COSName itemName)
{    COSBase c = this.getCOSObject().getItem(itemName);    if (c instanceof COSArray) {        PDColorSpace colorSpace = null;        switch(((COSArray) c).size()) {            case 1:                colorSpace = PDDeviceGray.INSTANCE;                break;            case 3:                colorSpace = PDDeviceRGB.INSTANCE;                break;            case 4:                colorSpace = PDDeviceCMYK.INSTANCE;                break;            default:                break;        }        return new PDColor((COSArray) c, colorSpace);    }    return null;}
public void pdfbox_f6060_0(PDPage page)
{    this.getCOSObject().setItem(COSName.P, page);}
public PDPage pdfbox_f6061_0()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.P);    if (base instanceof COSDictionary) {        return new PDPage((COSDictionary) base);    }    return null;}
public void pdfbox_f6062_0(PDDocument document)
{}
public void pdfbox_f6063_0()
{}
public void pdfbox_f6064_0(float difference)
{    setRectDifferences(difference, difference, difference, difference);}
public void pdfbox_f6065_0(float differenceLeft, float differenceTop, float differenceRight, float differenceBottom)
{    COSArray margins = new COSArray();    margins.add(new COSFloat(differenceLeft));    margins.add(new COSFloat(differenceTop));    margins.add(new COSFloat(differenceRight));    margins.add(new COSFloat(differenceBottom));    getCOSObject().setItem(COSName.RD, margins);}
public float[] pdfbox_f6066_0()
{    COSBase margin = getCOSObject().getItem(COSName.RD);    if (margin instanceof COSArray) {        return ((COSArray) margin).toFloatArray();    }    return new float[] {};}
public void pdfbox_f6067_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6068_0()
{    this.constructAppearances(null);}
public void pdfbox_f6069_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDCaretAppearanceHandler appearanceHandler = new PDCaretAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6070_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6071_0()
{    this.constructAppearances(null);}
public void pdfbox_f6072_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDCircleAppearanceHandler appearanceHandler = new PDCircleAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public PDFileSpecification pdfbox_f6073_0() throws IOException
{    return PDFileSpecification.createFS(getCOSObject().getDictionaryObject("FS"));}
public void pdfbox_f6074_0(PDFileSpecification file)
{    getCOSObject().setItem("FS", file);}
public String pdfbox_f6075_0()
{    return getCOSObject().getNameAsString(COSName.NAME, ATTACHMENT_NAME_PUSH_PIN);}
public void pdfbox_f6076_0(String name)
{    getCOSObject().setName(COSName.NAME, name);}
public String pdfbox_f6077_0()
{    return getCOSObject().getString(COSName.DA);}
public void pdfbox_f6078_0(String daValue)
{    getCOSObject().setString(COSName.DA, daValue);}
public String pdfbox_f6079_0()
{    return getCOSObject().getString(COSName.DS);}
public void pdfbox_f6080_0(String defaultStyleString)
{    getCOSObject().setString(COSName.DS, defaultStyleString);}
public int pdfbox_f6081_0()
{    return getCOSObject().getInt(COSName.Q, 0);}
public void pdfbox_f6082_0(int q)
{    getCOSObject().setInt(COSName.Q, q);}
public void pdfbox_f6083_0(float difference)
{    setRectDifferences(difference, difference, difference, difference);}
public void pdfbox_f6084_0(float differenceLeft, float differenceTop, float differenceRight, float differenceBottom)
{    COSArray margins = new COSArray();    margins.add(new COSFloat(differenceLeft));    margins.add(new COSFloat(differenceTop));    margins.add(new COSFloat(differenceRight));    margins.add(new COSFloat(differenceBottom));    getCOSObject().setItem(COSName.RD, margins);}
public float[] pdfbox_f6085_0()
{    COSBase margin = getCOSObject().getItem(COSName.RD);    if (margin instanceof COSArray) {        return ((COSArray) margin).toFloatArray();    }    return new float[] {};}
public final void pdfbox_f6086_0(float[] callout)
{    COSArray newCallout = new COSArray();    newCallout.setFloatArray(callout);    getCOSObject().setItem(COSName.CL, newCallout);}
public float[] pdfbox_f6087_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.CL);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
public final void pdfbox_f6088_0(String style)
{    getCOSObject().setName(COSName.LE, style);}
public String pdfbox_f6089_0()
{    return getCOSObject().getNameAsString(COSName.LE, PDAnnotationLine.LE_NONE);}
public void pdfbox_f6090_0(PDBorderEffectDictionary be)
{    getCOSObject().setItem(COSName.BE, be);}
public PDBorderEffectDictionary pdfbox_f6091_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.BE);    if (base instanceof COSDictionary) {        return new PDBorderEffectDictionary((COSDictionary) base);    }    return null;}
public void pdfbox_f6092_0(PDRectangle rd)
{    getCOSObject().setItem(COSName.RD, rd);}
public PDRectangle pdfbox_f6093_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.RD);    if (base instanceof COSArray) {        return new PDRectangle((COSArray) base);    }    return null;}
public void pdfbox_f6094_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6095_0()
{    this.constructAppearances(null);}
public void pdfbox_f6096_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDFreeTextAppearanceHandler appearanceHandler = new PDFreeTextAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6097_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6098_0()
{    this.constructAppearances(null);}
public void pdfbox_f6099_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDHighlightAppearanceHandler appearanceHandler = new PDHighlightAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6100_0(float[][] inkList)
{    if (inkList == null) {        getCOSObject().removeItem(COSName.INKLIST);        return;    }    COSArray array = new COSArray();    for (float[] path : inkList) {        COSArray innerArray = new COSArray();        innerArray.setFloatArray(path);        array.add(innerArray);    }    getCOSObject().setItem(COSName.INKLIST, array);}
public float[][] pdfbox_f6101_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.INKLIST);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        float[][] inkList = new float[array.size()][];        for (int i = 0; i < array.size(); ++i) {            COSBase base2 = array.getObject(i);            if (base2 instanceof COSArray) {                inkList[i] = ((COSArray) array.getObject(i)).toFloatArray();            } else {                inkList[i] = new float[0];            }        }        return inkList;    }    return new float[0][0];}
public void pdfbox_f6102_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6103_0()
{    this.constructAppearances(null);}
public void pdfbox_f6104_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDInkAppearanceHandler appearanceHandler = new PDInkAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6105_0(float[] l)
{    COSArray newL = new COSArray();    newL.setFloatArray(l);    getCOSObject().setItem(COSName.L, newL);}
public float[] pdfbox_f6106_0()
{    COSArray l = (COSArray) getCOSObject().getDictionaryObject(COSName.L);    return l.toFloatArray();}
public void pdfbox_f6107_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() == 0) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(0, actualStyle);    }}
public String pdfbox_f6108_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(0, LE_NONE);    }    return LE_NONE;}
public void pdfbox_f6109_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() < 2) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(1, actualStyle);    }}
public String pdfbox_f6110_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(1, LE_NONE);    }    return LE_NONE;}
public void pdfbox_f6111_0(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
public PDColor pdfbox_f6112_0()
{    return getColor(COSName.IC);}
public void pdfbox_f6113_0(boolean cap)
{    getCOSObject().setBoolean(COSName.CAP, cap);}
public boolean pdfbox_f6114_0()
{    return getCOSObject().getBoolean(COSName.CAP, false);}
public float pdfbox_f6115_0()
{    return this.getCOSObject().getFloat(COSName.LL, 0);}
public void pdfbox_f6116_0(float leaderLineLength)
{    this.getCOSObject().setFloat(COSName.LL, leaderLineLength);}
public float pdfbox_f6117_0()
{    return this.getCOSObject().getFloat(COSName.LLE, 0);}
public void pdfbox_f6118_0(float leaderLineExtensionLength)
{    this.getCOSObject().setFloat(COSName.LLE, leaderLineExtensionLength);}
public float pdfbox_f6119_0()
{    return this.getCOSObject().getFloat(COSName.LLO, 0);}
public void pdfbox_f6120_0(float leaderLineOffsetLength)
{    this.getCOSObject().setFloat(COSName.LLO, leaderLineOffsetLength);}
public String pdfbox_f6121_0()
{    return this.getCOSObject().getNameAsString(COSName.CP);}
public void pdfbox_f6122_0(String captionPositioning)
{    this.getCOSObject().setName(COSName.CP, captionPositioning);}
public void pdfbox_f6123_0(float offset)
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { offset, 0.f });        this.getCOSObject().setItem(COSName.CO, array);    } else {        array.set(0, new COSFloat(offset));    }}
public float pdfbox_f6124_0()
{    float retval = 0.f;    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[0];    }    return retval;}
public void pdfbox_f6125_0(float offset)
{    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array == null) {        array = new COSArray();        array.setFloatArray(new float[] { 0.f, offset });        this.getCOSObject().setItem(COSName.CO, array);    } else {        array.set(1, new COSFloat(offset));    }}
public float pdfbox_f6126_0()
{    float retval = 0.f;    COSArray array = (COSArray) this.getCOSObject().getDictionaryObject(COSName.CO);    if (array != null) {        retval = array.toFloatArray()[1];    }    return retval;}
public void pdfbox_f6127_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6128_0()
{    this.constructAppearances(null);}
public void pdfbox_f6129_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDLineAppearanceHandler appearanceHandler = new PDLineAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public PDAction pdfbox_f6130_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.A);    if (base instanceof COSDictionary) {        return PDActionFactory.createAction((COSDictionary) base);    }    return null;}
public void pdfbox_f6131_0(PDAction action)
{    this.getCOSObject().setItem(COSName.A, action);}
public void pdfbox_f6132_0(PDBorderStyleDictionary bs)
{    this.getCOSObject().setItem(COSName.BS, bs);}
public PDBorderStyleDictionary pdfbox_f6133_0()
{    COSBase bs = getCOSObject().getDictionaryObject(COSName.BS);    if (bs instanceof COSDictionary) {        return new PDBorderStyleDictionary((COSDictionary) bs);    }    return null;}
public PDDestination pdfbox_f6134_0() throws IOException
{    COSBase base = getCOSObject().getDictionaryObject(COSName.DEST);    return PDDestination.create(base);}
public void pdfbox_f6135_0(PDDestination dest)
{    getCOSObject().setItem(COSName.DEST, dest);}
public String pdfbox_f6136_0()
{    return getCOSObject().getNameAsString(COSName.H, HIGHLIGHT_MODE_INVERT);}
public void pdfbox_f6137_0(String mode)
{    getCOSObject().setName(COSName.H, mode);}
public void pdfbox_f6138_0(PDActionURI pa)
{    getCOSObject().setItem("PA", pa);}
public PDActionURI pdfbox_f6139_0()
{    COSBase base = getCOSObject().getDictionaryObject("PA");    if (base instanceof COSDictionary) {        return new PDActionURI((COSDictionary) base);    }    return null;}
public void pdfbox_f6140_0(float[] quadPoints)
{    COSArray newQuadPoints = new COSArray();    newQuadPoints.setFloatArray(quadPoints);    getCOSObject().setItem(COSName.QUADPOINTS, newQuadPoints);}
public float[] pdfbox_f6141_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.QUADPOINTS);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
public void pdfbox_f6142_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6143_0()
{    this.constructAppearances(null);}
public void pdfbox_f6144_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDLinkAppearanceHandler appearanceHandler = new PDLinkAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public String pdfbox_f6145_0()
{    return getCOSObject().getString(COSName.T);}
public void pdfbox_f6146_0(String t)
{    getCOSObject().setString(COSName.T, t);}
public PDAnnotationPopup pdfbox_f6147_0()
{    COSDictionary popup = (COSDictionary) getCOSObject().getDictionaryObject("Popup");    if (popup != null) {        return new PDAnnotationPopup(popup);    } else {        return null;    }}
public void pdfbox_f6148_0(PDAnnotationPopup popup)
{    getCOSObject().setItem("Popup", popup);}
public float pdfbox_f6149_0()
{    return getCOSObject().getFloat(COSName.CA, 1);}
public void pdfbox_f6150_0(float ca)
{    getCOSObject().setFloat(COSName.CA, ca);}
public String pdfbox_f6151_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.RC);    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    } else {        return null;    }}
public void pdfbox_f6152_0(String rc)
{    getCOSObject().setItem(COSName.RC, new COSString(rc));}
public Calendar pdfbox_f6153_0()
{    return getCOSObject().getDate(COSName.CREATION_DATE);}
public void pdfbox_f6154_0(Calendar creationDate)
{    getCOSObject().setDate(COSName.CREATION_DATE, creationDate);}
public PDAnnotation pdfbox_f6155_0() throws IOException
{    COSBase base = getCOSObject().getDictionaryObject("IRT");    if (base instanceof COSDictionary) {        return PDAnnotation.createAnnotation(base);    }    return null;}
public void pdfbox_f6156_0(PDAnnotation irt)
{    getCOSObject().setItem("IRT", irt);}
public String pdfbox_f6157_0()
{    return getCOSObject().getString(COSName.SUBJ);}
public void pdfbox_f6158_0(String subj)
{    getCOSObject().setString(COSName.SUBJ, subj);}
public String pdfbox_f6159_0()
{    return getCOSObject().getNameAsString("RT", RT_REPLY);}
public void pdfbox_f6160_0(String rt)
{    getCOSObject().setName("RT", rt);}
public String pdfbox_f6161_0()
{    return getCOSObject().getNameAsString(COSName.IT);}
public void pdfbox_f6162_0(String it)
{    getCOSObject().setName(COSName.IT, it);}
public PDExternalDataDictionary pdfbox_f6163_0()
{    COSBase exData = this.getCOSObject().getDictionaryObject("ExData");    if (exData instanceof COSDictionary) {        return new PDExternalDataDictionary((COSDictionary) exData);    }    return null;}
public void pdfbox_f6164_0(PDExternalDataDictionary externalData)
{    this.getCOSObject().setItem("ExData", externalData);}
public void pdfbox_f6165_0(PDBorderStyleDictionary bs)
{    this.getCOSObject().setItem(COSName.BS, bs);}
public PDBorderStyleDictionary pdfbox_f6166_0()
{    COSBase bs = getCOSObject().getDictionaryObject(COSName.BS);    if (bs instanceof COSDictionary) {        return new PDBorderStyleDictionary((COSDictionary) bs);    }    return null;}
public void pdfbox_f6167_0(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
public PDColor pdfbox_f6168_0()
{    return getColor(COSName.IC);}
public void pdfbox_f6169_0(PDBorderEffectDictionary be)
{    getCOSObject().setItem(COSName.BE, be);}
public PDBorderEffectDictionary pdfbox_f6170_0()
{    COSDictionary be = (COSDictionary) getCOSObject().getDictionaryObject(COSName.BE);    if (be != null) {        return new PDBorderEffectDictionary(be);    } else {        return null;    }}
public float[] pdfbox_f6171_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.VERTICES);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
public void pdfbox_f6172_0(float[] points)
{    COSArray ar = new COSArray();    ar.setFloatArray(points);    getCOSObject().setItem(COSName.VERTICES, ar);}
public float[][] pdfbox_f6173_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.PATH);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        float[][] pathArray = new float[array.size()][];        for (int i = 0; i < array.size(); ++i) {            COSBase base2 = array.getObject(i);            if (base2 instanceof COSArray) {                pathArray[i] = ((COSArray) array.getObject(i)).toFloatArray();            } else {                pathArray[i] = new float[0];            }        }        return pathArray;    }    return null;}
public void pdfbox_f6174_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6175_0()
{    this.constructAppearances(null);}
public void pdfbox_f6176_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDPolygonAppearanceHandler appearanceHandler = new PDPolygonAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6177_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() == 0) {        array = new COSArray();        array.add(COSName.getPDFName(actualStyle));        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(0, actualStyle);    }}
public String pdfbox_f6178_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(0, PDAnnotationLine.LE_NONE);    }    return PDAnnotationLine.LE_NONE;}
public void pdfbox_f6179_0(String style)
{    String actualStyle = style == null ? PDAnnotationLine.LE_NONE : style;    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    COSArray array;    if (!(base instanceof COSArray) || ((COSArray) base).size() < 2) {        array = new COSArray();        array.add(COSName.getPDFName(PDAnnotationLine.LE_NONE));        array.add(COSName.getPDFName(actualStyle));        getCOSObject().setItem(COSName.LE, array);    } else {        array = (COSArray) base;        array.setName(1, actualStyle);    }}
public String pdfbox_f6180_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.LE);    if (base instanceof COSArray && ((COSArray) base).size() >= 2) {        return ((COSArray) base).getName(1, PDAnnotationLine.LE_NONE);    }    return PDAnnotationLine.LE_NONE;}
public void pdfbox_f6181_0(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
public PDColor pdfbox_f6182_0()
{    return getColor(COSName.IC);}
public float[] pdfbox_f6183_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.VERTICES);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }    return null;}
public void pdfbox_f6184_0(float[] points)
{    COSArray ar = new COSArray();    ar.setFloatArray(points);    getCOSObject().setItem(COSName.VERTICES, ar);}
public void pdfbox_f6185_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6186_0()
{    this.constructAppearances(null);}
public void pdfbox_f6187_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDPolylineAppearanceHandler appearanceHandler = new PDPolylineAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6188_0(boolean open)
{    getCOSObject().setBoolean("Open", open);}
public boolean pdfbox_f6189_0()
{    return getCOSObject().getBoolean("Open", false);}
public void pdfbox_f6190_0(PDAnnotationMarkup annot)
{    getCOSObject().setItem(COSName.PARENT, annot.getCOSObject());}
public PDAnnotationMarkup pdfbox_f6191_1()
{    PDAnnotationMarkup am = null;    try {        am = (PDAnnotationMarkup) PDAnnotation.createAnnotation(getCOSObject().getDictionaryObject(COSName.PARENT, COSName.P));    } catch (IOException ioe) {                }    return am;}
public void pdfbox_f6192_0(String name)
{    getCOSObject().setName(COSName.NAME, name);}
public String pdfbox_f6193_0()
{    return getCOSObject().getNameAsString(COSName.NAME, NAME_DRAFT);}
public void pdfbox_f6194_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6195_0()
{    this.constructAppearances(null);}
public void pdfbox_f6196_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDSoundAppearanceHandler appearanceHandler = new PDSoundAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6197_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6198_0()
{    this.constructAppearances(null);}
public void pdfbox_f6199_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDSquareAppearanceHandler appearanceHandler = new PDSquareAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6200_0(PDColor ic)
{    getCOSObject().setItem(COSName.IC, ic.toCOSArray());}
public PDColor pdfbox_f6201_0()
{    return getColor(COSName.IC);}
public void pdfbox_f6202_0(PDBorderEffectDictionary be)
{    getCOSObject().setItem(COSName.BE, be);}
public PDBorderEffectDictionary pdfbox_f6203_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.BE);    if (base instanceof COSDictionary) {        return new PDBorderEffectDictionary((COSDictionary) base);    }    return null;}
public void pdfbox_f6204_0(PDRectangle rd)
{    getCOSObject().setItem(COSName.RD, rd);}
public PDRectangle pdfbox_f6205_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.RD);    if (base instanceof COSArray) {        return new PDRectangle((COSArray) base);    }    return null;}
public void pdfbox_f6206_0(float difference)
{    setRectDifferences(difference, difference, difference, difference);}
public void pdfbox_f6207_0(float differenceLeft, float differenceTop, float differenceRight, float differenceBottom)
{    COSArray margins = new COSArray();    margins.add(new COSFloat(differenceLeft));    margins.add(new COSFloat(differenceTop));    margins.add(new COSFloat(differenceRight));    margins.add(new COSFloat(differenceBottom));    getCOSObject().setItem(COSName.RD, margins);}
public float[] pdfbox_f6208_0()
{    COSBase margin = getCOSObject().getItem(COSName.RD);    if (margin instanceof COSArray) {        return ((COSArray) margin).toFloatArray();    }    return new float[] {};}
public void pdfbox_f6209_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6210_0()
{    this.constructAppearances(null);}
public void pdfbox_f6211_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDSquigglyAppearanceHandler appearanceHandler = new PDSquigglyAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6212_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6213_0()
{    this.constructAppearances(null);}
public void pdfbox_f6214_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDStrikeoutAppearanceHandler appearanceHandler = new PDStrikeoutAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public void pdfbox_f6215_0(boolean open)
{    getCOSObject().setBoolean(COSName.getPDFName("Open"), open);}
public boolean pdfbox_f6216_0()
{    return getCOSObject().getBoolean(COSName.getPDFName("Open"), false);}
public void pdfbox_f6217_0(String name)
{    getCOSObject().setName(COSName.NAME, name);}
public String pdfbox_f6218_0()
{    return getCOSObject().getNameAsString(COSName.NAME, NAME_NOTE);}
public String pdfbox_f6219_0()
{    return this.getCOSObject().getString(COSName.STATE);}
public void pdfbox_f6220_0(String state)
{    this.getCOSObject().setString(COSName.STATE, state);}
public String pdfbox_f6221_0()
{    return this.getCOSObject().getString(COSName.STATE_MODEL);}
public void pdfbox_f6222_0(String stateModel)
{    this.getCOSObject().setString(COSName.STATE_MODEL, stateModel);}
public void pdfbox_f6223_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6224_0()
{    this.constructAppearances(null);}
public void pdfbox_f6225_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDTextAppearanceHandler appearanceHandler = new PDTextAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public final void pdfbox_f6226_0(float[] quadPoints)
{    COSArray newQuadPoints = new COSArray();    newQuadPoints.setFloatArray(quadPoints);    getCOSObject().setItem(COSName.QUADPOINTS, newQuadPoints);}
public float[] pdfbox_f6227_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.QUADPOINTS);    if (base instanceof COSArray) {        return ((COSArray) base).toFloatArray();    }        return null;}
public void pdfbox_f6228_0(PDAppearanceHandler appearanceHandler)
{    customAppearanceHandler = appearanceHandler;}
public void pdfbox_f6229_0()
{    this.constructAppearances(null);}
public void pdfbox_f6230_0(PDDocument document)
{    if (customAppearanceHandler == null) {        PDUnderlineAppearanceHandler appearanceHandler = new PDUnderlineAppearanceHandler(this, document);        appearanceHandler.generateAppearanceStreams();    } else {        customAppearanceHandler.generateAppearanceStreams();    }}
public String pdfbox_f6231_0()
{    return this.getCOSObject().getNameAsString(COSName.H, "I");}
public void pdfbox_f6232_0(String highlightingMode)
{    if ((highlightingMode == null) || "N".equals(highlightingMode) || "I".equals(highlightingMode) || "O".equals(highlightingMode) || "P".equals(highlightingMode) || "T".equals(highlightingMode)) {        this.getCOSObject().setName(COSName.H, highlightingMode);    } else {        throw new IllegalArgumentException("Valid values for highlighting mode are " + "'N', 'N', 'O', 'P' or 'T'");    }}
public PDAppearanceCharacteristicsDictionary pdfbox_f6233_0()
{    COSBase mk = this.getCOSObject().getDictionaryObject(COSName.MK);    if (mk instanceof COSDictionary) {        return new PDAppearanceCharacteristicsDictionary((COSDictionary) mk);    }    return null;}
public void pdfbox_f6234_0(PDAppearanceCharacteristicsDictionary appearanceCharacteristics)
{    this.getCOSObject().setItem(COSName.MK, appearanceCharacteristics);}
public PDAction pdfbox_f6235_0()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.A);    if (base instanceof COSDictionary) {        return PDActionFactory.createAction((COSDictionary) base);    }    return null;}
public void pdfbox_f6236_0(PDAction action)
{    this.getCOSObject().setItem(COSName.A, action);}
public PDAnnotationAdditionalActions pdfbox_f6237_0()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.AA);    if (base instanceof COSDictionary) {        return new PDAnnotationAdditionalActions((COSDictionary) base);    }    return null;}
public void pdfbox_f6238_0(PDAnnotationAdditionalActions actions)
{    this.getCOSObject().setItem(COSName.AA, actions);}
public void pdfbox_f6239_0(PDBorderStyleDictionary bs)
{    this.getCOSObject().setItem(COSName.BS, bs);}
public PDBorderStyleDictionary pdfbox_f6240_0()
{    COSBase bs = getCOSObject().getDictionaryObject(COSName.BS);    if (bs instanceof COSDictionary) {        return new PDBorderStyleDictionary((COSDictionary) bs);    }    return null;}
public void pdfbox_f6241_0(PDTerminalField field)
{    if (this.getCOSObject().equals(field.getCOSObject())) {        throw new IllegalArgumentException("setParent() is not to be called for a field that shares a dictionary with its only widget");    }    this.getCOSObject().setItem(COSName.PARENT, field);}
public COSDictionary pdfbox_f6242_0()
{    return this.dictionary;}
public int pdfbox_f6243_0()
{    return this.getCOSObject().getInt(COSName.R, 0);}
public void pdfbox_f6244_0(int rotation)
{    this.getCOSObject().setInt(COSName.R, rotation);}
public PDColor pdfbox_f6245_0()
{    return getColor(COSName.BC);}
public void pdfbox_f6246_0(PDColor c)
{    this.getCOSObject().setItem(COSName.BC, c.toCOSArray());}
public PDColor pdfbox_f6247_0()
{    return getColor(COSName.BG);}
public void pdfbox_f6248_0(PDColor c)
{    this.getCOSObject().setItem(COSName.BG, c.toCOSArray());}
public String pdfbox_f6249_0()
{    return this.getCOSObject().getString(COSName.CA);}
public void pdfbox_f6250_0(String caption)
{    this.getCOSObject().setString(COSName.CA, caption);}
public String pdfbox_f6251_0()
{    return this.getCOSObject().getString(COSName.RC);}
public void pdfbox_f6252_0(String caption)
{    this.getCOSObject().setString(COSName.RC, caption);}
public String pdfbox_f6253_0()
{    return this.getCOSObject().getString(COSName.AC);}
public void pdfbox_f6254_0(String caption)
{    this.getCOSObject().setString(COSName.AC, caption);}
public PDFormXObject pdfbox_f6255_0()
{    COSBase i = this.getCOSObject().getDictionaryObject(COSName.I);    if (i instanceof COSStream) {        return new PDFormXObject((COSStream) i);    }    return null;}
public PDFormXObject pdfbox_f6256_0()
{    COSBase i = this.getCOSObject().getDictionaryObject(COSName.RI);    if (i instanceof COSStream) {        return new PDFormXObject((COSStream) i);    }    return null;}
public PDFormXObject pdfbox_f6257_0()
{    COSBase i = this.getCOSObject().getDictionaryObject(COSName.IX);    if (i instanceof COSStream) {        return new PDFormXObject((COSStream) i);    }    return null;}
private PDColor pdfbox_f6258_0(COSName itemName)
{    COSBase c = this.getCOSObject().getItem(itemName);    if (c instanceof COSArray) {        PDColorSpace colorSpace;        switch(((COSArray) c).size()) {            case 1:                colorSpace = PDDeviceGray.INSTANCE;                break;            case 3:                colorSpace = PDDeviceRGB.INSTANCE;                break;            case 4:                colorSpace = PDDeviceCMYK.INSTANCE;                break;            default:                return null;        }        return new PDColor((COSArray) c, colorSpace);    }    return null;}
public COSDictionary pdfbox_f6259_0()
{    return dictionary;}
public PDAppearanceEntry pdfbox_f6260_0()
{    COSBase entry = dictionary.getDictionaryObject(COSName.N);    if (entry instanceof COSDictionary) {        return new PDAppearanceEntry((COSDictionary) entry);    }    return null;}
public void pdfbox_f6261_0(PDAppearanceEntry entry)
{    dictionary.setItem(COSName.N, entry);}
public void pdfbox_f6262_0(PDAppearanceStream ap)
{    dictionary.setItem(COSName.N, ap);}
public PDAppearanceEntry pdfbox_f6263_0()
{    COSBase entry = dictionary.getDictionaryObject(COSName.R);    if (entry instanceof COSDictionary) {        return new PDAppearanceEntry((COSDictionary) entry);    } else {        return getNormalAppearance();    }}
public void pdfbox_f6264_0(PDAppearanceEntry entry)
{    dictionary.setItem(COSName.R, entry);}
public void pdfbox_f6265_0(PDAppearanceStream ap)
{    dictionary.setItem(COSName.R, ap);}
public PDAppearanceEntry pdfbox_f6266_0()
{    COSBase entry = dictionary.getDictionaryObject(COSName.D);    if (entry instanceof COSDictionary) {        return new PDAppearanceEntry((COSDictionary) entry);    } else {        return getNormalAppearance();    }}
public void pdfbox_f6267_0(PDAppearanceEntry entry)
{    dictionary.setItem(COSName.D, entry);}
public void pdfbox_f6268_0(PDAppearanceStream ap)
{    dictionary.setItem(COSName.D, ap);}
public COSDictionary pdfbox_f6269_0()
{    return entry;}
public boolean pdfbox_f6270_0()
{    return !(this.entry instanceof COSStream);}
public boolean pdfbox_f6271_0()
{    return this.entry instanceof COSStream;}
public PDAppearanceStream pdfbox_f6272_0()
{    if (!isStream()) {        throw new IllegalStateException("This entry is not an appearance stream");    }    return new PDAppearanceStream((COSStream) entry);}
public Map<COSName, PDAppearanceStream> pdfbox_f6273_0()
{    if (!isSubDictionary()) {        throw new IllegalStateException("This entry is not an appearance subdictionary");    }    COSDictionary dict = entry;    Map<COSName, PDAppearanceStream> map = new HashMap<>();    for (COSName name : dict.keySet()) {        COSBase value = dict.getDictionaryObject(name);                if (value instanceof COSStream) {            map.put(name, new PDAppearanceStream((COSStream) value));        }    }    return new COSDictionaryMap<>(map, dict);}
public COSDictionary pdfbox_f6274_0()
{    return dictionary;}
public void pdfbox_f6275_0(float i)
{    getCOSObject().setFloat("I", i);}
public float pdfbox_f6276_0()
{    return getCOSObject().getFloat("I", 0);}
public void pdfbox_f6277_0(String s)
{    getCOSObject().setName("S", s);}
public String pdfbox_f6278_0()
{    return getCOSObject().getNameAsString("S", STYLE_SOLID);}
public COSDictionary pdfbox_f6279_0()
{    return dictionary;}
public void pdfbox_f6280_0(float w)
{        if (Float.compare(w, (int) w) == 0) {        getCOSObject().setInt(COSName.W, (int) w);    } else {        getCOSObject().setFloat(COSName.W, w);    }}
public float pdfbox_f6281_0()
{    if (getCOSObject().getDictionaryObject(COSName.W) instanceof COSName) {                return 0;    }    return getCOSObject().getFloat(COSName.W, 1);}
public void pdfbox_f6282_0(String s)
{    getCOSObject().setName(COSName.S, s);}
public String pdfbox_f6283_0()
{    return getCOSObject().getNameAsString(COSName.S, STYLE_SOLID);}
public void pdfbox_f6284_0(COSArray dashArray)
{    COSArray array = null;    if (dashArray != null) {        array = dashArray;    }    getCOSObject().setItem(COSName.D, array);}
public PDLineDashPattern pdfbox_f6285_0()
{    COSArray d = (COSArray) getCOSObject().getDictionaryObject(COSName.D);    if (d == null) {        d = new COSArray();        d.add(COSInteger.THREE);        getCOSObject().setItem(COSName.D, d);    }    return new PDLineDashPattern(d, 0);}
public COSDictionary pdfbox_f6286_0()
{    return this.dataDictionary;}
public String pdfbox_f6287_0()
{    return this.getCOSObject().getNameAsString(COSName.TYPE, "ExData");}
public String pdfbox_f6288_0()
{    return this.getCOSObject().getNameAsString(COSName.SUBTYPE);}
public void pdfbox_f6289_0(String subtype)
{    this.getCOSObject().setName(COSName.SUBTYPE, subtype);}
public int pdfbox_f6290_0() throws IOException
{    nextAvailable();    int i = super.read();    if (i > -1) {        ++position;    }    return i;}
public int pdfbox_f6291_0(byte[] b) throws IOException
{    return read(b, 0, b.length);}
public int pdfbox_f6292_1(byte[] b, int off, int len) throws IOException
{    if (len == 0) {        return 0;    }    int c = read();    if (c == -1) {        return -1;    }    b[off] = (byte) c;    int i = 1;    try {        for (; i < len; i++) {            c = read();            if (c == -1) {                break;            }            b[off + i] = (byte) c;        }    } catch (IOException ee) {            }    return i;}
private boolean pdfbox_f6293_0() throws IOException
{    long pos = position;    for (int i = 0; i < byteRange.length / 2; ++i) {        if (byteRange[i * 2] <= pos && byteRange[i * 2] + byteRange[i * 2 + 1] > pos) {            return true;        }    }    return false;}
private void pdfbox_f6294_0() throws IOException
{    while (!inRange()) {        ++position;        if (super.read() < 0) {            break;        }    }}
public byte[] pdfbox_f6295_0() throws IOException
{    return IOUtils.toByteArray(this);}
public COSDictionary pdfbox_f6296_0()
{    return dictionary;}
public PDPropBuildDataDict pdfbox_f6297_0()
{    PDPropBuildDataDict filter = null;    COSDictionary filterDic = dictionary.getCOSDictionary(COSName.FILTER);    if (filterDic != null) {        filter = new PDPropBuildDataDict(filterDic);    }    return filter;}
public void pdfbox_f6298_0(PDPropBuildDataDict filter)
{    dictionary.setItem(COSName.FILTER, filter);}
public PDPropBuildDataDict pdfbox_f6299_0()
{    PDPropBuildDataDict pubSec = null;    COSDictionary pubSecDic = dictionary.getCOSDictionary(COSName.PUB_SEC);    if (pubSecDic != null) {        pubSec = new PDPropBuildDataDict(pubSecDic);    }    return pubSec;}
public void pdfbox_f6300_0(PDPropBuildDataDict pubSec)
{    dictionary.setItem(COSName.PUB_SEC, pubSec);}
public PDPropBuildDataDict pdfbox_f6301_0()
{    PDPropBuildDataDict app = null;    COSDictionary appDic = dictionary.getCOSDictionary(COSName.APP);    if (appDic != null) {        app = new PDPropBuildDataDict(appDic);    }    return app;}
public void pdfbox_f6302_0(PDPropBuildDataDict app)
{    dictionary.setItem(COSName.APP, app);}
public COSDictionary pdfbox_f6303_0()
{    return dictionary;}
public String pdfbox_f6304_0()
{    return dictionary.getNameAsString(COSName.NAME);}
public void pdfbox_f6305_0(String name)
{    dictionary.setName(COSName.NAME, name);}
public String pdfbox_f6306_0()
{    return dictionary.getString(COSName.DATE);}
public void pdfbox_f6307_0(String date)
{    dictionary.setString(COSName.DATE, date);}
public void pdfbox_f6308_0(String applicationVersion)
{    dictionary.setString("REx", applicationVersion);}
public String pdfbox_f6309_0()
{    return dictionary.getString("REx");}
public long pdfbox_f6310_0()
{    return dictionary.getLong(COSName.R);}
public void pdfbox_f6311_0(long revision)
{    dictionary.setLong(COSName.R, revision);}
public long pdfbox_f6312_0()
{    return dictionary.getLong(COSName.V);}
public void pdfbox_f6313_0(long revision)
{    dictionary.setLong(COSName.V, revision);}
public boolean pdfbox_f6314_0()
{    return dictionary.getBoolean(COSName.PRE_RELEASE, false);}
public void pdfbox_f6315_0(boolean preRelease)
{    dictionary.setBoolean(COSName.PRE_RELEASE, preRelease);}
public String pdfbox_f6316_0()
{    final COSBase cosBase = dictionary.getItem(COSName.OS);    if (cosBase instanceof COSArray) {        return ((COSArray) cosBase).getName(0);    }        return dictionary.getString(COSName.OS);}
public void pdfbox_f6317_0(String os)
{    if (os == null) {        dictionary.removeItem(COSName.OS);    } else {        COSBase osArray = dictionary.getItem(COSName.OS);        if (!(osArray instanceof COSArray)) {            osArray = new COSArray();            osArray.setDirect(true);            dictionary.setItem(COSName.OS, osArray);        }        ((COSArray) osArray).add(0, COSName.getPDFName(os));    }}
public boolean pdfbox_f6318_0()
{    return dictionary.getBoolean(COSName.NON_EFONT_NO_WARN, true);}
public boolean pdfbox_f6319_0()
{    return dictionary.getBoolean(COSName.TRUSTED_MODE, false);}
public void pdfbox_f6320_0(boolean trustedMode)
{    dictionary.setBoolean(COSName.TRUSTED_MODE, trustedMode);}
public COSDictionary pdfbox_f6321_0()
{    return dictionary;}
public boolean pdfbox_f6322_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_FILTER);}
public void pdfbox_f6323_0(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_FILTER, flag);}
public boolean pdfbox_f6324_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_SUBFILTER);}
public void pdfbox_f6325_0(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_SUBFILTER, flag);}
public boolean pdfbox_f6326_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DIGEST_METHOD);}
public void pdfbox_f6327_0(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_DIGEST_METHOD, flag);}
public boolean pdfbox_f6328_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_V);}
public void pdfbox_f6329_0(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_V, flag);}
public boolean pdfbox_f6330_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_REASON);}
public void pdfbox_f6331_0(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_REASON, flag);}
public boolean pdfbox_f6332_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_LEGAL_ATTESTATION);}
public void pdfbox_f6333_0(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_LEGAL_ATTESTATION, flag);}
public boolean pdfbox_f6334_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_ADD_REV_INFO);}
public void pdfbox_f6335_0(boolean flag)
{    getCOSObject().setFlag(COSName.FF, FLAG_ADD_REV_INFO, flag);}
public String pdfbox_f6336_0()
{    return dictionary.getNameAsString(COSName.FILTER);}
public void pdfbox_f6337_0(COSName filter)
{    dictionary.setItem(COSName.FILTER, filter);}
public List<String> pdfbox_f6338_0()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.SUB_FILTER);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getName(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
public void pdfbox_f6339_0(List<COSName> subfilter)
{    dictionary.setItem(COSName.SUB_FILTER, COSArrayList.converterToCOSArray(subfilter));}
public List<String> pdfbox_f6340_0()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.DIGEST_METHOD);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getName(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
public void pdfbox_f6341_0(List<COSName> digestMethod)
{        for (COSName cosName : digestMethod) {        if (!(cosName.equals(COSName.DIGEST_SHA1) || cosName.equals(COSName.DIGEST_SHA256) || cosName.equals(COSName.DIGEST_SHA384) || cosName.equals(COSName.DIGEST_SHA512) || cosName.equals(COSName.DIGEST_RIPEMD160))) {            throw new IllegalArgumentException("Specified digest " + cosName.getName() + " isn't allowed.");        }    }    dictionary.setItem(COSName.DIGEST_METHOD, COSArrayList.converterToCOSArray(digestMethod));}
public float pdfbox_f6342_0()
{    return dictionary.getFloat(COSName.V);}
public void pdfbox_f6343_0(float minimumRequiredCapability)
{    dictionary.setFloat(COSName.V, minimumRequiredCapability);}
public List<String> pdfbox_f6344_0()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.REASONS);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getString(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
public void pdfbox_f6345_0(List<String> reasons)
{    dictionary.setItem(COSName.REASONS, COSArrayList.converterToCOSArray(reasons));}
public PDSeedValueMDP pdfbox_f6346_0()
{    COSDictionary dict = dictionary.getCOSDictionary(COSName.MDP);    PDSeedValueMDP mdp = null;    if (dict != null) {        mdp = new PDSeedValueMDP(dict);    }    return mdp;}
public void pdfbox_f6347_0(PDSeedValueMDP mdp)
{    if (mdp != null) {        dictionary.setItem(COSName.MDP, mdp.getCOSObject());    }}
public PDSeedValueCertificate pdfbox_f6348_0()
{    COSBase base = dictionary.getDictionaryObject(COSName.CERT);    PDSeedValueCertificate certificate = null;    if (base instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) base;        certificate = new PDSeedValueCertificate(dict);    }    return certificate;}
public void pdfbox_f6349_0(PDSeedValueCertificate certificate)
{    dictionary.setItem(COSName.CERT, certificate);}
public PDSeedValueTimeStamp pdfbox_f6350_0()
{    COSDictionary dict = dictionary.getCOSDictionary(COSName.TIME_STAMP);    PDSeedValueTimeStamp timestamp = null;    if (dict != null) {        timestamp = new PDSeedValueTimeStamp(dict);    }    return timestamp;}
public void pdfbox_f6351_0(PDSeedValueTimeStamp timestamp)
{    if (timestamp != null) {        dictionary.setItem(COSName.TIME_STAMP, timestamp.getCOSObject());    }}
public List<String> pdfbox_f6352_0()
{    List<String> retval = null;    COSArray fields = (COSArray) dictionary.getDictionaryObject(COSName.LEGAL_ATTESTATION);    if (fields != null) {        List<String> actuals = new ArrayList<>();        for (int i = 0; i < fields.size(); i++) {            String element = fields.getString(i);            if (element != null) {                actuals.add(element);            }        }        retval = new COSArrayList<>(actuals, fields);    }    return retval;}
public void pdfbox_f6353_0(List<String> legalAttestation)
{    dictionary.setItem(COSName.LEGAL_ATTESTATION, COSArrayList.converterToCOSArray(legalAttestation));}
public COSDictionary pdfbox_f6354_0()
{    return dictionary;}
public boolean pdfbox_f6355_0()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_SUBJECT);}
public void pdfbox_f6356_0(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_SUBJECT, flag);}
public boolean pdfbox_f6357_0()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_ISSUER);}
public void pdfbox_f6358_0(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_ISSUER, flag);}
public boolean pdfbox_f6359_0()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_OID);}
public void pdfbox_f6360_0(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_OID, flag);}
public boolean pdfbox_f6361_0()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_SUBJECT_DN);}
public void pdfbox_f6362_0(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_SUBJECT_DN, flag);}
public boolean pdfbox_f6363_0()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_KEY_USAGE);}
public void pdfbox_f6364_0(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_KEY_USAGE, flag);}
public boolean pdfbox_f6365_0()
{    return this.getCOSObject().getFlag(COSName.FF, FLAG_URL);}
public void pdfbox_f6366_0(boolean flag)
{    this.getCOSObject().setFlag(COSName.FF, FLAG_URL, flag);}
public List<byte[]> pdfbox_f6367_0()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        return getListOfByteArraysFromCOSArray(array);    }    return null;}
public void pdfbox_f6368_0(List<byte[]> subjects)
{    COSArray array = new COSArray();    for (byte[] subject : subjects) {        array.add(new COSString(subject));    }    this.dictionary.setItem(COSName.SUBJECT, array);}
public void pdfbox_f6369_0(byte[] subject)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(subject);    array.add(string);    this.dictionary.setItem(COSName.SUBJECT, array);}
public void pdfbox_f6370_0(byte[] subject)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(subject));    }}
public List<Map<String, String>> pdfbox_f6371_0()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.SUBJECT_DN);    if (base instanceof COSArray) {        COSArray cosArray = (COSArray) base;        List subjectDNList = cosArray.toList();        List<Map<String, String>> result = new LinkedList<>();        for (Object subjectDNItem : subjectDNList) {            if (subjectDNItem instanceof COSDictionary) {                COSDictionary subjectDNItemDict = (COSDictionary) subjectDNItem;                Map<String, String> subjectDNMap = new HashMap<>();                for (COSName key : subjectDNItemDict.keySet()) {                    subjectDNMap.put(key.getName(), subjectDNItemDict.getString(key));                }                result.add(subjectDNMap);            }        }        return result;    }    return null;}
public void pdfbox_f6372_0(List<Map<String, String>> subjectDN)
{    List<COSDictionary> subjectDNDict = new LinkedList<>();    for (Map<String, String> subjectDNItem : subjectDN) {        COSDictionary dict = new COSDictionary();        for (Map.Entry<String, String> entry : subjectDNItem.entrySet()) {            dict.setItem(entry.getKey(), new COSString(entry.getValue()));        }        subjectDNDict.add(dict);    }    this.dictionary.setItem(COSName.SUBJECT_DN, COSArrayList.converterToCOSArray(subjectDNDict));}
public List<String> pdfbox_f6373_0()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.KEY_USAGE);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        List<String> keyUsageExtensions = new LinkedList<>();        for (COSBase item : array) {            if (item instanceof COSString) {                keyUsageExtensions.add(((COSString) item).getString());            }        }        return keyUsageExtensions;    }    return null;}
public void pdfbox_f6374_0(List<String> keyUsageExtensions)
{    this.dictionary.setItem(COSName.KEY_USAGE, COSArrayList.converterToCOSArray(keyUsageExtensions));}
public void pdfbox_f6375_0(String keyUsageExtension)
{    String allowedChars = "01X";    for (int c = 0; c < keyUsageExtension.length(); c++) {        if (allowedChars.indexOf(keyUsageExtension.charAt(c)) == -1) {            throw new IllegalArgumentException("characters can only be 0, 1, X");        }    }    COSBase base = this.dictionary.getDictionaryObject(COSName.KEY_USAGE);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(keyUsageExtension);    array.add(string);    this.dictionary.setItem(COSName.KEY_USAGE, array);}
public void pdfbox_f6376_0(char digitalSignature, char nonRepudiation, char keyEncipherment, char dataEncipherment, char keyAgreement, char keyCertSign, char cRLSign, char encipherOnly, char decipherOnly)
{    StringBuilder builder = new StringBuilder();    builder.append(digitalSignature);    builder.append(nonRepudiation);    builder.append(keyEncipherment);    builder.append(dataEncipherment);    builder.append(keyAgreement);    builder.append(keyCertSign);    builder.append(cRLSign);    builder.append(encipherOnly);    builder.append(decipherOnly);    addKeyUsage(builder.toString());}
public void pdfbox_f6377_0(String keyUsageExtension)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.KEY_USAGE);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(keyUsageExtension));    }}
public List<byte[]> pdfbox_f6378_0()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.ISSUER);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        return getListOfByteArraysFromCOSArray(array);    }    return null;}
public void pdfbox_f6379_0(List<byte[]> issuers)
{    COSArray array = new COSArray();    for (byte[] issuer : issuers) {        array.add(new COSString(issuer));    }    this.dictionary.setItem(COSName.ISSUER, array);}
public void pdfbox_f6380_0(byte[] issuer)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.ISSUER);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(issuer);    array.add(string);    this.dictionary.setItem(COSName.ISSUER, array);}
public void pdfbox_f6381_0(byte[] issuer)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.ISSUER);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(issuer));    }}
public List<byte[]> pdfbox_f6382_0()
{    COSBase base = this.dictionary.getDictionaryObject(COSName.OID);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        return getListOfByteArraysFromCOSArray(array);    }    return null;}
public void pdfbox_f6383_0(List<byte[]> oidByteStrings)
{    COSArray array = new COSArray();    for (byte[] oid : oidByteStrings) {        array.add(new COSString(oid));    }    this.dictionary.setItem(COSName.OID, array);}
public void pdfbox_f6384_0(byte[] oid)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.OID);    COSArray array;    if (base instanceof COSArray) {        array = (COSArray) base;    } else {        array = new COSArray();    }    COSString string = new COSString(oid);    array.add(string);    this.dictionary.setItem(COSName.OID, array);}
public void pdfbox_f6385_0(byte[] oid)
{    COSBase base = this.dictionary.getDictionaryObject(COSName.OID);    if (base instanceof COSArray) {        COSArray array = (COSArray) base;        array.remove(new COSString(oid));    }}
public String pdfbox_f6386_0()
{    return this.dictionary.getString(COSName.URL);}
public void pdfbox_f6387_0(String url)
{    this.dictionary.setString(COSName.URL, url);}
public String pdfbox_f6388_0()
{    return this.dictionary.getNameAsString(COSName.URL_TYPE);}
public void pdfbox_f6389_0(String urlType)
{    this.dictionary.setName(COSName.URL_TYPE, urlType);}
private static List<byte[]> pdfbox_f6390_0(COSArray array)
{    List<byte[]> result = new LinkedList<>();    for (COSBase item : array) {        if (item instanceof COSString) {            result.add(((COSString) item).getBytes());        }    }    return result;}
public COSDictionary pdfbox_f6391_0()
{    return dictionary;}
public int pdfbox_f6392_0()
{    return dictionary.getInt(COSName.P);}
public void pdfbox_f6393_0(int p)
{    if (p < 0 || p > 3) {        throw new IllegalArgumentException("Only values between 0 and 3 nare allowed.");    }    dictionary.setInt(COSName.P, p);}
public COSDictionary pdfbox_f6394_0()
{    return dictionary;}
public String pdfbox_f6395_0()
{    return dictionary.getString(COSName.URL);}
public void pdfbox_f6396_0(String url)
{    dictionary.setString(COSName.URL, url);}
public boolean pdfbox_f6397_0()
{    return dictionary.getInt(COSName.FT, 0) != 0;}
public void pdfbox_f6398_0(boolean flag)
{    dictionary.setInt(COSName.FT, flag ? 1 : 0);}
public COSDictionary pdfbox_f6399_0()
{    return dictionary;}
public void pdfbox_f6400_0(COSName type)
{    dictionary.setItem(COSName.TYPE, type);}
public void pdfbox_f6401_0(COSName filter)
{    dictionary.setItem(COSName.FILTER, filter);}
public void pdfbox_f6402_0(COSName subfilter)
{    dictionary.setItem(COSName.SUB_FILTER, subfilter);}
public void pdfbox_f6403_0(String name)
{    dictionary.setString(COSName.NAME, name);}
public void pdfbox_f6404_0(String location)
{    dictionary.setString(COSName.LOCATION, location);}
public void pdfbox_f6405_0(String reason)
{    dictionary.setString(COSName.REASON, reason);}
public void pdfbox_f6406_0(String contactInfo)
{    dictionary.setString(COSName.CONTACT_INFO, contactInfo);}
public void pdfbox_f6407_0(Calendar cal)
{    dictionary.setDate(COSName.M, cal);}
public String pdfbox_f6408_0()
{    return dictionary.getNameAsString(COSName.FILTER);}
public String pdfbox_f6409_0()
{    return dictionary.getNameAsString(COSName.SUB_FILTER);}
public String pdfbox_f6410_0()
{    return dictionary.getString(COSName.NAME);}
public String pdfbox_f6411_0()
{    return dictionary.getString(COSName.LOCATION);}
public String pdfbox_f6412_0()
{    return dictionary.getString(COSName.REASON);}
public String pdfbox_f6413_0()
{    return dictionary.getString(COSName.CONTACT_INFO);}
public Calendar pdfbox_f6414_0()
{    return dictionary.getDate(COSName.M);}
public void pdfbox_f6415_0(int[] range)
{    if (range.length != 4) {        return;    }    COSArray ary = new COSArray();    for (int i : range) {        ary.add(COSInteger.get(i));    }    dictionary.setItem(COSName.BYTERANGE, ary);    ary.setDirect(true);}
public int[] pdfbox_f6416_0()
{    COSArray byteRange = (COSArray) dictionary.getDictionaryObject(COSName.BYTERANGE);    int[] ary = new int[byteRange.size()];    for (int i = 0; i < ary.length; ++i) {        ary[i] = byteRange.getInt(i);    }    return ary;}
public byte[] pdfbox_f6417_0(InputStream pdfFile) throws IOException
{    int[] byteRange = getByteRange();    int begin = byteRange[0] + byteRange[1] + 1;    int len = byteRange[2] - begin;    return getConvertedContents(new COSFilterInputStream(pdfFile, new int[] { begin, len }));}
public byte[] pdfbox_f6418_0(byte[] pdfFile) throws IOException
{    int[] byteRange = getByteRange();    int begin = byteRange[0] + byteRange[1] + 1;    int len = byteRange[2] - begin;    return getConvertedContents(new COSFilterInputStream(pdfFile, new int[] { begin, len }));}
private byte[] pdfbox_f6419_0(InputStream is) throws IOException
{    ByteArrayOutputStream byteOS = new ByteArrayOutputStream(1024);    byte[] buffer = new byte[1024];    int c;    while ((c = is.read(buffer)) != -1) {                if (buffer[0] == 0x3C || buffer[0] == 0x28) {            byteOS.write(buffer, 1, c);        } else         if (buffer[c - 1] == 0x3E || buffer[c - 1] == 0x29) {            byteOS.write(buffer, 0, c - 1);        } else {            byteOS.write(buffer, 0, c);        }    }    is.close();    return COSString.parseHex(byteOS.toString("ISO-8859-1")).getBytes();}
public void pdfbox_f6420_0(byte[] bytes)
{    COSString string = new COSString(bytes);    string.setForceHexForm(true);    dictionary.setItem(COSName.CONTENTS, string);}
public byte[] pdfbox_f6421_0(InputStream pdfFile) throws IOException
{    try (COSFilterInputStream fis = new COSFilterInputStream(pdfFile, getByteRange())) {        return fis.toByteArray();    }}
public byte[] pdfbox_f6422_0(byte[] pdfFile) throws IOException
{    try (COSFilterInputStream fis = new COSFilterInputStream(pdfFile, getByteRange())) {        return fis.toByteArray();    }}
public PDPropBuild pdfbox_f6423_0()
{    PDPropBuild propBuild = null;    COSDictionary propBuildDic = dictionary.getCOSDictionary(COSName.PROP_BUILD);    if (propBuildDic != null) {        propBuild = new PDPropBuild(propBuildDic);    }    return propBuild;}
public void pdfbox_f6424_0(PDPropBuild propBuild)
{    dictionary.setItem(COSName.PROP_BUILD, propBuild);}
public void pdfbox_f6425_0(int pageNo)
{    this.pageNo = pageNo;}
public int pdfbox_f6426_0()
{    return pageNo;}
public void pdfbox_f6427_0(File file) throws IOException
{    initFromRandomAccessRead(new RandomAccessBufferedFileInputStream(file));}
public void pdfbox_f6428_0(InputStream is) throws IOException
{    initFromRandomAccessRead(new RandomAccessBuffer(is));}
private void pdfbox_f6429_0(RandomAccessRead rar) throws IOException
{    pdfSource = rar;    PDFParser parser = new PDFParser(pdfSource);    parser.parse();    visualSignature = parser.getDocument();}
public void pdfbox_f6430_0(PDVisibleSigProperties visSignatureProperties) throws IOException
{    setVisualSignature(visSignatureProperties.getVisibleSignature());}
public COSDocument pdfbox_f6431_0()
{    return visualSignature;}
public int pdfbox_f6432_0()
{    return preferredSignatureSize;}
public void pdfbox_f6433_0(int size)
{    if (size > 0) {        preferredSignatureSize = size;    }}
public void pdfbox_f6434_0() throws IOException
{    if (visualSignature != null) {        visualSignature.close();    }    if (pdfSource != null) {        pdfSource.close();    }}
public InputStream pdfbox_f6435_0() throws IOException
{    return cosWriter.getDataToSign();}
public void pdfbox_f6436_0(byte[] signature) throws IOException
{    cosWriter.writeExternalSignature(signature);}
public void pdfbox_f6437_0() throws IOException
{    if (cosWriter != null) {        try {            cosWriter.close();        } finally {            cosWriter = null;        }    }}
public PDFTemplateStructure pdfbox_f6438_0()
{    return pdfBuilder.getStructure();}
public InputStream pdfbox_f6439_1(PDVisibleSignDesigner properties) throws IOException
{        PDFTemplateStructure pdfStructure = pdfBuilder.getStructure();        pdfBuilder.createProcSetArray();        pdfBuilder.createPage(properties);    PDPage page = pdfStructure.getPage();        pdfBuilder.createTemplate(page);    try (PDDocument template = pdfStructure.getTemplate()) {                pdfBuilder.createAcroForm(template);        PDAcroForm acroForm = pdfStructure.getAcroForm();                pdfBuilder.createSignatureField(acroForm);        PDSignatureField pdSignatureField = pdfStructure.getSignatureField();                                                pdfBuilder.createSignature(pdSignatureField, page, "");                pdfBuilder.createAcroFormDictionary(acroForm, pdSignatureField);                pdfBuilder.createAffineTransform(properties.getTransform());        AffineTransform transform = pdfStructure.getAffineTransform();                pdfBuilder.createSignatureRectangle(pdSignatureField, properties);        pdfBuilder.createFormatterRectangle(properties.getFormatterRectangleParameters());        PDRectangle bbox = pdfStructure.getFormatterRectangle();        pdfBuilder.createSignatureImage(template, properties.getImage());                pdfBuilder.createHolderFormStream(template);        PDStream holderFormStream = pdfStructure.getHolderFormStream();        pdfBuilder.createHolderFormResources();        PDResources holderFormResources = pdfStructure.getHolderFormResources();        pdfBuilder.createHolderForm(holderFormResources, holderFormStream, bbox);                pdfBuilder.createAppearanceDictionary(pdfStructure.getHolderForm(), pdSignatureField);                pdfBuilder.createInnerFormStream(template);        pdfBuilder.createInnerFormResource();        PDResources innerFormResource = pdfStructure.getInnerFormResources();        pdfBuilder.createInnerForm(innerFormResource, pdfStructure.getInnerFormStream(), bbox);        PDFormXObject innerForm = pdfStructure.getInnerForm();                pdfBuilder.insertInnerFormToHolderResources(innerForm, holderFormResources);                pdfBuilder.createImageFormStream(template);        PDStream imageFormStream = pdfStructure.getImageFormStream();        pdfBuilder.createImageFormResources();        PDResources imageFormResources = pdfStructure.getImageFormResources();        pdfBuilder.createImageForm(imageFormResources, innerFormResource, imageFormStream, bbox, transform, pdfStructure.getImage());        pdfBuilder.createBackgroundLayerForm(innerFormResource, bbox);                pdfBuilder.injectProcSetArray(innerForm, page, innerFormResource, imageFormResources, holderFormResources, pdfStructure.getProcSet());        COSName imageFormName = pdfStructure.getImageFormName();        COSName imageName = pdfStructure.getImageName();        COSName innerFormName = pdfStructure.getInnerFormName();                pdfBuilder.injectAppearanceStreams(holderFormStream, imageFormStream, imageFormStream, imageFormName, imageName, innerFormName, properties);        pdfBuilder.createVisualSignature(template);        pdfBuilder.createWidgetDictionary(pdSignatureField, holderFormResources);        InputStream in = getVisualSignatureAsStream(pdfStructure.getVisualSignature());                        return in;    }}
private InputStream pdfbox_f6440_0(COSDocument visualSignature) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (COSWriter writer = new COSWriter(baos)) {        writer.write(visualSignature);    }    return new ByteArrayInputStream(baos.toByteArray());}
public PDPage pdfbox_f6441_0()
{    return page;}
public void pdfbox_f6442_0(PDPage page)
{    this.page = page;}
public PDDocument pdfbox_f6443_0()
{    return template;}
public void pdfbox_f6444_0(PDDocument template)
{    this.template = template;}
public PDAcroForm pdfbox_f6445_0()
{    return acroForm;}
public void pdfbox_f6446_0(PDAcroForm acroForm)
{    this.acroForm = acroForm;}
public PDSignatureField pdfbox_f6447_0()
{    return signatureField;}
public void pdfbox_f6448_0(PDSignatureField signatureField)
{    this.signatureField = signatureField;}
public PDSignature pdfbox_f6449_0()
{    return pdSignature;}
public void pdfbox_f6450_0(PDSignature pdSignature)
{    this.pdSignature = pdSignature;}
public COSDictionary pdfbox_f6451_0()
{    return acroFormDictionary;}
public void pdfbox_f6452_0(COSDictionary acroFormDictionary)
{    this.acroFormDictionary = acroFormDictionary;}
public PDRectangle pdfbox_f6453_0()
{    return signatureRectangle;}
public void pdfbox_f6454_0(PDRectangle signatureRectangle)
{    this.signatureRectangle = signatureRectangle;}
public AffineTransform pdfbox_f6455_0()
{    return affineTransform;}
public void pdfbox_f6456_0(AffineTransform affineTransform)
{    this.affineTransform = affineTransform;}
public COSArray pdfbox_f6457_0()
{    return procSet;}
public void pdfbox_f6458_0(COSArray procSet)
{    this.procSet = procSet;}
public PDImageXObject pdfbox_f6459_0()
{    return image;}
public void pdfbox_f6460_0(PDImageXObject image)
{    this.image = image;}
public PDRectangle pdfbox_f6461_0()
{    return formatterRectangle;}
public void pdfbox_f6462_0(PDRectangle formatterRectangle)
{    this.formatterRectangle = formatterRectangle;}
public PDStream pdfbox_f6463_0()
{    return holderFormStream;}
public void pdfbox_f6464_0(PDStream holderFormStream)
{    this.holderFormStream = holderFormStream;}
public PDFormXObject pdfbox_f6465_0()
{    return holderForm;}
public void pdfbox_f6466_0(PDFormXObject holderForm)
{    this.holderForm = holderForm;}
public PDResources pdfbox_f6467_0()
{    return holderFormResources;}
public void pdfbox_f6468_0(PDResources holderFormResources)
{    this.holderFormResources = holderFormResources;}
public PDAppearanceDictionary pdfbox_f6469_0()
{    return appearanceDictionary;}
public void pdfbox_f6470_0(PDAppearanceDictionary appearanceDictionary)
{    this.appearanceDictionary = appearanceDictionary;}
public PDStream pdfbox_f6471_0()
{    return innerFormStream;}
public void pdfbox_f6472_0(PDStream innerFormStream)
{    this.innerFormStream = innerFormStream;}
public PDResources pdfbox_f6473_0()
{    return innerFormResources;}
public void pdfbox_f6474_0(PDResources innerFormResources)
{    this.innerFormResources = innerFormResources;}
public PDFormXObject pdfbox_f6475_0()
{    return innerForm;}
public void pdfbox_f6476_0(PDFormXObject innerForm)
{    this.innerForm = innerForm;}
public COSName pdfbox_f6477_0()
{    return innerFormName;}
public void pdfbox_f6478_0(COSName innerFormName)
{    this.innerFormName = innerFormName;}
public PDStream pdfbox_f6479_0()
{    return imageFormStream;}
public void pdfbox_f6480_0(PDStream imageFormStream)
{    this.imageFormStream = imageFormStream;}
public PDResources pdfbox_f6481_0()
{    return imageFormResources;}
public void pdfbox_f6482_0(PDResources imageFormResources)
{    this.imageFormResources = imageFormResources;}
public PDFormXObject pdfbox_f6483_0()
{    return imageForm;}
public void pdfbox_f6484_0(PDFormXObject imageForm)
{    this.imageForm = imageForm;}
public COSName pdfbox_f6485_0()
{    return imageFormName;}
public void pdfbox_f6486_0(COSName imageFormName)
{    this.imageFormName = imageFormName;}
public COSName pdfbox_f6487_0()
{    return imageName;}
public void pdfbox_f6488_0(COSName imageName)
{    this.imageName = imageName;}
public COSDocument pdfbox_f6489_0()
{    return visualSignature;}
public void pdfbox_f6490_0(COSDocument visualSignature)
{    this.visualSignature = visualSignature;}
public List<PDField> pdfbox_f6491_0()
{    return acroFormFields;}
public void pdfbox_f6492_0(List<PDField> acroFormFields)
{    this.acroFormFields = acroFormFields;}
public COSDictionary pdfbox_f6493_0()
{    return widgetDictionary;}
public void pdfbox_f6494_0(COSDictionary widgetDictionary)
{    this.widgetDictionary = widgetDictionary;}
public void pdfbox_f6495_1(PDVisibleSignDesigner properties)
{    PDPage page = new PDPage(new PDRectangle(properties.getPageWidth(), properties.getPageHeight()));    pdfStructure.setPage(page);    }
public void pdfbox_f6496_0(PDPage page) throws IOException
{    PDDocument template = new PDDocument();    template.addPage(page);    pdfStructure.setTemplate(template);}
public void pdfbox_f6497_1(PDDocument template)
{    PDAcroForm theAcroForm = new PDAcroForm(template);    template.getDocumentCatalog().setAcroForm(theAcroForm);    pdfStructure.setAcroForm(theAcroForm);    }
public PDFTemplateStructure pdfbox_f6498_0()
{    return pdfStructure;}
public void pdfbox_f6499_1(PDAcroForm acroForm) throws IOException
{    PDSignatureField sf = new PDSignatureField(acroForm);    pdfStructure.setSignatureField(sf);    }
public void pdfbox_f6500_1(PDSignatureField pdSignatureField, PDPage page, String signerName) throws IOException
{    PDSignature pdSignature = new PDSignature();    PDAnnotationWidget widget = pdSignatureField.getWidgets().get(0);    pdSignatureField.setValue(pdSignature);    widget.setPage(page);    page.getAnnotations().add(widget);    if (!signerName.isEmpty()) {        pdSignature.setName(signerName);    }    pdfStructure.setPdSignature(pdSignature);    }
public void pdfbox_f6501_1(PDAcroForm acroForm, PDSignatureField signatureField) throws IOException
{    @SuppressWarnings("unchecked")    List<PDField> acroFormFields = acroForm.getFields();    COSDictionary acroFormDict = acroForm.getCOSObject();    acroForm.setSignaturesExist(true);    acroForm.setAppendOnly(true);    acroFormDict.setDirect(true);    acroFormFields.add(signatureField);        acroForm.setDefaultAppearance("/sylfaen 0 Tf 0 g");    pdfStructure.setAcroFormFields(acroFormFields);    pdfStructure.setAcroFormDictionary(acroFormDict);    }
public void pdfbox_f6502_1(PDSignatureField signatureField, PDVisibleSignDesigner properties) throws IOException
{    PDRectangle rect = new PDRectangle();    rect.setUpperRightX(properties.getxAxis() + properties.getWidth());    rect.setUpperRightY(properties.getTemplateHeight() - properties.getyAxis());    rect.setLowerLeftY(properties.getTemplateHeight() - properties.getyAxis() - properties.getHeight());    rect.setLowerLeftX(properties.getxAxis());    signatureField.getWidgets().get(0).setRectangle(rect);    pdfStructure.setSignatureRectangle(rect);    }
public void pdfbox_f6503_1(AffineTransform affineTransform)
{    pdfStructure.setAffineTransform(affineTransform);    }
public void pdfbox_f6504_1()
{    COSArray procSetArr = new COSArray();    procSetArr.add(COSName.getPDFName("PDF"));    procSetArr.add(COSName.getPDFName("Text"));    procSetArr.add(COSName.getPDFName("ImageB"));    procSetArr.add(COSName.getPDFName("ImageC"));    procSetArr.add(COSName.getPDFName("ImageI"));    pdfStructure.setProcSet(procSetArr);    }
public void pdfbox_f6505_1(PDDocument template, BufferedImage image) throws IOException
{    pdfStructure.setImage(LosslessFactory.createFromImage(template, image));    }
public void pdfbox_f6506_1(int[] params)
{    PDRectangle formatterRectangle = new PDRectangle();    formatterRectangle.setLowerLeftX(Math.min(params[0], params[2]));    formatterRectangle.setLowerLeftY(Math.min(params[1], params[3]));    formatterRectangle.setUpperRightX(Math.max(params[0], params[2]));    formatterRectangle.setUpperRightY(Math.max(params[1], params[3]));    pdfStructure.setFormatterRectangle(formatterRectangle);    }
public void pdfbox_f6507_1(PDDocument template)
{    PDStream holderForm = new PDStream(template);    pdfStructure.setHolderFormStream(holderForm);    }
public void pdfbox_f6508_1()
{    PDResources holderFormResources = new PDResources();    pdfStructure.setHolderFormResources(holderFormResources);    }
public void pdfbox_f6509_1(PDResources holderFormResources, PDStream holderFormStream, PDRectangle bbox)
{    PDFormXObject holderForm = new PDFormXObject(holderFormStream);    holderForm.setResources(holderFormResources);    holderForm.setBBox(bbox);    holderForm.setFormType(1);    pdfStructure.setHolderForm(holderForm);    }
public void pdfbox_f6510_1(PDFormXObject holderForml, PDSignatureField signatureField) throws IOException
{    PDAppearanceDictionary appearance = new PDAppearanceDictionary();    appearance.getCOSObject().setDirect(true);    PDAppearanceStream appearanceStream = new PDAppearanceStream(holderForml.getCOSObject());    appearance.setNormalAppearance(appearanceStream);    signatureField.getWidgets().get(0).setAppearance(appearance);    pdfStructure.setAppearanceDictionary(appearance);    }
public void pdfbox_f6511_1(PDDocument template)
{    PDStream innerFormStream = new PDStream(template);    pdfStructure.setInnterFormStream(innerFormStream);    }
public void pdfbox_f6512_1()
{    PDResources innerFormResources = new PDResources();    pdfStructure.setInnerFormResources(innerFormResources);    }
public void pdfbox_f6513_1(PDResources innerFormResources, PDStream innerFormStream, PDRectangle bbox)
{    PDFormXObject innerForm = new PDFormXObject(innerFormStream);    innerForm.setResources(innerFormResources);    innerForm.setBBox(bbox);    innerForm.setFormType(1);    pdfStructure.setInnerForm(innerForm);    }
public void pdfbox_f6514_1(PDFormXObject innerForm, PDResources holderFormResources)
{    holderFormResources.put(COSName.FRM, innerForm);    pdfStructure.setInnerFormName(COSName.FRM);    }
public void pdfbox_f6515_1(PDDocument template)
{    PDStream imageFormStream = new PDStream(template);    pdfStructure.setImageFormStream(imageFormStream);    }
public void pdfbox_f6516_1()
{    PDResources imageFormResources = new PDResources();    pdfStructure.setImageFormResources(imageFormResources);    }
public void pdfbox_f6517_1(PDResources imageFormResources, PDResources innerFormResource, PDStream imageFormStream, PDRectangle bbox, AffineTransform at, PDImageXObject img) throws IOException
{    PDFormXObject imageForm = new PDFormXObject(imageFormStream);    imageForm.setBBox(bbox);    imageForm.setMatrix(at);    imageForm.setResources(imageFormResources);    imageForm.setFormType(1);    imageFormResources.getCOSObject().setDirect(true);    COSName imageFormName = COSName.getPDFName("n2");    innerFormResource.put(imageFormName, imageForm);    COSName imageName = imageFormResources.add(img, "img");    pdfStructure.setImageForm(imageForm);    pdfStructure.setImageFormName(imageFormName);    pdfStructure.setImageName(imageName);    }
public void pdfbox_f6518_1(PDResources innerFormResource, PDRectangle bbox) throws IOException
{        PDFormXObject n0Form = new PDFormXObject(pdfStructure.getTemplate().getDocument().createCOSStream());    n0Form.setBBox(bbox);    n0Form.setResources(new PDResources());    n0Form.setFormType(1);    innerFormResource.put(COSName.getPDFName("n0"), n0Form);    }
public void pdfbox_f6519_1(PDFormXObject innerForm, PDPage page, PDResources innerFormResources, PDResources imageFormResources, PDResources holderFormResources, COSArray procSet)
{    innerForm.getResources().getCOSObject().setItem(COSName.PROC_SET, procSet);    page.getCOSObject().setItem(COSName.PROC_SET, procSet);    innerFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);    imageFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);    holderFormResources.getCOSObject().setItem(COSName.PROC_SET, procSet);    }
public void pdfbox_f6520_1(PDStream holderFormStream, PDStream innerFormStream, PDStream imageFormStream, COSName imageFormName, COSName imageName, COSName innerFormName, PDVisibleSignDesigner properties) throws IOException
{        int width = (int) this.getStructure().getFormatterRectangle().getWidth();    int height = (int) this.getStructure().getFormatterRectangle().getHeight();    String imgFormContent = "q " + width + " 0 0 " + height + " 0 0 cm /" + imageName.getName() + " Do Q\n";    String holderFormContent = "q 1 0 0 1 0 0 cm /" + innerFormName.getName() + " Do Q\n";    String innerFormContent = "q 1 0 0 1 0 0 cm /n0 Do Q q 1 0 0 1 0 0 cm /" + imageFormName.getName() + " Do Q\n";    appendRawCommands(pdfStructure.getHolderFormStream().createOutputStream(), holderFormContent);    appendRawCommands(pdfStructure.getInnerFormStream().createOutputStream(), innerFormContent);    appendRawCommands(pdfStructure.getImageFormStream().createOutputStream(), imgFormContent);    }
public void pdfbox_f6521_0(OutputStream os, String commands) throws IOException
{    os.write(commands.getBytes("UTF-8"));    os.close();}
public void pdfbox_f6522_1(PDDocument template)
{    pdfStructure.setVisualSignature(template.getDocument());    }
public void pdfbox_f6523_1(PDSignatureField signatureField, PDResources holderFormResources) throws IOException
{    COSDictionary widgetDict = signatureField.getWidgets().get(0).getCOSObject();    widgetDict.setNeedToBeUpdated(true);    widgetDict.setItem(COSName.DR, holderFormResources.getCOSObject());    pdfStructure.setWidgetDictionary(widgetDict);    }
public void pdfbox_f6524_0(PDDocument template) throws IOException
{    template.close();    pdfStructure.getTemplate().close();}
private void pdfbox_f6525_0(String filename, int page) throws IOException
{    try (PDDocument document = PDDocument.load(new File(filename))) {                calculatePageSize(document, page);    }}
private void pdfbox_f6526_0(InputStream documentStream, int page) throws IOException
{    try (PDDocument document = PDDocument.load(documentStream)) {                calculatePageSize(document, page);    }}
private void pdfbox_f6527_0(PDDocument document, int page)
{    if (page < 1) {        throw new IllegalArgumentException("First page of pdf is 1, not " + page);    }    PDPage firstPage = document.getPage(page - 1);    PDRectangle mediaBox = firstPage.getMediaBox();    pageHeight(mediaBox.getHeight());    pageWidth = mediaBox.getWidth();    imageSizeInPercents = 100;    rotation = firstPage.getRotation() % 360;}
public PDVisibleSignDesigner pdfbox_f6528_0()
{    switch(rotation) {        case 90:                        float temp = yAxis;            yAxis = pageHeight - xAxis - imageWidth;            xAxis = temp;            affineTransform = new AffineTransform(0, imageHeight / imageWidth, -imageWidth / imageHeight, 0, imageWidth, 0);            temp = imageHeight;            imageHeight = imageWidth;            imageWidth = temp;            break;        case 180:            float newX = pageWidth - xAxis - imageWidth;            float newY = pageHeight - yAxis - imageHeight;            xAxis = newX;            yAxis = newY;            affineTransform = new AffineTransform(-1, 0, 0, -1, imageWidth, imageHeight);            break;        case 270:            temp = xAxis;            xAxis = pageWidth - yAxis - imageHeight;            yAxis = temp;            affineTransform = new AffineTransform(0, -imageHeight / imageWidth, imageWidth / imageHeight, 0, 0, imageHeight);            temp = imageHeight;            imageHeight = imageWidth;            imageWidth = temp;            break;        case 0:        default:            break;    }    return this;}
public PDVisibleSignDesigner pdfbox_f6529_0(String path) throws IOException
{    try (InputStream in = new BufferedInputStream(new FileInputStream(path))) {        readImageStream(in);    }    return this;}
public PDVisibleSignDesigner pdfbox_f6530_0(float percent)
{    imageHeight += (imageHeight * percent) / 100;    imageWidth += (imageWidth * percent) / 100;    formatterRectangleParameters[2] = (int) imageWidth.floatValue();    formatterRectangleParameters[3] = (int) imageHeight.floatValue();    return this;}
public PDVisibleSignDesigner pdfbox_f6531_0(float x, float y)
{    xAxis(x);    yAxis(y);    return this;}
public float pdfbox_f6532_0()
{    return xAxis;}
public PDVisibleSignDesigner pdfbox_f6533_0(float xAxis)
{    this.xAxis = xAxis;    return this;}
public float pdfbox_f6534_0()
{    return yAxis;}
public PDVisibleSignDesigner pdfbox_f6535_0(float yAxis)
{    this.yAxis = yAxis;    return this;}
public float pdfbox_f6536_0()
{    return imageWidth;}
public PDVisibleSignDesigner pdfbox_f6537_0(float width)
{    this.imageWidth = width;    this.formatterRectangleParameters[2] = (int) width;    return this;}
public float pdfbox_f6538_0()
{    return imageHeight;}
public PDVisibleSignDesigner pdfbox_f6539_0(float height)
{    this.imageHeight = height;    this.formatterRectangleParameters[3] = (int) height;    return this;}
protected float pdfbox_f6540_0()
{    return getPageHeight();}
private PDVisibleSignDesigner pdfbox_f6541_0(float templateHeight)
{    this.pageHeight = templateHeight;    return this;}
public String pdfbox_f6542_0()
{    return signatureFieldName;}
public PDVisibleSignDesigner pdfbox_f6543_0(String signatureFieldName)
{    this.signatureFieldName = signatureFieldName;    return this;}
public BufferedImage pdfbox_f6544_0()
{    return image;}
private void pdfbox_f6545_0(InputStream stream) throws IOException
{    ImageIO.setUseCache(false);    setImage(ImageIO.read(stream));}
private void pdfbox_f6546_0(BufferedImage image)
{    this.image = image;    imageHeight = (float) image.getHeight();    imageWidth = (float) image.getWidth();    formatterRectangleParameters[2] = image.getWidth();    formatterRectangleParameters[3] = image.getHeight();}
public AffineTransform pdfbox_f6547_0()
{    return affineTransform;}
public PDVisibleSignDesigner pdfbox_f6548_0(AffineTransform affineTransform)
{    this.affineTransform = new AffineTransform(affineTransform);    return this;}
public int[] pdfbox_f6549_0()
{    return formatterRectangleParameters;}
public PDVisibleSignDesigner pdfbox_f6550_0(int[] formatterRectangleParameters)
{    this.formatterRectangleParameters = formatterRectangleParameters;    return this;}
public float pdfbox_f6551_0()
{    return pageWidth;}
public PDVisibleSignDesigner pdfbox_f6552_0(float pageWidth)
{    this.pageWidth = pageWidth;    return this;}
public float pdfbox_f6553_0()
{    return pageHeight;}
public float pdfbox_f6554_0()
{    return imageSizeInPercents;}
public void pdfbox_f6555_0(float imageSizeInPercents)
{    this.imageSizeInPercents = imageSizeInPercents;}
public String pdfbox_f6556_0()
{    throw new UnsupportedOperationException("That method is not yet implemented");}
public PDVisibleSignDesigner pdfbox_f6557_0(String signatureText)
{    throw new UnsupportedOperationException("That method is not yet implemented");}
public void pdfbox_f6558_0() throws IOException
{    PDFTemplateBuilder builder = new PDVisibleSigBuilder();    PDFTemplateCreator creator = new PDFTemplateCreator(builder);    setVisibleSignature(creator.buildPDF(getPdVisibleSignature()));}
public String pdfbox_f6559_0()
{    return signerName;}
public PDVisibleSigProperties pdfbox_f6560_0(String signerName)
{    this.signerName = signerName;    return this;}
public String pdfbox_f6561_0()
{    return signerLocation;}
public PDVisibleSigProperties pdfbox_f6562_0(String signerLocation)
{    this.signerLocation = signerLocation;    return this;}
public String pdfbox_f6563_0()
{    return signatureReason;}
public PDVisibleSigProperties pdfbox_f6564_0(String signatureReason)
{    this.signatureReason = signatureReason;    return this;}
public int pdfbox_f6565_0()
{    return page;}
public PDVisibleSigProperties pdfbox_f6566_0(int page)
{    this.page = page;    return this;}
public int pdfbox_f6567_0()
{    return preferredSize;}
public PDVisibleSigProperties pdfbox_f6568_0(int preferredSize)
{    this.preferredSize = preferredSize;    return this;}
public boolean pdfbox_f6569_0()
{    return visualSignEnabled;}
public PDVisibleSigProperties pdfbox_f6570_0(boolean visualSignEnabled)
{    this.visualSignEnabled = visualSignEnabled;    return this;}
public PDVisibleSignDesigner pdfbox_f6571_0()
{    return pdVisibleSignature;}
public PDVisibleSigProperties pdfbox_f6572_0(PDVisibleSignDesigner pdVisibleSignature)
{    this.pdVisibleSignature = pdVisibleSignature;    return this;}
public InputStream pdfbox_f6573_0()
{    return visibleSignature;}
public void pdfbox_f6574_0(InputStream visibleSignature)
{    this.visibleSignature = visibleSignature;}
public static PDDestination pdfbox_f6575_0(COSBase base) throws IOException
{    PDDestination retval = null;    if (base == null) {        } else if (base instanceof COSArray && ((COSArray) base).size() > 1 && ((COSArray) base).getObject(1) instanceof COSName) {        COSArray array = (COSArray) base;        COSName type = (COSName) array.getObject(1);        String typeString = type.getName();        switch(typeString) {            case PDPageFitDestination.TYPE:            case PDPageFitDestination.TYPE_BOUNDED:                retval = new PDPageFitDestination(array);                break;            case PDPageFitHeightDestination.TYPE:            case PDPageFitHeightDestination.TYPE_BOUNDED:                retval = new PDPageFitHeightDestination(array);                break;            case PDPageFitRectangleDestination.TYPE:                retval = new PDPageFitRectangleDestination(array);                break;            case PDPageFitWidthDestination.TYPE:            case PDPageFitWidthDestination.TYPE_BOUNDED:                retval = new PDPageFitWidthDestination(array);                break;            case PDPageXYZDestination.TYPE:                retval = new PDPageXYZDestination(array);                break;            default:                throw new IOException("Unknown destination type: " + type.getName());        }    } else if (base instanceof COSString) {        retval = new PDNamedDestination((COSString) base);    } else if (base instanceof COSName) {        retval = new PDNamedDestination((COSName) base);    } else {        throw new IOException("Error: can't convert to Destination " + base);    }    return retval;}
public COSBase pdfbox_f6576_0()
{    return namedDestination;}
public String pdfbox_f6577_0()
{    String retval = null;    if (namedDestination instanceof COSString) {        retval = ((COSString) namedDestination).getString();    } else if (namedDestination instanceof COSName) {        retval = ((COSName) namedDestination).getName();    }    return retval;}
public void pdfbox_f6578_0(String dest) throws IOException
{    if (dest == null) {        namedDestination = null;    } else {        namedDestination = new COSString(dest);    }}
public PDPage pdfbox_f6579_0()
{    PDPage retval = null;    if (array.size() > 0) {        COSBase page = array.getObject(0);        if (page instanceof COSDictionary) {            retval = new PDPage((COSDictionary) page);        }    }    return retval;}
public void pdfbox_f6580_0(PDPage page)
{    array.set(0, page);}
public int pdfbox_f6581_0()
{    int retval = -1;    if (array.size() > 0) {        COSBase page = array.getObject(0);        if (page instanceof COSNumber) {            retval = ((COSNumber) page).intValue();        }    }    return retval;}
public int pdfbox_f6582_0()
{    int retval = -1;    if (array.size() > 0) {        COSBase page = array.getObject(0);        if (page instanceof COSNumber) {            retval = ((COSNumber) page).intValue();        } else if (page instanceof COSDictionary) {            return indexOfPageTree((COSDictionary) page);        }    }    return retval;}
private int pdfbox_f6583_0(COSDictionary pageDict)
{    COSDictionary parent = pageDict;    while (parent.getDictionaryObject(COSName.PARENT, COSName.P) instanceof COSDictionary) {        parent = (COSDictionary) parent.getDictionaryObject(COSName.PARENT, COSName.P);    }    if (parent.containsKey(COSName.KIDS) && COSName.PAGES.equals(parent.getItem(COSName.TYPE))) {                PDPageTree pages = new PDPageTree(parent);        return pages.indexOf(new PDPage(pageDict));    }    return -1;}
public void pdfbox_f6584_0(int pageNumber)
{    array.set(0, pageNumber);}
public COSArray pdfbox_f6585_0()
{    return array;}
public boolean pdfbox_f6586_0()
{    return TYPE_BOUNDED.equals(array.getName(1));}
public void pdfbox_f6587_0(boolean fitBoundingBox)
{    array.growToSize(2);    if (fitBoundingBox) {        array.setName(1, TYPE_BOUNDED);    } else {        array.setName(1, TYPE);    }}
public int pdfbox_f6588_0()
{    return array.getInt(2);}
public void pdfbox_f6589_0(int x)
{    array.growToSize(3);    if (x == -1) {        array.set(2, null);    } else {        array.setInt(2, x);    }}
public boolean pdfbox_f6590_0()
{    return TYPE_BOUNDED.equals(array.getName(1));}
public void pdfbox_f6591_0(boolean fitBoundingBox)
{    array.growToSize(2);    if (fitBoundingBox) {        array.setName(1, TYPE_BOUNDED);    } else {        array.setName(1, TYPE);    }}
public int pdfbox_f6592_0()
{    return array.getInt(2);}
public void pdfbox_f6593_0(int x)
{    array.growToSize(3);    if (x == -1) {        array.set(2, null);    } else {        array.setInt(2, x);    }}
public int pdfbox_f6594_0()
{    return array.getInt(3);}
public void pdfbox_f6595_0(int y)
{    array.growToSize(6);    if (y == -1) {        array.set(3, null);    } else {        array.setInt(3, y);    }}
public int pdfbox_f6596_0()
{    return array.getInt(4);}
public void pdfbox_f6597_0(int x)
{    array.growToSize(6);    if (x == -1) {        array.set(4, null);    } else {        array.setInt(4, x);    }}
public int pdfbox_f6598_0()
{    return array.getInt(5);}
public void pdfbox_f6599_0(int y)
{    array.growToSize(6);    if (y == -1) {        array.set(5, null);    } else {        array.setInt(5, y);    }}
public int pdfbox_f6600_0()
{    return array.getInt(2);}
public void pdfbox_f6601_0(int y)
{    array.growToSize(3);    if (y == -1) {        array.set(2, null);    } else {        array.setInt(2, y);    }}
public boolean pdfbox_f6602_0()
{    return TYPE_BOUNDED.equals(array.getName(1));}
public void pdfbox_f6603_0(boolean fitBoundingBox)
{    array.growToSize(2);    if (fitBoundingBox) {        array.setName(1, TYPE_BOUNDED);    } else {        array.setName(1, TYPE);    }}
public int pdfbox_f6604_0()
{    return array.getInt(2);}
public void pdfbox_f6605_0(int x)
{    array.growToSize(3);    if (x == -1) {        array.set(2, null);    } else {        array.setInt(2, x);    }}
public int pdfbox_f6606_0()
{    return array.getInt(3);}
public void pdfbox_f6607_0(int y)
{    array.growToSize(4);    if (y == -1) {        array.set(3, null);    } else {        array.setInt(3, y);    }}
public float pdfbox_f6608_0()
{    COSBase obj = array.getObject(4);    if (obj instanceof COSNumber) {        return ((COSNumber) obj).floatValue();    }    return -1;}
public void pdfbox_f6609_0(float zoom)
{    array.growToSize(5);    if (Float.compare(zoom, -1) == 0) {        array.set(4, null);    } else {        array.set(4, new COSFloat(zoom));    }}
public boolean pdfbox_f6610_0()
{    return true;}
public void pdfbox_f6611_0()
{}
public void pdfbox_f6612_0()
{}
public void pdfbox_f6613_0(PDOutlineItem newSibling)
{    requireSingleNode(newSibling);    PDOutlineNode parent = getParent();    newSibling.setParent(parent);    PDOutlineItem next = getNextSibling();    setNextSibling(newSibling);    newSibling.setPreviousSibling(this);    if (next != null) {        newSibling.setNextSibling(next);        next.setPreviousSibling(newSibling);    } else if (parent != null) {        getParent().setLastChild(newSibling);    }    updateParentOpenCountForAddedChild(newSibling);}
public void pdfbox_f6614_0(PDOutlineItem newSibling)
{    requireSingleNode(newSibling);    PDOutlineNode parent = getParent();    newSibling.setParent(parent);    PDOutlineItem previous = getPreviousSibling();    setPreviousSibling(newSibling);    newSibling.setNextSibling(this);    if (previous != null) {        previous.setNextSibling(newSibling);        newSibling.setPreviousSibling(previous);    } else if (parent != null) {        getParent().setFirstChild(newSibling);    }    updateParentOpenCountForAddedChild(newSibling);}
public PDOutlineItem pdfbox_f6615_0()
{    return getOutlineItem(COSName.PREV);}
 void pdfbox_f6616_0(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.PREV, outlineNode);}
public PDOutlineItem pdfbox_f6617_0()
{    return getOutlineItem(COSName.NEXT);}
 void pdfbox_f6618_0(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.NEXT, outlineNode);}
public String pdfbox_f6619_0()
{    return getCOSObject().getString(COSName.TITLE);}
public void pdfbox_f6620_0(String title)
{    getCOSObject().setString(COSName.TITLE, title);}
public PDDestination pdfbox_f6621_0() throws IOException
{    return PDDestination.create(getCOSObject().getDictionaryObject(COSName.DEST));}
public void pdfbox_f6622_0(PDDestination dest)
{    getCOSObject().setItem(COSName.DEST, dest);}
public void pdfbox_f6623_0(PDPage page)
{    PDPageXYZDestination dest = null;    if (page != null) {        dest = new PDPageXYZDestination();        dest.setPage(page);    }    setDestination(dest);}
public PDPage pdfbox_f6624_0(PDDocument doc) throws IOException
{    PDDestination dest = getDestination();    if (dest == null) {        PDAction outlineAction = getAction();        if (outlineAction instanceof PDActionGoTo) {            dest = ((PDActionGoTo) outlineAction).getDestination();        }    }    if (dest == null) {        return null;    }    PDPageDestination pageDestination = null;    if (dest instanceof PDNamedDestination) {        pageDestination = doc.getDocumentCatalog().findNamedDestinationPage((PDNamedDestination) dest);        if (pageDestination == null) {            return null;        }    } else if (dest instanceof PDPageDestination) {        pageDestination = (PDPageDestination) dest;    } else {        throw new IOException("Error: Unknown destination type " + dest);    }    PDPage page = pageDestination.getPage();    if (page == null) {                        int pageNumber = pageDestination.getPageNumber();        if (pageNumber != -1) {            page = doc.getPage(pageNumber);        }    }    return page;}
public PDAction pdfbox_f6625_0()
{    return PDActionFactory.createAction((COSDictionary) getCOSObject().getDictionaryObject(COSName.A));}
public void pdfbox_f6626_0(PDAction action)
{    getCOSObject().setItem(COSName.A, action);}
public PDStructureElement pdfbox_f6627_0()
{    PDStructureElement se = null;    COSDictionary dic = (COSDictionary) getCOSObject().getDictionaryObject(COSName.SE);    if (dic != null) {        se = new PDStructureElement(dic);    }    return se;}
public void pdfbox_f6628_0(PDStructureElement structureElement)
{    getCOSObject().setItem(COSName.SE, structureElement);}
public PDColor pdfbox_f6629_0()
{    COSArray csValues = (COSArray) getCOSObject().getDictionaryObject(COSName.C);    if (csValues == null) {        csValues = new COSArray();        csValues.growToSize(3, new COSFloat(0));        getCOSObject().setItem(COSName.C, csValues);    }    return new PDColor(csValues, PDDeviceRGB.INSTANCE);}
public void pdfbox_f6630_0(PDColor textColor)
{    getCOSObject().setItem(COSName.C, textColor.toCOSArray());}
public void pdfbox_f6631_0(Color textColor)
{    COSArray array = new COSArray();    array.add(new COSFloat(textColor.getRed() / 255f));    array.add(new COSFloat(textColor.getGreen() / 255f));    array.add(new COSFloat(textColor.getBlue() / 255f));    getCOSObject().setItem(COSName.C, array);}
public boolean pdfbox_f6632_0()
{    return getCOSObject().getFlag(COSName.F, ITALIC_FLAG);}
public void pdfbox_f6633_0(boolean italic)
{    getCOSObject().setFlag(COSName.F, ITALIC_FLAG, italic);}
public boolean pdfbox_f6634_0()
{    return getCOSObject().getFlag(COSName.F, BOLD_FLAG);}
public void pdfbox_f6635_0(boolean bold)
{    getCOSObject().setFlag(COSName.F, BOLD_FLAG, bold);}
public boolean pdfbox_f6636_0()
{    return startingItem != null && (currentItem == null || (currentItem.getNextSibling() != null && !startingItem.equals(currentItem.getNextSibling())));}
public PDOutlineItem pdfbox_f6637_0()
{    if (currentItem == null) {        currentItem = startingItem;    } else {        currentItem = currentItem.getNextSibling();    }    return currentItem;}
public void pdfbox_f6638_0()
{    throw new UnsupportedOperationException();}
 PDOutlineNode pdfbox_f6639_0()
{    COSBase base = getCOSObject().getDictionaryObject(COSName.PARENT);    if (base instanceof COSDictionary) {        COSDictionary parent = (COSDictionary) base;        if (COSName.OUTLINES.equals(parent.getCOSName(COSName.TYPE))) {            return new PDDocumentOutline(parent);        }        return new PDOutlineItem(parent);    }    return null;}
 void pdfbox_f6640_0(PDOutlineNode parent)
{    getCOSObject().setItem(COSName.PARENT, parent);}
public void pdfbox_f6641_0(PDOutlineItem newChild)
{    requireSingleNode(newChild);    append(newChild);    updateParentOpenCountForAddedChild(newChild);}
public void pdfbox_f6642_0(PDOutlineItem newChild)
{    requireSingleNode(newChild);    prepend(newChild);    updateParentOpenCountForAddedChild(newChild);}
 void pdfbox_f6643_0(PDOutlineItem node)
{    if (node.getNextSibling() != null || node.getPreviousSibling() != null) {        throw new IllegalArgumentException("A single node with no siblings is required");    }}
private void pdfbox_f6644_0(PDOutlineItem newChild)
{    newChild.setParent(this);    if (!hasChildren()) {        setFirstChild(newChild);    } else {        PDOutlineItem previousLastChild = getLastChild();        previousLastChild.setNextSibling(newChild);        newChild.setPreviousSibling(previousLastChild);    }    setLastChild(newChild);}
private void pdfbox_f6645_0(PDOutlineItem newChild)
{    newChild.setParent(this);    if (!hasChildren()) {        setLastChild(newChild);    } else {        PDOutlineItem previousFirstChild = getFirstChild();        newChild.setNextSibling(previousFirstChild);        previousFirstChild.setPreviousSibling(newChild);    }    setFirstChild(newChild);}
 void pdfbox_f6646_0(PDOutlineItem newChild)
{    int delta = 1;    if (newChild.isNodeOpen()) {        delta += newChild.getOpenCount();    }    newChild.updateParentOpenCount(delta);}
public boolean pdfbox_f6647_0()
{    return getFirstChild() != null;}
 PDOutlineItem pdfbox_f6648_0(COSName name)
{    COSBase base = getCOSObject().getDictionaryObject(name);    if (base instanceof COSDictionary) {        return new PDOutlineItem((COSDictionary) base);    }    return null;}
public PDOutlineItem pdfbox_f6649_0()
{    return getOutlineItem(COSName.FIRST);}
 void pdfbox_f6650_0(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.FIRST, outlineNode);}
public PDOutlineItem pdfbox_f6651_0()
{    return getOutlineItem(COSName.LAST);}
 void pdfbox_f6652_0(PDOutlineNode outlineNode)
{    getCOSObject().setItem(COSName.LAST, outlineNode);}
public int pdfbox_f6653_0()
{    return getCOSObject().getInt(COSName.COUNT, 0);}
 void pdfbox_f6654_0(int openCount)
{    getCOSObject().setInt(COSName.COUNT, openCount);}
public void pdfbox_f6655_0()
{        if (!isNodeOpen()) {        switchNodeCount();    }}
public void pdfbox_f6656_0()
{    if (isNodeOpen()) {        switchNodeCount();    }}
private void pdfbox_f6657_0()
{    int openCount = getOpenCount();    setOpenCount(-openCount);    updateParentOpenCount(-openCount);}
public boolean pdfbox_f6658_0()
{    return getOpenCount() > 0;}
 void pdfbox_f6659_0(int delta)
{    PDOutlineNode parent = getParent();    if (parent != null) {        if (parent.isNodeOpen()) {            parent.setOpenCount(parent.getOpenCount() + delta);            parent.updateParentOpenCount(delta);        } else {            parent.setOpenCount(parent.getOpenCount() - delta);        }    }}
public Iterable<PDOutlineItem> pdfbox_f6660_0()
{    return () -> new PDOutlineItemIterator(getFirstChild());}
private void pdfbox_f6661_1()
{        if (field.getAcroForm().getDefaultResources() == null) {        return;    }    PDResources acroFormResources = field.getAcroForm().getDefaultResources();    for (PDAnnotationWidget widget : field.getWidgets()) {        if (widget.getNormalAppearanceStream() != null && widget.getNormalAppearanceStream().getResources() != null) {            PDResources widgetResources = widget.getNormalAppearanceStream().getResources();            for (COSName fontResourceName : widgetResources.getFontNames()) {                try {                    if (acroFormResources.getFont(fontResourceName) == null) {                                                acroFormResources.put(fontResourceName, widgetResources.getFont(fontResourceName));                    }                } catch (IOException e) {                                    }            }        }    }}
public void pdfbox_f6662_1(String apValue) throws IOException
{    value = apValue;        if (field instanceof PDTextField && !((PDTextField) field).isMultiline()) {        value = apValue.replaceAll("\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029]", " ");    }    for (PDAnnotationWidget widget : field.getWidgets()) {                        PDDefaultAppearanceString acroFormAppearance = defaultAppearance;        if (widget.getCOSObject().getDictionaryObject(COSName.DA) != null) {            defaultAppearance = getWidgetDefaultAppearanceString(widget);        }        PDRectangle rect = widget.getRectangle();        if (rect == null) {            widget.getCOSObject().removeItem(COSName.AP);                        continue;        }        PDFormFieldAdditionalActions actions = field.getActions();                if (actions == null || actions.getF() == null || widget.getCOSObject().getDictionaryObject(COSName.AP) != null) {            PDAppearanceDictionary appearanceDict = widget.getAppearance();            if (appearanceDict == null) {                appearanceDict = new PDAppearanceDictionary();                widget.setAppearance(appearanceDict);            }            PDAppearanceEntry appearance = appearanceDict.getNormalAppearance();                        PDAppearanceStream appearanceStream;            if (isValidAppearanceStream(appearance)) {                appearanceStream = appearance.getAppearanceStream();            } else {                appearanceStream = prepareNormalAppearanceStream(widget);                appearanceDict.setNormalAppearance(appearanceStream);                        }            /*                 * Adobe Acrobat always recreates the complete appearance stream if there is an appearance characteristics                 * entry (the widget dictionaries MK entry). In addition if there is no content yet also create the appearance                 * stream from the entries.                 *                  */            if (widget.getAppearanceCharacteristics() != null || appearanceStream.getContentStream().getLength() == 0) {                initializeAppearanceContent(widget, appearanceStream);            }            setAppearanceContent(widget, appearanceStream);        }                defaultAppearance = acroFormAppearance;    }}
private static boolean pdfbox_f6663_0(PDAppearanceEntry appearance)
{    if (appearance == null) {        return false;    }    if (!appearance.isStream()) {        return false;    }    PDRectangle bbox = appearance.getAppearanceStream().getBBox();    if (bbox == null) {        return false;    }    return Math.abs(bbox.getWidth()) > 0 && Math.abs(bbox.getHeight()) > 0;}
private PDAppearanceStream pdfbox_f6664_0(PDAnnotationWidget widget)
{    PDAppearanceStream appearanceStream = new PDAppearanceStream(field.getAcroForm().getDocument());            int rotation = resolveRotation(widget);    PDRectangle rect = widget.getRectangle();    Matrix matrix = Matrix.getRotateInstance(Math.toRadians(rotation), 0, 0);    Point2D.Float point2D = matrix.transformPoint(rect.getWidth(), rect.getHeight());    PDRectangle bbox = new PDRectangle(Math.abs((float) point2D.getX()), Math.abs((float) point2D.getY()));    appearanceStream.setBBox(bbox);    AffineTransform at = calculateMatrix(bbox, rotation);    if (!at.isIdentity()) {        appearanceStream.setMatrix(at);    }    appearanceStream.setFormType(1);    appearanceStream.setResources(new PDResources());    return appearanceStream;}
private PDDefaultAppearanceString pdfbox_f6665_0(PDAnnotationWidget widget) throws IOException
{    COSString da = (COSString) widget.getCOSObject().getDictionaryObject(COSName.DA);    PDResources dr = field.getAcroForm().getDefaultResources();    return new PDDefaultAppearanceString(da, dr);}
private int pdfbox_f6666_0(PDAnnotationWidget widget)
{    PDAppearanceCharacteristicsDictionary characteristicsDictionary = widget.getAppearanceCharacteristics();    if (characteristicsDictionary != null) {                return characteristicsDictionary.getRotation();    }    return 0;}
private void pdfbox_f6667_0(PDAnnotationWidget widget, PDAppearanceStream appearanceStream) throws IOException
{    try (ByteArrayOutputStream output = new ByteArrayOutputStream();        PDAppearanceContentStream contents = new PDAppearanceContentStream(appearanceStream, output)) {        PDAppearanceCharacteristicsDictionary appearanceCharacteristics = widget.getAppearanceCharacteristics();                if (appearanceCharacteristics != null) {            PDColor backgroundColour = appearanceCharacteristics.getBackground();            if (backgroundColour != null) {                contents.setNonStrokingColor(backgroundColour);                PDRectangle bbox = resolveBoundingBox(widget, appearanceStream);                contents.addRect(bbox.getLowerLeftX(), bbox.getLowerLeftY(), bbox.getWidth(), bbox.getHeight());                contents.fill();            }            float lineWidth = 0f;            PDColor borderColour = appearanceCharacteristics.getBorderColour();            if (borderColour != null) {                contents.setStrokingColor(borderColour);                lineWidth = 1f;            }            PDBorderStyleDictionary borderStyle = widget.getBorderStyle();            if (borderStyle != null && borderStyle.getWidth() > 0) {                lineWidth = borderStyle.getWidth();            }            if (lineWidth > 0 && borderColour != null) {                if (Float.compare(lineWidth, 1) != 0) {                    contents.setLineWidth(lineWidth);                }                PDRectangle bbox = resolveBoundingBox(widget, appearanceStream);                PDRectangle clipRect = applyPadding(bbox, Math.max(DEFAULT_PADDING, lineWidth / 2));                contents.addRect(clipRect.getLowerLeftX(), clipRect.getLowerLeftY(), clipRect.getWidth(), clipRect.getHeight());                contents.closeAndStroke();            }        }        writeToStream(output.toByteArray(), appearanceStream);    }}
private List<Object> pdfbox_f6668_0(PDAppearanceStream appearanceStream) throws IOException
{    PDFStreamParser parser = new PDFStreamParser(appearanceStream.getContents());    parser.parse();    return parser.getTokens();}
private void pdfbox_f6669_0(PDAnnotationWidget widget, PDAppearanceStream appearanceStream) throws IOException
{            defaultAppearance.copyNeededResourcesTo(appearanceStream);        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {        ContentStreamWriter writer = new ContentStreamWriter(output);        List<Object> tokens = tokenize(appearanceStream);        int bmcIndex = tokens.indexOf(BMC);        if (bmcIndex == -1) {                        writer.writeTokens(tokens);            writer.writeTokens(COSName.TX, BMC);        } else {                        writer.writeTokens(tokens.subList(0, bmcIndex + 1));        }                insertGeneratedAppearance(widget, appearanceStream, output);        int emcIndex = tokens.indexOf(EMC);        if (emcIndex == -1) {                        writer.writeTokens(EMC);        } else {                        writer.writeTokens(tokens.subList(emcIndex, tokens.size()));        }        writeToStream(output.toByteArray(), appearanceStream);    }}
private AffineTransform pdfbox_f6671_0(PDRectangle bbox, int rotation)
{    if (rotation == 0) {        return new AffineTransform();    }    float tx = 0, ty = 0;    switch(rotation) {        case 90:            tx = bbox.getUpperRightY();            break;        case 180:            tx = bbox.getUpperRightY();            ty = bbox.getUpperRightX();            break;        case 270:            ty = bbox.getUpperRightX();            break;        default:            break;    }    Matrix matrix = Matrix.getRotateInstance(Math.toRadians(rotation), tx, ty);    return matrix.createAffineTransform();}
private boolean pdfbox_f6672_0()
{    return field instanceof PDTextField && ((PDTextField) field).isMultiline();}
private boolean pdfbox_f6673_0()
{    return field instanceof PDTextField && ((PDTextField) field).isComb() && !((PDTextField) field).isMultiline() && !((PDTextField) field).isPassword() && !((PDTextField) field).isFileSelect();}
private void pdfbox_f6674_0(PDAppearanceContentStream contents, PDAppearanceStream appearanceStream, PDFont font, float fontSize) throws IOException
{            int maxLen = ((PDTextField) field).getMaxLen();    int numChars = Math.min(value.length(), maxLen);    PDRectangle paddingEdge = applyPadding(appearanceStream.getBBox(), 1);    float combWidth = appearanceStream.getBBox().getWidth() / maxLen;    float ascentAtFontSize = font.getFontDescriptor().getAscent() / FONTSCALE * fontSize;    float baselineOffset = paddingEdge.getLowerLeftY() + (appearanceStream.getBBox().getHeight() - ascentAtFontSize) / 2;    float prevCharWidth = 0f;    float xOffset = combWidth / 2;    for (int i = 0; i < numChars; i++) {        String combString = value.substring(i, i + 1);        float currCharWidth = font.getStringWidth(combString) / FONTSCALE * fontSize / 2;        xOffset = xOffset + prevCharWidth / 2 - currCharWidth / 2;        contents.newLineAtOffset(xOffset, baselineOffset);        contents.showText(combString);        baselineOffset = 0;        prevCharWidth = currCharWidth;        xOffset = combWidth;    }}
private void pdfbox_f6675_0(PDAppearanceContentStream contents, PDAppearanceStream appearanceStream, PDFont font, float fontSize) throws IOException
{    List<Integer> indexEntries = ((PDListBox) field).getSelectedOptionsIndex();    List<String> values = ((PDListBox) field).getValue();    List<String> options = ((PDListBox) field).getOptionsExportValues();    if (!values.isEmpty() && !options.isEmpty() && indexEntries.isEmpty()) {                indexEntries = new ArrayList<>();        for (String v : values) {            indexEntries.add(options.indexOf(v));        }    }                int topIndex = ((PDListBox) field).getTopIndex();    float highlightBoxHeight = font.getBoundingBox().getHeight() * fontSize / FONTSCALE;        PDRectangle paddingEdge = applyPadding(appearanceStream.getBBox(), 1);    for (int selectedIndex : indexEntries) {        contents.setNonStrokingColor(HIGHLIGHT_COLOR[0], HIGHLIGHT_COLOR[1], HIGHLIGHT_COLOR[2]);        contents.addRect(paddingEdge.getLowerLeftX(), paddingEdge.getUpperRightY() - highlightBoxHeight * (selectedIndex - topIndex + 1) + 2, paddingEdge.getWidth(), highlightBoxHeight);        contents.fill();    }    contents.setNonStrokingColor(0);}
private void pdfbox_f6676_0(PDAppearanceContentStream contents, PDAppearanceStream appearanceStream, PDRectangle contentRect, PDFont font, float fontSize) throws IOException
{    contents.setNonStrokingColor(0);    int q = field.getQ();    if (q == PDVariableText.QUADDING_CENTERED || q == PDVariableText.QUADDING_RIGHT) {        float fieldWidth = appearanceStream.getBBox().getWidth();        float stringWidth = (font.getStringWidth(value) / FONTSCALE) * fontSize;        float adjustAmount = fieldWidth - stringWidth - 4;        if (q == PDVariableText.QUADDING_CENTERED) {            adjustAmount = adjustAmount / 2.0f;        }        contents.newLineAtOffset(adjustAmount, 0);    } else if (q != PDVariableText.QUADDING_LEFT) {        throw new IOException("Error: Unknown justification value:" + q);    }    List<String> options = ((PDListBox) field).getOptionsDisplayValues();    int numOptions = options.size();    float yTextPos = contentRect.getUpperRightY();    int topIndex = ((PDListBox) field).getTopIndex();    for (int i = topIndex; i < numOptions; i++) {        if (i == topIndex) {            yTextPos = yTextPos - font.getFontDescriptor().getAscent() / FONTSCALE * fontSize;        } else {            yTextPos = yTextPos - font.getBoundingBox().getHeight() / FONTSCALE * fontSize;            contents.beginText();        }        contents.newLineAtOffset(contentRect.getLowerLeftX(), yTextPos);        contents.showText(options.get(i));        if (i != (numOptions - 1)) {            contents.endText();        }    }}
private void pdfbox_f6677_0(byte[] data, PDAppearanceStream appearanceStream) throws IOException
{    try (OutputStream out = appearanceStream.getCOSObject().createOutputStream()) {        out.write(data);    }}
private float pdfbox_f6678_0(PDFont font, PDRectangle contentRect) throws IOException
{    float fontSize = defaultAppearance.getFontSize();        if (Float.compare(fontSize, 0) == 0) {        if (isMultiLine()) {                        return DEFAULT_FONT_SIZE;        } else {            float yScalingFactor = FONTSCALE * font.getFontMatrix().getScaleY();            float xScalingFactor = FONTSCALE * font.getFontMatrix().getScaleX();                        float width = font.getStringWidth(value) * font.getFontMatrix().getScaleX();            float widthBasedFontSize = contentRect.getWidth() / width * xScalingFactor;                        float height = (font.getFontDescriptor().getCapHeight() + -font.getFontDescriptor().getDescent()) * font.getFontMatrix().getScaleY();            if (height <= 0) {                height = font.getBoundingBox().getHeight() * font.getFontMatrix().getScaleY();            }            float heightBasedFontSize = contentRect.getHeight() / height * yScalingFactor;            return Math.min(heightBasedFontSize, widthBasedFontSize);        }    }    return fontSize;}
private PDRectangle pdfbox_f6679_0(PDAnnotationWidget fieldWidget, PDAppearanceStream appearanceStream)
{    PDRectangle boundingBox = appearanceStream.getBBox();    if (boundingBox == null) {        boundingBox = fieldWidget.getRectangle().createRetranslatedRectangle();    }    return boundingBox;}
private PDRectangle pdfbox_f6680_0(PDRectangle box, float padding)
{    return new PDRectangle(box.getLowerLeftX() + padding, box.getLowerLeftY() + padding, box.getWidth() - 2 * padding, box.getHeight() - 2 * padding);}
 PDFont pdfbox_f6681_0()
{    return font;}
 void pdfbox_f6682_0(PDFont font)
{    this.font = font;}
 float pdfbox_f6683_0()
{    return fontSize;}
 void pdfbox_f6684_0(float fontSize)
{    this.fontSize = fontSize;    leading = fontSize * 1.2f;}
 float pdfbox_f6685_0()
{    return leading;}
 void pdfbox_f6686_0(float leading)
{    this.leading = leading;}
public String pdfbox_f6687_0()
{    return this.key;}
public String pdfbox_f6688_0()
{    return this.value;}
public String pdfbox_f6689_0()
{    return "(" + this.key + ", " + this.value + ")";}
public int pdfbox_f6690_0(KeyValue o1, KeyValue o2)
{    return o1.key.compareTo(o2.key);}
public int pdfbox_f6691_0(KeyValue o1, KeyValue o2)
{    return o1.value.compareTo(o2.value);}
 static List<KeyValue> pdfbox_f6692_0(List<String> key, List<String> value)
{    List<KeyValue> list = new ArrayList<>();    for (int i = 0; i < key.size(); i++) {        list.add(new FieldUtils.KeyValue(key.get(i), value.get(i)));    }    return list;}
 static void pdfbox_f6693_0(List<KeyValue> pairs)
{    Collections.sort(pairs, new FieldUtils.KeyValueValueComparator());}
 static void pdfbox_f6694_0(List<KeyValue> pairs)
{    Collections.sort(pairs, new FieldUtils.KeyValueKeyComparator());}
 static List<String> pdfbox_f6695_0(COSBase items, int pairIdx)
{    if (pairIdx < 0 || pairIdx > 1) {        throw new IllegalArgumentException("Only 0 and 1 are allowed as an index into two-element arrays");    }    if (items instanceof COSString) {        List<String> array = new ArrayList<>();        array.add(((COSString) items).getString());        return array;    } else if (items instanceof COSArray) {        List<String> entryList = new ArrayList<>();        for (COSBase entry : (COSArray) items) {            if (entry instanceof COSString) {                entryList.add(((COSString) entry).getString());            } else if (entry instanceof COSArray) {                COSArray cosArray = (COSArray) entry;                if (cosArray.size() >= pairIdx + 1 && cosArray.get(pairIdx) instanceof COSString) {                    entryList.add(((COSString) cosArray.get(pairIdx)).getString());                }            }        }        return entryList;    }    return Collections.emptyList();}
private void pdfbox_f6696_0()
{    final String adobeDefaultAppearanceString = "/Helv 0 Tf 0 g ";        if (getDefaultAppearance().length() == 0) {        setDefaultAppearance(adobeDefaultAppearanceString);        dictionary.setNeedToBeUpdated(true);    }        PDResources defaultResources = getDefaultResources();    if (defaultResources == null) {        defaultResources = new PDResources();        setDefaultResources(defaultResources);        dictionary.setNeedToBeUpdated(true);    }                            COSDictionary fontDict = defaultResources.getCOSObject().getCOSDictionary(COSName.FONT);    if (fontDict == null) {        fontDict = new COSDictionary();        defaultResources.getCOSObject().setItem(COSName.FONT, fontDict);    }    if (!fontDict.containsKey(COSName.HELV)) {        defaultResources.put(COSName.HELV, PDType1Font.HELVETICA);        defaultResources.getCOSObject().setNeedToBeUpdated(true);        fontDict.setNeedToBeUpdated(true);    }    if (!fontDict.containsKey(COSName.ZA_DB)) {        defaultResources.put(COSName.ZA_DB, PDType1Font.ZAPF_DINGBATS);        defaultResources.getCOSObject().setNeedToBeUpdated(true);        fontDict.setNeedToBeUpdated(true);    }}
 PDDocument pdfbox_f6697_0()
{    return document;}
public COSDictionary pdfbox_f6698_0()
{    return dictionary;}
public void pdfbox_f6699_0(FDFDocument fdf) throws IOException
{    List<FDFField> fields = fdf.getCatalog().getFDF().getFields();    if (fields != null) {        for (FDFField field : fields) {            FDFField fdfField = field;            PDField docField = getField(fdfField.getPartialFieldName());            if (docField != null) {                docField.importFDF(fdfField);            }        }    }}
public FDFDocument pdfbox_f6700_0() throws IOException
{    FDFDocument fdf = new FDFDocument();    FDFCatalog catalog = fdf.getCatalog();    FDFDictionary fdfDict = new FDFDictionary();    catalog.setFDF(fdfDict);    List<FDFField> fdfFields = new ArrayList<>();    List<PDField> fields = getFields();    for (PDField field : fields) {        fdfFields.add(field.exportFDF());    }    fdfDict.setID(document.getDocument().getDocumentID());    if (!fdfFields.isEmpty()) {        fdfDict.setFields(fdfFields);    }    return fdf;}
public void pdfbox_f6701_1() throws IOException
{        if (xfaIsDynamic()) {                return;    }    List<PDField> fields = new ArrayList<>();    for (PDField field : getFieldTree()) {        fields.add(field);    }    flatten(fields, false);}
public void pdfbox_f6702_1(List<PDField> fields, boolean refreshAppearances) throws IOException
{        if (fields.isEmpty()) {        return;    }    if (!refreshAppearances && getNeedAppearances()) {                    }        if (xfaIsDynamic()) {                return;    }        if (refreshAppearances) {        refreshAppearances(fields);    }        PDPageContentStream contentStream;    Map<COSDictionary, Set<COSDictionary>> pagesWidgetsMap = buildPagesWidgetsMap(fields);        for (PDPage page : document.getPages()) {        Set<COSDictionary> widgetsForPageMap = pagesWidgetsMap.get(page.getCOSObject());                        boolean isContentStreamWrapped = false;        List<PDAnnotation> annotations = new ArrayList<>();        for (PDAnnotation annotation : page.getAnnotations()) {            if (widgetsForPageMap != null && !widgetsForPageMap.contains(annotation.getCOSObject())) {                annotations.add(annotation);            } else if (!annotation.isInvisible() && !annotation.isHidden() && annotation.getNormalAppearanceStream() != null && annotation.getNormalAppearanceStream().getBBox() != null) {                contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, true, !isContentStreamWrapped);                isContentStreamWrapped = true;                PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();                PDFormXObject fieldObject = new PDFormXObject(appearanceStream.getCOSObject());                contentStream.saveGraphicsState();                                                boolean needsTranslation = resolveNeedsTranslation(appearanceStream);                                                boolean needsScaling = resolveNeedsScaling(annotation, page.getRotation());                Matrix transformationMatrix = new Matrix();                boolean transformed = false;                if (needsTranslation) {                    transformationMatrix.translate(annotation.getRectangle().getLowerLeftX(), annotation.getRectangle().getLowerLeftY());                    transformed = true;                }                if (needsScaling) {                    PDRectangle bbox = appearanceStream.getBBox();                    PDRectangle fieldRect = annotation.getRectangle();                    float xScale;                    float yScale;                    if (page.getRotation() == 90 || page.getRotation() == 270) {                        xScale = fieldRect.getWidth() / bbox.getHeight();                        yScale = fieldRect.getHeight() / bbox.getWidth();                    } else {                        xScale = fieldRect.getWidth() / bbox.getWidth();                        yScale = fieldRect.getHeight() / bbox.getHeight();                    }                    Matrix scalingMatrix = Matrix.getScaleInstance(xScale, yScale);                    transformationMatrix.concatenate(scalingMatrix);                    transformed = true;                }                if (transformed) {                    contentStream.transform(transformationMatrix);                }                contentStream.drawForm(fieldObject);                contentStream.restoreGraphicsState();                contentStream.close();            }        }        page.setAnnotations(annotations);    }        removeFields(fields);        dictionary.removeItem(COSName.XFA);}
public void pdfbox_f6703_0() throws IOException
{    for (PDField field : getFieldTree()) {        if (field instanceof PDTerminalField) {            ((PDTerminalField) field).constructAppearances();        }    }}
public void pdfbox_f6704_0(List<PDField> fields) throws IOException
{    for (PDField field : fields) {        if (field instanceof PDTerminalField) {            ((PDTerminalField) field).constructAppearances();        }    }}
public List<PDField> pdfbox_f6705_0()
{    COSArray cosFields = (COSArray) dictionary.getDictionaryObject(COSName.FIELDS);    if (cosFields == null) {        return Collections.emptyList();    }    List<PDField> pdFields = new ArrayList<>();    for (int i = 0; i < cosFields.size(); i++) {        COSDictionary element = (COSDictionary) cosFields.getObject(i);        if (element != null) {            PDField field = PDField.fromDictionary(this, element, null);            if (field != null) {                pdFields.add(field);            }        }    }    return new COSArrayList<>(pdFields, cosFields);}
public void pdfbox_f6706_0(List<PDField> fields)
{    dictionary.setItem(COSName.FIELDS, COSArrayList.converterToCOSArray(fields));}
public Iterator<PDField> pdfbox_f6707_0()
{    return new PDFieldTree(this).iterator();}
public PDFieldTree pdfbox_f6708_0()
{    return new PDFieldTree(this);}
public void pdfbox_f6709_0(boolean cache)
{    if (cache) {        fieldCache = new HashMap<>();        for (PDField field : getFieldTree()) {            fieldCache.put(field.getFullyQualifiedName(), field);        }    } else {        fieldCache = null;    }}
public boolean pdfbox_f6710_0()
{    return fieldCache != null;}
public PDField pdfbox_f6711_0(String fullyQualifiedName)
{        if (fieldCache != null) {        return fieldCache.get(fullyQualifiedName);    }        for (PDField field : getFieldTree()) {        if (field.getFullyQualifiedName().equals(fullyQualifiedName)) {            return field;        }    }    return null;}
public String pdfbox_f6712_0()
{    return dictionary.getString(COSName.DA, "");}
public void pdfbox_f6713_0(String daValue)
{    dictionary.setString(COSName.DA, daValue);}
public boolean pdfbox_f6714_0()
{    return dictionary.getBoolean(COSName.NEED_APPEARANCES, false);}
public void pdfbox_f6715_0(Boolean value)
{    dictionary.setBoolean(COSName.NEED_APPEARANCES, value);}
public PDResources pdfbox_f6716_0()
{    PDResources retval = null;    COSBase base = dictionary.getDictionaryObject(COSName.DR);    if (base instanceof COSDictionary) {        retval = new PDResources((COSDictionary) base, document.getResourceCache());    }    return retval;}
public void pdfbox_f6717_0(PDResources dr)
{    dictionary.setItem(COSName.DR, dr);}
public boolean pdfbox_f6718_0()
{    return dictionary.containsKey(COSName.XFA);}
public boolean pdfbox_f6719_0()
{    return hasXFA() && getFields().isEmpty();}
public PDXFAResource pdfbox_f6720_0()
{    PDXFAResource xfa = null;    COSBase base = dictionary.getDictionaryObject(COSName.XFA);    if (base != null) {        xfa = new PDXFAResource(base);    }    return xfa;}
public void pdfbox_f6721_0(PDXFAResource xfa)
{    dictionary.setItem(COSName.XFA, xfa);}
public int pdfbox_f6722_0()
{    int retval = 0;    COSNumber number = (COSNumber) dictionary.getDictionaryObject(COSName.Q);    if (number != null) {        retval = number.intValue();    }    return retval;}
public void pdfbox_f6723_0(int q)
{    dictionary.setInt(COSName.Q, q);}
public boolean pdfbox_f6724_0()
{    return dictionary.getFlag(COSName.SIG_FLAGS, FLAG_SIGNATURES_EXIST);}
public void pdfbox_f6725_0(boolean signaturesExist)
{    dictionary.setFlag(COSName.SIG_FLAGS, FLAG_SIGNATURES_EXIST, signaturesExist);}
public boolean pdfbox_f6726_0()
{    return dictionary.getFlag(COSName.SIG_FLAGS, FLAG_APPEND_ONLY);}
public void pdfbox_f6727_0(boolean appendOnly)
{    dictionary.setFlag(COSName.SIG_FLAGS, FLAG_APPEND_ONLY, appendOnly);}
private boolean pdfbox_f6728_1(PDAppearanceStream appearanceStream)
{            boolean needsTranslation = true;    PDResources resources = appearanceStream.getResources();    if (resources != null && resources.getXObjectNames().iterator().hasNext()) {        Iterator<COSName> xObjectNames = resources.getXObjectNames().iterator();        while (xObjectNames.hasNext()) {            try {                                                PDXObject xObject = resources.getXObject(xObjectNames.next());                if (xObject instanceof PDFormXObject) {                    PDRectangle bbox = ((PDFormXObject) xObject).getBBox();                    float llX = bbox.getLowerLeftX();                    float llY = bbox.getLowerLeftY();                    if (Float.compare(llX, 0) != 0 && Float.compare(llY, 0) != 0) {                        needsTranslation = false;                    }                }            } catch (IOException e) {                                                            }        }        return needsTranslation;    }    return true;}
private boolean pdfbox_f6729_0(PDAnnotation annotation, int rotation)
{    PDAppearanceStream appearanceStream = annotation.getNormalAppearanceStream();        PDResources resources = appearanceStream.getResources();    if (resources != null && resources.getXObjectNames().iterator().hasNext()) {        return true;    }    PDRectangle bbox = appearanceStream.getBBox();    PDRectangle fieldRect = annotation.getRectangle();    if (rotation == 90 || rotation == 270) {        return Float.compare(bbox.getWidth(), fieldRect.getHeight()) != 0 || Float.compare(bbox.getHeight(), fieldRect.getWidth()) != 0;    } else {        return Float.compare(bbox.getWidth(), fieldRect.getWidth()) != 0 || Float.compare(bbox.getHeight(), fieldRect.getHeight()) != 0;    }}
private Map<COSDictionary, Set<COSDictionary>> pdfbox_f6730_1(List<PDField> fields) throws IOException
{    Map<COSDictionary, Set<COSDictionary>> pagesAnnotationsMap = new HashMap<>();    boolean hasMissingPageRef = false;    for (PDField field : fields) {        List<PDAnnotationWidget> widgets = field.getWidgets();        for (PDAnnotationWidget widget : widgets) {            PDPage page = widget.getPage();            if (page != null) {                fillPagesAnnotationMap(pagesAnnotationsMap, page, widget);            } else {                hasMissingPageRef = true;            }        }    }    if (!hasMissingPageRef) {        return pagesAnnotationsMap;    }                for (PDPage page : document.getPages()) {        for (PDAnnotation annotation : page.getAnnotations()) {            if (annotation instanceof PDAnnotationWidget) {                fillPagesAnnotationMap(pagesAnnotationsMap, page, (PDAnnotationWidget) annotation);            }        }    }    return pagesAnnotationsMap;}
private void pdfbox_f6731_0(Map<COSDictionary, Set<COSDictionary>> pagesAnnotationsMap, PDPage page, PDAnnotationWidget widget)
{    if (pagesAnnotationsMap.get(page.getCOSObject()) == null) {        Set<COSDictionary> widgetsForPage = new HashSet<>();        widgetsForPage.add(widget.getCOSObject());        pagesAnnotationsMap.put(page.getCOSObject(), widgetsForPage);    } else {        Set<COSDictionary> widgetsForPage = pagesAnnotationsMap.get(page.getCOSObject());        widgetsForPage.add(widget.getCOSObject());    }}
private void pdfbox_f6732_0(List<PDField> fields)
{    for (PDField field : fields) {        COSArray array;        if (field.getParent() == null) {                        array = (COSArray) dictionary.getDictionaryObject(COSName.FIELDS);        } else {                        array = (COSArray) field.getParent().getCOSObject().getDictionaryObject(COSName.KIDS);        }        array.removeObject(field.getCOSObject());    }}
public boolean pdfbox_f6733_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_PUSHBUTTON);}
public void pdfbox_f6734_0(boolean pushbutton)
{    getCOSObject().setFlag(COSName.FF, FLAG_PUSHBUTTON, pushbutton);}
public boolean pdfbox_f6735_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_RADIO);}
public void pdfbox_f6736_0(boolean radiobutton)
{    getCOSObject().setFlag(COSName.FF, FLAG_RADIO, radiobutton);}
public String pdfbox_f6737_0()
{    COSBase value = getInheritableAttribute(COSName.V);    if (value instanceof COSName) {        return ((COSName) value).getName();    } else {                return "Off";    }}
public void pdfbox_f6738_0(String value) throws IOException
{    checkValue(value);            boolean hasExportValues = getExportValues().size() > 0;    if (hasExportValues) {        updateByOption(value);    } else {        updateByValue(value);    }    applyChange();}
public String pdfbox_f6739_0()
{    COSBase value = getInheritableAttribute(COSName.DV);    if (value instanceof COSName) {        return ((COSName) value).getName();    } else {        return "";    }}
public void pdfbox_f6740_0(String value)
{    checkValue(value);    getCOSObject().setName(COSName.DV, value);}
public String pdfbox_f6741_0()
{    return getValue();}
public List<String> pdfbox_f6742_0()
{    COSBase value = getInheritableAttribute(COSName.OPT);    if (value instanceof COSString) {        List<String> array = new ArrayList<>();        array.add(((COSString) value).getString());        return array;    } else if (value instanceof COSArray) {        return COSArrayList.convertCOSStringCOSArrayToList((COSArray) value);    }    return Collections.emptyList();}
public void pdfbox_f6743_0(List<String> values)
{    COSArray cosValues;    if (values != null && !values.isEmpty()) {        cosValues = COSArrayList.convertStringListToCOSStringCOSArray(values);        getCOSObject().setItem(COSName.OPT, cosValues);    } else {        getCOSObject().removeItem(COSName.OPT);    }}
 void pdfbox_f6744_0() throws IOException
{    List<String> exportValues = getExportValues();    if (exportValues.size() > 0) {                try {            int optionsIndex = Integer.parseInt(getValue());            if (optionsIndex < exportValues.size()) {                updateByOption(exportValues.get(optionsIndex));            }        } catch (NumberFormatException e) {                        }    } else {        updateByValue(getValue());    }}
public Set<String> pdfbox_f6745_0()
{        Set<String> onValues = new LinkedHashSet<>();    if (getExportValues().size() > 0) {        onValues.addAll(getExportValues());        return onValues;    }    List<PDAnnotationWidget> widgets = this.getWidgets();    for (PDAnnotationWidget widget : widgets) {        onValues.add(getOnValueForWidget(widget));    }    return onValues;}
private String pdfbox_f6746_0(int index)
{    List<PDAnnotationWidget> widgets = this.getWidgets();    if (index < widgets.size()) {        return getOnValueForWidget(widgets.get(index));    }    return "";}
private String pdfbox_f6747_0(PDAnnotationWidget widget)
{    PDAppearanceDictionary apDictionary = widget.getAppearance();    if (apDictionary != null) {        PDAppearanceEntry normalAppearance = apDictionary.getNormalAppearance();        if (normalAppearance != null) {            Set<COSName> entries = normalAppearance.getSubDictionary().keySet();            for (COSName entry : entries) {                if (COSName.Off.compareTo(entry) != 0) {                    return entry.getName();                }            }        }    }    return "";}
 void pdfbox_f6748_0(String value) throws IllegalArgumentException
{    Set<String> onValues = getOnValues();    if (COSName.Off.getName().compareTo(value) != 0 && !onValues.contains(value)) {        throw new IllegalArgumentException("value '" + value + "' is not a valid option for the field " + getFullyQualifiedName() + ", valid values are: " + onValues + " and " + COSName.Off.getName());    }}
private void pdfbox_f6749_0(String value)
{    getCOSObject().setName(COSName.V, value);        for (PDAnnotationWidget widget : getWidgets()) {        if (widget.getAppearance() == null) {            continue;        }        PDAppearanceEntry appearanceEntry = widget.getAppearance().getNormalAppearance();        if (appearanceEntry.getCOSObject().containsKey(value)) {            widget.setAppearanceState(value);        } else {            widget.setAppearanceState(COSName.Off.getName());        }    }}
private void pdfbox_f6750_0(String value)
{    List<PDAnnotationWidget> widgets = getWidgets();    List<String> options = getExportValues();    if (widgets.size() != options.size()) {        throw new IllegalArgumentException("The number of options doesn't match the number of widgets");    }    if (value.equals(COSName.Off.getName())) {        updateByValue(value);    } else {                int optionsIndex = options.indexOf(value);                if (optionsIndex != -1) {            updateByValue(getOnValue(optionsIndex));        }    }}
public boolean pdfbox_f6751_0()
{    return getValue().compareTo(getOnValue()) == 0;}
public void pdfbox_f6752_0() throws IOException
{    setValue(getOnValue());}
public void pdfbox_f6753_0() throws IOException
{    setValue(COSName.Off.getName());}
public String pdfbox_f6754_0()
{    PDAnnotationWidget widget = this.getWidgets().get(0);    PDAppearanceDictionary apDictionary = widget.getAppearance();    String onValue = "";    if (apDictionary != null) {        PDAppearanceEntry normalAppearance = apDictionary.getNormalAppearance();        if (normalAppearance != null) {            Set<COSName> entries = normalAppearance.getSubDictionary().keySet();            for (COSName entry : entries) {                if (COSName.Off.compareTo(entry) != 0) {                    onValue = entry.getName();                }            }        }    }    return onValue;}
public List<String> pdfbox_f6755_0()
{    COSBase values = getCOSObject().getDictionaryObject(COSName.OPT);    return FieldUtils.getPairableItems(values, 0);}
public void pdfbox_f6756_0(List<String> displayValues)
{    if (displayValues != null && !displayValues.isEmpty()) {        if (isSort()) {            Collections.sort(displayValues);        }        getCOSObject().setItem(COSName.OPT, COSArrayList.convertStringListToCOSStringCOSArray(displayValues));    } else {        getCOSObject().removeItem(COSName.OPT);    }}
public void pdfbox_f6757_0(List<String> exportValues, List<String> displayValues)
{    if (exportValues != null && displayValues != null && !exportValues.isEmpty() && !displayValues.isEmpty()) {        if (exportValues.size() != displayValues.size()) {            throw new IllegalArgumentException("The number of entries for exportValue and displayValue shall be the same.");        } else {            List<KeyValue> keyValuePairs = FieldUtils.toKeyValueList(exportValues, displayValues);            if (isSort()) {                FieldUtils.sortByValue(keyValuePairs);            }            COSArray options = new COSArray();            for (int i = 0; i < exportValues.size(); i++) {                COSArray entry = new COSArray();                entry.add(new COSString(keyValuePairs.get(i).getKey()));                entry.add(new COSString(keyValuePairs.get(i).getValue()));                options.add(entry);            }            getCOSObject().setItem(COSName.OPT, options);        }    } else {        getCOSObject().removeItem(COSName.OPT);    }}
public List<String> pdfbox_f6758_0()
{    COSBase values = getCOSObject().getDictionaryObject(COSName.OPT);    return FieldUtils.getPairableItems(values, 1);}
public List<String> pdfbox_f6759_0()
{    return getOptions();}
public List<Integer> pdfbox_f6760_0()
{    COSBase value = getCOSObject().getDictionaryObject(COSName.I);    if (value instanceof COSArray) {        return COSArrayList.convertIntegerCOSArrayToList((COSArray) value);    }    return Collections.emptyList();}
public void pdfbox_f6761_0(List<Integer> values)
{    if (values != null && !values.isEmpty()) {        if (!isMultiSelect()) {            throw new IllegalArgumentException("Setting the indices is not allowed for choice fields not allowing multiple selections.");        }        getCOSObject().setItem(COSName.I, COSArrayList.converterToCOSArray(values));    } else {        getCOSObject().removeItem(COSName.I);    }}
public boolean pdfbox_f6762_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_SORT);}
public void pdfbox_f6763_0(boolean sort)
{    getCOSObject().setFlag(COSName.FF, FLAG_SORT, sort);}
public boolean pdfbox_f6764_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_MULTI_SELECT);}
public void pdfbox_f6765_0(boolean multiSelect)
{    getCOSObject().setFlag(COSName.FF, FLAG_MULTI_SELECT, multiSelect);}
public boolean pdfbox_f6766_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK);}
public void pdfbox_f6767_0(boolean doNotSpellCheck)
{    getCOSObject().setFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK, doNotSpellCheck);}
public boolean pdfbox_f6768_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_COMMIT_ON_SEL_CHANGE);}
public void pdfbox_f6769_0(boolean commitOnSelChange)
{    getCOSObject().setFlag(COSName.FF, FLAG_COMMIT_ON_SEL_CHANGE, commitOnSelChange);}
public boolean pdfbox_f6770_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_COMBO);}
public void pdfbox_f6771_0(boolean combo)
{    getCOSObject().setFlag(COSName.FF, FLAG_COMBO, combo);}
public void pdfbox_f6772_0(String value) throws IOException
{    getCOSObject().setString(COSName.V, value);        setSelectedOptionsIndex(null);    applyChange();}
public void pdfbox_f6773_0(String value)
{    getCOSObject().setString(COSName.DV, value);}
public void pdfbox_f6774_0(List<String> values) throws IOException
{    if (values != null && !values.isEmpty()) {        if (!isMultiSelect()) {            throw new IllegalArgumentException("The list box does not allow multiple selections.");        }        if (!getOptions().containsAll(values)) {            throw new IllegalArgumentException("The values are not contained in the selectable options.");        }        getCOSObject().setItem(COSName.V, COSArrayList.convertStringListToCOSStringCOSArray(values));        updateSelectedOptionsIndex(values);    } else {        getCOSObject().removeItem(COSName.V);        getCOSObject().removeItem(COSName.I);    }    applyChange();}
public List<String> pdfbox_f6775_0()
{    return getValueFor(COSName.V);}
public List<String> pdfbox_f6776_0()
{    return getValueFor(COSName.DV);}
private List<String> pdfbox_f6777_0(COSName name)
{    COSBase value = getCOSObject().getDictionaryObject(name);    if (value instanceof COSString) {        List<String> array = new ArrayList<>();        array.add(((COSString) value).getString());        return array;    } else if (value instanceof COSArray) {        return COSArrayList.convertCOSStringCOSArrayToList((COSArray) value);    }    return Collections.emptyList();}
public String pdfbox_f6778_0()
{    return Arrays.toString(getValue().toArray());}
private void pdfbox_f6779_0(List<String> values)
{    List<String> options = getOptions();    List<Integer> indices = new ArrayList<>();    for (String value : values) {        indices.add(options.indexOf(value));    }        Collections.sort(indices);    setSelectedOptionsIndex(indices);}
public boolean pdfbox_f6780_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_EDIT);}
public void pdfbox_f6781_0(boolean edit)
{    getCOSObject().setFlag(COSName.FF, FLAG_EDIT, edit);}
 void pdfbox_f6782_0() throws IOException
{    AppearanceGeneratorHelper apHelper;    apHelper = new AppearanceGeneratorHelper(this);    List<String> values = getValue();    if (!values.isEmpty()) {        apHelper.setAppearanceValue(values.get(0));    } else {        apHelper.setAppearanceValue("");    }}
private void pdfbox_f6783_0(byte[] content) throws IOException
{    List<COSBase> arguments = new ArrayList<>();    PDFStreamParser parser = new PDFStreamParser(content);    Object token = parser.parseNextToken();    while (token != null) {        if (token instanceof COSObject) {            arguments.add(((COSObject) token).getObject());        } else if (token instanceof Operator) {            processOperator((Operator) token, arguments);            arguments = new ArrayList<>();        } else {            arguments.add((COSBase) token);        }        token = parser.parseNextToken();    }}
private void pdfbox_f6784_0(Operator operator, List<COSBase> operands) throws IOException
{    switch(operator.getName()) {        case OperatorName.SET_FONT_AND_SIZE:            processSetFont(operands);            break;        case OperatorName.NON_STROKING_GRAY:        case OperatorName.NON_STROKING_RGB:        case OperatorName.NON_STROKING_CMYK:            processSetFontColor(operands);            break;        default:            break;    }}
private void pdfbox_f6785_0(List<COSBase> operands) throws IOException
{    if (operands.size() < 2) {        throw new IOException("Missing operands for set font operator " + Arrays.toString(operands.toArray()));    }    COSBase base0 = operands.get(0);    COSBase base1 = operands.get(1);    if (!(base0 instanceof COSName)) {        return;    }    if (!(base1 instanceof COSNumber)) {        return;    }    COSName fontName = (COSName) base0;    PDFont font = defaultResources.getFont(fontName);    float fontSize = ((COSNumber) base1).floatValue();        if (font == null) {        throw new IOException("Could not find font: /" + fontName.getName());    }    setFontName(fontName);    setFont(font);    setFontSize(fontSize);}
private void pdfbox_f6786_0(List<COSBase> operands) throws IOException
{    PDColorSpace colorSpace;    switch(operands.size()) {        case 1:            colorSpace = PDDeviceGray.INSTANCE;            break;        case 3:            colorSpace = PDDeviceRGB.INSTANCE;            break;        case 4:            colorSpace = PDDeviceCMYK.INSTANCE;            break;        default:            throw new IOException("Missing operands for set non stroking color operator " + Arrays.toString(operands.toArray()));    }    COSArray array = new COSArray();    array.addAll(operands);    setFontColor(new PDColor(array, colorSpace));}
 COSName pdfbox_f6787_0()
{    return fontName;}
 void pdfbox_f6788_0(COSName fontName)
{    this.fontName = fontName;}
 PDFont pdfbox_f6789_0() throws IOException
{    return font;}
 void pdfbox_f6790_0(PDFont font)
{    this.font = font;}
public float pdfbox_f6791_0()
{    return fontSize;}
 void pdfbox_f6792_0(float fontSize)
{    this.fontSize = fontSize;}
 PDColor pdfbox_f6793_0()
{    return fontColor;}
 void pdfbox_f6794_0(PDColor fontColor)
{    this.fontColor = fontColor;}
 void pdfbox_f6795_0(PDAppearanceContentStream contents, float zeroFontSize) throws IOException
{    float fontSize = getFontSize();    if (Float.compare(fontSize, 0) == 0) {        fontSize = zeroFontSize;    }    contents.setFont(getFont(), fontSize);    if (getFontColor() != null) {        contents.setNonStrokingColor(getFontColor());    }}
 void pdfbox_f6796_0(PDAppearanceStream appearanceStream) throws IOException
{        PDResources streamResources = appearanceStream.getResources();    if (streamResources == null) {        streamResources = new PDResources();        appearanceStream.setResources(streamResources);    }    if (streamResources.getFont(fontName) == null) {        streamResources.put(fontName, getFont());    }}
 static PDField pdfbox_f6797_0(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    return PDFieldFactory.createField(form, field, parent);}
protected COSBase pdfbox_f6798_0(COSName key)
{    if (dictionary.containsKey(key)) {        return dictionary.getDictionaryObject(key);    } else if (parent != null) {        return parent.getInheritableAttribute(key);    } else {        return acroForm.getCOSObject().getDictionaryObject(key);    }}
public void pdfbox_f6799_0(boolean readonly)
{    dictionary.setFlag(COSName.FF, FLAG_READ_ONLY, readonly);}
public boolean pdfbox_f6800_0()
{    return dictionary.getFlag(COSName.FF, FLAG_READ_ONLY);}
public void pdfbox_f6801_0(boolean required)
{    dictionary.setFlag(COSName.FF, FLAG_REQUIRED, required);}
public boolean pdfbox_f6802_0()
{    return dictionary.getFlag(COSName.FF, FLAG_REQUIRED);}
public void pdfbox_f6803_0(boolean noExport)
{    dictionary.setFlag(COSName.FF, FLAG_NO_EXPORT, noExport);}
public boolean pdfbox_f6804_0()
{    return dictionary.getFlag(COSName.FF, FLAG_NO_EXPORT);}
public void pdfbox_f6805_0(int flags)
{    dictionary.setInt(COSName.FF, flags);}
public PDFormFieldAdditionalActions pdfbox_f6806_0()
{    COSDictionary aa = (COSDictionary) dictionary.getDictionaryObject(COSName.AA);    if (aa != null) {        return new PDFormFieldAdditionalActions(aa);    }    return null;}
 void pdfbox_f6807_0(FDFField fdfField) throws IOException
{    COSBase fieldValue = fdfField.getCOSValue();    if (fieldValue != null && this instanceof PDTerminalField) {        PDTerminalField currentField = (PDTerminalField) this;        if (fieldValue instanceof COSName) {            currentField.setValue(((COSName) fieldValue).getName());        } else if (fieldValue instanceof COSString) {            currentField.setValue(((COSString) fieldValue).getString());        } else if (fieldValue instanceof COSStream) {            currentField.setValue(((COSStream) fieldValue).toTextString());        } else if (fieldValue instanceof COSArray && this instanceof PDChoice) {            ((PDChoice) this).setValue(COSArrayList.convertCOSStringCOSArrayToList((COSArray) fieldValue));        } else {            throw new IOException("Error:Unknown type for field import" + fieldValue);        }    } else if (fieldValue != null) {        dictionary.setItem(COSName.V, fieldValue);    }    Integer ff = fdfField.getFieldFlags();    if (ff != null) {        setFieldFlags(ff);    } else {                Integer setFf = fdfField.getSetFieldFlags();        int fieldFlags = getFieldFlags();        if (setFf != null) {            int setFfInt = setFf;            fieldFlags = fieldFlags | setFfInt;            setFieldFlags(fieldFlags);        }        Integer clrFf = fdfField.getClearFieldFlags();        if (clrFf != null) {                                                                                                            int clrFfValue = clrFf;            clrFfValue ^= 0xFFFFFFFF;            fieldFlags = fieldFlags & clrFfValue;            setFieldFlags(fieldFlags);        }    }}
public PDNonTerminalField pdfbox_f6808_0()
{    return parent;}
 PDField pdfbox_f6809_0(String[] name, int nameIndex)
{    PDField retval = null;    COSArray kids = (COSArray) dictionary.getDictionaryObject(COSName.KIDS);    if (kids != null) {        for (int i = 0; retval == null && i < kids.size(); i++) {            COSDictionary kidDictionary = (COSDictionary) kids.getObject(i);            if (name[nameIndex].equals(kidDictionary.getString(COSName.T))) {                retval = PDField.fromDictionary(acroForm, kidDictionary, (PDNonTerminalField) this);                if (retval != null && name.length > nameIndex + 1) {                    retval = retval.findKid(name, nameIndex + 1);                }            }        }    }    return retval;}
public PDAcroForm pdfbox_f6810_0()
{    return acroForm;}
public COSDictionary pdfbox_f6811_0()
{    return dictionary;}
public String pdfbox_f6812_0()
{    return dictionary.getString(COSName.T);}
public void pdfbox_f6813_0(String name)
{    dictionary.setString(COSName.T, name);}
public String pdfbox_f6814_0()
{    String finalName = getPartialName();    String parentName = parent != null ? parent.getFullyQualifiedName() : null;    if (parentName != null) {        if (finalName != null) {            finalName = parentName + "." + finalName;        } else {            finalName = parentName;        }    }    return finalName;}
public String pdfbox_f6815_0()
{    return dictionary.getString(COSName.TU);}
public void pdfbox_f6816_0(String alternateFieldName)
{    dictionary.setString(COSName.TU, alternateFieldName);}
public String pdfbox_f6817_0()
{    return dictionary.getString(COSName.TM);}
public void pdfbox_f6818_0(String mappingName)
{    dictionary.setString(COSName.TM, mappingName);}
public String pdfbox_f6819_0()
{    return getFullyQualifiedName() + "{type: " + getClass().getSimpleName() + " value: " + getInheritableAttribute(COSName.V) + "}";}
 static PDField pdfbox_f6820_0(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    String fieldType = findFieldType(field);        if (field.containsKey(COSName.KIDS)) {        COSArray kids = (COSArray) field.getDictionaryObject(COSName.KIDS);        if (kids != null && kids.size() > 0) {            for (int i = 0; i < kids.size(); i++) {                COSBase kid = kids.getObject(i);                if (kid instanceof COSDictionary && ((COSDictionary) kid).getString(COSName.T) != null) {                    return new PDNonTerminalField(form, field, parent);                }            }        }    }    if (FIELD_TYPE_CHOICE.equals(fieldType)) {        return createChoiceSubType(form, field, parent);    } else if (FIELD_TYPE_TEXT.equals(fieldType)) {        return new PDTextField(form, field, parent);    } else if (FIELD_TYPE_SIGNATURE.equals(fieldType)) {        return new PDSignatureField(form, field, parent);    } else if (FIELD_TYPE_BUTTON.equals(fieldType)) {        return createButtonSubType(form, field, parent);    } else {                return null;    }}
private static PDField pdfbox_f6821_0(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    int flags = field.getInt(COSName.FF, 0);    if ((flags & PDChoice.FLAG_COMBO) != 0) {        return new PDComboBox(form, field, parent);    } else {        return new PDListBox(form, field, parent);    }}
private static PDField pdfbox_f6822_0(PDAcroForm form, COSDictionary field, PDNonTerminalField parent)
{    int flags = field.getInt(COSName.FF, 0);        if ((flags & PDButton.FLAG_RADIO) != 0) {        return new PDRadioButton(form, field, parent);    } else if ((flags & PDButton.FLAG_PUSHBUTTON) != 0) {        return new PDPushButton(form, field, parent);    } else {        return new PDCheckBox(form, field, parent);    }}
private static String pdfbox_f6823_0(COSDictionary dic)
{    String retval = dic.getNameAsString(COSName.FT);    if (retval == null) {        COSBase base = dic.getDictionaryObject(COSName.PARENT, COSName.P);        if (base instanceof COSDictionary) {            retval = findFieldType((COSDictionary) base);        }    }    return retval;}
public Iterator<PDField> pdfbox_f6824_0()
{    return new FieldIterator(acroForm);}
public boolean pdfbox_f6825_0()
{    return !queue.isEmpty();}
public PDField pdfbox_f6826_0()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    return queue.poll();}
public void pdfbox_f6827_0()
{    throw new UnsupportedOperationException();}
private void pdfbox_f6828_0(PDField node)
{    queue.add(node);    if (node instanceof PDNonTerminalField) {        List<PDField> kids = ((PDNonTerminalField) node).getChildren();        for (PDField kid : kids) {            enqueueKids(kid);        }    }}
public int pdfbox_f6829_0()
{    return getCOSObject().getInt(COSName.TI, 0);}
public void pdfbox_f6830_0(Integer topIndex)
{    if (topIndex != null) {        getCOSObject().setInt(COSName.TI, topIndex);    } else {        getCOSObject().removeItem(COSName.TI);    }}
 void pdfbox_f6831_0() throws IOException
{    AppearanceGeneratorHelper apHelper;    apHelper = new AppearanceGeneratorHelper(this);    apHelper.setAppearanceValue("");}
public int pdfbox_f6832_0()
{    int retval = 0;    COSInteger ff = (COSInteger) getCOSObject().getDictionaryObject(COSName.FF);    if (ff != null) {        retval = ff.intValue();    }        return retval;}
 void pdfbox_f6833_0(FDFField fdfField) throws IOException
{    super.importFDF(fdfField);    List<FDFField> fdfKids = fdfField.getKids();    List<PDField> children = getChildren();    for (int i = 0; fdfKids != null && i < fdfKids.size(); i++) {        for (COSObjectable pdKid : children) {            if (pdKid instanceof PDField) {                PDField pdChild = (PDField) pdKid;                FDFField fdfChild = fdfKids.get(i);                String fdfName = fdfChild.getPartialFieldName();                if (fdfName != null && fdfName.equals(pdChild.getPartialName())) {                    pdChild.importFDF(fdfChild);                }            }        }    }}
 FDFField pdfbox_f6834_0() throws IOException
{    FDFField fdfField = new FDFField();    fdfField.setPartialFieldName(getPartialName());    fdfField.setValue(getValue());    List<PDField> children = getChildren();    List<FDFField> fdfChildren = new ArrayList<>();    for (PDField child : children) {        fdfChildren.add(child.exportFDF());    }    fdfField.setKids(fdfChildren);    return fdfField;}
public List<PDField> pdfbox_f6835_1()
{        List<PDField> children = new ArrayList<>();    COSArray kids = (COSArray) getCOSObject().getDictionaryObject(COSName.KIDS);    for (int i = 0; i < kids.size(); i++) {        COSBase kid = kids.getObject(i);        if (kid instanceof COSDictionary) {            if (kid.getCOSObject() == this.getCOSObject()) {                                continue;            }            PDField field = PDField.fromDictionary(getAcroForm(), (COSDictionary) kid, this);            if (field != null) {                children.add(field);            }        }    }    return children;}
public void pdfbox_f6836_0(List<PDField> children)
{    COSArray kidsArray = COSArrayList.converterToCOSArray(children);    getCOSObject().setItem(COSName.KIDS, kidsArray);}
public String pdfbox_f6837_0()
{    return getCOSObject().getNameAsString(COSName.FT);}
public COSBase pdfbox_f6838_0()
{    return getCOSObject().getDictionaryObject(COSName.V);}
public String pdfbox_f6839_0()
{    COSBase fieldValue = getCOSObject().getDictionaryObject(COSName.V);    return fieldValue != null ? fieldValue.toString() : "";}
public void pdfbox_f6840_0(COSBase object) throws IOException
{    getCOSObject().setItem(COSName.V, object);}
public void pdfbox_f6841_0(String value) throws IOException
{    getCOSObject().setString(COSName.V, value);}
public COSBase pdfbox_f6842_0()
{    return getCOSObject().getDictionaryObject(COSName.DV);}
public void pdfbox_f6843_0(COSBase value)
{    getCOSObject().setItem(COSName.V, value);}
public List<PDAnnotationWidget> pdfbox_f6844_0()
{    List<PDAnnotationWidget> emptyList = Collections.emptyList();    return Collections.unmodifiableList(emptyList);}
public List<String> pdfbox_f6845_0()
{    return Collections.emptyList();}
public void pdfbox_f6846_0(List<String> values)
{    if (values != null && !values.isEmpty()) {        throw new IllegalArgumentException("A PDPushButton shall not use the Opt entry in the field dictionary");    }}
public String pdfbox_f6847_0()
{    return "";}
public String pdfbox_f6848_0()
{    return "";}
public String pdfbox_f6849_0()
{    return getValue();}
 void pdfbox_f6850_0() throws IOException
{}
public void pdfbox_f6851_0(boolean radiosInUnison)
{    getCOSObject().setFlag(COSName.FF, FLAG_RADIOS_IN_UNISON, radiosInUnison);}
public boolean pdfbox_f6852_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_RADIOS_IN_UNISON);}
public List<String> pdfbox_f6853_0()
{    Set<String> onValues = getOnValues();    List<String> exportValues = getExportValues();    List<String> selectedExportValues = new ArrayList<>();    if (exportValues.isEmpty()) {        selectedExportValues.add(getValue());        return selectedExportValues;    } else {        String fieldValue = getValue();        int idx = 0;        for (String onValue : onValues) {            if (onValue.compareTo(fieldValue) == 0) {                selectedExportValues.add(exportValues.get(idx));            }        }        return selectedExportValues;    }}
private String pdfbox_f6854_0()
{    String fieldName = "Signature";    Set<String> sigNames = new HashSet<>();    for (PDField field : getAcroForm().getFieldTree()) {        if (field instanceof PDSignatureField) {            sigNames.add(field.getPartialName());        }    }    int i = 1;    while (sigNames.contains(fieldName + i)) {        ++i;    }    return fieldName + i;}
public void pdfbox_f6855_0(PDSignature value) throws IOException
{    setValue(value);}
public PDSignature pdfbox_f6856_0()
{    return getValue();}
public void pdfbox_f6857_0(PDSignature value) throws IOException
{    getCOSObject().setItem(COSName.V, value);    applyChange();}
public void pdfbox_f6858_0(String value) throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Signature fields don't support setting the value as String " + "- use setValue(PDSignature value) instead");}
public void pdfbox_f6859_0(PDSignature value)
{    getCOSObject().setItem(COSName.DV, value);}
public PDSignature pdfbox_f6860_0()
{    COSBase value = getCOSObject().getDictionaryObject(COSName.V);    if (value instanceof COSDictionary) {        return new PDSignature((COSDictionary) value);    }    return null;}
public PDSignature pdfbox_f6861_0()
{    COSBase value = getCOSObject().getDictionaryObject(COSName.DV);    if (value == null) {        return null;    }    return new PDSignature((COSDictionary) value);}
public String pdfbox_f6862_0()
{    PDSignature signature = getValue();    return signature != null ? signature.toString() : "";}
public PDSeedValue pdfbox_f6863_0()
{    COSDictionary dict = (COSDictionary) getCOSObject().getDictionaryObject(COSName.SV);    PDSeedValue sv = null;    if (dict != null) {        sv = new PDSeedValue(dict);    }    return sv;}
public void pdfbox_f6864_0(PDSeedValue sv)
{    if (sv != null) {        getCOSObject().setItem(COSName.SV, sv);    }}
 void pdfbox_f6865_1() throws IOException
{    PDAnnotationWidget widget = this.getWidgets().get(0);    if (widget != null) {                if (widget.getRectangle() == null || Float.compare(widget.getRectangle().getHeight(), 0) == 0 && Float.compare(widget.getRectangle().getWidth(), 0) == 0 || widget.isNoView() || widget.isHidden()) {            return;        }                    }}
public void pdfbox_f6866_0(PDFormFieldAdditionalActions actions)
{    getCOSObject().setItem(COSName.AA, actions);}
public int pdfbox_f6867_0()
{    int retval = 0;    COSInteger ff = (COSInteger) getCOSObject().getDictionaryObject(COSName.FF);    if (ff != null) {        retval = ff.intValue();    } else if (getParent() != null) {        retval = getParent().getFieldFlags();    }    return retval;}
public String pdfbox_f6868_0()
{    String fieldType = getCOSObject().getNameAsString(COSName.FT);    if (fieldType == null && getParent() != null) {        fieldType = getParent().getFieldType();    }    return fieldType;}
public void pdfbox_f6869_0(FDFField fdfField) throws IOException
{    super.importFDF(fdfField);        PDAnnotationWidget widget = getWidgets().get(0);    if (widget != null) {        int annotFlags = widget.getAnnotationFlags();        Integer f = fdfField.getWidgetFieldFlags();        if (f != null) {            widget.setAnnotationFlags(f);        } else {                        Integer setF = fdfField.getSetWidgetFieldFlags();            if (setF != null) {                annotFlags = annotFlags | setF;                widget.setAnnotationFlags(annotFlags);            }            Integer clrF = fdfField.getClearWidgetFieldFlags();            if (clrF != null) {                                                                                                                                                int clrFValue = clrF;                clrFValue ^= 0xFFFFFFFFL;                annotFlags = annotFlags & clrFValue;                widget.setAnnotationFlags(annotFlags);            }        }    }}
 FDFField pdfbox_f6870_0() throws IOException
{    FDFField fdfField = new FDFField();    fdfField.setPartialFieldName(getPartialName());    fdfField.setValue(getCOSObject().getDictionaryObject(COSName.V));    return fdfField;}
public List<PDAnnotationWidget> pdfbox_f6871_0()
{    List<PDAnnotationWidget> widgets = new ArrayList<>();    COSArray kids = (COSArray) getCOSObject().getDictionaryObject(COSName.KIDS);    if (kids == null) {                widgets.add(new PDAnnotationWidget(getCOSObject()));    } else if (kids.size() > 0) {                for (int i = 0; i < kids.size(); i++) {            COSBase kid = kids.getObject(i);            if (kid instanceof COSDictionary) {                widgets.add(new PDAnnotationWidget((COSDictionary) kid));            }        }    }    return widgets;}
public void pdfbox_f6872_0(List<PDAnnotationWidget> children)
{    COSArray kidsArray = COSArrayList.converterToCOSArray(children);    getCOSObject().setItem(COSName.KIDS, kidsArray);    for (PDAnnotationWidget widget : children) {        widget.getCOSObject().setItem(COSName.PARENT, this);    }}
public PDAnnotationWidget pdfbox_f6873_0()
{    return getWidgets().get(0);}
protected final void pdfbox_f6874_0() throws IOException
{    constructAppearances();}
public boolean pdfbox_f6875_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_MULTILINE);}
public void pdfbox_f6876_0(boolean multiline)
{    getCOSObject().setFlag(COSName.FF, FLAG_MULTILINE, multiline);}
public boolean pdfbox_f6877_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_PASSWORD);}
public void pdfbox_f6878_0(boolean password)
{    getCOSObject().setFlag(COSName.FF, FLAG_PASSWORD, password);}
public boolean pdfbox_f6879_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_FILE_SELECT);}
public void pdfbox_f6880_0(boolean fileSelect)
{    getCOSObject().setFlag(COSName.FF, FLAG_FILE_SELECT, fileSelect);}
public boolean pdfbox_f6881_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK);}
public void pdfbox_f6882_0(boolean doNotSpellCheck)
{    getCOSObject().setFlag(COSName.FF, FLAG_DO_NOT_SPELL_CHECK, doNotSpellCheck);}
public boolean pdfbox_f6883_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_DO_NOT_SCROLL);}
public void pdfbox_f6884_0(boolean doNotScroll)
{    getCOSObject().setFlag(COSName.FF, FLAG_DO_NOT_SCROLL, doNotScroll);}
public boolean pdfbox_f6885_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_COMB);}
public void pdfbox_f6886_0(boolean comb)
{    getCOSObject().setFlag(COSName.FF, FLAG_COMB, comb);}
public boolean pdfbox_f6887_0()
{    return getCOSObject().getFlag(COSName.FF, FLAG_RICH_TEXT);}
public void pdfbox_f6888_0(boolean richText)
{    getCOSObject().setFlag(COSName.FF, FLAG_RICH_TEXT, richText);}
public int pdfbox_f6889_0()
{    return getCOSObject().getInt(COSName.MAX_LEN);}
public void pdfbox_f6890_0(int maxLen)
{    getCOSObject().setInt(COSName.MAX_LEN, maxLen);}
public void pdfbox_f6891_0(String value) throws IOException
{    getCOSObject().setString(COSName.V, value);    applyChange();}
public void pdfbox_f6892_0(String value)
{    getCOSObject().setString(COSName.DV, value);}
public String pdfbox_f6893_0()
{    return getStringOrStream(getInheritableAttribute(COSName.V));}
public String pdfbox_f6894_0()
{    return getStringOrStream(getInheritableAttribute(COSName.DV));}
public String pdfbox_f6895_0()
{    return getValue();}
 void pdfbox_f6896_0() throws IOException
{    AppearanceGeneratorHelper apHelper;    apHelper = new AppearanceGeneratorHelper(this);    apHelper.setAppearanceValue(getValue());}
public String pdfbox_f6897_0()
{    COSString defaultAppearance = (COSString) getInheritableAttribute(COSName.DA);    return defaultAppearance.getString();}
 PDDefaultAppearanceString pdfbox_f6898_0() throws IOException
{    COSString da = (COSString) getInheritableAttribute(COSName.DA);    PDResources dr = getAcroForm().getDefaultResources();    return new PDDefaultAppearanceString(da, dr);}
public void pdfbox_f6899_0(String daValue)
{    getCOSObject().setString(COSName.DA, daValue);}
public String pdfbox_f6900_0()
{    COSString defaultStyleString = (COSString) getCOSObject().getDictionaryObject(COSName.DS);    return defaultStyleString.getString();}
public void pdfbox_f6901_0(String defaultStyleString)
{    if (defaultStyleString != null) {        getCOSObject().setItem(COSName.DS, new COSString(defaultStyleString));    } else {        getCOSObject().removeItem(COSName.DS);    }}
public int pdfbox_f6902_0()
{    int retval = 0;    COSNumber number = (COSNumber) getInheritableAttribute(COSName.Q);    if (number != null) {        retval = number.intValue();    }    return retval;}
public void pdfbox_f6903_0(int q)
{    getCOSObject().setInt(COSName.Q, q);}
public String pdfbox_f6904_0()
{    return getStringOrStream(getInheritableAttribute(COSName.RV));}
public void pdfbox_f6905_0(String richTextValue)
{    if (richTextValue != null) {        getCOSObject().setItem(COSName.RV, new COSString(richTextValue));    } else {        getCOSObject().removeItem(COSName.RV);    }}
protected final String pdfbox_f6906_0(COSBase base)
{    if (base instanceof COSString) {        return ((COSString) base).getString();    } else if (base instanceof COSStream) {        return ((COSStream) base).toTextString();    }    return "";}
public COSBase pdfbox_f6907_0()
{    return xfa;}
public byte[] pdfbox_f6908_0() throws IOException
{        if (this.getCOSObject() instanceof COSArray) {        return getBytesFromPacket((COSArray) this.getCOSObject());    } else if (xfa.getCOSObject() instanceof COSStream) {        return getBytesFromStream((COSStream) this.getCOSObject());    }    return new byte[0];}
private static byte[] pdfbox_f6909_0(final COSArray cosArray) throws IOException
{    try (final ByteArrayOutputStream baos = new ByteArrayOutputStream()) {        for (int i = 1; i < cosArray.size(); i += 2) {            COSBase cosObj = cosArray.getObject(i);            if (cosObj instanceof COSStream) {                baos.write(getBytesFromStream((COSStream) cosObj.getCOSObject()));            }        }        return baos.toByteArray();    }}
private static byte[] pdfbox_f6910_0(final COSStream stream) throws IOException
{    try (final InputStream is = stream.createInputStream()) {        return IOUtils.toByteArray(is);    }}
public Document pdfbox_f6911_0() throws IOException
{    return     org.apache.pdfbox.util.XMLUtil.parse(new ByteArrayInputStream(this.getBytes()), true);}
 List<Paragraph> pdfbox_f6912_0()
{    return paragraphs;}
 String pdfbox_f6913_0()
{    return textContent;}
 List<Line> pdfbox_f6914_0(PDFont font, float fontSize, float width) throws IOException
{    BreakIterator iterator = BreakIterator.getLineInstance();    iterator.setText(textContent);    final float scale = fontSize / FONTSCALE;    int start = iterator.first();    int end = iterator.next();    float lineWidth = 0;    List<Line> textLines = new ArrayList<>();    Line textLine = new Line();    while (end != BreakIterator.DONE) {        String word = textContent.substring(start, end);        float wordWidth = font.getStringWidth(word) * scale;        lineWidth = lineWidth + wordWidth;                if (lineWidth >= width && Character.isWhitespace(word.charAt(word.length() - 1))) {            float whitespaceWidth = font.getStringWidth(word.substring(word.length() - 1)) * scale;            lineWidth = lineWidth - whitespaceWidth;        }        if (lineWidth >= width) {            textLine.setWidth(textLine.calculateWidth(font, fontSize));            textLines.add(textLine);            textLine = new Line();            lineWidth = font.getStringWidth(word) * scale;        }        AttributedString as = new AttributedString(word);        as.addAttribute(TextAttribute.WIDTH, wordWidth);        Word wordInstance = new Word(word);        wordInstance.setAttributes(as);        textLine.addWord(wordInstance);        start = end;        end = iterator.next();    }    textLine.setWidth(textLine.calculateWidth(font, fontSize));    textLines.add(textLine);    return textLines;}
 float pdfbox_f6915_0()
{    return lineWidth;}
 void pdfbox_f6916_0(float width)
{    lineWidth = width;}
 float pdfbox_f6917_0(PDFont font, float fontSize) throws IOException
{    final float scale = fontSize / FONTSCALE;    float calculatedWidth = 0f;    for (Word word : words) {        calculatedWidth = calculatedWidth + (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);        String text = word.getText();        if (words.indexOf(word) == words.size() - 1 && Character.isWhitespace(text.charAt(text.length() - 1))) {            float whitespaceWidth = font.getStringWidth(text.substring(text.length() - 1)) * scale;            calculatedWidth = calculatedWidth - whitespaceWidth;        }    }    return calculatedWidth;}
 List<Word> pdfbox_f6918_0()
{    return words;}
 float pdfbox_f6919_0(float width)
{    return (width - lineWidth) / (words.size() - 1);}
 void pdfbox_f6920_0(Word word)
{    words.add(word);}
 String pdfbox_f6921_0()
{    return textContent;}
 AttributedString pdfbox_f6922_0()
{    return attributedString;}
 void pdfbox_f6923_0(AttributedString as)
{    this.attributedString = as;}
 int pdfbox_f6924_0()
{    return alignment;}
public static TextAlign pdfbox_f6925_0(int alignment)
{    for (TextAlign textAlignment : TextAlign.values()) {        if (textAlignment.getTextAlign() == alignment) {            return textAlignment;        }    }    return TextAlign.LEFT;}
 Builder pdfbox_f6926_0(AppearanceStyle appearanceStyle)
{    this.appearanceStyle = appearanceStyle;    return this;}
 Builder pdfbox_f6927_0(boolean wrapLines)
{    this.wrapLines = wrapLines;    return this;}
 Builder pdfbox_f6928_0(float width)
{    this.width = width;    return this;}
 Builder pdfbox_f6929_0(int alignment)
{    this.textAlignment = TextAlign.valueOf(alignment);    return this;}
 Builder pdfbox_f6930_0(TextAlign alignment)
{    this.textAlignment = alignment;    return this;}
 Builder pdfbox_f6931_0(PlainText textContent)
{    this.textContent = textContent;    return this;}
 Builder pdfbox_f6932_0(float horizontalOffset, float verticalOffset)
{    this.horizontalOffset = horizontalOffset;    this.verticalOffset = verticalOffset;    return this;}
 PlainTextFormatter pdfbox_f6933_0()
{    return new PlainTextFormatter(this);}
public void pdfbox_f6934_0() throws IOException
{    if (textContent != null && !textContent.getParagraphs().isEmpty()) {        boolean isFirstParagraph = true;        for (Paragraph paragraph : textContent.getParagraphs()) {            if (wrapLines) {                List<Line> lines = paragraph.getLines(appearanceStyle.getFont(), appearanceStyle.getFontSize(), width);                processLines(lines, isFirstParagraph);                isFirstParagraph = false;            } else {                float startOffset = 0f;                float lineWidth = appearanceStyle.getFont().getStringWidth(paragraph.getText()) * appearanceStyle.getFontSize() / FONTSCALE;                if (lineWidth < width) {                    switch(textAlignment) {                        case CENTER:                            startOffset = (width - lineWidth) / 2;                            break;                        case RIGHT:                            startOffset = width - lineWidth;                            break;                        case JUSTIFY:                        default:                            startOffset = 0f;                    }                }                contents.newLineAtOffset(horizontalOffset + startOffset, verticalOffset);                contents.showText(paragraph.getText());            }        }    }}
private void pdfbox_f6935_0(List<Line> lines, boolean isFirstParagraph) throws IOException
{    float wordWidth;    float lastPos = 0f;    float startOffset = 0f;    float interWordSpacing = 0f;    for (Line line : lines) {        switch(textAlignment) {            case CENTER:                startOffset = (width - line.getWidth()) / 2;                break;            case RIGHT:                startOffset = width - line.getWidth();                break;            case JUSTIFY:                if (lines.indexOf(line) != lines.size() - 1) {                    interWordSpacing = line.getInterWordSpacing(width);                }                break;            default:                startOffset = 0f;        }        float offset = -lastPos + startOffset + horizontalOffset;        if (lines.indexOf(line) == 0 && isFirstParagraph) {            contents.newLineAtOffset(offset, verticalOffset);        } else {                        verticalOffset = verticalOffset - appearanceStyle.getLeading();            contents.newLineAtOffset(offset, -appearanceStyle.getLeading());        }        lastPos += offset;        List<Word> words = line.getWords();        for (Word word : words) {            contents.showText(word.getText());            wordWidth = (Float) word.getAttributes().getIterator().getAttribute(TextAttribute.WIDTH);            if (words.indexOf(word) != words.size() - 1) {                contents.newLineAtOffset(wordWidth + interWordSpacing, 0f);                lastPos = lastPos + wordWidth + interWordSpacing;            }        }    }    horizontalOffset = horizontalOffset - lastPos;}
public COSDictionary pdfbox_f6936_0()
{    return this.measureDictionary;}
public String pdfbox_f6937_0()
{    return TYPE;}
public String pdfbox_f6938_0()
{    return this.getCOSObject().getNameAsString(COSName.SUBTYPE, PDRectlinearMeasureDictionary.SUBTYPE);}
protected void pdfbox_f6939_0(String subtype)
{    this.getCOSObject().setName(COSName.SUBTYPE, subtype);}
public COSDictionary pdfbox_f6940_0()
{    return this.numberFormatDictionary;}
public String pdfbox_f6941_0()
{    return TYPE;}
public String pdfbox_f6942_0()
{    return this.getCOSObject().getString("U");}
public void pdfbox_f6943_0(String units)
{    this.getCOSObject().setString("U", units);}
public float pdfbox_f6944_0()
{    return this.getCOSObject().getFloat("C");}
public void pdfbox_f6945_0(float conversionFactor)
{    this.getCOSObject().setFloat("C", conversionFactor);}
public String pdfbox_f6946_0()
{    return this.getCOSObject().getString("F", FRACTIONAL_DISPLAY_DECIMAL);}
public void pdfbox_f6947_0(String fractionalDisplay)
{    if ((fractionalDisplay == null) || FRACTIONAL_DISPLAY_DECIMAL.equals(fractionalDisplay) || FRACTIONAL_DISPLAY_FRACTION.equals(fractionalDisplay) || FRACTIONAL_DISPLAY_ROUND.equals(fractionalDisplay) || FRACTIONAL_DISPLAY_TRUNCATE.equals(fractionalDisplay)) {        this.getCOSObject().setString("F", fractionalDisplay);    } else {        throw new IllegalArgumentException("Value must be \"D\", \"F\", \"R\", or \"T\", (or null).");    }}
public int pdfbox_f6948_0()
{    return this.getCOSObject().getInt("D");}
public void pdfbox_f6949_0(int denominator)
{    this.getCOSObject().setInt("D", denominator);}
public boolean pdfbox_f6950_0()
{    return this.getCOSObject().getBoolean("FD", false);}
public void pdfbox_f6951_0(boolean fd)
{    this.getCOSObject().setBoolean("FD", fd);}
public String pdfbox_f6952_0()
{    return this.getCOSObject().getString("RT", ",");}
public void pdfbox_f6953_0(String thousandsSeparator)
{    this.getCOSObject().setString("RT", thousandsSeparator);}
public String pdfbox_f6954_0()
{    return this.getCOSObject().getString("RD", ".");}
public void pdfbox_f6955_0(String decimalSeparator)
{    this.getCOSObject().setString("RD", decimalSeparator);}
public String pdfbox_f6956_0()
{    return this.getCOSObject().getString("PS", " ");}
public void pdfbox_f6957_0(String labelPrefixString)
{    this.getCOSObject().setString("PS", labelPrefixString);}
public String pdfbox_f6958_0()
{    return this.getCOSObject().getString("SS", " ");}
public void pdfbox_f6959_0(String labelSuffixString)
{    this.getCOSObject().setString("SS", labelSuffixString);}
public String pdfbox_f6960_0()
{    return this.getCOSObject().getString("O", LABEL_SUFFIX_TO_VALUE);}
public void pdfbox_f6961_0(String labelPositionToValue)
{    if ((labelPositionToValue == null) || LABEL_PREFIX_TO_VALUE.equals(labelPositionToValue) || LABEL_SUFFIX_TO_VALUE.equals(labelPositionToValue)) {        this.getCOSObject().setString("O", labelPositionToValue);    } else {        throw new IllegalArgumentException("Value must be \"S\", or \"P\" (or null).");    }}
public String pdfbox_f6962_0()
{    return this.getCOSObject().getString(COSName.R);}
public void pdfbox_f6963_0(String scaleRatio)
{    this.getCOSObject().setString(COSName.R, scaleRatio);}
public PDNumberFormatDictionary[] pdfbox_f6964_0()
{    COSArray x = (COSArray) this.getCOSObject().getDictionaryObject("X");    if (x != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[x.size()];        for (int i = 0; i < x.size(); i++) {            COSDictionary dic = (COSDictionary) x.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
public void pdfbox_f6965_0(PDNumberFormatDictionary[] changeXs)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary changeX : changeXs) {        array.add(changeX);    }    this.getCOSObject().setItem("X", array);}
public PDNumberFormatDictionary[] pdfbox_f6966_0()
{    COSArray y = (COSArray) this.getCOSObject().getDictionaryObject("Y");    if (y != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[y.size()];        for (int i = 0; i < y.size(); i++) {            COSDictionary dic = (COSDictionary) y.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
public void pdfbox_f6967_0(PDNumberFormatDictionary[] changeYs)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary changeY : changeYs) {        array.add(changeY);    }    this.getCOSObject().setItem("Y", array);}
public PDNumberFormatDictionary[] pdfbox_f6968_0()
{    COSArray d = (COSArray) this.getCOSObject().getDictionaryObject("D");    if (d != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[d.size()];        for (int i = 0; i < d.size(); i++) {            COSDictionary dic = (COSDictionary) d.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
public void pdfbox_f6969_0(PDNumberFormatDictionary[] distances)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary distance : distances) {        array.add(distance);    }    this.getCOSObject().setItem("D", array);}
public PDNumberFormatDictionary[] pdfbox_f6970_0()
{    COSArray a = (COSArray) this.getCOSObject().getDictionaryObject(COSName.A);    if (a != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[a.size()];        for (int i = 0; i < a.size(); i++) {            COSDictionary dic = (COSDictionary) a.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
public void pdfbox_f6971_0(PDNumberFormatDictionary[] areas)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary area : areas) {        array.add(area);    }    this.getCOSObject().setItem(COSName.A, array);}
public PDNumberFormatDictionary[] pdfbox_f6972_0()
{    COSArray t = (COSArray) this.getCOSObject().getDictionaryObject("T");    if (t != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[t.size()];        for (int i = 0; i < t.size(); i++) {            COSDictionary dic = (COSDictionary) t.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
public void pdfbox_f6973_0(PDNumberFormatDictionary[] angles)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary angle : angles) {        array.add(angle);    }    this.getCOSObject().setItem("T", array);}
public PDNumberFormatDictionary[] pdfbox_f6974_0()
{    COSArray s = (COSArray) this.getCOSObject().getDictionaryObject("S");    if (s != null) {        PDNumberFormatDictionary[] retval = new PDNumberFormatDictionary[s.size()];        for (int i = 0; i < s.size(); i++) {            COSDictionary dic = (COSDictionary) s.get(i);            retval[i] = new PDNumberFormatDictionary(dic);        }        return retval;    }    return null;}
public void pdfbox_f6975_0(PDNumberFormatDictionary[] lineSloaps)
{    COSArray array = new COSArray();    for (PDNumberFormatDictionary lineSloap : lineSloaps) {        array.add(lineSloap);    }    this.getCOSObject().setItem("S", array);}
public float[] pdfbox_f6976_0()
{    COSArray o = (COSArray) this.getCOSObject().getDictionaryObject("O");    if (o != null) {        return o.toFloatArray();    }    return null;}
public void pdfbox_f6977_0(float[] coordSystemOrigin)
{    COSArray array = new COSArray();    array.setFloatArray(coordSystemOrigin);    this.getCOSObject().setItem("O", array);}
public float pdfbox_f6978_0()
{    return this.getCOSObject().getFloat("CYX");}
public void pdfbox_f6979_0(float cyx)
{    this.getCOSObject().setFloat("CYX", cyx);}
public COSDictionary pdfbox_f6980_0()
{    return this.viewportDictionary;}
public String pdfbox_f6981_0()
{    return TYPE;}
public PDRectangle pdfbox_f6982_0()
{    COSBase bbox = this.getCOSObject().getDictionaryObject(COSName.BBOX);    if (bbox instanceof COSArray) {        return new PDRectangle((COSArray) bbox);    }    return null;}
public void pdfbox_f6983_0(PDRectangle rectangle)
{    this.getCOSObject().setItem(COSName.BBOX, rectangle);}
public String pdfbox_f6984_0()
{    return this.getCOSObject().getNameAsString(COSName.NAME);}
public void pdfbox_f6985_0(String name)
{    this.getCOSObject().setName(COSName.NAME, name);}
public PDMeasureDictionary pdfbox_f6986_0()
{    COSBase base = this.getCOSObject().getDictionaryObject(COSName.MEASURE);    if (base instanceof COSDictionary) {        return new PDMeasureDictionary((COSDictionary) base);    }    return null;}
public void pdfbox_f6987_0(PDMeasureDictionary measure)
{    this.getCOSObject().setItem(COSName.MEASURE, measure);}
public COSDictionary pdfbox_f6988_0()
{    return thread;}
public PDDocumentInformation pdfbox_f6989_0()
{    PDDocumentInformation retval = null;    COSDictionary info = (COSDictionary) thread.getDictionaryObject("I");    if (info != null) {        retval = new PDDocumentInformation(info);    }    return retval;}
public void pdfbox_f6990_0(PDDocumentInformation info)
{    thread.setItem("I", info);}
public PDThreadBead pdfbox_f6991_0()
{    PDThreadBead retval = null;    COSDictionary bead = (COSDictionary) thread.getDictionaryObject("F");    if (bead != null) {        retval = new PDThreadBead(bead);    }    return retval;}
public void pdfbox_f6992_0(PDThreadBead bead)
{    if (bead != null) {        bead.setThread(this);    }    thread.setItem("F", bead);}
public COSDictionary pdfbox_f6993_0()
{    return bead;}
public PDThread pdfbox_f6994_0()
{    PDThread retval = null;    COSDictionary dic = (COSDictionary) bead.getDictionaryObject("T");    if (dic != null) {        retval = new PDThread(dic);    }    return retval;}
public void pdfbox_f6995_0(PDThread thread)
{    bead.setItem("T", thread);}
public PDThreadBead pdfbox_f6996_0()
{    return new PDThreadBead((COSDictionary) bead.getDictionaryObject("N"));}
protected final void pdfbox_f6997_0(PDThreadBead next)
{    bead.setItem("N", next);}
public PDThreadBead pdfbox_f6998_0()
{    return new PDThreadBead((COSDictionary) bead.getDictionaryObject("V"));}
protected final void pdfbox_f6999_0(PDThreadBead previous)
{    bead.setItem("V", previous);}
public void pdfbox_f7000_0(PDThreadBead append)
{    PDThreadBead nextBead = getNextBead();    nextBead.setPreviousBead(append);    append.setNextBead(nextBead);    setNextBead(append);    append.setPreviousBead(this);}
public PDPage pdfbox_f7001_0()
{    PDPage page = null;    COSDictionary dic = (COSDictionary) bead.getDictionaryObject("P");    if (dic != null) {        page = new PDPage(dic);    }    return page;}
public void pdfbox_f7002_0(PDPage page)
{    bead.setItem("P", page);}
public PDRectangle pdfbox_f7003_0()
{    PDRectangle rect = null;    COSArray array = (COSArray) bead.getDictionaryObject(COSName.R);    if (array != null) {        rect = new PDRectangle(array);    }    return rect;}
public void pdfbox_f7004_0(PDRectangle rect)
{    bead.setItem(COSName.R, rect);}
public String pdfbox_f7005_0()
{    return getCOSObject().getNameAsString(COSName.S, PDTransitionStyle.R.name());}
public String pdfbox_f7006_0()
{    return getCOSObject().getNameAsString(COSName.DM, PDTransitionDimension.H.name());}
public void pdfbox_f7007_0(PDTransitionDimension dimension)
{    getCOSObject().setName(COSName.DM, dimension.name());}
public String pdfbox_f7008_0()
{    return getCOSObject().getNameAsString(COSName.M, PDTransitionMotion.I.name());}
public void pdfbox_f7009_0(PDTransitionMotion motion)
{    getCOSObject().setName(COSName.M, motion.name());}
public COSBase pdfbox_f7010_0()
{    COSBase item = getCOSObject().getItem(COSName.DI);    if (item == null) {        return COSInteger.ZERO;    }    return item;}
public void pdfbox_f7011_0(PDTransitionDirection direction)
{    getCOSObject().setItem(COSName.DI, direction.getCOSBase());}
public float pdfbox_f7012_0()
{    return getCOSObject().getFloat(COSName.D, 1);}
public void pdfbox_f7013_0(float duration)
{    getCOSObject().setItem(COSName.D, new COSFloat(duration));}
public float pdfbox_f7014_0()
{    return getCOSObject().getFloat(COSName.SS, 1);}
public void pdfbox_f7015_0(float scale)
{    getCOSObject().setItem(COSName.SS, new COSFloat(scale));}
public boolean pdfbox_f7016_0()
{    return getCOSObject().getBoolean(COSName.B, false);}
public void pdfbox_f7017_0(boolean opaque)
{    getCOSObject().setItem(COSName.B, COSBoolean.getBoolean(opaque));}
public COSBase pdfbox_f7018_0()
{    return COSInteger.get(degrees);}
public COSBase pdfbox_f7019_0()
{    return COSName.NONE;}
public COSDictionary pdfbox_f7020_0()
{    return prefs;}
public boolean pdfbox_f7021_0()
{    return prefs.getBoolean(COSName.HIDE_TOOLBAR, false);}
public void pdfbox_f7022_0(boolean value)
{    prefs.setBoolean(COSName.HIDE_TOOLBAR, value);}
public boolean pdfbox_f7023_0()
{    return prefs.getBoolean(COSName.HIDE_MENUBAR, false);}
public void pdfbox_f7024_0(boolean value)
{    prefs.setBoolean(COSName.HIDE_MENUBAR, value);}
public boolean pdfbox_f7025_0()
{    return prefs.getBoolean(COSName.HIDE_WINDOWUI, false);}
public void pdfbox_f7026_0(boolean value)
{    prefs.setBoolean(COSName.HIDE_WINDOWUI, value);}
public boolean pdfbox_f7027_0()
{    return prefs.getBoolean(COSName.FIT_WINDOW, false);}
public void pdfbox_f7028_0(boolean value)
{    prefs.setBoolean(COSName.FIT_WINDOW, value);}
public boolean pdfbox_f7029_0()
{    return prefs.getBoolean(COSName.CENTER_WINDOW, false);}
public void pdfbox_f7030_0(boolean value)
{    prefs.setBoolean(COSName.CENTER_WINDOW, value);}
public boolean pdfbox_f7031_0()
{    return prefs.getBoolean(COSName.DISPLAY_DOC_TITLE, false);}
public void pdfbox_f7032_0(boolean value)
{    prefs.setBoolean(COSName.DISPLAY_DOC_TITLE, value);}
public String pdfbox_f7033_0()
{    return prefs.getNameAsString(COSName.NON_FULL_SCREEN_PAGE_MODE, NON_FULL_SCREEN_PAGE_MODE.UseNone.toString());}
public void pdfbox_f7034_0(NON_FULL_SCREEN_PAGE_MODE value)
{    prefs.setName(COSName.NON_FULL_SCREEN_PAGE_MODE, value.toString());}
public String pdfbox_f7035_0()
{    return prefs.getNameAsString(COSName.DIRECTION, READING_DIRECTION.L2R.toString());}
public void pdfbox_f7036_0(READING_DIRECTION value)
{    prefs.setName(COSName.DIRECTION, value.toString());}
public String pdfbox_f7037_0()
{    return prefs.getNameAsString(COSName.VIEW_AREA, BOUNDARY.CropBox.toString());}
public void pdfbox_f7038_0(BOUNDARY value)
{    prefs.setName(COSName.VIEW_AREA, value.toString());}
public String pdfbox_f7039_0()
{    return prefs.getNameAsString(COSName.VIEW_CLIP, BOUNDARY.CropBox.toString());}
public void pdfbox_f7040_0(BOUNDARY value)
{    prefs.setName(COSName.VIEW_CLIP, value.toString());}
public String pdfbox_f7041_0()
{    return prefs.getNameAsString(COSName.PRINT_AREA, BOUNDARY.CropBox.toString());}
public void pdfbox_f7042_0(BOUNDARY value)
{    prefs.setName(COSName.PRINT_AREA, value.toString());}
public String pdfbox_f7043_0()
{    return prefs.getNameAsString(COSName.PRINT_CLIP, BOUNDARY.CropBox.toString());}
public void pdfbox_f7044_0(BOUNDARY value)
{    prefs.setName(COSName.PRINT_CLIP, value.toString());}
public String pdfbox_f7045_0()
{    return prefs.getNameAsString(COSName.DUPLEX);}
public void pdfbox_f7046_0(DUPLEX value)
{    prefs.setName(COSName.DUPLEX, value.toString());}
public String pdfbox_f7047_0()
{    return prefs.getNameAsString(COSName.PRINT_SCALING, PRINT_SCALING.AppDefault.toString());}
public void pdfbox_f7048_0(PRINT_SCALING value)
{    prefs.setName(COSName.PRINT_SCALING, value.toString());}
public static PageLayout pdfbox_f7049_0(String value)
{    for (PageLayout instance : PageLayout.values()) {        if (instance.value.equals(value)) {            return instance;        }    }    throw new IllegalArgumentException(value);}
public String pdfbox_f7050_0()
{    return value;}
public static PageMode pdfbox_f7051_0(String value)
{    for (PageMode instance : PageMode.values()) {        if (instance.value.equals(value)) {            return instance;        }    }    throw new IllegalArgumentException(value);}
public String pdfbox_f7052_0()
{    return value;}
protected void pdfbox_f7053_0(int fractionDigitsNumber)
{    formatDecimal.setMaximumFractionDigits(fractionDigitsNumber);}
public void pdfbox_f7054_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Nested beginText() calls are not allowed.");    }    writeOperator(OperatorName.BEGIN_TEXT);    inTextMode = true;}
public void pdfbox_f7055_0() throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Error: You must call beginText() before calling endText.");    }    writeOperator(OperatorName.END_TEXT);    inTextMode = false;}
public void pdfbox_f7056_1(PDFont font, float fontSize) throws IOException
{    if (fontStack.isEmpty()) {        fontStack.add(font);    } else {        fontStack.pop();        fontStack.push(font);    }        if (font.willBeSubset()) {        if (document != null) {            document.getFontsToSubset().add(font);        } else {                    }    }        if (font instanceof PDType0Font) {        PDType0Font pdType0Font = (PDType0Font) font;        GsubData gsubData = pdType0Font.getGsubData();        if (gsubData != GsubData.NO_DATA_FOUND) {            GsubWorker gsubWorker = gsubWorkerFactory.getGsubWorker(pdType0Font.getCmapLookup(), gsubData);            gsubWorkers.put((PDType0Font) font, gsubWorker);        }    }    writeOperand(resources.add(font));    writeOperand(fontSize);    writeOperator(OperatorName.SET_FONT_AND_SIZE);}
public void pdfbox_f7057_0(Object[] textWithPositioningArray) throws IOException
{    write("[");    for (Object obj : textWithPositioningArray) {        if (obj instanceof String) {            showTextInternal((String) obj);        } else if (obj instanceof Float) {            writeOperand((Float) obj);        } else {            throw new IllegalArgumentException("Argument must consist of array of Float and String types");        }    }    write("] ");    writeOperator(OperatorName.SHOW_TEXT_ADJUSTED);}
public void pdfbox_f7058_0(String text) throws IOException
{    showTextInternal(text);    write(" ");    writeOperator(OperatorName.SHOW_TEXT);}
protected void pdfbox_f7059_0(String text) throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Must call beginText() before showText()");    }    if (fontStack.isEmpty()) {        throw new IllegalStateException("Must call setFont() before showText()");    }    PDFont font = fontStack.peek();        byte[] encodedText = null;    if (font instanceof PDType0Font) {        GsubWorker gsubWorker = gsubWorkers.get(font);        if (gsubWorker != null) {            PDType0Font pdType0Font = (PDType0Font) font;            Set<Integer> glyphIds = new HashSet<>();            encodedText = encodeForGsub(gsubWorker, glyphIds, pdType0Font, text);            if (pdType0Font.willBeSubset()) {                pdType0Font.addGlyphsToSubset(glyphIds);            }        }    }    if (encodedText == null) {        encodedText = font.encode(text);    }        if (font.willBeSubset()) {        int offset = 0;        while (offset < text.length()) {            int codePoint = text.codePointAt(offset);            font.addToSubset(codePoint);            offset += Character.charCount(codePoint);        }    }    COSWriter.writeString(encodedText, outputStream);}
public void pdfbox_f7060_0(float leading) throws IOException
{    writeOperand(leading);    writeOperator(OperatorName.SET_TEXT_LEADING);}
public void pdfbox_f7061_0() throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Must call beginText() before newLine()");    }    writeOperator(OperatorName.NEXT_LINE);}
public void pdfbox_f7062_0(float tx, float ty) throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Error: must call beginText() before newLineAtOffset()");    }    writeOperand(tx);    writeOperand(ty);    writeOperator(OperatorName.MOVE_TEXT);}
public void pdfbox_f7063_0(Matrix matrix) throws IOException
{    if (!inTextMode) {        throw new IllegalStateException("Error: must call beginText() before setTextMatrix");    }    writeAffineTransform(matrix.createAffineTransform());    writeOperator(OperatorName.SET_MATRIX);}
public void pdfbox_f7064_0(PDImageXObject image, float x, float y) throws IOException
{    drawImage(image, x, y, image.getWidth(), image.getHeight());}
public void pdfbox_f7065_0(PDImageXObject image, float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawImage is not allowed within a text block.");    }    saveGraphicsState();    AffineTransform transform = new AffineTransform(width, 0, 0, height, x, y);    transform(new Matrix(transform));    writeOperand(resources.add(image));    writeOperator(OperatorName.DRAW_OBJECT);    restoreGraphicsState();}
public void pdfbox_f7066_0(PDImageXObject image, Matrix matrix) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawImage is not allowed within a text block.");    }    saveGraphicsState();    AffineTransform transform = matrix.createAffineTransform();    transform(new Matrix(transform));    writeOperand(resources.add(image));    writeOperator(OperatorName.DRAW_OBJECT);    restoreGraphicsState();}
public void pdfbox_f7067_0(PDInlineImage inlineImage, float x, float y) throws IOException
{    drawImage(inlineImage, x, y, inlineImage.getWidth(), inlineImage.getHeight());}
public void pdfbox_f7068_0(PDInlineImage inlineImage, float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawImage is not allowed within a text block.");    }    saveGraphicsState();    transform(new Matrix(width, 0, 0, height, x, y));        StringBuilder sb = new StringBuilder();    sb.append(OperatorName.BEGIN_INLINE_IMAGE);    sb.append("\n /W ");    sb.append(inlineImage.getWidth());    sb.append("\n /H ");    sb.append(inlineImage.getHeight());    sb.append("\n /CS ");    sb.append("/");    sb.append(inlineImage.getColorSpace().getName());    if (inlineImage.getDecode() != null && inlineImage.getDecode().size() > 0) {        sb.append("\n /D ");        sb.append("[");        for (COSBase base : inlineImage.getDecode()) {            sb.append(((COSNumber) base).intValue());            sb.append(" ");        }        sb.append("]");    }    if (inlineImage.isStencil()) {        sb.append("\n /IM true");    }    sb.append("\n /BPC ");    sb.append(inlineImage.getBitsPerComponent());        write(sb.toString());    writeLine();        writeOperator(OperatorName.BEGIN_INLINE_IMAGE_DATA);    writeBytes(inlineImage.getData());    writeLine();    writeOperator(OperatorName.END_INLINE_IMAGE);    restoreGraphicsState();}
public void pdfbox_f7069_0(PDFormXObject form) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawForm is not allowed within a text block.");    }    writeOperand(resources.add(form));    writeOperator(OperatorName.DRAW_OBJECT);}
public void pdfbox_f7070_0(Matrix matrix) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Modifying the current transformation matrix is not allowed within text objects.");    }    writeAffineTransform(matrix.createAffineTransform());    writeOperator(OperatorName.CONCAT);}
public void pdfbox_f7071_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Saving the graphics state is not allowed within text objects.");    }    if (!fontStack.isEmpty()) {        fontStack.push(fontStack.peek());    }    if (!strokingColorSpaceStack.isEmpty()) {        strokingColorSpaceStack.push(strokingColorSpaceStack.peek());    }    if (!nonStrokingColorSpaceStack.isEmpty()) {        nonStrokingColorSpaceStack.push(nonStrokingColorSpaceStack.peek());    }    writeOperator(OperatorName.SAVE);}
public void pdfbox_f7072_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: Restoring the graphics state is not allowed within text objects.");    }    if (!fontStack.isEmpty()) {        fontStack.pop();    }    if (!strokingColorSpaceStack.isEmpty()) {        strokingColorSpaceStack.pop();    }    if (!nonStrokingColorSpaceStack.isEmpty()) {        nonStrokingColorSpaceStack.pop();    }    writeOperator(OperatorName.RESTORE);}
protected COSName pdfbox_f7073_0(PDColorSpace colorSpace)
{    if (colorSpace instanceof PDDeviceGray || colorSpace instanceof PDDeviceRGB || colorSpace instanceof PDDeviceCMYK) {        return COSName.getPDFName(colorSpace.getName());    } else {        return resources.add(colorSpace);    }}
public void pdfbox_f7074_0(PDColor color) throws IOException
{    if (strokingColorSpaceStack.isEmpty() || strokingColorSpaceStack.peek() != color.getColorSpace()) {        writeOperand(getName(color.getColorSpace()));        writeOperator(OperatorName.STROKING_COLORSPACE);        setStrokingColorSpaceStack(color.getColorSpace());    }    for (float value : color.getComponents()) {        writeOperand(value);    }    if (color.getColorSpace() instanceof PDPattern) {        writeOperand(color.getPatternName());    }    if (color.getColorSpace() instanceof PDPattern || color.getColorSpace() instanceof PDSeparation || color.getColorSpace() instanceof PDDeviceN || color.getColorSpace() instanceof PDICCBased) {        writeOperator(OperatorName.STROKING_COLOR_N);    } else {        writeOperator(OperatorName.STROKING_COLOR);    }}
public void pdfbox_f7075_0(Color color) throws IOException
{    float[] components = new float[] { color.getRed() / 255f, color.getGreen() / 255f, color.getBlue() / 255f };    PDColor pdColor = new PDColor(components, PDDeviceRGB.INSTANCE);    setStrokingColor(pdColor);}
public void pdfbox_f7076_0(int r, int g, int b) throws IOException
{    if (isOutside255Interval(r) || isOutside255Interval(g) || isOutside255Interval(b)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d)", r, g, b));    }    writeOperand(r / 255f);    writeOperand(g / 255f);    writeOperand(b / 255f);    writeOperator(OperatorName.STROKING_COLOR_RGB);    setStrokingColorSpaceStack(PDDeviceRGB.INSTANCE);}
public void pdfbox_f7077_0(float c, float m, float y, float k) throws IOException
{    if (isOutsideOneInterval(c) || isOutsideOneInterval(m) || isOutsideOneInterval(y) || isOutsideOneInterval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..1, but are " + String.format("(%.2f,%.2f,%.2f,%.2f)", c, m, y, k));    }    writeOperand(c);    writeOperand(m);    writeOperand(y);    writeOperand(k);    writeOperator(OperatorName.STROKING_COLOR_CMYK);    setStrokingColorSpaceStack(PDDeviceCMYK.INSTANCE);}
public void pdfbox_f7078_0(float g) throws IOException
{    if (isOutsideOneInterval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..1, but is " + g);    }    writeOperand(g);    writeOperator(OperatorName.STROKING_COLOR_GRAY);    setStrokingColorSpaceStack(PDDeviceGray.INSTANCE);}
public void pdfbox_f7079_0(PDColor color) throws IOException
{    if (nonStrokingColorSpaceStack.isEmpty() || nonStrokingColorSpaceStack.peek() != color.getColorSpace()) {        writeOperand(getName(color.getColorSpace()));        writeOperator(OperatorName.NON_STROKING_COLORSPACE);        setNonStrokingColorSpaceStack(color.getColorSpace());    }    for (float value : color.getComponents()) {        writeOperand(value);    }    if (color.getColorSpace() instanceof PDPattern) {        writeOperand(color.getPatternName());    }    if (color.getColorSpace() instanceof PDPattern || color.getColorSpace() instanceof PDSeparation || color.getColorSpace() instanceof PDDeviceN || color.getColorSpace() instanceof PDICCBased) {        writeOperator(OperatorName.NON_STROKING_COLOR_N);    } else {        writeOperator(OperatorName.NON_STROKING_COLOR);    }}
public void pdfbox_f7080_0(Color color) throws IOException
{    float[] components = new float[] { color.getRed() / 255f, color.getGreen() / 255f, color.getBlue() / 255f };    PDColor pdColor = new PDColor(components, PDDeviceRGB.INSTANCE);    setNonStrokingColor(pdColor);}
public void pdfbox_f7081_0(int r, int g, int b) throws IOException
{    if (isOutside255Interval(r) || isOutside255Interval(g) || isOutside255Interval(b)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d)", r, g, b));    }    writeOperand(r / 255f);    writeOperand(g / 255f);    writeOperand(b / 255f);    writeOperator(OperatorName.NON_STROKING_RGB);    setNonStrokingColorSpaceStack(PDDeviceRGB.INSTANCE);}
public void pdfbox_f7082_0(int c, int m, int y, int k) throws IOException
{    if (isOutside255Interval(c) || isOutside255Interval(m) || isOutside255Interval(y) || isOutside255Interval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d,%d)", c, m, y, k));    }    setNonStrokingColor(c / 255f, m / 255f, y / 255f, k / 255f);}
public void pdfbox_f7083_0(float c, float m, float y, float k) throws IOException
{    if (isOutsideOneInterval(c) || isOutsideOneInterval(m) || isOutsideOneInterval(y) || isOutsideOneInterval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..1, but are " + String.format("(%.2f,%.2f,%.2f,%.2f)", c, m, y, k));    }    writeOperand(c);    writeOperand(m);    writeOperand(y);    writeOperand(k);    writeOperator(OperatorName.NON_STROKING_CMYK);    setNonStrokingColorSpaceStack(PDDeviceCMYK.INSTANCE);}
public void pdfbox_f7084_0(int g) throws IOException
{    if (isOutside255Interval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..255, but is " + g);    }    setNonStrokingColor(g / 255f);}
public void pdfbox_f7085_0(float g) throws IOException
{    if (isOutsideOneInterval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..1, but is " + g);    }    writeOperand(g);    writeOperator(OperatorName.NON_STROKING_GRAY);    setNonStrokingColorSpaceStack(PDDeviceGray.INSTANCE);}
public void pdfbox_f7086_0(float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: addRect is not allowed within a text block.");    }    writeOperand(x);    writeOperand(y);    writeOperand(width);    writeOperand(height);    writeOperator(OperatorName.APPEND_RECT);}
public void pdfbox_f7087_0(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: curveTo is not allowed within a text block.");    }    writeOperand(x1);    writeOperand(y1);    writeOperand(x2);    writeOperand(y2);    writeOperand(x3);    writeOperand(y3);    writeOperator(OperatorName.CURVE_TO);}
public void pdfbox_f7088_0(float x2, float y2, float x3, float y3) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: curveTo2 is not allowed within a text block.");    }    writeOperand(x2);    writeOperand(y2);    writeOperand(x3);    writeOperand(y3);    writeOperator(OperatorName.CURVE_TO_REPLICATE_INITIAL_POINT);}
public void pdfbox_f7089_0(float x1, float y1, float x3, float y3) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: curveTo1 is not allowed within a text block.");    }    writeOperand(x1);    writeOperand(y1);    writeOperand(x3);    writeOperand(y3);    writeOperator(OperatorName.CURVE_TO_REPLICATE_FINAL_POINT);}
public void pdfbox_f7090_0(float x, float y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: moveTo is not allowed within a text block.");    }    writeOperand(x);    writeOperand(y);    writeOperator(OperatorName.MOVE_TO);}
public void pdfbox_f7091_0(float x, float y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: lineTo is not allowed within a text block.");    }    writeOperand(x);    writeOperand(y);    writeOperator(OperatorName.LINE_TO);}
public void pdfbox_f7092_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: stroke is not allowed within a text block.");    }    writeOperator(OperatorName.STROKE_PATH);}
public void pdfbox_f7093_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closeAndStroke is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_AND_STROKE);}
public void pdfbox_f7094_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fill is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_NON_ZERO);}
public void pdfbox_f7095_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_EVEN_ODD);}
public void pdfbox_f7096_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillAndStroke is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_NON_ZERO_AND_STROKE);}
public void pdfbox_f7097_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillAndStrokeEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.FILL_EVEN_ODD_AND_STROKE);}
public void pdfbox_f7098_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closeAndFillAndStroke is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE);}
public void pdfbox_f7099_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closeAndFillAndStrokeEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE);}
public void pdfbox_f7100_0(PDShading shading) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: shadingFill is not allowed within a text block.");    }    writeOperand(resources.add(shading));    writeOperator(OperatorName.SHADING_FILL);}
public void pdfbox_f7101_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: closePath is not allowed within a text block.");    }    writeOperator(OperatorName.CLOSE_PATH);}
public void pdfbox_f7102_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: clip is not allowed within a text block.");    }    writeOperator(OperatorName.CLIP_NON_ZERO);        writeOperator(OperatorName.ENDPATH);}
public void pdfbox_f7103_0() throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: clipEvenOdd is not allowed within a text block.");    }    writeOperator(OperatorName.CLIP_EVEN_ODD);        writeOperator(OperatorName.ENDPATH);}
public void pdfbox_f7104_0(float lineWidth) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineWidth is not allowed within a text block.");    }    writeOperand(lineWidth);    writeOperator(OperatorName.SET_LINE_WIDTH);}
public void pdfbox_f7105_0(int lineJoinStyle) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineJoinStyle is not allowed within a text block.");    }    if (lineJoinStyle >= 0 && lineJoinStyle <= 2) {        writeOperand(lineJoinStyle);        writeOperator(OperatorName.SET_LINE_JOINSTYLE);    } else {        throw new IllegalArgumentException("Error: unknown value for line join style");    }}
public void pdfbox_f7106_0(int lineCapStyle) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineCapStyle is not allowed within a text block.");    }    if (lineCapStyle >= 0 && lineCapStyle <= 2) {        writeOperand(lineCapStyle);        writeOperator(OperatorName.SET_LINE_CAPSTYLE);    } else {        throw new IllegalArgumentException("Error: unknown value for line cap style");    }}
public void pdfbox_f7107_0(float[] pattern, float phase) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setLineDashPattern is not allowed within a text block.");    }    write("[");    for (float value : pattern) {        writeOperand(value);    }    write("] ");    writeOperand(phase);    writeOperator(OperatorName.SET_LINE_DASHPATTERN);}
public void pdfbox_f7108_0(float miterLimit) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: setMiterLimit is not allowed within a text block.");    }    if (miterLimit <= 0.0) {        throw new IllegalArgumentException("A miter limit <= 0 is invalid and will not render in Acrobat Reader");    }    writeOperand(miterLimit);    writeOperator(OperatorName.SET_LINE_MITERLIMIT);}
public void pdfbox_f7109_0(COSName tag) throws IOException
{    writeOperand(tag);    writeOperator(OperatorName.BEGIN_MARKED_CONTENT);}
public void pdfbox_f7110_0(COSName tag, PDPropertyList propertyList) throws IOException
{    writeOperand(tag);    writeOperand(resources.add(propertyList));    writeOperator(OperatorName.BEGIN_MARKED_CONTENT_SEQ);}
public void pdfbox_f7111_0() throws IOException
{    writeOperator(OperatorName.END_MARKED_CONTENT);}
public void pdfbox_f7112_0(PDExtendedGraphicsState state) throws IOException
{    writeOperand(resources.add(state));    writeOperator(OperatorName.SET_GRAPHICS_STATE_PARAMS);}
public void pdfbox_f7113_0(String comment) throws IOException
{    if (comment.indexOf('\n') >= 0 || comment.indexOf('\r') >= 0) {        throw new IllegalArgumentException("comment should not include a newline");    }    outputStream.write('%');    outputStream.write(comment.getBytes(Charsets.US_ASCII));    outputStream.write('\n');}
protected void pdfbox_f7114_0(float real) throws IOException
{    int byteCount = NumberFormatUtil.formatFloatFast(real, formatDecimal.getMaximumFractionDigits(), formatBuffer);    if (byteCount == -1) {                write(formatDecimal.format(real));    } else {        outputStream.write(formatBuffer, 0, byteCount);    }    outputStream.write(' ');}
protected void pdfbox_f7115_0(int integer) throws IOException
{    write(formatDecimal.format(integer));    outputStream.write(' ');}
protected void pdfbox_f7116_0(COSName name) throws IOException
{    name.writePDF(outputStream);    outputStream.write(' ');}
protected void pdfbox_f7117_0(String text) throws IOException
{    outputStream.write(text.getBytes(Charsets.US_ASCII));    outputStream.write('\n');}
protected void pdfbox_f7118_0(String text) throws IOException
{    outputStream.write(text.getBytes(Charsets.US_ASCII));}
protected void pdfbox_f7119_0(byte[] data) throws IOException
{    outputStream.write(data);}
protected void pdfbox_f7120_0() throws IOException
{    outputStream.write('\n');}
protected void pdfbox_f7121_0(byte[] data) throws IOException
{    outputStream.write(data);}
private void pdfbox_f7122_0(AffineTransform transform) throws IOException
{    double[] values = new double[6];    transform.getMatrix(values);    for (double v : values) {        writeOperand((float) v);    }}
public void pdfbox_f7123_1() throws IOException
{    if (inTextMode) {            }    outputStream.close();}
protected boolean pdfbox_f7124_0(int val)
{    return val < 0 || val > 255;}
private boolean pdfbox_f7125_0(double val)
{    return val < 0 || val > 1;}
protected void pdfbox_f7126_0(PDColorSpace colorSpace)
{    if (strokingColorSpaceStack.isEmpty()) {        strokingColorSpaceStack.add(colorSpace);    } else {        strokingColorSpaceStack.pop();        strokingColorSpaceStack.push(colorSpace);    }}
protected void pdfbox_f7127_0(PDColorSpace colorSpace)
{    if (nonStrokingColorSpaceStack.isEmpty()) {        nonStrokingColorSpaceStack.add(colorSpace);    } else {        nonStrokingColorSpaceStack.pop();        nonStrokingColorSpaceStack.push(colorSpace);    }}
public void pdfbox_f7128_0(float spacing) throws IOException
{    writeOperand(spacing);    writeOperator(OperatorName.SET_CHAR_SPACING);}
public void pdfbox_f7129_0(float spacing) throws IOException
{    writeOperand(spacing);    writeOperator(OperatorName.SET_WORD_SPACING);}
public void pdfbox_f7130_0(float scale) throws IOException
{    writeOperand(scale);    writeOperator(OperatorName.SET_TEXT_HORIZONTAL_SCALING);}
public void pdfbox_f7131_0(RenderingMode rm) throws IOException
{    writeOperand(rm.intValue());    writeOperator(OperatorName.SET_TEXT_RENDERINGMODE);}
public void pdfbox_f7132_0(float rise) throws IOException
{    writeOperand(rise);    writeOperator(OperatorName.SET_TEXT_RISE);}
private byte[] pdfbox_f7133_0(GsubWorker gsubWorker, Set<Integer> glyphIds, PDType0Font font, String text) throws IOException
{    Pattern spaceRegex = Pattern.compile("\\s");        List<String> words = new CompoundCharacterTokenizer("\\s").tokenize(text);    ByteArrayOutputStream out = new ByteArrayOutputStream();    for (String word : words) {        if (spaceRegex.matcher(word).matches()) {            out.write(font.encode(word));        } else {            glyphIds.addAll(applyGSUBRules(gsubWorker, out, font, word));        }    }    return out.toByteArray();}
private List<Integer> pdfbox_f7134_0(GsubWorker gsubWorker, ByteArrayOutputStream out, PDType0Font font, String word) throws IOException
{    List<Integer> originalGlyphIds = new ArrayList<>();    CmapLookup cmapLookup = font.getCmapLookup();        for (char unicodeChar : word.toCharArray()) {        int glyphId = cmapLookup.getGlyphId(unicodeChar);        if (glyphId <= 0) {            throw new IllegalStateException("could not find the glyphId for the character: " + unicodeChar);        }        originalGlyphIds.add(glyphId);    }    List<Integer> glyphIdsAfterGsub = gsubWorker.applyTransforms(originalGlyphIds);    for (Integer glyphId : glyphIdsAfterGsub) {        out.write(font.encodeGlyphId(glyphId));    }    return glyphIdsAfterGsub;}
public boolean pdfbox_f7135_0(PDColor color) throws IOException
{    if (color != null) {        float[] components = color.getComponents();        if (components.length > 0) {            setStrokingColor(components);            return true;        }    }    return false;}
public void pdfbox_f7136_0(float[] components) throws IOException
{    for (float value : components) {        writeOperand(value);    }    int numComponents = components.length;    switch(numComponents) {        case 1:            writeOperator(OperatorName.STROKING_COLOR_GRAY);            break;        case 3:            writeOperator(OperatorName.STROKING_COLOR_RGB);            break;        case 4:            writeOperator(OperatorName.STROKING_COLOR_CMYK);            break;        default:            break;    }}
public boolean pdfbox_f7137_0(PDColor color) throws IOException
{    if (color != null) {        float[] components = color.getComponents();        if (components.length > 0) {            setNonStrokingColor(components);            return true;        }    }    return false;}
public void pdfbox_f7138_0(float[] components) throws IOException
{    for (float value : components) {        writeOperand(value);    }    int numComponents = components.length;    switch(numComponents) {        case 1:            writeOperator(OperatorName.NON_STROKING_GRAY);            break;        case 3:            writeOperator(OperatorName.NON_STROKING_RGB);            break;        case 4:            writeOperator(OperatorName.NON_STROKING_CMYK);            break;        default:            break;    }}
public void pdfbox_f7139_0(float lineWidth, PDBorderStyleDictionary bs, COSArray border) throws IOException
{        if (bs != null && bs.getCOSObject().containsKey(COSName.D) && bs.getStyle().equals(PDBorderStyleDictionary.STYLE_DASHED)) {        setLineDashPattern(bs.getDashStyle().getDashArray(), 0);    } else if (bs == null && border.size() > 3 && border.getObject(3) instanceof COSArray) {        setLineDashPattern(((COSArray) border.getObject(3)).toFloatArray(), 0);    }    setLineWidthOnDemand(lineWidth);}
public void pdfbox_f7140_0(float lineWidth) throws IOException
{        if (!(Math.abs(lineWidth - 1) < 1e-6)) {        setLineWidth(lineWidth);    }}
public void pdfbox_f7141_0(float lineWidth, boolean hasStroke, boolean hasFill) throws IOException
{        boolean resolvedHasStroke = hasStroke;        if (lineWidth < 1e-6) {        resolvedHasStroke = false;    }    if (hasFill && resolvedHasStroke) {        fillAndStroke();    } else if (resolvedHasStroke) {        stroke();    } else if (hasFill) {        fill();    } else {        writeOperator(OperatorName.ENDPATH);    }}
protected PDPageDestination pdfbox_f7142_0(COSBase base) throws IOException
{    COSBase destination = base;    if (base instanceof COSDictionary) {                                destination = ((COSDictionary) base).getDictionaryObject(COSName.D);    }    return (PDPageDestination) PDDestination.create(destination);}
protected PDNameTreeNode<PDPageDestination> pdfbox_f7143_0(COSDictionary dic)
{    return new PDDestinationNameTreeNode(dic);}
public void pdfbox_f7144_0(PDPage page)
{    getPages().add(page);}
public void pdfbox_f7145_0(PDSignature sigObject) throws IOException
{    addSignature(sigObject, new SignatureOptions());}
public void pdfbox_f7146_0(PDSignature sigObject, SignatureOptions options) throws IOException
{    addSignature(sigObject, null, options);}
public void pdfbox_f7147_0(PDSignature sigObject, SignatureInterface signatureInterface) throws IOException
{    addSignature(sigObject, signatureInterface, new SignatureOptions());}
public void pdfbox_f7148_0(PDSignature sigObject, SignatureInterface signatureInterface, SignatureOptions options) throws IOException
{    if (signatureAdded) {        throw new IllegalStateException("Only one signature may be added in a document");    }    signatureAdded = true;                int preferredSignatureSize = options.getPreferredSignatureSize();    if (preferredSignatureSize > 0) {        sigObject.setContents(new byte[preferredSignatureSize]);    } else {        sigObject.setContents(new byte[SignatureOptions.DEFAULT_SIGNATURE_SIZE]);    }        sigObject.setByteRange(RESERVE_BYTE_RANGE);    signInterface = signatureInterface;            int pageCount = getNumberOfPages();    if (pageCount == 0) {        throw new IllegalStateException("Cannot sign an empty document");    }    int startIndex = Math.min(Math.max(options.getPage(), 0), pageCount - 1);    PDPage page = getPage(startIndex);        PDDocumentCatalog catalog = getDocumentCatalog();    PDAcroForm acroForm = catalog.getAcroForm();    catalog.getCOSObject().setNeedToBeUpdated(true);    if (acroForm == null) {        acroForm = new PDAcroForm(this);        catalog.setAcroForm(acroForm);    } else {        acroForm.getCOSObject().setNeedToBeUpdated(true);    }    PDSignatureField signatureField = null;    if (!(acroForm.getCOSObject().getDictionaryObject(COSName.FIELDS) instanceof COSArray)) {        acroForm.getCOSObject().setItem(COSName.FIELDS, new COSArray());    } else {        COSArray fieldArray = (COSArray) acroForm.getCOSObject().getDictionaryObject(COSName.FIELDS);        fieldArray.setNeedToBeUpdated(true);        signatureField = findSignatureField(acroForm.getFieldIterator(), sigObject);    }    if (signatureField == null) {        signatureField = new PDSignatureField(acroForm);                signatureField.setValue(sigObject);                signatureField.getWidgets().get(0).setPage(page);    } else {        sigObject.getCOSObject().setNeedToBeUpdated(true);    }                        signatureField.getWidgets().get(0).setPrinted(true);        List<PDField> acroFormFields = acroForm.getFields();    acroForm.getCOSObject().setDirect(true);    acroForm.setSignaturesExist(true);    acroForm.setAppendOnly(true);    boolean checkFields = checkSignatureField(acroForm.getFieldIterator(), signatureField);    if (checkFields) {        signatureField.getCOSObject().setNeedToBeUpdated(true);    } else {        acroFormFields.add(signatureField);    }        COSDocument visualSignature = options.getVisualSignature();        if (visualSignature == null) {        prepareNonVisibleSignature(signatureField);        return;    }    prepareVisibleSignature(signatureField, acroForm, visualSignature);        List<PDAnnotation> annotations = page.getAnnotations();                page.setAnnotations(annotations);        if (!(annotations instanceof COSArrayList && acroFormFields instanceof COSArrayList && ((COSArrayList<?>) annotations).toList().equals(((COSArrayList<?>) acroFormFields).toList()) && checkFields)) {        PDAnnotationWidget widget = signatureField.getWidgets().get(0);                if (checkSignatureAnnotation(annotations, widget)) {            widget.getCOSObject().setNeedToBeUpdated(true);        } else {            annotations.add(widget);        }    }    page.getCOSObject().setNeedToBeUpdated(true);}
private PDSignatureField pdfbox_f7149_0(Iterator<PDField> fieldIterator, PDSignature sigObject)
{    PDSignatureField signatureField = null;    while (fieldIterator.hasNext()) {        PDField pdField = fieldIterator.next();        if (pdField instanceof PDSignatureField) {            PDSignature signature = ((PDSignatureField) pdField).getSignature();            if (signature != null && signature.getCOSObject().equals(sigObject.getCOSObject())) {                signatureField = (PDSignatureField) pdField;            }        }    }    return signatureField;}
private boolean pdfbox_f7150_0(Iterator<PDField> fieldIterator, PDSignatureField signatureField)
{    while (fieldIterator.hasNext()) {        PDField field = fieldIterator.next();        if (field instanceof PDSignatureField && field.getCOSObject().equals(signatureField.getCOSObject())) {            return true;        }    }    return false;}
private boolean pdfbox_f7151_0(List<PDAnnotation> annotations, PDAnnotationWidget widget)
{    for (PDAnnotation annotation : annotations) {        if (annotation.getCOSObject().equals(widget.getCOSObject())) {            return true;        }    }    return false;}
private void pdfbox_f7152_0(PDSignatureField signatureField, PDAcroForm acroForm, COSDocument visualSignature)
{        boolean annotNotFound = true;    boolean sigFieldNotFound = true;    for (COSObject cosObject : visualSignature.getObjects()) {        if (!annotNotFound && !sigFieldNotFound) {            break;        }        COSBase base = cosObject.getObject();        if (base instanceof COSDictionary) {            COSDictionary cosBaseDict = (COSDictionary) base;                        COSBase type = cosBaseDict.getDictionaryObject(COSName.TYPE);            if (annotNotFound && COSName.ANNOT.equals(type)) {                assignSignatureRectangle(signatureField, cosBaseDict);                annotNotFound = false;            }                        COSBase fieldType = cosBaseDict.getDictionaryObject(COSName.FT);            COSBase apDict = cosBaseDict.getDictionaryObject(COSName.AP);            if (sigFieldNotFound && COSName.SIG.equals(fieldType) && apDict instanceof COSDictionary) {                assignAppearanceDictionary(signatureField, (COSDictionary) apDict);                assignAcroFormDefaultResource(acroForm, cosBaseDict);                sigFieldNotFound = false;            }        }    }    if (annotNotFound || sigFieldNotFound) {        throw new IllegalArgumentException("Template is missing required objects");    }}
private void pdfbox_f7153_0(PDSignatureField signatureField, COSDictionary annotDict)
{        COSArray rectArray = (COSArray) annotDict.getDictionaryObject(COSName.RECT);    PDRectangle rect = new PDRectangle(rectArray);    PDRectangle existingRectangle = signatureField.getWidgets().get(0).getRectangle();        if (existingRectangle == null || existingRectangle.getCOSArray().size() != 4) {        signatureField.getWidgets().get(0).setRectangle(rect);    }}
private void pdfbox_f7154_0(PDSignatureField signatureField, COSDictionary apDict)
{        PDAppearanceDictionary ap = new PDAppearanceDictionary(apDict);    apDict.setDirect(true);    signatureField.getWidgets().get(0).setAppearance(ap);}
private void pdfbox_f7155_0(PDAcroForm acroForm, COSDictionary newDict)
{        COSBase newBase = newDict.getDictionaryObject(COSName.DR);    if (newBase instanceof COSDictionary) {        COSDictionary newDR = (COSDictionary) newBase;        PDResources defaultResources = acroForm.getDefaultResources();        if (defaultResources == null) {            acroForm.getCOSObject().setItem(COSName.DR, newDR);            newDR.setDirect(true);            newDR.setNeedToBeUpdated(true);        } else {            COSDictionary oldDR = defaultResources.getCOSObject();            COSBase newXObjectBase = newDR.getItem(COSName.XOBJECT);            COSBase oldXObjectBase = oldDR.getItem(COSName.XOBJECT);            if (newXObjectBase instanceof COSDictionary && oldXObjectBase instanceof COSDictionary) {                ((COSDictionary) oldXObjectBase).addAll((COSDictionary) newXObjectBase);                oldDR.setNeedToBeUpdated(true);            }        }    }}
private void pdfbox_f7156_0(PDSignatureField signatureField)
{                signatureField.getWidgets().get(0).setRectangle(new PDRectangle());}
public void pdfbox_f7157_0(PDPage page)
{    getPages().remove(page);}
public void pdfbox_f7158_0(int pageNumber)
{    getPages().remove(pageNumber);}
public PDPage pdfbox_f7159_1(PDPage page) throws IOException
{    PDPage importedPage = new PDPage(new COSDictionary(page.getCOSObject()), resourceCache);    PDStream dest = new PDStream(this, page.getContents(), COSName.FLATE_DECODE);    importedPage.setContents(dest);    addPage(importedPage);    importedPage.setCropBox(page.getCropBox());    importedPage.setMediaBox(page.getMediaBox());    importedPage.setRotation(page.getRotation());    if (page.getResources() != null && !page.getCOSObject().containsKey(COSName.RESOURCES)) {                    }    return importedPage;}
public COSDocument pdfbox_f7160_0()
{    return document;}
public PDDocumentInformation pdfbox_f7161_0()
{    if (documentInformation == null) {        COSDictionary trailer = document.getTrailer();        COSDictionary infoDic = trailer.getCOSDictionary(COSName.INFO);        if (infoDic == null) {            infoDic = new COSDictionary();            trailer.setItem(COSName.INFO, infoDic);        }        documentInformation = new PDDocumentInformation(infoDic);    }    return documentInformation;}
public void pdfbox_f7162_0(PDDocumentInformation info)
{    documentInformation = info;    document.getTrailer().setItem(COSName.INFO, info.getCOSObject());}
public PDDocumentCatalog pdfbox_f7163_0()
{    if (documentCatalog == null) {        COSDictionary trailer = document.getTrailer();        COSBase dictionary = trailer.getDictionaryObject(COSName.ROOT);        if (dictionary instanceof COSDictionary) {            documentCatalog = new PDDocumentCatalog(this, (COSDictionary) dictionary);        } else {            documentCatalog = new PDDocumentCatalog(this);        }    }    return documentCatalog;}
public boolean pdfbox_f7164_0()
{    return document.isEncrypted();}
public PDEncryption pdfbox_f7165_0()
{    if (encryption == null && isEncrypted()) {        encryption = new PDEncryption(document.getEncryptionDictionary());    }    return encryption;}
public void pdfbox_f7166_0(PDEncryption encryption)
{    this.encryption = encryption;}
public PDSignature pdfbox_f7167_0()
{    List<PDSignature> signatureDictionaries = getSignatureDictionaries();    int size = signatureDictionaries.size();    if (size > 0) {        return signatureDictionaries.get(size - 1);    }    return null;}
public List<PDSignatureField> pdfbox_f7168_0()
{    List<PDSignatureField> fields = new ArrayList<>();    PDAcroForm acroForm = getDocumentCatalog().getAcroForm();    if (acroForm != null) {        for (PDField field : acroForm.getFieldTree()) {            if (field instanceof PDSignatureField) {                fields.add((PDSignatureField) field);            }        }    }    return fields;}
public List<PDSignature> pdfbox_f7169_0()
{    List<PDSignature> signatures = new ArrayList<>();    for (PDSignatureField field : getSignatureFields()) {        COSBase value = field.getCOSObject().getDictionaryObject(COSName.V);        if (value instanceof COSDictionary) {            signatures.add(new PDSignature((COSDictionary) value));        }    }    return signatures;}
public void pdfbox_f7170_0(TrueTypeFont ttf)
{    fontsToClose.add(ttf);}
 Set<PDFont> pdfbox_f7171_0()
{    return fontsToSubset;}
public static PDDocument pdfbox_f7172_0(File file) throws IOException
{    return load(file, "", MemoryUsageSetting.setupMainMemoryOnly());}
public static PDDocument pdfbox_f7173_0(File file, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(file, "", null, null, memUsageSetting);}
public static PDDocument pdfbox_f7174_0(File file, String password) throws IOException
{    return load(file, password, null, null, MemoryUsageSetting.setupMainMemoryOnly());}
public static PDDocument pdfbox_f7175_0(File file, String password, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(file, password, null, null, memUsageSetting);}
public static PDDocument pdfbox_f7176_0(File file, String password, InputStream keyStore, String alias) throws IOException
{    return load(file, password, keyStore, alias, MemoryUsageSetting.setupMainMemoryOnly());}
public static PDDocument pdfbox_f7177_0(File file, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{        @SuppressWarnings({ "squid:S2095" })    RandomAccessBufferedFileInputStream raFile = new RandomAccessBufferedFileInputStream(file);    try {        return load(raFile, password, keyStore, alias, memUsageSetting);    } catch (IOException ioe) {        IOUtils.closeQuietly(raFile);        throw ioe;    }}
private static PDDocument pdfbox_f7178_0(RandomAccessBufferedFileInputStream raFile, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    try {        PDFParser parser = new PDFParser(raFile, password, keyStore, alias, scratchFile);        parser.parse();        return parser.getPDDocument();    } catch (IOException ioe) {        IOUtils.closeQuietly(scratchFile);        throw ioe;    }}
public static PDDocument pdfbox_f7179_0(InputStream input) throws IOException
{    return load(input, "", null, null, MemoryUsageSetting.setupMainMemoryOnly());}
public static PDDocument pdfbox_f7180_0(InputStream input, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(input, "", null, null, memUsageSetting);}
public static PDDocument pdfbox_f7181_0(InputStream input, String password) throws IOException
{    return load(input, password, null, null, MemoryUsageSetting.setupMainMemoryOnly());}
public static PDDocument pdfbox_f7182_0(InputStream input, String password, InputStream keyStore, String alias) throws IOException
{    return load(input, password, keyStore, alias, MemoryUsageSetting.setupMainMemoryOnly());}
public static PDDocument pdfbox_f7183_0(InputStream input, String password, MemoryUsageSetting memUsageSetting) throws IOException
{    return load(input, password, null, null, memUsageSetting);}
public static PDDocument pdfbox_f7184_0(InputStream input, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    try {        RandomAccessRead source = scratchFile.createBuffer(input);        PDFParser parser = new PDFParser(source, password, keyStore, alias, scratchFile);        parser.parse();        return parser.getPDDocument();    } catch (IOException ioe) {        IOUtils.closeQuietly(scratchFile);        throw ioe;    }}
public static PDDocument pdfbox_f7185_0(byte[] input) throws IOException
{    return load(input, "");}
public static PDDocument pdfbox_f7186_0(byte[] input, String password) throws IOException
{    return load(input, password, null, null);}
public static PDDocument pdfbox_f7187_0(byte[] input, String password, InputStream keyStore, String alias) throws IOException
{    return load(input, password, keyStore, alias, MemoryUsageSetting.setupMainMemoryOnly());}
public static PDDocument pdfbox_f7188_0(byte[] input, String password, InputStream keyStore, String alias, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    RandomAccessRead source = new RandomAccessBuffer(input);    PDFParser parser = new PDFParser(source, password, keyStore, alias, scratchFile);    parser.parse();    return parser.getPDDocument();}
public void pdfbox_f7189_0(String fileName) throws IOException
{    save(new File(fileName));}
public void pdfbox_f7190_0(File file) throws IOException
{    save(new BufferedOutputStream(new FileOutputStream(file)));}
public void pdfbox_f7191_0(OutputStream output) throws IOException
{    if (document.isClosed()) {        throw new IOException("Cannot save a document which has been closed");    }        for (PDFont font : fontsToSubset) {        font.subset();    }    fontsToSubset.clear();        try (COSWriter writer = new COSWriter(output)) {        writer.write(this);    }}
public void pdfbox_f7192_0(OutputStream output) throws IOException
{    if (pdfSource == null) {        throw new IllegalStateException("document was not loaded from a file or a stream");    }    try (COSWriter writer = new COSWriter(output, pdfSource)) {        writer.write(this, signInterface);    }}
public ExternalSigningSupport pdfbox_f7193_0(OutputStream output) throws IOException
{    if (pdfSource == null) {        throw new IllegalStateException("document was not loaded from a file or a stream");    }            PDSignature foundSignature = null;    for (PDSignature sig : getSignatureDictionaries()) {        foundSignature = sig;        if (sig.getCOSObject().isNeedToBeUpdated()) {            break;        }    }    if (foundSignature == null) {        throw new IllegalStateException("document does not contain signature fields");    }    int[] byteRange = foundSignature.getByteRange();    if (!Arrays.equals(byteRange, RESERVE_BYTE_RANGE)) {        throw new IllegalStateException("signature reserve byte range has been changed " + "after addSignature(), please set the byte range that existed after addSignature()");    }    COSWriter writer = new COSWriter(output, pdfSource);    writer.write(this);    signingSupport = new SigningSupport(writer);    return signingSupport;}
public PDPage pdfbox_f7194_0(int pageIndex)
{    return getDocumentCatalog().getPages().get(pageIndex);}
public PDPageTree pdfbox_f7195_0()
{    return getDocumentCatalog().getPages();}
public int pdfbox_f7196_0()
{    return getDocumentCatalog().getPages().getCount();}
public void pdfbox_f7197_0() throws IOException
{    if (!document.isClosed()) {                                        IOException firstException = null;                if (signingSupport != null) {            firstException = IOUtils.closeAndLogException(signingSupport, LOG, "SigningSupport", firstException);        }                firstException = IOUtils.closeAndLogException(document, LOG, "COSDocument", firstException);                if (pdfSource != null) {            firstException = IOUtils.closeAndLogException(pdfSource, LOG, "RandomAccessRead pdfSource", firstException);        }                for (TrueTypeFont ttf : fontsToClose) {            firstException = IOUtils.closeAndLogException(ttf, LOG, "TrueTypeFont", firstException);        }                if (firstException != null) {            throw firstException;        }    }}
public void pdfbox_f7198_1(ProtectionPolicy policy) throws IOException
{    if (isAllSecurityToBeRemoved()) {                setAllSecurityToBeRemoved(false);    }    if (!isEncrypted()) {        encryption = new PDEncryption();    }    SecurityHandler securityHandler = SecurityHandlerFactory.INSTANCE.newSecurityHandlerForPolicy(policy);    if (securityHandler == null) {        throw new IOException("No security handler for policy " + policy);    }    getEncryption().setSecurityHandler(securityHandler);}
public AccessPermission pdfbox_f7199_0()
{    if (accessPermission == null) {        accessPermission = AccessPermission.getOwnerAccessPermission();    }    return accessPermission;}
public boolean pdfbox_f7200_0()
{    return allSecurityToBeRemoved;}
public void pdfbox_f7201_0(boolean removeAllSecurity)
{    allSecurityToBeRemoved = removeAllSecurity;}
public Long pdfbox_f7202_0()
{    return documentId;}
public void pdfbox_f7203_0(Long docId)
{    documentId = docId;}
public float pdfbox_f7204_1()
{    float headerVersionFloat = getDocument().getVersion();        if (headerVersionFloat >= 1.4f) {        String catalogVersion = getDocumentCatalog().getVersion();        float catalogVersionFloat = -1;        if (catalogVersion != null) {            try {                catalogVersionFloat = Float.parseFloat(catalogVersion);            } catch (NumberFormatException exception) {                            }        }                return Math.max(catalogVersionFloat, headerVersionFloat);    } else {        return headerVersionFloat;    }}
public void pdfbox_f7205_1(float newVersion)
{    float currentVersion = getVersion();        if (Float.compare(newVersion, currentVersion) == 0) {        return;    }        if (newVersion < currentVersion) {                return;    }        if (getDocument().getVersion() >= 1.4f) {        getDocumentCatalog().setVersion(Float.toString(newVersion));    } else {                getDocument().setVersion(newVersion);    }}
public ResourceCache pdfbox_f7206_0()
{    return resourceCache;}
public void pdfbox_f7207_0(ResourceCache resourceCache)
{    this.resourceCache = resourceCache;}
public COSDictionary pdfbox_f7208_0()
{    return root;}
public PDAcroForm pdfbox_f7209_0()
{    if (cachedAcroForm == null) {        COSDictionary dict = (COSDictionary) root.getDictionaryObject(COSName.ACRO_FORM);        cachedAcroForm = dict == null ? null : new PDAcroForm(document, dict);    }    return cachedAcroForm;}
public void pdfbox_f7210_0(PDAcroForm acroForm)
{    root.setItem(COSName.ACRO_FORM, acroForm);    cachedAcroForm = null;}
public PDPageTree pdfbox_f7211_0()
{        return new PDPageTree((COSDictionary) root.getDictionaryObject(COSName.PAGES), document);}
public PDViewerPreferences pdfbox_f7212_0()
{    COSBase base = root.getDictionaryObject(COSName.VIEWER_PREFERENCES);    return base instanceof COSDictionary ? new PDViewerPreferences((COSDictionary) base) : null;}
public void pdfbox_f7213_0(PDViewerPreferences prefs)
{    root.setItem(COSName.VIEWER_PREFERENCES, prefs);}
public PDDocumentOutline pdfbox_f7214_0()
{    COSBase cosObj = root.getDictionaryObject(COSName.OUTLINES);    return cosObj instanceof COSDictionary ? new PDDocumentOutline((COSDictionary) cosObj) : null;}
public void pdfbox_f7215_0(PDDocumentOutline outlines)
{    root.setItem(COSName.OUTLINES, outlines);}
public List<PDThread> pdfbox_f7216_0()
{    COSArray array = (COSArray) root.getDictionaryObject(COSName.THREADS);    if (array == null) {        array = new COSArray();        root.setItem(COSName.THREADS, array);    }    List<PDThread> pdObjects = new ArrayList<>();    for (int i = 0; i < array.size(); i++) {        pdObjects.add(new PDThread((COSDictionary) array.getObject(i)));    }    return new COSArrayList<>(pdObjects, array);}
public void pdfbox_f7217_0(List<PDThread> threads)
{    root.setItem(COSName.THREADS, COSArrayList.converterToCOSArray(threads));}
public PDMetadata pdfbox_f7218_0()
{    COSBase metaObj = root.getDictionaryObject(COSName.METADATA);    if (metaObj instanceof COSStream) {        return new PDMetadata((COSStream) metaObj);    }    return null;}
public void pdfbox_f7219_0(PDMetadata meta)
{    root.setItem(COSName.METADATA, meta);}
public void pdfbox_f7220_0(PDDestinationOrAction action)
{    root.setItem(COSName.OPEN_ACTION, action);}
public PDDestinationOrAction pdfbox_f7221_0() throws IOException
{    COSBase openAction = root.getDictionaryObject(COSName.OPEN_ACTION);    if (openAction instanceof COSDictionary) {        return PDActionFactory.createAction((COSDictionary) openAction);    } else if (openAction instanceof COSArray) {        return PDDestination.create(openAction);    } else {        return null;    }}
public PDDocumentCatalogAdditionalActions pdfbox_f7222_0()
{    COSDictionary addAction = (COSDictionary) root.getDictionaryObject(COSName.AA);    if (addAction == null) {        addAction = new COSDictionary();        root.setItem(COSName.AA, addAction);    }    return new PDDocumentCatalogAdditionalActions(addAction);}
public void pdfbox_f7223_0(PDDocumentCatalogAdditionalActions actions)
{    root.setItem(COSName.AA, actions);}
public PDDocumentNameDictionary pdfbox_f7224_0()
{    COSDictionary names = (COSDictionary) root.getDictionaryObject(COSName.NAMES);    return names == null ? null : new PDDocumentNameDictionary(this, names);}
public PDDocumentNameDestinationDictionary pdfbox_f7225_0()
{    PDDocumentNameDestinationDictionary nameDic = null;    COSDictionary dests = (COSDictionary) root.getDictionaryObject(COSName.DESTS);    if (dests != null) {        nameDic = new PDDocumentNameDestinationDictionary(dests);    }    return nameDic;}
public PDPageDestination pdfbox_f7226_0(PDNamedDestination namedDest) throws IOException
{    PDPageDestination pageDestination = null;    PDDocumentNameDictionary namesDict = getNames();    if (namesDict != null) {        PDDestinationNameTreeNode destsTree = namesDict.getDests();        if (destsTree != null) {            pageDestination = destsTree.getValue(namedDest.getNamedDestination());        }    }    if (pageDestination == null) {                PDDocumentNameDestinationDictionary nameDestDict = getDests();        if (nameDestDict != null) {            String name = namedDest.getNamedDestination();            pageDestination = (PDPageDestination) nameDestDict.getDestination(name);        }    }    return pageDestination;}
public void pdfbox_f7227_0(PDDocumentNameDictionary names)
{    root.setItem(COSName.NAMES, names);}
public PDMarkInfo pdfbox_f7228_0()
{    COSDictionary dic = (COSDictionary) root.getDictionaryObject(COSName.MARK_INFO);    return dic == null ? null : new PDMarkInfo(dic);}
public void pdfbox_f7229_0(PDMarkInfo markInfo)
{    root.setItem(COSName.MARK_INFO, markInfo);}
public List<PDOutputIntent> pdfbox_f7230_0()
{    List<PDOutputIntent> retval = new ArrayList<>();    COSArray array = (COSArray) root.getDictionaryObject(COSName.OUTPUT_INTENTS);    if (array != null) {        for (COSBase cosBase : array) {            if (cosBase instanceof COSObject) {                cosBase = ((COSObject) cosBase).getObject();            }            PDOutputIntent oi = new PDOutputIntent((COSDictionary) cosBase);            retval.add(oi);        }    }    return retval;}
public void pdfbox_f7231_0(PDOutputIntent outputIntent)
{    COSArray array = (COSArray) root.getDictionaryObject(COSName.OUTPUT_INTENTS);    if (array == null) {        array = new COSArray();        root.setItem(COSName.OUTPUT_INTENTS, array);    }    array.add(outputIntent.getCOSObject());}
public void pdfbox_f7232_0(List<PDOutputIntent> outputIntents)
{    COSArray array = new COSArray();    for (PDOutputIntent intent : outputIntents) {        array.add(intent.getCOSObject());    }    root.setItem(COSName.OUTPUT_INTENTS, array);}
public PageMode pdfbox_f7233_1()
{    String mode = root.getNameAsString(COSName.PAGE_MODE);    if (mode != null) {        try {            return PageMode.fromString(mode);        } catch (IllegalArgumentException e) {                        return PageMode.USE_NONE;        }    } else {        return PageMode.USE_NONE;    }}
public void pdfbox_f7234_0(PageMode mode)
{    root.setName(COSName.PAGE_MODE, mode.stringValue());}
public PageLayout pdfbox_f7235_0()
{    String mode = root.getNameAsString(COSName.PAGE_LAYOUT);    if (mode != null) {        return PageLayout.fromString(mode);    } else {        return PageLayout.SINGLE_PAGE;    }}
public void pdfbox_f7236_0(PageLayout layout)
{    root.setName(COSName.PAGE_LAYOUT, layout.stringValue());}
public PDURIDictionary pdfbox_f7237_0()
{    COSDictionary uri = (COSDictionary) root.getDictionaryObject(COSName.URI);    return uri == null ? null : new PDURIDictionary(uri);}
public void pdfbox_f7238_0(PDURIDictionary uri)
{    root.setItem(COSName.URI, uri);}
public PDStructureTreeRoot pdfbox_f7239_0()
{    COSDictionary dict = root.getCOSDictionary(COSName.STRUCT_TREE_ROOT);    return dict == null ? null : new PDStructureTreeRoot(dict);}
public void pdfbox_f7240_0(PDStructureTreeRoot treeRoot)
{    root.setItem(COSName.STRUCT_TREE_ROOT, treeRoot);}
public String pdfbox_f7241_0()
{    return root.getString(COSName.LANG);}
public void pdfbox_f7242_0(String language)
{    root.setString(COSName.LANG, language);}
public String pdfbox_f7243_0()
{    return root.getNameAsString(COSName.VERSION);}
public void pdfbox_f7244_0(String version)
{    root.setName(COSName.VERSION, version);}
public PDPageLabels pdfbox_f7245_0() throws IOException
{    COSDictionary dict = (COSDictionary) root.getDictionaryObject(COSName.PAGE_LABELS);    return dict == null ? null : new PDPageLabels(document, dict);}
public void pdfbox_f7246_0(PDPageLabels labels)
{    root.setItem(COSName.PAGE_LABELS, labels);}
public PDOptionalContentProperties pdfbox_f7247_0()
{    COSDictionary dict = (COSDictionary) root.getDictionaryObject(COSName.OCPROPERTIES);    return dict == null ? null : new PDOptionalContentProperties(dict);}
public void pdfbox_f7248_0(PDOptionalContentProperties ocProperties)
{    root.setItem(COSName.OCPROPERTIES, ocProperties);        if (ocProperties != null && document.getVersion() < 1.5) {        document.setVersion(1.5f);    }}
public COSDictionary pdfbox_f7249_0()
{    return info;}
public Object pdfbox_f7250_0(String propertyKey)
{    return info.getString(propertyKey);}
public String pdfbox_f7251_0()
{    return info.getString(COSName.TITLE);}
public void pdfbox_f7252_0(String title)
{    info.setString(COSName.TITLE, title);}
public String pdfbox_f7253_0()
{    return info.getString(COSName.AUTHOR);}
public void pdfbox_f7254_0(String author)
{    info.setString(COSName.AUTHOR, author);}
public String pdfbox_f7255_0()
{    return info.getString(COSName.SUBJECT);}
public void pdfbox_f7256_0(String subject)
{    info.setString(COSName.SUBJECT, subject);}
public String pdfbox_f7257_0()
{    return info.getString(COSName.KEYWORDS);}
public void pdfbox_f7258_0(String keywords)
{    info.setString(COSName.KEYWORDS, keywords);}
public String pdfbox_f7259_0()
{    return info.getString(COSName.CREATOR);}
public void pdfbox_f7260_0(String creator)
{    info.setString(COSName.CREATOR, creator);}
public String pdfbox_f7261_0()
{    return info.getString(COSName.PRODUCER);}
public void pdfbox_f7262_0(String producer)
{    info.setString(COSName.PRODUCER, producer);}
public Calendar pdfbox_f7263_0()
{    return info.getDate(COSName.CREATION_DATE);}
public void pdfbox_f7264_0(Calendar date)
{    info.setDate(COSName.CREATION_DATE, date);}
public Calendar pdfbox_f7265_0()
{    return info.getDate(COSName.MOD_DATE);}
public void pdfbox_f7266_0(Calendar date)
{    info.setDate(COSName.MOD_DATE, date);}
public String pdfbox_f7267_0()
{    return info.getNameAsString(COSName.TRAPPED);}
public Set<String> pdfbox_f7268_0()
{    Set<String> keys = new TreeSet<>();    for (COSName key : info.keySet()) {        keys.add(key.getName());    }    return keys;}
public String pdfbox_f7269_0(String fieldName)
{    return info.getString(fieldName);}
public void pdfbox_f7270_0(String fieldName, String fieldValue)
{    info.setString(fieldName, fieldValue);}
public void pdfbox_f7271_0(String value)
{    if (value != null && !value.equals("True") && !value.equals("False") && !value.equals("Unknown")) {        throw new RuntimeException("Valid values for trapped are " + "'True', 'False', or 'Unknown'");    }    info.setName(COSName.TRAPPED, value);}
public COSDictionary pdfbox_f7272_0()
{    return nameDictionary;}
public PDDestination pdfbox_f7273_0(String name) throws IOException
{    COSBase item = nameDictionary.getDictionaryObject(name);        if (item instanceof COSArray) {        return PDDestination.create(item);    } else if (item instanceof COSDictionary) {        COSDictionary dict = (COSDictionary) item;        if (dict.containsKey(COSName.D)) {            return PDDestination.create(dict.getDictionaryObject(COSName.D));        }    }    return null;}
public COSDictionary pdfbox_f7274_0()
{    return nameDictionary;}
public PDDestinationNameTreeNode pdfbox_f7275_0()
{    PDDestinationNameTreeNode dests = null;    COSDictionary dic = (COSDictionary) nameDictionary.getDictionaryObject(COSName.DESTS);        if (dic == null) {        dic = (COSDictionary) catalog.getCOSObject().getDictionaryObject(COSName.DESTS);    }    if (dic != null) {        dests = new PDDestinationNameTreeNode(dic);    }    return dests;}
public void pdfbox_f7276_0(PDDestinationNameTreeNode dests)
{    nameDictionary.setItem(COSName.DESTS, dests);                        catalog.getCOSObject().setItem(COSName.DESTS, (COSObjectable) null);}
public PDEmbeddedFilesNameTreeNode pdfbox_f7277_0()
{    PDEmbeddedFilesNameTreeNode retval = null;    COSDictionary dic = (COSDictionary) nameDictionary.getDictionaryObject(COSName.EMBEDDED_FILES);    if (dic != null) {        retval = new PDEmbeddedFilesNameTreeNode(dic);    }    return retval;}
public void pdfbox_f7278_0(PDEmbeddedFilesNameTreeNode ef)
{    nameDictionary.setItem(COSName.EMBEDDED_FILES, ef);}
public PDJavascriptNameTreeNode pdfbox_f7279_0()
{    PDJavascriptNameTreeNode retval = null;    COSDictionary dic = (COSDictionary) nameDictionary.getDictionaryObject(COSName.JAVA_SCRIPT);    if (dic != null) {        retval = new PDJavascriptNameTreeNode(dic);    }    return retval;}
public void pdfbox_f7280_0(PDJavascriptNameTreeNode js)
{    nameDictionary.setItem(COSName.JAVA_SCRIPT, js);}
protected PDComplexFileSpecification pdfbox_f7281_0(COSBase base) throws IOException
{    return new PDComplexFileSpecification((COSDictionary) base);}
protected PDNameTreeNode<PDComplexFileSpecification> pdfbox_f7282_0(COSDictionary dic)
{    return new PDEmbeddedFilesNameTreeNode(dic);}
protected PDActionJavaScript pdfbox_f7283_0(COSBase base) throws IOException
{    if (!(base instanceof COSDictionary)) {        throw new IOException("Error creating Javascript object, expected a COSDictionary and not " + base);    }    return (PDActionJavaScript) PDActionFactory.createAction((COSDictionary) base);}
protected PDNameTreeNode<PDActionJavaScript> pdfbox_f7284_0(COSDictionary dic)
{    return new PDJavascriptNameTreeNode(dic);}
public COSDictionary pdfbox_f7285_0()
{    return page;}
public Iterator<PDStream> pdfbox_f7286_0()
{    List<PDStream> streams = new ArrayList<>();    COSBase base = page.getDictionaryObject(COSName.CONTENTS);    if (base instanceof COSStream) {        streams.add(new PDStream((COSStream) base));    } else if (base instanceof COSArray && ((COSArray) base).size() > 0) {        COSArray array = (COSArray) base;        for (int i = 0; i < array.size(); i++) {            COSStream stream = (COSStream) array.getObject(i);            streams.add(new PDStream(stream));        }    }    return streams.iterator();}
public InputStream pdfbox_f7287_0() throws IOException
{    COSBase base = page.getDictionaryObject(COSName.CONTENTS);    if (base instanceof COSStream) {        return ((COSStream) base).createInputStream();    } else if (base instanceof COSArray && ((COSArray) base).size() > 0) {        COSArray streams = (COSArray) base;        byte[] delimiter = new byte[] { '\n' };        List<InputStream> inputStreams = new ArrayList<>();        for (int i = 0; i < streams.size(); i++) {            COSBase strm = streams.getObject(i);            if (strm instanceof COSStream) {                COSStream stream = (COSStream) strm;                inputStreams.add(stream.createInputStream());                inputStreams.add(new ByteArrayInputStream(delimiter));            }        }        return new SequenceInputStream(Collections.enumeration(inputStreams));    }    return new ByteArrayInputStream(new byte[0]);}
public boolean pdfbox_f7288_0()
{    COSBase contents = page.getDictionaryObject(COSName.CONTENTS);    if (contents instanceof COSStream) {        return ((COSStream) contents).size() > 0;    } else if (contents instanceof COSArray) {        return ((COSArray) contents).size() > 0;    }    return false;}
public PDResources pdfbox_f7289_0()
{    if (pageResources == null) {        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.RESOURCES);                if (base instanceof COSDictionary) {            pageResources = new PDResources((COSDictionary) base, resourceCache);        }    }    return pageResources;}
public void pdfbox_f7290_0(PDResources resources)
{    pageResources = resources;    if (resources != null) {        page.setItem(COSName.RESOURCES, resources);    } else {        page.removeItem(COSName.RESOURCES);    }}
public int pdfbox_f7291_0()
{    return page.getInt(COSName.STRUCT_PARENTS);}
public void pdfbox_f7292_0(int structParents)
{    page.setInt(COSName.STRUCT_PARENTS, structParents);}
public PDRectangle pdfbox_f7293_0()
{    return getCropBox();}
public Matrix pdfbox_f7294_0()
{        return new Matrix();}
public PDRectangle pdfbox_f7295_1()
{    if (mediaBox == null) {        COSBase base = PDPageTree.getInheritableAttribute(page, COSName.MEDIA_BOX);        if (base instanceof COSArray) {            mediaBox = new PDRectangle((COSArray) base);        }    }    if (mediaBox == null) {                mediaBox = PDRectangle.LETTER;    }    return mediaBox;}
public void pdfbox_f7296_0(PDRectangle mediaBox)
{    this.mediaBox = mediaBox;    if (mediaBox == null) {        page.removeItem(COSName.MEDIA_BOX);    } else {        page.setItem(COSName.MEDIA_BOX, mediaBox);    }}
public PDRectangle pdfbox_f7297_0()
{    COSBase base = PDPageTree.getInheritableAttribute(page, COSName.CROP_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getMediaBox();    }}
public void pdfbox_f7298_0(PDRectangle cropBox)
{    if (cropBox == null) {        page.removeItem(COSName.CROP_BOX);    } else {        page.setItem(COSName.CROP_BOX, cropBox.getCOSArray());    }}
public PDRectangle pdfbox_f7299_0()
{    COSBase base = page.getDictionaryObject(COSName.BLEED_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getCropBox();    }}
public void pdfbox_f7300_0(PDRectangle bleedBox)
{    if (bleedBox == null) {        page.removeItem(COSName.BLEED_BOX);    } else {        page.setItem(COSName.BLEED_BOX, bleedBox);    }}
public PDRectangle pdfbox_f7301_0()
{    COSBase base = page.getDictionaryObject(COSName.TRIM_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getCropBox();    }}
public void pdfbox_f7302_0(PDRectangle trimBox)
{    if (trimBox == null) {        page.removeItem(COSName.TRIM_BOX);    } else {        page.setItem(COSName.TRIM_BOX, trimBox);    }}
public PDRectangle pdfbox_f7303_0()
{    COSBase base = page.getDictionaryObject(COSName.ART_BOX);    if (base instanceof COSArray) {        return clipToMediaBox(new PDRectangle((COSArray) base));    } else {        return getCropBox();    }}
public void pdfbox_f7304_0(PDRectangle artBox)
{    if (artBox == null) {        page.removeItem(COSName.ART_BOX);    } else {        page.setItem(COSName.ART_BOX, artBox);    }}
private PDRectangle pdfbox_f7305_0(PDRectangle box)
{    PDRectangle mediaBox = getMediaBox();    PDRectangle result = new PDRectangle();    result.setLowerLeftX(Math.max(mediaBox.getLowerLeftX(), box.getLowerLeftX()));    result.setLowerLeftY(Math.max(mediaBox.getLowerLeftY(), box.getLowerLeftY()));    result.setUpperRightX(Math.min(mediaBox.getUpperRightX(), box.getUpperRightX()));    result.setUpperRightY(Math.min(mediaBox.getUpperRightY(), box.getUpperRightY()));    return result;}
public int pdfbox_f7306_0()
{    COSBase obj = PDPageTree.getInheritableAttribute(page, COSName.ROTATE);    if (obj instanceof COSNumber) {        int rotationAngle = ((COSNumber) obj).intValue();        if (rotationAngle % 90 == 0) {            return (rotationAngle % 360 + 360) % 360;        }    }    return 0;}
public void pdfbox_f7307_0(int rotation)
{    page.setInt(COSName.ROTATE, rotation);}
public void pdfbox_f7308_0(PDStream contents)
{    page.setItem(COSName.CONTENTS, contents);}
public void pdfbox_f7309_0(List<PDStream> contents)
{    COSArray array = new COSArray();    contents.forEach(array::add);    page.setItem(COSName.CONTENTS, array);}
public List<PDThreadBead> pdfbox_f7310_0()
{    COSArray beads = (COSArray) page.getDictionaryObject(COSName.B);    if (beads == null) {        beads = new COSArray();    }    List<PDThreadBead> pdObjects = new ArrayList<>();    for (int i = 0; i < beads.size(); i++) {        COSBase base = beads.getObject(i);        PDThreadBead bead = null;                if (base instanceof COSDictionary) {            bead = new PDThreadBead((COSDictionary) base);        }        pdObjects.add(bead);    }    return new COSArrayList<>(pdObjects, beads);}
public void pdfbox_f7311_0(List<PDThreadBead> beads)
{    page.setItem(COSName.B, COSArrayList.converterToCOSArray(beads));}
public PDMetadata pdfbox_f7312_0()
{    PDMetadata retval = null;    COSBase base = page.getDictionaryObject(COSName.METADATA);    if (base instanceof COSStream) {        retval = new PDMetadata((COSStream) base);    }    return retval;}
public void pdfbox_f7313_0(PDMetadata meta)
{    page.setItem(COSName.METADATA, meta);}
public PDPageAdditionalActions pdfbox_f7314_0()
{    COSDictionary addAct;    COSBase base = page.getDictionaryObject(COSName.AA);    if (base instanceof COSDictionary) {        addAct = (COSDictionary) base;    } else {        addAct = new COSDictionary();        page.setItem(COSName.AA, addAct);    }    return new PDPageAdditionalActions(addAct);}
public void pdfbox_f7315_0(PDPageAdditionalActions actions)
{    page.setItem(COSName.AA, actions);}
public PDTransition pdfbox_f7316_0()
{    COSBase base = page.getDictionaryObject(COSName.TRANS);    return base instanceof COSDictionary ? new PDTransition((COSDictionary) base) : null;}
public void pdfbox_f7317_0(PDTransition transition)
{    page.setItem(COSName.TRANS, transition);}
public void pdfbox_f7318_0(PDTransition transition, float duration)
{    page.setItem(COSName.TRANS, transition);    page.setItem(COSName.DUR, new COSFloat(duration));}
public List<PDAnnotation> pdfbox_f7319_0() throws IOException
{    return getAnnotations(annotation -> true);}
public List<PDAnnotation> pdfbox_f7320_0(AnnotationFilter annotationFilter) throws IOException
{    COSBase base = page.getDictionaryObject(COSName.ANNOTS);    if (base instanceof COSArray) {        COSArray annots = (COSArray) base;        List<PDAnnotation> actuals = new ArrayList<>();        for (int i = 0; i < annots.size(); i++) {            COSBase item = annots.getObject(i);            if (item == null) {                continue;            }            PDAnnotation createdAnnotation = PDAnnotation.createAnnotation(item);            if (annotationFilter.accept(createdAnnotation)) {                actuals.add(createdAnnotation);            }        }        return new COSArrayList<>(actuals, annots);    }    return new COSArrayList<>(page, COSName.ANNOTS);}
public void pdfbox_f7321_0(List<PDAnnotation> annotations)
{    page.setItem(COSName.ANNOTS, COSArrayList.converterToCOSArray(annotations));}
public boolean pdfbox_f7322_0(Object other)
{    return other instanceof PDPage && ((PDPage) other).getCOSObject() == this.getCOSObject();}
public int pdfbox_f7323_0()
{    return page.hashCode();}
public ResourceCache pdfbox_f7324_0()
{    return resourceCache;}
public List<PDViewportDictionary> pdfbox_f7325_1()
{    COSBase base = page.getDictionaryObject(COSName.VP);    if (!(base instanceof COSArray)) {        return null;    }    COSArray array = (COSArray) base;    List<PDViewportDictionary> viewports = new ArrayList<>();    for (int i = 0; i < array.size(); ++i) {        COSBase base2 = array.getObject(i);        if (base2 instanceof COSDictionary) {            viewports.add(new PDViewportDictionary((COSDictionary) base2));        } else {                    }    }    return viewports;}
public void pdfbox_f7326_0(List<PDViewportDictionary> viewports)
{    if (viewports == null) {        page.removeItem(COSName.VP);        return;    }    COSArray array = new COSArray();    viewports.forEach(array::add);    page.setItem(COSName.VP, array);}
public boolean pdfbox_f7327_0()
{    return this == OVERWRITE;}
public boolean pdfbox_f7328_0()
{    return this == PREPEND;}
public void pdfbox_f7329_0(String text) throws IOException
{    showText(text);}
public void pdfbox_f7330_0(float tx, float ty) throws IOException
{    newLineAtOffset(tx, ty);}
public void pdfbox_f7331_0(double a, double b, double c, double d, double e, double f) throws IOException
{    setTextMatrix(new Matrix((float) a, (float) b, (float) c, (float) d, (float) e, (float) f));}
public void pdfbox_f7332_0(AffineTransform matrix) throws IOException
{    setTextMatrix(new Matrix(matrix));}
public void pdfbox_f7333_0(double sx, double sy, double tx, double ty) throws IOException
{    setTextMatrix(new Matrix((float) sx, 0f, 0f, (float) sy, (float) tx, (float) ty));}
public void pdfbox_f7334_0(double tx, double ty) throws IOException
{    setTextMatrix(Matrix.getTranslateInstance((float) tx, (float) ty));}
public void pdfbox_f7335_0(double angle, double tx, double ty) throws IOException
{    setTextMatrix(Matrix.getRotateInstance(angle, (float) tx, (float) ty));}
public void pdfbox_f7336_0(PDInlineImage inlineImage, float x, float y) throws IOException
{    drawImage(inlineImage, x, y, inlineImage.getWidth(), inlineImage.getHeight());}
public void pdfbox_f7337_0(PDInlineImage inlineImage, float x, float y, float width, float height) throws IOException
{    drawImage(inlineImage, x, y, width, height);}
public void pdfbox_f7338_0(PDXObject xobject, float x, float y, float width, float height) throws IOException
{    AffineTransform transform = new AffineTransform(width, 0, 0, height, x, y);    drawXObject(xobject, transform);}
public void pdfbox_f7339_0(PDXObject xobject, AffineTransform transform) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawXObject is not allowed within a text block.");    }    String xObjectPrefix;    if (xobject instanceof PDImageXObject) {        xObjectPrefix = "Im";    } else {        xObjectPrefix = "Form";    }    COSName objMapping = resources.add(xobject, xObjectPrefix);    saveGraphicsState();    transform(new Matrix(transform));    writeOperand(objMapping);    writeOperator(OperatorName.DRAW_OBJECT);    restoreGraphicsState();}
public void pdfbox_f7340_0(double a, double b, double c, double d, double e, double f) throws IOException
{    transform(new Matrix((float) a, (float) b, (float) c, (float) d, (float) e, (float) f));}
public void pdfbox_f7341_0(AffineTransform at) throws IOException
{    transform(new Matrix(at));}
public void pdfbox_f7342_0(PDColorSpace colorSpace) throws IOException
{    setStrokingColorSpaceStack(colorSpace);    writeOperand(getName(colorSpace));    writeOperator(OperatorName.STROKING_COLORSPACE);}
public void pdfbox_f7343_0(PDColorSpace colorSpace) throws IOException
{    setNonStrokingColorSpaceStack(colorSpace);    writeOperand(getName(colorSpace));    writeOperator(OperatorName.NON_STROKING_COLORSPACE);}
public void pdfbox_f7344_0(float[] components) throws IOException
{    if (strokingColorSpaceStack.isEmpty()) {        throw new IllegalStateException("The color space must be set before setting a color");    }    for (float component : components) {        writeOperand(component);    }    PDColorSpace currentStrokingColorSpace = strokingColorSpaceStack.peek();    if (currentStrokingColorSpace instanceof PDSeparation || currentStrokingColorSpace instanceof PDPattern || currentStrokingColorSpace instanceof PDICCBased) {        writeOperator(OperatorName.STROKING_COLOR_N);    } else {        writeOperator(OperatorName.STROKING_COLOR);    }}
public void pdfbox_f7345_0(int c, int m, int y, int k) throws IOException
{    if (isOutside255Interval(c) || isOutside255Interval(m) || isOutside255Interval(y) || isOutside255Interval(k)) {        throw new IllegalArgumentException("Parameters must be within 0..255, but are " + String.format("(%d,%d,%d,%d)", c, m, y, k));    }    setStrokingColor(c / 255f, m / 255f, y / 255f, k / 255f);}
public void pdfbox_f7346_0(int g) throws IOException
{    if (isOutside255Interval(g)) {        throw new IllegalArgumentException("Parameter must be within 0..255, but is " + g);    }    setStrokingColor(g / 255f);}
public void pdfbox_f7347_0(float[] components) throws IOException
{    if (nonStrokingColorSpaceStack.isEmpty()) {        throw new IllegalStateException("The color space must be set before setting a color");    }    for (float component : components) {        writeOperand(component);    }    PDColorSpace currentNonStrokingColorSpace = nonStrokingColorSpaceStack.peek();    if (currentNonStrokingColorSpace instanceof PDSeparation || currentNonStrokingColorSpace instanceof PDPattern || currentNonStrokingColorSpace instanceof PDICCBased) {        writeOperator(OperatorName.NON_STROKING_COLOR_N);    } else {        writeOperator(OperatorName.NON_STROKING_COLOR);    }}
public void pdfbox_f7348_0(float x, float y, float width, float height) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillRect is not allowed within a text block.");    }    addRect(x, y, width, height);    fill();}
public void pdfbox_f7349_0(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{    curveTo(x1, y1, x2, y2, x3, y3);}
public void pdfbox_f7350_0(float x2, float y2, float x3, float y3) throws IOException
{    curveTo2(x2, y2, x3, y3);}
public void pdfbox_f7351_0(float x1, float y1, float x3, float y3) throws IOException
{    curveTo1(x1, y1, x3, y3);}
public void pdfbox_f7352_0(float xStart, float yStart, float xEnd, float yEnd) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: addLine is not allowed within a text block.");    }    moveTo(xStart, yStart);    lineTo(xEnd, yEnd);}
public void pdfbox_f7353_0(float xStart, float yStart, float xEnd, float yEnd) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawLine is not allowed within a text block.");    }    moveTo(xStart, yStart);    lineTo(xEnd, yEnd);    stroke();}
public void pdfbox_f7354_0(float[] x, float[] y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: addPolygon is not allowed within a text block.");    }    if (x.length != y.length) {        throw new IllegalArgumentException("Error: some points are missing coordinate");    }    for (int i = 0; i < x.length; i++) {        if (i == 0) {            moveTo(x[i], y[i]);        } else {            lineTo(x[i], y[i]);        }    }    closeSubPath();}
public void pdfbox_f7355_0(float[] x, float[] y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: drawPolygon is not allowed within a text block.");    }    addPolygon(x, y);    stroke();}
public void pdfbox_f7356_0(float[] x, float[] y) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: fillPolygon is not allowed within a text block.");    }    addPolygon(x, y);    fill();}
public void pdfbox_f7357_0(int windingRule) throws IOException
{    switch(windingRule) {        case PathIterator.WIND_NON_ZERO:            fill();            break;        case PathIterator.WIND_EVEN_ODD:            fillEvenOdd();            break;        default:            throw new IllegalArgumentException("Error: unknown value for winding rule");    }}
public void pdfbox_f7358_0() throws IOException
{    closePath();}
public void pdfbox_f7359_0(int windingRule) throws IOException
{    if (inTextMode) {        throw new IllegalStateException("Error: clipPath is not allowed within a text block.");    }    switch(windingRule) {        case PathIterator.WIND_NON_ZERO:            writeOperator(OperatorName.CLIP_NON_ZERO);            break;        case PathIterator.WIND_EVEN_ODD:            writeOperator(OperatorName.CLIP_EVEN_ODD);            break;        default:            throw new IllegalArgumentException("Error: unknown value for winding rule");    }    writeOperator(OperatorName.ENDPATH);}
public void pdfbox_f7360_0(COSName tag) throws IOException
{    beginMarkedContent(tag);}
public void pdfbox_f7361_0(COSName tag, COSName propsName) throws IOException
{    writeOperand(tag);    writeOperand(propsName);    writeOperator(OperatorName.BEGIN_MARKED_CONTENT_SEQ);}
public void pdfbox_f7362_0() throws IOException
{    endMarkedContent();}
public void pdfbox_f7363_0(String commands) throws IOException
{    write(commands);}
public void pdfbox_f7364_0(byte[] commands) throws IOException
{    write(commands);}
public void pdfbox_f7365_0(int data) throws IOException
{    writeOperand(data);}
public void pdfbox_f7366_0(double data) throws IOException
{    writeOperand((float) data);}
public void pdfbox_f7367_0(float data) throws IOException
{    writeOperand(data);}
public void pdfbox_f7368_0(COSName name) throws IOException
{    writeOperand(name);}
public static COSBase pdfbox_f7369_0(COSDictionary node, COSName key)
{    COSBase value = node.getDictionaryObject(key);    if (value != null) {        return value;    }    COSBase base = node.getDictionaryObject(COSName.PARENT, COSName.P);    if (base instanceof COSDictionary) {        COSDictionary parent = (COSDictionary) base;        if (COSName.PAGES.equals(parent.getDictionaryObject(COSName.TYPE))) {            return getInheritableAttribute(parent, key);        }    }    return null;}
public Iterator<PDPage> pdfbox_f7370_0()
{    return new PageIterator(root);}
private List<COSDictionary> pdfbox_f7371_1(COSDictionary node)
{    List<COSDictionary> result = new ArrayList<>();    COSArray kids = node.getCOSArray(COSName.KIDS);    if (kids == null) {                return result;    }    for (int i = 0, size = kids.size(); i < size; i++) {        COSBase base = kids.getObject(i);        if (base instanceof COSDictionary) {            result.add((COSDictionary) base);        } else {                    }    }    return result;}
private void pdfbox_f7372_0(COSDictionary node)
{    if (isPageTreeNode(node)) {        List<COSDictionary> kids = getKids(node);        for (COSDictionary kid : kids) {            enqueueKids(kid);        }    } else {        queue.add(node);    }}
public boolean pdfbox_f7373_0()
{    return !queue.isEmpty();}
public PDPage pdfbox_f7374_0()
{    COSDictionary next = queue.poll();    sanitizeType(next);    ResourceCache resourceCache = document != null ? document.getResourceCache() : null;    return new PDPage(next, resourceCache);}
public void pdfbox_f7375_0()
{    throw new UnsupportedOperationException();}
public PDPage pdfbox_f7376_0(int index)
{    COSDictionary dict = get(index + 1, root, 0);    sanitizeType(dict);    ResourceCache resourceCache = document != null ? document.getResourceCache() : null;    return new PDPage(dict, resourceCache);}
private static void pdfbox_f7377_0(COSDictionary dictionary)
{    COSName type = dictionary.getCOSName(COSName.TYPE);    if (type == null) {        dictionary.setItem(COSName.TYPE, COSName.PAGE);        return;    }    if (!COSName.PAGE.equals(type)) {        throw new IllegalStateException("Expected 'Page' but found " + type);    }}
private COSDictionary pdfbox_f7378_0(int pageNum, COSDictionary node, int encountered)
{    if (pageNum < 0) {        throw new IndexOutOfBoundsException("Index out of bounds: " + pageNum);    }    if (isPageTreeNode(node)) {        int count = node.getInt(COSName.COUNT, 0);        if (pageNum <= encountered + count) {                        for (COSDictionary kid : getKids(node)) {                                if (isPageTreeNode(kid)) {                    int kidCount = kid.getInt(COSName.COUNT, 0);                    if (pageNum <= encountered + kidCount) {                                                return get(pageNum, kid, encountered);                    } else {                        encountered += kidCount;                    }                } else {                                        encountered++;                    if (pageNum == encountered) {                                                return get(pageNum, kid, encountered);                    }                }            }            throw new IllegalStateException("1-based index not found: " + pageNum);        } else {            throw new IndexOutOfBoundsException("1-based index out of bounds: " + pageNum);        }    } else {        if (encountered == pageNum) {            return node;        } else {            throw new IllegalStateException("1-based index not found: " + pageNum);        }    }}
private boolean pdfbox_f7379_0(COSDictionary node)
{        return node != null && (node.getCOSName(COSName.TYPE) == COSName.PAGES || node.containsKey(COSName.KIDS));}
public int pdfbox_f7380_0(PDPage page)
{    SearchContext context = new SearchContext(page);    if (findPage(context, root)) {        return context.index;    }    return -1;}
private boolean pdfbox_f7381_0(SearchContext context, COSDictionary node)
{    for (COSDictionary kid : getKids(node)) {        if (context.found) {            break;        }        if (isPageTreeNode(kid)) {            findPage(context, kid);        } else {            context.visitPage(kid);        }    }    return context.found;}
private void pdfbox_f7382_0(COSDictionary current)
{    index++;    found = searched.equals(current);}
public int pdfbox_f7383_0()
{    return root.getInt(COSName.COUNT, 0);}
public COSDictionary pdfbox_f7384_0()
{    return root;}
public void pdfbox_f7385_0(int index)
{    COSDictionary node = get(index + 1, root, 0);    remove(node);}
public void pdfbox_f7386_0(PDPage page)
{    remove(page.getCOSObject());}
private void pdfbox_f7387_0(COSDictionary node)
{        COSDictionary parent = (COSDictionary) node.getDictionaryObject(COSName.PARENT, COSName.P);    COSArray kids = (COSArray) parent.getDictionaryObject(COSName.KIDS);    if (kids.removeObject(node)) {                do {            node = (COSDictionary) node.getDictionaryObject(COSName.PARENT, COSName.P);            if (node != null) {                node.setInt(COSName.COUNT, node.getInt(COSName.COUNT) - 1);            }        } while (node != null);    }}
public void pdfbox_f7388_0(PDPage page)
{        COSDictionary node = page.getCOSObject();    node.setItem(COSName.PARENT, root);            COSArray kids = (COSArray) root.getDictionaryObject(COSName.KIDS);    kids.add(node);        do {        node = (COSDictionary) node.getDictionaryObject(COSName.PARENT, COSName.P);        if (node != null) {            node.setInt(COSName.COUNT, node.getInt(COSName.COUNT) + 1);        }    } while (node != null);}
public void pdfbox_f7389_0(PDPage newPage, PDPage nextPage)
{    COSDictionary nextPageDict = nextPage.getCOSObject();    COSDictionary parentDict = (COSDictionary) nextPageDict.getDictionaryObject(COSName.PARENT);    COSArray kids = (COSArray) parentDict.getDictionaryObject(COSName.KIDS);    boolean found = false;    for (int i = 0; i < kids.size(); ++i) {        COSDictionary pageDict = (COSDictionary) kids.getObject(i);        if (pageDict.equals(nextPage.getCOSObject())) {            kids.add(i, newPage.getCOSObject());            newPage.getCOSObject().setItem(COSName.PARENT, parentDict);            found = true;            break;        }    }    if (!found) {        throw new IllegalArgumentException("attempted to insert before orphan page");    }    increaseParents(parentDict);}
public void pdfbox_f7390_0(PDPage newPage, PDPage prevPage)
{    COSDictionary prevPageDict = prevPage.getCOSObject();    COSDictionary parentDict = (COSDictionary) prevPageDict.getDictionaryObject(COSName.PARENT);    COSArray kids = (COSArray) parentDict.getDictionaryObject(COSName.KIDS);    boolean found = false;    for (int i = 0; i < kids.size(); ++i) {        COSDictionary pageDict = (COSDictionary) kids.getObject(i);        if (pageDict.equals(prevPage.getCOSObject())) {            kids.add(i + 1, newPage.getCOSObject());            newPage.getCOSObject().setItem(COSName.PARENT, parentDict);            found = true;            break;        }    }    if (!found) {        throw new IllegalArgumentException("attempted to insert before orphan page");    }    increaseParents(parentDict);}
private void pdfbox_f7391_0(COSDictionary parentDict)
{    do {        int cnt = parentDict.getInt(COSName.COUNT);        parentDict.setInt(COSName.COUNT, cnt + 1);        parentDict = (COSDictionary) parentDict.getDictionaryObject(COSName.PARENT);    } while (parentDict != null);}
public COSDictionary pdfbox_f7392_0()
{    return resources;}
public PDFont pdfbox_f7393_0(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.FONT, name);    if (cache != null && indirect != null) {        PDFont cached = cache.getFont(indirect);        if (cached != null) {            return cached;        }    } else if (indirect == null) {        SoftReference<PDFont> ref = directFontCache.get(name);        if (ref != null) {            PDFont cached = ref.get();            if (cached != null) {                return cached;            }        }    }    PDFont font = null;    COSDictionary dict = (COSDictionary) get(COSName.FONT, name);    if (dict != null) {        font = PDFontFactory.createFont(dict, cache);    }    if (cache != null && indirect != null) {        cache.put(indirect, font);    } else if (indirect == null) {        directFontCache.put(name, new SoftReference<>(font));    }    return font;}
public PDColorSpace pdfbox_f7394_0(COSName name) throws IOException
{    return getColorSpace(name, false);}
public PDColorSpace pdfbox_f7395_0(COSName name, boolean wasDefault) throws IOException
{    COSObject indirect = getIndirect(COSName.COLORSPACE, name);    if (cache != null && indirect != null) {        PDColorSpace cached = cache.getColorSpace(indirect);        if (cached != null) {            return cached;        }    }        PDColorSpace colorSpace;    COSBase object = get(COSName.COLORSPACE, name);    if (object != null) {        colorSpace = PDColorSpace.create(object, this, wasDefault);    } else {        colorSpace = PDColorSpace.create(name, this, wasDefault);    }        if (cache != null && !(colorSpace instanceof PDPattern)) {        cache.put(indirect, colorSpace);    }    return colorSpace;}
public boolean pdfbox_f7396_0(COSName name)
{    return get(COSName.COLORSPACE, name) != null;}
public PDExtendedGraphicsState pdfbox_f7397_0(COSName name)
{    COSObject indirect = getIndirect(COSName.EXT_G_STATE, name);    if (cache != null && indirect != null) {        PDExtendedGraphicsState cached = cache.getExtGState(indirect);        if (cached != null) {            return cached;        }    }        PDExtendedGraphicsState extGState = null;    COSDictionary dict = (COSDictionary) get(COSName.EXT_G_STATE, name);    if (dict != null) {        extGState = new PDExtendedGraphicsState(dict);    }    if (cache != null) {        cache.put(indirect, extGState);    }    return extGState;}
public PDShading pdfbox_f7398_0(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.SHADING, name);    if (cache != null && indirect != null) {        PDShading cached = cache.getShading(indirect);        if (cached != null) {            return cached;        }    }        PDShading shading = null;    COSDictionary dict = (COSDictionary) get(COSName.SHADING, name);    if (dict != null) {        shading = PDShading.create(dict);    }    if (cache != null) {        cache.put(indirect, shading);    }    return shading;}
public PDAbstractPattern pdfbox_f7399_0(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.PATTERN, name);    if (cache != null && indirect != null) {        PDAbstractPattern cached = cache.getPattern(indirect);        if (cached != null) {            return cached;        }    }        PDAbstractPattern pattern = null;    COSDictionary dict = (COSDictionary) get(COSName.PATTERN, name);    if (dict != null) {        pattern = PDAbstractPattern.create(dict);    }    if (cache != null) {        cache.put(indirect, pattern);    }    return pattern;}
public PDPropertyList pdfbox_f7400_0(COSName name)
{    COSObject indirect = getIndirect(COSName.PROPERTIES, name);    if (cache != null && indirect != null) {        PDPropertyList cached = cache.getProperties(indirect);        if (cached != null) {            return cached;        }    }        PDPropertyList propertyList = null;    COSDictionary dict = (COSDictionary) get(COSName.PROPERTIES, name);    if (dict != null) {        propertyList = PDPropertyList.create(dict);    }    if (cache != null) {        cache.put(indirect, propertyList);    }    return propertyList;}
public boolean pdfbox_f7401_0(COSName name)
{        COSBase value = get(COSName.XOBJECT, name);    if (value == null) {        return false;    } else if (value instanceof COSObject) {        value = ((COSObject) value).getObject();    }    if (!(value instanceof COSStream)) {        return false;    }    COSStream stream = (COSStream) value;    return COSName.IMAGE.equals(stream.getCOSName(COSName.SUBTYPE));}
public PDXObject pdfbox_f7402_0(COSName name) throws IOException
{    COSObject indirect = getIndirect(COSName.XOBJECT, name);    if (cache != null && indirect != null) {        PDXObject cached = cache.getXObject(indirect);        if (cached != null) {            return cached;        }    }        PDXObject xobject;    COSBase value = get(COSName.XOBJECT, name);    if (value == null) {        xobject = null;    } else if (value instanceof COSObject) {        xobject = PDXObject.createXObject(((COSObject) value).getObject(), this);    } else {        xobject = PDXObject.createXObject(value, this);    }    if (cache != null && isAllowedCache(xobject)) {        cache.put(indirect, xobject);    }    return xobject;}
private boolean pdfbox_f7403_0(PDXObject xobject)
{    if (xobject instanceof PDImageXObject) {        COSBase colorSpace = xobject.getCOSObject().getDictionaryObject(COSName.COLORSPACE);        if (colorSpace instanceof COSName) {                        COSName colorSpaceName = (COSName) colorSpace;            if (colorSpaceName.equals(COSName.DEVICECMYK) && hasColorSpace(COSName.DEFAULT_CMYK)) {                return false;            }            if (colorSpaceName.equals(COSName.DEVICERGB) && hasColorSpace(COSName.DEFAULT_RGB)) {                return false;            }            if (colorSpaceName.equals(COSName.DEVICEGRAY) && hasColorSpace(COSName.DEFAULT_GRAY)) {                return false;            }            if (hasColorSpace(colorSpaceName)) {                return false;            }        }    }    return true;}
private COSObject pdfbox_f7404_0(COSName kind, COSName name)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return null;    }    COSBase base = dict.getItem(name);    if (base instanceof COSObject) {        return (COSObject) base;    }        return null;}
private COSBase pdfbox_f7405_0(COSName kind, COSName name)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return null;    }    return dict.getDictionaryObject(name);}
public Iterable<COSName> pdfbox_f7406_0()
{    return getNames(COSName.COLORSPACE);}
public Iterable<COSName> pdfbox_f7407_0()
{    return getNames(COSName.XOBJECT);}
public Iterable<COSName> pdfbox_f7408_0()
{    return getNames(COSName.FONT);}
public Iterable<COSName> pdfbox_f7409_0()
{    return getNames(COSName.PROPERTIES);}
public Iterable<COSName> pdfbox_f7410_0()
{    return getNames(COSName.SHADING);}
public Iterable<COSName> pdfbox_f7411_0()
{    return getNames(COSName.PATTERN);}
public Iterable<COSName> pdfbox_f7412_0()
{    return getNames(COSName.EXT_G_STATE);}
private Iterable<COSName> pdfbox_f7413_0(COSName kind)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return Collections.emptySet();    }    return dict.keySet();}
public COSName pdfbox_f7414_0(PDFont font)
{    return add(COSName.FONT, "F", font);}
public COSName pdfbox_f7415_0(PDColorSpace colorSpace)
{    return add(COSName.COLORSPACE, "cs", colorSpace);}
public COSName pdfbox_f7416_0(PDExtendedGraphicsState extGState)
{    return add(COSName.EXT_G_STATE, "gs", extGState);}
public COSName pdfbox_f7417_0(PDShading shading)
{    return add(COSName.SHADING, "sh", shading);}
public COSName pdfbox_f7418_0(PDAbstractPattern pattern)
{    return add(COSName.PATTERN, "p", pattern);}
public COSName pdfbox_f7419_0(PDPropertyList properties)
{    if (properties instanceof PDOptionalContentGroup) {        return add(COSName.PROPERTIES, "oc", properties);    } else {        return add(COSName.PROPERTIES, "Prop", properties);    }}
public COSName pdfbox_f7420_0(PDImageXObject image)
{    return add(COSName.XOBJECT, "Im", image);}
public COSName pdfbox_f7421_0(PDFormXObject form)
{    return add(COSName.XOBJECT, "Form", form);}
public COSName pdfbox_f7422_0(PDXObject xobject, String prefix)
{    return add(COSName.XOBJECT, prefix, xobject);}
private COSName pdfbox_f7423_0(COSName kind, String prefix, COSObjectable object)
{        COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict != null && dict.containsValue(object.getCOSObject())) {        return dict.getKeyForValue(object.getCOSObject());    }        if (dict != null && COSName.FONT.equals(kind)) {        for (Map.Entry<COSName, COSBase> entry : dict.entrySet()) {            if (entry.getValue() instanceof COSObject && object.getCOSObject() == ((COSObject) entry.getValue()).getObject()) {                return entry.getKey();            }        }    }        COSName name = createKey(kind, prefix);    put(kind, name, object);    return name;}
private COSName pdfbox_f7424_0(COSName kind, String prefix)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        return COSName.getPDFName(prefix + 1);    }        String key;    int n = dict.keySet().size();    do {        ++n;        key = prefix + n;    } while (dict.containsKey(key));    return COSName.getPDFName(key);}
private void pdfbox_f7425_0(COSName kind, COSName name, COSObjectable object)
{    COSDictionary dict = (COSDictionary) resources.getDictionaryObject(kind);    if (dict == null) {        dict = new COSDictionary();        resources.setItem(kind, dict);    }    dict.setItem(name, object);}
public void pdfbox_f7426_0(COSName name, PDFont font)
{    put(COSName.FONT, name, font);}
public void pdfbox_f7427_0(COSName name, PDColorSpace colorSpace)
{    put(COSName.COLORSPACE, name, colorSpace);}
public void pdfbox_f7428_0(COSName name, PDExtendedGraphicsState extGState)
{    put(COSName.EXT_G_STATE, name, extGState);}
public void pdfbox_f7429_0(COSName name, PDShading shading)
{    put(COSName.SHADING, name, shading);}
public void pdfbox_f7430_0(COSName name, PDAbstractPattern pattern)
{    put(COSName.PATTERN, name, pattern);}
public void pdfbox_f7431_0(COSName name, PDPropertyList properties)
{    put(COSName.PROPERTIES, name, properties);}
public void pdfbox_f7432_0(COSName name, PDXObject xobject)
{    put(COSName.XOBJECT, name, xobject);}
public ResourceCache pdfbox_f7433_0()
{    return cache;}
protected PDStructureElement pdfbox_f7434_0(COSBase base) throws IOException
{    return new PDStructureElement((COSDictionary) base);}
protected PDNameTreeNode<PDStructureElement> pdfbox_f7435_0(COSDictionary dic)
{    return new PDStructureElementNameTreeNode(dic);}
public RenderingHints pdfbox_f7436_0()
{    return renderingHints;}
public void pdfbox_f7437_0(RenderingHints renderingHints)
{    this.renderingHints = renderingHints;}
public boolean pdfbox_f7438_0()
{    return subsamplingAllowed;}
public void pdfbox_f7439_0(boolean subsamplingAllowed)
{    this.subsamplingAllowed = subsamplingAllowed;}
public int pdfbox_f7440_0()
{    return document.getNumberOfPages();}
public PageFormat pdfbox_f7441_0(int pageIndex)
{    PDPage page = document.getPage(pageIndex);    PDRectangle mediaBox = PDFPrintable.getRotatedMediaBox(page);    PDRectangle cropBox = PDFPrintable.getRotatedCropBox(page);                            Paper paper;    boolean isLandscape;    if (mediaBox.getWidth() > mediaBox.getHeight()) {                paper = new Paper();        paper.setSize(mediaBox.getHeight(), mediaBox.getWidth());        paper.setImageableArea(cropBox.getLowerLeftY(), cropBox.getLowerLeftX(), cropBox.getHeight(), cropBox.getWidth());        isLandscape = true;    } else {        paper = new Paper();        paper.setSize(mediaBox.getWidth(), mediaBox.getHeight());        paper.setImageableArea(cropBox.getLowerLeftX(), cropBox.getLowerLeftY(), cropBox.getWidth(), cropBox.getHeight());        isLandscape = false;    }    PageFormat format = new PageFormat();    format.setPaper(paper);        switch(orientation) {        case AUTO:            format.setOrientation(isLandscape ? PageFormat.LANDSCAPE : PageFormat.PORTRAIT);            break;        case LANDSCAPE:            format.setOrientation(PageFormat.LANDSCAPE);            break;        case PORTRAIT:            format.setOrientation(PageFormat.PORTRAIT);            break;        default:            break;    }    return format;}
public Printable pdfbox_f7442_0(int i)
{    if (i >= getNumberOfPages()) {        throw new IndexOutOfBoundsException(i + " >= " + getNumberOfPages());    }    PDFPrintable printable = new PDFPrintable(document, Scaling.ACTUAL_SIZE, showPageBorder, dpi);    printable.setSubsamplingAllowed(subsamplingAllowed);    printable.setRenderingHints(renderingHints);    return printable;}
public boolean pdfbox_f7443_0()
{    return subsamplingAllowed;}
public void pdfbox_f7444_0(boolean subsamplingAllowed)
{    this.subsamplingAllowed = subsamplingAllowed;}
public RenderingHints pdfbox_f7445_0()
{    return renderingHints;}
public void pdfbox_f7446_0(RenderingHints renderingHints)
{    this.renderingHints = renderingHints;}
public int pdfbox_f7447_0(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException
{    if (pageIndex < 0 || pageIndex >= document.getNumberOfPages()) {        return NO_SUCH_PAGE;    }    try {        Graphics2D graphics2D = (Graphics2D) graphics;        PDPage page = document.getPage(pageIndex);        PDRectangle cropBox = getRotatedCropBox(page);                final double imageableWidth = pageFormat.getImageableWidth();        final double imageableHeight = pageFormat.getImageableHeight();        double scale = 1;        if (scaling != Scaling.ACTUAL_SIZE) {                        double scaleX = imageableWidth / cropBox.getWidth();            double scaleY = imageableHeight / cropBox.getHeight();            scale = Math.min(scaleX, scaleY);                        if (scale > 1 && scaling == Scaling.SHRINK_TO_FIT) {                scale = 1;            }                        if (scale < 1 && scaling == Scaling.STRETCH_TO_FIT) {                scale = 1;            }        }                graphics2D.translate(pageFormat.getImageableX(), pageFormat.getImageableY());                if (center) {            graphics2D.translate((imageableWidth - cropBox.getWidth() * scale) / 2, (imageableHeight - cropBox.getHeight() * scale) / 2);        }                Graphics2D printerGraphics = null;        BufferedImage image = null;        if (dpi > 0) {            float dpiScale = dpi / 72;            image = new BufferedImage((int) (imageableWidth * dpiScale / scale), (int) (imageableHeight * dpiScale / scale), BufferedImage.TYPE_INT_ARGB);            printerGraphics = graphics2D;            graphics2D = image.createGraphics();                        printerGraphics.scale(scale / dpiScale, scale / dpiScale);            scale = dpiScale;        }                AffineTransform transform = (AffineTransform) graphics2D.getTransform().clone();        graphics2D.setBackground(Color.WHITE);        renderer.setSubsamplingAllowed(subsamplingAllowed);        renderer.setRenderingHints(renderingHints);        renderer.renderPageToGraphics(pageIndex, graphics2D, (float) scale, (float) scale, RenderDestination.PRINT);                if (showPageBorder) {            graphics2D.setTransform(transform);            graphics2D.setClip(0, 0, (int) imageableWidth, (int) imageableHeight);            graphics2D.scale(scale, scale);            graphics2D.setColor(Color.GRAY);            graphics2D.setStroke(new BasicStroke(0.5f));            graphics.drawRect(0, 0, (int) cropBox.getWidth(), (int) cropBox.getHeight());        }                if (printerGraphics != null) {            printerGraphics.setBackground(Color.WHITE);            printerGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());            printerGraphics.drawImage(image, 0, 0, null);            graphics2D.dispose();        }        return PAGE_EXISTS;    } catch (IOException e) {        throw new PrinterIOException(e);    }}
 static PDRectangle pdfbox_f7448_0(PDPage page)
{    PDRectangle cropBox = page.getCropBox();    int rotationAngle = page.getRotation();    if (rotationAngle == 90 || rotationAngle == 270) {        return new PDRectangle(cropBox.getLowerLeftY(), cropBox.getLowerLeftX(), cropBox.getHeight(), cropBox.getWidth());    } else {        return cropBox;    }}
 static PDRectangle pdfbox_f7449_0(PDPage page)
{    PDRectangle mediaBox = page.getMediaBox();    int rotationAngle = page.getRotation();    if (rotationAngle == 90 || rotationAngle == 270) {        return new PDRectangle(mediaBox.getLowerLeftY(), mediaBox.getLowerLeftX(), mediaBox.getHeight(), mediaBox.getWidth());    } else {        return mediaBox;    }}
public GeneralPath pdfbox_f7450_1(int code)
{    GeneralPath path = cache.get(code);    if (path != null) {        return path;    }    try {        if (!font.hasGlyph(code)) {            String fontName = ((PDFontLike) font).getName();            if (font instanceof PDType0Font) {                int cid = ((PDType0Font) font).codeToCID(code);                String cidHex = String.format("%04x", cid);                            } else if (font instanceof PDSimpleFont) {                                PDSimpleFont simpleFont = (PDSimpleFont) font;                if (code == 10 && simpleFont.isStandard14()) {                                        path = new GeneralPath();                    cache.put(code, path);                    return path;                }            } else {                            }        }        path = font.getNormalizedPath(code);        cache.put(code, path);        return path;    } catch (IOException e) {                        return new GeneralPath();    }}
public void pdfbox_f7451_0(int x, int y, int width, int height)
{    groupG2D.clearRect(x, y, width, height);    alphaG2D.clearRect(x, y, width, height);}
public void pdfbox_f7452_0(int x, int y, int width, int height)
{    groupG2D.clipRect(x, y, width, height);    alphaG2D.clipRect(x, y, width, height);}
public void pdfbox_f7453_0(int x, int y, int width, int height, int dx, int dy)
{    groupG2D.copyArea(x, y, width, height, dx, dy);    alphaG2D.copyArea(x, y, width, height, dx, dy);}
public Graphics pdfbox_f7454_0()
{    Graphics g = groupG2D.create();    Graphics a = alphaG2D.create();    if (g instanceof Graphics2D && a instanceof Graphics2D) {        return new GroupGraphics(groupImage, (Graphics2D) g, groupAlphaImage, (Graphics2D) a);    }    throw new UnsupportedOperationException();}
public void pdfbox_f7455_0()
{    groupG2D.dispose();    alphaG2D.dispose();}
public void pdfbox_f7456_0(int x, int y, int width, int height, int startAngle, int arcAngle)
{    groupG2D.drawArc(x, y, width, height, startAngle, arcAngle);    alphaG2D.drawArc(x, y, width, height, startAngle, arcAngle);}
public boolean pdfbox_f7457_0(Image img, int x, int y, Color bgcolor, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, bgcolor, observer);    return alphaG2D.drawImage(img, x, y, bgcolor, observer);}
public boolean pdfbox_f7458_0(Image img, int x, int y, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, observer);    return alphaG2D.drawImage(img, x, y, observer);}
public boolean pdfbox_f7459_0(Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, width, height, bgcolor, observer);    return alphaG2D.drawImage(img, x, y, width, height, bgcolor, observer);}
public boolean pdfbox_f7460_0(Image img, int x, int y, int width, int height, ImageObserver observer)
{    groupG2D.drawImage(img, x, y, width, height, observer);    return alphaG2D.drawImage(img, x, y, width, height, observer);}
public boolean pdfbox_f7461_0(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor, ImageObserver observer)
{    groupG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);    return alphaG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);}
public boolean pdfbox_f7462_0(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer)
{    groupG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);    return alphaG2D.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);}
public void pdfbox_f7463_0(int x1, int y1, int x2, int y2)
{    groupG2D.drawLine(x1, y1, x2, y2);    alphaG2D.drawLine(x1, y1, x2, y2);}
public void pdfbox_f7464_0(int x, int y, int width, int height)
{    groupG2D.drawOval(x, y, width, height);    alphaG2D.drawOval(x, y, width, height);}
public void pdfbox_f7465_0(int[] xPoints, int[] yPoints, int nPoints)
{    groupG2D.drawPolygon(xPoints, yPoints, nPoints);    alphaG2D.drawPolygon(xPoints, yPoints, nPoints);}
public void pdfbox_f7466_0(int[] xPoints, int[] yPoints, int nPoints)
{    groupG2D.drawPolyline(xPoints, yPoints, nPoints);    alphaG2D.drawPolyline(xPoints, yPoints, nPoints);}
public void pdfbox_f7467_0(int x, int y, int width, int height, int arcWidth, int arcHeight)
{    groupG2D.drawRoundRect(x, y, width, height, arcWidth, arcHeight);    alphaG2D.drawRoundRect(x, y, width, height, arcWidth, arcHeight);}
public void pdfbox_f7468_0(AttributedCharacterIterator iterator, int x, int y)
{    groupG2D.drawString(iterator, x, y);    alphaG2D.drawString(iterator, x, y);}
public void pdfbox_f7469_0(String str, int x, int y)
{    groupG2D.drawString(str, x, y);    alphaG2D.drawString(str, x, y);}
public void pdfbox_f7470_0(int x, int y, int width, int height, int startAngle, int arcAngle)
{    groupG2D.fillArc(x, y, width, height, startAngle, arcAngle);    alphaG2D.fillArc(x, y, width, height, startAngle, arcAngle);}
public void pdfbox_f7471_0(int x, int y, int width, int height)
{    groupG2D.fillOval(x, y, width, height);    alphaG2D.fillOval(x, y, width, height);}
public void pdfbox_f7472_0(int[] xPoints, int[] yPoints, int nPoints)
{    groupG2D.fillPolygon(xPoints, yPoints, nPoints);    alphaG2D.fillPolygon(xPoints, yPoints, nPoints);}
public void pdfbox_f7473_0(int x, int y, int width, int height)
{    groupG2D.fillRect(x, y, width, height);    alphaG2D.fillRect(x, y, width, height);}
public void pdfbox_f7474_0(int x, int y, int width, int height, int arcWidth, int arcHeight)
{    groupG2D.fillRoundRect(x, y, width, height, arcWidth, arcHeight);    alphaG2D.fillRoundRect(x, y, width, height, arcWidth, arcHeight);}
public Shape pdfbox_f7475_0()
{    return groupG2D.getClip();}
public Rectangle pdfbox_f7476_0()
{    return groupG2D.getClipBounds();}
public Color pdfbox_f7477_0()
{    return groupG2D.getColor();}
public Font pdfbox_f7478_0()
{    return groupG2D.getFont();}
public FontMetrics pdfbox_f7479_0(Font f)
{    return groupG2D.getFontMetrics(f);}
public void pdfbox_f7480_0(int x, int y, int width, int height)
{    groupG2D.setClip(x, y, width, height);    alphaG2D.setClip(x, y, width, height);}
public void pdfbox_f7481_0(Shape clip)
{    groupG2D.setClip(clip);    alphaG2D.setClip(clip);}
public void pdfbox_f7482_0(Color c)
{    groupG2D.setColor(c);    alphaG2D.setColor(c);}
public void pdfbox_f7483_0(Font font)
{    groupG2D.setFont(font);    alphaG2D.setFont(font);}
public void pdfbox_f7484_0()
{    groupG2D.setPaintMode();    alphaG2D.setPaintMode();}
public void pdfbox_f7485_0(Color c1)
{    groupG2D.setXORMode(c1);    alphaG2D.setXORMode(c1);}
public void pdfbox_f7486_0(int x, int y)
{    groupG2D.translate(x, y);    alphaG2D.translate(x, y);}
public void pdfbox_f7487_0(Map<?, ?> hints)
{    groupG2D.addRenderingHints(hints);    alphaG2D.addRenderingHints(hints);}
public void pdfbox_f7488_0(Shape s)
{    groupG2D.clip(s);    alphaG2D.clip(s);}
public void pdfbox_f7489_0(Shape s)
{    groupG2D.draw(s);    alphaG2D.draw(s);}
public void pdfbox_f7490_0(GlyphVector g, float x, float y)
{    groupG2D.drawGlyphVector(g, x, y);    alphaG2D.drawGlyphVector(g, x, y);}
public void pdfbox_f7491_0(BufferedImage img, BufferedImageOp op, int x, int y)
{    groupG2D.drawImage(img, op, x, y);    alphaG2D.drawImage(img, op, x, y);}
public boolean pdfbox_f7492_0(Image img, AffineTransform xform, ImageObserver obs)
{    groupG2D.drawImage(img, xform, obs);    return alphaG2D.drawImage(img, xform, obs);}
public void pdfbox_f7493_0(RenderableImage img, AffineTransform xform)
{    groupG2D.drawRenderableImage(img, xform);    alphaG2D.drawRenderableImage(img, xform);}
public void pdfbox_f7494_0(RenderedImage img, AffineTransform xform)
{    groupG2D.drawRenderedImage(img, xform);    alphaG2D.drawRenderedImage(img, xform);}
public void pdfbox_f7495_0(AttributedCharacterIterator iterator, float x, float y)
{    groupG2D.drawString(iterator, x, y);    alphaG2D.drawString(iterator, x, y);}
public void pdfbox_f7496_0(String str, float x, float y)
{    groupG2D.drawString(str, x, y);    alphaG2D.drawString(str, x, y);}
public void pdfbox_f7497_0(Shape s)
{    groupG2D.fill(s);    alphaG2D.fill(s);}
public Color pdfbox_f7498_0()
{    return groupG2D.getBackground();}
public Composite pdfbox_f7499_0()
{    return groupG2D.getComposite();}
public GraphicsConfiguration pdfbox_f7500_0()
{    return groupG2D.getDeviceConfiguration();}
public FontRenderContext pdfbox_f7501_0()
{    return groupG2D.getFontRenderContext();}
public Paint pdfbox_f7502_0()
{    return groupG2D.getPaint();}
public Object pdfbox_f7503_0(RenderingHints.Key hintKey)
{    return groupG2D.getRenderingHint(hintKey);}
public RenderingHints pdfbox_f7504_0()
{    return groupG2D.getRenderingHints();}
public Stroke pdfbox_f7505_0()
{    return groupG2D.getStroke();}
public AffineTransform pdfbox_f7506_0()
{    return groupG2D.getTransform();}
public boolean pdfbox_f7507_0(Rectangle rect, Shape s, boolean onStroke)
{    return groupG2D.hit(rect, s, onStroke);}
public void pdfbox_f7508_0(double theta)
{    groupG2D.rotate(theta);    alphaG2D.rotate(theta);}
public void pdfbox_f7509_0(double theta, double x, double y)
{    groupG2D.rotate(theta, x, y);    alphaG2D.rotate(theta, x, y);}
public void pdfbox_f7510_0(double sx, double sy)
{    groupG2D.scale(sx, sy);    alphaG2D.scale(sx, sy);}
public void pdfbox_f7511_0(Color color)
{    groupG2D.setBackground(color);    alphaG2D.setBackground(color);}
public void pdfbox_f7512_0(Composite comp)
{    groupG2D.setComposite(comp);    alphaG2D.setComposite(comp);}
public void pdfbox_f7513_0(Paint paint)
{    groupG2D.setPaint(paint);    alphaG2D.setPaint(paint);}
public void pdfbox_f7514_0(RenderingHints.Key hintKey, Object hintValue)
{    groupG2D.setRenderingHint(hintKey, hintValue);    alphaG2D.setRenderingHint(hintKey, hintValue);}
public void pdfbox_f7515_0(Map<?, ?> hints)
{    groupG2D.setRenderingHints(hints);    alphaG2D.setRenderingHints(hints);}
public void pdfbox_f7516_0(Stroke s)
{    groupG2D.setStroke(s);    alphaG2D.setStroke(s);}
public void pdfbox_f7517_0(AffineTransform tx)
{    groupG2D.setTransform(tx);    alphaG2D.setTransform(tx);}
public void pdfbox_f7518_0(double shx, double shy)
{    groupG2D.shear(shx, shy);    alphaG2D.shear(shx, shy);}
public void pdfbox_f7519_0(AffineTransform tx)
{    groupG2D.transform(tx);    alphaG2D.transform(tx);}
public void pdfbox_f7520_0(double tx, double ty)
{    groupG2D.translate(tx, ty);    alphaG2D.translate(tx, ty);}
 void pdfbox_f7521_0(BufferedImage backdrop, int offsetX, int offsetY)
{    int groupWidth = groupImage.getWidth();    int groupHeight = groupImage.getHeight();    int backdropWidth = backdrop.getWidth();    int backdropHeight = backdrop.getHeight();    int groupType = groupImage.getType();    int groupAlphaType = groupAlphaImage.getType();    int backdropType = backdrop.getType();    DataBuffer groupDataBuffer = groupImage.getRaster().getDataBuffer();    DataBuffer groupAlphaDataBuffer = groupAlphaImage.getRaster().getDataBuffer();    DataBuffer backdropDataBuffer = backdrop.getRaster().getDataBuffer();    if (groupType == BufferedImage.TYPE_INT_ARGB && groupAlphaType == BufferedImage.TYPE_INT_ARGB && (backdropType == BufferedImage.TYPE_INT_ARGB || backdropType == BufferedImage.TYPE_INT_RGB) && groupDataBuffer instanceof DataBufferInt && groupAlphaDataBuffer instanceof DataBufferInt && backdropDataBuffer instanceof DataBufferInt) {                int[] groupData = ((DataBufferInt) groupDataBuffer).getData();        int[] groupAlphaData = ((DataBufferInt) groupAlphaDataBuffer).getData();        int[] backdropData = ((DataBufferInt) backdropDataBuffer).getData();        boolean backdropHasAlpha = backdropType == BufferedImage.TYPE_INT_ARGB;        for (int y = 0; y < groupHeight; y++) {            for (int x = 0; x < groupWidth; x++) {                int index = x + y * groupWidth;                                int alphagn = (groupAlphaData[index] >> 24) & 0xFF;                if (alphagn == 0) {                                        groupData[index] = 0;                    continue;                }                int backdropX = x + offsetX;                int backdropY = y + offsetY;                                int backdropRGB;                                float alpha0;                if (backdropX >= 0 && backdropX < backdropWidth && backdropY >= 0 && backdropY < backdropHeight) {                    backdropRGB = backdropData[backdropX + backdropY * backdropWidth];                    alpha0 = backdropHasAlpha ? ((backdropRGB >> 24) & 0xFF) : 255;                } else {                                        backdropRGB = 0;                    alpha0 = 0;                }                                float alphaFactor = alpha0 / (float) alphagn - alpha0 / 255.0f;                                int groupRGB = groupData[index];                                int r = backdropRemoval(groupRGB, backdropRGB, 16, alphaFactor);                int g = backdropRemoval(groupRGB, backdropRGB, 8, alphaFactor);                int b = backdropRemoval(groupRGB, backdropRGB, 0, alphaFactor);                                                groupData[index] = (alphagn << 24) | (r << 16) | (g << 8) | b;            }        }    } else {        for (int y = 0; y < groupHeight; y++) {            for (int x = 0; x < groupWidth; x++) {                int alphagn = (groupAlphaImage.getRGB(x, y) >> 24) & 0xFF;                if (alphagn == 0) {                    groupImage.setRGB(x, y, 0);                    continue;                }                int backdropX = x + offsetX;                int backdropY = y + offsetY;                int backdropRGB;                float alpha0;                if (backdropX >= 0 && backdropX < backdropWidth && backdropY >= 0 && backdropY < backdropHeight) {                    backdropRGB = backdrop.getRGB(backdropX, backdropY);                    alpha0 = (backdropRGB >> 24) & 0xFF;                } else {                    backdropRGB = 0;                    alpha0 = 0;                }                int groupRGB = groupImage.getRGB(x, y);                float alphaFactor = alpha0 / alphagn - alpha0 / 255.0f;                int r = backdropRemoval(groupRGB, backdropRGB, 16, alphaFactor);                int g = backdropRemoval(groupRGB, backdropRGB, 8, alphaFactor);                int b = backdropRemoval(groupRGB, backdropRGB, 0, alphaFactor);                groupImage.setRGB(x, y, (alphagn << 24) | (r << 16) | (g << 8) | b);            }        }    }}
private int pdfbox_f7522_0(int groupRGB, int backdropRGB, int shift, float alphaFactor)
{    float cn = (groupRGB >> shift) & 0xFF;    float c0 = (backdropRGB >> shift) & 0xFF;    int c = Math.round(cn + (cn - c0) * alphaFactor);    return (c < 0) ? 0 : (c > 255 ? 255 : c);}
 int pdfbox_f7523_0()
{    return BufferedImage.TYPE_BYTE_BINARY;}
 int pdfbox_f7524_0()
{    return BufferedImage.TYPE_BYTE_GRAY;}
 int pdfbox_f7525_0()
{    return BufferedImage.TYPE_INT_RGB;}
 int pdfbox_f7526_0()
{    return BufferedImage.TYPE_INT_ARGB;}
public AnnotationFilter pdfbox_f7527_0()
{    return annotationFilter;}
public void pdfbox_f7528_0(AnnotationFilter annotationFilter)
{    this.annotationFilter = annotationFilter;}
public final PDFRenderer pdfbox_f7529_0()
{    return renderer;}
protected final Graphics2D pdfbox_f7530_0()
{    return graphics;}
protected final GeneralPath pdfbox_f7531_0()
{    return linePath;}
private void pdfbox_f7532_0()
{    graphics.addRenderingHints(renderingHints);}
public void pdfbox_f7533_0(Graphics g, PDRectangle pageSize) throws IOException
{    graphics = (Graphics2D) g;    xform = graphics.getTransform();    initialClip = graphics.getClip();    this.pageSize = pageSize;    setRenderingHints();    graphics.translate(0, pageSize.getHeight());    graphics.scale(1, -1);        graphics.translate(-pageSize.getLowerLeftX(), -pageSize.getLowerLeftY());    processPage(getPage());    for (PDAnnotation annotation : getPage().getAnnotations(annotationFilter)) {        showAnnotation(annotation);    }    graphics = null;}
 void pdfbox_f7534_0(Graphics2D g, PDTilingPattern pattern, PDColorSpace colorSpace, PDColor color, Matrix patternMatrix) throws IOException
{    Graphics2D savedGraphics = graphics;    graphics = g;    GeneralPath savedLinePath = linePath;    linePath = new GeneralPath();    int savedClipWindingRule = clipWindingRule;    clipWindingRule = -1;    Area savedLastClip = lastClip;    lastClip = null;    Shape savedInitialClip = initialClip;    initialClip = null;    boolean savedFlipTG = flipTG;    flipTG = true;    setRenderingHints();    processTilingPattern(pattern, color, colorSpace, patternMatrix);    flipTG = savedFlipTG;    graphics = savedGraphics;    linePath = savedLinePath;    lastClip = savedLastClip;    initialClip = savedInitialClip;    clipWindingRule = savedClipWindingRule;}
private float pdfbox_f7535_0(float color)
{    return color < 0 ? 0 : (color > 1 ? 1 : color);}
protected Paint pdfbox_f7536_1(PDColor color) throws IOException
{    PDColorSpace colorSpace = color.getColorSpace();    if (!(colorSpace instanceof PDPattern)) {        float[] rgb = colorSpace.toRGB(color.getComponents());        return new Color(clampColor(rgb[0]), clampColor(rgb[1]), clampColor(rgb[2]));    } else {        PDPattern patternSpace = (PDPattern) colorSpace;        PDAbstractPattern pattern = patternSpace.getPattern(color);        if (pattern instanceof PDTilingPattern) {            PDTilingPattern tilingPattern = (PDTilingPattern) pattern;            if (tilingPattern.getPaintType() == PDTilingPattern.PAINT_COLORED) {                                return tilingPaintFactory.create(tilingPattern, null, null, xform);            } else {                                return tilingPaintFactory.create(tilingPattern, patternSpace.getUnderlyingColorSpace(), color, xform);            }        } else {            PDShadingPattern shadingPattern = (PDShadingPattern) pattern;            PDShading shading = shadingPattern.getShading();            if (shading == null) {                                return new Color(0, 0, 0, 0);            }            return shading.toPaint(Matrix.concatenate(getInitialMatrix(), shadingPattern.getMatrix()));        }    }}
private void pdfbox_f7537_0()
{    Area clippingPath = getGraphicsState().getCurrentClippingPath();    if (clippingPath != lastClip) {        graphics.setClip(clippingPath);        if (initialClip != null) {                        }        lastClip = clippingPath;    }}
public void pdfbox_f7538_0() throws IOException
{    setClip();    beginTextClip();}
public void pdfbox_f7539_0() throws IOException
{    endTextClip();}
private void pdfbox_f7540_0()
{        textClippings = new ArrayList<>();}
private void pdfbox_f7541_0()
{    PDGraphicsState state = getGraphicsState();    RenderingMode renderingMode = state.getTextState().getRenderingMode();        if (renderingMode.isClip() && !textClippings.isEmpty()) {                        GeneralPath path = new GeneralPath();        for (Shape shape : textClippings) {            path.append(shape, false);        }        state.intersectClippingPath(path);        textClippings = new ArrayList<>();                        lastClip = null;    }}
protected void pdfbox_f7542_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    AffineTransform at = textRenderingMatrix.createAffineTransform();    at.concatenate(font.getFontMatrix().createAffineTransform());        PDVectorFont vectorFont = (PDVectorFont) font;    GlyphCache cache = glyphCaches.get(font);    if (cache == null) {        cache = new GlyphCache(vectorFont);        glyphCaches.put(font, cache);    }    GeneralPath path = cache.getPathForCharacterCode(code);    drawGlyph(path, font, code, displacement, at);}
private void pdfbox_f7543_0(GeneralPath path, PDFont font, int code, Vector displacement, AffineTransform at) throws IOException
{    PDGraphicsState state = getGraphicsState();    RenderingMode renderingMode = state.getTextState().getRenderingMode();    if (path != null) {                if (!font.isEmbedded() && !font.isVertical() && !font.isStandard14() && font.hasExplicitWidth(code)) {            float fontWidth = font.getWidthFromFont(code);            if (            fontWidth > 0 && Math.abs(fontWidth - displacement.getX() * 1000) > 0.0001) {                float pdfWidth = displacement.getX() * 1000;                at.scale(pdfWidth / fontWidth, 1);            }        }                Shape glyph = at.createTransformedShape(path);        if (renderingMode.isFill()) {            graphics.setComposite(state.getNonStrokingJavaComposite());            graphics.setPaint(getNonStrokingPaint());            setClip();            if (isContentRendered()) {                graphics.fill(glyph);            }        }        if (renderingMode.isStroke()) {            graphics.setComposite(state.getStrokingJavaComposite());            graphics.setPaint(getStrokingPaint());            graphics.setStroke(getStroke());            setClip();            if (isContentRendered()) {                graphics.draw(glyph);            }        }        if (renderingMode.isClip()) {            textClippings.add(glyph);        }    }}
protected void pdfbox_f7544_0(Matrix textRenderingMatrix, PDType3Font font, int code, String unicode, Vector displacement) throws IOException
{    PDGraphicsState state = getGraphicsState();    RenderingMode renderingMode = state.getTextState().getRenderingMode();    if (!RenderingMode.NEITHER.equals(renderingMode)) {        super.showType3Glyph(textRenderingMatrix, font, code, unicode, displacement);    }}
public void pdfbox_f7545_0(Point2D p0, Point2D p1, Point2D p2, Point2D p3)
{            linePath.moveTo((float) p0.getX(), (float) p0.getY());    linePath.lineTo((float) p1.getX(), (float) p1.getY());    linePath.lineTo((float) p2.getX(), (float) p2.getY());    linePath.lineTo((float) p3.getX(), (float) p3.getY());            linePath.closePath();}
private Paint pdfbox_f7546_0(Paint parentPaint, PDSoftMask softMask) throws IOException
{    if (softMask == null || softMask.getGroup() == null) {        return parentPaint;    }    PDColor backdropColor = null;    if (COSName.LUMINOSITY.equals(softMask.getSubType())) {        COSArray backdropColorArray = softMask.getBackdropColor();        PDTransparencyGroup form = softMask.getGroup();        PDColorSpace colorSpace = form.getGroup().getColorSpace(form.getResources());        if (colorSpace != null && backdropColorArray != null) {            backdropColor = new PDColor(backdropColorArray, colorSpace);        }    }    TransparencyGroup transparencyGroup = new TransparencyGroup(softMask.getGroup(), true, softMask.getInitialTransformationMatrix(), backdropColor);    BufferedImage image = transparencyGroup.getImage();    if (image == null) {                return parentPaint;    }    BufferedImage gray = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);    if (COSName.ALPHA.equals(softMask.getSubType())) {        gray.setData(image.getAlphaRaster());    } else if (COSName.LUMINOSITY.equals(softMask.getSubType())) {        Graphics g = gray.getGraphics();        g.drawImage(image, 0, 0, null);        g.dispose();    } else {        throw new IOException("Invalid soft mask subtype.");    }    gray = adjustImage(gray);    Rectangle2D tpgBounds = transparencyGroup.getBounds();    adjustRectangle(tpgBounds);    return new SoftMask(parentPaint, gray, tpgBounds, backdropColor, softMask.getTransferFunction());}
private void pdfbox_f7547_0(Rectangle2D r)
{    Matrix m = new Matrix(xform);    float scaleX = Math.abs(m.getScalingFactorX());    float scaleY = Math.abs(m.getScalingFactorY());    AffineTransform adjustedTransform = new AffineTransform(xform);    adjustedTransform.scale(1.0 / scaleX, 1.0 / scaleY);    r.setRect(adjustedTransform.createTransformedShape(r).getBounds2D());}
private BufferedImage pdfbox_f7548_0(BufferedImage gray) throws IOException
{    AffineTransform at = new AffineTransform(xform);    Matrix m = new Matrix(at);    at.scale(1.0 / Math.abs(m.getScalingFactorX()), 1.0 / Math.abs(m.getScalingFactorY()));    Rectangle originalBounds = new Rectangle(gray.getWidth(), gray.getHeight());    Rectangle2D transformedBounds = at.createTransformedShape(originalBounds).getBounds2D();    at.preConcatenate(AffineTransform.getTranslateInstance(-transformedBounds.getMinX(), -transformedBounds.getMinY()));    int width = (int) Math.ceil(transformedBounds.getWidth());    int height = (int) Math.ceil(transformedBounds.getHeight());    BufferedImage transformedGray = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);    Graphics2D g2 = (Graphics2D) transformedGray.getGraphics();    g2.drawImage(gray, at, null);    g2.dispose();    return transformedGray;}
private Paint pdfbox_f7549_0() throws IOException
{    return applySoftMaskToPaint(getPaint(getGraphicsState().getStrokingColor()), getGraphicsState().getSoftMask());}
private Paint pdfbox_f7550_0() throws IOException
{    return applySoftMaskToPaint(getPaint(getGraphicsState().getNonStrokingColor()), getGraphicsState().getSoftMask());}
private BasicStroke pdfbox_f7551_0()
{    PDGraphicsState state = getGraphicsState();        float lineWidth = transformWidth(state.getLineWidth());        if (lineWidth < 0.25) {        lineWidth = 0.25f;    }    PDLineDashPattern dashPattern = state.getLineDashPattern();    float phaseStart = dashPattern.getPhase();    float[] dashArray = getDashArray(dashPattern);    phaseStart = transformWidth(phaseStart);        if (dashArray.length == 0 || Float.isInfinite(phaseStart) || Float.isNaN(phaseStart)) {        dashArray = null;    } else {        for (int i = 0; i < dashArray.length; ++i) {            if (Float.isInfinite(dashArray[i]) || Float.isNaN(dashArray[i])) {                dashArray = null;                break;            }        }    }        int lineCap = Math.min(2, Math.max(0, state.getLineCap()));    int lineJoin = Math.min(2, Math.max(0, state.getLineJoin()));    return new BasicStroke(lineWidth, lineCap, lineJoin, state.getMiterLimit(), dashArray, phaseStart);}
private float[] pdfbox_f7552_0(PDLineDashPattern dashPattern)
{    float[] dashArray = dashPattern.getDashArray();    if (JAVA_VERSION < 10) {        float scalingFactorX = new Matrix(xform).getScalingFactorX();        for (int i = 0; i < dashArray.length; ++i) {                        float w = transformWidth(dashArray[i]);                        if (scalingFactorX < 0.5f) {                                dashArray[i] = Math.max(w, 0.2f);            } else {                dashArray[i] = Math.max(w, 0.062f);            }        }    } else {        for (int i = 0; i < dashArray.length; ++i) {                        dashArray[i] = transformWidth(dashArray[i]);        }    }    return dashArray;}
public void pdfbox_f7553_0() throws IOException
{    graphics.setComposite(getGraphicsState().getStrokingJavaComposite());    graphics.setPaint(getStrokingPaint());    graphics.setStroke(getStroke());    setClip();        if (isContentRendered()) {        graphics.draw(linePath);    }    linePath.reset();}
public void pdfbox_f7554_0(int windingRule) throws IOException
{    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    graphics.setPaint(getNonStrokingPaint());    setClip();    linePath.setWindingRule(windingRule);                    Rectangle2D bounds = linePath.getBounds2D();    boolean noAntiAlias = isRectangular(linePath) && bounds.getWidth() > 1 && bounds.getHeight() > 1;    if (noAntiAlias) {        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);    }    Shape shape;    if (!(graphics.getPaint() instanceof Color)) {                Area area = new Area(linePath);        area.intersect(new Area(graphics.getClip()));        intersectShadingBBox(getGraphicsState().getNonStrokingColor(), area);        shape = area;    } else {        shape = linePath;    }    if (isContentRendered()) {        graphics.fill(shape);    }    linePath.reset();    if (noAntiAlias) {                        setRenderingHints();    }}
private void pdfbox_f7555_0(PDColor color, Area area) throws IOException
{    if (color.getColorSpace() instanceof PDPattern) {        PDColorSpace colorSpace = color.getColorSpace();        PDAbstractPattern pat = ((PDPattern) colorSpace).getPattern(color);        if (pat instanceof PDShadingPattern) {            PDShading shading = ((PDShadingPattern) pat).getShading();            PDRectangle bbox = shading.getBBox();            if (bbox != null) {                Matrix m = Matrix.concatenate(getInitialMatrix(), pat.getMatrix());                Area bboxArea = new Area(bbox.transform(m));                area.intersect(bboxArea);            }        }    }}
private boolean pdfbox_f7556_0(GeneralPath path)
{    PathIterator iter = path.getPathIterator(null);    double[] coords = new double[6];    int count = 0;    int[] xs = new int[4];    int[] ys = new int[4];    while (!iter.isDone()) {        switch(iter.currentSegment(coords)) {            case PathIterator.SEG_MOVETO:                if (count == 0) {                    xs[count] = (int) Math.floor(coords[0]);                    ys[count] = (int) Math.floor(coords[1]);                } else {                    return false;                }                count++;                break;            case PathIterator.SEG_LINETO:                if (count < 4) {                    xs[count] = (int) Math.floor(coords[0]);                    ys[count] = (int) Math.floor(coords[1]);                } else {                    return false;                }                count++;                break;            case PathIterator.SEG_CUBICTO:                return false;            case PathIterator.SEG_CLOSE:                break;            default:                break;        }        iter.next();    }    if (count == 4) {        return xs[0] == xs[1] || xs[0] == xs[2] || ys[0] == ys[1] || ys[0] == ys[3];    }    return false;}
public void pdfbox_f7557_0(int windingRule) throws IOException
{        GeneralPath path = (GeneralPath) linePath.clone();    fillPath(windingRule);    linePath = path;    strokePath();}
public void pdfbox_f7558_0(int windingRule)
{        clipWindingRule = windingRule;}
public void pdfbox_f7559_0(float x, float y)
{    linePath.moveTo(x, y);}
public void pdfbox_f7560_0(float x, float y)
{    linePath.lineTo(x, y);}
public void pdfbox_f7561_0(float x1, float y1, float x2, float y2, float x3, float y3)
{    linePath.curveTo(x1, y1, x2, y2, x3, y3);}
public Point2D pdfbox_f7562_0()
{    return linePath.getCurrentPoint();}
public void pdfbox_f7563_0()
{    linePath.closePath();}
public void pdfbox_f7564_0()
{    if (clipWindingRule != -1) {        linePath.setWindingRule(clipWindingRule);        getGraphicsState().intersectClippingPath(linePath);                        lastClip = null;        clipWindingRule = -1;    }    linePath.reset();}
public void pdfbox_f7565_0(PDImage pdImage) throws IOException
{    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();    AffineTransform at = ctm.createAffineTransform();    if (!pdImage.getInterpolate()) {        boolean isScaledUp = pdImage.getWidth() < Math.round(at.getScaleX()) || pdImage.getHeight() < Math.round(at.getScaleY());                if (isScaledUp) {            graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);        }    }    if (pdImage.isStencil()) {        if (getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDPattern) {                                                                                                                                    Paint paint = getNonStrokingPaint();            Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);            Rectangle2D bounds = at.createTransformedShape(unitRect).getBounds2D();            BufferedImage renderedPaint = new BufferedImage((int) Math.ceil(bounds.getWidth()), (int) Math.ceil(bounds.getHeight()), BufferedImage.TYPE_INT_ARGB);            Graphics2D g = (Graphics2D) renderedPaint.getGraphics();            g.translate(-bounds.getMinX(), -bounds.getMinY());            g.setPaint(paint);            g.fill(bounds);            g.dispose();                        BufferedImage mask = pdImage.getImage();            BufferedImage renderedMask = new BufferedImage((int) Math.ceil(bounds.getWidth()), (int) Math.ceil(bounds.getHeight()), BufferedImage.TYPE_INT_RGB);            g = (Graphics2D) renderedMask.getGraphics();            g.translate(-bounds.getMinX(), -bounds.getMinY());            AffineTransform imageTransform = new AffineTransform(at);            imageTransform.scale(1.0 / mask.getWidth(), -1.0 / mask.getHeight());            imageTransform.translate(0, -mask.getHeight());            g.drawImage(mask, imageTransform, null);            g.dispose();                        final int[] transparent = new int[4];            int[] alphaPixel = null;            WritableRaster raster = renderedPaint.getRaster();            WritableRaster alpha = renderedMask.getRaster();            int h = renderedMask.getRaster().getHeight();            int w = renderedMask.getRaster().getWidth();            for (int y = 0; y < h; y++) {                for (int x = 0; x < w; x++) {                    alphaPixel = alpha.getPixel(x, y, alphaPixel);                    if (alphaPixel[0] == 255) {                        raster.setPixel(x, y, transparent);                    }                }            }                        setClip();            graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());            if (isContentRendered()) {                graphics.drawImage(renderedPaint, AffineTransform.getTranslateInstance(bounds.getMinX(), bounds.getMinY()), null);            }        } else {                        BufferedImage image = pdImage.getStencilImage(getNonStrokingPaint());                        drawBufferedImage(image, at);        }    } else {        if (subsamplingAllowed) {            int subsampling = getSubsampling(pdImage, at);                        drawBufferedImage(pdImage.getImage(null, subsampling), at);        } else {                        drawBufferedImage(pdImage.getImage(), at);        }    }    if (!pdImage.getInterpolate()) {                        setRenderingHints();    }}
private int pdfbox_f7566_0(PDImage pdImage, AffineTransform at)
{        double scale = Math.abs(at.getDeterminant() * xform.getDeterminant());    int subsampling = (int) Math.floor(Math.sqrt(pdImage.getWidth() * pdImage.getHeight() / scale));    if (subsampling > 8) {        subsampling = 8;    }    if (subsampling < 1) {        subsampling = 1;    }    if (subsampling > pdImage.getWidth() || subsampling > pdImage.getHeight()) {                        subsampling = Math.min(pdImage.getWidth(), pdImage.getHeight());    }    return subsampling;}
private void pdfbox_f7567_0(BufferedImage image, AffineTransform at) throws IOException
{    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    setClip();    AffineTransform imageTransform = new AffineTransform(at);    PDSoftMask softMask = getGraphicsState().getSoftMask();    if (softMask != null) {        imageTransform.scale(1, -1);        imageTransform.translate(0, -1);        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Double(imageTransform.getTranslateX(), imageTransform.getTranslateY(), imageTransform.getScaleX(), imageTransform.getScaleY()));        awtPaint = applySoftMaskToPaint(awtPaint, softMask);        graphics.setPaint(awtPaint);        Rectangle2D unitRect = new Rectangle2D.Float(0, 0, 1, 1);        if (isContentRendered()) {            graphics.fill(at.createTransformedShape(unitRect));        }    } else {        COSBase transfer = getGraphicsState().getTransfer();        if (transfer instanceof COSArray || transfer instanceof COSDictionary) {            image = applyTransferFunction(image, transfer);        }        int width = image.getWidth();        int height = image.getHeight();        imageTransform.scale(1.0 / width, -1.0 / height);        imageTransform.translate(0, -height);        if (isContentRendered()) {            graphics.drawImage(image, imageTransform, null);        }    }}
private BufferedImage pdfbox_f7568_0(BufferedImage image, COSBase transfer) throws IOException
{    BufferedImage bim;    if (image.getColorModel().hasAlpha()) {        bim = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);    } else {        bim = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);    }            Integer[] rMap;    Integer[] gMap;    Integer[] bMap;    PDFunction rf;    PDFunction gf;    PDFunction bf;    if (transfer instanceof COSArray) {        COSArray ar = (COSArray) transfer;        rf = PDFunction.create(ar.getObject(0));        gf = PDFunction.create(ar.getObject(1));        bf = PDFunction.create(ar.getObject(2));        rMap = new Integer[256];        gMap = new Integer[256];        bMap = new Integer[256];    } else {        rf = PDFunction.create(transfer);        gf = rf;        bf = rf;        rMap = new Integer[256];        gMap = rMap;        bMap = rMap;    }        float[] input = new float[1];    for (int x = 0; x < image.getWidth(); ++x) {        for (int y = 0; y < image.getHeight(); ++y) {            int rgb = image.getRGB(x, y);            int ri = (rgb >> 16) & 0xFF;            int gi = (rgb >> 8) & 0xFF;            int bi = rgb & 0xFF;            int ro;            int go;            int bo;            if (rMap[ri] != null) {                ro = rMap[ri];            } else {                input[0] = (ri & 0xFF) / 255f;                ro = (int) (rf.eval(input)[0] * 255);                rMap[ri] = ro;            }            if (gMap[gi] != null) {                go = gMap[gi];            } else {                input[0] = (gi & 0xFF) / 255f;                go = (int) (gf.eval(input)[0] * 255);                gMap[gi] = go;            }            if (bMap[bi] != null) {                bo = bMap[bi];            } else {                input[0] = (bi & 0xFF) / 255f;                bo = (int) (bf.eval(input)[0] * 255);                bMap[bi] = bo;            }            bim.setRGB(x, y, (rgb & 0xFF000000) | (ro << 16) | (go << 8) | bo);        }    }    return bim;}
public void pdfbox_f7569_1(COSName shadingName) throws IOException
{    PDShading shading = getResources().getShading(shadingName);    if (shading == null) {                return;    }    Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();    Paint paint = shading.toPaint(ctm);    paint = applySoftMaskToPaint(paint, getGraphicsState().getSoftMask());    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    graphics.setPaint(paint);    graphics.setClip(null);    lastClip = null;            PDRectangle bbox = shading.getBBox();    Area area;    if (bbox != null) {        area = new Area(bbox.transform(ctm));        area.intersect(getGraphicsState().getCurrentClippingPath());    } else {        area = getGraphicsState().getCurrentClippingPath();    }    if (isContentRendered()) {        graphics.fill(area);    }}
public void pdfbox_f7570_0(PDAnnotation annotation) throws IOException
{    lastClip = null;    int deviceType = -1;    if (graphics.getDeviceConfiguration() != null && graphics.getDeviceConfiguration().getDevice() != null) {        deviceType = graphics.getDeviceConfiguration().getDevice().getType();    }    if (deviceType == GraphicsDevice.TYPE_PRINTER && !annotation.isPrinted()) {        return;    }    if (deviceType == GraphicsDevice.TYPE_RASTER_SCREEN && annotation.isNoView()) {        return;    }    if (annotation.isHidden()) {        return;    }    if (annotation.isInvisible() && annotation instanceof PDAnnotationUnknown) {                return;    }    if (isHiddenOCG(annotation.getOptionalContent())) {        return;    }    PDAppearanceDictionary appearance = annotation.getAppearance();    if (appearance == null || appearance.getNormalAppearance() == null) {        annotation.constructAppearances(renderer.document);    }    if (annotation.isNoRotate() && getCurrentPage().getRotation() != 0) {        PDRectangle rect = annotation.getRectangle();        AffineTransform savedTransform = graphics.getTransform();                        graphics.rotate(Math.toRadians(getCurrentPage().getRotation()), rect.getLowerLeftX(), rect.getUpperRightY());        super.showAnnotation(annotation);        graphics.setTransform(savedTransform);    } else {        super.showAnnotation(annotation);    }}
public void pdfbox_f7571_0(PDFormXObject form) throws IOException
{    if (isContentRendered()) {        super.showForm(form);    }}
public void pdfbox_f7572_1(PDTransparencyGroup form) throws IOException
{    if (!isContentRendered()) {        return;    }    TransparencyGroup group = new TransparencyGroup(form, false, getGraphicsState().getCurrentTransformationMatrix(), null);    BufferedImage image = group.getImage();    if (image == null) {                return;    }    graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());    setClip();            PDRectangle bbox = group.getBBox();    AffineTransform savedTransform = graphics.getTransform();    Matrix m = new Matrix(xform);    float xScale = Math.abs(m.getScalingFactorX());    float yScale = Math.abs(m.getScalingFactorY());    AffineTransform transform = new AffineTransform(xform);    transform.scale(1.0 / xScale, 1.0 / yScale);    graphics.setTransform(transform);        float x = bbox.getLowerLeftX() - pageSize.getLowerLeftX();    float y = pageSize.getUpperRightY() - bbox.getUpperRightY();    if (flipTG) {        graphics.translate(0, image.getHeight());        graphics.scale(1, -1);    } else {        graphics.translate(x * xScale, y * yScale);    }    PDSoftMask softMask = getGraphicsState().getSoftMask();    if (softMask != null) {        Paint awtPaint = new TexturePaint(image, new Rectangle2D.Float(0, 0, image.getWidth(), image.getHeight()));        awtPaint = applySoftMaskToPaint(awtPaint, softMask);        graphics.setPaint(awtPaint);        if (isContentRendered()) {            graphics.fill(new Rectangle2D.Float(0, 0, bbox.getWidth() * xScale, bbox.getHeight() * yScale));        }    } else {        if (isContentRendered()) {            try {                graphics.drawImage(image, null, null);            } catch (InternalError ie) {                            }        }    }    graphics.setTransform(savedTransform);}
private BufferedImage pdfbox_f7573_0(int width, int height)
{    /**     * gray + alpha     */    int[] bandOffsets = new int[] { 1, 0 };    int bands = bandOffsets.length;    /**     * Color Model used for raw GRAY + ALPHA     */    final ColorModel CM_GRAY_ALPHA = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), true, false, Transparency.TRANSLUCENT, DataBuffer.TYPE_BYTE);        DataBuffer buffer = new DataBufferByte(width * height * bands);        WritableRaster raster = Raster.createInterleavedRaster(buffer, width, height, width * bands, bands, bandOffsets, new Point(0, 0));        return new BufferedImage(CM_GRAY_ALPHA, raster, false, null);}
private boolean pdfbox_f7574_1(PDColorSpace colorSpace)
{    if (colorSpace instanceof PDDeviceGray) {        return true;    }    if (colorSpace instanceof PDICCBased) {        try {            return ((PDICCBased) colorSpace).getAlternateColorSpace() instanceof PDDeviceGray;        } catch (IOException ex) {                        return false;        }    }    return false;}
public BufferedImage pdfbox_f7575_0()
{    return image;}
public PDRectangle pdfbox_f7576_0()
{    return bbox;}
public Rectangle2D pdfbox_f7577_0()
{    Point2D size = new Point2D.Double(pageSize.getWidth(), pageSize.getHeight());        AffineTransform dpiTransform = AffineTransform.getScaleInstance(scaleX, scaleY);    size = dpiTransform.transform(size, size);        return new Rectangle2D.Double(minX - pageSize.getLowerLeftX() * scaleX, size.getY() - minY - height + pageSize.getLowerLeftY() * scaleY, width, height);}
private boolean pdfbox_f7578_0(PDTransparencyGroup group, Set<COSBase> groupsDone)
{    if (groupsDone.contains(group.getCOSObject())) {                return false;    }    groupsDone.add(group.getCOSObject());    PDResources resources = group.getResources();    if (resources == null) {        return false;    }    for (COSName name : resources.getExtGStateNames()) {        PDExtendedGraphicsState extGState = resources.getExtGState(name);        if (extGState == null) {            continue;        }        BlendMode blendMode = extGState.getBlendMode();        if (blendMode != BlendMode.NORMAL) {            return true;        }    }        for (COSName name : resources.getXObjectNames()) {        PDXObject xObject;        try {            xObject = resources.getXObject(name);        } catch (IOException ex) {            continue;        }        if (xObject instanceof PDTransparencyGroup && hasBlendMode((PDTransparencyGroup) xObject, groupsDone)) {            return true;        }    }    return false;}
public void pdfbox_f7579_0(COSName tag, COSDictionary properties)
{    if (nestedHiddenOCGCount > 0) {        nestedHiddenOCGCount++;        return;    }    if (tag == null || getPage().getResources() == null) {        return;    }    if (isHiddenOCG(getPage().getResources().getProperties(tag))) {        nestedHiddenOCGCount = 1;    }}
public void pdfbox_f7580_0()
{    if (nestedHiddenOCGCount > 0) {        nestedHiddenOCGCount--;    }}
private boolean pdfbox_f7581_0()
{    return nestedHiddenOCGCount <= 0;}
private boolean pdfbox_f7582_0(PDPropertyList propertyList)
{    if (propertyList instanceof PDOptionalContentGroup) {        PDOptionalContentGroup group = (PDOptionalContentGroup) propertyList;        RenderState printState = group.getRenderState(destination);        if (printState == null) {            if (!getRenderer().isGroupEnabled(group)) {                return true;            }        } else if (RenderState.OFF.equals(printState)) {            return true;        }    } else if (propertyList instanceof PDOptionalContentMembershipDictionary) {        return isHiddenOCMD((PDOptionalContentMembershipDictionary) propertyList);    }    return false;}
private boolean pdfbox_f7583_1(PDOptionalContentMembershipDictionary ocmd)
{    if (ocmd.getCOSObject().getCOSArray(COSName.VE) != null) {                    }    List<Boolean> visibles = new ArrayList<>();    for (PDPropertyList prop : ocmd.getOCGs()) {        visibles.add(!isHiddenOCG(prop));    }    COSName visibilityPolicy = ocmd.getVisibilityPolicy();    if (COSName.ANY_OFF.equals(visibilityPolicy)) {        for (boolean visible : visibles) {            if (!visible) {                return true;            }        }        return false;    }    if (COSName.ALL_ON.equals(visibilityPolicy)) {        for (boolean visible : visibles) {            if (!visible) {                return true;            }        }        return false;    }    if (COSName.ALL_OFF.equals(visibilityPolicy)) {        for (boolean visible : visibles) {            if (visible) {                return false;            }        }        return true;    }        for (boolean visible : visibles) {        if (visible) {            return false;        }    }    return true;}
private static int pdfbox_f7584_0()
{        String version = System.getProperty("java.specification.version");    final StringTokenizer st = new StringTokenizer(version, ".");    try {        int major = Integer.parseInt(st.nextToken());        int minor = 0;        if (st.hasMoreTokens()) {            minor = Integer.parseInt(st.nextToken());        }        return major == 1 ? minor : major;    } catch (NumberFormatException nfe) {                return 0;    }}
public PDPage pdfbox_f7585_0()
{    return page;}
 PDFRenderer pdfbox_f7586_0()
{    return renderer;}
public boolean pdfbox_f7587_0()
{    return subsamplingAllowed;}
public RenderDestination pdfbox_f7588_0()
{    return this.destination;}
public RenderingHints pdfbox_f7589_0()
{    return renderingHints;}
public AnnotationFilter pdfbox_f7590_0()
{    return annotationFilter;}
public void pdfbox_f7591_0(AnnotationFilter annotationsFilter)
{    this.annotationFilter = annotationsFilter;}
public boolean pdfbox_f7592_0()
{    return subsamplingAllowed;}
public void pdfbox_f7593_0(boolean subsamplingAllowed)
{    this.subsamplingAllowed = subsamplingAllowed;}
public RenderDestination pdfbox_f7594_0()
{    return defaultDestination;}
public void pdfbox_f7595_0(RenderDestination defaultDestination)
{    this.defaultDestination = defaultDestination;}
public RenderingHints pdfbox_f7596_0()
{    return renderingHints;}
public void pdfbox_f7597_0(RenderingHints renderingHints)
{    this.renderingHints = renderingHints;}
public BufferedImage pdfbox_f7598_0(int pageIndex) throws IOException
{    return renderImage(pageIndex, 1);}
public BufferedImage pdfbox_f7599_0(int pageIndex, float scale) throws IOException
{    return renderImage(pageIndex, scale, ImageType.RGB);}
public BufferedImage pdfbox_f7600_0(int pageIndex, float dpi) throws IOException
{    return renderImage(pageIndex, dpi / 72f, ImageType.RGB);}
public BufferedImage pdfbox_f7601_0(int pageIndex, float dpi, ImageType imageType) throws IOException
{    return renderImage(pageIndex, dpi / 72f, imageType);}
public BufferedImage pdfbox_f7602_0(int pageIndex, float scale, ImageType imageType) throws IOException
{    return renderImage(pageIndex, scale, imageType, defaultDestination == null ? RenderDestination.EXPORT : defaultDestination);}
public BufferedImage pdfbox_f7603_0(int pageIndex, float scale, ImageType imageType, RenderDestination destination) throws IOException
{    PDPage page = document.getPage(pageIndex);    PDRectangle cropbBox = page.getCropBox();    float widthPt = cropbBox.getWidth();    float heightPt = cropbBox.getHeight();        int widthPx = (int) Math.max(Math.floor(widthPt * scale), 1);    int heightPx = (int) Math.max(Math.floor(heightPt * scale), 1);        if ((long) widthPx * (long) heightPx > Integer.MAX_VALUE) {        throw new IOException(        "Maximum size of image exceeded (w * h * scale) = " + widthPt + " * " + heightPt + " * " + scale + " > " + Integer.MAX_VALUE);    }    int rotationAngle = page.getRotation();    int bimType = imageType.toBufferedImageType();    if (imageType != ImageType.ARGB && hasBlendMode(page)) {                                        bimType = BufferedImage.TYPE_INT_ARGB;    }        BufferedImage image;    if (rotationAngle == 90 || rotationAngle == 270) {        image = new BufferedImage(heightPx, widthPx, bimType);    } else {        image = new BufferedImage(widthPx, heightPx, bimType);    }    pageImage = image;        Graphics2D g = image.createGraphics();    if (image.getType() == BufferedImage.TYPE_INT_ARGB) {        g.setBackground(new Color(0, 0, 0, 0));    } else {        g.setBackground(Color.WHITE);    }    g.clearRect(0, 0, image.getWidth(), image.getHeight());    transform(g, page, scale, scale);        RenderingHints actualRenderingHints = renderingHints == null ? createDefaultRenderingHints(g) : renderingHints;    PageDrawerParameters parameters = new PageDrawerParameters(this, page, subsamplingAllowed, destination, actualRenderingHints);    PageDrawer drawer = createPageDrawer(parameters);    drawer.drawPage(g, page.getCropBox());    g.dispose();    if (image.getType() != imageType.toBufferedImageType()) {                BufferedImage newImage = new BufferedImage(image.getWidth(), image.getHeight(), imageType.toBufferedImageType());        Graphics2D dstGraphics = newImage.createGraphics();        dstGraphics.setBackground(Color.WHITE);        dstGraphics.clearRect(0, 0, image.getWidth(), image.getHeight());        dstGraphics.drawImage(image, 0, 0, null);        dstGraphics.dispose();        image = newImage;    }    return image;}
public void pdfbox_f7604_0(int pageIndex, Graphics2D graphics) throws IOException
{    renderPageToGraphics(pageIndex, graphics, 1);}
public void pdfbox_f7605_0(int pageIndex, Graphics2D graphics, float scale) throws IOException
{    renderPageToGraphics(pageIndex, graphics, scale, scale);}
public void pdfbox_f7606_0(int pageIndex, Graphics2D graphics, float scaleX, float scaleY) throws IOException
{    renderPageToGraphics(pageIndex, graphics, scaleX, scaleY, defaultDestination == null ? RenderDestination.VIEW : defaultDestination);}
public void pdfbox_f7607_0(int pageIndex, Graphics2D graphics, float scaleX, float scaleY, RenderDestination destination) throws IOException
{    PDPage page = document.getPage(pageIndex);        transform(graphics, page, scaleX, scaleY);    PDRectangle cropBox = page.getCropBox();    graphics.clearRect(0, 0, (int) cropBox.getWidth(), (int) cropBox.getHeight());        RenderingHints actualRenderingHints = renderingHints == null ? createDefaultRenderingHints(graphics) : renderingHints;    PageDrawerParameters parameters = new PageDrawerParameters(this, page, subsamplingAllowed, destination, actualRenderingHints);    PageDrawer drawer = createPageDrawer(parameters);    drawer.drawPage(graphics, cropBox);}
public boolean pdfbox_f7608_0(PDOptionalContentGroup group)
{    PDOptionalContentProperties ocProperties = document.getDocumentCatalog().getOCProperties();    return ocProperties == null || ocProperties.isGroupEnabled(group);}
private void pdfbox_f7609_0(Graphics2D graphics, PDPage page, float scaleX, float scaleY)
{    graphics.scale(scaleX, scaleY);        int rotationAngle = page.getRotation();    PDRectangle cropBox = page.getCropBox();    if (rotationAngle != 0) {        float translateX = 0;        float translateY = 0;        switch(rotationAngle) {            case 90:                translateX = cropBox.getHeight();                break;            case 270:                translateY = cropBox.getWidth();                break;            case 180:                translateX = cropBox.getWidth();                translateY = cropBox.getHeight();                break;            default:                break;        }        graphics.translate(translateX, translateY);        graphics.rotate(Math.toRadians(rotationAngle));    }}
private boolean pdfbox_f7610_0(Graphics2D graphics)
{    GraphicsConfiguration deviceConfiguration = graphics.getDeviceConfiguration();    if (deviceConfiguration == null) {        return false;    }    GraphicsDevice device = deviceConfiguration.getDevice();    if (device == null) {        return false;    }    DisplayMode displayMode = device.getDisplayMode();    if (displayMode == null) {        return false;    }    return displayMode.getBitDepth() == 1;}
private RenderingHints pdfbox_f7611_0(Graphics2D graphics)
{    RenderingHints r = new RenderingHints(null);    r.put(RenderingHints.KEY_INTERPOLATION, isBitonal(graphics) ? RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR : RenderingHints.VALUE_INTERPOLATION_BICUBIC);    r.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);    r.put(RenderingHints.KEY_ANTIALIASING, isBitonal(graphics) ? RenderingHints.VALUE_ANTIALIAS_OFF : RenderingHints.VALUE_ANTIALIAS_ON);    return r;}
protected PageDrawer pdfbox_f7612_0(PageDrawerParameters parameters) throws IOException
{    PageDrawer pageDrawer = new PageDrawer(parameters);    pageDrawer.setAnnotationFilter(annotationFilter);    return pageDrawer;}
private boolean pdfbox_f7613_0(PDPage page)
{        PDResources resources = page.getResources();    if (resources == null) {        return false;    }    for (COSName name : resources.getExtGStateNames()) {        PDExtendedGraphicsState extGState = resources.getExtGState(name);        if (extGState == null) {                        continue;        }        BlendMode blendMode = extGState.getBlendMode();        if (blendMode != BlendMode.NORMAL) {            return true;        }    }    return false;}
 BufferedImage pdfbox_f7614_0()
{    return pageImage;}
private static void pdfbox_f7615_1()
{    String cmmProperty = System.getProperty("sun.java2d.cmm");    if (!"sun.java2d.cmm.kcms.KcmsServiceProvider".equals(cmmProperty)) {        try {                        Class.forName("sun.java2d.cmm.kcms.KcmsServiceProvider");            String version = System.getProperty("java.version");            if (version == null || isGoodVersion(version, "1.8.0_(\\d+)", 191) || isGoodVersion(version, "9.0.(\\d+)", 4)) {                return;            }                                                                                } catch (ClassNotFoundException e) {                }    }}
private static boolean pdfbox_f7616_0(String version, String regex, int min)
{    Matcher matcher = Pattern.compile(regex).matcher(version);    if (matcher.matches() && matcher.groupCount() >= 1) {        try {            int v = Integer.parseInt(matcher.group(1));            if (v >= min) {                                return true;            }        } catch (NumberFormatException ex) {            return true;        }    }    return false;}
public PaintContext pdfbox_f7617_0(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    PaintContext ctx = paint.createContext(cm, deviceBounds, userBounds, xform, hints);    return new SoftPaintContext(ctx);}
public int pdfbox_f7618_0()
{    return TRANSLUCENT;}
public ColorModel pdfbox_f7619_0()
{    return ARGB_COLOR_MODEL;}
public Raster pdfbox_f7620_1(int x1, int y1, int w, int h)
{    Raster raster = context.getRaster(x1, y1, w, h);    ColorModel rasterCM = context.getColorModel();    float[] input = null;    Float[] map = null;    if (transferFunction != null) {        map = new Float[256];        input = new float[1];    }        WritableRaster output = getColorModel().createCompatibleWritableRaster(w, h);        x1 = x1 - (int) bboxDevice.getX();    y1 = y1 - (int) bboxDevice.getY();    int[] gray = new int[4];    Object pixelInput = null;    int[] pixelOutput = new int[4];    for (int y = 0; y < h; y++) {        for (int x = 0; x < w; x++) {            pixelInput = raster.getDataElements(x, y, pixelInput);            pixelOutput[0] = rasterCM.getRed(pixelInput);            pixelOutput[1] = rasterCM.getGreen(pixelInput);            pixelOutput[2] = rasterCM.getBlue(pixelInput);            pixelOutput[3] = rasterCM.getAlpha(pixelInput);                        gray[0] = 0;            if (x1 + x >= 0 && y1 + y >= 0 && x1 + x < mask.getWidth() && y1 + y < mask.getHeight()) {                mask.getRaster().getPixel(x1 + x, y1 + y, gray);                int g = gray[0];                if (transferFunction != null) {                                        try {                        if (map[g] != null) {                                                        pixelOutput[3] = Math.round(pixelOutput[3] * map[g]);                        } else {                                                        input[0] = g / 255f;                            float f = transferFunction.eval(input)[0];                            map[g] = f;                            pixelOutput[3] = Math.round(pixelOutput[3] * f);                        }                    } catch (IOException ex) {                                                                        pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255f));                    }                } else {                    pixelOutput[3] = Math.round(pixelOutput[3] * (g / 255f));                }            } else {                pixelOutput[3] = Math.round(pixelOutput[3] * (bc / 255f));            }            output.setPixel(x, y, pixelOutput);        }    }    return output;}
public void pdfbox_f7621_0()
{}
public PaintContext pdfbox_f7622_0(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
{    AffineTransform xformPattern = (AffineTransform) xform.clone();        AffineTransform patternNoScale = patternMatrix.createAffineTransform();    patternNoScale.scale(1 / patternMatrix.getScalingFactorX(), 1 / patternMatrix.getScalingFactorY());    xformPattern.concatenate(patternNoScale);    return paint.createContext(cm, deviceBounds, userBounds, xformPattern, hints);}
private BufferedImage pdfbox_f7623_0(PageDrawer drawer, PDTilingPattern pattern, PDColorSpace colorSpace, PDColor color, AffineTransform xform, Rectangle2D anchorRect) throws IOException
{    float width = (float) Math.abs(anchorRect.getWidth());    float height = (float) Math.abs(anchorRect.getHeight());        Matrix xformMatrix = new Matrix(xform);    float xScale = Math.abs(xformMatrix.getScalingFactorX());    float yScale = Math.abs(xformMatrix.getScalingFactorY());    width *= xScale;    height *= yScale;    int rasterWidth = Math.max(1, ceiling(width));    int rasterHeight = Math.max(1, ceiling(height));    BufferedImage image = new BufferedImage(rasterWidth, rasterHeight, BufferedImage.TYPE_INT_ARGB);    Graphics2D graphics = image.createGraphics();        if (pattern.getYStep() < 0) {        graphics.translate(0, rasterHeight);        graphics.scale(1, -1);    }        if (pattern.getXStep() < 0) {        graphics.translate(rasterWidth, 0);        graphics.scale(-1, 1);    }        graphics.scale(xScale, yScale);            Matrix newPatternMatrix;    newPatternMatrix = Matrix.getScaleInstance(Math.abs(patternMatrix.getScalingFactorX()), Math.abs(patternMatrix.getScalingFactorY()));        newPatternMatrix.concatenate(Matrix.getTranslateInstance(-pattern.getBBox().getLowerLeftX(), -pattern.getBBox().getLowerLeftY()));        drawer.drawTilingPattern(graphics, pattern, colorSpace, color, newPatternMatrix);    graphics.dispose();    return image;}
private static int pdfbox_f7624_0(double num)
{    BigDecimal decimal = new BigDecimal(num);        decimal = decimal.setScale(5, RoundingMode.CEILING);    return decimal.intValue();}
public int pdfbox_f7625_0()
{    return Transparency.TRANSLUCENT;}
private Rectangle2D pdfbox_f7626_1(PDTilingPattern pattern)
{    float xStep = pattern.getXStep();    if (Float.compare(xStep, 0) == 0) {        xStep = pattern.getBBox().getWidth();    }    float yStep = pattern.getYStep();    if (Float.compare(yStep, 0) == 0) {        yStep = pattern.getBBox().getHeight();    }    float xScale = patternMatrix.getScalingFactorX();    float yScale = patternMatrix.getScalingFactorY();    float width = xStep * xScale;    float height = yStep * yScale;    if (Math.abs(width * height) > MAXEDGE * MAXEDGE) {                                                                width = Math.min(MAXEDGE, Math.abs(width)) * Math.signum(width);        height = Math.min(MAXEDGE, Math.abs(height)) * Math.signum(height);        }        PDRectangle anchor = pattern.getBBox();    return new Rectangle2D.Float(anchor.getLowerLeftX() * xScale, anchor.getLowerLeftY() * yScale, width, height);}
 Paint pdfbox_f7627_0(PDTilingPattern pattern, PDColorSpace colorSpace, PDColor color, AffineTransform xform) throws IOException
{    Paint paint = null;    TilingPaintParameter tilingPaintParameter = new TilingPaintParameter(drawer.getInitialMatrix(), pattern.getCOSObject(), colorSpace, color, xform);    WeakReference<Paint> weakRef = weakCache.get(tilingPaintParameter);    if (weakRef != null) {                paint = weakRef.get();    }    if (paint == null) {        paint = new TilingPaint(drawer, pattern, colorSpace, color, xform);        weakCache.put(tilingPaintParameter, new WeakReference<>(paint));    }    return paint;}
public boolean pdfbox_f7628_1(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof TilingPaintParameter)) {        return false;    }    final TilingPaintParameter other = (TilingPaintParameter) obj;    if (this.matrix != other.matrix && (this.matrix == null || !this.matrix.equals(other.matrix))) {        return false;    }    if (this.patternDict != other.patternDict && (this.patternDict == null || !this.patternDict.equals(other.patternDict))) {        return false;    }    if (this.colorSpace != other.colorSpace && (this.colorSpace == null || !this.colorSpace.equals(other.colorSpace))) {        return false;    }    if (this.color == null && other.color != null) {        return false;    }    if (this.color != null && other.color == null) {        return false;    }    if (this.color != null && this.color.getColorSpace() != other.color.getColorSpace()) {        return false;    }    try {        if (this.color != other.color && this.color.toRGB() != other.color.toRGB()) {            return false;        }    } catch (IOException ex) {                return false;    }    return !(this.xform != other.xform && (this.xform == null || !this.xform.equals(other.xform)));}
public int pdfbox_f7629_0()
{    int hash = 7;    hash = 23 * hash + (this.matrix != null ? this.matrix.hashCode() : 0);    hash = 23 * hash + (this.patternDict != null ? this.patternDict.hashCode() : 0);    hash = 23 * hash + (this.colorSpace != null ? this.colorSpace.hashCode() : 0);    hash = 23 * hash + (this.color != null ? this.color.hashCode() : 0);    hash = 23 * hash + (this.xform != null ? this.xform.hashCode() : 0);    return hash;}
public String pdfbox_f7630_0()
{    return "TilingPaintParameter{" + "matrix=" + matrix + ", pattern=" + patternDict + ", colorSpace=" + colorSpace + ", color=" + color + ", xform=" + xform + '}';}
public void pdfbox_f7631_0(PDPage page) throws IOException
{    this.pageRotation = page.getRotation();    this.pageSize = page.getCropBox();    if (Float.compare(pageSize.getLowerLeftX(), 0) == 0 && Float.compare(pageSize.getLowerLeftY(), 0) == 0) {        translateMatrix = null;    } else {                translateMatrix = Matrix.getTranslateInstance(-pageSize.getLowerLeftX(), -pageSize.getLowerLeftY());    }    super.processPage(page);}
protected void pdfbox_f7632_1(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{                            PDGraphicsState state = getGraphicsState();    Matrix ctm = state.getCurrentTransformationMatrix();    float fontSize = state.getTextState().getFontSize();    float horizontalScaling = state.getTextState().getHorizontalScaling() / 100f;    Matrix textMatrix = getTextMatrix();    BoundingBox bbox = font.getBoundingBox();    if (bbox.getLowerLeftY() < Short.MIN_VALUE) {                        bbox.setLowerLeftY(-(bbox.getLowerLeftY() + 65536));    }        float glyphHeight = bbox.getHeight() / 2;        PDFontDescriptor fontDescriptor = font.getFontDescriptor();    if (fontDescriptor != null) {        float capHeight = fontDescriptor.getCapHeight();        if (Float.compare(capHeight, 0) != 0 && (capHeight < glyphHeight || Float.compare(glyphHeight, 0) == 0)) {            glyphHeight = capHeight;        }                        float ascent = fontDescriptor.getAscent();        float descent = fontDescriptor.getDescent();        if (capHeight > ascent && ascent > 0 && descent < 0 && ((ascent - descent) / 2 < glyphHeight || Float.compare(glyphHeight, 0) == 0)) {            glyphHeight = (ascent - descent) / 2;        }    }        float height;    if (font instanceof PDType3Font) {        height = font.getFontMatrix().transformPoint(0, glyphHeight).y;    } else {        height = glyphHeight / 1000;    }    float displacementX = displacement.getX();        if (font.isVertical()) {        displacementX = font.getWidth(code) / 1000;                TrueTypeFont ttf = null;        if (font instanceof PDTrueTypeFont) {            ttf = ((PDTrueTypeFont) font).getTrueTypeFont();        } else if (font instanceof PDType0Font) {            PDCIDFont cidFont = ((PDType0Font) font).getDescendantFont();            if (cidFont instanceof PDCIDFontType2) {                ttf = ((PDCIDFontType2) cidFont).getTrueTypeFont();            }        }        if (ttf != null && ttf.getUnitsPerEm() != 1000) {            displacementX *= 1000f / ttf.getUnitsPerEm();        }    }                                    float tx = displacementX * fontSize * horizontalScaling;    float ty = displacement.getY() * fontSize;        Matrix td = Matrix.getTranslateInstance(tx, ty);            Matrix nextTextRenderingMatrix = td.multiply(textMatrix).multiply(ctm);    float nextX = nextTextRenderingMatrix.getTranslateX();    float nextY = nextTextRenderingMatrix.getTranslateY();        float dxDisplay = nextX - textRenderingMatrix.getTranslateX();    float dyDisplay = height * textRenderingMatrix.getScalingFactorY();                                    float glyphSpaceToTextSpaceFactor = 1 / 1000f;    if (font instanceof PDType3Font) {        glyphSpaceToTextSpaceFactor = font.getFontMatrix().getScaleX();    }    float spaceWidthText = 0;    try {                spaceWidthText = font.getSpaceWidth() * glyphSpaceToTextSpaceFactor;    } catch (Exception exception) {            }    if (Float.compare(spaceWidthText, 0) == 0) {        spaceWidthText = font.getAverageFontWidth() * glyphSpaceToTextSpaceFactor;                spaceWidthText *= .80f;    }    if (Float.compare(spaceWidthText, 0) == 0) {                spaceWidthText = 1.0f;    }        float spaceWidthDisplay = spaceWidthText * textRenderingMatrix.getScalingFactorX();        unicode = font.toUnicode(code, glyphList);        if (unicode == null) {        if (font instanceof PDSimpleFont) {            char c = (char) code;            unicode = new String(new char[] { c });        } else {                        return;        }    }        Matrix translatedTextRenderingMatrix;    if (translateMatrix == null) {        translatedTextRenderingMatrix = textRenderingMatrix;    } else {        translatedTextRenderingMatrix = Matrix.concatenate(translateMatrix, textRenderingMatrix);        nextX -= pageSize.getLowerLeftX();        nextY -= pageSize.getLowerLeftY();    }    processTextPosition(new TextPosition(pageRotation, pageSize.getWidth(), pageSize.getHeight(), translatedTextRenderingMatrix, nextX, nextY, Math.abs(dyDisplay), dxDisplay, Math.abs(spaceWidthDisplay), unicode, new int[] { code }, font, fontSize, (int) (fontSize * textMatrix.getScalingFactorX())));}
protected void pdfbox_f7633_0(TextPosition text)
{}
private boolean pdfbox_f7634_0(float first, float second, float variance)
{    return second > first - variance && second < first + variance;}
public void pdfbox_f7635_0(COSName tag, COSDictionary properties)
{    PDMarkedContent markedContent = PDMarkedContent.create(tag, properties);    if (this.currentMarkedContents.isEmpty()) {        this.markedContents.add(markedContent);    } else {        PDMarkedContent currentMarkedContent = this.currentMarkedContents.peek();        if (currentMarkedContent != null) {            currentMarkedContent.addMarkedContent(markedContent);        }    }    this.currentMarkedContents.push(markedContent);}
public void pdfbox_f7636_0()
{    if (!this.currentMarkedContents.isEmpty()) {        this.currentMarkedContents.pop();    }}
public void pdfbox_f7637_0(PDXObject xobject)
{    if (!this.currentMarkedContents.isEmpty()) {        this.currentMarkedContents.peek().addXObject(xobject);    }}
protected void pdfbox_f7638_0(TextPosition text)
{    boolean showCharacter = true;    if (this.suppressDuplicateOverlappingText) {        showCharacter = false;        String textCharacter = text.getUnicode();        float textX = text.getX();        float textY = text.getY();        List<TextPosition> sameTextCharacters = this.characterListMapping.get(textCharacter);        if (sameTextCharacters == null) {            sameTextCharacters = new ArrayList<>();            this.characterListMapping.put(textCharacter, sameTextCharacters);        }                                                                                                boolean suppressCharacter = false;        float tolerance = (text.getWidth() / textCharacter.length()) / 3.0f;        for (TextPosition sameTextCharacter : sameTextCharacters) {            TextPosition character = sameTextCharacter;            String charCharacter = character.getUnicode();            float charX = character.getX();            float charY = character.getY();                        if (charCharacter != null &&             within(charX, textX, tolerance) && within(charY, textY, tolerance)) {                suppressCharacter = true;                break;            }        }        if (!suppressCharacter) {            sameTextCharacters.add(text);            showCharacter = true;        }    }    if (showCharacter) {        List<TextPosition> textList = new ArrayList<>();        /* In the wild, some PDF encoded documents put diacritics (accents on             * top of characters) into a separate Tj element.  When displaying them             * graphically, the two chunks get overlayed.  With text output though,             * we need to do the overlay. This code recombines the diacritic with             * its associated character if the two are consecutive.             */        if (textList.isEmpty()) {            textList.add(text);        } else {            /* test if we overlap the previous entry.                   * Note that we are making an assumption that we need to only look back                 * one TextPosition to find what we are overlapping.                   * This may not always be true. */            TextPosition previousTextPosition = textList.get(textList.size() - 1);            if (text.isDiacritic() && previousTextPosition.contains(text)) {                previousTextPosition.mergeDiacritic(text);            } else /* If the previous TextPosition was the diacritic, merge it into this                 * one and remove it from the list. */            if (previousTextPosition.isDiacritic() && text.contains(previousTextPosition)) {                text.mergeDiacritic(previousTextPosition);                textList.remove(textList.size() - 1);                textList.add(text);            } else {                textList.add(text);            }        }        if (!this.currentMarkedContents.isEmpty()) {            this.currentMarkedContents.peek().addText(text);        }    }}
public List<PDMarkedContent> pdfbox_f7639_0()
{    return this.markedContents;}
public String pdfbox_f7640_0(PDDocument doc) throws IOException
{    StringWriter outputStream = new StringWriter();    writeText(doc, outputStream);    return outputStream.toString();}
private void pdfbox_f7641_0()
{    currentPageNo = 0;    document = null;    if (charactersByArticle != null) {        charactersByArticle.clear();    }    if (characterListMapping != null) {        characterListMapping.clear();    }}
public void pdfbox_f7642_0(PDDocument doc, Writer outputStream) throws IOException
{    resetEngine();    document = doc;    output = outputStream;    if (getAddMoreFormatting()) {        paragraphEnd = lineSeparator;        pageStart = lineSeparator;        articleStart = lineSeparator;        articleEnd = lineSeparator;    }    startDocument(document);    processPages(document.getPages());    endDocument(document);}
protected void pdfbox_f7643_0(PDPageTree pages) throws IOException
{    PDPage startBookmarkPage = startBookmark == null ? null : startBookmark.findDestinationPage(document);    if (startBookmarkPage != null) {        startBookmarkPageNumber = pages.indexOf(startBookmarkPage) + 1;    } else {                startBookmarkPageNumber = -1;    }    PDPage endBookmarkPage = endBookmark == null ? null : endBookmark.findDestinationPage(document);    if (endBookmarkPage != null) {        endBookmarkPageNumber = pages.indexOf(endBookmarkPage) + 1;    } else {                endBookmarkPageNumber = -1;    }    if (startBookmarkPageNumber == -1 && startBookmark != null && endBookmarkPageNumber == -1 && endBookmark != null && startBookmark.getCOSObject() == endBookmark.getCOSObject()) {                                startBookmarkPageNumber = 0;        endBookmarkPageNumber = 0;    }    for (PDPage page : pages) {        currentPageNo++;        if (page.hasContents()) {            processPage(page);        }    }}
protected void pdfbox_f7644_0(PDDocument document) throws IOException
{}
protected void pdfbox_f7645_0(PDDocument document) throws IOException
{}
public void pdfbox_f7646_0(PDPage page) throws IOException
{    if (currentPageNo >= startPage && currentPageNo <= endPage && (startBookmarkPageNumber == -1 || currentPageNo >= startBookmarkPageNumber) && (endBookmarkPageNumber == -1 || currentPageNo <= endBookmarkPageNumber)) {        startPage(page);        int numberOfArticleSections = 1;        if (shouldSeparateByBeads) {            fillBeadRectangles(page);            numberOfArticleSections += beadRectangles.size() * 2;        }        int originalSize = charactersByArticle.size();        charactersByArticle.ensureCapacity(numberOfArticleSections);        int lastIndex = Math.max(numberOfArticleSections, originalSize);        for (int i = 0; i < lastIndex; i++) {            if (i < originalSize) {                charactersByArticle.get(i).clear();            } else {                if (numberOfArticleSections < originalSize) {                    charactersByArticle.remove(i);                } else {                    charactersByArticle.add(new ArrayList<TextPosition>());                }            }        }        characterListMapping.clear();        super.processPage(page);        writePage();        endPage(page);    }}
private void pdfbox_f7647_0(PDPage page)
{    beadRectangles = new ArrayList<>();    for (PDThreadBead bead : page.getThreadBeads()) {        if (bead == null) {                        beadRectangles.add(null);            continue;        }        PDRectangle rect = bead.getRectangle();                                PDRectangle mediaBox = page.getMediaBox();        float upperRightY = mediaBox.getUpperRightY() - rect.getLowerLeftY();        float lowerLeftY = mediaBox.getUpperRightY() - rect.getUpperRightY();        rect.setLowerLeftY(lowerLeftY);        rect.setUpperRightY(upperRightY);                PDRectangle cropBox = page.getCropBox();        if (Float.compare(cropBox.getLowerLeftX(), 0) != 0 || Float.compare(cropBox.getLowerLeftY(), 0) != 0) {            rect.setLowerLeftX(rect.getLowerLeftX() - cropBox.getLowerLeftX());            rect.setLowerLeftY(rect.getLowerLeftY() - cropBox.getLowerLeftY());            rect.setUpperRightX(rect.getUpperRightX() - cropBox.getLowerLeftX());            rect.setUpperRightY(rect.getUpperRightY() - cropBox.getLowerLeftY());        }        beadRectangles.add(rect);    }}
protected void pdfbox_f7648_0() throws IOException
{    startArticle(true);}
protected void pdfbox_f7649_0(boolean isLTR) throws IOException
{    output.write(getArticleStart());}
protected void pdfbox_f7650_0() throws IOException
{    output.write(getArticleEnd());}
protected void pdfbox_f7651_0(PDPage page) throws IOException
{}
protected void pdfbox_f7652_0(PDPage page) throws IOException
{}
protected void pdfbox_f7653_0() throws IOException
{    float maxYForLine = MAX_Y_FOR_LINE_RESET_VALUE;    float minYTopForLine = MIN_Y_TOP_FOR_LINE_RESET_VALUE;    float endOfLastTextX = END_OF_LAST_TEXT_X_RESET_VALUE;    float lastWordSpacing = LAST_WORD_SPACING_RESET_VALUE;    float maxHeightForLine = MAX_HEIGHT_FOR_LINE_RESET_VALUE;    PositionWrapper lastPosition = null;    PositionWrapper lastLineStartPosition = null;        boolean startOfPage = true;    boolean startOfArticle;    if (charactersByArticle.size() > 0) {        writePageStart();    }    for (List<TextPosition> textList : charactersByArticle) {        if (getSortByPosition()) {            TextPositionComparator comparator = new TextPositionComparator();                                                QuickSort.sort(textList, comparator);        }        startArticle();        startOfArticle = true;                                List<LineItem> line = new ArrayList<>();        Iterator<TextPosition> textIter = textList.iterator();                                                                        float previousAveCharWidth = -1;        while (textIter.hasNext()) {            TextPosition position = textIter.next();            PositionWrapper current = new PositionWrapper(position);            String characterValue = position.getUnicode();                        if (lastPosition != null && (position.getFont() != lastPosition.getTextPosition().getFont() || Float.compare(position.getFontSize(), lastPosition.getTextPosition().getFontSize()) != 0)) {                previousAveCharWidth = -1;            }            float positionX;            float positionY;            float positionWidth;            float positionHeight;                        if (getSortByPosition()) {                positionX = position.getXDirAdj();                positionY = position.getYDirAdj();                positionWidth = position.getWidthDirAdj();                positionHeight = position.getHeightDir();            } else {                positionX = position.getX();                positionY = position.getY();                positionWidth = position.getWidth();                positionHeight = position.getHeight();            }                        int wordCharCount = position.getIndividualWidths().length;                                    float wordSpacing = position.getWidthOfSpace();            float deltaSpace;            if (Float.compare(wordSpacing, 0) == 0 || Float.isNaN(wordSpacing)) {                deltaSpace = Float.MAX_VALUE;            } else {                if (lastWordSpacing < 0) {                    deltaSpace = wordSpacing * getSpacingTolerance();                } else {                    deltaSpace = (wordSpacing + lastWordSpacing) / 2f * getSpacingTolerance();                }            }                                                            float averageCharWidth;            if (previousAveCharWidth < 0) {                averageCharWidth = positionWidth / wordCharCount;            } else {                averageCharWidth = (previousAveCharWidth + positionWidth / wordCharCount) / 2f;            }            float deltaCharWidth = averageCharWidth * getAverageCharTolerance();                                    float expectedStartOfNextWordX = EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE;            if (Float.compare(endOfLastTextX, END_OF_LAST_TEXT_X_RESET_VALUE) != 0) {                expectedStartOfNextWordX = endOfLastTextX + Math.min(deltaSpace, deltaCharWidth);            }            if (lastPosition != null) {                if (startOfArticle) {                    lastPosition.setArticleStart();                    startOfArticle = false;                }                                if (!overlap(positionY, positionHeight, maxYForLine, maxHeightForLine)) {                    writeLine(normalize(line));                    line.clear();                    lastLineStartPosition = handleLineSeparation(current, lastPosition, lastLineStartPosition, maxHeightForLine);                    expectedStartOfNextWordX = EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE;                    maxYForLine = MAX_Y_FOR_LINE_RESET_VALUE;                    maxHeightForLine = MAX_HEIGHT_FOR_LINE_RESET_VALUE;                    minYTopForLine = MIN_Y_TOP_FOR_LINE_RESET_VALUE;                }                                if (Float.compare(expectedStartOfNextWordX, EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE) != 0 && expectedStartOfNextWordX < positionX &&                 lastPosition.getTextPosition().getUnicode() != null && !lastPosition.getTextPosition().getUnicode().endsWith(" ")) {                    line.add(LineItem.getWordSeparator());                }            }            if (positionY >= maxYForLine) {                maxYForLine = positionY;            }                                    endOfLastTextX = positionX + positionWidth;                        if (characterValue != null) {                if (startOfPage && lastPosition == null) {                                        writeParagraphStart();                }                line.add(new LineItem(position));            }            maxHeightForLine = Math.max(maxHeightForLine, positionHeight);            minYTopForLine = Math.min(minYTopForLine, positionY - positionHeight);            lastPosition = current;            if (startOfPage) {                lastPosition.setParagraphStart();                lastPosition.setLineStart();                lastLineStartPosition = lastPosition;                startOfPage = false;            }            lastWordSpacing = wordSpacing;            previousAveCharWidth = averageCharWidth;        }                if (line.size() > 0) {            writeLine(normalize(line));            writeParagraphEnd();        }        endArticle();    }    writePageEnd();}
private boolean pdfbox_f7654_0(float y1, float height1, float y2, float height2)
{    return within(y1, y2, .1f) || y2 <= y1 && y2 >= y1 - height1 || y1 <= y2 && y1 >= y2 - height2;}
protected void pdfbox_f7655_0() throws IOException
{    output.write(getLineSeparator());}
protected void pdfbox_f7656_0() throws IOException
{    output.write(getWordSeparator());}
protected void pdfbox_f7657_0(TextPosition text) throws IOException
{    output.write(text.getUnicode());}
protected void pdfbox_f7658_0(String text, List<TextPosition> textPositions) throws IOException
{    writeString(text);}
protected void pdfbox_f7659_0(String text) throws IOException
{    output.write(text);}
private boolean pdfbox_f7660_0(float first, float second, float variance)
{    return second < first + variance && second > first - variance;}
protected void pdfbox_f7661_0(TextPosition text)
{    boolean showCharacter = true;    if (suppressDuplicateOverlappingText) {        showCharacter = false;        String textCharacter = text.getUnicode();        float textX = text.getX();        float textY = text.getY();        TreeMap<Float, TreeSet<Float>> sameTextCharacters = characterListMapping.get(textCharacter);        if (sameTextCharacters == null) {            sameTextCharacters = new TreeMap<>();            characterListMapping.put(textCharacter, sameTextCharacters);        }                                                                                        boolean suppressCharacter = false;        float tolerance = text.getWidth() / textCharacter.length() / 3.0f;        SortedMap<Float, TreeSet<Float>> xMatches = sameTextCharacters.subMap(textX - tolerance, textX + tolerance);        for (TreeSet<Float> xMatch : xMatches.values()) {            SortedSet<Float> yMatches = xMatch.subSet(textY - tolerance, textY + tolerance);            if (!yMatches.isEmpty()) {                suppressCharacter = true;                break;            }        }        if (!suppressCharacter) {            TreeSet<Float> ySet = sameTextCharacters.get(textX);            if (ySet == null) {                ySet = new TreeSet<>();                sameTextCharacters.put(textX, ySet);            }            ySet.add(textY);            showCharacter = true;        }    }    if (showCharacter) {                int foundArticleDivisionIndex = -1;        int notFoundButFirstLeftAndAboveArticleDivisionIndex = -1;        int notFoundButFirstLeftArticleDivisionIndex = -1;        int notFoundButFirstAboveArticleDivisionIndex = -1;        float x = text.getX();        float y = text.getY();        if (shouldSeparateByBeads) {            for (int i = 0; i < beadRectangles.size() && foundArticleDivisionIndex == -1; i++) {                PDRectangle rect = beadRectangles.get(i);                if (rect != null) {                    if (rect.contains(x, y)) {                        foundArticleDivisionIndex = i * 2 + 1;                    } else if ((x < rect.getLowerLeftX() || y < rect.getUpperRightY()) && notFoundButFirstLeftAndAboveArticleDivisionIndex == -1) {                        notFoundButFirstLeftAndAboveArticleDivisionIndex = i * 2;                    } else if (x < rect.getLowerLeftX() && notFoundButFirstLeftArticleDivisionIndex == -1) {                        notFoundButFirstLeftArticleDivisionIndex = i * 2;                    } else if (y < rect.getUpperRightY() && notFoundButFirstAboveArticleDivisionIndex == -1) {                        notFoundButFirstAboveArticleDivisionIndex = i * 2;                    }                } else {                    foundArticleDivisionIndex = 0;                }            }        } else {            foundArticleDivisionIndex = 0;        }        int articleDivisionIndex;        if (foundArticleDivisionIndex != -1) {            articleDivisionIndex = foundArticleDivisionIndex;        } else if (notFoundButFirstLeftAndAboveArticleDivisionIndex != -1) {            articleDivisionIndex = notFoundButFirstLeftAndAboveArticleDivisionIndex;        } else if (notFoundButFirstLeftArticleDivisionIndex != -1) {            articleDivisionIndex = notFoundButFirstLeftArticleDivisionIndex;        } else if (notFoundButFirstAboveArticleDivisionIndex != -1) {            articleDivisionIndex = notFoundButFirstAboveArticleDivisionIndex;        } else {            articleDivisionIndex = charactersByArticle.size() - 1;        }        List<TextPosition> textList = charactersByArticle.get(articleDivisionIndex);                if (textList.isEmpty()) {            textList.add(text);        } else {                                                            TextPosition previousTextPosition = textList.get(textList.size() - 1);            if (text.isDiacritic() && previousTextPosition.contains(text)) {                previousTextPosition.mergeDiacritic(text);            } else             if (previousTextPosition.isDiacritic() && text.contains(previousTextPosition)) {                text.mergeDiacritic(previousTextPosition);                textList.remove(textList.size() - 1);                textList.add(text);            } else {                textList.add(text);            }        }    }}
public int pdfbox_f7662_0()
{    return startPage;}
public void pdfbox_f7663_0(int startPageValue)
{    startPage = startPageValue;}
public int pdfbox_f7664_0()
{    return endPage;}
public void pdfbox_f7665_0(int endPageValue)
{    endPage = endPageValue;}
public void pdfbox_f7666_0(String separator)
{    lineSeparator = separator;}
public String pdfbox_f7667_0()
{    return lineSeparator;}
public String pdfbox_f7668_0()
{    return wordSeparator;}
public void pdfbox_f7669_0(String separator)
{    wordSeparator = separator;}
public boolean pdfbox_f7670_0()
{    return suppressDuplicateOverlappingText;}
protected int pdfbox_f7671_0()
{    return currentPageNo;}
protected Writer pdfbox_f7672_0()
{    return output;}
protected List<List<TextPosition>> pdfbox_f7673_0()
{    return charactersByArticle;}
public void pdfbox_f7674_0(boolean suppressDuplicateOverlappingTextValue)
{    suppressDuplicateOverlappingText = suppressDuplicateOverlappingTextValue;}
public boolean pdfbox_f7675_0()
{    return shouldSeparateByBeads;}
public void pdfbox_f7676_0(boolean aShouldSeparateByBeads)
{    shouldSeparateByBeads = aShouldSeparateByBeads;}
public PDOutlineItem pdfbox_f7677_0()
{    return endBookmark;}
public void pdfbox_f7678_0(PDOutlineItem aEndBookmark)
{    endBookmark = aEndBookmark;}
public PDOutlineItem pdfbox_f7679_0()
{    return startBookmark;}
public void pdfbox_f7680_0(PDOutlineItem aStartBookmark)
{    startBookmark = aStartBookmark;}
public boolean pdfbox_f7681_0()
{    return addMoreFormatting;}
public void pdfbox_f7682_0(boolean newAddMoreFormatting)
{    addMoreFormatting = newAddMoreFormatting;}
public boolean pdfbox_f7683_0()
{    return sortByPosition;}
public void pdfbox_f7684_0(boolean newSortByPosition)
{    sortByPosition = newSortByPosition;}
public float pdfbox_f7685_0()
{    return spacingTolerance;}
public void pdfbox_f7686_0(float spacingToleranceValue)
{    spacingTolerance = spacingToleranceValue;}
public float pdfbox_f7687_0()
{    return averageCharTolerance;}
public void pdfbox_f7688_0(float averageCharToleranceValue)
{    averageCharTolerance = averageCharToleranceValue;}
public float pdfbox_f7689_0()
{    return indentThreshold;}
public void pdfbox_f7690_0(float indentThresholdValue)
{    indentThreshold = indentThresholdValue;}
public float pdfbox_f7691_0()
{    return dropThreshold;}
public void pdfbox_f7692_0(float dropThresholdValue)
{    dropThreshold = dropThresholdValue;}
public String pdfbox_f7693_0()
{    return paragraphStart;}
public void pdfbox_f7694_0(String s)
{    paragraphStart = s;}
public String pdfbox_f7695_0()
{    return paragraphEnd;}
public void pdfbox_f7696_0(String s)
{    paragraphEnd = s;}
public String pdfbox_f7697_0()
{    return pageStart;}
public void pdfbox_f7698_0(String pageStartValue)
{    pageStart = pageStartValue;}
public String pdfbox_f7699_0()
{    return pageEnd;}
public void pdfbox_f7700_0(String pageEndValue)
{    pageEnd = pageEndValue;}
public String pdfbox_f7701_0()
{    return articleStart;}
public void pdfbox_f7702_0(String articleStartValue)
{    articleStart = articleStartValue;}
public String pdfbox_f7703_0()
{    return articleEnd;}
public void pdfbox_f7704_0(String articleEndValue)
{    articleEnd = articleEndValue;}
private PositionWrapper pdfbox_f7705_0(PositionWrapper current, PositionWrapper lastPosition, PositionWrapper lastLineStartPosition, float maxHeightForLine) throws IOException
{    current.setLineStart();    isParagraphSeparation(current, lastPosition, lastLineStartPosition, maxHeightForLine);    lastLineStartPosition = current;    if (current.isParagraphStart()) {        if (lastPosition.isArticleStart()) {            if (lastPosition.isLineStart()) {                writeLineSeparator();            }            writeParagraphStart();        } else {            writeLineSeparator();            writeParagraphSeparator();        }    } else {        writeLineSeparator();    }    return lastLineStartPosition;}
private void pdfbox_f7706_0(PositionWrapper position, PositionWrapper lastPosition, PositionWrapper lastLineStartPosition, float maxHeightForLine)
{    boolean result = false;    if (lastLineStartPosition == null) {        result = true;    } else {        float yGap = Math.abs(position.getTextPosition().getYDirAdj() - lastPosition.getTextPosition().getYDirAdj());        float newYVal = multiplyFloat(getDropThreshold(), maxHeightForLine);                float xGap = position.getTextPosition().getXDirAdj() - lastLineStartPosition.getTextPosition().getXDirAdj();        float newXVal = multiplyFloat(getIndentThreshold(), position.getTextPosition().getWidthOfSpace());        float positionWidth = multiplyFloat(0.25f, position.getTextPosition().getWidth());        if (yGap > newYVal) {            result = true;        } else if (xGap > newXVal) {                        if (!lastLineStartPosition.isParagraphStart()) {                result = true;            } else {                position.setHangingIndent();            }        } else if (xGap < -position.getTextPosition().getWidthOfSpace()) {                        if (!lastLineStartPosition.isParagraphStart()) {                result = true;            }        } else if (Math.abs(xGap) < positionWidth) {                        if (lastLineStartPosition.isHangingIndent()) {                position.setHangingIndent();            } else if (lastLineStartPosition.isParagraphStart()) {                                                Pattern liPattern = matchListItemPattern(lastLineStartPosition);                if (liPattern != null) {                    Pattern currentPattern = matchListItemPattern(position);                    if (liPattern == currentPattern) {                        result = true;                    }                }            }        }    }    if (result) {        position.setParagraphStart();    }}
private float pdfbox_f7707_0(float value1, float value2)
{        return Math.round(value1 * value2 * 1000) / 1000f;}
protected void pdfbox_f7708_0() throws IOException
{    writeParagraphEnd();    writeParagraphStart();}
protected void pdfbox_f7709_0() throws IOException
{    if (inParagraph) {        writeParagraphEnd();        inParagraph = false;    }    output.write(getParagraphStart());    inParagraph = true;}
protected void pdfbox_f7710_0() throws IOException
{    if (!inParagraph) {        writeParagraphStart();    }    output.write(getParagraphEnd());    inParagraph = false;}
protected void pdfbox_f7711_0() throws IOException
{    output.write(getPageStart());}
protected void pdfbox_f7712_0() throws IOException
{    output.write(getPageEnd());}
private Pattern pdfbox_f7713_0(PositionWrapper pw)
{    TextPosition tp = pw.getTextPosition();    String txt = tp.getUnicode();    return matchPattern(txt, getListItemPatterns());}
protected void pdfbox_f7714_0(List<Pattern> patterns)
{    listOfPatterns = patterns;}
protected List<Pattern> pdfbox_f7715_0()
{    if (listOfPatterns == null) {        listOfPatterns = new ArrayList<>();        for (String expression : LIST_ITEM_EXPRESSIONS) {            Pattern p = Pattern.compile(expression);            listOfPatterns.add(p);        }    }    return listOfPatterns;}
protected static Pattern pdfbox_f7716_0(String string, List<Pattern> patterns)
{    for (Pattern p : patterns) {        if (p.matcher(string).matches()) {            return p;        }    }    return null;}
private void pdfbox_f7717_0(List<WordWithTextPositions> line) throws IOException
{    int numberOfStrings = line.size();    for (int i = 0; i < numberOfStrings; i++) {        WordWithTextPositions word = line.get(i);        writeString(word.getText(), word.getTextPositions());        if (i < numberOfStrings - 1) {            writeWordSeparator();        }    }}
private List<WordWithTextPositions> pdfbox_f7718_0(List<LineItem> line)
{    List<WordWithTextPositions> normalized = new LinkedList<>();    StringBuilder lineBuilder = new StringBuilder();    List<TextPosition> wordPositions = new ArrayList<>();    for (LineItem item : line) {        lineBuilder = normalizeAdd(normalized, lineBuilder, wordPositions, item);    }    if (lineBuilder.length() > 0) {        normalized.add(createWord(lineBuilder.toString(), wordPositions));    }    return normalized;}
private String pdfbox_f7719_0(String word)
{    Bidi bidi = new Bidi(word, Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT);        if (!bidi.isMixed() && bidi.getBaseLevel() == Bidi.DIRECTION_LEFT_TO_RIGHT) {        return word;    }        int runCount = bidi.getRunCount();    byte[] levels = new byte[runCount];    Integer[] runs = new Integer[runCount];    for (int i = 0; i < runCount; i++) {        levels[i] = (byte) bidi.getRunLevel(i);        runs[i] = i;    }        Bidi.reorderVisually(levels, 0, runs, 0, runCount);        StringBuilder result = new StringBuilder();    for (int i = 0; i < runCount; i++) {        int index = runs[i];        int start = bidi.getRunStart(index);        int end = bidi.getRunLimit(index);        int level = levels[index];        if ((level & 1) != 0) {            while (--end >= start) {                char character = word.charAt(end);                if (Character.isMirrored(word.codePointAt(end))) {                    if (MIRRORING_CHAR_MAP.containsKey(character)) {                        result.append(MIRRORING_CHAR_MAP.get(character));                    } else {                        result.append(character);                    }                } else {                    result.append(character);                }            }        } else {            result.append(word, start, end);        }    }    return result.toString();}
private static void pdfbox_f7720_0(InputStream inputStream) throws IOException
{    LineNumberReader rd = new LineNumberReader(new InputStreamReader(inputStream));    do {        String s = rd.readLine();        if (s == null) {            break;        }                int comment = s.indexOf('#');        if (comment != -1) {            s = s.substring(0, comment);        }        if (s.length() < 2) {            continue;        }        StringTokenizer st = new StringTokenizer(s, ";");        int nFields = st.countTokens();        Character[] fields = new Character[nFields];        for (int i = 0; i < nFields; i++) {            fields[i] = (char) Integer.parseInt(st.nextToken().trim(), 16);        }        if (fields.length == 2) {                        MIRRORING_CHAR_MAP.put(fields[0], fields[1]);        }    } while (true);}
private WordWithTextPositions pdfbox_f7721_0(String word, List<TextPosition> wordPositions)
{    return new WordWithTextPositions(normalizeWord(word), wordPositions);}
private String pdfbox_f7722_0(String word)
{    StringBuilder builder = null;    int p = 0;    int q = 0;    int strLength = word.length();    for (; q < strLength; q++) {                                                char c = word.charAt(q);        if (0xFB00 <= c && c <= 0xFDFF || 0xFE70 <= c && c <= 0xFEFF) {            if (builder == null) {                builder = new StringBuilder(strLength * 2);            }            builder.append(word.substring(p, q));                        if (c == 0xFDF2 && q > 0 && (word.charAt(q - 1) == 0x0627 || word.charAt(q - 1) == 0xFE8D)) {                builder.append("\u0644\u0644\u0647");            } else {                                builder.append(Normalizer.normalize(word.substring(q, q + 1), Normalizer.Form.NFKC).trim());            }            p = q + 1;        }    }    if (builder == null) {        return handleDirection(word);    } else {        builder.append(word.substring(p, q));        return handleDirection(builder.toString());    }}
private StringBuilder pdfbox_f7723_0(List<WordWithTextPositions> normalized, StringBuilder lineBuilder, List<TextPosition> wordPositions, LineItem item)
{    if (item.isWordSeparator()) {        normalized.add(createWord(lineBuilder.toString(), new ArrayList<>(wordPositions)));        lineBuilder = new StringBuilder();        wordPositions.clear();    } else {        TextPosition text = item.getTextPosition();        lineBuilder.append(text.getUnicode());        wordPositions.add(text);    }    return lineBuilder;}
public static LineItem pdfbox_f7724_0()
{    return WORD_SEPARATOR;}
public TextPosition pdfbox_f7725_0()
{    return textPosition;}
public boolean pdfbox_f7726_0()
{    return textPosition == null;}
public String pdfbox_f7727_0()
{    return text;}
public List<TextPosition> pdfbox_f7728_0()
{    return textPositions;}
public TextPosition pdfbox_f7729_0()
{    return position;}
public boolean pdfbox_f7730_0()
{    return isLineStart;}
public void pdfbox_f7731_0()
{    this.isLineStart = true;}
public boolean pdfbox_f7732_0()
{    return isParagraphStart;}
public void pdfbox_f7733_0()
{    this.isParagraphStart = true;}
public boolean pdfbox_f7734_0()
{    return isArticleStart;}
public void pdfbox_f7735_0()
{    this.isArticleStart = true;}
public boolean pdfbox_f7736_0()
{    return isPageBreak;}
public void pdfbox_f7737_0()
{    this.isPageBreak = true;}
public boolean pdfbox_f7738_0()
{    return isHangingIndent;}
public void pdfbox_f7739_0()
{    this.isHangingIndent = true;}
public final void pdfbox_f7740_0(boolean aShouldSeparateByBeads)
{}
public void pdfbox_f7741_0(String regionName, Rectangle2D rect)
{    regions.add(regionName);    regionArea.put(regionName, rect);}
public void pdfbox_f7742_0(String regionName)
{    regions.remove(regionName);    regionArea.remove(regionName);}
public List<String> pdfbox_f7743_0()
{    return regions;}
public String pdfbox_f7744_0(String regionName)
{    StringWriter text = regionText.get(regionName);    return text.toString();}
public void pdfbox_f7745_0(PDPage page) throws IOException
{    for (String region : regions) {        setStartPage(getCurrentPageNo());        setEndPage(getCurrentPageNo());                        String regionName = region;        ArrayList<List<TextPosition>> regionCharactersByArticle = new ArrayList<>();        regionCharactersByArticle.add(new ArrayList<TextPosition>());        regionCharacterList.put(regionName, regionCharactersByArticle);        regionText.put(regionName, new StringWriter());    }    if (page.hasContents()) {        processPage(page);    }}
protected void pdfbox_f7746_0(TextPosition text)
{    for (Map.Entry<String, Rectangle2D> regionAreaEntry : regionArea.entrySet()) {        Rectangle2D rect = regionAreaEntry.getValue();        if (rect.contains(text.getX(), text.getY())) {            charactersByArticle = regionCharacterList.get(regionAreaEntry.getKey());            super.processTextPosition(text);        }    }}
protected void pdfbox_f7747_0() throws IOException
{    for (String region : regionArea.keySet()) {        charactersByArticle = regionCharacterList.get(region);        output = regionText.get(region);        super.writePage();    }}
private static Map<Integer, String> pdfbox_f7748_0()
{    Map<Integer, String> map = new HashMap<>(31);    map.put(0x0060, "\u0300");    map.put(0x02CB, "\u0300");    map.put(0x0027, "\u0301");    map.put(0x02B9, "\u0301");    map.put(0x02CA, "\u0301");    map.put(0x005e, "\u0302");    map.put(0x02C6, "\u0302");    map.put(0x007E, "\u0303");    map.put(0x02C9, "\u0304");    map.put(0x00B0, "\u030A");    map.put(0x02BA, "\u030B");    map.put(0x02C7, "\u030C");    map.put(0x02C8, "\u030D");    map.put(0x0022, "\u030E");    map.put(0x02BB, "\u0312");    map.put(0x02BC, "\u0313");    map.put(0x0486, "\u0313");    map.put(0x055A, "\u0313");    map.put(0x02BD, "\u0314");    map.put(0x0485, "\u0314");    map.put(0x0559, "\u0314");    map.put(0x02D4, "\u031D");    map.put(0x02D5, "\u031E");    map.put(0x02D6, "\u031F");    map.put(0x02D7, "\u0320");    map.put(0x02B2, "\u0321");    map.put(0x02CC, "\u0329");    map.put(0x02B7, "\u032B");    map.put(0x02CD, "\u0331");    map.put(0x005F, "\u0332");    map.put(0x204E, "\u0359");    return map;}
public String pdfbox_f7749_0()
{    return unicode;}
public int[] pdfbox_f7750_0()
{    return charCodes;}
public Matrix pdfbox_f7751_0()
{    return textMatrix;}
public float pdfbox_f7752_0()
{    if (direction < 0) {        float a = textMatrix.getScaleY();        float b = textMatrix.getShearY();        float c = textMatrix.getShearX();        float d = textMatrix.getScaleX();                if (a > 0 && Math.abs(b) < d && Math.abs(c) < a && d > 0) {            direction = 0;        } else         if (a < 0 && Math.abs(b) < Math.abs(d) && Math.abs(c) < Math.abs(a) && d < 0) {            direction = 180;        } else         if (Math.abs(a) < Math.abs(c) && b > 0 && c < 0 && Math.abs(d) < b) {            direction = 90;        } else         if (Math.abs(a) < c && b < 0 && c > 0 && Math.abs(d) < Math.abs(b)) {            direction = 270;        } else {            direction = 0;        }    }    return direction;}
private float pdfbox_f7753_0(float rotation)
{    if (Float.compare(rotation, 0) == 0) {        return textMatrix.getTranslateX();    } else if (Float.compare(rotation, 90) == 0) {        return textMatrix.getTranslateY();    } else if (Float.compare(rotation, 180) == 0) {        return pageWidth - textMatrix.getTranslateX();    } else if (Float.compare(rotation, 270) == 0) {        return pageHeight - textMatrix.getTranslateY();    }    return 0;}
public float pdfbox_f7754_0()
{    return x;}
public float pdfbox_f7755_0()
{    return getXRot(getDir());}
private float pdfbox_f7756_0(float rotation)
{    if (Float.compare(rotation, 0) == 0) {        return textMatrix.getTranslateY();    } else if (Float.compare(rotation, 90) == 0) {        return pageWidth - textMatrix.getTranslateX();    } else if (Float.compare(rotation, 180) == 0) {        return pageHeight - textMatrix.getTranslateY();    } else if (Float.compare(rotation, 270) == 0) {        return textMatrix.getTranslateX();    }    return 0;}
public float pdfbox_f7757_0()
{    return y;}
public float pdfbox_f7758_0()
{    float dir = getDir();        if (Float.compare(dir, 0) == 0 || Float.compare(dir, 180) == 0) {        return pageHeight - getYLowerLeftRot(dir);    } else {        return pageWidth - getYLowerLeftRot(dir);    }}
private float pdfbox_f7759_0(float rotation)
{    if (Float.compare(rotation, 90) == 0 || Float.compare(rotation, 270) == 0) {        return Math.abs(endY - textMatrix.getTranslateY());    } else {        return Math.abs(endX - textMatrix.getTranslateX());    }}
public float pdfbox_f7760_0()
{    return getWidthRot(rotation);}
public float pdfbox_f7761_0()
{    return getWidthRot(getDir());}
public float pdfbox_f7762_0()
{    return maxHeight;}
public float pdfbox_f7763_0()
{        return maxHeight;}
public float pdfbox_f7764_0()
{    return fontSize;}
public float pdfbox_f7765_0()
{    return fontSizePt;}
public PDFont pdfbox_f7766_0()
{    return font;}
public float pdfbox_f7767_0()
{    return widthOfSpace;}
public float pdfbox_f7768_0()
{    return textMatrix.getScalingFactorX();}
public float pdfbox_f7769_0()
{    return textMatrix.getScalingFactorY();}
public float[] pdfbox_f7770_0()
{    return widths;}
public boolean pdfbox_f7771_0(TextPosition tp2)
{    double thisXstart = getXDirAdj();    double thisWidth = getWidthDirAdj();    double thisXend = thisXstart + thisWidth;    double tp2Xstart = tp2.getXDirAdj();    double tp2Xend = tp2Xstart + tp2.getWidthDirAdj();        if (tp2Xend <= thisXstart || tp2Xstart >= thisXend) {        return false;    }            double thisYstart = getYDirAdj();    double tp2Ystart = tp2.getYDirAdj();    if (tp2Ystart + tp2.getHeightDir() < thisYstart || tp2Ystart > thisYstart + getHeightDir()) {        return false;    } else     if (tp2Xstart > thisXstart && tp2Xend > thisXend) {        double overlap = thisXend - tp2Xstart;        double overlapPercent = overlap / thisWidth;        return overlapPercent > .15;    } else if (tp2Xstart < thisXstart && tp2Xend < thisXend) {        double overlap = tp2Xend - thisXstart;        double overlapPercent = overlap / thisWidth;        return overlapPercent > .15;    }    return true;}
public void pdfbox_f7772_1(TextPosition diacritic)
{    if (diacritic.getUnicode().length() > 1) {        return;    }    float diacXStart = diacritic.getXDirAdj();    float diacXEnd = diacXStart + diacritic.widths[0];    float currCharXStart = getXDirAdj();    int strLen = unicode.length();    boolean wasAdded = false;    for (int i = 0; i < strLen && !wasAdded; i++) {        if (i >= widths.length) {                        break;        }        float currCharXEnd = currCharXStart + widths[i];                if (diacXStart < currCharXStart && diacXEnd <= currCharXEnd) {            if (i == 0) {                insertDiacritic(i, diacritic);            } else {                float distanceOverlapping1 = diacXEnd - currCharXStart;                float percentage1 = distanceOverlapping1 / widths[i];                float distanceOverlapping2 = currCharXStart - diacXStart;                float percentage2 = distanceOverlapping2 / widths[i - 1];                if (percentage1 >= percentage2) {                    insertDiacritic(i, diacritic);                } else {                    insertDiacritic(i - 1, diacritic);                }            }            wasAdded = true;        } else         if (diacXStart < currCharXStart) {            insertDiacritic(i, diacritic);            wasAdded = true;        } else         if (diacXEnd <= currCharXEnd) {            insertDiacritic(i, diacritic);            wasAdded = true;        } else         if (i == strLen - 1) {            insertDiacritic(i, diacritic);            wasAdded = true;        }                currCharXStart += widths[i];    }}
private void pdfbox_f7773_0(int i, TextPosition diacritic)
{    StringBuilder sb = new StringBuilder();    sb.append(unicode.substring(0, i));    float[] widths2 = new float[widths.length + 1];    System.arraycopy(widths, 0, widths2, 0, i);            sb.append(unicode.charAt(i));    widths2[i] = widths[i];    sb.append(combineDiacritic(diacritic.getUnicode()));    widths2[i + 1] = 0;        sb.append(unicode.substring(i + 1, unicode.length()));    System.arraycopy(widths, i + 1, widths2, i + 2, widths.length - i - 1);    unicode = sb.toString();    widths = widths2;}
private String pdfbox_f7774_0(String str)
{        int codePoint = str.codePointAt(0);        if (DIACRITICS.containsKey(codePoint)) {        return DIACRITICS.get(codePoint);    } else {        return Normalizer.normalize(str, Normalizer.Form.NFKC).trim();    }}
public boolean pdfbox_f7775_0()
{    String text = this.getUnicode();    if (text.length() != 1) {        return false;    }    if ("".equals(text)) {                return false;    }    int type = Character.getType(text.charAt(0));    return type == Character.NON_SPACING_MARK || type == Character.MODIFIER_SYMBOL || type == Character.MODIFIER_LETTER;}
public String pdfbox_f7776_0()
{    return getUnicode();}
public float pdfbox_f7777_0()
{    return endX;}
public float pdfbox_f7778_0()
{    return endY;}
public int pdfbox_f7779_0()
{    return rotation;}
public float pdfbox_f7780_0()
{    return pageHeight;}
public float pdfbox_f7781_0()
{    return pageWidth;}
public boolean pdfbox_f7782_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof TextPosition)) {        return false;    }    TextPosition that = (TextPosition) o;    if (Float.compare(that.endX, endX) != 0) {        return false;    }    if (Float.compare(that.endY, endY) != 0) {        return false;    }    if (Float.compare(that.maxHeight, maxHeight) != 0) {        return false;    }    if (rotation != that.rotation) {        return false;    }    if (Float.compare(that.x, x) != 0) {        return false;    }    if (Float.compare(that.y, y) != 0) {        return false;    }    if (Float.compare(that.pageHeight, pageHeight) != 0) {        return false;    }    if (Float.compare(that.pageWidth, pageWidth) != 0) {        return false;    }    if (Float.compare(that.widthOfSpace, widthOfSpace) != 0) {        return false;    }    if (Float.compare(that.fontSize, fontSize) != 0) {        return false;    }    if (fontSizePt != that.fontSizePt) {        return false;    }    if (Float.compare(that.direction, direction) != 0) {        return false;    }    if (textMatrix != null ? !textMatrix.equals(that.textMatrix) : that.textMatrix != null) {        return false;    }    if (!Arrays.equals(charCodes, that.charCodes)) {        return false;    }    if (font != null ? !font.equals(that.font) : that.font != null) {        return false;    }    if (!Arrays.equals(widths, that.widths)) {        return false;    }    return unicode != null ? unicode.equals(that.unicode) : that.unicode == null;}
public int pdfbox_f7783_0()
{    int result = textMatrix != null ? textMatrix.hashCode() : 0;    result = 31 * result + Float.floatToIntBits(endX);    result = 31 * result + Float.floatToIntBits(endY);    result = 31 * result + Float.floatToIntBits(maxHeight);    result = 31 * result + rotation;    result = 31 * result + Float.floatToIntBits(x);    result = 31 * result + Float.floatToIntBits(y);    result = 31 * result + Float.floatToIntBits(pageHeight);    result = 31 * result + Float.floatToIntBits(pageWidth);    result = 31 * result + Float.floatToIntBits(widthOfSpace);    result = 31 * result + Arrays.hashCode(charCodes);    result = 31 * result + (font != null ? font.hashCode() : 0);    result = 31 * result + Float.floatToIntBits(fontSize);    result = 31 * result + fontSizePt;    return result;}
public int pdfbox_f7784_0(TextPosition pos1, TextPosition pos2)
{        int cmp1 = Float.compare(pos1.getDir(), pos2.getDir());    if (cmp1 != 0) {        return cmp1;    }        float x1 = pos1.getXDirAdj();    float x2 = pos2.getXDirAdj();    float pos1YBottom = pos1.getYDirAdj();    float pos2YBottom = pos2.getYDirAdj();        float pos1YTop = pos1YBottom - pos1.getHeightDir();    float pos2YTop = pos2YBottom - pos2.getHeightDir();    float yDifference = Math.abs(pos1YBottom - pos2YBottom);        if (yDifference < .1 || pos2YBottom >= pos1YTop && pos2YBottom <= pos1YBottom || pos1YBottom >= pos2YTop && pos1YBottom <= pos2YBottom) {        return Float.compare(x1, x2);    } else if (pos1YBottom < pos2YBottom) {        return -1;    } else {        return 1;    }}
public static String pdfbox_f7785_0(Calendar cal)
{    if (cal == null) {        return null;    }    String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET), "'");    return String.format(Locale.US, "D:" +     "%1$4tY%1$2tm%1$2td" +     "%1$2tH%1$2tM%1$2tS" +     "%2$s" +     "'", cal, offset);}
public static String pdfbox_f7786_0(Calendar cal)
{    String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET), ":");    return String.format(Locale.US,     "%1$4tY" +     "-%1$2tm" +     "-%1$2td" +     "T" +     "%1$2tH:%1$2tM:%1$2tS" +     "%2$s", cal, offset);}
private static int pdfbox_f7787_0(long proposedOffset)
{    if (proposedOffset <= 14 * MILLIS_PER_HOUR && proposedOffset >= -14 * MILLIS_PER_HOUR) {                return (int) proposedOffset;    }        proposedOffset = ((proposedOffset + HALF_DAY) % DAY + DAY) % DAY;    if (proposedOffset == 0) {        return HALF_DAY;    }        proposedOffset = (proposedOffset - HALF_DAY) % HALF_DAY;        return (int) proposedOffset;}
 static String pdfbox_f7788_0(long millis, String sep)
{        SimpleDateFormat sdf = new SimpleDateFormat("Z");    sdf.setTimeZone(new SimpleTimeZone(restrainTZoffset(millis), "unknown"));    String tz = sdf.format(new Date());    return tz.substring(0, 3) + sep + tz.substring(3);}
private static int pdfbox_f7789_0(String text, ParsePosition where, int maxlen, int remedy)
{    if (text == null) {        return remedy;    }            int retval = 0;    int index = where.getIndex();    int limit = index + Math.min(maxlen, text.length() - index);    for (; index < limit; index++) {                int cval = text.charAt(index) - '0';                if (cval < 0 || cval > 9) {                        break;        }                retval = retval * 10 + cval;    }    if (index == where.getIndex()) {        return remedy;    }    where.setIndex(index);    return retval;}
private static char pdfbox_f7790_0(String text, ParsePosition where, String optionals)
{    char retval = ' ', currch;    while (text != null && where.getIndex() < text.length() && optionals.indexOf((currch = text.charAt(where.getIndex()))) >= 0) {        retval = (currch != ' ') ? currch : retval;        where.setIndex(where.getIndex() + 1);    }    return retval;}
private static boolean pdfbox_f7791_0(String text, String victim, ParsePosition where)
{    if (text.startsWith(victim, where.getIndex())) {        where.setIndex(where.getIndex() + victim.length());        return true;    }    return false;}
 static GregorianCalendar pdfbox_f7792_0()
{    GregorianCalendar retCal = new GregorianCalendar(Locale.ENGLISH);    retCal.setTimeZone(new SimpleTimeZone(0, "UTC"));    retCal.setLenient(false);    retCal.set(Calendar.MILLISECOND, 0);    return retCal;}
private static void pdfbox_f7793_0(GregorianCalendar cal, TimeZone tz)
{    cal.setTimeZone(tz);    int offset = (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / MILLIS_PER_MINUTE;    cal.add(Calendar.MINUTE, -offset);}
 static boolean pdfbox_f7794_0(String text, GregorianCalendar cal, ParsePosition initialWhere)
{    ParsePosition where = new ParsePosition(initialWhere.getIndex());    TimeZone tz = new SimpleTimeZone(0, "GMT");    int tzHours, tzMin;    char sign = skipOptionals(text, where, "Z+- ");    boolean hadGMT = (sign == 'Z' || skipString(text, "GMT", where) || skipString(text, "UTC", where));    sign = (!hadGMT) ? sign : skipOptionals(text, where, "+- ");    tzHours = parseTimeField(text, where, 2, -999);    skipOptionals(text, where, "\': ");    tzMin = parseTimeField(text, where, 2, 0);    skipOptionals(text, where, "\' ");    if (tzHours != -999) {                int hrSign = (sign == '-' ? -1 : 1);        tz.setRawOffset(restrainTZoffset(hrSign * (tzHours * MILLIS_PER_HOUR + tzMin * (long) MILLIS_PER_MINUTE)));        updateZoneId(tz);    } else if (!hadGMT) {                String tzText = text.substring(initialWhere.getIndex()).trim();        tz = TimeZone.getTimeZone(tzText);                if ("GMT".equals(tz.getID())) {                        return false;        } else {                        where.setIndex(text.length());        }    }    adjustTimeZoneNicely(cal, tz);    initialWhere.setIndex(where.getIndex());    return true;}
private static void pdfbox_f7795_0(TimeZone tz)
{    int offset = tz.getRawOffset();    char pm = '+';    if (offset < 0) {        pm = '-';        offset = -offset;    }    int hh = offset / 3600000;    int mm = offset % 3600000 / 60000;    if (offset == 0) {        tz.setID("GMT");    } else if (pm == '+' && hh <= 12) {        tz.setID(String.format(Locale.US, "GMT+%02d:%02d", hh, mm));    } else if (pm == '-' && hh <= 14) {        tz.setID(String.format(Locale.US, "GMT-%02d:%02d", hh, mm));    } else {        tz.setID("unknown");    }}
private static GregorianCalendar pdfbox_f7796_1(String text, ParsePosition initialWhere)
{    ParsePosition where = new ParsePosition(initialWhere.getIndex());    int year = parseTimeField(text, where, 4, 0);    if (where.getIndex() != 4 + initialWhere.getIndex()) {        return null;    }    skipOptionals(text, where, "/- ");        int month = parseTimeField(text, where, 2, 1) - 1;    skipOptionals(text, where, "/- ");    int day = parseTimeField(text, where, 2, 1);    skipOptionals(text, where, " T");    int hour = parseTimeField(text, where, 2, 0);    skipOptionals(text, where, ": ");    int minute = parseTimeField(text, where, 2, 0);    skipOptionals(text, where, ": ");    int second = parseTimeField(text, where, 2, 0);    char nextC = skipOptionals(text, where, ".");    if (nextC == '.') {                parseTimeField(text, where, 19, 0);    }    GregorianCalendar dest = newGreg();    try {        dest.set(year, month, day, hour, minute, second);                dest.getTimeInMillis();    } catch (IllegalArgumentException ill) {                return null;    }    initialWhere.setIndex(where.getIndex());    skipOptionals(text, initialWhere, " ");        return dest;}
private static GregorianCalendar pdfbox_f7797_0(String text, String[] fmts, ParsePosition initialWhere)
{    for (String fmt : fmts) {        ParsePosition where = new ParsePosition(initialWhere.getIndex());        SimpleDateFormat sdf = new SimpleDateFormat(fmt, Locale.ENGLISH);        GregorianCalendar retCal = newGreg();        sdf.setCalendar(retCal);        if (sdf.parse(text, where) != null) {            initialWhere.setIndex(where.getIndex());            skipOptionals(text, initialWhere, " ");            return retCal;        }    }    return null;}
private static Calendar pdfbox_f7798_0(String text, ParsePosition initialWhere)
{    if (text == null || text.isEmpty()) {        return null;    }        int longestLen = -999999;                GregorianCalendar longestDate = null;        int whereLen;    ParsePosition where = new ParsePosition(initialWhere.getIndex());        skipOptionals(text, where, " ");    int startPosition = where.getIndex();        GregorianCalendar retCal = parseBigEndianDate(text, where);        if (retCal != null && (where.getIndex() == text.length() || parseTZoffset(text, retCal, where))) {                whereLen = where.getIndex();        if (whereLen == text.length()) {            initialWhere.setIndex(whereLen);            return retCal;        }        longestLen = whereLen;        longestDate = retCal;    }        where.setIndex(startPosition);    String[] formats = Character.isDigit(text.charAt(startPosition)) ? DIGIT_START_FORMATS : ALPHA_START_FORMATS;    retCal = parseSimpleDate(text, formats, where);        if (retCal != null && (where.getIndex() == text.length() || parseTZoffset(text, retCal, where))) {                whereLen = where.getIndex();        if (whereLen == text.length()) {            initialWhere.setIndex(whereLen);            return retCal;        }        if (whereLen > longestLen) {            longestLen = whereLen;            longestDate = retCal;        }    }    if (longestDate != null) {        initialWhere.setIndex(longestLen);        return longestDate;    }    return retCal;}
public static Calendar pdfbox_f7799_0(COSString text)
{    if (text == null) {        return null;    }    return toCalendar(text.getString());}
public static Calendar pdfbox_f7800_0(String text)
{    if (text == null || text.trim().isEmpty()) {        return null;    }    ParsePosition where = new ParsePosition(0);    skipOptionals(text, where, " ");    skipString(text, "D:", where);    Calendar calendar = parseDate(text, where);    if (calendar == null || where.getIndex() != text.length()) {                return null;    }    return calendar;}
public void pdfbox_f7801_0(T value)
{    if (this.value != null) {        throw new IllegalStateException("Value already set for this trie node");    }    this.value = value;}
public T pdfbox_f7802_0()
{    return value;}
public T pdfbox_f7803_0(byte[] bytes)
{    ByteTrieNode<T> node = root;    T val = node.getValue();    for (byte b : bytes) {        ByteTrieNode<T> child = node.children.get(b);        if (child == null) {            break;        }        node = child;        if (node.getValue() != null) {            val = node.getValue();        }    }    return val;}
public void pdfbox_f7804_0(T value, byte[]... parts)
{    int depth = 0;    ByteTrieNode<T> node = root;    for (byte[] part : parts) {        for (byte b : part) {            ByteTrieNode<T> child = node.children.get(b);            if (child == null) {                child = new ByteTrieNode<>();                node.children.put(b, child);            }            node = child;            depth++;        }    }    node.setValue(value);    maxDepth = Math.max(maxDepth, depth);}
public void pdfbox_f7805_0(T defaultValue)
{    root.setValue(defaultValue);}
public int pdfbox_f7806_0()
{    return maxDepth;}
public static FileType pdfbox_f7807_0(final BufferedInputStream inputStream) throws IOException
{    if (!inputStream.markSupported()) {        throw new IOException("Stream must support mark/reset");    }    int maxByteCount = root.getMaxDepth();    inputStream.mark(maxByteCount);    byte[] bytes = new byte[maxByteCount];    int bytesRead = inputStream.read(bytes);    if (bytesRead == -1) {        throw new IOException("Stream ended before file's magic number could be determined.");    }    inputStream.reset();        return root.find(bytes);}
public static FileType pdfbox_f7808_0(final byte[] fileBytes) throws IOException
{    return root.find(fileBytes);}
public static String pdfbox_f7809_0(byte b)
{    char[] chars = new char[] { HEX_CHARS[getHighNibble(b)], HEX_CHARS[getLowNibble(b)] };    return new String(chars);}
public static String pdfbox_f7810_0(byte[] bytes)
{    StringBuilder string = new StringBuilder(bytes.length * 2);    for (byte b : bytes) {        string.append(HEX_CHARS[getHighNibble(b)]).append(HEX_CHARS[getLowNibble(b)]);    }    return string.toString();}
public static byte[] pdfbox_f7811_0(byte b)
{    return new byte[] { HEX_BYTES[getHighNibble(b)], HEX_BYTES[getLowNibble(b)] };}
public static byte[] pdfbox_f7812_0(byte[] bytes)
{    byte[] asciiBytes = new byte[bytes.length * 2];    for (int i = 0; i < bytes.length; i++) {        asciiBytes[i * 2] = HEX_BYTES[getHighNibble(bytes[i])];        asciiBytes[i * 2 + 1] = HEX_BYTES[getLowNibble(bytes[i])];    }    return asciiBytes;}
public static char[] pdfbox_f7813_0(short num)
{    char[] hex = new char[4];    hex[0] = HEX_CHARS[(num >> 12) & 0x0F];    hex[1] = HEX_CHARS[(num >> 8) & 0x0F];    hex[2] = HEX_CHARS[(num >> 4) & 0x0F];    hex[3] = HEX_CHARS[num & 0x0F];    return hex;}
public static char[] pdfbox_f7814_0(String text)
{            char[] hex = new char[text.length() * 4];    for (int stringIdx = 0, charIdx = 0; stringIdx < text.length(); stringIdx++) {        char c = text.charAt(stringIdx);        hex[charIdx++] = HEX_CHARS[(c >> 12) & 0x0F];        hex[charIdx++] = HEX_CHARS[(c >> 8) & 0x0F];        hex[charIdx++] = HEX_CHARS[(c >> 4) & 0x0F];        hex[charIdx++] = HEX_CHARS[c & 0x0F];    }    return hex;}
public static void pdfbox_f7815_0(byte b, OutputStream output) throws IOException
{    output.write(HEX_BYTES[getHighNibble(b)]);    output.write(HEX_BYTES[getLowNibble(b)]);}
public static void pdfbox_f7816_0(byte[] bytes, OutputStream output) throws IOException
{    for (byte b : bytes) {        writeHexByte(b, output);    }}
private static int pdfbox_f7817_0(byte b)
{    return (b & 0xF0) >> 4;}
private static int pdfbox_f7818_0(byte b)
{    return b & 0x0F;}
public static byte[] pdfbox_f7819_0(String base64Value)
{    return Base64.getDecoder().decode(base64Value.replaceAll("\\s", ""));}
public static byte[] pdfbox_f7820_1(String s) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    int i = 0;    while (i < s.length() - 1) {        if (s.charAt(i) == '\n' || s.charAt(i) == '\r') {            ++i;        } else {            String hexByte = s.substring(i, i + 2);            try {                                baos.write(Integer.parseInt(hexByte, 16));            } catch (NumberFormatException ex) {                                break;            }            i += 2;        }    }    return baos.toByteArray();}
public static Matrix pdfbox_f7821_0(COSBase base)
{    if (!(base instanceof COSArray)) {        return new Matrix();    }    COSArray array = (COSArray) base;    if (array.size() < 6) {        return new Matrix();    }    for (int i = 0; i < 6; ++i) {        if (!(array.getObject(i) instanceof COSNumber)) {            return new Matrix();        }    }    return new Matrix(array);}
public void pdfbox_f7822_0()
{    System.arraycopy(DEFAULT_SINGLE, 0, single, 0, DEFAULT_SINGLE.length);}
public AffineTransform pdfbox_f7823_0()
{    return new AffineTransform(    single[0],     single[1],     single[3],     single[4], single[6],     single[7]);}
public void pdfbox_f7824_0(AffineTransform af)
{    single[0] = (float) af.getScaleX();    single[1] = (float) af.getShearY();    single[3] = (float) af.getShearX();    single[4] = (float) af.getScaleY();    single[6] = (float) af.getTranslateX();    single[7] = (float) af.getTranslateY();}
public float pdfbox_f7825_0(int row, int column)
{    return single[row * 3 + column];}
public void pdfbox_f7826_0(int row, int column, float value)
{    single[row * 3 + column] = value;}
public float[][] pdfbox_f7827_0()
{    float[][] retval = new float[3][3];    retval[0][0] = single[0];    retval[0][1] = single[1];    retval[0][2] = single[2];    retval[1][0] = single[3];    retval[1][1] = single[4];    retval[1][2] = single[5];    retval[2][0] = single[6];    retval[2][1] = single[7];    retval[2][2] = single[8];    return retval;}
public double[][] pdfbox_f7828_0()
{    double[][] retval = new double[3][3];    retval[0][0] = single[0];    retval[0][1] = single[1];    retval[0][2] = single[2];    retval[1][0] = single[3];    retval[1][1] = single[4];    retval[1][2] = single[5];    retval[2][0] = single[6];    retval[2][1] = single[7];    retval[2][2] = single[8];    return retval;}
public void pdfbox_f7829_0(Matrix matrix)
{    matrix.multiply(this, this);}
public void pdfbox_f7830_0(Vector vector)
{    Matrix m = Matrix.getTranslateInstance(vector.getX(), vector.getY());    concatenate(m);}
public void pdfbox_f7831_0(float tx, float ty)
{    Matrix m = Matrix.getTranslateInstance(tx, ty);    concatenate(m);}
public void pdfbox_f7832_0(float sx, float sy)
{    Matrix m = Matrix.getScaleInstance(sx, sy);    concatenate(m);}
public void pdfbox_f7833_0(double theta)
{    Matrix m = Matrix.getRotateInstance(theta, 0, 0);    concatenate(m);}
public Matrix pdfbox_f7834_0(Matrix b)
{    return this.multiply(b, new Matrix());}
public Matrix pdfbox_f7835_0(Matrix other, Matrix result)
{    if (result == null) {        result = new Matrix();    }    if (other != null && other.single != null) {                float[] thisOperand = this.single;        float[] otherOperand = other.single;        if (this == result) {            final float[] thisOrigVals = new float[this.single.length];            System.arraycopy(this.single, 0, thisOrigVals, 0, this.single.length);            thisOperand = thisOrigVals;        }        if (other == result) {            final float[] otherOrigVals = new float[other.single.length];            System.arraycopy(other.single, 0, otherOrigVals, 0, other.single.length);            otherOperand = otherOrigVals;        }        result.single[0] = thisOperand[0] * otherOperand[0] + thisOperand[1] * otherOperand[3] + thisOperand[2] * otherOperand[6];        result.single[1] = thisOperand[0] * otherOperand[1] + thisOperand[1] * otherOperand[4] + thisOperand[2] * otherOperand[7];        result.single[2] = thisOperand[0] * otherOperand[2] + thisOperand[1] * otherOperand[5] + thisOperand[2] * otherOperand[8];        result.single[3] = thisOperand[3] * otherOperand[0] + thisOperand[4] * otherOperand[3] + thisOperand[5] * otherOperand[6];        result.single[4] = thisOperand[3] * otherOperand[1] + thisOperand[4] * otherOperand[4] + thisOperand[5] * otherOperand[7];        result.single[5] = thisOperand[3] * otherOperand[2] + thisOperand[4] * otherOperand[5] + thisOperand[5] * otherOperand[8];        result.single[6] = thisOperand[6] * otherOperand[0] + thisOperand[7] * otherOperand[3] + thisOperand[8] * otherOperand[6];        result.single[7] = thisOperand[6] * otherOperand[1] + thisOperand[7] * otherOperand[4] + thisOperand[8] * otherOperand[7];        result.single[8] = thisOperand[6] * otherOperand[2] + thisOperand[7] * otherOperand[5] + thisOperand[8] * otherOperand[8];    }    return result;}
public void pdfbox_f7836_0(Point2D point)
{    float x = (float) point.getX();    float y = (float) point.getY();    float a = single[0];    float b = single[1];    float c = single[3];    float d = single[4];    float e = single[6];    float f = single[7];    point.setLocation(x * a + y * c + e, x * b + y * d + f);}
public Point2D.Float pdfbox_f7837_0(float x, float y)
{    float a = single[0];    float b = single[1];    float c = single[3];    float d = single[4];    float e = single[6];    float f = single[7];    return new Point2D.Float(x * a + y * c + e, x * b + y * d + f);}
public Vector pdfbox_f7838_0(Vector vector)
{    float a = single[0];    float b = single[1];    float c = single[3];    float d = single[4];    float e = single[6];    float f = single[7];    float x = vector.getX();    float y = vector.getY();    return new Vector(x * a + y * c + e, x * b + y * d + f);}
public Matrix pdfbox_f7839_0()
{    Matrix matrix = new Matrix();    matrix.single[0] = this.single[0];    matrix.single[4] = this.single[4];    return matrix;}
public static Matrix pdfbox_f7840_0(float sx, float sy)
{    Matrix matrix = new Matrix();    matrix.single[0] = sx;    matrix.single[4] = sy;    return matrix;}
public Matrix pdfbox_f7841_0()
{    Matrix matrix = new Matrix();    matrix.single[6] = this.single[6];    matrix.single[7] = this.single[7];    return matrix;}
public static Matrix pdfbox_f7842_0(float tx, float ty)
{    return getTranslateInstance(tx, ty);}
public static Matrix pdfbox_f7843_0(float tx, float ty)
{    Matrix matrix = new Matrix();    matrix.single[6] = tx;    matrix.single[7] = ty;    return matrix;}
public static Matrix pdfbox_f7844_0(double theta, float tx, float ty)
{    float cosTheta = (float) Math.cos(theta);    float sinTheta = (float) Math.sin(theta);    Matrix matrix = new Matrix();    matrix.single[0] = cosTheta;    matrix.single[1] = sinTheta;    matrix.single[3] = -sinTheta;    matrix.single[4] = cosTheta;    matrix.single[6] = tx;    matrix.single[7] = ty;    return matrix;}
public static Matrix pdfbox_f7845_0(Matrix a, Matrix b)
{    Matrix copy = a.clone();    copy.concatenate(b);    return copy;}
public Matrix pdfbox_f7846_0()
{    Matrix clone = new Matrix();    System.arraycopy(single, 0, clone.single, 0, 9);    return clone;}
public float pdfbox_f7847_0()
{    float xScale = single[0];    /**     * BM: if the trm is rotated, the calculation is a little more complicated     *     * The rotation matrix multiplied with the scaling matrix is:     * (   x   0   0)    ( cos  sin  0)    ( x*cos x*sin   0)     * (   0   y   0) *  (-sin  cos  0)  = (-y*sin y*cos   0)     * (   0   0   1)    (   0    0  1)    (     0     0   1)     *     * So, if you want to deduce x from the matrix you take     * M(0,0) = x*cos and M(0,1) = x*sin and use the theorem of Pythagoras     *     * sqrt(M(0,0)^2+M(0,1)^2) =     * sqrt(x2*cos2+x2*sin2) =     * sqrt(x2*(cos2+sin2)) = <- here is the trick cos2+sin2 is one     * sqrt(x2) =     * abs(x)     */    if (!(Float.compare(single[1], 0.0f) == 0 && Float.compare(single[3], 0.0f) == 0)) {        xScale = (float) Math.sqrt(Math.pow(single[0], 2) + Math.pow(single[1], 2));    }    return xScale;}
public float pdfbox_f7848_0()
{    float yScale = single[4];    if (!(Float.compare(single[1], 0.0f) == 0 && Float.compare(single[3], 0.0f) == 0)) {        yScale = (float) Math.sqrt(Math.pow(single[3], 2) + Math.pow(single[4], 2));    }    return yScale;}
public float pdfbox_f7849_0()
{    return single[0];}
public float pdfbox_f7850_0()
{    return single[1];}
public float pdfbox_f7851_0()
{    return single[3];}
public float pdfbox_f7852_0()
{    return single[4];}
public float pdfbox_f7853_0()
{    return single[6];}
public float pdfbox_f7854_0()
{    return single[7];}
public float pdfbox_f7855_0()
{    return single[6];}
public float pdfbox_f7856_0()
{    return single[7];}
public COSArray pdfbox_f7857_0()
{    COSArray array = new COSArray();    array.add(new COSFloat(single[0]));    array.add(new COSFloat(single[1]));    array.add(new COSFloat(single[3]));    array.add(new COSFloat(single[4]));    array.add(new COSFloat(single[6]));    array.add(new COSFloat(single[7]));    return array;}
public String pdfbox_f7858_0()
{    return "[" + single[0] + "," + single[1] + "," + single[3] + "," + single[4] + "," + single[6] + "," + single[7] + "]";}
public int pdfbox_f7859_0()
{    return Arrays.hashCode(single);}
public boolean pdfbox_f7860_0(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    return Arrays.equals(this.single, ((Matrix) obj).single);}
public static int pdfbox_f7861_0(float value, int maxFractionDigits, byte[] asciiBuffer)
{    if (Float.isNaN(value) || Float.isInfinite(value) || value > Long.MAX_VALUE || value <= Long.MIN_VALUE || maxFractionDigits > MAX_FRACTION_DIGITS) {        return -1;    }    int offset = 0;    long integerPart = (long) value;        if (value < 0) {        asciiBuffer[offset++] = '-';        integerPart = -integerPart;    }        long fractionPart = (long) ((Math.abs((double) value) - integerPart) * POWER_OF_TENS[maxFractionDigits] + 0.5d);        if (fractionPart >= POWER_OF_TENS[maxFractionDigits]) {        integerPart++;        fractionPart -= POWER_OF_TENS[maxFractionDigits];    }        offset = formatPositiveNumber(integerPart, getExponent(integerPart), false, asciiBuffer, offset);    if (fractionPart > 0 && maxFractionDigits > 0) {        asciiBuffer[offset++] = '.';        offset = formatPositiveNumber(fractionPart, maxFractionDigits - 1, true, asciiBuffer, offset);    }    return offset;}
private static int pdfbox_f7862_0(long number, int exp, boolean omitTrailingZeros, byte[] asciiBuffer, int startOffset)
{    int offset = startOffset;    long remaining = number;    while (remaining > Integer.MAX_VALUE && (!omitTrailingZeros || remaining > 0)) {        long digit = remaining / POWER_OF_TENS[exp];        remaining -= (digit * POWER_OF_TENS[exp]);        asciiBuffer[offset++] = (byte) ('0' + digit);        exp--;    }        int remainingInt = (int) remaining;    while (exp >= 0 && (!omitTrailingZeros || remainingInt > 0)) {        int digit = remainingInt / POWER_OF_TENS_INT[exp];        remainingInt -= (digit * POWER_OF_TENS_INT[exp]);        asciiBuffer[offset++] = (byte) ('0' + digit);        exp--;    }    return offset;}
private static int pdfbox_f7863_0(long number)
{    for (int exp = 0; exp < (POWER_OF_TENS.length - 1); exp++) {        if (number < POWER_OF_TENS[exp + 1]) {            return exp;        }    }    return POWER_OF_TENS.length - 1;}
public static void pdfbox_f7864_0(List<T> list, Comparator<T> cmp)
{    int size = list.size();    if (size < 2) {        return;    }    quicksort(list, cmp);}
public static void pdfbox_f7865_0(List<T> list)
{    sort(list, (Comparator<T>) OBJCOMP);}
private static void pdfbox_f7866_0(List<T> list, Comparator<T> cmp)
{    Deque<Integer> stack = new ArrayDeque<>();    stack.push(0);    stack.push(list.size());    while (!stack.isEmpty()) {        int right = stack.pop();        int left = stack.pop();        if (right - left < 2) {            continue;        }        int p = left + ((right - left) / 2);        p = partition(list, cmp, p, left, right);        stack.push(p + 1);        stack.push(right);        stack.push(left);        stack.push(p);    }}
private static int pdfbox_f7867_0(List<T> list, Comparator<T> cmp, int p, int start, int end)
{    int l = start;    int h = end - 2;    T piv = list.get(p);    swap(list, p, end - 1);    while (l < h) {        if (cmp.compare(list.get(l), piv) <= 0) {            l++;        } else if (cmp.compare(piv, list.get(h)) <= 0) {            h--;        } else {            swap(list, l, h);        }    }    int idx = h;    if (cmp.compare(list.get(h), piv) < 0) {        idx++;    }    swap(list, end - 1, idx);    return idx;}
private static void pdfbox_f7868_0(List<T> list, int i, int j)
{    T tmp = list.get(i);    list.set(i, list.get(j));    list.set(j, tmp);}
private int pdfbox_f7869_0(Object key)
{    if (isEmpty() || (key == null)) {        return -1;    }    for (int aIdx = 0; aIdx < mapArr.length; aIdx += 2) {        if (key.equals(mapArr[aIdx])) {            return aIdx;        }    }    return -1;}
private int pdfbox_f7870_0(Object value)
{    if (isEmpty() || (value == null)) {        return -1;    }    for (int aIdx = 1; aIdx < mapArr.length; aIdx += 2) {        if (value.equals(mapArr[aIdx])) {            return aIdx;        }    }    return -1;}
public int pdfbox_f7871_0()
{    return mapArr == null ? 0 : mapArr.length >> 1;}
public boolean pdfbox_f7872_0()
{    return (mapArr == null) || (mapArr.length == 0);}
public boolean pdfbox_f7873_0(Object key)
{    return findKey(key) >= 0;}
public boolean pdfbox_f7874_0(Object value)
{    return findValue(value) >= 0;}
public V pdfbox_f7875_0(Object key)
{    int kIdx = findKey(key);    return kIdx < 0 ? null : (V) mapArr[kIdx + 1];}
public V pdfbox_f7876_0(K key, V value)
{    if ((key == null) || (value == null)) {        throw new NullPointerException("Key or value must not be null.");    }    if (mapArr == null) {        mapArr = new Object[] { key, value };        return null;    } else {        int kIdx = findKey(key);        if (kIdx < 0) {                        int oldLen = mapArr.length;            Object[] newMapArr = new Object[oldLen + 2];            System.arraycopy(mapArr, 0, newMapArr, 0, oldLen);            newMapArr[oldLen] = key;            newMapArr[oldLen + 1] = value;            mapArr = newMapArr;            return null;        } else {                        @SuppressWarnings("unchecked")            V oldValue = (V) mapArr[kIdx + 1];            mapArr[kIdx + 1] = value;            return oldValue;        }    }}
public V pdfbox_f7877_0(Object key)
{    int kIdx = findKey(key);    if (kIdx < 0) {                return null;    }    @SuppressWarnings("unchecked")    V oldValue = (V) mapArr[kIdx + 1];    int oldLen = mapArr.length;    if (oldLen == 2) {                mapArr = null;    } else {        Object[] newMapArr = new Object[oldLen - 2];        System.arraycopy(mapArr, 0, newMapArr, 0, kIdx);        System.arraycopy(mapArr, kIdx + 2, newMapArr, kIdx, oldLen - kIdx - 2);        mapArr = newMapArr;    }    return oldValue;}
public final void pdfbox_f7878_0(Map<? extends K, ? extends V> otherMap)
{    if ((mapArr == null) || (mapArr.length == 0)) {                mapArr = new Object[otherMap.size() << 1];        int aIdx = 0;        for (Entry<? extends K, ? extends V> entry : otherMap.entrySet()) {            if ((entry.getKey() == null) || (entry.getValue() == null)) {                throw new NullPointerException("Key or value must not be null.");            }            mapArr[aIdx++] = entry.getKey();            mapArr[aIdx++] = entry.getValue();        }    } else {        int oldLen = mapArr.length;                        Object[] newMapArr = new Object[oldLen + (otherMap.size() << 1)];        System.arraycopy(mapArr, 0, newMapArr, 0, oldLen);        int newIdx = oldLen;        for (Entry<? extends K, ? extends V> entry : otherMap.entrySet()) {            if ((entry.getKey() == null) || (entry.getValue() == null)) {                throw new NullPointerException("Key or value must not be null.");            }            int existKeyIdx = findKey(entry.getKey());            if (existKeyIdx >= 0) {                                newMapArr[existKeyIdx + 1] = entry.getValue();            } else {                                newMapArr[newIdx++] = entry.getKey();                newMapArr[newIdx++] = entry.getValue();            }        }        if (newIdx < newMapArr.length) {            Object[] reducedMapArr = new Object[newIdx];            System.arraycopy(newMapArr, 0, reducedMapArr, 0, newIdx);            newMapArr = reducedMapArr;        }        mapArr = newMapArr;    }}
public void pdfbox_f7879_0()
{    mapArr = null;}
public Set<K> pdfbox_f7880_0()
{    if (isEmpty()) {        return Collections.emptySet();    }    Set<K> keys = new LinkedHashSet<>();    for (int kIdx = 0; kIdx < mapArr.length; kIdx += 2) {        keys.add((K) mapArr[kIdx]);    }    return Collections.unmodifiableSet(keys);}
public Collection<V> pdfbox_f7881_0()
{    if (isEmpty()) {        return Collections.emptySet();    }    List<V> values = new ArrayList<>(mapArr.length >> 1);    for (int vIdx = 1; vIdx < mapArr.length; vIdx += 2) {        values.add((V) mapArr[vIdx]);    }    return Collections.unmodifiableList(values);}
public K pdfbox_f7882_0()
{    return (K) mapArr[keyIdx];}
public V pdfbox_f7883_0()
{    return (V) mapArr[keyIdx + 1];}
public V pdfbox_f7884_0(V value)
{    if (value == null) {        throw new NullPointerException("Key or value must not be null.");    }    V oldValue = getValue();    mapArr[keyIdx + 1] = value;    return oldValue;}
public int pdfbox_f7885_0()
{    return getKey().hashCode();}
public boolean pdfbox_f7886_0(Object obj)
{    if (!(obj instanceof SmallMap.SmallMapEntry)) {        return false;    }    @SuppressWarnings("unchecked")    SmallMapEntry other = (SmallMapEntry) obj;    return getKey().equals(other.getKey()) && getValue().equals(other.getValue());}
public Set<java.util.Map.Entry<K, V>> pdfbox_f7887_0()
{    if (isEmpty()) {        return Collections.emptySet();    }    Set<java.util.Map.Entry<K, V>> entries = new LinkedHashSet<>();    for (int kIdx = 0; kIdx < mapArr.length; kIdx += 2) {        entries.add(new SmallMapEntry(kIdx));    }    return Collections.unmodifiableSet(entries);}
public float pdfbox_f7888_0()
{    return x;}
public float pdfbox_f7889_0()
{    return y;}
public Vector pdfbox_f7890_0(float sxy)
{    return new Vector(x * sxy, y * sxy);}
public String pdfbox_f7891_0()
{    return "(" + x + ", " + y + ")";}
public static String pdfbox_f7892_1()
{    try (InputStream is = Version.class.getResourceAsStream(PDFBOX_VERSION_PROPERTIES)) {        if (is == null) {            return null;        }        Properties properties = new Properties();        properties.load(is);        return properties.getProperty("pdfbox.version", null);    } catch (IOException io) {                return null;    }}
public static Document pdfbox_f7893_0(InputStream is) throws IOException
{    return parse(is, false);}
public static Document pdfbox_f7894_0(InputStream is, boolean nsAware) throws IOException
{    try {        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();        builderFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);        builderFactory.setFeature("http://xml.org/sax/features/external-general-entities", false);        builderFactory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);        builderFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);        builderFactory.setXIncludeAware(false);        builderFactory.setExpandEntityReferences(false);        builderFactory.setNamespaceAware(nsAware);        DocumentBuilder builder = builderFactory.newDocumentBuilder();        return builder.parse(is);    } catch (FactoryConfigurationError | ParserConfigurationException | SAXException e) {        throw new IOException(e.getMessage(), e);    }}
public static String pdfbox_f7895_0(Element node)
{    StringBuilder sb = new StringBuilder();    NodeList children = node.getChildNodes();    int numNodes = children.getLength();    for (int i = 0; i < numNodes; i++) {        Node next = children.item(i);        if (next instanceof Text) {            sb.append(next.getNodeValue());        }    }    return sb.toString();}
public void pdfbox_f7896_0()
{        final COSObjectKey objectUnderTest = new COSObjectKey(0L, 0);    final COSObjectKey other = new COSObjectKey(0L, 0);        final int retval = objectUnderTest.compareTo(other);        Assert.assertEquals(0, retval);}
public void pdfbox_f7897_0()
{        final COSObjectKey objectUnderTest = new COSObjectKey(0L, 0);    final COSObjectKey other = new COSObjectKey(-9_223_372_036_854_775_808L, 0);        final int retval = objectUnderTest.compareTo(other);        Assert.assertEquals(1, retval);}
public void pdfbox_f7898_0()
{    for (String deviation : deviations) {        COSString cosString = new COSString(deviation);        assertEquals(cosString.getString(), deviation);    }}
public void pdfbox_f7899_0() throws IOException
{    for (int i = 0; i < 256; i++) {        String hex = String.format("FEFF%04X", i);        COSString cs1 = COSString.parseHex(hex);        COSString cs2 = new COSString(cs1.getString());        assertEquals(cs1, cs2);    }}
public void pdfbox_f7900_0()
{    assertEquals(testCOSBase, testCOSBase.getCOSObject());}
public void pdfbox_f7901_0()
{    testCOSBase.setDirect(true);    assertTrue(testCOSBase.isDirect());    testCOSBase.setDirect(false);    assertFalse(testCOSBase.isDirect());}
protected void pdfbox_f7902_0(byte[] byteArr1, byte[] byteArr2)
{    assertEquals(byteArr1.length, byteArr1.length);    for (int i = 0; i < byteArr1.length; i++) {        assertEquals(byteArr1[i], byteArr2[i]);    }}
public void pdfbox_f7903_0()
{    try {        testCOSBase = COSNumber.get("1.1");    } catch (IOException e) {        fail("Failed to create a COSNumber in setUp()");    }}
public void pdfbox_f7904_0(int low, int high, int step)
{    this.low = low;    this.high = high;    this.step = step;}
public void pdfbox_f7905_0()
{        loop(123456);        loop(System.currentTimeMillis());}
private void pdfbox_f7906_0(long seed)
{    Random rnd = new Random(seed);    for (int i = low; i < high; i += step) {        float num = i * rnd.nextFloat();        try {            runTest(num);        } catch (AssertionError a) {            fail("num = " + num + ", seed = " + seed);        }    }}
public void pdfbox_f7907_0()
{    new BaseTester() {        @Override        void runTest(float num) {            COSFloat test1 = new COSFloat(num);            COSFloat test2 = new COSFloat(num);            COSFloat test3 = new COSFloat(num);                        assertTrue(test1.equals(test1));                        assertTrue(test2.equals(test3));            assertTrue(test1.equals(test2));                        assertTrue(test1.equals(test2));            assertTrue(test2.equals(test3));            assertTrue(test1.equals(test3));            float nf = Float.intBitsToFloat(Float.floatToIntBits(num) + 1);            COSFloat test4 = new COSFloat(nf);            assertFalse(test4.equals(test1));        }    }.runTests();}
 void pdfbox_f7908_0(float num)
{    COSFloat test1 = new COSFloat(num);    COSFloat test2 = new COSFloat(num);    COSFloat test3 = new COSFloat(num);        assertTrue(test1.equals(test1));        assertTrue(test2.equals(test3));    assertTrue(test1.equals(test2));        assertTrue(test1.equals(test2));    assertTrue(test2.equals(test3));    assertTrue(test1.equals(test3));    float nf = Float.intBitsToFloat(Float.floatToIntBits(num) + 1);    COSFloat test4 = new COSFloat(nf);    assertFalse(test4.equals(test1));}
 void pdfbox_f7909_0(float num)
{    COSFloat test1 = new COSFloat(num);    COSFloat test2 = new COSFloat(num);    assertEquals(test1.hashCode(), test2.hashCode());    float nf = Float.intBitsToFloat(Float.floatToIntBits(num) + 1);    COSFloat test3 = new COSFloat(nf);    assertFalse(test3.hashCode() == test1.hashCode());}
public void pdfbox_f7910_0()
{    new HashCodeTester().runTests();}
 void pdfbox_f7911_0(float num)
{    COSFloat testFloat = new COSFloat(num);    assertEquals(num, testFloat.floatValue());}
public void pdfbox_f7912_0()
{    new FloatValueTester().runTests();}
 void pdfbox_f7913_0(float num)
{    COSFloat testFloat = new COSFloat(num);            assertEquals(Float.toString(num), Double.toString(testFloat.doubleValue()));}
public void pdfbox_f7914_0()
{    new DoubleValueTester().runTests();}
 void pdfbox_f7915_0(float num)
{    COSFloat testFloat = new COSFloat(num);    assertEquals((int) num, testFloat.intValue());}
public void pdfbox_f7916_0()
{    new IntValueTester().runTests();}
 void pdfbox_f7917_0(float num)
{    COSFloat testFloat = new COSFloat(num);    assertEquals((long) num, testFloat.longValue());}
public void pdfbox_f7918_0()
{    new LongValueTester().runTests();}
 void pdfbox_f7919_0(float num)
{    try {        COSFloat cosFloat = new COSFloat(num);        cosFloat.accept(visitor);        assertEquals(floatToString(cosFloat.floatValue()), outStream.toString("ISO-8859-1"));        testByteArrays(floatToString(num).getBytes("ISO-8859-1"), outStream.toByteArray());        outStream.reset();    } catch (IOException e) {        fail("Failed to write " + num + " exception: " + e.getMessage());    }}
public void pdfbox_f7920_0()
{    new AcceptTester().runTests();}
 void pdfbox_f7921_0(float num)
{    try {        COSFloat cosFloat = new COSFloat(num);        cosFloat.writePDF(outStream);        assertEquals(floatToString(cosFloat.floatValue()), outStream.toString("ISO-8859-1"));        assertEquals(floatToString(num), outStream.toString("ISO-8859-1"));        testByteArrays(floatToString(num).getBytes("ISO-8859-1"), outStream.toByteArray());        outStream.reset();    } catch (IOException e) {        fail("Failed to write " + num + " exception: " + e.getMessage());    }}
public void pdfbox_f7922_0()
{    WritePDFTester writePDFTester = new WritePDFTester();    writePDFTester.runTests();        writePDFTester.runTest(0.000000000000000000000000000000001f);}
public void pdfbox_f7923_0() throws IOException
{        COSFloat cosFloat = new COSFloat("--16.33");    assertEquals(-16.33f, cosFloat.floatValue());}
private String pdfbox_f7924_0(float value)
{        return removeTrailingNull(new BigDecimal(String.valueOf(value)).toPlainString());}
private String pdfbox_f7925_0(String value)
{        if (value.indexOf('.') > -1 && !value.endsWith(".0")) {        while (value.endsWith("0") && !value.endsWith(".0")) {            value = value.substring(0, value.length() - 1);        }    }    return value;}
public static Test pdfbox_f7926_0()
{    return new TestSuite(TestCOSFloat.class);}
public void pdfbox_f7927_0()
{    try {        testCOSBase = COSNumber.get("0");    } catch (IOException e) {        fail("Failed to create a COSNumber in setUp()");    }}
public void pdfbox_f7928_0()
{        for (int i = -1000; i < 3000; i += 200) {        COSInteger test1 = COSInteger.get(i);        COSInteger test2 = COSInteger.get(i);        COSInteger test3 = COSInteger.get(i);                assertTrue(test1.equals(test1));                assertTrue(test2.equals(test1));        assertTrue(test1.equals(test2));                assertTrue(test1.equals(test2));        assertTrue(test2.equals(test3));        assertTrue(test1.equals(test3));                assertFalse(test1 == null);        assertFalse(test2 == null);        assertFalse(test3 == null);        COSInteger test4 = COSInteger.get(i + 1);        assertFalse(test4.equals(test1));    }}
public void pdfbox_f7929_0()
{    for (int i = -1000; i < 3000; i += 200) {        COSInteger test1 = COSInteger.get(i);        COSInteger test2 = COSInteger.get(i);        assertEquals(test1.hashCode(), test2.hashCode());        COSInteger test3 = COSInteger.get(i + 1);        assertFalse(test3.hashCode() == test1.hashCode());    }}
public void pdfbox_f7930_0()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals((float) i, COSInteger.get(i).floatValue());    }}
public void pdfbox_f7931_0()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals((double) i, COSInteger.get(i).doubleValue());    }}
public void pdfbox_f7932_0()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals(i, COSInteger.get(i).intValue());    }}
public void pdfbox_f7933_0()
{    for (int i = -1000; i < 3000; i += 200) {        assertEquals((long) i, COSInteger.get(i).longValue());    }}
public void pdfbox_f7934_0()
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    COSWriter visitor = new COSWriter(outStream);    int index = 0;    try {        for (int i = -1000; i < 3000; i += 200) {            index = i;            COSInteger cosInt = COSInteger.get(i);            cosInt.accept(visitor);            testByteArrays(String.valueOf(i).getBytes("ISO-8859-1"), outStream.toByteArray());            outStream.reset();        }    } catch (Exception e) {        fail("Failed to write " + index + " exception: " + e.getMessage());    }}
public void pdfbox_f7935_0()
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    int index = 0;    try {        for (int i = -1000; i < 3000; i += 200) {            index = i;            COSInteger cosInt = COSInteger.get(i);            cosInt.writePDF(outStream);            testByteArrays(String.valueOf(i).getBytes("ISO-8859-1"), outStream.toByteArray());            outStream.reset();        }    } catch (Exception e) {        fail("Failed to write " + index + " exception: " + e.getMessage());    }}
public static Test pdfbox_f7936_0()
{    return new TestSuite(TestCOSInteger.class);}
public void pdfbox_f7937_0() throws IOException
{    String special = "!";    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        document.getDocumentCatalog().getCOSObject().setString(COSName.getPDFName(special), special);        document.save(baos);    }    try (PDDocument document = PDDocument.load(baos.toByteArray())) {        COSDictionary catalogDict = document.getDocumentCatalog().getCOSObject();        Assert.assertTrue(catalogDict.containsKey(special));        Assert.assertEquals(special, catalogDict.getString(special));    }}
public void pdfbox_f7938_0()
{    try {                assertEquals(COSInteger.ZERO, COSNumber.get("0"));        assertEquals(COSInteger.ONE, COSNumber.get("1"));        assertEquals(COSInteger.TWO, COSNumber.get("2"));        assertEquals(COSInteger.THREE, COSNumber.get("3"));                assertEquals(COSInteger.get(100), COSNumber.get("100"));        assertEquals(COSInteger.get(256), COSNumber.get("256"));        assertEquals(COSInteger.get(-1000), COSNumber.get("-1000"));        assertEquals(COSInteger.get(2000), COSNumber.get("+2000"));                assertEquals(new COSFloat(1.1f), COSNumber.get("1.1"));        assertEquals(new COSFloat(100f), COSNumber.get("100.0"));        assertEquals(new COSFloat(-100.001f), COSNumber.get("-100.001"));                        assertNotNull(COSNumber.get("-2e-006"));        assertNotNull(COSNumber.get("-8e+05"));        try {            assertEquals("Null Value...", COSNumber.get(null));            fail("Failed to throw a NullPointerException");        } catch (NullPointerException e) {                }    } catch (IOException e) {        fail("Failed to convert a number " + e.getMessage());    }}
public void pdfbox_f7939_0() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    COSStream stream = createStream(testString, null);    validateEncoded(stream, testString);}
public void pdfbox_f7940_0() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    COSStream stream = createStream(testString, null);    validateDecoded(stream, testString);}
public void pdfbox_f7941_0() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    COSStream stream = createStream(testString, COSName.FLATE_DECODE);    validateEncoded(stream, testStringEncoded);}
public void pdfbox_f7942_0() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    COSStream stream = new COSStream();    try (OutputStream output = stream.createRawOutputStream()) {        output.write(testStringEncoded);    }    stream.setItem(COSName.FILTER, COSName.FLATE_DECODE);    validateDecoded(stream, testString);}
public void pdfbox_f7943_0() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    testStringEncoded = encodeData(testStringEncoded, COSName.ASCII85_DECODE);    COSArray filters = new COSArray();    filters.add(COSName.ASCII85_DECODE);    filters.add(COSName.FLATE_DECODE);    COSStream stream = createStream(testString, filters);    validateEncoded(stream, testStringEncoded);}
public void pdfbox_f7944_0() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    testStringEncoded = encodeData(testStringEncoded, COSName.ASCII85_DECODE);    COSStream stream = new COSStream();    COSArray filters = new COSArray();    filters.add(COSName.ASCII85_DECODE);    filters.add(COSName.FLATE_DECODE);    stream.setItem(COSName.FILTER, filters);    try (OutputStream output = stream.createRawOutputStream()) {        output.write(testStringEncoded);    }    validateDecoded(stream, testString);}
public void pdfbox_f7945_0() throws IOException
{    byte[] testString = "This is a test string to be used as input for TestCOSStream".getBytes("ASCII");    byte[] testStringEncoded = encodeData(testString, COSName.FLATE_DECODE);    COSStream stream = new COSStream();    OutputStream output = stream.createOutputStream(COSName.FLATE_DECODE);    output.write(testString);    output.close();    output.close();    validateEncoded(stream, testStringEncoded);}
private byte[] pdfbox_f7946_0(byte[] original, COSName filter) throws IOException
{    Filter encodingFilter = FilterFactory.INSTANCE.getFilter(filter);    ByteArrayOutputStream encoded = new ByteArrayOutputStream();    encodingFilter.encode(new ByteArrayInputStream(original), encoded, new COSDictionary(), 0);    return encoded.toByteArray();}
private COSStream pdfbox_f7947_0(byte[] testString, COSBase filters) throws IOException
{    COSStream stream = new COSStream();    try (OutputStream output = stream.createOutputStream(filters)) {        output.write(testString);    }    return stream;}
private void pdfbox_f7948_0(COSStream stream, byte[] expected) throws IOException
{    byte[] decoded = IOUtils.toByteArray(stream.createRawInputStream());    stream.close();    assertTrue("Encoded data doesn't match input", Arrays.equals(expected, decoded));}
private void pdfbox_f7949_0(COSStream stream, byte[] expected) throws IOException
{    byte[] encoded = IOUtils.toByteArray(stream.createInputStream());    stream.close();    assertTrue("Decoded data doesn't match input", Arrays.equals(expected, encoded));}
public static Test pdfbox_f7950_0()
{    return new TestSuite(TestCOSString.class);}
public void pdfbox_f7951_0()
{    testCOSBase = new COSString("test cos string");}
public static void pdfbox_f7952_0(String[] args)
{    String[] arg = { TestCOSString.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f7953_0()
{    String inputString = "Test with a text and a few numbers 1, 2 and 3";    String pdfHex = "<" + createHex(inputString) + ">";    COSString cosStr = new COSString(inputString);    cosStr.setForceHexForm(true);    writePDFTests(pdfHex, cosStr);    COSString escStr = new COSString(ESC_CHAR_STRING);    writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", escStr);    escStr.setForceHexForm(true);        writePDFTests("<" + createHex(ESC_CHAR_STRING) + ">", escStr);}
private void pdfbox_f7954_0(String expected, COSString testSubj)
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    try {        COSWriter.writeString(testSubj, outStream);    } catch (IOException e) {        fail("IOException: " + e.getMessage());    }    assertEquals(expected, outStream.toString());}
public void pdfbox_f7955_0()
{    String expected = "Quick and simple test";    String hexForm = createHex(expected);    try {        COSString test1 = COSString.parseHex(hexForm);        writePDFTests("(" + expected + ")", test1);        COSString test2 = COSString.parseHex(createHex(ESC_CHAR_STRING));        writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", test2);    } catch (IOException e) {        fail("IOException thrown: " + e.getMessage());    }    try {        COSString.parseHex(hexForm + "xx");        fail("Should have thrown an IOException here");    } catch (IOException e) {        }}
private String pdfbox_f7956_0(String str)
{    StringBuilder sb = new StringBuilder();    for (char c : str.toCharArray()) {        sb.append(Integer.toString(c, 16));    }    return sb.toString().toUpperCase();}
public void pdfbox_f7957_0()
{    String expected = "Test subject for testing getHex";    COSString test1 = new COSString(expected);    String hexForm = createHex(expected);    assertEquals(hexForm, test1.toHexString());    COSString escCS = new COSString(ESC_CHAR_STRING);            assertEquals(createHex(ESC_CHAR_STRING), escCS.toHexString());}
public void pdfbox_f7958_0()
{    try {        String testStr = "Test subject for getString()";        COSString test1 = new COSString(testStr);        assertEquals(testStr, test1.getString());        COSString hexStr = COSString.parseHex(createHex(testStr));        assertEquals(testStr, hexStr.getString());        COSString escapedString = new COSString(ESC_CHAR_STRING);        assertEquals(ESC_CHAR_STRING, escapedString.getString());        testStr = "Line1\nLine2\nLine3\n";        COSString lineFeedString = new COSString(testStr);        assertEquals(testStr, lineFeedString.getString());    } catch (IOException e) {        fail("IOException thrown: " + e.getMessage());    }}
public void pdfbox_f7959_0()
{    COSString str = new COSString(ESC_CHAR_STRING);    testByteArrays(ESC_CHAR_STRING.getBytes(), str.getBytes());}
public void pdfbox_f7960_0()
{        COSString testSubj = new COSString(ESC_CHAR_STRING);    writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", testSubj);    String textString = "This is just an arbitrary piece of text for testing";    COSString testSubj2 = new COSString(textString);    writePDFTests("(" + textString + ")", testSubj2);}
public void pdfbox_f7961_0() throws IOException
{    String theString = "\u4e16";    COSString string = new COSString(theString);    assertTrue(string.getString().equals(theString));    String textAscii = "This is some regular text. It should all be expressable in ASCII";    /**     * En franais o les choses sont accentus. En espaol, as     */    String text8Bit = "En fran\u00e7ais o\u00f9 les choses sont accentu\u00e9s. En espa\u00f1ol, as\u00ed";    /**     *      */    String textHighBits = "\u3092\u30af\u30ea\u30c3\u30af\u3057\u3066\u304f";        COSString stringAscii = new COSString(textAscii);    assertEquals(stringAscii.getString(), textAscii);    COSString string8Bit = new COSString(text8Bit);    assertEquals(string8Bit.getString(), text8Bit);    COSString stringHighBits = new COSString(textHighBits);    assertEquals(stringHighBits.getString(), textHighBits);            assertEquals(textAscii, new String(stringAscii.getBytes(), "ISO-8859-1"));        assertEquals(text8Bit, new String(string8Bit.getBytes(), "ISO-8859-1"));        assertEquals(textHighBits, new String(stringHighBits.getBytes(), "UnicodeBig"));        ByteArrayOutputStream out = new ByteArrayOutputStream();    COSWriter.writeString(stringAscii, out);    assertEquals("(" + textAscii + ")", new String(out.toByteArray(), "ASCII"));    out.reset();    COSWriter.writeString(string8Bit, out);    StringBuffer hex = new StringBuffer();    for (char c : text8Bit.toCharArray()) {        hex.append(Integer.toHexString(c).toUpperCase());    }    assertEquals("<" + hex.toString() + ">", new String(out.toByteArray(), "ASCII"));    out.reset();    COSWriter.writeString(stringHighBits, out);    hex = new StringBuffer();        hex.append("FEFF");    for (char c : textHighBits.toCharArray()) {        hex.append(Integer.toHexString(c).toUpperCase());    }    assertEquals("<" + hex.toString() + ">", new String(out.toByteArray(), "ASCII"));}
public void pdfbox_f7962_0() throws IOException
{    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    ICOSVisitor visitor = new COSWriter(outStream);    COSString testSubj = new COSString(ESC_CHAR_STRING);    testSubj.accept(visitor);    assertEquals("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", outStream.toString());    outStream.reset();    testSubj.setForceHexForm(true);    testSubj.accept(visitor);    assertEquals("<" + createHex(ESC_CHAR_STRING) + ">", outStream.toString());}
public void pdfbox_f7963_0()
{        for (int i = 0; i < 10; i++) {                COSString x1 = new COSString("Test");        assertTrue(x1.equals(x1));                COSString y1 = new COSString("Test");        assertTrue(x1.equals(y1));        assertTrue(y1.equals(x1));        COSString x2 = new COSString("Test");        x2.setForceHexForm(true);                assertFalse(x1.equals(x2));        assertFalse(x2.equals(x1));                COSString z1 = new COSString("Test");        assertTrue(x1.equals(y1));        assertTrue(y1.equals(z1));        assertTrue(x1.equals(z1));                assertTrue(x1.equals(y1));        assertFalse(y1.equals(x2));        assertFalse(x1.equals(x2));                assertFalse(x1 == null);        assertFalse(y1 == null);        assertFalse(z1 == null);        assertFalse(x2 == null);    }}
public void pdfbox_f7964_0()
{    COSString str1 = new COSString("Test1");    COSString str2 = new COSString("Test2");    assertFalse(str1.hashCode() == str2.hashCode());    COSString str3 = new COSString("Test1");    assertTrue(str1.hashCode() == str3.hashCode());    str3.setForceHexForm(true);    assertFalse(str1.hashCode() == str3.hashCode());}
public void pdfbox_f7965_0() throws IOException
{    COSString test1 = COSString.parseHex("000000FF000000");    COSString test2 = COSString.parseHex("000000FF00FFFF");    assertEquals(test1, test1);    assertEquals(test2, test2);    assertFalse(test1.toHexString().equals(test2.toHexString()));    assertFalse(Arrays.equals(test1.getBytes(), test2.getBytes()));    assertFalse(test1.equals(test2));    assertFalse(test2.equals(test1));    assertFalse(test1.getString().equals(test2.getString()));}
public void pdfbox_f7966_0() throws IOException
{    assertTrue(COSString.parseHex("FEFF").getString().isEmpty());    assertTrue(COSString.parseHex("FFFE").getString().isEmpty());}
public void pdfbox_f7967_0()
{        COSUpdateInfo testCOSDictionary = new COSDictionary();    testCOSDictionary.setNeedToBeUpdated(true);    assertTrue(testCOSDictionary.isNeedToBeUpdated());    testCOSDictionary.setNeedToBeUpdated(false);    assertFalse(testCOSDictionary.isNeedToBeUpdated());        COSUpdateInfo testCOSObject;    testCOSObject = new COSObject(null);    testCOSObject.setNeedToBeUpdated(true);    assertTrue(testCOSObject.isNeedToBeUpdated());    testCOSObject.setNeedToBeUpdated(false);    assertFalse(testCOSObject.isNeedToBeUpdated());}
public static Collection pdfbox_f7968_0()
{    return Arrays.asList(40, 128, 256);}
public void pdfbox_f7969_0() throws Exception
{    if (Cipher.getMaxAllowedKeyLength("AES") != Integer.MAX_VALUE) {                fail("JCE unlimited strength jurisdiction policy files are not installed");    }    permission1 = new AccessPermission();    permission1.setCanAssembleDocument(false);    permission1.setCanExtractContent(false);    permission1.setCanExtractForAccessibility(true);    permission1.setCanFillInForm(false);    permission1.setCanModify(false);    permission1.setCanModifyAnnotations(false);    permission1.setCanPrint(false);    permission1.setCanPrintDegraded(false);    permission2 = new AccessPermission();    permission2.setCanAssembleDocument(false);    permission2.setCanExtractContent(false);    permission2.setCanExtractForAccessibility(true);    permission2.setCanFillInForm(false);    permission2.setCanModify(false);    permission2.setCanModifyAnnotations(false);        permission2.setCanPrint(true);    permission2.setCanPrintDegraded(false);    recipient1 = getRecipient("test1.der", permission1);    recipient2 = getRecipient("test2.der", permission2);    password1 = "test1";    password2 = "test2";    keyStore1 = "test1.pfx";    keyStore2 = "test2.pfx";    document = PDDocument.load(new File(this.getClass().getResource("test.pdf").toURI()));    text = new PDFTextStripper().getText(document);    producer = document.getDocumentInformation().getProducer();    document.setVersion(1.7f);}
public void pdfbox_f7970_0() throws Exception
{    document.close();}
public void pdfbox_f7971_0() throws Exception
{    PublicKeyProtectionPolicy policy = new PublicKeyProtectionPolicy();    policy.addRecipient(recipient1);    policy.setEncryptionKeyLength(keyLength);    document.protect(policy);    PDDocument encryptedDoc = null;    try {        File file = save("testProtectionError");        encryptedDoc = reload(file, password2, getKeyStore(keyStore2));        Assert.assertTrue(encryptedDoc.isEncrypted());        fail("No exception when using an incorrect decryption key");    } catch (IOException ex) {        String msg = ex.getMessage();        Assert.assertTrue("not the expected exception: " + msg, msg.contains("serial-#: rid 2 vs. cert 3"));    } finally {        if (encryptedDoc != null) {            encryptedDoc.close();        }    }}
public void pdfbox_f7972_0() throws Exception
{    PublicKeyProtectionPolicy policy = new PublicKeyProtectionPolicy();    policy.addRecipient(recipient1);    policy.setEncryptionKeyLength(keyLength);    document.protect(policy);    File file = save("testProtection");    try (PDDocument encryptedDoc = reload(file, password1, getKeyStore(keyStore1))) {        Assert.assertTrue(encryptedDoc.isEncrypted());        AccessPermission permission = encryptedDoc.getCurrentAccessPermission();        Assert.assertFalse(permission.canAssembleDocument());        Assert.assertFalse(permission.canExtractContent());        Assert.assertTrue(permission.canExtractForAccessibility());        Assert.assertFalse(permission.canFillInForm());        Assert.assertFalse(permission.canModify());        Assert.assertFalse(permission.canModifyAnnotations());        Assert.assertFalse(permission.canPrint());        Assert.assertFalse(permission.canPrintDegraded());    }}
public void pdfbox_f7973_0() throws Exception
{    PublicKeyProtectionPolicy policy = new PublicKeyProtectionPolicy();    policy.addRecipient(recipient1);    policy.addRecipient(recipient2);    policy.setEncryptionKeyLength(keyLength);    document.protect(policy);        File file = save("testMultipleRecipients");    try (PDDocument encryptedDoc1 = reload(file, password1, getKeyStore(keyStore1))) {        AccessPermission permission = encryptedDoc1.getCurrentAccessPermission();        Assert.assertFalse(permission.canAssembleDocument());        Assert.assertFalse(permission.canExtractContent());        Assert.assertTrue(permission.canExtractForAccessibility());        Assert.assertFalse(permission.canFillInForm());        Assert.assertFalse(permission.canModify());        Assert.assertFalse(permission.canModifyAnnotations());        Assert.assertFalse(permission.canPrint());        Assert.assertFalse(permission.canPrintDegraded());    }        try (PDDocument encryptedDoc2 = reload(file, password2, getKeyStore(keyStore2))) {        AccessPermission permission = encryptedDoc2.getCurrentAccessPermission();        Assert.assertFalse(permission.canAssembleDocument());        Assert.assertFalse(permission.canExtractContent());        Assert.assertTrue(permission.canExtractForAccessibility());        Assert.assertFalse(permission.canFillInForm());        Assert.assertFalse(permission.canModify());        Assert.assertFalse(permission.canModifyAnnotations());        Assert.assertTrue(permission.canPrint());        Assert.assertFalse(permission.canPrintDegraded());    }}
private PDDocument pdfbox_f7974_0(File file, String decryptionPassword, InputStream keyStore) throws IOException, NoSuchAlgorithmException
{    PDDocument doc2 = PDDocument.load(file, decryptionPassword, keyStore, null, MemoryUsageSetting.setupMainMemoryOnly());    Assert.assertEquals("Extracted text is different", text, new PDFTextStripper().getText(doc2));    Assert.assertEquals("Producer is different", producer, doc2.getDocumentInformation().getProducer());    return doc2;}
private PublicKeyRecipient pdfbox_f7975_0(String certificate, AccessPermission permission) throws Exception
{    try (InputStream input = TestPublicKeyEncryption.class.getResourceAsStream(certificate)) {        CertificateFactory factory = CertificateFactory.getInstance("X.509");        PublicKeyRecipient recipient = new PublicKeyRecipient();        recipient.setPermission(permission);        recipient.setX509((X509Certificate) factory.generateCertificate(input));        return recipient;    }}
private InputStream pdfbox_f7976_0(String name)
{    return TestPublicKeyEncryption.class.getResourceAsStream(name);}
private File pdfbox_f7977_0(String name) throws IOException
{    File file = new File(testResultsDir, name + "-" + keyLength + "bit.pdf");    document.save(file);    return file;}
protected void pdfbox_f7978_0() throws Exception
{    testResultsDir.mkdirs();    if (Cipher.getMaxAllowedKeyLength("AES") != Integer.MAX_VALUE) {                fail("JCE unlimited strength jurisdiction policy files are not installed");    }    permission = new AccessPermission();    permission.setCanAssembleDocument(false);    permission.setCanExtractContent(false);    permission.setCanExtractForAccessibility(true);    permission.setCanFillInForm(false);    permission.setCanModify(false);    permission.setCanModifyAnnotations(false);    permission.setCanPrint(true);    permission.setCanPrintDegraded(false);    permission.setReadOnly();}
public void pdfbox_f7979_0() throws IOException
{    AccessPermission fullAP = new AccessPermission();    AccessPermission restrAP = new AccessPermission();    restrAP.setCanPrint(false);    restrAP.setCanExtractContent(false);    restrAP.setCanModify(false);    byte[] inputFileAsByteArray = getFileResourceAsByteArray("PasswordSample-40bit.pdf");    checkPerms(inputFileAsByteArray, "owner", fullAP);    checkPerms(inputFileAsByteArray, "user", restrAP);    try {        checkPerms(inputFileAsByteArray, "", null);        fail("wrong password not detected");    } catch (IOException ex) {        assertEquals("Cannot decrypt PDF, the password is incorrect", ex.getMessage());    }    restrAP.setCanAssembleDocument(false);    restrAP.setCanExtractForAccessibility(false);    restrAP.setCanPrintDegraded(false);    inputFileAsByteArray = getFileResourceAsByteArray("PasswordSample-128bit.pdf");    checkPerms(inputFileAsByteArray, "owner", fullAP);    checkPerms(inputFileAsByteArray, "user", restrAP);    try {        checkPerms(inputFileAsByteArray, "", null);        fail("wrong password not detected");    } catch (IOException ex) {        assertEquals("Cannot decrypt PDF, the password is incorrect", ex.getMessage());    }    inputFileAsByteArray = getFileResourceAsByteArray("PasswordSample-256bit.pdf");    checkPerms(inputFileAsByteArray, "owner", fullAP);    checkPerms(inputFileAsByteArray, "user", restrAP);    try {        checkPerms(inputFileAsByteArray, "", null);        fail("wrong password not detected");    } catch (IOException ex) {        assertEquals("Cannot decrypt PDF, the password is incorrect", ex.getMessage());    }}
private void pdfbox_f7980_0(byte[] inputFileAsByteArray, String password, AccessPermission expectedPermissions) throws IOException
{    try (PDDocument doc = PDDocument.load(inputFileAsByteArray, password)) {        AccessPermission currentAccessPermission = doc.getCurrentAccessPermission();                assertEquals(expectedPermissions.isOwnerPermission(), currentAccessPermission.isOwnerPermission());        if (!expectedPermissions.isOwnerPermission()) {            assertEquals(true, currentAccessPermission.isReadOnly());        }        assertEquals(expectedPermissions.canAssembleDocument(), currentAccessPermission.canAssembleDocument());        assertEquals(expectedPermissions.canExtractContent(), currentAccessPermission.canExtractContent());        assertEquals(expectedPermissions.canExtractForAccessibility(), currentAccessPermission.canExtractForAccessibility());        assertEquals(expectedPermissions.canFillInForm(), currentAccessPermission.canFillInForm());        assertEquals(expectedPermissions.canModify(), currentAccessPermission.canModify());        assertEquals(expectedPermissions.canModifyAnnotations(), currentAccessPermission.canModifyAnnotations());        assertEquals(expectedPermissions.canPrint(), currentAccessPermission.canPrint());        assertEquals(expectedPermissions.canPrintDegraded(), currentAccessPermission.canPrintDegraded());        new PDFRenderer(doc).renderImage(0);    }}
public void pdfbox_f7981_0() throws Exception
{    byte[] inputFileAsByteArray = getFileResourceAsByteArray("Acroform-PDFBOX-2333.pdf");    int sizePriorToEncryption = inputFileAsByteArray.length;    testSymmEncrForKeySize(40, false, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);    testSymmEncrForKeySize(128, false, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);    testSymmEncrForKeySize(128, true, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);    testSymmEncrForKeySize(256, true, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);}
public void pdfbox_f7982_0() throws IOException
{    byte[] inputFileAsByteArray;    try (InputStream is = new FileInputStream("target/pdfs/PDFBOX-4308.pdf")) {        inputFileAsByteArray = IOUtils.toByteArray(is);    }    int sizePriorToEncryption = inputFileAsByteArray.length;    testSymmEncrForKeySize(40, false, sizePriorToEncryption, inputFileAsByteArray, USERPASSWORD, OWNERPASSWORD, permission);}
public void pdfbox_f7983_0() throws Exception
{    String testFileName = "preEnc_20141025_105451.pdf";    byte[] inputFileWithEmbeddedFileAsByteArray = getFileResourceAsByteArray(testFileName);    int sizeOfFileWithEmbeddedFile = inputFileWithEmbeddedFileAsByteArray.length;    File extractedEmbeddedFile = extractEmbeddedFile(new ByteArrayInputStream(inputFileWithEmbeddedFileAsByteArray), "innerFile.pdf");    testSymmEncrForKeySizeInner(40, false, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);    testSymmEncrForKeySizeInner(128, false, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);    testSymmEncrForKeySizeInner(128, true, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);    testSymmEncrForKeySizeInner(256, true, sizeOfFileWithEmbeddedFile, inputFileWithEmbeddedFileAsByteArray, extractedEmbeddedFile, USERPASSWORD, OWNERPASSWORD);}
public void pdfbox_f7984_0() throws IOException
{    final int TESTCOUNT = 1000;    File file = new File(testResultsDir, "PDFBOX-4453.pdf");    try (PDDocument doc = new PDDocument()) {        doc.addPage(new PDPage());        for (int i = 0; i < TESTCOUNT; ++i) {                                    COSDictionary dict = new COSDictionary();            doc.getPage(0).getCOSObject().setItem(COSName.getPDFName("_Test-" + i), dict);                                    dict.setString("key1", "3");            dict.setString("key2", "0");        }                StandardProtectionPolicy spp = new StandardProtectionPolicy("12345", "", new AccessPermission());        spp.setEncryptionKeyLength(40);        spp.setPreferAES(false);        doc.protect(spp);        doc.save(file);    }    try (PDDocument doc = PDDocument.load(file)) {        Assert.assertTrue(doc.isEncrypted());        for (int i = 0; i < TESTCOUNT; ++i) {            COSDictionary dict = doc.getPage(0).getCOSObject().getCOSDictionary(COSName.getPDFName("_Test-" + i));            Assert.assertEquals("3", dict.getString("key1"));            Assert.assertEquals("0", dict.getString("key2"));        }    }}
private void pdfbox_f7985_0(int keyLength, boolean preferAES, int sizePriorToEncr, byte[] inputFileAsByteArray, String userpassword, String ownerpassword, AccessPermission permission) throws IOException
{    PDDocument document = PDDocument.load(inputFileAsByteArray);    String prefix = "Simple-";    int numSrcPages = document.getNumberOfPages();    PDFRenderer pdfRenderer = new PDFRenderer(document);    List<BufferedImage> srcImgTab = new ArrayList<>();    List<byte[]> srcContentStreamTab = new ArrayList<>();    for (int i = 0; i < numSrcPages; ++i) {        srcImgTab.add(pdfRenderer.renderImage(i));        try (InputStream unfilteredStream = document.getPage(i).getContents()) {            srcContentStreamTab.add(IOUtils.toByteArray(unfilteredStream));        }    }    try (PDDocument encryptedDoc = encrypt(keyLength, preferAES, sizePriorToEncr, document, prefix, permission, userpassword, ownerpassword)) {        Assert.assertEquals(numSrcPages, encryptedDoc.getNumberOfPages());        pdfRenderer = new PDFRenderer(encryptedDoc);        for (int i = 0; i < encryptedDoc.getNumberOfPages(); ++i) {                        BufferedImage bim = pdfRenderer.renderImage(i);            ValidateXImage.checkIdent(bim, srcImgTab.get(i));                        try (InputStream unfilteredStream = encryptedDoc.getPage(i).getContents()) {                byte[] bytes = IOUtils.toByteArray(unfilteredStream);                Assert.assertArrayEquals("content stream of page " + i + " not identical", srcContentStreamTab.get(i), bytes);            }        }        File pdfFile = new File(testResultsDir, prefix + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + "-decrypted.pdf");        encryptedDoc.setAllSecurityToBeRemoved(true);        encryptedDoc.save(pdfFile);    }}
private PDDocument pdfbox_f7986_0(int keyLength, boolean preferAES, int sizePriorToEncr, PDDocument doc, String prefix, AccessPermission permission, String userpassword, String ownerpassword) throws IOException
{    StandardProtectionPolicy spp = new StandardProtectionPolicy(ownerpassword, userpassword, permission);    spp.setEncryptionKeyLength(keyLength);    spp.setPreferAES(preferAES);        doc.setAllSecurityToBeRemoved(true);    doc.protect(spp);    File pdfFile = new File(testResultsDir, prefix + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + "-encrypted.pdf");    doc.save(pdfFile);    doc.close();    long sizeEncrypted = pdfFile.length();    Assert.assertTrue(keyLength + "-bit " + (preferAES ? "AES" : "RC4") + " encrypted pdf should not have same size as plain one", sizeEncrypted != sizePriorToEncr);        PDDocument encryptedDoc = PDDocument.load(pdfFile, ownerpassword);    Assert.assertTrue(encryptedDoc.isEncrypted());    Assert.assertTrue(encryptedDoc.getCurrentAccessPermission().isOwnerPermission());        PDEncryption encryption = encryptedDoc.getEncryption();    int revision = encryption.getRevision();    if (revision < 5) {        StandardSecurityHandler standardSecurityHandler = new StandardSecurityHandler();        int keyLengthInBytes = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;        byte[] computedUserPassword = standardSecurityHandler.getUserPassword(ownerpassword.getBytes(Charsets.ISO_8859_1), encryption.getOwnerKey(), revision, keyLengthInBytes);        Assert.assertEquals(userpassword.substring(0, 32), new String(computedUserPassword, Charsets.ISO_8859_1));    }    encryptedDoc.close();        encryptedDoc = PDDocument.load(pdfFile, userpassword);    Assert.assertTrue(encryptedDoc.isEncrypted());    Assert.assertFalse(encryptedDoc.getCurrentAccessPermission().isOwnerPermission());    assertEquals(permission.getPermissionBytes(), encryptedDoc.getCurrentAccessPermission().getPermissionBytes());    return encryptedDoc;}
private File pdfbox_f7987_1(InputStream pdfInputStream, String name) throws IOException
{    PDDocument docWithEmbeddedFile;    docWithEmbeddedFile = PDDocument.load(pdfInputStream);    PDDocumentCatalog catalog = docWithEmbeddedFile.getDocumentCatalog();    PDDocumentNameDictionary names = catalog.getNames();    PDEmbeddedFilesNameTreeNode embeddedFiles = names.getEmbeddedFiles();    Map<String, PDComplexFileSpecification> embeddedFileNames = embeddedFiles.getNames();    Assert.assertEquals(1, embeddedFileNames.size());    Map.Entry<String, PDComplexFileSpecification> entry = embeddedFileNames.entrySet().iterator().next();        PDComplexFileSpecification complexFileSpec = entry.getValue();    PDEmbeddedFile embeddedFile = complexFileSpec.getEmbeddedFile();    File resultFile = new File(testResultsDir, name);    try (FileOutputStream fos = new FileOutputStream(resultFile);        InputStream is = embeddedFile.createInputStream()) {        IOUtils.copy(is, fos);    }        assertEquals(embeddedFile.getSize(), resultFile.length());    return resultFile;}
private void pdfbox_f7988_0(int keyLength, boolean preferAES, int sizePriorToEncr, byte[] inputFileWithEmbeddedFileAsByteArray, File embeddedFilePriorToEncryption, String userpassword, String ownerpassword) throws IOException
{    PDDocument document = PDDocument.load(inputFileWithEmbeddedFileAsByteArray);    try (PDDocument encryptedDoc = encrypt(keyLength, preferAES, sizePriorToEncr, document, "ContainsEmbedded-", permission, userpassword, ownerpassword)) {        File decryptedFile = new File(testResultsDir, "DecryptedContainsEmbedded-" + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + ".pdf");        encryptedDoc.setAllSecurityToBeRemoved(true);        encryptedDoc.save(decryptedFile);        File extractedEmbeddedFile = extractEmbeddedFile(new FileInputStream(decryptedFile), "decryptedInnerFile-" + keyLength + "-bit-" + (preferAES ? "AES" : "RC4") + ".pdf");        Assert.assertEquals(keyLength + "-bit " + (preferAES ? "AES" : "RC4") + " decrypted inner attachment pdf should have same size as plain one", embeddedFilePriorToEncryption.length(), extractedEmbeddedFile.length());                Assert.assertArrayEquals(getFileAsByteArray(embeddedFilePriorToEncryption), getFileAsByteArray(extractedEmbeddedFile));    }}
private byte[] pdfbox_f7989_0(String testFileName) throws IOException
{    return IOUtils.toByteArray(TestSymmetricKeyEncryption.class.getResourceAsStream(testFileName));}
private byte[] pdfbox_f7990_0(File f) throws IOException
{    return Files.readAllBytes(f.toPath());}
public void pdfbox_f7991_0()
{    Assert.assertEquals(Integer.parseInt("11111111", 2), getBitSeq(Integer.parseInt("11111111", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("00000000", 2), getBitSeq(Integer.parseInt("00000000", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("1", 2), getBitSeq(Integer.parseInt("11111111", 2), 0, 1));    Assert.assertEquals(Integer.parseInt("0", 2), getBitSeq(Integer.parseInt("00000000", 2), 0, 1));    Assert.assertEquals(Integer.parseInt("001", 2), getBitSeq(Integer.parseInt("00110001", 2), 0, 3));    Assert.assertEquals(Integer.parseInt("10101010", 2), getBitSeq(Integer.parseInt("10101010", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("10", 2), getBitSeq(Integer.parseInt("10101010", 2), 0, 2));    Assert.assertEquals(Integer.parseInt("01", 2), getBitSeq(Integer.parseInt("10101010", 2), 1, 2));    Assert.assertEquals(Integer.parseInt("10", 2), getBitSeq(Integer.parseInt("10101010", 2), 2, 2));    Assert.assertEquals(Integer.parseInt("101", 2), getBitSeq(Integer.parseInt("10101010", 2), 3, 3));    Assert.assertEquals(Integer.parseInt("1010101", 2), getBitSeq(Integer.parseInt("10101010", 2), 1, 7));    Assert.assertEquals(Integer.parseInt("01", 2), getBitSeq(Integer.parseInt("10101010", 2), 3, 2));    Assert.assertEquals(Integer.parseInt("00110001", 2), getBitSeq(Integer.parseInt("00110001", 2), 0, 8));    Assert.assertEquals(Integer.parseInt("10001", 2), getBitSeq(Integer.parseInt("00110001", 2), 0, 5));    Assert.assertEquals(Integer.parseInt("0011", 2), getBitSeq(Integer.parseInt("00110001", 2), 4, 4));    Assert.assertEquals(Integer.parseInt("110", 2), getBitSeq(Integer.parseInt("00110001", 2), 3, 3));    Assert.assertEquals(Integer.parseInt("00", 2), getBitSeq(Integer.parseInt("00110001", 2), 6, 2));    Assert.assertEquals(Integer.parseInt("1111", 2), getBitSeq(Integer.parseInt("11110000", 2), 4, 4));    Assert.assertEquals(Integer.parseInt("11", 2), getBitSeq(Integer.parseInt("11110000", 2), 6, 2));    Assert.assertEquals(Integer.parseInt("0000", 2), getBitSeq(Integer.parseInt("11110000", 2), 0, 4));}
public void pdfbox_f7992_0()
{    Assert.assertEquals(Integer.parseInt("00000000", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 8, 0));    Assert.assertEquals(Integer.parseInt("00000001", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 8, 1));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 1, 1));    Assert.assertEquals(Integer.parseInt("11111101", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 2, 1));    Assert.assertEquals(Integer.parseInt("11111001", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 3, 1));    Assert.assertEquals(Integer.parseInt("00000001", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 0, 2, 1));    Assert.assertEquals(Integer.parseInt("11110001", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 4, 1));    Assert.assertEquals(Integer.parseInt("11100011", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 1, 4, 1));    Assert.assertEquals(Integer.parseInt("00000010", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 1, 1, 1));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 7, 1, 1));    Assert.assertEquals(Integer.parseInt("01111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 7, 1, 0));    Assert.assertEquals(Integer.parseInt("10000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 7, 1, 1));    Assert.assertEquals(Integer.parseInt("00000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 7, 1, 0));    Assert.assertEquals(Integer.parseInt("01000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 6, 1, 1));    Assert.assertEquals(Integer.parseInt("00000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 6, 1, 0));    Assert.assertEquals(Integer.parseInt("00110000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 3, 3, 6));    Assert.assertEquals(Integer.parseInt("01100000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 4, 3, 6));    Assert.assertEquals(Integer.parseInt("11000000", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 5, 3, 6));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 0, 8, 0xFF));    Assert.assertEquals(Integer.parseInt("11111111", 2), calcSetBitSeq(Integer.parseInt("11111111", 2), 0, 8, 0xFF));    Assert.assertEquals(0x7E, calcSetBitSeq(0xA5, 0, 8, 0xD9 + 0xA5));        Assert.assertEquals(Integer.parseInt("00000010", 2), calcSetBitSeq(Integer.parseInt("00000000", 2), 1, 1, 3));}
public void pdfbox_f7993_0() throws IOException
{    final int COUNT = 10;    Random rd = new Random(123456);    for (int iter = 0; iter < COUNT * 2; iter++) {        long seed;        if (iter < COUNT) {                        seed = rd.nextLong();        } else {                        seed = new Random().nextLong();        }        boolean success = false;        try {            final Random random = new Random(seed);            final int numBytes = 10000 + random.nextInt(20000);            byte[] original = new byte[numBytes];            int upto = 0;            while (upto < numBytes) {                final int left = numBytes - upto;                if (random.nextBoolean() || left < 2) {                                        final int end = upto + Math.min(left, 10 + random.nextInt(100));                    while (upto < end) {                        original[upto++] = (byte) random.nextInt();                    }                } else {                                        final int end = upto + Math.min(left, 2 + random.nextInt(10));                    final byte value = (byte) random.nextInt(4);                    while (upto < end) {                        original[upto++] = value;                    }                }            }            for (Filter filter : FilterFactory.INSTANCE.getAllFilters()) {                                if (filter instanceof DCTFilter || filter instanceof CCITTFaxFilter || filter instanceof JPXFilter || filter instanceof JBIG2Filter || filter instanceof RunLengthDecodeFilter) {                    continue;                }                checkEncodeDecode(filter, original);            }            success = true;        } finally {            if (!success) {                System.err.println("NOTE: test failed with seed=" + seed);            }        }    }}
public void pdfbox_f7994_0() throws IOException
{    PDDocument.load(new File("target/pdfs/PDFBOX-4517-cryptfilter.pdf"), "userpassword1234");}
public void pdfbox_f7995_0() throws IOException
{    Filter lzwFilter = FilterFactory.INSTANCE.getFilter(COSName.LZW_DECODE);    byte[] byteArray = IOUtils.toByteArray(this.getClass().getResourceAsStream("PDFBOX-1777.bin"));    checkEncodeDecode(lzwFilter, byteArray);}
private void pdfbox_f7996_0(Filter filter, byte[] original) throws IOException
{    ByteArrayOutputStream encoded = new ByteArrayOutputStream();    filter.encode(new ByteArrayInputStream(original), encoded, new COSDictionary());    ByteArrayOutputStream decoded = new ByteArrayOutputStream();    filter.decode(new ByteArrayInputStream(encoded.toByteArray()), decoded, new COSDictionary(), 0);    assertTrue("Data that is encoded and then decoded through " + filter.getClass() + " does not match the original data", Arrays.equals(original, decoded.toByteArray()));}
public void pdfbox_f7997_0() throws IOException
{    byte[] data = "Hello World!".getBytes();    byte[] buffer = new byte[data.length];    long count = IOUtils.populateBuffer(new ByteArrayInputStream(data), buffer);    assertEquals(12, count);        buffer = new byte[data.length - 2];    InputStream in = new ByteArrayInputStream(data);    count = IOUtils.populateBuffer(in, buffer);    assertEquals(10, count);    byte[] leftOver = IOUtils.toByteArray(in);    assertEquals(2, leftOver.length);        buffer = new byte[data.length + 2];    in = new ByteArrayInputStream(data);    count = IOUtils.populateBuffer(in, buffer);    assertEquals(12, count);        assertEquals(-1, in.read());}
public void pdfbox_f7998_0() throws IOException
{    RandomAccessBuffer buffer = new RandomAccessBuffer();    byte[] byteArray = new byte[CHUNK_SIZE + 2];        for (int i = 0; i < 2; i++) {        byteArray[CHUNK_SIZE + i] = 1;    }    buffer.write(byteArray);    buffer.seek(CHUNK_SIZE - 2);        buffer.read(byteArray, 0, 2);        buffer.read(byteArray, 0, 2);        assertEquals(2, byteArray[0] + byteArray[1]);    buffer.close();    buffer = new RandomAccessBuffer();    byteArray = new byte[2 * CHUNK_SIZE + 2];        for (int i = 0; i < CHUNK_SIZE; i++) {        byteArray[CHUNK_SIZE + i] = 1;    }        for (int i = 0; i < 2; i++) {        byteArray[2 * CHUNK_SIZE + i] = 2;    }    buffer.write(byteArray);    buffer.seek(700);    byte[] bytesRead = new byte[1348];    buffer.read(bytesRead, 0, bytesRead.length);    assertEquals(2, buffer.read());    buffer.close();}
public void pdfbox_f7999_0() throws IOException
{        RandomAccessBuffer buffer = new RandomAccessBuffer();    for (int i = 0; i < 10; i++) {        buffer.write(i);    }        buffer.seek(0);        int result = 0;    for (int i = 0; i < 10; i++) {        result += buffer.read();    }    assertEquals(45, result);    buffer.close();}
public void pdfbox_f8000_0() throws IOException
{        byte[] byteArray = new byte[10];    for (byte i = 0; i < 10; i++) {        byteArray[i] = i;    }        RandomAccessBuffer buffer = new RandomAccessBuffer();    buffer.write(byteArray);        buffer.seek(0);            int result = 0;    for (int i = 0; i < 10; i++) {        result += buffer.read();    }    assertEquals(45, result);        buffer.seek(0);            buffer.read(byteArray, 0, byteArray.length);    result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(45, result);    buffer.close();}
public void pdfbox_f8001_0() throws IOException
{        byte[] byteArray = new byte[2 * CHUNK_SIZE + 100];    for (int i = CHUNK_SIZE; i < 2 * CHUNK_SIZE; i++) {        byteArray[i] = 1;    }    for (int i = 2 * CHUNK_SIZE; i < 2 * CHUNK_SIZE + 100; i++) {        byteArray[i] = 2;    }        RandomAccessBuffer buffer = new RandomAccessBuffer();    buffer.write(byteArray);        buffer.seek(0);        assertEquals(0, buffer.read());        buffer.seek(CHUNK_SIZE - 1);    assertEquals(0, buffer.read());        buffer.seek(CHUNK_SIZE);    assertEquals(1, buffer.read());        buffer.seek(CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray, 0, byteArray.length);    int result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(5, result);        buffer.seek(2 * CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray);    result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(15, result);    buffer.close();}
public void pdfbox_f8002_0() throws IOException
{        byte[] byteArray = new byte[CHUNK_SIZE + 100];    RandomAccessBuffer buffer = new RandomAccessBuffer();    for (int i = CHUNK_SIZE; i < CHUNK_SIZE + 100; i++) {        byteArray[i] = 1;    }    buffer.write(byteArray);        buffer.seek(CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray, 0, byteArray.length);    int result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(5, result);        buffer.seek(CHUNK_SIZE - 5);        for (int i = 0; i < 5; i++) {        buffer.write(2);    }    for (int i = 0; i < 5; i++) {        buffer.write(3);    }        buffer.seek(CHUNK_SIZE - 5);            byteArray = new byte[10];    buffer.read(byteArray, 0, byteArray.length);    result = 0;    for (int i = 0; i < 10; i++) {        result += byteArray[i];    }    assertEquals(25, result);    buffer.close();}
public void pdfbox_f8003_0() throws IOException
{        RandomAccessBuffer buffer = new RandomAccessBuffer();    for (int i = 0; i < 10; i++) {        buffer.write(i);    }        buffer.seek(0);        buffer.seek(20);        assertEquals(-1, buffer.read());        assertTrue(buffer.isEOF());    buffer.close();}
public void pdfbox_f8004_0() throws Exception
{        byte[] byteArray = new byte[CHUNK_SIZE - 1];    RandomAccessBuffer buffer = new RandomAccessBuffer();    buffer.write(byteArray);        buffer.write(0);        buffer.seek(buffer.getPosition());    buffer.close();}
public void pdfbox_f8005_0() throws Exception
{                int chunkSize = (CHUNK_SIZE << 4) + 3;    byte[] byteArray = new byte[chunkSize];    RandomAccessBuffer buffer = new RandomAccessBuffer(byteArray);        for (int i = 0; i < chunkSize; i++) {        buffer.write(1);    }        RandomAccessBuffer bufferClone = buffer.clone();        buffer.seek(0);    int bufRead = buffer.read(new byte[(int) buffer.length()]);    bufferClone.seek(0);    int bufCloneRead = bufferClone.read(new byte[(int) bufferClone.length()]);    assertEquals(bufRead, bufCloneRead);    buffer.close();    bufferClone.close();}
protected void pdfbox_f8006_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8007_0() throws IOException
{    RandomAccessOutputStream out;    byte[] buffer;    File file = new File(testResultsDir, "raf-outputstream.bin");    file.delete();    RandomAccessFile raFile = new RandomAccessFile(file, "rw");        buffer = createDataSequence(16, 10);    out = new RandomAccessOutputStream(raFile);    for (byte b : buffer) {        out.write(b);    }    assertEquals(16, raFile.length());    assertEquals(16, raFile.getPosition());    out.close();        out = new RandomAccessOutputStream(raFile);    assertEquals(16, raFile.length());    assertEquals(16, raFile.getPosition());    out.close();        buffer = createDataSequence(8, 30);    out = new RandomAccessOutputStream(raFile);    out.write(buffer);    assertEquals(24, raFile.length());    assertEquals(24, raFile.getPosition());    out.close();        buffer = createDataSequence(16, 50);    out = new RandomAccessOutputStream(raFile);    out.write(buffer, 8, 4);    out.write(buffer, 4, 2);    assertEquals(30, raFile.length());    assertEquals(30, raFile.getPosition());    out.close();        buffer = new byte[(int) raFile.length()];    raFile.seek(0);    assertEquals(buffer.length, raFile.read(buffer, 0, buffer.length));    assertEquals(10, buffer[0]);    assertEquals(11, buffer[1]);    assertEquals(25, buffer[15]);    assertEquals(30, buffer[16]);    assertEquals(31, buffer[17]);    assertEquals(37, buffer[23]);    assertEquals(58, buffer[24]);    assertEquals(59, buffer[25]);    assertEquals(60, buffer[26]);    assertEquals(61, buffer[27]);    assertEquals(54, buffer[28]);    assertEquals(55, buffer[29]);        raFile.close();    file.delete();}
protected byte[] pdfbox_f8008_0(int length, int firstByteValue)
{    byte[] buffer = new byte[length];    for (int i = 0; i < buffer.length; i++) {        buffer[i] = (byte) (firstByteValue + i);    }    return buffer;}
public void pdfbox_f8009_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDType0Font font = PDType0Font.load(doc, GsubWorkerForBengaliTest.class.getResourceAsStream(LOHIT_BENGALI_TTF), true);        cmapLookup = font.getCmapLookup();        gsubWorkerForBengali = new GsubWorkerFactory().getGsubWorker(cmapLookup, font.getGsubData());    }}
public void pdfbox_f8010_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(56, 102, 91);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8011_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(89, 156, 101, 97);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8012_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(438, 89, 94, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8013_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 89, 101, 97);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8014_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 96, 101, 108, 94, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8015_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 73, 101, 108, 77, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8016_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(108, 91, 114, 94);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8017_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(439, 89, 93);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8018_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(167, 103, 438, 93, 93);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8019_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(274, 82);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8020_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(85, 104, 440, 82);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8021_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(352, 108, 87, 101);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8022_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(67, 108, 369, 101, 94);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
public void pdfbox_f8023_0()
{        List<Integer> glyphsAfterGsub = Arrays.asList(98, 78, 101, 113);        List<Integer> result = gsubWorkerForBengali.applyTransforms(getGlyphIds(""));        assertEquals(glyphsAfterGsub, result);}
private List<Integer> pdfbox_f8024_0(String word)
{    List<Integer> originalGlyphIds = new ArrayList<>();    for (char unicodeChar : word.toCharArray()) {        int glyphId = cmapLookup.getGlyphId(unicodeChar);        assertTrue(glyphId > 0);        originalGlyphIds.add(glyphId);    }    return originalGlyphIds;}
public void pdfbox_f8025_0()
{    OUT_DIR.mkdirs();}
public void pdfbox_f8026_0() throws IOException
{    PDFMergerUtility merger = new PDFMergerUtility();    File toBeMerged = new File(IN_DIR, "AcroFormForMerge.pdf");    File pdfOutput = new File(OUT_DIR, "PDFBoxLegacyMerge-SameMerged.pdf");    merger.setDestinationFileName(pdfOutput.getAbsolutePath());    merger.addSource(toBeMerged);    merger.addSource(toBeMerged);    merger.mergeDocuments(null);    merger.setAcroFormMergeMode(AcroFormMergeMode.PDFBOX_LEGACY_MODE);    try (PDDocument compliantDocument = PDDocument.load(new File(IN_DIR, "PDFBoxLegacyMerge-SameMerged.pdf"));        PDDocument toBeCompared = PDDocument.load(new File(OUT_DIR, "PDFBoxLegacyMerge-SameMerged.pdf"))) {        PDAcroForm compliantAcroForm = compliantDocument.getDocumentCatalog().getAcroForm();        PDAcroForm toBeComparedAcroForm = toBeCompared.getDocumentCatalog().getAcroForm();        assertEquals("There shall be the same number of root fields", compliantAcroForm.getFields().size(), toBeComparedAcroForm.getFields().size());        for (PDField compliantField : compliantAcroForm.getFieldTree()) {            assertNotNull("There shall be a field with the same FQN", toBeComparedAcroForm.getField(compliantField.getFullyQualifiedName()));            PDField toBeComparedField = toBeComparedAcroForm.getField(compliantField.getFullyQualifiedName());            compareFieldProperties(compliantField, toBeComparedField);        }        for (PDField toBeComparedField : toBeComparedAcroForm.getFieldTree()) {            assertNotNull("There shall be a field with the same FQN", compliantAcroForm.getField(toBeComparedField.getFullyQualifiedName()));            PDField compliantField = compliantAcroForm.getField(toBeComparedField.getFullyQualifiedName());            compareFieldProperties(toBeComparedField, compliantField);        }    }}
private void pdfbox_f8027_0(PDField sourceField, PDField toBeComapredField)
{                final String[] keys = { "FT", "T", "TU", "TM", "Ff", "V", "DV", "Opts", "TI", "I", "Rect", "DA" };    COSDictionary sourceFieldCos = sourceField.getCOSObject();    COSDictionary toBeComparedCos = toBeComapredField.getCOSObject();    for (String key : keys) {        COSBase sourceBase = sourceFieldCos.getDictionaryObject(key);        COSBase toBeComparedBase = toBeComparedCos.getDictionaryObject(key);        if (sourceBase != null) {            assertEquals("The content of the field properties shall be the same", sourceBase.toString(), toBeComparedBase.toString());        } else {            assertNull("If the source property is null the compared property shall be null too", toBeComparedBase);        }    }}
public void pdfbox_f8028_0() throws IOException
{        PDFMergerUtility merger = new PDFMergerUtility();    File f1 = new File(TARGET_PDF_DIR, "PDFBOX-1031-1.pdf");    File f2 = new File(TARGET_PDF_DIR, "PDFBOX-1031-2.pdf");    File pdfOutput = new File(OUT_DIR, "PDFBOX-1031.pdf");    try (InputStream is1 = new FileInputStream(f1);        InputStream is2 = new FileInputStream(f2)) {        merger.setDestinationFileName(pdfOutput.getAbsolutePath());        merger.addSource(is1);        merger.addSource(is2);        merger.mergeDocuments(null);    }        try (PDDocument mergedPDF = PDDocument.load(pdfOutput)) {        assertEquals("There shall be 2 pages", 2, mergedPDF.getNumberOfPages());        assertNotNull("There shall be an /Annots entry for the first page", mergedPDF.getPage(0).getCOSObject().getDictionaryObject(COSName.ANNOTS));        assertEquals("There shall be 1 annotation for the first page", 1, mergedPDF.getPage(0).getAnnotations().size());        assertNotNull("There shall be an /Annots entry for the second page", mergedPDF.getPage(1).getCOSObject().getDictionaryObject(COSName.ANNOTS));        assertEquals("There shall be 1 annotation for the second page", 1, mergedPDF.getPage(0).getAnnotations().size());    }}
public void pdfbox_f8029_0() throws IOException
{    File file1 = new File(TARGET_PDF_DIR, "PDFBOX-1100-1.pdf");    File file2 = new File(TARGET_PDF_DIR, "PDFBOX-1100-2.pdf");        PDFMergerUtility merger = new PDFMergerUtility();    File pdfOutput = new File(OUT_DIR, "PDFBOX-1100.pdf");    try (InputStream is1 = new FileInputStream(file1);        InputStream is2 = new FileInputStream(file2)) {        merger.setDestinationFileName(pdfOutput.getAbsolutePath());        merger.addSource(is1);        merger.addSource(is2);        merger.mergeDocuments(null);    }        try (PDDocument mergedPDF = PDDocument.load(pdfOutput)) {        assertEquals("There shall be 2 pages", 2, mergedPDF.getNumberOfPages());        PDAcroForm acroForm = mergedPDF.getDocumentCatalog().getAcroForm();        PDField formField = acroForm.getField("Testfeld");        assertNotNull("There shall be an /AP entry for the field", formField.getCOSObject().getDictionaryObject(COSName.AP));        assertNotNull("There shall be a /V entry for the field", formField.getCOSObject().getDictionaryObject(COSName.V));        formField = acroForm.getField("Testfeld2");        assertNotNull("There shall be an /AP entry for the field", formField.getCOSObject().getDictionaryObject(COSName.AP));        assertNotNull("There shall be a /V entry for the field", formField.getCOSObject().getDictionaryObject(COSName.V));    }}
public void pdfbox_f8030_0()
{    OUT_DIR.mkdirs();}
public void pdfbox_f8031_0() throws IOException
{        PDFMergerUtility merger = new PDFMergerUtility();    File file1 = new File(TARGET_PDF_DIR, "PDFBOX-1065-1.pdf");    File file2 = new File(TARGET_PDF_DIR, "PDFBOX-1065-2.pdf");    try (InputStream is1 = new FileInputStream(file1);        InputStream is2 = new FileInputStream(file2)) {        File pdfOutput = new File(OUT_DIR, "PDFBOX-1065.pdf");        merger.setDestinationFileName(pdfOutput.getAbsolutePath());        merger.addSource(is1);        merger.addSource(is2);        merger.mergeDocuments(null);                PDDocument mergedPDF = PDDocument.load(pdfOutput);        assertEquals("There shall be 6 pages", 6, mergedPDF.getNumberOfPages());        PDDocumentNameDestinationDictionary destinations = mergedPDF.getDocumentCatalog().getDests();                        assertEquals("There shall be 12 entries", 12, destinations.getCOSObject().entrySet().size());        List<PDAnnotation> sourceAnnotations01 = mergedPDF.getPage(0).getAnnotations();        List<PDAnnotation> sourceAnnotations02 = mergedPDF.getPage(3).getAnnotations();        List<PDAnnotation> targetAnnotations01 = mergedPDF.getPage(2).getAnnotations();        List<PDAnnotation> targetAnnotations02 = mergedPDF.getPage(5).getAnnotations();                assertEquals("There shall be 3 source annotations at the first page", 3, sourceAnnotations01.size());        assertEquals("There shall be 3 source annotations at the third page", 3, targetAnnotations01.size());        assertTrue("The annotations shall match to each other", testAnnotationsMatch(sourceAnnotations01, targetAnnotations01));                assertEquals("There shall be 3 source annotations at the first page", 3, sourceAnnotations02.size());        assertEquals("There shall be 3 source annotations at the third page", 3, targetAnnotations02.size());        assertTrue("The annotations shall match to each other", testAnnotationsMatch(sourceAnnotations02, targetAnnotations02));        mergedPDF.close();    }}
private boolean pdfbox_f8032_0(List<PDAnnotation> sourceAnnots, List<PDAnnotation> targetAnnots)
{    Map<String, PDAnnotation> targetAnnotsByName = new HashMap<>();    COSName destinationName;        for (PDAnnotation targetAnnot : targetAnnots) {        destinationName = (COSName) targetAnnot.getCOSObject().getDictionaryObject(COSName.DEST);        targetAnnotsByName.put(destinationName.getName(), targetAnnot);    }        for (PDAnnotation sourceAnnot : sourceAnnots) {        destinationName = (COSName) sourceAnnot.getCOSObject().getDictionaryObject(COSName.DEST);        if (targetAnnotsByName.get("annoRef_" + destinationName.getName()) == null) {            return false;        }    }    return true;}
protected void pdfbox_f8033_0() throws Exception
{}
protected void pdfbox_f8034_0() throws Exception
{}
private void pdfbox_f8035_0(PDDocument doc)
{    if (doc != null) {        try {            doc.close();        } catch (Exception e) {        /* Can't do much about this... */        }    }}
public void pdfbox_f8036_0() throws Exception
{    PDDocument sourcePdf = null;    PDDocument result = null;    try {                sourcePdf = PDDocument.load(new File("src/test/resources/input/cweb.pdf"));        PageExtractor instance = new PageExtractor(sourcePdf);        result = instance.extract();        assertEquals(sourcePdf.getNumberOfPages(), result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 1, 1);        result = instance.extract();        assertEquals(1, result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 1, 5);        result = instance.extract();        assertEquals(5, result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 5, 10);        result = instance.extract();        assertEquals(6, result.getNumberOfPages());        closeDoc(result);        instance = new PageExtractor(sourcePdf, 2, 1);        result = instance.extract();        assertEquals(0, result.getNumberOfPages());        closeDoc(result);    } finally {        closeDoc(sourcePdf);        closeDoc(result);    }}
public void pdfbox_f8037_0() throws IOException
{    try (PDDocument srcDoc = new PDDocument();        PDDocument dstDoc = new PDDocument()) {        PDPage pdPage = new PDPage();        srcDoc.addPage(pdPage);        new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, true).close();        new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, true).close();        new PDFCloneUtility(dstDoc).cloneForNewDocument(pdPage.getCOSObject());    }}
public void pdfbox_f8038_0() throws IOException
{    final String TESTDIR = "target/test-output/clone/";    final String CLONESRC = "clone-src.pdf";    final String CLONEDST = "clone-dst.pdf";    new File(TESTDIR).mkdirs();    PDDocument srcDoc = new PDDocument();    PDPage pdPage = new PDPage();    srcDoc.addPage(pdPage);    try (PDPageContentStream pdPageContentStream1 = new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, false)) {        pdPageContentStream1.setNonStrokingColor(Color.black);        pdPageContentStream1.addRect(100, 600, 300, 100);        pdPageContentStream1.fill();    }    try (PDPageContentStream pdPageContentStream2 = new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, false)) {        pdPageContentStream2.setNonStrokingColor(Color.red);        pdPageContentStream2.addRect(100, 500, 300, 100);        pdPageContentStream2.fill();    }    try (PDPageContentStream pdPageContentStream3 = new PDPageContentStream(srcDoc, pdPage, AppendMode.APPEND, false)) {        pdPageContentStream3.setNonStrokingColor(Color.yellow);        pdPageContentStream3.addRect(100, 400, 300, 100);        pdPageContentStream3.fill();    }    srcDoc.save(TESTDIR + CLONESRC);    PDFMergerUtility merger = new PDFMergerUtility();    PDDocument dstDoc = new PDDocument();            merger.appendDocument(dstDoc, srcDoc);        dstDoc.save(TESTDIR + CLONEDST);    PDDocument.load(new File(TESTDIR + CLONESRC)).close();    PDDocument.load(new File(TESTDIR + CLONESRC), (String) null).close();    PDDocument.load(new File(TESTDIR + CLONEDST)).close();    PDDocument.load(new File(TESTDIR + CLONEDST), (String) null).close();}
protected void pdfbox_f8039_0() throws Exception
{    super.setUp();    new File(TARGETTESTDIR).mkdirs();    if (!new File(TARGETTESTDIR).exists()) {        throw new IOException("could not create output directory");    }}
public void pdfbox_f8040_0() throws IOException
{    checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.decoded.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.decoded.pdf", "GlobalResourceMergeTestResult.pdf", MemoryUsageSetting.setupMainMemoryOnly());        checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.decoded.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.decoded.pdf", "GlobalResourceMergeTestResult2.pdf", MemoryUsageSetting.setupTempFileOnly());}
public void pdfbox_f8041_0() throws IOException
{    checkMergeIdentical("jpegrgb.pdf", "multitiff.pdf", "JpegMultiMergeTestResult.pdf", MemoryUsageSetting.setupMainMemoryOnly());        checkMergeIdentical("jpegrgb.pdf", "multitiff.pdf", "JpegMultiMergeTestResult.pdf", MemoryUsageSetting.setupTempFileOnly());}
public void pdfbox_f8042_0() throws IOException
{    checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.pdf", "GlobalResourceMergeTestResult.pdf", MemoryUsageSetting.setupMainMemoryOnly());        checkMergeIdentical("PDFBox.GlobalResourceMergeTest.Doc01.pdf", "PDFBox.GlobalResourceMergeTest.Doc02.pdf", "GlobalResourceMergeTestResult2.pdf", MemoryUsageSetting.setupTempFileOnly());}
public void pdfbox_f8043_0() throws IOException
{    try (PDDocument doc1 = new PDDocument()) {        doc1.addPage(new PDPage());        doc1.addPage(new PDPage());        doc1.addPage(new PDPage());        doc1.save(new File(TARGETTESTDIR, "MergerOpenActionTest1.pdf"));    }    PDPageDestination dest;    try (PDDocument doc2 = new PDDocument()) {        doc2.addPage(new PDPage());        doc2.addPage(new PDPage());        doc2.addPage(new PDPage());        dest = new PDPageFitDestination();        dest.setPage(doc2.getPage(1));        doc2.getDocumentCatalog().setOpenAction(dest);        doc2.save(new File(TARGETTESTDIR, "MergerOpenActionTest2.pdf"));    }    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    pdfMergerUtility.addSource(new File(TARGETTESTDIR, "MergerOpenActionTest1.pdf"));    pdfMergerUtility.addSource(new File(TARGETTESTDIR, "MergerOpenActionTest2.pdf"));    pdfMergerUtility.setDestinationFileName(TARGETTESTDIR + "MergerOpenActionTestResult.pdf");    pdfMergerUtility.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());    try (PDDocument mergedDoc = PDDocument.load(new File(TARGETTESTDIR, "MergerOpenActionTestResult.pdf"))) {        PDDocumentCatalog documentCatalog = mergedDoc.getDocumentCatalog();        dest = (PDPageDestination) documentCatalog.getOpenAction();        assertEquals(4, documentCatalog.getPages().indexOf(dest.getPage()));    }}
public void pdfbox_f8044_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(134, singleCnt);    assertEquals(134, singleSetSize);    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-merged.pdf"));    dst.close();    PDDocument doc = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-merged.pdf"));        elementCounter = new ElementCounter();    elementCounter.walk(doc.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    checkForPageOrphans(doc);    doc.close();}
public void pdfbox_f8045_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    doc.getDocumentCatalog().getAcroForm().flatten();    doc.save(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(doc.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(134, singleCnt);    assertEquals(134, singleSetSize);    doc.close();    PDDocument src = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened.pdf"));    pdfMergerUtility.appendDocument(dst, src);            src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened-merged.pdf"));    dst.close();    doc = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-3999-GeneralForbearance-flattened-merged.pdf"));    checkForPageOrphans(doc);        elementCounter = new ElementCounter();    elementCounter.walk(doc.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    doc.close();}
public void pdfbox_f8046_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(25, singleCnt);    assertEquals(25, singleSetSize);    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4408-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4408-merged.pdf"));        elementCounter = new ElementCounter();    elementCounter.walk(dst.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    checkWithNumberTree(dst);    checkForPageOrphans(dst);    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4408-merged.pdf"));}
public void pdfbox_f8047_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-001031.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    assertEquals(104, singleCnt);    assertEquals(104, singleSetSize);    PDDocument dst = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-001031.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4417-001031-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4417-001031-merged.pdf"));        elementCounter = new ElementCounter();    elementCounter.walk(dst.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    checkWithNumberTree(dst);    checkForPageOrphans(dst);    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4417-001031-merged.pdf"));}
public void pdfbox_f8048_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-054080.pdf"));    ElementCounter elementCounter = new ElementCounter();    elementCounter.walk(src.getDocumentCatalog().getStructureTreeRoot().getK());    int singleCnt = elementCounter.cnt;    int singleSetSize = elementCounter.set.size();    PDDocument dst = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-054080.pdf"));    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4417-054080-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4417-054080-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);        elementCounter = new ElementCounter();    elementCounter.walk(dst.getDocumentCatalog().getStructureTreeRoot().getK());    assertEquals(singleCnt * 2, elementCounter.cnt);    assertEquals(singleSetSize * 2, elementCounter.set.size());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4417-054080-merged.pdf"));}
public void pdfbox_f8049_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000671.pdf"));    PDStructureTreeRoot structureTreeRoot = src.getDocumentCatalog().getStructureTreeRoot();    PDNumberTreeNode parentTree = structureTreeRoot.getParentTree();    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(381, numberTreeAsMap.size());    assertEquals(743, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(0, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(743, structureTreeRoot.getParentTreeNextKey());    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000314.pdf"));    structureTreeRoot = dst.getDocumentCatalog().getStructureTreeRoot();    parentTree = structureTreeRoot.getParentTree();    numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(7, numberTreeAsMap.size());    assertEquals(328, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(321, (int) Collections.min(numberTreeAsMap.keySet()));        assertEquals(408, structureTreeRoot.getParentTreeNextKey());    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4418-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4418-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);    structureTreeRoot = dst.getDocumentCatalog().getStructureTreeRoot();    parentTree = structureTreeRoot.getParentTree();    numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(381 + 7, numberTreeAsMap.size());    assertEquals(408 + 743, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(321, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(408 + 743, structureTreeRoot.getParentTreeNextKey());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4418-merged.pdf"));}
public void pdfbox_f8050_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4423-000746.pdf"));    PDStructureTreeRoot structureTreeRoot = src.getDocumentCatalog().getStructureTreeRoot();    PDNumberTreeNode parentTree = structureTreeRoot.getParentTree();    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(33, numberTreeAsMap.size());    assertEquals(64, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(31, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(126, structureTreeRoot.getParentTreeNextKey());    PDDocument dst = new PDDocument();    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4423-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4423-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);    structureTreeRoot = dst.getDocumentCatalog().getStructureTreeRoot();    parentTree = structureTreeRoot.getParentTree();    numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(33, numberTreeAsMap.size());    assertEquals(64, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(31, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(64, structureTreeRoot.getParentTreeNextKey());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4423-merged.pdf"));}
public void pdfbox_f8051_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000314.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4418-000314.pdf"));                        dst.getDocumentCatalog().getStructureTreeRoot().getCOSObject().removeItem(COSName.PARENT_TREE_NEXT_KEY);    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4418-000314-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4418-000314-merged.pdf"));    assertEquals(656, dst.getDocumentCatalog().getStructureTreeRoot().getParentTreeNextKey());    dst.close();}
public void pdfbox_f8052_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-001031.pdf"));    PDDocument dst = PDDocument.load(new File(SRCDIR, "PDFBOX-4417-054080.pdf"));    PDNameTreeNode<PDStructureElement> srcIDTree = src.getDocumentCatalog().getStructureTreeRoot().getIDTree();    Map<String, PDStructureElement> srcIDTreeMap = PDFMergerUtility.getIDTreeAsMap(srcIDTree);    PDNameTreeNode<PDStructureElement> dstIDTree = dst.getDocumentCatalog().getStructureTreeRoot().getIDTree();    Map<String, PDStructureElement> dstIDTreeMap = PDFMergerUtility.getIDTreeAsMap(dstIDTree);    int expectedTotal = srcIDTreeMap.size() + dstIDTreeMap.size();    assertEquals(192, expectedTotal);            PDDocument emptyDest = new PDDocument();    pdfMergerUtility.appendDocument(emptyDest, src);    src.close();    src = emptyDest;    assertEquals(4, src.getDocumentCatalog().getStructureTreeRoot().getParentTreeNextKey());    pdfMergerUtility.appendDocument(dst, src);    src.close();    dst.save(new File(TARGETTESTDIR, "PDFBOX-4416-IDTree-merged.pdf"));    dst.close();    dst = PDDocument.load(new File(TARGETTESTDIR, "PDFBOX-4416-IDTree-merged.pdf"));    checkWithNumberTree(dst);    checkForPageOrphans(dst);    dstIDTree = dst.getDocumentCatalog().getStructureTreeRoot().getIDTree();    dstIDTreeMap = PDFMergerUtility.getIDTreeAsMap(dstIDTree);    assertEquals(expectedTotal, dstIDTreeMap.size());    dst.close();    checkStructTreeRootCount(new File(TARGETTESTDIR, "PDFBOX-4416-IDTree-merged.pdf"));}
public void pdfbox_f8053_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    dst.getDocumentCatalog().setStructureTreeRoot(null);    dst.getPage(0).setStructParents(9999);    dst.getPage(0).getAnnotations().get(0).setStructParent(9998);    pdfMergerUtility.appendDocument(dst, src);    checkWithNumberTree(dst);    checkForPageOrphans(dst);    src.close();    dst.close();}
public void pdfbox_f8054_0() throws IOException
{    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    PDDocument src = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    PDDocument dst = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4408.pdf"));    src.getDocumentCatalog().setStructureTreeRoot(null);    src.getPage(0).setStructParents(9999);    src.getPage(0).getAnnotations().get(0).setStructParent(9998);    pdfMergerUtility.appendDocument(dst, src);    checkWithNumberTree(dst);    checkForPageOrphans(dst);    src.close();    dst.close();}
public void pdfbox_f8055_0() throws IOException
{    PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3999-GeneralForbearance.pdf"));    PDStructureTreeRoot structureTreeRoot = doc.getDocumentCatalog().getStructureTreeRoot();    PDNumberTreeNode parentTree = structureTreeRoot.getParentTree();    parentTree.getValue(0);    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    assertEquals(31, numberTreeAsMap.size());    assertEquals(31, Collections.max(numberTreeAsMap.keySet()) + 1);    assertEquals(0, (int) Collections.min(numberTreeAsMap.keySet()));    assertEquals(31, structureTreeRoot.getParentTreeNextKey());    doc.close();}
private void pdfbox_f8056_0(File file) throws IOException
{    int count = 0;    try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file)))) {        String line;        while ((line = br.readLine()) != null) {            if (line.equals("/Type /StructTreeRoot")) {                ++count;            }        }    }    assertEquals(1, count);}
 void pdfbox_f8057_0(PDDocument document) throws IOException
{    PDDocumentCatalog documentCatalog = document.getDocumentCatalog();    PDNumberTreeNode parentTree = documentCatalog.getStructureTreeRoot().getParentTree();    Map<Integer, COSObjectable> numberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(parentTree);    Set<Integer> keySet = numberTreeAsMap.keySet();    PDAcroForm acroForm = documentCatalog.getAcroForm();    if (acroForm != null) {        for (PDField field : acroForm.getFieldTree()) {            for (PDAnnotationWidget widget : field.getWidgets()) {                if (widget.getStructParent() >= 0) {                    assertTrue("field '" + field.getFullyQualifiedName() + "' /StructParent " + widget.getStructParent() + " missing in /ParentTree", keySet.contains(widget.getStructParent()));                }            }        }    }    for (PDPage page : document.getPages()) {        if (page.getStructParents() >= 0) {            assertTrue(keySet.contains(page.getStructParents()));        }        for (PDAnnotation ann : page.getAnnotations()) {            if (ann.getStructParent() >= 0) {                assertTrue("/StructParent " + ann.getStructParent() + " missing in /ParentTree", keySet.contains(ann.getStructParent()));            }        }    }}
public void pdfbox_f8058_0() throws IOException
{    File outFile = new File(TARGETTESTDIR, "PDFBOX-4383-result.pdf");    File inFile1 = new File(TARGETTESTDIR, "PDFBOX-4383-src1.pdf");    File inFile2 = new File(TARGETTESTDIR, "PDFBOX-4383-src2.pdf");    createSimpleFile(inFile1);    createSimpleFile(inFile2);    try (OutputStream out = new FileOutputStream(outFile)) {        PDFMergerUtility merger = new PDFMergerUtility();        merger.setDestinationStream(out);        merger.addSource(inFile1);        merger.addSource(inFile2);        merger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());    }    Files.delete(inFile1.toPath());    Files.delete(inFile2.toPath());    Files.delete(outFile.toPath());}
private void pdfbox_f8059_0(PDDocument doc) throws IOException
{            PDPageTree pageTree = doc.getPages();    PDStructureTreeRoot structureTreeRoot = doc.getDocumentCatalog().getStructureTreeRoot();    checkElement(pageTree, structureTreeRoot.getParentTree().getCOSObject());    checkElement(pageTree, structureTreeRoot.getK());    checkForIDTreeOrphans(pageTree, structureTreeRoot);}
private void pdfbox_f8060_0(PDPageTree pageTree, PDStructureTreeRoot structureTreeRoot) throws IOException
{    PDNameTreeNode<PDStructureElement> idTree = structureTreeRoot.getIDTree();    if (idTree == null) {        return;    }    Map<String, PDStructureElement> map = PDFMergerUtility.getIDTreeAsMap(idTree);    for (PDStructureElement element : map.values()) {        if (element.getPage() != null) {            checkForPage(pageTree, element);        }        if (!element.getKids().isEmpty()) {            checkElement(pageTree, element.getCOSObject().getDictionaryObject(COSName.K));        }    }}
private void pdfbox_f8061_0(File file) throws IOException
{    try (PDDocument doc = new PDDocument()) {        doc.addPage(new PDPage());        doc.save(file);    }}
 void pdfbox_f8062_0(COSBase base)
{    if (base instanceof COSArray) {        for (COSBase base2 : (COSArray) base) {            if (base2 instanceof COSObject) {                base2 = ((COSObject) base2).getObject();            }            walk(base2);        }    } else if (base instanceof COSDictionary) {        COSDictionary kdict = (COSDictionary) base;        if (kdict.containsKey(COSName.PG)) {            ++cnt;            set.add(kdict);        }        if (kdict.containsKey(COSName.K)) {            walk(kdict.getDictionaryObject(COSName.K));        }    }}
private void pdfbox_f8063_0(PDPageTree pageTree, COSBase base) throws IOException
{    if (base instanceof COSArray) {        for (COSBase base2 : (COSArray) base) {            if (base2 instanceof COSObject) {                base2 = ((COSObject) base2).getObject();            }            checkElement(pageTree, base2);        }    } else if (base instanceof COSDictionary) {        COSDictionary kdict = (COSDictionary) base;        if (kdict.containsKey(COSName.PG)) {            PDStructureElement structureElement = new PDStructureElement(kdict);            checkForPage(pageTree, structureElement);        }        if (kdict.containsKey(COSName.K)) {            checkElement(pageTree, kdict.getDictionaryObject(COSName.K));            return;        }                if (kdict.containsKey(COSName.KIDS)) {            checkElement(pageTree, kdict.getDictionaryObject(COSName.KIDS));        } else if (kdict.containsKey(COSName.NUMS)) {            checkElement(pageTree, kdict.getDictionaryObject(COSName.NUMS));        }                if (kdict.containsKey(COSName.OBJ)) {            COSDictionary obj = (COSDictionary) kdict.getDictionaryObject(COSName.OBJ);            COSBase type = obj.getDictionaryObject(COSName.TYPE);            if (COSName.ANNOT.equals(type)) {                PDAnnotation annotation = PDAnnotation.createAnnotation(obj);                PDPage page = annotation.getPage();                if (page != null) {                    if (pageTree.indexOf(page) == -1) {                        COSBase item = kdict.getItem(COSName.OBJ);                        if (item instanceof COSObject) {                            assertTrue("Annotation page is not in the page tree: " + item, pageTree.indexOf(page) != -1);                        } else {                                                        assertTrue("Annotation page is not in the page tree", pageTree.indexOf(page) != -1);                        }                    }                }            } else {                                                fail("Other type: " + type);            }        }    }}
private void pdfbox_f8064_0(String filename1, String filename2, String mergeFilename, MemoryUsageSetting memUsageSetting) throws IOException
{    int src1PageCount;    BufferedImage[] src1ImageTab;    try (PDDocument srcDoc1 = PDDocument.load(new File(SRCDIR, filename1), (String) null)) {        src1PageCount = srcDoc1.getNumberOfPages();        PDFRenderer src1PdfRenderer = new PDFRenderer(srcDoc1);        src1ImageTab = new BufferedImage[src1PageCount];        for (int page = 0; page < src1PageCount; ++page) {            src1ImageTab[page] = src1PdfRenderer.renderImageWithDPI(page, DPI);        }    }    int src2PageCount;    BufferedImage[] src2ImageTab;    try (PDDocument srcDoc2 = PDDocument.load(new File(SRCDIR, filename2), (String) null)) {        src2PageCount = srcDoc2.getNumberOfPages();        PDFRenderer src2PdfRenderer = new PDFRenderer(srcDoc2);        src2ImageTab = new BufferedImage[src2PageCount];        for (int page = 0; page < src2PageCount; ++page) {            src2ImageTab[page] = src2PdfRenderer.renderImageWithDPI(page, DPI);        }    }    PDFMergerUtility pdfMergerUtility = new PDFMergerUtility();    pdfMergerUtility.addSource(new File(SRCDIR, filename1));    pdfMergerUtility.addSource(new File(SRCDIR, filename2));    pdfMergerUtility.setDestinationFileName(TARGETTESTDIR + mergeFilename);    pdfMergerUtility.mergeDocuments(memUsageSetting);    try (PDDocument mergedDoc = PDDocument.load(new File(TARGETTESTDIR, mergeFilename), (String) null)) {        PDFRenderer mergePdfRenderer = new PDFRenderer(mergedDoc);        int mergePageCount = mergedDoc.getNumberOfPages();        assertEquals(src1PageCount + src2PageCount, mergePageCount);        for (int page = 0; page < src1PageCount; ++page) {            BufferedImage bim = mergePdfRenderer.renderImageWithDPI(page, DPI);            checkImagesIdentical(bim, src1ImageTab[page]);        }        for (int page = 0; page < src2PageCount; ++page) {            int mergePage = page + src1PageCount;            BufferedImage bim = mergePdfRenderer.renderImageWithDPI(mergePage, DPI);            checkImagesIdentical(bim, src2ImageTab[page]);        }    }}
private void pdfbox_f8065_0(BufferedImage bim1, BufferedImage bim2)
{    assertEquals(bim1.getHeight(), bim2.getHeight());    assertEquals(bim1.getWidth(), bim2.getWidth());    int w = bim1.getWidth();    int h = bim1.getHeight();    for (int i = 0; i < w; ++i) {        for (int j = 0; j < h; ++j) {            assertEquals(bim1.getRGB(i, j), bim2.getRGB(i, j));        }    }}
private void pdfbox_f8066_0(PDPageTree pageTree, PDStructureElement structureElement)
{    PDPage page = structureElement.getPage();    if (page != null) {        assertTrue("Page is not in the page tree", pageTree.indexOf(page) != -1);    }}
protected void pdfbox_f8067_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8068_0() throws Exception
{    File mainPDF = createMainPDF();    File overlay1 = createOverlay1();    File targetFile = new File(testResultsDir, "text-with-form-overlay.pdf");    try (PDDocument targetDoc = PDDocument.load(mainPDF);        PDDocument overlay1Doc = PDDocument.load(overlay1)) {        LayerUtility layerUtil = new LayerUtility(targetDoc);        PDFormXObject form = layerUtil.importPageAsForm(overlay1Doc, 0);        PDPage targetPage = targetDoc.getPage(0);        layerUtil.wrapInSaveRestore(targetPage);        AffineTransform at = new AffineTransform();        layerUtil.appendFormAsLayer(targetPage, form, at, "overlay");        targetDoc.save(targetFile.getAbsolutePath());    }    try (PDDocument doc = PDDocument.load(targetFile)) {        PDDocumentCatalog catalog = doc.getDocumentCatalog();                assertEquals(1.5f, doc.getVersion());        PDPage page = doc.getPage(0);        PDOptionalContentGroup ocg = (PDOptionalContentGroup) page.getResources().getProperties(COSName.getPDFName("oc1"));        assertNotNull(ocg);        assertEquals("overlay", ocg.getName());        PDOptionalContentProperties ocgs = catalog.getOCProperties();        PDOptionalContentGroup overlay = ocgs.getGroup("overlay");        assertEquals(ocg.getName(), overlay.getName());    }}
private File pdfbox_f8069_0() throws IOException
{    File targetFile = new File(testResultsDir, "text-doc.pdf");    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }        final String[] text = new String[] { "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer fermentum lacus in eros", "condimentum eget tristique risus viverra. Sed ac sem et lectus ultrices placerat. Nam", "fringilla tincidunt nulla id euismod. Vivamus eget mauris dui. Mauris luctus ullamcorper", "leo, et laoreet diam suscipit et. Nulla viverra commodo sagittis. Integer vitae rhoncus velit.", "Mauris porttitor ipsum in est sagittis non luctus purus molestie. Sed placerat aliquet", "vulputate." };        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                        PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginText();            contentStream.newLineAtOffset(50, 720);            contentStream.setFont(font, 14);            contentStream.showText("Simple test document with text.");            contentStream.endText();            font = PDType1Font.HELVETICA;            contentStream.beginText();            int fontSize = 12;            contentStream.setFont(font, fontSize);            contentStream.newLineAtOffset(50, 700);            for (String line : text) {                contentStream.newLineAtOffset(0, -fontSize * 1.2f);                contentStream.showText(line);            }            contentStream.endText();        }        doc.save(targetFile.getAbsolutePath());    }    return targetFile;}
private File pdfbox_f8070_0() throws IOException
{    File targetFile = new File(testResultsDir, "overlay1.pdf");    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                        PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.setNonStrokingColor(Color.LIGHT_GRAY);            contentStream.beginText();            float fontSize = 96;            contentStream.setFont(font, fontSize);            String text = "OVERLAY";                                    PDRectangle crop = page.getCropBox();            float cx = crop.getWidth() / 2f;            float cy = crop.getHeight() / 2f;            Matrix transform = new Matrix();            transform.translate(cx, cy);            transform.rotate(Math.toRadians(45));            transform.translate(-190, /* sw/2 */            0);            contentStream.setTextMatrix(transform);            contentStream.showText(text);            contentStream.endText();        }        doc.save(targetFile.getAbsolutePath());    }    return targetFile;}
public void pdfbox_f8071_0()
{    executorService.shutdown();    try {        executorService.awaitTermination(timeoutSeconds, TimeUnit.SECONDS);    } catch (InterruptedException exc) {        throw new RuntimeException(exc);    }}
public void pdfbox_f8072_0(Runnable childStatement)
{    executorService.submit(childStatement);}
public void pdfbox_f8073_0() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    EndstreamOutputStream feos = new EndstreamOutputStream(baos);    byte[] tab1 = { 1, 2, 3, 4 };    byte[] tab2 = { 5, 6, 7, '\r', '\n' };    byte[] tab3 = { 8, 9, '\r', '\n' };    feos.write(tab1, 0, tab1.length);    feos.write(tab2, 0, tab2.length);    feos.write(tab3, 0, tab3.length);    feos.flush();    byte[] expectedResult1 = { 1, 2, 3, 4, 5, 6, 7, '\r', '\n', 8, 9 };    Assert.assertArrayEquals(expectedResult1, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab4 = { 1, 2, 3, 4 };    byte[] tab5 = { 5, 6, 7, '\r' };    byte[] tab6 = { 8, 9, '\n' };    feos.write(tab4, 0, tab4.length);    feos.write(tab5, 0, tab5.length);    feos.write(tab6, 0, tab6.length);    feos.flush();    byte[] expectedResult2 = { 1, 2, 3, 4, 5, 6, 7, '\r', 8, 9 };    Assert.assertArrayEquals(expectedResult2, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab7 = { 1, 2, 3, 4, '\r' };    byte[] tab8 = { '\n', 5, 6, 7, '\n' };        byte[] tab9 = { 8, 9, '\r' };    feos.write(tab7, 0, tab7.length);    feos.write(tab8, 0, tab8.length);    feos.write(tab9, 0, tab9.length);    feos.flush();    byte[] expectedResult3 = { 1, 2, 3, 4, '\r', '\n', 5, 6, 7, '\n', 8, 9, '\r' };    Assert.assertArrayEquals(expectedResult3, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab10 = { 1, 2, 3, 4, '\r' };    byte[] tab11 = { '\n', 5, 6, 7, '\r' };    byte[] tab12 = { 8, 9, '\r' };        byte[] tab13 = { '\n' };    feos.write(tab10, 0, tab10.length);    feos.write(tab11, 0, tab11.length);    feos.write(tab12, 0, tab12.length);    feos.write(tab13, 0, tab13.length);    feos.flush();    byte[] expectedResult4 = { 1, 2, 3, 4, '\r', '\n', 5, 6, 7, '\r', 8, 9 };    Assert.assertArrayEquals(expectedResult4, baos.toByteArray());    baos = new ByteArrayOutputStream();    feos = new EndstreamOutputStream(baos);    byte[] tab14 = { 1, 2, 3, 4, '\r' };    byte[] tab15 = { '\n', 5, 6, 7, '\r' };    byte[] tab16 = { 8, 9, '\n' };        byte[] tab17 = { '\r' };    feos.write(tab14, 0, tab14.length);    feos.write(tab15, 0, tab15.length);    feos.write(tab16, 0, tab16.length);    feos.write(tab17, 0, tab17.length);    feos.flush();    byte[] expectedResult5 = { 1, 2, 3, 4, '\r', '\n', 5, 6, 7, '\r', 8, 9, '\n', '\r' };    Assert.assertArrayEquals(expectedResult5, baos.toByteArray());}
public void pdfbox_f8074_0() throws IOException
{        try (PDDocument doc = PDDocument.load(new File("src/test/resources/org/apache/pdfbox/pdfparser", "embedded_zip.pdf"))) {        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDDocumentNameDictionary names = catalog.getNames();        PDEmbeddedFilesNameTreeNode node = names.getEmbeddedFiles();        Map<String, PDComplexFileSpecification> map = node.getNames();        Assert.assertEquals(1, map.size());        PDComplexFileSpecification spec = map.get("My first attachment");        PDEmbeddedFile file = spec.getEmbeddedFile();        InputStream input = file.createInputStream();        File d = new File("target/test-output");        d.mkdirs();        File f = new File(d, spec.getFile());        try (OutputStream os = new FileOutputStream(f)) {            IOUtils.copy(input, os);        }        Assert.assertEquals(17660, f.length());    }}
public void pdfbox_f8075_0() throws IOException
{    testInlineImage2ops("ID\n12345EI Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI EMC", "12345", "EMC");    testInlineImage2ops("ID\n12345EI Q ", "12345", "Q");    testInlineImage2ops("ID\n12345EI EMC ", "12345", "EMC");    testInlineImage2ops("ID\n12345EI  Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI  EMC", "12345", "EMC");    testInlineImage2ops("ID\n12345EI  Q ", "12345", "Q");    testInlineImage2ops("ID\n12345EI  EMC ", "12345", "EMC");    testInlineImage2ops("ID\n12345EI \000Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI Q                             ", "12345", "Q");    testInlineImage2ops("ID\n12345EI EMC                           ", "12345", "EMC");    testInlineImage1op("ID\n12345EI", "12345");    testInlineImage1op("ID\n12345EI                               ", "12345");    testInlineImage2ops("ID\n12345EI                               Q ", "12345", "Q");    testInlineImage2ops("ID\n12345EI                               EMC ", "12345", "EMC");    testInlineImage2ops("ID\n12345EI                               Q", "12345", "Q");    testInlineImage2ops("ID\n12345EI                               EMC", "12345", "EMC");    testInlineImage1op("ID\n12EI5EI", "12EI5");    testInlineImage1op("ID\n12EI5EI ", "12EI5");    testInlineImage1op("ID\n12EI5EIQEI", "12EI5EIQ");    testInlineImage2ops("ID\n12EI5EIQEI Q", "12EI5EIQ", "Q");    testInlineImage2ops("ID\n12EI5EI Q", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI Q ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI EMC", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI                                Q", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI                                Q ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI                                EMC", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI                                EMC ", "12EI5", "EMC");            testInlineImage2ops("ID\n12EI5EI       EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI        EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI         EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI          EMC ", "12EI5", "EMC");    testInlineImage2ops("ID\n12EI5EI       Q   ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI        Q   ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI         Q   ", "12EI5", "Q");    testInlineImage2ops("ID\n12EI5EI          Q   ", "12EI5", "Q");}
private void pdfbox_f8076_0(String s, String imageDataString, String opName) throws IOException
{    List<Object> tokens = parseTokenString(s);    assertEquals(2, tokens.size());    assertEquals(OperatorName.BEGIN_INLINE_IMAGE_DATA, ((Operator) tokens.get(0)).getName());    assertEquals(imageDataString.length(), ((Operator) tokens.get(0)).getImageData().length);    assertArrayEquals(imageDataString.getBytes(), ((Operator) tokens.get(0)).getImageData());    assertEquals(opName, ((Operator) tokens.get(1)).getName());}
private void pdfbox_f8077_0(String s, String imageDataString) throws IOException
{    List<Object> tokens = parseTokenString(s);    assertEquals(1, tokens.size());    assertEquals(OperatorName.BEGIN_INLINE_IMAGE_DATA, ((Operator) tokens.get(0)).getName());    assertEquals(imageDataString.length(), ((Operator) tokens.get(0)).getImageData().length);    assertArrayEquals(imageDataString.getBytes(), ((Operator) tokens.get(0)).getImageData());}
private List<Object> pdfbox_f8078_0(String s) throws IOException
{    PDFStreamParser pdfStreamParser = new PDFStreamParser(s.getBytes());    pdfStreamParser.parse();    return pdfStreamParser.getTokens();}
public void pdfbox_f8079_0() throws Exception
{    numberOfTmpFiles = getNumberOfTempFile();}
private int pdfbox_f8080_0()
{    int result = 0;    File[] tmpPdfs = tmpDirectory.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.startsWith(COSParser.TMP_FILE_PREFIX) && name.endsWith("pdf");        }    });    if (tmpPdfs != null) {        result = tmpPdfs.length;    }    return result;}
public boolean pdfbox_f8081_0(File dir, String name)
{    return name.startsWith(COSParser.TMP_FILE_PREFIX) && name.endsWith("pdf");}
public void pdfbox_f8082_0() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new File(PATH_OF_PDF)), MemoryUsageSetting.setupMainMemoryOnly());}
public void pdfbox_f8083_0() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new FileInputStream(PATH_OF_PDF)), MemoryUsageSetting.setupMainMemoryOnly());}
public void pdfbox_f8084_0() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new File(PATH_OF_PDF)), MemoryUsageSetting.setupTempFileOnly());}
public void pdfbox_f8085_0() throws IOException
{    executeParserTest(new RandomAccessBufferedFileInputStream(new FileInputStream(PATH_OF_PDF)), MemoryUsageSetting.setupTempFileOnly());}
public void pdfbox_f8086_0() throws IOException, URISyntaxException
{        PDDocument.load(new File(TestPDFParser.class.getResource("MissingCatalog.pdf").toURI())).close();}
public void pdfbox_f8087_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3208-L33MUTT2SVCWGCS6UIYL5TH3PNPXHIS6.pdf"))) {        PDDocumentInformation di = doc.getDocumentInformation();        assertEquals("Liquent Enterprise Services", di.getAuthor());        assertEquals("Liquent services server", di.getCreator());        assertEquals("Amyuni PDF Converter version 4.0.0.9", di.getProducer());        assertEquals("", di.getKeywords());        assertEquals("", di.getSubject());        assertEquals("892B77DE781B4E71A1BEFB81A51A5ABC_20140326022424.docx", di.getTitle());        assertEquals(DateConverter.toCalendar("D:20140326142505-02'00'"), di.getCreationDate());        assertEquals(DateConverter.toCalendar("20140326172513Z"), di.getModificationDate());    }}
public void pdfbox_f8088_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3940-079977.pdf"))) {        PDDocumentInformation di = doc.getDocumentInformation();        assertEquals("Unknown", di.getAuthor());        assertEquals("C:REGULA~1IREGSFR_EQ_EM.WP", di.getCreator());        assertEquals("Acrobat PDFWriter 3.02 for Windows", di.getProducer());        assertEquals("", di.getKeywords());        assertEquals("", di.getSubject());        assertEquals("C:REGULA~1IREGSFR_EQ_EM.PDF", di.getTitle());        assertEquals(DateConverter.toCalendar("Tuesday, July 28, 1998 4:00:09 PM"), di.getCreationDate());    }}
public void pdfbox_f8089_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3783-72GLBIGUC6LB46ELZFBARRJTLN4RBSQM.pdf")).close();}
public void pdfbox_f8090_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3785-202097.pdf"))) {        assertEquals(11, doc.getNumberOfPages());    }}
public void pdfbox_f8091_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3947-670064.pdf")).close();}
public void pdfbox_f8092_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3948-EUWO6SQS5TM4VGOMRD3FLXZHU35V2CP2.pdf")).close();}
public void pdfbox_f8093_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3949-MKFYUGZWS3OPXLLVU2Z4LWCTVA5WNOGF.pdf")).close();}
public void pdfbox_f8094_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3950-23EGDHXSBBYQLKYOKGZUOVYVNE675PRD.pdf"))) {        assertEquals(4, doc.getNumberOfPages());        PDFRenderer renderer = new PDFRenderer(doc);        for (int i = 0; i < doc.getNumberOfPages(); ++i) {            try {                renderer.renderImage(i);            } catch (IOException ex) {                if (i == 3 && ex.getMessage().equals("Missing descendant font array")) {                    continue;                }                throw ex;            }        }    }}
public void pdfbox_f8095_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3951-FIHUZWDDL2VGPOE34N6YHWSIGSH5LVGZ.pdf"))) {        assertEquals(143, doc.getNumberOfPages());    }}
public void pdfbox_f8096_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3964-c687766d68ac766be3f02aaec5e0d713_2.pdf"))) {        assertEquals(10, doc.getNumberOfPages());    }}
public void pdfbox_f8097_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-3977-63NGFQRI44HQNPIPEJH5W2TBM6DJZWMI.pdf"))) {        PDDocumentInformation di = doc.getDocumentInformation();        assertEquals("QuarkXPress(tm) 6.52", di.getCreator());        assertEquals("Acrobat Distiller 7.0 pour Macintosh", di.getProducer());        assertEquals("Fich sal Fabr corr1 (Page 6)", di.getTitle());        assertEquals(DateConverter.toCalendar("D:20070608151915+02'00'"), di.getCreationDate());        assertEquals(DateConverter.toCalendar("D:20080604152122+02'00'"), di.getModificationDate());    }}
public void pdfbox_f8098_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "genko_oc_shiryo1.pdf")).close();}
public void pdfbox_f8099_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4338.pdf")).close();}
public void pdfbox_f8100_0() throws IOException
{    PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4339.pdf")).close();}
private void pdfbox_f8101_0(RandomAccessRead source, MemoryUsageSetting memUsageSetting) throws IOException
{    ScratchFile scratchFile = new ScratchFile(memUsageSetting);    PDFParser pdfParser = new PDFParser(source, scratchFile);    pdfParser.parse();    try (COSDocument doc = pdfParser.getDocument()) {        assertNotNull(doc);    }    source.close();        assertEquals(numberOfTmpFiles, getNumberOfTempFile());}
public void pdfbox_f8102_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        doc.save(new BufferedOutputStream(new ByteArrayOutputStream(1024) {            private boolean open = true;            @Override            public void close() throws IOException {                                open = false;                super.close();            }            @Override            public void flush() throws IOException {                if (!open) {                    throw new IOException("Stream already closed");                }                        }        }));    }}
public void pdfbox_f8103_0() throws IOException
{        open = false;    super.close();}
public void pdfbox_f8104_0() throws IOException
{    if (!open) {        throw new IOException("Stream already closed");    }}
public void pdfbox_f8105_0()
{        final COSWriterXRefEntry objectUnderTest = new COSWriterXRefEntry(0L, null, null);    final COSWriterXRefEntry obj = null;        final int retval = objectUnderTest.compareTo(obj);        Assert.assertEquals(-1, retval);}
public static void pdfbox_f8106_0(String[] args)
{    String[] arg = { TestFunctions.class.getName() };    junit.textui.TestRunner.main(arg);}
public static Test pdfbox_f8107_0()
{    TestSuite suite = new TestSuite(TestFunctions.class.getName());    suite.addTestSuite(TestOperators.class);    suite.addTestSuite(TestParser.class);    suite.addTestSuite(TestPDFunctionType4.class);    return suite;}
private PDFunctionType4 pdfbox_f8108_0(String function, float[] domain, float[] range) throws IOException
{    COSStream stream = new COSStream();    stream.setInt("FunctionType", 4);    COSArray domainArray = new COSArray();    domainArray.setFloatArray(domain);    stream.setItem("Domain", domainArray);    COSArray rangeArray = new COSArray();    rangeArray.setFloatArray(range);    stream.setItem("Range", rangeArray);    try (OutputStream out = stream.createOutputStream()) {        byte[] data = function.getBytes("US-ASCII");        out.write(data, 0, data.length);    }    return new PDFunctionType4(stream);}
public void pdfbox_f8109_0() throws Exception
{    String functionText = "{ add }";        PDFunctionType4 function = createFunction(functionText, new float[] { -1.0f, 1.0f, -1.0f, 1.0f }, new float[] { -1.0f, 1.0f });    float[] input = new float[] { 0.8f, 0.1f };    float[] output = function.eval(input);    assertEquals(1, output.length);    assertEquals(0.9f, output[0], 0.0001f);        input = new float[] { 0.8f, 0.3f };    output = function.eval(input);    assertEquals(1, output.length);    assertEquals(1f, output[0]);        input = new float[] { 0.8f, 1.2f };    output = function.eval(input);    assertEquals(1, output.length);    assertEquals(1f, output[0]);}
public void pdfbox_f8110_0() throws Exception
{    String functionText = "{ pop }";        PDFunctionType4 function = createFunction(functionText, new float[] { -1.0f, 1.0f, -1.0f, 1.0f }, new float[] { -1.0f, 1.0f });    float[] input = new float[] { -0.7f, 0.0f };    float[] output = function.eval(input);    assertEquals(1, output.length);    assertEquals(-0.7f, output[0], 0.0001f);}
public void pdfbox_f8111_0() throws Exception
{    Type4Tester.create("5 6 add").pop(11).isEmpty();    Type4Tester.create("5 0.23 add").pop(5.23f).isEmpty();    int bigValue = Integer.MAX_VALUE - 2;    ExecutionContext context = Type4Tester.create(bigValue + " " + bigValue + " add").toExecutionContext();    float floatResult = (Float) context.getStack().pop();    assertEquals(2 * (long) Integer.MAX_VALUE - 4, floatResult, 1);    assertTrue(context.getStack().isEmpty());}
public void pdfbox_f8112_0() throws Exception
{    Type4Tester.create("-3 abs 2.1 abs -2.1 abs -7.5 abs").pop(7.5f).pop(2.1f).pop(2.1f).pop(3).isEmpty();}
public void pdfbox_f8113_0() throws Exception
{    Type4Tester.create("true true and true false and").pop(false).pop(true).isEmpty();    Type4Tester.create("99 1 and 52 7 and").pop(4).pop(1).isEmpty();}
public void pdfbox_f8114_0() throws Exception
{    Type4Tester.create("0 1 atan").pop(0f).isEmpty();    Type4Tester.create("1 0 atan").pop(90f).isEmpty();    Type4Tester.create("-100 0 atan").pop(270f).isEmpty();    Type4Tester.create("4 4 atan").pop(45f).isEmpty();}
public void pdfbox_f8115_0() throws Exception
{    Type4Tester.create("3.2 ceiling -4.8 ceiling 99 ceiling").pop(99).pop(-4f).pop(4f).isEmpty();}
public void pdfbox_f8116_0() throws Exception
{    Type4Tester.create("0 cos").popReal(1f).isEmpty();    Type4Tester.create("90 cos").popReal(0f).isEmpty();}
public void pdfbox_f8117_0() throws Exception
{    Type4Tester.create("-47.8 cvi").pop(-47).isEmpty();    Type4Tester.create("520.9 cvi").pop(520).isEmpty();}
public void pdfbox_f8118_0() throws Exception
{    Type4Tester.create("-47.8 cvr").popReal(-47.8f).isEmpty();    Type4Tester.create("520.9 cvr").popReal(520.9f).isEmpty();    Type4Tester.create("77 cvr").popReal(77f).isEmpty();        ExecutionContext context = Type4Tester.create("77 77 cvr").toExecutionContext();    Assert.assertTrue("Expected a real as the result of 'cvr'", context.getStack().pop() instanceof Float);    Assert.assertTrue("Expected an int from an integer literal", context.getStack().pop() instanceof Integer);}
public void pdfbox_f8119_0() throws Exception
{    Type4Tester.create("3 2 div").popReal(1.5f).isEmpty();    Type4Tester.create("4 2 div").popReal(2.0f).isEmpty();}
public void pdfbox_f8120_0() throws Exception
{    Type4Tester.create("9 0.5 exp").popReal(3.0f).isEmpty();    Type4Tester.create("-9 -1 exp").popReal(-0.111111f, 0.000001).isEmpty();}
public void pdfbox_f8121_0() throws Exception
{    Type4Tester.create("3.2 floor -4.8 floor 99 floor").pop(99).pop(-5f).pop(3f).isEmpty();}
public void pdfbox_f8122_0() throws Exception
{    Type4Tester.create("3 2 idiv").pop(1).isEmpty();    Type4Tester.create("4 2 idiv").pop(2).isEmpty();    Type4Tester.create("-5 2 idiv").pop(-2).isEmpty();    try {        Type4Tester.create("4.4 2 idiv");        Assert.fail("Expected typecheck");    } catch (ClassCastException cce) {        }}
public void pdfbox_f8123_0() throws Exception
{    Type4Tester.create("10 ln").popReal(2.30259f, 0.00001f).isEmpty();    Type4Tester.create("100 ln").popReal(4.60517f, 0.00001f).isEmpty();}
public void pdfbox_f8124_0() throws Exception
{    Type4Tester.create("10 log").popReal(1.0f).isEmpty();    Type4Tester.create("100 log").popReal(2.0f).isEmpty();}
public void pdfbox_f8125_0() throws Exception
{    Type4Tester.create("5 3 mod").pop(2).isEmpty();    Type4Tester.create("5 2 mod").pop(1).isEmpty();    Type4Tester.create("-5 3 mod").pop(-2).isEmpty();    try {        Type4Tester.create("4.4 2 mod");        Assert.fail("Expected typecheck");    } catch (ClassCastException cce) {        }}
public void pdfbox_f8126_0() throws Exception
{    Type4Tester.create("1 2 mul").pop(2).isEmpty();    Type4Tester.create("1.5 2 mul").popReal(3.0f).isEmpty();    Type4Tester.create("1.5 2.1 mul").popReal(3.15f, 0.001).isEmpty();        Type4Tester.create((Integer.MAX_VALUE - 3) + " 2 mul").popReal(2L * (Integer.MAX_VALUE - 3), 0.001).isEmpty();}
public void pdfbox_f8127_0() throws Exception
{    Type4Tester.create("4.5 neg").popReal(-4.5f).isEmpty();    Type4Tester.create("-3 neg").pop(3).isEmpty();        Type4Tester.create((Integer.MIN_VALUE + 1) + " neg").pop(Integer.MAX_VALUE).isEmpty();    Type4Tester.create(Integer.MIN_VALUE + " neg").popReal(-(float) Integer.MIN_VALUE).isEmpty();}
public void pdfbox_f8128_0() throws Exception
{    Type4Tester.create("3.2 round").popReal(3.0f).isEmpty();    Type4Tester.create("6.5 round").popReal(7.0f).isEmpty();    Type4Tester.create("-4.8 round").popReal(-5.0f).isEmpty();    Type4Tester.create("-6.5 round").popReal(-6.0f).isEmpty();    Type4Tester.create("99 round").pop(99).isEmpty();}
public void pdfbox_f8129_0() throws Exception
{    Type4Tester.create("0 sin").popReal(0f).isEmpty();    Type4Tester.create("90 sin").popReal(1f).isEmpty();    Type4Tester.create("-90.0 sin").popReal(-1f).isEmpty();}
public void pdfbox_f8130_0() throws Exception
{    Type4Tester.create("0 sqrt").popReal(0f).isEmpty();    Type4Tester.create("1 sqrt").popReal(1f).isEmpty();    Type4Tester.create("4 sqrt").popReal(2f).isEmpty();    Type4Tester.create("4.4 sqrt").popReal(2.097617f, 0.000001).isEmpty();    try {        Type4Tester.create("-4.1 sqrt");        Assert.fail("Expected rangecheck");    } catch (IllegalArgumentException iae) {        }}
public void pdfbox_f8131_0() throws Exception
{    Type4Tester.create("5 2 sub -7.5 1 sub").pop(-8.5f).pop(3).isEmpty();}
public void pdfbox_f8132_0() throws Exception
{    Type4Tester.create("3.2 truncate").popReal(3.0f).isEmpty();    Type4Tester.create("-4.8 truncate").popReal(-4.0f).isEmpty();    Type4Tester.create("99 truncate").pop(99).isEmpty();}
public void pdfbox_f8133_0() throws Exception
{    Type4Tester.create("7 3 bitshift 142 -3 bitshift").pop(17).pop(56).isEmpty();}
public void pdfbox_f8134_0() throws Exception
{    Type4Tester.create("7 7 eq 7 6 eq 7 -7 eq true true eq false true eq 7.7 7.7 eq").pop(true).pop(false).pop(true).pop(false).pop(false).pop(true).isEmpty();}
public void pdfbox_f8135_0() throws Exception
{    Type4Tester.create("5 7 ge 7 5 ge 7 7 ge -1 2 ge").pop(false).pop(true).pop(true).pop(false).isEmpty();}
public void pdfbox_f8136_0() throws Exception
{    Type4Tester.create("5 7 gt 7 5 gt 7 7 gt -1 2 gt").pop(false).pop(false).pop(true).pop(false).isEmpty();}
public void pdfbox_f8137_0() throws Exception
{    Type4Tester.create("5 7 le 7 5 le 7 7 le -1 2 le").pop(true).pop(true).pop(false).pop(true).isEmpty();}
public void pdfbox_f8138_0() throws Exception
{    Type4Tester.create("5 7 lt 7 5 lt 7 7 lt -1 2 lt").pop(true).pop(false).pop(false).pop(true).isEmpty();}
public void pdfbox_f8139_0() throws Exception
{    Type4Tester.create("7 7 ne 7 6 ne 7 -7 ne true true ne false true ne 7.7 7.7 ne").pop(false).pop(true).pop(false).pop(true).pop(true).pop(false).isEmpty();}
public void pdfbox_f8140_0() throws Exception
{    Type4Tester.create("true not false not").pop(true).pop(false).isEmpty();    Type4Tester.create("52 not -37 not").pop(37).pop(-52).isEmpty();}
public void pdfbox_f8141_0() throws Exception
{    Type4Tester.create("true true or true false or false false or").pop(false).pop(true).pop(true).isEmpty();    Type4Tester.create("17 5 or 1 1 or").pop(1).pop(21).isEmpty();}
public void pdfbox_f8142_0() throws Exception
{    Type4Tester.create("true true xor true false xor false false xor").pop(false).pop(true).pop(false).isEmpty();    Type4Tester.create("7 3 xor 12 3 or").pop(15).pop(4);}
public void pdfbox_f8143_0() throws Exception
{    Type4Tester.create("true { 2 1 add } if").pop(3).isEmpty();    Type4Tester.create("false { 2 1 add } if").isEmpty();    try {        Type4Tester.create("0 { 2 1 add } if");        fail("Need typecheck error for the '0'");    } catch (ClassCastException cce) {        }}
public void pdfbox_f8144_0() throws Exception
{    Type4Tester.create("true { 2 1 add } { 2 1 sub } ifelse").pop(3).isEmpty();    Type4Tester.create("false { 2 1 add } { 2 1 sub } ifelse").pop(1).isEmpty();}
public void pdfbox_f8145_0() throws Exception
{    Type4Tester.create("true 1 2 3 3 copy").pop(3).pop(2).pop(1).pop(3).pop(2).pop(1).pop(true).isEmpty();}
public void pdfbox_f8146_0() throws Exception
{    Type4Tester.create("true 1 2 dup").pop(2).pop(2).pop(1).pop(true).isEmpty();    Type4Tester.create("true dup").pop(true).pop(true).isEmpty();}
public void pdfbox_f8147_0() throws Exception
{    Type4Tester.create("true 1 exch").pop(true).pop(1).isEmpty();    Type4Tester.create("1 2.5 exch").pop(1).pop(2.5f).isEmpty();}
public void pdfbox_f8148_0() throws Exception
{    Type4Tester.create("1 2 3 4 0 index").pop(4).pop(4).pop(3).pop(2).pop(1).isEmpty();    Type4Tester.create("1 2 3 4 3 index").pop(1).pop(4).pop(3).pop(2).pop(1).isEmpty();}
public void pdfbox_f8149_0() throws Exception
{    Type4Tester.create("1 pop 7 2 pop").pop(7).isEmpty();    Type4Tester.create("1 2 3 pop pop").pop(1).isEmpty();}
public void pdfbox_f8150_0() throws Exception
{    Type4Tester.create("1 2 3 4 5 5 -2 roll").pop(2).pop(1).pop(5).pop(4).pop(3).isEmpty();    Type4Tester.create("1 2 3 4 5 5 2 roll").pop(3).pop(2).pop(1).pop(5).pop(4).isEmpty();    Type4Tester.create("1 2 3 3 0 roll").pop(3).pop(2).pop(1).isEmpty();}
public void pdfbox_f8151_0() throws Exception
{    Type4Tester.create("3 4 add 2 sub").pop(5).isEmpty();}
public void pdfbox_f8152_0() throws Exception
{    Type4Tester.create("true { 2 1 add } { 2 1 sub } ifelse").pop(3).isEmpty();    Type4Tester.create("{ true }").pop(true).isEmpty();}
public void pdfbox_f8153_0() throws Exception
{    assertEquals(0, InstructionSequenceBuilder.parseReal("0"), 0.00001f);    assertEquals(1, InstructionSequenceBuilder.parseReal("1"), 0.00001f);    assertEquals(1, InstructionSequenceBuilder.parseReal("+1"), 0.00001f);    assertEquals(-1, InstructionSequenceBuilder.parseReal("-1"), 0.00001f);    assertEquals(3.14157, InstructionSequenceBuilder.parseReal("3.14157"), 0.00001f);    assertEquals(-1.2, InstructionSequenceBuilder.parseReal("-1.2"), 0.00001f);    assertEquals(1.0E-5, InstructionSequenceBuilder.parseReal("1.0E-5"), 0.00001f);}
public void pdfbox_f8154_0() throws Exception
{                    Type4Tester.create("1 {dup dup .72 mul exch 0 exch .38 mul}\n").pop(0.38f).pop(0f).pop(0.72f).pop(1.0f).isEmpty();}
public static Type4Tester pdfbox_f8155_0(String text)
{    InstructionSequence instructions = InstructionSequenceBuilder.parse(text);    ExecutionContext context = new ExecutionContext(new Operators());    instructions.execute(context);    return new Type4Tester(context);}
public Type4Tester pdfbox_f8156_0(boolean expected)
{    boolean value = (Boolean) context.getStack().pop();    Assert.assertEquals(expected, value);    return this;}
public Type4Tester pdfbox_f8157_0(float expected)
{    return popReal(expected, 0.0000001);}
public Type4Tester pdfbox_f8158_0(float expected, double delta)
{    Float value = (Float) context.getStack().pop();    Assert.assertEquals(expected, value, delta);    return this;}
public Type4Tester pdfbox_f8159_0(int expected)
{    int value = context.popInt();    Assert.assertEquals(expected, value);    return this;}
public Type4Tester pdfbox_f8160_0(float expected)
{    return pop(expected, 0.0000001);}
public Type4Tester pdfbox_f8161_0(float expected, double delta)
{    Number value = context.popNumber();    Assert.assertEquals(expected, value.doubleValue(), delta);    return this;}
public Type4Tester pdfbox_f8162_0()
{    Assert.assertTrue(context.getStack().isEmpty());    return this;}
public ExecutionContext pdfbox_f8163_0()
{    return this.context;}
protected COSInteger pdfbox_f8164_0(COSBase base) throws IOException
{    return (COSInteger) base;}
protected PDIntegerNameTreeNode pdfbox_f8165_0(COSDictionary dic)
{    return new PDIntegerNameTreeNode(dic);}
public void pdfbox_f8166_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, (COSArray) null);        Assert.assertNull(pdStream.getFilters());        List<String> stopFilters = new ArrayList<>();        stopFilters.add(COSName.DCT_DECODE.toString());        stopFilters.add(COSName.DCT_DECODE_ABBREVIATION.toString());        is = pdStream.createInputStream(stopFilters);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
public void pdfbox_f8167_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, new COSArray());        Assert.assertEquals(0, pdStream.getFilters().size());        List<String> stopFilters = new ArrayList<>();        stopFilters.add(COSName.DCT_DECODE.toString());        stopFilters.add(COSName.DCT_DECODE_ABBREVIATION.toString());        is = pdStream.createInputStream(stopFilters);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
public void pdfbox_f8168_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {        InputStream is = new ByteArrayInputStream(new byte[] { 12, 34, 56, 78 });        PDStream pdStream = new PDStream(doc, is, new COSArray());        Assert.assertEquals(0, pdStream.getFilters().size());        is = pdStream.createInputStream((List<String>) null);        Assert.assertEquals(12, is.read());        Assert.assertEquals(34, is.read());        Assert.assertEquals(56, is.read());        Assert.assertEquals(78, is.read());        Assert.assertEquals(-1, is.read());    }}
public void pdfbox_f8169_0() throws IOException
{    PDEmbeddedFile embeddedFile = null;    boolean ok = false;    try {        PDDocument doc = PDDocument.load(TestEmbeddedFiles.class.getResourceAsStream("null_PDComplexFileSpecification.pdf"));        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDDocumentNameDictionary names = catalog.getNames();        assertEquals("expected two files", 2, names.getEmbeddedFiles().getNames().size());        PDEmbeddedFilesNameTreeNode embeddedFiles = names.getEmbeddedFiles();        PDComplexFileSpecification spec = embeddedFiles.getNames().get("non-existent-file.docx");        if (spec != null) {            embeddedFile = spec.getEmbeddedFile();            ok = true;        }                spec = embeddedFiles.getNames().get("My first attachment");        assertNotNull("one attachment actually exists", spec);        assertEquals("existing file length", 17660, spec.getEmbeddedFile().getLength());        spec = embeddedFiles.getNames().get("non-existent-file.docx");    } catch (NullPointerException e) {        assertNotNull("null pointer exception", null);    }    assertTrue("Was able to get file without exception", ok);    assertNull("EmbeddedFile was correctly null", embeddedFile);}
public void pdfbox_f8170_0() throws IOException
{    PDEmbeddedFile nonOSFile = null;    PDEmbeddedFile macFile = null;    PDEmbeddedFile dosFile = null;    PDEmbeddedFile unixFile = null;    PDDocument doc = PDDocument.load(TestEmbeddedFiles.class.getResourceAsStream("testPDF_multiFormatEmbFiles.pdf"));    PDDocumentCatalog catalog = doc.getDocumentCatalog();    PDDocumentNameDictionary names = catalog.getNames();    PDEmbeddedFilesNameTreeNode treeNode = names.getEmbeddedFiles();    List<PDNameTreeNode<PDComplexFileSpecification>> kids = treeNode.getKids();    for (PDNameTreeNode<PDComplexFileSpecification> kid : kids) {        Map<String, PDComplexFileSpecification> tmpNames = kid.getNames();        COSObjectable obj = tmpNames.get("My first attachment");        PDComplexFileSpecification spec = (PDComplexFileSpecification) obj;        nonOSFile = spec.getEmbeddedFile();        macFile = spec.getEmbeddedFileMac();        dosFile = spec.getEmbeddedFileDos();        unixFile = spec.getEmbeddedFileUnix();    }    assertTrue("non os specific", byteArrayContainsLC("non os specific", nonOSFile.toByteArray(), "ISO-8859-1"));    assertTrue("mac", byteArrayContainsLC("mac embedded", macFile.toByteArray(), "ISO-8859-1"));    assertTrue("dos", byteArrayContainsLC("dos embedded", dosFile.toByteArray(), "ISO-8859-1"));    assertTrue("unix", byteArrayContainsLC("unix embedded", unixFile.toByteArray(), "ISO-8859-1"));}
private boolean pdfbox_f8171_0(String target, byte[] bytes, String encoding) throws UnsupportedEncodingException
{    String s = new String(bytes, encoding);    return s.toLowerCase().contains(target);}
protected void pdfbox_f8172_0() throws Exception
{    this.node5 = new PDIntegerNameTreeNode();    Map<String, COSInteger> names = new TreeMap<>();    names.put("Actinium", COSInteger.get(89));    names.put("Aluminum", COSInteger.get(13));    names.put("Americium", COSInteger.get(95));    names.put("Antimony", COSInteger.get(51));    names.put("Argon", COSInteger.get(18));    names.put("Arsenic", COSInteger.get(33));    names.put("Astatine", COSInteger.get(85));    this.node5.setNames(names);    this.node24 = new PDIntegerNameTreeNode();    names = new TreeMap<>();    names.put("Xenon", COSInteger.get(54));    names.put("Ytterbium", COSInteger.get(70));    names.put("Yttrium", COSInteger.get(39));    names.put("Zinc", COSInteger.get(30));    names.put("Zirconium", COSInteger.get(40));    this.node24.setNames(names);    this.node2 = new PDIntegerNameTreeNode();    List<PDNameTreeNode<COSInteger>> kids = this.node2.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node5);    this.node2.setKids(kids);    this.node4 = new PDIntegerNameTreeNode();    kids = this.node4.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node24);    this.node4.setKids(kids);    this.node1 = new PDIntegerNameTreeNode();    kids = this.node1.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node2);    kids.add(this.node4);    this.node1.setKids(kids);}
public void pdfbox_f8173_0() throws IOException
{    Assert.assertEquals("Astatine", this.node5.getUpperLimit());    Assert.assertEquals("Astatine", this.node2.getUpperLimit());    Assert.assertEquals("Zirconium", this.node24.getUpperLimit());    Assert.assertEquals("Zirconium", this.node4.getUpperLimit());    Assert.assertEquals(null, this.node1.getUpperLimit());}
public void pdfbox_f8174_0() throws IOException
{    Assert.assertEquals("Actinium", this.node5.getLowerLimit());    Assert.assertEquals("Actinium", this.node2.getLowerLimit());    Assert.assertEquals("Xenon", this.node24.getLowerLimit());    Assert.assertEquals("Xenon", this.node4.getLowerLimit());    Assert.assertEquals(null, this.node1.getLowerLimit());}
public COSBase pdfbox_f8175_0()
{    return COSInteger.get(value);}
public int pdfbox_f8176_0()
{    final int prime = 31;    int result = 1;    result = prime * result + value;    return result;}
public boolean pdfbox_f8177_0(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PDTest other = (PDTest) obj;    return value == other.value;}
protected void pdfbox_f8178_0() throws Exception
{    this.node5 = new PDNumberTreeNode(PDTest.class);    Map<Integer, PDTest> Numbers = new TreeMap<>();    Numbers.put(1, new PDTest(89));    Numbers.put(2, new PDTest(13));    Numbers.put(3, new PDTest(95));    Numbers.put(4, new PDTest(51));    Numbers.put(5, new PDTest(18));    Numbers.put(6, new PDTest(33));    Numbers.put(7, new PDTest(85));    this.node5.setNumbers(Numbers);    this.node24 = new PDNumberTreeNode(PDTest.class);    Numbers = new TreeMap<>();    Numbers.put(8, new PDTest(54));    Numbers.put(9, new PDTest(70));    Numbers.put(10, new PDTest(39));    Numbers.put(11, new PDTest(30));    Numbers.put(12, new PDTest(40));    this.node24.setNumbers(Numbers);    this.node2 = new PDNumberTreeNode(PDTest.class);    List<PDNumberTreeNode> kids = this.node2.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node5);    this.node2.setKids(kids);    this.node4 = new PDNumberTreeNode(PDTest.class);    kids = this.node4.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node24);    this.node4.setKids(kids);    this.node1 = new PDNumberTreeNode(PDTest.class);    kids = this.node1.getKids();    if (kids == null) {        kids = new COSArrayList<>();    }    kids.add(this.node2);    kids.add(this.node4);    this.node1.setKids(kids);}
public void pdfbox_f8179_0() throws IOException
{    Assert.assertEquals(new PDTest(51), this.node5.getValue(4));    Assert.assertEquals(new PDTest(70), this.node1.getValue(9));    this.node1.setKids(null);    this.node1.setNumbers(null);    Assert.assertNull(this.node1.getValue(0));}
public void pdfbox_f8180_0() throws IOException
{    Assert.assertEquals(7, (int) this.node5.getUpperLimit());    Assert.assertEquals(7, (int) this.node2.getUpperLimit());    Assert.assertEquals(12, (int) this.node24.getUpperLimit());    Assert.assertEquals(12, (int) this.node4.getUpperLimit());    Assert.assertEquals(12, (int) this.node1.getUpperLimit());    this.node24.setNumbers(new HashMap<Integer, COSObjectable>());    Assert.assertNull(this.node24.getUpperLimit());    this.node5.setNumbers(null);    Assert.assertNull(this.node5.getUpperLimit());    this.node1.setKids(null);    Assert.assertNull(this.node1.getUpperLimit());}
public void pdfbox_f8181_0() throws IOException
{    Assert.assertEquals(1, (int) this.node5.getLowerLimit());    Assert.assertEquals(1, (int) this.node2.getLowerLimit());    Assert.assertEquals(8, (int) this.node24.getLowerLimit());    Assert.assertEquals(8, (int) this.node4.getLowerLimit());    Assert.assertEquals(1, (int) this.node1.getLowerLimit());    this.node24.setNumbers(new HashMap<Integer, COSObjectable>());    Assert.assertNull(this.node24.getLowerLimit());    this.node5.setNumbers(null);    Assert.assertNull(this.node5.getLowerLimit());    this.node1.setKids(null);    Assert.assertNull(this.node1.getLowerLimit());}
public void pdfbox_f8182_0() throws IOException
{    Set<Revisions<PDAttributeObject>> attributeSet = new HashSet<>();    try (PDDocument doc = PDDocument.load(new File(TARGETPDFDIR, "PDFBOX-4197.pdf"))) {        PDStructureTreeRoot structureTreeRoot = doc.getDocumentCatalog().getStructureTreeRoot();        checkElement(structureTreeRoot.getK(), attributeSet);    }        Assert.assertEquals(117, attributeSet.size());    int cnt = 0;    for (Revisions<PDAttributeObject> attributes : attributeSet) {        cnt += attributes.size();    }        Assert.assertEquals(111, cnt);}
private void pdfbox_f8183_0(COSBase base, Set<Revisions<PDAttributeObject>> attributeSet)
{    if (base instanceof COSArray) {        for (COSBase base2 : (COSArray) base) {            if (base2 instanceof COSObject) {                base2 = ((COSObject) base2).getObject();            }            checkElement(base2, attributeSet);        }    } else if (base instanceof COSDictionary) {        COSDictionary kdict = (COSDictionary) base;        if (kdict.containsKey(COSName.PG)) {            PDStructureElement structureElement = new PDStructureElement(kdict);            Revisions<PDAttributeObject> attributes = structureElement.getAttributes();            attributeSet.add(attributes);            Revisions<String> classNames = structureElement.getClassNames();                }        if (kdict.containsKey(COSName.K)) {            checkElement(kdict.getDictionaryObject(COSName.K), attributeSet);        }    }}
public void pdfbox_f8184_0() throws IOException, URISyntaxException
{    File f = new File(FDFAnnotationTest.class.getResource("xfdf-test-document-annotations.xml").toURI());    try (FDFDocument fdfDoc = FDFDocument.loadXFDF(f)) {        List<FDFAnnotation> fdfAnnots = fdfDoc.getCatalog().getFDF().getAnnotations();        assertEquals(18, fdfAnnots.size());                                        boolean testedPDFBox4345andPDFBox3646 = false;        for (FDFAnnotation ann : fdfAnnots) {            if (ann instanceof FDFAnnotationFreeText) {                FDFAnnotationFreeText annotationFreeText = (FDFAnnotationFreeText) ann;                if ("P&1 P&2 P&3".equals(annotationFreeText.getContents())) {                    testedPDFBox4345andPDFBox3646 = true;                    Assert.assertEquals("<body style=\"font:12pt Helvetica; " + "color:#D66C00;\" xfa:APIVersion=\"Acrobat:7.0.8\" " + "xfa:spec=\"2.0.2\" xmlns=\"http://www.w3.org/1999/xhtml\" " + "xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n" + "          <p dir=\"ltr\">P&amp;1 <span style=\"text-" + "decoration:word;font-family:Helvetica\">P&amp;2</span> " + "P&amp;3</p>\n" + "        </body>", annotationFreeText.getRichContents().trim());                }            }        }        Assert.assertTrue(testedPDFBox4345andPDFBox3646);    }}
public void pdfbox_f8185_0() throws IOException
{    String testString = "Test value";    COSString testCOSString = new COSString(testString);    FDFField field = new FDFField();    field.setValue(testCOSString);    assertEquals(testCOSString, (COSString) field.getCOSValue());    assertEquals(testString, field.getValue());}
public void pdfbox_f8186_0() throws IOException
{    String testString = "Test value";    byte[] testBytes = testString.getBytes("ASCII");    COSStream stream = createStream(testBytes, null);    FDFField field = new FDFField();    field.setValue(stream);    assertEquals(testString, field.getValue());}
public void pdfbox_f8187_0() throws IOException
{    String testString = "Yes";    COSName testCOSSName = COSName.getPDFName(testString);    FDFField field = new FDFField();    field.setValue(testCOSSName);    assertEquals(testCOSSName, (COSName) field.getCOSValue());    assertEquals(testString, field.getValue());}
public void pdfbox_f8188_0() throws IOException
{    List<String> testList = new ArrayList<>();    testList.add("A");    testList.add("B");    COSArray testCOSArray = COSArrayList.convertStringListToCOSStringCOSArray(testList);    FDFField field = new FDFField();    field.setValue(testCOSArray);    assertEquals(testCOSArray, (COSArray) field.getCOSValue());    assertEquals(testList, field.getValue());}
private COSStream pdfbox_f8189_0(byte[] testString, COSBase filters) throws IOException
{    COSStream stream = new COSStream();    OutputStream output = stream.createOutputStream(filters);    output.write(testString);    output.close();    return stream;}
public void pdfbox_f8190_0() throws Exception
{    OUT_DIR.mkdirs();}
public void pdfbox_f8191_0() throws IOException, URISyntaxException
{    try (PDDocument doc = PDDocument.load(new File(PDFontTest.class.getResource("F001u_3_7j.pdf").toURI()))) {        PDFRenderer renderer = new PDFRenderer(doc);        renderer.renderImage(0);        }}
public void pdfbox_f8192_0() throws IOException
{    File file = new File("c:/windows/fonts", "calibri.ttf");    if (!file.exists()) {        System.out.println("testPDFBox3747 skipped");        return;    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDFont font = PDType0Font.load(doc, file);        try (PDPageContentStream cs = new PDPageContentStream(doc, page)) {            cs.beginText();            cs.setFont(font, 10);            cs.showText("PDFBOX-3747");            cs.endText();        }        doc.save(baos);    }    try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDFTextStripper stripper = new PDFTextStripper();        String text = stripper.getText(doc);        Assert.assertEquals("PDFBOX-3747", text.trim());    }}
public void pdfbox_f8193_0() throws IOException, URISyntaxException
{    URL url = PDFont.class.getResource("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");    File fontFile = new File(url.toURI());    try (TrueTypeFont ttf1 = new TTFParser().parse(fontFile)) {        testPDFBox3826checkFonts(testPDFBox3826createDoc(ttf1), fontFile);    }    try (TrueTypeFont ttf2 = new TTFParser().parse(new FileInputStream(fontFile))) {        testPDFBox3826checkFonts(testPDFBox3826createDoc(ttf2), fontFile);    }}
public void pdfbox_f8194_0() throws IOException
{    File fontFile = new File("target/fonts", "n019003l.pfb");    File outputFile = new File(OUT_DIR, "FontType1.pdf");    String text = "";    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page)) {            PDType1Font font = new PDType1Font(doc, new FileInputStream(fontFile), WinAnsiEncoding.INSTANCE);            contentStream.beginText();            contentStream.setFont(font, 10);            contentStream.newLineAtOffset(10, 700);            contentStream.showText(text);            contentStream.endText();        }        doc.addPage(page);        doc.save(outputFile);    }    try (PDDocument doc = PDDocument.load(outputFile)) {        PDType1Font font = (PDType1Font) doc.getPage(0).getResources().getFont(COSName.getPDFName("F1"));        Assert.assertEquals(font.getEncoding(), WinAnsiEncoding.INSTANCE);        for (char c : text.toCharArray()) {            String name = font.getEncoding().getName(c);            Assert.assertEquals("dieresis", name.substring(1));            Assert.assertFalse(font.getPath(name).getBounds2D().isEmpty());        }        PDFTextStripper stripper = new PDFTextStripper();        Assert.assertEquals(text, stripper.getText(doc).trim());    }}
public void pdfbox_f8195_0() throws IOException
{    try {        PDType1Font.HELVETICA_BOLD.encode("\u0080");        Assert.fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException ex) {    }    PDType1Font.HELVETICA_BOLD.encode("");    try {        PDType1Font.HELVETICA_BOLD.encode("\u0080");        Assert.fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException ex) {    }}
private void pdfbox_f8196_0(byte[] byteArray, File fontFile) throws IOException
{    try (PDDocument doc = PDDocument.load(byteArray)) {        PDPage page2 = doc.getPage(0);                PDType0Font fontF1 = (PDType0Font) page2.getResources().getFont(COSName.getPDFName("F1"));        Assert.assertTrue(fontF1.getName().contains("+"));        Assert.assertTrue(fontFile.length() > fontF1.getFontDescriptor().getFontFile2().toByteArray().length);                PDType0Font fontF2 = (PDType0Font) page2.getResources().getFont(COSName.getPDFName("F2"));        Assert.assertFalse(fontF2.getName().contains("+"));        Assert.assertEquals(fontFile.length(), fontF2.getFontDescriptor().getFontFile2().toByteArray().length);                PDTrueTypeFont fontF3 = (PDTrueTypeFont) page2.getResources().getFont(COSName.getPDFName("F3"));        Assert.assertFalse(fontF2.getName().contains("+"));        Assert.assertEquals(fontFile.length(), fontF3.getFontDescriptor().getFontFile2().toByteArray().length);        new PDFRenderer(doc).renderImage(0);        PDFTextStripper stripper = new PDFTextStripper();        stripper.setLineSeparator("\n");        String text = stripper.getText(doc);        Assert.assertEquals("testMultipleFontFileReuse1\ntestMultipleFontFileReuse2\ntestMultipleFontFileReuse3", text.trim());    }}
private byte[] pdfbox_f8197_0(TrueTypeFont ttf) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);                PDFont font = PDType0Font.load(doc, ttf, true);        try (PDPageContentStream cs = new PDPageContentStream(doc, page)) {            cs.beginText();            cs.newLineAtOffset(10, 700);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse1");            cs.endText();                        font = PDType0Font.load(doc, ttf, false);            cs.beginText();            cs.newLineAtOffset(10, 650);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse2");            cs.endText();                        font = PDTrueTypeFont.load(doc, ttf, WinAnsiEncoding.INSTANCE);            cs.beginText();            cs.newLineAtOffset(10, 600);            cs.setFont(font, 10);            cs.showText("testMultipleFontFileReuse3");            cs.endText();        }        doc.save(baos);    }    return baos.toByteArray();}
protected void pdfbox_f8198_0()
{    OUT_DIR.mkdirs();}
public void pdfbox_f8199_0() throws IOException
{    validateCIDFontType2(false);}
public void pdfbox_f8200_0() throws IOException
{    validateCIDFontType2(true);}
public void pdfbox_f8201_0() throws IOException
{    String text = "ABC";    String expectedExtractedtext = "\nA\nB\nC\n";    File pdf = new File(OUT_DIR, "CIDFontType2VM.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        File ipafont = new File("target/fonts/ipag00303", "ipag.ttf");        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(vfont, 20);            contentStream.newLineAtOffset(50, 700);            contentStream.showText(text);            contentStream.endText();        }                byte[] encode = vfont.encode(text);        int cid = ((encode[0] & 0xFF) << 8) + (encode[1] & 0xFF);                assertEquals(7392, cid);                COSDictionary fontDict = vfont.getCOSObject();        assertEquals(COSName.IDENTITY_V, fontDict.getDictionaryObject(COSName.ENCODING));        document.save(pdf);                COSDictionary descFontDict = vfont.getDescendantFont().getCOSObject();        COSArray dw2 = (COSArray) descFontDict.getDictionaryObject(COSName.DW2);                assertNull(dw2);        COSArray w2 = (COSArray) descFontDict.getDictionaryObject(COSName.W2);                assertEquals(0, w2.size());    }        String extracted = getUnicodeText(pdf);    assertEquals(expectedExtractedtext, extracted.replaceAll("\r", "").trim());}
public void pdfbox_f8202_0() throws IOException
{    String text = "ABC";    String expectedExtractedtext = "\nA\nB\nC\n";    File pdf = new File(OUT_DIR, "CIDFontType2VP.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        File ipafont = new File("target/fonts/ipagp00303", "ipagp.ttf");        PDType0Font vfont = PDType0Font.loadVertical(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(vfont, 20);            contentStream.newLineAtOffset(50, 700);            contentStream.showText(text);            contentStream.endText();        }                byte[] encode = vfont.encode(text);        int cid = ((encode[0] & 0xFF) << 8) + (encode[1] & 0xFF);                assertEquals(12607, cid);                COSDictionary fontDict = vfont.getCOSObject();        assertEquals(COSName.IDENTITY_V, fontDict.getDictionaryObject(COSName.ENCODING));        document.save(pdf);                COSDictionary descFontDict = vfont.getDescendantFont().getCOSObject();        COSArray dw2 = (COSArray) descFontDict.getDictionaryObject(COSName.DW2);                assertNull(dw2);                COSArray w2 = (COSArray) descFontDict.getDictionaryObject(COSName.W2);        assertEquals(2, w2.size());                assertEquals(12607, w2.getInt(0));        COSArray metrics = (COSArray) w2.getObject(1);        int i = 0;        for (int n : new int[] { -570, 500, 450, -570, 500, 880 }) {            assertEquals(n, metrics.getInt(i++));        }    }        String extracted = getUnicodeText(pdf);    assertEquals(expectedExtractedtext, extracted.replaceAll("\r", "").trim());}
public void pdfbox_f8203_0() throws IOException
{    String BANGLA_TEXT_1 = "         ";    String BANGLA_TEXT_2 = "             ";    String BANGLA_TEXT_3 = "    ";    String expectedExtractedtext = BANGLA_TEXT_1 + "\n" + BANGLA_TEXT_2 + "\n" + BANGLA_TEXT_3;    File pdf = new File(OUT_DIR, "Bengali.pdf");    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        PDFont font = PDType0Font.load(document, this.getClass().getResourceAsStream("/org/apache/pdfbox/ttf/Lohit-Bengali.ttf"));        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(font, 18);            contentStream.newLineAtOffset(10, 750);            contentStream.showText(BANGLA_TEXT_1);            contentStream.newLineAtOffset(0, -30);            contentStream.showText(BANGLA_TEXT_2);            contentStream.newLineAtOffset(0, -30);            contentStream.showText(BANGLA_TEXT_3);            contentStream.endText();        }        document.save(pdf);    }    File IN_DIR = new File("src/test/resources/org/apache/pdfbox/ttf");        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(pdf, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + pdf + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }        String extracted = getUnicodeText(pdf);}
public void pdfbox_f8204_0() throws IOException
{    File file;    String text;    text = "" + "" + "";        Set<Character> set = new HashSet<>(ToUnicodeWriter.MAX_ENTRIES_PER_OPERATOR);    for (int i = 0; i < text.length(); ++i) {        set.add(text.charAt(i));    }    assertEquals(ToUnicodeWriter.MAX_ENTRIES_PER_OPERATOR, set.size());    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A0);        document.addPage(page);        File ipafont = new File("target/fonts/ipag00303", "ipag.ttf");        PDType0Font font = PDType0Font.load(document, ipafont);        try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {            contentStream.beginText();            contentStream.setFont(font, 20);            contentStream.newLineAtOffset(50, 3000);            contentStream.showText(text);            contentStream.endText();        }        file = new File(OUT_DIR, "PDFBOX-4302-test.pdf");        document.save(file);    }        String extracted = getUnicodeText(file);    assertEquals(text, extracted.trim());}
private void pdfbox_f8205_0(boolean useSubset) throws IOException
{    String text;    File file;    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        document.addPage(page);        InputStream input = PDFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");        PDType0Font font = PDType0Font.load(document, input, useSubset);        try (PDPageContentStream stream = new PDPageContentStream(document, page)) {            stream.beginText();            stream.setFont(font, 12);            text = "Unicode   Ting Vit";            stream.newLineAtOffset(50, 600);            stream.showText(text);            stream.endText();        }        file = new File(OUT_DIR, "CIDFontType2.pdf");        document.save(file);    }        String extracted = getUnicodeText(file);    assertEquals(text, extracted.trim());}
private String pdfbox_f8206_0(File file) throws IOException
{    PDDocument document = PDDocument.load(file);    PDFTextStripper stripper = new PDFTextStripper();    return stripper.getText(document);}
public void pdfbox_f8207_0() throws Exception
{        int codeForSpace = WinAnsiEncoding.INSTANCE.getNameToCodeMap().get("space");    assertEquals(32, codeForSpace);    codeForSpace = MacRomanEncoding.INSTANCE.getNameToCodeMap().get("space");    assertEquals(32, codeForSpace);}
public void pdfbox_f8208_0() throws Exception
{        COSDictionary dictEncodingDict = new COSDictionary();    dictEncodingDict.setItem(COSName.TYPE, COSName.ENCODING);    dictEncodingDict.setItem(COSName.BASE_ENCODING, COSName.WIN_ANSI_ENCODING);    COSArray differences = new COSArray();    differences.add(COSInteger.get(32));    differences.add(COSName.getPDFName("a"));    dictEncodingDict.setItem(COSName.DIFFERENCES, differences);    DictionaryEncoding dictEncoding = new DictionaryEncoding(dictEncodingDict, false, null);    assertNull(dictEncoding.getNameToCodeMap().get("space"));    assertEquals(32, dictEncoding.getNameToCodeMap().get("a").intValue());}
public void pdfbox_f8209_0() throws IOException
{    PDDocument doc = new PDDocument();    PDPage page = new PDPage();    doc.addPage(page);    PDPageContentStream cs = new PDPageContentStream(doc, page);    cs.setFont(PDType1Font.HELVETICA, 20);    cs.beginText();    cs.newLineAtOffset(100, 700);            cs.showText("~");    cs.endText();    cs.close();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    doc.save(baos);    doc.close();        doc = PDDocument.load(baos.toByteArray());    PDFTextStripper stripper = new PDFTextStripper();    String text = stripper.getText(doc);    assertEquals("~", text.trim());    doc.close();}
public void pdfbox_f8210_0() throws IOException
{    InputStream input = PDFont.class.getResourceAsStream("/org/apache/pdfbox/resources/ttf/LiberationSans-Regular.ttf");    Assert.assertNotNull(input);    TTFParser parser = new TTFParser();    TrueTypeFont font = parser.parse(input);    CmapTable cmapTable = font.getCmap();    Assert.assertNotNull(cmapTable);    CmapSubtable[] cmaps = cmapTable.getCmaps();    Assert.assertNotNull(cmaps);    CmapSubtable cmap = null;    for (CmapSubtable e : cmaps) {        if (e.getPlatformId() == NameRecord.PLATFORM_WINDOWS && e.getPlatformEncodingId() == NameRecord.ENCODING_WINDOWS_UNICODE_BMP) {            cmap = e;            break;        }    }    Assert.assertNotNull(cmap);    PostScriptTable post = font.getPostScript();    Assert.assertNotNull(post);    String[] glyphNames = font.getPostScript().getGlyphNames();    Assert.assertNotNull(glyphNames);            int gid = cmap.getGlyphId(0x2122);    Assert.assertEquals("trademark", glyphNames[gid]);            gid = cmap.getGlyphId(0x20AC);    Assert.assertEquals("Euro", glyphNames[gid]);}
public void pdfbox_f8211_0()
{    assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.NORMAL));    assertEquals(BlendMode.NORMAL, BlendMode.getInstance(COSName.COMPATIBLE));    assertEquals(BlendMode.MULTIPLY, BlendMode.getInstance(COSName.MULTIPLY));    assertEquals(BlendMode.SCREEN, BlendMode.getInstance(COSName.SCREEN));    assertEquals(BlendMode.OVERLAY, BlendMode.getInstance(COSName.OVERLAY));    assertEquals(BlendMode.DARKEN, BlendMode.getInstance(COSName.DARKEN));    assertEquals(BlendMode.LIGHTEN, BlendMode.getInstance(COSName.LIGHTEN));    assertEquals(BlendMode.COLOR_DODGE, BlendMode.getInstance(COSName.COLOR_DODGE));    assertEquals(BlendMode.COLOR_BURN, BlendMode.getInstance(COSName.COLOR_BURN));    assertEquals(BlendMode.HARD_LIGHT, BlendMode.getInstance(COSName.HARD_LIGHT));    assertEquals(BlendMode.SOFT_LIGHT, BlendMode.getInstance(COSName.SOFT_LIGHT));    assertEquals(BlendMode.DIFFERENCE, BlendMode.getInstance(COSName.DIFFERENCE));    assertEquals(BlendMode.EXCLUSION, BlendMode.getInstance(COSName.EXCLUSION));    assertEquals(BlendMode.HUE, BlendMode.getInstance(COSName.HUE));    assertEquals(BlendMode.SATURATION, BlendMode.getInstance(COSName.SATURATION));    assertEquals(BlendMode.LUMINOSITY, BlendMode.getInstance(COSName.LUMINOSITY));    assertEquals(BlendMode.COLOR, BlendMode.getInstance(COSName.COLOR));}
public void pdfbox_f8212_0()
{    assertEquals(COSName.NORMAL, BlendMode.getCOSName(BlendMode.NORMAL));    assertEquals(COSName.NORMAL, BlendMode.getCOSName(BlendMode.COMPATIBLE));    assertEquals(COSName.MULTIPLY, BlendMode.getCOSName(BlendMode.MULTIPLY));    assertEquals(COSName.SCREEN, BlendMode.getCOSName(BlendMode.SCREEN));    assertEquals(COSName.OVERLAY, BlendMode.getCOSName(BlendMode.OVERLAY));    assertEquals(COSName.DARKEN, BlendMode.getCOSName(BlendMode.DARKEN));    assertEquals(COSName.LIGHTEN, BlendMode.getCOSName(BlendMode.LIGHTEN));    assertEquals(COSName.COLOR_DODGE, BlendMode.getCOSName(BlendMode.COLOR_DODGE));    assertEquals(COSName.COLOR_BURN, BlendMode.getCOSName(BlendMode.COLOR_BURN));    assertEquals(COSName.HARD_LIGHT, BlendMode.getCOSName(BlendMode.HARD_LIGHT));    assertEquals(COSName.SOFT_LIGHT, BlendMode.getCOSName(BlendMode.SOFT_LIGHT));    assertEquals(COSName.DIFFERENCE, BlendMode.getCOSName(BlendMode.DIFFERENCE));    assertEquals(COSName.EXCLUSION, BlendMode.getCOSName(BlendMode.EXCLUSION));    assertEquals(COSName.HUE, BlendMode.getCOSName(BlendMode.HUE));    assertEquals(COSName.SATURATION, BlendMode.getCOSName(BlendMode.SATURATION));    assertEquals(COSName.LUMINOSITY, BlendMode.getCOSName(BlendMode.LUMINOSITY));    assertEquals(COSName.COLOR, BlendMode.getCOSName(BlendMode.COLOR));}
public void pdfbox_f8213_0() throws IOException
{    PDDeviceCMYK.INSTANCE = new CustomDeviceCMYK();}
public void pdfbox_f8214_0()
{    PDDocument doc = new PDDocument();    PDICCBased iccBased = new PDICCBased(doc);    assertEquals("ICCBased", iccBased.getName());    assertNotNull(iccBased.getPDStream());}
public void pdfbox_f8215_0()
{    PDLab pdLab = new PDLab();    COSArray cosArray = (COSArray) pdLab.getCOSObject();    COSDictionary dict = (COSDictionary) cosArray.getObject(1);        assertEquals("Lab", pdLab.getName());    assertEquals(3, pdLab.getNumberOfComponents());    assertNotNull(pdLab.getInitialColor());    assertTrue(Arrays.equals(new float[] { 0, 0, 0 }, pdLab.getInitialColor().getComponents()));    assertEquals(0f, pdLab.getBlackPoint().getX());    assertEquals(0f, pdLab.getBlackPoint().getY());    assertEquals(0f, pdLab.getBlackPoint().getZ());    assertEquals(1f, pdLab.getWhitepoint().getX());    assertEquals(1f, pdLab.getWhitepoint().getY());    assertEquals(1f, pdLab.getWhitepoint().getZ());    assertEquals(-100f, pdLab.getARange().getMin());    assertEquals(100f, pdLab.getARange().getMax());    assertEquals(-100f, pdLab.getBRange().getMin());    assertEquals(100f, pdLab.getBRange().getMax());    assertEquals("read operations should not change the size of /Lab objects", 0, dict.size());        dict.toString();        PDRange pdRange = new PDRange();    pdRange.setMin(-1);    pdRange.setMax(2);    pdLab.setARange(pdRange);    pdRange = new PDRange();    pdRange.setMin(3);    pdRange.setMax(4);    pdLab.setBRange(pdRange);    assertEquals(-1f, pdLab.getARange().getMin());    assertEquals(2f, pdLab.getARange().getMax());    assertEquals(3f, pdLab.getBRange().getMin());    assertEquals(4f, pdLab.getBRange().getMax());    PDTristimulus pdTristimulus = new PDTristimulus();    pdTristimulus.setX(5);    pdTristimulus.setY(6);    pdTristimulus.setZ(7);    pdLab.setWhitePoint(pdTristimulus);    pdTristimulus = new PDTristimulus();    pdTristimulus.setX(8);    pdTristimulus.setY(9);    pdTristimulus.setZ(10);    pdLab.setBlackPoint(pdTristimulus);    assertEquals(5f, pdLab.getWhitepoint().getX());    assertEquals(6f, pdLab.getWhitepoint().getY());    assertEquals(7f, pdLab.getWhitepoint().getZ());    assertEquals(8f, pdLab.getBlackPoint().getX());    assertEquals(9f, pdLab.getBlackPoint().getY());    assertEquals(10f, pdLab.getBlackPoint().getZ());    assertTrue(Arrays.equals(new float[] { 0, 0, 3 }, pdLab.getInitialColor().getComponents()));}
protected void pdfbox_f8216_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8217_0() throws IOException
{    String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    String tiffG4Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4.tif";    PDDocument document = new PDDocument();    PDImageXObject ximage3 = CCITTFactory.createFromFile(document, new File(tiffG3Path));    validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    BufferedImage bim3 = ImageIO.read(new File(tiffG3Path));    checkIdent(bim3, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    PDImageXObject ximage4 = CCITTFactory.createFromFile(document, new File(tiffG4Path));    validate(ximage4, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    BufferedImage bim4 = ImageIO.read(new File(tiffG3Path));    checkIdent(bim4, ximage4.getOpaqueImage());    page = new PDPage(PDRectangle.A4);    document.addPage(page);    contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage4, 0, 0);    contentStream.close();    document.save(testResultsDir + "/singletiff.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletiff.pdf"));    assertEquals(2, document.getNumberOfPages());    document.close();}
public void pdfbox_f8218_0() throws IOException
{    String tiffPath = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4multi.tif";    ImageInputStream is = ImageIO.createImageInputStream(new File(tiffPath));    ImageReader imageReader = ImageIO.getImageReaders(is).next();    imageReader.setInput(is);    int countTiffImages = imageReader.getNumImages(true);    assertTrue(countTiffImages > 1);    PDDocument document = new PDDocument();    int pdfPageNum = 0;    while (true) {        PDImageXObject ximage = CCITTFactory.createFromFile(document, new File(tiffPath), pdfPageNum);        if (ximage == null) {            break;        }        BufferedImage bim = imageReader.read(pdfPageNum);        validate(ximage, 1, bim.getWidth(), bim.getHeight(), "tiff", PDDeviceGray.INSTANCE.getName());        checkIdent(bim, ximage.getOpaqueImage());        PDPage page = new PDPage(PDRectangle.A4);        float fX = ximage.getWidth() / page.getMediaBox().getWidth();        float fY = ximage.getHeight() / page.getMediaBox().getHeight();        float factor = Math.max(fX, fY);        document.addPage(page);        PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);        contentStream.drawImage(ximage, 0, 0, ximage.getWidth() / factor, ximage.getHeight() / factor);        contentStream.close();        ++pdfPageNum;    }    assertEquals(countTiffImages, pdfPageNum);    document.save(testResultsDir + "/multitiff.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "multitiff.pdf"), (String) null);    assertEquals(countTiffImages, document.getNumberOfPages());    document.close();    imageReader.dispose();}
public void pdfbox_f8219_0() throws IOException
{    String tiffG4Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg4.tif";    PDDocument document = new PDDocument();    BufferedImage bim = ImageIO.read(new File(tiffG4Path));    PDImageXObject ximage3 = CCITTFactory.createFromImage(document, bim);    validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());    checkIdent(bim, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    document.save(testResultsDir + "/singletifffrombi.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletifffrombi.pdf"));    assertEquals(1, document.getNumberOfPages());    document.close();}
public void pdfbox_f8220_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage bim = new BufferedImage(343, 287, BufferedImage.TYPE_BYTE_BINARY);        assertTrue((bim.getWidth() / 8) * 8 != bim.getWidth());    int col = 0;    for (int x = 0; x < bim.getWidth(); ++x) {        for (int y = 0; y < bim.getHeight(); ++y) {            bim.setRGB(x, y, col & 0xFFFFFF);            col = ~col;        }    }    PDImageXObject ximage3 = CCITTFactory.createFromImage(document, bim);    validate(ximage3, 1, 343, 287, "tiff", PDDeviceGray.INSTANCE.getName());    checkIdent(bim, ximage3.getOpaqueImage());    PDPage page = new PDPage(PDRectangle.A4);    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage3, 0, 0, ximage3.getWidth(), ximage3.getHeight());    contentStream.close();    document.save(testResultsDir + "/singletifffromchessbi.pdf");    document.close();    document = PDDocument.load(new File(testResultsDir, "singletifffromchessbi.pdf"));    assertEquals(1, document.getNumberOfPages());    document.close();}
public void pdfbox_f8221_0() throws IOException
{        String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    File copiedTiffFile = new File(testResultsDir, "ccittg3.tif");    Files.copy(new File(tiffG3Path).toPath(), copiedTiffFile.toPath(), StandardCopyOption.REPLACE_EXISTING);    PDDocument document = new PDDocument();    CCITTFactory.createFromFile(document, copiedTiffFile);    assertTrue(copiedTiffFile.delete());}
public void pdfbox_f8222_0() throws IOException
{        String tiffG3Path = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3.tif";    File copiedTiffFile = new File(testResultsDir, "ccittg3n.tif");    Files.copy(new File(tiffG3Path).toPath(), copiedTiffFile.toPath(), StandardCopyOption.REPLACE_EXISTING);    PDDocument document = new PDDocument();    CCITTFactory.createFromFile(document, copiedTiffFile, 0);    assertTrue(copiedTiffFile.delete());}
public void pdfbox_f8223_0() throws IOException
{    try (PDDocument document = new PDDocument()) {        String basePath = "src/test/resources/org/apache/pdfbox/pdmodel/graphics/image/ccittg3-garbage-padded-fields";        for (String ext : Arrays.asList(".tif", "-bigendian.tif")) {            String tiffPath = basePath + ext;            PDImageXObject ximage3 = CCITTFactory.createFromFile(document, new File(tiffPath));            validate(ximage3, 1, 344, 287, "tiff", PDDeviceGray.INSTANCE.getName());        }    }}
protected void pdfbox_f8224_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8225_0() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 344, 287, "jpg", PDDeviceRGB.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegrgbstream.pdf");    checkJpegStream(testResultsDir, "jpegrgbstream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));}
public void pdfbox_f8226_0() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpegcmyk.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 343, 287, "jpg", PDDeviceCMYK.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegcmykstream.pdf");    checkJpegStream(testResultsDir, "jpegcmykstream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpegcmyk.jpg"));}
public void pdfbox_f8227_0() throws IOException
{    PDDocument document = new PDDocument();    InputStream stream = JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg");    PDImageXObject ximage = JPEGFactory.createFromStream(document, stream);    validate(ximage, 8, 344, 287, "jpg", PDDeviceGray.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpeg256stream.pdf");    checkJpegStream(testResultsDir, "jpeg256stream.pdf", JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg"));}
public void pdfbox_f8228_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));    assertEquals(3, image.getColorModel().getNumComponents());    PDImageXObject ximage = JPEGFactory.createFromImage(document, image);    validate(ximage, 8, 344, 287, "jpg", PDDeviceRGB.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpegrgb.pdf");}
public void pdfbox_f8229_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg256.jpg"));    assertEquals(1, image.getColorModel().getNumComponents());    PDImageXObject ximage = JPEGFactory.createFromImage(document, image);    validate(ximage, 8, 344, 287, "jpg", PDDeviceGray.INSTANCE.getName());    doWritePDF(document, ximage, testResultsDir, "jpeg256.pdf");}
public void pdfbox_f8230_0() throws IOException
{        if (System.getProperty("java.runtime.name").equals("OpenJDK Runtime Environment") && (System.getProperty("java.specification.version").equals("1.6") || System.getProperty("java.specification.version").equals("1.7") || System.getProperty("java.specification.version").equals("1.8"))) {        return;    }    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));        int width = image.getWidth();    int height = image.getHeight();    BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = JPEGFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "jpg", PDDeviceRGB.INSTANCE.getName());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, width, height, "jpg", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "jpeg-intargb.pdf");}
public void pdfbox_f8231_0() throws IOException
{        if (System.getProperty("java.runtime.name").equals("OpenJDK Runtime Environment") && (System.getProperty("java.specification.version").equals("1.6") || System.getProperty("java.specification.version").equals("1.7") || System.getProperty("java.specification.version").equals("1.8"))) {        return;    }    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(JPEGFactoryTest.class.getResourceAsStream("jpeg.jpg"));        int width = image.getWidth();    int height = image.getHeight();    BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = JPEGFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "jpg", PDDeviceRGB.INSTANCE.getName());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, width, height, "jpg", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "jpeg-4bargb.pdf");}
private void pdfbox_f8232_0(File testResultsDir, String filename, InputStream resourceStream) throws IOException
{    PDDocument doc = PDDocument.load(new File(testResultsDir, filename));    PDImageXObject img = (PDImageXObject) doc.getPage(0).getResources().getXObject(COSName.getPDFName("Im1"));    InputStream dctStream = img.createInputStream(Arrays.asList(COSName.DCT_DECODE.getName()));    ByteArrayOutputStream baos1 = new ByteArrayOutputStream();    ByteArrayOutputStream baos2 = new ByteArrayOutputStream();    IOUtils.copy(resourceStream, baos1);    IOUtils.copy(dctStream, baos2);    resourceStream.close();    dctStream.close();    assertArrayEquals(baos1.toByteArray(), baos2.toByteArray());    doc.close();}
protected void pdfbox_f8233_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8234_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    PDImageXObject ximage1 = LosslessFactory.createFromImage(document, image);    validate(ximage1, 8, image.getWidth(), image.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage1.getImage());        BufferedImage grayImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);    Graphics g = grayImage.getGraphics();    g.drawImage(image, 0, 0, null);    g.dispose();    PDImageXObject ximage2 = LosslessFactory.createFromImage(document, grayImage);    validate(ximage2, 8, grayImage.getWidth(), grayImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    checkIdent(grayImage, ximage2.getImage());        BufferedImage bitonalImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_BINARY);        assertFalse(bitonalImage.getWidth() % 8 == 0);    g = bitonalImage.getGraphics();    g.drawImage(image, 0, 0, null);    g.dispose();    PDImageXObject ximage3 = LosslessFactory.createFromImage(document, bitonalImage);    validate(ximage3, 1, bitonalImage.getWidth(), bitonalImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    checkIdent(bitonalImage, ximage3.getImage());                PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage1, 200, 300, ximage1.getWidth() / 2, ximage1.getHeight() / 2);    contentStream.drawImage(ximage2, 200, 450, ximage2.getWidth() / 2, ximage2.getHeight() / 2);    contentStream.drawImage(ximage3, 200, 600, ximage3.getWidth() / 2, ximage3.getHeight() / 2);    contentStream.close();    File pdfFile = new File(testResultsDir, "misc.pdf");    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile, (String) null);    new PDFRenderer(document).renderImage(0);    document.close();}
public void pdfbox_f8235_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));        int w = image.getWidth();    int h = image.getHeight();    BufferedImage argbImage = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, argbImage.getWidth(), argbImage.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, argbImage.getWidth(), argbImage.getHeight(), "png", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "intargb.pdf");}
public void pdfbox_f8236_0() throws IOException
{    doBitmaskTransparencyTest(BufferedImage.TYPE_INT_ARGB, "bitmaskintargb.pdf");}
public void pdfbox_f8237_0() throws IOException
{    doBitmaskTransparencyTest(BufferedImage.TYPE_4BYTE_ABGR, "bitmask4babgr.pdf");}
public void pdfbox_f8238_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));        int w = image.getWidth();    int h = image.getHeight();    BufferedImage argbImage = new BufferedImage(w, h, BufferedImage.TYPE_4BYTE_ABGR);    Graphics ag = argbImage.getGraphics();    ag.drawImage(image, 0, 0, null);    ag.dispose();    for (int x = 0; x < argbImage.getWidth(); ++x) {        for (int y = 0; y < argbImage.getHeight(); ++y) {            argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));        }    }                        argbImage = argbImage.getSubimage(1, 1, argbImage.getWidth() - 2, argbImage.getHeight() - 2);    w -= 2;    h -= 2;    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 8, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertTrue(colorCount(ximage.getSoftMask().getImage()) > image.getHeight() / 10);    doWritePDF(document, ximage, testResultsDir, "4babgr.pdf");}
public void pdfbox_f8239_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("gif.gif"));    assertEquals(Transparency.BITMASK, image.getColorModel().getTransparency());    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    int w = image.getWidth();    int h = image.getHeight();    validate(ximage, 8, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    checkIdentRGB(image, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 1, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(2, colorCount(ximage.getSoftMask().getImage()));    doWritePDF(document, ximage, testResultsDir, "gif.pdf");}
public void pdfbox_f8240_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(new File("target/imgs", "PDFBOX-4184-032163.jpg"));    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    validate(ximage, 8, image.getWidth(), image.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    doWritePDF(document, ximage, testResultsDir, "PDFBOX-4184-032163.pdf");}
private void pdfbox_f8241_0(BufferedImage expectedImage, BufferedImage actualImage)
{    String errMsg = "";    int w = expectedImage.getWidth();    int h = expectedImage.getHeight();    assertEquals(w, actualImage.getWidth());    assertEquals(h, actualImage.getHeight());    for (int y = 0; y < h; ++y) {        for (int x = 0; x < w; ++x) {            if ((expectedImage.getRGB(x, y) & 0xFFFFFF) != (actualImage.getRGB(x, y) & 0xFFFFFF)) {                errMsg = String.format("(%d,%d) %06X != %06X", x, y, expectedImage.getRGB(x, y) & 0xFFFFFF, actualImage.getRGB(x, y) & 0xFFFFFF);            }            assertEquals(errMsg, expectedImage.getRGB(x, y) & 0xFFFFFF, actualImage.getRGB(x, y) & 0xFFFFFF);        }    }}
private void pdfbox_f8242_0(int imageType, String pdfFilename) throws IOException
{    PDDocument document = new PDDocument();    int width = 257;    int height = 256;        BufferedImage argbImage = new BufferedImage(width, height, imageType);        Graphics2D g = argbImage.createGraphics();    GraphicsConfiguration gc = g.getDeviceConfiguration();    argbImage = gc.createCompatibleImage(width, height, Transparency.BITMASK);    g.dispose();        g = argbImage.createGraphics();    g.setColor(Color.red);    g.fillRect(0, 0, width, height);    g.dispose();    Random random = new Random();    random.setSeed(12345);            int startX = width / 2 - width / 8;    int endX = width / 2 + width / 8;    int startY = height / 2 - height / 8;    int endY = height / 2 + height / 8;    for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {                                    int alpha;            if ((x >= startX && x <= endX) || y >= startY && y <= endY) {                alpha = 128 + (int) (random.nextFloat() * 127);                assertTrue(alpha >= 128);                argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));                assertEquals(255, argbImage.getRGB(x, y) >>> 24);            } else {                alpha = (int) (random.nextFloat() * 127);                assertTrue(alpha < 128);                argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));                assertEquals(0, argbImage.getRGB(x, y) >>> 24);            }        }    }    PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);    validate(ximage, 8, width, height, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(argbImage, ximage.getImage());    checkIdentRGB(argbImage, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 1, width, height, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(2, colorCount(ximage.getSoftMask().getImage()));        BufferedImage maskImage = ximage.getSoftMask().getImage();        assertFalse(maskImage.getWidth() % 8 == 0);    assertEquals(Transparency.OPAQUE, maskImage.getTransparency());    for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if ((x >= startX && x <= endX) || y >= startY && y <= endY) {                assertEquals(0xFFFFFF, maskImage.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0, maskImage.getRGB(x, y) & 0xFFFFFF);            }        }    }                    BufferedImage rectImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);    g = rectImage.createGraphics();    g.setColor(Color.blue);    g.fillRect(0, 0, width, height);    g.dispose();    PDImageXObject ximage2 = LosslessFactory.createFromImage(document, rectImage);    PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(ximage2, 150, 300, ximage2.getWidth(), ximage2.getHeight());    contentStream.drawImage(ximage, 150, 300, ximage.getWidth(), ximage.getHeight());    contentStream.close();    File pdfFile = new File(testResultsDir, pdfFilename);    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile, (String) null);    new PDFRenderer(document).renderImage(0);    document.close();}
public void pdfbox_f8243_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    final ColorSpace targetCS = new ICC_ColorSpace(ICC_Profile.getInstance(this.getClass().getResourceAsStream("/org/apache/pdfbox/resources/icc/ISOcoated_v2_300_bas.icc")));    ColorConvertOp op = new ColorConvertOp(image.getColorModel().getColorSpace(), targetCS, null);    BufferedImage imageCMYK = op.filter(image, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imageCMYK);    validate(ximage, 8, imageCMYK.getWidth(), imageCMYK.getHeight(), "png", "ICCBased");    doWritePDF(document, ximage, testResultsDir, "cmyk.pdf");}
public void pdfbox_f8244_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    ColorSpace targetCS = ColorSpace.getInstance(ColorSpace.CS_sRGB);    int dataBufferType = DataBuffer.TYPE_USHORT;    final ColorModel colorModel = new ComponentColorModel(targetCS, false, false, ColorModel.OPAQUE, dataBufferType);    WritableRaster targetRaster = Raster.createInterleavedRaster(dataBufferType, image.getWidth(), image.getHeight(), targetCS.getNumComponents(), new Point(0, 0));    BufferedImage img16Bit = new BufferedImage(colorModel, targetRaster, false, new Hashtable());    ColorConvertOp op = new ColorConvertOp(image.getColorModel().getColorSpace(), targetCS, null);    op.filter(image, img16Bit);    PDImageXObject ximage = LosslessFactory.createFromImage(document, img16Bit);    validate(ximage, 16, img16Bit.getWidth(), img16Bit.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    doWritePDF(document, ximage, testResultsDir, "misc-16bit.pdf");}
public void pdfbox_f8245_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgBgr = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_BGR);    Graphics2D graphics = imgBgr.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgBgr);    validate(ximage, 8, imgBgr.getWidth(), imgBgr.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
public void pdfbox_f8246_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgRgb = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);    Graphics2D graphics = imgRgb.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgRgb);    validate(ximage, 8, imgRgb.getWidth(), imgRgb.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
public void pdfbox_f8247_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(this.getClass().getResourceAsStream("png.png"));    BufferedImage imgRgb = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);    Graphics2D graphics = imgRgb.createGraphics();    graphics.drawImage(image, 0, 0, null);    PDImageXObject ximage = LosslessFactory.createFromImage(document, imgRgb);    validate(ximage, 8, imgRgb.getWidth(), imgRgb.getHeight(), "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());}
public void pdfbox_f8248_0() throws IOException
{    PDDocument document = new PDDocument();    BufferedImage image = ImageIO.read(new File("target/imgs", "PDFBOX-4184-16bit.png"));    assertEquals(64, image.getColorModel().getPixelSize());    assertEquals(Transparency.TRANSLUCENT, image.getColorModel().getTransparency());    assertEquals(4, image.getRaster().getNumDataElements());    assertEquals(java.awt.image.DataBuffer.TYPE_USHORT, image.getRaster().getDataBuffer().getDataType());    PDImageXObject ximage = LosslessFactory.createFromImage(document, image);    int w = image.getWidth();    int h = image.getHeight();    validate(ximage, 16, w, h, "png", PDDeviceRGB.INSTANCE.getName());    checkIdent(image, ximage.getImage());    checkIdentRGB(image, ximage.getOpaqueImage());    assertNotNull(ximage.getSoftMask());    validate(ximage.getSoftMask(), 16, w, h, "png", PDDeviceGray.INSTANCE.getName());    assertEquals(35, colorCount(ximage.getSoftMask().getImage()));    doWritePDF(document, ximage, testResultsDir, "png16bit.pdf");}
protected void pdfbox_f8249_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8250_0() throws IOException
{    COSDictionary dict = new COSDictionary();    dict.setBoolean(COSName.IM, true);    int width = 31;    int height = 27;    dict.setInt(COSName.W, width);    dict.setInt(COSName.H, height);    dict.setInt(COSName.BPC, 1);    int rowbytes = width / 8;    if (rowbytes * 8 < width) {                                ++rowbytes;    }        int datalen = rowbytes * height;    byte[] data = new byte[datalen];    for (int i = 0; i < datalen; ++i) {        data[i] = (i / 4 % 2 == 0) ? (byte) Integer.parseInt("10101010", 2) : 0;    }    PDInlineImage inlineImage1 = new PDInlineImage(dict, data, null);    assertTrue(inlineImage1.isStencil());    assertEquals(width, inlineImage1.getWidth());    assertEquals(height, inlineImage1.getHeight());    assertEquals(1, inlineImage1.getBitsPerComponent());    COSDictionary dict2 = new COSDictionary();    dict2.addAll(dict);        COSArray decodeArray = new COSArray();    decodeArray.add(COSInteger.ONE);    decodeArray.add(COSInteger.ZERO);    dict2.setItem(COSName.DECODE, decodeArray);    PDInlineImage inlineImage2 = new PDInlineImage(dict2, data, null);    Paint paint = new Color(0, 0, 0);    BufferedImage stencilImage = inlineImage1.getStencilImage(paint);    assertEquals(width, stencilImage.getWidth());    assertEquals(height, stencilImage.getHeight());    BufferedImage stencilImage2 = inlineImage2.getStencilImage(paint);    assertEquals(width, stencilImage2.getWidth());    assertEquals(height, stencilImage2.getHeight());    BufferedImage image1 = inlineImage1.getImage();    assertEquals(width, image1.getWidth());    assertEquals(height, image1.getHeight());    BufferedImage image2 = inlineImage2.getImage();    assertEquals(width, image2.getWidth());    assertEquals(height, image2.getHeight());        boolean writeOk = ImageIO.write(image1, "png", new FileOutputStream(new File(testResultsDir + "/inline-grid1.png")));    assertTrue(writeOk);    BufferedImage bim1 = ImageIO.read(new File(testResultsDir + "/inline-grid1.png"));    assertNotNull(bim1);    assertEquals(width, bim1.getWidth());    assertEquals(height, bim1.getHeight());    writeOk = ImageIO.write(image2, "png", new FileOutputStream(new File(testResultsDir + "/inline-grid2.png")));    assertTrue(writeOk);    BufferedImage bim2 = ImageIO.read(new File(testResultsDir + "/inline-grid2.png"));    assertNotNull(bim2);    assertEquals(width, bim2.getWidth());    assertEquals(height, bim2.getHeight());        for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if (x % 2 == 0 && y % 2 == 0) {                assertEquals(0xFFFFFF, bim1.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0, bim1.getRGB(x, y) & 0xFFFFFF);            }        }    }        for (int x = 0; x < width; ++x) {        for (int y = 0; y < height; ++y) {            if (x % 2 == 0 && y % 2 == 0) {                assertEquals(0, bim2.getRGB(x, y) & 0xFFFFFF);            } else {                assertEquals(0xFFFFFF, bim2.getRGB(x, y) & 0xFFFFFF);            }        }    }    PDDocument document = new PDDocument();    PDPage page = new PDPage();    document.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false);    contentStream.drawImage(inlineImage1, 150, 400);    contentStream.drawImage(inlineImage1, 150, 500, inlineImage1.getWidth() * 2, inlineImage1.getHeight() * 2);    contentStream.drawImage(inlineImage1, 150, 600, inlineImage1.getWidth() * 4, inlineImage1.getHeight() * 4);    contentStream.drawImage(inlineImage2, 350, 400);    contentStream.drawImage(inlineImage2, 350, 500, inlineImage2.getWidth() * 2, inlineImage2.getHeight() * 2);    contentStream.drawImage(inlineImage2, 350, 600, inlineImage2.getWidth() * 4, inlineImage2.getHeight() * 4);    contentStream.close();    File pdfFile = new File(testResultsDir, "inline.pdf");    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile);    new PDFRenderer(document).renderImage(0);    document.close();}
public void pdfbox_f8251_0()
{        parentDir.mkdirs();}
public void pdfbox_f8252_0() throws IOException
{    checkImageConvert("png.png");}
public void pdfbox_f8253_0() throws IOException
{    checkImageConvert("png_rgb_gamma.png");}
public void pdfbox_f8254_0() throws IOException
{    checkImageConvert("png_rgb_romm_16bit.png");}
public void pdfbox_f8255_0() throws IOException
{    checkImageConvert("png_indexed.png");}
public void pdfbox_f8256_0() throws IOException
{    checkImageConvert("png_indexed_1bit_alpha.png");}
public void pdfbox_f8257_0() throws IOException
{    checkImageConvert("png_indexed_2bit_alpha.png");}
public void pdfbox_f8258_0() throws IOException
{    checkImageConvert("png_indexed_4bit_alpha.png");}
public void pdfbox_f8259_0() throws IOException
{    checkImageConvert("png_indexed_8bit_alpha.png");}
public void pdfbox_f8260_0() throws IOException
{        checkImageConvertFail("png_alpha_rgb.png");}
public void pdfbox_f8261_0() throws IOException
{        checkImageConvertFail("png_alpha_gray.png");}
public void pdfbox_f8262_0() throws IOException
{    checkImageConvertFail("png_gray.png");}
public void pdfbox_f8263_0() throws IOException
{    checkImageConvertFail("png_gray_with_gama.png");}
private void pdfbox_f8264_0(String name) throws IOException
{    PDDocument doc = new PDDocument();    byte[] imageBytes = IOUtils.toByteArray(PNGConverterTest.class.getResourceAsStream(name));    PDImageXObject pdImageXObject = PNGConverter.convertPNGImage(doc, imageBytes);    assertNull(pdImageXObject);    doc.close();}
private void pdfbox_f8265_0(String name) throws IOException
{    PDDocument doc = new PDDocument();    byte[] imageBytes = IOUtils.toByteArray(PNGConverterTest.class.getResourceAsStream(name));    PDImageXObject pdImageXObject = PNGConverter.convertPNGImage(doc, imageBytes);    assertNotNull(pdImageXObject);    PDPage page = new PDPage();    doc.addPage(page);    PDPageContentStream contentStream = new PDPageContentStream(doc, page);    contentStream.setNonStrokingColor(Color.PINK);    contentStream.addRect(0, 0, page.getCropBox().getWidth(), page.getCropBox().getHeight());    contentStream.fill();    contentStream.drawImage(pdImageXObject, 0, 0, pdImageXObject.getWidth(), pdImageXObject.getHeight());    contentStream.close();    doc.save(new File(parentDir, name + ".pdf"));    BufferedImage image = pdImageXObject.getImage();    checkIdent(ImageIO.read(new ByteArrayInputStream(imageBytes)), image);    doc.close();}
public void pdfbox_f8266_0()
{    assertFalse(PNGConverter.checkConverterState(null));    PNGConverter.PNGConverterState state = new PNGConverter.PNGConverterState();    assertFalse(PNGConverter.checkConverterState(state));    PNGConverter.Chunk invalidChunk = new PNGConverter.Chunk();    invalidChunk.bytes = new byte[0];    assertFalse(PNGConverter.checkChunkSane(invalidChunk));        PNGConverter.Chunk validChunk = new PNGConverter.Chunk();    validChunk.bytes = new byte[16];    validChunk.start = 4;    validChunk.length = 8;    validChunk.crc = 2077607535;    assertTrue(PNGConverter.checkChunkSane(validChunk));    state.IHDR = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.IDATs = Collections.singletonList(validChunk);    assertFalse(PNGConverter.checkConverterState(state));    state.IHDR = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.IDATs = new ArrayList<PNGConverter.Chunk>();    assertFalse(PNGConverter.checkConverterState(state));    state.IDATs = Collections.singletonList(validChunk);    assertTrue(PNGConverter.checkConverterState(state));    state.PLTE = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.PLTE = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.cHRM = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.cHRM = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.tRNS = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.tRNS = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.iCCP = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.iCCP = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.sRGB = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.sRGB = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.gAMA = invalidChunk;    assertFalse(PNGConverter.checkConverterState(state));    state.gAMA = validChunk;    assertTrue(PNGConverter.checkConverterState(state));    state.IDATs = Arrays.asList(validChunk, invalidChunk);    assertFalse(PNGConverter.checkConverterState(state));}
public void pdfbox_f8267_0()
{    PNGConverter.Chunk chunk = new PNGConverter.Chunk();    assertTrue(PNGConverter.checkChunkSane(null));    chunk.bytes = "IHDRsomedummyvaluesDummyValuesAtEnd".getBytes();    chunk.length = 19;    assertEquals(chunk.bytes.length, 35);    assertEquals("IHDRsomedummyvalues", new String(chunk.getData()));    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.start = 4;    assertEquals("somedummyvaluesDumm", new String(chunk.getData()));    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.crc = -1729802258;    assertTrue(PNGConverter.checkChunkSane(chunk));    chunk.start = 6;    assertFalse(PNGConverter.checkChunkSane(chunk));    chunk.length = 60;    assertFalse(PNGConverter.checkChunkSane(chunk));}
public void pdfbox_f8268_0()
{    byte[] b1 = "Hello World!".getBytes();    assertEquals(472456355, PNGConverter.crc(b1, 0, b1.length));    assertEquals(-632335482, PNGConverter.crc(b1, 2, b1.length - 4));}
public void pdfbox_f8269_0()
{    assertEquals(COSName.PERCEPTUAL, PNGConverter.mapPNGRenderIntent(0));    assertEquals(COSName.RELATIVE_COLORIMETRIC, PNGConverter.mapPNGRenderIntent(1));    assertEquals(COSName.SATURATION, PNGConverter.mapPNGRenderIntent(2));    assertEquals(COSName.ABSOLUTE_COLORIMETRIC, PNGConverter.mapPNGRenderIntent(3));    assertNull(PNGConverter.mapPNGRenderIntent(-1));    assertNull(PNGConverter.mapPNGRenderIntent(4));}
public static void pdfbox_f8270_0(PDImageXObject ximage, int bpc, int width, int height, String format, String colorSpaceName) throws IOException
{        assertNotNull(ximage);    COSStream cosStream = ximage.getCOSObject();    assertNotNull(cosStream);    assertEquals(COSName.XOBJECT, cosStream.getItem(COSName.TYPE));    assertEquals(COSName.IMAGE, cosStream.getItem(COSName.SUBTYPE));    assertTrue(ximage.getCOSObject().getLength() > 0);    assertEquals(bpc, ximage.getBitsPerComponent());    assertEquals(width, ximage.getWidth());    assertEquals(height, ximage.getHeight());    assertEquals(format, ximage.getSuffix());    assertEquals(colorSpaceName, ximage.getColorSpace().getName());        assertNotNull(ximage.getImage());    assertEquals(ximage.getWidth(), ximage.getImage().getWidth());    assertEquals(ximage.getHeight(), ximage.getImage().getHeight());    boolean canEncode = true;    boolean writeOk;        if ("jpg".equals(format) && ximage.getImage().getType() == BufferedImage.TYPE_INT_ARGB) {        ImageWriter writer = ImageIO.getImageWritersBySuffix(format).next();        ImageWriterSpi originatingProvider = writer.getOriginatingProvider();        canEncode = originatingProvider.canEncodeImage(ximage.getImage());    }    if (canEncode) {        writeOk = ImageIO.write(ximage.getImage(), format, new NullOutputStream());        assertTrue(writeOk);    }    writeOk = ImageIO.write(ximage.getOpaqueImage(), format, new NullOutputStream());    assertTrue(writeOk);}
public void pdfbox_f8271_0(int b) throws IOException
{}
 static int pdfbox_f8272_0(BufferedImage bim)
{    Set<Integer> colors = new HashSet<>();    int w = bim.getWidth();    int h = bim.getHeight();    for (int y = 0; y < h; y++) {        for (int x = 0; x < w; x++) {            colors.add(bim.getRGB(x, y));        }    }    return colors.size();}
 static void pdfbox_f8273_0(PDDocument document, PDImageXObject ximage, File testResultsDir, String filename) throws IOException
{    File pdfFile = new File(testResultsDir, filename);                PDPage page = new PDPage();    document.addPage(page);    try (PDPageContentStream contentStream = new PDPageContentStream(document, page, AppendMode.APPEND, false)) {        contentStream.drawImage(ximage, 150, 300);        contentStream.drawImage(ximage, 200, 350);    }        assertEquals(1, count(document.getPage(0).getResources().getXObjectNames()));    document.save(pdfFile);    document.close();    document = PDDocument.load(pdfFile);    assertEquals(1, count(document.getPage(0).getResources().getXObjectNames()));    new PDFRenderer(document).renderImage(0);    document.close();}
private static int pdfbox_f8274_0(Iterable<COSName> iterable)
{    int count = 0;    for (COSName name : iterable) {        count++;    }    return count;}
public static void pdfbox_f8275_0(BufferedImage expectedImage, BufferedImage actualImage)
{    String errMsg = "";    int w = expectedImage.getWidth();    int h = expectedImage.getHeight();    assertEquals(w, actualImage.getWidth());    assertEquals(h, actualImage.getHeight());    for (int y = 0; y < h; ++y) {        for (int x = 0; x < w; ++x) {            if (expectedImage.getRGB(x, y) != actualImage.getRGB(x, y)) {                errMsg = String.format("(%d,%d) expected: <%08X> but was: <%08X>; ", x, y, expectedImage.getRGB(x, y), actualImage.getRGB(x, y));            }            assertEquals(errMsg, expectedImage.getRGB(x, y), actualImage.getRGB(x, y));        }    }}
protected void pdfbox_f8276_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8277_0() throws Exception
{    PDDocument doc = new PDDocument();    try {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup background = new PDOptionalContentGroup("background");        ocprops.addGroup(background);        assertTrue(ocprops.isGroupEnabled("background"));                PDOptionalContentGroup enabled = new PDOptionalContentGroup("enabled");        ocprops.addGroup(enabled);        assertFalse(ocprops.setGroupEnabled("enabled", true));        assertTrue(ocprops.isGroupEnabled("enabled"));                PDOptionalContentGroup disabled = new PDOptionalContentGroup("disabled");        ocprops.addGroup(disabled);        assertFalse(ocprops.setGroupEnabled("disabled", true));        assertTrue(ocprops.isGroupEnabled("disabled"));        assertTrue(ocprops.setGroupEnabled("disabled", false));        assertFalse(ocprops.isGroupEnabled("disabled"));                PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false);        PDFont font = PDType1Font.HELVETICA_BOLD;        contentStream.beginMarkedContent(COSName.OC, background);        contentStream.beginText();        contentStream.setFont(font, 14);        contentStream.newLineAtOffset(80, 700);        contentStream.showText("PDF 1.5: Optional Content Groups");        contentStream.endText();        font = PDType1Font.HELVETICA;        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 680);        contentStream.showText("You should see a green textline, but no red text line.");        contentStream.endText();        contentStream.endMarkedContent();                contentStream.beginMarkedContent(COSName.OC, enabled);        contentStream.setNonStrokingColor(Color.GREEN);        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 600);        contentStream.showText("This is from an enabled layer. If you see this, that's good.");        contentStream.endText();        contentStream.endMarkedContent();                contentStream.beginMarkedContent(COSName.OC, disabled);        contentStream.setNonStrokingColor(Color.RED);        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(80, 500);        contentStream.showText("This is from a disabled layer. If you see this, that's NOT good!");        contentStream.endText();        contentStream.endMarkedContent();        contentStream.close();        File targetFile = new File(testResultsDir, "ocg-generation.pdf");        doc.save(targetFile.getAbsolutePath());    } finally {        doc.close();    }}
public void pdfbox_f8278_0() throws Exception
{    File pdfFile = new File(testResultsDir, "ocg-generation.pdf");    if (!pdfFile.exists()) {        testOCGGeneration();    }    PDDocument doc = PDDocument.load(pdfFile);    try {        assertEquals(1.5f, doc.getVersion());        PDDocumentCatalog catalog = doc.getDocumentCatalog();        PDPage page = doc.getPage(0);        PDResources resources = page.getResources();        COSName mc0 = COSName.getPDFName("oc1");        PDOptionalContentGroup ocg = (PDOptionalContentGroup) resources.getProperties(mc0);        assertNotNull(ocg);        assertEquals("background", ocg.getName());        assertNull(resources.getProperties(COSName.getPDFName("inexistent")));        PDOptionalContentProperties ocgs = catalog.getOCProperties();        assertEquals(BaseState.ON, ocgs.getBaseState());        Set<String> names = new java.util.HashSet<>(Arrays.asList(ocgs.getGroupNames()));        assertEquals(3, names.size());        assertTrue(names.contains("background"));        assertTrue(ocgs.isGroupEnabled("background"));        assertTrue(ocgs.isGroupEnabled("enabled"));        assertFalse(ocgs.isGroupEnabled("disabled"));        ocgs.setGroupEnabled("background", false);        assertFalse(ocgs.isGroupEnabled("background"));        PDOptionalContentGroup background = ocgs.getGroup("background");        assertEquals(ocg.getName(), background.getName());        assertNull(ocgs.getGroup("inexistent"));        Collection<PDOptionalContentGroup> coll = ocgs.getOptionalContentGroups();        assertEquals(3, coll.size());        Set<String> nameSet = new HashSet<>();        for (PDOptionalContentGroup ocg2 : coll) {            nameSet.add(ocg2.getName());        }        assertTrue(nameSet.contains("background"));        assertTrue(nameSet.contains("enabled"));        assertTrue(nameSet.contains("disabled"));    } finally {        doc.close();    }}
public void pdfbox_f8279_0() throws Exception
{    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup visible = new PDOptionalContentGroup("layer");        ocprops.addGroup(visible);        assertTrue(ocprops.isGroupEnabled(visible));                PDOptionalContentGroup invisible = new PDOptionalContentGroup("layer");        ocprops.addGroup(invisible);        assertFalse(ocprops.setGroupEnabled(invisible, false));        assertFalse(ocprops.isGroupEnabled(invisible));                assertTrue(ocprops.isGroupEnabled(visible));                try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginMarkedContent(COSName.OC, visible);            contentStream.beginText();            contentStream.setFont(font, 14);            contentStream.newLineAtOffset(80, 700);            contentStream.showText("PDF 1.5: Optional Content Groups");            contentStream.endText();            font = PDType1Font.HELVETICA;            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 680);            contentStream.showText("You should see this text, but no red text line.");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, invisible);            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("This is from a disabled layer. If you see this, that's NOT good!");            contentStream.endText();            contentStream.endMarkedContent();        }        File targetFile = new File(testResultsDir, "ocg-generation-same-name.pdf");        doc.save(targetFile.getAbsolutePath());    }}
public void pdfbox_f8280_0() throws IOException
{    BufferedImage expectedImage;    BufferedImage actualImage;    try (PDDocument doc = new PDDocument()) {                PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }                PDOptionalContentProperties ocprops = new PDOptionalContentProperties();        doc.getDocumentCatalog().setOCProperties(ocprops);                        PDOptionalContentGroup background = new PDOptionalContentGroup("background");        ocprops.addGroup(background);        assertTrue(ocprops.isGroupEnabled("background"));                PDOptionalContentGroup enabled = new PDOptionalContentGroup("science");        ocprops.addGroup(enabled);        assertFalse(ocprops.setGroupEnabled("science", true));        assertTrue(ocprops.isGroupEnabled("science"));                PDOptionalContentGroup disabled1 = new PDOptionalContentGroup("alternative");        ocprops.addGroup(disabled1);                PDOptionalContentGroup disabled2 = new PDOptionalContentGroup("alternative");        ocprops.addGroup(disabled2);        assertFalse(ocprops.setGroupEnabled("alternative", false));        assertFalse(ocprops.isGroupEnabled("alternative"));                try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA_BOLD;            contentStream.beginMarkedContent(COSName.OC, background);            contentStream.beginText();            contentStream.setFont(font, 14);            contentStream.newLineAtOffset(80, 700);            contentStream.showText("PDF 1.5: Optional Content Groups");            contentStream.endText();            contentStream.endMarkedContent();            font = PDType1Font.HELVETICA;                        contentStream.beginMarkedContent(COSName.OC, enabled);            contentStream.setNonStrokingColor(Color.GREEN);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 600);            contentStream.showText("The earth is a sphere");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, disabled1);            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("Alternative 1: The earth is a flat circle");            contentStream.endText();            contentStream.endMarkedContent();                        contentStream.beginMarkedContent(COSName.OC, disabled2);            contentStream.setNonStrokingColor(Color.BLUE);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 450);            contentStream.showText("Alternative 2: The earth is a flat parallelogram");            contentStream.endText();            contentStream.endMarkedContent();        }        doc.getDocumentCatalog().setPageMode(PageMode.USE_OPTIONAL_CONTENT);        File targetFile = new File(testResultsDir, "ocg-generation-same-name-off.pdf");        doc.save(targetFile.getAbsolutePath());    }        try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDResources resources = page.getResources();        if (resources == null) {            resources = new PDResources();            page.setResources(resources);        }        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {            PDFont font = PDType1Font.HELVETICA;            contentStream.setNonStrokingColor(Color.RED);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 500);            contentStream.showText("Alternative 1: The earth is a flat circle");            contentStream.endText();            contentStream.setNonStrokingColor(Color.BLUE);            contentStream.beginText();            contentStream.setFont(font, 12);            contentStream.newLineAtOffset(80, 450);            contentStream.showText("Alternative 2: The earth is a flat parallelogram");            contentStream.endText();        }        expectedImage = new PDFRenderer(doc).renderImage(0, 2);        ImageIO.write(expectedImage, "png", new File(testResultsDir, "ocg-generation-same-name-off-expected.png"));    }        try (PDDocument doc = PDDocument.load(new File(testResultsDir, "ocg-generation-same-name-off.pdf"))) {        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("background", false);        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("science", false);        doc.getDocumentCatalog().getOCProperties().setGroupEnabled("alternative", true);        actualImage = new PDFRenderer(doc).renderImage(0, 2);        ImageIO.write(actualImage, "png", new File(testResultsDir, "ocg-generation-same-name-off-actual.png"));    }        DataBufferInt expectedData = (DataBufferInt) expectedImage.getRaster().getDataBuffer();    DataBufferInt actualData = (DataBufferInt) actualImage.getRaster().getDataBuffer();    Assert.assertArrayEquals(expectedData.getData(), actualData.getData());}
public void pdfbox_f8281_0()
{    COSArray ar = new COSArray();    ar.add(COSInteger.ONE);    ar.add(COSInteger.TWO);    PDLineDashPattern dash = new PDLineDashPattern(ar, 3);    COSArray dashBase = (COSArray) dash.getCOSObject();    COSArray dashArray = (COSArray) dashBase.getObject(0);    assertEquals(2, dashBase.size());    assertEquals(2, dashArray.size());    assertEquals(new COSFloat(1), dashArray.get(0));    assertEquals(new COSFloat(2), dashArray.get(1));    assertEquals(COSInteger.THREE, dashBase.get(1));    System.out.println(dash);}
public void pdfbox_f8282_0()
{        final String value = "AbsoluteColorimetric";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.ABSOLUTE_COLORIMETRIC, retval);}
public void pdfbox_f8283_0()
{        final String value = "RelativeColorimetric";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.RELATIVE_COLORIMETRIC, retval);}
public void pdfbox_f8284_0()
{        final String value = "Perceptual";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.PERCEPTUAL, retval);}
public void pdfbox_f8285_0()
{        final String value = "Saturation";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.SATURATION, retval);}
public void pdfbox_f8286_0()
{        final String value = "";        final RenderingIntent retval = RenderingIntent.fromString(value);        Assert.assertEquals(RenderingIntent.RELATIVE_COLORIMETRIC, retval);}
public void pdfbox_f8287_0()
{        final RenderingIntent objectUnderTest = RenderingIntent.ABSOLUTE_COLORIMETRIC;        final String retval = objectUnderTest.stringValue();        Assert.assertEquals("AbsoluteColorimetric", retval);}
public void pdfbox_f8288_0()
{    PDActionURI actionURI = new PDActionURI();    assertNull(actionURI.getURI());    actionURI.setURI("http://.com/");    assertEquals("http://.com/", actionURI.getURI());}
public void pdfbox_f8289_0() throws IOException
{    PDActionURI actionURI = new PDActionURI();        COSString utf16URI = COSString.parseHex("FEFF0068007400740070003A002F002F00770077" + "0077002E006E00610070002E006500640075002F0063006100740061006C006F006700" + "2F00310031003100340030002E00680074006D006C");    actionURI.getCOSObject().setItem(COSName.URI, utf16URI);    assertEquals("http://www.nap.edu/catalog/11140.html", actionURI.getURI());}
public void pdfbox_f8290_0() throws IOException
{    PDActionURI actionURI = new PDActionURI();    COSString utf16URI = COSString.parseHex("FFFE68007400740070003A00");    actionURI.getCOSObject().setItem(COSName.URI, utf16URI);    assertEquals("http:", actionURI.getURI());}
public void pdfbox_f8291_0()
{    PDActionURI actionURI = new PDActionURI();    actionURI.setURI("http://pdfbox.apache.org/");    assertEquals("http://pdfbox.apache.org/", actionURI.getURI());}
public void pdfbox_f8292_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    OUT_DIR.mkdirs();}
public void pdfbox_f8293_0() throws IOException
{    PDPage page = document.getPage(0);    PDAnnotation annotation = page.getAnnotations().get(0);        PDAppearanceStream appearanceContentStream = annotation.getNormalAppearanceStream();    PDFStreamParser streamParser = new PDFStreamParser(appearanceContentStream.getContents());    streamParser.parse();    List<Object> tokensForOriginal = streamParser.getTokens();        annotation.getCOSObject().removeItem(COSName.AP);    annotation.constructAppearances();    appearanceContentStream = annotation.getNormalAppearanceStream();    streamParser = new PDFStreamParser(appearanceContentStream.getContents());    streamParser.parse();    List<Object> tokensForPdfbox = streamParser.getTokens();    assertEquals("The number of tokens in the content stream should be the same", tokensForOriginal.size(), tokensForPdfbox.size());    int actualToken = 0;    for (Object tokenForOriginal : tokensForOriginal) {        Object tokenForPdfbox = tokensForPdfbox.get(actualToken);        assertEquals("The tokens should have the same type", tokenForOriginal.getClass().getName(), tokenForPdfbox.getClass().getName());        if (tokenForOriginal instanceof Operator) {            assertEquals("The operator generated by PDFBox should be the same Operator", ((Operator) tokenForOriginal).getName(), ((Operator) tokenForPdfbox).getName());        } else if (tokenForOriginal instanceof COSFloat) {            assertTrue("The difference between the numbers should be smaller than " + DELTA, (Math.abs(((COSFloat) tokenForOriginal).floatValue() - ((COSFloat) tokenForPdfbox).floatValue()) < DELTA));        }        actualToken++;    }        File file = new File(OUT_DIR, NAME_OF_PDF + "-newAP.pdf");    document.save(file);}
public void pdfbox_f8294_0() throws IOException
{    File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8295_0() throws IOException
{    document.close();}
public void pdfbox_f8296_0()
{    PDAnnotation annotation = new PDAnnotationWidget();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8297_0()
{    PDDocument document = new PDDocument();    PDAcroForm acroForm = new PDAcroForm(document);    PDTextField textField = new PDTextField(acroForm);    PDAnnotation annotation = textField.getWidgets().get(0);    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8298_0()
{    PDAnnotation annotation = new PDAnnotationCircle();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationCircle.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8299_0() throws IOException
{    rectangle = new PDRectangle();    rectangle.setLowerLeftX(91.5958f);    rectangle.setLowerLeftY(741.91f);    rectangle.setUpperRightX(113.849f);    rectangle.setUpperRightY(757.078f);}
public void pdfbox_f8300_0()
{    PDAnnotation annotation = new PDAnnotationSquare();    assertEquals(COSName.ANNOT, annotation.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationSquare.SUB_TYPE, annotation.getCOSObject().getNameAsString(COSName.SUBTYPE));}
public void pdfbox_f8301_0() throws IOException
{        final int borderWidth = 1;    try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        List<PDAnnotation> annotations = page.getAnnotations();        PDAnnotationSquareCircle annotation = new PDAnnotationSquare();        PDBorderStyleDictionary borderThin = new PDBorderStyleDictionary();        borderThin.setWidth(borderWidth);        PDColor red = new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE);        annotation.setContents("Square Annotation");        annotation.setColor(red);        annotation.setBorderStyle(borderThin);        annotation.setRectangle(rectangle);        annotation.constructAppearances();        annotations.add(annotation);    }}
public void pdfbox_f8302_0() throws IOException
{        final int borderWidth = 1;    File file = new File(IN_DIR, NAME_OF_PDF);    try (PDDocument document = PDDocument.load(file)) {        PDPage page = document.getPage(0);        List<PDAnnotation> annotations = page.getAnnotations();        PDAnnotationSquareCircle annotation = (PDAnnotationSquareCircle) annotations.get(0);                assertNotNull("Appearance dictionary shall not be null", annotation.getAppearance());        assertNotNull("Normal appearance shall not be null", annotation.getAppearance().getNormalAppearance());        PDAppearanceStream appearanceStream = annotation.getAppearance().getNormalAppearance().getAppearanceStream();        assertNotNull("Appearance stream shall not be null", appearanceStream);        assertEquals(rectangle.getLowerLeftX(), appearanceStream.getBBox().getLowerLeftX(), DELTA);        assertEquals(rectangle.getLowerLeftY(), appearanceStream.getBBox().getLowerLeftY(), DELTA);        assertEquals(rectangle.getWidth(), appearanceStream.getBBox().getWidth(), DELTA);        assertEquals(rectangle.getHeight(), appearanceStream.getBBox().getHeight(), DELTA);        Matrix matrix = appearanceStream.getMatrix();        assertNotNull("Matrix shall not be null", matrix);                assertEquals(-rectangle.getLowerLeftX(), matrix.getTranslateX(), DELTA);        assertEquals(-rectangle.getLowerLeftY(), matrix.getTranslateY(), DELTA);                PDStream contentStream = appearanceStream.getContentStream();        assertNotNull("Content stream shall not be null", contentStream);        PDFStreamParser parser = new PDFStreamParser(appearanceStream.getContents());        parser.parse();        List<Object> tokens = parser.getTokens();                assertEquals(10, tokens.size());                assertEquals(1, ((COSInteger) tokens.get(0)).intValue());        assertEquals(0, ((COSInteger) tokens.get(1)).intValue());        assertEquals(0, ((COSInteger) tokens.get(2)).intValue());        assertEquals("RG", ((Operator) tokens.get(3)).getName());                        assertEquals(rectangle.getLowerLeftX() + borderWidth, ((COSFloat) tokens.get(4)).floatValue(), DELTA);        assertEquals(rectangle.getLowerLeftY() + borderWidth, ((COSFloat) tokens.get(5)).floatValue(), DELTA);        assertEquals(rectangle.getWidth() - 2 * borderWidth, ((COSFloat) tokens.get(6)).floatValue(), DELTA);        assertEquals(rectangle.getHeight() - 2 * borderWidth, ((COSFloat) tokens.get(7)).floatValue(), DELTA);        assertEquals("re", ((Operator) tokens.get(8)).getName());        assertEquals("S", ((Operator) tokens.get(9)).getName());    }}
public void pdfbox_f8303_0()
{    PDDocumentOutline outline = new PDDocumentOutline();    PDOutlineItem firstLevelChild = new PDOutlineItem();    outline.addLast(firstLevelChild);    PDOutlineItem secondLevelChild = new PDOutlineItem();    firstLevelChild.addLast(secondLevelChild);    assertEquals(0, secondLevelChild.getOpenCount());    assertEquals(-1, firstLevelChild.getOpenCount());    assertFalse("Outlines count cannot be " + outline.getOpenCount(), outline.getOpenCount() < 0);}
public void pdfbox_f8304_0()
{    PDDocumentOutline outline = new PDDocumentOutline();    PDOutlineItem root = new PDOutlineItem();    outline.addLast(root);    assertEquals(1, outline.getOpenCount());    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(1, outline.getOpenCount());    root.addLast(new PDOutlineItem());    assertEquals(-2, root.getOpenCount());    assertEquals(1, outline.getOpenCount());    root.openNode();    assertEquals(2, root.getOpenCount());    assertEquals(3, outline.getOpenCount());}
public void pdfbox_f8305_0()
{    PDOutlineItem first = new PDOutlineItem();    PDOutlineItemIterator iterator = new PDOutlineItemIterator(first);    assertTrue(iterator.hasNext());    assertEquals(first, iterator.next());    assertFalse(iterator.hasNext());}
public void pdfbox_f8306_0()
{    PDOutlineItem first = new PDOutlineItem();    PDOutlineItem second = new PDOutlineItem();    first.setNextSibling(second);    PDOutlineItemIterator iterator = new PDOutlineItemIterator(first);    assertTrue(iterator.hasNext());    assertEquals(first, iterator.next());    assertTrue(iterator.hasNext());    assertEquals(second, iterator.next());    assertFalse(iterator.hasNext());}
public void pdfbox_f8307_0()
{    new PDOutlineItemIterator(new PDOutlineItem()).remove();}
public void pdfbox_f8308_0()
{    PDOutlineItemIterator iterator = new PDOutlineItemIterator(null);    assertFalse(iterator.hasNext());}
public void pdfbox_f8309_0()
{    root = new PDOutlineItem();    first = new PDOutlineItem();    second = new PDOutlineItem();    root.addLast(first);    root.addLast(second);    newSibling = new PDOutlineItem();    newSibling.addLast(new PDOutlineItem());    newSibling.addLast(new PDOutlineItem());}
public void pdfbox_f8310_0()
{    newSibling.openNode();    root.openNode();    assertEquals(2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(5, root.getOpenCount());}
public void pdfbox_f8311_0()
{    newSibling.openNode();    root.openNode();    assertEquals(2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(5, root.getOpenCount());}
public void pdfbox_f8312_0()
{    newSibling.openNode();    assertEquals(-2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-5, root.getOpenCount());}
public void pdfbox_f8313_0()
{    newSibling.openNode();    assertEquals(-2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-5, root.getOpenCount());}
public void pdfbox_f8314_0()
{    root.openNode();    assertEquals(2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(3, root.getOpenCount());}
public void pdfbox_f8315_0()
{    root.openNode();    assertEquals(2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(3, root.getOpenCount());}
public void pdfbox_f8316_0()
{    assertEquals(-2, root.getOpenCount());    first.insertSiblingAfter(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-3, root.getOpenCount());}
public void pdfbox_f8317_0()
{    assertEquals(-2, root.getOpenCount());    second.insertSiblingBefore(newSibling);    assertEquals(first.getNextSibling(), newSibling);    assertEquals(second.getPreviousSibling(), newSibling);    assertEquals(-3, root.getOpenCount());}
public void pdfbox_f8318_0()
{    assertEquals(root.getFirstChild(), first);    PDOutlineItem newSibling = new PDOutlineItem();    first.insertSiblingBefore(newSibling);    assertEquals(first.getPreviousSibling(), newSibling);    assertEquals(root.getFirstChild(), newSibling);}
public void pdfbox_f8319_0()
{    assertEquals(root.getFirstChild(), first);    PDOutlineItem newSibling = new PDOutlineItem();    root.insertSiblingBefore(newSibling);    assertEquals(root.getPreviousSibling(), newSibling);}
public void pdfbox_f8320_0()
{    assertEquals(root.getLastChild(), second);    PDOutlineItem newSibling = new PDOutlineItem();    second.insertSiblingAfter(newSibling);    assertEquals(second.getNextSibling(), newSibling);    assertEquals(root.getLastChild(), newSibling);}
public void pdfbox_f8321_0()
{    assertEquals(root.getLastChild(), second);    PDOutlineItem newSibling = new PDOutlineItem();    root.insertSiblingAfter(newSibling);    assertEquals(root.getNextSibling(), newSibling);}
public void pdfbox_f8322_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.insertSiblingBefore(child);}
public void pdfbox_f8323_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.insertSiblingAfter(child);}
public void pdfbox_f8324_0()
{    root = new PDOutlineItem();}
public void pdfbox_f8325_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    PDDocumentOutline outline = new PDDocumentOutline();    outline.addLast(root);    assertNull(outline.getParent());    assertEquals(outline, root.getParent());    assertEquals(root, child.getParent());}
public void pdfbox_f8326_0()
{    assertNull(root.getLastChild());}
public void pdfbox_f8327_0()
{    assertNull(root.getFirstChild());}
public void pdfbox_f8328_0()
{    PDOutlineItem child = new PDOutlineItem();    assertEquals(0, root.getOpenCount());    root.addLast(child);    root.openNode();    assertTrue(root.isNodeOpen());    assertEquals(1, root.getOpenCount());    root.openNode();    assertTrue(root.isNodeOpen());    assertEquals(1, root.getOpenCount());}
public void pdfbox_f8329_0()
{    PDOutlineItem child = new PDOutlineItem();    assertEquals(0, root.getOpenCount());    root.addLast(child);    root.openNode();    root.closeNode();    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());    root.closeNode();    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());}
public void pdfbox_f8330_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    child.openNode();    assertFalse(child.isNodeOpen());}
public void pdfbox_f8331_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    assertFalse(root.isNodeOpen());    assertEquals(-1, root.getOpenCount());}
public void pdfbox_f8332_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(child);    root.openNode();    assertEquals(3, root.getOpenCount());    assertEquals(2, child.getOpenCount());    child.closeNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());}
public void pdfbox_f8333_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(child);    assertEquals(-3, root.getOpenCount());    assertEquals(2, child.getOpenCount());    child.closeNode();    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());}
public void pdfbox_f8334_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(child);    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    child.openNode();    assertEquals(3, root.getOpenCount());    assertEquals(2, child.getOpenCount());}
public void pdfbox_f8335_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(child);    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    child.openNode();    assertEquals(-3, root.getOpenCount());    assertEquals(2, child.getOpenCount());}
public void pdfbox_f8336_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addLast(child);    assertEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());}
public void pdfbox_f8337_0()
{    PDOutlineItem child = new PDOutlineItem();    root.addFirst(child);    assertEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());}
public void pdfbox_f8338_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(4, root.getOpenCount());}
public void pdfbox_f8339_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    child.openNode();    root.addFirst(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(4, root.getOpenCount());}
public void pdfbox_f8340_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    child.openNode();    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(-4, root.getOpenCount());}
public void pdfbox_f8341_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    child.openNode();    root.addFirst(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(-4, root.getOpenCount());}
public void pdfbox_f8342_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(2, root.getOpenCount());}
public void pdfbox_f8343_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    root.addFirst(new PDOutlineItem());    root.openNode();    assertEquals(1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(2, root.getOpenCount());}
public void pdfbox_f8344_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addLast(new PDOutlineItem());    child.addLast(new PDOutlineItem());    root.addLast(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addLast(child);    assertNotEquals(child, root.getFirstChild());    assertEquals(child, root.getLastChild());    assertEquals(-2, root.getOpenCount());}
public void pdfbox_f8345_0()
{    PDOutlineItem child = new PDOutlineItem();    child.addFirst(new PDOutlineItem());    child.addFirst(new PDOutlineItem());    root.addFirst(new PDOutlineItem());    assertEquals(-1, root.getOpenCount());    assertEquals(-2, child.getOpenCount());    root.addFirst(child);    assertNotEquals(child, root.getLastChild());    assertEquals(child, root.getFirstChild());    assertEquals(-2, root.getOpenCount());}
public void pdfbox_f8346_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.addLast(child);}
public void pdfbox_f8347_0()
{    PDOutlineItem child = new PDOutlineItem();    child.insertSiblingAfter(new PDOutlineItem());    child.insertSiblingAfter(new PDOutlineItem());    root.addFirst(child);}
public void pdfbox_f8348_0()
{    root.addFirst(new PDOutlineItem());    assertEquals(root.getFirstChild(), root.getLastChild());}
public void pdfbox_f8349_0()
{    PDOutlineItem first = new PDOutlineItem();    root.addFirst(first);    root.addLast(new PDOutlineItem());    PDOutlineItem second = new PDOutlineItem();    first.insertSiblingAfter(second);    int counter = 0;    for (PDOutlineItem current : root.children()) {        counter++;    }    assertEquals(3, counter);}
public void pdfbox_f8350_0()
{    int counter = 0;    for (PDOutlineItem current : new PDOutlineItem().children()) {        counter++;    }    assertEquals(0, counter);}
public void pdfbox_f8351_0()
{}
public void pdfbox_f8352_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
public void pdfbox_f8353_0() throws IOException
{            PDField field = acroForm.getField("pdfbox.portrait.single.rotation0");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation90");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation180");    field.setValue(field.getFullyQualifiedName());    field = acroForm.getField("pdfbox.portrait.single.rotation270");    field.setValue(field.getFullyQualifiedName());        field = acroForm.getField("pdfbox.portrait.multi.rotation0");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation90");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation180");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.portrait.multi.rotation270");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);            field = acroForm.getField("pdfbox.page90.single.rotation0");    field.setValue("pdfbox.page90.single.rotation0");    field = acroForm.getField("pdfbox.page90.single.rotation90");    field.setValue("pdfbox.page90.single.rotation90");    field = acroForm.getField("pdfbox.page90.single.rotation180");    field.setValue("pdfbox.page90.single.rotation180");    field = acroForm.getField("pdfbox.page90.single.rotation270");    field.setValue("pdfbox.page90.single.rotation270");        field = acroForm.getField("pdfbox.page90.multi.rotation0");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation90");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation180");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);    field = acroForm.getField("pdfbox.page90.multi.rotation270");    field.setValue(field.getFullyQualifiedName() + "\n" + TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                        System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8354_0() throws IOException
{    document.close();}
public void pdfbox_f8355_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
public void pdfbox_f8356_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("AlignLeft");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small_Outside");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium_Outside");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide_Clipped");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide_Outside");    field.setValue(TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8357_0() throws IOException
{    document.close();}
public void pdfbox_f8358_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();}
public void pdfbox_f8359_0() throws IOException
{    acroForm.getField("pdfbox-nul").setValue("NUL\0NUL");}
public void pdfbox_f8360_0() throws IOException
{    acroForm.getField("pdfbox-tab").setValue("TAB\tTAB");}
public void pdfbox_f8361_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-space");    field.setValue("SPACE SPACE");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-space"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8362_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-cr");    field.setValue("CR\rCR");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-cr"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8363_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-lf");    field.setValue("LF\nLF");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-lf"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8364_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-crlf");    field.setValue("CRLF\r\nCRLF");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-crlf"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8365_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-lfcr");    field.setValue("LFCR\n\rLFCR");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-lfcr"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8366_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-linebreak");    field.setValue("linebreak\u2028linebreak");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-linebreak"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8367_0() throws IOException
{    PDField field = acroForm.getField("pdfbox-paragraphbreak");    field.setValue("paragraphbreak\u2029paragraphbreak");    List<String> pdfboxValues = getStringsFromStream(field);    List<String> acrobatValues = getStringsFromStream(acroForm.getField("acrobat-paragraphbreak"));    assertEquals(pdfboxValues, acrobatValues);}
public void pdfbox_f8368_0() throws IOException
{    document.close();}
private List<String> pdfbox_f8369_0(PDField field) throws IOException
{    PDAnnotationWidget widget = field.getWidgets().get(0);    PDFStreamParser parser = new PDFStreamParser(widget.getNormalAppearanceStream().getContents());    Object token = parser.parseNextToken();    List<String> stringValues = new ArrayList<>();    while (token != null) {        if (token instanceof COSString) {                                                stringValues.add(((COSString) token).getString().trim());        }        token = parser.parseNextToken();    }    return stringValues;}
public void pdfbox_f8370_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();        PDTextField field = (PDTextField) acroForm.getField("SingleAnnotation");    field.setValue("single annotation");    field = (PDTextField) acroForm.getField("MultipeAnnotations-SameLayout");    field.setValue("same layout");    field = (PDTextField) acroForm.getField("MultipleAnnotations-DifferentLayout");    field.setValue("different layout");    File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);}
public void pdfbox_f8371_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("SingleAnnotation");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue(contentAsString.indexOf(fieldFontSetting) > 0);    }}
public void pdfbox_f8372_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("MultipeAnnotations-SameLayout");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue("font setting in content stream shall be " + fieldFontSetting, contentAsString.indexOf(fieldFontSetting) > 0);    }}
public void pdfbox_f8373_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("MultipleAnnotations-DifferentLayout");    String fieldFontSetting = getFontSettingFromDA(field);    List<PDAnnotationWidget> widgets = field.getWidgets();    for (PDAnnotationWidget widget : widgets) {        String widgetFontSetting = getFontSettingFromDA(widget);        String fontSetting = widgetFontSetting == null ? fieldFontSetting : widgetFontSetting;        String contentAsString = new String(widget.getNormalAppearanceStream().getContentStream().toByteArray());        assertTrue("font setting in content stream shall be " + fontSetting, contentAsString.indexOf(fontSetting) > 0);    }}
public void pdfbox_f8374_0() throws IOException
{    document.close();}
private String pdfbox_f8375_0(PDTextField field)
{    String defaultAppearance = field.getDefaultAppearance();        return defaultAppearance.substring(0, defaultAppearance.lastIndexOf("Tf") + 2);}
private String pdfbox_f8376_0(PDAnnotationWidget widget)
{    String defaultAppearance = widget.getCOSObject().getString(COSName.DA);    if (defaultAppearance != null) {        return defaultAppearance.substring(0, defaultAppearance.lastIndexOf("Tf") + 2);    }    return defaultAppearance;}
public void pdfbox_f8377_0() throws IOException
{    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acroForm = document.getDocumentCatalog().getAcroForm();    OUT_DIR.mkdirs();}
public void pdfbox_f8378_0() throws IOException
{    PDTextField field = (PDTextField) acroForm.getField("AlignLeft");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Small");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Medium");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignLeft-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignMiddle-Border_Wide");    field.setValue(TEST_VALUE);    field = (PDTextField) acroForm.getField("AlignRight-Border_Wide");    field.setValue(TEST_VALUE);        File file = new File(OUT_DIR, NAME_OF_PDF);    document.save(file);    TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.err.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8379_0() throws IOException
{    document.close();}
public void pdfbox_f8380_0()
{    IN_DIR.mkdirs();    OUT_DIR.mkdirs();}
public void pdfbox_f8381_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12742551/Testformular1.pdf";    String targetFileName = "Testformular1.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8382_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12425859/TestFax_56972.pdf";    String targetFileName = "TestFax_56972.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8383_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12682897/FormI-9-English.pdf";    String targetFileName = "FormI-9-English.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8384_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12678455/testPDF_acroForm.pdf";    String targetFileName = "testPDF_acroForm.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8385_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12689788/test.pdf";    String targetFileName = "test-2586.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8386_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12770263/mypdf.pdf";    String targetFileName = "mypdf.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8387_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12792007/hidden_fields.pdf";    String targetFileName = "hidden_fields.pdf";    assertTrue(flattenAndCompare(sourceUrl, targetFileName));}
public void pdfbox_f8388_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12816014/Signed-Document-1.pdf";    String targetFileName = "Signed-Document-1.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8389_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12816016/Signed-Document-2.pdf";    String targetFileName = "Signed-Document-2.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8390_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12821307/Signed-Document-3.pdf";    String targetFileName = "Signed-Document-3.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8391_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12821308/Signed-Document-4.pdf";    String targetFileName = "Signed-Document-4.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8392_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12839977/OpenOfficeForm.pdf";    String targetFileName = "OpenOfficeForm.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8393_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12840280/OpenOfficeForm_filled.pdf";    String targetFileName = "OpenOfficeForm_filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8394_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976553/PDFBOX-4157-filled.pdf";    String targetFileName = "PDFBOX-4157-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8395_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976552/PDFBOX-4172-filled.pdf";    String targetFileName = "PDFBOX-4172-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
public void pdfbox_f8396_0() throws IOException
{    String sourceUrl = "https://issues.apache.org/jira/secure/attachment/12976452/resetboundingbox-filled.pdf";    String targetFileName = "PDFBOX-4615-filled.pdf";    flattenAndCompare(sourceUrl, targetFileName);}
private static boolean pdfbox_f8397_0(String sourceUrl, String targetFileName) throws IOException
{    generateSamples(sourceUrl, targetFileName);    File inputFile = new File(IN_DIR, targetFileName);    File outputFile = new File(OUT_DIR, targetFileName);    try (PDDocument testPdf = PDDocument.load(inputFile)) {        testPdf.getDocumentCatalog().getAcroForm().flatten();        testPdf.setAllSecurityToBeRemoved(true);        assertTrue(testPdf.getDocumentCatalog().getAcroForm().getFields().isEmpty());        testPdf.save(outputFile);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(outputFile, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + outputFile + " failed or is not identical to expected rendering in " + IN_DIR + " directory");        removeMatchingRenditions(inputFile);        return false;    } else {                removeAllRenditions(inputFile);        inputFile.delete();        outputFile.delete();    }    return true;}
private static void pdfbox_f8398_0(String sourceUrl, String targetFile) throws IOException
{    getFromUrl(sourceUrl, targetFile);    File file = new File(IN_DIR, targetFile);    try (PDDocument document = PDDocument.load(file, (String) null)) {        String outputPrefix = IN_DIR.getAbsolutePath() + '/' + file.getName() + "-";        int numPages = document.getNumberOfPages();        PDFRenderer renderer = new PDFRenderer(document);        for (int i = 0; i < numPages; i++) {            String fileName = outputPrefix + (i + 1) + ".png";                        BufferedImage image = renderer.renderImageWithDPI(i, 96);            ImageIO.write(image, "PNG", new File(fileName));        }    }}
private static void pdfbox_f8399_0(String sourceUrl, String targetFile) throws IOException
{    URL url = new URL(sourceUrl);    try (InputStream is = url.openStream();        OutputStream os = new FileOutputStream(new File(IN_DIR, targetFile))) {        byte[] b = new byte[2048];        int length;        while ((length = is.read(b)) != -1) {            os.write(b, 0, length);        }    }}
private static void pdfbox_f8400_0(final File inputFile)
{    File[] testFiles = inputFile.getParentFile().listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));        }    });    for (File testFile : testFiles) {        if (!new File(OUT_DIR, testFile.getName()).exists()) {            testFile.delete();        }    }}
public boolean pdfbox_f8401_0(File dir, String name)
{    return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));}
private static void pdfbox_f8402_0(final File inputFile)
{    File[] testFiles = inputFile.getParentFile().listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));        }    });    for (File testFile : testFiles) {        testFile.delete();    }}
public boolean pdfbox_f8403_0(File dir, String name)
{    return (name.startsWith(inputFile.getName()) && name.toLowerCase().endsWith(".png"));}
public void pdfbox_f8404_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    document.getDocumentCatalog().setAcroForm(acroForm);}
public void pdfbox_f8405_0()
{            assertNotNull(acroForm.getFields());    assertEquals(acroForm.getFields().size(), 0);        assertNull(acroForm.getField("foo"));            acroForm.getCOSObject().removeItem(COSName.FIELDS);        assertNotNull(acroForm.getFields());    assertEquals(acroForm.getFields().size(), 0);        assertNull(acroForm.getField("foo"));}
public void pdfbox_f8406_0()
{    assertTrue(acroForm.getDefaultAppearance().isEmpty());    acroForm.setDefaultAppearance("/Helv 0 Tf 0 g");    assertEquals(acroForm.getDefaultAppearance(), "/Helv 0 Tf 0 g");}
public void pdfbox_f8407_0() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened.pdf");    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        testPdf.getDocumentCatalog().getAcroForm().flatten();        assertTrue(testPdf.getDocumentCatalog().getAcroForm().getFields().isEmpty());        testPdf.save(file);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8408_0() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened-noRef.pdf");    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        PDAcroForm acroFormToTest = testPdf.getDocumentCatalog().getAcroForm();        for (PDField field : acroFormToTest.getFieldTree()) {            for (PDAnnotationWidget widget : field.getWidgets()) {                widget.getCOSObject().removeItem(COSName.P);            }        }        acroFormToTest.flatten();                assertEquals(36, testPdf.getPage(0).getAnnotations().size());        assertTrue(acroFormToTest.getFields().isEmpty());        testPdf.save(file);    }        TestPDFToImage testPDFToImage = new TestPDFToImage(TestPDFToImage.class.getName());    if (!testPDFToImage.doTestFile(file, IN_DIR.getAbsolutePath(), OUT_DIR.getAbsolutePath())) {                System.out.println("Rendering of " + file + " failed or is not identical to expected rendering in " + IN_DIR + " directory");    }}
public void pdfbox_f8409_0() throws IOException
{    File file = new File(OUT_DIR, "AlignmentTests-flattened-specificFields.pdf");    List<PDField> fieldsToFlatten = new ArrayList<>();    try (PDDocument testPdf = PDDocument.load(new File(IN_DIR, "AlignmentTests.pdf"))) {        PDAcroForm acroFormToFlatten = testPdf.getDocumentCatalog().getAcroForm();        int numFieldsBeforeFlatten = acroFormToFlatten.getFields().size();        int numWidgetsBeforeFlatten = countWidgets(testPdf);        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Small-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Medium-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Wide-Filled"));        fieldsToFlatten.add(acroFormToFlatten.getField("AlignLeft-Border_Wide_Clipped-Filled"));        acroFormToFlatten.flatten(fieldsToFlatten, true);        int numFieldsAfterFlatten = acroFormToFlatten.getFields().size();        int numWidgetsAfterFlatten = countWidgets(testPdf);        assertEquals(numFieldsBeforeFlatten, numFieldsAfterFlatten + fieldsToFlatten.size());        assertEquals(numWidgetsBeforeFlatten, numWidgetsAfterFlatten + fieldsToFlatten.size());        testPdf.save(file);    }}
public void pdfbox_f8410_0()
{    try {        byte[] pdfBytes = createAcroFormWithMissingResourceInformation();        try (PDDocument pdfDocument = PDDocument.load(pdfBytes)) {                        PDDocumentCatalog documentCatalog = pdfDocument.getDocumentCatalog();            COSDictionary catalogDictionary = documentCatalog.getCOSObject();            COSDictionary acroFormDictionary = (COSDictionary) catalogDictionary.getDictionaryObject(COSName.ACRO_FORM);                        assertNull(acroFormDictionary.getDictionaryObject(COSName.DA));            assertNull(acroFormDictionary.getDictionaryObject(COSName.RESOURCES));            pdfDocument.close();        }    } catch (IOException e) {        System.err.println("Couldn't create test document, test skipped");        return;    }}
public void pdfbox_f8411_0()
{    try {        byte[] pdfBytes = createAcroFormWithMissingResourceInformation();        try (PDDocument pdfDocument = PDDocument.load(pdfBytes)) {            PDDocumentCatalog documentCatalog = pdfDocument.getDocumentCatalog();                        PDAcroForm theAcroForm = documentCatalog.getAcroForm();                                    assertEquals("/Helv 0 Tf 0 g ", theAcroForm.getDefaultAppearance());            assertNotNull(theAcroForm.getDefaultResources());                        PDResources acroFormResources = theAcroForm.getDefaultResources();            assertNotNull(acroFormResources.getFont(COSName.getPDFName("Helv")));            assertEquals("Helvetica", acroFormResources.getFont(COSName.getPDFName("Helv")).getName());            assertNotNull(acroFormResources.getFont(COSName.getPDFName("ZaDb")));            assertEquals("ZapfDingbats", acroFormResources.getFont(COSName.getPDFName("ZaDb")).getName());        }    } catch (IOException e) {        System.err.println("Couldn't create test document, test skipped");        return;    }}
public void pdfbox_f8412_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(document);        doc.getDocumentCatalog().setAcroForm(acroForm);        acroForm.setDefaultResources(new PDResources());        PDTextField textBox = new PDTextField(acroForm);        textBox.setPartialName("SampleField");                        textBox.setDefaultAppearance("/Helv 0 tf 0 g");        acroForm.getFields().add(textBox);        PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 20);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);        try {            textBox.setValue("huhu");        } catch (IllegalArgumentException ex) {            return;        }        fail("IllegalArgumentException should have been thrown");    }}
public void pdfbox_f8413_0() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        PDAcroForm acroForm2 = new PDAcroForm(doc);        doc.getDocumentCatalog().setAcroForm(acroForm2);        PDResources defaultResources = acroForm2.getDefaultResources();        assertNull(defaultResources);        defaultResources = new PDResources();        acroForm2.setDefaultResources(defaultResources);        assertNull(defaultResources.getFont(COSName.HELV));        assertNull(defaultResources.getFont(COSName.ZA_DB));                acroForm2 = doc.getDocumentCatalog().getAcroForm();        defaultResources = acroForm2.getDefaultResources();        assertNotNull(defaultResources.getFont(COSName.HELV));        assertNotNull(defaultResources.getFont(COSName.ZA_DB));                doc.getDocumentCatalog().setAcroForm(new PDAcroForm(doc));        acroForm2 = doc.getDocumentCatalog().getAcroForm();        defaultResources = acroForm2.getDefaultResources();        PDFont helv = defaultResources.getFont(COSName.HELV);        PDFont zadb = defaultResources.getFont(COSName.ZA_DB);        assertNotNull(helv);        assertNotNull(zadb);        doc.save(baos);    }    try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDAcroForm acroForm2 = doc.getDocumentCatalog().getAcroForm();        PDResources defaultResources = acroForm2.getDefaultResources();        PDFont helv = defaultResources.getFont(COSName.HELV);        PDFont zadb = defaultResources.getFont(COSName.ZA_DB);        assertNotNull(helv);        assertNotNull(zadb);                assertNotEquals(PDType1Font.HELVETICA, helv);        assertNotEquals(PDType1Font.ZAPF_DINGBATS, zadb);    }}
public void pdfbox_f8414_0() throws IOException
{    document.close();}
private byte[] pdfbox_f8415_0() throws IOException
{    try (PDDocument tmpDocument = new PDDocument();        ByteArrayOutputStream baos = new ByteArrayOutputStream()) {        PDPage page = new PDPage();        tmpDocument.addPage(page);        PDAcroForm newAcroForm = new PDAcroForm(document);        tmpDocument.getDocumentCatalog().setAcroForm(newAcroForm);        PDTextField textBox = new PDTextField(newAcroForm);        textBox.setPartialName("SampleField");        newAcroForm.getFields().add(textBox);        PDAnnotationWidget widget = textBox.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 20);        widget.setRectangle(rect);        widget.setPage(page);        page.getAnnotations().add(widget);                                tmpDocument.save(baos);        tmpDocument.close();        return baos.toByteArray();    }}
private int pdfbox_f8416_0(PDDocument documentToTest)
{    int count = 0;    for (PDPage page : documentToTest.getPages()) {        try {            for (PDAnnotation annotation : page.getAnnotations()) {                if (annotation instanceof PDAnnotationWidget) {                    count++;                }            }        } catch (IOException e) {                }    }    return count;}
public void pdfbox_f8417_0() throws IOException
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    acrobatDocument = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    acrobatAcroForm = acrobatDocument.getDocumentCatalog().getAcroForm();}
public void pdfbox_f8418_0()
{    PDButton buttonField = new PDCheckBox(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertFalse(buttonField.isPushButton());    assertFalse(buttonField.isRadioButton());}
public void pdfbox_f8419_0()
{    PDButton buttonField = new PDPushButton(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertTrue(buttonField.isPushButton());    assertFalse(buttonField.isRadioButton());}
public void pdfbox_f8420_0()
{    PDButton buttonField = new PDRadioButton(acroForm);    assertEquals(buttonField.getFieldType(), buttonField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(buttonField.getFieldType(), "Btn");    assertTrue(buttonField.isRadioButton());    assertFalse(buttonField.isPushButton());}
public void pdfbox_f8421_0() throws MalformedURLException
{    File file = new File(TARGET_PDF_DIR, "PDFBOX-3656.pdf");    try (InputStream is = new FileInputStream(file);        PDDocument pdfDocument = PDDocument.load(is)) {        PDRadioButton radioButton = (PDRadioButton) pdfDocument.getDocumentCatalog().getAcroForm().getField("Checking/Savings");        radioButton.setValue("Off");        for (PDAnnotationWidget widget : radioButton.getWidgets()) {            assertEquals("The widget should be set to Off", COSName.Off, widget.getCOSObject().getItem(COSName.AS));        }    } catch (IOException e) {        fail("Unexpected IOException " + e.getMessage());    }}
public void pdfbox_f8422_0() throws MalformedURLException
{    File file = new File(TARGET_PDF_DIR, "PDFBOX-3682.pdf");    try (InputStream is = new FileInputStream(file);        PDDocument pdfDocument = PDDocument.load(is)) {        pdfDocument.getDocumentCatalog().getAcroForm().getField("RadioButton").setValue("c");        PDRadioButton radioButton = (PDRadioButton) pdfDocument.getDocumentCatalog().getAcroForm().getField("RadioButton");        radioButton.setValue("c");                assertFalse("This shall no longer be 2", "2".equals(radioButton.getValueAsString()));        assertFalse("This shall no longer be 2", "2".equals(radioButton.getWidgets().get(2).getCOSObject().getNameAsString(COSName.AS)));                assertTrue("This shall be c", "c".equals(radioButton.getValueAsString()));        assertTrue("This shall be c", "c".equals(radioButton.getWidgets().get(2).getCOSObject().getNameAsString(COSName.AS)));    } catch (IOException e) {        fail("Unexpected IOException " + e.getMessage());    }}
public void pdfbox_f8423_0()
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");    assertNotNull(checkbox);    assertEquals(checkbox.getOnValue(), "Yes");    assertEquals(checkbox.getOnValues().size(), 1);    assertTrue(checkbox.getOnValues().contains("Yes"));}
public void pdfbox_f8424_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");    assertEquals(checkbox.getValue(), "Off");    assertEquals(checkbox.isChecked(), false);    checkbox.check();    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    checkbox.setValue("Yes");    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.YES);    checkbox.setValue("Off");    assertEquals(checkbox.getValue(), COSName.Off.getName());    assertEquals(checkbox.isChecked(), false);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox-DefaultValue");    assertEquals(checkbox.getDefaultValue(), checkbox.getOnValue());    checkbox.setDefaultValue("Off");    assertEquals(checkbox.getDefaultValue(), COSName.Off.getName());}
public void pdfbox_f8425_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("Checkbox");    checkbox.setValue("Yes");    assertEquals(checkbox.getValueAsString(), ((PDCheckBox) checkbox).getOnValue());    assertEquals(((PDCheckBox) checkbox).isChecked(), true);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.YES);    checkbox.setValue("Off");    assertEquals(checkbox.getValueAsString(), COSName.Off.getName());    assertEquals(((PDCheckBox) checkbox).isChecked(), false);    assertEquals(checkbox.getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);}
public void pdfbox_f8426_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("CheckboxGroup");    assertEquals(checkbox.getValue(), "Off");    assertEquals(checkbox.isChecked(), false);    checkbox.check();    assertEquals(checkbox.getValue(), checkbox.getOnValue());    assertEquals(checkbox.isChecked(), true);    assertEquals(checkbox.getOnValues().size(), 3);    assertTrue(checkbox.getOnValues().contains("Option1"));    assertTrue(checkbox.getOnValues().contains("Option2"));    assertTrue(checkbox.getOnValues().contains("Option3"));        checkbox.setValue("Option1");    assertEquals("Option1", checkbox.getValue());    assertEquals("Option1", checkbox.getValueAsString());            assertEquals("Option1", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(3).getAppearanceState().getName());            checkbox.setValue("Option3");    assertEquals("Option3", checkbox.getValue());    assertEquals("Option3", checkbox.getValueAsString());            assertEquals("Off", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(3).getAppearanceState().getName());}
public void pdfbox_f8427_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("Option1");    assertEquals("Option1", checkbox.getValueAsString());            assertEquals("Option1", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(3).getAppearanceState().getName());            checkbox.setValue("Option3");    assertEquals("Option3", checkbox.getValueAsString());            assertEquals("Off", checkbox.getWidgets().get(0).getAppearanceState().getName());    assertEquals("Off", checkbox.getWidgets().get(1).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(2).getAppearanceState().getName());    assertEquals("Option3", checkbox.getWidgets().get(3).getAppearanceState().getName());}
public void pdfbox_f8428_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("Checkbox");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8429_0() throws IOException
{    PDCheckBox checkbox = (PDCheckBox) acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8430_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("Checkbox");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8431_0() throws IOException
{    PDField checkbox = acrobatAcroForm.getField("CheckboxGroup");        checkbox.setValue("InvalidValue");}
public void pdfbox_f8432_0()
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");    assertNotNull(radioButton);    assertEquals(radioButton.getOnValues().size(), 2);    assertTrue(radioButton.getOnValues().contains("RadioButton01"));    assertTrue(radioButton.getOnValues().contains("RadioButton02"));}
public void pdfbox_f8433_0() throws IOException
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("RadioButton01");    assertEquals(radioButton.getValue(), "RadioButton01");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton01"));    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);        radioButton.setValue("RadioButton02");    assertEquals(radioButton.getValue(), "RadioButton02");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton02"));}
public void pdfbox_f8434_0() throws IOException
{    PDField radioButton = acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("RadioButton01");    assertEquals(radioButton.getValueAsString(), "RadioButton01");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton01"));    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);        radioButton.setValue("RadioButton02");    assertEquals(radioButton.getValueAsString(), "RadioButton02");        assertEquals(radioButton.getWidgets().get(0).getCOSObject().getDictionaryObject(COSName.AS), COSName.Off);    assertEquals(radioButton.getWidgets().get(1).getCOSObject().getDictionaryObject(COSName.AS), COSName.getPDFName("RadioButton02"));}
public void pdfbox_f8435_0() throws IOException
{    PDRadioButton radioButton = (PDRadioButton) acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("InvalidValue");}
public void pdfbox_f8436_0() throws IOException
{    PDField radioButton = acrobatAcroForm.getField("RadioButtonGroup");        radioButton.setValue("InvalidValue");}
public void pdfbox_f8437_0() throws IOException
{    document.close();    acrobatDocument.close();}
public void pdfbox_f8438_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);    options = new ArrayList<>();    options.add(" ");    options.add("A");    options.add("B");}
public void pdfbox_f8439_0()
{    PDChoice choiceField = new PDListBox(acroForm);    assertEquals(choiceField.getFieldType(), choiceField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(choiceField.getFieldType(), "Ch");    assertFalse(choiceField.isCombo());}
public void pdfbox_f8440_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    assertEquals(choiceField.getFieldType(), choiceField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(choiceField.getFieldType(), "Ch");    assertTrue(choiceField.isCombo());}
public void pdfbox_f8441_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();    choiceFieldOptions.add(new COSString(" "));    choiceFieldOptions.add(new COSString("A"));    choiceFieldOptions.add(new COSString("B"));            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
public void pdfbox_f8442_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();        COSArray entry = new COSArray();    entry.add(new COSString(" "));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("A"));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("B"));    choiceFieldOptions.add(entry);            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
public void pdfbox_f8443_0()
{    PDChoice choiceField = new PDComboBox(acroForm);    COSArray choiceFieldOptions = new COSArray();        choiceFieldOptions.add(new COSString(" "));        COSArray entry = new COSArray();    entry.add(new COSString("A"));    choiceFieldOptions.add(entry);        entry = new COSArray();    entry.add(new COSString("B"));    choiceFieldOptions.add(entry);            choiceField.getCOSObject().setItem(COSName.OPT, choiceFieldOptions);    assertEquals(options, choiceField.getOptions());}
public void pdfbox_f8444_0()
{    resources = new PDResources();            fontResourceName = resources.add(PDType1Font.HELVETICA);}
public void pdfbox_f8445_0() throws IOException
{    COSString sampleString = new COSString("/" + fontResourceName.getName() + " 12 Tf 0.019 0.305 0.627 rg");    PDDefaultAppearanceString defaultAppearanceString = new PDDefaultAppearanceString(sampleString, resources);    assertEquals(12, defaultAppearanceString.getFontSize(), 0.001);    assertEquals(PDType1Font.HELVETICA, defaultAppearanceString.getFont());    assertEquals(PDDeviceRGB.INSTANCE, defaultAppearanceString.getFontColor().getColorSpace());    assertEquals(0.019, defaultAppearanceString.getFontColor().getComponents()[0], 0.0001);    assertEquals(0.305, defaultAppearanceString.getFontColor().getComponents()[1], 0.0001);    assertEquals(0.627, defaultAppearanceString.getFontColor().getComponents()[2], 0.0001);}
public void pdfbox_f8446_0() throws IOException
{    COSString sampleString = new COSString("/Helvetica 12 Tf 0.019 0.305 0.627 rg");    new PDDefaultAppearanceString(sampleString, resources);}
public void pdfbox_f8447_0() throws IOException
{    COSString sampleString = new COSString("/Helvetica 12 Tf 0.305 0.627 rg");    new PDDefaultAppearanceString(sampleString, resources);}
public void pdfbox_f8448_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);}
public void pdfbox_f8449_0()
{    PDSignatureField sigField = new PDSignatureField(acroForm);    sigField.setPartialName("SignatureField");    assertEquals(sigField.getFieldType(), sigField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(sigField.getFieldType(), "Sig");    assertEquals(COSName.ANNOT, sigField.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, sigField.getCOSObject().getNameAsString(COSName.SUBTYPE));        List<PDField> fields = new ArrayList<>();    fields.add(sigField);    this.acroForm.setFields(fields);    assertNotNull(acroForm.getField("SignatureField"));}
public void pdfbox_f8450_0()
{    PDSignatureField sigField = new PDSignatureField(acroForm);    sigField.setPartialName("SignatureField");    sigField.setValue("Can't set value using String");}
public void pdfbox_f8451_0()
{    document = new PDDocument();    acroForm = new PDAcroForm(document);}
public void pdfbox_f8452_0()
{    PDField textField = new PDTextField(acroForm);    assertEquals(textField.getFieldType(), textField.getCOSObject().getNameAsString(COSName.FT));    assertEquals(textField.getFieldType(), "Tx");}
public void pdfbox_f8453_0()
{    PDTextField textField = new PDTextField(acroForm);    assertNull(textField.getCOSObject().getItem(COSName.TYPE));    assertNull(textField.getCOSObject().getNameAsString(COSName.SUBTYPE));    PDAnnotationWidget widget = textField.getWidgets().get(0);    assertEquals(COSName.ANNOT, textField.getCOSObject().getItem(COSName.TYPE));    assertEquals(PDAnnotationWidget.SUB_TYPE, textField.getCOSObject().getNameAsString(COSName.SUBTYPE));    assertEquals(widget.getCOSObject(), textField.getCOSObject());}
public void pdfbox_f8454_0()
{    PlainText text = new PlainText("CR\rCR");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8455_0()
{    PlainText text = new PlainText("LF\nLF");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8456_0()
{    PlainText text = new PlainText("CRLF\r\nCRLF");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8457_0()
{    PlainText text = new PlainText("LFCR\n\rLFCR");    assertEquals(3, text.getParagraphs().size());}
public void pdfbox_f8458_0()
{    PlainText text = new PlainText("linebreak\u2028linebreak");    assertEquals(2, text.getParagraphs().size());}
public void pdfbox_f8459_0()
{    PlainText text = new PlainText("paragraphbreak\u2029paragraphbreak");    assertEquals(2, text.getParagraphs().size());}
public static Test pdfbox_f8460_0()
{    return new TestSuite(TestCheckBox.class);}
public static void pdfbox_f8461_0(String[] args)
{    String[] arg = { TestCheckBox.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8462_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDCheckBox checkBox = new PDCheckBox(form);                        assertNotNull(checkBox.getExportValues());        assertNotNull(checkBox.getValue());                List<String> options = new ArrayList<>();        options.add("Value01");        options.add("Value02");        checkBox.setExportValues(options);        COSArray optItem = (COSArray) checkBox.getCOSObject().getItem(COSName.OPT);                assertNotNull(checkBox.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), 2);        assertEquals(options.get(0), optItem.getString(0));                List<String> retrievedOptions = checkBox.getExportValues();        assertEquals(retrievedOptions.size(), 2);        assertEquals(retrievedOptions, options);                checkBox.setExportValues(null);        assertNull(checkBox.getCOSObject().getItem(COSName.OPT));                assertTrue(checkBox.getExportValues().isEmpty());    }}
public void pdfbox_f8463_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDAcroForm acroForm = new PDAcroForm(doc);                acroForm.setNeedAppearances(true);        doc.getDocumentCatalog().setAcroForm(acroForm);        List<PDField> fields = new ArrayList<>();        PDCheckBox checkBox = new PDCheckBox(acroForm);        checkBox.setPartialName("checkbox");        PDAnnotationWidget widget = checkBox.getWidgets().get(0);        widget.setRectangle(new PDRectangle(50, 600, 100, 100));        PDBorderStyleDictionary bs = new PDBorderStyleDictionary();        bs.setStyle(PDBorderStyleDictionary.STYLE_SOLID);        bs.setWidth(1);        COSDictionary acd = new COSDictionary();        PDAppearanceCharacteristicsDictionary ac = new PDAppearanceCharacteristicsDictionary(acd);        ac.setBackground(new PDColor(new float[] { 1, 1, 0 }, PDDeviceRGB.INSTANCE));        ac.setBorderColour(new PDColor(new float[] { 1, 0, 0 }, PDDeviceRGB.INSTANCE));                ac.setNormalCaption("4");        widget.setAppearanceCharacteristics(ac);        widget.setBorderStyle(bs);        checkBox.setValue("Off");        fields.add(checkBox);        page.getAnnotations().add(widget);        acroForm.setFields(fields);        assertEquals("Off", checkBox.getValue());    }}
public static Test pdfbox_f8464_0()
{    return new TestSuite(TestFields.class);}
public static void pdfbox_f8465_0(String[] args)
{    String[] arg = { TestFields.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8466_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDTextField textBox = new PDTextField(form);                assertFalse(textBox.isComb());                textBox.setComb(true);        assertTrue(textBox.isComb());        textBox.setComb(false);        assertFalse(textBox.isComb());                textBox.setComb(true);        textBox.setDoNotScroll(true);        assertTrue(textBox.isComb());        assertTrue(textBox.doNotScroll());        textBox.setComb(false);        textBox.setDoNotScroll(false);        assertFalse(textBox.isComb());        assertFalse(textBox.doNotScroll());                textBox.setComb(false);        assertFalse(textBox.isComb());        textBox.setComb(false);        assertFalse(textBox.isComb());                textBox.setComb(true);        assertTrue(textBox.isComb());        textBox.setComb(true);        assertTrue(textBox.isComb());    }}
public void pdfbox_f8467_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(PATH_OF_PDF))) {                PDAcroForm form = doc.getDocumentCatalog().getAcroForm();        assertNotNull(form);                        PDTextField textField = (PDTextField) form.getField("TextField");        assertNull(textField.getCOSObject().getItem(COSName.V));        textField.setValue("field value");        assertNotNull(textField.getCOSObject().getItem(COSName.V));        assertEquals(textField.getValue(), "field value");                assertNotNull(textField.getCOSObject().getItem(COSName.V));        textField.setValue(null);        assertNull(textField.getCOSObject().getItem(COSName.V));                textField = (PDTextField) form.getField("TextField-DefaultValue");        assertNotNull(textField);        assertEquals(textField.getDefaultValue(), "DefaultValue");        assertEquals(textField.getDefaultValue(), ((COSString) textField.getCOSObject().getDictionaryObject(COSName.DV)).getString());        assertEquals(textField.getDefaultAppearance(), "/Helv 12 Tf 0 g");                textField = (PDTextField) form.getField("RichTextField-DefaultValue");        assertNotNull(textField);        assertEquals(textField.getDefaultValue(), "DefaultValue");        assertEquals(textField.getDefaultValue(), ((COSString) textField.getCOSObject().getDictionaryObject(COSName.DV)).getString());        assertEquals(textField.getValue(), "DefaultValue");        assertEquals(textField.getDefaultAppearance(), "/Helv 12 Tf 0 g");        assertEquals(textField.getDefaultStyleString(), "font: Helvetica,sans-serif 12.0pt; text-align:left; color:#000000 ");                assertEquals(textField.getRichTextValue().length(), 338);                textField = (PDTextField) form.getField("LongRichTextField");        assertNotNull(textField);        assertEquals(textField.getCOSObject().getDictionaryObject(COSName.V).getClass().getName(), "org.apache.pdfbox.cos.COSStream");        assertEquals(textField.getValue().length(), 145396);    }}
public void pdfbox_f8468_0() throws IOException
{    try (PDDocument doc = PDDocument.load(new File(PATH_OF_PDF))) {        PDAcroForm form = doc.getDocumentCatalog().getAcroForm();        PDTextField textField = (PDTextField) form.getField("TextField-DefaultValue");        PDAnnotationWidget widget = textField.getWidgets().get(0);                assertNotNull(widget.getCOSObject().getDictionaryObject(COSName.AP));        widget.getCOSObject().removeItem(COSName.RECT);        textField.setValue("field value");                        assertNull(widget.getCOSObject().getDictionaryObject(COSName.AP));    }}
public static Test pdfbox_f8469_0()
{    return new TestSuite(TestListBox.class);}
public static void pdfbox_f8470_0(String[] args)
{    String[] arg = { TestListBox.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8471_0() throws IOException
{    /*         * Set up two data lists which will be used for the tests         */        List<String> exportValues = new ArrayList<>();    exportValues.add("export01");    exportValues.add("export02");    exportValues.add("export03");            List<String> displayValues = new ArrayList<>();    displayValues.add("display02");    displayValues.add("display01");    displayValues.add("display03");    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage(PDRectangle.A4);        doc.addPage(page);        PDAcroForm form = new PDAcroForm(doc);                        PDFont font = PDType1Font.HELVETICA;        PDResources resources = new PDResources();        resources.put(COSName.getPDFName("Helv"), font);                form.setDefaultResources(resources);                        String defaultAppearanceString = "/Helv 0 Tf 0 g";        form.setDefaultAppearance(defaultAppearanceString);        PDListBox choice = new PDListBox(form);        choice.setDefaultAppearance("/Helv 12 Tf 0g");                PDAnnotationWidget widget = choice.getWidgets().get(0);        PDRectangle rect = new PDRectangle(50, 750, 200, 50);        widget.setRectangle(rect);        widget.setPage(page);                page.getAnnotations().add(widget);                        assertNotNull(choice.getOptions());        assertNotNull(choice.getValue());        /*             * Tests for setting the export values             */                choice.setOptions(exportValues);        assertEquals(exportValues, choice.getOptionsDisplayValues());        assertEquals(exportValues, choice.getOptionsExportValues());                choice.setTopIndex(1);        choice.setValue(exportValues.get(2));        assertEquals(exportValues.get(2), choice.getValue().get(0));                choice.setTopIndex(null);                COSArray optItem = (COSArray) choice.getCOSObject().getItem(COSName.OPT);        assertNotNull(choice.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), exportValues.size());        assertEquals(exportValues.get(0), optItem.getString(0));                List<String> retrievedOptions = choice.getOptions();        assertEquals(retrievedOptions.size(), exportValues.size());        assertEquals(retrievedOptions, exportValues);        /*             * Tests for setting the field values             */                choice.setValue("export01");        assertEquals(choice.getValue().get(0), "export01");                choice.setMultiSelect(false);                try {            choice.setValue(exportValues);            fail("Missing IllegalArgumentException");        } catch (IllegalArgumentException e) {            assertEquals("The list box does not allow multiple selections.", e.getMessage());        }                choice.setMultiSelect(true);                choice.setValue(exportValues);                COSArray valueItems = (COSArray) choice.getCOSObject().getItem(COSName.V);        assertNotNull(valueItems);        assertEquals(valueItems.size(), exportValues.size());        assertEquals(exportValues.get(0), valueItems.getString(0));                COSArray indexItems = (COSArray) choice.getCOSObject().getItem(COSName.I);        assertNotNull(indexItems);        assertEquals(indexItems.size(), exportValues.size());                choice.setValue("export01");        indexItems = (COSArray) choice.getCOSObject().getItem(COSName.I);        assertNull(indexItems);                choice.setOptions(null);        assertNull(choice.getCOSObject().getItem(COSName.OPT));                assertEquals(choice.getOptions(), Collections.<String>emptyList());        /*             * Test for setting export and display values             */                choice.setOptions(exportValues, displayValues);        assertEquals(displayValues, choice.getOptionsDisplayValues());        assertEquals(exportValues, choice.getOptionsExportValues());        /*             * Testing the sort option             */        assertEquals(choice.getOptionsDisplayValues().get(0), "display02");        choice.setSort(true);        choice.setOptions(exportValues, displayValues);        assertEquals(choice.getOptionsDisplayValues().get(0), "display01");        /*             * Setting options with an empty list             */                choice.setOptions(null, displayValues);        assertNull(choice.getCOSObject().getItem(COSName.OPT));                assertEquals(choice.getOptions(), Collections.<String>emptyList());        assertEquals(choice.getOptionsDisplayValues(), Collections.<String>emptyList());        assertEquals(choice.getOptionsExportValues(), Collections.<String>emptyList());                        exportValues.remove(1);        try {            choice.setOptions(exportValues, displayValues);            fail("Missing exception");        } catch (IllegalArgumentException e) {            assertEquals("The number of entries for exportValue and displayValue shall be the same.", e.getMessage());        }    }}
public static Test pdfbox_f8472_0()
{    return new TestSuite(TestRadioButtons.class);}
public static void pdfbox_f8473_0(String[] args)
{    String[] arg = { TestRadioButtons.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8474_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDAcroForm form = new PDAcroForm(doc);        PDRadioButton radioButton = new PDRadioButton(form);                        assertNotNull(radioButton.getDefaultValue());        assertNotNull(radioButton.getSelectedExportValues());        assertNotNull(radioButton.getExportValues());        assertNotNull(radioButton.getValue());                List<String> options = new ArrayList<>();        options.add("Value01");        options.add("Value02");        radioButton.setExportValues(options);        COSArray optItem = (COSArray) radioButton.getCOSObject().getItem(COSName.OPT);                assertNotNull(radioButton.getCOSObject().getItem(COSName.OPT));        assertEquals(optItem.size(), 2);        assertEquals(options.get(0), optItem.getString(0));                List<String> retrievedOptions = radioButton.getExportValues();        assertEquals(retrievedOptions.size(), 2);        assertEquals(retrievedOptions, options);                radioButton.setExportValues(null);        assertNull(radioButton.getCOSObject().getItem(COSName.OPT));                assertEquals(radioButton.getExportValues(), new ArrayList<String>());    }}
public void pdfbox_f8475_0()
{    assertEquals(COSName.NONE, PDTransitionDirection.NONE.getCOSBase());    assertEquals(0, ((COSInteger) PDTransitionDirection.LEFT_TO_RIGHT.getCOSBase()).intValue());    assertEquals(90, ((COSInteger) PDTransitionDirection.BOTTOM_TO_TOP.getCOSBase()).intValue());    assertEquals(180, ((COSInteger) PDTransitionDirection.RIGHT_TO_LEFT.getCOSBase()).intValue());    assertEquals(270, ((COSInteger) PDTransitionDirection.TOP_TO_BOTTOM.getCOSBase()).intValue());    assertEquals(315, ((COSInteger) PDTransitionDirection.TOP_LEFT_TO_BOTTOM_RIGHT.getCOSBase()).intValue());}
public void pdfbox_f8476_0()
{    PDTransition transition = new PDTransition();    assertEquals(COSName.TRANS, transition.getCOSObject().getCOSName(COSName.TYPE));    assertEquals(PDTransitionStyle.R.name(), transition.getStyle());}
public void pdfbox_f8477_0()
{    PDTransition transition = new PDTransition(PDTransitionStyle.Fade);    assertEquals(COSName.TRANS, transition.getCOSObject().getCOSName(COSName.TYPE));    assertEquals(PDTransitionStyle.Fade.name(), transition.getStyle());}
public void pdfbox_f8478_0()
{    PDTransition transition = new PDTransition(new COSDictionary());    assertEquals(PDTransitionStyle.R.name(), transition.getStyle());    assertEquals(PDTransitionDimension.H.name(), transition.getDimension());    assertEquals(PDTransitionMotion.I.name(), transition.getMotion());    assertEquals(COSInteger.ZERO, transition.getDirection());    assertEquals(1, transition.getDuration(), 0);    assertEquals(1, transition.getFlyScale(), 0);    assertFalse(transition.isFlyAreaOpaque());}
public void pdfbox_f8479_0()
{    PDTransition transition = new PDTransition();    transition.setDimension(PDTransitionDimension.H);    assertEquals(PDTransitionDimension.H.name(), transition.getDimension());}
public void pdfbox_f8480_0()
{    PDTransition transition = new PDTransition();    transition.setDirection(PDTransitionDirection.NONE);    assertEquals(COSName.class.getName(), transition.getDirection().getClass().getName());    assertEquals(COSName.NONE, transition.getDirection());}
public void pdfbox_f8481_0()
{    PDTransition transition = new PDTransition();    transition.setDirection(PDTransitionDirection.LEFT_TO_RIGHT);    assertEquals(COSInteger.class.getName(), transition.getDirection().getClass().getName());    assertEquals(COSInteger.ZERO, transition.getDirection());}
public void pdfbox_f8482_0()
{    PDTransition transition = new PDTransition();    transition.setMotion(PDTransitionMotion.O);    assertEquals(PDTransitionMotion.O.name(), transition.getMotion());}
public void pdfbox_f8483_0()
{    PDTransition transition = new PDTransition();    transition.setDuration(4);    assertEquals(4, transition.getDuration(), 0);}
public void pdfbox_f8484_0()
{    PDTransition transition = new PDTransition();    transition.setFlyScale(4);    assertEquals(4, transition.getFlyScale(), 0);}
public void pdfbox_f8485_0()
{    PDTransition transition = new PDTransition();    transition.setFlyAreaOpaque(true);    assertTrue(transition.isFlyAreaOpaque());}
public void pdfbox_f8486_0()
{    Set<PageLayout> pageLayoutSet = EnumSet.noneOf(PageLayout.class);    Set<String> stringSet = new HashSet<>();    for (PageLayout pl : PageLayout.values()) {        String s = pl.stringValue();        stringSet.add(s);        pageLayoutSet.add(PageLayout.fromString(s));    }    assertEquals(PageLayout.values().length, pageLayoutSet.size());    assertEquals(PageLayout.values().length, stringSet.size());}
public void pdfbox_f8487_0()
{        final String value = "SinglePag";        thrown.expect(IllegalArgumentException.class);    PageLayout.fromString(value);}
public void pdfbox_f8488_0()
{        final String value = "FullScreen";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.FULL_SCREEN, retval);}
public void pdfbox_f8489_0()
{        final String value = "UseThumbs";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_THUMBS, retval);}
public void pdfbox_f8490_0()
{        final String value = "UseOC";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_OPTIONAL_CONTENT, retval);}
public void pdfbox_f8491_0()
{        final String value = "UseNone";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_NONE, retval);}
public void pdfbox_f8492_0()
{        final String value = "UseAttachments";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_ATTACHMENTS, retval);}
public void pdfbox_f8493_0()
{        final String value = "UseOutlines";        final PageMode retval = PageMode.fromString(value);        Assert.assertEquals(PageMode.USE_OUTLINES, retval);}
public void pdfbox_f8494_0()
{        final String value = "";        thrown.expect(IllegalArgumentException.class);    PageMode.fromString(value);}
public void pdfbox_f8495_0()
{        final String value = "Dulacb`ecj";        thrown.expect(IllegalArgumentException.class);    PageMode.fromString(value);}
public void pdfbox_f8496_0()
{        final PageMode objectUnderTest = PageMode.USE_OPTIONAL_CONTENT;        final String retval = objectUnderTest.stringValue();        Assert.assertEquals("UseOC", retval);}
public void pdfbox_f8497_0() throws URISyntaxException, IOException
{    checkFields("/org/apache/pdfbox/pdfparser/withcatalog.fdf");    checkFields("/org/apache/pdfbox/pdfparser/nocatalog.fdf");}
private void pdfbox_f8498_0(String name) throws IOException, URISyntaxException
{    try (FDFDocument fdf = FDFDocument.load(new File(TestFDF.class.getResource(name).toURI()))) {        fdf.saveXFDF(new PrintWriter(new ByteArrayOutputStream()));        List<FDFField> fields = fdf.getCatalog().getFDF().getFields();        assertEquals(2, fields.size());        assertEquals("Field1", fields.get(0).getPartialFieldName());        assertEquals("Field2", fields.get(1).getPartialFieldName());        assertEquals("Test1", fields.get(0).getValue());        assertEquals("Test2", fields.get(1).getValue());        try (PDDocument pdf = PDDocument.load(new File(TestFDF.class.getResource("/org/apache/pdfbox/pdfparser/SimpleForm2Fields.pdf").toURI()))) {            PDAcroForm acroForm = pdf.getDocumentCatalog().getAcroForm();            acroForm.importFDF(fdf);            assertEquals("Test1", acroForm.getField("Field1").getValueAsString());            assertEquals("Test2", acroForm.getField("Field2").getValueAsString());        }    }}
protected void pdfbox_f8499_0() throws Exception
{    super.setUp();    testResultsDir.mkdirs();}
public void pdfbox_f8500_0() throws IOException
{        PDDocument document = new PDDocument();    document.addPage(new PDPage());        ByteArrayOutputStream baos = new ByteArrayOutputStream();    document.save(baos);    document.close();        byte[] pdf = baos.toByteArray();    assertTrue(pdf.length > 200);    assertEquals("%PDF-1.4", new String(Arrays.copyOfRange(pdf, 0, 8), "UTF-8"));    assertEquals("%%EOF\n", new String(Arrays.copyOfRange(pdf, pdf.length - 6, pdf.length), "UTF-8"));        PDDocument loadDoc = PDDocument.load(new ByteArrayInputStream(pdf));    assertEquals(1, loadDoc.getNumberOfPages());    loadDoc.close();}
public void pdfbox_f8501_0() throws IOException
{        PDDocument document = new PDDocument();    document.addPage(new PDPage());        File targetFile = new File(testResultsDir, "pddocument-saveloadfile.pdf");    document.save(targetFile);    document.close();        assertTrue(targetFile.length() > 200);    InputStream in = new FileInputStream(targetFile);    byte[] pdf = IOUtils.toByteArray(in);    in.close();    assertTrue(pdf.length > 200);    assertEquals("%PDF-1.4", new String(Arrays.copyOfRange(pdf, 0, 8), "UTF-8"));    assertEquals("%%EOF\n", new String(Arrays.copyOfRange(pdf, pdf.length - 6, pdf.length), "UTF-8"));        PDDocument loadDoc = PDDocument.load(targetFile);    assertEquals(1, loadDoc.getNumberOfPages());    loadDoc.close();}
public void pdfbox_f8502_0() throws IOException
{    PDDocument document = new PDDocument();        assertEquals(1.4f, document.getVersion());    assertEquals(1.4f, document.getDocument().getVersion());    assertEquals("1.4", document.getDocumentCatalog().getVersion());        document.getDocument().setVersion(1.3f);    document.getDocumentCatalog().setVersion(null);        assertEquals(1.3f, document.getVersion());    assertEquals(1.3f, document.getDocument().getVersion());    assertNull(document.getDocumentCatalog().getVersion());    document.close();        document = new PDDocument();    document.setVersion(1.3f);        assertEquals(1.4f, document.getVersion());    assertEquals(1.4f, document.getDocument().getVersion());    assertEquals("1.4", document.getDocumentCatalog().getVersion());        document.setVersion(1.5f);        assertEquals(1.5f, document.getVersion());        assertEquals(1.4f, document.getDocument().getVersion());        assertEquals("1.5", document.getDocumentCatalog().getVersion());    document.close();}
public void pdfbox_f8503_0() throws FileNotFoundException
{    File f = new File("test.pdf");    PrintWriter pw = new PrintWriter(new FileOutputStream(f));    pw.write("<script language='JavaScript'>");    pw.close();    PDDocument doc = null;    try {        doc = PDDocument.load(f);        fail("parsing should fail");    } catch (IOException ex) {        } finally {        assertNull(doc);    }    boolean deleted = f.delete();    assertTrue("delete bad file failed after failed load()", deleted);}
public void pdfbox_f8504_0() throws IOException
{    File f = new File("test.pdf");    PDDocument doc = new PDDocument();    doc.addPage(new PDPage());    doc.save(f);    doc.close();    PDDocument.load(f).close();    boolean deleted = f.delete();    assertTrue("delete good file failed after successful load() and close()", deleted);}
public void pdfbox_f8505_0() throws IOException
{    Locale defaultLocale = Locale.getDefault();    Locale arabicLocale = new Locale.Builder().setLanguageTag("ar-EG-u-nu-arab").build();    Locale.setDefault(arabicLocale);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PDDocument doc = new PDDocument();    doc.addPage(new PDPage());    doc.save(baos);    doc.close();    PDDocument.load(new ByteArrayInputStream(baos.toByteArray())).close();    Locale.setDefault(defaultLocale);}
public void pdfbox_f8506_0() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test_pagelabels.pdf"));        PDDocumentCatalog cat = doc.getDocumentCatalog();        String[] labels = cat.getPageLabels().getLabelsByPageIndices();        assertEquals(12, labels.length);        assertEquals("A1", labels[0]);        assertEquals("A2", labels[1]);        assertEquals("A3", labels[2]);        assertEquals("i", labels[3]);        assertEquals("ii", labels[4]);        assertEquals("iii", labels[5]);        assertEquals("iv", labels[6]);        assertEquals("v", labels[7]);        assertEquals("vi", labels[8]);        assertEquals("vii", labels[9]);        assertEquals("Appendix I", labels[10]);        assertEquals("Appendix II", labels[11]);    } finally {        if (doc != null) {            doc.close();        }    }}
public void pdfbox_f8507_0() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("badpagelabels.pdf"));        PDDocumentCatalog cat = doc.getDocumentCatalog();                cat.getPageLabels().getLabelsByPageIndices();    } finally {        if (doc != null) {            doc.close();        }    }}
public void pdfbox_f8508_0() throws IOException
{    PDDocument doc = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test.unc.pdf"));        assertEquals(4, doc.getNumberOfPages());    } finally {        if (doc != null) {            doc.close();        }    }}
public void pdfbox_f8509_0() throws IOException
{    PDDocument doc = null;    InputStream colorProfile = null;    try {        doc = PDDocument.load(TestPDDocumentCatalog.class.getResourceAsStream("test.unc.pdf"));        PDDocumentCatalog catalog = doc.getDocumentCatalog();                List<PDOutputIntent> outputIntents = catalog.getOutputIntents();        assertTrue(outputIntents.isEmpty());                colorProfile = TestPDDocumentCatalog.class.getResourceAsStream("sRGB.icc");                PDOutputIntent oi = new PDOutputIntent(doc, colorProfile);        oi.setInfo("sRGB IEC61966-2.1");        oi.setOutputCondition("sRGB IEC61966-2.1");        oi.setOutputConditionIdentifier("sRGB IEC61966-2.1");        oi.setRegistryName("http://www.color.org");        doc.getDocumentCatalog().addOutputIntent(oi);                outputIntents = catalog.getOutputIntents();        assertEquals(1, outputIntents.size());                catalog.setOutputIntents(outputIntents);        outputIntents = catalog.getOutputIntents();        assertEquals(1, outputIntents.size());    } finally {        if (doc != null) {            doc.close();        }        if (colorProfile != null) {            colorProfile.close();        }    }}
public void pdfbox_f8510_0() throws IOException
{        PDDocument doc = new PDDocument();    doc.getDocumentCatalog().getCOSObject().setBoolean(COSName.OPEN_ACTION, false);    assertNull(doc.getDocumentCatalog().getOpenAction());}
public void pdfbox_f8511_0() throws Exception
{        try (PDDocument doc = PDDocument.load(new File("src/test/resources/input/hello3.pdf"))) {        PDDocumentInformation info = doc.getDocumentInformation();        assertEquals("Wrong author", "Brian Carrier", info.getAuthor());        assertNotNull("Wrong creationDate", info.getCreationDate());        assertEquals("Wrong creator", "Acrobat PDFMaker 8.1 for Word", info.getCreator());        assertNull("Wrong keywords", info.getKeywords());        assertNotNull("Wrong modificationDate", info.getModificationDate());        assertEquals("Wrong producer", "Acrobat Distiller 8.1.0 (Windows)", info.getProducer());        assertNull("Wrong subject", info.getSubject());        assertNull("Wrong trapped", info.getTrapped());        List<String> expectedMetadataKeys = Arrays.asList("CreationDate", "Author", "Creator", "Producer", "ModDate", "Company", "SourceModified", "Title");        assertEquals("Wrong metadata key count", expectedMetadataKeys.size(), info.getMetadataKeys().size());        for (String key : expectedMetadataKeys) {            assertTrue("Missing metadata key:" + key, info.getMetadataKeys().contains(key));        }                assertEquals("Wrong company", "Basis Technology Corp.", info.getCustomMetadataValue("Company"));        assertEquals("Wrong sourceModified", "D:20080819181502", info.getCustomMetadataValue("SourceModified"));    }}
public void pdfbox_f8512_0() throws Exception
{    try (PDDocument doc = PDDocument.load(TestPDDocumentInformation.class.getResourceAsStream("PDFBOX-3068.pdf"))) {        PDDocumentInformation documentInformation = doc.getDocumentInformation();        assertEquals("Title", documentInformation.getTitle());    }}
public void pdfbox_f8513_0()
{    COSDictionary mockedPageWithAnnotations = new COSDictionary();    COSArray annotsDictionnary = new COSArray();    annotsDictionnary.add(new PDAnnotationRubberStamp().getCOSObject());    annotsDictionnary.add(new PDAnnotationSquare().getCOSObject());    annotsDictionnary.add(new PDAnnotationLink().getCOSObject());    mockedPageWithAnnotations.setItem(COSName.ANNOTS, annotsDictionnary);    page = new PDPage(mockedPageWithAnnotations);}
public void pdfbox_f8514_0() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations();    Assert.assertEquals(3, annotations.size());    Assert.assertTrue(annotations.get(0) instanceof PDAnnotationRubberStamp);    Assert.assertTrue(annotations.get(1) instanceof PDAnnotationSquare);    Assert.assertTrue(annotations.get(2) instanceof PDAnnotationLink);}
public void pdfbox_f8515_0() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations(annotation -> false);    Assert.assertEquals(0, annotations.size());}
public void pdfbox_f8516_0() throws IOException
{    List<PDAnnotation> annotations = page.getAnnotations(annotation -> (annotation instanceof PDAnnotationLink || annotation instanceof PDAnnotationSquare));    Assert.assertEquals(2, annotations.size());    Assert.assertTrue(annotations.get(0) instanceof PDAnnotationSquare);    Assert.assertTrue(annotations.get(1) instanceof PDAnnotationLink);}
public void pdfbox_f8517_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, true)) {                        contentStream.setNonStrokingColor(0.1f, 0.2f, 0.3f, 0.4f);        }                PDFStreamParser parser = new PDFStreamParser(page.getContents());        parser.parse();        java.util.List<Object> pageTokens = parser.getTokens();                                                        assertEquals(0.1f, ((COSFloat) pageTokens.get(0)).floatValue());        assertEquals(0.2f, ((COSFloat) pageTokens.get(1)).floatValue());        assertEquals(0.3f, ((COSFloat) pageTokens.get(2)).floatValue());        assertEquals(0.4f, ((COSFloat) pageTokens.get(3)).floatValue());        assertEquals("k", ((Operator) pageTokens.get(4)).getName());                page = new PDPage();        doc.addPage(page);        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, false)) {                        contentStream.setStrokingColor(0.5f, 0.6f, 0.7f, 0.8f);        }                parser = new PDFStreamParser(page.getContents());        parser.parse();        pageTokens = parser.getTokens();                                                        assertEquals(0.5f, ((COSFloat) pageTokens.get(0)).floatValue());        assertEquals(0.6f, ((COSFloat) pageTokens.get(1)).floatValue());        assertEquals(0.7f, ((COSFloat) pageTokens.get(2)).floatValue());        assertEquals(0.8f, ((COSFloat) pageTokens.get(3)).floatValue());        assertEquals("K", ((Operator) pageTokens.get(4)).getName());    }}
public void pdfbox_f8518_0() throws IOException
{    PDPage page = new PDPage();    PDFStreamParser parser = new PDFStreamParser(page.getContents());    parser.parse();    List<Object> tokens = parser.getTokens();    assertEquals(0, tokens.size());}
public void pdfbox_f8519_0() throws IOException
{    try (PDDocument doc = new PDDocument()) {        PDPage page = new PDPage();        doc.addPage(page);        PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.OVERWRITE, true);        contentStream.close();        contentStream.close();    }}
public void pdfbox_f8520_0() throws IOException, URISyntaxException
{    try (PDDocument doc = PDDocument.load(new File(this.getClass().getResource("/org/apache/pdfbox/pdmodel/interactive/pagenavigation/transitions_test.pdf").toURI()))) {        PDTransition firstTransition = doc.getPages().get(0).getTransition();        assertEquals(PDTransitionStyle.Glitter.name(), firstTransition.getStyle());        assertEquals(2, firstTransition.getDuration(), 0);        assertEquals(PDTransitionDirection.TOP_LEFT_TO_BOTTOM_RIGHT.getCOSBase(), firstTransition.getDirection());    }}
public void pdfbox_f8521_0() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();        try (PDDocument document = new PDDocument()) {        PDPage page = new PDPage();        document.addPage(page);        PDTransition transition = new PDTransition(PDTransitionStyle.Fly);        transition.setDirection(PDTransitionDirection.NONE);        transition.setFlyScale(0.5f);        page.setTransition(transition, 2);        document.save(baos);    }        try (PDDocument doc = PDDocument.load(baos.toByteArray())) {        PDPage page = doc.getPages().get(0);        PDTransition loadedTransition = page.getTransition();        assertEquals(PDTransitionStyle.Fly.name(), loadedTransition.getStyle());        assertEquals(2, page.getCOSObject().getFloat(COSName.DUR), 0);        assertEquals(PDTransitionDirection.NONE.getCOSBase(), loadedTransition.getDirection());    }}
public void pdfbox_f8522_0() throws IOException
{    if (doc != null) {        doc.close();    }}
public void pdfbox_f8523_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();    for (PDOutlineItem current : outline.children()) {        if (current.getTitle().contains("Second")) {            assertEquals(2, doc.getPages().indexOf(current.findDestinationPage(doc)));        }    }}
public void pdfbox_f8524_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    for (int i = 0; i < doc.getNumberOfPages(); i++) {        assertEquals(i, doc.getPages().indexOf(doc.getPage(i)));    }}
public void pdfbox_f8525_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("page_tree_multiple_levels.pdf"));    for (int i = 0; i < doc.getNumberOfPages(); i++) {        assertEquals(i, doc.getPages().indexOf(doc.getPage(i)));    }}
public void pdfbox_f8526_0() throws IOException
{    doc = PDDocument.load(TestPDPageTree.class.getResourceAsStream("with_outline.pdf"));    assertEquals(-1, doc.getPages().indexOf(new PDPage()));}
public static Collection<Object[]> pdfbox_f8527_0()
{    File[] testFiles = new File(inDir).listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.toLowerCase().endsWith(".pdf") || name.toLowerCase().endsWith(".ai"));        }    });    List<Object[]> params = new ArrayList<>();    for (File file : testFiles) {        params.add(new Object[] { file.getName() });    }    return params;}
public boolean pdfbox_f8528_0(File dir, String name)
{    return (name.toLowerCase().endsWith(".pdf") || name.toLowerCase().endsWith(".ai"));}
public void pdfbox_f8529_0() throws IOException
{    new File(outDir).mkdirs();    if (!doTestFile(new File(inDir, filename), inDir, outDir)) {        fail("failure, see test log for details");    }}
private BufferedImage pdfbox_f8530_0(int minWidth, int minHeight, int maxWidth, int maxHeight)
{    BufferedImage bim3 = new BufferedImage(maxWidth, maxHeight, BufferedImage.TYPE_INT_RGB);    Graphics graphics = bim3.getGraphics();    if (minWidth != maxWidth || minHeight != maxHeight) {        graphics.setColor(Color.BLACK);        graphics.fillRect(0, 0, maxWidth, maxHeight);    }    graphics.setColor(Color.WHITE);    graphics.fillRect(0, 0, minWidth, minHeight);    graphics.dispose();    return bim3;}
private BufferedImage pdfbox_f8531_0(BufferedImage bim1, BufferedImage bim2) throws IOException
{    int minWidth = Math.min(bim1.getWidth(), bim2.getWidth());    int minHeight = Math.min(bim1.getHeight(), bim2.getHeight());    int maxWidth = Math.max(bim1.getWidth(), bim2.getWidth());    int maxHeight = Math.max(bim1.getHeight(), bim2.getHeight());    BufferedImage bim3 = null;    if (minWidth != maxWidth || minHeight != maxHeight) {        bim3 = createEmptyDiffImage(minWidth, minHeight, maxWidth, maxHeight);    }    for (int x = 0; x < minWidth; ++x) {        for (int y = 0; y < minHeight; ++y) {            int rgb1 = bim1.getRGB(x, y);            int rgb2 = bim2.getRGB(x, y);            if (rgb1 != rgb2 &&             (Math.abs((rgb1 & 0xFF) - (rgb2 & 0xFF)) > 3 || Math.abs(((rgb1 >> 8) & 0xFF) - ((rgb2 >> 8) & 0xFF)) > 3 || Math.abs(((rgb1 >> 16) & 0xFF) - ((rgb2 >> 16) & 0xFF)) > 3)) {                if (bim3 == null) {                    bim3 = createEmptyDiffImage(minWidth, minHeight, maxWidth, maxHeight);                }                int r = Math.abs((rgb1 & 0xFF) - (rgb2 & 0xFF));                int g = Math.abs((rgb1 & 0xFF00) - (rgb2 & 0xFF00));                int b = Math.abs((rgb1 & 0xFF0000) - (rgb2 & 0xFF0000));                bim3.setRGB(x, y, 0xFFFFFF - (r | g | b));            } else {                if (bim3 != null) {                    bim3.setRGB(x, y, Color.WHITE.getRGB());                }            }        }    }    return bim3;}
public boolean pdfbox_f8532_1(final File file, String inDir, String outDir) throws IOException
{    PDDocument document = null;    boolean failed = false;        try {        new FileOutputStream(new File(outDir, file.getName() + ".parseerror")).close();        document = PDDocument.load(file, (String) null);        String outputPrefix = outDir + '/' + file.getName() + "-";        int numPages = document.getNumberOfPages();        if (numPages < 1) {            failed = true;                    } else {            new File(outDir, file.getName() + ".parseerror").delete();        }                PDFRenderer renderer = new PDFRenderer(document);        for (int i = 0; i < numPages; i++) {            String fileName = outputPrefix + (i + 1) + ".png";            new FileOutputStream(new File(fileName + ".rendererror")).close();                        BufferedImage image = renderer.renderImageWithDPI(i, 96);            new File(fileName + ".rendererror").delete();                        new FileOutputStream(new File(fileName + ".writeerror")).close();            ImageIO.write(image, "PNG", new File(fileName));            new File(fileName + ".writeerror").delete();        }                new FileOutputStream(new File(outDir, file.getName() + ".saveerror")).close();        File tmpFile = File.createTempFile("pdfbox", ".pdf");        document.setAllSecurityToBeRemoved(true);        document.save(tmpFile);        new File(outDir, file.getName() + ".saveerror").delete();        new FileOutputStream(new File(outDir, file.getName() + ".reloaderror")).close();        PDDocument.load(tmpFile, (String) null).close();        new File(outDir, file.getName() + ".reloaderror").delete();        tmpFile.delete();    } catch (IOException e) {        failed = true;                throw e;    } finally {        if (document != null) {            document.close();        }    }            try {        new File(outDir + file.getName() + ".cmperror").delete();        File[] outFiles = new File(outDir).listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return (name.endsWith(".png") && name.startsWith(file.getName(), 0)) && !name.endsWith(".png-diff.png");            }        });        if (outFiles.length == 0) {            failed = true;                    }        for (File outFile : outFiles) {                        new File(outFile.getAbsolutePath() + "-diff.png").delete();            File inFile = new File(inDir + '/' + outFile.getName());            if (!inFile.exists()) {                failed = true;                            } else if (!filesAreIdentical(outFile, inFile)) {                                                BufferedImage bim3 = diffImages(ImageIO.read(inFile), ImageIO.read(outFile));                if (bim3 != null) {                    failed = true;                                        ImageIO.write(bim3, "png", new File(outFile.getAbsolutePath() + "-diff.png"));                    System.err.println("Files differ: " + inFile.getAbsolutePath() + "\n" + "              " + outFile.getAbsolutePath());                } else {                                                            outFile.delete();                }            } else {                                                outFile.delete();            }        }    } catch (Exception e) {        new FileOutputStream(new File(outDir, file.getName() + ".cmperror")).close();        failed = true;            }    return !failed;}
public boolean pdfbox_f8533_0(File dir, String name)
{    return (name.endsWith(".png") && name.startsWith(file.getName(), 0)) && !name.endsWith(".png-diff.png");}
private boolean pdfbox_f8534_0(File left, File right) throws IOException
{    /* -- I reworked ASSERT's into IF statement -- dwilson         assert left != null;         assert right != null;         assert left.exists();         assert right.exists();         */    if (left != null && right != null && left.exists() && right.exists()) {        if (left.length() != right.length()) {            return false;        }        FileInputStream lin = new FileInputStream(left);        FileInputStream rin = new FileInputStream(right);        try {            byte[] lbuffer = new byte[4096];            byte[] rbuffer = new byte[lbuffer.length];            int lcount;            while ((lcount = lin.read(lbuffer)) > 0) {                int bytesRead = 0;                int rcount;                while ((rcount = rin.read(rbuffer, bytesRead, lcount - bytesRead)) > 0) {                    bytesRead += rcount;                }                for (int byteIndex = 0; byteIndex < lcount; byteIndex++) {                    if (lbuffer[byteIndex] != rbuffer[byteIndex]) {                        return false;                    }                }            }        } finally {            lin.close();            rin.close();        }        return true;    } else {        return false;    }}
public static Collection<Object[]> pdfbox_f8535_0()
{    File[] testFiles = new File(INPUT_DIR).listFiles((dir, name) -> (name.endsWith(".pdf") || name.endsWith(".ai")));    return Stream.of(testFiles).map(file -> new Object[] { file.getName() }).collect(Collectors.toList());}
public void pdfbox_f8536_0() throws IOException
{    File file = new File(INPUT_DIR, fileName);    PDDocument document = PDDocument.load(file);    PDFRenderer renderer = new PDFRenderer(document);    renderer.renderImage(0);                    document.close();}
public void pdfbox_f8537_0() throws IOException
{    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new IOException("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }    document = PDDocument.load(new File(IN_DIR, NAME_OF_PDF));    stripper = new PDFTextStripper();    stripper.setLineSeparator("\n");}
public void pdfbox_f8538_0() throws IOException
{    File testFile = new File(IN_DIR, NAME_OF_PDF);    doTestFile(testFile, outDir, false, true);}
public void pdfbox_f8539_0() throws IOException
{    File testFile = new File(IN_DIR, NAME_OF_PDF);    doTestFile(testFile, outDir, false, false);}
public void pdfbox_f8540_0() throws IOException
{    document.close();}
public void pdfbox_f8541_1(File inFile, File outDir, boolean bLogResult, boolean bSort) throws IOException
{    if (bSort) {            } else {            }    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new IOException("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }    PDDocument document = PDDocument.load(inFile);    try {        File outFile;        File expectedFile;        if (bSort) {            outFile = new File(outDir, inFile.getName() + "-sorted.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + "-sorted.txt");        } else {            outFile = new File(outDir, inFile.getName() + ".txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + ".txt");        }        OutputStream os = new FileOutputStream(outFile);        try {            Writer writer = new OutputStreamWriter(os, ENCODING);            try {                                stripper.setSortByPosition(bSort);                stripper.writeText(document, writer);            } finally {                                writer.close();            }        } finally {            os.close();        }        if (bLogResult) {                                }        if (!expectedFile.exists()) {            this.bFail = true;            fail("FAILURE: Input verification file: " + expectedFile.getAbsolutePath() + " did not exist");            return;        }        LineNumberReader expectedReader = new LineNumberReader(new InputStreamReader(new FileInputStream(expectedFile), ENCODING));        LineNumberReader actualReader = new LineNumberReader(new InputStreamReader(new FileInputStream(outFile), ENCODING));        while (true) {            String expectedLine = expectedReader.readLine();            while (expectedLine != null && expectedLine.trim().length() == 0) {                expectedLine = expectedReader.readLine();            }            String actualLine = actualReader.readLine();            while (actualLine != null && actualLine.trim().length() == 0) {                actualLine = actualReader.readLine();            }            if (!stringsEqual(expectedLine, actualLine)) {                this.bFail = true;                fail("FAILURE: Line mismatch for file " + inFile.getName() + " (sort = " + bSort + ")" + " at expected line: " + expectedReader.getLineNumber() + " at actual line: " + actualReader.getLineNumber() + "\nexpected line was: \"" + expectedLine + "\"" + "\nactual line was:   \"" + actualLine + "\"" + "\n");                                    }            if (expectedLine == null || actualLine == null) {                break;            }        }        expectedReader.close();        actualReader.close();    } finally {        document.close();    }}
private boolean pdfbox_f8542_1(String expected, String actual)
{    boolean equals = true;    if ((expected == null) && (actual == null)) {        return true;    } else if (expected != null && actual != null) {        expected = expected.trim();        actual = actual.trim();        char[] expectedArray = expected.toCharArray();        char[] actualArray = actual.toCharArray();        int expectedIndex = 0;        int actualIndex = 0;        while (expectedIndex < expectedArray.length && actualIndex < actualArray.length) {            if (expectedArray[expectedIndex] != actualArray[actualIndex]) {                equals = false;                                break;            }            expectedIndex = skipWhitespace(expectedArray, expectedIndex);            actualIndex = skipWhitespace(actualArray, actualIndex);            expectedIndex++;            actualIndex++;        }        if (equals) {            if (expectedIndex != expectedArray.length) {                equals = false;                            }            if (actualIndex != actualArray.length) {                equals = false;                            }        }    } else {        equals = (expected == null && actual != null && actual.trim().isEmpty()) || (actual == null && expected != null && expected.trim().isEmpty());    }    return equals;}
private int pdfbox_f8543_0(char[] array, int index)
{        if (array[index] == ' ' || array[index] > 256) {        while (index < array.length && (array[index] == ' ' || array[index] > 256)) {            index++;        }        index--;    }    return index;}
public void pdfbox_f8544_0()
{}
private boolean pdfbox_f8545_1(String expected, String actual)
{    boolean equals = true;    if ((expected == null) && (actual == null)) {        return true;    } else if (expected != null && actual != null) {        expected = expected.trim();        actual = actual.trim();        char[] expectedArray = expected.toCharArray();        char[] actualArray = actual.toCharArray();        int expectedIndex = 0;        int actualIndex = 0;        while (expectedIndex < expectedArray.length && actualIndex < actualArray.length) {            if (expectedArray[expectedIndex] != actualArray[actualIndex]) {                equals = false;                                break;            }            expectedIndex = skipWhitespace(expectedArray, expectedIndex);            actualIndex = skipWhitespace(actualArray, actualIndex);            expectedIndex++;            actualIndex++;        }        if (equals) {            if (expectedIndex != expectedArray.length) {                equals = false;                            }            if (actualIndex != actualArray.length) {                equals = false;                            }        }    } else {        equals = (expected == null && actual != null && actual.trim().isEmpty()) || (actual == null && expected != null && expected.trim().isEmpty());    }    return equals;}
private int pdfbox_f8546_0(char[] array, int index)
{        if (array[index] == ' ' || array[index] > 256) {        while (index < array.length && (array[index] == ' ' || array[index] > 256)) {            index++;        }        index--;    }    return index;}
public void pdfbox_f8547_1(File inFile, File outDir, boolean bLogResult, boolean bSort) throws Exception
{    if (bSort) {            } else {            }    if (!outDir.exists()) {        if (!outDir.mkdirs()) {            throw (new Exception("Error creating " + outDir.getAbsolutePath() + " directory"));        }    }        try (PDDocument document = PDDocument.load(inFile)) {        File outFile;        File diffFile;        File expectedFile;        if (bSort) {            outFile = new File(outDir, inFile.getName() + "-sorted.txt");            diffFile = new File(outDir, inFile.getName() + "-sorted-diff.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + "-sorted.txt");        } else {            outFile = new File(outDir, inFile.getName() + ".txt");            diffFile = new File(outDir, inFile.getName() + "-diff.txt");            expectedFile = new File(inFile.getParentFile(), inFile.getName() + ".txt");        }                diffFile.delete();        try (OutputStream os = new FileOutputStream(outFile)) {            os.write(0xEF);            os.write(0xBB);            os.write(0xBF);            try (Writer writer = new BufferedWriter(new OutputStreamWriter(os, ENCODING))) {                                stripper.setSortByPosition(bSort);                stripper.writeText(document, writer);                        }        }        if (bLogResult) {                                }        if (!expectedFile.exists()) {            this.bFail = true;                        return;        }        boolean localFail = false;        try (LineNumberReader expectedReader = new LineNumberReader(new InputStreamReader(new FileInputStream(expectedFile), ENCODING));            LineNumberReader actualReader = new LineNumberReader(new InputStreamReader(new FileInputStream(outFile), ENCODING))) {            while (true) {                String expectedLine = expectedReader.readLine();                while (expectedLine != null && expectedLine.trim().length() == 0) {                    expectedLine = expectedReader.readLine();                }                String actualLine = actualReader.readLine();                while (actualLine != null && actualLine.trim().length() == 0) {                    actualLine = actualReader.readLine();                }                if (!stringsEqual(expectedLine, actualLine)) {                    this.bFail = true;                    localFail = true;                                                                    }                if (expectedLine == null || actualLine == null) {                    break;                }            }        }        if (!localFail) {            outFile.delete();        } else {                        List<String> original = fileToLines(expectedFile);            List<String> revised = fileToLines(outFile);                        Patch patch = DiffUtils.diff(original, revised);            try (PrintStream diffPS = new PrintStream(diffFile, ENCODING)) {                for (Object delta : patch.getDeltas()) {                    if (delta instanceof ChangeDelta) {                        ChangeDelta cdelta = (ChangeDelta) delta;                        diffPS.println("Org: " + cdelta.getOriginal());                        diffPS.println("New: " + cdelta.getRevised());                        diffPS.println();                    } else if (delta instanceof DeleteDelta) {                        DeleteDelta ddelta = (DeleteDelta) delta;                        diffPS.println("Org: " + ddelta.getOriginal());                        diffPS.println("New: " + ddelta.getRevised());                        diffPS.println();                    } else if (delta instanceof InsertDelta) {                        InsertDelta idelta = (InsertDelta) delta;                        diffPS.println("Org: " + idelta.getOriginal());                        diffPS.println("New: " + idelta.getRevised());                        diffPS.println();                    } else {                        diffPS.println(delta);                    }                }            }        }    }}
private static List<String> pdfbox_f8548_0(File file)
{    List<String> lines = new LinkedList<>();    String line;    try {        try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(file), ENCODING))) {            while ((line = in.readLine()) != null) {                lines.add(line);            }        }    } catch (IOException e) {        e.printStackTrace();    }    return lines;}
private int pdfbox_f8549_0(PDDocument doc, PDOutlineItem oi) throws IOException
{    PDPageDestination pageDest = (PDPageDestination) oi.getDestination();        int indexOfPage = doc.getPages().indexOf(oi.findDestinationPage(doc));    int pageNum = pageDest.retrievePageNumber();    assertEquals(indexOfPage, pageNum);    return pageNum;}
public void pdfbox_f8550_0() throws IOException, URISyntaxException
{    PDDocument doc = PDDocument.load(new File(TestPDPageTree.class.getResource("with_outline.pdf").toURI()));    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();    Iterable<PDOutlineItem> children = outline.children();    Iterator<PDOutlineItem> it = children.iterator();    PDOutlineItem oi0 = it.next();    PDOutlineItem oi2 = it.next();    PDOutlineItem oi3 = it.next();    PDOutlineItem oi4 = it.next();    assertEquals(0, findOutlineItemDestPageNum(doc, oi0));    assertEquals(2, findOutlineItemDestPageNum(doc, oi2));    assertEquals(3, findOutlineItemDestPageNum(doc, oi3));    assertEquals(4, findOutlineItemDestPageNum(doc, oi4));    String textFull = stripper.getText(doc);    assertFalse(textFull.isEmpty());    String expectedTextFull = "First level 1\n" + "First level 2\n" + "Fist level 3\n" + "Some content\n" + "Some other content\n" + "Second at level 1\n" + "Second level 2\n" + "Content\n" + "Third level 1\n" + "Third level 2\n" + "Third level 3\n" + "Content\n" + "Fourth level 1\n" + "Content\n" + "Content\n";    assertEquals(expectedTextFull, textFull.replaceAll("\r", ""));            stripper.setStartBookmark(oi2);    stripper.setEndBookmark(oi3);    String textoi23 = stripper.getText(doc);    assertFalse(textoi23.isEmpty());    assertFalse(textoi23.equals(textFull));    String expectedTextoi23 = "Second at level 1\n" + "Second level 2\n" + "Content\n" + "Third level 1\n" + "Third level 2\n" + "Third level 3\n" + "Content\n";    assertEquals(expectedTextoi23, textoi23.replaceAll("\r", ""));            stripper.setStartBookmark(null);    stripper.setEndBookmark(null);    stripper.setStartPage(3);    stripper.setEndPage(4);    String textp34 = stripper.getText(doc);    assertFalse(textp34.isEmpty());    assertFalse(textoi23.equals(textFull));    assertTrue(textoi23.equals(textp34));            stripper.setStartBookmark(oi2);    stripper.setEndBookmark(oi2);    String textoi2 = stripper.getText(doc);    assertFalse(textoi2.isEmpty());    assertFalse(textoi2.equals(textoi23));    assertFalse(textoi23.equals(textFull));    String expectedTextoi2 = "Second at level 1\n" + "Second level 2\n" + "Content\n";    assertEquals(expectedTextoi2, textoi2.replaceAll("\r", ""));            stripper.setStartBookmark(null);    stripper.setEndBookmark(null);    stripper.setStartPage(3);    stripper.setEndPage(3);    String textp3 = stripper.getText(doc);    assertFalse(textp3.isEmpty());    assertFalse(textp3.equals(textp34));    assertFalse(textoi23.equals(textFull));    assertTrue(textoi2.equals(textp3));        PDOutlineItem oiOrphan = new PDOutlineItem();    stripper.setStartBookmark(oiOrphan);    stripper.setEndBookmark(oiOrphan);    String textOiOrphan = stripper.getText(doc);    assertTrue(textOiOrphan.isEmpty());}
private void pdfbox_f8551_0(File inDir, File outDir) throws Exception
{    File[] testFiles = inDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return (name.endsWith(".pdf"));        }    });    for (File testFile : testFiles) {                doTestFile(testFile, outDir, false, false);                doTestFile(testFile, outDir, false, true);    }}
public boolean pdfbox_f8552_0(File dir, String name)
{    return (name.endsWith(".pdf"));}
public void pdfbox_f8553_0() throws Exception
{    String filename = System.getProperty("org.apache.pdfbox.util.TextStripper.file");    File inDir = new File("src/test/resources/input");    File outDir = new File("target/test-output");    File inDirExt = new File("target/test-input-ext");    File outDirExt = new File("target/test-output-ext");    if ((filename == null) || (filename.length() == 0)) {        doTestDir(inDir, outDir);        if (inDirExt.exists()) {            doTestDir(inDirExt, outDirExt);        }    } else {                doTestFile(new File(inDir, filename), outDir, true, false);                doTestFile(new File(inDir, filename), outDir, true, true);    }    if (this.bFail) {        fail("One or more failures, see test log for details");    }}
public static Test pdfbox_f8554_0()
{    return new TestSuite(TestTextStripper.class);}
public static void pdfbox_f8555_0(String[] args)
{    String[] arg = { TestTextStripper.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8556_0()
{    Matrix m = new Matrix(2, 4, 5, 8, 2, 0);    COSArray toCOSArray = m.toCOSArray();    assertEquals(new COSFloat(2), toCOSArray.get(0));    assertEquals(new COSFloat(4), toCOSArray.get(1));    assertEquals(new COSFloat(5), toCOSArray.get(2));    assertEquals(new COSFloat(8), toCOSArray.get(3));    assertEquals(new COSFloat(2), toCOSArray.get(4));    assertEquals(new COSFloat(0), toCOSArray.get(5));}
public void pdfbox_f8557_0() throws Exception
{    TimeZone timezone = TimeZone.getDefault();    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));    assertCalendarEquals(new GregorianCalendar(2005, 4, 12), DateConverter.toCalendar("D:05/12/2005"));    assertCalendarEquals(new GregorianCalendar(2005, 4, 12, 15, 57, 16), DateConverter.toCalendar("5/12/2005 15:57:16"));    TimeZone.setDefault(timezone);        assertNull(DateConverter.toCalendar((String) null));}
public void pdfbox_f8558_0(Calendar expect, Calendar was)
{    assertEquals(expect.getTimeInMillis(), was.getTimeInMillis());    assertEquals(expect.getTimeZone().getRawOffset(), was.getTimeZone().getRawOffset());}
public void pdfbox_f8559_0() throws IOException
{    Calendar c = DateConverter.toCalendar("D:20050526205258+01'00'");    assertEquals(2005, c.get(Calendar.YEAR));    assertEquals(05 - 1, c.get(Calendar.MONTH));    assertEquals(26, c.get(Calendar.DAY_OF_MONTH));    assertEquals(20, c.get(Calendar.HOUR_OF_DAY));    assertEquals(52, c.get(Calendar.MINUTE));    assertEquals(58, c.get(Calendar.SECOND));    assertEquals(0, c.get(Calendar.MILLISECOND));}
private static void pdfbox_f8560_0(int yr, int mon, int day, int hr, int min, int sec, int offsetHours, int offsetMinutes, String orig) throws Exception
{    String pdfDate = String.format(Locale.US, "D:%04d%02d%02d%02d%02d%02d%+03d'%02d'", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    String iso8601Date = String.format(Locale.US, "%04d-%02d-%02d" + "T%02d:%02d:%02d%+03d:%02d", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    Calendar cal = DateConverter.toCalendar(orig);    if (cal != null) {        assertEquals(iso8601Date, DateConverter.toISO8601(cal));        assertEquals(pdfDate, DateConverter.toString(cal));    }        cal = DateConverter.toCalendar(orig);    if (yr == BAD) {        assertEquals(null, cal);    } else {        assertEquals(pdfDate, DateConverter.toString(cal));    }}
public void pdfbox_f8561_0() throws Exception
{    int year = Calendar.getInstance().get(Calendar.YEAR);    checkParse(2010, 4, 23, 0, 0, 0, 0, 0, "D:20100423");    checkParse(2011, 4, 23, 0, 0, 0, 0, 0, "20110423");    checkParse(2012, 1, 1, 0, 0, 0, 0, 0, "D:2012");    checkParse(2013, 1, 1, 0, 0, 0, 0, 0, "2013");        checkParse(2001, 1, 31, 10, 33, 0, +1, 0, "2001-01-31T10:33+01:00  ");        checkParse(2002, 5, 12, 9, 47, 0, 0, 0, "9:47 5/12/2002");        checkParse(2003, 12, 17, 2, 2, 3, 0, 0, "200312172:2:3");        checkParse(2009, 3, 19, 20, 1, 22, 0, 0, "  20090319 200122");    checkParse(2014, 4, 1, 0, 0, 0, +2, 0, "20140401+0200");        checkParse(2115, 1, 11, 0, 0, 0, 0, 0, "Friday, January 11, 2115");        checkParse(1915, 1, 11, 0, 0, 0, 0, 0, "Monday, Jan 11, 1915");        checkParse(2215, 1, 11, 0, 0, 0, 0, 0, "Wed, January 11, 2215");        checkParse(2015, 1, 11, 0, 0, 0, 0, 0, " Sun, January 11, 2015 ");    checkParse(2016, 4, 1, 0, 0, 0, +4, 0, "20160401+04'00'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 0, "20170401+09'00'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 30, "20170401+09'30'");    checkParse(2018, 4, 1, 0, 0, 0, -2, 0, "20180401-02'00'");    checkParse(2019, 4, 1, 6, 1, 1, -11, 0, "20190401 6:1:1 -1100");    checkParse(2020, 5, 26, 11, 25, 10, 0, 0, "26 May 2020 11:25:10");    checkParse(2021, 5, 26, 11, 23, 0, 0, 0, "26 May 2021 11:23");        checkParse(2016, 4, 1, 0, 0, 0, +4, 30, "20160401+04'30'");    checkParse(2017, 4, 1, 0, 0, 0, +9, 30, "20170401+09'30'");    checkParse(2018, 4, 1, 0, 0, 0, -2, 30, "20180401-02'30'");    checkParse(2019, 4, 1, 6, 1, 1, -11, 30, "20190401 6:1:1 -1130");    checkParse(2000, 2, 29, 0, 0, 0, +11, 30, " 2000 Feb 29 GMT + 11:30");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Tuesday, May 32 2000 11:27 UCT");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "32 May 2000 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Tuesday, May 32 2000 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921301 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921232 11:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19921001 11:60");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "19920401 24:25");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0,     "20070430193647+713'00' illegal tz hr");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "nodigits");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "Unknown");    checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "333three digit year");        checkParse(2000, 2, 29, 0, 0, 0, 0, 0, "2000 Feb 29");        checkParse(2000, 2, 29, 0, 0, 0, +11, 0, " 2000 Feb 29 GMT + 11:00");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "2100 Feb 29 GMT+11");        checkParse(2012, 2, 29, 0, 0, 0, +11, 0, "2012 Feb 29 GMT+11");        checkParse(BAD, 0, 0, 0, 0, 0, 0, 0, "2012 Feb 30 GMT+11");        checkParse(1970, 12, 23, 0, 8, 0, 0, 0, "1970 12 23:08");                        checkParse(1971, 7, 6, 17, 22, 1, 0, 0, "Tuesday, 6 Jul 1971 5:22:1 PM");        checkParse(1972, 7, 6, 17, 22, 1, 0, 0, "Thu, July 6, 1972 5:22:1 pm");        checkParse(1973, 7, 6, 17, 22, 1, 0, 0, "7/6/1973 17:22:1");        checkParse(1974, 7, 6, 0, 0, 0, 0, 0, "7/6/1974");        checkParse(1975, 7, 6, 17, 22, 1, -10, 0, "1975-7-6T17:22:1-1000");        checkParse(1976, 7, 6, 17, 22, 1, -4, 0, "1976-7-6T17:22:1GMT-4");            checkParse(BAD, 7, 6, 17, 22, 1, -4, 0, "2076-7-6T17:22:1EDT");            checkParse(1960, 7, 6, 17, 22, 1, -5, 0, "1960-7-6T17:22:1EST");        checkParse(1977, 7, 6, 0, 0, 0, 0, 0, "Wednesday, Jul 6, 1977");        checkParse(1978, 7, 6, 17, 22, 1, 0, 0, "Thu Jul 6, 1978 17:22:1");        checkParse(1979, 7, 6, 17, 22, 1, +8, 0, "Friday July 6 17:22:1 GMT+08:00 1979");        checkParse(1980, 7, 6, 16, 23, 0, 0, 0, "Sun, Jul 6, 1980 at 4:23pm");        checkParse(1981, 7, 6, 0, 0, 0, 0, 0, "Monday, July 6, 1981");        checkParse(1982, 7, 6, 17, 22, 1, 0, 0, "6 Jul 1982 17:22:1");        checkParse(1983, 7, 6, 17, 22, 1, 0, 0, "7/6/1983 17:22:1");        checkParse(1984, 7, 6, 17, 22, 1, 0, 0, "7/6/1984 17:22:01");        checkParse(1985, 7, 6, 0, 0, 0, 0, 0, "7/6/1985");        checkParse(1986, 7, 6, 0, 0, 0, 0, 0, "07/06/1986");        checkParse(1987, 7, 6, 17, 22, 1, 0, 0, "7/6/1987 17:22:1");        checkParse(1988, 7, 6, 0, 0, 0, 0, 0, "7/6/1988");        checkParse(year - 79, 1, 1, 0, 0, 0, 0, 0, "1/1/" + ((year - 79) % 100) +     " 00:00:00");        checkParse(year + 19, 1, 1, 0, 0, 0, 0, 0, "1/1/" + ((year + 19) % 100));        checkParse(1991, 7, 6, 17, 7, 1, +6, 0, "19910706 17:7:1 Z+0600");        checkParse(1992, 7, 6, 17, 7, 1, 0, 0, "19920706 17:07:01");        checkParse(1993, 7, 6, 0, 0, 0, 0, 0, "19930706+00'00'");        checkParse(1994, 7, 6, 0, 0, 0, 1, 0, "19940706+01'00'");        checkParse(1995, 7, 6, 0, 0, 0, 2, 0, "19950706+02'00'");        checkParse(1996, 7, 6, 0, 0, 0, 3, 0, "19960706+03'00'");            checkParse(1997, 7, 6, 0, 0, 0, -10, 0, "19970706-10'00'");        checkParse(1998, 7, 6, 0, 0, 0, -11, 0, "19980706-11'00'");        checkParse(1999, 7, 6, 0, 0, 0, 0, 0, "19990706");        checkParse(2073, 12, 25, 0, 8, 0, 0, 0, "2073 12 25:08");        checkParse(2016, 4, 11, 16, 01, 15, 12, 0, "D:20160411160115+12'00'");}
private static void pdfbox_f8562_0(int yr, int mon, int day, int hr, int min, int sec, TimeZone tz, int offsetHours, int offsetMinutes) throws Exception
{        GregorianCalendar cal = new GregorianCalendar(tz, Locale.ENGLISH);    cal.set(yr, mon - 1, day, hr, min, sec);        String pdfDate = String.format(Locale.US, "D:%04d%02d%02d%02d%02d%02d%+03d'%02d'", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);    String iso8601Date = String.format(Locale.US, "%04d-%02d-%02d" + "T%02d:%02d:%02d%+03d:%02d", yr, mon, day, hr, min, sec, offsetHours, offsetMinutes);        assertEquals(pdfDate, DateConverter.toString(cal));    assertEquals(iso8601Date, DateConverter.toISO8601(cal));}
public void pdfbox_f8563_0() throws Exception
{            TimeZone tzPgh = TimeZone.getTimeZone("America/New_York");        TimeZone tzBerlin = TimeZone.getTimeZone("Europe/Berlin");        TimeZone tzMaputo = TimeZone.getTimeZone("Africa/Maputo");        TimeZone tzAruba = TimeZone.getTimeZone("America/Aruba");        TimeZone tzJamaica = TimeZone.getTimeZone("America/Jamaica");        TimeZone tzMcMurdo = TimeZone.getTimeZone("Antartica/McMurdo");        TimeZone tzAdelaide = TimeZone.getTimeZone("Australia/Adelaide");    assertNull(DateConverter.toCalendar((COSString) null));    assertNull(DateConverter.toCalendar((String) null));    checkToString(2013, 8, 28, 3, 14, 15, tzPgh, -4, 0);    checkToString(2014, 2, 28, 3, 14, 15, tzPgh, -5, 0);    checkToString(2015, 8, 28, 3, 14, 15, tzBerlin, +2, 0);    checkToString(2016, 2, 28, 3, 14, 15, tzBerlin, +1, 0);    checkToString(2017, 8, 28, 3, 14, 15, tzAruba, -4, 0);    checkToString(2018, 1, 1, 1, 14, 15, tzJamaica, -5, 0);    checkToString(2019, 12, 31, 12, 59, 59, tzJamaica, -5, 0);    checkToString(2020, 2, 29, 0, 0, 0, tzMaputo, +2, 0);    checkToString(2015, 8, 28, 3, 14, 15, tzAdelaide, +9, 30);    checkToString(2016, 2, 28, 3, 14, 15, tzAdelaide, +10, 30);        checkToString(1981, 1, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1982, 2, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1983, 3, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1984, 4, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1985, 5, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1986, 6, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1987, 7, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1988, 8, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1989, 9, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1990, 10, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1991, 11, 1, 1, 14, 15, tzMcMurdo, +0, 0);    checkToString(1992, 12, 1, 1, 14, 15, tzMcMurdo, +0, 0);}
private static void pdfbox_f8564_0(int expect, String src)
{    GregorianCalendar dest = DateConverter.newGreg();    DateConverter.parseTZoffset(src, dest, new ParsePosition(0));    assertEquals(expect, dest.get(Calendar.ZONE_OFFSET));}
public void pdfbox_f8565_0()
{        checkParseTZ(0 * HRS + 0 * MINS, "+00:00");    checkParseTZ(0 * HRS + 0 * MINS, "-0000");    checkParseTZ(1 * HRS + 0 * MINS, "+1:00");    checkParseTZ(-(1 * HRS + 0 * MINS), "-1:00");    checkParseTZ(-(1 * HRS + 30 * MINS), "-0130");    checkParseTZ(11 * HRS + 59 * MINS, "1159");    checkParseTZ(12 * HRS + 30 * MINS, "1230");    checkParseTZ(-(12 * HRS + 30 * MINS), "-12:30");    checkParseTZ(0 * HRS + 0 * MINS, "Z");    checkParseTZ(-(8 * HRS + 0 * MINS), "PST");        checkParseTZ(0 * HRS + 0 * MINS, "EDT");    checkParseTZ(-(3 * HRS + 0 * MINS), "GMT-0300");    checkParseTZ(+(11 * HRS + 0 * MINS), "GMT+11:00");    checkParseTZ(-(6 * HRS + 0 * MINS), "America/Chicago");    checkParseTZ(+(3 * HRS + 0 * MINS), "Europe/Moscow");    checkParseTZ(+(9 * HRS + 30 * MINS), "Australia/Adelaide");    checkParseTZ((5 * HRS + 0 * MINS), "0500");    checkParseTZ((5 * HRS + 0 * MINS), "+0500");    checkParseTZ((11 * HRS + 0 * MINS), "+11'00'");    checkParseTZ(0, "Z");        checkParseTZ(12 * HRS + 0 * MINS, "+12:00");    checkParseTZ(-(12 * HRS + 0 * MINS), "-12:00");    checkParseTZ(14 * HRS + 0 * MINS, "1400");    checkParseTZ(-(14 * HRS + 0 * MINS), "-1400");}
private static void pdfbox_f8566_0(double off, String expect)
{    TimeZone tz = new SimpleTimeZone((int) (off * 60 * 60 * 1000), "junkID");    String got = DateConverter.formatTZoffset(tz.getRawOffset(), ":");    assertEquals(expect, got);}
public void pdfbox_f8567_0()
{        checkFormatOffset(-12.1, "-12:06");    checkFormatOffset(12.1, "+12:06");    checkFormatOffset(0, "+00:00");    checkFormatOffset(-1, "-01:00");    checkFormatOffset(.5, "+00:30");    checkFormatOffset(-0.5, "-00:30");    checkFormatOffset(.1, "+00:06");    checkFormatOffset(-0.1, "-00:06");    checkFormatOffset(-12, "-12:00");    checkFormatOffset(12, "+12:00");    checkFormatOffset(-11.5, "-11:30");    checkFormatOffset(11.5, "+11:30");    checkFormatOffset(11.9, "+11:54");    checkFormatOffset(11.1, "+11:06");    checkFormatOffset(-11.9, "-11:54");    checkFormatOffset(-11.1, "-11:06");        checkFormatOffset(14, "+14:00");    checkFormatOffset(-14, "-14:00");}
public static Test pdfbox_f8568_0()
{    return new TestSuite(TestDateUtil.class);}
public static void pdfbox_f8569_0(String[] args)
{    String[] arg = { TestDateUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8570_0()
{    assertArrayEquals(new char[] { '0', '0', '0', '0' }, Hex.getChars((short) 0x0000));    assertArrayEquals(new char[] { '0', '0', '0', 'F' }, Hex.getChars((short) 0x000F));    assertArrayEquals(new char[] { 'A', 'B', 'C', 'D' }, Hex.getChars((short) 0xABCD));    assertArrayEquals(new char[] { 'B', 'A', 'B', 'E' }, Hex.getChars((short) 0xCAFEBABE));}
public void pdfbox_f8571_0()
{    assertArrayEquals(new char[] { '0', '0', '6', '1', '0', '0', '6', '2' }, Hex.getCharsUTF16BE("ab"));    assertArrayEquals(new char[] { '5', 'E', '2', 'E', '5', '2', 'A', '9' }, Hex.getCharsUTF16BE(""));}
private void pdfbox_f8572_0(char[] expected, char[] actual)
{    assertEquals("Length of char array not equal", expected.length, actual.length);    for (int idx = 0; idx < expected.length; idx++) {        if (expected[idx] != actual[idx]) {            fail(String.format("Character at index %d not equal. Expected '%c' but got '%c'", idx, expected[idx], actual[idx]));        }    }}
public static Test pdfbox_f8573_0()
{    return new TestSuite(TestHexUtil.class);}
public static void pdfbox_f8574_0(String[] args)
{    String[] arg = { TestHexUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8575_0() throws Exception
{    Matrix m1 = new Matrix();    assertMatrixIsPristine(m1);    Matrix m2 = m1.clone();    assertNotSame(m1, m2);    assertMatrixIsPristine(m2);}
public void pdfbox_f8576_0() throws Exception
{        final Matrix testMatrix = new Matrix();        for (int x = 0; x < 3; x++) {        for (int y = 0; y < 3; y++) {            testMatrix.setValue(x, y, x + y);        }    }    Matrix m1 = testMatrix.clone();    Matrix m2 = testMatrix.clone();        Matrix product = m1.multiply(m2);    assertNotSame(m1, product);    assertNotSame(m2, product);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, product);            Matrix resultMatrix = new Matrix();    Matrix retVal = m1.multiply(m2, resultMatrix);    assertSame(retVal, resultMatrix);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, resultMatrix);        retVal = m1.multiply(m2, m2);    assertSame(retVal, m2);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m1);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);        m1 = testMatrix.clone();    m2 = testMatrix.clone();    retVal = m1.multiply(m2, m1);    assertSame(retVal, m1);        assertMatrixValuesEqualTo(new float[] { 0, 1, 2, 1, 2, 3, 2, 3, 4 }, m2);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);        m1 = testMatrix.clone();    retVal = m1.multiply(m1, m1);    assertSame(retVal, m1);    assertMatrixValuesEqualTo(new float[] { 5, 8, 11, 8, 14, 20, 11, 20, 29 }, retVal);}
private void pdfbox_f8577_0(Matrix m)
{    assertMatrixValuesEqualTo(new float[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 }, m);}
private void pdfbox_f8578_0(float[] values, Matrix m)
{    float delta = 0.00001f;    for (int i = 0; i < values.length; i++) {                int row = (int) Math.floor(i / 3);        int column = i % 3;        StringBuilder failureMsg = new StringBuilder();        failureMsg.append("Incorrect value for matrix[").append(row).append(",").append(column).append("]");        assertEquals(failureMsg.toString(), values[i], m.getValue(row, column), delta);    }}
public static Test pdfbox_f8579_0()
{    return new TestSuite(TestMatrix.class);}
public static void pdfbox_f8580_0(String[] args)
{    String[] arg = { TestMatrix.class.getName() };    junit.textui.TestRunner.main(arg);}
public void pdfbox_f8581_0()
{    assertEquals(2, NumberFormatUtil.formatFloatFast(51, 5, buffer));    assertArrayEquals(new byte[] { '5', '1' }, Arrays.copyOfRange(buffer, 0, 2));    assertEquals(3, NumberFormatUtil.formatFloatFast(-51, 5, buffer));    assertArrayEquals(new byte[] { '-', '5', '1' }, Arrays.copyOfRange(buffer, 0, 3));    assertEquals(1, NumberFormatUtil.formatFloatFast(0, 5, buffer));    assertArrayEquals(new byte[] { '0' }, Arrays.copyOfRange(buffer, 0, 1));    assertEquals(19, NumberFormatUtil.formatFloatFast(Long.MAX_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '7' }, Arrays.copyOfRange(buffer, 0, 19));                assertEquals(10, NumberFormatUtil.formatFloatFast(Integer.MAX_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '2', '1', '4', '7', '4', '8', '3', '6', '4', '8' }, Arrays.copyOfRange(buffer, 0, 10));    assertEquals(11, NumberFormatUtil.formatFloatFast(Integer.MIN_VALUE, 5, buffer));    assertArrayEquals(new byte[] { '-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8' }, Arrays.copyOfRange(buffer, 0, 11));}
public void pdfbox_f8582_0()
{    assertEquals(3, NumberFormatUtil.formatFloatFast(0.7f, 5, buffer));    assertArrayEquals(new byte[] { '0', '.', '7' }, Arrays.copyOfRange(buffer, 0, 3));    assertEquals(4, NumberFormatUtil.formatFloatFast(-0.7f, 5, buffer));    assertArrayEquals(new byte[] { '-', '0', '.', '7' }, Arrays.copyOfRange(buffer, 0, 4));    assertEquals(5, NumberFormatUtil.formatFloatFast(0.003f, 5, buffer));    assertArrayEquals(new byte[] { '0', '.', '0', '0', '3' }, Arrays.copyOfRange(buffer, 0, 5));    assertEquals(6, NumberFormatUtil.formatFloatFast(-0.003f, 5, buffer));    assertArrayEquals(new byte[] { '-', '0', '.', '0', '0', '3' }, Arrays.copyOfRange(buffer, 0, 6));}
public void pdfbox_f8583_0()
{    assertEquals("NaN should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.NaN, 5, buffer));    assertEquals("+Infinity should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.POSITIVE_INFINITY, 5, buffer));    assertEquals("-Infinity should not be formattable", -1, NumberFormatUtil.formatFloatFast(Float.NEGATIVE_INFINITY, 5, buffer));    assertEquals("Too big number should not be formattable", -1, NumberFormatUtil.formatFloatFast(((float) Long.MAX_VALUE) + 1000000000000f, 5, buffer));    assertEquals("Too big negative number should not be formattable", -1, NumberFormatUtil.formatFloatFast(Long.MIN_VALUE, 5, buffer));}
public void pdfbox_f8584_0()
{    assertEquals(1, NumberFormatUtil.formatFloatFast(0.999999f, 5, buffer));    assertArrayEquals(new byte[] { '1' }, Arrays.copyOfRange(buffer, 0, 1));    assertEquals(4, NumberFormatUtil.formatFloatFast(0.125f, 2, buffer));    assertArrayEquals(new byte[] { '0', '.', '1', '3' }, Arrays.copyOfRange(buffer, 0, 4));    assertEquals(2, NumberFormatUtil.formatFloatFast(-0.999999f, 5, buffer));    assertArrayEquals(new byte[] { '-', '1' }, Arrays.copyOfRange(buffer, 0, 2));}
public void pdfbox_f8585_0()
{    assertEquals(4, NumberFormatUtil.formatFloatFast(0.994f, 2, buffer));    assertArrayEquals(new byte[] { '0', '.', '9', '9' }, Arrays.copyOfRange(buffer, 0, 4));}
public void pdfbox_f8586_0()
{        BigDecimal minVal = new BigDecimal("-10");    BigDecimal maxVal = new BigDecimal("10");    BigDecimal maxDelta = BigDecimal.ZERO;    Pattern pattern = Pattern.compile("^\\-?\\d+(\\.\\d+)?$");    byte[] formatBuffer = new byte[32];    for (int maxFractionDigits = 0; maxFractionDigits <= 5; maxFractionDigits++) {        BigDecimal increment = new BigDecimal(10).pow(-maxFractionDigits, MathContext.DECIMAL128);        for (BigDecimal value = minVal; value.compareTo(maxVal) < 0; value = value.add(increment)) {                        int byteCount = NumberFormatUtil.formatFloatFast(value.floatValue(), maxFractionDigits, formatBuffer);            assertFalse(byteCount == -1);            String newStringResult = new String(formatBuffer, 0, byteCount, Charsets.US_ASCII);            BigDecimal formattedDecimal = new BigDecimal(newStringResult);                                                BigDecimal expectedDecimal = new BigDecimal(value.floatValue());            expectedDecimal = expectedDecimal.setScale(maxFractionDigits, RoundingMode.HALF_UP);            BigDecimal diff = formattedDecimal.subtract(expectedDecimal).abs();            assertTrue(pattern.matcher(newStringResult).matches());                        if (diff.compareTo(maxDelta) > 0) {                fail("Expected: " + expectedDecimal + ", actual: " + newStringResult + ", diff: " + diff);            }        }    }}
private void pdfbox_f8587_0(byte[] expected, byte[] actual)
{    assertEquals("Length of byte array not equal", expected.length, actual.length);    for (int idx = 0; idx < expected.length; idx++) {        if (expected[idx] != actual[idx]) {            fail(String.format("Byte at index %d not equal. Expected '%02X' but got '%02X'", idx, expected[idx], actual[idx]));        }    }}
public static Test pdfbox_f8588_0()
{    return new TestSuite(TestNumberFormatUtil.class);}
public static void pdfbox_f8589_0(String[] args)
{    String[] arg = { TestNumberFormatUtil.class.getName() };    junit.textui.TestRunner.main(arg);}
 void pdfbox_f8590_0(T[] input, T[] expected)
{    List<T> list = Arrays.asList(input);    QuickSort.sort(list);    boolean equal = Arrays.equals(list.toArray(new Object[input.length]), expected);    assertTrue(equal);}
public void pdfbox_f8591_0()
{    {        Integer[] input = new Integer[] { 9, 8, 7, 6, 5, 4, 3, 2, 1 };        Integer[] expected = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 4, 3, 2, 1, 9, 8, 7, 6, 5 };        Integer[] expected = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] {};        Integer[] expected = new Integer[] {};        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 5 };        Integer[] expected = new Integer[] { 5 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 5, 6 };        Integer[] expected = new Integer[] { 5, 6 };        doTest(input, expected);    }    {        Integer[] input = new Integer[] { 6, 5 };        Integer[] expected = new Integer[] { 5, 6 };        doTest(input, expected);    }    Random rnd = new Random(12345);    for (int cnt = 0; cnt < 100; ++cnt) {        int len = rnd.nextInt(20000) + 2;        Integer[] input = new Integer[len];        Integer[] expected = new Integer[len];        for (int i = 0; i < len; ++i) {                        expected[i] = input[i] = rnd.nextInt(rnd.nextInt(100) + 1);        }        Arrays.sort(expected);        doTest(input, expected);    }}
public boolean pdfbox_f8592_0()
{    return this.aaKey != null;}
public COSDictionary pdfbox_f8593_0()
{    return actionDictionnary;}
public String pdfbox_f8594_0()
{    return aaKey;}
protected boolean pdfbox_f8595_0() throws ValidationException
{    List<AbstractActionManager> lActions = this.actionFact.getNextActions(this.context, this.actionDictionnary);    for (AbstractActionManager nAction : lActions) {        if (!nAction.innerValid()) {            return false;        }    }    return true;}
public boolean pdfbox_f8596_0() throws ValidationException
{    return valid(false);}
public boolean pdfbox_f8597_0(boolean additionalActionAuth) throws ValidationException
{    if (isAdditionalAction() && !additionalActionAuth) {        context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTION, "Additional Action are forbidden"));        return false;    }    if (innerValid()) {        return validNextActions();    }    return true;}
public final List<AbstractActionManager> pdfbox_f8598_0(PreflightContext ctx, COSDictionary dictionary) throws ValidationException
{    List<AbstractActionManager> result = new ArrayList<>(0);    Map<COSObjectKey, Boolean> alreadyCreated = new HashMap<>();    COSBase aDict = dictionary.getDictionaryObject(COSName.A);    if (aDict != null) {        callCreateAction(aDict, ctx, result, alreadyCreated);    }    COSBase oaDict = dictionary.getDictionaryObject(COSName.OPEN_ACTION);    if (oaDict != null && !(oaDict instanceof COSArray)) {        callCreateAction(oaDict, ctx, result, alreadyCreated);    }        COSDictionary aaDict = dictionary.getCOSDictionary(COSName.AA);    if (aaDict != null) {        for (COSName name : aaDict.keySet()) {            callCreateAction(aaDict.getDictionaryObject(name), ctx, result, name.getName(), alreadyCreated);        }    }    return result;}
private void pdfbox_f8599_0(COSBase aDict, PreflightContext ctx, List<AbstractActionManager> result, Map<COSObjectKey, Boolean> alreadyCreated) throws ValidationException
{    callCreateAction(aDict, ctx, result, null, alreadyCreated);}
private void pdfbox_f8600_0(COSBase aDict, PreflightContext ctx, List<AbstractActionManager> result, String additionActionKey, Map<COSObjectKey, Boolean> alreadyCreated) throws ValidationException
{    if (aDict instanceof COSDictionary || aDict instanceof COSObject && ((COSObject) aDict).getObject() instanceof COSDictionary) {        if (aDict instanceof COSObject) {            COSObjectKey cok = new COSObjectKey((COSObject) aDict);            COSDictionary indirectDict = (COSDictionary) ((COSObject) aDict).getObject();            if (!alreadyCreated.containsKey(cok)) {                result.add(createActionManager(ctx, indirectDict, additionActionKey));                alreadyCreated.put(cok, true);            }        } else {            result.add(createActionManager(ctx, (COSDictionary) aDict, additionActionKey));        }    } else {        ctx.addValidationError(new ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Action entry isn't an instance of COSDictionary"));    }}
public final List<AbstractActionManager> pdfbox_f8601_0(PreflightContext ctx, COSDictionary actionDictionary) throws ValidationException
{    List<AbstractActionManager> result = new ArrayList<>(0);    Map<COSObjectKey, Boolean> alreadyCreated = new HashMap<>();    COSBase nextDict = actionDictionary.getDictionaryObject(COSName.NEXT);    if (nextDict != null) {        if (nextDict instanceof COSArray) {            COSArray array = (COSArray) nextDict;                        for (int i = 0; i < array.size(); ++i) {                callCreateAction(array.getObject(i), ctx, result, alreadyCreated);            }        } else {                        callCreateAction(nextDict, ctx, result, alreadyCreated);        }    }    return result;}
protected AbstractActionManager pdfbox_f8602_0(PreflightContext ctx, COSDictionary action, String aaKey) throws ValidationException
{    String type = action.getNameAsString(COSName.TYPE);    if (type != null && !ACTION_DICTIONARY_VALUE_TYPE.equals(type)) {        throw new ValidationException("The given dictionary isn't the dictionary of an Action");    }            String s = action.getNameAsString(COSName.S);        if (ACTION_DICTIONARY_VALUE_ATYPE_GOTO.equals(s)) {        return new GoToAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_GOTOR.equals(s)) {        return new GoToRemoteAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_THREAD.equals(s)) {        return new ThreadAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_URI.equals(s)) {        return new UriAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_HIDE.equals(s)) {        return new HideAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_NAMED.equals(s)) {        return new NamedAction(this, action, ctx, aaKey);    }    if (ACTION_DICTIONARY_VALUE_ATYPE_SUBMIT.equals(s)) {        return new SubmitAction(this, action, ctx, aaKey);    }        if (ACTION_DICTIONARY_VALUE_ATYPE_LAUNCH.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_SOUND.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_MOVIE.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_RESET.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_IMPORT.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_JAVASCRIPT.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_SETSTATE.equals(s) || ACTION_DICTIONARY_VALUE_ATYPE_NOOP.equals(s)) {        return new InvalidAction(this, action, ctx, aaKey, s);    }        return new UndefAction(this, action, ctx, aaKey, s);}
protected boolean pdfbox_f8603_0() throws ValidationException
{    COSBase dest = this.actionDictionnary.getItem(COSName.D);        if (dest == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "D entry is mandatory for the GoToActions"));        return false;    }    ContextHelper.validateElement(context, dest, DESTINATION_PROCESS);    return true;}
protected boolean pdfbox_f8604_0() throws ValidationException
{    COSBase dest = this.actionDictionnary.getItem(COSName.D);        if (dest == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "/D entry is mandatory for the GoToActions"));        return false;    }    if (!(dest instanceof COSName || dest instanceof COSString || dest instanceof COSArray)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "Type " + dest.getClass().getSimpleName() + " of /D entry is invalid"));        return false;    }    COSBase f = this.actionDictionnary.getItem(COSName.F);    if (f == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "/F entry is mandatory for the GoToRemoteActions"));        return false;    }    if (dest instanceof COSArray) {        COSArray ar = (COSArray) dest;        if (ar.size() < 2) {            context.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination array must have at least 2 elements"));            return false;        }        if (!(ar.get(1) instanceof COSName)) {            context.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Second element of destination array must be a name"));            return false;        }        validateExplicitDestination(ar);    }    try {        PDDestination.create(dest);    } catch (IOException e) {        context.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));        return false;    }    return true;}
private boolean pdfbox_f8605_0(COSArray ar)
{    if (!(ar.get(0) instanceof COSNumber)) {                context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "First element in /D array entry of GoToRemoteAction must be a page number, but is " + ar.get(0)));        return false;    }    return true;}
protected boolean pdfbox_f8606_0()
{    COSBase t = this.actionDictionnary.getDictionaryObject(COSName.T);        if (t == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "T entry is mandatory for the NamedActions"));        return false;    }    if (!(t instanceof COSDictionary || t instanceof COSArray || t instanceof COSString || t instanceof COSName)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "T entry type is invalid"));        return false;    }    /*         * ---- H entry is optional but the default value is True (annotations of the T entry will be hidden) according         * to the aim of a PDF/A it should be false (annotations of the T entry will be shown).         *          * We check the H value and we throw an error if it is true because of the PDF/A Application Notes sentence :         *          * The PDF Reference supports a concept whereby something will happen when the user performs an explicit or         * implicit action in a PDF viewer - these "things" are called Actions. PDF/A-1 permits a limited set of these         * Actions, which are detailed in section 6.6.1. Specifically, any action that could change the visual         * representation of the document or is not documented in the PDF Reference is not permitted. This includes the         * /Hide action which isn't specifically prohibited by PDF/A-1, but should have been.         */    boolean h = this.actionDictionnary.getBoolean(COSName.H, true);    if (h) {        context.addValidationError(new ValidationError(ERROR_ACTION_HIDE_H_INVALID, "H entry is \"true\""));        return false;    }    return true;}
protected boolean pdfbox_f8607_0()
{    context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN, "The action " + actionName + " is forbidden"));    return false;}
protected boolean pdfbox_f8608_0()
{    String n = this.actionDictionnary.getNameAsString(COSName.N);        if (n == null || "".equals(n)) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "N entry is mandatory for the NamedActions"));        return false;    }        if (!(ACTION_DICTIONARY_VALUE_ATYPE_NAMED_FIRST.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_LAST.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_NEXT.equals(n) || ACTION_DICTIONARY_VALUE_ATYPE_NAMED_PREV.equals(n))) {        context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED, n + " isn't authorized as named action"));        return false;    }    return true;}
protected boolean pdfbox_f8609_0()
{    COSBase f = this.actionDictionnary.getItem(COSName.F);    if (f == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "F entry is mandatory for the SubmitActions"));        return false;    }    return true;}
protected boolean pdfbox_f8610_0()
{    COSBase d = this.actionDictionnary.getDictionaryObject(COSName.D);        if (d == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "D entry is mandatory for the ThreadAction"));        return false;    }    if (!(d instanceof COSInteger || d instanceof COSName || d instanceof COSString || d instanceof COSDictionary)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "D entry type is invalid"));        return false;    }    return true;}
protected boolean pdfbox_f8611_0()
{    context.addValidationError(new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_UNDEF, "The action " + actionName + " is undefined"));    return false;}
protected boolean pdfbox_f8612_0()
{    COSBase uri = this.actionDictionnary.getDictionaryObject(COSName.URI);    if (uri == null) {        context.addValidationError(new ValidationError(ERROR_ACTION_MISING_KEY, "URI entry is mandatory for the UriAction"));        return false;    }    if (!(uri instanceof COSString)) {        context.addValidationError(new ValidationError(ERROR_ACTION_INVALID_TYPE, "URI entry should be a string"));        return false;    }    return true;}
protected boolean pdfbox_f8613_0()
{    boolean result = this.pdAnnot.isPrinted();    result = result && !this.pdAnnot.isHidden();    result = result && !this.pdAnnot.isInvisible();    result = result && !this.pdAnnot.isNoView();    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_FLAG, "Flags of " + pdAnnot.getSubtype() + " annotation are invalid"));    }    return result;}
protected boolean pdfbox_f8614_0()
{    COSBase ca = this.pdAnnot.getCOSObject().getDictionaryObject(COSName.CA);    if (ca instanceof COSFloat) {        float caf = ((COSFloat) ca).floatValue();        if (Float.compare(caf, 1.0f) != 0) {                        ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_CA, "CA entry is invalid. Expected 1.0 / Read " + caf));            return false;        }    }        return true;}
protected boolean pdfbox_f8615_0() throws ValidationException
{    if (this.pdAnnot.getColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
protected boolean pdfbox_f8616_0() throws ValidationException
{    ICCProfileWrapper iccpw = ICCProfileWrapper.getOrSearchICCProfile(ctx);    if (iccpw != null) {        return iccpw.isRGBColorSpace();    }    return false;}
protected boolean pdfbox_f8617_0() throws ValidationException
{    PDAppearanceDictionary ap = this.pdAnnot.getAppearance();    if (ap != null) {        COSDictionary apDict = ap.getCOSObject();                if (apDict.getItem(COSName.D) != null || apDict.getItem(COSName.R) != null) {            ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "Only the N Appearance is authorized"));            return false;        } else if (apDict.getItem(COSName.N) == null) {                        ctx.addValidationError(new ValidationError(ERROR_ANNOT_MISSING_AP_N_CONTENT, "The N Appearance must be present"));            return false;        } else {            COSBase apn = apDict.getDictionaryObject(COSName.N);            COSName subtype = annotDictionary.getCOSName(COSName.SUBTYPE);            COSBase ft = getFieldType();            if (COSName.WIDGET.equals(subtype) && COSName.BTN.equals(ft)) {                                if (apn instanceof COSStream) {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance of a Btn widget must not be a stream, but an appearance subdictionary"));                                                            ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) apn), GRAPHIC_PROCESS);                    return false;                }                if (apn instanceof COSDictionary) {                    for (COSBase val : ((COSDictionary) apn).getValues()) {                                                if (val instanceof COSObject) {                            val = ((COSObject) val).getObject();                        }                        ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) val), GRAPHIC_PROCESS);                    }                } else {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance must be an appearance subdictionary"));                    return false;                }            } else {                                if (apn instanceof COSStream) {                                        ContextHelper.validateElement(ctx, new PDFormXObject((COSStream) apn), GRAPHIC_PROCESS);                } else {                    ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "The N Appearance must be a Stream"));                    return false;                }            }        }    } else if (this.pdAnnot instanceof PDAnnotationWidget && this.pdAnnot.getAppearance() == null) {                                ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_AP_CONTENT, "widget annotation lacks an appearance dictionary"));        return false;    }        return true;}
protected boolean pdfbox_f8618_0() throws ValidationException
{    ContextHelper.validateElement(ctx, annotDictionary, ACTIONS_PROCESS);    return true;}
protected boolean pdfbox_f8619_0() throws ValidationException
{    COSBase cosPopup = this.annotDictionary.getDictionaryObject(COSName.getPDFName(ANNOT_DICTIONARY_VALUE_SUBTYPE_POPUP));    if (cosPopup != null) {        if (!(cosPopup instanceof COSDictionary)) {            ctx.addValidationError(new ValidationError(ERROR_SYNTAX_DICT_INVALID, "An Annotation has a Popup entry, but the value is missing or isn't a dictionary"));            return false;        }        AnnotationValidator popupVal = this.annotFact.getAnnotationValidator(ctx, (COSDictionary) cosPopup);        return popupVal.validate();    }    return true;}
public boolean pdfbox_f8620_0() throws ValidationException
{    boolean isValid = checkMandatoryFields();    isValid = checkFlags() && isValid;    isValid = checkColors() && isValid;    isValid = checkAP() && isValid;    isValid = checkCA() && isValid;    isValid = checkActions() && isValid;    isValid = checkPopup() && isValid;    return isValid;}
protected boolean pdfbox_f8621_0()
{    boolean subtype = this.annotDictionary.containsKey(COSName.SUBTYPE);    boolean rect = this.annotDictionary.containsKey(COSName.RECT);    boolean result = (subtype && rect && checkSpecificMandatoryFields());    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_MISSING_FIELDS, "A mandatory field for the " + this.pdAnnot.getSubtype() + " annotation is missing"));    }    return result;}
protected boolean pdfbox_f8622_0()
{    return true;}
public final void pdfbox_f8623_0(AnnotationValidatorFactory fact)
{    this.annotFact = fact;}
private COSBase pdfbox_f8624_0()
{    COSBase ft = annotDictionary.getDictionaryObject(COSName.FT);    COSDictionary parent = annotDictionary;    while (ft == null) {                COSBase parentBase = parent.getDictionaryObject(COSName.PARENT);        if (parentBase instanceof COSDictionary) {            parent = (COSDictionary) parentBase;            ft = parent.getDictionaryObject(COSName.FT);        } else {            break;        }    }    return ft;}
public final void pdfbox_f8625_0(ActionManagerFactory _actionFact)
{    this.actionFact = _actionFact;}
public final AnnotationValidator pdfbox_f8626_0(PreflightContext ctx, COSDictionary annotDic) throws ValidationException
{    AnnotationValidator result = null;    String subtype = annotDic.getNameAsString(COSName.SUBTYPE);    Class<? extends AnnotationValidator> clazz = this.validatorClasses.get(subtype);    if (clazz == null) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_SUBTYPE, "The subtype isn't authorized : " + subtype));    } else {        try {            Constructor<? extends AnnotationValidator> constructor = clazz.getDeclaredConstructor(PreflightContext.class, COSDictionary.class);            result = constructor.newInstance(ctx, annotDic);            result.setFactory(this);        } catch (Exception e) {            throw new ValidationException(e.getMessage(), e);        }    }    return result;}
protected boolean pdfbox_f8627_0()
{    return this.annotDictionary.containsKey(COSName.DA);}
protected boolean pdfbox_f8628_0()
{    return this.annotDictionary.containsKey(COSName.getPDFName(ANNOT_DICTIONARY_KEY_INKLIST));}
public boolean pdfbox_f8629_0() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkIColors() && isValid;    return isValid;}
protected boolean pdfbox_f8630_0() throws ValidationException
{    if (this.pdLine.getInteriorColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
protected boolean pdfbox_f8631_0()
{    return this.annotDictionary.containsKey(COSName.L);}
public boolean pdfbox_f8632_0() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkDest() && isValid;    return isValid;}
protected boolean pdfbox_f8633_0()
{    try {        if (this.pdLink.getDestination() != null && this.pdLink.getAction() != null) {            ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_DEST, "Dest can't be used due to A element"));            return false;        }        COSDictionary dict = pdLink.getCOSObject();        COSBase dest = dict.getDictionaryObject(COSName.DEST);        if (dest != null) {            ContextHelper.validateElement(ctx, dest, DESTINATION_PROCESS);        }    } catch (IOException e) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_INVALID_DEST, e.getMessage(), e));        return false;    }    return true;}
protected boolean pdfbox_f8634_0()
{    return this.annotDictionary.containsKey(COSName.getPDFName(ANNOT_DICTIONARY_KEY_QUADPOINTS));}
protected void pdfbox_f8635_0()
{    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_TEXT, TextAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_LINK, LinkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_FREETEXT, FreeTextAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_LINE, LineAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_SQUARE, SquareAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_CIRCLE, CircleAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_HIGHLIGHT, HighlightAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_UNDERLINE, UnderlineAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_STRIKEOUT, StrikeoutAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_SQUIGGLY, SquigglyAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_STAMP, RubberStampAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_INK, InkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_POPUP, PopupAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_WIDGET, WidgetAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_PRINTERMARK, PrintMarkAnnotationValidator.class);    this.validatorClasses.put(ANNOT_DICTIONARY_VALUE_SUBTYPE_TRAPNET, TrapNetAnnotationValidator.class);}
public boolean pdfbox_f8636_0() throws ValidationException
{    boolean isValid = super.validate();    isValid = checkIColors() && isValid;    return isValid;}
protected boolean pdfbox_f8637_0() throws ValidationException
{    if (this.pdSquareCircle.getInteriorColor() != null && !searchRGBProfile()) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_COLOR, "Annotation uses a Color profile which isn't the same than the profile contained by the OutputIntent"));        return false;    }    return true;}
protected boolean pdfbox_f8638_0()
{        boolean result = super.checkFlags();    /*         * For Text Annotation, this two flags should be set to avoid potential ambiguity between the annotation         * dictionary and the reader behavior.         */    result = result && this.pdAnnot.isNoRotate();    result = result && this.pdAnnot.isNoZoom();    if (!result) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_NOT_RECOMMENDED_FLAG));    }    return result;}
public boolean pdfbox_f8639_0() throws ValidationException
{    boolean isValid = super.validate();    return checkAAField() && isValid;}
protected boolean pdfbox_f8640_0()
{    if (this.pdWidget.getActions() != null) {        ctx.addValidationError(new ValidationError(ERROR_ANNOT_FORBIDDEN_AA));        return false;    }    return true;}
public String pdfbox_f8641_0()
{    return errorCode;}
public void pdfbox_f8642_0(String errorCode)
{    this.errorCode = errorCode;}
public void pdfbox_f8643_0() throws ValidationException
{    try {        if (processedPage.hasContents()) {            processPage(processedPage);        }    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the Page ContentStream : " + e.getMessage(), e);    }}
public void pdfbox_f8644_0(PDFormXObject form) throws ValidationException
{    try {                if (processedPage == null) {                        processChildStream(form, new PDPage());        } else {            processChildStream(form, processedPage);        }    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the XObject ContentStream : " + e.getMessage(), e);    }}
public void pdfbox_f8645_0(PDTilingPattern pattern) throws ValidationException
{    try {        processChildStream(pattern, processedPage);    } catch (ContentStreamException e) {        context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage()));    } catch (IOException e) {        throw new ValidationException("Unable to check the Pattern ContentStream : " + e.getMessage(), e);    }}
protected void pdfbox_f8646_0(Operator operator, List<COSBase> operands) throws IOException
{    super.processOperator(operator, operands);    /*         * Process Specific Validation. The Generic Processing is useless for PDF/A validation         */    if (OperatorName.BEGIN_INLINE_IMAGE.equals(operator.getName())) {        validateInlineImageFilter(operator);        validateInlineImageColorSpace(operator);    }    checkShowTextOperators(operator, operands);    checkColorOperators(operator.getName());    validateRenderingIntent(operator, operands);    checkSetColorSpaceOperators(operator, operands);    validateNumberOfGraphicStates(operator);    validateDefaultColorSpace(operator);}
protected void pdfbox_f8647_0(Operator operator, List<COSBase> arguments)
{    registerError("The operator \"" + operator.getName() + "\" isn't supported.", ERROR_SYNTAX_CONTENT_STREAM_UNSUPPORTED_OP);}
protected void pdfbox_f8648_0(Operator operator, List<?> arguments) throws IOException
{    String op = operator.getName();    if (OperatorName.SHOW_TEXT.equals(op) || OperatorName.SHOW_TEXT_LINE.equals(op) || OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(op)) {        validateStringDefinition(operator, arguments);    }    if (OperatorName.SHOW_TEXT_ADJUSTED.equals(op)) {        validateStringArray(operator, arguments);    }}
private void pdfbox_f8649_0(Operator operator, List<?> arguments) throws IOException
{    /*         * For a Text operator, the arguments list should contain only one COSString object         */    if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(operator.getName())) {        if (arguments.size() != 3) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }        Object arg0 = arguments.get(0);        Object arg1 = arguments.get(1);        Object arg2 = arguments.get(2);        if (!(arg0 instanceof COSInteger || arg0 instanceof COSFloat) || !(arg1 instanceof COSInteger || arg1 instanceof COSFloat)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }        if (arg2 instanceof COSString) {            validateText(((COSString) arg2).getBytes());        } else {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);        }    } else {        Object objStr = arguments.get(0);        if (objStr instanceof COSString) {            validateText(((COSString) objStr).getBytes());        } else if (!(objStr instanceof COSInteger)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);        }    }}
private void pdfbox_f8650_0(Operator operator, List<?> arguments) throws IOException
{    for (Object object : arguments) {        if (object instanceof COSArray) {            validateStringArray(operator, ((COSArray) object).toList());        } else if (object instanceof COSString) {            validateText(((COSString) object).getBytes());        } else if (!(object instanceof COSInteger || object instanceof COSFloat)) {            registerError("Invalid argument for the operator : " + operator.getName(), ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);            return;        }    }}
public void pdfbox_f8651_0(byte[] string) throws IOException
{        PDTextState textState = getGraphicsState().getTextState();    final RenderingMode renderingMode = textState.getRenderingMode();    final PDFont font = textState.getFont();    if (font == null) {                registerError("Text operator can't be processed without a Font", ERROR_FONTS_UNKNOWN_FONT_REF);        return;    }    FontContainer<?> fontContainer = context.getFontContainer(font.getCOSObject());    if (renderingMode == RenderingMode.NEITHER && (fontContainer == null || !fontContainer.isEmbeddedFont())) {                return;    } else if (fontContainer == null) {                if (font.getName() == null) {            registerError("invalid font dictionary", ERROR_FONTS_UNKNOWN_FONT_REF);        } else {            registerError("font '" + font.getName() + "' is missing", ERROR_FONTS_UNKNOWN_FONT_REF);        }        return;    } else if (!fontContainer.isValid() && !fontContainer.errorsAleadyMerged()) {        context.addValidationErrors(fontContainer.getAllErrors());        fontContainer.setErrorsAlreadyMerged(true);        return;    }    if (!fontContainer.isValid() && fontContainer.errorsAleadyMerged()) {                return;    }    InputStream in = new ByteArrayInputStream(string);    while (in.available() > 0) {        try {            int code = font.readCode(in);            fontContainer.checkGlyphWidth(code);        } catch (IOException e) {            registerError("Encoding can't interpret the character code", ERROR_FONTS_ENCODING_ERROR, e);            return;        } catch (GlyphException e) {            if (renderingMode != RenderingMode.NEITHER) {                registerError(e.getMessage(), e.getErrorCode(), e);                return;            }        }    }}
protected void pdfbox_f8652_0(Operator operator, List<COSBase> arguments) throws ContentStreamException
{    if (OperatorName.SET_RENDERINGINTENT.equals(operator.getName())) {        String riArgument0 = "";        if (arguments.get(0) instanceof COSName) {            riArgument0 = ((COSName) arguments.get(0)).getName();        }        if (!RenderingIntents.contains(riArgument0)) {            registerError("Unexpected value '" + arguments.get(0) + "' for ri operand. ", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        }    }}
protected void pdfbox_f8653_0(Operator operator) throws ContentStreamException
{    if (OperatorName.SAVE.equals(operator.getName())) {        int numberOfGraphicStates = this.getGraphicsStackSize();        if (numberOfGraphicStates > MAX_GRAPHIC_STATES) {            registerError("Too many graphic states", ERROR_GRAPHIC_TOO_MANY_GRAPHIC_STATES);        }    }}
protected void pdfbox_f8654_0(Operator operator) throws ContentStreamException
{    COSDictionary dict = operator.getImageParameters();    /*         * Search a Filter declaration in the InlinedImage dictionary. The LZWDecode Filter is forbidden.         */    COSBase filter = dict.getDictionaryObject(COSName.F, COSName.FILTER);    FilterHelper.isAuthorizedFilter(context, filter instanceof COSName ? ((COSName) filter).getName() : null);}
protected void pdfbox_f8655_0(Operator operator) throws IOException
{    COSDictionary dict = operator.getImageParameters();    COSBase csInlinedBase = dict.getDictionaryObject(COSName.CS, COSName.COLORSPACE);    ColorSpaceHelper csHelper = null;    if (csInlinedBase != null) {        if (csInlinedBase instanceof COSName) {                                    String colorSpace = ((COSName) csInlinedBase).getName();            ColorSpaces cs = null;            try {                cs = ColorSpaces.valueOf(colorSpace);            } catch (IllegalArgumentException e) {                                                PDColorSpace pdCS = this.getResources().getColorSpace(COSName.getPDFName(colorSpace));                if (pdCS != null) {                    cs = ColorSpaces.valueOf(pdCS.getName());                    csHelper = getColorSpaceHelper(pdCS);                }            }            if (cs == null) {                registerError("The ColorSpace " + colorSpace + " is unknown", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);                return;            }        }        if (csHelper == null) {                        csInlinedBase = toLongName(csInlinedBase);            if (csInlinedBase instanceof COSArray && ((COSArray) csInlinedBase).size() > 1) {                COSArray srcArray = (COSArray) csInlinedBase;                COSBase csType = srcArray.get(0);                if (COSName.I.equals(csType) || COSName.INDEXED.equals(csType)) {                    COSArray dstArray = new COSArray();                    dstArray.addAll(srcArray);                    dstArray.set(0, COSName.INDEXED);                    dstArray.set(1, toLongName(srcArray.get(1)));                    csInlinedBase = dstArray;                }            }            PDColorSpace pdCS = PDColorSpace.create(csInlinedBase);            csHelper = getColorSpaceHelper(pdCS);        }        csHelper.validate();    }}
private ColorSpaceHelper pdfbox_f8656_0(PDColorSpace pdCS)
{    PreflightConfiguration cfg = context.getConfig();    ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();    return csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.ONLY_DEVICE);}
private COSBase pdfbox_f8657_0(COSBase cs)
{    if (COSName.RGB.equals(cs)) {        return COSName.DEVICERGB;    }    if (COSName.CMYK.equals(cs)) {        return COSName.DEVICECMYK;    }    if (COSName.G.equals(cs)) {        return COSName.DEVICEGRAY;    }    return cs;}
protected void pdfbox_f8658_0(String operation) throws ContentStreamException
{    PDColorSpace cs = getColorSpace(operation);    if ((OperatorName.NON_STROKING_RGB.equals(operation) || OperatorName.STROKING_COLOR_RGB.equals(operation)) && !validColorSpace(cs, ColorSpaceType.RGB)) {        registerError("The operator \"" + operation + "\" can't be used with CMYK Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_RGB);        return;    }    if ((OperatorName.NON_STROKING_CMYK.equals(operation) || OperatorName.STROKING_COLOR_CMYK.equals(operation)) && !validColorSpace(cs, ColorSpaceType.CMYK)) {        registerError("The operator \"" + operation + "\" can't be used with RGB Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_CMYK);        return;    }    if ((OperatorName.NON_STROKING_GRAY.equals(operation) || OperatorName.STROKING_COLOR_GRAY.equals(operation) || OperatorName.FILL_NON_ZERO.equals(operation) || OperatorName.LEGACY_FILL_NON_ZERO.equals(operation) || OperatorName.FILL_EVEN_ODD.equals(operation) || OperatorName.FILL_NON_ZERO_AND_STROKE.equals(operation) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(operation) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(operation) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(operation)) && !validColorSpace(cs, ColorSpaceType.ALL)) {        registerError("The operator \"" + operation + "\" can't be used without Color Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING);    }}
 void pdfbox_f8659_0(Operator operator) throws ContentStreamException
{    boolean v = false;    String op = operator.getName();    if (OperatorName.SHOW_TEXT.equals(op) || OperatorName.SHOW_TEXT_ADJUSTED.equals(op) || OperatorName.SHOW_TEXT_LINE.equals(op) || OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(op)) {        RenderingMode rm = getGraphicsState().getTextState().getRenderingMode();        if (rm.isFill() && getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDDeviceGray) {            v = true;        }        if (rm.isStroke() && getGraphicsState().getStrokingColor().getColorSpace() instanceof PDDeviceGray) {            v = true;        }    }        if ((OperatorName.FILL_NON_ZERO.equals(op) || OperatorName.LEGACY_FILL_NON_ZERO.equals(op) || OperatorName.FILL_EVEN_ODD.equals(op) || OperatorName.FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(op)) && getGraphicsState().getNonStrokingColor().getColorSpace() instanceof PDDeviceGray) {        v = true;    }        if ((OperatorName.FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_NON_ZERO_AND_STROKE.equals(op) || OperatorName.CLOSE_FILL_EVEN_ODD_AND_STROKE.equals(op) || OperatorName.CLOSE_AND_STROKE.equals(op) || OperatorName.STROKE_PATH.equals(op)) && getGraphicsState().getStrokingColor().getColorSpace() instanceof PDDeviceGray) {        v = true;    }    if (v && !validColorSpaceDestOutputProfile(PreflightStreamEngine.ColorSpaceType.ALL)) {        registerError("/DeviceGray default for operator \"" + op + "\" can't be used without Color Profile", ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING);    }}
private boolean pdfbox_f8660_0(PDColorSpace colorSpace, ColorSpaceType expectedIccType) throws ContentStreamException
{    if (colorSpace == null) {        return validColorSpaceDestOutputProfile(expectedIccType);    } else {        return isDeviceIndependent(colorSpace, expectedIccType) || validColorSpaceDestOutputProfile(expectedIccType);    }}
private boolean pdfbox_f8661_0(ColorSpaceType expectedType) throws ContentStreamException
{    try {        ICCProfileWrapper profileWrapper = ICCProfileWrapper.getOrSearchICCProfile(context);        if (profileWrapper == null) {            return false;        }        switch(expectedType) {            case RGB:                return profileWrapper.isRGBColorSpace();            case CMYK:                return profileWrapper.isCMYKColorSpace();            default:                return true;        }    } catch (ValidationException e) {        throw new ContentStreamException(e);    }}
private boolean pdfbox_f8662_0(PDColorSpace cs, ColorSpaceType expectedIccType)
{    if (cs instanceof PDICCBased) {        int type = ((PDICCBased) cs).getColorSpaceType();        switch(expectedIccType) {            case RGB:                return type == ICC_ColorSpace.TYPE_RGB;            case CMYK:                return type == ICC_ColorSpace.TYPE_CMYK;            default:                return true;        }    } else if (cs instanceof PDSeparation) {        return isDeviceIndependent(((PDSeparation) cs).getAlternateColorSpace(), expectedIccType);    } else {        return cs instanceof PDCIEBasedColorSpace;    }}
private PDColorSpace pdfbox_f8663_0(String operation)
{    if (getGraphicsState() == null) {        return null;    }    if (operation.equals("rg") || operation.equals("g") || operation.equals("k") || operation.equals("f") || operation.equals("F") || operation.equals("f*")) {                return getGraphicsState().getNonStrokingColorSpace();    } else {                return getGraphicsState().getStrokingColorSpace();    }}
protected void pdfbox_f8664_0(Operator operator, List<COSBase> arguments) throws IOException
{    if (!OperatorName.STROKING_COLORSPACE.equals(operator.getName()) && !OperatorName.NON_STROKING_COLORSPACE.equals(operator.getName())) {        return;    }    String colorSpaceName;    if (arguments.get(0) instanceof COSString) {        colorSpaceName = (arguments.get(0)).toString();    } else if (arguments.get(0) instanceof COSName) {        colorSpaceName = ((COSName) arguments.get(0)).getName();    } else {        registerError("The operand " + arguments.get(0) + " for colorSpace operator " + operator.getName() + " doesn't have the expected type", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        return;    }    ColorSpaceHelper csHelper = null;    ColorSpaces cs = null;    try {        cs = ColorSpaces.valueOf(colorSpaceName);    } catch (IllegalArgumentException e) {        /*             * The color space is unknown. Try to access the resources dictionary, the color space can be a reference.             */        PDColorSpace pdCS = this.getResources().getColorSpace(COSName.getPDFName(colorSpaceName));        if (pdCS != null) {            cs = ColorSpaces.valueOf(pdCS.getName());            PreflightConfiguration cfg = context.getConfig();            ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();            csHelper = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);        }    }    if (cs == null) {        registerError("The ColorSpace " + colorSpaceName + " is unknown", ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY);        return;    }    if (csHelper == null) {        PDColorSpace pdCS = PDColorSpace.create(COSName.getPDFName(colorSpaceName));        PreflightConfiguration cfg = context.getConfig();        ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();        csHelper = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);    }    csHelper.validate();}
protected void pdfbox_f8665_0(String msg, String errorCode)
{    registerError(msg, errorCode, null);}
public void pdfbox_f8666_0(String msg, String errorCode, Throwable cause)
{    registerError(msg, errorCode, false, cause);}
protected void pdfbox_f8667_0(String msg, String errorCode, boolean warning)
{    registerError(msg, errorCode, warning, null);}
public void pdfbox_f8668_0(String msg, String errorCode, boolean warning, Throwable cause)
{    ValidationError error = new ValidationError(errorCode, msg, cause);    error.setWarning(warning);    this.context.addValidationError(error);}
public void pdfbox_f8669_0(Operator operator, List<COSBase> arguments) throws IOException
{    String opName = operator.getName();    if (CHECK_NO_OPERANDS.contains(opName)) {        checkNoOperands(arguments);    } else if (CHECK_STRING_OPERANDS.contains(opName)) {        checkStringOperands(arguments, 1);    } else if (CHECK_TAG_AND_PROPERTY_OPERANDS.contains(opName)) {        checkTagAndPropertyOperands(arguments);    } else if (CHECK_NUMBER_OPERANDS_6.contains(opName)) {        checkNumberOperands(arguments, 6);    } else if (CHECK_NUMBER_OPERANDS_4.contains(opName)) {        checkNumberOperands(arguments, 4);    } else if (CHECK_NUMBER_OPERANDS_2.contains(opName)) {        checkNumberOperands(arguments, 2);    } else if (CHECK_NUMBER_OPERANDS.contains(opName)) {        checkNumberOperands(arguments, 1);    } else if (CHECK_ARRAY_OPERANDS.contains(opName)) {        checkArrayOperands(arguments, 1);    } else if (OperatorName.SHOW_TEXT_LINE_AND_SPACE.equals(opName)) {        checkNumberOperands(arguments.subList(0, 2), 2);        checkStringOperands(arguments.subList(2, arguments.size()), 1);    }}
private void pdfbox_f8670_0(List<COSBase> arguments) throws ContentStreamException
{    if (arguments != null && !arguments.isEmpty()) {        throw createInvalidArgumentsError();    }}
private void pdfbox_f8671_0(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (int i = 0; i < length; ++i) {        COSBase arg = arguments.get(i);        if (!(arg instanceof COSName) && !(arg instanceof COSString)) {            throw createInvalidArgumentsError();        }        if (arg instanceof COSName && ((COSName) arg).getName().length() > MAX_NAME_SIZE) {            throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");        }        if (arg instanceof COSString && ((COSString) arg).getString().getBytes().length > MAX_STRING_LENGTH) {            throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");        }    }}
private void pdfbox_f8672_0(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (int i = 0; i < length; ++i) {        COSBase arg = arguments.get(i);        if (!(arg instanceof COSArray)) {            throw createInvalidArgumentsError();        }        if (((COSArray) arg).size() > MAX_ARRAY_ELEMENTS) {            throw createLimitError(ERROR_SYNTAX_ARRAY_TOO_LONG, "Array has " + ((COSArray) arg).size() + " elements");        }    }}
private void pdfbox_f8673_0(List<COSBase> arguments, int length) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != length) {        throw createInvalidArgumentsError();    }    for (COSBase arg : arguments) {        if (!(arg instanceof COSFloat) && !(arg instanceof COSInteger)) {            throw createInvalidArgumentsError();        }        if (arg instanceof COSInteger && (((COSInteger) arg).longValue() > Integer.MAX_VALUE || ((COSInteger) arg).longValue() < Integer.MIN_VALUE)) {            throw createLimitError(ERROR_SYNTAX_NUMERIC_RANGE, "Invalid integer range in a Number operand");        }        if (arg instanceof COSFloat && (((COSFloat) arg).doubleValue() > MAX_POSITIVE_FLOAT || ((COSFloat) arg).doubleValue() < MAX_NEGATIVE_FLOAT)) {            throw createLimitError(ERROR_SYNTAX_NUMERIC_RANGE, "Invalid float range in a Number operand");        }    }}
private void pdfbox_f8674_0(List<COSBase> arguments) throws ContentStreamException
{    if (arguments == null || arguments.isEmpty() || arguments.size() != 2) {        throw createInvalidArgumentsError();    }    COSBase arg = arguments.get(0);    if (!(arg instanceof COSName) && !(arg instanceof COSString)) {        throw createInvalidArgumentsError();    }    if (arg instanceof COSName && ((COSName) arg).getName().length() > MAX_NAME_SIZE) {        throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");    }    if (arg instanceof COSString && ((COSString) arg).getString().getBytes().length > MAX_STRING_LENGTH) {        throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");    }    COSBase arg2 = arguments.get(1);    if (!(arg2 instanceof COSName) && !(arg2 instanceof COSString) && !(arg2 instanceof COSDictionary)) {        throw createInvalidArgumentsError();    }    if (arg2 instanceof COSName && ((COSName) arg2).getName().length() > MAX_NAME_SIZE) {        throw createLimitError(ERROR_SYNTAX_NAME_TOO_LONG, "A Name operand is too long");    }    if (arg2 instanceof COSString && ((COSString) arg2).getString().getBytes().length > MAX_STRING_LENGTH) {        throw createLimitError(ERROR_SYNTAX_LITERAL_TOO_LONG, "A String operand is too long");    }    if (arg2 instanceof COSDictionary && ((COSDictionary) arg2).size() > MAX_DICT_ENTRIES) {        throw createLimitError(ERROR_SYNTAX_TOO_MANY_ENTRIES, "Dictionary has " + ((COSDictionary) arg2).size() + " entries");    }}
private ContentStreamException pdfbox_f8675_0()
{    ContentStreamException ex = new ContentStreamException("Invalid arguments");    ex.setErrorCode(ERROR_SYNTAX_CONTENT_STREAM_INVALID_ARGUMENT);    return ex;}
private ContentStreamException pdfbox_f8676_0(String errorCode, String details)
{    ContentStreamException ex = new ContentStreamException(details);    ex.setErrorCode(errorCode);    return ex;}
public String pdfbox_f8677_0()
{    return name;}
public String pdfbox_f8678_0()
{    return processName;}
public ValidationResult pdfbox_f8679_0()
{    return result;}
public Integer pdfbox_f8680_0()
{    return pageNumber;}
protected void pdfbox_f8681_0(COSBase ctog)
{    checkCIDToGIDMap(ctog, false);}
protected void pdfbox_f8682_0()
{    this.descriptorHelper = new CIDType0DescriptorHelper(context, font, fontContainer);}
protected void pdfbox_f8683_0(COSBase ctog)
{    checkCIDToGIDMap(ctog, true);}
protected void pdfbox_f8684_0()
{    this.descriptorHelper = new CIDType2DescriptorHelper(context, font, fontContainer);}
public boolean pdfbox_f8685_0(int code) throws IOException
{    return font.codeToGID(code) != 0;}
public boolean pdfbox_f8686_0(int code) throws IOException
{    return font.codeToGID(code) != 0;}
public void pdfbox_f8687_0(ValidationError error)
{    this.errorBuffer.add(error);}
public void pdfbox_f8688_0(List<ValidationError> errors)
{    this.errorBuffer.addAll(errors);}
public List<ValidationError> pdfbox_f8689_0()
{    return this.errorBuffer;}
public boolean pdfbox_f8690_0()
{    return this.errorBuffer.isEmpty() && isEmbeddedFont();}
public boolean pdfbox_f8691_0()
{    return errorsAlreadyMerged;}
public void pdfbox_f8692_0(boolean errorsAlreadyMerged)
{    this.errorsAlreadyMerged = errorsAlreadyMerged;}
public boolean pdfbox_f8693_0()
{    return embeddedFont;}
public void pdfbox_f8694_0()
{    this.embeddedFont = false;}
public void pdfbox_f8695_0(int code) throws GlyphException
{    if (isAlreadyProcessed(code)) {        return;    }    try {                if (!hasGlyph(code)) {            GlyphException e = new GlyphException(PreflightConstants.ERROR_FONTS_GLYPH_MISSING, code, "The character code " + code + " in the font program \"" + font.getName() + "\" is missing from the Character Encoding");            markAsInvalid(code, e);            throw e;        }                float expectedWidth = font.getWidth(code);        float foundWidth = font.getWidthFromFont(code);        checkWidthsConsistency(code, expectedWidth, foundWidth);    } catch (IOException e) {        throw new GlyphException(PreflightConstants.ERROR_FONTS_GLYPH, code, "Unexpected error during the width validation for the character code " + code + " : " + e.getMessage(), e);    }}
private boolean pdfbox_f8696_0(int code) throws GlyphException
{    boolean already = false;    GlyphDetail detail = codeToDetail.get(code);    if (detail != null) {        detail.throwExceptionIfNotValid();        already = true;    }    return already;}
private void pdfbox_f8697_0(int code, float expectedWidth, float foundWidth) throws GlyphException
{        if (Math.abs(foundWidth - expectedWidth) > 1) {        GlyphException e = new GlyphException(PreflightConstants.ERROR_FONTS_METRICS, code, "Width (" + foundWidth + ") of the character \"" + code + "\" in the font program \"" + this.font.getName() + "\" is inconsistent with the width (" + expectedWidth + ") in the PDF dictionary.");        markAsInvalid(code, e);        throw e;    }    markAsValid(code);}
public final void pdfbox_f8698_0(int code)
{    this.codeToDetail.put(code, new GlyphDetail(code));}
public final void pdfbox_f8699_0(int code, GlyphException e)
{    this.codeToDetail.put(code, new GlyphDetail(code, e));}
public boolean pdfbox_f8700_0(int code) throws IOException
{    if (font.isEmbedded()) {        int gid = font.codeToGID(code);        return gid != 0;    }    return false;}
public void pdfbox_f8701_0(FontContainer<?> delegateFontContainer)
{    this.delegateFontContainer = delegateFontContainer;}
public List<ValidationError> pdfbox_f8702_0()
{    if (this.delegateFontContainer != null) {        this.errorBuffer.addAll(this.delegateFontContainer.getAllErrors());    }    return this.errorBuffer;}
public boolean pdfbox_f8703_0()
{    boolean result = (this.errorBuffer.isEmpty() && isEmbeddedFont());    if (this.delegateFontContainer != null) {        result &= this.delegateFontContainer.isValid();    }    return result;}
public boolean pdfbox_f8704_0()
{    boolean result = embeddedFont;    if (this.delegateFontContainer != null) {        result &= this.delegateFontContainer.isEmbeddedFont();    }    return result;}
public boolean pdfbox_f8705_0(int code) throws IOException
{    return this.delegateFontContainer.hasGlyph(code);}
public boolean pdfbox_f8706_0(int code) throws IOException
{    if (font.isEmbedded()) {        String name = font.getEncoding().getName(code);        return font.getFontBoxFont().hasGlyph(name);    }    return false;}
public boolean pdfbox_f8707_0(int code) throws IOException
{    return font.getCharProc(code) != null;}
protected void pdfbox_f8708_0()
{    boolean arePresent = fontDictionary.containsKey(COSName.TYPE);    arePresent &= fontDictionary.containsKey(COSName.SUBTYPE);    arePresent &= fontDictionary.containsKey(COSName.BASE_FONT);    arePresent &= fontDictionary.containsKey(COSName.CIDSYSTEMINFO);    arePresent &= fontDictionary.containsKey(COSName.FONT_DESC);    if (!arePresent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Required keys are missing"));    }    checkCIDSystemInfo(fontDictionary.getCOSDictionary(COSName.CIDSYSTEMINFO));    checkCIDToGIDMap(fontDictionary.getDictionaryObject(COSName.CID_TO_GID_MAP));}
protected void pdfbox_f8709_0(COSDictionary sysinfo)
{    if (sysinfo != null) {        String reg = sysinfo.getString(COSName.REGISTRY);        String ord = sysinfo.getString(COSName.ORDERING);        COSBase sup = sysinfo.getDictionaryObject(COSName.SUPPLEMENT);        if (!(reg != null && ord != null && sup instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));        }    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));    }}
protected void pdfbox_f8710_0(COSBase ctog, boolean mandatory)
{    if (ctog instanceof COSName) {                if (!COSName.IDENTITY.equals(ctog)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": The CIDToGID entry is invalid"));        }    } else if (ctog instanceof COSStream) {        try {                        InputStream is = ((COSStream) ctog).createInputStream();            is.close();        } catch (IOException e) {                        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": error getting CIDToGIDMap", e));        }    } else if (mandatory) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CIDTOGID, font.getName() + ": mandatory CIDToGIDMap missing"));    }}
public PDStream pdfbox_f8711_0(PDFontDescriptor fontDescriptor)
{    PDStream ff3 = fontDescriptor.getFontFile3();    if (ff3 != null) {                COSStream stream = ff3.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();        } else {                                    String st = stream.getNameAsString(COSName.SUBTYPE);            if (!(FONT_DICTIONARY_VALUE_TYPE0C.equals(st) || FONT_DICTIONARY_VALUE_TYPE1C.equals(st))) {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": invalid /Subtype /" + st + " in /FontFile3 stream"));            }            checkCIDSet(fontDescriptor);        }    }    return ff3;}
protected void pdfbox_f8712_0(PDFontDescriptor pfDescriptor)
{    if (isSubSet(pfDescriptor.getFontName())) {        COSBase cidset = pfDescriptor.getCOSObject().getDictionaryObject(COSName.CID_SET);        if (!(cidset instanceof COSStream)) {            this.fContainer.push(new ValidationResult.ValidationError(ERROR_FONTS_CIDSET_MISSING_FOR_SUBSET, pfDescriptor.getFontName() + ": The CIDSet entry is missing for the Composite Subset"));        }    }}
protected void pdfbox_f8713_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The FontFile can't be read"));    }}
protected void pdfbox_f8714_0(PDFontDescriptor pfDescriptor)
{    if (isSubSet(pfDescriptor.getFontName())) {        COSBase cidset = pfDescriptor.getCOSObject().getDictionaryObject(COSName.CID_SET);        if (!(cidset instanceof COSStream)) {            this.fContainer.push(new ValidationResult.ValidationError(ERROR_FONTS_CIDSET_MISSING_FOR_SUBSET, pfDescriptor.getFontName() + ": The CIDSet entry is missing for the Composite Subset"));        }    }}
public PDStream pdfbox_f8715_0(PDFontDescriptor fontDescriptor)
{    PDStream ff2 = fontDescriptor.getFontFile2();    if (ff2 != null) {                COSStream stream = ff2.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();        }    }    checkCIDSet(fontDescriptor);    return ff2;}
protected void pdfbox_f8716_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The FontFile can't be read"));    }}
public void pdfbox_f8717_0()
{    PDFontDescriptor fd = this.font.getFontDescriptor();    boolean isStandard14 = false;    if (this.font instanceof PDFont) {        isStandard14 = ((PDFont) font).isStandard14();    }        if (fd != null) {        fontDescriptor = fd;        if (!isStandard14) {            checkMandatoryFields(fontDescriptor.getCOSObject());        }        if (hasOnlyOneFontFile(fontDescriptor)) {            PDStream fontFile = extractFontFile(fontDescriptor);            if (fontFile != null) {                processFontFile(fontDescriptor, fontFile);                checkFontFileMetaData(fontDescriptor, fontFile);            }        } else {            if (fontFileNotEmbedded(fontDescriptor)) {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": FontFile entry is missing from FontDescriptor"));                this.fContainer.notEmbedded();            } else {                this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": They is more than one FontFile"));            }        }    } else {        this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": FontDescriptor is null or is an AFM Descriptor"));        this.fContainer.notEmbedded();    }}
protected boolean pdfbox_f8718_0(COSDictionary fDescriptor)
{    boolean result = true;    StringBuilder missingFields = new StringBuilder();    for (String field : MANDATORYFIELDS) {        if (!fDescriptor.containsKey(field)) {            if (missingFields.length() > 1) {                missingFields.append(", ");            }            missingFields.append(field);        }    }    if (fDescriptor.containsKey(COSName.TYPE)) {        COSBase type = fDescriptor.getItem(COSName.TYPE);        if (!COSName.FONT_DESC.equals(type)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": /Type in FontDescriptor must be /FontDescriptor, but is " + type));            result = false;        }    }    if (missingFields.length() > 0) {        this.fContainer.push(new ValidationError(ERROR_FONTS_DESCRIPTOR_INVALID, this.font.getName() + ": some mandatory fields are missing from the FontDescriptor: " + missingFields + "."));        result = false;    }    return result;}
protected boolean pdfbox_f8719_0(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff2 = fontDescriptor.getFontFile2();    PDStream ff3 = fontDescriptor.getFontFile3();    return (ff1 != null ^ ff2 != null ^ ff3 != null);}
protected boolean pdfbox_f8720_0(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff2 = fontDescriptor.getFontFile2();    PDStream ff3 = fontDescriptor.getFontFile3();    return (ff1 == null && ff2 == null && ff3 == null);}
protected void pdfbox_f8721_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    try {        PDMetadata metadata = fontFile.getMetadata();        if (metadata != null) {                        if (metadata.getFilters() != null && !metadata.getFilters().isEmpty()) {                this.fContainer.push(new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, this.font.getName() + ": Filter specified in font file metadata dictionnary"));                return;            }            byte[] mdAsBytes = getMetaDataStreamAsBytes(metadata);            try {                DomXmpParser xmpBuilder = new DomXmpParser();                XMPMetadata xmpMeta = xmpBuilder.parse(mdAsBytes);                FontMetaDataValidation fontMDval = new FontMetaDataValidation();                List<ValidationError> ve = new ArrayList<>();                fontMDval.analyseFontName(xmpMeta, fontDescriptor, ve);                fontMDval.analyseRights(xmpMeta, fontDescriptor, ve);                this.fContainer.push(ve);            } catch (XmpParsingException e) {                if (e.getErrorType() == ErrorType.NoValueType) {                    this.fContainer.push(new ValidationError(ERROR_METADATA_UNKNOWN_VALUETYPE, e.getMessage(), e));                } else if (e.getErrorType() == ErrorType.XpacketBadEnd) {                    this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_XPACKET, this.font.getName() + ": Unable to parse font metadata due to : " + e.getMessage(), e));                } else {                    this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT, e.getMessage(), e));                }            }        }    } catch (IllegalStateException e) {        this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_UNKOWN, this.font.getName() + ": The Metadata entry doesn't reference a stream object", e));    }}
protected final byte[] pdfbox_f8722_0(PDMetadata metadata)
{    try (InputStream metaDataContent = metadata.createInputStream()) {        return IOUtils.toByteArray(metaDataContent);    } catch (IOException e) {        this.fContainer.push(new ValidationError(ERROR_METADATA_FORMAT_STREAM, this.font.getName() + ": Unable to read font metadata due to : " + e.getMessage(), e));        return null;    }}
public static boolean pdfbox_f8723_0(String fontName)
{    return fontName != null && fontName.matches("^[A-Z]{6}\\+.*");}
public PDStream pdfbox_f8724_0(PDFontDescriptor fontDescriptor)
{    PDStream fontFile = fontDescriptor.getFontFile2();    COSStream stream = (fontFile == null ? null : fontFile.getCOSObject());    if (stream == null) {        this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile2 is missing"));        this.fContainer.notEmbedded();        return null;    }    if (stream.getInt(COSName.LENGTH1) <= 0) {        this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile entry /Length1 is invalid"));        return null;    }    return fontFile;}
protected void pdfbox_f8725_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_TRUETYPE_DAMAGED, this.font.getName() + ": The FontFile can't be read"));    } else {                TrueTypeFont ttf = pdTrueTypeFont.getTrueTypeFont();        try {            if (pdTrueTypeFont.isSymbolic() && ttf.getCmap().getCmaps().length != 1) {                this.fContainer.push(new ValidationError(ERROR_FONTS_ENCODING, this.font.getName() + ": Symbolic TrueType font has more than one 'cmap' entry"));            }        } catch (IOException e) {            this.fContainer.push(new ValidationError(ERROR_FONTS_TRUETYPE_DAMAGED, this.font.getName() + ": The TTF 'cmap' could not be read"));        }    }}
protected boolean pdfbox_f8726_0(COSDictionary fDescriptor)
{    boolean result = super.checkMandatoryFields(fDescriptor);    /*         * if this font is a subset, the CharSet entry must be present in the FontDescriptor         */    if (isSubSet(fontDescriptor.getFontName())) {        String charsetStr = fontDescriptor.getCharSet();        if (charsetStr == null || "".equals(charsetStr)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_CHARSET_MISSING_FOR_SUBSET, fontDescriptor.getFontName() + ": The Charset entry is missing for the Type1 Subset"));            result = false;        }    }    return result;}
public PDStream pdfbox_f8727_0(PDFontDescriptor fontDescriptor)
{    PDStream ff1 = fontDescriptor.getFontFile();    PDStream ff3 = fontDescriptor.getFontFile3();    if (ff1 != null) {        COSStream stream = ff1.getCOSObject();        if (stream == null) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is missing"));            this.fContainer.notEmbedded();            return null;        }        boolean hasLength1 = stream.getInt(COSName.LENGTH1) > 0;        boolean hasLength2 = stream.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_LENGTH2)) > 0;        boolean hasLength3 = stream.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_LENGTH3)) >= 0;        if (!(hasLength1 && hasLength2 && hasLength3)) {            this.fContainer.push(new ValidationError(ERROR_FONTS_FONT_FILEX_INVALID, fontDescriptor.getFontName() + ": The FontFile is invalid"));            return null;        }        return ff1;    } else {        return ff3;    }}
protected void pdfbox_f8728_0(PDFontDescriptor fontDescriptor, PDStream fontFile)
{    if (font.isDamaged()) {        this.fContainer.push(new ValidationError(ERROR_FONTS_TYPE1_DAMAGED, this.font.getName() + ": The FontFile can't be read"));    }}
protected void pdfbox_f8729_0()
{}
protected void pdfbox_f8730_0()
{}
public T pdfbox_f8731_0()
{    return fontContainer;}
public void pdfbox_f8732_0() throws ValidationException
{    checkMandatoryField();    createFontDescriptorHelper();    processFontDescriptorValidation();    checkEncoding();    checkToUnicode();}
protected void pdfbox_f8733_0()
{    String missingFields = "";    boolean areFieldsPresent = fontDictionary.containsKey(COSName.TYPE);    if (!areFieldsPresent) {        missingFields = "type, ";    }    boolean subType = fontDictionary.containsKey(COSName.SUBTYPE);    areFieldsPresent &= subType;    if (!subType) {        missingFields += "subType, ";    }    boolean baseFont = fontDictionary.containsKey(COSName.BASE_FONT);    areFieldsPresent &= baseFont;    if (!baseFont) {        missingFields += "baseFont, ";    }    boolean firstChar = fontDictionary.containsKey(COSName.FIRST_CHAR);    areFieldsPresent &= firstChar;    if (!firstChar) {        missingFields += "firstChar, ";    }    boolean lastChar = fontDictionary.containsKey(COSName.LAST_CHAR);    areFieldsPresent &= lastChar;    if (!lastChar) {        missingFields += "lastChar, ";    }    boolean widths = fontDictionary.containsKey(COSName.WIDTHS);    areFieldsPresent &= widths;    if (!widths) {        missingFields += "widths, ";    }    if (!areFieldsPresent) {        if (missingFields.endsWith(", ")) {            missingFields = missingFields.substring(0, missingFields.length() - 2);        }        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, this.font.getName() + ": some required fields are missing from the Font dictionary: " + missingFields + "."));    }}
protected void pdfbox_f8734_0()
{    this.descriptorHelper.validate();}
protected void pdfbox_f8735_0()
{    this.descriptorHelper = new TrueTypeDescriptorHelper(context, (PDTrueTypeFont) font, fontContainer);}
protected void pdfbox_f8736_0()
{    PDTrueTypeFont ttFont = (PDTrueTypeFont) font;    PDFontDescriptor fd = ttFont.getFontDescriptor();    if (fd != null) {        /*             * only MacRomanEncoding or WinAnsiEncoding are allowed for a non symbolic font.             */        if (fd.isNonSymbolic()) {            Encoding encodingValue = ttFont.getEncoding();            if (!(encodingValue instanceof MacRomanEncoding || encodingValue instanceof WinAnsiEncoding)) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING, fd.getFontName() + ": The Encoding is invalid for the NonSymbolic TTF"));            }        }        /*             * For symbolic font, no encoding entry is allowed and only one encoding entry is expected into the FontFile             * CMap (Check latter when the FontFile stream will be checked)             */        if (fd.isSymbolic() && fontDictionary.getItem(COSName.ENCODING) != null) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING, fd.getFontName() + ": The Encoding should be missing for the Symbolic TTF"));        }    }}
public void pdfbox_f8737_0() throws ValidationException
{    checkMandatoryFields();    processDescendantFont();    checkEncoding();    checkToUnicode();}
protected void pdfbox_f8738_0()
{    COSDictionary fontDictionary = font.getCOSObject();    boolean areFieldsPResent = fontDictionary.containsKey(COSName.TYPE);    areFieldsPResent &= fontDictionary.containsKey(COSName.SUBTYPE);    areFieldsPResent &= fontDictionary.containsKey(COSName.BASE_FONT);    areFieldsPResent &= fontDictionary.containsKey(COSName.DESCENDANT_FONTS);    areFieldsPResent &= fontDictionary.containsKey(COSName.ENCODING);    if (!areFieldsPResent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Some keys are missing from composite font dictionary"));    }}
protected void pdfbox_f8739_0() throws ValidationException
{    COSDictionary fontDictionary = font.getCOSObject();        COSArray array = fontDictionary.getCOSArray(COSName.DESCENDANT_FONTS);    if (array == null || array.size() != 1) {        /*             * in PDF 1.4, this array must contain only one element, because of a PDF/A should be a PDF 1.4, this method             * returns an error if the array has more than one element.             */        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": CIDFont is missing from the DescendantFonts array or the size of array is greater than 1"));        return;    }    COSDictionary cidFont = (COSDictionary) array.getObject(0);    if (cidFont == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": The DescendantFonts array should have one element with is a dictionary."));        return;    }    FontValidator<? extends FontContainer<? extends PDCIDFont>> cidFontValidator = createDescendantValidator(cidFont);    if (cidFontValidator != null) {        this.fontContainer.setDelegateFontContainer(cidFontValidator.getFontContainer());        cidFontValidator.validate();    }}
protected FontValidator<? extends FontContainer<? extends PDCIDFont>> pdfbox_f8740_0(COSDictionary cidFont)
{    COSName subtype = cidFont.getCOSName(COSName.SUBTYPE);    FontValidator<? extends FontContainer<? extends PDCIDFont>> cidFontValidator = null;    if (COSName.CID_FONT_TYPE0.equals(subtype)) {        cidFontValidator = createCIDType0FontValidator(cidFont);    } else if (COSName.CID_FONT_TYPE2.equals(subtype)) {        cidFontValidator = createCIDType2FontValidator(cidFont);    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Type and/or Subtype keys are missing"));    }    return cidFontValidator;}
protected FontValidator<? extends FontContainer<PDCIDFontType0>> pdfbox_f8741_0(COSDictionary fDict)
{    try {        return new CIDType0FontValidator(context, new PDCIDFontType0(fDict, (PDType0Font) font));    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The CIDType0 font is damaged", e));        return null;    }}
protected FontValidator<? extends FontContainer<PDCIDFontType2>> pdfbox_f8742_0(COSDictionary fDict)
{    try {        return new CIDType2FontValidator(context, new PDCIDFontType2(fDict, (PDType0Font) font));    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_DAMAGED, font.getName() + ": The CIDType2 font is damaged", e));        return null;    }}
protected void pdfbox_f8743_0()
{    COSBase encoding = (font.getCOSObject()).getDictionaryObject(COSName.ENCODING);    checkCMapEncoding(encoding);}
protected void pdfbox_f8744_0(COSBase encoding)
{    if (encoding instanceof COSName || encoding instanceof COSString) {                String str = encoding instanceof COSName ? ((COSName) encoding).getName() : ((COSString) encoding).getString();        if (!(FONT_DICTIONARY_VALUE_CMAP_IDENTITY_V.equals(str) || FONT_DICTIONARY_VALUE_CMAP_IDENTITY_H.equals(str))) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_INVALID, font.getName() + ": The CMap is a string but it isn't an Identity-H/V"));        }    } else if (encoding instanceof COSStream) {        /*             * If the CMap is a stream, some fields are mandatory and the CIDSytemInfo must be compared with the             * CIDSystemInfo entry of the CIDFont.             */        processCMapAsStream((COSStream) encoding);    } else {                this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": The CMap type is invalid"));    }}
private void pdfbox_f8745_0(COSStream aCMap)
{    checkCIDSystemInfo(aCMap.getCOSDictionary(COSName.CIDSYSTEMINFO));    try (InputStream cmapStream = aCMap.createInputStream()) {                CMap fontboxCMap = new CMapParser().parse(cmapStream);        int wmValue = fontboxCMap.getWMode();        String cmnValue = fontboxCMap.getName();        /*             * According to the getInt javadoc, -1 is returned if there is no result. In the PDF Reference v1.7 p449,             * we can read that the default value is 0.             */        int wmode = aCMap.getInt(COSName.getPDFName(FONT_DICTIONARY_KEY_CMAP_WMODE), FONT_DICTIONARY_DEFAULT_CMAP_WMODE);        COSName type = aCMap.getCOSName(COSName.TYPE);        String cmapName = aCMap.getNameAsString(COSName.CMAPNAME);        if (cmapName == null || "".equals(cmapName) || wmode > 1) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": Some elements in the CMap dictionary are missing or invalid"));        } else if (!(wmValue == wmode && cmapName.equals(cmnValue))) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": CMapName or WMode is inconsistent"));        } else if (!COSName.CMAP.equals(type)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_CMAP_INVALID_OR_MISSING, font.getName() + ": The CMap type is invalid"));        }    } catch (IOException e) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CID_CMAP_DAMAGED, font.getName() + ": The CMap type is damaged", e));    }    COSDictionary cmapUsed = (COSDictionary) aCMap.getDictionaryObject(COSName.getPDFName(FONT_DICTIONARY_KEY_CMAP_USECMAP));    if (cmapUsed != null) {        checkCMapEncoding(cmapUsed);    }    compareCIDSystemInfo(aCMap);}
protected boolean pdfbox_f8746_0(COSDictionary cidSysInfo)
{    boolean result = true;    if (cidSysInfo != null) {        String reg = cidSysInfo.getString(COSName.REGISTRY);        String ord = cidSysInfo.getString(COSName.ORDERING);        COSBase sup = cidSysInfo.getDictionaryObject(COSName.SUPPLEMENT);        if (!(reg != null && ord != null && sup instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));            result = false;        }    } else {        this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO));        result = false;    }    return result;}
private void pdfbox_f8747_0(COSDictionary cmap)
{    COSDictionary fontDictionary = font.getCOSObject();    COSArray array = fontDictionary.getCOSArray(COSName.DESCENDANT_FONTS);    if (array != null && array.size() > 0) {        COSDictionary cidFont = (COSDictionary) array.getObject(0);        COSDictionary cmsi = cmap.getCOSDictionary(COSName.CIDSYSTEMINFO);        COSDictionary cfsi = cidFont.getCOSDictionary(COSName.CIDSYSTEMINFO);        String regCM = cmsi.getString(COSName.REGISTRY);        String ordCM = cmsi.getString(COSName.ORDERING);        String regCF = cfsi.getString(COSName.REGISTRY);        String ordCF = cfsi.getString(COSName.ORDERING);        if (!regCF.equals(regCM) || !ordCF.equals(ordCM)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_CIDKEYED_SYSINFO, font.getName() + ": The CIDSystemInfo is inconsistent"));        }    }}
protected void pdfbox_f8748_0()
{    this.descriptorHelper = new Type1DescriptorHelper(context, (PDSimpleFont) font, fontContainer);}
protected void pdfbox_f8749_0()
{    COSBase encoding = fontDictionary.getDictionaryObject(COSName.ENCODING);    if (encoding != null) {        if (encoding instanceof COSName) {            String encodingName = ((COSName) encoding).getName();            if (!(encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_MAC) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_MAC_EXP) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_WIN) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_PDFDOC) || encodingName.equals(FONT_DICTIONARY_VALUE_ENCODING_STD))) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING));            }        } else if (!(encoding instanceof COSDictionary)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_ENCODING));        }    }}
public void pdfbox_f8750_0() throws ValidationException
{    checkMandatoryField();    checkFontBBox();    checkFontMatrix();    checkEncoding();    checkResources();    checkCharProcsAndMetrics();    checkToUnicode();}
protected void pdfbox_f8751_0()
{    boolean areFieldsPResent = fontDictionary.containsKey(COSName.FONT_BBOX);    areFieldsPResent &= fontDictionary.containsKey(COSName.FONT_MATRIX);    areFieldsPResent &= fontDictionary.containsKey(COSName.CHAR_PROCS);    areFieldsPResent &= fontDictionary.containsKey(COSName.ENCODING);    areFieldsPResent &= fontDictionary.containsKey(COSName.FIRST_CHAR);    areFieldsPResent &= fontDictionary.containsKey(COSName.LAST_CHAR);    areFieldsPResent &= fontDictionary.containsKey(COSName.WIDTHS);    if (!areFieldsPResent) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": Some required fields are missing from the Font dictionary."));    }}
private void pdfbox_f8752_0()
{    COSBase fontBBox = fontDictionary.getDictionaryObject(COSName.FONT_BBOX);    if (!(fontBBox instanceof COSArray)) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontBBox element isn't an array"));        return;    }    /*         * check the content of the FontBBox. Should be an array with 4 numbers         */    COSArray bbox = (COSArray) fontBBox;    if (bbox.size() != 4) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontBBox element is invalid"));        return;    }    for (int i = 0; i < 4; i++) {        COSBase elt = bbox.get(i);        if (!(elt instanceof COSFloat || elt instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": An element of FontBBox isn't a number"));            return;        }    }}
private void pdfbox_f8753_0()
{    COSBase fontMatrix = fontDictionary.getDictionaryObject(COSName.FONT_MATRIX);    if (!(fontMatrix instanceof COSArray)) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontMatrix element isn't an array"));        return;    }    /*         * Check the content of the FontMatrix. Should be an array with 6 numbers         */    COSArray matrix = (COSArray) fontMatrix;    if (matrix.size() != 6) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The FontMatrix element is invalid"));        return;    }    for (int i = 0; i < 6; i++) {        COSBase elt = matrix.get(i);        if (!(elt instanceof COSFloat || elt instanceof COSInteger)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": An element of FontMatrix isn't a number"));            return;        }    }}
protected void pdfbox_f8754_0()
{    COSBase fontEncoding = fontDictionary.getDictionaryObject(COSName.ENCODING);    if (fontEncoding instanceof COSName) {        checkEncodingAsString(((COSName) fontEncoding).getName());    } else if (fontEncoding instanceof COSDictionary) {        checkEncodingAsDictionary((COSDictionary) fontDictionary);    } else {                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The Encoding entry doesn't have the right type"));    }}
private void pdfbox_f8755_0(String enc)
{        Encoding encodingInstance = Encoding.getInstance(COSName.getPDFName(enc));    if (encodingInstance == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "The encoding '" + enc + "' doesn't exist"));    }}
private void pdfbox_f8756_0(COSDictionary encodingDictionary)
{    if (encodingDictionary.containsKey(COSName.BASE_ENCODING)) {        checkEncodingAsString(encodingDictionary.getString(COSName.BASE_ENCODING));    }    COSBase diff = encodingDictionary.getDictionaryObject(COSName.DIFFERENCES);    if (diff != null) {        if (!(diff instanceof COSArray)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "The differences element of the encoding dictionary isn't an array"));            return;        }                                COSArray diffArray = (COSArray) diff;        for (int i = 0; i < diffArray.size(); ++i) {            COSBase item = diffArray.get(i);            if (!(item instanceof COSInteger || item instanceof COSName)) {                                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, "Differences Array should contain COSInt or COSName, no other type"));                return;            }        }    }}
private void pdfbox_f8757_0() throws ValidationException
{    List<Float> widths = getWidths(font);    if (widths == null || widths.isEmpty()) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The Witdhs array is unreachable"));        return;    }    COSDictionary charProcs = fontDictionary.getCOSDictionary(COSName.CHAR_PROCS);    if (charProcs == null) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The CharProcs element isn't a dictionary"));        return;    }    int fc = font.getCOSObject().getInt(COSName.FIRST_CHAR, -1);    int lc = font.getCOSObject().getInt(COSName.LAST_CHAR, -1);    /*         * wArr length = (lc - fc) + 1 and it is an array of int.          * If FirstChar is greater than LastChar, the validation         * will fail because of the array will have an expected size &lt;= 0.         */    int expectedLength = (lc - fc) + 1;    if (widths.size() != expectedLength) {        this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The length of Witdhs array is invalid. Expected : \"" + expectedLength + "\" Current : \"" + widths.size() + "\""));        return;    }        for (int i = 0; i < expectedLength; i++) {        int code = fc + i;        float width = widths.get(i);        PDType3CharProc charProc = getCharProc(code);        if (charProc != null) {            try {                float fontProgramWidth = getWidthFromCharProc(charProc);                if (Math.abs(width - fontProgramWidth) < 0.001f) {                                                                                                                        this.fontContainer.markAsValid(code);                } else {                    GlyphException glyphEx = new GlyphException(ERROR_FONTS_METRICS, code, font.getName() + ": The character with CID " + code + " should have a width equals to " + width + ", but has " + fontProgramWidth);                    this.fontContainer.markAsInvalid(code, glyphEx);                }            } catch (ContentStreamException e) {                                                this.context.addValidationError(new ValidationError(e.getErrorCode(), e.getMessage(), e));                return;            } catch (IOException e) {                this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The CharProcs references an element which can't be read", e));                return;            }        }    }}
public List<Float> pdfbox_f8758_0(PDFont font)
{    List<Float> widths;    COSArray array = (COSArray) font.getCOSObject().getDictionaryObject(COSName.WIDTHS);    if (array != null) {        widths = COSArrayList.convertFloatCOSArrayToList(array);    } else {        widths = Collections.emptyList();    }    return widths;}
private PDType3CharProc pdfbox_f8759_0(int code) throws ValidationException
{    PDType3CharProc charProc = font.getCharProc(code);    if (charProc == null) {                        GlyphException glyphEx = new GlyphException(ERROR_FONTS_METRICS, code, font.getName() + ": The CharProcs \"" + font.getEncoding().getName(code) + "\" doesn't exist");        this.fontContainer.markAsInvalid(code, glyphEx);    }    return charProc;}
private float pdfbox_f8760_0(PDType3CharProc charProc) throws IOException
{    PreflightPath vPath = context.getValidationPath();    PreflightType3Stream parser = new PreflightType3Stream(context, vPath.getClosestPathElement(PDPage.class), charProc);    parser.showType3Character(charProc);    return parser.getWidth();}
private void pdfbox_f8761_0() throws ValidationException
{    COSBase resources = this.fontDictionary.getDictionaryObject(COSName.RESOURCES);    if (resources != null) {        if (!(resources instanceof COSDictionary)) {            this.fontContainer.push(new ValidationError(ERROR_FONTS_DICTIONARY_INVALID, font.getName() + ": The Resources element isn't a dictionary"));            return;        }        COSDictionary dictionary = (COSDictionary) resources;                ContextHelper.validateElement(context, new PDResources(dictionary), RESOURCES_PROCESS);        COSDictionary dicFonts = dictionary.getCOSDictionary(COSName.FONT);        if (dicFonts != null) {            /*                 * Check that all referenced object are present in the PDF file                 */            Set<COSName> keyList = dicFonts.keySet();            for (COSName key : keyList) {                COSDictionary xObjFont = dicFonts.getCOSDictionary(key);                try {                    PDFont aFont = PDFontFactory.createFont(xObjFont);                    FontContainer<?> aContainer = this.context.getFontContainer(aFont.getCOSObject());                                        if (!aContainer.isValid()) {                        this.fontContainer.push(new ValidationError(ERROR_FONTS_TYPE3_DAMAGED, font.getName() + ": The Resources dictionary of type 3 font contains invalid font"));                    }                } catch (IOException e) {                    context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_DAMAGED, font.getName() + ": Unable to valid the Type3 : " + e.getMessage(), e));                }            }        }    }}
public List<ValidationError> pdfbox_f8762_0(XMPMetadata metadata, PDFontDescriptor fontDesc) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    analyseFontName(metadata, fontDesc, ve);    analyseRights(metadata, fontDesc, ve);    return ve;}
public boolean pdfbox_f8763_0(XMPMetadata metadata, PDFontDescriptor fontDesc, List<ValidationError> ve)
{    String fontName = fontDesc.getFontName();    String noSubSetName = fontName;    if (FontDescriptorHelper.isSubSet(fontName)) {        noSubSetName = fontName.split("\\+")[1];    }    DublinCoreSchema dc = metadata.getDublinCoreSchema();    if (dc != null && dc.getTitleProperty() != null) {        String defaultTitle = dc.getTitle("x-default");        if (defaultTitle != null) {            if (!defaultTitle.equals(fontName) && (noSubSetName != null && !defaultTitle.equals(noSubSetName))) {                StringBuilder sb = new StringBuilder(80);                sb.append("FontName").append(" present in the FontDescriptor dictionary doesn't match with XMP information dc:title of the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString()));                return false;            }                        return true;        } else {            Iterator<AbstractField> it = dc.getTitleProperty().getContainer().getAllProperties().iterator();            boolean empty = true;            while (it.hasNext()) {                empty = false;                AbstractField tmp = it.next();                if (tmp instanceof TextType) {                    String val = ((TextType) tmp).getStringValue();                    if (val.equals(fontName) || val.equals(noSubSetName)) {                                                return true;                    }                }            }                        StringBuilder sb = new StringBuilder(80);            sb.append("FontName");            if (empty) {                sb.append(" present in the FontDescriptor dictionary can't be found in XMP information the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, sb.toString()));            } else {                sb.append(" present in the FontDescriptor dictionary doesn't match with XMP information dc:title of the Font File Stream.");                ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString()));            }            return false;        }    }    return true;}
public boolean pdfbox_f8764_0(XMPMetadata metadata, PDFontDescriptor fontDesc, List<ValidationError> ve)
{    DublinCoreSchema dc = metadata.getDublinCoreSchema();    if (dc != null) {        ArrayProperty copyrights = dc.getRightsProperty();        if (copyrights == null || copyrights.getContainer() == null || copyrights.getContainer().getAllProperties().isEmpty()) {            ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, "CopyRights is missing from the XMP information (dc:rights) of the Font File Stream."));            return false;        }    }    XMPRightsManagementSchema rights = metadata.getXMPRightsManagementSchema();    if (rights != null) {        BooleanType marked = rights.getMarkedProperty();        if (marked != null && !marked.getValue()) {            ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, "the XMP information (xmpRights:Marked) is invalid for the Font File Stream."));            return false;        }    /*             * rights.getUsageTerms() & rights.getOwnerValue() should be present but it is only a recommendation : may             * be it should be useful to append a Warning if these entries are missing.             */    }    return true;}
public void pdfbox_f8765_0() throws GlyphException
{    if (this.exception != null) {        throw this.exception;    }}
public int pdfbox_f8766_0()
{    return this.code;}
public String pdfbox_f8767_0()
{    return errorCode;}
public int pdfbox_f8768_0()
{    return invalidCid;}
public void pdfbox_f8769_0(PDType3CharProc charProc) throws IOException
{        processChildStream(charProc, new PDPage());}
public Image pdfbox_f8770_0() throws IOException
{    showType3Character(charProc);    return image.getImage();}
protected void pdfbox_f8771_0(Operator operator, List<COSBase> operands) throws IOException
{    super.processOperator(operator, operands);    String operation = operator.getName();    if (operation.equals(OperatorName.BEGIN_INLINE_IMAGE)) {        image = new PDInlineImage(operator.getImageParameters(), operator.getImageData(), getResources());        validateInlineImageFilter(operator);        validateInlineImageColorSpace(operator);    }    if (operation.equals(OperatorName.TYPE3_D0)) {        checkType3FirstOperator(operands);    } else if (operation.equals(OperatorName.TYPE3_D1)) {        COSNumber llx = (COSNumber) operands.get(2);        COSNumber lly = (COSNumber) operands.get(3);        COSNumber urx = (COSNumber) operands.get(4);        COSNumber ury = (COSNumber) operands.get(5);        box = new BoundingBox();        box.setLowerLeftX(llx.floatValue());        box.setLowerLeftY(lly.floatValue());        box.setUpperRightX(urx.floatValue());        box.setUpperRightY(ury.floatValue());        checkType3FirstOperator(operands);    }    checkColorOperators(operation);    validateRenderingIntent(operator, operands);    checkSetColorSpaceOperators(operator, operands);    validateNumberOfGraphicStates(operator);    firstOperator = false;}
private void pdfbox_f8772_0(List<COSBase> arguments) throws IOException
{    if (!firstOperator) {        throw new IOException("Type3 CharProc : First operator must be d0 or d1");    }    COSBase obj = arguments.get(0);    if (obj instanceof COSNumber) {        width = ((COSNumber) obj).floatValue();    } else {        throw new IOException("Unexpected argument type. Expected : COSInteger or Number / Received : " + obj.getClass().getName());    }}
public float pdfbox_f8773_0()
{    return this.width;}
public String pdfbox_f8774_0()
{    return fname;}
public ColorSpaceHelper pdfbox_f8775_0(PreflightContext context, PDColorSpace cs, ColorSpaceRestriction csr)
{    switch(csr) {        case NO_PATTERN:            return new NoPatternColorSpaceHelper(context, cs);        case ONLY_DEVICE:            return new DeviceColorSpaceHelper(context, cs);        default:            return new StandardColorSpaceHelper(context, cs);    }}
public String pdfbox_f8776_0()
{    return label;}
public void pdfbox_f8777_0(String label)
{    this.label = label;}
protected void pdfbox_f8778_0(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, "Pattern ColorSpace is forbidden"));}
protected void pdfbox_f8779_0(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, "DeviceN ColorSpace is forbidden"));}
protected void pdfbox_f8780_0(PDColorSpace colorSpace)
{    PDIndexed indexed = (PDIndexed) colorSpace;    PDColorSpace baseColorSpace = indexed.getBaseColorSpace();    ColorSpaces colorSpaces = ColorSpaces.valueOf(baseColorSpace.getName());    switch(colorSpaces) {        case Indexed:        case I:        case Pattern:            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_FORBIDDEN, colorSpaces.getLabel() + " ColorSpace is forbidden"));            break;        default:            processAllColorSpace(baseColorSpace);    }}
public int pdfbox_f8781_0()
{    return colorSpace.getType();}
public ICC_Profile pdfbox_f8782_0()
{    return profile;}
public boolean pdfbox_f8783_0()
{    return ICC_ColorSpace.TYPE_RGB == colorSpace.getType();}
public boolean pdfbox_f8784_0()
{    return ICC_ColorSpace.TYPE_CMYK == colorSpace.getType();}
public boolean pdfbox_f8785_0()
{    return ICC_ColorSpace.TYPE_GRAY == colorSpace.getType();}
private static ICCProfileWrapper pdfbox_f8786_0(PreflightContext context)
{    PreflightDocument document = context.getDocument();    PDDocumentCatalog catalog = document.getDocumentCatalog();    COSArray outputIntents = catalog.getCOSObject().getCOSArray(COSName.OUTPUT_INTENTS);    for (int i = 0; outputIntents != null && i < outputIntents.size(); ++i) {        COSDictionary outputIntentDict = (COSDictionary) outputIntents.getObject(i);        COSBase destOutputProfile = outputIntentDict.getDictionaryObject(COSName.DEST_OUTPUT_PROFILE);        if (destOutputProfile instanceof COSStream) {            try (InputStream is = ((COSStream) destOutputProfile).createInputStream()) {                return new ICCProfileWrapper(ICC_Profile.getInstance(is));            } catch (IllegalArgumentException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "DestOutputProfile isn't a valid ICCProfile. Caused by : " + e.getMessage(), e));            } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "Unable to parse the ICCProfile. Caused by : " + e.getMessage(), e));            }        }    }    return null;}
public static ICCProfileWrapper pdfbox_f8787_0(PreflightContext context) throws ValidationException
{    ICCProfileWrapper profileWrapper = context.getIccProfileWrapper();    if (profileWrapper == null && !context.isIccProfileAlreadySearched()) {        profileWrapper = searchFirstICCProfile(context);        context.setIccProfileAlreadySearched(true);    }    return profileWrapper;}
protected void pdfbox_f8788_0(PDColorSpace colorSpace)
{    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_COLOR_SPACE_FORBIDDEN, "Pattern color space is forbidden"));}
public final void pdfbox_f8789_0() throws ValidationException
{    if (pdcs == null) {        throw new ValidationException("Unable to create a PDColorSpace with the value null");    }    this.iccpw = ICCProfileWrapper.getOrSearchICCProfile(context);    processAllColorSpace(pdcs);}
protected final void pdfbox_f8790_0(PDColorSpace colorSpace)
{    ColorSpaces cs = ColorSpaces.valueOf(colorSpace.getName());    switch(cs) {        case DeviceRGB:        case RGB:            processRGBColorSpace(colorSpace);            break;        case DeviceCMYK:        case CMYK:            processCYMKColorSpace(colorSpace);            break;        case CalRGB:        case CalGray:        case Lab:            processCalibratedColorSpace(colorSpace);            break;        case DeviceGray:        case G:            processGrayColorSpace(colorSpace);            break;        case ICCBased:            processICCBasedColorSpace(colorSpace);            break;        case DeviceN:            processDeviceNColorSpace(colorSpace);            break;        case Indexed:        case I:            processIndexedColorSpace(colorSpace);            break;        case Separation:            processSeparationColorSpace(colorSpace);            break;        case Pattern:            processPatternColorSpace(colorSpace);            break;        default:            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE, cs.getLabel() + " is unknown as ColorSpace"));    }}
protected void pdfbox_f8791_0(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace)) {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));        } else if (!iccpw.isRGBColorSpace()) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_RGB, "DestOutputProfile isn't RGB ColorSpace"));        }    }}
protected void pdfbox_f8792_0(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace)) {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));        } else if (!iccpw.isCMYKColorSpace()) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_CMYK, "DestOutputProfile isn't CMYK ColorSpace"));        }    }}
protected void pdfbox_f8793_0(PDColorSpace colorSpace)
{    if (iccpw == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));    }}
protected void pdfbox_f8794_0(PDColorSpace colorSpace)
{    if (!processDefaultColorSpace(colorSpace) && iccpw == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));    }}
protected void pdfbox_f8795_0(PDColorSpace colorSpace)
{}
protected void pdfbox_f8796_0(PDColorSpace colorSpace)
{    PDICCBased iccBased = (PDICCBased) colorSpace;    try {        ICC_Profile iccp;        try (InputStream is = iccBased.getPDStream().createInputStream()) {                                    iccp = ICC_Profile.getInstance(is);        }        PDColorSpace altpdcs = iccBased.getAlternateColorSpace();        if (altpdcs != null) {            ColorSpaces altCsId = ColorSpaces.valueOf(altpdcs.getName());            if (altCsId == ColorSpaces.Pattern) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_COLOR_SPACE_FORBIDDEN, "Pattern is forbidden as AlternateColorSpace of a ICCBased"));            }                        if (!validateICCProfileNEntry(iccBased.getPDStream().getCOSObject(), iccp)) {                return;            }            if (!validateICCProfileVersion(iccp)) {                return;            }            validateICCProfileAlternateEntry(iccBased);        }    } catch (IllegalArgumentException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_ICCBASED, "ICCBased color space is invalid: " + e.getMessage(), e));    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read ICCBase color space: " + e.getMessage(), e));    }}
protected void pdfbox_f8797_0(PDColorSpace colorSpace)
{    PDDeviceN deviceN = (PDDeviceN) colorSpace;    try {        if (iccpw == null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_MISSING, "DestOutputProfile is missing"));            return;        }        COSBase cosAlt = ((COSArray) colorSpace.getCOSObject()).getObject(2);        PDColorSpace altColor = PDColorSpace.create(cosAlt);        if (altColor != null) {            processAllColorSpace(altColor);        }        int numberOfColorants = 0;        PDDeviceNAttributes attr = deviceN.getAttributes();        if (attr != null) {            final Map<String, PDSeparation> colorants = attr.getColorants();            numberOfColorants = colorants.size();            for (PDSeparation col : colorants.values()) {                if (col != null) {                    processAllColorSpace(col);                }            }            PDDeviceNProcess process = attr.getProcess();            if (process != null) {                processAllColorSpace(process.getColorSpace());            }        }        int numberOfComponents = deviceN.getNumberOfComponents();        if (numberOfColorants > MAX_DEVICE_N_LIMIT || numberOfComponents > MAX_DEVICE_N_LIMIT) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_TOO_MANY_COMPONENTS_DEVICEN, "DeviceN has too many tint components or colorants"));        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read DeviceN color space : " + e.getMessage(), e));    }}
protected void pdfbox_f8798_0(PDColorSpace colorSpace)
{    PDIndexed indexed = (PDIndexed) colorSpace;    PDColorSpace based = indexed.getBaseColorSpace();    ColorSpaces cs = ColorSpaces.valueOf(based.getName());    if (cs == ColorSpaces.Indexed || cs == ColorSpaces.I) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_INDEXED, "Indexed color space can't be used as Base color space"));        return;    }    if (cs == ColorSpaces.Pattern) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_INDEXED, "Pattern color space can't be used as Base color space"));        return;    }    processAllColorSpace(based);}
protected void pdfbox_f8799_0(PDColorSpace colorSpace)
{    try {        COSBase cosAlt = ((COSArray) colorSpace.getCOSObject()).getObject(2);        PDColorSpace altCol = PDColorSpace.create(cosAlt);        if (altCol != null) {            ColorSpaces acs = ColorSpaces.valueOf(altCol.getName());            switch(acs) {                case Separation:                case DeviceN:                case Pattern:                case Indexed:                case I:                    context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE_ALTERNATE, acs.getLabel() + " color space can't be used as alternate color space"));                    break;                default:                    processAllColorSpace(altCol);            }        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read Separation color space : " + e.getMessage(), e));    }}
protected boolean pdfbox_f8800_0(PDColorSpace colorSpace)
{    boolean result = false;        PreflightPath vPath = context.getValidationPath();    PDResources resources = vPath.getClosestPathElement(PDResources.class);    if (resources != null) {        PDColorSpace defaultCS = null;        try {            if (colorSpace.getName().equals(ColorSpaces.DeviceCMYK.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_CMYK)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_CMYK);            } else if (colorSpace.getName().equals(ColorSpaces.DeviceRGB.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_RGB)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_RGB);            } else if (colorSpace.getName().equals(ColorSpaces.DeviceGray.getLabel()) && resources.hasColorSpace(COSName.DEFAULT_GRAY)) {                defaultCS = resources.getColorSpace(COSName.DEFAULT_GRAY);            }        } catch (IOException e) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_COLOR_SPACE, "Unable to read default color space : " + e.getMessage(), e));        }        if (defaultCS != null) {                        int nbOfErrors = context.getDocument().getResult().getErrorsList().size();            processAllColorSpace(defaultCS);            int newNbOfErrors = context.getDocument().getResult().getErrorsList().size();            result = (nbOfErrors == newNbOfErrors);        }    }    return result;}
private boolean pdfbox_f8801_0(ICC_Profile iccp)
{    PreflightConfiguration config = context.getConfig();        if (iccp.getMajorVersion() == 2) {        if (iccp.getMinorVersion() > 0x40) {                                                ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_TOO_RECENT, "Invalid version of the ICCProfile");            error.setWarning(config.isLazyValidation());            context.addValidationError(error);            return false;        }        } else if (iccp.getMajorVersion() > 2) {                                ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_TOO_RECENT, "Invalid version of the ICCProfile");        error.setWarning(config.isLazyValidation());        context.addValidationError(error);        return false;    }        return true;}
private boolean pdfbox_f8802_0(COSStream stream, ICC_Profile iccp) throws IOException
{    COSDictionary streamDict = (COSDictionary) stream.getCOSObject();    if (!streamDict.containsKey(COSName.N)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is mandatory"));        return false;    }    COSBase nValue = streamDict.getItem(COSName.N);    if (!(nValue instanceof COSNumber)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile must be a number, but is " + nValue));        return false;    }    int nNumberValue = ((COSNumber) nValue).intValue();    if (nNumberValue != 1 && nNumberValue != 3 && nNumberValue != 4) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile must be 1, 3 or 4, but is " + nNumberValue));        return false;    }    if (iccp.getNumComponents() != nNumberValue) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is " + nNumberValue + " but the ICC profile has " + iccp.getNumComponents() + " components"));        return false;    }    return true;}
private void pdfbox_f8803_0(PDICCBased iccBased) throws IOException
{    PDColorSpace altCS = iccBased.getAlternateColorSpace();    if (altCS != null && altCS.getNumberOfComponents() != iccBased.getNumberOfComponents()) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "/N entry of ICC profile is different (" + iccBased.getNumberOfComponents() + ") than alternate entry colorspace component count (" + altCS.getNumberOfComponents() + ")"));    }}
public List<ValidationError> pdfbox_f8804_0(XMPMetadata metadata) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    PDFAIdentificationSchema id = metadata.getPDFIdentificationSchema();    if (id == null) {        ve.add(new ValidationError(ERROR_METADATA_PDFA_ID_MISSING, "PDF/A identification schema " + PDFAIdentificationSchema.class.getAnnotation(StructuredType.class).namespace() + " is missing"));        return ve;    }        StructuredType stBasic = XMPBasicSchema.class.getAnnotation(StructuredType.class);    StructuredType stPdfaIdent = PDFAIdentificationSchema.class.getAnnotation(StructuredType.class);    if (!id.getPrefix().equals(stPdfaIdent.preferedPrefix())) {        if (metadata.getSchema(stPdfaIdent.preferedPrefix(), stBasic.namespace()) == null) {            ve.add(unexpectedPrefixFoundError(id.getPrefix(), stPdfaIdent.preferedPrefix(), PDFAIdentificationSchema.class.getName()));        } else {            id = (PDFAIdentificationSchema) metadata.getSchema(stPdfaIdent.preferedPrefix(), stPdfaIdent.namespace());        }    }    checkConformanceLevel(ve, id.getConformance());    checkPartNumber(ve, id.getPart() == null ? -1 : id.getPart());    return ve;}
protected ValidationError pdfbox_f8805_0(String prefFound, String prefExpected, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(schema).append(" found but prefix used is '").append(prefFound).append("', prefix '").append(prefExpected).append("' is expected.");    return new ValidationError(ERROR_METADATA_WRONG_NS_PREFIX, sb.toString());}
protected void pdfbox_f8806_0(List<ValidationError> ve, String value)
{    if (value == null || !(value.equals("A") || value.equals("B"))) {        ve.add(new ValidationError(ERROR_METADATA_INVALID_PDFA_CONFORMANCE));    }}
protected void pdfbox_f8807_0(List<ValidationError> ve, int value)
{    if (value != 1) {        ve.add(new ValidationError(ERROR_METADATA_INVALID_PDFA_VERSION_ID));    }}
public void pdfbox_f8808_0(XMPMetadata metadata) throws ValidationException, DifferentRDFAboutException
{    List<XMPSchema> schemas = metadata.getAllSchemas();    if (schemas.isEmpty()) {        throw new ValidationException("Schemas not found in the given metadata representation");    }    String about = schemas.get(0).getAboutValue();        for (XMPSchema xmpSchema : schemas) {                String schemaAboutValue = xmpSchema.getAboutValue();        if (!("".equals(schemaAboutValue) || "".equals(about) || about.equals(schemaAboutValue))) {            throw new DifferentRDFAboutException();        }        if ("".equals(about)) {            about = schemaAboutValue;        }    }}
protected void pdfbox_f8809_0(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String title = dico.getTitle();    if (title != null) {                title = removeTrailingNul(title);        if (dc != null) {                        if (dc.getTitle() != null) {                if (dc.getTitle("x-default") != null) {                    if (!dc.getTitle("x-default").equals(title)) {                        ve.add(unsynchronizedMetaDataError("Title"));                    }                } else {                                                                                                    Iterator<AbstractField> it = dc.getTitleProperty().getContainer().getAllProperties().iterator();                    if (it.hasNext()) {                        AbstractField tmp = it.next();                        if (tmp instanceof TextType) {                            if (!((TextType) tmp).getStringValue().equals(title)) {                                ve.add(unsynchronizedMetaDataError("Title"));                            }                        } else {                            ve.add(absentXMPPropertyError("Title", "Property is badly defined"));                        }                    } else {                        ve.add(absentXMPPropertyError("Title", "Property is not defined"));                    }                }            } else {                ve.add(absentXMPPropertyError("Title", "Property is not defined"));            }        } else {            ve.add(absentSchemaMetaDataError("Title", "Dublin Core"));        }    }}
protected void pdfbox_f8810_0(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String author = dico.getAuthor();    if (author != null) {                author = removeTrailingNul(author);        if (dc != null) {            if (dc.getCreatorsProperty() != null) {                if (dc.getCreators().size() != 1) {                    ve.add(absentXMPPropertyError("Author", "In XMP metadata, Author(s) must be represented by a single entry in a text array (dc:creator) "));                } else {                    if (dc.getCreators().get(0) == null) {                        ve.add(absentXMPPropertyError("Author", "Property is defined as null"));                    } else {                        if (!dc.getCreators().get(0).equals(author)) {                            ve.add(unsynchronizedMetaDataError("Author"));                        }                    }                }            } else {                ve.add(absentXMPPropertyError("Author", "Property is not defined in XMP Metadata"));            }        } else {            ve.add(absentSchemaMetaDataError("Author", "Dublin Core"));        }    }}
protected void pdfbox_f8811_0(PDDocumentInformation dico, DublinCoreSchema dc, List<ValidationError> ve)
{    String subject = dico.getSubject();    if (subject != null) {                subject = removeTrailingNul(subject);        if (dc != null) {                        if (dc.getDescriptionProperty() != null) {                if (dc.getDescription("x-default") == null) {                    ve.add(absentXMPPropertyError("Subject", "Subject not found in XMP (dc:description[\"x-default\"] not found)"));                } else {                    if (!dc.getDescription("x-default").equals(subject)) {                        ve.add(unsynchronizedMetaDataError("Subject"));                    }                }            } else {                ve.add(absentXMPPropertyError("Subject", "Property is defined as null"));            }        } else {            ve.add(absentSchemaMetaDataError("Subject", "Dublin Core"));        }    }}
protected void pdfbox_f8812_0(PDDocumentInformation dico, AdobePDFSchema pdf, List<ValidationError> ve)
{    String keyword = dico.getKeywords();    if (keyword != null) {                keyword = removeTrailingNul(keyword);        if (pdf != null) {            if (pdf.getKeywordsProperty() == null) {                ve.add(absentXMPPropertyError("Keywords", "Property is not defined"));            } else {                if (!pdf.getKeywords().equals(keyword)) {                    ve.add(unsynchronizedMetaDataError("Keywords"));                }            }        } else {            ve.add(absentSchemaMetaDataError("Keywords", "PDF"));        }    }}
protected void pdfbox_f8813_0(PDDocumentInformation dico, AdobePDFSchema pdf, List<ValidationError> ve)
{    String producer = dico.getProducer();    if (producer != null) {                producer = removeTrailingNul(producer);        if (pdf != null) {            if (pdf.getProducerProperty() == null) {                ve.add(absentXMPPropertyError("Producer", "Property is not defined"));            } else {                if (!pdf.getProducer().equals(producer)) {                    ve.add(unsynchronizedMetaDataError("Producer"));                }            }        } else {            ve.add(absentSchemaMetaDataError("Producer", "PDF"));        }    }}
protected void pdfbox_f8814_0(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve)
{    String creatorTool = dico.getCreator();    if (creatorTool != null) {                creatorTool = removeTrailingNul(creatorTool);        if (xmp != null) {            if (xmp.getCreatorToolProperty() == null) {                ve.add(absentXMPPropertyError("CreatorTool", "Property is not defined"));            } else {                if (!xmp.getCreatorTool().equals(creatorTool)) {                    ve.add(unsynchronizedMetaDataError("CreatorTool"));                }            }        } else {            ve.add(absentSchemaMetaDataError("CreatorTool", "PDF"));        }    }}
protected void pdfbox_f8815_0(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve) throws ValidationException
{    Calendar creationDate = dico.getCreationDate();    COSBase item = dico.getCOSObject().getItem(COSName.CREATION_DATE);    if (creationDate != null && isValidPDFDateFormat(item)) {        if (xmp != null) {            Calendar xmpCreationDate = xmp.getCreateDate();            if (xmpCreationDate == null) {                ve.add(absentXMPPropertyError("CreationDate", "Property is not defined"));            } else {                if (xmpCreationDate.compareTo(creationDate) != 0) {                    ve.add(unsynchronizedMetaDataError("CreationDate"));                } else if (hasTimeZone(xmp.getCreateDateProperty().getRawValue()) != hasTimeZone(dico.getPropertyStringValue("CreationDate"))) {                    ve.add(unsynchronizedMetaDataError("CreationDate"));                }            }        } else {            ve.add(absentSchemaMetaDataError("CreationDate", "Basic XMP"));        }    }}
protected void pdfbox_f8816_0(PDDocumentInformation dico, XMPBasicSchema xmp, List<ValidationError> ve) throws ValidationException
{    Calendar modifyDate = dico.getModificationDate();    COSBase item = dico.getCOSObject().getItem(COSName.MOD_DATE);    if (modifyDate != null && isValidPDFDateFormat(item)) {        if (xmp != null) {            Calendar xmpModifyDate = xmp.getModifyDate();            if (xmpModifyDate == null) {                ve.add(absentXMPPropertyError("ModifyDate", "Property is not defined"));            } else {                if (xmpModifyDate.compareTo(modifyDate) != 0) {                    ve.add(unsynchronizedMetaDataError("ModificationDate"));                } else if (hasTimeZone(xmp.getModifyDateProperty().getRawValue()) != hasTimeZone(dico.getPropertyStringValue("ModDate"))) {                    ve.add(unsynchronizedMetaDataError("ModificationDate"));                }            }        } else {            ve.add(absentSchemaMetaDataError("ModifyDate", "Basic XMP"));        }    }}
public List<ValidationError> pdfbox_f8817_0(PDDocument document, XMPMetadata metadata) throws ValidationException
{    List<ValidationError> ve = new ArrayList<>();    if (document == null) {        throw new ValidationException("Document provided is null");    } else {        PDDocumentInformation dico = document.getDocumentInformation();        if (metadata == null) {            throw new ValidationException("Metadata provided are null");        } else {            DublinCoreSchema dc = metadata.getDublinCoreSchema();                        analyzeTitleProperty(dico, dc, ve);                        analyzeAuthorProperty(dico, dc, ve);                        analyzeSubjectProperty(dico, dc, ve);            AdobePDFSchema pdf = metadata.getAdobePDFSchema();                        analyzeKeywordsProperty(dico, pdf, ve);                        analyzeProducerProperty(dico, pdf, ve);            XMPBasicSchema xmp = metadata.getXMPBasicSchema();                        analyzeCreatorToolProperty(dico, xmp, ve);                        analyzeCreationDateProperty(dico, xmp, ve);                        analyzeModifyDateProperty(dico, xmp, ve);        }    }    return ve;}
protected ValidationError pdfbox_f8818_0(String prefFound, String prefExpected, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(schema).append(" found but prefix used is '").append(prefFound).append("', prefix '").append(prefExpected).append("' is expected.");    return new ValidationError(PreflightConstants.ERROR_METADATA_WRONG_NS_PREFIX, sb.toString());}
protected ValidationException pdfbox_f8819_0(String target, Throwable cause)
{    StringBuilder sb = new StringBuilder(80);    sb.append("Cannot access to the ").append(target).append(" schema");    return new ValidationException(sb.toString(), cause);}
protected ValidationError pdfbox_f8820_0(String target)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary doesn't match with XMP information");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
protected ValidationError pdfbox_f8821_0(String target, String schema)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary can't be found in XMP information (").append(schema).append(" schema not declared)");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
protected ValidationError pdfbox_f8822_0(String target, String details)
{    StringBuilder sb = new StringBuilder(80);    sb.append(target).append(" present in the document catalog dictionary can't be found in XMP information (").append(details).append(")");    return new ValidationError(PreflightConstants.ERROR_METADATA_MISMATCH, sb.toString());}
private String pdfbox_f8823_0(String string)
{        int length = string.length();    while (length > 0 && string.charAt(length - 1) == 0) {        length--;    }    return string.substring(0, length);}
private boolean pdfbox_f8824_0(Object date)
{    final String datePattern = "^D:.*[Z]$|^D:.*[+-].*|^\\d{4}.*T.*Z(\\d{2}:\\d{2}){0,1}$|^\\d{4}.*T.*[+-]\\d{2}.*$";    if (date instanceof Calendar) {                return true;    } else if (date instanceof String) {        return Pattern.matches(datePattern, (String) date);    }    return false;}
private boolean pdfbox_f8825_0(COSBase item)
{    if (item instanceof COSString) {        String date = ((COSString) item).getString();        if (date.matches("D:\\d{4}(\\d{2}(\\d{2}(\\d{2}(\\d{2}(\\d{2}([\\+\\-Z](\\d{2}'\\d{2}')?)?)?)?)?)?)?")) {            return true;        }    }    return false;}
public ValidationError pdfbox_f8826_0()
{    return error;}
protected static ValidationResult pdfbox_f8827_0()
{    ValidationError error = new ValidationError(PreflightConstants.ERROR_UNKOWN_ERROR);    return new ValidationResult(error);}
protected void pdfbox_f8828_0(ValidationError error)
{    if (this.validationResult == null) {        this.validationResult = new ValidationResult(error.isWarning());    }    this.validationResult.addError(error);}
protected void pdfbox_f8829_0(List<ValidationError> errors)
{    errors.forEach(this::addValidationError);}
public void pdfbox_f8830_0() throws IOException
{    parse(Format.PDF_A1B);}
public void pdfbox_f8831_0(Format format) throws IOException
{    parse(format, null);}
public void pdfbox_f8832_0(Format format, PreflightConfiguration config) throws IOException
{    checkPdfHeader();    try {        super.parse();    } catch (IOException e) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_COMMON, e.getMessage()));        throw new SyntaxValidationException(e, this.validationResult);    } finally {                IOUtils.closeQuietly(source);    }    Format formatToUse = (format == null ? Format.PDF_A1B : format);    createPdfADocument(formatToUse, config);    createContext();}
protected void pdfbox_f8833_0(Format format, PreflightConfiguration config) throws IOException
{    COSDocument cosDocument = getDocument();    this.preflightDocument = new PreflightDocument(cosDocument, format, config);}
protected void pdfbox_f8834_0()
{    ctx = new PreflightContext();    ctx.setDocument(preflightDocument);    preflightDocument.setContext(ctx);    ctx.setXrefTrailerResolver(xrefTrailerResolver);    ctx.setFileLen(this.fileLen);}
public PDDocument pdfbox_f8835_0() throws IOException
{    preflightDocument.setResult(validationResult);        return preflightDocument;}
public PreflightDocument pdfbox_f8836_0() throws IOException
{    return (PreflightDocument) getPDDocument();}
protected void pdfbox_f8837_0() throws IOException
{    super.initialParse();            Map<COSObjectKey, Long> xrefTable = document.getXrefTable();    for (Entry<COSObjectKey, Long> entry : xrefTable.entrySet()) {        COSObject co = document.getObjectFromPool(entry.getKey());        if (co.getObject() == null) {                        parseObjectDynamically(co, true);        }    }}
protected void pdfbox_f8838_0()
{    try {        source.seek(0);        String firstLine = readLine();        if (firstLine == null || !firstLine.matches("%PDF-1\\.[1-9]")) {            addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "First line must match %PDF-1.\\d"));        }        String secondLine = readLine();        if (secondLine != null) {            byte[] secondLineAsBytes = secondLine.getBytes(encoding.name());            if (secondLineAsBytes.length >= 5) {                if (secondLineAsBytes[0] != '%') {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));                } else {                    for (int i = 1; i < 5; ++i) {                        byte b = secondLineAsBytes[i];                        if ((b & 0xFF) < 0x80) {                            addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));                            break;                        }                    }                }            } else {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Second line must begin with '%' followed by at least 4 bytes greater than 127"));            }        }        source.seek(0);    } catch (IOException e) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_HEADER, "Unable to read the PDF file : " + e.getMessage(), e));    }}
protected boolean pdfbox_f8839_0(long startByteOffset) throws IOException
{    if (source.peek() != 'x') {        return false;    }    String xref = readString();    if (!xref.equals("xref")) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "xref must be followed by a EOL character"));        return false;    }    if (!nextIsEOL()) {        addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "xref must be followed by EOL"));    }        xrefTrailerResolver.nextXrefObj(startByteOffset, XRefType.TABLE);        while (true) {                        long currObjID;                int count;        long offset = source.getPosition();        String line = readLine();        Pattern pattern = Pattern.compile("(\\d+)\\s(\\d+)(\\s*)");        Matcher matcher = pattern.matcher(line);        if (matcher.matches()) {            currObjID = Long.parseLong(matcher.group(1));            count = Integer.parseInt(matcher.group(2));        } else {            addValidationError(new ValidationError(ERROR_SYNTAX_CROSS_REF, "Cross reference subsection header is invalid: '" + line + "' at position " + source.getPosition()));                        source.seek(offset);                        currObjID = readObjectNumber();                        count = readInt();        }        skipSpaces();        for (int i = 0; i < count; i++) {            if (source.isEOF() || isEndOfName((char) source.peek())) {                break;            }            if (source.peek() == 't') {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "Expected xref line but 't' found"));                break;            }                        String currentLine = readLine();            String[] splitString = currentLine.split(" ");            if (splitString.length < 3) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "invalid xref line: " + currentLine));                break;            }                        if (splitString[splitString.length - 1].equals("n")) {                try {                    long currOffset = Long.parseLong(splitString[0]);                    int currGenID = Integer.parseInt(splitString[1]);                    COSObjectKey objKey = new COSObjectKey(currObjID, currGenID);                    xrefTrailerResolver.setXRef(objKey, currOffset);                } catch (NumberFormatException e) {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "offset or genid can't be read as number " + e.getMessage(), e));                }            } else if (!splitString[2].equals("f")) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_CROSS_REF, "Corrupt XRefTable Entry - ObjID:" + currObjID));            }            currObjID++;            skipSpaces();        }        skipSpaces();        if (!isDigit()) {            break;        }    }    return true;}
protected COSStream pdfbox_f8840_0(COSDictionary dic) throws IOException
{    long startOffset = checkStreamKeyWord();    COSStream result = super.parseCOSStream(dic);    checkEndstreamKeyWord(dic, startOffset);    return result;}
private long pdfbox_f8841_0() throws IOException
{    String streamV = readString();    if (!streamV.equals("stream")) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'stream' keyword but found '" + streamV + "' at offset " + source.getPosition()));    }    long startOffset = source.getPosition();    int nextChar = source.read();    if (nextChar == 13 && source.peek() == 10) {        startOffset += 2;    } else if (nextChar == 10) {        startOffset++;    } else {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'EOL' after the stream keyword at offset " + source.getPosition()));    }        source.seek(source.getPosition() - 7);    return startOffset;}
private void pdfbox_f8842_0(COSDictionary dic, long startOffset) throws IOException
{    source.seek(source.getPosition() - 10);    long endOffset = source.getPosition();    int nextChar = source.read();    boolean eolFound = false;    boolean crlfFound = false;        if (nextChar == '\n') {        eolFound = true;                source.rewind(2);        if (source.read() == '\r') {            endOffset--;            crlfFound = true;        }        source.read();    }    boolean addStreamLengthErrorMessage = false;    long actualLength = endOffset - startOffset;    if (!eolFound) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'EOL' before the endstream keyword at offset " + source.getPosition() + " but found '" + source.peek() + "'"));        addStreamLengthErrorMessage = true;    }    String endstreamV = readString();    if (!endstreamV.equals("endstream")) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_DELIMITER, "Expected 'endstream' keyword at offset " + source.getPosition() + " but found '" + endstreamV + "'"));        addStreamLengthErrorMessage = true;    }    int length = dic.getInt(COSName.LENGTH);    if (    addStreamLengthErrorMessage || (length > -1 && ((!crlfFound && length - actualLength != 0) || (crlfFound && length - actualLength > 1)))) {        addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_LENGTH_INVALID, "Stream length is invalid [dic=" + dic + "; defined length=" + length + "; actual length=" + actualLength + ", starting offset=" + startOffset));    }}
private boolean pdfbox_f8843_0() throws IOException
{    boolean succeed = false;    int nextChar = source.read();    if (ASCII_CR == nextChar && ASCII_LF == source.peek()) {        source.read();        succeed = true;    } else if (ASCII_CR == nextChar || ASCII_LF == nextChar) {        succeed = true;    }    return succeed;}
protected COSArray pdfbox_f8844_0() throws IOException
{    COSArray result = super.parseCOSArray();    if (result != null && result.size() > MAX_ARRAY_ELEMENTS) {        addValidationError(new ValidationError(ERROR_SYNTAX_ARRAY_TOO_LONG, "Array too long : " + result.size()));    }    return result;}
protected COSName pdfbox_f8845_0() throws IOException
{    COSName result = super.parseCOSName();    if (result != null && result.getName().getBytes().length > MAX_NAME_SIZE) {        addValidationError(new ValidationError(ERROR_SYNTAX_NAME_TOO_LONG, "Name too long: " + result.getName()));    }    return result;}
protected COSString pdfbox_f8846_0() throws IOException
{        long offset = source.getPosition();    char nextChar = (char) source.read();    int count = 0;    if (nextChar == '<') {        do {            nextChar = (char) source.read();            if (nextChar != '>') {                if (isWhitespace(nextChar)) {                                        continue;                }                if (Character.digit(nextChar, 16) >= 0) {                    count++;                } else {                    addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_INVALID, "Hexa String must have only Hexadecimal Characters (found '" + nextChar + "') at offset " + source.getPosition()));                    break;                }            }        } while (nextChar != '>');    }    if (count % 2 != 0) {        addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_EVEN_NUMBER, "Hexa string shall contain even number of non white space char at offset " + source.getPosition()));    }        source.seek(offset);    COSString result = super.parseCOSString();    if (result.getString().length() > MAX_STRING_LENGTH) {        addValidationError(new ValidationError(ERROR_SYNTAX_HEXA_STRING_TOO_LONG, "Hexa string is too long at offset " + source.getPosition()));    }    return result;}
protected COSBase pdfbox_f8847_0() throws IOException
{    COSBase result = super.parseDirObject();    if (result instanceof COSNumber) {        COSNumber number = (COSNumber) result;        if (number instanceof COSFloat) {            Double real = number.doubleValue();            if (real > MAX_POSITIVE_FLOAT || real < MAX_NEGATIVE_FLOAT) {                addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "Float is too long or too small: " + real + "  at offset " + source.getPosition()));            }        } else {            long numAsLong = number.longValue();            if (numAsLong > Integer.MAX_VALUE || numAsLong < Integer.MIN_VALUE) {                addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "Numeric is too long or too small: " + numAsLong + "  at offset " + source.getPosition()));            }        }    }    if (result instanceof COSDictionary) {        COSDictionary dic = (COSDictionary) result;        if (dic.size() > MAX_DICT_ENTRIES) {            addValidationError(new ValidationError(ERROR_SYNTAX_TOO_MANY_ENTRIES, "Too Many Entries In Dictionary at offset " + source.getPosition()));        }    }    return result;}
protected COSBase pdfbox_f8848_0(long objNr, int objGenNr, boolean requireExistingNotCompressedObj) throws IOException
{        final COSObjectKey objKey = new COSObjectKey(objNr, objGenNr);    final COSObject pdfObject = document.getObjectFromPool(objKey);    if (pdfObject.getObject() == null) {                        Long offsetOrObjstmObNr = document.getXrefTable().get(objKey);                if (requireExistingNotCompressedObj && ((offsetOrObjstmObNr == null))) {            addValidationError(new ValidationError(ERROR_SYNTAX_MISSING_OFFSET, "Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration()));            throw new SyntaxValidationException("Object must be defined and must not be compressed object: " + objKey.getNumber() + ":" + objKey.getGeneration(), validationResult);        }        if (offsetOrObjstmObNr == null) {                        pdfObject.setObject(COSNull.NULL);        } else if (offsetOrObjstmObNr == 0) {            addValidationError(new ValidationError(ERROR_SYNTAX_INVALID_OFFSET, "Object {" + objKey.getNumber() + ":" + objKey.getGeneration() + "} has an offset of 0"));        } else if (offsetOrObjstmObNr > 0) {                                    source.seek(offsetOrObjstmObNr);                        long readObjNr;            int readObjGen;            long offset = source.getPosition();            String line = readLine();            Pattern pattern = Pattern.compile("(\\d+)\\s(\\d+)\\sobj");            Matcher matcher = pattern.matcher(line);            if (matcher.matches()) {                readObjNr = Long.parseLong(matcher.group(1));                readObjGen = Integer.parseInt(matcher.group(2));            } else {                addValidationError(new ValidationError(ERROR_SYNTAX_OBJ_DELIMITER, "Single space expected [offset=" + offset + "; key=" + offsetOrObjstmObNr.toString() + "; line=" + line + "; object=" + pdfObject.toString() + "]"));                                source.seek(offset);                readObjNr = readObjectNumber();                readObjGen = readGenerationNumber();                                skipSpaces();                for (char c : OBJ_MARKER) {                    if (source.read() != c) {                        addValidationError(new ValidationError(ERROR_SYNTAX_OBJ_DELIMITER, "Expected pattern '" + new String(OBJ_MARKER) + " but missed at character '" + c + "'"));                        throw new SyntaxValidationException("Expected pattern '" + new String(OBJ_MARKER) + " but missed at character '" + c + "'", validationResult);                    }                }            }                        if ((readObjNr != objKey.getNumber()) || (readObjGen != objKey.getGeneration())) {                throw new IOException("XREF for " + objKey.getNumber() + ":" + objKey.getGeneration() + " points to wrong object: " + readObjNr + ":" + readObjGen);            }            skipSpaces();            COSBase pb = parseDirObject();            skipSpaces();            long endObjectOffset = source.getPosition();            String endObjectKey = readString();            if (endObjectKey.equals("stream")) {                source.seek(endObjectOffset);                if (pb instanceof COSDictionary) {                    COSStream stream = parseCOSStream((COSDictionary) pb);                    if (securityHandler != null) {                        securityHandler.decryptStream(stream, objNr, objGenNr);                    }                    pb = stream;                } else {                                        throw new IOException("Stream not preceded by dictionary (offset: " + offsetOrObjstmObNr + ").");                }                skipSpaces();                endObjectOffset = source.getPosition();                endObjectKey = readString();                                if (!endObjectKey.startsWith("endobj")) {                    if (endObjectKey.startsWith("endstream")) {                        endObjectKey = endObjectKey.substring(9).trim();                        if (endObjectKey.length() == 0) {                                                                                    endObjectKey = readString();                        }                    }                }            } else if (securityHandler != null) {                securityHandler.decrypt(pb, objNr, objGenNr);            }            pdfObject.setObject(pb);            if (!endObjectKey.startsWith("endobj")) {                throw new IOException("Object (" + readObjNr + ":" + readObjGen + ") at offset " + offsetOrObjstmObNr + " does not end with 'endobj'.");            } else {                offset = source.getPosition();                source.seek(endObjectOffset - 1);                if (!nextIsEOL()) {                    addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_OBJ_DELIMITER, "EOL expected before the 'endobj' keyword at offset " + source.getPosition()));                }                source.seek(offset);            }            if (!nextIsEOL()) {                addValidationError(new ValidationError(PreflightConstants.ERROR_SYNTAX_OBJ_DELIMITER, "EOL expected after the 'endobj' keyword at offset " + source.getPosition()));            }        } else {                                    final int objstmObjNr = (int) (-offsetOrObjstmObNr);            final COSBase objstmBaseObj = parseObjectDynamically(objstmObjNr, 0, true);            if (objstmBaseObj instanceof COSStream) {                                PDFObjectStreamParser parser = new PDFObjectStreamParser((COSStream) objstmBaseObj, document);                parser.parse();                                parser.getObjects().forEach(next -> {                    COSObjectKey stmObjKey = new COSObjectKey(next);                    Long offset = document.getXrefTable().get(stmObjKey);                    if (offset != null && offset == -objstmObjNr) {                        COSObject stmObj = document.getObjectFromPool(stmObjKey);                        stmObj.setObject(next.getObject());                    }                });            }        }    }    return pdfObject.getObject();}
protected int pdfbox_f8849_0(final char[] pattern, final byte[] buf, final int endOff)
{    int offset = super.lastIndexOf(pattern, buf, endOff);    if (offset > 0 && Arrays.equals(pattern, EOF_MARKER)) {                        int tmpOffset = offset + pattern.length;        if (tmpOffset != buf.length) {                        if ((buf.length - tmpOffset) > 2 || (buf.length - tmpOffset == 2 && (buf[tmpOffset] != 13 || buf[tmpOffset + 1] != 10)) || (buf.length - tmpOffset == 1 && (buf[tmpOffset] != 13 && buf[tmpOffset] != 10))) {                long position;                try {                    position = source.getPosition();                } catch (IOException excpetion) {                    position = Long.MIN_VALUE;                }                addValidationError(new ValidationError(ERROR_SYNTAX_TRAILER_EOF, "File contains data after the last %%EOF sequence at offset " + position));            }        }    }    return offset;}
public Element pdfbox_f8850_0(File file) throws IOException
{    return validate(new RandomAccessBufferedFileInputStream(file), file.getName());}
public Element pdfbox_f8851_0(Document rdocument, File file) throws IOException
{    return validate(rdocument, new RandomAccessBufferedFileInputStream(file), file.getName());}
private Element pdfbox_f8852_0(RandomAccessRead source, String name) throws IOException
{    try {        Document rdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();        return validate(rdocument, source, name);    } catch (ParserConfigurationException e) {        throw new IOException("Failed to init document builder", e);    }}
private Element pdfbox_f8853_0(Document rdocument, RandomAccessRead source, String name) throws IOException
{    String pdfType = null;    ValidationResult result;    long before = System.currentTimeMillis();    try {        PreflightParser parser = new PreflightParser(source);        try {            parser.parse();            try (PreflightDocument document = parser.getPreflightDocument()) {                document.validate();                pdfType = document.getSpecification().getFname();                result = document.getResult();            }        } catch (SyntaxValidationException e) {            result = e.getResult();        }    } catch (Exception e) {        long after = System.currentTimeMillis();        return generateFailureResponse(rdocument, name, after - before, pdfType, e);    }    long after = System.currentTimeMillis();    if (result.isValid()) {        Element preflight = generateResponseSkeleton(rdocument, name, after - before);                Element valid = rdocument.createElement("isValid");        valid.setAttribute("type", pdfType);        valid.setTextContent("true");        preflight.appendChild(valid);        return preflight;    } else {        Element preflight = generateResponseSkeleton(rdocument, name, after - before);                createResponseWithError(rdocument, pdfType, result, preflight);        return preflight;    }}
protected void pdfbox_f8854_0(Document rdocument, String pdfType, ValidationResult result, Element preflight)
{    Element valid = rdocument.createElement("isValid");    valid.setAttribute("type", pdfType);    valid.setTextContent("false");    preflight.appendChild(valid);        Element errors = rdocument.createElement("errors");    Map<ValidationError, Integer> cleaned = cleanErrorList(result.getErrorsList());    preflight.appendChild(errors);    int totalCount = 0;    for (Map.Entry<ValidationError, Integer> entry : cleaned.entrySet()) {        Element error = rdocument.createElement("error");        int count = entry.getValue();        error.setAttribute("count", String.format("%d", count));        totalCount += count;        Element code = rdocument.createElement("code");        ValidationError ve = entry.getKey();        code.setTextContent(ve.getErrorCode());        error.appendChild(code);        Element detail = rdocument.createElement("details");        detail.setTextContent(ve.getDetails());        error.appendChild(detail);        if (ve.getPageNumber() != null) {            Element page = rdocument.createElement("page");            page.setTextContent(ve.getPageNumber().toString());            error.appendChild(page);        }        errors.appendChild(error);    }    errors.setAttribute("count", String.format("%d", totalCount));}
private Map<ValidationError, Integer> pdfbox_f8855_0(List<ValidationError> errors)
{    Map<ValidationError, Integer> cleaned = new HashMap<>(errors.size());    for (ValidationError ve : errors) {        Integer found = cleaned.get(ve);        if (found != null) {            cleaned.put(ve, found + 1);        } else {            cleaned.put(ve, 1);        }    }    return cleaned;}
protected Element pdfbox_f8856_0(Document rdocument, String name, long duration, String pdfType, Exception e)
{    Element preflight = generateResponseSkeleton(rdocument, name, duration);        Element valid = rdocument.createElement("isValid");    valid.setAttribute("type", pdfType);    valid.setTextContent("false");    preflight.appendChild(valid);        Element exception = rdocument.createElement("exceptionThrown");    Element message = rdocument.createElement("message");    message.setTextContent(e.getMessage());    StringWriter sw = new StringWriter();    PrintWriter pw = new PrintWriter(sw);    e.printStackTrace(pw);    pw.close();    Element stack = rdocument.createElement("stackTrace");    stack.setTextContent(sw.toString());    exception.appendChild(message);    exception.appendChild(stack);    preflight.appendChild(exception);    return preflight;}
protected Element pdfbox_f8857_0(Document rdocument, String name, long duration)
{    Element preflight = rdocument.createElement("preflight");    preflight.setAttribute("name", name);        Element eduration = rdocument.createElement("executionTimeMS");    eduration.setTextContent(String.format("%d", duration));    preflight.appendChild(eduration);        return preflight;}
public static PreflightConfiguration pdfbox_f8858_0()
{    PreflightConfiguration configuration = new PreflightConfiguration();    configuration.replaceProcess(CATALOG_PROCESS, CatalogValidationProcess.class);    configuration.replaceProcess(FILE_SPECIF_PROCESS, FileSpecificationValidationProcess.class);    configuration.replaceProcess(TRAILER_PROCESS, TrailerValidationProcess.class);    configuration.replaceProcess(XREF_PROCESS, XRefValidationProcess.class);    configuration.replaceProcess(ACRO_FORM_PROCESS, AcroFormValidationProcess.class);    configuration.replaceProcess(BOOKMARK_PROCESS, BookmarkValidationProcess.class);    configuration.replaceProcess(PAGES_TREE_PROCESS, PageTreeValidationProcess.class);    configuration.replaceProcess(META_DATA_PROCESS, MetadataValidationProcess.class);    configuration.replaceProcess(STREAM_PROCESS, StreamValidationProcess.class);    configuration.replacePageProcess(PAGE_PROCESS, SinglePageValidationProcess.class);    configuration.replacePageProcess(EXTGSTATE_PROCESS, ExtGStateValidationProcess.class);    configuration.replacePageProcess(SHADING_PATTERN_PROCESS, ShadingPatternValidationProcess.class);    configuration.replacePageProcess(GRAPHIC_PROCESS, GraphicObjectPageValidationProcess.class);    configuration.replacePageProcess(TILING_PATTERN_PROCESS, TilingPatternValidationProcess.class);    configuration.replacePageProcess(RESOURCES_PROCESS, ResourcesValidationProcess.class);    configuration.replacePageProcess(FONT_PROCESS, FontValidationProcess.class);    configuration.replacePageProcess(ACTIONS_PROCESS, ActionsValidationProcess.class);    configuration.replacePageProcess(ANNOTATIONS_PROCESS, AnnotationValidationProcess.class);    configuration.replacePageProcess(DESTINATION_PROCESS, DestinationValidationProcess.class);    configuration.actionFact = new ActionManagerFactory();    configuration.annotFact = new PDFAbAnnotationFactory();    configuration.colorSpaceHelperFact = new ColorSpaceHelperFactory();    return configuration;}
public Collection<String> pdfbox_f8859_0()
{    return this.processes.keySet();}
public ValidationProcess pdfbox_f8860_0(String processName) throws ValidationException
{    Class<? extends ValidationProcess> clazz = null;    if (processes.containsKey(processName)) {        clazz = processes.get(processName);    } else if (innerProcesses.containsKey(processName)) {        clazz = innerProcesses.get(processName);    } else if (errorOnMissingProcess) {        throw new MissingValidationProcessException(processName);    } else {        return new EmptyValidationProcess();    }    try {        return clazz.getDeclaredConstructor().newInstance();    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) {        throw new ValidationException(processName + " can't be created", e);    }}
public void pdfbox_f8861_0(String processName, Class<? extends ValidationProcess> process)
{    if (process == null) {        removeProcess(processName);    } else {        this.processes.put(processName, process);    }}
public void pdfbox_f8862_0(String processName)
{    this.processes.remove(processName);}
public Collection<String> pdfbox_f8863_0()
{    return this.innerProcesses.keySet();}
public void pdfbox_f8864_0(String processName, Class<? extends ValidationProcess> process)
{    if (process == null) {        removePageProcess(processName);    } else {        this.innerProcesses.put(processName, process);    }}
public void pdfbox_f8865_0(String processName)
{    this.innerProcesses.remove(processName);}
public boolean pdfbox_f8866_0()
{    return errorOnMissingProcess;}
public void pdfbox_f8867_0(boolean errorOnMissingProcess)
{    this.errorOnMissingProcess = errorOnMissingProcess;}
public boolean pdfbox_f8868_0()
{    return lazyValidation;}
public void pdfbox_f8869_0(boolean lazyValidation)
{    this.lazyValidation = lazyValidation;}
public AnnotationValidatorFactory pdfbox_f8870_0()
{    return annotFact;}
public void pdfbox_f8871_0(AnnotationValidatorFactory annotFact)
{    this.annotFact = annotFact;}
public ActionManagerFactory pdfbox_f8872_0()
{    return actionFact;}
public void pdfbox_f8873_0(ActionManagerFactory actionFact)
{    this.actionFact = actionFact;}
public ColorSpaceHelperFactory pdfbox_f8874_0()
{    return colorSpaceHelperFact;}
public void pdfbox_f8875_0(ColorSpaceHelperFactory colorSpaceHelperFact)
{    this.colorSpaceHelperFact = colorSpaceHelperFact;}
public int pdfbox_f8876_0()
{    return maxErrors;}
public void pdfbox_f8877_0(int maxErrors)
{    this.maxErrors = maxErrors;}
public XMPMetadata pdfbox_f8878_0()
{    return metadata;}
public void pdfbox_f8879_0(XMPMetadata metadata)
{    this.metadata = metadata;}
public PreflightDocument pdfbox_f8880_0()
{    return document;}
public XrefTrailerResolver pdfbox_f8881_0()
{    return xrefTrailerResolver;}
public void pdfbox_f8882_0(XrefTrailerResolver xrefTrailerResolver)
{    this.xrefTrailerResolver = xrefTrailerResolver;}
public void pdfbox_f8883_0(PreflightDocument document)
{    this.document = document;}
public void pdfbox_f8884_0(COSBase cBase, FontContainer<?> fc)
{    this.fontContainers.put(cBase, fc);}
public FontContainer<?> pdfbox_f8885_0(COSBase cBase)
{    return this.fontContainers.get(cBase);}
public ICCProfileWrapper pdfbox_f8886_0()
{    return iccProfileWrapper;}
public void pdfbox_f8887_0(ICCProfileWrapper iccProfileWrapper)
{    this.iccProfileWrapper = iccProfileWrapper;}
public PreflightConfiguration pdfbox_f8888_0()
{    return config;}
public void pdfbox_f8889_0(PreflightConfiguration config)
{    this.config = config;}
public void pdfbox_f8890_0()
{    IOUtils.closeQuietly(document);}
public void pdfbox_f8891_0(ValidationError error)
{    PreflightDocument pfDoc = this.document;    error.setPageNumber(currentPageNumber);    pfDoc.addValidationError(error);}
public void pdfbox_f8892_0(List<ValidationError> errors)
{    PreflightDocument pfDoc = this.document;    for (ValidationError error : errors) {        pfDoc.addValidationError(error);    }}
public PreflightPath pdfbox_f8893_0()
{    return validationPath;}
public void pdfbox_f8894_0(PreflightPath validationPath)
{    this.validationPath = validationPath;}
public boolean pdfbox_f8895_0()
{    return iccProfileAlreadySearched;}
public void pdfbox_f8896_0(boolean iccProfileAlreadySearched)
{    this.iccProfileAlreadySearched = iccProfileAlreadySearched;}
public void pdfbox_f8897_0(Integer currentPageNumber)
{    this.currentPageNumber = currentPageNumber;}
public Integer pdfbox_f8898_0()
{    return currentPageNumber;}
public void pdfbox_f8899_0(long fileLen)
{    this.fileLen = fileLen;}
public long pdfbox_f8900_0()
{    return fileLen;}
public void pdfbox_f8901_0(COSObjectable cos)
{    processedSet.add(cos);}
public boolean pdfbox_f8902_0(COSObjectable cos)
{    return processedSet.contains(cos);}
private void pdfbox_f8903_0(Format format)
{    switch(format) {        default:                        this.config = PreflightConfiguration.createPdfA1BConfiguration();            break;    }}
public ValidationResult pdfbox_f8904_0()
{    return result;}
public void pdfbox_f8905_0(ValidationResult result)
{    if (this.result != null) {        this.result.mergeResult(result);    } else if (result != null) {        this.result = result;    } else {        this.result = new ValidationResult(true);    }}
public void pdfbox_f8906_0(ValidationError error)
{    if (error != null) {        if (result == null) {            this.result = new ValidationResult(error.isWarning());        }        this.result.addError(error);    }}
public PreflightContext pdfbox_f8907_0()
{    return this.context;}
public void pdfbox_f8908_0(PreflightContext context)
{    this.context = context;}
public void pdfbox_f8909_0() throws ValidationException
{            javax.xml.bind.DatatypeConverter.parseInt("0");    context.setConfig(config);    Collection<String> processes = config.getProcessNames();    for (String name : processes) {        ContextHelper.validateElement(context, name);    }}
public Format pdfbox_f8910_0()
{    return specification;}
public boolean pdfbox_f8911_0(Object pathElement)
{    boolean pushed = false;    if (pathElement != null) {        this.objectPath.push(pathElement);        this.classObjPath.push(pathElement.getClass());        pushed = true;    }    return pushed;}
public T pdfbox_f8912_0(int position, Class<T> expectedType)
{    if (position < 0 || position >= this.objectPath.size()) {        return null;    }    return (T) this.objectPath.get(position);}
public int pdfbox_f8913_0(Class<T> type)
{    for (int i = this.objectPath.size(); i-- > 0; ) {        if (this.classObjPath.get(i).equals(type)) {            return i;        }    }    return -1;}
public T pdfbox_f8914_0(Class<T> type)
{    return getPathElement(getClosestTypePosition(type), type);}
public Object pdfbox_f8915_0()
{    return this.objectPath.peek();}
public Object pdfbox_f8916_0()
{    this.classObjPath.pop();    return this.objectPath.pop();}
public void pdfbox_f8917_0()
{    this.classObjPath.clear();    this.objectPath.clear();}
public int pdfbox_f8918_0()
{    return this.objectPath.size();}
public boolean pdfbox_f8919_0()
{    return this.objectPath.isEmpty();}
public boolean pdfbox_f8920_0(Class<?> type)
{    @SuppressWarnings("rawtypes")    Class knownType = this.classObjPath.peek();    return (knownType != null && (type.equals(knownType) || type.isAssignableFrom(knownType)));}
protected void pdfbox_f8921_0(PreflightContext ctx, ValidationError error)
{    ctx.addValidationError(error);}
protected void pdfbox_f8922_0(PreflightContext ctx, List<ValidationError> errors)
{    for (ValidationError error : errors) {        addValidationError(ctx, error);    }}
protected void pdfbox_f8923_0(COSDictionary dictionary, PreflightContext context, IOException e)
{    COSName type = dictionary.getCOSName(COSName.TYPE, COSName.FONT);    if (!COSName.FONT.equals(type)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Expected 'Font' dictionary but found '" + type.getName() + "'"));    }    String fontName = "Unknown";    if (dictionary.containsKey(COSName.BASE_FONT)) {        fontName = dictionary.getNameAsString(COSName.BASE_FONT);    }    COSName subType = dictionary.getCOSName(COSName.SUBTYPE);    if (COSName.TYPE1.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE1_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.MM_TYPE1.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE1_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TRUE_TYPE.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TRUETYPE_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TYPE3.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_TYPE3_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.TYPE0.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_CID_DAMAGED, "The FontFile can't be read for " + fontName + ": " + e.getMessage()));    } else if (COSName.CID_FONT_TYPE0.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unexpected CIDFontType0 descendant font for " + fontName + ": " + e.getMessage()));    } else if (COSName.CID_FONT_TYPE2.equals(subType)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unexpected CIDFontType2 descendant font for " + fontName + ": " + e.getMessage()));    } else {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unknown font type for " + fontName));    }}
public void pdfbox_f8924_0(PreflightContext ctx) throws ValidationException
{    PDDocumentCatalog catalog = ctx.getDocument().getDocumentCatalog();    if (catalog != null) {        PDAcroForm acroForm = catalog.getAcroForm();        if (acroForm != null) {            checkNeedAppearences(ctx, acroForm);            try {                exploreFields(ctx, acroForm.getFields());            } catch (IOException e) {                throw new ValidationException("Unable to get the list of fields : " + e.getMessage(), e);            }        }    } else {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There is no Catalog entry in the Document"));    }}
protected void pdfbox_f8925_0(PreflightContext ctx, PDAcroForm acroForm)
{    if (acroForm.getCOSObject().getBoolean(ACROFORM_DICTIONARY_KEY_NEED_APPEARANCES, false)) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_DICT_INVALID, "NeedAppearance is present with the value \"true\""));    }}
protected boolean pdfbox_f8926_0(PreflightContext ctx, List<PDField> lFields) throws IOException
{    if (lFields != null) {                for (Object obj : lFields) {            if (obj instanceof PDField) {                if (!validateField(ctx, (PDField) obj)) {                    return false;                }            } else if (obj instanceof PDAnnotationWidget) {                                ContextHelper.validateElement(ctx, ((PDAnnotationWidget) obj).getCOSObject(), ANNOTATIONS_PROCESS);            } else {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_BODY, "Field can only have fields or widget annotations as KIDS"));            }        }    }    return true;}
protected boolean pdfbox_f8927_0(PreflightContext ctx, List<PDAnnotationWidget> widgets) throws IOException
{    for (PDAnnotationWidget widget : widgets) {                ContextHelper.validateElement(ctx, widget.getCOSObject(), ANNOTATIONS_PROCESS);    }    return true;}
protected boolean pdfbox_f8928_0(PreflightContext ctx, PDField field) throws IOException
{    boolean res = true;    PDFormFieldAdditionalActions aa = field.getActions();    if (aa != null) {        addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTIONS_FIELD, "\"AA\" must not be used in a Field dictionary"));        res = false;    }    if (field instanceof PDTerminalField) {                List<PDAnnotationWidget> widgets = field.getWidgets();        if (res && widgets != null) {            for (PDAnnotationWidget widget : widgets) {                ContextHelper.validateElement(ctx, widget.getCOSObject(), ANNOTATIONS_PROCESS);                COSBase act = widget.getCOSObject().getDictionaryObject(COSName.A);                if (act != null) {                    addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_WIDGET_ACTION_FIELD, "\"A\" must not be used in a widget annotation"));                    return false;                }            }        }        return exploreWidgets(ctx, field.getWidgets());    } else {        return res && exploreFields(ctx, ((PDNonTerminalField) field).getChildren());    }}
public void pdfbox_f8929_0(PreflightContext ctx) throws ValidationException
{    PDDocumentCatalog catalog = ctx.getDocument().getDocumentCatalog();    if (catalog != null) {        PDDocumentOutline outlineHierarchy = catalog.getDocumentOutline();        if (outlineHierarchy != null) {            COSDictionary dict = outlineHierarchy.getCOSObject();            if (!checkIndirectObjects(ctx, dict)) {                return;            }            COSObject firstObj = toCOSObject(dict.getItem(COSName.FIRST));            COSObject lastObj = toCOSObject(dict.getItem(COSName.LAST));                        if (!isCountEntryPresent(dict) && (outlineHierarchy.getFirstChild() != null || outlineHierarchy.getLastChild() != null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline Hierarchy doesn't have Count entry"));            } else if (isCountEntryPositive(dict) && (outlineHierarchy.getFirstChild() == null || outlineHierarchy.getLastChild() == null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline Hierarchy doesn't have First and/or Last entry(ies)"));            } else {                exploreOutlineLevel(ctx, outlineHierarchy.getFirstChild(), firstObj, lastObj);            }        }    } else {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There is no /Catalog entry in the Document"));    }}
private boolean pdfbox_f8930_0(COSDictionary outline)
{    return outline.getItem(COSName.COUNT) != null;}
private boolean pdfbox_f8931_0(COSDictionary outline)
{    COSBase countBase = outline.getDictionaryObject(COSName.COUNT);    return countBase instanceof COSInteger && ((COSInteger) countBase).intValue() > 0;}
protected boolean pdfbox_f8932_0(PreflightContext ctx, PDOutlineItem inputItem, COSObject firstObj, COSObject lastObj) throws ValidationException
{    PDOutlineItem currentItem = inputItem;    COSObject currentObj = firstObj;    Set<COSObject> levelObjects = new HashSet<>();    levelObjects.add(firstObj);    boolean result = true;    if (currentItem != null && inputItem.getPreviousSibling() != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "The value of /Prev of first object " + firstObj + " on a level is " + inputItem.getCOSObject().getItem(COSName.PREV) + ", but shouldn't exist"));        result = false;    }    while (currentItem != null) {        COSObject realPrevObject = currentObj;        if (!validateItem(ctx, currentItem)) {            result = false;        }        currentObj = toCOSObject(currentItem.getCOSObject().getItem(COSName.NEXT));        if (levelObjects.contains(currentObj)) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Loop detected: /Next " + currentObj + " is already in the list"));            return false;        }        if (realPrevObject == null) {                        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline object before " + currentObj + " is null"));            return false;        }        levelObjects.add(currentObj);        currentItem = currentItem.getNextSibling();        if (currentItem == null) {            if (!realPrevObject.equals(lastObj)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Last object on a level isn't the expected /Last: " + lastObj + ", but is " + currentObj));                result = false;            }        } else {            COSObject prevObject = toCOSObject(currentItem.getCOSObject().getItem(COSName.PREV));            if (!realPrevObject.equals(prevObject)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "The value of /Prev at " + currentObj + " doesn't point to previous object " + realPrevObject + ", but to " + prevObject));                result = false;            }        }    }    return result;}
protected boolean pdfbox_f8933_0(PreflightContext ctx, PDOutlineItem inputItem) throws ValidationException
{    boolean isValid = true;                COSDictionary dictionary = inputItem.getCOSObject();    COSBase dest = dictionary.getItem(COSName.DEST);    COSBase action = dictionary.getItem(COSName.A);    if (!checkIndirectObjects(ctx, dictionary)) {        return false;    }    if (action != null && dest != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Dest entry isn't permitted if the A entry is present"));        return false;    } else if (action != null) {        ContextHelper.validateElement(ctx, dictionary, ACTIONS_PROCESS);    } else if (dest != null) {        ContextHelper.validateElement(ctx, dest, DESTINATION_PROCESS);    }            PDOutlineItem fChild = inputItem.getFirstChild();    if (fChild != null) {        if (!isCountEntryPresent(inputItem.getCOSObject())) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "Outline item doesn't have Count entry but has at least one descendant"));            isValid = false;        } else {            COSObject firstObj = toCOSObject(dictionary.getItem(COSName.FIRST));            COSObject lastObj = toCOSObject(dictionary.getItem(COSName.LAST));            if ((firstObj == null && lastObj != null) || (firstObj != null && lastObj == null)) {                addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "/First and /Last are both required if there are outline entries"));                isValid = false;            }                        isValid = isValid && exploreOutlineLevel(ctx, fChild, firstObj, lastObj);        }    }    return isValid;}
private boolean pdfbox_f8934_0(PreflightContext ctx, COSDictionary dictionary)
{        if (!checkIndirectObject(ctx, dictionary, COSName.PARENT)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.PREV)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.NEXT)) {        return false;    }    if (!checkIndirectObject(ctx, dictionary, COSName.FIRST)) {        return false;    }    return checkIndirectObject(ctx, dictionary, COSName.LAST);}
private boolean pdfbox_f8935_0(PreflightContext ctx, COSDictionary dictionary, COSName name)
{    COSBase item = dictionary.getItem(name);    if (item == null || item instanceof COSNull || item instanceof COSObject) {        return true;    }    addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_OUTLINES_INVALID, "/" + name.getName() + " entry must be an indirect object"));    return false;}
private COSObject pdfbox_f8936_0(COSBase base)
{    if (base == null || base instanceof COSNull) {        return null;    }    if (!(base instanceof COSObject)) {        throw new IllegalArgumentException("Paremater " + base + " should be null, COSNull or a COSObject");    }    return (COSObject) base;}
protected boolean pdfbox_f8937_0(String name)
{    for (String iccStandard : listICC) {        if (iccStandard.contains(name)) {            return true;        }    }    return false;}
public void pdfbox_f8938_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfbox = ctx.getDocument();    this.catalog = pdfbox.getDocumentCatalog();    if (this.catalog == null) {        ctx.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There are no Catalog entry in the Document"));    } else {        validateActions(ctx);        validateLang(ctx);        validateNames(ctx);        validateOCProperties(ctx);        validateOutputIntent(ctx);    }}
protected void pdfbox_f8939_0(PreflightContext ctx) throws ValidationException
{    ContextHelper.validateElement(ctx, catalog.getCOSObject(), ACTIONS_PROCESS);        COSBase aa = catalog.getCOSObject().getItem(COSName.AA);    if (aa != null) {        addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTION, "The AA field is forbidden for the Catalog  when the PDF is a PDF/A"));    }}
protected void pdfbox_f8940_0(PreflightContext ctx) throws ValidationException
{    String lang = catalog.getLanguage();    if (lang != null && !"".equals(lang) && !lang.matches("[A-Za-z]{1,8}(-[A-Za-z]{1,8})*")) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_LANG_NOT_RFC1766));    }}
protected void pdfbox_f8941_0(PreflightContext ctx) throws ValidationException
{    PDDocumentNameDictionary names = catalog.getNames();    if (names != null) {        PDEmbeddedFilesNameTreeNode efs = names.getEmbeddedFiles();        if (efs != null) {            addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_CATALOG_EMBEDDEDFILES, "EmbeddedFile entry is present in the Names dictionary"));        }        if (names.getJavaScript() != null) {            addValidationError(ctx, new ValidationError(ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED, "Javascript entry is present in the Names dictionary"));        }    }}
protected void pdfbox_f8942_0(PreflightContext ctx) throws ValidationException
{    if (catalog.getOCProperties() != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER_CATALOG_OCPROPERTIES, "A Catalog shall not contain the OCPProperties entry"));    }}
public void pdfbox_f8943_0(PreflightContext ctx) throws ValidationException
{    COSArray outputIntents = catalog.getCOSObject().getCOSArray(COSName.OUTPUT_INTENTS);    Map<COSObjectKey, Boolean> tmpDestOutputProfile = new HashMap<>();    for (int i = 0; outputIntents != null && i < outputIntents.size(); ++i) {        COSDictionary outputIntentDict = (COSDictionary) outputIntents.getObject(i);        if (outputIntentDict == null) {            addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "OutputIntent object is null or isn't a dictionary"));        } else {                        String sValue = outputIntentDict.getNameAsString(OUTPUT_INTENT_DICTIONARY_KEY_S);            if (!OUTPUT_INTENT_DICTIONARY_VALUE_GTS_PDFA1.equals(sValue)) {                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_S_VALUE_INVALID, "The S entry of the OutputIntent isn't GTS_PDFA1"));                continue;            }                        String outputConditionIdentifier = outputIntentDict.getString(OUTPUT_INTENT_DICTIONARY_KEY_OUTPUT_CONDITION_IDENTIFIER);            if (outputConditionIdentifier == null) {                                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "The OutputIntentCondition is missing"));                continue;            }            /*                 * If OutputConditionIdentifier is "Custom" or a non Standard ICC Characterization : DestOutputProfile                 * and Info are mandatory DestOutputProfile must be a ICC Profile                 *                  * Because of PDF/A conforming file needs to specify the color characteristics, the DestOutputProfile is                 * checked even if the OutputConditionIdentifier isn't "Custom"                 */            COSBase destOutputProfile = outputIntentDict.getItem(COSName.DEST_OUTPUT_PROFILE);            validateICCProfile(destOutputProfile, tmpDestOutputProfile, ctx);            PreflightConfiguration config = ctx.getConfig();            if (config.isLazyValidation() && !isStandardICCCharacterization(outputConditionIdentifier)) {                String info = outputIntentDict.getString(COSName.getPDFName(OUTPUT_INTENT_DICTIONARY_KEY_INFO));                if (info == null || "".equals(info)) {                    ValidationError error = new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "The Info entry of a OutputIntent dictionary is missing");                    error.setWarning(true);                    addValidationError(ctx, error);                }            }        }    }}
protected void pdfbox_f8944_0(COSBase destOutputProfile, Map<COSObjectKey, Boolean> mapDestOutputProfile, PreflightContext ctx) throws ValidationException
{    try {        if (destOutputProfile == null) {            return;        }        COSBase localDestOutputProfile = destOutputProfile;                if (localDestOutputProfile instanceof COSObject) {            if (mapDestOutputProfile.containsKey(new COSObjectKey((COSObject) localDestOutputProfile))) {                                return;            } else if (!mapDestOutputProfile.isEmpty()) {                                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_MULTIPLE, "More than one ICCProfile is defined: " + destOutputProfile));                return;            }                        localDestOutputProfile = ((COSObject) localDestOutputProfile).getObject();        }                mapDestOutputProfile.put(new COSObjectKey((COSObject) destOutputProfile), true);        if (!(localDestOutputProfile instanceof COSStream)) {            addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_INVALID_ENTRY, "OutputIntent object must be a stream"));            return;        }        COSStream stream = (COSStream) localDestOutputProfile;        COSArray array = new COSArray();        array.add(COSName.ICCBASED);        array.add(stream);        PDICCBased iccBased = PDICCBased.create(array, null);        PreflightConfiguration cfg = ctx.getConfig();        ColorSpaceHelperFactory csFact = cfg.getColorSpaceHelperFact();        ColorSpaceHelper csHelper = csFact.getColorSpaceHelper(ctx, iccBased, ColorSpaceRestriction.NO_RESTRICTION);        csHelper.validate();        if (ctx.getIccProfileWrapper() == null) {            try (InputStream is = stream.createInputStream()) {                ctx.setIccProfileWrapper(new ICCProfileWrapper(ICC_Profile.getInstance(is)));            }        }    } catch (IllegalArgumentException e) {                addValidationError(ctx, new ValidationError(ERROR_GRAPHIC_OUTPUT_INTENT_ICC_PROFILE_INVALID, "DestOutputProfile isn't a valid ICCProfile: " + e.getMessage(), e));    } catch (IOException e) {        throw new ValidationException("Unable to parse the ICC Profile.", e);    }}
public void pdfbox_f8945_0(PreflightContext context) throws ValidationException
{}
public void pdfbox_f8946_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    COSDocument cDoc = pdfDoc.getDocument();    List<?> lCOSObj = cDoc.getObjects();    for (Object o : lCOSObj) {        COSBase cBase = ((COSObject) o).getObject();        if (cBase instanceof COSDictionary) {            COSDictionary dic = (COSDictionary) cBase;            String type = dic.getNameAsString(COSName.TYPE);            if (FILE_SPECIFICATION_VALUE_TYPE.equals(type) || COSName.F.getName().equals(type)) {                                validateFileSpecification(ctx, dic);            }        }    }}
public List<ValidationError> pdfbox_f8947_0(PreflightContext ctx, COSDictionary fileSpec)
{    List<ValidationError> result = new ArrayList<>(0);        if (fileSpec.getItem(COSName.getPDFName(FILE_SPECIFICATION_KEY_EMBEDDED_FILE)) != null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_EMBEDDED_FILES, "EmbeddedFile entry is present in a FileSpecification dictionary"));    }    return result;}
public void pdfbox_f8948_0(PreflightContext ctx) throws ValidationException
{    try {        PDDocument document = ctx.getDocument();        InputStream is = getXpacket(document);        DomXmpParser builder = new DomXmpParser();        XMPMetadata metadata = builder.parse(is);        is.close();        ctx.setMetadata(metadata);                if (metadata.getXpacketBytes() != null) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_XPACKET_DEPRECATED, "bytes attribute is forbidden"));        }        if (metadata.getXpacketEncoding() != null) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_XPACKET_DEPRECATED, "encoding attribute is forbidden"));        }        checkThumbnails(ctx, metadata);                addValidationErrors(ctx, new SynchronizedMetaDataValidation().validateMetadataSynchronization(document, metadata));                addValidationErrors(ctx, new PDFAIdentificationValidation().validatePDFAIdentifer(metadata));                try {            new RDFAboutAttributeConcordanceValidation().validateRDFAboutAttributes(metadata);        } catch (DifferentRDFAboutException e) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_RDF_ABOUT_ATTRIBUTE_INEQUAL_VALUE, e.getMessage(), e));        }    } catch (XpacketParsingException e) {        if (e.getError() != null) {            addValidationError(ctx, e.getError());        } else {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_MAIN, "Unexpected error", e));        }    } catch (XmpParsingException e) {        if (e.getErrorType() == ErrorType.NoValueType) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_UNKNOWN_VALUETYPE, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.RequiredProperty) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_MISSING, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidPrefix) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_ABSENT_DESCRIPTION_SCHEMA, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidType) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_PROPERTY_UNKNOWN, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.XpacketBadEnd) {            throw new ValidationException("Unable to parse font metadata due to : " + e.getMessage(), e);        } else if (e.getErrorType() == ErrorType.NoSchema) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_ABSENT_DESCRIPTION_SCHEMA, e.getMessage(), e));        } else if (e.getErrorType() == ErrorType.InvalidPdfaSchema) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_WRONG_NS_URI, e.getMessage(), e));        } else {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        }    } catch (IOException e) {        throw new ValidationException("Failed while validating", e);    }}
private void pdfbox_f8949_0(PreflightContext ctx, XMPMetadata metadata)
{    XMPBasicSchema xmp = metadata.getXMPBasicSchema();    if (xmp == null) {        return;    }    List<ThumbnailType> tbProp;    try {        tbProp = xmp.getThumbnailsProperty();    } catch (BadFieldValueException e) {                addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        return;    }    if (tbProp == null) {        return;    }    for (ThumbnailType tb : tbProp) {        checkThumbnail(tb, ctx);    }}
private void pdfbox_f8950_0(ThumbnailType tb, PreflightContext ctx)
{    byte[] binImage;    try {        binImage = Hex.decodeBase64(tb.getImage());    } catch (IllegalArgumentException e) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:image is not correct base64 encoding"));        return;    }    if (!hasJpegMagicNumber(binImage)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:image decoded base64 content is not in JPEG format"));        return;    }    BufferedImage bim;    try {        bim = ImageIO.read(new ByteArrayInputStream(binImage));    } catch (IOException e) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, e.getMessage(), e));        return;    }    if (!"JPEG".equals(tb.getFormat())) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:format must be 'JPEG'"));    }    if (bim.getHeight() != tb.getHeight()) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:height does not match the actual base64-encoded thumbnail image data"));    }    if (bim.getWidth() != tb.getWidth()) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "xapGImg:witdh does not match the actual base64-encoded thumbnail image data"));    }}
private boolean pdfbox_f8951_0(byte[] binImage)
{    if (binImage.length < 4) {        return false;    }    return (binImage[0] == (byte) 0xFF && binImage[1] == (byte) 0xD8 && binImage[binImage.length - 2] == (byte) 0xFF && binImage[binImage.length - 1] == (byte) 0xD9);}
private static InputStream pdfbox_f8952_0(PDDocument document) throws IOException, XpacketParsingException
{    PDDocumentCatalog catalog = document.getDocumentCatalog();    PDMetadata metadata = catalog.getMetadata();    if (metadata == null) {        COSBase metaObject = catalog.getCOSObject().getDictionaryObject(COSName.METADATA);        if (!(metaObject instanceof COSStream)) {                        ValidationError error = new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "Metadata is not a stream");            throw new XpacketParsingException("Failed while retrieving xpacket", error);        }                ValidationError error = new ValidationError(PreflightConstants.ERROR_METADATA_FORMAT, "Missing Metadata Key in catalog");        throw new XpacketParsingException("Failed while retrieving xpacket", error);    }        if (metadata.getFilters() != null) {                ValidationError error = new ValidationError(PreflightConstants.ERROR_SYNTAX_STREAM_INVALID_FILTER, "Filter specified in metadata dictionnary");        throw new XpacketParsingException("Failed while retrieving xpacket", error);    }    return metadata.exportXMPMetadata();}
protected List<ValidationError> pdfbox_f8953_0(PDDocument doc)
{    List<ValidationError> ve = new ArrayList<>();    List<?> filters = doc.getDocumentCatalog().getMetadata().getFilters();    if (filters != null && !filters.isEmpty()) {        ve.add(new ValidationError(PreflightConstants.ERROR_METADATA_MAIN, "Using stream filter on metadata dictionary is forbidden"));    }    return ve;}
public void pdfbox_f8954_0(PreflightContext context) throws ValidationException
{    PDDocumentCatalog catalog = context.getDocument().getDocumentCatalog();    if (catalog != null) {        COSDictionary catalogDict = catalog.getCOSObject();        if (!(catalogDict.getDictionaryObject(COSName.PAGES) instanceof COSDictionary)) {            addValidationError(context, new ValidationError(ERROR_PDF_PROCESSING_MISSING, "/Pages dictionary entry is missing in document catalog"));            return;        }        int p = 0;        for (PDPage page : context.getDocument().getPages()) {            context.setCurrentPageNumber(p);            validatePage(context, page);            if (context.getDocument().getResult().getErrorsList().size() > context.getConfig().getMaxErrors()) {                context.addValidationError(new ValidationError(PreflightConstants.ERROR_UNKOWN_ERROR, "Over " + context.getConfig().getMaxErrors() + " errors, page tree validation process aborted"));                break;            }            context.setCurrentPageNumber(null);            ++p;        }    } else {        context.addValidationError(new ValidationError(ERROR_SYNTAX_NOCATALOG, "There are no Catalog entry in the Document"));    }}
protected void pdfbox_f8955_0(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page, PAGE_PROCESS);}
public void pdfbox_f8956_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Action validation process needs at least one COSDictionary object"));    } else {        COSDictionary actionsDict = (COSDictionary) vPath.peek();                boolean aaEntryAuth = ((vPath.size() - vPath.getClosestTypePosition(PDPage.class)) == 2);        PreflightConfiguration config = context.getConfig();        ActionManagerFactory factory = config.getActionFact();        List<AbstractActionManager> la = factory.getActionManagers(context, actionsDict);        for (AbstractActionManager aMng : la) {            aMng.valid(aaEntryAuth);        }    }}
public void pdfbox_f8957_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_ANNOT_INVALID_ELEMENT, "Annotation validation process needs at least one COSDictionary object"));    } else {        COSDictionary annotDict = (COSDictionary) vPath.peek();        PreflightConfiguration config = context.getConfig();        AnnotationValidatorFactory factory = config.getAnnotFact();        AnnotationValidator annotValidator = factory.getAnnotationValidator(context, annotDict);        if (annotValidator != null) {            annotValidator.validate();        }    }}
public void pdfbox_f8958_0(PreflightContext ctx) throws ValidationException
{    PreflightPath vPath = ctx.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(COSBase.class)) {        ctx.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_ACTION_INVALID_TYPE, "Destination validation process needs at least one COSBase object"));        return;    }    COSBase dest = (COSBase) vPath.peek();    if (!(dest instanceof COSName || dest instanceof COSString || dest instanceof COSArray)) {        ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination type entry " + dest.getClass().getSimpleName() + " is invalid"));        return;    }    if (dest instanceof COSArray) {        COSArray ar = (COSArray) dest;        if (ar.size() < 2) {            ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Destination array must have at least 2 elements"));            return;        }        if (!(ar.get(1) instanceof COSName)) {            ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "Second element of destination array must be a name"));            return;        }        validateExplicitDestination(ctx, ar);    }    try {        PDDestination.create(dest);    } catch (IOException e) {        ctx.addValidationError(new ValidationResult.ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));    }}
 void pdfbox_f8959_0(PreflightContext ctx, COSArray ar)
{        if (ar.get(0) instanceof COSObject) {        COSObject ob = (COSObject) ar.get(0);        COSBase type = ob.getDictionaryObject(COSName.TYPE);        if (COSName.PAGE.equals(type)) {            try {                PDDestination.create(ar);            } catch (IOException e) {                ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, e.getMessage(), e));            }            return;        }    }    ctx.addValidationError(new ValidationResult.ValidationError(ERROR_SYNTAX_DICT_INVALID, "First element in Destination array entry must be an indirect reference to a dictionary of /Type /Page, but is " + ar.getName(0)));}
public void pdfbox_f8960_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(COSDictionary.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_XOBJECT_INVALID_TYPE, "ExtGState validation required at least a Resource dictionary"));    } else {        COSDictionary extGStatesDict = (COSDictionary) vPath.peek();        List<COSDictionary> listOfExtGState = extractExtGStateDictionaries(extGStatesDict);        validateTransparencyRules(context, listOfExtGState);        validateFonts(context, listOfExtGState);    }}
public List<COSDictionary> pdfbox_f8961_0(COSDictionary extGStates) throws ValidationException
{    List<COSDictionary> listOfExtGState = new ArrayList<>(0);    if (extGStates != null) {        for (COSName key : extGStates.keySet()) {            COSDictionary gsDict = extGStates.getCOSDictionary(key);            if (gsDict == null) {                throw new ValidationException("The Extended Graphics State dictionary is invalid");            }            listOfExtGState.add(gsDict);        }    }    return listOfExtGState;}
protected void pdfbox_f8962_0(PreflightContext context, List<COSDictionary> listOfExtGState)
{    for (COSDictionary egs : listOfExtGState) {        checkSoftMask(context, egs);        checkUpperCA(context, egs);        checkLowerCA(context, egs);        checkBlendMode(context, egs);        checkTRKey(context, egs);        checkTR2Key(context, egs);    }}
protected void pdfbox_f8963_0(PreflightContext context, List<COSDictionary> listOfExtGState) throws ValidationException
{    for (COSDictionary egs : listOfExtGState) {        checkFont(context, egs);    }}
private void pdfbox_f8964_0(PreflightContext context, COSDictionary egs) throws ValidationException
{    COSBase base = egs.getItem(COSName.FONT);    if (base == null) {        return;    }    if (!(base instanceof COSArray) || ((COSArray) base).size() != 2) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "/Font entry in /ExtGState must be an array with 2 elements"));        return;    }    COSArray ar = (COSArray) base;    COSBase base0 = ar.get(0);    if (!(base0 instanceof COSObject)) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "1st element in /Font entry in /ExtGState must be an indirect object"));        return;    }    COSBase base1 = ar.getObject(1);    if (!(base1 instanceof COSNumber)) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_COMMON, "2nd element in /Font entry in /ExtGState must be a number"));        return;    }    COSNumber fontSize = (COSNumber) ar.getObject(1);    if (fontSize.floatValue() > MAX_POSITIVE_FLOAT || fontSize.floatValue() < MAX_NEGATIVE_FLOAT) {        context.addValidationError(new ValidationError(ERROR_SYNTAX_NUMERIC_RANGE, "invalid float range in 2nd element in /Font entry in /ExtGState"));    }    if (ar.getObject(0) instanceof COSDictionary) {        COSDictionary fontDict = (COSDictionary) ar.getObject(0);        try {            PDFont newFont = PDFontFactory.createFont(fontDict);            ContextHelper.validateElement(context, newFont, FONT_PROCESS);        } catch (IOException e) {            addFontError(fontDict, context, e);        }    }}
private void pdfbox_f8965_0(PreflightContext context, COSDictionary egs)
{    COSBase smVal = egs.getDictionaryObject(COSName.SMASK);    if (smVal != null && !(smVal instanceof COSName && COSName.NONE.equals(smVal))) {                context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_SOFT_MASK, "SoftMask must be null or None"));    }}
private void pdfbox_f8966_0(PreflightContext context, COSDictionary egs)
{    COSName bmVal = egs.getCOSName(COSName.BM);        if (bmVal != null && !(COSName.NORMAL.equals(bmVal) || COSName.COMPATIBLE.equals(bmVal))) {        context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_BLEND_MODE, "BlendMode value isn't valid (only Normal and Compatible are authorized)"));    }}
private void pdfbox_f8967_0(PreflightContext context, COSDictionary egs)
{    COSBase uCA = egs.getDictionaryObject(COSName.CA);    if (uCA != null) {                Float fca = uCA instanceof COSFloat ? ((COSFloat) uCA).floatValue() : null;        Integer ica = uCA instanceof COSInteger ? ((COSInteger) uCA).intValue() : null;        if (!(fca != null && Float.compare(fca, 1.0f) == 0) && !(ica != null && ica == 1)) {            context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_CA, "CA entry in a ExtGState is invalid"));        }    }}
private void pdfbox_f8968_0(PreflightContext context, COSDictionary egs)
{    COSBase lCA = egs.getDictionaryObject(COSName.CA_NS);    if (lCA != null) {                Float fca = lCA instanceof COSFloat ? ((COSFloat) lCA).floatValue() : null;        Integer ica = lCA instanceof COSInteger ? ((COSInteger) lCA).intValue() : null;        if (!(fca != null && Float.compare(fca, 1.0f) == 0) && !(ica != null && ica == 1)) {            context.addValidationError(new ValidationError(ERROR_TRANSPARENCY_EXT_GS_CA, "ca entry in a ExtGState is invalid"));        }    }}
protected void pdfbox_f8969_0(PreflightContext context, COSDictionary egs)
{    if (egs.getItem(COSName.TR) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "No TR key expected in Extended graphics state"));    }}
protected void pdfbox_f8970_0(PreflightContext context, COSDictionary egs)
{    if (egs.getItem("TR2") != null) {        String s = egs.getNameAsString("TR2");        if (!"Default".equals(s)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "TR2 key only expect 'Default' value, not '" + s + "'"));        }    }}
public void pdfbox_f8971_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDFont.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_INVALID_DATA, "Font validation process needs at least one PDFont object"));    } else {        PDFont font = (PDFont) vPath.peek();        FontContainer<?> fontContainer = context.getFontContainer(font.getCOSObject());        if (fontContainer == null) {                        FontValidator<? extends FontContainer<? extends PDFont>> validator = getFontValidator(context, font);            if (validator != null) {                validator.validate();            }        }    }}
protected FontValidator<? extends FontContainer<? extends PDFont>> pdfbox_f8972_0(PreflightContext context, PDFont font)
{    String subtype = font.getSubType();    if (FONT_DICTIONARY_VALUE_TRUETYPE.equals(subtype)) {        return new TrueTypeFontValidator(context, (PDTrueTypeFont) font);    }    if (FONT_DICTIONARY_VALUE_MMTYPE.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE1.equals(subtype)) {        return new Type1FontValidator(context, (PDSimpleFont) font);    }    if (FONT_DICTIONARY_VALUE_TYPE3.equals(subtype)) {        return new Type3FontValidator(context, (PDType3Font) font);    }    if (FONT_DICTIONARY_VALUE_COMPOSITE.equals(subtype)) {        return new Type0FontValidator(context, font);    }    if (FONT_DICTIONARY_VALUE_TYPE2.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE1C.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE0C.equals(subtype) || FONT_DICTIONARY_VALUE_TYPE0.equals(subtype)) {                return null;    }    context.addValidationError(new ValidationError(PreflightConstants.ERROR_FONTS_UNKNOWN_FONT_TYPE, "Unknown font type: " + subtype));    return null;}
public void pdfbox_f8973_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    XObjectValidator validator = null;    if (!vPath.isEmpty() && vPath.isExpectedType(PDImageXObject.class)) {        validator = new XObjImageValidator(context, (PDImageXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(PDFormXObject.class)) {        validator = new XObjFormValidator(context, (PDFormXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(PDPostScriptXObject.class)) {        validator = new XObjPostscriptValidator(context, (PDPostScriptXObject) vPath.peek());    } else if (!vPath.isEmpty() && vPath.isExpectedType(COSStream.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_XOBJECT_INVALID_TYPE, "Invalid XObject subtype"));    } else {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "Graphic validation process needs at least one PDXObject"));    }    if (validator != null) {        validator.validate();    }}
public void pdfbox_f8974_0(PreflightContext ctx) throws ValidationException
{    PreflightPath vPath = ctx.getValidationPath();    if (vPath.isEmpty()) {    } else if (!vPath.isExpectedType(PDResources.class)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_PDF_PROCESSING_MISSING, "Resources validation process needs at least one PDResources object"));    } else {        PDResources resources = (PDResources) vPath.peek();        validateFonts(ctx, resources);        validateExtGStates(ctx, resources);        validateShadingPattern(ctx, resources);        validateTilingPattern(ctx, resources);        validateXObjects(ctx, resources);    }}
protected void pdfbox_f8975_0(PreflightContext context, PDResources resources) throws ValidationException
{    Map<String, PDFont> mapOfFonts = getFonts(resources.getCOSObject(), context);    for (Entry<String, PDFont> entry : mapOfFonts.entrySet()) {        ContextHelper.validateElement(context, entry.getValue(), FONT_PROCESS);    }}
private Map<String, PDFont> pdfbox_f8976_0(COSDictionary resources, PreflightContext context)
{    Map<String, PDFont> fonts = new HashMap<>();    COSDictionary fontsDictionary = (COSDictionary) resources.getDictionaryObject(COSName.FONT);    if (fontsDictionary == null) {        fontsDictionary = new COSDictionary();        resources.setItem(COSName.FONT, fontsDictionary);    }    for (COSName fontName : fontsDictionary.keySet()) {        COSBase font = fontsDictionary.getDictionaryObject(fontName);                if (font instanceof COSDictionary) {            PDFont newFont = null;            try {                newFont = PDFontFactory.createFont((COSDictionary) font);            } catch (IOException e) {                addFontError((COSDictionary) font, context, e);            }            if (newFont != null) {                fonts.put(fontName.getName(), newFont);            }        }    }    return fonts;}
protected void pdfbox_f8977_0(PreflightContext context, PDResources resources) throws ValidationException
{    COSDictionary extGState = resources.getCOSObject().getCOSDictionary(COSName.EXT_G_STATE);    if (extGState != null) {        ContextHelper.validateElement(context, extGState, EXTGSTATE_PROCESS);    }}
protected void pdfbox_f8978_0(PreflightContext context, PDResources resources) throws ValidationException
{    try {        for (COSName name : resources.getShadingNames()) {            PDShading shading = resources.getShading(name);            ContextHelper.validateElement(context, shading, SHADING_PATTERN_PROCESS);        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION, e.getMessage(), e));    }}
protected void pdfbox_f8979_0(PreflightContext context, PDResources resources) throws ValidationException
{    try {        for (COSName name : resources.getPatternNames()) {            PDAbstractPattern pattern = resources.getPattern(name);            if (pattern instanceof PDTilingPattern) {                ContextHelper.validateElement(context, pattern, TILING_PATTERN_PROCESS);            }        }    } catch (IOException e) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION, e.getMessage(), e));    }}
protected void pdfbox_f8980_0(PreflightContext context, PDResources resources) throws ValidationException
{    COSDictionary mapOfXObj = resources.getCOSObject().getCOSDictionary(COSName.XOBJECT);    if (mapOfXObj == null) {        return;    }    for (Entry<COSName, COSBase> entry : mapOfXObj.entrySet()) {        COSBase xobj = entry.getValue();        if (xobj instanceof COSObject) {            xobj = ((COSObject) xobj).getObject();        }        if (xobj instanceof COSStream) {            try {                PDXObject pdXObject = PDXObject.createXObject(xobj, resources);                ContextHelper.validateElement(context, pdXObject, GRAPHIC_PROCESS);            } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_MAIN, e.getMessage() + " for entry '" + entry.getKey().getName() + "'", e));            }        }    }}
public void pdfbox_f8981_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDShading.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "ShadingPattern validation required at least a PDResources"));    } else {        PDShading shadingResource = (PDShading) vPath.peek();        PDPage page = vPath.getClosestPathElement(PDPage.class);        checkColorSpace(context, page, shadingResource);        checkGraphicState(context, page, shadingResource);    }}
protected void pdfbox_f8982_1(PreflightContext context, PDPage page, PDShading shadingRes) throws ValidationException
{    try {        PDColorSpace pColorSpace = shadingRes.getColorSpace();        PreflightConfiguration config = context.getConfig();        ColorSpaceHelperFactory csFact = config.getColorSpaceHelperFact();        ColorSpaceHelper csh = csFact.getColorSpaceHelper(context, pColorSpace, ColorSpaceRestriction.NO_PATTERN);        csh.validate();    } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE, e.getMessage()));    }}
protected void pdfbox_f8983_0(PreflightContext context, PDPage page, PDShading shadingRes) throws ValidationException
{    COSDictionary resources = (COSDictionary) shadingRes.getCOSObject().getDictionaryObject(COSName.EXT_G_STATE);    if (resources != null) {        ContextHelper.validateElement(context, resources, EXTGSTATE_PROCESS);    }}
public void pdfbox_f8984_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    }    if (!vPath.isExpectedType(PDPage.class)) {        addValidationError(context, new ValidationError(PreflightConstants.ERROR_PDF_PROCESSING_MISSING, "Page validation required at least a PDPage"));    } else {        PDPage page = (PDPage) vPath.peek();        validateActions(context, page);        validateAnnotation(context, page);        validateColorSpaces(context, page);        validateResources(context, page);        validateGraphicObjects(context, page);        validateGroupTransparency(context, page);                        validateContent(context, page);    }}
protected void pdfbox_f8985_0(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page.getCOSObject(), ACTIONS_PROCESS);}
protected void pdfbox_f8986_1(PreflightContext context, PDPage page)
{    PDResources resources = page.getResources();    if (resources != null) {        PreflightConfiguration config = context.getConfig();        ColorSpaceHelperFactory colorSpaceFactory = config.getColorSpaceHelperFact();        for (COSName name : resources.getColorSpaceNames()) {            try {                PDColorSpace pdCS = resources.getColorSpace(name);                ColorSpaceHelper csHelper = colorSpaceFactory.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_RESTRICTION);                csHelper.validate();            } catch (IOException e) {                                            }        }    }}
protected void pdfbox_f8987_1(PreflightContext context, PDPage page) throws ValidationException
{    COSBase thumbBase = page.getCOSObject().getItem(COSName.THUMB);    if (thumbBase != null) {        try {            if (thumbBase instanceof COSObject) {                thumbBase = ((COSObject) thumbBase).getObject();            }            PDXObject thumbImg = PDImageXObject.createThumbnail((COSStream) thumbBase);            ContextHelper.validateElement(context, thumbImg, GRAPHIC_PROCESS);        } catch (IOException e) {                        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID, "Unable to read Thumb image : " + e.getMessage()));        }    }}
protected void pdfbox_f8988_0(PreflightContext context, PDPage page) throws ValidationException
{    ContextHelper.validateElement(context, page.getResources(), RESOURCES_PROCESS);}
protected void pdfbox_f8989_1(PreflightContext context, PDPage page) throws ValidationException
{        try {        PreflightContentStream csWrapper = new PreflightContentStream(context, page);        csWrapper.validatePageContentStream();    } catch (IOException e) {                context.addValidationError(new ValidationError(ERROR_UNKOWN_ERROR, e.getMessage(), e));    }}
protected void pdfbox_f8990_0(PreflightContext context, PDPage page) throws ValidationException
{    try {        List<?> lAnnots = page.getAnnotations();        for (Object object : lAnnots) {            if (object instanceof PDAnnotation) {                COSDictionary cosAnnot = ((PDAnnotation) object).getCOSObject();                ContextHelper.validateElement(context, cosAnnot, ANNOTATIONS_PROCESS);            }        }    } catch (ValidationException e) {        throw e;    } catch (IOException e) {                throw new ValidationException("Unable to access Annotation", e);    }}
protected void pdfbox_f8991_0(PreflightContext context, PDPage page) throws ValidationException
{    COSDictionary groupDictionary = page.getCOSObject().getCOSDictionary(COSName.GROUP);    if (groupDictionary != null) {        COSName sVal = groupDictionary.getCOSName(COSName.S);        if (COSName.TRANSPARENCY.equals(sVal)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_GROUP, "Group has a transparency S entry or the S entry is null"));        }    }}
public void pdfbox_f8992_0(PreflightContext context) throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    if (vPath.isEmpty()) {        return;    } else if (!vPath.isExpectedType(PDTilingPattern.class)) {        context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_OBJECT, "Tiling pattern validation required at least a PDPage"));    } else {        PDTilingPattern tilingPattern = (PDTilingPattern) vPath.peek();        PDPage page = vPath.getClosestPathElement(PDPage.class);        checkMandatoryFields(context, page, tilingPattern);        parseResources(context, page, tilingPattern);        parsePatternContent(context, page, tilingPattern);    }}
protected void pdfbox_f8993_0(PreflightContext context, PDPage page, PDTilingPattern pattern) throws ValidationException
{    PDResources resources = pattern.getResources();    if (resources != null) {        ContextHelper.validateElement(context, resources, RESOURCES_PROCESS);    }}
protected void pdfbox_f8994_0(PreflightContext context, PDPage page, PDTilingPattern pattern) throws ValidationException
{    PreflightContentStream csWrapper = new PreflightContentStream(context, page);    csWrapper.validatePatternContentStream(pattern);}
protected void pdfbox_f8995_0(PreflightContext context, PDPage page, PDTilingPattern pattern)
{    COSDictionary dictionary = pattern.getCOSObject();    boolean res = dictionary.getItem(COSName.RESOURCES) != null;    res = res && dictionary.getItem(COSName.BBOX) != null;    res = res && dictionary.getItem(COSName.PAINT_TYPE) != null;    res = res && dictionary.getItem(COSName.TILING_TYPE) != null;    res = res && dictionary.getItem(COSName.X_STEP) != null;    res = res && dictionary.getItem(COSName.Y_STEP) != null;    if (!res) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_PATTERN_DEFINITION));    }}
public void pdfbox_f8996_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    List<COSObject> lCOSObj = pdfDoc.getDocument().getObjects();    for (COSObject cObj : lCOSObj) {                COSBase cBase = cObj.getObject();        if (cBase instanceof COSStream) {            validateStreamObject(ctx, cObj);        }    }}
public void pdfbox_f8997_0(PreflightContext context, COSObject cObj) throws ValidationException
{    COSStream streamObj = (COSStream) cObj.getObject();                checkDictionaryEntries(context, streamObj);        checkFilters(streamObj, context);}
protected void pdfbox_f8998_0(COSStream stream, PreflightContext context)
{    COSBase bFilter = stream.getDictionaryObject(COSName.FILTER);    if (bFilter != null) {        if (bFilter instanceof COSArray) {            COSArray afName = (COSArray) bFilter;            for (int i = 0; i < afName.size(); ++i) {                FilterHelper.isAuthorizedFilter(context, afName.getString(i));            }        } else if (bFilter instanceof COSName) {            String fName = ((COSName) bFilter).getName();            FilterHelper.isAuthorizedFilter(context, fName);        } else {                        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, "Filter should be a Name or an Array"));        }    }}
protected void pdfbox_f8999_0(PreflightContext context, COSStream streamObj)
{    boolean len = streamObj.containsKey(COSName.LENGTH);    boolean f = streamObj.containsKey(COSName.F);    boolean ffilter = streamObj.containsKey(COSName.F_FILTER);    boolean fdecParams = streamObj.containsKey(COSName.F_DECODE_PARMS);    if (!len) {        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_LENGTH_MISSING, "Stream length is missing"));    }    if (f || ffilter || fdecParams) {        addValidationError(context, new ValidationError(ERROR_SYNTAX_STREAM_FX_KEYS, "F, FFilter or FDecodeParms keys are present in the stream dictionary"));    }}
public void pdfbox_f9000_0(PreflightContext ctx) throws ValidationException
{    PDDocument pdfDoc = ctx.getDocument();    COSDictionary linearizedDict = getLinearizedDictionary(pdfDoc);        if (linearizedDict != null && ctx.getXrefTrailerResolver().getTrailerCount() == 2 && ctx.getFileLen() == linearizedDict.getLong(COSName.L)) {                checkLinearizedDictionnary(ctx, linearizedDict);                                        float pdfVersion = pdfDoc.getVersion();        if (pdfVersion <= 1.4f) {            checkTrailersForLinearizedPDF14(ctx);        } else {            checkTrailersForLinearizedPDF15(ctx);        }    } else {                checkMainTrailer(ctx, pdfDoc.getDocument().getTrailer());    }}
protected void pdfbox_f9001_0(PreflightContext ctx)
{    COSDictionary first = ctx.getXrefTrailerResolver().getFirstTrailer();    if (first == null) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER, "There are no trailer in the PDF file"));    } else {        COSDictionary last = ctx.getXrefTrailerResolver().getLastTrailer();        checkMainTrailer(ctx, first);        if (!compareIds(first, last)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ID_CONSISTENCY, "ID is different in the first and the last trailer"));        }    }}
protected void pdfbox_f9002_0(PreflightContext ctx)
{    PDDocument pdfDoc = ctx.getDocument();    COSDocument cosDocument = pdfDoc.getDocument();    List<COSObject> xrefs = cosDocument.getObjectsByType(COSName.XREF);    if (xrefs.isEmpty()) {                checkTrailersForLinearizedPDF14(ctx);    } else {        long min = Long.MAX_VALUE;        long max = Long.MIN_VALUE;        COSDictionary firstTrailer = null;        COSDictionary lastTrailer = null;                for (COSObject co : xrefs) {            long offset = cosDocument.getXrefTable().get(new COSObjectKey(co));            if (offset < min) {                min = offset;                firstTrailer = (COSDictionary) co.getObject();            }            if (offset > max) {                max = offset;                lastTrailer = (COSDictionary) co.getObject();            }        }        checkMainTrailer(ctx, firstTrailer);        if (!compareIds(firstTrailer, lastTrailer)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ID_CONSISTENCY, "ID is different in the first and the last trailer"));        }    }}
protected boolean pdfbox_f9003_0(COSDictionary first, COSDictionary last)
{    COSBase idFirst = first.getDictionaryObject(COSName.ID);    COSBase idLast = last.getDictionaryObject(COSName.ID);        if (idFirst != null && idLast != null) {                if (!(idFirst instanceof COSArray) || !(idLast instanceof COSArray)) {            return false;        }                boolean isEqual = true;        for (COSBase of : ((COSArray) idFirst).toList()) {            boolean oneIsEquals = false;            for (COSBase ol : ((COSArray) idLast).toList()) {                                if (!oneIsEquals) {                    oneIsEquals = ((COSString) ol).getString().equals(((COSString) of).getString());                } else {                    break;                }            }            isEqual &= oneIsEquals;            if (!isEqual) {                break;            }        }        return isEqual;    } else {        return true;    }}
protected void pdfbox_f9004_0(PreflightContext ctx, COSDictionary trailer)
{    boolean id = false;    boolean root = false;    boolean size = false;    boolean prev = false;    boolean info = false;    boolean encrypt = false;    for (COSName cosName : trailer.keySet()) {        if (cosName.equals(COSName.ENCRYPT)) {            encrypt = true;        }        if (cosName.equals(COSName.SIZE)) {            size = true;        }        if (cosName.equals(COSName.PREV)) {            prev = true;        }        if (cosName.equals(COSName.ROOT)) {            root = true;        }        if (cosName.equals(COSName.INFO)) {            info = true;        }        if (cosName.equals(COSName.ID)) {            id = true;        }    }        if (!id) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_ID, "The trailer dictionary doesn't contain ID"));    } else {        COSBase trailerId = trailer.getDictionaryObject(COSName.ID);        if (!(trailerId instanceof COSArray)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains an id but it isn't an array"));        }    }        if (encrypt) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_ENCRYPT, "The trailer dictionary contains Encrypt"));    }        if (!size) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_SIZE, "The trailer dictionary doesn't contain Size"));    } else {        COSBase trailerSize = trailer.getDictionaryObject(COSName.SIZE);        if (!(trailerSize instanceof COSInteger)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a size but it isn't an integer"));        }    }        if (!root) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_MISSING_ROOT, "The trailer dictionary doesn't contain Root"));    } else {        COSBase trailerRoot = trailer.getDictionaryObject(COSName.ROOT);        if (!(trailerRoot instanceof COSDictionary)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a root but it isn't a dictionary"));        }    }        if (prev) {        COSBase trailerPrev = trailer.getDictionaryObject(COSName.PREV);        if (!(trailerPrev instanceof COSInteger)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains a prev but it isn't an integer"));        }    }        if (info) {        COSBase trailerInfo = trailer.getDictionaryObject(COSName.INFO);        if (!(trailerInfo instanceof COSDictionary)) {            addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_TRAILER_TYPE_INVALID, "The trailer dictionary contains an info but it isn't a dictionary"));        }    }}
protected COSDictionary pdfbox_f9005_0(PDDocument document)
{        COSDocument cDoc = document.getDocument();    List<COSObject> lObj = cDoc.getObjects();    for (COSObject object : lObj) {        COSBase curObj = object.getObject();        if (curObj instanceof COSDictionary && ((COSDictionary) curObj).keySet().contains(COSName.getPDFName(DICTIONARY_KEY_LINEARIZED))) {            return (COSDictionary) curObj;        }    }    return null;}
protected void pdfbox_f9006_0(PreflightContext ctx, COSDictionary linearizedDict)
{            boolean l = false;    boolean h = false;    boolean o = false;    boolean e = false;    boolean n = false;    boolean t = false;    for (COSName key : linearizedDict.keySet()) {        String cosName = key.getName();        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_L)) {            l = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_H)) {            h = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_O)) {            o = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_E)) {            e = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_N)) {            n = true;        }        if (cosName.equals(DICTIONARY_KEY_LINEARIZED_T)) {            t = true;        }    }    if (!(l && h && o && e && t && n)) {        addValidationError(ctx, new ValidationError(PreflightConstants.ERROR_SYNTAX_DICT_INVALID, "Invalid key in The Linearized dictionary"));    }}
public void pdfbox_f9007_0(PreflightContext ctx) throws ValidationException
{    COSDocument document = ctx.getDocument().getDocument();    if (document.isXRefStream()) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_TRAILER, "/XRef cross reference streams are not allowed"));    }    if (document.getObjects().size() > PreflightConstants.MAX_INDIRECT_OBJ) {        addValidationError(ctx, new ValidationError(ERROR_SYNTAX_INDIRECT_OBJ_RANGE, "Too many indirect objects"));    }}
public static void pdfbox_f9008_0(PreflightContext context, Object element, String processName) throws ValidationException
{    if (element == null) {        context.addValidationError(new ValidationError(ERROR_PDF_PROCESSING_MISSING, "Unable to process an element if it is null."));    } else {        callValidation(context, element, processName);    }}
private static void pdfbox_f9009_0(PreflightContext context, Object element, String processName) throws ValidationException
{    PreflightPath validationPath = context.getValidationPath();    if (hasRecursion(context, element, validationPath)) {        return;    }        if (element instanceof COSObjectable &&     (PreflightConfiguration.GRAPHIC_PROCESS.equals(processName) ||     PreflightConfiguration.FONT_PROCESS.equals(processName))) {                COSBase cos = ((COSObjectable) element).getCOSObject();        if (context.isInProcessedSet(cos)) {            return;        }        context.addToProcessedSet(cos);    }    boolean needPop = validationPath.pushObject(element);    PreflightConfiguration config = context.getConfig();    ValidationProcess process = config.getInstanceOfProcess(processName);    process.validate(context);    if (needPop) {        validationPath.pop();    }}
private static boolean pdfbox_f9010_0(PreflightContext context, Object element, PreflightPath validationPath)
{    if (element instanceof PDResources || element instanceof PDFormXObject) {        for (int i = 0; i < validationPath.size(); ++i) {            Object obj = validationPath.getPathElement(i, Object.class);            if (obj instanceof COSObjectable) {                COSObjectable cos = (COSObjectable) obj;                if (cos.getCOSObject() == ((COSObjectable) element).getCOSObject()) {                    context.addValidationError(new ValidationError(ERROR_PDF_PROCESSING, element.getClass().getSimpleName() + " recursion"));                    return true;                }            }        }    }    return false;}
public static void pdfbox_f9011_0(PreflightContext context, String processName) throws ValidationException
{    callValidation(context, null, processName);}
public static void pdfbox_f9012_0(PreflightContext context, String filter)
{    PreflightDocument preflightDocument = context.getDocument();    switch(preflightDocument.getSpecification()) {        case PDF_A1A:            isAuthorizedFilterInPDFA(context, filter);            break;        default:                        isAuthorizedFilterInPDFA(context, filter);            break;    }}
public static void pdfbox_f9013_0(PreflightContext context, String filter)
{    if (filter != null) {                if (STREAM_DICTIONARY_VALUE_FILTER_LZW.equals(filter) || INLINE_DICTIONARY_VALUE_FILTER_LZW.equals(filter)) {            context.addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_INVALID_FILTER, "LZWDecode is forbidden"));            return;        }                if (!ALLOWED_FILTERS.contains(filter)) {            context.addValidationError(new ValidationError(ERROR_SYNTAX_STREAM_UNDEFINED_FILTER, "This filter isn't defined in the PDF Reference Third Edition : " + filter));        }    }}
public static boolean pdfbox_f9014_0(String riArg)
{    return RENDERING_INTENTS.contains(riArg);}
public void pdfbox_f9015_0(ValidationResult otherResult)
{    if (otherResult != null) {        this.lErrors.addAll(otherResult.getErrorsList());        this.isValid &= otherResult.isValid();    }}
public XMPMetadata pdfbox_f9016_0()
{    return xmpMetaData;}
 void pdfbox_f9017_0(XMPMetadata xmpMetaData)
{    this.xmpMetaData = xmpMetaData;}
public boolean pdfbox_f9018_0()
{    return isValid;}
public void pdfbox_f9019_0(ValidationError error)
{    if (error != null) {        this.isValid &= error.isWarning();        this.lErrors.add(error);    }}
public void pdfbox_f9020_0(List<ValidationError> errors)
{    if (errors != null) {        for (ValidationError validationError : errors) {            addError(validationError);        }    }}
public List<ValidationError> pdfbox_f9021_0()
{    return this.lErrors;}
public Throwable pdfbox_f9022_0()
{    return t;}
public Throwable pdfbox_f9023_0()
{    return cause;}
public Integer pdfbox_f9024_0()
{    return pageNumber;}
public void pdfbox_f9025_0(Integer pageNumber)
{    this.pageNumber = pageNumber;}
public String pdfbox_f9026_0()
{    return errorCode;}
public String pdfbox_f9027_0()
{    return details;}
public void pdfbox_f9028_0(String details)
{    this.details = details;}
public boolean pdfbox_f9029_0()
{    return isWarning;}
public void pdfbox_f9030_0(boolean isWarning)
{    this.isWarning = isWarning;}
public int pdfbox_f9031_0()
{    return errorCode.hashCode();}
public boolean pdfbox_f9032_0(Object o)
{    if (o instanceof ValidationError) {        ValidationError ve = (ValidationError) o;                if (!errorCode.equals(ve.errorCode)) {            return false;        } else if (!details.equals(ve.details)) {            return false;        } else if (pageNumber != null && ve.pageNumber == null) {            return false;        } else if (pageNumber == null && ve.pageNumber != null) {            return false;        } else if (pageNumber != null && ve.pageNumber != null && pageNumber.compareTo(ve.pageNumber) != 0) {            return false;        }                return isWarning == ve.isWarning;    } else {        return false;    }}
public static void pdfbox_f9033_0(String[] args) throws IOException, TransformerException, ParserConfigurationException
{    if (args.length == 0) {        usage();        System.exit(1);    }        int posFile = 0;    boolean outputXml = "xml".equals(args[posFile]);    posFile += outputXml ? 1 : 0;        boolean isGroup = "group".equals(args[posFile]);    posFile += isGroup ? 1 : 0;        boolean isBatch = "batch".equals(args[posFile]);    posFile += isBatch ? 1 : 0;    if (isGroup || isBatch) {                List<File> ftp = listFiles(args[posFile]);        int status = 0;        if (!outputXml) {                        for (File file2 : ftp) {                status |= runSimple(file2);            }            System.exit(status);        } else {            Transformer transformer = TransformerFactory.newInstance().newTransformer();            transformer.setOutputProperty(OutputKeys.INDENT, "yes");            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");            XmlResultParser xrp = new XmlResultParser();            if (isGroup) {                Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();                Element root = document.createElement("preflights");                document.appendChild(root);                root.setAttribute("count", String.format("%d", ftp.size()));                for (File file : ftp) {                    Element result = xrp.validate(document, file);                    root.appendChild(result);                }                transformer.transform(new DOMSource(document), new StreamResult(new File(args[posFile] + ".preflight.xml")));            } else {                                for (File file : ftp) {                    Element result = xrp.validate(file);                    Document document = result.getOwnerDocument();                    document.appendChild(result);                    transformer.transform(new DOMSource(document), new StreamResult(new File(file.getAbsolutePath() + ".preflight.xml")));                }            }        }    } else {        if (!outputXml) {                        System.exit(runSimple(new File(args[posFile])));        } else {                        XmlResultParser xrp = new XmlResultParser();            Element result = xrp.validate(new File(args[posFile]));            Document document = result.getOwnerDocument();            document.appendChild(result);            Transformer transformer = TransformerFactory.newInstance().newTransformer();            transformer.setOutputProperty(OutputKeys.INDENT, "yes");            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");            transformer.transform(new DOMSource(document), new StreamResult(System.out));        }    }}
private static void pdfbox_f9034_0() throws IOException
{    String version = Version.getVersion();    System.out.println("Usage : java org.apache.pdfbox.preflight.Validator_A1b [xml] [<mode>] <file path>");    System.out.println();    System.out.println(" * xml : if set, generate xml output instead of text");    System.out.println(" * <mode> : if set, <file path> must be a file containing the PDF files to parse. <mode> can have 2 values:");    System.out.println("       batch : generate xml result files for each PDF file in the list");    System.out.println("       group : generate one xml result file for all the PDF files in the list.");    System.out.println("Version : " + version);}
private static int pdfbox_f9035_0(File file) throws IOException
{    ValidationResult result;    PreflightParser parser = new PreflightParser(file);    try {        parser.parse();        try (PreflightDocument document = parser.getPreflightDocument()) {            document.validate();            result = document.getResult();        }    } catch (SyntaxValidationException e) {        result = e.getResult();    }    if (result.isValid()) {        System.out.println("The file " + file.getName() + " is a valid PDF/A-1b file");        System.out.println();        return 0;    } else {        System.out.println("The file " + file.getName() + " is not a valid PDF/A-1b file, error(s) :");        for (ValidationError error : result.getErrorsList()) {            System.out.print(error.getErrorCode() + " : " + error.getDetails());            if (error.getPageNumber() != null) {                System.out.println(" on page " + (error.getPageNumber() + 1));            } else {                System.out.println();            }        }        System.out.println();        return -1;    }}
private static List<File> pdfbox_f9036_0(String path) throws IOException
{    List<File> files = new ArrayList<>();    File f = new File(path);    if (f.isFile()) {        FileReader fr = new FileReader(f);        BufferedReader buf = new BufferedReader(fr);        while (buf.ready()) {            File fn = new File(buf.readLine());            if (fn.exists()) {                files.add(fn);            }                }        IOUtils.closeQuietly(buf);    } else {        File[] fileList = f.listFiles();        if (fileList != null) {            files.addAll(Arrays.asList(fileList));        }    }    return files;}
protected void pdfbox_f9037_0()
{    COSBase smask = xobject.getCOSDictionary(COSName.SMASK);    if (smask != null && !(smask instanceof COSName && COSName.NONE.equals(smask))) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_SMASK, "Soft Mask must be null or None [" + xobject.toString() + "]"));    }}
protected void pdfbox_f9038_0()
{        if (this.xobject.getItem(COSName.getPDFName("OPI")) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'OPI' Key"));    }}
protected void pdfbox_f9039_0()
{        if (this.xobject.getItem("Ref") != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "No reference XObject allowed in PDF/A"));    }}
protected void pdfbox_f9040_0()
{        COSName subtype = this.xobject.getCOSName(COSName.SUBTYPE);    if (COSName.PS.equals(subtype)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "No Postscript XObject allowed in PDF/A"));    } else if (this.xobject.getItem(COSName.getPDFName("Subtype2")) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "No Postscript XObject allowed in PDF/A (Subtype2)"));    }}
public void pdfbox_f9041_0() throws ValidationException
{    checkMandatoryFields();    checkOPI();    checkSMask();    checkReferenceXObject();    checkPostscriptXObject();}
public void pdfbox_f9042_0() throws ValidationException
{    super.validate();    checkGroup();    checkSubtype2Value();    validateXObjectResources();    validateXObjectContent();}
protected void pdfbox_f9043_0()
{    boolean lastMod = this.xobject.getItem(COSName.LAST_MODIFIED) != null;    boolean pieceInfo = this.xobject.getItem("PieceInfo") != null;        if (lastMod ^ pieceInfo) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_MISSING_FIELD));        return;    }    COSArray bbArray = this.xobject.getCOSArray(COSName.BBOX);        if (bbArray == null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_BBOX));    }}
protected void pdfbox_f9044_0() throws ValidationException
{    PreflightPath vPath = context.getValidationPath();    PreflightContentStream csWrapper = new PreflightContentStream(context, vPath.getClosestPathElement(PDPage.class));    csWrapper.validateXObjContentStream(pdXObj);}
protected void pdfbox_f9045_0()
{    COSDictionary groupDictionary = this.xobject.getCOSDictionary(COSName.GROUP);    if (groupDictionary != null) {        if (!COSName.GROUP.equals(groupDictionary.getCOSName(COSName.TYPE))) {            context.addValidationError(new ValidationError(PreflightConstants.ERROR_GRAPHIC_MISSING_FIELD, "The Group dictionary hasn't Group as Type value"));        } else {            COSName sVal = groupDictionary.getCOSName(COSName.S);            if (sVal == null || COSName.TRANSPARENCY.equals(sVal)) {                context.addValidationError(new ValidationError(ERROR_GRAPHIC_TRANSPARENCY_GROUP, "Group has a transparency S entry or the S entry is null [" + xobject.toString() + "]"));            }        }    }}
protected void pdfbox_f9046_0()
{        if (this.xobject.getItem(COSName.PS) != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'PS' Key"));    }}
protected void pdfbox_f9047_0()
{        if (this.xobject.getItem(COSName.getPDFName("Subtype2")) != null && "PS".equals(this.xobject.getNameAsString("Subtype2"))) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected 'PS' value for 'Subtype2' Key"));    }}
protected void pdfbox_f9048_0() throws ValidationException
{    PDResources resources = this.pdXObj.getResources();    if (resources != null) {        ContextHelper.validateElement(context, resources, RESOURCES_PROCESS);    }}
protected void pdfbox_f9049_0()
{    boolean res = this.xobject.getItem(COSName.WIDTH) != null;    res = res && this.xobject.getItem(COSName.HEIGHT) != null;        if (!res) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_MISSING_FIELD));    }}
protected void pdfbox_f9050_0() throws ValidationException
{    if (this.xobject.getItem("Alternates") != null) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "Unexpected 'Alternates' Key"));    }}
protected void pdfbox_f9051_0() throws ValidationException
{    if (this.xobject.getItem(COSName.INTERPOLATE) != null && this.xobject.getBoolean(COSName.INTERPOLATE, true)) {        context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected 'true' value for 'Interpolate' Key"));    }}
protected void pdfbox_f9052_0() throws ValidationException
{    if (this.xobject.getItem("Intent") != null) {        String s = this.xobject.getNameAsString("Intent");        if (!RenderingIntents.contains(s)) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "Unexpected value '" + s + "' for Intent key in image"));        }    }}
protected void pdfbox_f9053_1() throws ValidationException
{    COSBase csImg = this.xobject.getItem(COSName.COLORSPACE);    COSBase bitsPerComp = this.xobject.getDictionaryObject(COSName.BITS_PER_COMPONENT);    COSBase mask = this.xobject.getItem(COSName.MASK);    if (isImageMaskTrue()) {        if (csImg != null || mask != null) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_KEY, "ImageMask entry is true, ColorSpace and Mask are forbidden."));        }        if (bitsPerComp instanceof COSInteger && ((COSInteger) bitsPerComp).intValue() != 1) {            context.addValidationError(new ValidationError(ERROR_GRAPHIC_UNEXPECTED_VALUE_FOR_KEY, "ImageMask entry is true, BitsPerComponent must be absent or 1."));        }    } else {        try {            PreflightConfiguration config = context.getConfig();            ColorSpaceHelperFactory csFact = config.getColorSpaceHelperFact();            PDColorSpace pdCS = PDColorSpace.create(csImg);            ColorSpaceHelper csh = csFact.getColorSpaceHelper(context, pdCS, ColorSpaceRestriction.NO_PATTERN);            csh.validate();        } catch (IOException e) {                        context.addValidationError(new ValidationError(ERROR_GRAPHIC_INVALID_UNKNOWN_COLOR_SPACE));        }    }}
private boolean pdfbox_f9054_0()
{    COSBase imgMask = this.xobject.getItem("ImageMask");    if (imgMask instanceof COSBoolean) {        return ((COSBoolean) imgMask).getValue();    } else {        return false;    }}
public void pdfbox_f9055_0() throws ValidationException
{    super.validate();    checkAlternates();    checkInterpolate();    checkIntent();    checkColorSpaceAndImageMask();}
protected void pdfbox_f9056_0()
{}
protected PreflightContext pdfbox_f9057_0() throws Exception
{    PDDocument doc = PDDocument.load(new File("src/test/resources/pdfa-with-annotations-square.pdf"));    PreflightDocument preflightDocument = new PreflightDocument(doc.getDocument(), Format.PDF_A1B);    PreflightContext ctx = new PreflightContext();    ctx.setDocument(preflightDocument);    preflightDocument.setContext(ctx);    return ctx;}
protected void pdfbox_f9058_0(PDAction action, boolean valid) throws Exception
{    valid(action, valid, null);}
protected void pdfbox_f9059_0(COSDictionary action, boolean valid) throws Exception
{    valid(action, valid, null);}
protected void pdfbox_f9060_0(PDAction action, boolean valid, String expectedCode) throws Exception
{    valid(action.getCOSObject(), valid, expectedCode);}
protected void pdfbox_f9061_0(COSDictionary action, boolean valid, String expectedCode) throws Exception
{    ActionManagerFactory fact = new ActionManagerFactory();    PreflightContext ctx = createContext();    ctx.setConfig(PreflightConfiguration.createPdfA1BConfiguration());    COSDictionary dict = new COSDictionary();    dict.setItem(COSName.A, action);        List<AbstractActionManager> actions = fact.getActionManagers(ctx, dict);    for (AbstractActionManager abstractActionManager : actions) {        abstractActionManager.valid();    }        if (!valid) {        List<ValidationError> errors = ctx.getDocument().getResult().getErrorsList();        assertFalse(errors.isEmpty());        if (expectedCode != null || !"".equals(expectedCode)) {            boolean found = false;            for (ValidationError err : errors) {                if (err.getErrorCode().equals(expectedCode)) {                    found = true;                    break;                }            }            assertTrue(found);        }    } else {        if (ctx.getDocument().getResult() != null) {            List<ValidationError> errors = ctx.getDocument().getResult().getErrorsList();            assertTrue(errors.isEmpty());        }    }    ctx.getDocument().close();}
protected COSDictionary pdfbox_f9062_0(String type)
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName(type));    return action;}
public void pdfbox_f9063_0() throws Exception
{    COSDictionary action = createAction("Launch");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9064_0() throws Exception
{    COSDictionary action = createAction("Sound");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9065_0() throws Exception
{    COSDictionary action = createAction("Movie");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9066_0() throws Exception
{    COSDictionary action = createAction("ImportData");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9067_0() throws Exception
{    COSDictionary action = createAction("ResetForm");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9068_0() throws Exception
{    COSDictionary action = createAction("JavaScript");    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public void pdfbox_f9069_0() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    gotoAction.setDestination(new PDDestination() {        @Override        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }    });    valid(gotoAction, true);}
public COSBase pdfbox_f9070_0()
{    return COSName.getPDFName("ADest");}
public void pdfbox_f9071_0() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    gotoAction.setDestination(new PDDestination() {        @Override        public COSBase getCOSObject() {            return new COSDictionary();        }    });    valid(gotoAction, false, PreflightConstants.ERROR_SYNTAX_DICT_INVALID);}
public COSBase pdfbox_f9072_0()
{    return new COSDictionary();}
public void pdfbox_f9073_0() throws Exception
{    PDActionGoTo gotoAction = new PDActionGoTo();    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public void pdfbox_f9074_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(COSName.getPDFName("ADest"));    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, true);}
public COSBase pdfbox_f9075_0()
{    return COSName.getPDFName("ADest");}
public void pdfbox_f9076_0(String file)
{}
public String pdfbox_f9077_0()
{    return "pouey";}
public void pdfbox_f9078_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(new COSDictionary());    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
public COSBase pdfbox_f9079_0()
{    return COSName.getPDFName("ADest");}
public void pdfbox_f9080_0(String file)
{}
public String pdfbox_f9081_0()
{    return "pouey";}
public void pdfbox_f9082_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setFile(new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("ADest");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return "pouey";        }    });    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public COSBase pdfbox_f9083_0()
{    return COSName.getPDFName("ADest");}
public void pdfbox_f9084_0(String file)
{}
public String pdfbox_f9085_0()
{    return "pouey";}
public void pdfbox_f9086_0() throws Exception
{    PDActionRemoteGoTo gotoAction = new PDActionRemoteGoTo();    gotoAction.setD(COSName.getPDFName("ADest"));    valid(gotoAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
protected COSDictionary pdfbox_f9087_0()
{    COSDictionary hideAction = new COSDictionary();    hideAction.setItem(COSName.TYPE, COSName.getPDFName("Action"));    hideAction.setItem(COSName.S, COSName.getPDFName("Hide"));    hideAction.setBoolean(COSName.H, false);    hideAction.setString(COSName.T, "avalue");    return hideAction;}
public void pdfbox_f9088_0() throws Exception
{    COSDictionary action = createHideAction();    valid(action, true);}
public void pdfbox_f9089_0() throws Exception
{    COSDictionary action = createHideAction();    action.setBoolean(COSName.H, true);    valid(action, false, PreflightConstants.ERROR_ACTION_HIDE_H_INVALID);}
public void pdfbox_f9090_0() throws Exception
{    COSDictionary action = createHideAction();    action.setBoolean(COSName.T, true);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
public void pdfbox_f9091_0() throws Exception
{    COSDictionary action = createHideAction();    action.removeItem(COSName.T);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
protected COSDictionary pdfbox_f9092_0()
{    COSDictionary namedAction = new COSDictionary();    namedAction.setItem(COSName.TYPE, COSName.getPDFName("Action"));    namedAction.setItem(COSName.S, COSName.getPDFName("Named"));    return namedAction;}
public void pdfbox_f9093_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_FIRST));    valid(namedAction, true);}
public void pdfbox_f9094_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_LAST));    valid(namedAction, true);}
public void pdfbox_f9095_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_NEXT));    valid(namedAction, true);}
public void pdfbox_f9096_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName(PreflightConstants.ACTION_DICTIONARY_VALUE_ATYPE_NAMED_PREV));    valid(namedAction, true);}
public void pdfbox_f9097_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    valid(namedAction, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public void pdfbox_f9098_0() throws Exception
{    COSDictionary namedAction = createNamedAction();    namedAction.setItem(COSName.N, COSName.getPDFName("unknown"));    valid(namedAction, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_NAMED);}
protected COSDictionary pdfbox_f9099_0()
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName("SubmitForm"));    action.setItem(COSName.F, new PDFileSpecification() {        public COSBase getCOSObject() {            return COSName.getPDFName("value");        }        @Override        public void setFile(String file) {        }        @Override        public String getFile() {            return null;        }    });    return action;}
public COSBase pdfbox_f9100_0()
{    return COSName.getPDFName("value");}
public void pdfbox_f9101_0(String file)
{}
public String pdfbox_f9102_0()
{    return null;}
public void pdfbox_f9103_0() throws Exception
{    COSDictionary action = createSubmitAction();    valid(action, true);}
public void pdfbox_f9104_0() throws Exception
{    COSDictionary action = createSubmitAction();    action.removeItem(COSName.F);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
protected COSDictionary pdfbox_f9105_0()
{    COSDictionary action = new COSDictionary();    action.setItem(COSName.TYPE, COSName.getPDFName("Action"));    action.setItem(COSName.S, COSName.getPDFName("Thread"));    action.setInt(COSName.D, 1);    return action;}
public void pdfbox_f9106_0() throws Exception
{    COSDictionary action = createSubmitAction();    valid(action, true);}
public void pdfbox_f9107_0() throws Exception
{    COSDictionary action = createSubmitAction();    action.removeItem(COSName.D);    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public void pdfbox_f9108_0() throws Exception
{    COSDictionary action = createSubmitAction();    action.setBoolean(COSName.D, false);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
protected PDActionURI pdfbox_f9109_0()
{    PDActionURI action = new PDActionURI();    action.setURI("http://www.apache.org");    return action;}
public void pdfbox_f9110_0() throws Exception
{    PDAction action = createAction();    valid(action, true);}
public void pdfbox_f9111_0() throws Exception
{    PDActionURI action = new PDActionURI();    valid(action, false, PreflightConstants.ERROR_ACTION_MISING_KEY);}
public void pdfbox_f9112_0() throws Exception
{    PDActionURI action = new PDActionURI();    action.getCOSObject().setBoolean(COSName.URI, true);    valid(action, false, PreflightConstants.ERROR_ACTION_INVALID_TYPE);}
public void pdfbox_f9113_0() throws Exception
{    PDActionURI action = createAction();    action.setNext(Arrays.asList(createAction()));    valid(action, true);}
public void pdfbox_f9114_0() throws Exception
{    PDActionURI action = createAction();    action.setNext(Arrays.asList(new PDActionJavaScript()));    valid(action, false, PreflightConstants.ERROR_ACTION_FORBIDDEN_ACTIONS_EXPLICITLY_FORBIDDEN);}
public static void pdfbox_f9115_0(String[] args) throws Exception
{    if (args.length < 3) {        System.err.println("Usage : Benchmark loop resultFile <file1 ... filen|dir>");        System.exit(255);    }    Integer loop = Integer.parseInt(args[0]);    FileWriter resFile = new FileWriter(new File(args[1]));    List<File> lfd = new ArrayList<>();    for (int i = 2; i < args.length; ++i) {        File fi = new File(args[i]);        if (fi.isDirectory()) {                        Collection<File> cf = FileUtils.listFiles(fi, null, true);            lfd.addAll(cf);        } else {            lfd.add(fi);        }    }    SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss.Z");    long startGTime = System.currentTimeMillis();    int size = lfd.size();    for (int i = 0; i < loop; i++) {        File file = lfd.get(i % size);        long startLTime = System.currentTimeMillis();        PreflightParser parser = new PreflightParser(file);        parser.parse();        try (PreflightDocument document = parser.getPreflightDocument()) {            document.validate();            ValidationResult result = document.getResult();            if (!result.isValid()) {                resFile.write(file.getAbsolutePath() + " isn't PDF/A\n");                for (ValidationError error : result.getErrorsList()) {                    resFile.write(error.getErrorCode() + " : " + error.getDetails() + "\n");                }            }        }        long endLTime = System.currentTimeMillis();        resFile.write(file.getName() + " (ms) : " + (endLTime - startLTime) + "\n");        resFile.flush();    }    long endGTime = System.currentTimeMillis();    resFile.write("Start : " + sdf.format(new Date(startGTime)) + "\n");    resFile.write("End : " + sdf.format(new Date(endGTime)) + "\n");    resFile.write("Duration (ms) : " + (endGTime - startGTime) + "\n");    resFile.write("Average (ms) : " + (int) ((endGTime - startGTime) / loop) + "\n");    System.out.println("Start : " + sdf.format(new Date(startGTime)));    System.out.println("End : " + sdf.format(new Date(endGTime)));    System.out.println("Duration (ms) : " + (endGTime - startGTime));    System.out.println("Average (ms) : " + (int) ((endGTime - startGTime) / loop));    resFile.flush();    IOUtils.closeQuietly(resFile);}
public final void pdfbox_f9116_1() throws Exception
{    if (path == null) {                return;    }    PreflightDocument document = null;    try {        PreflightParser parser = new PreflightParser(path);        parser.parse();        document = parser.getPreflightDocument();        document.validate();        ValidationResult result = document.getResult();        Assert.assertFalse(path + " : Isartor file should be invalid (" + path + ")", result.isValid());        Assert.assertTrue(path + " : Should find at least one error", result.getErrorsList().size() > 0);                boolean found = false;        if (this.expectedError != null) {            for (ValidationError error : result.getErrorsList()) {                if (error.getErrorCode().equals(this.expectedError)) {                    found = true;                    if (outputResult == null) {                        break;                    }                }                if (outputResult != null) {                    String log = path.getName().replace(".pdf", "") + "#" + error.getErrorCode() + "#" + error.getDetails() + "\n";                    outputResult.write(log.getBytes());                }            }        }        if (result.getErrorsList().size() > 0) {            if (this.expectedError == null) {                            } else if (!found) {                StringBuilder message = new StringBuilder(100);                message.append(path).append(" : Invalid error code returned. Expected ");                message.append(this.expectedError).append(", found ");                for (ValidationError error : result.getErrorsList()) {                    message.append(error.getErrorCode()).append(" ");                }                Assert.fail(message.toString());            }        } else {            Assert.assertEquals(path + " : Invalid error code returned.", this.expectedError, result.getErrorsList().get(0).getErrorCode());        }    } catch (ValidationException e) {        throw new Exception(path + " :" + e.getMessage(), e);    } finally {        if (document != null) {            document.close();        }    }}
public void pdfbox_f9117_0() throws Exception
{    String irp = System.getProperty(getResultFileKey());    if (irp == null) {                outputResult = System.err;    } else {        outputResult = new FileOutputStream(irp);    }}
public void pdfbox_f9118_0() throws Exception
{    IOUtils.closeQuietly(outputResult);}
protected static Collection<Object[]> pdfbox_f9119_0() throws Exception
{    List<Object[]> ret = new ArrayList<>();    ret.add(new Object[] { null, null });    return ret;}
protected String pdfbox_f9121_0()
{    return RESULTS_FILE;}
protected static Collection<Object[]> pdfbox_f9122_0() throws Exception
{    List<Object[]> ret = new ArrayList<>();    ret.add(new Object[] { null, null });    return ret;}
protected String pdfbox_f9124_0()
{    return RESULTS_FILE;}
protected static Collection<Object[]> pdfbox_f9125_0() throws Exception
{        List<Object[]> ret = new ArrayList<>();    ret.add(new Object[] { null });    return ret;}
public static void pdfbox_f9127_0() throws Exception
{    String irp = System.getProperty(RESULTS_FILE);    if (irp == null) {                System.err.println("No result file defined, will use standard error");        isartorResultFile = System.err;    } else {        isartorResultFile = new FileOutputStream(irp);    }}
public static void pdfbox_f9128_0() throws Exception
{    IOUtils.closeQuietly(isartorResultFile);}
public void pdfbox_f9129_1() throws Exception
{    if (path == null) {                return;    }    PreflightDocument document = null;    try {        PreflightParser parser = new PreflightParser(path);        parser.parse();        document = parser.getPreflightDocument();        document.validate();        ValidationResult result = document.getResult();        Assert.assertFalse(path + " : Isartor file should be invalid (" + path + ")", result.isValid());        Assert.assertTrue(path + " : Should find at least one error", result.getErrorsList().size() > 0);                if (result.getErrorsList().size() > 0) {            Assert.fail("File expected valid : " + path.getAbsolutePath());        }    } catch (ValidationException e) {        throw new Exception(path + " :" + e.getMessage(), e);    } finally {        if (document != null) {            document.close();        }    }}
public void pdfbox_f9130_0() throws Exception
{    String testfileDirectory = "src/test/resources/org/apache/pdfbox/preflight/metadata/";    File validFile = new File(testfileDirectory + "PDFAMetaDataValidationTestTrailingNul.pdf");    assertTrue("Metadata test file " + validFile + " has to be valid ", checkPDF(validFile));    File invalidFile1 = new File(testfileDirectory + "PDFAMetaDataValidationTestTrailingSpaces.pdf");    assertFalse("Metadata test file " + invalidFile1 + " has to be invalid ", checkPDF(invalidFile1));    File invalidFile2 = new File(testfileDirectory + "PDFAMetaDataValidationTestTrailingControlChar.pdf");    assertFalse("Metadata test file " + invalidFile2 + " has to be invalid ", checkPDF(invalidFile2));    File invalidFile3 = new File(testfileDirectory + "PDFAMetaDataValidationTestMiddleNul.pdf");    assertFalse("Metadata test file " + invalidFile3 + " has to be invalid ", checkPDF(invalidFile3));    File invalidFile4 = new File(testfileDirectory + "PDFAMetaDataValidationTestMiddleControlChar.pdf");    assertFalse("Metadata test file " + invalidFile4 + " has to be invalid ", checkPDF(invalidFile4));}
private boolean pdfbox_f9131_0(File pdf)
{    PreflightDocument document = null;    boolean testResult = false;    if (pdf.exists()) {        ValidationResult result = null;        try {            PreflightParser parser = new PreflightParser(pdf);            parser.parse();            document = (PreflightDocument) parser.getPDDocument();            document.validate();            result = document.getResult();        } catch (SyntaxValidationException e) {            result = e.getResult();        } catch (IOException e) {            fail("An exception occured while parsing the PDF " + pdf + ": " + e);        }        if (result != null) {            testResult = result.isValid();        }        if (document != null) {            try {                document.close();            } catch (IOException e) {                        }        }    } else {        fail("Can't find the given file " + pdf);    }    return testResult;}
public static void pdfbox_f9132_0()
{    sync = new SynchronizedMetaDataValidation();}
public void pdfbox_f9133_0() throws Exception
{    doc = new PDDocument();    dico = doc.getDocumentInformation();    metadata = XMPMetadata.createXMPMetadata();}
public void pdfbox_f9134_0() throws ValidationException
{    sync.validateMetadataSynchronization(null, metadata);}
public void pdfbox_f9135_0() throws ValidationException
{    sync.validateMetadataSynchronization(doc, null);}
public void pdfbox_f9136_0() throws Exception
{    try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(0, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9137_0() throws Exception
{    initValues();            dico.setTitle(title);        dico.setAuthor(author);        dico.setSubject(subject);        dico.setKeywords(keywords);        dico.setCreator(creator);        dico.setProducer(producer);        dico.setCreationDate(creationDate);        dico.setModificationDate(modifyDate);    try {        ve = sync.validateMetadataSynchronization(doc, metadata);                for (ValidationError valid : ve) {            Assert.assertEquals(PreflightConstants.ERROR_METADATA_MISMATCH, valid.getErrorCode());        }    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9138_0() throws Exception
{    initValues();        metadata.createAndAddDublinCoreSchema();    metadata.createAndAddAdobePDFSchema();    metadata.createAndAddXMPBasicSchema();            dico.setTitle(title);        dico.setAuthor(author);        dico.setSubject(subject);        dico.setKeywords(keywords);        dico.setCreator(creator);        dico.setProducer(producer);        dico.setCreationDate(creationDate);        dico.setModificationDate(modifyDate);    try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(8, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9139_0() throws Exception
{        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();        dico.setAuthor("dicoAuthor");    dc.addCreator(null);        dico.setSubject("dicoSubj");    dc.addSubject(null);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(2, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9140_0() throws Exception
{        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();            dico.setTitle("dicoTitle");    dc.setTitle("x-default", "XMPTitle");        dico.setAuthor("dicoAuthor");    dc.addCreator("XMPAuthor");    dc.addCreator("2ndCreator");        dico.setSubject("dicoSubj");    dc.addSubject("XMPSubj");    dc.addSubject("2ndSubj");        dico.setKeywords("DicoKeywords");    pdf.setKeywords("XMPkeywords");        dico.setCreator("DicoCreator");    xmp.setCreatorTool("XMPCreator");        dico.setProducer("DicoProducer");    pdf.setProducer("XMPProducer");        dico.setCreationDate(Calendar.getInstance());    GregorianCalendar XMPCreate = new GregorianCalendar(2008, 11, 05);    xmp.setCreateDate(XMPCreate);        dico.setModificationDate(Calendar.getInstance());    GregorianCalendar XMPModify = new GregorianCalendar(2009, 10, 15);    xmp.setModifyDate(XMPModify);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(8, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9141_0() throws Exception
{        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();            dico.setTitle("dicoTitle");    dc.setTitle("x-default", "XMPTitle");        dico.setAuthor("dicoAuthor");    dc.addCreator("XMPAuthor");        dico.setSubject("dicoSubj");    dc.addSubject("XMPSubj");        dico.setKeywords("DicoKeywords");    pdf.setKeywords("XMPkeywords");        dico.setCreator("DicoCreator");    xmp.setCreatorTool("XMPCreator");        dico.setProducer("DicoProducer");    pdf.setProducer("XMPProducer");        dico.setCreationDate(Calendar.getInstance());    GregorianCalendar XMPCreate = new GregorianCalendar(2008, 11, 05);    xmp.setCreateDate(XMPCreate);        dico.setModificationDate(Calendar.getInstance());    GregorianCalendar XMPModify = new GregorianCalendar(2009, 10, 15);    xmp.setModifyDate(XMPModify);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(8, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9142_0() throws Exception
{    initValues();        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();            dico.setTitle(title);    dc.setTitle("x-default", title);        dico.setAuthor(author);    dc.addCreator(author);        dico.setSubject(subject);    dc.addDescription("x-default", subject);        dico.setKeywords(keywords);    pdf.setKeywords(keywords);        dico.setCreator(creator);    xmp.setCreatorTool(creator);        dico.setProducer(producer);    pdf.setProducer(producer);        dico.setCreationDate(creationDate);    xmp.setCreateDate(creationDate);        dico.setModificationDate(modifyDate);    xmp.setModifyDate(modifyDate);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(0, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9143_0() throws Exception
{    Throwable cause = new Throwable();    Assert.assertSame(cause, sync.schemaAccessException("test", cause).getCause());}
public void pdfbox_f9144_0() throws Exception
{    initValues();        DublinCoreSchema dc = new DublinCoreSchema(metadata, "dctest");    metadata.addSchema(dc);    XMPBasicSchema xmp = new XMPBasicSchema(metadata, "xmptest");    metadata.addSchema(xmp);    AdobePDFSchema pdf = new AdobePDFSchema(metadata, "pdftest");    metadata.addSchema(pdf);            dico.setTitle(title);    dc.setTitle("x-default", title);        dico.setAuthor(author);    dc.addCreator(author);        dico.setSubject(subject);    dc.addDescription("x-default", subject);        dico.setKeywords(keywords);    pdf.setKeywords(keywords);        dico.setCreator(creator);    xmp.setCreatorTool(creator);        dico.setProducer(producer);    pdf.setProducer(producer);        dico.setCreationDate(creationDate);    xmp.setCreateDate(creationDate);        dico.setModificationDate(modifyDate);    xmp.setModifyDate(modifyDate);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);        for (ValidationError valid : ve) {            Assert.assertEquals(PreflightConstants.ERROR_METADATA_WRONG_NS_PREFIX, valid.getErrorCode());        }    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9145_0() throws Exception
{    initValues();        DublinCoreSchema dc = metadata.createAndAddDublinCoreSchema();    DublinCoreSchema dc2 = new DublinCoreSchema(metadata, "dctest");    metadata.addSchema(dc2);    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();    XMPBasicSchema xmp2 = new XMPBasicSchema(metadata, "xmptest");    metadata.addSchema(xmp2);    AdobePDFSchema pdf = metadata.createAndAddAdobePDFSchema();    AdobePDFSchema pdf2 = new AdobePDFSchema(metadata, "pdftest");    metadata.addSchema(pdf2);        dc2.setCoverage("tmpcover");    xmp2.setCreatorTool("tmpcreator");    pdf2.setKeywords("tmpkeys");            dico.setTitle(title);    dc.setTitle("x-default", title);        dico.setAuthor(author);    dc.addCreator(author);        dico.setSubject(subject);    dc.addDescription("x-default", subject);        dico.setKeywords(keywords);    pdf.setKeywords(keywords);        dico.setCreator(creator);    xmp.setCreatorTool(creator);        dico.setProducer(producer);    pdf.setProducer(producer);        dico.setCreationDate(creationDate);    xmp.setCreateDate(creationDate);        dico.setModificationDate(modifyDate);    xmp.setModifyDate(modifyDate);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);        Assert.assertTrue(ve.isEmpty());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9146_0() throws Exception
{    initValues();    Calendar cal1 = org.apache.pdfbox.util.DateConverter.toCalendar("20180817115837+02'00'");    Calendar cal2 = org.apache.xmpbox.DateConverter.toCalendar("2018-08-17T09:58:37Z");    XMPBasicSchema xmp = metadata.createAndAddXMPBasicSchema();    dico.setCreationDate(cal1);    xmp.setCreateDate(cal2);    dico.setModificationDate(cal1);    xmp.setModifyDate(cal2);        try {        ve = sync.validateMetadataSynchronization(doc, metadata);                Assert.assertEquals(0, ve.size());    } catch (ValidationException e) {        throw new Exception(e.getMessage());    }}
public void pdfbox_f9147_0() throws Exception
{    try {        doc.close();    } catch (IOException e) {        throw new Exception("Error while closing PDF Document");    }/*         * Iterator<ValidationError> it=ve.iterator(); while(it.hasNext()){ ValidationError tmp=it.next();         * System.out.println("Error:"+ tmp.getDetails()+"\n code: "+tmp.getErrorCode()); }         */}
private void pdfbox_f9148_0()
{    title = "TITLE";    author = "AUTHOR(S)";    subject = "SUBJECTS";    keywords = "KEYWORD(S)";    creator = "CREATOR";    producer = "PRODUCER";    creationDate = Calendar.getInstance();    modifyDate = Calendar.getInstance();                creationDate.set(Calendar.MILLISECOND, 0);    modifyDate.set(Calendar.MILLISECOND, 0);}
public void pdfbox_f9149_0() throws Exception
{    PreflightConfiguration configuration = PreflightConfiguration.createPdfA1BConfiguration();    configuration.getInstanceOfProcess("unknownProcess");}
public void pdfbox_f9150_0() throws Exception
{    PreflightConfiguration configuration = PreflightConfiguration.createPdfA1BConfiguration();    configuration.setErrorOnMissingProcess(false);    configuration.getInstanceOfProcess("unknownProcess");}
public void pdfbox_f9151_0() throws Exception
{    PreflightConfiguration configuration = PreflightConfiguration.createPdfA1BConfiguration();    String processName = "mock-process";    configuration.replaceProcess(processName, MockProcess.class);    assertEquals(MockProcess.class, configuration.getInstanceOfProcess(processName).getClass());    configuration.replaceProcess(processName, MockProcess2.class);    assertEquals(MockProcess2.class, configuration.getInstanceOfProcess(processName).getClass());}
public void pdfbox_f9152_0(PreflightContext ctx) throws ValidationException
{}
public void pdfbox_f9153_0(PreflightContext ctx) throws ValidationException
{}
public void pdfbox_f9154_0() throws Exception
{    document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();    preflight = parser.generateResponseSkeleton(document, "myname", 14);    xpath = XPathFactory.newInstance().newXPath();}
public void pdfbox_f9155_0() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError("7"));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='1']", preflight, XPathConstants.NODE));    NodeList nl = (NodeList) xpath.evaluate("errors/error[@count='1']", preflight, XPathConstants.NODESET);    Assert.assertEquals(1, nl.getLength());}
public void pdfbox_f9156_0() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError("7"));    result.addError(new ValidationResult.ValidationError(ERROR_CODE));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='2']", preflight, XPathConstants.NODE));    NodeList nl = (NodeList) xpath.evaluate("errors/error[@count='1']", preflight, XPathConstants.NODESET);    Assert.assertEquals(2, nl.getLength());}
public void pdfbox_f9157_0() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError(ERROR_CODE));    result.addError(new ValidationResult.ValidationError(ERROR_CODE));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='2']", preflight, XPathConstants.NODE));    Assert.assertNotNull(xpath.evaluate("errors/error[@count='2']", preflight, XPathConstants.NODE));    Element code = (Element) xpath.evaluate("errors/error[@count='2']/code", preflight, XPathConstants.NODE);    Assert.assertNotNull(code);    Assert.assertEquals(ERROR_CODE, code.getTextContent());}
public void pdfbox_f9158_0() throws Exception
{    ValidationResult result = new ValidationResult(false);    result.addError(new ValidationResult.ValidationError(ERROR_CODE, "message 1"));    result.addError(new ValidationResult.ValidationError(ERROR_CODE, "message 2"));    parser.createResponseWithError(document, "pdftype", result, preflight);    Assert.assertNotNull(xpath.evaluate("errors[@count='2']", preflight, XPathConstants.NODE));    NodeList nl = (NodeList) xpath.evaluate("errors/error[@count='1']", preflight, XPathConstants.NODESET);    Assert.assertEquals(2, nl.getLength());}
public void pdfbox_f9159_0() throws Exception
{    PreflightDocument document = null;    System.out.println(target);    ValidationResult result = null;    try {        PreflightParser parser = new PreflightParser(target);        parser.parse();        document = (PreflightDocument) parser.getPDDocument();        document.validate();        result = document.getResult();    } catch (SyntaxValidationException e) {        result = e.getResult();    } finally {        if (document != null) {            document.close();        }    }    Assert.assertFalse("Test of " + target, result.isValid());}
public static Collection<Object[]> pdfbox_f9160_0() throws Exception
{        File directory = null;    String pdfPath = System.getProperty("pdfa.invalid", null);    if ("${user.pdfa.invalid}".equals(pdfPath)) {        pdfPath = null;    }    if (pdfPath != null) {        directory = new File(pdfPath);        if (!directory.exists())            throw new Exception("directory does not exists : " + directory.getAbsolutePath());        if (!directory.isDirectory())            throw new Exception("not a directory : " + directory.getAbsolutePath());    } else {        System.err.println("System property 'pdfa.invalid' not defined, will not run TestValidaDirectory");    }        if (directory == null) {        return new ArrayList<>(0);    } else {        File[] files = directory.listFiles();        List<Object[]> data = new ArrayList<>(files.length);        for (File file : files) {            if (file.isFile()) {                data.add(new Object[] { file });            }        }        return data;    }}
public static Collection<Object[]> pdfbox_f9161_0() throws Exception
{    String filter = System.getProperty(FILTER_FILE);    String skipBavaria = System.getProperty(SKIP_BAVARIA);        File f = new File("src/test/resources/expected_errors.txt");    InputStream expected = new FileInputStream(f);    Properties props = new Properties();    props.load(expected);    IOUtils.closeQuietly(expected);        List<Object[]> data = new ArrayList<>();    File isartor = new File("target/pdfs/Isartor testsuite/PDFA-1b");    if (isartor.isDirectory()) {        Collection<?> pdfFiles = FileUtils.listFiles(isartor, new String[] { "pdf", "PDF" }, true);        for (Object pdfFile : pdfFiles) {            String fn = ((File) pdfFile).getName();            if (filter == null || fn.contains(filter)) {                String path = props.getProperty(fn);                String error = new StringTokenizer(path, "//").nextToken().trim();                String[] errTab = error.split(",");                Set<String> errorSet = new HashSet<>(Arrays.asList(errTab));                data.add(new Object[] { pdfFile, errorSet });            }        }    } else {        fail("Isartor data set has not been downloaded! Try running Maven?");    }    if ("false".equals(skipBavaria)) {        File bavaria = new File("target/pdfs/Bavaria testsuite");        if (bavaria.isDirectory()) {            Collection<?> pdfFiles = FileUtils.listFiles(bavaria, new String[] { "pdf", "PDF" }, true);            for (Object pdfFile : pdfFiles) {                String fn = ((File) pdfFile).getName();                if (filter == null || fn.contains(filter)) {                    String path = props.getProperty(fn);                    Set<String> errorSet = new HashSet<>();                    if (!path.isEmpty()) {                        String error = new StringTokenizer(path, "//").nextToken().trim();                        errorSet.addAll(Arrays.asList(error.split(",")));                    }                    data.add(new Object[] { pdfFile, errorSet });                }            }        } else {            fail("Bavaria data set has not been downloaded! Try running Maven?");        }    } else {        System.out.println("Bavaria tests are skipped. You can enable them in Maven with -Dskip-bavaria=false");        System.out.println("About the tests: http://www.pdflib.com/knowledge-base/pdfa/validation-report/");    }    return data;}
public static void pdfbox_f9162_0() throws Exception
{    String irp = System.getProperty("isartor.results.path");    if (irp != null) {        File f = new File(irp);        if (f.exists() && f.isFile()) {            f.delete();            isartorResultFile = new FileOutputStream(f);        } else if (!f.exists()) {            isartorResultFile = new FileOutputStream(f);        } else {            throw new IllegalArgumentException("Invalid result file : " + irp);        }    }}
public static void pdfbox_f9163_0() throws Exception
{    if (isartorResultFile != null) {        IOUtils.closeQuietly(isartorResultFile);    }}
public void pdfbox_f9164_0() throws Exception
{    PreflightDocument document = null;    try {        ValidationResult result;        try {            PreflightParser parser = new PreflightParser(file);            parser.parse();            document = (PreflightDocument) parser.getPDDocument();                        if (document.getNumberOfPages() < 8191) {                document.validate();            }            result = document.getResult();        } catch (SyntaxValidationException e) {            result = e.getResult();        }        if (this.expectedErrorSet.isEmpty()) {            Set<String> errorSet = new HashSet<>();            for (ValidationError error : result.getErrorsList()) {                errorSet.add(error.getErrorCode());            }            StringBuilder message = new StringBuilder();            message.append(file.getName());            message.append(" : PDF/A file should be valid, but has error");            if (errorSet.size() > 1) {                message.append('s');            }            message.append(':');            for (String errMsg : errorSet) {                message.append(' ');                message.append(errMsg);            }            assertTrue(message.toString(), result.isValid());            assertTrue(message.toString(), result.getErrorsList().isEmpty());        } else {            assertFalse(file.getName() + " : PDF/A file should be invalid (expected " + this.expectedErrorSet + ")",             result.isValid());            assertTrue(file.getName() + " : Should find at least one error", result.getErrorsList().size() > 0);                        boolean logged = false;            boolean allFound = true;            for (String expectedError : this.expectedErrorSet) {                boolean oneFound = false;                for (ValidationError error : result.getErrorsList()) {                    if (error.getErrorCode().equals(expectedError)) {                        oneFound = true;                    }                    if (isartorResultFile != null && !logged) {                        String log = file.getName().replace(".pdf", "") + "#" + error.getErrorCode() + "#" + error.getDetails() + "\n";                        isartorResultFile.write(log.getBytes());                    }                }                if (!oneFound) {                    allFound = false;                    break;                }                                logged = true;            }            if (!allFound) {                Set<String> errorSet = new HashSet<>();                for (ValidationError error : result.getErrorsList()) {                    errorSet.add(error.getErrorCode());                }                StringBuilder message = new StringBuilder();                for (String errMsg : errorSet) {                    if (message.length() > 0) {                        message.append(", ");                    }                    message.append(errMsg);                }                fail(String.format("%s : Invalid error code returned. Expected %s, found [%s]", file.getName(), expectedErrorSet, message.toString().trim()));            }                }    } finally {        if (document != null) {            document.close();        }    }}
public void pdfbox_f9165_0() throws IOException
{    PreflightParser parser = new PreflightParser(new File("src/test/resources/PDFBOX-3741.pdf"));    parser.parse();    ValidationResult result;    try (PreflightDocument document = parser.getPreflightDocument()) {        document.validate();        result = document.getResult();    }            Assert.assertFalse("File PDFBOX-3741.pdf should be detected as not PDF/A-1b", result.isValid());    Assert.assertEquals("List should contain one result", 1, result.getErrorsList().size());    Assert.assertEquals("2.4.3", result.getErrorsList().get(0).getErrorCode());}
public void pdfbox_f9166_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof BookmarkValidationProcess);}
public void pdfbox_f9167_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof ResourcesValidationProcess);}
public void pdfbox_f9168_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.setErrorOnMissingProcess(false);    confg.removeProcess(PreflightConfiguration.BOOKMARK_PROCESS);    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof EmptyValidationProcess);}
public void pdfbox_f9169_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.setErrorOnMissingProcess(false);    confg.removePageProcess(PreflightConfiguration.RESOURCES_PROCESS);    ValidationProcess vp = confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.assertNotNull(vp);    Assert.assertTrue(vp instanceof EmptyValidationProcess);}
public void pdfbox_f9170_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.removeProcess(PreflightConfiguration.BOOKMARK_PROCESS);    confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.fail();}
public void pdfbox_f9171_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.removePageProcess(PreflightConfiguration.RESOURCES_PROCESS);    confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.fail();}
public void pdfbox_f9172_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.replaceProcess(PreflightConfiguration.BOOKMARK_PROCESS, null);    confg.getInstanceOfProcess(PreflightConfiguration.BOOKMARK_PROCESS);    Assert.fail();}
public void pdfbox_f9173_0() throws Exception
{    PreflightConfiguration confg = PreflightConfiguration.createPdfA1BConfiguration();    confg.replacePageProcess(PreflightConfiguration.RESOURCES_PROCESS, null);    confg.getInstanceOfProcess(PreflightConfiguration.RESOURCES_PROCESS);    Assert.fail();}
public void pdfbox_f9174_0()
{    PreflightPath path = new PreflightPath();    assertTrue(path.isEmpty());    assertEquals(0, path.size());    path.pushObject("a");    assertEquals(1, path.size());    assertFalse(path.isEmpty());    int position = path.getClosestTypePosition(String.class);    assertEquals(0, position);    path.pushObject(6);    assertEquals(2, path.size());    position = path.getClosestTypePosition(String.class);    assertEquals(0, position);    position = path.getClosestTypePosition(Integer.class);    assertEquals(1, position);    path.pushObject("b");    assertEquals(3, path.size());    position = path.getClosestTypePosition(String.class);    assertEquals(2, position);    position = path.getClosestTypePosition(Integer.class);    assertEquals(1, position);    Integer i = path.getPathElement(position, Integer.class);    assertEquals(Integer.valueOf(6), i);    Object str = path.peek();    assertEquals(3, path.size());    assertEquals(String.class, str.getClass());    assertEquals("b", str);    str = path.pop();    assertEquals(2, path.size());    assertEquals(String.class, str.getClass());    assertEquals("b", str);    path.clear();    assertTrue(path.isEmpty());    assertEquals(0, path.size());}
public void pdfbox_f9175_0()
{    PreflightPath path = new PreflightPath();    assertTrue(path.pushObject("a"));    assertFalse(path.pushObject(null));}
public void pdfbox_f9176_0() throws Exception
{    PreflightDocument document = null;    System.out.println(target);    ValidationResult result = null;    try {        PreflightParser parser = new PreflightParser(target);        parser.parse();        document = (PreflightDocument) parser.getPDDocument();        document.validate();        result = document.getResult();    } catch (SyntaxValidationException e) {        result = e.getResult();    } finally {        if (document != null) {            document.close();        }    }    Assert.assertTrue("Validation of " + target, result.isValid());}
public static Collection<Object[]> pdfbox_f9177_0() throws Exception
{        File directory = null;    String pdfPath = System.getProperty("pdfa.valid", null);    if ("${user.pdfa.valid}".equals(pdfPath)) {        pdfPath = null;    }    if (pdfPath != null) {        directory = new File(pdfPath);        if (!directory.exists())            throw new Exception("directory does not exists : " + directory.getAbsolutePath());        if (!directory.isDirectory())            throw new Exception("not a directory : " + directory.getAbsolutePath());    } else {        System.err.println("System property 'pdfa.valid' not defined, will not run TestValidaDirectory");    }        if (directory == null) {        return new ArrayList<>(0);    } else {        File[] files = directory.listFiles();        List<Object[]> data = new ArrayList<>(files.length);        for (File file : files) {            if (file.isFile()) {                data.add(new Object[] { file });            }        }        return data;    }}
public static void pdfbox_f9178_0(String[] args)
{        System.setProperty("apple.awt.UIElement", "true");    if (args.length < 1) {        usage();    }    String inputFilename = args[0];    String outputFilename;    if (args.length > 1) {        outputFilename = args[1];    } else {        if (inputFilename.matches(".*\\.[pP][dD][fF]$")) {            outputFilename = inputFilename.replaceAll("\\.[pP][dD][fF]$", ".unc.pdf");        } else {            outputFilename = inputFilename + ".unc.pdf";        }    }    PDDocument doc = null;    try {        doc = PDDocument.load(new File(inputFilename));        for (COSObject objStream : doc.getDocument().getObjectsByType(COSName.OBJ_STM)) {            COSStream stream = (COSStream) objStream.getObject();            PDFObjectStreamParser sp = new PDFObjectStreamParser(stream, doc.getDocument());            sp.parse();            for (COSObject next : sp.getObjects()) {                COSObjectKey key = new COSObjectKey(next);                COSObject obj = doc.getDocument().getObjectFromPool(key);                obj.setObject(next.getObject());            }            doc.getDocument().removeObject(new COSObjectKey(objStream));        }        doc.save(outputFilename);    } catch (Exception e) {        System.err.println("Error processing file: " + e.getMessage());    } finally {        IOUtils.closeQuietly(doc);    }}
private static void pdfbox_f9179_0()
{    String message = "Usage: java -cp pdfbox-app-x.y.z.jar " + "org.apache.pdfbox.tools.DecompressObjectstreams <inputfile> [<outputfile>]\n" + "\nOptions:\n" + "  <inputfile>  : The PDF document to decompress\n" + "  <outputfile> : The output filename (default is to replace .pdf with .unc.pdf)";    System.err.println(message);    System.exit(1);}
public static void pdfbox_f9180_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    Decrypt decrypt = new Decrypt();    decrypt.parseCommandLine(args);    decrypt.decrypt();}
private void pdfbox_f9181_0(String[] args)
{    Options options = defineOptions();    CommandLine commandLine = parseArguments(options, args);    this.alias = commandLine.getOptionValue(ALIAS);    this.password = commandLine.getOptionValue(PASSWORD, "");    this.keyStore = commandLine.getOptionValue(KEYSTORE);            List<String> fileNames = commandLine.getArgList();    if (fileNames.isEmpty() || fileNames.size() > 2) {        usage(options);    }    this.infile = fileNames.get(0);    if (fileNames.size() == 1) {        this.outfile = fileNames.get(0);    } else {        this.outfile = fileNames.get(1);    }}
private static Options pdfbox_f9182_0()
{    Options options = new Options();    options.addOption(Option.builder(ALIAS).hasArg().desc("The alias of the key in the certificate file (mandatory if several keys are available).").build());    options.addOption(Option.builder(PASSWORD).hasArg().desc("The password to open the certificate and extract the private key from it.").build());    options.addOption(Option.builder(KEYSTORE).hasArg().desc("The KeyStore that holds the certificate.").build());    return options;}
private static CommandLine pdfbox_f9183_0(Options options, String[] commandLineArguments)
{    CommandLineParser cmdLineParser = new DefaultParser();    CommandLine commandLine = null;    try {        commandLine = cmdLineParser.parse(options, commandLineArguments);    } catch (ParseException parseException) {        System.out.println(parseException.getMessage());        usage(options);    }    return commandLine;}
private void pdfbox_f9184_0() throws IOException
{    PDDocument document = null;    InputStream keyStoreStream = null;    try {        if (keyStore != null) {            keyStoreStream = new FileInputStream(keyStore);        }        document = PDDocument.load(new File(infile), password, keyStoreStream, alias);        if (document.isEncrypted()) {            AccessPermission ap = document.getCurrentAccessPermission();            if (ap.isOwnerPermission()) {                document.setAllSecurityToBeRemoved(true);                document.save(outfile);            } else {                throw new IOException("Error: You are only allowed to decrypt a document with the owner password.");            }        } else {            System.err.println("Error: Document is not encrypted.");        }    } finally {        if (document != null) {            document.close();        }        IOUtils.closeQuietly(keyStoreStream);    }}
private static void pdfbox_f9185_0(Options options)
{    HelpFormatter formatter = new HelpFormatter();    String syntax = "java -jar pdfbox-app-x.y.z.jar Decrypt [options] <inputfile> [outputfile]";    String header = "\nOptions";    formatter.setWidth(132);    formatter.printHelp(syntax, header, options, "");    System.exit(1);}
public static void pdfbox_f9186_0(String[] args) throws IOException, CertificateException
{        System.setProperty("apple.awt.UIElement", "true");    Encrypt encrypt = new Encrypt();    encrypt.encrypt(args);}
private void pdfbox_f9187_0(String[] args) throws IOException, CertificateException
{    if (args.length < 1) {        usage();    } else {        AccessPermission ap = new AccessPermission();        String infile = null;        String outfile = null;        String certFile = null;        @SuppressWarnings({ "squid:S2068" })        String userPassword = "";        @SuppressWarnings({ "squid:S2068" })        String ownerPassword = "";        int keyLength = 256;        PDDocument document = null;        try {            for (int i = 0; i < args.length; i++) {                String key = args[i];                if (key.equals("-O")) {                    ownerPassword = args[++i];                } else if (key.equals("-U")) {                    userPassword = args[++i];                } else if (key.equals("-canAssemble")) {                    ap.setCanAssembleDocument(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canExtractContent")) {                    ap.setCanExtractContent(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canExtractForAccessibility")) {                    ap.setCanExtractForAccessibility(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canFillInForm")) {                    ap.setCanFillInForm(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canModify")) {                    ap.setCanModify(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canModifyAnnotations")) {                    ap.setCanModifyAnnotations(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canPrint")) {                    ap.setCanPrint(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-canPrintDegraded")) {                    ap.setCanPrintDegraded(args[++i].equalsIgnoreCase("true"));                } else if (key.equals("-certFile")) {                    certFile = args[++i];                } else if (key.equals("-keyLength")) {                    try {                        keyLength = Integer.parseInt(args[++i]);                    } catch (NumberFormatException e) {                        throw new NumberFormatException("Error: -keyLength is not an integer '" + args[i] + "'");                    }                } else if (infile == null) {                    infile = key;                } else if (outfile == null) {                    outfile = key;                } else {                    usage();                }            }            if (infile == null) {                usage();            }            if (outfile == null) {                outfile = infile;            }            document = PDDocument.load(new File(infile));            if (!document.isEncrypted()) {                if (certFile != null) {                    PublicKeyProtectionPolicy ppp = new PublicKeyProtectionPolicy();                    PublicKeyRecipient recip = new PublicKeyRecipient();                    recip.setPermission(ap);                    CertificateFactory cf = CertificateFactory.getInstance("X.509");                    try (InputStream inStream = new FileInputStream(certFile)) {                        X509Certificate certificate = (X509Certificate) cf.generateCertificate(inStream);                        recip.setX509(certificate);                    }                    ppp.addRecipient(recip);                    ppp.setEncryptionKeyLength(keyLength);                    document.protect(ppp);                } else {                    StandardProtectionPolicy spp = new StandardProtectionPolicy(ownerPassword, userPassword, ap);                    spp.setEncryptionKeyLength(keyLength);                    document.protect(spp);                }                document.save(outfile);            } else {                System.err.println("Error: Document is already encrypted.");            }        } finally {            if (document != null) {                document.close();            }        }    }}
private static void pdfbox_f9188_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar Encrypt [options] <inputfile> [outputfile]\n" + "\nOptions:\n" + "  -O <password>                            : Set the owner password (ignored if certFile is set)\n" + "  -U <password>                            : Set the user password (ignored if certFile is set)\n" + "  -certFile <path to cert>                 : Path to X.509 certificate\n" + "  -canAssemble <true|false>                : Set the assemble permission\n" + "  -canExtractContent <true|false>          : Set the extraction permission\n" + "  -canExtractForAccessibility <true|false> : Set the extraction permission\n" + "  -canFillInForm <true|false>              : Set the fill in form permission\n" + "  -canModify <true|false>                  : Set the modify permission\n" + "  -canModifyAnnotations <true|false>       : Set the modify annots permission\n" + "  -canPrint <true|false>                   : Set the print permission\n" + "  -canPrintDegraded <true|false>           : Set the print degraded permission\n" + "  -keyLength <length>                      : Key length in bits " + "(valid values: 40, 128 or 256, default is 256)\n" + "\nNote: By default all permissions are set to true!";    System.err.println(message);    System.exit(1);}
public static void pdfbox_f9189_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExportFDF exporter = new ExportFDF();    exporter.exportFDF(args);}
private void pdfbox_f9190_0(String[] args) throws IOException
{    if (args.length != 1 && args.length != 2) {        usage();    } else {        try (PDDocument pdf = PDDocument.load(new File(args[0]))) {            PDAcroForm form = pdf.getDocumentCatalog().getAcroForm();            if (form == null) {                System.err.println("Error: This PDF does not contain a form.");            } else {                String fdfName = null;                if (args.length == 2) {                    fdfName = args[1];                } else {                    if (args[0].length() > 4) {                        fdfName = args[0].substring(0, args[0].length() - 4) + ".fdf";                    }                }                try (FDFDocument fdf = form.exportFDF()) {                    fdf.save(fdfName);                }            }        }    }}
private static void pdfbox_f9191_0()
{    String message = "Usage: org.apache.pdfbox.ExportFDF <inputfile> [output-fdf-file]\n" + "\nOptions:\n" + "  [output-fdf-file] : Default is pdf name, test.pdf->test.fdf";    System.err.println(message);    System.exit(1);}
public static void pdfbox_f9192_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExportXFDF exporter = new ExportXFDF();    exporter.exportXFDF(args);}
private void pdfbox_f9193_0(String[] args) throws IOException
{    if (args.length != 1 && args.length != 2) {        usage();    } else {        try (PDDocument pdf = PDDocument.load(new File(args[0]))) {            PDAcroForm form = pdf.getDocumentCatalog().getAcroForm();            if (form == null) {                System.err.println("Error: This PDF does not contain a form.");            } else {                String fdfName = null;                if (args.length == 2) {                    fdfName = args[1];                } else {                    if (args[0].length() > 4) {                        fdfName = args[0].substring(0, args[0].length() - 4) + ".xfdf";                    }                }                try (FDFDocument fdf = form.exportFDF()) {                    fdf.saveXFDF(fdfName);                }            }        }    }}
private static void pdfbox_f9194_0()
{    String message = "Usage: org.apache.pdfbox.ExportXFDF <inputfile> [output-xfdf-file]\n" + "\nOptions:\n" + "  [output-xfdf-file] : Default is pdf name, test.pdf->test.xfdf";    System.err.println(message);    System.exit(1);}
public static void pdfbox_f9195_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExtractImages extractor = new ExtractImages();    extractor.run(args);}
private void pdfbox_f9196_0(String[] args) throws IOException
{    if (args.length < 1 || args.length > 4) {        usage();    } else {        String pdfFile = null;        @SuppressWarnings({ "squid:S2068" })        String password = "";        for (int i = 0; i < args.length; i++) {            switch(args[i]) {                case PASSWORD:                    i++;                    if (i >= args.length) {                        usage();                    }                    password = args[i];                    break;                case PREFIX:                    i++;                    if (i >= args.length) {                        usage();                    }                    prefix = args[i];                    break;                case DIRECTJPEG:                    directJPEG = true;                    break;                default:                    if (pdfFile == null) {                        pdfFile = args[i];                    }                    break;            }        }        if (pdfFile == null) {            usage();        } else {            if (prefix == null && pdfFile.length() > 4) {                prefix = pdfFile.substring(0, pdfFile.length() - 4);            }            extract(pdfFile, password);        }    }}
private static void pdfbox_f9197_0()
{    String message = "Usage: java " + ExtractImages.class.getName() + " [options] <inputfile>\n" + "\nOptions:\n" + "  -password <password>   : Password to decrypt document\n" + "  -prefix <image-prefix> : Image prefix (default to pdf name)\n" + "  -directJPEG            : Forces the direct extraction of JPEG/JPX images " + "                           regardless of colorspace or masking\n" + "  <inputfile>            : The PDF document to use\n";    System.err.println(message);    System.exit(1);}
private void pdfbox_f9198_0(String pdfFile, String password) throws IOException
{    try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {        AccessPermission ap = document.getCurrentAccessPermission();        if (!ap.canExtractContent()) {            throw new IOException("You do not have permission to extract images");        }        for (PDPage page : document.getPages()) {            ImageGraphicsEngine extractor = new ImageGraphicsEngine(page);            extractor.run();        }    }}
public void pdfbox_f9199_0() throws IOException
{    PDPage page = getPage();    processPage(page);    PDResources res = page.getResources();    for (COSName name : res.getExtGStateNames()) {        PDSoftMask softMask = res.getExtGState(name).getSoftMask();        if (softMask != null) {            PDTransparencyGroup group = softMask.getGroup();            if (group != null) {                                res.getExtGState(name).copyIntoGraphicsState(getGraphicsState());                processSoftMask(group);            }        }    }}
public void pdfbox_f9200_0(PDImage pdImage) throws IOException
{    if (pdImage instanceof PDImageXObject) {        if (pdImage.isStencil()) {            processColor(getGraphicsState().getNonStrokingColor());        }        PDImageXObject xobject = (PDImageXObject) pdImage;        if (seen.contains(xobject.getCOSObject())) {                        return;        }        seen.add(xobject.getCOSObject());    }        String name = prefix + "-" + imageCounter;    imageCounter++;    System.out.println("Writing image: " + name);    write2file(pdImage, name, directJPEG);}
public void pdfbox_f9201_0(Point2D p0, Point2D p1, Point2D p2, Point2D p3) throws IOException
{}
public void pdfbox_f9202_0(int windingRule) throws IOException
{}
public void pdfbox_f9203_0(float x, float y) throws IOException
{}
public void pdfbox_f9204_0(float x, float y) throws IOException
{}
public void pdfbox_f9205_0(float x1, float y1, float x2, float y2, float x3, float y3) throws IOException
{}
public Point2D pdfbox_f9206_0() throws IOException
{    return new Point2D.Float(0, 0);}
public void pdfbox_f9207_0() throws IOException
{}
public void pdfbox_f9208_0() throws IOException
{}
protected void pdfbox_f9209_0(Matrix textRenderingMatrix, PDFont font, int code, String unicode, Vector displacement) throws IOException
{    RenderingMode renderingMode = getGraphicsState().getTextState().getRenderingMode();    if (renderingMode.isFill()) {        processColor(getGraphicsState().getNonStrokingColor());    }    if (renderingMode.isStroke()) {        processColor(getGraphicsState().getStrokingColor());    }}
public void pdfbox_f9210_0() throws IOException
{    processColor(getGraphicsState().getStrokingColor());}
public void pdfbox_f9211_0(int windingRule) throws IOException
{    processColor(getGraphicsState().getNonStrokingColor());}
public void pdfbox_f9212_0(int windingRule) throws IOException
{    processColor(getGraphicsState().getNonStrokingColor());}
public void pdfbox_f9213_0(COSName shadingName) throws IOException
{}
private void pdfbox_f9214_0(PDColor color) throws IOException
{    if (color.getColorSpace() instanceof PDPattern) {        PDPattern pattern = (PDPattern) color.getColorSpace();        PDAbstractPattern abstractPattern = pattern.getPattern(color);        if (abstractPattern instanceof PDTilingPattern) {            processTilingPattern((PDTilingPattern) abstractPattern, null, null);        }    }}
private boolean pdfbox_f9215_0(PDImage pdImage) throws IOException
{    if (pdImage instanceof PDImageXObject) {        PDImageXObject ximg = (PDImageXObject) pdImage;        return ximg.getMask() != null || ximg.getSoftMask() != null;    }    return false;}
private void pdfbox_f9216_0(PDImage pdImage, String prefix, boolean directJPEG) throws IOException
{    String suffix = pdImage.getSuffix();    if (suffix == null || "jb2".equals(suffix)) {        suffix = "png";    } else if ("jpx".equals(suffix)) {                suffix = "jp2";    }    try (FileOutputStream out = new FileOutputStream(prefix + "." + suffix)) {        BufferedImage image = pdImage.getImage();        if (image != null) {            if ("jpg".equals(suffix)) {                String colorSpaceName = pdImage.getColorSpace().getName();                if (directJPEG || !hasMasks(pdImage) && (PDDeviceGray.INSTANCE.getName().equals(colorSpaceName) || PDDeviceRGB.INSTANCE.getName().equals(colorSpaceName))) {                                        InputStream data = pdImage.createInputStream(JPEG);                    IOUtils.copy(data, out);                    IOUtils.closeQuietly(data);                } else {                                        ImageIOUtil.writeImage(image, suffix, out);                }            } else if ("jp2".equals(suffix)) {                String colorSpaceName = pdImage.getColorSpace().getName();                if (directJPEG || !hasMasks(pdImage) && (PDDeviceGray.INSTANCE.getName().equals(colorSpaceName) || PDDeviceRGB.INSTANCE.getName().equals(colorSpaceName))) {                                        InputStream data = pdImage.createInputStream(Arrays.asList(COSName.JPX_DECODE.getName()));                    IOUtils.copy(data, out);                    IOUtils.closeQuietly(data);                } else {                                        ImageIOUtil.writeImage(image, "jpeg2000", out);                }            } else {                ImageIOUtil.writeImage(image, suffix, out);            }        }        out.flush();    }}
public static void pdfbox_f9217_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ExtractText extractor = new ExtractText();    extractor.startExtraction(args);}
public void pdfbox_f9218_0(String[] args) throws IOException
{    boolean toConsole = false;    boolean toHTML = false;    boolean sort = false;    boolean separateBeads = true;    boolean alwaysNext = false;    boolean rotationMagic = false;    @SuppressWarnings({ "squid:S2068" })    String password = "";    String encoding = STD_ENCODING;    String pdfFile = null;    String outputFile = null;        String ext = ".txt";    int startPage = 1;    int endPage = Integer.MAX_VALUE;    for (int i = 0; i < args.length; i++) {        if (args[i].equals(PASSWORD)) {            i++;            if (i >= args.length) {                usage();            }            password = args[i];        } else if (args[i].equals(ENCODING)) {            i++;            if (i >= args.length) {                usage();            }            encoding = args[i];        } else if (args[i].equals(START_PAGE)) {            i++;            if (i >= args.length) {                usage();            }            startPage = Integer.parseInt(args[i]);        } else if (args[i].equals(HTML)) {            toHTML = true;            ext = ".html";        } else if (args[i].equals(SORT)) {            sort = true;        } else if (args[i].equals(IGNORE_BEADS)) {            separateBeads = false;        } else if (args[i].equals(DEBUG)) {            debug = true;        } else if (args[i].equals(ALWAYSNEXT)) {            alwaysNext = true;        } else if (args[i].equals(ROTATION_MAGIC)) {            rotationMagic = true;        } else if (args[i].equals(END_PAGE)) {            i++;            if (i >= args.length) {                usage();            }            endPage = Integer.parseInt(args[i]);        } else if (args[i].equals(CONSOLE)) {            toConsole = true;        } else {            if (pdfFile == null) {                pdfFile = args[i];            } else {                outputFile = args[i];            }        }    }    if (pdfFile == null) {        usage();    } else {        Writer output = null;        PDDocument document = null;        try {            long startTime = startProcessing("Loading PDF " + pdfFile);            if (outputFile == null && pdfFile.length() > 4) {                outputFile = new File(pdfFile.substring(0, pdfFile.length() - 4) + ext).getAbsolutePath();            }            document = PDDocument.load(new File(pdfFile), password);            AccessPermission ap = document.getCurrentAccessPermission();            if (!ap.canExtractContent()) {                throw new IOException("You do not have permission to extract text");            }            stopProcessing("Time for loading: ", startTime);            if (toConsole) {                output = new OutputStreamWriter(System.out, encoding);            } else {                if (toHTML && !STD_ENCODING.equals(encoding)) {                    encoding = STD_ENCODING;                    System.out.println("The encoding parameter is ignored when writing html output.");                }                output = new OutputStreamWriter(new FileOutputStream(outputFile), encoding);            }            startTime = startProcessing("Starting text extraction");            if (debug) {                System.err.println("Writing to " + outputFile);            }            PDFTextStripper stripper;            if (toHTML) {                                stripper = new PDFText2HTML();                stripper.setSortByPosition(sort);                stripper.setShouldSeparateByBeads(separateBeads);                stripper.setStartPage(startPage);                stripper.setEndPage(endPage);                                stripper.writeText(document, output);            } else {                if (rotationMagic) {                    stripper = new FilteredTextStripper();                } else {                    stripper = new PDFTextStripper();                }                stripper.setSortByPosition(sort);                stripper.setShouldSeparateByBeads(separateBeads);                                extractPages(startPage, Math.min(endPage, document.getNumberOfPages()), stripper, document, output, rotationMagic, alwaysNext);            }                        PDDocumentCatalog catalog = document.getDocumentCatalog();            PDDocumentNameDictionary names = catalog.getNames();            if (names != null) {                PDEmbeddedFilesNameTreeNode embeddedFiles = names.getEmbeddedFiles();                if (embeddedFiles != null) {                    Map<String, PDComplexFileSpecification> embeddedFileNames = embeddedFiles.getNames();                    if (embeddedFileNames != null) {                        for (Map.Entry<String, PDComplexFileSpecification> ent : embeddedFileNames.entrySet()) {                            if (debug) {                                System.err.println("Processing embedded file " + ent.getKey() + ":");                            }                            PDComplexFileSpecification spec = ent.getValue();                            PDEmbeddedFile file = spec.getEmbeddedFile();                            if (file != null && "application/pdf".equals(file.getSubtype())) {                                if (debug) {                                    System.err.println("  is PDF (size=" + file.getSize() + ")");                                }                                try (InputStream fis = file.createInputStream();                                    PDDocument subDoc = PDDocument.load(fis)) {                                    if (toHTML) {                                                                                stripper.writeText(subDoc, output);                                    } else {                                        extractPages(1, subDoc.getNumberOfPages(), stripper, subDoc, output, rotationMagic, alwaysNext);                                    }                                }                            }                        }                    }                }            }            stopProcessing("Time for extraction: ", startTime);        } finally {            IOUtils.closeQuietly(output);            IOUtils.closeQuietly(document);        }    }}
private void pdfbox_f9219_1(int startPage, int endPage, PDFTextStripper stripper, PDDocument document, Writer output, boolean rotationMagic, boolean alwaysNext) throws IOException
{    for (int p = startPage; p <= endPage; ++p) {        stripper.setStartPage(p);        stripper.setEndPage(p);        try {            if (rotationMagic) {                PDPage page = document.getPage(p - 1);                int rotation = page.getRotation();                page.setRotation(0);                AngleCollector angleCollector = new AngleCollector();                angleCollector.setStartPage(p);                angleCollector.setEndPage(p);                angleCollector.writeText(document, new NullWriter());                                for (int angle : angleCollector.getAngles()) {                                        try (PDPageContentStream cs = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.PREPEND, false)) {                        cs.transform(Matrix.getRotateInstance(-Math.toRadians(angle), 0, 0));                    }                    stripper.writeText(document, output);                                        ((COSArray) page.getCOSObject().getItem(COSName.CONTENTS)).remove(0);                }                page.setRotation(rotation);            } else {                stripper.writeText(document, output);            }        } catch (IOException ex) {            if (!alwaysNext) {                throw ex;            }                    }    }}
private long pdfbox_f9220_0(String message)
{    if (debug) {        System.err.println(message);    }    return System.currentTimeMillis();}
private void pdfbox_f9221_0(String message, long startTime)
{    if (debug) {        long stopTime = System.currentTimeMillis();        float elapsedTime = ((float) (stopTime - startTime)) / 1000;        System.err.println(message + elapsedTime + " seconds");    }}
 static int pdfbox_f9222_0(TextPosition text)
{        Matrix m = text.getTextMatrix().clone();    m.concatenate(text.getFont().getFontMatrix());    return (int) Math.round(Math.toDegrees(Math.atan2(m.getShearY(), m.getScaleY())));}
private static void pdfbox_f9223_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar ExtractText [options] <inputfile> [output-text-file]\n" + "\nOptions:\n" + "  -password <password>        : Password to decrypt document\n" + "  -encoding <output encoding> : UTF-8 (default) or ISO-8859-1, UTF-16BE,\n" + "                                UTF-16LE, etc.\n" + "  -console                    : Send text to console instead of file\n" + "  -html                       : Output in HTML format instead of raw text\n" + "  -sort                       : Sort the text before writing\n" + "  -ignoreBeads                : Disables the separation by beads\n" + "  -debug                      : Enables debug output about the time consumption\n" + "                                of every stage\n" + "  -alwaysNext                 : Process next page (if applicable) despite\n" + "                                IOException (ignored when -html)\n" + "  -rotationMagic              : Analyze each page for rotated/skewed text,\n" + "                                rotate to 0 and extract separately\n" + "                                (slower, and ignored when -html)\n" + "  -startPage <number>         : The first page to start extraction (1 based)\n" + "  -endPage <number>           : The last page to extract (1 based, inclusive)\n" + "  <inputfile>                 : The PDF document to use\n" + "  [output-text-file]          : The file to write the text to";    System.err.println(message);    System.exit(1);}
 Set<Integer> pdfbox_f9224_0()
{    return angles;}
protected void pdfbox_f9225_0(TextPosition text)
{    int angle = ExtractText.getAngle(text);    angle = (angle + 360) % 360;    angles.add(angle);}
protected void pdfbox_f9226_0(TextPosition text)
{    int angle = ExtractText.getAngle(text);    if (angle == 0) {        super.processTextPosition(text);    }}
public void pdfbox_f9227_0(char[] cbuf, int off, int len) throws IOException
{}
public void pdfbox_f9228_0() throws IOException
{}
public void pdfbox_f9229_0() throws IOException
{}
public static boolean pdfbox_f9230_0(BufferedImage image, String filename, int dpi) throws IOException
{    float compressionQuality = 1f;    String formatName = filename.substring(filename.lastIndexOf('.') + 1);    if ("png".equalsIgnoreCase(formatName)) {                compressionQuality = 0f;    }    return writeImage(image, filename, dpi, compressionQuality);}
public static boolean pdfbox_f9231_0(BufferedImage image, String filename, int dpi, float compressionQuality) throws IOException
{    try (OutputStream output = new BufferedOutputStream(new FileOutputStream(filename))) {        String formatName = filename.substring(filename.lastIndexOf('.') + 1);        return writeImage(image, formatName, output, dpi, compressionQuality);    }}
public static boolean pdfbox_f9232_0(BufferedImage image, String formatName, String filename, int dpi) throws IOException
{    try (OutputStream output = new BufferedOutputStream(new FileOutputStream(filename + "." + formatName))) {        return writeImage(image, formatName, output, dpi);    }}
public static boolean pdfbox_f9233_0(BufferedImage image, String formatName, OutputStream output) throws IOException
{    return writeImage(image, formatName, output, 72);}
public static boolean pdfbox_f9234_0(BufferedImage image, String formatName, OutputStream output, int dpi) throws IOException
{    float compressionQuality = 1f;    if ("png".equalsIgnoreCase(formatName)) {                compressionQuality = 0f;    }    return writeImage(image, formatName, output, dpi, compressionQuality);}
public static boolean pdfbox_f9235_0(BufferedImage image, String formatName, OutputStream output, int dpi, float compressionQuality) throws IOException
{    return writeImage(image, formatName, output, dpi, compressionQuality, "");}
public static boolean pdfbox_f9236_1(BufferedImage image, String formatName, OutputStream output, int dpi, float compressionQuality, String compressionType) throws IOException
{    ImageOutputStream imageOutput = null;    ImageWriter writer = null;    try {                Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName(formatName);        ImageWriteParam param = null;        IIOMetadata metadata = null;                while (writers.hasNext()) {            if (writer != null) {                writer.dispose();            }            writer = writers.next();            if (writer != null) {                param = writer.getDefaultWriteParam();                metadata = writer.getDefaultImageMetadata(new ImageTypeSpecifier(image), param);                if (metadata != null && !metadata.isReadOnly() && metadata.isStandardMetadataFormatSupported()) {                    break;                }            }        }        if (writer == null) {                                    return false;        }                if (param != null && param.canWriteCompressed()) {            param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);            if (formatName.toLowerCase().startsWith("tif")) {                if ("".equals(compressionType)) {                                        TIFFUtil.setCompressionType(param, image);                } else {                    param.setCompressionType(compressionType);                    if (compressionType != null) {                        param.setCompressionQuality(compressionQuality);                    }                }            } else {                param.setCompressionType(param.getCompressionTypes()[0]);                param.setCompressionQuality(compressionQuality);            }        }        if (formatName.toLowerCase().startsWith("tif")) {                        TIFFUtil.updateMetadata(metadata, image, dpi);        } else if ("jpeg".equalsIgnoreCase(formatName) || "jpg".equalsIgnoreCase(formatName)) {                                                            JPEGUtil.updateMetadata(metadata, dpi);        } else {                        if (metadata != null && !metadata.isReadOnly() && metadata.isStandardMetadataFormatSupported()) {                setDPI(metadata, dpi, formatName);            }        }                imageOutput = ImageIO.createImageOutputStream(output);        writer.setOutput(imageOutput);        writer.write(null, new IIOImage(image, null, metadata), param);    } finally {        if (writer != null) {            writer.dispose();        }        if (imageOutput != null) {            imageOutput.close();        }    }    return true;}
private static IIOMetadataNode pdfbox_f9237_0(IIOMetadataNode parentNode, String name)
{    NodeList nodeList = parentNode.getElementsByTagName(name);    if (nodeList.getLength() > 0) {        return (IIOMetadataNode) nodeList.item(0);    }    IIOMetadataNode childNode = new IIOMetadataNode(name);    parentNode.appendChild(childNode);    return childNode;}
private static void pdfbox_f9238_0(IIOMetadata metadata, int dpi, String formatName) throws IIOInvalidTreeException
{    IIOMetadataNode root = (IIOMetadataNode) metadata.getAsTree(MetaUtil.STANDARD_METADATA_FORMAT);    IIOMetadataNode dimension = getOrCreateChildNode(root, "Dimension");                float res = "PNG".equalsIgnoreCase(formatName) ? dpi / 25.4f : 25.4f / dpi;    IIOMetadataNode child;    child = getOrCreateChildNode(dimension, "HorizontalPixelSize");    child.setAttribute("value", Double.toString(res));    child = getOrCreateChildNode(dimension, "VerticalPixelSize");    child.setAttribute("value", Double.toString(res));    metadata.mergeTree(MetaUtil.STANDARD_METADATA_FORMAT, root);}
 static void pdfbox_f9239_0(IIOMetadata metadata, int dpi) throws IIOInvalidTreeException
{    MetaUtil.debugLogMetadata(metadata, MetaUtil.JPEG_NATIVE_FORMAT);            Element root = (Element) metadata.getAsTree(MetaUtil.JPEG_NATIVE_FORMAT);    NodeList jvarNodeList = root.getElementsByTagName("JPEGvariety");    Element jvarChild;    if (jvarNodeList.getLength() == 0) {        jvarChild = new IIOMetadataNode("JPEGvariety");        root.appendChild(jvarChild);    } else {        jvarChild = (Element) jvarNodeList.item(0);    }    NodeList jfifNodeList = jvarChild.getElementsByTagName("app0JFIF");    Element jfifChild;    if (jfifNodeList.getLength() == 0) {        jfifChild = new IIOMetadataNode("app0JFIF");        jvarChild.appendChild(jfifChild);    } else {        jfifChild = (Element) jfifNodeList.item(0);    }    if (jfifChild.getAttribute("majorVersion").isEmpty()) {        jfifChild.setAttribute("majorVersion", "1");    }    if (jfifChild.getAttribute("minorVersion").isEmpty()) {        jfifChild.setAttribute("minorVersion", "2");    }        jfifChild.setAttribute("resUnits", "1");    jfifChild.setAttribute("Xdensity", Integer.toString(dpi));    jfifChild.setAttribute("Ydensity", Integer.toString(dpi));    if (jfifChild.getAttribute("thumbWidth").isEmpty()) {        jfifChild.setAttribute("thumbWidth", "0");    }    if (jfifChild.getAttribute("thumbHeight").isEmpty()) {        jfifChild.setAttribute("thumbHeight", "0");    }        metadata.setFromTree(MetaUtil.JPEG_NATIVE_FORMAT, root);}
 static void pdfbox_f9240_1(IIOMetadata metadata, String format)
{    if (!LOG.isDebugEnabled()) {        return;    }            IIOMetadataNode root = (IIOMetadataNode) metadata.getAsTree(format);    try {        StringWriter xmlStringWriter = new StringWriter();        StreamResult streamResult = new StreamResult(xmlStringWriter);        Transformer transformer = TransformerFactory.newInstance().newTransformer();                transformer.setOutputProperty(OutputKeys.INDENT, "yes");        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");        DOMSource domSource = new DOMSource(root);        transformer.transform(domSource, streamResult);            } catch (IllegalArgumentException | TransformerException ex) {            }}
public static void pdfbox_f9241_0(ImageWriteParam param, BufferedImage image)
{        if (image.getType() == BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() == 1) {        param.setCompressionType("CCITT T.6");    } else {        param.setCompressionType("LZW");    }}
 static void pdfbox_f9242_1(IIOMetadata metadata, BufferedImage image, int dpi) throws IIOInvalidTreeException
{    String metaDataFormat = metadata.getNativeMetadataFormatName();    if (metaDataFormat == null) {                return;    }    debugLogMetadata(metadata, metaDataFormat);    IIOMetadataNode root = new IIOMetadataNode(metaDataFormat);    IIOMetadataNode ifd;    if (root.getElementsByTagName("TIFFIFD").getLength() == 0) {        ifd = new IIOMetadataNode("TIFFIFD");        root.appendChild(ifd);    } else {        ifd = (IIOMetadataNode) root.getElementsByTagName("TIFFIFD").item(0);    }        ifd.appendChild(createRationalField(282, "XResolution", dpi, 1));    ifd.appendChild(createRationalField(283, "YResolution", dpi, 1));        ifd.appendChild(createShortField(296, "ResolutionUnit", 2));    ifd.appendChild(createLongField(278, "RowsPerStrip", image.getHeight()));    ifd.appendChild(createAsciiField(305, "Software", "PDFBOX"));    if (image.getType() == BufferedImage.TYPE_BYTE_BINARY && image.getColorModel().getPixelSize() == 1) {                        ifd.appendChild(createShortField(262, "PhotometricInterpretation", 0));    }    metadata.mergeTree(metaDataFormat, root);    debugLogMetadata(metadata, metaDataFormat);}
private static IIOMetadataNode pdfbox_f9243_0(int tiffTagNumber, String name, int val)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(tiffTagNumber));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFShorts");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFShort");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", Integer.toString(val));    return field;}
private static IIOMetadataNode pdfbox_f9244_0(int number, String name, String val)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(number));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFAsciis");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFAscii");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", val);    return field;}
private static IIOMetadataNode pdfbox_f9245_0(int number, String name, long val)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(number));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFLongs");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFLong");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", Long.toString(val));    return field;}
private static IIOMetadataNode pdfbox_f9246_0(int number, String name, int numerator, int denominator)
{    IIOMetadataNode field, arrayNode, valueNode;    field = new IIOMetadataNode("TIFFField");    field.setAttribute("number", Integer.toString(number));    field.setAttribute("name", name);    arrayNode = new IIOMetadataNode("TIFFRationals");    field.appendChild(arrayNode);    valueNode = new IIOMetadataNode("TIFFRational");    arrayNode.appendChild(valueNode);    valueNode.setAttribute("value", numerator + "/" + denominator);    return field;}
public static void pdfbox_f9247_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ImageToPDF app = new ImageToPDF();    if (args.length < 2) {        app.usage();    }    List<String> imageFilenames = new ArrayList<>();    String pdfPath = args[args.length - 1];    if (!pdfPath.endsWith(".pdf")) {        System.err.println("Last argument must be the destination .pdf file");        System.exit(1);    }    for (int i = 0; i < args.length - 1; i++) {        if (args[i].startsWith("-")) {            if ("-resize".equals(args[i])) {                                app.resize = true;            } else if ("-landscape".equals(args[i])) {                app.setLandscape(true);            } else if ("-autoOrientation".equals(args[i])) {                app.setAutoOrientation(true);            } else if ("-pageSize".equals(args[i])) {                i++;                PDRectangle rectangle = createRectangle(args[i]);                if (rectangle == null) {                    throw new IOException("Unknown argument: " + args[i]);                }                app.setMediaBox(rectangle);            } else {                throw new IOException("Unknown argument: " + args[i]);            }        } else {            imageFilenames.add(args[i]);        }    }    try (PDDocument doc = new PDDocument()) {        app.createPDFFromImages(doc, imageFilenames);        doc.save(pdfPath);    }}
 void pdfbox_f9248_0(PDDocument doc, List<String> imageFilenames) throws IOException
{    for (String imageFileName : imageFilenames) {        PDImageXObject pdImage = PDImageXObject.createFromFile(imageFileName, doc);        PDRectangle actualMediaBox = mediaBox;        if ((autoOrientation && pdImage.getWidth() > pdImage.getHeight()) || landscape) {            actualMediaBox = new PDRectangle(mediaBox.getHeight(), mediaBox.getWidth());        }        PDPage page = new PDPage(actualMediaBox);        doc.addPage(page);        try (PDPageContentStream contents = new PDPageContentStream(doc, page)) {            if (resize) {                contents.drawImage(pdImage, 0, 0, actualMediaBox.getWidth(), actualMediaBox.getHeight());            } else {                contents.drawImage(pdImage, 0, 0, pdImage.getWidth(), pdImage.getHeight());            }        }    }}
private static PDRectangle pdfbox_f9249_0(String paperSize)
{    if ("letter".equalsIgnoreCase(paperSize)) {        return PDRectangle.LETTER;    } else if ("legal".equalsIgnoreCase(paperSize)) {        return PDRectangle.LEGAL;    } else if ("A0".equalsIgnoreCase(paperSize)) {        return PDRectangle.A0;    } else if ("A1".equalsIgnoreCase(paperSize)) {        return PDRectangle.A1;    } else if ("A2".equalsIgnoreCase(paperSize)) {        return PDRectangle.A2;    } else if ("A3".equalsIgnoreCase(paperSize)) {        return PDRectangle.A3;    } else if ("A4".equalsIgnoreCase(paperSize)) {        return PDRectangle.A4;    } else if ("A5".equalsIgnoreCase(paperSize)) {        return PDRectangle.A5;    } else if ("A6".equalsIgnoreCase(paperSize)) {        return PDRectangle.A6;    } else {        return null;    }}
public PDRectangle pdfbox_f9250_0()
{    return mediaBox;}
public void pdfbox_f9251_0(PDRectangle mediaBox)
{    this.mediaBox = mediaBox;}
public boolean pdfbox_f9252_0()
{    return landscape;}
public void pdfbox_f9253_0(boolean landscape)
{    this.landscape = landscape;}
public boolean pdfbox_f9254_0()
{    return autoOrientation;}
public void pdfbox_f9255_0(boolean autoOrientation)
{    this.autoOrientation = autoOrientation;}
private void pdfbox_f9256_0()
{    StringBuilder message = new StringBuilder();    message.append("Usage: jar -jar pdfbox-app-x.y.z.jar ImageToPDF [options] <image-file>..<image-file> <output-file>\n");    message.append("\nOptions:\n");    message.append("  -resize              : resize to page size\n");    message.append("  -pageSize <pageSize> : Letter (default)\n");    message.append("                         Legal\n");    message.append("                         A0\n");    message.append("                         A1\n");    message.append("                         A2\n");    message.append("                         A3\n");    message.append("                         A4\n");    message.append("                         A5\n");    message.append("                         A6\n");    message.append("  -landscape           : sets orientation to landscape\n");    message.append("  -autoOrientation     : sets orientation depending of image proportion\n");    System.err.println(message.toString());    System.exit(1);}
public void pdfbox_f9257_0(PDDocument pdfDocument, FDFDocument fdfDocument) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    if (acroForm == null) {        return;    }    acroForm.setCacheFields(true);    acroForm.importFDF(fdfDocument);        acroForm.setNeedAppearances(true);}
public static void pdfbox_f9258_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ImportFDF importer = new ImportFDF();    importer.importFDF(args);}
private void pdfbox_f9259_0(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        ImportFDF importer = new ImportFDF();        try (PDDocument pdf = PDDocument.load(new File(args[0]));            FDFDocument fdf = FDFDocument.load(args[1])) {            importer.importFDF(pdf, fdf);            pdf.save(args[2]);        }    }}
private static void pdfbox_f9260_0()
{    System.err.println("usage: org.apache.pdfbox.tools.ImportFDF <pdf-file> <fdf-file> <output-file>");    System.exit(1);}
public void pdfbox_f9261_0(PDDocument pdfDocument, FDFDocument fdfDocument) throws IOException
{    PDDocumentCatalog docCatalog = pdfDocument.getDocumentCatalog();    PDAcroForm acroForm = docCatalog.getAcroForm();    acroForm.setCacheFields(true);    acroForm.importFDF(fdfDocument);}
public static void pdfbox_f9262_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    ImportXFDF importer = new ImportXFDF();    importer.importXFDF(args);}
private void pdfbox_f9263_0(String[] args) throws IOException
{    if (args.length != 3) {        usage();    } else {        ImportFDF importer = new ImportFDF();        try (PDDocument pdf = PDDocument.load(new File(args[0]));            FDFDocument fdf = FDFDocument.loadXFDF(args[1])) {            importer.importFDF(pdf, fdf);            pdf.save(args[2]);        }    }}
private static void pdfbox_f9264_0()
{    System.err.println("usage: org.apache.pdfbox.tools.ImportXFDF <pdf-file> <fdf-file> <output-file>");    System.exit(1);}
public static void pdfbox_f9265_1(final String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    String outputFilename = null;    Overlay overlayer = new Overlay();    Map<Integer, String> specificPageOverlayFile = new HashMap<>();        for (int i = 0; i < args.length; i++) {        String arg = args[i].trim();        if (i == 0) {            overlayer.setInputFile(arg);        } else if (i == (args.length - 1)) {            outputFilename = arg;        } else if (arg.equals(POSITION) && ((i + 1) < args.length)) {            if (Position.FOREGROUND.toString().equalsIgnoreCase(args[i + 1].trim())) {                overlayer.setOverlayPosition(Position.FOREGROUND);            } else if (Position.BACKGROUND.toString().equalsIgnoreCase(args[i + 1].trim())) {                overlayer.setOverlayPosition(Position.BACKGROUND);            } else {                usage();            }            i += 1;        } else if (arg.equals(ODD) && ((i + 1) < args.length)) {            overlayer.setOddPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(EVEN) && ((i + 1) < args.length)) {            overlayer.setEvenPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(FIRST) && ((i + 1) < args.length)) {            overlayer.setFirstPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(LAST) && ((i + 1) < args.length)) {            overlayer.setLastPageOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(USEALLPAGES) && ((i + 1) < args.length)) {            overlayer.setAllPagesOverlayFile(args[i + 1].trim());            i += 1;        } else if (arg.equals(PAGE) && ((i + 2) < args.length) && (isInteger(args[i + 1].trim()))) {            specificPageOverlayFile.put(Integer.parseInt(args[i + 1].trim()), args[i + 2].trim());            i += 2;        } else if (overlayer.getDefaultOverlayFile() == null) {            overlayer.setDefaultOverlayFile(arg);        } else {            usage();        }    }    if (overlayer.getInputFile() == null || outputFilename == null) {        usage();    }    try {        try (PDDocument result = overlayer.overlay(specificPageOverlayFile)) {            result.save(outputFilename);        }    } catch (IOException e) {                throw e;    } finally {                        overlayer.close();    }}
private static void pdfbox_f9266_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar OverlayPDF <inputfile> [options] <outputfile>\n" + "\nOptions:\n" + "  <inputfile>                                  : input file\n" + "  <defaultOverlay.pdf>                         : default overlay file\n" + "  -odd <oddPageOverlay.pdf>                    : overlay file used for odd pages\n" + "  -even <evenPageOverlay.pdf>                  : overlay file used for even pages\n" + "  -first <firstPageOverlay.pdf>                : overlay file used for the first page\n" + "  -last <lastPageOverlay.pdf>                  : overlay file used for the last page\n" + "  -useAllPages <allPagesOverlay.pdf>           : overlay file used for overlay, all pages" + " are used by simply repeating them\n" + "  -page <pageNumber> <specificPageOverlay.pdf> : overlay file used for " + "the given page number, may occur more than once\n" + "  -position foreground|background              : where to put the overlay " + "file: foreground or background\n" + "  <outputfile>                                 : output file";    System.err.println(message);    System.exit(1);}
private static boolean pdfbox_f9267_0(String str)
{    try {        Integer.parseInt(str);    } catch (NumberFormatException nfe) {        return false;    }    return true;}
public static void pdfbox_f9268_0(String[] args) throws Exception
{        System.setProperty("apple.awt.UIElement", "true");    if (args.length > 0) {        String command = args[0];        String[] arguments = new String[args.length - 1];        System.arraycopy(args, 1, arguments, 0, arguments.length);        boolean exitAfterCallingMain = true;        switch(command) {            case "Decrypt":                Decrypt.main(arguments);                break;            case "Encrypt":                Encrypt.main(arguments);                break;            case "ExtractText":                ExtractText.main(arguments);                break;            case "ExtractImages":                ExtractImages.main(arguments);                break;            case "OverlayPDF":                OverlayPDF.main(arguments);                break;            case "PrintPDF":                PrintPDF.main(arguments);                break;            case "PDFDebugger":            case "PDFReader":                PDFDebugger.main(arguments);                exitAfterCallingMain = false;                break;            case "PDFMerger":                PDFMerger.main(arguments);                break;            case "PDFSplit":                PDFSplit.main(arguments);                break;            case "PDFToImage":                PDFToImage.main(arguments);                break;            case "ImageToPDF":                ImageToPDF.main(arguments);                break;            case "TextToPDF":                TextToPDF.main(arguments);                break;            case "WriteDecodedDoc":                WriteDecodedDoc.main(arguments);                break;            default:                showMessageAndExit();                break;        }        if (exitAfterCallingMain) {            System.exit(0);        }    } else {        showMessageAndExit();    }}
private static void pdfbox_f9269_0()
{    String message = "PDFBox version: \"" + Version.getVersion() + "\"" + "\nUsage: java -jar pdfbox-app-x.y.z.jar <command> <args..>\n" + "\nPossible commands are:\n" + "  Decrypt\n" + "  Encrypt\n" + "  ExtractText\n" + "  ExtractImages\n" + "  ImageToPDF\n" + "  OverlayPDF\n" + "  PrintPDF\n" + "  PDFDebugger\n" + "  PDFMerger\n" + "  PDFReader\n" + "  PDFSplit\n" + "  PDFToImage\n" + "  TextToPDF\n" + "  WriteDecodedDoc";    System.err.println(message);    System.exit(1);}
public static void pdfbox_f9270_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    PDFMerger merge = new PDFMerger();    merge.merge(args);}
private void pdfbox_f9271_0(String[] args) throws IOException
{    int firstFileArgPos = 0;    if (args.length - firstFileArgPos < 3) {        usage();    }    PDFMergerUtility merger = new PDFMergerUtility();    for (int i = firstFileArgPos; i < args.length - 1; i++) {        String sourceFileName = args[i];        merger.addSource(sourceFileName);    }    String destinationFileName = args[args.length - 1];    merger.setDestinationFileName(destinationFileName);    merger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());}
private static void pdfbox_f9272_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFMerger " + "<inputfiles 2..n> <outputfile>\n" + "\nOptions:\n" + "  <inputfiles 2..n> : 2 or more source PDF documents to merge\n" + "  <outputfile>      : The PDF document to save the merged documents to\n";    System.err.println(message);    System.exit(1);}
public static void pdfbox_f9273_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    PDFSplit split = new PDFSplit();    split.split(args);}
private void pdfbox_f9274_0(String[] args) throws IOException
{    @SuppressWarnings({ "squid:S2068" })    String password = "";    String split = null;    String startPage = null;    String endPage = null;    Splitter splitter = new Splitter();    String pdfFile = null;    String outputPrefix = null;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case SPLIT:                i++;                if (i >= args.length) {                    usage();                }                split = args[i];                break;            case START_PAGE:                i++;                if (i >= args.length) {                    usage();                }                startPage = args[i];                break;            case END_PAGE:                i++;                if (i >= args.length) {                    usage();                }                endPage = args[i];                break;            case OUTPUT_PREFIX:                i++;                outputPrefix = args[i];                break;            default:                if (pdfFile == null) {                    pdfFile = args[i];                }                break;        }    }    if (pdfFile == null) {        usage();    } else {        if (outputPrefix == null) {            outputPrefix = pdfFile.substring(0, pdfFile.lastIndexOf('.'));        }        PDDocument document = null;        List<PDDocument> documents = null;        try {            document = PDDocument.load(new File(pdfFile), password);            int numberOfPages = document.getNumberOfPages();            boolean startEndPageSet = false;            if (startPage != null) {                splitter.setStartPage(Integer.parseInt(startPage));                startEndPageSet = true;                if (split == null) {                    splitter.setSplitAtPage(numberOfPages);                }            }            if (endPage != null) {                splitter.setEndPage(Integer.parseInt(endPage));                startEndPageSet = true;                if (split == null) {                    splitter.setSplitAtPage(Integer.parseInt(endPage));                }            }            if (split != null) {                splitter.setSplitAtPage(Integer.parseInt(split));            } else {                if (!startEndPageSet) {                    splitter.setSplitAtPage(1);                }            }            documents = splitter.split(document);            for (int i = 0; i < documents.size(); i++) {                try (PDDocument doc = documents.get(i)) {                    doc.save(outputPrefix + "-" + (i + 1) + ".pdf");                }            }        } finally {            if (document != null) {                document.close();            }            for (int i = 0; documents != null && i < documents.size(); i++) {                PDDocument doc = documents.get(i);                doc.close();            }        }    }}
private static void pdfbox_f9275_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFSplit [options] <inputfile>\n" + "\nOptions:\n" + "  -password  <password>  : Password to decrypt document\n" + "  -split     <integer>   : split after this many pages (default 1, if startPage and endPage are unset)\n" + "  -startPage <integer>   : start page\n" + "  -endPage   <integer>   : end page\n" + "  -outputPrefix <prefix> : Filename prefix for splitted files\n" + "  <inputfile>            : The PDF document to use\n";    System.err.println(message);    System.exit(1);}
protected void pdfbox_f9276_0() throws IOException
{}
protected void pdfbox_f9277_0(PDDocument document) throws IOException
{    StringBuilder buf = new StringBuilder(INITIAL_PDF_TO_HTML_BYTES);    buf.append("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"" + "\n" + "\"http://www.w3.org/TR/html4/loose.dtd\">\n");    buf.append("<html><head>");    buf.append("<title>").append(escape(getTitle())).append("</title>\n");    buf.append("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=\"UTF-8\">\n");    buf.append("</head>\n");    buf.append("<body>\n");    super.writeString(buf.toString());}
public void pdfbox_f9278_0(PDDocument document) throws IOException
{    super.writeString("</body></html>");}
protected String pdfbox_f9279_0()
{    String titleGuess = document.getDocumentInformation().getTitle();    if (titleGuess != null && titleGuess.length() > 0) {        return titleGuess;    } else {        Iterator<List<TextPosition>> textIter = getCharactersByArticle().iterator();        float lastFontSize = -1.0f;        StringBuilder titleText = new StringBuilder();        while (textIter.hasNext()) {            for (TextPosition position : textIter.next()) {                float currentFontSize = position.getFontSize();                                if (Float.compare(currentFontSize, lastFontSize) != 0 || titleText.length() > 64) {                    if (titleText.length() > 0) {                        return titleText.toString();                    }                    lastFontSize = currentFontSize;                }                if (currentFontSize > 13.0f) {                                        titleText.append(position.getUnicode());                }            }        }    }    return "";}
protected void pdfbox_f9280_0(boolean isLTR) throws IOException
{    if (isLTR) {        super.writeString("<div>");    } else {        super.writeString("<div dir=\"RTL\">");    }}
protected void pdfbox_f9281_0() throws IOException
{    super.endArticle();    super.writeString("</div>");}
protected void pdfbox_f9282_0(String text, List<TextPosition> textPositions) throws IOException
{    super.writeString(fontState.push(text, textPositions));}
protected void pdfbox_f9283_0(String chars) throws IOException
{    super.writeString(escape(chars));}
protected void pdfbox_f9284_0() throws IOException
{        super.writeString(fontState.clear());    super.writeParagraphEnd();}
private static String pdfbox_f9285_0(String chars)
{    StringBuilder builder = new StringBuilder(chars.length());    for (int i = 0; i < chars.length(); i++) {        appendEscaped(builder, chars.charAt(i));    }    return builder.toString();}
private static void pdfbox_f9286_0(StringBuilder builder, char character)
{        if ((character < 32) || (character > 126)) {        int charAsInt = character;        builder.append("&#").append(charAsInt).append(";");    } else {        switch(character) {            case 34:                builder.append("&quot;");                break;            case 38:                builder.append("&amp;");                break;            case 60:                builder.append("&lt;");                break;            case 62:                builder.append("&gt;");                break;            default:                builder.append(String.valueOf(character));        }    }}
public String pdfbox_f9287_0(String text, List<TextPosition> textPositions)
{    StringBuilder buffer = new StringBuilder();    if (text.length() == textPositions.size()) {                for (int i = 0; i < text.length(); i++) {            push(buffer, text.charAt(i), textPositions.get(i));        }    } else if (!text.isEmpty()) {                if (textPositions.isEmpty()) {            return text;        }        push(buffer, text.charAt(0), textPositions.get(0));        buffer.append(escape(text.substring(1)));    }    return buffer.toString();}
public String pdfbox_f9288_0()
{    StringBuilder buffer = new StringBuilder();    closeUntil(buffer, null);    stateList.clear();    stateSet.clear();    return buffer.toString();}
protected String pdfbox_f9289_0(StringBuilder buffer, char character, TextPosition textPosition)
{    boolean bold = false;    boolean italics = false;    PDFontDescriptor descriptor = textPosition.getFont().getFontDescriptor();    if (descriptor != null) {        bold = isBold(descriptor);        italics = isItalic(descriptor);    }    buffer.append(bold ? open("b") : close("b"));    buffer.append(italics ? open("i") : close("i"));    appendEscaped(buffer, character);    return buffer.toString();}
private String pdfbox_f9290_0(String tag)
{    if (stateSet.contains(tag)) {        return "";    }    stateList.add(tag);    stateSet.add(tag);    return openTag(tag);}
private String pdfbox_f9291_0(String tag)
{    if (!stateSet.contains(tag)) {        return "";    }        StringBuilder tagsBuilder = new StringBuilder();    int index = closeUntil(tagsBuilder, tag);        stateList.remove(index);    stateSet.remove(tag);        for (; index < stateList.size(); index++) {        tagsBuilder.append(openTag(stateList.get(index)));    }    return tagsBuilder.toString();}
private int pdfbox_f9292_0(StringBuilder tagsBuilder, String endTag)
{    for (int i = stateList.size(); i-- > 0; ) {        String tag = stateList.get(i);        tagsBuilder.append(closeTag(tag));        if (endTag != null && tag.equals(endTag)) {            return i;        }    }    return -1;}
private String pdfbox_f9293_0(String tag)
{    return "<" + tag + ">";}
private String pdfbox_f9294_0(String tag)
{    return "</" + tag + ">";}
private boolean pdfbox_f9295_0(PDFontDescriptor descriptor)
{    if (descriptor.isForceBold()) {        return true;    }    return descriptor.getFontName().contains("Bold");}
private boolean pdfbox_f9296_0(PDFontDescriptor descriptor)
{    if (descriptor.isItalic()) {        return true;    }    return descriptor.getFontName().contains("Italic");}
public static void pdfbox_f9297_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    @SuppressWarnings({ "squid:S2068" })    String password = "";    String pdfFile = null;    String outputPrefix = null;    String imageFormat = "jpg";    int startPage = 1;    int endPage = Integer.MAX_VALUE;    String color = "rgb";    int dpi;    float quality = -1;    float cropBoxLowerLeftX = 0;    float cropBoxLowerLeftY = 0;    float cropBoxUpperRightX = 0;    float cropBoxUpperRightY = 0;    boolean showTime = false;    boolean subsampling = false;    try {        dpi = Toolkit.getDefaultToolkit().getScreenResolution();    } catch (HeadlessException e) {        dpi = 96;    }    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case START_PAGE:                i++;                if (i >= args.length) {                    usage();                }                startPage = Integer.parseInt(args[i]);                break;            case END_PAGE:                i++;                if (i >= args.length) {                    usage();                }                endPage = Integer.parseInt(args[i]);                break;            case PAGE:                i++;                if (i >= args.length) {                    usage();                }                startPage = Integer.parseInt(args[i]);                endPage = Integer.parseInt(args[i]);                break;            case IMAGE_TYPE:            case FORMAT:                i++;                imageFormat = args[i];                break;            case OUTPUT_PREFIX:            case PREFIX:                i++;                outputPrefix = args[i];                break;            case COLOR:                i++;                color = args[i];                break;            case RESOLUTION:            case DPI:                i++;                dpi = Integer.parseInt(args[i]);                break;            case QUALITY:                i++;                quality = Float.parseFloat(args[i]);                break;            case CROPBOX:                i++;                cropBoxLowerLeftX = Float.valueOf(args[i]);                i++;                cropBoxLowerLeftY = Float.valueOf(args[i]);                i++;                cropBoxUpperRightX = Float.valueOf(args[i]);                i++;                cropBoxUpperRightY = Float.valueOf(args[i]);                break;            case TIME:                showTime = true;                break;            case SUBSAMPLING:                subsampling = true;                break;            default:                if (pdfFile == null) {                    pdfFile = args[i];                }                break;        }    }    if (pdfFile == null) {        usage();    } else {        if (outputPrefix == null) {            outputPrefix = pdfFile.substring(0, pdfFile.lastIndexOf('.'));        }        if (quality < 0) {            quality = "png".equals(imageFormat) ? 0f : 1f;        }        try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {            PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();            if (acroForm != null && acroForm.getNeedAppearances()) {                acroForm.refreshAppearances();            }            ImageType imageType = null;            if ("bilevel".equalsIgnoreCase(color)) {                imageType = ImageType.BINARY;            } else if ("gray".equalsIgnoreCase(color)) {                imageType = ImageType.GRAY;            } else if ("rgb".equalsIgnoreCase(color)) {                imageType = ImageType.RGB;            } else if ("rgba".equalsIgnoreCase(color)) {                imageType = ImageType.ARGB;            }            if (imageType == null) {                System.err.println("Error: Invalid color.");                System.exit(2);            }                        if (Float.compare(cropBoxLowerLeftX, 0) != 0 || Float.compare(cropBoxLowerLeftY, 0) != 0 || Float.compare(cropBoxUpperRightX, 0) != 0 || Float.compare(cropBoxUpperRightY, 0) != 0) {                changeCropBox(document, cropBoxLowerLeftX, cropBoxLowerLeftY, cropBoxUpperRightX, cropBoxUpperRightY);            }            long startTime = System.nanoTime();                        boolean success = true;            endPage = Math.min(endPage, document.getNumberOfPages());            PDFRenderer renderer = new PDFRenderer(document);            renderer.setSubsamplingAllowed(subsampling);            for (int i = startPage - 1; i < endPage; i++) {                BufferedImage image = renderer.renderImageWithDPI(i, dpi, imageType);                String fileName = outputPrefix + (i + 1) + "." + imageFormat;                success &= ImageIOUtil.writeImage(image, fileName, dpi, quality);            }                        long endTime = System.nanoTime();            long duration = endTime - startTime;            int count = 1 + endPage - startPage;            if (showTime) {                System.err.printf("Rendered %d page%s in %dms\n", count, count == 1 ? "" : "s", duration / 1000000);            }            if (!success) {                System.err.println("Error: no writer found for image format '" + imageFormat + "'");                System.exit(1);            }        }    }}
private static void pdfbox_f9298_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PDFToImage [options] <inputfile>\n" + "\nOptions:\n" + "  -password  <password>            : Password to decrypt document\n" + "  -format <string>                 : Available image formats: " + getImageFormats() + "\n" + "  -prefix <string>                 : Filename prefix for image files\n" + "  -page <int>                      : The only page to extract (1-based)\n" + "  -startPage <int>                 : The first page to start extraction (1-based)\n" + "  -endPage <int>                   : The last page to extract (inclusive)\n" + "  -color <string>                  : The color depth (valid: bilevel, gray, rgb (default), rgba)\n" + "  -dpi <int>                       : The DPI of the output image, default: screen resolution or 96 if unknown\n" + "  -quality <float>                 : The quality to be used when compressing the image (0 <= quality <= 1)\n" + "                                     (default: 0 for PNG and 1 for the other formats)\n" + "  -cropbox <int> <int> <int> <int> : The page area to export\n" + "  -time                            : Prints timing information to stdout\n" + "  -subsampling                     : Activate subsampling (for PDFs with huge images)\n" + "  <inputfile>                      : The PDF document to use\n";    System.err.println(message);    System.exit(1);}
private static String pdfbox_f9299_0()
{    StringBuilder retval = new StringBuilder();    String[] formats = ImageIO.getWriterFormatNames();    for (int i = 0; i < formats.length; i++) {        if (formats[i].equalsIgnoreCase(formats[i])) {            retval.append(formats[i]);            if (i + 1 < formats.length) {                retval.append(", ");            }        }    }    return retval.toString();}
private static void pdfbox_f9300_0(PDDocument document, float a, float b, float c, float d)
{    for (PDPage page : document.getPages()) {        System.out.println("resizing page");        PDRectangle rectangle = new PDRectangle();        rectangle.setLowerLeftX(a);        rectangle.setLowerLeftY(b);        rectangle.setUpperRightX(c);        rectangle.setUpperRightY(d);        page.setCropBox(rectangle);    }}
public static void pdfbox_f9301_0(String[] args) throws PrinterException, IOException
{        System.setProperty("apple.awt.UIElement", "true");    @SuppressWarnings({ "squid:S2068" })    String password = "";    String pdfFile = null;    boolean silentPrint = false;    String printerName = null;    Orientation orientation = Orientation.AUTO;    boolean showPageBorder = false;    int dpi = 0;    Map<String, Orientation> orientationMap = new HashMap<>();    orientationMap.put("auto", Orientation.AUTO);    orientationMap.put("landscape", Orientation.LANDSCAPE);    orientationMap.put("portrait", Orientation.PORTRAIT);    RenderingHints renderingHints = null;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case PRINTER_NAME:                i++;                if (i >= args.length) {                    usage();                }                printerName = args[i];                break;            case SILENT:                silentPrint = true;                break;            case ORIENTATION:                i++;                if (i >= args.length) {                    usage();                }                orientation = orientationMap.get(args[i]);                if (orientation == null) {                    usage();                }                break;            case BORDER:                showPageBorder = true;                break;            case DPI:                i++;                if (i >= args.length) {                    usage();                }                dpi = Integer.parseInt(args[i]);                break;            case NOCOLOROPT:                renderingHints = new RenderingHints(null);                renderingHints.put(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);                renderingHints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);                renderingHints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);                break;            default:                pdfFile = args[i];                break;        }    }    if (pdfFile == null) {        usage();    }    try (PDDocument document = PDDocument.load(new File(pdfFile), password)) {        AccessPermission ap = document.getCurrentAccessPermission();        if (!ap.canPrint()) {            throw new IOException("You do not have permission to print");        }        PrinterJob printJob = PrinterJob.getPrinterJob();        printJob.setJobName(new File(pdfFile).getName());        if (printerName != null) {            PrintService[] printServices = PrinterJob.lookupPrintServices();            boolean printerFound = false;            for (int i = 0; !printerFound && i < printServices.length; i++) {                if (printServices[i].getName().equals(printerName)) {                    printJob.setPrintService(printServices[i]);                    printerFound = true;                }            }            if (!printerFound) {                System.err.println("printer '" + printerName + "' not found, using default");                showAvailablePrinters();            }        }        PDFPageable pageable = new PDFPageable(document, orientation, showPageBorder, dpi);        pageable.setRenderingHints(renderingHints);        printJob.setPageable(pageable);        if (silentPrint || printJob.printDialog()) {            printJob.print();        }    }}
private static void pdfbox_f9302_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar PrintPDF [options] <inputfile>\n" + "\nOptions:\n" + "  -password  <password>                : Password to decrypt document\n" + "  -printerName <name>                  : Print to specific printer\n" + "  -orientation auto|portrait|landscape : Print using orientation\n" + "                                           (default: auto)\n" + "  -border                              : Print with border\n" + "  -dpi                                 : Render into intermediate image with\n" + "                                           specific dpi and then print\n" + "  -noColorOpt                          : Disable color optimizations\n" + "                                           (useful when printing barcodes)\n" + "  -silentPrint                         : Print without printer dialog box\n";    System.err.println(message);    showAvailablePrinters();    System.exit(1);}
private static void pdfbox_f9303_0()
{    System.err.println("Available printer names:");    PrintService[] printServices = PrinterJob.lookupPrintServices();    for (PrintService printService : printServices) {        System.err.println("    " + printService.getName());    }}
public PDDocument pdfbox_f9304_0(Reader text) throws IOException
{    PDDocument doc = new PDDocument();    createPDFFromText(doc, text);    return doc;}
public void pdfbox_f9305_0(PDDocument doc, Reader text) throws IOException
{    try {        final int margin = 40;        float height = font.getBoundingBox().getHeight() / FONTSCALE;        PDRectangle actualMediaBox = mediaBox;        if (landscape) {            actualMediaBox = new PDRectangle(mediaBox.getHeight(), mediaBox.getWidth());        }                height = height * fontSize * LINE_HEIGHT_FACTOR;        BufferedReader data = new BufferedReader(text);        String nextLine;        PDPage page = new PDPage(actualMediaBox);        PDPageContentStream contentStream = null;        float y = -1;        float maxStringLength = page.getMediaBox().getWidth() - 2 * margin;                boolean textIsEmpty = true;        while ((nextLine = data.readLine()) != null) {                                                textIsEmpty = false;            String[] lineWords = nextLine.replaceAll("[\\n\\r]+$", "").split(" ");            int lineIndex = 0;            while (lineIndex < lineWords.length) {                StringBuilder nextLineToDraw = new StringBuilder();                float lengthIfUsingNextWord = 0;                boolean ff = false;                do {                    String word1, word2 = "";                    int indexFF = lineWords[lineIndex].indexOf('\f');                    if (indexFF == -1) {                        word1 = lineWords[lineIndex];                    } else {                        ff = true;                        word1 = lineWords[lineIndex].substring(0, indexFF);                        if (indexFF < lineWords[lineIndex].length()) {                            word2 = lineWords[lineIndex].substring(indexFF + 1);                        }                    }                                        if (word1.length() > 0 || !ff) {                        nextLineToDraw.append(word1);                        nextLineToDraw.append(" ");                    }                    if (!ff || word2.length() == 0) {                        lineIndex++;                    } else {                        lineWords[lineIndex] = word2;                    }                    if (ff) {                        break;                    }                    if (lineIndex < lineWords.length) {                                                String nextWord = lineWords[lineIndex];                        indexFF = nextWord.indexOf('\f');                        if (indexFF != -1) {                            nextWord = nextWord.substring(0, indexFF);                        }                        String lineWithNextWord = nextLineToDraw.toString() + " " + nextWord;                        lengthIfUsingNextWord = (font.getStringWidth(lineWithNextWord) / FONTSCALE) * fontSize;                    }                } while (lineIndex < lineWords.length && lengthIfUsingNextWord < maxStringLength);                if (y < margin) {                                                            page = new PDPage(actualMediaBox);                    doc.addPage(page);                    if (contentStream != null) {                        contentStream.endText();                        contentStream.close();                    }                    contentStream = new PDPageContentStream(doc, page);                    contentStream.setFont(font, fontSize);                    contentStream.beginText();                    y = page.getMediaBox().getHeight() - margin + height;                    contentStream.newLineAtOffset(margin, y);                }                if (contentStream == null) {                    throw new IOException("Error:Expected non-null content stream.");                }                contentStream.newLineAtOffset(0, -height);                y -= height;                contentStream.showText(nextLineToDraw.toString());                if (ff) {                    page = new PDPage(actualMediaBox);                    doc.addPage(page);                    contentStream.endText();                    contentStream.close();                    contentStream = new PDPageContentStream(doc, page);                    contentStream.setFont(font, fontSize);                    contentStream.beginText();                    y = page.getMediaBox().getHeight() - margin + height;                    contentStream.newLineAtOffset(margin, y);                }            }        }                if (textIsEmpty) {            doc.addPage(page);        }        if (contentStream != null) {            contentStream.endText();            contentStream.close();        }    } catch (IOException io) {        if (doc != null) {            doc.close();        }        throw io;    }}
public static void pdfbox_f9306_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    TextToPDF app = new TextToPDF();    try (PDDocument doc = new PDDocument()) {        if (args.length < 2) {            app.usage();        } else {            for (int i = 0; i < args.length - 2; i++) {                switch(args[i]) {                    case "-standardFont":                        i++;                        app.setFont(getStandardFont(args[i]));                        break;                    case "-ttf":                        i++;                        PDFont font = PDType0Font.load(doc, new File(args[i]));                        app.setFont(font);                        break;                    case "-fontSize":                        i++;                        app.setFontSize(Integer.parseInt(args[i]));                        break;                    case "-pageSize":                        i++;                        PDRectangle rectangle = createRectangle(args[i]);                        if (rectangle == null) {                            throw new IOException("Unknown argument: " + args[i]);                        }                        app.setMediaBox(rectangle);                        break;                    case "-landscape":                        app.setLandscape(true);                        break;                    default:                        throw new IOException("Unknown argument: " + args[i]);                }            }            try (FileReader fileReader = new FileReader(args[args.length - 1])) {                app.createPDFFromText(doc, fileReader);            }            doc.save(args[args.length - 2]);        }    }}
private static PDRectangle pdfbox_f9307_0(String paperSize)
{    if ("letter".equalsIgnoreCase(paperSize)) {        return PDRectangle.LETTER;    } else if ("legal".equalsIgnoreCase(paperSize)) {        return PDRectangle.LEGAL;    } else if ("A0".equalsIgnoreCase(paperSize)) {        return PDRectangle.A0;    } else if ("A1".equalsIgnoreCase(paperSize)) {        return PDRectangle.A1;    } else if ("A2".equalsIgnoreCase(paperSize)) {        return PDRectangle.A2;    } else if ("A3".equalsIgnoreCase(paperSize)) {        return PDRectangle.A3;    } else if ("A4".equalsIgnoreCase(paperSize)) {        return PDRectangle.A4;    } else if ("A5".equalsIgnoreCase(paperSize)) {        return PDRectangle.A5;    } else if ("A6".equalsIgnoreCase(paperSize)) {        return PDRectangle.A6;    } else {        return null;    }}
private void pdfbox_f9308_0()
{    String[] std14 = getStandard14Names();    StringBuilder message = new StringBuilder();    message.append("Usage: jar -jar pdfbox-app-x.y.z.jar TextToPDF [options] <outputfile> <textfile>\n");    message.append("\nOptions:\n");    message.append("  -standardFont <name> : ").append(DEFAULT_FONT.getBaseFont()).append(" (default)\n");    for (String std14String : std14) {        message.append("                         ").append(std14String).append("\n");    }    message.append("  -ttf <ttf file>      : The TTF font to use.\n");    message.append("  -fontSize <fontSize> : default: ").append(DEFAULT_FONT_SIZE).append("\n");    message.append("  -pageSize <pageSize> : Letter (default)\n");    message.append("                         Legal\n");    message.append("                         A0\n");    message.append("                         A1\n");    message.append("                         A2\n");    message.append("                         A3\n");    message.append("                         A4\n");    message.append("                         A5\n");    message.append("                         A6\n");    message.append("  -landscape           : sets orientation to landscape");    System.err.println(message.toString());    System.exit(1);}
private static PDType1Font pdfbox_f9309_0(String name)
{    return STANDARD_14.get(name);}
private static String[] pdfbox_f9310_0()
{    return STANDARD_14.keySet().toArray(new String[14]);}
public PDFont pdfbox_f9311_0()
{    return font;}
public void pdfbox_f9312_0(PDFont aFont)
{    this.font = aFont;}
public int pdfbox_f9313_0()
{    return fontSize;}
public void pdfbox_f9314_0(int aFontSize)
{    this.fontSize = aFontSize;}
public PDRectangle pdfbox_f9315_0()
{    return mediaBox;}
public void pdfbox_f9316_0(PDRectangle mediaBox)
{    this.mediaBox = mediaBox;}
public boolean pdfbox_f9317_0()
{    return landscape;}
public void pdfbox_f9318_0(boolean landscape)
{    this.landscape = landscape;}
public static String pdfbox_f9319_0()
{    String version = org.apache.pdfbox.util.Version.getVersion();    if (version != null) {        return version;    } else {        return "unknown";    }}
public static void pdfbox_f9320_0(String[] args)
{        System.setProperty("apple.awt.UIElement", "true");    if (args.length != 0) {        usage();        return;    }    System.out.println("Version:" + getVersion());}
private static void pdfbox_f9321_0()
{    System.err.println("Usage: " + Version.class.getName());    System.exit(1);}
public void pdfbox_f9322_0(String in, String out, String password, boolean skipImages) throws IOException
{    try (PDDocument doc = PDDocument.load(new File(in), password)) {        doc.setAllSecurityToBeRemoved(true);        for (COSObject cosObject : doc.getDocument().getObjects()) {            COSBase base = cosObject.getObject();            if (base instanceof COSStream) {                COSStream stream = (COSStream) base;                if (skipImages && COSName.XOBJECT.equals(stream.getItem(COSName.TYPE)) && COSName.IMAGE.equals(stream.getItem(COSName.SUBTYPE))) {                    continue;                }                byte[] bytes;                try {                    bytes = new PDStream(stream).toByteArray();                } catch (IOException ex) {                    System.err.println("skip " + cosObject.getObjectNumber() + " " + cosObject.getGenerationNumber() + " obj: " + ex.getMessage());                    continue;                }                stream.removeItem(COSName.FILTER);                try (OutputStream streamOut = stream.createOutputStream()) {                    streamOut.write(bytes);                }            }        }        doc.getDocumentCatalog();        doc.save(out);    }}
public static void pdfbox_f9323_0(String[] args) throws IOException
{        System.setProperty("apple.awt.UIElement", "true");    WriteDecodedDoc app = new WriteDecodedDoc();    @SuppressWarnings({ "squid:S2068" })    String password = "";    String pdfFile = null;    String outputFile = null;    boolean skipImages = false;    for (int i = 0; i < args.length; i++) {        switch(args[i]) {            case PASSWORD:                i++;                if (i >= args.length) {                    usage();                }                password = args[i];                break;            case SKIPIMAGES:                skipImages = true;                break;            default:                if (pdfFile == null) {                    pdfFile = args[i];                } else {                    outputFile = args[i];                }                break;        }    }    if (pdfFile == null) {        usage();    } else {        if (outputFile == null) {            outputFile = calculateOutputFilename(pdfFile);        }        app.doIt(pdfFile, outputFile, password, skipImages);    }}
private static String pdfbox_f9324_0(String filename)
{    String outputFilename;    if (filename.toLowerCase().endsWith(".pdf")) {        outputFilename = filename.substring(0, filename.length() - 4);    } else {        outputFilename = filename;    }    outputFilename += "_unc.pdf";    return outputFilename;}
private static void pdfbox_f9325_0()
{    String message = "Usage: java -jar pdfbox-app-x.y.z.jar WriteDecodedDoc [options] <inputfile> [outputfile]\n" + "\nOptions:\n" + "  -password <password> : Password to decrypt the document\n" + "  -skipImages          : Don't uncompress images\n" + "  <inputfile>          : The PDF document to be decompressed\n" + "  [outputfile]         : The filename for the decompressed pdf\n";    System.err.println(message);    System.exit(1);}
 void pdfbox_f9326_0(PDResources resources) throws IOException
{    if (resources == null) {        return;    }    for (COSName name : resources.getXObjectNames()) {        PDXObject xobject = resources.getXObject(name);        if (xobject instanceof PDImageXObject) {            PDImageXObject imageObject = (PDImageXObject) xobject;            String suffix = imageObject.getSuffix();            if (suffix != null) {                if ("jpx".equals(suffix)) {                    suffix = "JPEG2000";                }                if ("jb2".equals(suffix)) {                                        suffix = "PNG";                }                boolean writeOK = ImageIOUtil.writeImage(imageObject.getImage(), suffix, new ByteArrayOutputStream());                assertTrue(writeOK);            }        } else if (xobject instanceof PDFormXObject) {            checkSaveResources(((PDFormXObject) xobject).getResources());        }    }}
private void pdfbox_f9327_1(File file, String outDir) throws IOException
{    PDDocument document = null;        try {                float dpi = 36;        document = PDDocument.load(file);                checkSaveResources(document.getPage(0).getResources());                String imageType = "png";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 0, "");        checkResolution(outDir + file.getName() + "-1." + imageType, (int) dpi);        checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.PNG);                imageType = "jpg";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 0.5f, "");        checkResolution(outDir + file.getName() + "-1." + imageType, (int) dpi);        checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.JPEG);                imageType = "bmp";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 1, "");        checkResolution(outDir + file.getName() + "-1." + imageType, (int) dpi);        checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.BMP);                imageType = "gif";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.RGB, dpi, 1, "");                checkFileTypeByContent(outDir + file.getName() + "-1." + imageType, FileType.GIF);                imageType = "wbmp";        writeImage(document, imageType, outDir + file.getName() + "-", ImageType.BINARY, dpi, 1, "");                        imageType = "tif";        writeImage(document, imageType, outDir + file.getName() + "-bw-", ImageType.BINARY, dpi, 1, "");        checkResolution(outDir + file.getName() + "-bw-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-bw-1." + imageType, "CCITT T.6");        checkFileTypeByContent(outDir + file.getName() + "-bw-1." + imageType, FileType.TIFF);        writeImage(document, imageType, outDir + file.getName() + "-coLZW-", ImageType.RGB, dpi, 1, "");        checkResolution(outDir + file.getName() + "-coLZW-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-coLZW-1." + imageType, "LZW");        checkFileTypeByContent(outDir + file.getName() + "-coLZW-1." + imageType, FileType.TIFF);        writeImage(document, imageType, outDir + file.getName() + "-coJPEG-", ImageType.RGB, dpi, 0.5f, "JPEG");        checkResolution(outDir + file.getName() + "-coJPEG-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-coJPEG-1." + imageType, "JPEG");        checkFileTypeByContent(outDir + file.getName() + "-coJPEG-1." + imageType, FileType.TIFF);        writeImage(document, imageType, outDir + file.getName() + "-coNone-", ImageType.RGB, dpi, 1, null);        checkResolution(outDir + file.getName() + "-coNone-1." + imageType, (int) dpi);        checkTiffCompression(outDir + file.getName() + "-coNone-1." + imageType, "None");        checkFileTypeByContent(outDir + file.getName() + "-coNone-1." + imageType, FileType.TIFF);    } finally {        if (document != null) {            document.close();        }    }}
private void pdfbox_f9328_0(String filename, BufferedImage image) throws IOException
{    BufferedImage newImage = ImageIO.read(new File(filename));    assertNotNull("File '" + filename + "' could not be read", newImage);    checkNotBlank(filename, newImage);    checkBufferedImageSize(filename, image, newImage);    for (int x = 0; x < image.getWidth(); ++x) {        for (int y = 0; y < image.getHeight(); ++y) {            if (image.getRGB(x, y) != newImage.getRGB(x, y)) {                assertEquals("\"File '" + filename + "' has different pixel at (" + x + "," + y + ")", new Color(image.getRGB(x, y)), new Color(newImage.getRGB(x, y)));            }        }    }}
private void pdfbox_f9329_0(String filename, BufferedImage image) throws IOException
{    BufferedImage newImage = ImageIO.read(new File(filename));    assertNotNull("File '" + filename + "' could not be read", newImage);    checkNotBlank(filename, newImage);    checkBufferedImageSize(filename, image, newImage);}
private void pdfbox_f9330_0(String filename, BufferedImage image, BufferedImage newImage) throws IOException
{    assertEquals("File '" + filename + "' has different height after read", image.getHeight(), newImage.getHeight());    assertEquals("File '" + filename + "' has different width after read", image.getWidth(), newImage.getWidth());}
private void pdfbox_f9331_0(String filename, BufferedImage newImage)
{        Set<Integer> colors = new HashSet<>();    int w = newImage.getWidth();    int h = newImage.getHeight();    for (int x = 0; x < w; x++) {        for (int y = 0; y < h; y++) {            colors.add(newImage.getRGB(x, y));        }    }    assertFalse("File '" + filename + "' has less than two colors", colors.size() < 2);}
private void pdfbox_f9332_1(PDDocument document, String imageFormat, String outputPrefix, ImageType imageType, float dpi, float compressionQuality, String compressionType) throws IOException
{    PDFRenderer renderer = new PDFRenderer(document);    BufferedImage image = renderer.renderImageWithDPI(0, dpi, imageType);    String fileName = outputPrefix + 1;            System.out.println("  " + fileName + "." + imageFormat);    try (OutputStream os = new FileOutputStream(fileName + "." + imageFormat)) {        boolean res = ImageIOUtil.writeImage(image, imageFormat, os, Math.round(dpi), compressionQuality, compressionType);        assertTrue("ImageIOUtil.writeImage() failed for file " + fileName, res);    }    if ("jpg".equals(imageFormat) || "gif".equals(imageFormat) || "JPEG".equals(compressionType)) {                        checkImageFileSize(fileName + "." + imageFormat, image);    } else {        checkImageFileSizeAndContent(fileName + "." + imageFormat, image);    }}
public void pdfbox_f9333_0() throws Exception
{    String inDir = "src/test/resources/input/ImageIOUtil";    String outDir = "target/test-output/ImageIOUtil/";    new File(outDir).mkdirs();    if (!new File(outDir).exists()) {        throw new IOException("could not create output directory");    }    File[] testFiles = new File(inDir).listFiles((dir, name) -> (name.endsWith(".pdf") || name.endsWith(".ai")));    for (File file : testFiles) {        doTestFile(file, outDir);    }}
private void pdfbox_f9334_0(String filename, int expectedResolution) throws IOException
{    assertFalse("Empty file " + filename, new File(filename).length() == 0);    String suffix = filename.substring(filename.lastIndexOf('.') + 1);    if ("BMP".equals(suffix.toUpperCase())) {                checkBmpResolution(filename, expectedResolution);        return;    }    Iterator readers = ImageIO.getImageReadersBySuffix(suffix);    assertTrue("No image reader found for suffix " + suffix, readers.hasNext());    ImageReader reader = (ImageReader) readers.next();    try (ImageInputStream iis = ImageIO.createImageInputStream(new File(filename))) {        assertNotNull("No ImageInputStream created for file " + filename, iis);        reader.setInput(iis);        IIOMetadata imageMetadata = reader.getImageMetadata(0);        Element root = (Element) imageMetadata.getAsTree(STANDARD_METADATA_FORMAT);        NodeList dimensionNodes = root.getElementsByTagName("Dimension");        assertTrue("No resolution found in image file " + filename, dimensionNodes.getLength() > 0);        Element dimensionElement = (Element) dimensionNodes.item(0);        NodeList pixelSizeNodes = dimensionElement.getElementsByTagName("HorizontalPixelSize");        assertTrue("No X resolution found in image file " + filename, pixelSizeNodes.getLength() > 0);        Node pixelSizeNode = pixelSizeNodes.item(0);        String val = pixelSizeNode.getAttributes().getNamedItem("value").getNodeValue();        int actualResolution = (int) Math.round(25.4 / Double.parseDouble(val));        assertEquals("X resolution doesn't match in image file " + filename, expectedResolution, actualResolution);        pixelSizeNodes = dimensionElement.getElementsByTagName("VerticalPixelSize");        assertTrue("No Y resolution found in image file " + filename, pixelSizeNodes.getLength() > 0);        pixelSizeNode = pixelSizeNodes.item(0);        val = pixelSizeNode.getAttributes().getNamedItem("value").getNodeValue();        actualResolution = (int) Math.round(25.4 / Double.parseDouble(val));        assertEquals("Y resolution doesn't match", expectedResolution, actualResolution);    }    reader.dispose();}
private void pdfbox_f9335_0(String filename, int expectedResolution) throws FileNotFoundException, IOException
{        try (DataInputStream dis = new DataInputStream(new FileInputStream(new File(filename)))) {        int skipped = dis.skipBytes(38);        assertEquals("Can't skip 38 bytes in image file " + filename, 38, skipped);        int pixelsPerMeter = Integer.reverseBytes(dis.readInt());        int actualResolution = (int) Math.round(pixelsPerMeter / 100.0 * 2.54);        assertEquals("X resolution doesn't match in image file " + filename, expectedResolution, actualResolution);        pixelsPerMeter = Integer.reverseBytes(dis.readInt());        actualResolution = (int) Math.round(pixelsPerMeter / 100.0 * 2.54);        assertEquals("Y resolution doesn't match in image file " + filename, expectedResolution, actualResolution);    }}
 void pdfbox_f9336_0(String filename, String expectedCompression) throws IOException
{    Iterator readers = ImageIO.getImageReadersBySuffix("tiff");    ImageReader reader = (ImageReader) readers.next();    try (ImageInputStream iis = ImageIO.createImageInputStream(new File(filename))) {        reader.setInput(iis);        IIOMetadata imageMetadata = reader.getImageMetadata(0);        Element root = (Element) imageMetadata.getAsTree(STANDARD_METADATA_FORMAT);        Element comprElement = (Element) root.getElementsByTagName("Compression").item(0);        Node comprTypeNode = comprElement.getElementsByTagName("CompressionTypeName").item(0);        String actualCompression = comprTypeNode.getAttributes().getNamedItem("value").getNodeValue();        assertEquals("Incorrect TIFF compression in file " + filename, expectedCompression, actualCompression);    }    reader.dispose();}
private void pdfbox_f9337_0(String filename, FileType fileType) throws IOException
{    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filename));    assertEquals(fileType, FileTypeDetector.detectFileType(bis));    IOUtils.closeQuietly(bis);}
public void pdfbox_f9338_0() throws Exception
{    ByteArrayOutputStream outBytes = new ByteArrayOutputStream();    PrintStream stdout = System.out;    System.setOut(new PrintStream(outBytes));    try {        ExtractText.main(new String[] { "src/test/resources/org/apache/pdfbox/testPDFPackage.pdf", "-console", "-encoding UTF-8" });    } finally {                System.setOut(stdout);    }    String result = outBytes.toString("UTF-8");    assertTrue(result.contains("PDF1"));    assertTrue(result.contains("PDF2"));}
private PDDocument pdfbox_f9339_0(String title, PDFont font, String text) throws IOException
{    PDDocument doc = new PDDocument();    doc.getDocumentInformation().setTitle(title);    PDPage page = new PDPage();    doc.addPage(page);    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page)) {        contentStream.beginText();        contentStream.setFont(font, 12);        contentStream.newLineAtOffset(100, 700);        contentStream.showText(text);        contentStream.endText();    }    return doc;}
public void pdfbox_f9340_0() throws IOException
{    PDFTextStripper stripper = new PDFText2HTML();    PDDocument doc = createDocument("<script>\u3042", PDType1Font.HELVETICA, "<foo>");    String text = stripper.getText(doc);    Matcher m = Pattern.compile("<title>(.*?)</title>").matcher(text);    assertTrue(m.find());    assertEquals("&lt;script&gt;&#12354;", m.group(1));    assertTrue(text.contains("&lt;foo&gt;"));}
public void pdfbox_f9341_0() throws IOException
{    PDFTextStripper stripper = new PDFText2HTML();    PDDocument doc = createDocument("t", PDType1Font.HELVETICA_BOLD, "<bold>");    String text = stripper.getText(doc);    Matcher bodyMatcher = Pattern.compile("<p>(.*?)</p>").matcher(text);    assertTrue("body p exists", bodyMatcher.find());    assertEquals("body p", "<b>&lt;bold&gt;</b>", bodyMatcher.group(1));}
public void pdfbox_f9342_0() throws Exception
{    TextToPDF pdfCreator = new TextToPDF();    PDDocument pdfDoc;    try (StringReader reader = new StringReader("")) {        pdfDoc = pdfCreator.createPDFFromText(reader);    }            int pageCount = pdfDoc.getNumberOfPages();    assertNotNull("All Pages was unexpectedly zero.", pageCount);    assertEquals("Wrong number of pages.", 1, pageCount);    pdfDoc.close();}
public static Test pdfbox_f9343_0()
{    return new TestSuite(TestTextToPdf.class);}
public static void pdfbox_f9344_0(String[] args)
{    String[] arg = { TestTextToPdf.class.getName() };    junit.textui.TestRunner.main(arg);}
public static Calendar pdfbox_f9345_0(String date) throws IOException
{    Calendar retval = null;    if ((date != null) && (date.trim().length() > 0)) {                int month = 1;        int day = 1;        int hour = 0;        int minute = 0;        int second = 0;                try {            SimpleTimeZone zone = null;            if (Pattern.matches("^\\d{4}-\\d{2}-\\d{2}T.*", date)) {                                return fromISO8601(date);            } else if (date.startsWith("D:")) {                date = date.substring(2, date.length());            }            date = date.replaceAll("[-:T]", "");            if (date.length() < 4) {                throw new IOException("Error: Invalid date format '" + date + "'");            }            int year = Integer.parseInt(date.substring(0, 4));            if (date.length() >= 6) {                month = Integer.parseInt(date.substring(4, 6));            }            if (date.length() >= 8) {                day = Integer.parseInt(date.substring(6, 8));            }            if (date.length() >= 10) {                hour = Integer.parseInt(date.substring(8, 10));            }            if (date.length() >= 12) {                minute = Integer.parseInt(date.substring(10, 12));            }            int timeZonePos = 12;            if (date.length() - 12 > 5 || (date.length() - 12 == 3 && date.endsWith("Z"))) {                if (date.length() >= 14) {                    second = Integer.parseInt(date.substring(12, 14));                }                timeZonePos = 14;            } else {                second = 0;            }            if (date.length() >= (timeZonePos + 1)) {                char sign = date.charAt(timeZonePos);                if (sign == 'Z') {                    zone = new SimpleTimeZone(0, "Unknown");                } else {                    int hours = 0;                    int minutes = 0;                    if (date.length() >= (timeZonePos + 3)) {                        if (sign == '+') {                                                        hours = Integer.parseInt(date.substring((timeZonePos + 1), (timeZonePos + 3)));                        } else {                            hours = -Integer.parseInt(date.substring(timeZonePos, (timeZonePos + 2)));                        }                    }                    if (sign == '+') {                        if (date.length() >= (timeZonePos + 5)) {                            minutes = Integer.parseInt(date.substring((timeZonePos + 3), (timeZonePos + 5)));                        }                    } else {                        if (date.length() >= (timeZonePos + 4)) {                            minutes = Integer.parseInt(date.substring((timeZonePos + 2), (timeZonePos + 4)));                        }                    }                    zone = new SimpleTimeZone(hours * 60 * 60 * 1000 + minutes * 60 * 1000, "Unknown");                }            }            if (zone == null) {                retval = new GregorianCalendar();            } else {                updateZoneId(zone);                retval = new GregorianCalendar(zone);            }            retval.clear();            retval.set(year, month - 1, day, hour, minute, second);        } catch (NumberFormatException e) {                        if (date.substring(date.length() - 3, date.length() - 2).equals(":") && (date.substring(date.length() - 6, date.length() - 5).equals("+") || date.substring(date.length() - 6, date.length() - 5).equals("-"))) {                                date = date.substring(0, date.length() - 3) + date.substring(date.length() - 2);            }            for (int i = 0; (retval == null) && (i < POTENTIAL_FORMATS.length); i++) {                try {                    Date utilDate = POTENTIAL_FORMATS[i].parse(date);                    retval = new GregorianCalendar();                    retval.setTime(utilDate);                } catch (ParseException pe) {                                }            }            if (retval == null) {                                throw new IOException("Error converting date:" + date, e);            }        }    }    return retval;}
private static void pdfbox_f9346_0(TimeZone tz)
{    int offset = tz.getRawOffset();    char pm = '+';    if (offset < 0) {        pm = '-';        offset = -offset;    }    int hh = offset / 3600000;    int mm = offset % 3600000 / 60000;    if (offset == 0) {        tz.setID("GMT");    } else if (pm == '+' && hh <= 12) {        tz.setID(String.format(Locale.US, "GMT+%02d:%02d", hh, mm));    } else if (pm == '-' && hh <= 14) {        tz.setID(String.format(Locale.US, "GMT-%02d:%02d", hh, mm));    } else {        tz.setID("unknown");    }}
public static String pdfbox_f9347_0(Calendar cal)
{    return toISO8601(cal, false);}
public static String pdfbox_f9348_0(Calendar cal, boolean printMillis)
{    StringBuilder retval = new StringBuilder();    retval.append(cal.get(Calendar.YEAR));    retval.append("-");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.MONTH) + 1));    retval.append("-");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.DAY_OF_MONTH)));    retval.append("T");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.HOUR_OF_DAY)));    retval.append(":");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.MINUTE)));    retval.append(":");    retval.append(String.format(Locale.US, "%02d", cal.get(Calendar.SECOND)));    if (printMillis) {        retval.append(".");        retval.append(String.format(Locale.US, "%03d", cal.get(Calendar.MILLISECOND)));    }    int timeZone = cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET);    if (timeZone < 0) {        retval.append("-");    } else {        retval.append("+");    }    timeZone = Math.abs(timeZone);            int hours = timeZone / 1000 / 60 / 60;    int minutes = (timeZone - (hours * 1000 * 60 * 60)) / 1000 / 1000;    if (hours < 10) {        retval.append("0");    }    retval.append(Integer.toString(hours));    retval.append(":");    if (minutes < 10) {        retval.append("0");    }    retval.append(Integer.toString(minutes));    return retval.toString();}
private static Calendar pdfbox_f9349_0(String dateString)
{        Pattern timeZonePattern = Pattern.compile("[\\d-]*T?[\\d-\\.]([A-Z]{1,4})$|(.*\\d*)([A-Z][a-z]+\\/[A-Z][a-z]+)$");    Matcher timeZoneMatcher = timeZonePattern.matcher(dateString);    String timeZoneString = null;    while (timeZoneMatcher.find()) {        for (int i = 1; i <= timeZoneMatcher.groupCount(); i++) {            if (timeZoneMatcher.group(i) != null) {                timeZoneString = timeZoneMatcher.group(i);            }        }    }    if (timeZoneString != null) {                int teeIndex = dateString.indexOf('T');        int tzIndex = dateString.indexOf(timeZoneString);        String toParse = dateString.substring(0, tzIndex);        if (tzIndex - teeIndex == 6) {            toParse = dateString.substring(0, tzIndex) + ":00";        }        Calendar cal = javax.xml.bind.DatatypeConverter.parseDateTime(toParse);        TimeZone z = TimeZone.getTimeZone(timeZoneString);        cal.setTimeZone(z);        return cal;    } else {                int teeIndex = dateString.indexOf('T');        if (teeIndex == -1) {            return javax.xml.bind.DatatypeConverter.parseDateTime(dateString);        }        int plusIndex = dateString.indexOf('+', teeIndex + 1);        int minusIndex = dateString.indexOf('-', teeIndex + 1);        if (plusIndex == -1 && minusIndex == -1) {            return javax.xml.bind.DatatypeConverter.parseDateTime(dateString);        }        plusIndex = Math.max(plusIndex, minusIndex);        if (plusIndex - teeIndex == 6) {            String toParse = dateString.substring(0, plusIndex) + ":00" + dateString.substring(plusIndex);            return javax.xml.bind.DatatypeConverter.parseDateTime(toParse);        }        return javax.xml.bind.DatatypeConverter.parseDateTime(dateString);    }}
public void pdfbox_f9350_0(String value)
{    TextType keywords;    keywords = createTextType(KEYWORDS, value);    addProperty(keywords);}
public void pdfbox_f9351_0(TextType keywords)
{    addProperty(keywords);}
public void pdfbox_f9352_0(String value)
{    TextType version;    version = createTextType(PDF_VERSION, value);    addProperty(version);}
public void pdfbox_f9353_0(TextType version)
{    addProperty(version);}
public void pdfbox_f9354_0(String value)
{    TextType producer;    producer = createTextType(PRODUCER, value);    addProperty(producer);}
public void pdfbox_f9355_0(TextType producer)
{    addProperty(producer);}
public TextType pdfbox_f9356_0()
{    AbstractField tmp = getProperty(KEYWORDS);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
public String pdfbox_f9357_0()
{    AbstractField tmp = getProperty(KEYWORDS);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
public TextType pdfbox_f9358_0()
{    AbstractField tmp = getProperty(PDF_VERSION);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
public String pdfbox_f9359_0()
{    AbstractField tmp = getProperty(PDF_VERSION);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
public TextType pdfbox_f9360_0()
{    AbstractField tmp = getProperty(PRODUCER);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
public String pdfbox_f9361_0()
{    AbstractField tmp = getProperty(PRODUCER);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
public void pdfbox_f9362_0(String properName)
{    addQualifiedBagValue(CONTRIBUTOR, properName);}
public void pdfbox_f9363_0(String properName)
{    removeUnqualifiedBagValue(CONTRIBUTOR, properName);}
public void pdfbox_f9364_0(String text)
{    addProperty(createTextType(COVERAGE, text));}
public void pdfbox_f9365_0(TextType text)
{    addProperty(text);}
public void pdfbox_f9366_0(String properName)
{    addUnqualifiedSequenceValue(CREATOR, properName);}
public void pdfbox_f9367_0(String name)
{    removeUnqualifiedSequenceValue(CREATOR, name);}
public void pdfbox_f9368_0(Calendar date)
{    addUnqualifiedSequenceDateValue(DATE, date);}
public void pdfbox_f9369_0(Calendar date)
{    removeUnqualifiedSequenceDateValue(DATE, date);}
public void pdfbox_f9370_0(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(DESCRIPTION, lang, value);}
public void pdfbox_f9371_0(String value)
{    addDescription(null, value);}
public void pdfbox_f9372_0(String mimeType)
{    addProperty(createTextType(FORMAT, mimeType));}
public void pdfbox_f9373_0(String text)
{    addProperty(createTextType(IDENTIFIER, text));}
public void pdfbox_f9374_0(TextType text)
{    addProperty(text);}
public void pdfbox_f9375_0(String locale)
{    addQualifiedBagValue(LANGUAGE, locale);}
public void pdfbox_f9376_0(String locale)
{    removeUnqualifiedBagValue(LANGUAGE, locale);}
public void pdfbox_f9377_0(String properName)
{    addQualifiedBagValue(PUBLISHER, properName);}
public void pdfbox_f9378_0(String name)
{    removeUnqualifiedBagValue(PUBLISHER, name);}
public void pdfbox_f9379_0(String text)
{    addQualifiedBagValue(RELATION, text);}
public void pdfbox_f9380_0(String text)
{    removeUnqualifiedBagValue(RELATION, text);}
public void pdfbox_f9381_0(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(RIGHTS, lang, value);}
public void pdfbox_f9382_0(String text)
{    addProperty(createTextType(SOURCE, text));}
public void pdfbox_f9383_0(TextType text)
{    addProperty(text);}
public void pdfbox_f9384_0(MIMEType text)
{    addProperty(text);}
public void pdfbox_f9385_0(String text)
{    addQualifiedBagValue(SUBJECT, text);}
public void pdfbox_f9386_0(String text)
{    removeUnqualifiedBagValue(SUBJECT, text);}
public void pdfbox_f9387_0(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(TITLE, lang, value);}
public void pdfbox_f9388_0(String value)
{    setTitle(null, value);}
public void pdfbox_f9389_0(String lang, String value)
{    setTitle(lang, value);}
public void pdfbox_f9390_0(String type)
{    addQualifiedBagValue(TYPE, type);}
public ArrayProperty pdfbox_f9391_0()
{    return (ArrayProperty) getProperty(CONTRIBUTOR);}
public List<String> pdfbox_f9392_0()
{    return getUnqualifiedBagValueList(CONTRIBUTOR);}
public TextType pdfbox_f9393_0()
{    return (TextType) getProperty(COVERAGE);}
public String pdfbox_f9394_0()
{    TextType tt = (TextType) getProperty(COVERAGE);    return tt == null ? null : tt.getStringValue();}
public ArrayProperty pdfbox_f9395_0()
{    return (ArrayProperty) getProperty(CREATOR);}
public List<String> pdfbox_f9396_0()
{    return getUnqualifiedSequenceValueList(CREATOR);}
public ArrayProperty pdfbox_f9397_0()
{    return (ArrayProperty) getProperty(DATE);}
public List<Calendar> pdfbox_f9398_0()
{    return getUnqualifiedSequenceDateValueList(DATE);}
public ArrayProperty pdfbox_f9399_0()
{    return (ArrayProperty) getProperty(DESCRIPTION);}
public List<String> pdfbox_f9400_0()
{    return getUnqualifiedLanguagePropertyLanguagesValue(DESCRIPTION);}
public String pdfbox_f9401_0(String lang)
{    return getUnqualifiedLanguagePropertyValue(DESCRIPTION, lang);}
public String pdfbox_f9402_0()
{    return getDescription(null);}
public TextType pdfbox_f9403_0()
{    return (TextType) getProperty(FORMAT);}
public String pdfbox_f9404_0()
{    TextType tt = (TextType) getProperty(FORMAT);    return tt == null ? null : tt.getStringValue();}
public TextType pdfbox_f9405_0()
{    return (TextType) getProperty(IDENTIFIER);}
public String pdfbox_f9406_0()
{    TextType tt = (TextType) getProperty(IDENTIFIER);    return tt == null ? null : tt.getStringValue();}
public ArrayProperty pdfbox_f9407_0()
{    return (ArrayProperty) getProperty(LANGUAGE);}
public List<String> pdfbox_f9408_0()
{    return getUnqualifiedBagValueList(LANGUAGE);}
public ArrayProperty pdfbox_f9409_0()
{    return (ArrayProperty) getProperty(PUBLISHER);}
public List<String> pdfbox_f9410_0()
{    return getUnqualifiedBagValueList(PUBLISHER);}
public ArrayProperty pdfbox_f9411_0()
{    return (ArrayProperty) getProperty(RELATION);}
public List<String> pdfbox_f9412_0()
{    return getUnqualifiedBagValueList(RELATION);}
public ArrayProperty pdfbox_f9413_0()
{    return (ArrayProperty) getProperty(RIGHTS);}
public List<String> pdfbox_f9414_0()
{    return getUnqualifiedLanguagePropertyLanguagesValue(RIGHTS);}
public String pdfbox_f9415_0(String lang)
{    return getUnqualifiedLanguagePropertyValue(RIGHTS, lang);}
public String pdfbox_f9416_0()
{    return getRights(null);}
public TextType pdfbox_f9417_0()
{    return (TextType) getProperty(SOURCE);}
public String pdfbox_f9418_0()
{    TextType tt = (TextType) getProperty(SOURCE);    return tt == null ? null : tt.getStringValue();}
public ArrayProperty pdfbox_f9419_0()
{    return (ArrayProperty) getProperty(SUBJECT);}
public List<String> pdfbox_f9420_0()
{    return getUnqualifiedBagValueList(SUBJECT);}
public ArrayProperty pdfbox_f9421_0()
{    return (ArrayProperty) getProperty(TITLE);}
public List<String> pdfbox_f9422_0()
{    return getUnqualifiedLanguagePropertyLanguagesValue(TITLE);}
public String pdfbox_f9423_0(String lang)
{    return getUnqualifiedLanguagePropertyValue(TITLE, lang);}
public String pdfbox_f9424_0()
{    return getTitle(null);}
public ArrayProperty pdfbox_f9425_0()
{    return (ArrayProperty) getProperty(TYPE);}
public List<String> pdfbox_f9426_0()
{    return getUnqualifiedBagValueList(TYPE);}
public void pdfbox_f9427_0(String type)
{    removeUnqualifiedBagValue(TYPE, type);}
public ArrayProperty pdfbox_f9428_0()
{    return (ArrayProperty) getProperty(USER_COMMENT);}
public List<String> pdfbox_f9429_0()
{    return getUnqualifiedLanguagePropertyLanguagesValue(USER_COMMENT);}
public String pdfbox_f9430_0(String lang)
{    return getUnqualifiedLanguagePropertyValue(USER_COMMENT, lang);}
public String pdfbox_f9431_0()
{    return getUserComment(null);}
public ArrayProperty pdfbox_f9432_0()
{    return (ArrayProperty) getProperty(SCHEMAS);}
public void pdfbox_f9433_0(String value)
{    IntegerType part = (IntegerType) instanciateSimple(PART, value);    addProperty(part);}
public void pdfbox_f9434_0(int value)
{    IntegerType part = (IntegerType) instanciateSimple(PART, value);    addProperty(part);}
public void pdfbox_f9435_0(Integer value)
{    setPartValueWithInt(value);}
public void pdfbox_f9436_0(IntegerType part)
{    addProperty(part);}
public void pdfbox_f9437_0(String value)
{    TextType amd = createTextType(AMD, value);    addProperty(amd);}
public void pdfbox_f9438_0(TextType amd)
{    addProperty(amd);}
public void pdfbox_f9439_0(String value) throws BadFieldValueException
{    if (value.equals("A") || value.equals("B") || value.equals("U")) {        TextType conf = createTextType(CONFORMANCE, value);        addProperty(conf);    } else {        throw new BadFieldValueException("The property given not seems to be a PDF/A conformance level (must be A, B or U)");    }}
public void pdfbox_f9440_0(TextType conf) throws BadFieldValueException
{    String value = conf.getStringValue();    if (value.equals("A") || value.equals("B") || value.equals("U")) {        addProperty(conf);    } else {        throw new BadFieldValueException("The property given not seems to be a PDF/A conformance level (must be A, B or U)");    }}
public Integer pdfbox_f9441_0()
{    IntegerType tmp = getPartProperty();    if (tmp == null) {        return null;    }    return tmp.getValue();}
public IntegerType pdfbox_f9442_0()
{    AbstractField tmp = getProperty(PART);    if (tmp instanceof IntegerType) {        return (IntegerType) tmp;    }    return null;}
public String pdfbox_f9443_0()
{    AbstractField tmp = getProperty(AMD);    if (tmp instanceof TextType) {        return ((TextType) tmp).getStringValue();    }    return null;}
public TextType pdfbox_f9444_0()
{    AbstractField tmp = getProperty(AMD);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
public String pdfbox_f9445_0()
{    TextType tmp = getAmdProperty();    if (tmp == null) {        for (Attribute attribute : getAllAttributes()) {            if (attribute.getName().equals(AMD)) {                return attribute.getValue();            }        }        return null;    } else {        return tmp.getStringValue();    }}
public TextType pdfbox_f9446_0()
{    AbstractField tmp = getProperty(CONFORMANCE);    if (tmp instanceof TextType) {        return (TextType) tmp;    }    return null;}
public String pdfbox_f9447_0()
{    TextType tt = getConformanceProperty();    if (tt == null) {        for (Attribute attribute : getAllAttributes()) {            if (attribute.getName().equals(CONFORMANCE)) {                return attribute.getValue();            }        }        return null;    } else {        return tt.getStringValue();    }}
public URIType pdfbox_f9448_0()
{    return (URIType) getProperty(ANCESTORID);}
public String pdfbox_f9449_0()
{    TextType tt = ((TextType) getProperty(ANCESTORID));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9450_0(String text)
{    URIType tt = (URIType) instanciateSimple(ANCESTORID, text);    setAncestorIDProperty(tt);}
public void pdfbox_f9451_0(URIType text)
{    addProperty(text);}
public TextType pdfbox_f9452_0()
{    return (TextType) getProperty(AUTHORS_POSITION);}
public String pdfbox_f9453_0()
{    TextType tt = ((TextType) getProperty(AUTHORS_POSITION));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9454_0(String text)
{    TextType tt = (TextType) instanciateSimple(AUTHORS_POSITION, text);    setAuthorsPositionProperty(tt);}
public void pdfbox_f9455_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9456_0()
{    return (TextType) getProperty(CAPTION_WRITER);}
public String pdfbox_f9457_0()
{    TextType tt = ((TextType) getProperty(CAPTION_WRITER));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9458_0(String text)
{    ProperNameType tt = (ProperNameType) instanciateSimple(CAPTION_WRITER, text);    setCaptionWriterProperty(tt);}
public void pdfbox_f9459_0(ProperNameType text)
{    addProperty(text);}
public TextType pdfbox_f9460_0()
{    return (TextType) getProperty(CATEGORY);}
public String pdfbox_f9461_0()
{    TextType tt = ((TextType) getProperty(CATEGORY));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9462_0(String text)
{    TextType tt = (TextType) instanciateSimple(CATEGORY, text);    setCategoryProperty(tt);}
public void pdfbox_f9463_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9464_0()
{    return (TextType) getProperty(CITY);}
public String pdfbox_f9465_0()
{    TextType tt = ((TextType) getProperty(CITY));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9466_0(String text)
{    TextType tt = (TextType) instanciateSimple(CITY, text);    setCityProperty(tt);}
public void pdfbox_f9467_0(TextType text)
{    addProperty(text);}
public IntegerType pdfbox_f9468_0()
{    return (IntegerType) getProperty(COLOR_MODE);}
public Integer pdfbox_f9469_0()
{    IntegerType tt = ((IntegerType) getProperty(COLOR_MODE));    return tt == null ? null : tt.getValue();}
public void pdfbox_f9470_0(String text)
{    IntegerType tt = (IntegerType) instanciateSimple(COLOR_MODE, text);    setColorModeProperty(tt);}
public void pdfbox_f9471_0(IntegerType text)
{    addProperty(text);}
public TextType pdfbox_f9472_0()
{    return (TextType) getProperty(COUNTRY);}
public String pdfbox_f9473_0()
{    TextType tt = ((TextType) getProperty(COUNTRY));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9474_0(String text)
{    TextType tt = (TextType) instanciateSimple(COUNTRY, text);    setCountryProperty(tt);}
public void pdfbox_f9475_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9476_0()
{    return (TextType) getProperty(CREDIT);}
public String pdfbox_f9477_0()
{    TextType tt = ((TextType) getProperty(CREDIT));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9478_0(String text)
{    TextType tt = (TextType) instanciateSimple(CREDIT, text);    setCreditProperty(tt);}
public void pdfbox_f9479_0(TextType text)
{    addProperty(text);}
public DateType pdfbox_f9480_0()
{    return (DateType) getProperty(DATE_CREATED);}
public String pdfbox_f9481_0()
{    TextType tt = ((TextType) getProperty(DATE_CREATED));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9482_0(String text)
{    DateType tt = (DateType) instanciateSimple(DATE_CREATED, text);    setDateCreatedProperty(tt);}
public void pdfbox_f9483_0(DateType text)
{    addProperty(text);}
public void pdfbox_f9484_0(String text)
{    addQualifiedBagValue(DOCUMENT_ANCESTORS, text);}
public ArrayProperty pdfbox_f9485_0()
{    return (ArrayProperty) getProperty(DOCUMENT_ANCESTORS);}
public List<String> pdfbox_f9486_0()
{    return getUnqualifiedBagValueList(DOCUMENT_ANCESTORS);}
public TextType pdfbox_f9487_0()
{    return (TextType) getProperty(HEADLINE);}
public String pdfbox_f9488_0()
{    TextType tt = ((TextType) getProperty(HEADLINE));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9489_0(String text)
{    TextType tt = (TextType) instanciateSimple(HEADLINE, text);    setHeadlineProperty(tt);}
public void pdfbox_f9490_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9491_0()
{    return (TextType) getProperty(HISTORY);}
public String pdfbox_f9492_0()
{    TextType tt = ((TextType) getProperty(HISTORY));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9493_0(String text)
{    TextType tt = (TextType) instanciateSimple(HISTORY, text);    setHistoryProperty(tt);}
public void pdfbox_f9494_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9495_0()
{    return (TextType) getProperty(ICC_PROFILE);}
public String pdfbox_f9496_0()
{    TextType tt = ((TextType) getProperty(ICC_PROFILE));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9497_0(String text)
{    TextType tt = (TextType) instanciateSimple(ICC_PROFILE, text);    setICCProfileProperty(tt);}
public void pdfbox_f9498_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9499_0()
{    return (TextType) getProperty(INSTRUCTIONS);}
public String pdfbox_f9500_0()
{    TextType tt = ((TextType) getProperty(INSTRUCTIONS));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9501_0(String text)
{    TextType tt = (TextType) instanciateSimple(INSTRUCTIONS, text);    setInstructionsProperty(tt);}
public void pdfbox_f9502_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9503_0()
{    return (TextType) getProperty(SOURCE);}
public String pdfbox_f9504_0()
{    TextType tt = ((TextType) getProperty(SOURCE));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9505_0(String text)
{    TextType source = (TextType) instanciateSimple(SOURCE, text);    setSourceProperty(source);}
public void pdfbox_f9506_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9507_0()
{    return (TextType) getProperty(STATE);}
public String pdfbox_f9508_0()
{    TextType tt = ((TextType) getProperty(STATE));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9509_0(String text)
{    TextType tt = (TextType) instanciateSimple(STATE, text);    setStateProperty(tt);}
public void pdfbox_f9510_0(TextType text)
{    addProperty(text);}
public TextType pdfbox_f9511_0()
{    return (TextType) getProperty(SUPPLEMENTAL_CATEGORIES);}
public String pdfbox_f9512_0()
{    TextType tt = ((TextType) getProperty(SUPPLEMENTAL_CATEGORIES));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9513_0(String text)
{    TextType tt = (TextType) instanciateSimple(SUPPLEMENTAL_CATEGORIES, text);    setSupplementalCategoriesProperty(tt);}
public void pdfbox_f9514_0(TextType text)
{    addProperty(text);}
public void pdfbox_f9515_0(String layerName, String layerText)
{    if (seqLayer == null) {        seqLayer = createArrayProperty(TEXT_LAYERS, Cardinality.Seq);        addProperty(seqLayer);    }    LayerType layer = new LayerType(getMetadata());    layer.setLayerName(layerName);    layer.setLayerText(layerText);    seqLayer.getContainer().addProperty(layer);}
public List<LayerType> pdfbox_f9516_0() throws BadFieldValueException
{    List<AbstractField> tmp = getUnqualifiedArrayList(TEXT_LAYERS);    if (tmp != null) {        List<LayerType> layers = new ArrayList<>();        for (AbstractField abstractField : tmp) {            if (abstractField instanceof LayerType) {                layers.add((LayerType) abstractField);            } else {                throw new BadFieldValueException("Layer expected and " + abstractField.getClass().getName() + " found.");            }        }        return layers;    }    return null;}
public TextType pdfbox_f9517_0()
{    return (TextType) getProperty(TRANSMISSION_REFERENCE);}
public String pdfbox_f9518_0()
{    TextType tt = ((TextType) getProperty(TRANSMISSION_REFERENCE));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9519_0(String text)
{    TextType tt = (TextType) instanciateSimple(TRANSMISSION_REFERENCE, text);    setTransmissionReferenceProperty(tt);}
public void pdfbox_f9520_0(TextType text)
{    addProperty(text);}
public IntegerType pdfbox_f9521_0()
{    return (IntegerType) getProperty(URGENCY);}
public Integer pdfbox_f9522_0()
{    IntegerType tt = ((IntegerType) getProperty(URGENCY));    return tt == null ? null : tt.getValue();}
public void pdfbox_f9523_0(String s)
{    IntegerType tt = (IntegerType) instanciateSimple(URGENCY, s);    setUrgencyProperty(tt);}
public void pdfbox_f9524_0(Integer s)
{    IntegerType tt = (IntegerType) instanciateSimple(URGENCY, s);    setUrgencyProperty(tt);}
public void pdfbox_f9525_0(IntegerType text)
{    addProperty(text);}
public ProperNameType pdfbox_f9526_0()
{    return (ProperNameType) getProperty(ARTIST);}
public String pdfbox_f9527_0()
{    ProperNameType tt = (ProperNameType) getProperty(ARTIST);    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9528_0(String text)
{    addProperty(createTextType(ARTIST, text));}
public ArrayProperty pdfbox_f9529_0()
{    return (ArrayProperty) getProperty(IMAGE_DESCRIPTION);}
public List<String> pdfbox_f9530_0()
{    return getUnqualifiedLanguagePropertyLanguagesValue(IMAGE_DESCRIPTION);}
public String pdfbox_f9531_0(String lang)
{    return getUnqualifiedLanguagePropertyValue(IMAGE_DESCRIPTION, lang);}
public String pdfbox_f9532_0()
{    return getImageDescription(null);}
public void pdfbox_f9533_0(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(IMAGE_DESCRIPTION, lang, value);}
public ArrayProperty pdfbox_f9534_0()
{    return (ArrayProperty) getProperty(COPYRIGHT);}
public List<String> pdfbox_f9535_0()
{    return getUnqualifiedLanguagePropertyLanguagesValue(COPYRIGHT);}
public String pdfbox_f9536_0(String lang)
{    return getUnqualifiedLanguagePropertyValue(COPYRIGHT, lang);}
public String pdfbox_f9537_0()
{    return getCopyRight(null);}
public void pdfbox_f9538_0(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(COPYRIGHT, lang, value);}
public void pdfbox_f9539_0(String id, String name, String url)
{    addJob(id, name, url, null);}
public void pdfbox_f9540_0(String id, String name, String url, String fieldPrefix)
{    JobType job = new JobType(getMetadata(), fieldPrefix);    job.setId(id);    job.setName(name);    job.setUrl(url);    addJob(job);}
public void pdfbox_f9541_0(JobType job)
{    String prefix = getNamespacePrefix(job.getNamespace());    if (prefix != null) {                job.setPrefix(prefix);    } else {                addNamespace(job.getNamespace(), job.getPrefix());    }        if (bagJobs == null) {        bagJobs = createArrayProperty(JOB_REF, Cardinality.Bag);        addProperty(bagJobs);    }        bagJobs.getContainer().addProperty(job);}
public List<JobType> pdfbox_f9542_0() throws BadFieldValueException
{    List<AbstractField> tmp = getUnqualifiedArrayList(JOB_REF);    if (tmp != null) {        List<JobType> layers = new ArrayList<>();        for (AbstractField abstractField : tmp) {            if (abstractField instanceof JobType) {                layers.add((JobType) abstractField);            } else {                throw new BadFieldValueException("Job expected and " + abstractField.getClass().getName() + " found.");            }        }        return layers;    }    return null;}
public void pdfbox_f9543_0(Integer height, Integer width, String format, String img)
{    if (altThumbs == null) {        altThumbs = createArrayProperty(THUMBNAILS, Cardinality.Alt);        addProperty(altThumbs);    }    ThumbnailType thumb = new ThumbnailType(getMetadata());    thumb.setHeight(height);    thumb.setWidth(width);    thumb.setFormat(format);    thumb.setImage(img);    altThumbs.getContainer().addProperty(thumb);}
public void pdfbox_f9544_0(String xpath)
{    addQualifiedBagValue(ADVISORY, xpath);}
public void pdfbox_f9545_0(String xpath)
{    removeUnqualifiedBagValue(ADVISORY, xpath);}
public void pdfbox_f9546_0(String url)
{    URLType tt = (URLType) instanciateSimple(BASEURL, url);    setBaseURLProperty(tt);}
public void pdfbox_f9547_0(URLType url)
{    addProperty(url);}
public void pdfbox_f9548_0(Calendar date)
{    DateType tt = (DateType) instanciateSimple(CREATEDATE, date);    setCreateDateProperty(tt);}
public void pdfbox_f9549_0(DateType date)
{    addProperty(date);}
public void pdfbox_f9550_0(String creatorTool)
{    AgentNameType tt = (AgentNameType) instanciateSimple(CREATORTOOL, creatorTool);    setCreatorToolProperty(tt);}
public void pdfbox_f9551_0(AgentNameType creatorTool)
{    addProperty(creatorTool);}
public void pdfbox_f9552_0(String text)
{    addQualifiedBagValue(IDENTIFIER, text);}
public void pdfbox_f9553_0(String text)
{    removeUnqualifiedBagValue(IDENTIFIER, text);}
public void pdfbox_f9554_0(String text)
{    TextType tt = (TextType) instanciateSimple(LABEL, text);    setLabelProperty(tt);}
public void pdfbox_f9555_0(TextType text)
{    addProperty(text);}
public void pdfbox_f9556_0(Calendar date)
{    DateType tt = (DateType) instanciateSimple(METADATADATE, date);    setMetadataDateProperty(tt);}
public void pdfbox_f9557_0(DateType date)
{    addProperty(date);}
public void pdfbox_f9558_0(Calendar date)
{    DateType tt = (DateType) instanciateSimple(MODIFYDATE, date);    setModifyDateProperty(tt);}
public void pdfbox_f9559_0(Calendar date)
{    DateType tt = (DateType) instanciateSimple(MODIFIER_DATE, date);    setModifierDateProperty(tt);}
public void pdfbox_f9560_0(DateType date)
{    addProperty(date);}
public void pdfbox_f9561_0(DateType date)
{    addProperty(date);}
public void pdfbox_f9562_0(String text)
{    TextType tt = (TextType) instanciateSimple(NICKNAME, text);    setNicknameProperty(tt);}
public void pdfbox_f9563_0(TextType text)
{    addProperty(text);}
public void pdfbox_f9564_0(Integer rate)
{    IntegerType tt = (IntegerType) instanciateSimple(RATING, rate);    setRatingProperty(tt);}
public void pdfbox_f9565_0(IntegerType rate)
{    addProperty(rate);}
public ArrayProperty pdfbox_f9566_0()
{    return (ArrayProperty) getProperty(ADVISORY);}
public List<String> pdfbox_f9567_0()
{    return getUnqualifiedBagValueList(ADVISORY);}
public TextType pdfbox_f9568_0()
{    return (TextType) getProperty(BASEURL);}
public String pdfbox_f9569_0()
{    TextType tt = ((TextType) getProperty(BASEURL));    return tt == null ? null : tt.getStringValue();}
public DateType pdfbox_f9570_0()
{    return (DateType) getProperty(CREATEDATE);}
public Calendar pdfbox_f9571_0()
{    DateType createDate = (DateType) getProperty(CREATEDATE);    if (createDate != null) {        return createDate.getValue();    }    return null;}
public TextType pdfbox_f9572_0()
{    return (TextType) getProperty(CREATORTOOL);}
public String pdfbox_f9573_0()
{    TextType tt = ((TextType) getProperty(CREATORTOOL));    return tt == null ? null : tt.getStringValue();}
public ArrayProperty pdfbox_f9574_0()
{    return (ArrayProperty) getProperty(IDENTIFIER);}
public List<String> pdfbox_f9575_0()
{    return getUnqualifiedBagValueList(IDENTIFIER);}
public TextType pdfbox_f9576_0()
{    return (TextType) getProperty(LABEL);}
public String pdfbox_f9577_0()
{    TextType tt = ((TextType) getProperty(LABEL));    return tt == null ? null : tt.getStringValue();}
public DateType pdfbox_f9578_0()
{    return (DateType) getProperty(METADATADATE);}
public Calendar pdfbox_f9579_0()
{    DateType dt = ((DateType) getProperty(METADATADATE));    return dt == null ? null : dt.getValue();}
public DateType pdfbox_f9580_0()
{    return (DateType) getProperty(MODIFYDATE);}
public DateType pdfbox_f9581_0()
{    return (DateType) getProperty(MODIFIER_DATE);}
public Calendar pdfbox_f9582_0()
{    DateType modifyDate = (DateType) getProperty(MODIFYDATE);    if (modifyDate != null) {        return modifyDate.getValue();    }    return null;}
public Calendar pdfbox_f9583_0()
{    DateType modifierDate = (DateType) getProperty(MODIFIER_DATE);    if (modifierDate != null) {        return modifierDate.getValue();    }    return null;}
public TextType pdfbox_f9584_0()
{    return (TextType) getProperty(NICKNAME);}
public String pdfbox_f9585_0()
{    TextType tt = ((TextType) getProperty(NICKNAME));    return tt == null ? null : tt.getStringValue();}
public IntegerType pdfbox_f9586_0()
{    return ((IntegerType) getProperty(RATING));}
public Integer pdfbox_f9587_0()
{    IntegerType it = ((IntegerType) getProperty(RATING));    return it == null ? null : it.getValue();}
public List<ThumbnailType> pdfbox_f9588_0() throws BadFieldValueException
{    List<AbstractField> tmp = getUnqualifiedArrayList(THUMBNAILS);    if (tmp != null) {        List<ThumbnailType> thumbs = new ArrayList<>();        for (AbstractField abstractField : tmp) {            if (abstractField instanceof ThumbnailType) {                thumbs.add((ThumbnailType) abstractField);            } else {                throw new BadFieldValueException("Thumbnail expected and " + abstractField.getClass().getName() + " found.");            }        }        return thumbs;    }    return null;}
public void pdfbox_f9589_0(ResourceRefType tt)
{    addProperty(tt);}
public ResourceRefType pdfbox_f9590_0()
{    return (ResourceRefType) getProperty(DERIVED_FROM);}
public void pdfbox_f9591_0(String url)
{    URIType tt = (URIType) instanciateSimple(DOCUMENTID, url);    setDocumentIDProperty(tt);}
public void pdfbox_f9592_0(URIType tt)
{    addProperty(tt);}
public TextType pdfbox_f9593_0()
{    return (TextType) getProperty(DOCUMENTID);}
public String pdfbox_f9594_0()
{    TextType tt = getDocumentIDProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9595_0(String url)
{    URLType tt = (URLType) instanciateSimple(LAST_URL, url);    setLastURLProperty(tt);}
public void pdfbox_f9596_0(URLType tt)
{    addProperty(tt);}
public URLType pdfbox_f9597_0()
{    return (URLType) getProperty(LAST_URL);}
public String pdfbox_f9598_0()
{    URLType tt = getLastURLProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9599_0(Integer url)
{    IntegerType tt = (IntegerType) instanciateSimple(SAVE_ID, url);    setSaveIDProperty(tt);}
public void pdfbox_f9600_0(IntegerType tt)
{    addProperty(tt);}
public IntegerType pdfbox_f9601_0()
{    return (IntegerType) getProperty(SAVE_ID);}
public Integer pdfbox_f9602_0()
{    IntegerType tt = getSaveIDProperty();    return tt != null ? tt.getValue() : null;}
public void pdfbox_f9603_0(String value)
{    AgentNameType tt = (AgentNameType) instanciateSimple(MANAGER, value);    setManagerProperty(tt);}
public void pdfbox_f9604_0(AgentNameType tt)
{    addProperty(tt);}
public TextType pdfbox_f9605_0()
{    return (TextType) getProperty(MANAGER);}
public String pdfbox_f9606_0()
{    TextType tt = getManagerProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9607_0(String value)
{    URIType tt = (URIType) instanciateSimple(MANAGETO, value);    setManageToProperty(tt);}
public void pdfbox_f9608_0(URIType tt)
{    addProperty(tt);}
public TextType pdfbox_f9609_0()
{    return (TextType) getProperty(MANAGETO);}
public String pdfbox_f9610_0()
{    TextType tt = getManageToProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9611_0(String value)
{    URIType tt = (URIType) instanciateSimple(MANAGEUI, value);    setManageUIProperty(tt);}
public void pdfbox_f9612_0(URIType tt)
{    addProperty(tt);}
public TextType pdfbox_f9613_0()
{    return (TextType) getProperty(MANAGEUI);}
public String pdfbox_f9614_0()
{    TextType tt = getManageUIProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9615_0(String value)
{    TextType tt = (TextType) instanciateSimple(MANAGERVARIANT, value);    setManagerVariantProperty(tt);}
public void pdfbox_f9616_0(TextType tt)
{    addProperty(tt);}
public TextType pdfbox_f9617_0()
{    return (TextType) getProperty(MANAGERVARIANT);}
public String pdfbox_f9618_0()
{    TextType tt = getManagerVariantProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9619_0(String value)
{    URIType tt = (URIType) instanciateSimple(INSTANCEID, value);    setInstanceIDProperty(tt);}
public void pdfbox_f9620_0(URIType tt)
{    addProperty(tt);}
public TextType pdfbox_f9621_0()
{    return (TextType) getProperty(INSTANCEID);}
public String pdfbox_f9622_0()
{    TextType tt = getInstanceIDProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9623_0(ResourceRefType resourceRef)
{    addProperty(resourceRef);}
public ResourceRefType pdfbox_f9624_0()
{    return (ResourceRefType) getProperty(MANAGED_FROM);}
public void pdfbox_f9625_0(String url)
{    TextType tt = (TextType) instanciateSimple(ORIGINALDOCUMENTID, url);    setOriginalDocumentIDProperty(tt);}
public void pdfbox_f9626_0(TextType tt)
{    addProperty(tt);}
public TextType pdfbox_f9627_0()
{    return (TextType) getProperty(ORIGINALDOCUMENTID);}
public String pdfbox_f9628_0()
{    TextType tt = getOriginalDocumentIDProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9629_0(String value)
{    RenditionClassType tt = (RenditionClassType) instanciateSimple(RENDITIONCLASS, value);    setRenditionClassProperty(tt);}
public void pdfbox_f9630_0(RenditionClassType tt)
{    addProperty(tt);}
public TextType pdfbox_f9631_0()
{    return (TextType) getProperty(RENDITIONCLASS);}
public String pdfbox_f9632_0()
{    TextType tt = getRenditionClassProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9633_0(String url)
{    TextType tt = (TextType) instanciateSimple(RENDITIONPARAMS, url);    setRenditionParamsProperty(tt);}
public void pdfbox_f9634_0(TextType tt)
{    addProperty(tt);}
public TextType pdfbox_f9635_0()
{    return (TextType) getProperty(RENDITIONPARAMS);}
public String pdfbox_f9636_0()
{    TextType tt = getRenditionParamsProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9637_0(String value)
{    TextType tt = (TextType) instanciateSimple(VERSIONID, value);    setVersionIDProperty(tt);}
public void pdfbox_f9638_0(TextType tt)
{    addProperty(tt);}
public TextType pdfbox_f9639_0()
{    return (TextType) getProperty(VERSIONID);}
public String pdfbox_f9640_0()
{    TextType tt = getVersionIDProperty();    return tt != null ? tt.getStringValue() : null;}
public void pdfbox_f9641_0(String value)
{    addQualifiedBagValue(VERSIONS, value);}
public ArrayProperty pdfbox_f9642_0()
{    return (ArrayProperty) getProperty(VERSIONS);}
public List<String> pdfbox_f9643_0()
{    return getUnqualifiedBagValueList(VERSIONS);}
public void pdfbox_f9644_0(String history)
{    addUnqualifiedSequenceValue(HISTORY, history);}
public ArrayProperty pdfbox_f9645_0()
{    return (ArrayProperty) getProperty(HISTORY);}
public List<String> pdfbox_f9646_0()
{    return getUnqualifiedSequenceValueList(HISTORY);}
public void pdfbox_f9647_0(String ingredients)
{    addQualifiedBagValue(INGREDIENTS, ingredients);}
public ArrayProperty pdfbox_f9648_0()
{    return (ArrayProperty) getProperty(INGREDIENTS);}
public List<String> pdfbox_f9649_0()
{    return getUnqualifiedBagValueList(INGREDIENTS);}
public void pdfbox_f9650_0(String value)
{    addQualifiedBagValue(OWNER, value);}
public void pdfbox_f9651_0(String value)
{    removeUnqualifiedBagValue(OWNER, value);}
public ArrayProperty pdfbox_f9652_0()
{    return (ArrayProperty) getProperty(OWNER);}
public List<String> pdfbox_f9653_0()
{    return getUnqualifiedBagValueList(OWNER);}
public void pdfbox_f9654_0(Boolean marked)
{    BooleanType tt = (BooleanType) instanciateSimple(MARKED, marked ? BooleanType.TRUE : BooleanType.FALSE);    setMarkedProperty(tt);}
public void pdfbox_f9655_0(BooleanType marked)
{    addProperty(marked);}
public BooleanType pdfbox_f9656_0()
{    return (BooleanType) getProperty(MARKED);}
public Boolean pdfbox_f9657_0()
{    BooleanType bt = ((BooleanType) getProperty(MARKED));    return bt == null ? null : bt.getValue();}
public void pdfbox_f9658_0(String lang, String value)
{    setUnqualifiedLanguagePropertyValue(USAGETERMS, lang, value);}
public void pdfbox_f9659_0(String terms)
{    addUsageTerms(null, terms);}
public ArrayProperty pdfbox_f9660_0()
{    return (ArrayProperty) getProperty(USAGETERMS);}
public List<String> pdfbox_f9661_0()
{    return getUnqualifiedLanguagePropertyLanguagesValue(USAGETERMS);}
public String pdfbox_f9662_0(String lang)
{    return getUnqualifiedLanguagePropertyValue(USAGETERMS, lang);}
public String pdfbox_f9663_0()
{    return getUsageTerms(null);}
public TextType pdfbox_f9664_0()
{    return ((TextType) getProperty(WEBSTATEMENT));}
public String pdfbox_f9665_0()
{    TextType tt = ((TextType) getProperty(WEBSTATEMENT));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9666_0(String url)
{    URLType tt = (URLType) instanciateSimple(WEBSTATEMENT, url);    setWebStatementProperty(tt);}
public void pdfbox_f9667_0(URLType url)
{    addProperty(url);}
public TextType pdfbox_f9668_0()
{    return ((TextType) getProperty(CERTIFICATE));}
public String pdfbox_f9669_0()
{    TextType tt = ((TextType) getProperty(CERTIFICATE));    return tt == null ? null : tt.getStringValue();}
public void pdfbox_f9670_0(String url)
{    URLType tt = (URLType) instanciateSimple(CERTIFICATE, url);    setCertificateProperty(tt);}
public void pdfbox_f9671_0(URLType url)
{    addProperty(url);}
public AbstractField pdfbox_f9672_0(String qualifiedName)
{    for (AbstractField child : getContainer().getAllProperties()) {        if (child.getPropertyName().equals(qualifiedName)) {            return child;        }    }    return null;}
public Attribute pdfbox_f9673_0()
{    return getAttribute(XmpConstants.ABOUT_NAME);}
public String pdfbox_f9674_0()
{    Attribute prop = getAttribute(XmpConstants.ABOUT_NAME);    if (prop != null) {        return prop.getValue();    }        return "";}
public void pdfbox_f9675_0(Attribute about) throws BadFieldValueException
{    if (XmpConstants.RDF_NAMESPACE.equals(about.getNamespace()) && XmpConstants.ABOUT_NAME.equals(about.getName())) {        setAttribute(about);        return;    }    throw new BadFieldValueException("Attribute 'about' must be named 'rdf:about' or 'about'");}
public void pdfbox_f9676_0(String about)
{    if (about == null) {        removeAttribute(XmpConstants.ABOUT_NAME);    } else {        setAttribute(new Attribute(XmpConstants.RDF_NAMESPACE, XmpConstants.ABOUT_NAME, about));    }}
private void pdfbox_f9677_0(Types type, String qualifiedName, Object propertyValue)
{    if (propertyValue == null) {                for (AbstractField child : getContainer().getAllProperties()) {            if (child.getPropertyName().equals(qualifiedName)) {                getContainer().removeProperty(child);                return;            }        }    } else {        AbstractSimpleProperty specifiedTypeProperty;        try {            TypeMapping tm = getMetadata().getTypeMapping();            specifiedTypeProperty = tm.instanciateSimpleProperty(null, getPrefix(), qualifiedName, propertyValue, type);        } catch (Exception e) {            throw new IllegalArgumentException("Failed to create property with the specified type given in parameters", e);        }                for (AbstractField child : getAllProperties()) {            if (child.getPropertyName().equals(qualifiedName)) {                removeProperty(child);                addProperty(specifiedTypeProperty);                return;            }        }        addProperty(specifiedTypeProperty);    }}
private void pdfbox_f9678_0(AbstractSimpleProperty prop)
{        for (AbstractField child : getAllProperties()) {        if (child.getPropertyName().equals(prop.getPropertyName())) {            removeProperty(child);            addProperty(prop);            return;        }    }    addProperty(prop);}
public void pdfbox_f9679_0(TextType prop)
{    setSpecifiedSimpleTypeProperty(prop);}
public void pdfbox_f9680_0(String qualifiedName, String propertyValue)
{    setSpecifiedSimpleTypeProperty(Types.Text, qualifiedName, propertyValue);}
public void pdfbox_f9681_0(String simpleName, String propertyValue)
{    this.setTextPropertyValue(simpleName, propertyValue);}
public TextType pdfbox_f9682_0(String name)
{    AbstractField prop = getAbstractProperty(name);    if (prop != null) {        if (prop instanceof TextType) {            return (TextType) prop;        } else {            throw new IllegalArgumentException("Property asked is not a Text Property");        }    }    return null;}
public String pdfbox_f9683_0(String name)
{    TextType tt = getUnqualifiedTextProperty(name);    return tt == null ? null : tt.getStringValue();}
public DateType pdfbox_f9684_0(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof DateType) {            return (DateType) prop;        } else {            throw new IllegalArgumentException("Property asked is not a Date Property");        }    }    return null;}
public Calendar pdfbox_f9685_0(String simpleName)
{    return this.getDatePropertyValue(simpleName);}
public Calendar pdfbox_f9686_0(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof DateType) {            return ((DateType) prop).getValue();        } else {            throw new IllegalArgumentException("Property asked is not a Date Property");        }    }    return null;}
public void pdfbox_f9687_0(DateType date)
{    setSpecifiedSimpleTypeProperty(date);}
public void pdfbox_f9688_0(String simpleName, Calendar date)
{    this.setDatePropertyValue(simpleName, date);}
public void pdfbox_f9689_0(String qualifiedName, Calendar date)
{    setSpecifiedSimpleTypeProperty(Types.Date, qualifiedName, date);}
public BooleanType pdfbox_f9690_0(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof BooleanType) {            return (BooleanType) prop;        } else {            throw new IllegalArgumentException("Property asked is not a Boolean Property");        }    }    return null;}
public Boolean pdfbox_f9691_0(String simpleName)
{    return this.getBooleanPropertyValue(simpleName);}
public Boolean pdfbox_f9692_0(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof BooleanType) {            return ((BooleanType) prop).getValue();        } else {            throw new IllegalArgumentException("Property asked is not a Boolean Property");        }    }    return null;}
public void pdfbox_f9693_0(BooleanType bool)
{    setSpecifiedSimpleTypeProperty(bool);}
public void pdfbox_f9694_0(String simpleName, Boolean bool)
{    this.setBooleanPropertyValue(simpleName, bool);}
public void pdfbox_f9695_0(String qualifiedName, Boolean bool)
{    setSpecifiedSimpleTypeProperty(Types.Boolean, qualifiedName, bool);}
public IntegerType pdfbox_f9696_0(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof IntegerType) {            return ((IntegerType) prop);        } else {            throw new IllegalArgumentException("Property asked is not an Integer Property");        }    }    return null;}
public Integer pdfbox_f9697_0(String simpleName)
{    return this.getIntegerPropertyValue(simpleName);}
public Integer pdfbox_f9698_0(String qualifiedName)
{    AbstractField prop = getAbstractProperty(qualifiedName);    if (prop != null) {        if (prop instanceof IntegerType) {            return ((IntegerType) prop).getValue();        } else {            throw new IllegalArgumentException("Property asked is not an Integer Property");        }    }    return null;}
public void pdfbox_f9699_0(IntegerType prop)
{    setSpecifiedSimpleTypeProperty(prop);}
public void pdfbox_f9700_0(String simpleName, Integer intValue)
{    this.setIntegerPropertyValue(simpleName, intValue);}
public void pdfbox_f9701_0(String qualifiedName, Integer intValue)
{    setSpecifiedSimpleTypeProperty(Types.Integer, qualifiedName, intValue);}
private void pdfbox_f9702_0(String arrayName, String fieldValue)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(arrayName);    if (array != null) {        List<AbstractField> toDelete = new ArrayList<>();        for (AbstractField abstractField : array.getContainer().getAllProperties()) {            AbstractSimpleProperty tmp = (AbstractSimpleProperty) abstractField;            if (tmp.getStringValue().equals(fieldValue)) {                toDelete.add(tmp);            }        }        for (AbstractField aToDelete : toDelete) {            array.getContainer().removeProperty(aToDelete);        }    }}
public void pdfbox_f9703_0(String bagName, String bagValue)
{    removeUnqualifiedArrayValue(bagName, bagValue);}
public void pdfbox_f9704_0(String simpleName, String bagValue)
{    this.internalAddBagValue(simpleName, bagValue);}
private void pdfbox_f9705_0(String qualifiedBagName, String bagValue)
{    ArrayProperty bag = (ArrayProperty) getAbstractProperty(qualifiedBagName);    TextType li = createTextType(XmpConstants.LIST_NAME, bagValue);    if (bag != null) {        bag.getContainer().addProperty(li);    } else {        ArrayProperty newBag = createArrayProperty(qualifiedBagName, Cardinality.Bag);        newBag.getContainer().addProperty(li);        addProperty(newBag);    }}
public void pdfbox_f9706_0(String simpleName, String bagValue)
{    internalAddBagValue(simpleName, bagValue);}
public List<String> pdfbox_f9707_0(String bagName)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(bagName);    if (array != null) {        return array.getElementsAsString();    } else {        return null;    }}
public void pdfbox_f9708_0(String qualifiedSeqName, String seqValue)
{    removeUnqualifiedArrayValue(qualifiedSeqName, seqValue);}
public void pdfbox_f9709_0(String arrayName, AbstractField fieldValue)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(arrayName);    if (array != null) {        List<AbstractField> toDelete = new ArrayList<>();        for (AbstractField abstractField : array.getContainer().getAllProperties()) {            AbstractSimpleProperty tmp = (AbstractSimpleProperty) abstractField;            if (tmp.equals(fieldValue)) {                toDelete.add(tmp);            }        }        for (AbstractField aToDelete : toDelete) {            array.getContainer().removeProperty(aToDelete);        }    }}
public void pdfbox_f9710_0(String qualifiedSeqName, AbstractField seqValue)
{    removeUnqualifiedArrayValue(qualifiedSeqName, seqValue);}
public void pdfbox_f9711_0(String simpleSeqName, String seqValue)
{    ArrayProperty seq = (ArrayProperty) getAbstractProperty(simpleSeqName);    TextType li = createTextType(XmpConstants.LIST_NAME, seqValue);    if (seq != null) {        seq.getContainer().addProperty(li);    } else {        ArrayProperty newSeq = createArrayProperty(simpleSeqName, Cardinality.Seq);        newSeq.getContainer().addProperty(li);        addProperty(newSeq);    }}
public void pdfbox_f9712_0(String qualifiedSeqName, AbstractField seqValue)
{    ArrayProperty bag = (ArrayProperty) getAbstractProperty(qualifiedSeqName);    if (bag != null) {        bag.getContainer().addProperty(seqValue);    } else {        ArrayProperty newBag = createArrayProperty(qualifiedSeqName, Cardinality.Bag);        newBag.getContainer().addProperty(seqValue);        addProperty(newBag);    }}
public void pdfbox_f9713_0(String seqName, AbstractField seqValue)
{    ArrayProperty seq = (ArrayProperty) getAbstractProperty(seqName);    if (seq != null) {        seq.getContainer().addProperty(seqValue);    } else {        ArrayProperty newSeq = createArrayProperty(seqName, Cardinality.Seq);        newSeq.getContainer().addProperty(seqValue);        addProperty(newSeq);    }}
public List<String> pdfbox_f9714_0(String seqName)
{    ArrayProperty array = (ArrayProperty) getAbstractProperty(seqName);    if (array != null) {        return array.getElementsAsString();    } else {        return null;    }}
public void pdfbox_f9715_0(String seqName, Calendar date)
{    ArrayProperty seq = (ArrayProperty) getAbstractProperty(seqName);    if (seq != null) {        List<AbstractField> toDelete = new ArrayList<>();        for (AbstractField tmp : seq.getContainer().getAllProperties()) {            if (tmp instanceof DateType && ((DateType) tmp).getValue().equals(date)) {                toDelete.add(tmp);            }        }        for (AbstractField aToDelete : toDelete) {            seq.getContainer().removeProperty(aToDelete);        }    }}
public void pdfbox_f9716_0(String simpleName, Calendar date)
{    addUnqualifiedSequenceDateValue(simpleName, date);}
public void pdfbox_f9717_0(String seqName, Calendar date)
{    addUnqualifiedSequenceValue(seqName, getMetadata().getTypeMapping().createDate(null, XmpConstants.DEFAULT_RDF_LOCAL_NAME, XmpConstants.LIST_NAME, date));}
public List<Calendar> pdfbox_f9718_0(String seqName)
{    List<Calendar> retval = null;    ArrayProperty seq = (ArrayProperty) getAbstractProperty(seqName);    if (seq != null) {        retval = new ArrayList<>();        for (AbstractField child : seq.getContainer().getAllProperties()) {            if (child instanceof DateType) {                retval.add(((DateType) child).getValue());            }        }    }    return retval;}
public void pdfbox_f9719_0(ComplexPropertyContainer alt)
{    Iterator<AbstractField> it = alt.getAllProperties().iterator();    AbstractField xdefault = null;    boolean xdefaultFound = false;        if (it.hasNext() && it.next().getAttribute(XmpConstants.LANG_NAME).getValue().equals(XmpConstants.X_DEFAULT)) {        return;    }        while (it.hasNext() && !xdefaultFound) {        xdefault = it.next();        if (xdefault.getAttribute(XmpConstants.LANG_NAME).getValue().equals(XmpConstants.X_DEFAULT)) {            alt.removeProperty(xdefault);            xdefaultFound = true;        }    }    if (xdefaultFound) {        it = alt.getAllProperties().iterator();        List<AbstractField> reordered = new ArrayList<>();        List<AbstractField> toDelete = new ArrayList<>();        reordered.add(xdefault);        while (it.hasNext()) {            AbstractField tmp = it.next();            reordered.add(tmp);            toDelete.add(tmp);        }        for (AbstractField aToDelete : toDelete) {            alt.removeProperty(aToDelete);        }        it = reordered.iterator();        while (it.hasNext()) {            alt.addProperty(it.next());        }    }}
public void pdfbox_f9720_0(String name, String language, String value)
{    if (language == null || language.isEmpty()) {        language = XmpConstants.X_DEFAULT;    }    AbstractField property = getAbstractProperty(name);    ArrayProperty arrayProp;    if (property != null) {                if (property instanceof ArrayProperty) {            arrayProp = (ArrayProperty) property;                        for (AbstractField child : arrayProp.getContainer().getAllProperties()) {                                if (child.getAttribute(XmpConstants.LANG_NAME).getValue().equals(language)) {                                        arrayProp.getContainer().removeProperty(child);                    if (value != null) {                        TextType langValue = createTextType(XmpConstants.LIST_NAME, value);                        langValue.setAttribute(new Attribute(XMLConstants.XML_NS_URI, XmpConstants.LANG_NAME, language));                        arrayProp.getContainer().addProperty(langValue);                    }                    reorganizeAltOrder(arrayProp.getContainer());                    return;                }            }                        TextType langValue = createTextType(XmpConstants.LIST_NAME, value);            langValue.setAttribute(new Attribute(XMLConstants.XML_NS_URI, XmpConstants.LANG_NAME, language));            arrayProp.getContainer().addProperty(langValue);            reorganizeAltOrder(arrayProp.getContainer());        }    } else {        arrayProp = createArrayProperty(name, Cardinality.Alt);        TextType langValue = createTextType(XmpConstants.LIST_NAME, value);        langValue.setAttribute(new Attribute(XMLConstants.XML_NS_URI, XmpConstants.LANG_NAME, language));        arrayProp.getContainer().addProperty(langValue);        addProperty(arrayProp);    }}
public String pdfbox_f9721_0(String name, String expectedLanguage)
{    String language = (expectedLanguage != null) ? expectedLanguage : XmpConstants.X_DEFAULT;    AbstractField property = getAbstractProperty(name);    if (property != null) {        if (property instanceof ArrayProperty) {            ArrayProperty arrayProp = (ArrayProperty) property;            for (AbstractField child : arrayProp.getContainer().getAllProperties()) {                Attribute text = child.getAttribute(XmpConstants.LANG_NAME);                if (text != null && text.getValue().equals(language)) {                    return ((TextType) child).getStringValue();                }            }            return null;        } else {            throw new IllegalArgumentException("The property '" + name + "' is not of Lang Alt type");        }    }    return null;}
public List<String> pdfbox_f9722_0(String name)
{    AbstractField property = getAbstractProperty(name);    if (property != null) {        if (property instanceof ArrayProperty) {            List<String> retval = new ArrayList<>();            ArrayProperty arrayProp = (ArrayProperty) property;            for (AbstractField child : arrayProp.getContainer().getAllProperties()) {                Attribute text = child.getAttribute(XmpConstants.LANG_NAME);                if (text != null) {                    retval.add(text.getValue());                } else {                    retval.add(XmpConstants.X_DEFAULT);                }            }            return retval;        } else {            throw new IllegalArgumentException("The property '" + name + "' is not of Lang Alt type");        }    }        return null;}
public void pdfbox_f9723_0(XMPSchema xmpSchema) throws IOException
{    if (!xmpSchema.getClass().equals(this.getClass())) {        throw new IOException("Can only merge schemas of the same type.");    }    for (Attribute att : xmpSchema.getAllAttributes()) {        if (att.getNamespace().equals(getNamespace())) {            setAttribute(att);        }    }    String analyzedPropQualifiedName;    for (AbstractField child : xmpSchema.getContainer().getAllProperties()) {        if (child.getPrefix().equals(getPrefix())) {            if (child instanceof ArrayProperty) {                analyzedPropQualifiedName = child.getPropertyName();                for (AbstractField tmpEmbeddedProperty : getAllProperties()) {                    if (tmpEmbeddedProperty instanceof ArrayProperty && tmpEmbeddedProperty.getPropertyName().equals(analyzedPropQualifiedName)) {                        Iterator<AbstractField> itNewValues = ((ArrayProperty) child).getContainer().getAllProperties().iterator();                        if (mergeComplexProperty(itNewValues, (ArrayProperty) tmpEmbeddedProperty)) {                            return;                        }                    }                }            } else {                addProperty(child);            }        }    }}
private boolean pdfbox_f9724_0(Iterator<AbstractField> itNewValues, ArrayProperty arrayProperty)
{    while (itNewValues.hasNext()) {        TextType tmpNewValue = (TextType) itNewValues.next();        for (AbstractField abstractField : arrayProperty.getContainer().getAllProperties()) {            TextType tmpOldValue = (TextType) abstractField;            if (tmpOldValue.getStringValue().equals(tmpNewValue.getStringValue())) {                return true;            }        }        arrayProperty.getContainer().addProperty(tmpNewValue);    }    return false;}
public List<AbstractField> pdfbox_f9725_0(String name) throws BadFieldValueException
{    ArrayProperty array = null;    for (AbstractField child : getAllProperties()) {        if (child.getPropertyName().equals(name)) {            if (child instanceof ArrayProperty) {                array = (ArrayProperty) child;                break;            }            throw new BadFieldValueException("Property asked is not an array");        }    }    if (array != null) {        return new ArrayList<>(array.getContainer().getAllProperties());    }    return null;}
protected AbstractSimpleProperty pdfbox_f9726_0(String propertyName, Object value)
{    TypeMapping tm = getMetadata().getTypeMapping();    return tm.instanciateSimpleField(getClass(), null, getPrefix(), propertyName, value);}
public String pdfbox_f9727_0()
{    return namespace;}
public PropertyType pdfbox_f9728_0(String name)
{    return propDef.getPropertyType(name);}
public XMPSchema pdfbox_f9729_0(XMPMetadata metadata, String prefix) throws XmpSchemaException
{    XMPSchema schema;    Class<?>[] argsClass;    Object[] schemaArgs;    if (schemaClass == XMPSchema.class) {        argsClass = new Class[] { XMPMetadata.class, String.class, String.class };        schemaArgs = new Object[] { metadata, namespace, nsName };    } else if (prefix != null && !"".equals(prefix)) {        argsClass = new Class[] { XMPMetadata.class, String.class };        schemaArgs = new Object[] { metadata, prefix };    } else {        argsClass = new Class[] { XMPMetadata.class };        schemaArgs = new Object[] { metadata };    }    try {        schema = schemaClass.getDeclaredConstructor(argsClass).newInstance(schemaArgs);        if (schema != null) {            metadata.addSchema(schema);        }        return schema;    } catch (Exception e) {        throw new XmpSchemaException("Cannot instanciate specified object schema", e);    }}
public PropertiesDescription pdfbox_f9730_0()
{    return this.propDef;}
public void pdfbox_f9731_0(String namespace, String prefix)
{    this.namespaceToPrefix.put(namespace, prefix);}
public String pdfbox_f9732_0(String namespace)
{    return this.namespaceToPrefix.get(namespace);}
public Map<String, String> pdfbox_f9733_0()
{    return this.namespaceToPrefix;}
public final void pdfbox_f9734_0(AbstractField obj)
{        if (!(this instanceof ArrayProperty)) {        container.removePropertiesByName(obj.getPropertyName());    }    container.addProperty(obj);}
public final void pdfbox_f9735_0(AbstractField property)
{    container.removeProperty(property);}
public final ComplexPropertyContainer pdfbox_f9736_0()
{    return container;}
public final List<AbstractField> pdfbox_f9737_0()
{    return container.getAllProperties();}
public final AbstractField pdfbox_f9738_0(String fieldName)
{    List<AbstractField> list = container.getPropertiesByLocalName(fieldName);        if (list == null) {        return null;    }        return list.get(0);}
public final ArrayProperty pdfbox_f9739_0(String fieldName)
{    List<AbstractField> list = container.getPropertiesByLocalName(fieldName);        if (list == null) {        return null;    }        return (ArrayProperty) list.get(0);}
protected final AbstractField pdfbox_f9740_0(String localName, Class<? extends AbstractField> type)
{    return container.getFirstEquivalentProperty(localName, type);}
public final String pdfbox_f9741_0()
{    return propertyName;}
public final void pdfbox_f9742_0(String value)
{    this.propertyName = value;}
public final void pdfbox_f9743_0(Attribute value)
{    if (attributes.containsKey(value.getName())) {                attributes.remove(value.getName());    }    attributes.put(value.getName(), value);}
public final boolean pdfbox_f9744_0(String qualifiedName)
{    return attributes.containsKey(qualifiedName);}
public final Attribute pdfbox_f9745_0(String qualifiedName)
{    return attributes.get(qualifiedName);}
public final List<Attribute> pdfbox_f9746_0()
{    return new ArrayList<>(attributes.values());}
public final void pdfbox_f9747_0(String qualifiedName)
{    if (containsAttribute(qualifiedName)) {        attributes.remove(qualifiedName);    }}
public final XMPMetadata pdfbox_f9748_0()
{    return metadata;}
public Object pdfbox_f9749_0()
{    return rawValue;}
public String pdfbox_f9750_0()
{    return "[" + this.getClass().getSimpleName() + ":" + getStringValue() + "]";}
public final String pdfbox_f9751_0()
{    return namespace;}
public String pdfbox_f9752_0()
{    return prefix;}
public final String pdfbox_f9753_0()
{    return namespace;}
public final void pdfbox_f9754_0(String ns)
{    this.namespace = ns;}
public final String pdfbox_f9755_0()
{    return prefix;}
public final void pdfbox_f9756_0(String pf)
{    this.prefix = pf;}
public final String pdfbox_f9757_0()
{    return preferedPrefix;}
protected void pdfbox_f9758_0(String propertyName, Object value)
{    TypeMapping tm = getMetadata().getTypeMapping();    AbstractSimpleProperty asp = tm.instanciateSimpleField(getClass(), null, getPrefix(), propertyName, value);    addProperty(asp);}
protected String pdfbox_f9759_0(String fieldName)
{    AbstractSimpleProperty absProp = (AbstractSimpleProperty) getProperty(fieldName);    if (absProp == null) {        return null;    } else {        return absProp.getStringValue();    }}
protected Calendar pdfbox_f9760_0(String fieldName)
{    DateType absProp = (DateType) getFirstEquivalentProperty(fieldName, DateType.class);    if (absProp != null) {        return absProp.getValue();    } else {        return null;    }}
public TextType pdfbox_f9761_0(String propertyName, String value)
{    return getMetadata().getTypeMapping().createText(getNamespace(), getPrefix(), propertyName, value);}
public ArrayProperty pdfbox_f9762_0(String propertyName, Cardinality type)
{    return getMetadata().getTypeMapping().createArrayProperty(getNamespace(), getPrefix(), propertyName, type);}
public Cardinality pdfbox_f9763_0()
{    return arrayType;}
public List<String> pdfbox_f9764_0()
{    List<String> retval;    retval = new ArrayList<>();    Iterator<AbstractField> it = getContainer().getAllProperties().iterator();    AbstractSimpleProperty tmp;    while (it.hasNext()) {        tmp = (AbstractSimpleProperty) it.next();        retval.add(tmp.getStringValue());    }    retval = Collections.unmodifiableList(retval);    return retval;}
public final String pdfbox_f9765_0()
{    return namespace;}
public String pdfbox_f9766_0()
{    return prefix;}
public String pdfbox_f9767_0()
{    return name;}
public void pdfbox_f9768_0(String lname)
{    name = lname;}
public String pdfbox_f9769_0()
{    return nsURI;}
public void pdfbox_f9770_0(String nsURI)
{    this.nsURI = nsURI;}
public String pdfbox_f9771_0()
{    return value;}
public void pdfbox_f9772_0(String value)
{    this.value = value;}
public String pdfbox_f9773_0()
{    return "[attr:{" + nsURI + "}" + name + "=" + value + "]";}
public Boolean pdfbox_f9774_0()
{    return booleanValue;}
public void pdfbox_f9775_0(Object value)
{    if (value instanceof Boolean) {        booleanValue = (Boolean) value;    } else if (value instanceof String) {                String s = value.toString().trim().toUpperCase();        if ("TRUE".equals(s)) {            booleanValue = true;        } else if ("FALSE".equals(s)) {            booleanValue = false;        } else {                        throw new IllegalArgumentException("Not a valid boolean value : '" + value + "'");        }    } else {                throw new IllegalArgumentException("Value given is not allowed for the Boolean type.");    }}
public String pdfbox_f9776_0()
{    return booleanValue ? TRUE : FALSE;}
public boolean pdfbox_f9777_0()
{    return this.array;}
protected AbstractField pdfbox_f9778_0(String localName, Class<? extends AbstractField> type)
{    List<AbstractField> list = getPropertiesByLocalName(localName);    if (list != null) {        for (AbstractField abstractField : list) {            if (abstractField.getClass().equals(type)) {                return abstractField;            }        }    }    return null;}
public void pdfbox_f9779_0(AbstractField obj)
{    if (containsProperty(obj)) {        removeProperty(obj);    }    properties.add(obj);}
public List<AbstractField> pdfbox_f9780_0()
{    return properties;}
public List<AbstractField> pdfbox_f9781_0(String localName)
{    List<AbstractField> absFields = getAllProperties();    if (absFields != null) {        List<AbstractField> list = new ArrayList<>();        for (AbstractField abstractField : absFields) {            if (abstractField.getPropertyName().equals(localName)) {                list.add(abstractField);            }        }        if (list.isEmpty()) {            return null;        } else {            return list;        }    }    return null;}
public boolean pdfbox_f9782_0(AbstractField prop1, AbstractField prop2)
{    if (prop1.getClass().equals(prop2.getClass())) {        String pn1 = prop1.getPropertyName();        String pn2 = prop2.getPropertyName();        if (pn1 == null) {            return pn2 == null;        } else {            if (pn1.equals(pn2)) {                return prop1.equals(prop2);            }        }    }    return false;}
public boolean pdfbox_f9783_0(AbstractField property)
{    Iterator<AbstractField> it = getAllProperties().iterator();    AbstractField tmp;    while (it.hasNext()) {        tmp = it.next();        if (isSameProperty(tmp, property)) {            return true;        }    }    return false;}
public void pdfbox_f9784_0(AbstractField property)
{    if (containsProperty(property)) {        properties.remove(property);    }}
public void pdfbox_f9785_0(String localName)
{    if (properties.isEmpty()) {        return;    }    List<AbstractField> propList = getPropertiesByLocalName(localName);    if (propList == null) {        return;    }    for (AbstractField field : propList) {        properties.remove(field);    }}
private void pdfbox_f9786_0(Calendar value)
{    dateValue = value;}
public Calendar pdfbox_f9787_0()
{    return dateValue;}
private boolean pdfbox_f9788_0(Object value)
{    if (value instanceof Calendar) {        return true;    } else if (value instanceof String) {        try {            DateConverter.toCalendar((String) value);            return true;        } catch (IOException e) {            return false;        }    }    return false;}
public void pdfbox_f9789_0(Object value)
{    if (!isGoodType(value)) {        if (value == null) {            throw new IllegalArgumentException("Value null is not allowed for the Date type");        }        throw new IllegalArgumentException("Value given is not allowed for the Date type: " + value.getClass() + ", value: " + value);    } else {                if (value instanceof String) {            setValueFromString((String) value);        } else {                        setValueFromCalendar((Calendar) value);        }    }}
public String pdfbox_f9790_0()
{    return DateConverter.toISO8601(dateValue);}
private void pdfbox_f9791_0(String value)
{    try {        setValueFromCalendar(DateConverter.toCalendar(value));    } catch (IOException e) {                throw new IllegalArgumentException(e);    }}
public void pdfbox_f9792_0(String name, PropertyType type)
{    definedProperties.put(name, type);}
public Map<String, PropertyType> pdfbox_f9793_0()
{    return definedProperties;}
public Integer pdfbox_f9794_0()
{    return integerValue;}
public void pdfbox_f9795_0(Object value)
{    if (value instanceof Integer) {        integerValue = (Integer) value;    } else if (value instanceof String) {        integerValue = Integer.parseInt((String) value);        } else {                throw new IllegalArgumentException("Value given is not allowed for the Integer type: " + value);    }}
public String pdfbox_f9796_0()
{    return Integer.toString(integerValue);}
public void pdfbox_f9797_0(String id)
{    addSimpleProperty(ID, id);}
public void pdfbox_f9798_0(String name)
{    addSimpleProperty(NAME, name);}
public void pdfbox_f9799_0(String name)
{    addSimpleProperty(URL, name);}
public String pdfbox_f9800_0()
{    return getPropertyValueAsString(ID);}
public String pdfbox_f9801_0()
{    return getPropertyValueAsString(NAME);}
public String pdfbox_f9802_0()
{    return getPropertyValueAsString(URL);}
public String pdfbox_f9803_0()
{    AbstractField absProp = getFirstEquivalentProperty(LAYER_NAME, TextType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
public void pdfbox_f9804_0(String image)
{    this.addProperty(createTextType(LAYER_NAME, image));}
public String pdfbox_f9805_0()
{    AbstractField absProp = getFirstEquivalentProperty(LAYER_TEXT, TextType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
public void pdfbox_f9806_0(String image)
{    this.addProperty(createTextType(LAYER_TEXT, image));}
public String pdfbox_f9807_0()
{    TextType tt = (TextType) getProperty(NAME);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9808_0()
{    TextType tt = (TextType) getProperty(VALUETYPE);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9809_0()
{    TextType tt = (TextType) getProperty(DESCRIPTION);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9810_0()
{    TextType tt = (TextType) getProperty(NAME);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9811_0()
{    ChoiceType tt = (ChoiceType) getProperty(VALUETYPE);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9812_0()
{    TextType tt = (TextType) getProperty(DESCRIPTION);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9813_0()
{    ChoiceType tt = (ChoiceType) getProperty(CATEGORY);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9814_0()
{    URIType tt = (URIType) getProperty(NAMESPACE_URI);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9815_0()
{    TextType tt = (TextType) getProperty(PREFIX);    return tt == null ? null : tt.getStringValue();}
public ArrayProperty pdfbox_f9816_0()
{    return getArrayProperty(PROPERTY);}
public ArrayProperty pdfbox_f9817_0()
{    return getArrayProperty(VALUE_TYPE);}
public String pdfbox_f9818_0()
{    URIType tt = (URIType) getProperty(NS_URI);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9819_0()
{    TextType tt = (TextType) getProperty(TYPE);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9820_0()
{    TextType tt = (TextType) getProperty(PREFIX);    return tt == null ? null : tt.getStringValue();}
public String pdfbox_f9821_0()
{    TextType tt = (TextType) getProperty(DESCRIPTION);    return tt == null ? null : tt.getStringValue();}
public ArrayProperty pdfbox_f9822_0()
{    return getArrayProperty(FIELD);}
public List<String> pdfbox_f9823_0()
{    return new ArrayList<>(types.keySet());}
public void pdfbox_f9824_0(String name, PropertyType type)
{    types.put(name, type);}
public PropertyType pdfbox_f9825_0(String name)
{    return types.get(name);}
public Float pdfbox_f9826_0()
{    return realValue;}
public void pdfbox_f9827_0(Object value)
{    if (value instanceof Float) {        realValue = (Float) value;    } else if (value instanceof String) {                realValue = Float.valueOf((String) value);    } else {                throw new IllegalArgumentException("Value given is not allowed for the Real type: " + value);    }}
public String pdfbox_f9828_0()
{    return Float.toString(realValue);}
public String pdfbox_f9829_0()
{    return getPropertyValueAsString(INSTANCE_ID);}
public void pdfbox_f9830_0(String value)
{    addSimpleProperty(INSTANCE_ID, value);}
public String pdfbox_f9831_0()
{    return getPropertyValueAsString(SOFTWARE_AGENT);}
public void pdfbox_f9832_0(String value)
{    addSimpleProperty(SOFTWARE_AGENT, value);}
public Calendar pdfbox_f9833_0()
{    return getDatePropertyAsCalendar(WHEN);}
public void pdfbox_f9834_0(Calendar value)
{    addSimpleProperty(WHEN, value);}
public String pdfbox_f9835_0()
{    return getPropertyValueAsString(ACTION);}
public void pdfbox_f9836_0(String value)
{    addSimpleProperty(ACTION, value);}
public String pdfbox_f9837_0()
{    return getPropertyValueAsString(CHANGED);}
public void pdfbox_f9838_0(String value)
{    addSimpleProperty(CHANGED, value);}
public String pdfbox_f9839_0()
{    return getPropertyValueAsString(PARAMETERS);}
public void pdfbox_f9840_0(String value)
{    addSimpleProperty(PARAMETERS, value);}
public String pdfbox_f9841_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(DOCUMENT_ID, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9842_0(String value)
{    addSimpleProperty(DOCUMENT_ID, value);}
public String pdfbox_f9843_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(FILE_PATH, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9844_0(String value)
{    addSimpleProperty(FILE_PATH, value);}
public String pdfbox_f9845_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(INSTANCE_ID, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9846_0(String value)
{    addSimpleProperty(INSTANCE_ID, value);}
public Calendar pdfbox_f9847_0()
{    DateType absProp = (DateType) getFirstEquivalentProperty(LAST_MODIFY_DATE, DateType.class);    if (absProp != null) {        return absProp.getValue();    } else {        return null;    }}
public void pdfbox_f9848_0(Calendar value)
{    addSimpleProperty(LAST_MODIFY_DATE, value);}
public String pdfbox_f9849_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGE_UI, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9850_0(String value)
{    addSimpleProperty(MANAGE_UI, value);}
public String pdfbox_f9851_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGE_TO, URIType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9852_0(String value)
{    addSimpleProperty(MANAGE_TO, value);}
public String pdfbox_f9853_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGER, AgentNameType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9854_0(String value)
{    addSimpleProperty(MANAGER, value);}
public String pdfbox_f9855_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MANAGER_VARIANT, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9856_0(String value)
{    addSimpleProperty(MANAGER_VARIANT, value);}
public String pdfbox_f9857_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(PART_MAPPING, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9858_0(String value)
{    addSimpleProperty(PART_MAPPING, value);}
public String pdfbox_f9859_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(RENDITION_PARAMS, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9860_0(String value)
{    addSimpleProperty(RENDITION_PARAMS, value);}
public String pdfbox_f9861_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(VERSION_ID, TextType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9862_0(String value)
{    addSimpleProperty(VERSION_ID, value);}
public String pdfbox_f9863_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(MASK_MARKERS, ChoiceType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9864_0(String value)
{    addSimpleProperty(MASK_MARKERS, value);}
public String pdfbox_f9865_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(RENDITION_CLASS, RenditionClassType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9866_0(String value)
{    addSimpleProperty(RENDITION_CLASS, value);}
public String pdfbox_f9867_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(FROM_PART, PartType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9868_0(String value)
{    addSimpleProperty(FROM_PART, value);}
public String pdfbox_f9869_0()
{    TextType absProp = (TextType) getFirstEquivalentProperty(TO_PART, PartType.class);    if (absProp != null) {        return absProp.getStringValue();    } else {        return null;    }}
public void pdfbox_f9870_0(String value)
{    addSimpleProperty(TO_PART, value);}
public void pdfbox_f9871_0(String value)
{    ArrayProperty seq = (ArrayProperty) getFirstEquivalentProperty(ALTERNATE_PATHS, ArrayProperty.class);    if (seq == null) {        seq = getMetadata().getTypeMapping().createArrayProperty(null, getPreferedPrefix(), ALTERNATE_PATHS, Cardinality.Seq);        addProperty(seq);    }    TypeMapping tm = getMetadata().getTypeMapping();    TextType tt = (TextType) tm.instanciateSimpleProperty(null, "rdf", "li", value, Types.Text);    seq.addProperty(tt);}
public ArrayProperty pdfbox_f9872_0()
{    return (ArrayProperty) getFirstEquivalentProperty(ALTERNATE_PATHS, ArrayProperty.class);}
public List<String> pdfbox_f9873_0()
{    ArrayProperty seq = (ArrayProperty) getFirstEquivalentProperty(ALTERNATE_PATHS, ArrayProperty.class);    if (seq != null) {        return seq.getElementsAsString();    } else {        return null;    }}
public void pdfbox_f9874_0(Object value)
{    if (!(value instanceof String)) {        throw new IllegalArgumentException("Value given is not allowed for the Text type : '" + value + "'");    } else {        textValue = (String) value;    }}
public String pdfbox_f9875_0()
{    return textValue;}
public Object pdfbox_f9876_0()
{    return textValue;}
public Integer pdfbox_f9877_0()
{    AbstractField absProp = getFirstEquivalentProperty(HEIGHT, IntegerType.class);    if (absProp != null) {        return ((IntegerType) absProp).getValue();    }    return null;}
public void pdfbox_f9878_0(Integer height)
{    addSimpleProperty(HEIGHT, height);}
public Integer pdfbox_f9879_0()
{    AbstractField absProp = getFirstEquivalentProperty(WIDTH, IntegerType.class);    if (absProp != null) {        return ((IntegerType) absProp).getValue();    }    return null;}
public void pdfbox_f9880_0(Integer width)
{    addSimpleProperty(WIDTH, width);}
public String pdfbox_f9881_0()
{    AbstractField absProp = getFirstEquivalentProperty(IMAGE, TextType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
public void pdfbox_f9882_0(String image)
{    addSimpleProperty(IMAGE, image);}
public String pdfbox_f9883_0()
{    AbstractField absProp = getFirstEquivalentProperty(FORMAT, ChoiceType.class);    if (absProp != null) {        return ((TextType) absProp).getStringValue();    }    return null;}
public void pdfbox_f9884_0(String format)
{    addSimpleProperty(FORMAT, format);}
private void pdfbox_f9885_0()
{        structuredMappings = new EnumMap<>(Types.class);    structuredNamespaces = new HashMap<>();    for (Types type : Types.values()) {        if (type.isStructured()) {            Class<? extends AbstractStructuredType> clz = type.getImplementingClass().asSubclass(AbstractStructuredType.class);            StructuredType st = clz.getAnnotation(StructuredType.class);            String ns = st.namespace();            PropertiesDescription pm = initializePropMapping(clz);            structuredNamespaces.put(ns, type);            structuredMappings.put(type, pm);        }    }        definedStructuredNamespaces = new HashMap<>();    definedStructuredMappings = new HashMap<>();        schemaMap = new HashMap<>();    addNameSpace(XMPBasicSchema.class);    addNameSpace(DublinCoreSchema.class);    addNameSpace(PDFAExtensionSchema.class);    addNameSpace(XMPMediaManagementSchema.class);    addNameSpace(AdobePDFSchema.class);    addNameSpace(PDFAIdentificationSchema.class);    addNameSpace(XMPRightsManagementSchema.class);    addNameSpace(PhotoshopSchema.class);    addNameSpace(XMPBasicJobTicketSchema.class);    addNameSpace(ExifSchema.class);    addNameSpace(TiffSchema.class);    addNameSpace(XMPageTextSchema.class);}
public void pdfbox_f9886_0(String typeName, String ns, PropertiesDescription pm)
{    definedStructuredNamespaces.put(ns, typeName);    definedStructuredMappings.put(typeName, pm);}
public PropertiesDescription pdfbox_f9887_0(String namespace)
{    String dt = definedStructuredNamespaces.get(namespace);    return this.definedStructuredMappings.get(dt);}
public AbstractStructuredType pdfbox_f9888_0(Types type, String propertyName) throws BadFieldValueException
{    try {        Class<? extends AbstractStructuredType> propertyTypeClass = type.getImplementingClass().asSubclass(AbstractStructuredType.class);        Constructor<? extends AbstractStructuredType> construct = propertyTypeClass.getDeclaredConstructor(XMPMetadata.class);        AbstractStructuredType tmp = construct.newInstance(metadata);        tmp.setPropertyName(propertyName);        return tmp;    } catch (InvocationTargetException | IllegalArgumentException | InstantiationException | IllegalAccessException | SecurityException | NoSuchMethodException e) {        throw new BadFieldValueException("Failed to instanciate structured type : " + type, e);    }}
public AbstractStructuredType pdfbox_f9889_0(String propertyName, String namespace)
{    return new DefinedStructuredType(metadata, namespace, null, propertyName);}
public AbstractSimpleProperty pdfbox_f9890_0(String nsuri, String prefix, String name, Object value, Types type)
{        Object[] params = new Object[] { metadata, nsuri, prefix, name, value };        Class<? extends AbstractSimpleProperty> clz = type.getImplementingClass().asSubclass(AbstractSimpleProperty.class);    try {        Constructor<? extends AbstractSimpleProperty> cons = clz.getDeclaredConstructor(SIMPLEPROPERTYCONSTPARAMS);        return cons.newInstance(params);    } catch (NoSuchMethodError | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException | SecurityException | NoSuchMethodException e) {        throw new IllegalArgumentException("Failed to instanciate " + clz.getSimpleName() + " property with value " + value, e);    }}
public AbstractSimpleProperty pdfbox_f9891_0(Class<?> clz, String nsuri, String prefix, String propertyName, Object value)
{    PropertiesDescription pm = initializePropMapping(clz);    PropertyType simpleType = pm.getPropertyType(propertyName);    Types type = simpleType.type();    return instanciateSimpleProperty(nsuri, prefix, propertyName, value, type);}
public boolean pdfbox_f9892_0(String namespace)
{    return structuredNamespaces.containsKey(namespace);}
public boolean pdfbox_f9893_0(String namespace)
{    return definedStructuredNamespaces.containsKey(namespace);}
public boolean pdfbox_f9894_0(String name)
{    return this.definedStructuredMappings.containsKey(name);}
private void pdfbox_f9895_0(Class<? extends XMPSchema> classSchem)
{    StructuredType st = classSchem.getAnnotation(StructuredType.class);    String ns = st.namespace();    schemaMap.put(ns, new XMPSchemaFactory(ns, classSchem, initializePropMapping(classSchem)));}
public void pdfbox_f9896_0(String ns, String prefered)
{    PropertiesDescription mapping = new PropertiesDescription();    schemaMap.put(ns, new XMPSchemaFactory(ns, XMPSchema.class, mapping));}
public PropertiesDescription pdfbox_f9897_0(Types type)
{    return structuredMappings.get(type);}
public XMPSchema pdfbox_f9898_0(XMPMetadata metadata, String namespace, String prefix) throws XmpSchemaException
{    if (schemaMap.containsKey(namespace)) {        XMPSchemaFactory factory = schemaMap.get(namespace);        return factory.createXMPSchema(metadata, prefix);    } else {        XMPSchemaFactory factory = getSchemaFactory(namespace);        return factory != null ? factory.createXMPSchema(metadata, prefix) : null;    }}
public XMPSchemaFactory pdfbox_f9899_0(String namespace)
{    return schemaMap.get(namespace);}
public boolean pdfbox_f9900_0(String namespace)
{    return schemaMap.containsKey(namespace);}
public boolean pdfbox_f9901_0(String namespace)
{    return isDefinedSchema(namespace) || isStructuredTypeNamespace(namespace) || isDefinedTypeNamespace(namespace);}
public PropertyType pdfbox_f9902_0(QName name) throws BadFieldValueException
{    XMPSchemaFactory factory = getSchemaFactory(name.getNamespaceURI());    if (factory != null) {                return factory.getPropertyType(name.getLocalPart());    } else {                Types st = structuredNamespaces.get(name.getNamespaceURI());        if (st != null) {            return createPropertyType(st, Cardinality.Simple);        } else {                        String dt = definedStructuredNamespaces.get(name.getNamespaceURI());            if (dt == null) {                                throw new BadFieldValueException("No descriptor found for " + name);            } else {                return createPropertyType(Types.DefinedType, Cardinality.Simple);            }        }    }}
public PropertiesDescription pdfbox_f9903_0(Class<?> classSchem)
{    PropertiesDescription propMap = new PropertiesDescription();    Field[] fields = classSchem.getFields();    String propName = null;    for (Field field : fields) {        if (field.isAnnotationPresent(PropertyType.class)) {            try {                propName = (String) field.get(propName);            } catch (Exception e) {                throw new IllegalArgumentException("couldn't read one type declaration, please check accessibility and declaration of fields annoted in " + classSchem.getName(), e);            }            PropertyType propType = field.getAnnotation(PropertyType.class);            propMap.addNewProperty(propName, propType);        }    }    return propMap;}
public BooleanType pdfbox_f9904_0(String namespaceURI, String prefix, String propertyName, boolean value)
{    return new BooleanType(metadata, namespaceURI, prefix, propertyName, value);}
public DateType pdfbox_f9905_0(String namespaceURI, String prefix, String propertyName, Calendar value)
{    return new DateType(metadata, namespaceURI, prefix, propertyName, value);}
public IntegerType pdfbox_f9906_0(String namespaceURI, String prefix, String propertyName, int value)
{    return new IntegerType(metadata, namespaceURI, prefix, propertyName, value);}
public RealType pdfbox_f9907_0(String namespaceURI, String prefix, String propertyName, float value)
{    return new RealType(metadata, namespaceURI, prefix, propertyName, value);}
public TextType pdfbox_f9908_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new TextType(metadata, namespaceURI, prefix, propertyName, value);}
public ProperNameType pdfbox_f9909_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new ProperNameType(metadata, namespaceURI, prefix, propertyName, value);}
public URIType pdfbox_f9910_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new URIType(metadata, namespaceURI, prefix, propertyName, value);}
public URLType pdfbox_f9911_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new URLType(metadata, namespaceURI, prefix, propertyName, value);}
public RenditionClassType pdfbox_f9912_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new RenditionClassType(metadata, namespaceURI, prefix, propertyName, value);}
public PartType pdfbox_f9913_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new PartType(metadata, namespaceURI, prefix, propertyName, value);}
public MIMEType pdfbox_f9914_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new MIMEType(metadata, namespaceURI, prefix, propertyName, value);}
public LocaleType pdfbox_f9915_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new LocaleType(metadata, namespaceURI, prefix, propertyName, value);}
public GUIDType pdfbox_f9916_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new GUIDType(metadata, namespaceURI, prefix, propertyName, value);}
public ChoiceType pdfbox_f9917_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new ChoiceType(metadata, namespaceURI, prefix, propertyName, value);}
public AgentNameType pdfbox_f9918_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new AgentNameType(metadata, namespaceURI, prefix, propertyName, value);}
public XPathType pdfbox_f9919_0(String namespaceURI, String prefix, String propertyName, String value)
{    return new XPathType(metadata, namespaceURI, prefix, propertyName, value);}
public ArrayProperty pdfbox_f9920_0(String namespace, String prefix, String propertyName, Cardinality type)
{    return new ArrayProperty(metadata, namespace, prefix, propertyName, type);}
public static PropertyType pdfbox_f9921_0(final Types type, final Cardinality card)
{    return new PropertyType() {        @Override        public Class<? extends Annotation> annotationType() {            return null;        }        @Override        public Types type() {            return type;        }        @Override        public Cardinality card() {            return card;        }    };}
public Class<? extends Annotation> pdfbox_f9922_0()
{    return null;}
public Types pdfbox_f9923_0()
{    return type;}
public Cardinality pdfbox_f9924_0()
{    return card;}
public boolean pdfbox_f9925_0()
{    return simple;}
public boolean pdfbox_f9926_0()
{    return basic == null;}
public boolean pdfbox_f9927_0()
{    return basic == Structured;}
public boolean pdfbox_f9928_0()
{    return this == DefinedType;}
public Types pdfbox_f9929_0()
{    return basic;}
public Class<? extends AbstractField> pdfbox_f9930_0()
{    return clz;}
public String pdfbox_f9931_0()
{    return getPropertyValueAsString(COMMENTS);}
public void pdfbox_f9932_0(String value)
{    addSimpleProperty(COMMENTS, value);}
public ResourceEventType pdfbox_f9933_0()
{    return (ResourceEventType) getFirstEquivalentProperty(EVENT, ResourceEventType.class);}
public void pdfbox_f9934_0(ResourceEventType value)
{    this.addProperty(value);}
public Calendar pdfbox_f9935_0()
{    return getDatePropertyAsCalendar(MODIFY_DATE);}
public void pdfbox_f9936_0(Calendar value)
{    addSimpleProperty(MODIFY_DATE, value);}
public String pdfbox_f9937_0()
{    return getPropertyValueAsString(VERSION);}
public void pdfbox_f9938_0(String value)
{    addSimpleProperty(VERSION, value);}
public String pdfbox_f9939_0()
{    return getPropertyValueAsString(MODIFIER);}
public void pdfbox_f9940_0(String value)
{    addSimpleProperty(MODIFIER, value);}
public static Element pdfbox_f9941_0(Element description) throws XmpParsingException
{    NodeList nl = description.getChildNodes();    int pos = -1;    for (int i = 0; i < nl.getLength(); i++) {        if (nl.item(i) instanceof Element) {            if (pos >= 0) {                                throw new XmpParsingException(ErrorType.Undefined, "Found two child elements in " + description);            } else {                pos = i;            }        }    }    return (Element) nl.item(pos);}
public static Element pdfbox_f9942_0(Element description) throws XmpParsingException
{    NodeList nl = description.getChildNodes();    for (int i = 0; i < nl.getLength(); i++) {        if (nl.item(i) instanceof Element) {            return (Element) nl.item(i);        }    }    return null;}
public static List<Element> pdfbox_f9943_0(Element description) throws XmpParsingException
{    NodeList nl = description.getChildNodes();    List<Element> ret = new ArrayList<>(nl.getLength());    for (int i = 0; i < nl.getLength(); i++) {        if (nl.item(i) instanceof Element) {            ret.add((Element) nl.item(i));        }    }    return ret;}
public static QName pdfbox_f9944_0(Element element)
{    return new QName(element.getNamespaceURI(), element.getLocalName(), element.getPrefix());}
public static boolean pdfbox_f9945_0(Element element)
{    return (XmpConstants.DEFAULT_RDF_PREFIX.equals(element.getPrefix()) && XmpConstants.DESCRIPTION_NAME.equals(element.getLocalName()));}
public static boolean pdfbox_f9946_0(Element element)
{    Attr parseType = element.getAttributeNodeNS(XmpConstants.RDF_NAMESPACE, XmpConstants.PARSE_TYPE);    return parseType != null && XmpConstants.RESOURCE_NAME.equals(parseType.getValue());}
public boolean pdfbox_f9947_0()
{    return strictParsing;}
public void pdfbox_f9948_0(boolean strictParsing)
{    this.strictParsing = strictParsing;}
public XMPMetadata pdfbox_f9949_0(byte[] xmp) throws XmpParsingException
{    ByteArrayInputStream input = new ByteArrayInputStream(xmp);    return parse(input);}
public XMPMetadata pdfbox_f9950_0(InputStream input) throws XmpParsingException
{    Document document = null;    try {                dBuilder.setErrorHandler(null);        document = dBuilder.parse(input);    } catch (SAXException | IOException e) {        throw new XmpParsingException(ErrorType.Undefined, "Failed to parse", e);    }    XMPMetadata xmp = null;        removeComments(document);    Node node = document.getFirstChild();        if (!(node instanceof ProcessingInstruction)) {        throw new XmpParsingException(ErrorType.XpacketBadStart, "xmp should start with a processing instruction");    } else {        xmp = parseInitialXpacket((ProcessingInstruction) node);        node = node.getNextSibling();    }        while (node instanceof ProcessingInstruction) {        node = node.getNextSibling();    }        Element root = null;    if (!(node instanceof Element)) {        throw new XmpParsingException(ErrorType.NoRootElement, "xmp should contain a root element");    } else {                root = (Element) node;        node = node.getNextSibling();    }        if (!(node instanceof ProcessingInstruction)) {        throw new XmpParsingException(ErrorType.XpacketBadEnd, "xmp should end with a processing instruction");    } else {        parseEndPacket(xmp, (ProcessingInstruction) node);        node = node.getNextSibling();    }        if (node != null) {        throw new XmpParsingException(ErrorType.XpacketBadEnd, "xmp should end after xpacket end processing instruction");    }            Element rdfRdf = findDescriptionsParent(root);    List<Element> descriptions = DomHelper.getElementChildren(rdfRdf);    List<Element> dataDescriptions = new ArrayList<>(descriptions.size());    for (Element description : descriptions) {        Element first = DomHelper.getFirstChildElement(description);        if (first != null && "pdfaExtension".equals(first.getPrefix())) {            PdfaExtensionHelper.validateNaming(xmp, description);            parseDescriptionRoot(xmp, description);        } else {            dataDescriptions.add(description);        }    }        PdfaExtensionHelper.populateSchemaMapping(xmp);        for (Element description : dataDescriptions) {        parseDescriptionRoot(xmp, description);    }    return xmp;}
private void pdfbox_f9951_0(XMPMetadata xmp, Element description) throws XmpParsingException
{    nsFinder.push(description);    TypeMapping tm = xmp.getTypeMapping();    try {        List<Element> properties = DomHelper.getElementChildren(description);                NamedNodeMap nnm = description.getAttributes();        for (int i = 0; i < nnm.getLength(); i++) {            Attr attr = (Attr) nnm.item(i);            if (XMLConstants.XMLNS_ATTRIBUTE.equals(attr.getPrefix())) {                        } else if (XmpConstants.DEFAULT_RDF_PREFIX.equals(attr.getPrefix()) && XmpConstants.ABOUT_NAME.equals(attr.getLocalName())) {                        } else if (attr.getPrefix() == null && XmpConstants.ABOUT_NAME.equals(attr.getLocalName())) {                        } else {                parseDescriptionRootAttr(xmp, description, attr, tm);            }        }        parseChildrenAsProperties(xmp, properties, tm, description);    } catch (XmpSchemaException e) {        throw new XmpParsingException(ErrorType.Undefined, "Parsing failed", e);    } finally {        nsFinder.pop();    }}
private void pdfbox_f9952_0(XMPMetadata xmp, Element description, Attr attr, TypeMapping tm) throws XmpSchemaException, XmpParsingException
{    String namespace = attr.getNamespaceURI();    XMPSchema schema = xmp.getSchema(namespace);    if (schema == null && tm.getSchemaFactory(namespace) != null) {        schema = tm.getSchemaFactory(namespace).createXMPSchema(xmp, attr.getPrefix());        loadAttributes(schema, description);    }        if (schema != null) {        ComplexPropertyContainer container = schema.getContainer();        PropertyType type = checkPropertyDefinition(xmp, new QName(attr.getNamespaceURI(), attr.getLocalName()));                if (type == null) {            type = TypeMapping.createPropertyType(Types.Text, Cardinality.Simple);        }        try {            AbstractSimpleProperty sp = tm.instanciateSimpleProperty(namespace, schema.getPrefix(), attr.getLocalName(), attr.getValue(), type.type());            container.addProperty(sp);        } catch (IllegalArgumentException e) {            throw new XmpParsingException(ErrorType.Format, e.getMessage() + " in " + schema.getPrefix() + ":" + attr.getLocalName(), e);        }    }}
private void pdfbox_f9953_0(XMPMetadata xmp, List<Element> properties, TypeMapping tm, Element description) throws XmpParsingException, XmpSchemaException
{        for (Element property : properties) {        String namespace = property.getNamespaceURI();        PropertyType type = checkPropertyDefinition(xmp, DomHelper.getQName(property));                if (!tm.isDefinedSchema(namespace)) {            throw new XmpParsingException(ErrorType.NoSchema, "This namespace is not a schema or a structured type : " + namespace);        }        XMPSchema schema = xmp.getSchema(namespace);        if (schema == null) {            schema = tm.getSchemaFactory(namespace).createXMPSchema(xmp, property.getPrefix());            loadAttributes(schema, description);        }        ComplexPropertyContainer container = schema.getContainer();                createProperty(xmp, property, type, container);    }}
private void pdfbox_f9954_0(XMPMetadata xmp, Element property, PropertyType type, ComplexPropertyContainer container) throws XmpParsingException
{    String prefix = property.getPrefix();    String name = property.getLocalName();    String namespace = property.getNamespaceURI();        nsFinder.push(property);    try {        if (type == null) {            if (strictParsing) {                throw new XmpParsingException(ErrorType.InvalidType, "No type defined for {" + namespace + "}" + name);            } else {                                manageSimpleType(xmp, property, Types.Text, container);            }        } else if (type.type() == Types.LangAlt) {            manageLangAlt(xmp, property, container);        } else if (type.card().isArray()) {            manageArray(xmp, property, type, container);        } else if (type.type().isSimple()) {            manageSimpleType(xmp, property, type.type(), container);        } else if (type.type().isStructured()) {            manageStructuredType(xmp, property, prefix, container);        } else if (type.type() == Types.DefinedType) {            manageDefinedType(xmp, property, prefix, container);        }    } catch (IllegalArgumentException e) {        throw new XmpParsingException(ErrorType.Format, e.getMessage() + " in " + prefix + ":" + name, e);    } finally {        nsFinder.pop();    }}
private void pdfbox_f9955_0(XMPMetadata xmp, Element property, String prefix, ComplexPropertyContainer container) throws XmpParsingException
{    if (DomHelper.isParseTypeResource(property)) {        AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), property);        ast.setPrefix(prefix);        container.addProperty(ast);    } else {        Element inner = DomHelper.getFirstChildElement(property);        if (inner == null) {            throw new XmpParsingException(ErrorType.Format, "property should contain child element : " + property);        }        AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), inner);        ast.setPrefix(prefix);        container.addProperty(ast);    }}
private void pdfbox_f9956_0(XMPMetadata xmp, Element property, String prefix, ComplexPropertyContainer container) throws XmpParsingException
{    if (DomHelper.isParseTypeResource(property)) {        AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), property);        if (ast != null) {            ast.setPrefix(prefix);            container.addProperty(ast);        }    } else {        Element inner = DomHelper.getFirstChildElement(property);        if (inner != null) {            nsFinder.push(inner);            AbstractStructuredType ast = parseLiDescription(xmp, DomHelper.getQName(property), inner);            ast.setPrefix(prefix);            container.addProperty(ast);        }    }}
private void pdfbox_f9957_0(XMPMetadata xmp, Element property, Types type, ComplexPropertyContainer container) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();    String prefix = property.getPrefix();    String name = property.getLocalName();    String namespace = property.getNamespaceURI();    AbstractSimpleProperty sp = tm.instanciateSimpleProperty(namespace, prefix, name, property.getTextContent(), type);    loadAttributes(sp, property);    container.addProperty(sp);}
private void pdfbox_f9958_0(XMPMetadata xmp, Element property, PropertyType type, ComplexPropertyContainer container) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();    String prefix = property.getPrefix();    String name = property.getLocalName();    String namespace = property.getNamespaceURI();    Element bagOrSeq = DomHelper.getUniqueElementChild(property);        if (bagOrSeq == null) {                String whatFound = "nothing";        if (property.getFirstChild() != null) {            whatFound = property.getFirstChild().getClass().getName();        }        throw new XmpParsingException(ErrorType.Format, "Invalid array definition, expecting " + type.card() + " and found " + whatFound + " [prefix=" + prefix + "; name=" + name + "]");    }    if (!bagOrSeq.getLocalName().equals(type.card().name())) {                throw new XmpParsingException(ErrorType.Format, "Invalid array type, expecting " + type.card() + " and found " + bagOrSeq.getLocalName() + " [prefix=" + prefix + "; name=" + name + "]");    }    ArrayProperty array = tm.createArrayProperty(namespace, prefix, name, type.card());    container.addProperty(array);    List<Element> lis = DomHelper.getElementChildren(bagOrSeq);    for (Element element : lis) {        QName propertyQName = new QName(element.getLocalName());        AbstractField ast = parseLiElement(xmp, propertyQName, element, type.type());        if (ast != null) {            array.addProperty(ast);        }    }}
private void pdfbox_f9959_0(XMPMetadata xmp, Element property, ComplexPropertyContainer container) throws XmpParsingException
{    manageArray(xmp, property, TypeMapping.createPropertyType(Types.LangAlt, Cardinality.Alt), container);}
private void pdfbox_f9960_0(XMPMetadata xmp, Element description, ComplexPropertyContainer parentContainer) throws XmpParsingException
{    nsFinder.push(description);    TypeMapping tm = xmp.getTypeMapping();    try {        List<Element> properties = DomHelper.getElementChildren(description);        for (Element property : properties) {            String name = property.getLocalName();            PropertyType dtype = checkPropertyDefinition(xmp, DomHelper.getQName(property));            PropertyType ptype = tm.getStructuredPropMapping(dtype.type()).getPropertyType(name);                        createProperty(xmp, property, ptype, parentContainer);        }    } finally {        nsFinder.pop();    }}
private AbstractField pdfbox_f9961_0(XMPMetadata xmp, QName descriptor, Element liElement, Types type) throws XmpParsingException
{    if (DomHelper.isParseTypeResource(liElement)) {        return parseLiDescription(xmp, descriptor, liElement);    }        Element liChild = DomHelper.getUniqueElementChild(liElement);    if (liChild != null) {        nsFinder.push(liChild);        return parseLiDescription(xmp, descriptor, liChild);    } else {                String text = liElement.getTextContent();        TypeMapping tm = xmp.getTypeMapping();        if (type.isSimple()) {            AbstractField af = tm.instanciateSimpleProperty(descriptor.getNamespaceURI(), descriptor.getPrefix(), descriptor.getLocalPart(), text, type);            loadAttributes(af, liElement);            return af;        } else {                        AbstractField af;            try {                af = tm.instanciateStructuredType(type, descriptor.getLocalPart());            } catch (BadFieldValueException ex) {                throw new XmpParsingException(ErrorType.InvalidType, "Parsing of structured type failed", ex);            }            loadAttributes(af, liElement);            return af;        }    }}
private void pdfbox_f9962_0(AbstractField sp, Element element)
{    NamedNodeMap nnm = element.getAttributes();    for (int i = 0; i < nnm.getLength(); i++) {        Attr attr = (Attr) nnm.item(i);        if (XMLConstants.XMLNS_ATTRIBUTE.equals(attr.getPrefix())) {                } else if (XmpConstants.DEFAULT_RDF_PREFIX.equals(attr.getPrefix()) && XmpConstants.ABOUT_NAME.equals(attr.getLocalName())) {                        if (sp instanceof XMPSchema) {                ((XMPSchema) sp).setAboutAsSimple(attr.getValue());            }        } else {            Attribute attribute = new Attribute(XMLConstants.XML_NS_URI, attr.getLocalName(), attr.getValue());            sp.setAttribute(attribute);        }    }}
private AbstractStructuredType pdfbox_f9963_0(XMPMetadata xmp, QName descriptor, Element liElement) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();    List<Element> elements = DomHelper.getElementChildren(liElement);    if (elements.isEmpty()) {                return null;    }        Element first = elements.get(0);    PropertyType ctype = checkPropertyDefinition(xmp, DomHelper.getQName(first));    Types tt = ctype.type();    AbstractStructuredType ast = instanciateStructured(tm, tt, descriptor.getLocalPart(), first.getNamespaceURI());    ast.setNamespace(descriptor.getNamespaceURI());    ast.setPrefix(descriptor.getPrefix());    PropertiesDescription pm;    if (tt.isStructured()) {        pm = tm.getStructuredPropMapping(tt);    } else {        pm = tm.getDefinedDescriptionByNamespace(first.getNamespaceURI());    }    for (Element element : elements) {        String prefix = element.getPrefix();        String name = element.getLocalName();        String namespace = element.getNamespaceURI();        PropertyType type = pm.getPropertyType(name);        if (type == null) {                        throw new XmpParsingException(ErrorType.NoType, "Type '" + name + "' not defined in " + element.getNamespaceURI());        } else if (type.card().isArray()) {            ArrayProperty array = tm.createArrayProperty(namespace, prefix, name, type.card());            ast.getContainer().addProperty(array);            Element bagOrSeq = DomHelper.getUniqueElementChild(element);            List<Element> lis = DomHelper.getElementChildren(bagOrSeq);            for (Element element2 : lis) {                AbstractField ast2 = parseLiElement(xmp, descriptor, element2, type.type());                if (ast2 != null) {                    array.addProperty(ast2);                }            }        } else if (type.type().isSimple()) {            AbstractSimpleProperty sp = tm.instanciateSimpleProperty(namespace, prefix, name, element.getTextContent(), type.type());            loadAttributes(sp, element);            ast.getContainer().addProperty(sp);        } else if (type.type().isStructured()) {                        AbstractStructuredType inner = instanciateStructured(tm, type.type(), name, null);            inner.setNamespace(namespace);            inner.setPrefix(prefix);            ast.getContainer().addProperty(inner);            ComplexPropertyContainer cpc = inner.getContainer();            if (DomHelper.isParseTypeResource(element)) {                parseDescriptionInner(xmp, element, cpc);            } else {                Element descElement = DomHelper.getFirstChildElement(element);                if (descElement != null) {                    parseDescriptionInner(xmp, descElement, cpc);                }            }        } else {            throw new XmpParsingException(ErrorType.NoType, "Unidentified element to parse " + element + " (type=" + type + ")");        }    }    return ast;}
private XMPMetadata pdfbox_f9964_0(ProcessingInstruction pi) throws XmpParsingException
{    if (!"xpacket".equals(pi.getNodeName())) {        throw new XmpParsingException(ErrorType.XpacketBadStart, "Bad processing instruction name : " + pi.getNodeName());    }    String data = pi.getData();    StringTokenizer tokens = new StringTokenizer(data, " ");    String id = null;    String begin = null;    String bytes = null;    String encoding = null;    while (tokens.hasMoreTokens()) {        String token = tokens.nextToken();        if (!token.endsWith("\"") && !token.endsWith("\'")) {            throw new XmpParsingException(ErrorType.XpacketBadStart, "Cannot understand PI data part : '" + token + "' in '" + data + "'");        }        String quote = token.substring(token.length() - 1);        int pos = token.indexOf("=" + quote);        if (pos <= 0) {            throw new XmpParsingException(ErrorType.XpacketBadStart, "Cannot understand PI data part : '" + token + "' in '" + data + "'");        }        String name = token.substring(0, pos);        if (token.length() - 1 < pos + 2) {            throw new XmpParsingException(ErrorType.XpacketBadStart, "Cannot understand PI data part : '" + token + "' in '" + data + "'");        }        String value = token.substring(pos + 2, token.length() - 1);        switch(name) {            case "id":                id = value;                break;            case "begin":                begin = value;                break;            case "bytes":                bytes = value;                break;            case "encoding":                encoding = value;                break;            default:                throw new XmpParsingException(ErrorType.XpacketBadStart, "Unknown attribute in xpacket PI : '" + token + "'");        }    }    return XMPMetadata.createXMPMetadata(begin, id, bytes, encoding);}
private void pdfbox_f9965_0(XMPMetadata metadata, ProcessingInstruction pi) throws XmpParsingException
{    String xpackData = pi.getData();        if (xpackData.startsWith("end=")) {        char end = xpackData.charAt(5);                if (end != 'r' && end != 'w') {            throw new XmpParsingException(ErrorType.XpacketBadEnd, "Excepted xpacket 'end' attribute with value 'r' or 'w' ");        } else {            metadata.setEndXPacket(Character.toString(end));        }    } else {                throw new XmpParsingException(ErrorType.XpacketBadEnd, "Excepted xpacket 'end' attribute (must be present and placed in first)");    }}
private Element pdfbox_f9966_0(Element root) throws XmpParsingException
{        expectNaming(root, "adobe:ns:meta/", "x", "xmpmeta");        NodeList nl = root.getChildNodes();    if (nl.getLength() == 0) {                throw new XmpParsingException(ErrorType.Format, "No rdf description found in xmp");    } else if (nl.getLength() > 1) {                throw new XmpParsingException(ErrorType.Format, "More than one element found in x:xmpmeta");    } else if (!(root.getFirstChild() instanceof Element)) {                throw new XmpParsingException(ErrorType.Format, "x:xmpmeta does not contains rdf:RDF element");    }        Element rdfRdf = (Element) root.getFirstChild();            expectNaming(rdfRdf, XmpConstants.RDF_NAMESPACE, XmpConstants.DEFAULT_RDF_PREFIX, XmpConstants.DEFAULT_RDF_LOCAL_NAME);        return rdfRdf;}
private void pdfbox_f9967_0(Element element, String ns, String prefix, String ln) throws XmpParsingException
{    if ((ns != null) && !(ns.equals(element.getNamespaceURI()))) {        throw new XmpParsingException(ErrorType.Format, "Expecting namespace '" + ns + "' and found '" + element.getNamespaceURI() + "'");    } else if ((prefix != null) && !(prefix.equals(element.getPrefix()))) {        throw new XmpParsingException(ErrorType.Format, "Expecting prefix '" + prefix + "' and found '" + element.getPrefix() + "'");    } else if ((ln != null) && !(ln.equals(element.getLocalName()))) {        throw new XmpParsingException(ErrorType.Format, "Expecting local name '" + ln + "' and found '" + element.getLocalName() + "'");    }}
private void pdfbox_f9968_0(Node root)
{        List<Node> forDeletion = new ArrayList<>();    NodeList nl = root.getChildNodes();    if (nl.getLength() <= 1) {                return;    }    for (int i = 0; i < nl.getLength(); i++) {        Node node = nl.item(i);        if (node instanceof Comment) {                        forDeletion.add(node);        } else if (node instanceof Text) {            if (node.getTextContent().trim().isEmpty()) {                                                forDeletion.add(node);            }        } else if (node instanceof Element) {                        removeComments(node);        }        }        for (Node node : forDeletion) {        root.removeChild(node);    }}
private AbstractStructuredType pdfbox_f9969_0(TypeMapping tm, Types type, String name, String structuredNamespace) throws XmpParsingException
{    try {        if (type.isStructured()) {            return tm.instanciateStructuredType(type, name);        } else if (type.isDefined()) {            return tm.instanciateDefinedType(name, structuredNamespace);        } else {            throw new XmpParsingException(ErrorType.InvalidType, "Type not structured : " + type);        }    } catch (BadFieldValueException e) {        throw new XmpParsingException(ErrorType.InvalidType, "Parsing failed", e);    }}
private PropertyType pdfbox_f9970_0(XMPMetadata xmp, QName prop) throws XmpParsingException
{    TypeMapping tm = xmp.getTypeMapping();        if (!nsFinder.containsNamespace(prop.getNamespaceURI())) {        throw new XmpParsingException(ErrorType.NoSchema, "Schema is not set in this document : " + prop.getNamespaceURI());    }        String nsuri = prop.getNamespaceURI();    if (!tm.isDefinedNamespace(nsuri)) {        throw new XmpParsingException(ErrorType.NoSchema, "Cannot find a definition for the namespace " + prop.getNamespaceURI());    }    try {        return tm.getSpecifiedPropertyType(prop);    } catch (BadFieldValueException e) {        throw new XmpParsingException(ErrorType.InvalidType, "Failed to retrieve property definition", e);    }}
protected void pdfbox_f9971_0(Element description)
{    NamedNodeMap nnm = description.getAttributes();    Map<String, String> map = new HashMap<>(nnm.getLength());    for (int j = 0; j < nnm.getLength(); j++) {        Attr no = (Attr) nnm.item(j);                if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(no.getNamespaceURI())) {            map.put(no.getLocalName(), no.getValue());        }    }    stack.push(map);}
protected Map<String, String> pdfbox_f9972_0()
{    return stack.pop();}
protected boolean pdfbox_f9973_0(String namespace)
{    for (int i = stack.size() - 1; i >= 0; i--) {        Map<String, String> map = stack.get(i);        if (map.containsValue(namespace)) {            return true;        }    }        return false;}
public static void pdfbox_f9974_0(XMPMetadata meta, Element description) throws XmpParsingException
{    NamedNodeMap nnm = description.getAttributes();    for (int i = 0; i < nnm.getLength(); i++) {        Attr attr = (Attr) nnm.item(i);        checkNamespaceDeclaration(attr, PDFAExtensionSchema.class);        checkNamespaceDeclaration(attr, PDFAFieldType.class);        checkNamespaceDeclaration(attr, PDFAPropertyType.class);        checkNamespaceDeclaration(attr, PDFASchemaType.class);        checkNamespaceDeclaration(attr, PDFATypeType.class);    }}
private static void pdfbox_f9975_0(Attr attr, Class<? extends AbstractStructuredType> clz) throws XmpParsingException
{    String prefix = attr.getLocalName();    String namespace = attr.getValue();    String cprefix = clz.getAnnotation(StructuredType.class).preferedPrefix();    String cnamespace = clz.getAnnotation(StructuredType.class).namespace();        if (cprefix.equals(prefix) && !cnamespace.equals(namespace)) {        throw new XmpParsingException(ErrorType.InvalidPdfaSchema, "Invalid PDF/A namespace definition");    }    if (cnamespace.equals(namespace) && !cprefix.equals(prefix)) {        throw new XmpParsingException(ErrorType.InvalidPdfaSchema, "Invalid PDF/A namespace definition");    }}
public static void pdfbox_f9976_0(XMPMetadata meta) throws XmpParsingException
{    List<XMPSchema> schems = meta.getAllSchemas();    TypeMapping tm = meta.getTypeMapping();    StructuredType stPdfaExt = PDFAExtensionSchema.class.getAnnotation(StructuredType.class);    for (XMPSchema xmpSchema : schems) {        if (xmpSchema.getNamespace().equals(stPdfaExt.namespace())) {                        if (!xmpSchema.getPrefix().equals(stPdfaExt.preferedPrefix())) {                throw new XmpParsingException(ErrorType.InvalidPrefix, "Found invalid prefix for PDF/A extension, found '" + xmpSchema.getPrefix() + "', should be '" + stPdfaExt.preferedPrefix() + "'");            }                        PDFAExtensionSchema pes = (PDFAExtensionSchema) xmpSchema;            ArrayProperty sp = pes.getSchemasProperty();            for (AbstractField af : sp.getAllProperties()) {                if (af instanceof PDFASchemaType) {                    populatePDFASchemaType(meta, (PDFASchemaType) af, tm);                }                        }        }    }}
private static void pdfbox_f9977_0(XMPMetadata meta, PDFASchemaType st, TypeMapping tm) throws XmpParsingException
{    String namespaceUri = st.getNamespaceURI().trim();    String prefix = st.getPrefixValue();    ArrayProperty properties = st.getProperty();    ArrayProperty valueTypes = st.getValueType();    XMPSchemaFactory xsf = tm.getSchemaFactory(namespaceUri);        if (xsf == null) {                tm.addNewNameSpace(namespaceUri, prefix);        xsf = tm.getSchemaFactory(namespaceUri);    }        if (valueTypes != null) {        for (AbstractField af2 : valueTypes.getAllProperties()) {            if (af2 instanceof PDFATypeType) {                populatePDFAType(meta, (PDFATypeType) af2, tm);            }        }    }        if (properties == null) {        throw new XmpParsingException(ErrorType.RequiredProperty, "Missing pdfaSchema:property in type definition");    }    for (AbstractField af2 : properties.getAllProperties()) {        if (af2 instanceof PDFAPropertyType) {            populatePDFAPropertyType((PDFAPropertyType) af2, tm, xsf);        }        }}
private static void pdfbox_f9978_0(PDFAPropertyType property, TypeMapping tm, XMPSchemaFactory xsf) throws XmpParsingException
{    String pname = property.getName();    String ptype = property.getValueType();    String pdescription = property.getDescription();    String pCategory = property.getCategory();        if (pname == null || ptype == null || pdescription == null || pCategory == null) {                throw new XmpParsingException(ErrorType.RequiredProperty, "Missing field in property definition");    }        PropertyType pt = transformValueType(tm, ptype);    if (pt == null) {        throw new XmpParsingException(ErrorType.NoValueType, "Unknown property value type : " + ptype);    }    if (pt.type() == null) {        throw new XmpParsingException(ErrorType.NoValueType, "Type not defined : " + ptype);    } else if (pt.type().isSimple() || pt.type().isStructured() || pt.type() == Types.DefinedType) {        xsf.getPropertyDefinition().addNewProperty(pname, pt);    } else {        throw new XmpParsingException(ErrorType.NoValueType, "Type not defined : " + ptype);    }}
private static void pdfbox_f9979_0(XMPMetadata meta, PDFATypeType type, TypeMapping tm) throws XmpParsingException
{    String ttype = type.getType();    String tns = type.getNamespaceURI();    String tprefix = type.getPrefixValue();    String tdescription = type.getDescription();    ArrayProperty fields = type.getFields();    if (ttype == null || tns == null || tprefix == null || tdescription == null) {                throw new XmpParsingException(ErrorType.RequiredProperty, "Missing field in type definition");    }            DefinedStructuredType structuredType = new DefinedStructuredType(meta, tns, tprefix, null);        if (fields != null) {        List<AbstractField> definedFields = fields.getAllProperties();        for (AbstractField af3 : definedFields) {            if (af3 instanceof PDFAFieldType) {                populatePDFAFieldType((PDFAFieldType) af3, structuredType);            }                }    }        PropertiesDescription pm = new PropertiesDescription();    for (Map.Entry<String, PropertyType> entry : structuredType.getDefinedProperties().entrySet()) {        pm.addNewProperty(entry.getKey(), entry.getValue());    }    tm.addToDefinedStructuredTypes(ttype, tns, pm);}
private static void pdfbox_f9980_0(PDFAFieldType field, DefinedStructuredType structuredType) throws XmpParsingException
{    String fName = field.getName();    String fDescription = field.getDescription();    String fValueType = field.getValueType();    if (fName == null || fDescription == null || fValueType == null) {        throw new XmpParsingException(ErrorType.RequiredProperty, "Missing field in field definition");    }    try {        Types fValue = Types.valueOf(fValueType);        structuredType.addProperty(fName, TypeMapping.createPropertyType(fValue, Cardinality.Simple));    } catch (IllegalArgumentException e) {        throw new XmpParsingException(ErrorType.NoValueType, "Type not defined : " + fValueType, e);        }}
private static PropertyType pdfbox_f9981_0(TypeMapping tm, String valueType) throws XmpParsingException
{    if ("Lang Alt".equals(valueType)) {        return TypeMapping.createPropertyType(Types.LangAlt, Cardinality.Simple);    }        if (valueType.startsWith(CLOSED_CHOICE)) {        valueType = valueType.substring(CLOSED_CHOICE.length());    } else if (valueType.startsWith(OPEN_CHOICE)) {        valueType = valueType.substring(OPEN_CHOICE.length());    }    int pos = valueType.indexOf(' ');    Cardinality card = Cardinality.Simple;    if (pos > 0) {        String scard = valueType.substring(0, pos);        if ("seq".equals(scard)) {            card = Cardinality.Seq;        } else if ("bag".equals(scard)) {            card = Cardinality.Bag;        } else if ("alt".equals(scard)) {            card = Cardinality.Alt;        } else {            return null;        }    }    String vt = valueType.substring(pos + 1);    Types type = null;    try {        type = pos < 0 ? Types.valueOf(valueType) : Types.valueOf(vt);    } catch (IllegalArgumentException e) {        if (tm.isDefinedType(vt)) {            type = Types.DefinedType;        }    }    return TypeMapping.createPropertyType(type, card);}
public ErrorType pdfbox_f9982_0()
{    return errorType;}
public void pdfbox_f9983_0(XMPMetadata metadata, OutputStream os, boolean withXpacket) throws TransformerException
{    Document doc = documentBuilder.newDocument();        Element rdf = createRdfElement(doc, metadata, withXpacket);    for (XMPSchema schema : metadata.getAllSchemas()) {        rdf.appendChild(serializeSchema(doc, schema));    }        save(doc, os, "UTF-8");}
protected Element pdfbox_f9984_0(Document doc, XMPSchema schema)
{        Element selem = doc.createElementNS(XmpConstants.RDF_NAMESPACE, "rdf:Description");    selem.setAttributeNS(XmpConstants.RDF_NAMESPACE, "rdf:about", schema.getAboutValue());    selem.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, "xmlns:" + schema.getPrefix(), schema.getNamespace());        fillElementWithAttributes(selem, schema);        List<AbstractField> fields = schema.getAllProperties();    serializeFields(doc, selem, fields, schema.getPrefix(), null, true);        return selem;}
public void pdfbox_f9985_0(Document doc, Element parent, List<AbstractField> fields, String resourceNS, String prefix, boolean wrapWithProperty)
{    for (AbstractField field : fields) {        if (field instanceof AbstractSimpleProperty) {            AbstractSimpleProperty simple = (AbstractSimpleProperty) field;            String localPrefix;            if (prefix != null && !prefix.isEmpty()) {                localPrefix = prefix;            } else {                localPrefix = simple.getPrefix();            }            Element esimple = doc.createElement(localPrefix + ":" + simple.getPropertyName());            esimple.setTextContent(simple.getStringValue());            List<Attribute> attributes = simple.getAllAttributes();            for (Attribute attribute : attributes) {                esimple.setAttributeNS(attribute.getNamespace(), attribute.getName(), attribute.getValue());            }            parent.appendChild(esimple);        } else if (field instanceof ArrayProperty) {            ArrayProperty array = (ArrayProperty) field;                        Element asimple = doc.createElement(array.getPrefix() + ":" + array.getPropertyName());            parent.appendChild(asimple);                        fillElementWithAttributes(asimple, array);                        Element econtainer = doc.createElement(XmpConstants.DEFAULT_RDF_PREFIX + ":" + array.getArrayType());            asimple.appendChild(econtainer);                        List<AbstractField> innerFields = array.getAllProperties();            serializeFields(doc, econtainer, innerFields, resourceNS, XmpConstants.DEFAULT_RDF_PREFIX, false);        } else if (field instanceof AbstractStructuredType) {            AbstractStructuredType structured = (AbstractStructuredType) field;            List<AbstractField> innerFields = structured.getAllProperties();                        Element listParent = parent;            if (wrapWithProperty) {                Element nstructured = doc.createElement(resourceNS + ":" + structured.getPropertyName());                parent.appendChild(nstructured);                listParent = nstructured;            }                        Element estructured = doc.createElement(XmpConstants.DEFAULT_RDF_PREFIX + ":" + XmpConstants.LIST_NAME);            listParent.appendChild(estructured);            if (parseTypeResourceForLi) {                estructured.setAttribute("rdf:parseType", "Resource");                                serializeFields(doc, estructured, innerFields, resourceNS, null, true);            } else {                                Element econtainer = doc.createElement(XmpConstants.DEFAULT_RDF_PREFIX + ":" + "Description");                estructured.appendChild(econtainer);                                serializeFields(doc, econtainer, innerFields, resourceNS, null, true);            }        } else {                        System.err.println(">> TODO >> " + field.getClass());        }    }}
private void pdfbox_f9986_0(Element target, AbstractComplexProperty property)
{        List<Attribute> toSerialize = normalizeAttributes(property);    for (Attribute attribute : toSerialize) {        if (XmpConstants.RDF_NAMESPACE.equals(attribute.getNamespace())) {            target.setAttribute(XmpConstants.DEFAULT_RDF_PREFIX + ":" + attribute.getName(), attribute.getValue());        } else {            target.setAttribute(attribute.getName(), attribute.getValue());        }    }    for (Map.Entry<String, String> ns : property.getAllNamespacesWithPrefix().entrySet()) {        target.setAttribute(XMLConstants.XMLNS_ATTRIBUTE + ":" + ns.getValue(), ns.getKey());    }}
private List<Attribute> pdfbox_f9987_0(AbstractComplexProperty property)
{    List<Attribute> attributes = property.getAllAttributes();    List<Attribute> toSerialize = new ArrayList<>();    List<AbstractField> fields = property.getAllProperties();    for (Attribute attribute : attributes) {        boolean matchesField = false;        for (AbstractField field : fields) {            if (attribute.getName().compareTo(field.getPropertyName()) == 0) {                matchesField = true;                break;            }        }        if (!matchesField) {            toSerialize.add(attribute);        }    }    return toSerialize;}
protected Element pdfbox_f9988_0(Document doc, XMPMetadata metadata, boolean withXpacket)
{        if (withXpacket) {        ProcessingInstruction beginXPacket = doc.createProcessingInstruction("xpacket", "begin=\"" + metadata.getXpacketBegin() + "\" id=\"" + metadata.getXpacketId() + "\"");        doc.appendChild(beginXPacket);    }        Element xmpmeta = doc.createElementNS("adobe:ns:meta/", "x:xmpmeta");    xmpmeta.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, "xmlns:x", "adobe:ns:meta/");    doc.appendChild(xmpmeta);        if (withXpacket) {        ProcessingInstruction endXPacket = doc.createProcessingInstruction("xpacket", "end=\"" + metadata.getEndXPacket() + "\"");        doc.appendChild(endXPacket);    }        Element rdf = doc.createElementNS(XmpConstants.RDF_NAMESPACE, "rdf:RDF");        xmpmeta.appendChild(rdf);        return rdf;}
private void pdfbox_f9989_0(Node doc, OutputStream outStream, String encoding) throws TransformerException
{    Transformer transformer = TransformerFactory.newInstance().newTransformer();        transformer.setOutputProperty(OutputKeys.INDENT, "yes");        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");        transformer.setOutputProperty(OutputKeys.ENCODING, encoding);    transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");        Result result = new StreamResult(outStream);    DOMSource source = new DOMSource(doc);        transformer.transform(source, result);}
public static XMPMetadata pdfbox_f9990_0()
{    return new XMPMetadata();}
public static XMPMetadata pdfbox_f9991_0(String xpacketBegin, String xpacketId, String xpacketBytes, String xpacketEncoding)
{    return new XMPMetadata(xpacketBegin, xpacketId, xpacketBytes, xpacketEncoding);}
public TypeMapping pdfbox_f9992_0()
{    return this.typeMapping;}
public String pdfbox_f9993_0()
{    return xpacketBytes;}
public String pdfbox_f9994_0()
{    return xpacketEncoding;}
public String pdfbox_f9995_0()
{    return xpacketBegin;}
public String pdfbox_f9996_0()
{    return xpacketId;}
public List<XMPSchema> pdfbox_f9997_0()
{    List<XMPSchema> schem = new ArrayList<>();    for (XMPSchema schema : schemas) {        schem.add(schema);    }    return schem;}
public void pdfbox_f9998_0(String data)
{    xpacketEndData = data;}
public String pdfbox_f9999_0()
{    return xpacketEndData;}
public XMPSchema pdfbox_f10000_0(String nsURI)
{    Iterator<XMPSchema> it = schemas.iterator();    XMPSchema tmp;    while (it.hasNext()) {        tmp = it.next();        if (tmp.getNamespace().equals(nsURI)) {            return tmp;        }    }    return null;}
public XMPSchema pdfbox_f10001_0(Class<? extends XMPSchema> clz)
{    StructuredType st = clz.getAnnotation(StructuredType.class);    return getSchema(st.namespace());}
public XMPSchema pdfbox_f10002_0(String prefix, String nsURI)
{    Iterator<XMPSchema> it = getAllSchemas().iterator();    XMPSchema tmp;    while (it.hasNext()) {        tmp = it.next();        if (tmp.getNamespace().equals(nsURI) && tmp.getPrefix().equals(prefix)) {            return tmp;        }    }    return null;}
public XMPSchema pdfbox_f10003_0(String nsPrefix, String nsURI)
{    XMPSchema schem = new XMPSchema(this, nsURI, nsPrefix);    schem.setAboutAsSimple("");    addSchema(schem);    return schem;}
public PDFAExtensionSchema pdfbox_f10004_0()
{    PDFAExtensionSchema pdfAExt = new PDFAExtensionSchema(this);    pdfAExt.setAboutAsSimple("");    addSchema(pdfAExt);    return pdfAExt;}
public PDFAExtensionSchema pdfbox_f10005_0(Map<String, String> namespaces) throws XmpSchemaException
{    PDFAExtensionSchema pdfAExt = new PDFAExtensionSchema(this);    pdfAExt.setAboutAsSimple("");    addSchema(pdfAExt);    return pdfAExt;}
public PDFAExtensionSchema pdfbox_f10006_0()
{    return (PDFAExtensionSchema) getSchema(PDFAExtensionSchema.class);}
public PDFAIdentificationSchema pdfbox_f10007_0()
{    PDFAIdentificationSchema pdfAId = new PDFAIdentificationSchema(this);    pdfAId.setAboutAsSimple("");    addSchema(pdfAId);    return pdfAId;}
public PDFAIdentificationSchema pdfbox_f10008_0()
{    return (PDFAIdentificationSchema) getSchema(PDFAIdentificationSchema.class);}
public DublinCoreSchema pdfbox_f10009_0()
{    DublinCoreSchema dc = new DublinCoreSchema(this);    dc.setAboutAsSimple("");    addSchema(dc);    return dc;}
public DublinCoreSchema pdfbox_f10010_0()
{    return (DublinCoreSchema) getSchema(DublinCoreSchema.class);}
public XMPBasicJobTicketSchema pdfbox_f10011_0()
{    XMPBasicJobTicketSchema sc = new XMPBasicJobTicketSchema(this);    sc.setAboutAsSimple("");    addSchema(sc);    return sc;}
public XMPBasicJobTicketSchema pdfbox_f10012_0()
{    return (XMPBasicJobTicketSchema) getSchema(XMPBasicJobTicketSchema.class);}
public XMPRightsManagementSchema pdfbox_f10013_0()
{    XMPRightsManagementSchema rights = new XMPRightsManagementSchema(this);    rights.setAboutAsSimple("");    addSchema(rights);    return rights;}
public XMPRightsManagementSchema pdfbox_f10014_0()
{    return (XMPRightsManagementSchema) getSchema(XMPRightsManagementSchema.class);}
public XMPBasicSchema pdfbox_f10015_0()
{    XMPBasicSchema xmpB = new XMPBasicSchema(this);    xmpB.setAboutAsSimple("");    addSchema(xmpB);    return xmpB;}
public XMPBasicSchema pdfbox_f10016_0()
{    return (XMPBasicSchema) getSchema(XMPBasicSchema.class);}
public XMPMediaManagementSchema pdfbox_f10017_0()
{    XMPMediaManagementSchema xmpMM = new XMPMediaManagementSchema(this);    xmpMM.setAboutAsSimple("");    addSchema(xmpMM);    return xmpMM;}
public PhotoshopSchema pdfbox_f10018_0()
{    PhotoshopSchema photoshop = new PhotoshopSchema(this);    photoshop.setAboutAsSimple("");    addSchema(photoshop);    return photoshop;}
public PhotoshopSchema pdfbox_f10019_0()
{    return (PhotoshopSchema) getSchema(PhotoshopSchema.class);}
public XMPMediaManagementSchema pdfbox_f10020_0()
{    return (XMPMediaManagementSchema) getSchema(XMPMediaManagementSchema.class);}
public AdobePDFSchema pdfbox_f10021_0()
{    AdobePDFSchema pdf = new AdobePDFSchema(this);    pdf.setAboutAsSimple("");    addSchema(pdf);    return pdf;}
public AdobePDFSchema pdfbox_f10022_0()
{    return (AdobePDFSchema) getSchema(AdobePDFSchema.class);}
public void pdfbox_f10023_0(XMPSchema obj)
{    schemas.add(obj);}
public void pdfbox_f10024_0(XMPSchema schema)
{    schemas.remove(schema);}
public void pdfbox_f10025_0()
{    schemas.clear();}
public void pdfbox_f10026_0() throws Exception
{    final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");    Calendar jaxbCal;        Calendar convDate = DateConverter.toCalendar("2015-02-02");    assertEquals(2015, convDate.get(Calendar.YEAR));        assertEquals(DateConverter.toCalendar("2015-12-08T12:07:00-05:00"), DateConverter.toCalendar("2015-12-08T12:07-05:00"));    assertEquals(DateConverter.toCalendar("2011-11-20T10:09:00Z"), DateConverter.toCalendar("2011-11-20T10:09Z"));        jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192Z");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192Z");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192+00:00");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192Z");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192+02:00");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192+02:00");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192Z");    convDate = DateConverter.toCalendar("2015-02-02T08:37:19.192PST");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));    jaxbCal = javax.xml.bind.DatatypeConverter.parseDateTime("2015-02-02T16:37:19.192+01:00");    convDate = DateConverter.toCalendar("2015-02-02T16:37:19.192Europe/Berlin");    assertEquals(dateFormat.format(jaxbCal.getTime()), dateFormat.format(convDate.getTime()));}
public void pdfbox_f10027_0() throws Exception
{    final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");    Calendar cal = DateConverter.toCalendar("2015-02-02T16:37:19.192Z");    assertEquals(dateFormat.format(cal.getTime()), dateFormat.format(DateConverter.toCalendar(DateConverter.toISO8601(cal, true)).getTime()));}
public void pdfbox_f10028_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();}
public void pdfbox_f10029_0() throws Exception
{    DublinCoreSchema dc1 = metadata.createAndAddDublinCoreSchema();    String ownPrefix = "test";    DublinCoreSchema dc2 = new DublinCoreSchema(metadata, ownPrefix);    metadata.addSchema(dc2);    List<String> creators = new ArrayList<>();    creators.add("creator1");    creators.add("creator2");    String format = "application/pdf";    dc1.setFormat(format);    dc1.addCreator(creators.get(0));    dc1.addCreator(creators.get(1));    String coverage = "Coverage";    dc2.setCoverage(coverage);    dc2.addCreator(creators.get(0));    dc2.addCreator(creators.get(1));    StructuredType stDub = DublinCoreSchema.class.getAnnotation(StructuredType.class);            Assert.assertEquals(format, ((DublinCoreSchema) metadata.getSchema(stDub.preferedPrefix(), stDub.namespace())).getFormat());    Assert.assertEquals(coverage, ((DublinCoreSchema) metadata.getSchema(ownPrefix, stDub.namespace())).getCoverage());    List<XMPSchema> schems = metadata.getAllSchemas();    DublinCoreSchema dc;    for (XMPSchema xmpSchema : schems) {        dc = (DublinCoreSchema) xmpSchema;        Assert.assertTrue(dc.getCreators().containsAll(creators));    }}
public void pdfbox_f10030_0() throws Exception
{    bos = new ByteArrayOutputStream();    serializer = new XmpSerializer();}
public void pdfbox_f10031_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/structured_recursive.xml");    DomXmpParser xdb = new DomXmpParser();    xdb.parse(fis);}
public void pdfbox_f10032_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/empty_list.xml");    DomXmpParser xdb = new DomXmpParser();    xdb.parse(fis);}
public void pdfbox_f10033_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/emptyli.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    DublinCoreSchema dc = meta.getDublinCoreSchema();    dc.getCreatorsProperty();}
public void pdfbox_f10034_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/emptyli.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    DublinCoreSchema dc = meta.getDublinCoreSchema();    String s = dc.getTitle(null);    Assert.assertEquals("title value", s);}
public void pdfbox_f10035_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/AltBagSeqTest.xml");    DomXmpParser xdb = new DomXmpParser();    xdb.parse(fis);}
public void pdfbox_f10036_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/org/apache/xmpbox/parser/ThumbisartorStyle.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata metadata = xdb.parse(fis);        Assert.assertEquals("uuid:09C78666-2F91-3A9C-92AF-3691A6D594F7", metadata.getXMPMediaManagementSchema().getDocumentID());                Assert.assertEquals(DateConverter.toCalendar("2008-01-18T16:59:54+01:00"), metadata.getXMPBasicSchema().getCreateDate());    Assert.assertEquals(DateConverter.toCalendar("2008-01-18T16:59:54+01:00"), metadata.getXMPBasicSchema().getModifyDate());    Assert.assertEquals(DateConverter.toCalendar("2008-01-18T16:59:54+01:00"), metadata.getXMPBasicSchema().getMetadataDate());        List<ThumbnailType> thumbs = metadata.getXMPBasicSchema().getThumbnailsProperty();    Assert.assertNotNull(thumbs);    Assert.assertEquals(2, thumbs.size());    ThumbnailType thumb = thumbs.get(0);    Assert.assertEquals(Integer.valueOf(162), thumb.getHeight());    Assert.assertEquals(Integer.valueOf(216), thumb.getWidth());    Assert.assertEquals("JPEG", thumb.getFormat());    Assert.assertEquals("/9j/4AAQSkZJRgABAgEASABIAAD", thumb.getImage());    thumb = thumbs.get(1);    Assert.assertEquals(Integer.valueOf(162), thumb.getHeight());    Assert.assertEquals(Integer.valueOf(216), thumb.getWidth());    Assert.assertEquals("JPEG", thumb.getFormat());    Assert.assertEquals("/9j/4AAQSkZJRgABAgEASABIAAD", thumb.getImage());}
public void pdfbox_f10037_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/noxpacket.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.XpacketBadStart, e.getErrorType());    }}
public void pdfbox_f10038_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/noxpacketend.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.XpacketBadEnd, e.getErrorType());    }}
public void pdfbox_f10039_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/noroot.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
public void pdfbox_f10040_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/tworoot.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
public void pdfbox_f10041_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/invalidroot2.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
public void pdfbox_f10042_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/invalidroot.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.Format, e.getErrorType());    }}
public void pdfbox_f10043_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/undefinedschema.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.NoSchema, e.getErrorType());    }}
public void pdfbox_f10044_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/undefinedpropertyindefinedschema.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.NoType, e.getErrorType());    }}
public void pdfbox_f10045_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/invalidxmp/undefinedstructuredindefinedschema.xml");    DomXmpParser xdb = new DomXmpParser();    try {        xdb.parse(fis);        Assert.fail("Should fail during parse");    } catch (XmpParsingException e) {        Assert.assertEquals(ErrorType.NoValueType, e.getErrorType());    }}
public void pdfbox_f10046_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/emptyli.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    List<XMPSchema> schemas = meta.getAllSchemas();    for (XMPSchema xmpSchema : schemas) {        Assert.assertNotNull(xmpSchema.getAboutAttribute());    }}
public void pdfbox_f10047_0() throws Exception
{    InputStream fis = DomXmpParser.class.getResourceAsStream("/validxmp/attr_as_props.xml");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(fis);    AdobePDFSchema pdf = meta.getAdobePDFSchema();    Assert.assertEquals("GPL Ghostscript 8.64", pdf.getProducer());    DublinCoreSchema dc = meta.getDublinCoreSchema();    Assert.assertEquals("application/pdf", dc.getFormat());    XMPBasicSchema basic = meta.getXMPBasicSchema();    Assert.assertNotNull(basic.getCreateDate());}
public void pdfbox_f10048_0() throws Exception
{            InputStream is = DomXmpParser.class.getResourceAsStream("/validxmp/only_space_fields.xmp");    DomXmpParser xdb = new DomXmpParser();    XMPMetadata meta = xdb.parse(is);        Assert.assertEquals(" ", meta.getAdobePDFSchema().getProducer());        Assert.assertEquals("Canon ", meta.getXMPBasicSchema().getCreatorTool());}
public void pdfbox_f10049_0()
{    propMap = new PropertiesDescription();}
public void pdfbox_f10050_0() throws Exception
{    DublinCoreSchema dc = new DublinCoreSchema(XMPMetadata.createXMPMetadata());    dc.setCoverage("coverage");    dc.addContributor("contributor1");    dc.addContributor("contributor2");    dc.addDescription("x-default", "Description");}
public void pdfbox_f10051_0() throws Exception
{    XMPMetadata meta = XMPMetadata.createXMPMetadata();    DublinCoreSchema dc = meta.createAndAddDublinCoreSchema();    dc.setCoverage("coverage");    dc.addContributor("contributor1");    dc.addContributor("contributor2");    dc.addDescription("x-default", "Description");    AdobePDFSchema pdf = meta.createAndAddAdobePDFSchema();    pdf.setProducer("Producer");    pdf.setPDFVersion("1.4");}
public void pdfbox_f10052_0() throws Exception
{    builder = new DomXmpParser();    xmp = XMPMetadata.createXMPMetadata();    typeMapping = xmp.getTypeMapping();}
protected Class<? extends XMPSchema> pdfbox_f10053_0()
{    return getSchema().getClass();}
public void pdfbox_f10054_0() throws Exception
{    XMPSchema schema = getSchema();        Assert.assertNull(schema.getProperty(fieldName));        if (cardinality == Cardinality.Simple) {        String getter = calculateSimpleGetter(fieldName);        Method get = getSchemaClass().getMethod(getter);        Object result = get.invoke(schema);        Assert.assertNull(result);    } else {                String getter = calculateArrayGetter(fieldName);        Method get = getSchemaClass().getMethod(getter);        Object result = get.invoke(schema);        Assert.assertNull(result);    }}
public void pdfbox_f10055_0() throws Exception
{    internalTestSettingValue();}
public void pdfbox_f10056_0() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSettingValue();    }}
private void pdfbox_f10057_0() throws Exception
{    if (cardinality != Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();        Object value = getJavaValue(type);    AbstractSimpleProperty property = schema.instanciateSimple(fieldName, value);    schema.addProperty(property);    String qn = getPropertyQualifiedName(fieldName);    Assert.assertNotNull(schema.getProperty(fieldName));        List<Field> fields = getXmpFields(getSchemaClass());    for (Field field : fields) {                String fqn = getPropertyQualifiedName(field.get(null).toString());        if (!fqn.equals(qn)) {            Assert.assertNull(schema.getProperty(fqn));        }    }}
public void pdfbox_f10058_0() throws Exception
{    internalTestSettingValueInArray();}
public void pdfbox_f10059_0() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSettingValueInArray();    }}
private void pdfbox_f10060_0() throws Exception
{    if (cardinality == Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();        Object value = getJavaValue(type);    AbstractSimpleProperty property = schema.instanciateSimple(fieldName, value);    switch(cardinality) {        case Seq:            schema.addUnqualifiedSequenceValue(property.getPropertyName(), property);            break;        case Bag:            schema.addBagValue(property.getPropertyName(), property);            break;        default:            throw new Exception("Unexpected case in test : " + cardinality.name());    }    String qn = getPropertyQualifiedName(fieldName);    Assert.assertNotNull(schema.getProperty(fieldName));        List<Field> fields = getXmpFields(getSchemaClass());    for (Field field : fields) {                String fqn = getPropertyQualifiedName(field.get(null).toString());        if (!fqn.equals(qn)) {            Assert.assertNull(schema.getProperty(fqn));        }    }}
public void pdfbox_f10061_0() throws Exception
{    internalTestPropertySetterSimple();}
public void pdfbox_f10062_0() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestPropertySetterSimple();    }}
private void pdfbox_f10063_0() throws Exception
{    if (cardinality != Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();    String setter = calculateSimpleSetter(fieldName) + "Property";    Object value = getJavaValue(type);    AbstractSimpleProperty asp = typeMapping.instanciateSimpleProperty(schema.getNamespace(), schema.getPrefix(), fieldName, value, type);    Method set = getSchemaClass().getMethod(setter, type.getImplementingClass());    set.invoke(schema, asp);        AbstractSimpleProperty stored = (AbstractSimpleProperty) schema.getProperty(fieldName);    Assert.assertEquals(value, stored.getValue());        String getter = calculateSimpleGetter(fieldName) + "Property";    Method get = getSchemaClass().getMethod(getter);    Object result = get.invoke(schema);    Assert.assertTrue(type.getImplementingClass().isAssignableFrom(result.getClass()));    Assert.assertEquals(asp, result);}
public void pdfbox_f10064_0() throws Exception
{    internalTestPropertySetterInArray();}
public void pdfbox_f10065_0() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestPropertySetterInArray();    }}
private void pdfbox_f10066_0() throws Exception
{    if (cardinality == Cardinality.Simple) {        return;    }    XMPSchema schema = getSchema();        String setter = "add" + calculateFieldNameForMethod(fieldName);            Object value1 = getJavaValue(type);    Method set = getSchemaClass().getMethod(setter, getJavaType(type));    set.invoke(schema, value1);        String getter = calculateArrayGetter(fieldName) + "Property";    Method getcp = getSchemaClass().getMethod(getter);    Object ocp = getcp.invoke(schema);    Assert.assertTrue(ocp instanceof ArrayProperty);    ArrayProperty cp = (ArrayProperty) ocp;        Assert.assertEquals(1, cp.getContainer().getAllProperties().size());        Object value2 = getJavaValue(type);    set.invoke(schema, value2);    Assert.assertEquals(2, cp.getContainer().getAllProperties().size());        String remover = "remove" + calculateFieldNameForMethod(fieldName);    Method remove = getSchemaClass().getMethod(remover, getJavaType(type));    remove.invoke(schema, value1);    Assert.assertEquals(1, cp.getContainer().getAllProperties().size());}
protected String pdfbox_f10067_0(String name)
{    StringBuilder sb = new StringBuilder();    sb.append(getSchema().getPrefix()).append(":").append(name);    return sb.toString();}
public static Object[] pdfbox_f10068_0(String name, Types type, Object value)
{    return wrapProperty(name, type, Cardinality.Simple, value);}
public static Object[] pdfbox_f10069_0(String name, Types type, Cardinality card, Object value)
{        return new Object[] { name, TypeMapping.createPropertyType(type, card), value };}
public void pdfbox_f10070_0() throws Exception
{    if (type.type() == Types.Text && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.Boolean && type.card() == Cardinality.Simple) {        testGetSetBooleanValue();    } else if (type.type() == Types.Integer && type.card() == Cardinality.Simple) {        testGetSetIntegerValue();    } else if (type.type() == Types.Date && type.card() == Cardinality.Simple) {        testGetSetDateValue();    } else if (type.type() == Types.URI && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.URL && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.AgentName && type.card() == Cardinality.Simple) {        testGetSetTextValue();    } else if (type.type() == Types.LangAlt && type.card() == Cardinality.Simple) {        } else if (type.type() == Types.ResourceRef && type.card() == Cardinality.Simple) {        } else if (type.card() != Cardinality.Simple) {        } else {        throw new Exception("Unknown type : " + type);    }}
public void pdfbox_f10071_0() throws Exception
{    if (type.type() == Types.Text && type.card() == Cardinality.Simple) {        testGetSetTextProperty();    } else if (type.type() == Types.URI && type.card() == Cardinality.Simple) {        testGetSetURIProperty();    } else if (type.type() == Types.URL && type.card() == Cardinality.Simple) {        testGetSetURLProperty();    } else if (type.type() == Types.AgentName && type.card() == Cardinality.Simple) {        testGetSetAgentNameProperty();    } else if (type.type() == Types.Boolean && type.card() == Cardinality.Simple) {        testGetSetBooleanProperty();    } else if (type.type() == Types.Integer && type.card() == Cardinality.Simple) {        testGetSetIntegerProperty();    } else if (type.type() == Types.Date && type.card() == Cardinality.Simple) {        testGetSetDateProperty();    } else if (type.type() == Types.Text && type.card() == Cardinality.Seq) {        testGetSetTextListValue("seq");    } else if (type.type() == Types.Version && type.card() == Cardinality.Seq) {        testGetSetTextListValue("seq");    } else if (type.type() == Types.Text && type.card() == Cardinality.Bag) {        testGetSetTextListValue("bag");    } else if (type.type() == Types.ProperName && type.card() == Cardinality.Bag) {        testGetSetTextListValue("bag");    } else if (type.type() == Types.XPath && type.card() == Cardinality.Bag) {        testGetSetTextListValue("bag");    } else if (type.type() == Types.Date && type.card() == Cardinality.Seq) {        testGetSetDateListValue("seq");    } else if (type.type() == Types.LangAlt && type.card() == Cardinality.Simple) {        testGetSetLangAltValue();    } else if (type.type() == Types.Thumbnail && type.card() == Cardinality.Alt) {        testGetSetThumbnail();    } else {        throw new Exception("Unknown type : " + type);    }    Field[] fields = schemaClass.getFields();    for (Field field : fields) {        if (field.isAnnotationPresent(PropertyType.class)) {            if (!field.get(schema).equals(property)) {                PropertyType pt = field.getAnnotation(PropertyType.class);                if (pt.type() == Types.LangAlt) {                                } else if (pt.type() == Types.Thumbnail && pt.card() == Cardinality.Alt) {                                } else if (pt.type() == Types.ResourceRef) {                                } else if (pt.type() == Types.Version && pt.card() == Cardinality.Seq) {                                } else {                                        PropertyType spt = retrievePropertyType(field.get(schema).toString());                    String getNameProperty = "get" + prepareName(field.get(schema).toString(), spt) + "Property";                    Method getMethod = schemaClass.getMethod(getNameProperty);                    Assert.assertNull(getNameProperty + " should return null when testing " + property, getMethod.invoke(schema));                                        String getNameValue = "get" + prepareName(field.get(schema).toString(), spt);                    getMethod = schemaClass.getMethod(getNameValue);                    Assert.assertNotNull(getNameValue + " method should exist", getMethod);                    Assert.assertNull(getNameValue + " should return null when testing " + property, getMethod.invoke(schema));                }            }        }    }}
protected PropertyType pdfbox_f10072_0(String prop) throws IllegalArgumentException, IllegalAccessException
{    Field[] fields = schemaClass.getFields();    for (Field field : fields) {        if (field.isAnnotationPresent(PropertyType.class)) {            PropertyType pt = field.getAnnotation(PropertyType.class);            if (field.get(schema).equals(prop)) {                return pt;            }        }    }    return type;}
protected String pdfbox_f10073_0(String name)
{    StringBuilder sb = new StringBuilder(name.length());    sb.append(name.substring(0, 1).toUpperCase());    sb.append(name.substring(1));    return sb.toString();}
protected String pdfbox_f10074_0(String prop, PropertyType type)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(fu.length() + 1);    sb.append(fu);    if (fu.endsWith("s")) {        } else if (fu.endsWith("y")) {        } else if (type.card() != Cardinality.Simple) {        sb.append("s");    }    return sb.toString();}
protected String pdfbox_f10075_0(String prop)
{    StringBuilder sb = new StringBuilder(3 + prop.length());    sb.append("set").append(prepareName(prop, type)).append("Property");    return sb.toString();}
protected String pdfbox_f10076_0(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(3 + prop.length());    sb.append("add").append(fu);    return sb.toString();}
protected String pdfbox_f10077_0(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(3 + prop.length());    sb.append("get").append(fu).append("Property");    return sb.toString();}
protected String pdfbox_f10078_0(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(8 + prop.length());    sb.append("set").append(fu);    return sb.toString();}
protected String pdfbox_f10079_0(String prop)
{    StringBuilder sb = new StringBuilder(8 + prop.length());    sb.append("get").append(prepareName(prop, type));    return sb.toString();}
protected String pdfbox_f10080_0(String prop)
{    String fu = firstUpper(prop);    StringBuilder sb = new StringBuilder(10 + prop.length());    sb.append("add").append(fu);    return sb.toString();}
protected void pdfbox_f10081_0() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    BooleanType bt = new BooleanType(metadata, null, schema.getPrefix(), property, value);    Method setMethod = schemaClass.getMethod(setName, BooleanType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, bt);    Boolean found = ((BooleanType) getMethod.invoke(schema)).getValue();    Assert.assertEquals(value, found);}
protected void pdfbox_f10082_0() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    DateType dt = new DateType(metadata, null, schema.getPrefix(), property, value);    Method setMethod = schemaClass.getMethod(setName, DateType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, dt);    Calendar found = ((DateType) getMethod.invoke(schema)).getValue();    Assert.assertEquals(value, found);}
protected void pdfbox_f10083_0() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    IntegerType it = new IntegerType(metadata, null, schema.getPrefix(), property, value);    Method setMethod = schemaClass.getMethod(setName, IntegerType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, it);    Integer found = ((IntegerType) getMethod.invoke(schema)).getValue();    Assert.assertEquals(value, found);}
protected void pdfbox_f10084_0() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    TextType tt = metadata.getTypeMapping().createText(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, TextType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((TextType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
protected void pdfbox_f10085_0() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    URIType tt = metadata.getTypeMapping().createURI(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, URIType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((TextType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
protected void pdfbox_f10086_0() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    URLType tt = metadata.getTypeMapping().createURL(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, URLType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((TextType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
protected void pdfbox_f10087_0() throws Exception
{    String setName = setMethod(property);    String getName = getMethod(property);    AgentNameType tt = metadata.getTypeMapping().createAgentName(null, schema.getPrefix(), property, (String) value);    Method setMethod = schemaClass.getMethod(setName, AgentNameType.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, tt);    String found = ((AgentNameType) getMethod.invoke(schema)).getStringValue();    Assert.assertEquals(value, found);}
protected void pdfbox_f10088_0(String tp) throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    String[] svalue = (String[]) value;    Arrays.sort(svalue);        Method setMethod = schemaClass.getMethod(setName, String.class);    for (String string : svalue) {        setMethod.invoke(schema, string);    }        Method getMethod = schemaClass.getMethod(getName);    List<String> fields = (List<String>) getMethod.invoke(schema);    for (String field : fields) {        Assert.assertTrue(field + " should be found in list", Arrays.binarySearch(svalue, field) >= 0);    }}
protected void pdfbox_f10089_0(String tp) throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    Calendar[] svalue = (Calendar[]) value;    Arrays.sort(svalue);        Method setMethod = schemaClass.getMethod(setName, Calendar.class);    for (Calendar inst : svalue) {        setMethod.invoke(schema, inst);    }        Method getMethod = schemaClass.getMethod(getName);    List<Calendar> fields = (List<Calendar>) getMethod.invoke(schema);    for (Calendar field : fields) {        Assert.assertTrue(field + " should be found in list", Arrays.binarySearch(svalue, field) >= 0);    }}
protected void pdfbox_f10090_0() throws Exception
{    String addName = addMethod(property);    String getName = getMethod(property);    Method setMethod = schemaClass.getMethod(addName, Integer.class, Integer.class, String.class, String.class);    Method getMethod = schemaClass.getMethod(getName);    Integer height = 162;    Integer width = 400;    String format = "JPEG";    String img = "/9j/4AAQSkZJRgABAgEASABIAAD";    setMethod.invoke(schema, height, width, format, img);    List<ThumbnailType> found = ((List<ThumbnailType>) getMethod.invoke(schema));    Assert.assertTrue(found.size() == 1);    ThumbnailType t1 = found.get(0);    Assert.assertEquals(height, t1.getHeight());    Assert.assertEquals(width, t1.getWidth());    Assert.assertEquals(format, t1.getFormat());    Assert.assertEquals(img, t1.getImage());}
protected void pdfbox_f10091_0() throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    Map<String, String> svalue = (Map<String, String>) value;        Method setMethod = schemaClass.getMethod(setName, String.class, String.class);    for (Map.Entry<String, String> inst : svalue.entrySet()) {        setMethod.invoke(schema, inst.getKey(), inst.getValue());    }        String getLanguagesName = "get" + firstUpper(property) + "Languages";    Method getLanguages = schemaClass.getMethod(getLanguagesName);    List<String> lgs = (List<String>) getLanguages.invoke(schema);    for (String string : lgs) {        Method getMethod = schemaClass.getMethod(getName, String.class);        String res = (String) getMethod.invoke(schema, string);        Assert.assertEquals(res, svalue.get(string));    }}
protected void pdfbox_f10092_0() throws Exception
{    String setName = addToValueMethod(property);    String getName = getValueMethod(property);    String svalue = (String) value;        Method setMethod = schemaClass.getMethod(setName, String.class, String.class);    setMethod.invoke(schema, property, svalue);        String getLanguagesName = "get" + firstUpper(property) + "Languages";    Method getLanguages = schemaClass.getMethod(getLanguagesName);    List<String> lgs = (List<String>) getLanguages.invoke(schema);    for (String string : lgs) {        Method getMethod = schemaClass.getMethod(getName, String.class);        String res = (String) getMethod.invoke(schema, string);        Assert.assertEquals(res, svalue);    }}
protected void pdfbox_f10093_0() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, String.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    String found = (String) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
protected void pdfbox_f10094_0() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, Boolean.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    Boolean found = (Boolean) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
protected void pdfbox_f10095_0() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, Calendar.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    Calendar found = (Calendar) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
protected void pdfbox_f10096_0() throws Exception
{    String setName = setValueMethod(property);    String getName = getValueMethod(property);    Method setMethod = schemaClass.getMethod(setName, Integer.class);    Method getMethod = schemaClass.getMethod(getName);    setMethod.invoke(schema, value);    Integer found = (Integer) getMethod.invoke(schema);    Assert.assertEquals(value, found);}
public void pdfbox_f10097_0() throws Exception
{    builder = new DomXmpParser();    metadata = XMPMetadata.createXMPMetadata();}
public void pdfbox_f10098_0() throws Exception
{    AdobePDFSchema schem = metadata.createAndAddAdobePDFSchema();    String keywords = "keywords ihih";    String pdfVersion = "1.4";    String producer = "producer";    schem.setKeywords(keywords);    schem.setPDFVersion(pdfVersion);        Assert.assertNull(schem.getProducer());    schem.setProducer(producer);    Assert.assertEquals("Keywords", schem.getKeywordsProperty().getPropertyName());    Assert.assertEquals(keywords, schem.getKeywords());    Assert.assertEquals("PDFVersion", schem.getPDFVersionProperty().getPropertyName());    Assert.assertEquals(pdfVersion, schem.getPDFVersion());    Assert.assertEquals("Producer", schem.getProducerProperty().getPropertyName());    Assert.assertEquals(producer, schem.getProducer());        Assert.assertEquals(schem, metadata.getAdobePDFSchema());}
public void pdfbox_f10099_0() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    String conformance = "kiohiohiohiohio";    pdfaid.setConformance(conformance);}
public void pdfbox_f10100_0() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    pdfaid.setPartValueWithString("1");    pdfaid.setPartValueWithString("ojoj");}
public void pdfbox_f10101_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddAdobePDFSchema();    schemaClass = AdobePDFSchema.class;}
public static Collection<Object[]> pdfbox_f10102_0() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("Keywords", Types.Text, "kw1 kw2 kw3"));    data.add(wrapProperty("PDFVersion", Types.Text, "1.4"));    data.add(wrapProperty("Producer", Types.Text, "testcase"));    return data;}
public void pdfbox_f10103_0() throws Exception
{    AdobePDFSchema schem = metadata.createAndAddAdobePDFSchema();    String keywords = "keywords ihih";    String pdfVersion = "1.4";    String producer = "producer";    schem.setKeywords(keywords);    schem.setPDFVersion(pdfVersion);        Assert.assertNull(schem.getProducer());    schem.setProducer(producer);    Assert.assertEquals("pdf", schem.getKeywordsProperty().getPrefix());    Assert.assertEquals("Keywords", schem.getKeywordsProperty().getPropertyName());    Assert.assertEquals(keywords, schem.getKeywords());    Assert.assertEquals("pdf", schem.getPDFVersionProperty().getPrefix());    Assert.assertEquals("PDFVersion", schem.getPDFVersionProperty().getPropertyName());    Assert.assertEquals(pdfVersion, schem.getPDFVersion());    Assert.assertEquals("pdf", schem.getProducerProperty().getPrefix());    Assert.assertEquals("Producer", schem.getProducerProperty().getPropertyName());    Assert.assertEquals(producer, schem.getProducer());}
public void pdfbox_f10104_0() throws BadFieldValueException
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    String conformance = "kiohiohiohiohio";    pdfaid.setConformance(conformance);}
public static void pdfbox_f10105_0() throws Exception
{    builder = new DomXmpParser();}
public void pdfbox_f10106_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    serializer = new XmpSerializer();}
public void pdfbox_f10107_0() throws Exception
{    XMPBasicJobTicketSchema basic = metadata.createAndAddBasicJobTicketSchema();    basic.addJob("zeid1", "zename1", "zeurl1", "aaa");    basic.addJob("zeid2", "zename2", "zeurl2");        ByteArrayOutputStream bos = new ByteArrayOutputStream();    serializer.serialize(metadata, bos, true);    XMPMetadata rxmp = builder.parse(bos.toByteArray());    XMPBasicJobTicketSchema jt = rxmp.getBasicJobTicketSchema();    Assert.assertNotNull(jt);    Assert.assertEquals(2, jt.getJobs().size());}
public void pdfbox_f10108_0() throws Exception
{    XMPBasicJobTicketSchema basic = metadata.createAndAddBasicJobTicketSchema();    basic.addJob("zeid2", "zename2", "zeurl2");        ByteArrayOutputStream bos = new ByteArrayOutputStream();    serializer.serialize(metadata, bos, true);    XMPMetadata rxmp = builder.parse(bos.toByteArray());    XMPBasicJobTicketSchema jt = rxmp.getBasicJobTicketSchema();    Assert.assertNotNull(jt);    Assert.assertEquals(1, jt.getJobs().size());    StructuredType stjob = JobType.class.getAnnotation(StructuredType.class);    JobType job = jt.getJobs().get(0);    Assert.assertEquals("zeid2", job.getId());    Assert.assertEquals("zename2", job.getName());    Assert.assertEquals("zeurl2", job.getUrl());}
public void pdfbox_f10109_0() throws Exception
{    XMPBasicJobTicketSchema basic = metadata.createAndAddBasicJobTicketSchema();    basic.addJob("zeid2", "zename2", "zeurl2", "aaa");            ByteArrayOutputStream bos = new ByteArrayOutputStream();    serializer.serialize(metadata, bos, true);    XMPMetadata rxmp = builder.parse(bos.toByteArray());    XMPBasicJobTicketSchema jt = rxmp.getBasicJobTicketSchema();    Assert.assertNotNull(jt);    Assert.assertEquals(1, jt.getJobs().size());    JobType job = jt.getJobs().get(0);                Assert.assertEquals("zeid2", job.getId());    Assert.assertEquals("zename2", job.getName());    Assert.assertEquals("zeurl2", job.getUrl());}
public DublinCoreSchema pdfbox_f10110_0()
{    return xmp.createAndAddDublinCoreSchema();}
public void pdfbox_f10111_0() throws Exception
{    super.before();}
public static Collection<Object[]> pdfbox_f10112_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { "contributor", Types.ProperName, Cardinality.Bag });    result.add(new Object[] { "coverage", Types.Text, Cardinality.Simple });    result.add(new Object[] { "creator", Types.ProperName, Cardinality.Seq });    result.add(new Object[] { "date", Types.Date, Cardinality.Seq });    result.add(new Object[] { "format", Types.MIMEType, Cardinality.Simple });    result.add(new Object[] { "identifier", Types.Text, Cardinality.Simple });    result.add(new Object[] { "language", Types.Locale, Cardinality.Bag });    result.add(new Object[] { "publisher", Types.ProperName, Cardinality.Bag });    result.add(new Object[] { "relation", Types.Text, Cardinality.Bag });    result.add(new Object[] { "source", Types.Text, Cardinality.Simple });    result.add(new Object[] { "subject", Types.Text, Cardinality.Bag });    result.add(new Object[] { "type", Types.Text, Cardinality.Bag });    return result;}
public void pdfbox_f10113_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();}
public void pdfbox_f10114_0() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    Integer versionId = 1;    String amdId = "2005";    String conformance = "B";    pdfaid.setPartValueWithInt(versionId);    pdfaid.setAmd(amdId);    pdfaid.setConformance(conformance);    Assert.assertEquals(versionId, pdfaid.getPart());    Assert.assertEquals(amdId, pdfaid.getAmendment());    Assert.assertEquals(conformance, pdfaid.getConformance());    Assert.assertEquals("" + versionId, pdfaid.getPartProperty().getStringValue());    Assert.assertEquals(amdId, pdfaid.getAmdProperty().getStringValue());    Assert.assertEquals(conformance, pdfaid.getConformanceProperty().getStringValue());        Assert.assertEquals(pdfaid, metadata.getPDFIdentificationSchema());}
public void pdfbox_f10115_0() throws BadFieldValueException
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    String conformance = "kiohiohiohiohio";    pdfaid.setConformance(conformance);}
public void pdfbox_f10116_0() throws Exception
{    PDFAIdentificationSchema pdfaid = metadata.createAndAddPFAIdentificationSchema();    pdfaid.setPartValueWithString("1");    pdfaid.setPartValueWithString("ojoj");}
public void pdfbox_f10117_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddPFAIdentificationSchema();    schemaClass = PDFAIdentificationSchema.class;}
public static Collection<Object[]> pdfbox_f10118_0() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("part", Types.Integer, 1));    data.add(wrapProperty("amd", Types.Text, "2005"));    data.add(wrapProperty("conformance", Types.Text, "B"));    return data;}
public PhotoshopSchema pdfbox_f10119_0()
{    return xmp.createAndAddPhotoshopSchema();}
public void pdfbox_f10120_0() throws Exception
{    super.before();}
public static Collection<Object[]> pdfbox_f10121_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { "AncestorID", Types.URI, Cardinality.Simple });    result.add(new Object[] { "AuthorsPosition", Types.Text, Cardinality.Simple });    result.add(new Object[] { "CaptionWriter", Types.ProperName, Cardinality.Simple });    result.add(new Object[] { "Category", Types.Text, Cardinality.Simple });    result.add(new Object[] { "City", Types.Text, Cardinality.Simple });    result.add(new Object[] { "ColorMode", Types.Integer, Cardinality.Simple });    result.add(new Object[] { "Country", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Credit", Types.Text, Cardinality.Simple });    result.add(new Object[] { "DateCreated", Types.Date, Cardinality.Simple });    result.add(new Object[] { "Headline", Types.Text, Cardinality.Simple });    result.add(new Object[] { "History", Types.Text, Cardinality.Simple });    result.add(new Object[] { "ICCProfile", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Instructions", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Source", Types.Text, Cardinality.Simple });    result.add(new Object[] { "State", Types.Text, Cardinality.Simple });    result.add(new Object[] { "SupplementalCategories", Types.Text, Cardinality.Simple });    result.add(new Object[] { "TransmissionReference", Types.Text, Cardinality.Simple });    result.add(new Object[] { "Urgency", Types.Integer, Cardinality.Simple });    return result;}
public void pdfbox_f10122_0() throws Exception
{    InputStream is = this.getClass().getResourceAsStream("/validxmp/exif.xmp");    DomXmpParser builder = new DomXmpParser();    builder.setStrictParsing(false);    XMPMetadata rxmp = builder.parse(is);    ExifSchema schema = (ExifSchema) rxmp.getSchema(ExifSchema.class);    TextType ss = (TextType) schema.getProperty(ExifSchema.SPECTRAL_SENSITIVITY);    Assert.assertNotNull(ss);    Assert.assertEquals("spectral sens value", ss.getValue());}
public void pdfbox_f10123_0() throws Exception
{    XMPMetadata metadata = XMPMetadata.createXMPMetadata();    TypeMapping tmapping = metadata.getTypeMapping();    ExifSchema exif = new ExifSchema(metadata);    metadata.addSchema(exif);    OECFType oecf = new OECFType(metadata);    oecf.addProperty(tmapping.createInteger(oecf.getNamespace(), oecf.getPrefix(), OECFType.COLUMNS, 14));    oecf.setPropertyName(ExifSchema.OECF);    exif.addProperty(oecf);    XmpSerializer serializer = new XmpSerializer();    serializer.serialize(metadata, new ByteArrayOutputStream(), false);}
public void pdfbox_f10124_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddXMPBasicSchema();    schemaClass = XMPBasicSchema.class;}
public static Collection<Object[]> pdfbox_f10125_0() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("Advisory", Types.XPath, Cardinality.Bag, new String[] { "xpath1", "xpath2" }));    data.add(wrapProperty("BaseURL", Types.URL, "URL"));    data.add(wrapProperty("CreateDate", Types.Date, Calendar.getInstance()));    data.add(wrapProperty("CreatorTool", Types.AgentName, "CreatorTool"));    data.add(wrapProperty("Identifier", Types.Text, Cardinality.Bag, new String[] { "id1", "id2" }));    data.add(wrapProperty("Label", Types.Text, "label"));    data.add(wrapProperty("MetadataDate", Types.Date, Calendar.getInstance()));    data.add(wrapProperty("ModifyDate", Types.Date, Calendar.getInstance()));    data.add(wrapProperty("Nickname", Types.Text, "nick name"));    data.add(wrapProperty("Rating", Types.Integer, 7));    data.add(wrapProperty("Thumbnails", Types.Thumbnail, Cardinality.Alt, null));    return data;}
public void pdfbox_f10126_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddXMPMediaManagementSchema();    schemaClass = XMPMediaManagementSchema.class;}
public static Collection<Object[]> pdfbox_f10127_0() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("DocumentID", Types.URI, "uuid:FB031973-5E75-11B2-8F06-E7F5C101C07A"));    data.add(wrapProperty("Manager", Types.AgentName, "Raoul"));    data.add(wrapProperty("ManageTo", Types.URI, "uuid:36"));    data.add(wrapProperty("ManageUI", Types.URI, "uuid:3635"));        data.add(wrapProperty("InstanceID", Types.URI, "uuid:42"));    data.add(wrapProperty("OriginalDocumentID", Types.Text, "uuid:142"));        data.add(wrapProperty("RenditionParams", Types.Text, "my params"));    data.add(wrapProperty("VersionID", Types.Text, "14"));    data.add(wrapProperty("Versions", Types.Version, Cardinality.Seq, new String[] { "1", "2", "3" }));    data.add(wrapProperty("History", Types.Text, Cardinality.Seq, new String[] { "action 1", "action 2", "action 3" }));    data.add(wrapProperty("Ingredients", Types.Text, Cardinality.Bag, new String[] { "resource1", "resource2" }));    return data;}
public void pdfbox_f10128_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    schema = metadata.createAndAddXMPRightsManagementSchema();    schemaClass = XMPRightsManagementSchema.class;}
public static Collection<Object[]> pdfbox_f10129_0() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(wrapProperty("Certificate", Types.URL, "http://une.url.vers.un.certificat/moncert.cer"));    data.add(wrapProperty("Marked", Types.Boolean, true));    data.add(wrapProperty("Owner", Types.ProperName, Cardinality.Bag, new String[] { "OwnerName" }));    Map<String, String> desc = new HashMap<>(2);    desc.put("fr", "Termes d'utilisation");    desc.put("en", "Usage Terms");    data.add(wrapProperty("UsageTerms", Types.LangAlt, desc));    data.add(wrapProperty("WebStatement", Types.URL, "http://une.url.vers.une.page.fr/"));    return data;}
public void pdfbox_f10130_0() throws Exception
{    parent = XMPMetadata.createXMPMetadata();    schem = new XMPSchema(parent, "nsURI", "nsSchem");}
public void pdfbox_f10131_0() throws Exception
{    String bagName = "BAGTEST";    String value1 = "valueOne";    String value2 = "valueTwo";    schem.addBagValue(bagName, schem.getMetadata().getTypeMapping().createText(null, "rdf", "li", value1));    schem.addQualifiedBagValue(bagName, value2);    List<String> values = schem.getUnqualifiedBagValueList(bagName);    Assert.assertEquals(value1, values.get(0));    Assert.assertEquals(value2, values.get(1));    schem.removeUnqualifiedBagValue(bagName, value1);    List<String> values2 = schem.getUnqualifiedBagValueList(bagName);    Assert.assertEquals(1, values2.size());    Assert.assertEquals(value2, values2.get(0));}
public void pdfbox_f10132_0() throws Exception
{    XMPMetadata meta = XMPMetadata.createXMPMetadata();    ArrayProperty newSeq = meta.getTypeMapping().createArrayProperty(null, "nsSchem", "seqType", Cardinality.Seq);    TypeMapping tm = meta.getTypeMapping();    TextType li1 = tm.createText(null, "rdf", "li", "valeur1");    TextType li2 = tm.createText(null, "rdf", "li", "valeur2");    newSeq.getContainer().addProperty(li1);    newSeq.getContainer().addProperty(li2);    schem.addProperty(newSeq);    List<AbstractField> list = schem.getUnqualifiedArrayList("seqType");    Assert.assertTrue(list.contains(li1));    Assert.assertTrue(list.contains(li2));}
public void pdfbox_f10133_0() throws Exception
{    Calendar date = Calendar.getInstance();    BooleanType bool = parent.getTypeMapping().createBoolean(null, "rdf", "li", true);    String textVal = "seqValue";    String seqName = "SEQNAME";    schem.addUnqualifiedSequenceDateValue(seqName, date);    schem.addUnqualifiedSequenceValue(seqName, bool);    schem.addUnqualifiedSequenceValue(seqName, textVal);    List<Calendar> dates = schem.getUnqualifiedSequenceDateValueList(seqName);    Assert.assertEquals(1, dates.size());    Assert.assertEquals(date, dates.get(0));    List<String> values = schem.getUnqualifiedSequenceValueList(seqName);    Assert.assertEquals(3, values.size());    Assert.assertEquals(DateConverter.toISO8601(date), values.get(0));    Assert.assertEquals(bool.getStringValue(), values.get(1));    Assert.assertEquals(textVal, values.get(2));    schem.removeUnqualifiedSequenceDateValue(seqName, date);    Assert.assertEquals(0, schem.getUnqualifiedSequenceDateValueList(seqName).size());    schem.removeUnqualifiedSequenceValue(seqName, bool);    schem.removeUnqualifiedSequenceValue(seqName, textVal);    Assert.assertEquals(0, schem.getUnqualifiedSequenceValueList(seqName).size());}
public void pdfbox_f10134_0()
{    Assert.assertEquals("", schem.getAboutValue());    String about = "about";    schem.setAboutAsSimple(about);    Assert.assertEquals(about, schem.getAboutValue());    schem.setAboutAsSimple("");    Assert.assertEquals("", schem.getAboutValue());    schem.setAboutAsSimple(null);    Assert.assertEquals("", schem.getAboutValue());}
public void pdfbox_f10135_0() throws Exception
{    schem.setAbout(new Attribute(null, "about", ""));}
public void pdfbox_f10136_0() throws Exception
{    String prop = "testprop";    String val = "value";    String val2 = "value2";    schem.setTextPropertyValueAsSimple(prop, val);    Assert.assertEquals(val, schem.getUnqualifiedTextPropertyValue(prop));    schem.setTextPropertyValueAsSimple(prop, val2);    Assert.assertEquals(val2, schem.getUnqualifiedTextPropertyValue(prop));    schem.setTextPropertyValueAsSimple(prop, null);    Assert.assertNull(schem.getUnqualifiedTextProperty(prop));}
public void pdfbox_f10137_0() throws Exception
{    String prop = "testprop";    String val = "value";    String val2 = "value2";    schem.setTextPropertyValueAsSimple(prop, val);    TextType text = schem.getMetadata().getTypeMapping().createText(null, schem.getPrefix(), prop, "value2");    schem.setTextProperty(text);    Assert.assertEquals(val2, schem.getUnqualifiedTextPropertyValue(prop));    Assert.assertEquals(text, schem.getUnqualifiedTextProperty(prop));}
public void pdfbox_f10138_0() throws Exception
{    String bool = "bool";    boolean boolVal = true;    String date = "date";    Calendar dateVal = Calendar.getInstance();    String integ = "integer";    Integer i = 1;    String langprop = "langprop";    String lang = "x-default";    String langVal = "langVal";    String bagprop = "bagProp";    String bagVal = "bagVal";    String seqprop = "SeqProp";    String seqPropVal = "seqval";    String seqdate = "SeqDate";    String prefSchem = "";    schem.setBooleanPropertyValueAsSimple(bool, boolVal);    schem.setDatePropertyValueAsSimple(date, dateVal);    schem.setIntegerPropertyValueAsSimple(integ, i);    schem.setUnqualifiedLanguagePropertyValue(langprop, lang, langVal);    schem.addBagValueAsSimple(bagprop, bagVal);    schem.addUnqualifiedSequenceValue(seqprop, seqPropVal);    schem.addSequenceDateValueAsSimple(seqdate, dateVal);    Assert.assertEquals(Boolean.valueOf(boolVal), schem.getBooleanProperty(prefSchem + bool).getValue());    Assert.assertEquals(dateVal, schem.getDateProperty(prefSchem + date).getValue());    Assert.assertEquals("" + i, schem.getIntegerProperty(prefSchem + integ).getStringValue());    Assert.assertEquals(langVal, schem.getUnqualifiedLanguagePropertyValue(langprop, lang));    Assert.assertTrue(schem.getUnqualifiedBagValueList(bagprop).contains(bagVal));    Assert.assertTrue(schem.getUnqualifiedSequenceValueList(seqprop).contains(seqPropVal));    Assert.assertTrue(schem.getUnqualifiedSequenceDateValueList(seqdate).contains(dateVal));    Assert.assertTrue(schem.getUnqualifiedLanguagePropertyLanguagesValue(langprop).contains(lang));    Assert.assertEquals(boolVal, schem.getBooleanPropertyValueAsSimple(bool).booleanValue());    Assert.assertEquals(dateVal, schem.getDatePropertyValueAsSimple(date));    Assert.assertEquals(i, schem.getIntegerPropertyValueAsSimple(integ));    Assert.assertEquals(langVal, schem.getUnqualifiedLanguagePropertyValue(langprop, lang));    Assert.assertTrue(schem.getUnqualifiedBagValueList(bagprop).contains(bagVal));    Assert.assertTrue(schem.getUnqualifiedSequenceValueList(seqprop).contains(seqPropVal));    Assert.assertTrue(schem.getUnqualifiedSequenceDateValueList(seqdate).contains(dateVal));    Assert.assertTrue(schem.getUnqualifiedLanguagePropertyLanguagesValue(langprop).contains(lang));}
public void pdfbox_f10139_0() throws Exception
{    Assert.assertEquals("nsURI", schem.getNamespace());        schem.addNamespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "rdf");    String aboutVal = "aboutTest";    schem.setAboutAsSimple(aboutVal);    Assert.assertEquals(aboutVal, schem.getAboutValue());    Attribute about = new Attribute(XmpConstants.RDF_NAMESPACE, "about", "YEP");    schem.setAbout(about);    Assert.assertEquals(about, schem.getAboutAttribute());    String textProp = "textProp";    String textPropVal = "TextPropTest";    schem.setTextPropertyValue(textProp, textPropVal);    Assert.assertEquals(textPropVal, schem.getUnqualifiedTextPropertyValue(textProp));    TextType text = parent.getTypeMapping().createText(null, "nsSchem", "textType", "GRINGO");    schem.setTextProperty(text);    Assert.assertEquals(text, schem.getUnqualifiedTextProperty("textType"));    Calendar dateVal = Calendar.getInstance();    String date = "nsSchem:dateProp";    schem.setDatePropertyValue(date, dateVal);    Assert.assertEquals(dateVal, schem.getDatePropertyValue(date));    DateType dateType = parent.getTypeMapping().createDate(null, "nsSchem", "dateType", Calendar.getInstance());    schem.setDateProperty(dateType);    Assert.assertEquals(dateType, schem.getDateProperty("dateType"));    String bool = "nsSchem:booleanTestProp";    Boolean boolVal = false;    schem.setBooleanPropertyValue(bool, boolVal);    Assert.assertEquals(boolVal, schem.getBooleanPropertyValue(bool));    BooleanType boolType = parent.getTypeMapping().createBoolean(null, "nsSchem", "boolType", false);    schem.setBooleanProperty(boolType);    Assert.assertEquals(boolType, schem.getBooleanProperty("boolType"));    String intProp = "nsSchem:IntegerTestProp";    Integer intPropVal = 5;    schem.setIntegerPropertyValue(intProp, intPropVal);    Assert.assertEquals(intPropVal, schem.getIntegerPropertyValue(intProp));    IntegerType intType = parent.getTypeMapping().createInteger(null, "nsSchem", "intType", 5);    schem.setIntegerProperty(intType);    Assert.assertEquals(intType, schem.getIntegerProperty("intType"));        boolean ok = false;    try {        schem.getIntegerProperty("boolType");    } catch (IllegalArgumentException e) {        ok = true;    }    Assert.assertTrue(ok);    ok = false;    try {        schem.getUnqualifiedTextProperty("intType");    } catch (IllegalArgumentException e) {        ok = true;    }    Assert.assertTrue(ok);    ok = false;    try {        schem.getDateProperty("textType");    } catch (IllegalArgumentException e) {        ok = true;    }    Assert.assertTrue(ok);    ok = false;    try {        schem.getBooleanProperty("dateType");    } catch (IllegalArgumentException e) {        ok = true;    }}
public void pdfbox_f10140_0() throws Exception
{    String altProp = "AltProp";    String defaultLang = "x-default";    String defaultVal = "Default Language";    String usLang = "en-us";    String usVal = "American Language";    String frLang = "fr-fr";    String frVal = "Lang franaise";    schem.setUnqualifiedLanguagePropertyValue(altProp, usLang, usVal);    schem.setUnqualifiedLanguagePropertyValue(altProp, defaultLang, defaultVal);    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, frVal);    Assert.assertEquals(defaultVal, schem.getUnqualifiedLanguagePropertyValue(altProp, defaultLang));    Assert.assertEquals(frVal, schem.getUnqualifiedLanguagePropertyValue(altProp, frLang));    Assert.assertEquals(usVal, schem.getUnqualifiedLanguagePropertyValue(altProp, usLang));    List<String> languages = schem.getUnqualifiedLanguagePropertyLanguagesValue(altProp);        Assert.assertEquals(defaultLang, languages.get(0));    Assert.assertTrue(languages.contains(usLang));    Assert.assertTrue(languages.contains(frLang));        frVal = "Langue franaise";    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, frVal);    Assert.assertEquals(frVal, schem.getUnqualifiedLanguagePropertyValue(altProp, frLang));    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, null);    languages = schem.getUnqualifiedLanguagePropertyLanguagesValue(altProp);    Assert.assertFalse(languages.contains(frLang));    schem.setUnqualifiedLanguagePropertyValue(altProp, frLang, frVal);}
public void pdfbox_f10141_0() throws Exception
{    String bagName = "bagName";    String seqName = "seqName";    String qseqName = "test:" + seqName;    String altName = "AltProp";    String qaltName = "test:" + altName;    String valBagSchem1 = "BagvalSchem1";    String valBagSchem2 = "BagvalSchem2";    String valSeqSchem1 = "seqvalSchem1";    String valSeqSchem2 = "seqvalSchem2";    String valAltSchem1 = "altvalSchem1";    String langAltSchem1 = "x-default";    String valAltSchem2 = "altvalSchem2";    String langAltSchem2 = "fr-fr";    XMPSchema schem1 = new XMPSchema(parent, "http://www.test.org/schem/", "test");    schem1.addQualifiedBagValue(bagName, valBagSchem1);    schem1.addUnqualifiedSequenceValue(seqName, valSeqSchem1);    schem1.setUnqualifiedLanguagePropertyValue(altName, langAltSchem1, valAltSchem1);    XMPSchema schem2 = new XMPSchema(parent, "http://www.test.org/schem/", "test");    schem2.addQualifiedBagValue(bagName, valBagSchem2);    schem2.addUnqualifiedSequenceValue(seqName, valSeqSchem2);    schem2.setUnqualifiedLanguagePropertyValue(altName, langAltSchem2, valAltSchem2);    schem1.merge(schem2);        Assert.assertEquals(valAltSchem2, schem1.getUnqualifiedLanguagePropertyValue(altName, langAltSchem2));    Assert.assertEquals(valAltSchem1, schem1.getUnqualifiedLanguagePropertyValue(altName, langAltSchem1));    List<String> bag = schem1.getUnqualifiedBagValueList(bagName);    Assert.assertTrue(bag.contains(valBagSchem1));    Assert.assertTrue(bag.contains(valBagSchem2));    List<String> seq = schem1.getUnqualifiedSequenceValueList(seqName);    Assert.assertTrue(seq.contains(valSeqSchem1));    Assert.assertTrue(seq.contains(valSeqSchem1));}
public void pdfbox_f10142_0() throws Exception
{    String boolname = "bool";    boolean boolVal = true;    BooleanType bool = parent.getTypeMapping().createBoolean(null, schem.getPrefix(), boolname, boolVal);    Attribute att = new Attribute(XmpConstants.RDF_NAMESPACE, "test", "vgh");    schem.setAttribute(att);    schem.setBooleanProperty(bool);    Assert.assertEquals(schem.getAllProperties(), schem.getAllProperties());    Assert.assertTrue(schem.getAllProperties().contains(bool));    Assert.assertTrue(schem.getAllAttributes().contains(att));    Assert.assertEquals(bool, schem.getProperty(boolname));}
public static Collection<Object[]> pdfbox_f10143_0() throws Exception
{    List<Object[]> params = new ArrayList<>();    InputStream is = TestValidatePermitedMetadata.class.getResourceAsStream("/permited_metadata.txt");    BufferedReader reader = new BufferedReader(new InputStreamReader(is, "ISO-8859-1"));    String line = reader.readLine();    while (line != null) {        if (line.startsWith("http://")) {                        int pos = line.lastIndexOf(':');            int spos = line.lastIndexOf('/', pos);            String namespace = line.substring(0, spos + 1);            String preferred = line.substring(spos + 1, pos);            String fieldname = line.substring(pos + 1);            params.add(new String[] { namespace, preferred, fieldname });        }                        line = reader.readLine();    }    return params;}
public void pdfbox_f10144_0() throws Exception
{        XMPMetadata xmpmd = new XMPMetadata();    TypeMapping mapping = new TypeMapping(xmpmd);    XMPSchemaFactory factory = mapping.getSchemaFactory(namespace);    assertNotNull("Schema not existing: " + namespace, factory);        XMPSchema schema = factory.createXMPSchema(xmpmd, "aa");    assertEquals(preferred, schema.getPreferedPrefix());        boolean found = false;    Class<?> clz = schema.getClass();    for (Field dfield : clz.getDeclaredFields()) {        PropertyType ptype = dfield.getAnnotation(PropertyType.class);        if (ptype != null) {                        if (String.class.equals(dfield.getType())) {                String value = (String) dfield.get(clz);                if (fieldname.equals(value)) {                                        found = true;                    break;                }            } else {                                throw new IllegalArgumentException("Should be a string : " + dfield.getName());            }        }    }    String msg = String.format("Did not find field definition for '%s' in %s (%s)", fieldname, clz.getSimpleName(), namespace);    assertTrue(msg, found);}
public static Collection<Object[]> pdfbox_f10145_0() throws Exception
{    List<Object[]> data = new ArrayList<>();    data.add(new Object[] { "/validxmp/override_ns.rdf" });    data.add(new Object[] { "/validxmp/ghost2.xmp" });    data.add(new Object[] { "/validxmp/history2.rdf" });    data.add(new Object[] { "/validxmp/Notepad++_A1b.xmp" });    data.add(new Object[] { "/validxmp/metadata.rdf" });    return data;}
public void pdfbox_f10146_0() throws Exception
{    InputStream is = this.getClass().getResourceAsStream(path);    DomXmpParser builder = new DomXmpParser();    XMPMetadata rxmp = builder.parse(is);}
public void pdfbox_f10147_0() throws Exception
{    builder = new DomXmpParser();    xmp = XMPMetadata.createXMPMetadata();    typeMapping = xmp.getTypeMapping();}
public void pdfbox_f10148_0() throws Exception
{    AbstractStructuredType structured = getStructured();        Assert.assertNull(structured.getProperty(fieldName));        Method get = clz.getMethod(calculateSimpleGetter(fieldName));    Object result = get.invoke(structured);    Assert.assertNull(result);}
public void pdfbox_f10149_0() throws Exception
{    internalTestSettingValue();}
public void pdfbox_f10150_0() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSettingValue();    }}
private void pdfbox_f10151_0() throws Exception
{    AbstractStructuredType structured = getStructured();    Object value = getJavaValue(type);    structured.addSimpleProperty(fieldName, value);    Assert.assertNotNull(structured.getProperty(fieldName));        List<Field> fields = getXmpFields(clz);    for (Field field : fields) {                String name = field.get(null).toString();        if (!name.equals(fieldName)) {            Assert.assertNull(structured.getProperty(name));        }    }}
public void pdfbox_f10152_0() throws Exception
{    internalTestPropertyType();}
public void pdfbox_f10153_0() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestPropertyType();    }}
private void pdfbox_f10154_0() throws Exception
{    AbstractStructuredType structured = getStructured();    Object value = getJavaValue(type);    structured.addSimpleProperty(fieldName, value);    Assert.assertNotNull(structured.getProperty(fieldName));        AbstractSimpleProperty asp = (AbstractSimpleProperty) structured.getProperty(fieldName);    Assert.assertEquals(type.getImplementingClass(), asp.getClass());}
public void pdfbox_f10155_0() throws Exception
{    internalTestSetter();}
public void pdfbox_f10156_0() throws Exception
{    initializeSeed(new Random());    for (int i = 0; i < RAND_LOOP_COUNT; i++) {        internalTestSetter();    }}
private void pdfbox_f10157_0() throws Exception
{    AbstractStructuredType structured = getStructured();    String setter = calculateSimpleSetter(fieldName);    Object value = getJavaValue(type);    Method set = clz.getMethod(setter, getJavaType(type));    set.invoke(structured, value);        Assert.assertEquals(value, ((AbstractSimpleProperty) structured.getProperty(fieldName)).getValue());        Method get = clz.getMethod(calculateSimpleGetter(fieldName));    Object result = get.invoke(structured);    Assert.assertTrue(getJavaType(type).isAssignableFrom(result.getClass()));    Assert.assertEquals(value, result);}
protected void pdfbox_f10158_0(Random rand)
{    this.counterRandom = rand;}
public String pdfbox_f10159_0(String name)
{    StringBuilder sb = new StringBuilder(3 + name.length());    sb.append("get").append(calculateFieldNameForMethod(name));    return sb.toString();}
public String pdfbox_f10160_0(String name)
{    StringBuilder sb = new StringBuilder(4 + name.length());    String fn = calculateFieldNameForMethod(name);    sb.append("get").append(fn);    if (!fn.endsWith("s")) {        sb.append("s");    }    return sb.toString();}
public String pdfbox_f10161_0(String name)
{    StringBuilder sb = new StringBuilder(3 + name.length());    sb.append("set").append(calculateFieldNameForMethod(name));    return sb.toString();}
public String pdfbox_f10162_0(String name)
{    StringBuilder sb = new StringBuilder(name.length());    sb.append(name.substring(0, 1).toUpperCase()).append(name.substring(1));    return sb.toString();}
public Class<?> pdfbox_f10163_0(Types type)
{    if (type.getImplementingClass() == TextType.class) {        return String.class;    } else if (type.getImplementingClass() == DateType.class) {        return Calendar.class;    } else if (type.getImplementingClass() == IntegerType.class) {        return Integer.class;    } else if (TextType.class.isAssignableFrom(type.getImplementingClass())) {        return String.class;    } else {        throw new IllegalArgumentException("Type not expected in test : " + type.getImplementingClass());    }}
public Object pdfbox_f10164_0(Types type)
{    if (TextType.class.isAssignableFrom(type.getImplementingClass())) {        return "Text_String_" + counterRandom.nextLong() % MAX_COUNTER;    } else if (type.getImplementingClass() == DateType.class) {        Calendar calendar = Calendar.getInstance();        calendar.setTimeInMillis(counterRandom.nextLong() % MAX_COUNTER);        return calendar;    } else if (type.getImplementingClass() == IntegerType.class) {        return counterRandom.nextInt();    } else {        throw new IllegalArgumentException("Type not expected in test : " + type.getImplementingClass());    }}
public List<Field> pdfbox_f10165_0(Class<?> clz)
{    Field[] fields = clz.getFields();    List<Field> result = new ArrayList<>(fields.length);    for (Field field : fields) {        if (field.getAnnotation(PropertyType.class) != null) {            result.add(field);        }    }    return result;}
public void pdfbox_f10166_0()
{    String nsUri = "nsUri";    String prefix = "prefix";    String localName = "localName";    String value = "value";    Attribute att = new Attribute(nsUri, localName, value);    Assert.assertEquals(nsUri, att.getNamespace());    Assert.assertEquals(localName, att.getName());    Assert.assertEquals(value, att.getValue());    String nsUri2 = "nsUri2";    String prefix2 = "prefix2";    String localName2 = "localName2";    String value2 = "value2";    att.setNsURI(nsUri2);    att.setName(localName2);    att.setValue(value2);    Assert.assertEquals(nsUri2, att.getNamespace());    Assert.assertEquals(localName2, att.getName());    Assert.assertEquals(value2, att.getValue());}
public void pdfbox_f10167_0()
{    String nsUri = "nsUri";    String localName = "localName";    String value = "value";    Attribute att = new Attribute(nsUri, localName, value);    Assert.assertEquals(nsUri, att.getNamespace());    Assert.assertEquals(localName, att.getName());    att = new Attribute(nsUri, localName, value);    Assert.assertEquals(nsUri, att.getNamespace());    Assert.assertEquals(localName, att.getName());}
public void pdfbox_f10168_0() throws Exception
{    XMPMetadata xmp = XMPMetadata.createXMPMetadata();    st = new MyStructuredType(xmp, MY_NS, MY_PREFIX);}
public void pdfbox_f10169_0() throws Exception
{    Assert.assertEquals(MY_NS, st.getNamespace());    Assert.assertEquals(MY_PREFIX, st.getPrefix());    Assert.assertEquals(MY_PREFIX, st.getPrefix());}
public void pdfbox_f10170_0() throws Exception
{    Assert.assertNull(st.getProperty("NOT_EXISTING"));}
public void pdfbox_f10171_0() throws Exception
{    Assert.assertNull(st.getProperty(MyStructuredType.MYTEXT));}
public void pdfbox_f10172_0() throws Exception
{    String s = "my value";    st.addSimpleProperty(MyStructuredType.MYTEXT, s);    Assert.assertEquals(s, st.getPropertyValueAsString(MyStructuredType.MYTEXT));    Assert.assertNull(st.getPropertyValueAsString(MyStructuredType.MYDATE));    Assert.assertNotNull(st.getProperty(MyStructuredType.MYTEXT));}
public void pdfbox_f10173_0() throws Exception
{    Calendar c = Calendar.getInstance();    st.addSimpleProperty(MyStructuredType.MYDATE, c);    Assert.assertEquals(c, st.getDatePropertyAsCalendar(MyStructuredType.MYDATE));    Assert.assertNull(st.getDatePropertyAsCalendar(MyStructuredType.MYTEXT));    Assert.assertNotNull(st.getProperty(MyStructuredType.MYDATE));}
public static Collection<Object[]> pdfbox_f10174_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { AgentNameType.class, "AgentName" });    result.add(new Object[] { ChoiceType.class, "Choice" });    result.add(new Object[] { GUIDType.class, "GUID" });    result.add(new Object[] { LocaleType.class, "Locale" });    result.add(new Object[] { MIMEType.class, "MIME" });    result.add(new Object[] { PartType.class, "Part" });    result.add(new Object[] { ProperNameType.class, "ProperName" });    result.add(new Object[] { RenditionClassType.class, "RenditionClass" });    result.add(new Object[] { URIType.class, "URI" });    result.add(new Object[] { URLType.class, "URL" });    result.add(new Object[] { XPathType.class, "XPath" });    return result;}
public void pdfbox_f10175_0() throws Exception
{    xmp = XMPMetadata.createXMPMetadata();    constructor = clz.getDeclaredConstructor(XMPMetadata.class, String.class, String.class, String.class, Object.class);}
protected TextType pdfbox_f10176_0(XMPMetadata metadata, String namespaceURI, String prefix, String propertyName, Object value) throws Exception
{    Object[] initargs = new Object[] { metadata, namespaceURI, prefix, propertyName, value };    return constructor.newInstance(initargs);}
public void pdfbox_f10177_0() throws Exception
{    TextType element = instanciate(xmp, null, PREFIX, NAME, VALUE);    Assert.assertNull(element.getNamespace());    Assert.assertTrue(element.getValue() instanceof String);    Assert.assertEquals(VALUE, element.getValue());}
public void pdfbox_f10178_0() throws Exception
{    super.before();}
protected AbstractStructuredType pdfbox_f10179_0()
{    return new JobType(xmp, "job");}
public static Collection<Object[]> pdfbox_f10180_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { JobType.class, "id", Types.Text });    result.add(new Object[] { JobType.class, "name", Types.Text });    result.add(new Object[] { JobType.class, "url", Types.URL });    return result;}
public void pdfbox_f10181_0() throws Exception
{    super.before();}
protected AbstractStructuredType pdfbox_f10182_0()
{    return new LayerType(xmp);}
public static Collection<Object[]> pdfbox_f10183_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { LayerType.class, "LayerName", Types.Text });    result.add(new Object[] { LayerType.class, "LayerText", Types.Text });    return result;}
public void pdfbox_f10184_0() throws Exception
{    super.before();}
protected AbstractStructuredType pdfbox_f10185_0()
{    return new ResourceEventType(xmp);}
public static Collection<Object[]> pdfbox_f10186_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { ResourceEventType.class, "action", Types.Choice });    result.add(new Object[] { ResourceEventType.class, "changed", Types.Text });    result.add(new Object[] { ResourceEventType.class, "instanceID", Types.GUID });    result.add(new Object[] { ResourceEventType.class, "parameters", Types.Text });    result.add(new Object[] { ResourceEventType.class, "softwareAgent", Types.AgentName });    result.add(new Object[] { ResourceEventType.class, "when", Types.Date });    return result;}
public void pdfbox_f10187_0() throws Exception
{    super.before();}
protected AbstractStructuredType pdfbox_f10188_0()
{    return new ResourceRefType(xmp);}
public static Collection<Object[]> pdfbox_f10189_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();            result.add(new Object[] { ResourceRefType.class, "documentID", Types.URI });    result.add(new Object[] { ResourceRefType.class, "filePath", Types.URI });    result.add(new Object[] { ResourceRefType.class, "fromPart", Types.Part });    result.add(new Object[] { ResourceRefType.class, "instanceID", Types.URI });    result.add(new Object[] { ResourceRefType.class, "lastModifyDate", Types.Date });    result.add(new Object[] { ResourceRefType.class, "manager", Types.AgentName });    result.add(new Object[] { ResourceRefType.class, "managerVariant", Types.Text });    result.add(new Object[] { ResourceRefType.class, "manageTo", Types.URI });    result.add(new Object[] { ResourceRefType.class, "manageUI", Types.URI });    result.add(new Object[] { ResourceRefType.class, "maskMarkers", Types.Choice });    result.add(new Object[] { ResourceRefType.class, "partMapping", Types.Text });    result.add(new Object[] { ResourceRefType.class, "renditionClass", Types.RenditionClass });    result.add(new Object[] { ResourceRefType.class, "renditionParams", Types.Text });    result.add(new Object[] { ResourceRefType.class, "toPart", Types.Part });    result.add(new Object[] { ResourceRefType.class, "versionID", Types.Text });    return result;}
public void pdfbox_f10190_0() throws Exception
{    parent = XMPMetadata.createXMPMetadata();}
public void pdfbox_f10191_0()
{    new BooleanType(parent, null, "test", "booleen", "Not a Boolean");}
public void pdfbox_f10192_0()
{    new DateType(parent, null, "test", "date", "Bad Date");}
public void pdfbox_f10193_0()
{    new IntegerType(parent, null, "test", "integer", "Not an int");}
public void pdfbox_f10194_0() throws Exception
{    new RealType(parent, null, "test", "real", "Not a real");}
public void pdfbox_f10195_0() throws Exception
{    new TextType(parent, null, "test", "text", Calendar.getInstance());}
public void pdfbox_f10196_0() throws Exception
{    boolean boolv = true;    Calendar datev = Calendar.getInstance();    int integerv = 1;    float realv = Float.parseFloat("1.69");    String textv = "TEXTCONTENT";    BooleanType bool = parent.getTypeMapping().createBoolean(null, "test", "booleen", boolv);    DateType date = parent.getTypeMapping().createDate(null, "test", "date", datev);    IntegerType integer = parent.getTypeMapping().createInteger(null, "test", "integer", integerv);    RealType real = parent.getTypeMapping().createReal(null, "test", "real", realv);    TextType text = parent.getTypeMapping().createText(null, "test", "text", textv);    Assert.assertEquals(boolv, bool.getValue());    Assert.assertEquals(datev, date.getValue());    Assert.assertEquals(Integer.valueOf(integerv), integer.getValue());    Assert.assertEquals(realv, real.getValue(), 0);    Assert.assertEquals(textv, text.getStringValue());}
public void pdfbox_f10197_0() throws Exception
{    String boolv = "False";    String datev = "2010-03-22T14:33:11+01:00";    String integerv = "10";    String realv = "1.92";    String textv = "text";    BooleanType bool = new BooleanType(parent, null, "test", "booleen", boolv);    DateType date = new DateType(parent, null, "test", "date", datev);    IntegerType integer = new IntegerType(parent, null, "test", "integer", integerv);    RealType real = new RealType(parent, null, "test", "real", realv);    TextType text = new TextType(parent, null, "test", "text", textv);    Assert.assertEquals(boolv, bool.getStringValue());    Assert.assertEquals(datev, date.getStringValue());    Assert.assertEquals(integerv, integer.getStringValue());    Assert.assertEquals(realv, real.getStringValue());    Assert.assertEquals(textv, text.getStringValue());}
public void pdfbox_f10198_0() throws Exception
{    String ns = "http://www.test.org/pdfa/";    BooleanType bool = parent.getTypeMapping().createBoolean(ns, "test", "booleen", true);    DateType date = parent.getTypeMapping().createDate(ns, "test", "date", Calendar.getInstance());    IntegerType integer = parent.getTypeMapping().createInteger(ns, "test", "integer", 1);    RealType real = parent.getTypeMapping().createReal(ns, "test", "real", (float) 1.6);    TextType text = parent.getTypeMapping().createText(ns, "test", "text", "TEST");    Assert.assertEquals(ns, bool.getNamespace());    Assert.assertEquals(ns, date.getNamespace());    Assert.assertEquals(ns, integer.getNamespace());    Assert.assertEquals(ns, real.getNamespace());    Assert.assertEquals(ns, text.getNamespace());}
public void pdfbox_f10199_0() throws Exception
{    throw new IllegalArgumentException("TEST", new Throwable());}
public void pdfbox_f10200_0() throws Exception
{    IntegerType integer = new IntegerType(parent, null, "test", "integer", 1);    Attribute value = new Attribute("http://www.test.org/test/", "value1", "StringValue1");    Attribute value2 = new Attribute("http://www.test.org/test/", "value2", "StringValue2");    integer.setAttribute(value);        Assert.assertEquals(value, integer.getAttribute(value.getName()));    Assert.assertTrue(integer.containsAttribute(value.getName()));        integer.setAttribute(value2);    Assert.assertEquals(value2, integer.getAttribute(value2.getName()));    integer.removeAttribute(value2.getName());    Assert.assertFalse(integer.containsAttribute(value2.getName()));        Attribute valueNS = new Attribute("http://www.tefst2.org/test/", "value2", "StringValue.2");    integer.setAttribute(valueNS);    Attribute valueNS2 = new Attribute("http://www.test2.org/test/", "value2", "StringValueTwo");    integer.setAttribute(valueNS2);    List<Attribute> atts = integer.getAllAttributes();    /*         * for (Attribute attribute : atts) { System.out.println(attribute.getLocalName ()+" :"+attribute.getValue()); }         */    Assert.assertFalse(atts.contains(valueNS));    Assert.assertTrue(atts.contains(valueNS2));}
public void pdfbox_f10201_0() throws Exception
{    super.before();}
protected AbstractStructuredType pdfbox_f10202_0()
{    return new ThumbnailType(xmp);}
public static Collection<Object[]> pdfbox_f10203_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { ThumbnailType.class, "format", Types.Choice });    result.add(new Object[] { ThumbnailType.class, "height", Types.Integer });    result.add(new Object[] { ThumbnailType.class, "width", Types.Integer });    result.add(new Object[] { ThumbnailType.class, "image", Types.Text });    return result;}
public void pdfbox_f10204_0() throws Exception
{    super.before();}
protected AbstractStructuredType pdfbox_f10205_0()
{    return new VersionType(xmp);}
public static Collection<Object[]> pdfbox_f10206_0() throws Exception
{    Collection<Object[]> result = new ArrayList<>();    result.add(new Object[] { VersionType.class, "modifier", Types.ProperName });    return result;}
public void pdfbox_f10207_0() throws Exception
{    metadata = XMPMetadata.createXMPMetadata();    String tmpNsURI = "http://www.test.org/schem/";    tmp = new XMPSchema(metadata, tmpNsURI, "test");    tmp.addQualifiedBagValue("BagContainer", "Value1");    tmp.addQualifiedBagValue("BagContainer", "Value2");    tmp.addQualifiedBagValue("BagContainer", "Value3");    tmp.addUnqualifiedSequenceValue("SeqContainer", "Value1");    tmp.addUnqualifiedSequenceValue("SeqContainer", "Value2");    tmp.addUnqualifiedSequenceValue("SeqContainer", "Value3");    tmp.addProperty(metadata.getTypeMapping().createText(null, "test", "simpleProperty", "YEP"));    tmp2 = new XMPSchema(metadata, "http://www.space.org/schem/", "space", "space");    tmp2.addUnqualifiedSequenceValue("SeqSpContainer", "ValueSpace1");    tmp2.addUnqualifiedSequenceValue("SeqSpContainer", "ValueSpace2");    tmp2.addUnqualifiedSequenceValue("SeqSpContainer", "ValueSpace3");    metadata.addSchema(tmp);    metadata.addSchema(tmp2);        Assert.assertEquals(tmp, metadata.getSchema(tmpNsURI));    Assert.assertNull(metadata.getSchema("THIS URI NOT EXISTS !"));}
public void pdfbox_f10208_0()
{    List<XMPSchema> vals = metadata.getAllSchemas();    Assert.assertTrue(vals.contains(tmp));    Assert.assertTrue(vals.contains(tmp2));}
public void pdfbox_f10209_0() throws XmpSerializationException
{    throw new XmpSerializationException("TEST");}
public void pdfbox_f10210_0() throws XmpSerializationException
{    throw new XmpSerializationException("TEST", new Throwable());}
public void pdfbox_f10211_0() throws Exception
{    String xpacketBegin = "TESTBEG", xpacketId = "TESTID", xpacketBytes = "TESTBYTES", xpacketEncoding = "TESTENCOD";    metadata = XMPMetadata.createXMPMetadata(xpacketBegin, xpacketId, xpacketBytes, xpacketEncoding);    Assert.assertEquals(xpacketBegin, metadata.getXpacketBegin());    Assert.assertEquals(xpacketId, metadata.getXpacketId());    Assert.assertEquals(xpacketBytes, metadata.getXpacketBytes());    Assert.assertEquals(xpacketEncoding, metadata.getXpacketEncoding());}
public void pdfbox_f10212_0() throws IOException, XmpParsingException
{        String xmpmeta = "<?xpacket id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n" + "<x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:14:39\">\n" + "   <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:xap=\"http://ns.adobe.com/xap/1.0/\">\n" + "         <xap:CreatorTool>Acrobat PDFMaker 8.1 for Word</xap:CreatorTool>\n" + "         <xap:ModifyDate>2008-11-12T15:29:43+01:00</xap:ModifyDate>\n" + "         <xap:CreateDate>2008-11-12T15:29:40+01:00</xap:CreateDate>\n" + "         <xap:MetadataDate>2008-11-12T15:29:43+01:00</xap:MetadataDate>\n" + "      </rdf:Description>\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">\n" + "         <pdf:Producer>Acrobat Distiller 8.1.0 (Windows)</pdf:Producer>\n" + "      </rdf:Description>\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n" + "         <dc:format>application/pdf</dc:format>\n" + "         <dc:creator>\n" + "            <rdf:Seq>\n" + "               <rdf:li>R002325</rdf:li>\n" + "            </rdf:Seq>\n" + "         </dc:creator>\n" + "         <dc:subject>\n" + "            <rdf:Bag>\n" + "               <rdf:li>one</rdf:li>\n" + "               <rdf:li>two</rdf:li>\n" + "               <rdf:li>three</rdf:li>\n" + "               <rdf:li>four</rdf:li>\n" + "            </rdf:Bag>\n" + "         </dc:subject>\n" + "         <dc:title>\n" + "            <rdf:Alt>\n" + "               <rdf:li xml:lang=\"x-default\"> </rdf:li>\n" + "            </rdf:Alt>\n" + "         </dc:title>\n" + "      </rdf:Description>\n" + "      <rdf:Description rdf:about=\"\"\n" + "            xmlns:xapMM=\"http://ns.adobe.com/xap/1.0/mm/\">\n" + "         <xapMM:DocumentID>uuid:31ae92cf-9a27-45e0-9371-0d2741e25919</xapMM:DocumentID>\n" + "         <xapMM:InstanceID>uuid:2c7eb5da-9210-4666-8cef-e02ef6631c5e</xapMM:InstanceID>\n" + "      </rdf:Description>\n" + "   </rdf:RDF>\n" + "</x:xmpmeta>\n" + "<?xpacket end=\"w\"?>";    DomXmpParser xmpParser = new DomXmpParser();    xmpParser.setStrictParsing(false);        XMPMetadata xmp = xmpParser.parse(xmpmeta.getBytes());    XMPBasicSchema basicSchema = xmp.getXMPBasicSchema();    Calendar createDate1 = basicSchema.getCreateDate();    basicSchema.setCreateDate(new GregorianCalendar());    Calendar createDate2 = basicSchema.getCreateDate();    Assert.assertFalse("CreateDate has not been set", createDate1.equals(createDate2));        DublinCoreSchema dublinCoreSchema = xmp.getDublinCoreSchema();    List<String> subjects = dublinCoreSchema.getSubjects();    Assert.assertEquals(4, subjects.size());}
