public int curator_f0_0()
{    return expirationPercent;}
public T curator_f1_0(CuratorZookeeperClient client, Callable<T> proc) throws Exception
{    client.internalBlockUntilConnectedOrTimedOut();    T result = null;    RetryLoop retryLoop = client.newRetryLoop();    while (retryLoop.shouldContinue()) {        try {            result = proc.call();            retryLoop.markComplete();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            retryLoop.takeException(e);        }    }    return result;}
public CheckTimeoutsResult curator_f2_0(Callable<String> hasNewConnectionString, long connectionStartMs, int sessionTimeoutMs, int connectionTimeoutMs) throws Exception
{    if (hasNewConnectionString.call() != null) {        return CheckTimeoutsResult.NEW_CONNECTION_STRING;    }    return CheckTimeoutsResult.NOP;}
 ZooKeeper curator_f3_0() throws Exception
{    if (SessionFailRetryLoop.sessionForThreadHasFailed()) {        throw new SessionFailRetryLoop.SessionFailedException();    }    Exception exception = backgroundExceptions.poll();    if (exception != null) {        new EventTrace("background-exceptions", tracer.get()).commit();        throw exception;    }    boolean localIsConnected = isConnected.get();    if (!localIsConnected) {        checkTimeouts();    }    return zooKeeper.getZooKeeper();}
 boolean curator_f4_0()
{    return isConnected.get();}
 void curator_f5_1() throws Exception
{        ensembleProvider.start();    reset();}
public void curator_f6_0() throws IOException
{    close(0);}
public void curator_f7_1(int waitForShutdownTimeoutMs) throws IOException
{        CloseableUtils.closeQuietly(ensembleProvider);    try {        zooKeeper.closeAndClear(waitForShutdownTimeoutMs);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    } finally {        isConnected.set(false);    }}
 void curator_f8_0(Watcher watcher)
{    parentWatchers.offer(watcher);}
 void curator_f9_0(Watcher watcher)
{    parentWatchers.remove(watcher);}
 long curator_f10_0()
{    return instanceIndex.get();}
 int curator_f11_0()
{    return lastNegotiatedSessionTimeoutMs.get();}
public void curator_f12_1(WatchedEvent event)
{    if (LOG_EVENTS) {            }    if (event.getType() == Watcher.Event.EventType.None) {        boolean wasConnected = isConnected.get();        boolean newIsConnected = checkState(event.getState(), wasConnected);        if (newIsConnected != wasConnected) {            isConnected.set(newIsConnected);            connectionStartMs = System.currentTimeMillis();            if (newIsConnected) {                lastNegotiatedSessionTimeoutMs.set(zooKeeper.getNegotiatedSessionTimeoutMs());                            }        }    }    for (Watcher parentWatcher : parentWatchers) {        OperationTrace trace = new OperationTrace("connection-state-parent-process", tracer.get(), getSessionId());        parentWatcher.process(event);        trace.commit();    }}
 EnsembleProvider curator_f13_0()
{    return ensembleProvider;}
 synchronized void curator_f14_1() throws Exception
{        instanceIndex.incrementAndGet();    isConnected.set(false);    connectionStartMs = System.currentTimeMillis();    zooKeeper.closeAndReset();        zooKeeper.getZooKeeper();}
private synchronized void curator_f15_1() throws Exception
{    final AtomicReference<String> newConnectionString = new AtomicReference<>();    Callable<String> hasNewConnectionString = new Callable<String>() {        @Override        public String call() {            newConnectionString.set(zooKeeper.getNewConnectionString());            return newConnectionString.get();        }    };    int lastNegotiatedSessionTimeoutMs = getLastNegotiatedSessionTimeoutMs();    int useSessionTimeoutMs = (lastNegotiatedSessionTimeoutMs > 0) ? lastNegotiatedSessionTimeoutMs : sessionTimeoutMs;    ConnectionHandlingPolicy.CheckTimeoutsResult result = connectionHandlingPolicy.checkTimeouts(hasNewConnectionString, connectionStartMs, useSessionTimeoutMs, connectionTimeoutMs);    switch(result) {        default:        case NOP:            {                break;            }        case NEW_CONNECTION_STRING:            {                handleNewConnectionString(newConnectionString.get());                break;            }        case RESET_CONNECTION:            {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    long elapsed = System.currentTimeMillis() - connectionStartMs;                    int maxTimeout = Math.max(useSessionTimeoutMs, connectionTimeoutMs);                                    }                reset();                break;            }        case CONNECTION_TIMEOUT:            {                KeeperException.ConnectionLossException connectionLossException = new CuratorConnectionLossException();                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    long elapsed = System.currentTimeMillis() - connectionStartMs;                                    }                new EventTrace("connections-timed-out", tracer.get(), getSessionId()).commit();                throw connectionLossException;            }        case SESSION_TIMEOUT:            {                handleExpiredSession();                break;            }    }}
public String curator_f16_0()
{    newConnectionString.set(zooKeeper.getNewConnectionString());    return newConnectionString.get();}
public long curator_f17_0()
{    long sessionId = 0;    try {        ZooKeeper zk = zooKeeper.getZooKeeper();        if (zk != null) {            sessionId = zk.getSessionId();        }    } catch (Exception e) {        }    return sessionId;}
private boolean curator_f18_1(Event.KeeperState state, boolean wasConnected)
{    boolean isConnected = wasConnected;    boolean checkNewConnectionString = true;    switch(state) {        default:        case Disconnected:            {                isConnected = false;                break;            }        case SyncConnected:        case ConnectedReadOnly:            {                isConnected = true;                break;            }        case AuthFailed:            {                isConnected = false;                                break;            }        case Expired:            {                isConnected = false;                checkNewConnectionString = false;                handleExpiredSession();                break;            }        case SaslAuthenticated:            {                                break;            }    }        if (state != Event.KeeperState.Expired) {        new EventTrace(state.toString(), tracer.get(), getSessionId()).commit();    }    if (checkNewConnectionString) {        String newConnectionString = zooKeeper.getNewConnectionString();        if (newConnectionString != null) {            handleNewConnectionString(newConnectionString);        }    }    return isConnected;}
private void curator_f19_1(String newConnectionString)
{        new EventTrace("connection-string-changed", tracer.get(), getSessionId()).commit();    try {        ZooKeeper zooKeeper = this.zooKeeper.getZooKeeper();        if (zooKeeper == null) {                    } else {            if (ensembleProvider.updateServerListEnabled()) {                zooKeeper.updateServerList(newConnectionString);            } else {                reset();            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        queueBackgroundException(e);    }}
private void curator_f20_1()
{        new EventTrace("session-expired", tracer.get(), getSessionId()).commit();    try {        reset();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        queueBackgroundException(e);    }}
private void curator_f21_0(Exception e)
{    while (backgroundExceptions.size() >= MAX_BACKGROUND_EXCEPTIONS) {        backgroundExceptions.poll();    }    backgroundExceptions.offer(e);}
public ZooKeeper curator_f22_0() throws Exception
{    Preconditions.checkState(started.get(), "Client is not started");    return state.getZooKeeper();}
public RetryLoop curator_f23_0()
{    return new RetryLoop(retryPolicy.get(), tracer);}
public SessionFailRetryLoop curator_f24_0(SessionFailRetryLoop.Mode mode)
{    return new SessionFailRetryLoop(this, mode);}
public boolean curator_f25_0()
{    return state.isConnected();}
public boolean curator_f26_1() throws InterruptedException
{    Preconditions.checkState(started.get(), "Client is not started");        OperationTrace trace = startAdvancedTracer("blockUntilConnectedOrTimedOut");    internalBlockUntilConnectedOrTimedOut();    trace.commit();    boolean localIsConnected = state.isConnected();        return localIsConnected;}
public void curator_f27_1() throws Exception
{        if (!started.compareAndSet(false, true)) {        throw new IllegalStateException("Already started");    }    state.start();}
public void curator_f28_0()
{    close(waitForShutdownTimeoutMs);}
public void curator_f29_1(int waitForShutdownTimeoutMs)
{        started.set(false);    try {        state.close(waitForShutdownTimeoutMs);    } catch (IOException e) {        ThreadUtils.checkInterrupted(e);            }}
public void curator_f30_0(RetryPolicy policy)
{    Preconditions.checkNotNull(policy, "policy cannot be null");    retryPolicy.set(policy);}
public RetryPolicy curator_f31_0()
{    return retryPolicy.get();}
public TimeTrace curator_f32_0(String name)
{    return new TimeTrace(name, tracer.get());}
public OperationTrace curator_f33_0(String name)
{    return new OperationTrace(name, tracer.get(), state.getSessionId());}
public TracerDriver curator_f34_0()
{    return tracer.get();}
public void curator_f35_0(TracerDriver tracer)
{    this.tracer.set(tracer);}
public String curator_f36_0()
{    return state.getEnsembleProvider().getConnectionString();}
public int curator_f37_0()
{    return connectionTimeoutMs;}
public void curator_f38_0() throws Exception
{    state.reset();}
public long curator_f39_0()
{    return state.getInstanceIndex();}
public ConnectionHandlingPolicy curator_f40_0()
{    return connectionHandlingPolicy;}
public int curator_f41_0()
{    return state.getLastNegotiatedSessionTimeoutMs();}
 void curator_f42_0(Watcher watcher)
{    state.addParentWatcher(watcher);}
 void curator_f43_0(Watcher watcher)
{    state.removeParentWatcher(watcher);}
public void curator_f44_0() throws InterruptedException
{    long waitTimeMs = connectionTimeoutMs;    while (!state.isConnected() && (waitTimeMs > 0)) {        final CountDownLatch latch = new CountDownLatch(1);        Watcher tempWatcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        state.addParentWatcher(tempWatcher);        long startTimeMs = System.currentTimeMillis();        long timeoutMs = Math.min(waitTimeMs, 1000);        try {            latch.await(timeoutMs, TimeUnit.MILLISECONDS);        } finally {            state.removeParentWatcher(tempWatcher);        }        long elapsed = Math.max(1, System.currentTimeMillis() - startTimeMs);        waitTimeMs -= elapsed;    }}
public void curator_f45_0(WatchedEvent event)
{    latch.countDown();}
public final void curator_f46_0(String name, long time, TimeUnit unit)
{}
public final void curator_f47_0(String name, int increment)
{}
public String curator_f48_0()
{    return this.name;}
public long curator_f49_0()
{    return this.sessionId;}
public void curator_f50_0()
{    if (this.driver instanceof AdvancedTracerDriver) {        ((AdvancedTracerDriver) this.driver).addEvent(this);    } else {        this.driver.addCount(this.name, 1);    }}
public OperationTrace curator_f51_0(int returnCode)
{    this.returnCode = returnCode;    return this;}
public OperationTrace curator_f52_0(long length)
{    this.requestBytesLength = length;    return this;}
public OperationTrace curator_f53_0(String data)
{    if (data == null) {        return this;    }    try {        this.setRequestBytesLength(data.getBytes("UTF-8").length);    } catch (UnsupportedEncodingException e) {        }    return this;}
public OperationTrace curator_f54_0(byte[] data)
{    if (data == null) {        return this;    }    return this.setRequestBytesLength(data.length);}
public OperationTrace curator_f55_0(long length)
{    this.responseBytesLength = length;    return this;}
public OperationTrace curator_f56_0(byte[] data)
{    if (data == null) {        return this;    }    return this.setResponseBytesLength(data.length);}
public OperationTrace curator_f57_0(String path)
{    this.path = path;    return this;}
public OperationTrace curator_f58_0(boolean withWatcher)
{    this.withWatcher = withWatcher;    return this;}
public OperationTrace curator_f59_0(Stat stat)
{    this.stat = stat;    return this;}
public String curator_f60_0()
{    return this.name;}
public int curator_f61_0()
{    return this.returnCode;}
public long curator_f62_0()
{    return this.latencyMs;}
public long curator_f63_0()
{    return this.requestBytesLength;}
public long curator_f64_0()
{    return this.responseBytesLength;}
public long curator_f65_0()
{    return this.sessionId;}
public String curator_f66_0()
{    return this.path;}
public boolean curator_f67_0()
{    return this.withWatcher;}
public Stat curator_f68_0()
{    return this.stat;}
public void curator_f69_0()
{    long elapsed = System.nanoTime() - startTimeNanos;    this.latencyMs = TimeUnit.MILLISECONDS.convert(elapsed, TimeUnit.NANOSECONDS);    if (this.driver instanceof AdvancedTracerDriver) {        ((AdvancedTracerDriver) this.driver).addTrace(this);    } else {        this.driver.addTrace(this.name, elapsed, TimeUnit.NANOSECONDS);    }}
public String curator_f70_0(String hostname, int port, String uriPath, String mimeType) throws Exception
{    URI uri = new URI(useSsl ? "https" : "http", null, hostname, port, uriPath, null, null);    HttpURLConnection connection = (HttpURLConnection) uri.toURL().openConnection();    connection.addRequestProperty("Accept", mimeType);    StringBuilder str = new StringBuilder();    InputStream in = new BufferedInputStream(connection.getInputStream());    try {        for (; ; ) {            int b = in.read();            if (b < 0) {                break;            }            str.append((char) (b & 0xff));        }    } finally {        CloseableUtils.closeQuietly(in);    }    return str.toString();}
public void curator_f71_0(Exhibitors newExhibitors)
{    exhibitors.set(newExhibitors);    masterExhibitors.set(newExhibitors);}
public void curator_f72_0() throws Exception
{    Preconditions.checkState(state.get() == State.LATENT, "Cannot be called after start()");    poll();}
public void curator_f73_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            poll();        }    }, pollingMs, pollingMs, TimeUnit.MILLISECONDS);}
public void curator_f74_0()
{    poll();}
public void curator_f75_0() throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    service.shutdownNow();}
public String curator_f76_0()
{    return connectionString.get();}
public void curator_f77_1(String connectionString)
{    }
public boolean curator_f78_0()
{    return false;}
protected void curator_f79_1()
{    Exhibitors localExhibitors = exhibitors.get();    Map<String, String> values = queryExhibitors(localExhibitors);    int count = getCountFromValues(values);    if (count == 0) {                values = useBackup(localExhibitors);        count = getCountFromValues(values);    }    if (count > 0) {        int port = Integer.parseInt(values.get(VALUE_PORT));        StringBuilder newConnectionString = new StringBuilder();        List<String> newHostnames = Lists.newArrayList();        for (int i = 0; i < count; ++i) {            if (newConnectionString.length() > 0) {                newConnectionString.append(",");            }            String server = values.get(VALUE_SERVER_PREFIX + i);            newConnectionString.append(server).append(":").append(port);            newHostnames.add(server);        }        String newConnectionStringValue = newConnectionString.toString();        if (!newConnectionStringValue.equals(connectionString.get())) {                    }        Exhibitors newExhibitors = new Exhibitors(newHostnames, localExhibitors.getRestPort(), new Exhibitors.BackupConnectionStringProvider() {            @Override            public String getBackupConnectionString() throws Exception {                                return masterExhibitors.get().getBackupConnectionString();            }        });        connectionString.set(newConnectionStringValue);        exhibitors.set(newExhibitors);    }}
public String curator_f80_0() throws Exception
{        return masterExhibitors.get().getBackupConnectionString();}
private int curator_f81_0(Map<String, String> values)
{    try {        return Integer.parseInt(values.get(VALUE_COUNT));    } catch (NumberFormatException e) {        }    return 0;}
private Map<String, String> curator_f82_1(Exhibitors localExhibitors)
{    Map<String, String> values = newValues();    try {        String backupConnectionString = localExhibitors.getBackupConnectionString();        int thePort = -1;        int count = 0;        for (String spec : backupConnectionString.split(",")) {            spec = spec.trim();            String[] parts = spec.split(":");            if (parts.length == 2) {                String hostname = parts[0];                int port = Integer.parseInt(parts[1]);                if (thePort < 0) {                    thePort = port;                } else if (port != thePort) {                                    }                values.put(VALUE_SERVER_PREFIX + count, hostname);                ++count;            } else {                            }        }        values.put(VALUE_COUNT, Integer.toString(count));        values.put(VALUE_PORT, Integer.toString(thePort));    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return values;}
private Map<String, String> curator_f83_0()
{    Map<String, String> values = Maps.newHashMap();    values.put(VALUE_COUNT, "0");    return values;}
private static Map<String, String> curator_f84_0(String str) throws UnsupportedEncodingException
{    Map<String, String> values = Maps.newHashMap();    for (String spec : str.split("&")) {        String[] parts = spec.split("=");        if (parts.length == 2) {            values.put(parts[0], URLDecoder.decode(parts[1], "UTF-8"));        }    }    return values;}
private Map<String, String> curator_f85_1(Exhibitors localExhibitors)
{    Map<String, String> values = newValues();    long start = System.currentTimeMillis();    int retries = 0;    boolean done = false;    while (!done) {        List<String> hostnames = Lists.newArrayList(localExhibitors.getHostnames());        if (hostnames.size() == 0) {            done = true;        } else {            String hostname = hostnames.get(random.nextInt(hostnames.size()));            try {                String encoded = restClient.getRaw(hostname, localExhibitors.getRestPort(), restUriPath, MIME_TYPE);                values.putAll(decodeExhibitorList(encoded));                done = true;            } catch (Throwable e) {                ThreadUtils.checkInterrupted(e);                if (retryPolicy.allowRetry(retries++, System.currentTimeMillis() - start, RetryLoop.getDefaultRetrySleeper())) {                                    } else {                                        done = true;                }            }        }    }    return values;}
public Collection<String> curator_f86_0()
{    return hostnames;}
public int curator_f87_0()
{    return restPort;}
public String curator_f88_0() throws Exception
{    return backupConnectionStringProvider.getBackupConnectionString();}
public void curator_f89_0() throws Exception
{}
public void curator_f90_0() throws IOException
{}
public void curator_f91_0(String connectionString)
{    this.connectionString.set(connectionString);}
public String curator_f92_0()
{    return connectionString.get();}
public boolean curator_f93_0()
{    return updateServerListEnabled;}
 ZooKeeper curator_f94_0() throws Exception
{    return (helper != null) ? helper.getZooKeeper() : null;}
 int curator_f95_0()
{    return (helper != null) ? helper.getNegotiatedSessionTimeoutMs() : 0;}
 String curator_f96_0()
{    return (helper != null) ? helper.getConnectionString() : null;}
 String curator_f97_0()
{    String helperConnectionString = (helper != null) ? helper.getConnectionString() : null;    return ((helperConnectionString != null) && !ensembleProvider.getConnectionString().equals(helperConnectionString)) ? helperConnectionString : null;}
 void curator_f98_0(int waitForShutdownTimeoutMs) throws Exception
{    internalClose(waitForShutdownTimeoutMs);    helper = null;}
 void curator_f99_0() throws Exception
{    internalClose(0);            helper = new Helper() {        private volatile ZooKeeper zooKeeperHandle = null;        private volatile String connectionString = null;        @Override        public ZooKeeper getZooKeeper() throws Exception {            synchronized (this) {                if (zooKeeperHandle == null) {                    connectionString = ensembleProvider.getConnectionString();                    zooKeeperHandle = zookeeperFactory.newZooKeeper(connectionString, sessionTimeout, watcher, canBeReadOnly);                }                helper = new Helper() {                    @Override                    public ZooKeeper getZooKeeper() throws Exception {                        return zooKeeperHandle;                    }                    @Override                    public String getConnectionString() {                        return connectionString;                    }                    @Override                    public int getNegotiatedSessionTimeoutMs() {                        return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;                    }                };                return zooKeeperHandle;            }        }        @Override        public String getConnectionString() {            return connectionString;        }        @Override        public int getNegotiatedSessionTimeoutMs() {            return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;        }    };}
public ZooKeeper curator_f100_0() throws Exception
{    synchronized (this) {        if (zooKeeperHandle == null) {            connectionString = ensembleProvider.getConnectionString();            zooKeeperHandle = zookeeperFactory.newZooKeeper(connectionString, sessionTimeout, watcher, canBeReadOnly);        }        helper = new Helper() {            @Override            public ZooKeeper getZooKeeper() throws Exception {                return zooKeeperHandle;            }            @Override            public String getConnectionString() {                return connectionString;            }            @Override            public int getNegotiatedSessionTimeoutMs() {                return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;            }        };        return zooKeeperHandle;    }}
public ZooKeeper curator_f101_0() throws Exception
{    return zooKeeperHandle;}
public String curator_f102_0()
{    return connectionString;}
public int curator_f103_0()
{    return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;}
public String curator_f104_0()
{    return connectionString;}
public int curator_f105_0()
{    return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;}
private void curator_f106_0(int waitForShutdownTimeoutMs) throws Exception
{    try {        ZooKeeper zooKeeper = (helper != null) ? helper.getZooKeeper() : null;        if (zooKeeper != null) {            Watcher dummyWatcher = new Watcher() {                @Override                public void process(WatchedEvent event) {                }            };                        zooKeeper.register(dummyWatcher);            if (waitForShutdownTimeoutMs == 0) {                                zooKeeper.close();            } else {                zooKeeper.close(waitForShutdownTimeoutMs);            }        }    } catch (InterruptedException dummy) {        Thread.currentThread().interrupt();    }}
public void curator_f107_0(WatchedEvent event)
{}
public int curator_f108_0()
{    return maxSleepTimeMs;}
protected long curator_f109_0(int retryCount, long elapsedTimeMs)
{    return Math.min(maxSleepTimeMs, super.getSleepTimeMs(retryCount, elapsedTimeMs));}
public int curator_f110_0()
{    return baseSleepTimeMs;}
protected long curator_f111_1(int retryCount, long elapsedTimeMs)
{        long sleepMs = baseSleepTimeMs * Math.max(1, random.nextInt(1 << (retryCount + 1)));    if (sleepMs > maxSleepMs) {                sleepMs = maxSleepMs;    }    return sleepMs;}
private static int curator_f112_1(int maxRetries)
{    if (maxRetries > MAX_RETRIES_LIMIT) {                maxRetries = MAX_RETRIES_LIMIT;    }    return maxRetries;}
public boolean curator_f113_1(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    try {        sleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();                return false;    }    return true;}
protected long curator_f114_0(int retryCount, long elapsedTimeMs)
{    return sleepMsBetweenRetries;}
public boolean curator_f115_0(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    return super.allowRetry(retryCount, elapsedTimeMs, sleeper) && (elapsedTimeMs < maxElapsedTimeMs);}
protected long curator_f116_0(int retryCount, long elapsedTimeMs)
{    return sleepMsBetweenRetries;}
public int curator_f117_0()
{    return n;}
public boolean curator_f118_0(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    if (retryCount < n) {        try {            sleeper.sleepFor(getSleepTimeMs(retryCount, elapsedTimeMs), TimeUnit.MILLISECONDS);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return false;        }        return true;    }    return false;}
public void curator_f119_0(long time, TimeUnit unit) throws InterruptedException
{    unit.sleep(time);}
public static RetrySleeper curator_f120_0()
{    return sleeper;}
public static T curator_f121_0(CuratorZookeeperClient client, Callable<T> proc) throws Exception
{    return client.getConnectionHandlingPolicy().callWithRetry(client, proc);}
public boolean curator_f122_0()
{    return !isDone;}
public void curator_f123_0()
{    isDone = true;}
public static boolean curator_f124_0(int rc)
{    return (rc == KeeperException.Code.CONNECTIONLOSS.intValue()) || (rc == KeeperException.Code.OPERATIONTIMEOUT.intValue()) || (rc == KeeperException.Code.SESSIONMOVED.intValue()) || (rc == KeeperException.Code.SESSIONEXPIRED.intValue()) ||     (rc == -13);}
public static boolean curator_f125_0(Throwable exception)
{    if (exception instanceof KeeperException) {        KeeperException keeperException = (KeeperException) exception;        return shouldRetry(keeperException.code().intValue());    }    return false;}
public void curator_f126_1(Exception exception) throws Exception
{    boolean rethrow = true;    if (isRetryException(exception)) {        if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    }        if (retryPolicy.allowRetry(retryCount++, System.currentTimeMillis() - startTimeMs, sleeper)) {            new EventTrace("retries-allowed", tracer.get()).commit();            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                            }            rethrow = false;        } else {            new EventTrace("retries-disallowed", tracer.get()).commit();            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                            }        }    }    if (rethrow) {        throw exception;    }}
public void curator_f127_0(WatchedEvent event)
{    if (event.getState() == Event.KeeperState.Expired) {        sessionHasFailed.set(true);        failedSessionThreads.add(ourThread);    }}
public static T curator_f128_0(CuratorZookeeperClient client, Mode mode, Callable<T> proc) throws Exception
{    T result = null;    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(mode);    retryLoop.start();    try {        while (retryLoop.shouldContinue()) {            try {                result = proc.call();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                retryLoop.takeException(e);            }        }    } finally {        retryLoop.close();    }    return result;}
 static boolean curator_f129_0()
{    return failedSessionThreads.contains(Thread.currentThread());}
public void curator_f130_0()
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    client.addParentWatcher(watcher);}
public boolean curator_f131_0()
{    boolean localIsDone = isDone.getAndSet(true);    return !localIsDone;}
public void curator_f132_0()
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    failedSessionThreads.remove(ourThread);    client.removeParentWatcher(watcher);}
public void curator_f133_0(Exception exception) throws Exception
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    boolean passUp = true;    if (sessionHasFailed.get()) {        switch(mode) {            case RETRY:                {                    sessionHasFailed.set(false);                    failedSessionThreads.remove(ourThread);                    if (exception instanceof SessionFailedException) {                        isDone.set(false);                        passUp = false;                    }                    break;                }            case FAIL:                {                    break;                }        }    }    if (passUp) {        retryLoop.takeException(exception);    }}
public void curator_f134_0()
{    long elapsed = System.nanoTime() - startTimeNanos;    driver.addTrace(name, elapsed, TimeUnit.NANOSECONDS);}
public boolean curator_f135_0(boolean mayInterruptIfRunning)
{    futures.remove(scheduledFuture);    return scheduledFuture.cancel(mayInterruptIfRunning);}
public boolean curator_f136_0()
{    return scheduledFuture.isCancelled();}
public boolean curator_f137_0()
{    return scheduledFuture.isDone();}
public Void curator_f138_0() throws InterruptedException, ExecutionException
{    return null;}
public Void curator_f139_0(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    return null;}
protected void curator_f140_0()
{    futures.remove(task);}
public boolean curator_f141_0()
{    return !isOpen.get();}
 int curator_f142_0()
{    return futures.size();}
public void curator_f143_1()
{    isOpen.set(false);    Iterator<Future<?>> iterator = futures.iterator();    while (iterator.hasNext()) {        Future<?> future = iterator.next();        iterator.remove();        if (!future.isDone() && !future.isCancelled() && !future.cancel(true)) {                    }    }    if (shutdownOnClose) {        executorService.shutdownNow();    }}
public Future<V> curator_f144_0(Callable<V> task)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<V> futureTask = new InternalFutureTask<V>(new FutureTask<V>(task));    executorService.execute(futureTask);    return futureTask;}
public Future<?> curator_f145_0(Runnable task)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<Void> futureTask = new InternalFutureTask<Void>(new FutureTask<Void>(task, null));    executorService.execute(futureTask);    return futureTask;}
public Future<?> curator_f146_0(Runnable task, long delay, TimeUnit unit)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<Void> futureTask = new InternalFutureTask<Void>(new FutureTask<Void>(task, null));    scheduledExecutorService.schedule(futureTask, delay, unit);    return futureTask;}
public Future<?> curator_f147_0(Runnable task, long initialDelay, long delay, TimeUnit unit)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(task, initialDelay, delay, unit);    return new InternalScheduledFutureTask(scheduledFuture);}
public static void curator_f148_1(Closeable closeable)
{    try {                Closeables.close(closeable, true);    } catch (IOException e) {                            }}
public static boolean curator_f149_0()
{    return !hasZooKeeperAdmin;}
public static void curator_f150_1(ZooKeeper zooKeeper)
{    if (isZK34() || (queueEventMethod == null)) {        InjectSessionExpiration.injectSessionExpiration(zooKeeper);    } else {        try {            WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null);            queueEventMethod.invoke(zooKeeper.getTestable(), event);        } catch (Exception e) {                    }    }}
public void curator_f151_0(String name, long time, TimeUnit unit)
{    if (log.isTraceEnabled()) {        log.trace("Trace: " + name + " - " + TimeUnit.MILLISECONDS.convert(time, unit) + " ms");    }}
public void curator_f152_0(String name, int increment)
{    if (log.isTraceEnabled()) {        log.trace("Counter " + name + ": " + increment);    }}
public ZooKeeper curator_f153_0(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);}
public void curator_f154_0(CuratorZookeeperClient client, String path, final boolean makeLastNode) throws Exception
{}
public void curator_f155_0(CuratorZookeeperClient client) throws Exception
{    Helper localHelper = helper.get();    localHelper.ensure(client, path, makeLastNode);}
public EnsurePath curator_f156_0()
{    return new EnsurePath(path, helper, false, aclProvider);}
public String curator_f157_0()
{    return this.path;}
protected boolean curator_f158_0()
{    return false;}
public synchronized void curator_f159_0(final CuratorZookeeperClient client, final String path, final boolean makeLastNode) throws Exception
{    if (!isSet) {        RetryLoop.callWithRetry(client, new Callable<Object>() {            @Override            public Object call() throws Exception {                ZKPaths.mkdirs(client.getZooKeeper(), path, makeLastNode, aclProvider, asContainers());                helper.set(doNothingHelper);                isSet = true;                return null;            }        });    }}
public Object curator_f160_0() throws Exception
{    ZKPaths.mkdirs(client.getZooKeeper(), path, makeLastNode, aclProvider, asContainers());    helper.set(doNothingHelper);    isSet = true;    return null;}
public void curator_f161_0()
{    if (mainEx != null) {        Throwables.propagate(mainEx);    }}
public void curator_f162_0(Throwable e)
{    if (e instanceof InterruptedException) {        if (mainEx != null) {            e.addSuppressed(mainEx);        }        Thread.currentThread().interrupt();    }    if (mainEx == null) {        mainEx = e;    } else {        mainEx.addSuppressed(e);    }}
public static void curator_f163_0(ZooKeeper zooKeeper)
{    try {        WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null);        ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zooKeeper);        Object eventThread = eventThreadField.get(clientCnxn);        queueEventMethod.invoke(eventThread, event);        } catch (ReflectiveOperationException e) {        throw new RuntimeException("Could not inject session expiration using reflection", e);    }}
public static void curator_f164_0(String path, boolean isSequential) throws IllegalArgumentException
{    validatePath(isSequential ? path + "1" : path);}
public static String curator_f165_0(String path) throws IllegalArgumentException
{    if (path == null) {        throw new IllegalArgumentException("Path cannot be null");    }    if (path.length() == 0) {        throw new IllegalArgumentException("Path length must be > 0");    }    if (path.charAt(0) != '/') {        throw new IllegalArgumentException("Path must start with / character");    }    if (path.length() == 1) {                return path;    }    if (path.charAt(path.length() - 1) == '/') {        throw new IllegalArgumentException("Path must not end with / character");    }    String reason = null;    char lastc = '/';    char[] chars = path.toCharArray();    char c;    for (int i = 1; i < chars.length; lastc = chars[i], i++) {        c = chars[i];        if (c == 0) {            reason = "null character not allowed @" + i;            break;        } else if (c == '/' && lastc == '/') {            reason = "empty node name specified @" + i;            break;        } else if (c == '.' && lastc == '.') {            if (chars[i - 2] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c == '.') {            if (chars[i - 1] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c > '\u0000' && c < '\u001f' || c > '\u007f' && c < '\u009F' || c > '\ud800' && c < '\uf8ff' || c > '\ufff0' && c < '\uffff') {            reason = "invalid charater @" + i;            break;        }    }    if (reason != null) {        throw new IllegalArgumentException("Invalid path string \"" + path + "\" caused by " + reason);    }    return path;}
public static boolean curator_f166_0(Throwable e)
{    if (e instanceof InterruptedException) {        Thread.currentThread().interrupt();        return true;    }    return false;}
public static ExecutorService curator_f167_0(String processName)
{    return Executors.newSingleThreadExecutor(newThreadFactory(processName));}
public static ExecutorService curator_f168_0(int qty, String processName)
{    return Executors.newFixedThreadPool(qty, newThreadFactory(processName));}
public static ScheduledExecutorService curator_f169_0(String processName)
{    return Executors.newSingleThreadScheduledExecutor(newThreadFactory(processName));}
public static ScheduledExecutorService curator_f170_0(int qty, String processName)
{    return Executors.newScheduledThreadPool(qty, newThreadFactory(processName));}
public static ThreadFactory curator_f171_0(String processName)
{    return newGenericThreadFactory("Curator-" + processName);}
public static ThreadFactory curator_f172_1(String processName)
{    Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {        @Override        public void uncaughtException(Thread t, Throwable e) {                        Throwables.propagate(e);        }    };    return new ThreadFactoryBuilder().setNameFormat(processName + "-%d").setDaemon(true).setUncaughtExceptionHandler(uncaughtExceptionHandler).build();}
public void curator_f173_1(Thread t, Throwable e)
{        Throwables.propagate(e);}
public static String curator_f174_0(Class<?> clazz)
{    if (clazz.isAnonymousClass()) {        return getProcessName(clazz.getEnclosingClass());    }    return clazz.getSimpleName();}
public static CreateMode curator_f175_0()
{    return CreateModeHolder.containerCreateMode;}
public static boolean curator_f176_0()
{    return getContainerCreateMode() != NON_CONTAINER_MODE;}
public static String curator_f177_0(String namespace, String path)
{    return fixForNamespace(namespace, path, false);}
public static String curator_f178_0(String namespace, String path, boolean isSequential)
{        PathUtils.validatePath(path, isSequential);    if (namespace != null) {        return makePath(namespace, path);    }    return path;}
public static String curator_f179_0(String path)
{    PathUtils.validatePath(path);    int i = path.lastIndexOf(PATH_SEPARATOR_CHAR);    if (i < 0) {        return path;    }    if ((i + 1) >= path.length()) {        return "";    }    return path.substring(i + 1);}
public String curator_f180_0()
{    return path;}
public String curator_f181_0()
{    return node;}
public int curator_f182_0()
{    final int prime = 31;    int result = 1;    result = prime * result + node.hashCode();    result = prime * result + path.hashCode();    return result;}
public boolean curator_f183_0(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PathAndNode other = (PathAndNode) obj;    if (!node.equals(other.node)) {        return false;    }    if (!path.equals(other.path)) {        return false;    }    return true;}
public String curator_f184_0()
{    return "PathAndNode [path=" + path + ", node=" + node + "]";}
public static PathAndNode curator_f185_0(String path)
{    PathUtils.validatePath(path);    int i = path.lastIndexOf(PATH_SEPARATOR_CHAR);    if (i < 0) {        return new PathAndNode(path, "");    }    if ((i + 1) >= path.length()) {        return new PathAndNode(PATH_SEPARATOR, "");    }    String node = path.substring(i + 1);    String parentPath = (i > 0) ? path.substring(0, i) : PATH_SEPARATOR;    return new PathAndNode(parentPath, node);}
public static String curator_f186_0(String path)
{    int length = path.length();    return length > SEQUENTIAL_SUFFIX_DIGITS ? path.substring(length - SEQUENTIAL_SUFFIX_DIGITS) : path;}
public static List<String> curator_f187_0(String path)
{    PathUtils.validatePath(path);    return PATH_SPLITTER.splitToList(path);}
public static void curator_f188_0(ZooKeeper zookeeper, String path) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, true, null, false);}
public static void curator_f189_0(ZooKeeper zookeeper, String path, boolean makeLastNode) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, makeLastNode, null, false);}
public static void curator_f190_0(ZooKeeper zookeeper, String path, boolean makeLastNode, InternalACLProvider aclProvider) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, makeLastNode, aclProvider, false);}
public static void curator_f191_0(ZooKeeper zookeeper, String path, boolean makeLastNode, InternalACLProvider aclProvider, boolean asContainers) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);        int pos = 1;    do {        pos = path.indexOf(PATH_SEPARATOR_CHAR, pos + 1);        if (pos == -1) {            if (makeLastNode) {                pos = path.length();            } else {                break;            }        }        String subPath = path.substring(0, pos);        if (zookeeper.exists(subPath, false) == null) {            try {                List<ACL> acl = null;                if (aclProvider != null) {                    acl = aclProvider.getAclForPath(subPath);                    if (acl == null) {                        acl = aclProvider.getDefaultAcl();                    }                }                if (acl == null) {                    acl = ZooDefs.Ids.OPEN_ACL_UNSAFE;                }                zookeeper.create(subPath, new byte[0], acl, getCreateMode(asContainers));            } catch (KeeperException.NodeExistsException e) {                        }        }    } while (pos < path.length());}
public static void curator_f192_0(ZooKeeper zookeeper, String path, boolean deleteSelf) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);    List<String> children;    try {        children = zookeeper.getChildren(path, null);    } catch (KeeperException.NoNodeException e) {                return;    }    for (String child : children) {        String fullPath = makePath(path, child);        deleteChildren(zookeeper, fullPath, true);    }    if (deleteSelf) {        try {            zookeeper.delete(path, -1);        } catch (KeeperException.NotEmptyException e) {                        deleteChildren(zookeeper, path, true);        } catch (KeeperException.NoNodeException e) {                }    }}
public static List<String> curator_f193_0(ZooKeeper zookeeper, String path) throws InterruptedException, KeeperException
{    List<String> children = zookeeper.getChildren(path, false);    List<String> sortedList = Lists.newArrayList(children);    Collections.sort(sortedList);    return sortedList;}
public static String curator_f194_0(String parent, String child)
{        int maxPathLength = nullableStringLength(parent) + nullableStringLength(child) + 2;        StringBuilder path = new StringBuilder(maxPathLength);    joinPath(path, parent, child);    return path.toString();}
public static String curator_f195_0(String parent, String firstChild, String... restChildren)
{        int maxPathLength = nullableStringLength(parent) + nullableStringLength(firstChild) + 2;    if (restChildren != null) {        for (String child : restChildren) {                        maxPathLength += nullableStringLength(child) + 1;        }    }        StringBuilder path = new StringBuilder(maxPathLength);    joinPath(path, parent, firstChild);    if (restChildren == null) {        return path.toString();    } else {        for (String child : restChildren) {            joinPath(path, "", child);        }        return path.toString();    }}
private static int curator_f196_0(String s)
{    return s != null ? s.length() : 0;}
private static void curator_f197_0(StringBuilder path, String parent, String child)
{        if ((parent != null) && (parent.length() > 0)) {        if (parent.charAt(0) != PATH_SEPARATOR_CHAR) {            path.append(PATH_SEPARATOR_CHAR);        }        if (parent.charAt(parent.length() - 1) == PATH_SEPARATOR_CHAR) {            path.append(parent, 0, parent.length() - 1);        } else {            path.append(parent);        }    }    if ((child == null) || (child.length() == 0) || (child.length() == 1 && child.charAt(0) == PATH_SEPARATOR_CHAR)) {                if (path.length() == 0) {            path.append(PATH_SEPARATOR_CHAR);        }        return;    }        path.append(PATH_SEPARATOR_CHAR);    int childAppendBeginIndex;    if (child.charAt(0) == PATH_SEPARATOR_CHAR) {        childAppendBeginIndex = 1;    } else {        childAppendBeginIndex = 0;    }    int childAppendEndIndex;    if (child.charAt(child.length() - 1) == PATH_SEPARATOR_CHAR) {        childAppendEndIndex = child.length() - 1;    } else {        childAppendEndIndex = child.length();    }        path.append(child, childAppendBeginIndex, childAppendEndIndex);}
private static CreateMode curator_f198_0(boolean asContainers)
{    return asContainers ? getContainerCreateMode() : CreateMode.PERSISTENT;}
public void curator_f199_0() throws Exception
{    final ZooKeeper mockZookeeper = Mockito.mock(ZooKeeper.class);    ZookeeperFactory zookeeperFactory = new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception {            return mockZookeeper;        }    };    CuratorZookeeperClient client = new CuratorZookeeperClient(zookeeperFactory, new FixedEnsembleProvider(server.getConnectString()), 10000, 10000, null, new RetryOneTime(1), false);    client.start();    Assert.assertEquals(client.getZooKeeper(), mockZookeeper);}
public ZooKeeper curator_f200_0(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    return mockZookeeper;}
public void curator_f201_0() throws Exception
{        final Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getState() == Event.KeeperState.Expired) {                latch.countDown();            }        }    };    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), watcher, new RetryOneTime(2));    client.start();    try {        final AtomicBoolean firstTime = new AtomicBoolean(true);        RetryLoop.callWithRetry(client, new Callable<Object>() {            @Override            public Object call() throws Exception {                if (firstTime.compareAndSet(true, false)) {                    try {                        client.getZooKeeper().create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    } catch (KeeperException.NodeExistsException ignore) {                                        }                    Compatibility.injectSessionExpiration(client.getZooKeeper());                    Assert.assertTrue(timing.awaitLatch(latch));                }                ZooKeeper zooKeeper = client.getZooKeeper();                client.blockUntilConnectedOrTimedOut();                Assert.assertNotNull(zooKeeper.exists("/foo", false));                return null;            }        });    } finally {        client.close();    }}
public void curator_f202_0(WatchedEvent event)
{    if (event.getState() == Event.KeeperState.Expired) {        latch.countDown();    }}
public Object curator_f203_0() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        try {            client.getZooKeeper().create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ignore) {                }        Compatibility.injectSessionExpiration(client.getZooKeeper());        Assert.assertTrue(timing.awaitLatch(latch));    }    ZooKeeper zooKeeper = client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNotNull(zooKeeper.exists("/foo", false));    return null;}
public void curator_f204_0() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        byte[] writtenData = { 1, 2, 3 };        client.getZooKeeper().create("/test", writtenData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Thread.sleep(1000);        server.stop();        Thread.sleep(1000);        server.restart();        Assert.assertTrue(client.blockUntilConnectedOrTimedOut());        byte[] readData = client.getZooKeeper().getData("/test", false, null);        Assert.assertEquals(readData, writtenData);    } finally {        client.close();    }}
public void curator_f205_0() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        String path = client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Assert.assertEquals(path, "/test");    } finally {        client.close();    }}
public void curator_f206_0() throws Exception
{    final int CONNECTION_TIMEOUT_MS = 4000;    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, CONNECTION_TIMEOUT_MS, null, new RetryOneTime(1));    try {        Assert.assertFalse(client.isConnected());        client.start();        outer: do {            for (int i = 0; i < (CONNECTION_TIMEOUT_MS / 1000); ++i) {                if (client.isConnected()) {                    break outer;                }                Thread.sleep(CONNECTION_TIMEOUT_MS);            }            Assert.fail();        } while (false);    } finally {        client.close();    }}
public String curator_f207_0() throws Exception
{    return null;}
public void curator_f208_0() throws Exception
{    final AtomicReference<String> backupConnectionString = new AtomicReference<String>("backup1:1");    final AtomicReference<String> connectionString = new AtomicReference<String>("count=1&port=2&server0=localhost");    Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, new Exhibitors.BackupConnectionStringProvider() {        @Override        public String getBackupConnectionString() {            return backupConnectionString.get();        }    });    ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {        @Override        public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {            String localConnectionString = connectionString.get();            if (localConnectionString == null) {                throw new IOException();            }            return localConnectionString;        }    };    final Semaphore semaphore = new Semaphore(0);    ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1)) {        @Override        protected void poll() {            super.poll();            semaphore.release();        }    };    provider.pollForInitialEnsemble();    try {        provider.start();        Assert.assertEquals(provider.getConnectionString(), "localhost:2");        connectionString.set(null);        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "backup1:1");        backupConnectionString.set("backup2:2");        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "backup2:2");        connectionString.set("count=1&port=3&server0=localhost3");        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "localhost3:3");    } finally {        CloseableUtils.closeQuietly(provider);    }}
public String curator_f209_0()
{    return backupConnectionString.get();}
public String curator_f210_0(String hostname, int port, String uriPath, String mimeType) throws Exception
{    String localConnectionString = connectionString.get();    if (localConnectionString == null) {        throw new IOException();    }    return localConnectionString;}
protected void curator_f211_0()
{    super.poll();    semaphore.release();}
public void curator_f212_0() throws Exception
{    TestingServer secondServer = new TestingServer();    try {        String mainConnectionString = "count=1&port=" + server.getPort() + "&server0=localhost";        String secondConnectionString = "count=1&port=" + secondServer.getPort() + "&server0=localhost";        final Semaphore semaphore = new Semaphore(0);        final AtomicReference<String> connectionString = new AtomicReference<String>(mainConnectionString);        Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, dummyConnectionStringProvider);        ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {            @Override            public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {                semaphore.release();                return connectionString.get();            }        };        ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1));        provider.pollForInitialEnsemble();        Timing timing = new Timing().multiple(4);        final CuratorZookeeperClient client = new CuratorZookeeperClient(provider, timing.session(), timing.connection(), null, new RetryOneTime(2));        client.start();        try {            RetryLoop.callWithRetry(client, new Callable<Object>() {                @Override                public Object call() throws Exception {                    client.getZooKeeper().create("/test", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    return null;                }            });            connectionString.set(secondConnectionString);            semaphore.drainPermits();            semaphore.acquire();                        server.stop();            Stat stat = RetryLoop.callWithRetry(client, new Callable<Stat>() {                @Override                public Stat call() throws Exception {                    return client.getZooKeeper().exists("/test", false);                }            });                        Assert.assertNull(stat);        } finally {            client.close();        }    } finally {        CloseableUtils.closeQuietly(secondServer);    }}
public String curator_f213_0(String hostname, int port, String uriPath, String mimeType) throws Exception
{    semaphore.release();    return connectionString.get();}
public Object curator_f214_0() throws Exception
{    client.getZooKeeper().create("/test", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    return null;}
public Stat curator_f215_0() throws Exception
{    return client.getZooKeeper().exists("/test", false);}
public void curator_f216_0() throws Exception
{    Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, dummyConnectionStringProvider);    ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {        @Override        public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {            return "count=1&port=" + server.getPort() + "&server0=localhost";        }    };    ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1));    provider.pollForInitialEnsemble();    Timing timing = new Timing();    CuratorZookeeperClient client = new CuratorZookeeperClient(provider, timing.session(), timing.connection(), null, new ExponentialBackoffRetry(timing.milliseconds(), 3));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        client.getZooKeeper().exists("/", false);    } catch (Exception e) {        Assert.fail("provider.getConnectionString(): " + provider.getConnectionString() + " server.getPort(): " + server.getPort(), e);    } finally {        client.close();    }}
public String curator_f217_0(String hostname, int port, String uriPath, String mimeType) throws Exception
{    return "count=1&port=" + server.getPort() + "&server0=localhost";}
public void curator_f218_0() throws Exception
{    ZooKeeper client = mock(ZooKeeper.class, Mockito.RETURNS_MOCKS);    CuratorZookeeperClient curator = mock(CuratorZookeeperClient.class);    RetryPolicy retryPolicy = new RetryOneTime(1);    RetryLoop retryLoop = new RetryLoop(retryPolicy, null);    when(curator.getConnectionHandlingPolicy()).thenReturn(new StandardConnectionHandlingPolicy());    when(curator.getZooKeeper()).thenReturn(client);    when(curator.getRetryPolicy()).thenReturn(retryPolicy);    when(curator.newRetryLoop()).thenReturn(retryLoop);    Stat fakeStat = mock(Stat.class);    when(client.exists(Mockito.<String>any(), anyBoolean())).thenReturn(fakeStat);    EnsurePath ensurePath = new EnsurePath("/one/two/three");    ensurePath.ensure(curator);    verify(client, times(3)).exists(Mockito.<String>any(), anyBoolean());    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);}
public void curator_f219_0() throws Exception
{    ZooKeeper client = mock(ZooKeeper.class, Mockito.RETURNS_MOCKS);    RetryPolicy retryPolicy = new RetryOneTime(1);    RetryLoop retryLoop = new RetryLoop(retryPolicy, null);    final CuratorZookeeperClient curator = mock(CuratorZookeeperClient.class);    when(curator.getConnectionHandlingPolicy()).thenReturn(new StandardConnectionHandlingPolicy());    when(curator.getZooKeeper()).thenReturn(client);    when(curator.getRetryPolicy()).thenReturn(retryPolicy);    when(curator.newRetryLoop()).thenReturn(retryLoop);    final Stat fakeStat = mock(Stat.class);    final CountDownLatch startedLatch = new CountDownLatch(2);    final CountDownLatch finishedLatch = new CountDownLatch(2);    final Semaphore semaphore = new Semaphore(0);    when(client.exists(Mockito.<String>any(), anyBoolean())).thenAnswer(new Answer<Stat>() {        @Override        public Stat answer(InvocationOnMock invocation) throws Throwable {            semaphore.acquire();            return fakeStat;        }    });    final EnsurePath ensurePath = new EnsurePath("/one/two/three");    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < 2; ++i) {        service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                startedLatch.countDown();                ensurePath.ensure(curator);                finishedLatch.countDown();                return null;            }        });    }    Assert.assertTrue(startedLatch.await(10, TimeUnit.SECONDS));    semaphore.release(3);    Assert.assertTrue(finishedLatch.await(10, TimeUnit.SECONDS));    verify(client, times(3)).exists(Mockito.<String>any(), anyBoolean());    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);}
public Stat curator_f220_0(InvocationOnMock invocation) throws Throwable
{    semaphore.acquire();    return fakeStat;}
public Void curator_f221_0() throws Exception
{    startedLatch.countDown();    ensurePath.ensure(curator);    finishedLatch.countDown();    return null;}
public void curator_f222_0()
{    RetrySleeper sleeper = new RetrySleeper() {        @Override        public void sleepFor(long time, TimeUnit unit) throws InterruptedException {            Assert.assertTrue(unit.toMillis(time) <= 100);        }    };    ExponentialBackoffRetry retry = new ExponentialBackoffRetry(1, Integer.MAX_VALUE, 100);    for (int i = 0; i >= 0; ++i) {        retry.allowRetry(i, 0, sleeper);    }}
public void curator_f223_0(long time, TimeUnit unit) throws InterruptedException
{    Assert.assertTrue(unit.toMillis(time) <= 100);}
public void curator_f224_0() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 5000, 5000, null, new RetryOneTime(1));    client.start();    try {        int loopCount = 0;        RetryLoop retryLoop = client.newRetryLoop();        outer: while (retryLoop.shouldContinue()) {            ++loopCount;            switch(loopCount) {                case 1:                    {                        server.stop();                        break;                    }                case 2:                    {                        server.restart();                        break;                    }                case 3:                case 4:                    {                                                break;                    }                default:                    {                        Assert.fail();                        break outer;                    }            }            try {                client.blockUntilConnectedOrTimedOut();                client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                retryLoop.markComplete();            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(loopCount >= 2);    } finally {        client.close();    }}
public void curator_f225_0() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        int loopCount = 0;        RetryLoop retryLoop = client.newRetryLoop();        while (retryLoop.shouldContinue()) {            if (++loopCount > 2) {                Assert.fail();                break;            }            try {                client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                retryLoop.markComplete();            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(loopCount > 0);    } finally {        client.close();    }}
public void curator_f226_0() throws Exception
{    int retryIntervalMs = 1;    RetrySleeper sleeper = Mockito.mock(RetrySleeper.class);    RetryForever retryForever = new RetryForever(retryIntervalMs);    for (int i = 0; i < 10; i++) {        boolean allowed = retryForever.allowRetry(i, 0, sleeper);        Assert.assertTrue(allowed);        Mockito.verify(sleeper, times(i + 1)).sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS);    }}
public void curator_f227_0() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.RETRY);    retryLoop.start();    try {        client.start();        final AtomicBoolean secondWasDone = new AtomicBoolean(false);        final AtomicBoolean firstTime = new AtomicBoolean(true);        while (retryLoop.shouldContinue()) {            try {                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        if (firstTime.compareAndSet(true, false)) {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                        }                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        return null;                    }                });                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        Assert.assertFalse(firstTime.get());                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        secondWasDone.set(true);                        return null;                    }                });            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(secondWasDone.get());    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
public Void curator_f228_0() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));        Compatibility.injectSessionExpiration(client.getZooKeeper());        client.getZooKeeper();        client.blockUntilConnectedOrTimedOut();    }    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
public Void curator_f229_0() throws Exception
{    Assert.assertFalse(firstTime.get());    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    secondWasDone.set(true);    return null;}
public void curator_f230_0() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.RETRY);    retryLoop.start();    try {        client.start();        final AtomicBoolean secondWasDone = new AtomicBoolean(false);        final AtomicBoolean firstTime = new AtomicBoolean(true);        SessionFailRetryLoop.callWithRetry(client, SessionFailRetryLoop.Mode.RETRY, new Callable<Object>() {            @Override            public Object call() throws Exception {                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        if (firstTime.compareAndSet(true, false)) {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                        }                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        return null;                    }                });                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        Assert.assertFalse(firstTime.get());                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        secondWasDone.set(true);                        return null;                    }                });                return null;            }        });        Assert.assertTrue(secondWasDone.get());    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
public Object curator_f231_0() throws Exception
{    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            if (firstTime.compareAndSet(true, false)) {                Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                Compatibility.injectSessionExpiration(client.getZooKeeper());                client.getZooKeeper();                client.blockUntilConnectedOrTimedOut();            }            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            return null;        }    });    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            Assert.assertFalse(firstTime.get());            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            secondWasDone.set(true);            return null;        }    });    return null;}
public Void curator_f232_0() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));        Compatibility.injectSessionExpiration(client.getZooKeeper());        client.getZooKeeper();        client.blockUntilConnectedOrTimedOut();    }    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
public Void curator_f233_0() throws Exception
{    Assert.assertFalse(firstTime.get());    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    secondWasDone.set(true);    return null;}
public void curator_f234_0() throws Exception
{    final Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.FAIL);    retryLoop.start();    try {        client.start();        try {            while (retryLoop.shouldContinue()) {                try {                    RetryLoop.callWithRetry(client, new Callable<Void>() {                        @Override                        public Void call() throws Exception {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            timing.sleepABit();                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            return null;                        }                    });                } catch (Exception e) {                    retryLoop.takeException(e);                }            }            Assert.fail();        } catch (SessionFailRetryLoop.SessionFailedException dummy) {                }    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
public Void curator_f235_0() throws Exception
{    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    Compatibility.injectSessionExpiration(client.getZooKeeper());    timing.sleepABit();    client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
public void curator_f236_0() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.FAIL);    retryLoop.start();    try {        client.start();        try {            SessionFailRetryLoop.callWithRetry(client, SessionFailRetryLoop.Mode.FAIL, new Callable<Object>() {                @Override                public Object call() throws Exception {                    RetryLoop.callWithRetry(client, new Callable<Void>() {                        @Override                        public Void call() throws Exception {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            return null;                        }                    });                    return null;                }            });        } catch (SessionFailRetryLoop.SessionFailedException dummy) {                }    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
public Object curator_f237_0() throws Exception
{    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            Compatibility.injectSessionExpiration(client.getZooKeeper());            client.getZooKeeper();            client.blockUntilConnectedOrTimedOut();            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            return null;        }    });    return null;}
public Void curator_f238_0() throws Exception
{    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    Compatibility.injectSessionExpiration(client.getZooKeeper());    client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
public void curator_f239_0()
{    executorService = Executors.newFixedThreadPool(QTY * 2);}
public void curator_f240_0()
{    executorService.shutdownNow();}
public void curator_f241_0() throws InterruptedException
{    try {        CloseableExecutorService service = new CloseableExecutorService(executorService);        CountDownLatch startLatch = new CountDownLatch(QTY);        CountDownLatch latch = new CountDownLatch(QTY);        for (int i = 0; i < QTY; ++i) {            submitRunnable(service, startLatch, latch);        }        Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));        service.close();        Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));    } catch (AssertionError e) {        throw e;    } catch (Throwable e) {        e.printStackTrace();    }}
public void curator_f242_0() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    final CountDownLatch startLatch = new CountDownLatch(QTY);    final CountDownLatch latch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                } finally {                    latch.countDown();                }                return null;            }        });    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    service.close();    Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));}
public Void curator_f243_0() throws Exception
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        latch.countDown();    }    return null;}
public void curator_f244_0() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    List<Future<?>> futures = Lists.newArrayList();    final CountDownLatch startLatch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        Future<?> future = service.submit(new Runnable() {            @Override            public void run() {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }        });        futures.add(future);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    for (Future<?> future : futures) {        future.cancel(true);    }    Assert.assertEquals(service.size(), 0);}
public void curator_f245_0()
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
public void curator_f246_0() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    final CountDownLatch startLatch = new CountDownLatch(QTY);    List<Future<?>> futures = Lists.newArrayList();    for (int i = 0; i < QTY; ++i) {        Future<?> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }                return null;            }        });        futures.add(future);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    for (Future<?> future : futures) {        future.cancel(true);    }    Assert.assertEquals(service.size(), 0);}
public Void curator_f247_0() throws Exception
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return null;}
public void curator_f248_0() throws InterruptedException
{    final CountDownLatch outsideLatch = new CountDownLatch(1);    executorService.submit(new Runnable() {        @Override        public void run() {            try {                Thread.currentThread().join();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {                outsideLatch.countDown();            }        }    });    CloseableExecutorService service = new CloseableExecutorService(executorService);    CountDownLatch startLatch = new CountDownLatch(QTY);    CountDownLatch latch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        submitRunnable(service, startLatch, latch);    }    while (service.size() < QTY) {        Thread.sleep(100);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    service.close();    Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));    Assert.assertEquals(outsideLatch.getCount(), 1);}
public void curator_f249_0()
{    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        outsideLatch.countDown();    }}
private void curator_f250_0(CloseableExecutorService service, final CountDownLatch startLatch, final CountDownLatch latch)
{    service.submit(new Runnable() {        @Override        public void run() {            try {                startLatch.countDown();                Thread.sleep(100000);            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {                latch.countDown();            }        }    });}
public void curator_f251_0()
{    try {        startLatch.countDown();        Thread.sleep(100000);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        latch.countDown();    }}
public void curator_f252_0()
{    executorService = Executors.newScheduledThreadPool(QTY * 2);}
public void curator_f253_0()
{    executorService.shutdownNow();}
public void curator_f254_0() throws InterruptedException
{    CloseableScheduledExecutorService service = new CloseableScheduledExecutorService(executorService);    final CountDownLatch latch = new CountDownLatch(QTY);    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            latch.countDown();        }    }, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    Assert.assertTrue(latch.await((QTY * 2) * DELAY_MS, TimeUnit.MILLISECONDS));}
public void curator_f255_0()
{    latch.countDown();}
public void curator_f256_0() throws InterruptedException
{    final AtomicInteger outerCounter = new AtomicInteger(0);    Runnable command = new Runnable() {        @Override        public void run() {            outerCounter.incrementAndGet();        }    };    executorService.scheduleWithFixedDelay(command, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    CloseableScheduledExecutorService service = new CloseableScheduledExecutorService(executorService);    final AtomicInteger innerCounter = new AtomicInteger(0);    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            innerCounter.incrementAndGet();        }    }, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    Thread.sleep(DELAY_MS * 4);    service.close();    Thread.sleep(DELAY_MS * 2);    int innerValue = innerCounter.get();    Assert.assertTrue(innerValue > 0);    int value = outerCounter.get();    Thread.sleep(DELAY_MS * 2);    int newValue = outerCounter.get();    Assert.assertTrue(newValue > value);    Assert.assertEquals(innerValue, innerCounter.get());    value = newValue;    Thread.sleep(DELAY_MS * 2);    newValue = outerCounter.get();    Assert.assertTrue(newValue > value);    Assert.assertEquals(innerValue, innerCounter.get());}
public void curator_f257_0()
{    outerCounter.incrementAndGet();}
public void curator_f258_0()
{    innerCounter.incrementAndGet();}
public void curator_f259_0()
{    Assert.assertEquals(ZKPaths.makePath(null, "/"), "/");    Assert.assertEquals(ZKPaths.makePath("", null), "/");    Assert.assertEquals(ZKPaths.makePath("/", null), "/");    Assert.assertEquals(ZKPaths.makePath(null, null), "/");    Assert.assertEquals(ZKPaths.makePath("/", "/"), "/");    Assert.assertEquals(ZKPaths.makePath("", "/"), "/");    Assert.assertEquals(ZKPaths.makePath("/", ""), "/");    Assert.assertEquals(ZKPaths.makePath("", ""), "/");    Assert.assertEquals(ZKPaths.makePath("foo", ""), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", "/"), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", ""), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", "/"), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("", "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("/", "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("", "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("/", "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "/bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "/bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "bar/"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo/", "/bar/"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", "baz"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", "baz", "qux"), "/foo/bar/baz/qux");    Assert.assertEquals(ZKPaths.makePath("/foo", "/bar", "/baz"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("/foo/", "/bar/", "/baz/"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("foo", null, null), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", null), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", null, "baz"), "/foo/baz");}
public void curator_f260_0()
{    Assert.assertEquals(ZKPaths.split("/"), Collections.emptyList());    Assert.assertEquals(ZKPaths.split("/test"), Collections.singletonList("test"));    Assert.assertEquals(ZKPaths.split("/test/one"), Arrays.asList("test", "one"));    Assert.assertEquals(ZKPaths.split("/test/one/two"), Arrays.asList("test", "one", "two"));}
public static AsyncCuratorFramework curator_f261_0(CuratorFramework client)
{        return AsyncCuratorFramework.wrap(client);}
public static void curator_f262_0(CuratorFramework client, String path, byte[] payload)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath(path, payload).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            System.out.println("Created node name is: " + name);        }    });}
public static void curator_f263_0(CuratorFramework client, String path)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);                        async.create().forPath(path).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            handleWatchedStage(async.watched().checkExists().forPath(path).event());        }    });}
public static void curator_f264_0(CuratorFramework client, String path)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.create().forPath(path).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {                                    async.with(WatchMode.successOnly).watched().checkExists().forPath(path).event().thenAccept(event -> {                System.out.println(event.getType());                System.out.println(event);            });        }    });}
private static void curator_f265_0(CompletionStage<WatchedEvent> watchedStage)
{                watchedStage.thenAccept(event -> {        System.out.println(event.getType());        System.out.println(event);        });                watchedStage.exceptionally(exception -> {        AsyncEventException asyncEx = (AsyncEventException) exception;                asyncEx.printStackTrace();        handleWatchedStage(asyncEx.reset());        return null;    });}
public static void curator_f266_0(String[] args) throws Exception
{    TestingServer server = new TestingServer();    CuratorFramework client = null;    PathChildrenCache cache = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));        client.start();                cache = new PathChildrenCache(client, PATH, true);        cache.start();        processCommands(client, cache);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(server);    }}
private static void curator_f267_0(PathChildrenCache cache)
{        PathChildrenCacheListener listener = new PathChildrenCacheListener() {        @Override        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {            switch(event.getType()) {                case CHILD_ADDED:                    {                        System.out.println("Node added: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }                case CHILD_UPDATED:                    {                        System.out.println("Node changed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }                case CHILD_REMOVED:                    {                        System.out.println("Node removed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }            }        }    };    cache.getListenable().addListener(listener);}
public void curator_f268_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    switch(event.getType()) {        case CHILD_ADDED:            {                System.out.println("Node added: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }        case CHILD_UPDATED:            {                System.out.println("Node changed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }        case CHILD_REMOVED:            {                System.out.println("Node removed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }    }}
private static void curator_f269_0(CuratorFramework client, PathChildrenCache cache) throws Exception
{        printHelp();    List<ExampleServer> servers = Lists.newArrayList();    try {        addListener(cache);        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        boolean done = false;        while (!done) {            System.out.print("> ");            String line = in.readLine();            if (line == null) {                break;            }            String command = line.trim();            String[] parts = command.split("\\s");            if (parts.length == 0) {                continue;            }            String operation = parts[0];            String[] args = Arrays.copyOfRange(parts, 1, parts.length);            if (operation.equalsIgnoreCase("help") || operation.equalsIgnoreCase("?")) {                printHelp();            } else if (operation.equalsIgnoreCase("q") || operation.equalsIgnoreCase("quit")) {                done = true;            } else if (operation.equals("set")) {                setValue(client, command, args);            } else if (operation.equals("remove")) {                remove(client, command, args);            } else if (operation.equals("list")) {                list(cache);            }                        Thread.sleep(1000);        }    } finally {        for (ExampleServer server : servers) {            CloseableUtils.closeQuietly(server);        }    }}
private static void curator_f270_0(PathChildrenCache cache)
{    if (cache.getCurrentData().size() == 0) {        System.out.println("* empty *");    } else {        for (ChildData data : cache.getCurrentData()) {            System.out.println(data.getPath() + " = " + new String(data.getData()));        }    }}
private static void curator_f271_0(CuratorFramework client, String command, String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("syntax error (expected remove <path>): " + command);        return;    }    String name = args[0];    if (name.contains("/")) {        System.err.println("Invalid node name" + name);        return;    }    String path = ZKPaths.makePath(PATH, name);    try {        client.delete().forPath(path);    } catch (KeeperException.NoNodeException e) {        }}
private static void curator_f272_0(CuratorFramework client, String command, String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("syntax error (expected set <path> <value>): " + command);        return;    }    String name = args[0];    if (name.contains("/")) {        System.err.println("Invalid node name" + name);        return;    }    String path = ZKPaths.makePath(PATH, name);    byte[] bytes = args[1].getBytes();    try {        client.setData().forPath(path, bytes);    } catch (KeeperException.NoNodeException e) {        client.create().creatingParentContainersIfNeeded().forPath(path, bytes);    }}
private static void curator_f273_0()
{    System.out.println("An example of using PathChildrenCache. This example is driven by entering commands at the prompt:\n");    System.out.println("set <name> <value>: Adds or updates a node with the given name");    System.out.println("remove <name>: Deletes the node with the given name");    System.out.println("list: List the nodes/values in the cache");    System.out.println("quit: Quit the example");    System.out.println();}
public static void curator_f274_0(String[] args) throws Exception
{    CuratorFramework client = CreateClientExamples.createSimple("127.0.0.1:2181");    client.getUnhandledErrorListenable().addListener((message, e) -> {        System.err.println("error=" + message);        e.printStackTrace();    });    client.getConnectionStateListenable().addListener((c, newState) -> {        System.out.println("state=" + newState);    });    client.start();    TreeCache cache = TreeCache.newBuilder(client, "/").setCacheData(false).build();    cache.getListenable().addListener((c, event) -> {        if (event.getData() != null) {            System.out.println("type=" + event.getType() + " path=" + event.getData().getPath());        } else {            System.out.println("type=" + event.getType());        }    });    cache.start();    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    in.readLine();}
public static void curator_f275_0(String[] args) throws Exception
{        TestingServer server = new TestingServer();    CuratorFramework client = null;    ServiceDiscovery<InstanceDetails> serviceDiscovery = null;    Map<String, ServiceProvider<InstanceDetails>> providers = Maps.newHashMap();    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));        client.start();        JsonInstanceSerializer<InstanceDetails> serializer = new JsonInstanceSerializer<InstanceDetails>(InstanceDetails.class);        serviceDiscovery = ServiceDiscoveryBuilder.builder(InstanceDetails.class).client(client).basePath(PATH).serializer(serializer).build();        serviceDiscovery.start();        processCommands(serviceDiscovery, providers, client);    } finally {        for (ServiceProvider<InstanceDetails> cache : providers.values()) {            CloseableUtils.closeQuietly(cache);        }        CloseableUtils.closeQuietly(serviceDiscovery);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(server);    }}
private static void curator_f276_0(ServiceDiscovery<InstanceDetails> serviceDiscovery, Map<String, ServiceProvider<InstanceDetails>> providers, CuratorFramework client) throws Exception
{        printHelp();    List<ExampleServer> servers = Lists.newArrayList();    try {        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        boolean done = false;        while (!done) {            System.out.print("> ");            String line = in.readLine();            if (line == null) {                break;            }            String command = line.trim();            String[] parts = command.split("\\s");            if (parts.length == 0) {                continue;            }            String operation = parts[0];            String[] args = Arrays.copyOfRange(parts, 1, parts.length);            if (operation.equalsIgnoreCase("help") || operation.equalsIgnoreCase("?")) {                printHelp();            } else if (operation.equalsIgnoreCase("q") || operation.equalsIgnoreCase("quit")) {                done = true;            } else if (operation.equals("add")) {                addInstance(args, client, command, servers);            } else if (operation.equals("delete")) {                deleteInstance(args, command, servers);            } else if (operation.equals("random")) {                listRandomInstance(args, serviceDiscovery, providers, command);            } else if (operation.equals("list")) {                listInstances(serviceDiscovery);            }        }    } finally {        for (ExampleServer server : servers) {            CloseableUtils.closeQuietly(server);        }    }}
private static void curator_f277_0(String[] args, ServiceDiscovery<InstanceDetails> serviceDiscovery, Map<String, ServiceProvider<InstanceDetails>> providers, String command) throws Exception
{    if (args.length != 1) {        System.err.println("syntax error (expected random <name>): " + command);        return;    }    String serviceName = args[0];    ServiceProvider<InstanceDetails> provider = providers.get(serviceName);    if (provider == null) {        provider = serviceDiscovery.serviceProviderBuilder().serviceName(serviceName).providerStrategy(new RandomStrategy<InstanceDetails>()).build();        providers.put(serviceName, provider);        provider.start();                Thread.sleep(2500);    }    ServiceInstance<InstanceDetails> instance = provider.getInstance();    if (instance == null) {        System.err.println("No instances named: " + serviceName);    } else {        outputInstance(instance);    }}
private static void curator_f278_0(ServiceDiscovery<InstanceDetails> serviceDiscovery) throws Exception
{    try {        Collection<String> serviceNames = serviceDiscovery.queryForNames();        System.out.println(serviceNames.size() + " type(s)");        for (String serviceName : serviceNames) {            Collection<ServiceInstance<InstanceDetails>> instances = serviceDiscovery.queryForInstances(serviceName);            System.out.println(serviceName);            for (ServiceInstance<InstanceDetails> instance : instances) {                outputInstance(instance);            }        }    } finally {        CloseableUtils.closeQuietly(serviceDiscovery);    }}
private static void curator_f279_0(ServiceInstance<InstanceDetails> instance)
{    System.out.println("\t" + instance.getPayload().getDescription() + ": " + instance.buildUriSpec());}
private static void curator_f280_0(String[] args, String command, List<ExampleServer> servers)
{    if (args.length != 1) {        System.err.println("syntax error (expected delete <name>): " + command);        return;    }    final String serviceName = args[0];    ExampleServer server = Iterables.find(servers, new Predicate<ExampleServer>() {        @Override        public boolean apply(ExampleServer server) {            return server.getThisInstance().getName().endsWith(serviceName);        }    }, null);    if (server == null) {        System.err.println("No servers found named: " + serviceName);        return;    }    servers.remove(server);    CloseableUtils.closeQuietly(server);    System.out.println("Removed a random instance of: " + serviceName);}
public boolean curator_f281_0(ExampleServer server)
{    return server.getThisInstance().getName().endsWith(serviceName);}
private static void curator_f282_0(String[] args, CuratorFramework client, String command, List<ExampleServer> servers) throws Exception
{    if (args.length < 2) {        System.err.println("syntax error (expected add <name> <description>): " + command);        return;    }    StringBuilder description = new StringBuilder();    for (int i = 1; i < args.length; ++i) {        if (i > 1) {            description.append(' ');        }        description.append(args[i]);    }    String serviceName = args[0];    ExampleServer server = new ExampleServer(client, PATH, serviceName, description.toString());    servers.add(server);    server.start();    System.out.println(serviceName + " added");}
private static void curator_f283_0()
{    System.out.println("An example of using the ServiceDiscovery APIs. This example is driven by entering commands at the prompt:\n");    System.out.println("add <name> <description>: Adds a mock service with the given name and description");    System.out.println("delete <name>: Deletes one of the mock services with the given name");    System.out.println("list: Lists all the currently registered services");    System.out.println("random <name>: Lists a random instance of the service with the given name");    System.out.println("quit: Quit the example");    System.out.println();}
public ServiceInstance<InstanceDetails> curator_f284_0()
{    return thisInstance;}
public void curator_f285_0() throws Exception
{    serviceDiscovery.start();}
public void curator_f286_0() throws IOException
{    CloseableUtils.closeQuietly(serviceDiscovery);}
public void curator_f287_0(String description)
{    this.description = description;}
public String curator_f288_0()
{    return description;}
public static CuratorFramework curator_f289_0(String connectionString)
{                ExponentialBackoffRetry retryPolicy = new ExponentialBackoffRetry(1000, 3);        return CuratorFrameworkFactory.newClient(connectionString, retryPolicy);}
public static CuratorFramework curator_f290_0(String connectionString, RetryPolicy retryPolicy, int connectionTimeoutMs, int sessionTimeoutMs)
{        return CuratorFrameworkFactory.builder().connectString(connectionString).retryPolicy(retryPolicy).connectionTimeoutMs(connectionTimeoutMs).sessionTimeoutMs(sessionTimeoutMs).build();}
public static void curator_f291_0(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.create().forPath(path, payload);}
public static void curator_f292_0(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.create().withMode(CreateMode.EPHEMERAL).forPath(path, payload);}
public static String curator_f293_0(CuratorFramework client, String path, byte[] payload) throws Exception
{    /*            Protection Mode:            It turns out there is an edge case that exists when creating sequential-ephemeral nodes. The creation            can succeed on the server, but the server can crash before the created node name is returned to the            client. However, the ZK session is still valid so the ephemeral node is not deleted. Thus, there is no            way for the client to determine what node was created for them.            Even without sequential-ephemeral, however, the create can succeed on the sever but the client (for various            reasons) will not know it. Putting the create builder into protection mode works around this. The name of            the node that is created is prefixed with a GUID. If node creation fails the normal retry mechanism will            occur. On the retry, the parent path is first searched for a node that has the GUID in it. If that node is            found, it is assumed to be the lost node that was successfully created on the first try and is returned to            the caller.         */    return client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, payload);}
public static void curator_f294_0(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.setData().forPath(path, payload);}
public static void curator_f295_0(CuratorFramework client, String path, byte[] payload) throws Exception
{        CuratorListener listener = new CuratorListener() {        @Override        public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                }    };    client.getCuratorListenable().addListener(listener);            client.setData().inBackground().forPath(path, payload);}
public void curator_f296_0(CuratorFramework client, CuratorEvent event) throws Exception
{}
public static void curator_f297_0(CuratorFramework client, BackgroundCallback callback, String path, byte[] payload) throws Exception
{        client.setData().inBackground(callback).forPath(path, payload);}
public static void curator_f298_0(CuratorFramework client, String path) throws Exception
{        client.delete().forPath(path);}
public static void curator_f299_0(CuratorFramework client, String path) throws Exception
{        /*            Guaranteed Delete            Solves this edge case: deleting a node can fail due to connection issues. Further, if the node was            ephemeral, the node will not get auto-deleted as the session is still valid. This can wreak havoc            with lock implementations.            When guaranteed is set, Curator will record failed node deletions and attempt to delete them in the            background until successful. NOTE: you will still get an exception when the deletion fails. But, you            can be assured that as long as the CuratorFramework instance is open attempts will be made to delete            the node.         */    client.delete().guaranteed().forPath(path);}
public static List<String> curator_f300_0(CuratorFramework client, String path) throws Exception
{    /**     * Get children and set a watcher on the node. The watcher notification will come through the     * CuratorListener (see setDataAsync() above).     */    return client.getChildren().watched().forPath(path);}
public static List<String> curator_f301_0(CuratorFramework client, String path, Watcher watcher) throws Exception
{    /**     * Get children and set the given watcher on the node.     */    return client.getChildren().usingWatcher(watcher).forPath(path);}
public static Collection<CuratorTransactionResult> curator_f302_0(CuratorFramework client) throws Exception
{        CuratorOp createOp = client.transactionOp().create().forPath("/a/path", "some data".getBytes());    CuratorOp setDataOp = client.transactionOp().setData().forPath("/another/path", "other data".getBytes());    CuratorOp deleteOp = client.transactionOp().delete().forPath("/yet/another/path");    Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp, setDataOp, deleteOp);    for (CuratorTransactionResult result : results) {        System.out.println(result.getForPath() + " - " + result.getType());    }    return results;}
public void curator_f303_0() throws IOException
{            leaderSelector.start();}
public void curator_f304_0() throws IOException
{    leaderSelector.close();}
public void curator_f305_0(CuratorFramework client) throws Exception
{        final int waitSeconds = (int) (5 * Math.random()) + 1;    System.out.println(name + " is now the leader. Waiting " + waitSeconds + " seconds...");    System.out.println(name + " has been leader " + leaderCount.getAndIncrement() + " time(s) before.");    try {        Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));    } catch (InterruptedException e) {        System.err.println(name + " was interrupted.");        Thread.currentThread().interrupt();    } finally {        System.out.println(name + " relinquishing leadership.\n");    }}
public static void curator_f306_0(String[] args) throws Exception
{        System.out.println("Create " + CLIENT_QTY + " clients, have each negotiate for leadership and then wait a random number of seconds before letting another leader election occur.");    System.out.println("Notice that leader election is fair: all clients will become leader and will do so the same number of times.");    List<CuratorFramework> clients = Lists.newArrayList();    List<ExampleClient> examples = Lists.newArrayList();    TestingServer server = new TestingServer();    try {        for (int i = 0; i < CLIENT_QTY; ++i) {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));            clients.add(client);            ExampleClient example = new ExampleClient(client, PATH, "Client #" + i);            examples.add(example);            client.start();            example.start();        }        System.out.println("Press enter/return to quit\n");        new BufferedReader(new InputStreamReader(System.in)).readLine();    } finally {        System.out.println("Shutting down...");        for (ExampleClient exampleClient : examples) {            CloseableUtils.closeQuietly(exampleClient);        }        for (CuratorFramework client : clients) {            CloseableUtils.closeQuietly(client);        }        CloseableUtils.closeQuietly(server);    }}
public void curator_f307_0(long time, TimeUnit unit) throws Exception
{    if (!lock.acquire(time, unit)) {        throw new IllegalStateException(clientName + " could not acquire the lock");    }    try {        System.out.println(clientName + " has the lock");        resource.use();    } finally {        System.out.println(clientName + " releasing the lock");                lock.release();    }}
public void curator_f308_0() throws InterruptedException
{    if (!inUse.compareAndSet(false, true)) {        throw new IllegalStateException("Needs to be used by one client at a time");    }    try {        Thread.sleep((long) (3 * Math.random()));    } finally {        inUse.set(false);    }}
public static void curator_f309_0(String[] args) throws Exception
{            final FakeLimitedResource resource = new FakeLimitedResource();    ExecutorService service = Executors.newFixedThreadPool(QTY);    final TestingServer server = new TestingServer();    try {        for (int i = 0; i < QTY; ++i) {            final int index = i;            Callable<Void> task = new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));                    try {                        client.start();                        ExampleClientThatLocks example = new ExampleClientThatLocks(client, PATH, resource, "Client " + index);                        for (int j = 0; j < REPETITIONS; ++j) {                            example.doWork(10, TimeUnit.SECONDS);                        }                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                    } catch (Exception e) {                        e.printStackTrace();                                        } finally {                        CloseableUtils.closeQuietly(client);                    }                    return null;                }            };            service.submit(task);        }        service.shutdown();        service.awaitTermination(10, TimeUnit.MINUTES);    } finally {        CloseableUtils.closeQuietly(server);    }}
public Void curator_f310_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));    try {        client.start();        ExampleClientThatLocks example = new ExampleClientThatLocks(client, PATH, resource, "Client " + index);        for (int j = 0; j < REPETITIONS; ++j) {            example.doWork(10, TimeUnit.SECONDS);        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } catch (Exception e) {        e.printStackTrace();        } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
public int curator_f311_0()
{    return typeId;}
public boolean curator_f312_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ContainerType that = (ContainerType) o;    return typeId == that.typeId;}
public int curator_f313_0()
{    return typeId;}
public String curator_f314_0()
{    return "ContainerType{" + "typeId=" + typeId + '}';}
public static ModeledFramework<PersonModel> curator_f315_0(AsyncCuratorFramework client)
{    JacksonModelSerializer<PersonModel> serializer = JacksonModelSerializer.build(PersonModel.class);        ModelSpec<PersonModel> modelSpec = ModelSpec.builder(ZPath.parse("/example/path"), serializer).build();        return ModeledFramework.wrap(client, modelSpec);}
public static void curator_f316_0(ModeledFramework<PersonModel> modeled, PersonModel model)
{        ModeledFramework<PersonModel> atId = modeled.child(model.getId().getId());                atId.set(model);}
public static void curator_f317_0(ModeledFramework<PersonModel> modeled, String id, Consumer<PersonModel> receiver)
{        modeled.child(id).read().whenComplete((person, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            receiver.accept(person);        }    });}
public static void curator_f318_0(PersonModelSpec modelSpec, PersonModel model)
{        ModeledFramework<PersonModel> resolved = modelSpec.resolved(model.getContainerType(), model.getId());                resolved.set(model);}
public static void curator_f319_0(PersonModelSpec modelSpec, ContainerType containerType, PersonId id, Consumer<PersonModel> receiver)
{    ModeledFramework<PersonModel> resolved = modelSpec.resolved(containerType, id);        resolved.read().whenComplete((person, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            receiver.accept(person);        }    });}
public String curator_f320_0()
{    return id;}
public boolean curator_f321_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    PersonId personId = (PersonId) o;    return id.equals(personId.id);}
public int curator_f322_0()
{    return id.hashCode();}
public String curator_f323_0()
{    return "PersonId{" + "id='" + id + '\'' + '}';}
public PersonId curator_f324_0()
{    return id;}
public ContainerType curator_f325_0()
{    return containerType;}
public String curator_f326_0()
{    return firstName;}
public String curator_f327_0()
{    return lastName;}
public int curator_f328_0()
{    return age;}
public boolean curator_f329_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    PersonModel that = (PersonModel) o;    if (age != that.age) {        return false;    }    if (!id.equals(that.id)) {        return false;    }    if (!containerType.equals(that.containerType)) {        return false;    }        if (!firstName.equals(that.firstName)) {        return false;    }    return lastName.equals(that.lastName);}
public int curator_f330_0()
{    int result = id.hashCode();    result = 31 * result + containerType.hashCode();    result = 31 * result + firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + age;    return result;}
public String curator_f331_0()
{    return "PersonModel{" + "id=" + id + ", containerType=" + containerType + ", firstName='" + firstName + '\'' + ", lastName='" + lastName + '\'' + ", age=" + age + '}';}
public ModeledFramework<PersonModel> curator_f332_0(ContainerType containerType, PersonId personId)
{    ModelSpec<PersonModel> resolved = modelSpec.resolved(containerType.getTypeId(), personId.getId());    return ModeledFramework.wrap(client, resolved);}
private static ModelSpecBuilder<T> curator_f333_0(Class<T> clazz)
{    return ModelSpec.builder(JacksonModelSerializer.build(clazz)).withTtl(    TimeUnit.MINUTES.toMillis(10)).withCreateMode(CreateMode.PERSISTENT_WITH_TTL);}
public String curator_f334_0()
{    return "LocationAvailable{" + "name='" + name + '\'' + ", availableUntil=" + availableUntil + "} " + super.toString();}
public String curator_f335_0()
{    return name;}
public String curator_f336_0()
{    return position;}
public String curator_f337_0()
{    return "UserCreated{" + "name='" + name + '\'' + ", position='" + position + '\'' + "} " + super.toString();}
public String curator_f338_0()
{    return groupName;}
public String curator_f339_0()
{    return groupName;}
public String curator_f340_0()
{    return id;}
public InstanceType curator_f341_0()
{    return type;}
public String curator_f342_0()
{    return hostname;}
public int curator_f343_0()
{    return port;}
public String curator_f344_0()
{    return id;}
public String curator_f345_0()
{    return "Instance{" + "id='" + id + '\'' + ", type=" + type + ", hostname='" + hostname + '\'' + ", port=" + port + '}';}
public String curator_f346_0()
{    return id;}
public Priority curator_f347_0()
{    return priority;}
public String curator_f348_0()
{    return id;}
public String curator_f349_0()
{    return "Message{" + "id='" + id + '\'' + ", priority=" + priority + '}';}
public void curator_f350_1(Instance instance)
{    ModeledFramework<Instance> resolvedClient = Clients.instanceClient.resolved(client, instance.getType());    resolvedClient.set(instance).exceptionally(e -> {                return null;    });}
public void curator_f351_1(List<Instance> instances)
{    List<CuratorOp> operations = instances.stream().map(instance -> Clients.instanceClient.resolved(client, instance.getType()).createOp(instance)).collect(Collectors.toList());    client.transaction().forOperations(operations).exceptionally(e -> {                return null;    });}
public void curator_f352_0(Group group, LocationAvailable locationAvailable)
{    publishMessage(Clients.locationAvailableClient, group, locationAvailable);}
public void curator_f353_0(Group group, UserCreated userCreated)
{    publishMessage(Clients.userCreatedClient, group, userCreated);}
public void curator_f354_0(Group group, List<LocationAvailable> locationsAvailable)
{    publishMessages(Clients.locationAvailableClient, group, locationsAvailable);}
public void curator_f355_0(Group group, List<UserCreated> usersCreated)
{    publishMessages(Clients.userCreatedClient, group, usersCreated);}
private void curator_f356_1(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, T message)
{    ModeledFramework<T> resolvedClient = typedClient.resolved(client, group, message.getPriority());    resolvedClient.set(message).exceptionally(e -> {                return null;    });}
private void curator_f357_1(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, List<T> messages)
{    List<CuratorOp> operations = messages.stream().map(message -> typedClient.resolved(client, group, message.getPriority()).createOp(message)).collect(Collectors.toList());    client.transaction().forOperations(operations).exceptionally(e -> {                return null;    });}
public static void curator_f358_0(String[] args)
{    try (SubPubTest subPubTest = new SubPubTest()) {        subPubTest.start();                TimeUnit.MINUTES.sleep(1);    } catch (Exception e) {        e.printStackTrace();    }}
public void curator_f359_0()
{    client.unwrap().start();    Publisher publisher = new Publisher(client);    Subscriber subscriber = new Subscriber(client);        instanceSubscribers.addAll(Arrays.stream(InstanceType.values()).map(subscriber::startInstanceSubscriber).collect(Collectors.toList()));        locationAvailableSubscribers.addAll(Arrays.stream(Priority.values()).flatMap(priority -> Arrays.stream(groups).map(group -> subscriber.startLocationAvailableSubscriber(group, priority))).collect(Collectors.toList()));        userCreatedSubscribers.addAll(Arrays.stream(Priority.values()).flatMap(priority -> Arrays.stream(groups).map(group -> subscriber.startUserCreatedSubscriber(group, priority))).collect(Collectors.toList()));        instanceSubscribers.forEach(s -> s.listenable().addListener(generalListener()));    locationAvailableSubscribers.forEach(s -> s.listenable().addListener(generalListener()));    userCreatedSubscribers.forEach(s -> s.listenable().addListener(generalListener()));        executorService.scheduleAtFixedRate(() -> publishSomething(publisher), 1, 1, TimeUnit.SECONDS);}
public void curator_f360_0() throws IOException
{    executorService.shutdownNow();    try {        executorService.awaitTermination(5, TimeUnit.SECONDS);    } catch (InterruptedException ignore) {        Thread.currentThread().interrupt();    }    userCreatedSubscribers.forEach(CachedModeledFramework::close);    locationAvailableSubscribers.forEach(CachedModeledFramework::close);    instanceSubscribers.forEach(CachedModeledFramework::close);    client.unwrap().close();    testingServer.close();}
private void curator_f361_0(Publisher publisher)
{        switch(ThreadLocalRandom.current().nextInt(6)) {        case 0:            {                Instance instance = new Instance(nextId(), random(InstanceType.values()), random(hostnames), random(ports));                System.out.println("Publishing 1 instance");                publisher.publishInstance(instance);                break;            }        case 1:            {                List<Instance> instances = IntStream.range(1, 10).mapToObj(__ -> new Instance(nextId(), random(InstanceType.values()), random(hostnames), random(ports))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d instances", instances.size()));                publisher.publishInstances(instances);                break;            }        case 2:            {                LocationAvailable locationAvailable = new LocationAvailable(nextId(), random(Priority.values()), random(locations), random(durations));                System.out.println("Publishing 1 locationAvailable");                publisher.publishLocationAvailable(random(groups), locationAvailable);                break;            }        case 3:            {                List<LocationAvailable> locationsAvailable = IntStream.range(1, 10).mapToObj(__ -> new LocationAvailable(nextId(), random(Priority.values()), random(locations), random(durations))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d locationsAvailable", locationsAvailable.size()));                publisher.publishLocationsAvailable(random(groups), locationsAvailable);                break;            }        case 4:            {                UserCreated userCreated = new UserCreated(nextId(), random(Priority.values()), random(locations), random(positions));                System.out.println("Publishing 1 userCreated");                publisher.publishUserCreated(random(groups), userCreated);                break;            }        case 5:            {                List<UserCreated> usersCreated = IntStream.range(1, 10).mapToObj(__ -> new UserCreated(nextId(), random(Priority.values()), random(locations), random(positions))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d usersCreated", usersCreated.size()));                publisher.publishUsersCreated(random(groups), usersCreated);                break;            }    }}
private ModeledCacheListener<T> curator_f362_0()
{    return (type, path, stat, model) -> System.out.println(String.format("Subscribed %s @ %s", model.getClass().getSimpleName(), path));}
private final T curator_f363_0(T... tab)
{    int index = ThreadLocalRandom.current().nextInt(tab.length);    return tab[index];}
private String curator_f364_0()
{    return Long.toString(nextId.getAndIncrement());}
public CachedModeledFramework<LocationAvailable> curator_f365_0(Group group, Priority priority)
{    return startSubscriber(Clients.locationAvailableClient, group, priority);}
public CachedModeledFramework<UserCreated> curator_f366_0(Group group, Priority priority)
{    return startSubscriber(Clients.userCreatedClient, group, priority);}
public CachedModeledFramework<Instance> curator_f367_0(InstanceType instanceType)
{    CachedModeledFramework<Instance> resolved = Clients.instanceClient.resolved(client, instanceType).cached();    resolved.start();    return resolved;}
private CachedModeledFramework<T> curator_f368_0(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, Priority priority)
{    CachedModeledFramework<T> resolved = typedClient.resolved(client, group, priority).cached();    resolved.start();    return resolved;}
public static Predicate<CuratorTransactionResult> curator_f369_0(final OperationType type, final String forPath)
{    return new Predicate<CuratorTransactionResult>() {        @Override        public boolean apply(CuratorTransactionResult result) {            return (result.getType() == type) && result.getForPath().equals(forPath);        }    };}
public boolean curator_f370_0(CuratorTransactionResult result)
{    return (result.getType() == type) && result.getForPath().equals(forPath);}
public OperationType curator_f371_0()
{    return type;}
public String curator_f372_0()
{    return forPath;}
public String curator_f373_0()
{    return resultPath;}
public Stat curator_f374_0()
{    return resultStat;}
public int curator_f375_0()
{    return error;}
public OperationType curator_f376_0()
{    return type;}
public String curator_f377_0()
{    return forPath;}
public String curator_f378_0()
{    return scheme;}
public byte[] curator_f379_0()
{    return auth;}
public String curator_f380_0()
{    return "AuthInfo{" + "scheme='" + scheme + '\'' + ", auth=" + Arrays.toString(auth) + '}';}
 CompletableFuture<Void> curator_f381_0(Object monitorHolder)
{    return runSafe(() -> {        synchronized (monitorHolder) {            monitorHolder.notifyAll();        }    });}
public static Builder curator_f382_0()
{    return new Builder();}
public static CuratorFramework curator_f383_0(String connectString, RetryPolicy retryPolicy)
{    return newClient(connectString, DEFAULT_SESSION_TIMEOUT_MS, DEFAULT_CONNECTION_TIMEOUT_MS, retryPolicy);}
public static CuratorFramework curator_f384_0(String connectString, int sessionTimeoutMs, int connectionTimeoutMs, RetryPolicy retryPolicy)
{    return builder().connectString(connectString).sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs).retryPolicy(retryPolicy).build();}
public static byte[] curator_f385_0()
{    try {        return InetAddress.getLocalHost().getHostAddress().getBytes();    } catch (UnknownHostException ignore) {        }    return new byte[0];}
public CuratorFramework curator_f386_0()
{    return new CuratorFrameworkImpl(this);}
public CuratorTempFramework curator_f387_0()
{    return buildTemp(DEFAULT_INACTIVE_THRESHOLD_MS, TimeUnit.MILLISECONDS);}
public CuratorTempFramework curator_f388_0(long inactiveThreshold, TimeUnit unit)
{    return new CuratorTempFrameworkImpl(this, unit.toMillis(inactiveThreshold));}
public Builder curator_f389_0(String scheme, byte[] auth)
{    return authorization(ImmutableList.of(new AuthInfo(scheme, (auth != null) ? Arrays.copyOf(auth, auth.length) : null)));}
public Builder curator_f390_0(List<AuthInfo> authInfos)
{    this.authInfos = ImmutableList.copyOf(authInfos);    return this;}
public Builder curator_f391_0(String connectString)
{    ensembleProvider = new FixedEnsembleProvider(connectString);    return this;}
public Builder curator_f392_0(EnsembleProvider ensembleProvider)
{    this.ensembleProvider = ensembleProvider;    return this;}
public Builder curator_f393_0(byte[] defaultData)
{    this.defaultData = (defaultData != null) ? Arrays.copyOf(defaultData, defaultData.length) : null;    return this;}
public Builder curator_f394_0(String namespace)
{    this.namespace = namespace;    return this;}
public Builder curator_f395_0(int sessionTimeoutMs)
{    this.sessionTimeoutMs = sessionTimeoutMs;    return this;}
public Builder curator_f396_0(int connectionTimeoutMs)
{    this.connectionTimeoutMs = connectionTimeoutMs;    return this;}
public Builder curator_f397_0(int maxCloseWaitMs)
{    this.maxCloseWaitMs = maxCloseWaitMs;    return this;}
public Builder curator_f398_0(RetryPolicy retryPolicy)
{    this.retryPolicy = retryPolicy;    return this;}
public Builder curator_f399_0(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    return this;}
public Builder curator_f400_0(CompressionProvider compressionProvider)
{    this.compressionProvider = compressionProvider;    return this;}
public Builder curator_f401_0(ZookeeperFactory zookeeperFactory)
{    this.zookeeperFactory = zookeeperFactory;    return this;}
public Builder curator_f402_0(ACLProvider aclProvider)
{    this.aclProvider = aclProvider;    return this;}
public Builder curator_f403_0(boolean canBeReadOnly)
{    this.canBeReadOnly = canBeReadOnly;    return this;}
public Builder curator_f404_0()
{    this.useContainerParentsIfAvailable = false;    return this;}
public Builder curator_f405_0(ConnectionStateErrorPolicy connectionStateErrorPolicy)
{    this.connectionStateErrorPolicy = connectionStateErrorPolicy;    return this;}
public Builder curator_f406_0(boolean mode)
{    this.zk34CompatibilityMode = mode;    return this;}
public Builder curator_f407_0(int waitForShutdownTimeoutMs)
{    this.waitForShutdownTimeoutMs = waitForShutdownTimeoutMs;    return this;}
public Builder curator_f408_0(ConnectionHandlingPolicy connectionHandlingPolicy)
{    this.connectionHandlingPolicy = connectionHandlingPolicy;    return this;}
public Builder curator_f409_0(SchemaSet schemaSet)
{    this.schemaSet = schemaSet;    return this;}
public Builder curator_f410_0(Executor runSafeService)
{    this.runSafeService = runSafeService;    return this;}
public Builder curator_f411_0(ConnectionStateListenerManagerFactory connectionStateListenerManagerFactory)
{    this.connectionStateListenerManagerFactory = Objects.requireNonNull(connectionStateListenerManagerFactory, "connectionStateListenerManagerFactory cannot be null");    return this;}
public Executor curator_f412_0()
{    return runSafeService;}
public ACLProvider curator_f413_0()
{    return aclProvider;}
public ZookeeperFactory curator_f414_0()
{    return zookeeperFactory;}
public CompressionProvider curator_f415_0()
{    return compressionProvider;}
public ThreadFactory curator_f416_0()
{    return threadFactory;}
public EnsembleProvider curator_f417_0()
{    return ensembleProvider;}
public int curator_f418_0()
{    return sessionTimeoutMs;}
public int curator_f419_0()
{    return connectionTimeoutMs;}
public int curator_f420_0()
{    return waitForShutdownTimeoutMs;}
public int curator_f421_0()
{    return maxCloseWaitMs;}
public RetryPolicy curator_f422_0()
{    return retryPolicy;}
public String curator_f423_0()
{    return namespace;}
public boolean curator_f424_0()
{    return useContainerParentsIfAvailable;}
public ConnectionStateErrorPolicy curator_f425_0()
{    return connectionStateErrorPolicy;}
public ConnectionHandlingPolicy curator_f426_0()
{    return connectionHandlingPolicy;}
public SchemaSet curator_f427_0()
{    return schemaSet;}
public boolean curator_f428_0()
{    return zk34CompatibilityMode;}
public String curator_f429_0()
{    int qty = (authInfos != null) ? authInfos.size() : 0;    switch(qty) {        case 0:            {                return null;            }        case 1:            {                return authInfos.get(0).scheme;            }        default:            {                throw new IllegalStateException("More than 1 auth has been added");            }    }}
public byte[] curator_f430_0()
{    int qty = (authInfos != null) ? authInfos.size() : 0;    switch(qty) {        case 0:            {                return null;            }        case 1:            {                byte[] bytes = authInfos.get(0).getAuth();                return (bytes != null) ? Arrays.copyOf(bytes, bytes.length) : null;            }        default:            {                throw new IllegalStateException("More than 1 auth has been added");            }    }}
public List<AuthInfo> curator_f431_0()
{    return authInfos;}
public byte[] curator_f432_0()
{    return defaultData;}
public boolean curator_f433_0()
{    return canBeReadOnly;}
public ConnectionStateListenerManagerFactory curator_f434_0()
{    return connectionStateListenerManagerFactory;}
public void curator_f435_0() throws Exception
{    if (ensureNeeded.get()) {        internalEnsure();    }}
public void curator_f436_0()
{    ensureNeeded.set(true);}
private synchronized void curator_f437_0() throws Exception
{    if (ensureNeeded.compareAndSet(true, false)) {        client.createContainers(path);    }}
 InternalACLProvider curator_f438_0()
{    return applyToParents ? this : aclProvider;}
 List<ACL> curator_f439_0(String path)
{    if (aclList != null)        return aclList;    if (path != null) {        List<ACL> localAclList = aclProvider.getAclForPath(path);        if (localAclList != null) {            return localAclList;        }    }    return aclProvider.getDefaultAcl();}
public List<ACL> curator_f440_0()
{    return aclProvider.getDefaultAcl();}
public List<ACL> curator_f441_0(String path)
{    return getAclList(path);}
 boolean curator_f442_0()
{    return inBackground;}
 Object curator_f443_0()
{    return context;}
 BackgroundCallback curator_f444_0()
{    return callback;}
 void curator_f445_0(Throwable e, Watching watching) throws Exception
{    if (e != null) {        if (errorListener != null) {            errorListener.unhandledError("n/a", e);        } else if (e instanceof Exception) {            throw (Exception) e;        } else {            Throwables.propagate(e);        }    }}
private static BackgroundCallback curator_f446_0(final CuratorFrameworkImpl client, final BackgroundCallback callback, final Executor executor)
{    return new BackgroundCallback() {        @Override        public void processResult(CuratorFramework dummy, final CuratorEvent event) throws Exception {            executor.execute(new Runnable() {                @Override                public void run() {                    try {                        callback.processResult(client, event);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        if (e instanceof KeeperException) {                            client.validateConnection(client.codeToState(((KeeperException) e).code()));                        }                        client.logError("Background operation result handling threw exception", e);                    }                }            });        }    };}
public void curator_f447_0(CuratorFramework dummy, final CuratorEvent event) throws Exception
{    executor.execute(new Runnable() {        @Override        public void run() {            try {                callback.processResult(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                if (e instanceof KeeperException) {                    client.validateConnection(client.codeToState(((KeeperException) e).code()));                }                client.logError("Background operation result handling threw exception", e);            }        }    });}
public void curator_f448_0()
{    try {        callback.processResult(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        if (e instanceof KeeperException) {            client.validateConnection(client.codeToState(((KeeperException) e).code()));        }        client.logError("Background operation result handling threw exception", e);    }}
public void curator_f449_0(final OperationAndData<String> operationAndData) throws Exception
{    final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("BackgroundSyncImpl");    final String data = operationAndData.getData();    client.getZooKeeper().sync(data, new AsyncCallback.VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            trace.setReturnCode(rc).setRequestBytesLength(data).commit();            CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, null, ctx, null, null, null, null, null, null);            client.processBackgroundOperation(operationAndData, event);        }    }, context);}
public void curator_f450_0(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setRequestBytesLength(data).commit();    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, null, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
public void curator_f451_0(int version)
{    this.setDataIfExistsVersion = version;}
public CreateBuilder2 curator_f452_0()
{    return orSetData(-1);}
public CreateBuilder2 curator_f453_0(int version)
{    setDataIfExists = true;    setDataIfExistsVersion = version;    return this;}
public CreateBuilderMain curator_f454_0(long ttl)
{    Preconditions.checkState(!client.isZk34CompatibilityMode(), "TTLs are not support when running in ZooKeeper 3.4 compatibility mode");    this.ttl = ttl;    return this;}
 TransactionCreateBuilder<T> curator_f455_0(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionCreateBuilder<T>() {        @Override        public PathAndBytesable<T> withACL(List<ACL> aclList) {            return withACL(aclList, false);        }        @Override        public PathAndBytesable<T> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public TransactionCreateBuilder2<T> withTtl(long ttl) {            CreateBuilderImpl.this.withTtl(ttl);            return this;        }        @Override        public ACLPathAndBytesable<T> withMode(CreateMode mode) {            CreateBuilderImpl.this.withMode(mode);            return this;        }        @Override        public ACLCreateModePathAndBytesable<T> compressed() {            CreateBuilderImpl.this.compressed();            return this;        }        @Override        public T forPath(String path) throws Exception {            return forPath(path, client.getDefaultData());        }        @Override        public T forPath(String path, byte[] data) throws Exception {            if (compress) {                data = client.getCompressionProvider().compress(path, data);            }            String fixedPath = client.fixForNamespace(path);            if (client.isZk34CompatibilityMode()) {                transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode), OperationType.CREATE, path);            } else {                transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode, ttl), OperationType.CREATE, path);            }            return context;        }    };}
public PathAndBytesable<T> curator_f456_0(List<ACL> aclList)
{    return withACL(aclList, false);}
public PathAndBytesable<T> curator_f457_0(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
public TransactionCreateBuilder2<T> curator_f458_0(long ttl)
{    CreateBuilderImpl.this.withTtl(ttl);    return this;}
public ACLPathAndBytesable<T> curator_f459_0(CreateMode mode)
{    CreateBuilderImpl.this.withMode(mode);    return this;}
public ACLCreateModePathAndBytesable<T> curator_f460_0()
{    CreateBuilderImpl.this.compressed();    return this;}
public T curator_f461_0(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
public T curator_f462_0(String path, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    String fixedPath = client.fixForNamespace(path);    if (client.isZk34CompatibilityMode()) {        transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode), OperationType.CREATE, path);    } else {        transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode, ttl), OperationType.CREATE, path);    }    return context;}
public CreateBackgroundModeStatACLable curator_f463_0()
{    compress = true;    return new CreateBackgroundModeStatACLable() {        @Override        public CreateBackgroundModeACLable storingStatIn(Stat stat) {            storingStat = stat;            return asCreateBackgroundModeACLable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            createParentsIfNeeded = true;            return asACLCreateModePathAndBytesable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            setCreateParentsAsContainers();            return creatingParentsIfNeeded();        }        @Override        public ACLPathAndBytesable<String> withProtectedEphemeralSequential() {            return CreateBuilderImpl.this.withProtectedEphemeralSequential();        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
public CreateBackgroundModeACLable curator_f464_0(Stat stat)
{    storingStat = stat;    return asCreateBackgroundModeACLable();}
public ACLCreateModePathAndBytesable<String> curator_f465_0()
{    createParentsIfNeeded = true;    return asACLCreateModePathAndBytesable();}
public ACLCreateModePathAndBytesable<String> curator_f466_0()
{    setCreateParentsAsContainers();    return creatingParentsIfNeeded();}
public ACLPathAndBytesable<String> curator_f467_0()
{    return CreateBuilderImpl.this.withProtectedEphemeralSequential();}
public BackgroundPathAndBytesable<String> curator_f468_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public BackgroundPathAndBytesable<String> curator_f469_0(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
public ErrorListenerPathAndBytesable<String> curator_f470_0(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathAndBytesable<String> curator_f471_0(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
public ErrorListenerPathAndBytesable<String> curator_f472_0()
{    return CreateBuilderImpl.this.inBackground();}
public ErrorListenerPathAndBytesable<String> curator_f473_0(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
public ErrorListenerPathAndBytesable<String> curator_f474_0(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathAndBytesable<String> curator_f475_0(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
public ACLBackgroundPathAndBytesable<String> curator_f476_0(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
public String curator_f477_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public String curator_f478_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public ACLBackgroundPathAndBytesable<String> curator_f479_0(List<ACL> aclList)
{    return withACL(aclList, false);}
public ACLBackgroundPathAndBytesable<String> curator_f480_0(List<ACL> aclList, boolean applyToParents)
{    acling = new ACLing(client.getAclProvider(), aclList, applyToParents);    return new ACLBackgroundPathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
public BackgroundPathAndBytesable<String> curator_f481_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public BackgroundPathAndBytesable<String> curator_f482_0(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
public ErrorListenerPathAndBytesable<String> curator_f483_0()
{    return CreateBuilderImpl.this.inBackground();}
public ErrorListenerPathAndBytesable<String> curator_f484_0(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathAndBytesable<String> curator_f485_0(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
public ErrorListenerPathAndBytesable<String> curator_f486_0(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
public ErrorListenerPathAndBytesable<String> curator_f487_0(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathAndBytesable<String> curator_f488_0(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
public String curator_f489_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public String curator_f490_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public ProtectACLCreateModeStatPathAndBytesable<String> curator_f491_0()
{    setCreateParentsAsContainers();    return creatingParentsIfNeeded();}
private void curator_f492_0()
{    if (client.useContainerParentsIfAvailable()) {        createParentsAsContainers = true;    }}
public ProtectACLCreateModeStatPathAndBytesable<String> curator_f493_0()
{    createParentsIfNeeded = true;    return new ProtectACLCreateModeStatPathAndBytesable<String>() {        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> withProtection() {            return CreateBuilderImpl.this.withProtection();        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return withACL(aclList, false);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public ACLBackgroundPathAndBytesable<String> storingStatIn(Stat stat) {            storingStat = stat;            return CreateBuilderImpl.this;        }    };}
public ACLCreateModeBackgroundPathAndBytesable<String> curator_f494_0()
{    return CreateBuilderImpl.this.withProtection();}
public BackgroundPathAndBytesable<String> curator_f495_0(List<ACL> aclList)
{    return withACL(aclList, false);}
public BackgroundPathAndBytesable<String> curator_f496_0(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
public ErrorListenerPathAndBytesable<String> curator_f497_0()
{    return CreateBuilderImpl.this.inBackground();}
public ErrorListenerPathAndBytesable<String> curator_f498_0(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
public ErrorListenerPathAndBytesable<String> curator_f499_0(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathAndBytesable<String> curator_f500_0(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathAndBytesable<String> curator_f501_0(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
public ErrorListenerPathAndBytesable<String> curator_f502_0(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
public ACLBackgroundPathAndBytesable<String> curator_f503_0(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
public String curator_f504_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public String curator_f505_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public ACLBackgroundPathAndBytesable<String> curator_f506_0(Stat stat)
{    storingStat = stat;    return CreateBuilderImpl.this;}
public ACLCreateModeStatBackgroundPathAndBytesable<String> curator_f507_0()
{    protectedMode.setProtectedMode();    return asACLCreateModeStatBackgroundPathAndBytesable();}
public ACLPathAndBytesable<String> curator_f508_0()
{    protectedMode.setProtectedMode();    createMode = CreateMode.EPHEMERAL_SEQUENTIAL;    return new ACLPathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
public PathAndBytesable<String> curator_f509_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public PathAndBytesable<String> curator_f510_0(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
public String curator_f511_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public String curator_f512_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public ACLBackgroundPathAndBytesable<String> curator_f513_0(CreateMode mode)
{    createMode = mode;    return this;}
public ErrorListenerPathAndBytesable<String> curator_f514_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathAndBytesable<String> curator_f515_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathAndBytesable<String> curator_f516_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathAndBytesable<String> curator_f517_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public ErrorListenerPathAndBytesable<String> curator_f518_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathAndBytesable<String> curator_f519_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public PathAndBytesable<String> curator_f520_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public String curator_f521_0(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
public String curator_f522_0(final String givenPath, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(givenPath, data);    }    final String adjustedPath = adjustPath(client.fixForNamespace(givenPath, createMode.isSequential()));    List<ACL> aclList = acling.getAclList(adjustedPath);    client.getSchemaSet().getSchema(givenPath).validateCreate(createMode, givenPath, data, aclList);    String returnPath = null;    if (backgrounding.inBackground()) {        pathInBackground(adjustedPath, data, givenPath);    } else {        String path = protectedPathInForeground(adjustedPath, data, aclList);        returnPath = client.unfixForNamespace(path);    }    return returnPath;}
private String curator_f523_0(String adjustedPath, byte[] data, List<ACL> aclList) throws Exception
{    try {        return pathInForeground(adjustedPath, data, aclList);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        if ((e instanceof KeeperException.ConnectionLossException || !(e instanceof KeeperException)) && protectedMode.doProtected()) {            /*                 * CURATOR-45 + CURATOR-79: we don't know if the create operation was successful or not,                 * register the znode to be sure it is deleted later.                 */            new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(adjustedPath).getPath(), protectedMode.protectedId()).execute();            /*                 * The current UUID is scheduled to be deleted, it is not safe to use it again.                 * If this builder is used again later create a new UUID                 */            protectedMode.resetProtectedId();        }        throw e;    }}
public void curator_f524_0(final OperationAndData<PathAndBytes> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-Background");        final byte[] data = operationAndData.getData().getData();        final CompatibleCreateCallback mainCallback = new CompatibleCreateCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).commit();                if ((stat != null) && (storingStat != null)) {                    DataTree.copyStat(stat, storingStat);                }                if ((rc == KeeperException.Code.NONODE.intValue()) && createParentsIfNeeded) {                    backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData().getPath(), backgrounding, acling.getACLProviderForParents(), createParentsAsContainers);                } else if ((rc == KeeperException.Code.NODEEXISTS.intValue()) && setDataIfExists) {                    backgroundSetData(client, operationAndData, operationAndData.getData().getPath(), backgrounding);                } else {                    sendBackgroundResponse(rc, path, ctx, name, stat, operationAndData);                }            }        };        if (client.isZk34CompatibilityMode()) {            AsyncCallback.StringCallback stringCallback = new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    mainCallback.processResult(rc, path, ctx, name, null);                }            };            client.getZooKeeper().create(operationAndData.getData().getPath(), data, acling.getAclList(operationAndData.getData().getPath()), createMode, stringCallback, backgrounding.getContext());        } else {            CreateZK35.create(client.getZooKeeper(), operationAndData.getData().getPath(), data, acling.getAclList(operationAndData.getData().getPath()), createMode, mainCallback, backgrounding.getContext(), ttl);        }    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f525_0(int rc, String path, Object ctx, String name, Stat stat)
{    trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).commit();    if ((stat != null) && (storingStat != null)) {        DataTree.copyStat(stat, storingStat);    }    if ((rc == KeeperException.Code.NONODE.intValue()) && createParentsIfNeeded) {        backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData().getPath(), backgrounding, acling.getACLProviderForParents(), createParentsAsContainers);    } else if ((rc == KeeperException.Code.NODEEXISTS.intValue()) && setDataIfExists) {        backgroundSetData(client, operationAndData, operationAndData.getData().getPath(), backgrounding);    } else {        sendBackgroundResponse(rc, path, ctx, name, stat, operationAndData);    }}
public void curator_f526_0(int rc, String path, Object ctx, String name)
{    mainCallback.processResult(rc, path, ctx, name, null);}
public CreateProtectACLCreateModePathAndBytesable<String> curator_f527_0(Stat stat)
{    storingStat = stat;    return new CreateProtectACLCreateModePathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> withProtection() {            return CreateBuilderImpl.this.withProtection();        }        @Override        public ProtectACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            return CreateBuilderImpl.this.creatingParentsIfNeeded();        }        @Override        public ProtectACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            return CreateBuilderImpl.this.creatingParentContainersIfNeeded();        }    };}
public BackgroundPathAndBytesable<String> curator_f528_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public BackgroundPathAndBytesable<String> curator_f529_0(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
public ErrorListenerPathAndBytesable<String> curator_f530_0()
{    return CreateBuilderImpl.this.inBackground();}
public ErrorListenerPathAndBytesable<String> curator_f531_0(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
public ErrorListenerPathAndBytesable<String> curator_f532_0(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathAndBytesable<String> curator_f533_0(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathAndBytesable<String> curator_f534_0(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
public ErrorListenerPathAndBytesable<String> curator_f535_0(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
public String curator_f536_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public String curator_f537_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public ACLBackgroundPathAndBytesable<String> curator_f538_0(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
public ACLCreateModeBackgroundPathAndBytesable<String> curator_f539_0()
{    return CreateBuilderImpl.this.withProtection();}
public ProtectACLCreateModePathAndBytesable<String> curator_f540_0()
{    return CreateBuilderImpl.this.creatingParentsIfNeeded();}
public ProtectACLCreateModePathAndBytesable<String> curator_f541_0()
{    return CreateBuilderImpl.this.creatingParentContainersIfNeeded();}
private static String curator_f542_0(String protectedId)
{    return PROTECTED_PREFIX + protectedId + "-";}
 static void curator_f543_0(final CuratorFrameworkImpl client, final OperationAndData<T> mainOperationAndData, final String path, Backgrounding backgrounding, final InternalACLProvider aclProvider, final boolean createParentsAsContainers)
{    BackgroundOperation<T> operation = new BackgroundOperation<T>() {        @Override        public void performBackgroundOperation(OperationAndData<T> dummy) throws Exception {            try {                ZKPaths.mkdirs(client.getZooKeeper(), path, false, aclProvider, createParentsAsContainers);            } catch (KeeperException e) {                if (!RetryLoop.isRetryException(e)) {                    throw e;                }                        }            client.queueOperation(mainOperationAndData);        }    };    OperationAndData<T> parentOperation = new OperationAndData<>(operation, mainOperationAndData.getData(), null, null, backgrounding.getContext(), null);    client.queueOperation(parentOperation);}
public void curator_f544_0(OperationAndData<T> dummy) throws Exception
{    try {        ZKPaths.mkdirs(client.getZooKeeper(), path, false, aclProvider, createParentsAsContainers);    } catch (KeeperException e) {        if (!RetryLoop.isRetryException(e)) {            throw e;        }        }    client.queueOperation(mainOperationAndData);}
private void curator_f545_0(final CuratorFrameworkImpl client, final OperationAndData<PathAndBytes> mainOperationAndData, final String path, final Backgrounding backgrounding)
{    final AsyncCallback.StatCallback statCallback = new AsyncCallback.StatCallback() {        @Override        public void processResult(int rc, String path, Object ctx, Stat stat) {            if (rc == KeeperException.Code.NONODE.intValue()) {                                client.queueOperation(mainOperationAndData);            } else {                sendBackgroundResponse(rc, path, ctx, path, stat, mainOperationAndData);            }        }    };    BackgroundOperation<PathAndBytes> operation = new BackgroundOperation<PathAndBytes>() {        @Override        public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws Exception {            try {                client.getZooKeeper().setData(path, mainOperationAndData.getData().getData(), setDataIfExistsVersion, statCallback, backgrounding.getContext());            } catch (KeeperException e) {                        }        }    };    client.queueOperation(new OperationAndData<>(operation, null, null, null, null, null));}
public void curator_f546_0(int rc, String path, Object ctx, Stat stat)
{    if (rc == KeeperException.Code.NONODE.intValue()) {                client.queueOperation(mainOperationAndData);    } else {        sendBackgroundResponse(rc, path, ctx, path, stat, mainOperationAndData);    }}
public void curator_f547_0(OperationAndData<PathAndBytes> op) throws Exception
{    try {        client.getZooKeeper().setData(path, mainOperationAndData.getData().getData(), setDataIfExistsVersion, statCallback, backgrounding.getContext());    } catch (KeeperException e) {        }}
private void curator_f548_0(int rc, String path, Object ctx, String name, Stat stat, OperationAndData<PathAndBytes> operationAndData)
{    path = client.unfixForNamespace(path);    name = client.unfixForNamespace(name);    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.CREATE, rc, path, name, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
private ACLCreateModePathAndBytesable<String> curator_f549_0()
{    return new ACLCreateModePathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public ACLPathAndBytesable<String> withMode(CreateMode mode) {            createMode = mode;            return new ACLPathAndBytesable<String>() {                @Override                public PathAndBytesable<String> withACL(List<ACL> aclList) {                    return CreateBuilderImpl.this.withACL(aclList);                }                @Override                public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {                    return CreateBuilderImpl.this.withACL(aclList, applyToParents);                }                @Override                public String forPath(String path, byte[] data) throws Exception {                    return CreateBuilderImpl.this.forPath(path, data);                }                @Override                public String forPath(String path) throws Exception {                    return CreateBuilderImpl.this.forPath(path);                }            };        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
public PathAndBytesable<String> curator_f550_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public PathAndBytesable<String> curator_f551_0(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
public ACLPathAndBytesable<String> curator_f552_0(CreateMode mode)
{    createMode = mode;    return new ACLPathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
public PathAndBytesable<String> curator_f553_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public PathAndBytesable<String> curator_f554_0(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
public String curator_f555_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public String curator_f556_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public String curator_f557_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public String curator_f558_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
private CreateBackgroundModeACLable curator_f559_0()
{    return new CreateBackgroundModeACLable() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ACLPathAndBytesable<String> withProtectedEphemeralSequential() {            return CreateBuilderImpl.this.withProtectedEphemeralSequential();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            createParentsIfNeeded = true;            return asACLCreateModePathAndBytesable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            setCreateParentsAsContainers();            return asACLCreateModePathAndBytesable();        }    };}
public BackgroundPathAndBytesable<String> curator_f560_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public BackgroundPathAndBytesable<String> curator_f561_0(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
public ACLBackgroundPathAndBytesable<String> curator_f562_0(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
public String curator_f563_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public String curator_f564_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public ErrorListenerPathAndBytesable<String> curator_f565_0(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
public ErrorListenerPathAndBytesable<String> curator_f566_0(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
public ErrorListenerPathAndBytesable<String> curator_f567_0(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathAndBytesable<String> curator_f568_0(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathAndBytesable<String> curator_f569_0(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
public ErrorListenerPathAndBytesable<String> curator_f570_0()
{    return CreateBuilderImpl.this.inBackground();}
public ACLPathAndBytesable<String> curator_f571_0()
{    return CreateBuilderImpl.this.withProtectedEphemeralSequential();}
public ACLCreateModePathAndBytesable<String> curator_f572_0()
{    createParentsIfNeeded = true;    return asACLCreateModePathAndBytesable();}
public ACLCreateModePathAndBytesable<String> curator_f573_0()
{    setCreateParentsAsContainers();    return asACLCreateModePathAndBytesable();}
private ACLCreateModeStatBackgroundPathAndBytesable<String> curator_f574_0()
{    return new ACLCreateModeStatBackgroundPathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> storingStatIn(Stat stat) {            storingStat = stat;            return CreateBuilderImpl.this;        }    };}
public BackgroundPathAndBytesable<String> curator_f575_0(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
public BackgroundPathAndBytesable<String> curator_f576_0(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
public ErrorListenerPathAndBytesable<String> curator_f577_0()
{    return CreateBuilderImpl.this.inBackground();}
public ErrorListenerPathAndBytesable<String> curator_f578_0(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
public ErrorListenerPathAndBytesable<String> curator_f579_0(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
public ErrorListenerPathAndBytesable<String> curator_f580_0(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathAndBytesable<String> curator_f581_0(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathAndBytesable<String> curator_f582_0(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
public String curator_f583_0(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
public String curator_f584_0(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
public ACLBackgroundPathAndBytesable<String> curator_f585_0(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
public ACLCreateModeBackgroundPathAndBytesable<String> curator_f586_0(Stat stat)
{    storingStat = stat;    return CreateBuilderImpl.this;}
private void curator_f587_0(final String path, final byte[] data, final String givenPath)
{    final AtomicBoolean firstTime = new AtomicBoolean(true);    OperationAndData<PathAndBytes> operationAndData = new OperationAndData<PathAndBytes>(this, new PathAndBytes(path, data), backgrounding.getCallback(), new OperationAndData.ErrorCallback<PathAndBytes>() {        public void retriesExhausted(OperationAndData<PathAndBytes> operationAndData) {            if (protectedMode.doProtected()) {                                new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(path).getPath(), protectedMode.protectedId()).execute();                                protectedMode.resetProtectedId();            }        }    }, backgrounding.getContext(), null) {        @Override        void callPerformBackgroundOperation() throws Exception {            boolean callSuper = true;            boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;            protectedMode.checkSetSessionId(client, createMode);            if (!localFirstTime && protectedMode.doProtected()) {                debugForceFindProtectedNode = false;                String createdPath = null;                try {                    createdPath = findProtectedNodeInForeground(path);                } catch (KeeperException.ConnectionLossException e) {                    sendBackgroundResponse(KeeperException.Code.CONNECTIONLOSS.intValue(), path, backgrounding.getContext(), null, null, this);                    callSuper = false;                }                if (createdPath != null) {                    try {                        sendBackgroundResponse(KeeperException.Code.OK.intValue(), createdPath, backgrounding.getContext(), createdPath, null, this);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        client.logError("Processing protected create for path: " + givenPath, e);                    }                    callSuper = false;                }            }            if (failNextCreateForTesting) {                failNextCreateForTesting = false;                                pathInForeground(path, data, acling.getAclList(path));                throw new KeeperException.ConnectionLossException();            }            if (callSuper) {                super.callPerformBackgroundOperation();            }        }    };    client.processBackgroundOperation(operationAndData, null);}
public void curator_f588_0(OperationAndData<PathAndBytes> operationAndData)
{    if (protectedMode.doProtected()) {                new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(path).getPath(), protectedMode.protectedId()).execute();                protectedMode.resetProtectedId();    }}
 void curator_f589_0() throws Exception
{    boolean callSuper = true;    boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;    protectedMode.checkSetSessionId(client, createMode);    if (!localFirstTime && protectedMode.doProtected()) {        debugForceFindProtectedNode = false;        String createdPath = null;        try {            createdPath = findProtectedNodeInForeground(path);        } catch (KeeperException.ConnectionLossException e) {            sendBackgroundResponse(KeeperException.Code.CONNECTIONLOSS.intValue(), path, backgrounding.getContext(), null, null, this);            callSuper = false;        }        if (createdPath != null) {            try {                sendBackgroundResponse(KeeperException.Code.OK.intValue(), createdPath, backgrounding.getContext(), createdPath, null, this);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                client.logError("Processing protected create for path: " + givenPath, e);            }            callSuper = false;        }    }    if (failNextCreateForTesting) {        failNextCreateForTesting = false;                pathInForeground(path, data, acling.getAclList(path));        throw new KeeperException.ConnectionLossException();    }    if (callSuper) {        super.callPerformBackgroundOperation();    }}
private String curator_f590_0(final String path, final byte[] data, final List<ACL> aclList) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-Foreground");    final AtomicBoolean firstTime = new AtomicBoolean(true);    String returnPath = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<String>() {        @Override        public String call() throws Exception {            boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;            protectedMode.checkSetSessionId(client, createMode);            String createdPath = null;            if (!localFirstTime && protectedMode.doProtected()) {                debugForceFindProtectedNode = false;                createdPath = findProtectedNodeInForeground(path);            }            if (createdPath == null) {                try {                    if (client.isZk34CompatibilityMode()) {                        createdPath = client.getZooKeeper().create(path, data, aclList, createMode);                    } else {                        createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);                    }                } catch (KeeperException.NoNodeException e) {                    if (createParentsIfNeeded) {                        ZKPaths.mkdirs(client.getZooKeeper(), path, false, acling.getACLProviderForParents(), createParentsAsContainers);                        if (client.isZk34CompatibilityMode()) {                            createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode);                        } else {                            createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode, storingStat, ttl);                        }                    } else {                        throw e;                    }                } catch (KeeperException.NodeExistsException e) {                    if (setDataIfExists) {                        Stat setStat = client.getZooKeeper().setData(path, data, setDataIfExistsVersion);                        if (storingStat != null) {                            DataTree.copyStat(setStat, storingStat);                        }                        createdPath = path;                    } else {                        throw e;                    }                }            }            if (failNextCreateForTesting) {                failNextCreateForTesting = false;                throw new KeeperException.ConnectionLossException();            }            return createdPath;        }    });    trace.setRequestBytesLength(data).setPath(path).commit();    return returnPath;}
public String curator_f591_0() throws Exception
{    boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;    protectedMode.checkSetSessionId(client, createMode);    String createdPath = null;    if (!localFirstTime && protectedMode.doProtected()) {        debugForceFindProtectedNode = false;        createdPath = findProtectedNodeInForeground(path);    }    if (createdPath == null) {        try {            if (client.isZk34CompatibilityMode()) {                createdPath = client.getZooKeeper().create(path, data, aclList, createMode);            } else {                createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);            }        } catch (KeeperException.NoNodeException e) {            if (createParentsIfNeeded) {                ZKPaths.mkdirs(client.getZooKeeper(), path, false, acling.getACLProviderForParents(), createParentsAsContainers);                if (client.isZk34CompatibilityMode()) {                    createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode);                } else {                    createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode, storingStat, ttl);                }            } else {                throw e;            }        } catch (KeeperException.NodeExistsException e) {            if (setDataIfExists) {                Stat setStat = client.getZooKeeper().setData(path, data, setDataIfExistsVersion);                if (storingStat != null) {                    DataTree.copyStat(setStat, storingStat);                }                createdPath = path;            } else {                throw e;            }        }    }    if (failNextCreateForTesting) {        failNextCreateForTesting = false;        throw new KeeperException.ConnectionLossException();    }    return createdPath;}
private String curator_f592_1(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-findProtectedNodeInForeground");    String returnPath = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<String>() {        @Override        public String call() throws Exception {            String foundNode = null;            try {                final ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);                List<String> children = client.getZooKeeper().getChildren(pathAndNode.getPath(), false);                foundNode = findNode(children, pathAndNode.getPath(), protectedMode.protectedId());                                foundNode = protectedMode.validateFoundNode(client, createMode, foundNode);            } catch (KeeperException.NoNodeException ignore) {                        }            return foundNode;        }    });    trace.setPath(path).commit();    return returnPath;}
public String curator_f593_1() throws Exception
{    String foundNode = null;    try {        final ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);        List<String> children = client.getZooKeeper().getChildren(pathAndNode.getPath(), false);        foundNode = findNode(children, pathAndNode.getPath(), protectedMode.protectedId());                foundNode = protectedMode.validateFoundNode(client, createMode, foundNode);    } catch (KeeperException.NoNodeException ignore) {        }    return foundNode;}
 String curator_f594_0(String path) throws Exception
{    if (protectedMode.doProtected()) {        ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);        String name = getProtectedPrefix(protectedMode.protectedId()) + pathAndNode.getNode();        path = ZKPaths.makePath(pathAndNode.getPath(), name);    }    return path;}
 static String curator_f595_0(final List<String> children, final String path, final String protectedId)
{    final String protectedPrefix = getProtectedPrefix(protectedId);    String foundNode = Iterables.find(children, new Predicate<String>() {        @Override        public boolean apply(String node) {            return node.startsWith(protectedPrefix);        }    }, null);    if (foundNode != null) {        foundNode = ZKPaths.makePath(path, foundNode);    }    return foundNode;}
public boolean curator_f596_0(String node)
{    return node.startsWith(protectedPrefix);}
 static void curator_f597_0(ZooKeeper zooKeeper, String path, byte[] data, List<ACL> acl, CreateMode createMode, final CompatibleCreateCallback compatibleCallback, Object ctx, long ttl)
{    AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {            compatibleCallback.processResult(rc, path, ctx, name, stat);        }    };    zooKeeper.create(path, data, acl, createMode, callback, ctx, ttl);}
public void curator_f598_0(int rc, String path, Object ctx, String name, Stat stat)
{    compatibleCallback.processResult(rc, path, ctx, name, stat);}
public CuratorEventType curator_f599_0()
{    return type;}
public int curator_f600_0()
{    return resultCode;}
public String curator_f601_0()
{    return path;}
public Object curator_f602_0()
{    return context;}
public Stat curator_f603_0()
{    return stat;}
public byte[] curator_f604_0()
{    return data;}
public String curator_f605_0()
{    return name;}
public List<String> curator_f606_0()
{    return children;}
public WatchedEvent curator_f607_0()
{    return watchedEvent;}
public List<ACL> curator_f608_0()
{    return aclList;}
public List<CuratorTransactionResult> curator_f609_0()
{    return opResults;}
public String curator_f610_0()
{    return "CuratorEventImpl{" + "type=" + type + ", resultCode=" + resultCode + ", path='" + path + '\'' + ", name='" + name + '\'' + ", children=" + children + ", context=" + context + ", stat=" + stat + ", data=" + Arrays.toString(data) + ", watchedEvent=" + watchedEvent + ", aclList=" + aclList + ", opResults=" + opResults + '}';}
public void curator_f611_0(WatchedEvent watchedEvent)
{    CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), null, null, null, null, null, watchedEvent, null, null);    processEvent(event);}
private Executor curator_f612_0(CuratorFrameworkFactory.Builder builder)
{    if (builder.getRunSafeService() != null) {        return builder.getRunSafeService();    }    ThreadFactory threadFactory = builder.getThreadFactory();    if (threadFactory == null) {        threadFactory = ThreadUtils.newThreadFactory("SafeNotifyService");    }    return Executors.newSingleThreadExecutor(threadFactory);}
private List<AuthInfo> curator_f613_0(CuratorFrameworkFactory.Builder builder)
{    ImmutableList.Builder<AuthInfo> builder1 = ImmutableList.builder();    if (builder.getAuthInfos() != null) {        builder1.addAll(builder.getAuthInfos());    }    return builder1.build();}
public CompletableFuture<Void> curator_f614_0(Runnable runnable)
{    return CompletableFuture.runAsync(runnable, runSafeService);}
public WatcherRemoveCuratorFramework curator_f615_0()
{    return new WatcherRemovalFacade(this);}
public QuorumVerifier curator_f616_0()
{    return (ensembleTracker != null) ? ensembleTracker.getCurrentConfig() : null;}
private ZookeeperFactory curator_f617_0(final ZookeeperFactory actualZookeeperFactory)
{    return new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception {            ZooKeeper zooKeeper = actualZookeeperFactory.newZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);            for (AuthInfo auth : authInfos) {                zooKeeper.addAuthInfo(auth.getScheme(), auth.getAuth());            }            return zooKeeper;        }    };}
public ZooKeeper curator_f618_0(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    ZooKeeper zooKeeper = actualZookeeperFactory.newZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);    for (AuthInfo auth : authInfos) {        zooKeeper.addAuthInfo(auth.getScheme(), auth.getAuth());    }    return zooKeeper;}
private ThreadFactory curator_f619_0(CuratorFrameworkFactory.Builder builder)
{    ThreadFactory threadFactory = builder.getThreadFactory();    if (threadFactory == null) {        threadFactory = ThreadUtils.newThreadFactory("Framework");    }    return threadFactory;}
public void curator_f620_0(String path) throws Exception
{    checkExists().creatingParentContainersIfNeeded().forPath(ZKPaths.makePath(path, "foo"));}
public void curator_f621_0(Watcher watcher)
{}
public CuratorFrameworkState curator_f622_0()
{    return state.get();}
public boolean curator_f623_0()
{    return state.get() == CuratorFrameworkState.STARTED;}
public boolean curator_f624_0(int maxWaitTime, TimeUnit units) throws InterruptedException
{    return connectionStateManager.blockUntilConnected(maxWaitTime, units);}
public void curator_f625_0() throws InterruptedException
{    blockUntilConnected(0, null);}
public ConnectionStateErrorPolicy curator_f626_0()
{    return connectionStateErrorPolicy;}
public void curator_f627_1()
{        if (!state.compareAndSet(CuratorFrameworkState.LATENT, CuratorFrameworkState.STARTED)) {        throw new IllegalStateException("Cannot be started more than once");    }    try {                connectionStateManager.start();        final ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState) {                    logAsErrorConnectionErrors.set(true);                }            }            @Override            public boolean doNotProxy() {                return true;            }        };        this.getConnectionStateListenable().addListener(listener);        client.start();        executorService = Executors.newSingleThreadScheduledExecutor(threadFactory);        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                backgroundOperationsLoop();                return null;            }        });        if (ensembleTracker != null) {            ensembleTracker.start();        }            } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleBackgroundOperationException(null, e);    }}
public void curator_f628_0(CuratorFramework client, ConnectionState newState)
{    if (ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState) {        logAsErrorConnectionErrors.set(true);    }}
public boolean curator_f629_0()
{    return true;}
public Object curator_f630_0() throws Exception
{    backgroundOperationsLoop();    return null;}
public void curator_f631_1()
{        if (state.compareAndSet(CuratorFrameworkState.STARTED, CuratorFrameworkState.STOPPED)) {        listeners.forEach(new Function<CuratorListener, Void>() {            @Override            public Void apply(CuratorListener listener) {                CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.CLOSING, 0, null, null, null, null, null, null, null, null, null);                try {                    listener.eventReceived(CuratorFrameworkImpl.this, event);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    }                return null;            }        });        if (executorService != null) {            executorService.shutdownNow();            try {                executorService.awaitTermination(maxCloseWaitMs, TimeUnit.MILLISECONDS);            } catch (InterruptedException e) {                                Thread.currentThread().interrupt();            }        }        if (ensembleTracker != null) {            ensembleTracker.close();        }        listeners.clear();        unhandledErrorListeners.clear();        connectionStateManager.close();        client.close();    }}
public Void curator_f632_1(CuratorListener listener)
{    CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.CLOSING, 0, null, null, null, null, null, null, null, null, null);    try {        listener.eventReceived(CuratorFrameworkImpl.this, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
public CuratorFramework curator_f633_0()
{    return usingNamespace(null);}
public String curator_f634_0()
{    String str = namespace.getNamespace();    return (str != null) ? str : "";}
private void curator_f635_0()
{    CuratorFrameworkState state = getState();    Preconditions.checkState(state == CuratorFrameworkState.STARTED, "Expected state [%s] was [%s]", CuratorFrameworkState.STARTED, state);}
public CuratorFramework curator_f636_0(String newNamespace)
{    checkState();    return namespaceFacadeCache.get(newNamespace);}
public CreateBuilder curator_f637_0()
{    checkState();    return new CreateBuilderImpl(this);}
public DeleteBuilder curator_f638_0()
{    checkState();    return new DeleteBuilderImpl(this);}
public ExistsBuilder curator_f639_0()
{    checkState();    return new ExistsBuilderImpl(this);}
public GetDataBuilder curator_f640_0()
{    checkState();    return new GetDataBuilderImpl(this);}
public SetDataBuilder curator_f641_0()
{    checkState();    return new SetDataBuilderImpl(this);}
public GetChildrenBuilder curator_f642_0()
{    checkState();    return new GetChildrenBuilderImpl(this);}
public GetACLBuilder curator_f643_0()
{    checkState();    return new GetACLBuilderImpl(this);}
public SetACLBuilder curator_f644_0()
{    checkState();    return new SetACLBuilderImpl(this);}
public ReconfigBuilder curator_f645_0()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "reconfig/config APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new ReconfigBuilderImpl(this);}
public GetConfigBuilder curator_f646_0()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "reconfig/config APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new GetConfigBuilderImpl(this);}
public CuratorTransaction curator_f647_0()
{    checkState();    return new CuratorTransactionImpl(this);}
public CuratorMultiTransaction curator_f648_0()
{    checkState();    return new CuratorMultiTransactionImpl(this);}
public TransactionOp curator_f649_0()
{    checkState();    return new TransactionOpImpl(this);}
public Listenable<ConnectionStateListener> curator_f650_0()
{    return connectionStateManager.getListenable();}
public Listenable<CuratorListener> curator_f651_0()
{    return listeners;}
public Listenable<UnhandledErrorListener> curator_f652_0()
{    return unhandledErrorListeners;}
public void curator_f653_0(String path, Object context)
{    checkState();    path = fixForNamespace(path);    internalSync(this, path, context);}
public SyncBuilder curator_f654_0()
{    return new SyncBuilderImpl(this);}
public RemoveWatchesBuilder curator_f655_0()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "Remove watches APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new RemoveWatchesBuilderImpl(this);}
protected void curator_f656_0(CuratorFrameworkImpl impl, String path, Object context)
{    BackgroundOperation<String> operation = new BackgroundSyncImpl(impl, context);    performBackgroundOperation(new OperationAndData<String>(operation, path, null, null, context, null));}
public CuratorZookeeperClient curator_f657_0()
{    return client;}
public EnsurePath curator_f658_0(String path)
{    return namespace.newNamespaceAwareEnsurePath(path);}
public SchemaSet curator_f659_0()
{    return schemaSet;}
 ACLProvider curator_f660_0()
{    return aclProvider;}
 FailedDeleteManager curator_f661_0()
{    return failedDeleteManager;}
 FailedRemoveWatchManager curator_f662_0()
{    return failedRemoveWatcherManager;}
 RetryLoop curator_f663_0()
{    return client.newRetryLoop();}
 ZooKeeper curator_f664_0() throws Exception
{    return client.getZooKeeper();}
 CompressionProvider curator_f665_0()
{    return compressionProvider;}
 boolean curator_f666_0()
{    return useContainerParentsIfAvailable;}
 void curator_f667_0(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    boolean isInitialExecution = (event == null);    if (isInitialExecution) {        performBackgroundOperation(operationAndData);        return;    }    boolean doQueueOperation = false;    do {        if (RetryLoop.shouldRetry(event.getResultCode())) {            doQueueOperation = checkBackgroundRetry(operationAndData, event);            break;        }        if (operationAndData.getCallback() != null) {            sendToBackgroundCallback(operationAndData, event);            break;        }        processEvent(event);    } while (false);    if (doQueueOperation) {        queueOperation(operationAndData);    }}
 boolean curator_f668_0(OperationAndData<DATA_TYPE> operationAndData)
{    if (getState() == CuratorFrameworkState.STARTED) {        backgroundOperations.offer(operationAndData);        return true;    }    return false;}
 void curator_f669_1(String reason, final Throwable e)
{    if ((reason == null) || (reason.length() == 0)) {        reason = "n/a";    }    if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES) || !(e instanceof KeeperException)) {        if (e instanceof KeeperException.ConnectionLossException) {            if (LOG_ALL_CONNECTION_ISSUES_AS_ERROR_LEVEL || logAsErrorConnectionErrors.compareAndSet(true, false)) {                            } else {                            }        } else {                    }    }    final String localReason = reason;    unhandledErrorListeners.forEach(new Function<UnhandledErrorListener, Void>() {        @Override        public Void apply(UnhandledErrorListener listener) {            listener.unhandledError(localReason, e);            return null;        }    });    if (debugUnhandledErrorListener != null) {        debugUnhandledErrorListener.unhandledError(reason, e);    }}
public Void curator_f670_0(UnhandledErrorListener listener)
{    listener.unhandledError(localReason, e);    return null;}
 String curator_f671_0(String path)
{    return namespace.unfixForNamespace(path);}
 String curator_f672_0(String path)
{    return namespace.fixForNamespace(path, false);}
 String curator_f673_0(String path, boolean isSequential)
{    return namespace.fixForNamespace(path, isSequential);}
 byte[] curator_f674_0()
{    return defaultData;}
 NamespaceFacadeCache curator_f675_0()
{    return namespaceFacadeCache;}
 void curator_f676_0(Watcher.Event.KeeperState state)
{    if (state == Watcher.Event.KeeperState.Disconnected) {        internalConnectionHandler.suspendConnection(this);    } else if (state == Watcher.Event.KeeperState.Expired) {        connectionStateManager.addStateChange(ConnectionState.LOST);    } else if (state == Watcher.Event.KeeperState.SyncConnected) {        internalConnectionHandler.checkNewConnection(this);        connectionStateManager.addStateChange(ConnectionState.RECONNECTED);        unSleepBackgroundOperations();    } else if (state == Watcher.Event.KeeperState.ConnectedReadOnly) {        internalConnectionHandler.checkNewConnection(this);        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);    }}
 void curator_f677_0()
{    long instanceIndex = client.getInstanceIndex();    long newInstanceIndex = currentInstanceIndex.getAndSet(instanceIndex);    if (    (newInstanceIndex >= 0) && (instanceIndex != newInstanceIndex)) {        connectionStateManager.addStateChange(ConnectionState.LOST);    }}
 Watcher.Event.KeeperState curator_f678_0(KeeperException.Code code)
{    switch(code) {        case AUTHFAILED:        case NOAUTH:            {                return Watcher.Event.KeeperState.AuthFailed;            }        case CONNECTIONLOSS:        case OPERATIONTIMEOUT:            {                return Watcher.Event.KeeperState.Disconnected;            }        case SESSIONEXPIRED:            {                return Watcher.Event.KeeperState.Expired;            }        case OK:        case SESSIONMOVED:            {                return Watcher.Event.KeeperState.SyncConnected;            }    }    return Watcher.Event.KeeperState.fromInt(-1);}
 WatcherRemovalManager curator_f679_0()
{    return null;}
 boolean curator_f680_0()
{    return connectionStateManager.setToSuspended();}
 void curator_f681_0(ConnectionState newConnectionState)
{    connectionStateManager.addStateChange(newConnectionState);}
public boolean curator_f682_0()
{    return zk34CompatibilityMode;}
 EnsembleTracker curator_f683_0()
{    return ensembleTracker;}
private boolean curator_f684_0(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    boolean doRetry = false;    if (client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)) {        doRetry = true;    } else {        if (operationAndData.getErrorCallback() != null) {            operationAndData.getErrorCallback().retriesExhausted(operationAndData);        }        if (operationAndData.getCallback() != null) {            sendToBackgroundCallback(operationAndData, event);        }        KeeperException.Code code = KeeperException.Code.get(event.getResultCode());        Exception e = null;        try {            e = (code != null) ? KeeperException.create(code) : null;        } catch (Throwable t) {            ThreadUtils.checkInterrupted(t);        }        if (e == null) {            e = new Exception("Unknown result codegetResultCode()");        }        validateConnection(codeToState(code));        logError("Background operation retry gave up", e);    }    return doRetry;}
private void curator_f685_0(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    try {        operationAndData.getCallback().processResult(this, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleBackgroundOperationException(operationAndData, e);    }}
private void curator_f686_1(OperationAndData<DATA_TYPE> operationAndData, Throwable e)
{    do {        if ((operationAndData != null) && RetryLoop.isRetryException(e)) {            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                            }            if (client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)) {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                                    }                backgroundOperations.offer(operationAndData);                break;            } else {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                                    }                if (operationAndData.getErrorCallback() != null) {                    operationAndData.getErrorCallback().retriesExhausted(operationAndData);                }            }        }        logError("Background exception was not retry-able or retry gave up", e);    } while (false);}
private void curator_f687_1()
{    try {        while (state.get() == CuratorFrameworkState.STARTED) {            OperationAndData<?> operationAndData;            try {                operationAndData = backgroundOperations.take();                if (debugListener != null) {                    debugListener.listen(operationAndData);                }                performBackgroundOperation(operationAndData);            } catch (InterruptedException e) {                                                }        }    } finally {            }}
 void curator_f688_0(OperationAndData<?> operationAndData)
{    try {        if (!operationAndData.isConnectionRequired() || client.isConnected()) {            operationAndData.callPerformBackgroundOperation();        } else {                        client.getZooKeeper();            if (operationAndData.getElapsedTimeMs() >= client.getConnectionTimeoutMs()) {                throw new CuratorConnectionLossException();            }            sleepAndQueueOperation(operationAndData);        }    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        /**         * Fix edge case reported as CURATOR-52. ConnectionState.checkTimeouts() throws KeeperException.ConnectionLossException         * when the initial (or previously failed) connection cannot be re-established. This needs to be run through the retry policy         * and callbacks need to get invoked, etc.         */        if (e instanceof CuratorConnectionLossException) {            WatchedEvent watchedEvent = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Disconnected, null);            CuratorEvent event = new CuratorEventImpl(this, CuratorEventType.WATCHED, KeeperException.Code.CONNECTIONLOSS.intValue(), null, null, operationAndData.getContext(), null, null, null, watchedEvent, null, null);            if (checkBackgroundRetry(operationAndData, event)) {                queueOperation(operationAndData);            } else {                logError("Background retry gave up", e);            }        } else {            handleBackgroundOperationException(operationAndData, e);        }    }}
private void curator_f689_0(OperationAndData<?> operationAndData) throws InterruptedException
{    operationAndData.sleepFor(sleepAndQueueOperationSeconds, TimeUnit.SECONDS);    if (queueOperation(operationAndData)) {        forcedSleepOperations.add(operationAndData);    }}
private void curator_f690_1()
{    Collection<OperationAndData<?>> drain = new ArrayList<>(forcedSleepOperations.size());    forcedSleepOperations.drainTo(drain);        for (OperationAndData<?> operation : drain) {        operation.clearSleep();        if (        backgroundOperations.remove(operation)) {            backgroundOperations.offer(operation);        }    }}
private void curator_f691_0(final CuratorEvent curatorEvent)
{    if (curatorEvent.getType() == CuratorEventType.WATCHED) {        validateConnection(curatorEvent.getWatchedEvent().getState());    }    listeners.forEach(new Function<CuratorListener, Void>() {        @Override        public Void apply(CuratorListener listener) {            try {                OperationTrace trace = client.startAdvancedTracer("EventListener");                listener.eventReceived(CuratorFrameworkImpl.this, curatorEvent);                trace.commit();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                logError("Event listener threw exception", e);            }            return null;        }    });}
public Void curator_f692_0(CuratorListener listener)
{    try {        OperationTrace trace = client.startAdvancedTracer("EventListener");        listener.eventReceived(CuratorFrameworkImpl.this, curatorEvent);        trace.commit();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        logError("Event listener threw exception", e);    }    return null;}
public ErrorListenerMultiTransactionMain curator_f693_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerMultiTransactionMain curator_f694_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public ErrorListenerMultiTransactionMain curator_f695_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerMultiTransactionMain curator_f696_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerMultiTransactionMain curator_f697_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
public ErrorListenerMultiTransactionMain curator_f698_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public CuratorMultiTransactionMain curator_f699_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public List<CuratorTransactionResult> curator_f700_0(CuratorOp... operations) throws Exception
{    List<CuratorOp> ops = (operations != null) ? Arrays.asList(operations) : Lists.<CuratorOp>newArrayList();    return forOperations(ops);}
public List<CuratorTransactionResult> curator_f701_0(List<CuratorOp> operations) throws Exception
{    operations = Preconditions.checkNotNull(operations, "operations cannot be null");    Preconditions.checkArgument(!operations.isEmpty(), "operations list cannot be empty");    CuratorMultiTransactionRecord record = new CuratorMultiTransactionRecord();    for (CuratorOp curatorOp : operations) {        Schema schema = client.getSchemaSet().getSchema(curatorOp.getTypeAndPath().getForPath());        record.add(curatorOp.get(), curatorOp.getTypeAndPath().getType(), curatorOp.getTypeAndPath().getForPath());        if ((curatorOp.get().getType() == ZooDefs.OpCode.create) || (curatorOp.get().getType() == ZooDefs.OpCode.createContainer)) {            CreateRequest createRequest = (CreateRequest) curatorOp.get().toRequestRecord();            CreateMode createMode;            if (client.isZk34CompatibilityMode()) {                try {                    createMode = CreateMode.fromFlag(createRequest.getFlags());                } catch (KeeperException.BadArgumentsException dummy) {                    createMode = CreateMode.PERSISTENT;                }            } else {                createMode = CreateMode.fromFlag(createRequest.getFlags(), CreateMode.PERSISTENT);            }            schema.validateCreate(createMode, createRequest.getPath(), createRequest.getData(), createRequest.getAcl());        } else if ((curatorOp.get().getType() == ZooDefs.OpCode.delete) || (curatorOp.get().getType() == ZooDefs.OpCode.deleteContainer)) {            DeleteRequest deleteRequest = (DeleteRequest) curatorOp.get().toRequestRecord();            schema.validateDelete(deleteRequest.getPath());        } else if (curatorOp.get().getType() == ZooDefs.OpCode.setData) {            SetDataRequest setDataRequest = (SetDataRequest) curatorOp.get().toRequestRecord();            schema.validateGeneral(setDataRequest.getPath(), setDataRequest.getData(), null);        }    }    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, record, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);        return null;    } else {        return forOperationsInForeground(record);    }}
public void curator_f702_0(final OperationAndData<CuratorMultiTransactionRecord> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("CuratorMultiTransactionImpl-Background");        AsyncCallback.MultiCallback callback = new AsyncCallback.MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                trace.commit();                List<CuratorTransactionResult> curatorResults = (opResults != null) ? CuratorTransactionImpl.wrapResults(client, opResults, operationAndData.getData()) : null;                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.TRANSACTION, rc, path, null, ctx, null, null, null, null, null, curatorResults);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().multi(operationAndData.getData(), callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f703_0(int rc, String path, Object ctx, List<OpResult> opResults)
{    trace.commit();    List<CuratorTransactionResult> curatorResults = (opResults != null) ? CuratorTransactionImpl.wrapResults(client, opResults, operationAndData.getData()) : null;    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.TRANSACTION, rc, path, null, ctx, null, null, null, null, null, curatorResults);    client.processBackgroundOperation(operationAndData, event);}
private List<CuratorTransactionResult> curator_f704_0(final CuratorMultiTransactionRecord record) throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("CuratorMultiTransactionImpl-Foreground");    List<OpResult> responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<OpResult>>() {        @Override        public List<OpResult> call() throws Exception {            return client.getZooKeeper().multi(record);        }    });    trace.commit();    return CuratorTransactionImpl.wrapResults(client, responseData, record);}
public List<OpResult> curator_f705_0() throws Exception
{    return client.getZooKeeper().multi(record);}
public final void curator_f706_0(Op op)
{    throw new UnsupportedOperationException();}
 void curator_f707_0(Op op, OperationType type, String forPath)
{    super.add(op);    metadata.add(new TypeAndPath(type, forPath));}
 TypeAndPath curator_f708_0(int index)
{    return metadata.get(index);}
 int curator_f709_0()
{    return metadata.size();}
 void curator_f710_0(MessageDigest digest)
{    for (Op op : this) {        digest.update(op.getPath().getBytes());        digest.update(Integer.toString(op.getType()).getBytes());        digest.update(op.toRequestRecord().toString().getBytes());    }}
public void curator_f711_0()
{    closeClient();}
public CuratorTransaction curator_f712_0() throws Exception
{    openConnectionIfNeeded();    return new CuratorTransactionImpl(client);}
public TempGetDataBuilder curator_f713_0() throws Exception
{    openConnectionIfNeeded();    return new TempGetDataBuilderImpl(client);}
 synchronized CuratorFrameworkImpl curator_f714_0()
{    return client;}
 synchronized ScheduledExecutorService curator_f715_0()
{    return cleanup;}
 synchronized void curator_f716_0()
{    lastAccess = System.currentTimeMillis();}
private synchronized void curator_f717_0() throws Exception
{    if (client == null) {                client = (CuratorFrameworkImpl) factory.build();        client.start();    }    if (cleanup == null) {        ThreadFactory threadFactory = factory.getThreadFactory();        if (threadFactory == null) {            threadFactory = ThreadUtils.newGenericThreadFactory("CuratorTempFrameworkImpl");        }        cleanup = Executors.newScheduledThreadPool(1, threadFactory);        Runnable command = new Runnable() {            @Override            public void run() {                checkInactive();            }        };        cleanup.scheduleAtFixedRate(command, inactiveThresholdMs, inactiveThresholdMs, TimeUnit.MILLISECONDS);    }    updateLastAccess();}
public void curator_f718_0()
{    checkInactive();}
private synchronized void curator_f719_0()
{    long elapsed = System.currentTimeMillis() - lastAccess;    if (elapsed >= inactiveThresholdMs) {        closeClient();    }}
private synchronized void curator_f720_0()
{    if (cleanup != null) {        cleanup.shutdownNow();        cleanup = null;    }    if (client != null) {        CloseableUtils.closeQuietly(client);        client = null;    }}
public CuratorTransactionFinal curator_f721_0()
{    return this;}
public TransactionCreateBuilder<CuratorTransactionBridge> curator_f722_0()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new CreateBuilderImpl(client).asTransactionCreateBuilder(asBridge, transaction);}
public TransactionDeleteBuilder<CuratorTransactionBridge> curator_f723_0()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new DeleteBuilderImpl(client).asTransactionDeleteBuilder(asBridge, transaction);}
public TransactionSetDataBuilder<CuratorTransactionBridge> curator_f724_0()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new SetDataBuilderImpl(client).asTransactionSetDataBuilder(asBridge, transaction);}
public TransactionCheckBuilder<CuratorTransactionBridge> curator_f725_0()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return makeTransactionCheckBuilder(client, asBridge, transaction);}
 static TransactionCheckBuilder<T> curator_f726_0(final CuratorFrameworkImpl client, final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionCheckBuilder<T>() {        private int version = -1;        @Override        public T forPath(String path) throws Exception {            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.check(fixedPath, version), OperationType.CHECK, path);            return context;        }        @Override        public Pathable<T> withVersion(int version) {            this.version = version;            return this;        }    };}
public T curator_f727_0(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.check(fixedPath, version), OperationType.CHECK, path);    return context;}
public Pathable<T> curator_f728_0(int version)
{    this.version = version;    return this;}
public Collection<CuratorTransactionResult> curator_f729_0() throws Exception
{    Preconditions.checkState(!isCommitted, "transaction already committed");    isCommitted = true;    List<OpResult> resultList = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<OpResult>>() {        @Override        public List<OpResult> call() throws Exception {            return doOperation();        }    });    if (resultList.size() != transaction.metadataSize()) {        throw new IllegalStateException(String.format("Result size (%d) doesn't match input size (%d)", resultList.size(), transaction.metadataSize()));    }    return wrapResults(client, resultList, transaction);}
public List<OpResult> curator_f730_0() throws Exception
{    return doOperation();}
 static List<CuratorTransactionResult> curator_f731_0(CuratorFrameworkImpl client, List<OpResult> resultList, CuratorMultiTransactionRecord transaction)
{    ImmutableList.Builder<CuratorTransactionResult> builder = ImmutableList.builder();    for (int i = 0; i < resultList.size(); ++i) {        OpResult opResult = resultList.get(i);        TypeAndPath metadata = transaction.getMetadata(i);        CuratorTransactionResult curatorResult = makeCuratorResult(client, opResult, metadata);        builder.add(curatorResult);    }    return builder.build();}
 static CuratorTransactionResult curator_f732_0(CuratorFrameworkImpl client, OpResult opResult, TypeAndPath metadata)
{    String resultPath = null;    Stat resultStat = null;    int error = 0;    switch(opResult.getType()) {        default:            {                                break;            }        case ZooDefs.OpCode.create:            {                OpResult.CreateResult createResult = (OpResult.CreateResult) opResult;                resultPath = client.unfixForNamespace(createResult.getPath());                break;            }        case ZooDefs.OpCode.setData:            {                OpResult.SetDataResult setDataResult = (OpResult.SetDataResult) opResult;                resultStat = setDataResult.getStat();                break;            }        case ZooDefs.OpCode.error:            {                OpResult.ErrorResult errorResult = (OpResult.ErrorResult) opResult;                error = errorResult.getErr();                break;            }    }    return new CuratorTransactionResult(metadata.getType(), metadata.getForPath(), resultPath, resultStat, error);}
private List<OpResult> curator_f733_0() throws Exception
{    List<OpResult> opResults = client.getZooKeeper().multi(transaction);    if (opResults.size() > 0) {        OpResult firstResult = opResults.get(0);        if (firstResult.getType() == ZooDefs.OpCode.error) {            OpResult.ErrorResult error = (OpResult.ErrorResult) firstResult;            KeeperException.Code code = KeeperException.Code.get(error.getErr());            if (code == null) {                code = KeeperException.Code.UNIMPLEMENTED;            }            throw KeeperException.create(code);        }    }    return opResults;}
public List<ACL> curator_f734_0()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
public List<ACL> curator_f735_0(String path)
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
 TransactionDeleteBuilder<T> curator_f736_0(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionDeleteBuilder<T>() {        @Override        public T forPath(String path) throws Exception {            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.delete(fixedPath, version), OperationType.DELETE, path);            return context;        }        @Override        public Pathable<T> withVersion(int version) {            DeleteBuilderImpl.this.withVersion(version);            return this;        }    };}
public T curator_f737_0(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.delete(fixedPath, version), OperationType.DELETE, path);    return context;}
public Pathable<T> curator_f738_0(int version)
{    DeleteBuilderImpl.this.withVersion(version);    return this;}
public DeleteBuilderMain curator_f739_0()
{    quietly = true;    return this;}
public ChildrenDeletable curator_f740_0()
{    guaranteed = true;    return this;}
public BackgroundVersionable curator_f741_0()
{    deletingChildrenIfNeeded = true;    return this;}
public BackgroundPathable<Void> curator_f742_0(int version)
{    this.version = version;    return this;}
public ErrorListenerPathable<Void> curator_f743_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<Void> curator_f744_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathable<Void> curator_f745_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<Void> curator_f746_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public ErrorListenerPathable<Void> curator_f747_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathable<Void> curator_f748_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public Pathable<Void> curator_f749_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public void curator_f750_0(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("DeleteBuilderImpl-Background");        client.getZooKeeper().delete(operationAndData.getData(), version, new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.setReturnCode(rc).setPath(path).commit();                if ((rc == KeeperException.Code.NOTEMPTY.intValue()) && deletingChildrenIfNeeded) {                    backgroundDeleteChildrenThenNode(operationAndData);                } else {                    if ((rc == KeeperException.Code.NONODE.intValue()) && quietly) {                        rc = KeeperException.Code.OK.intValue();                    }                    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.DELETE, rc, path, null, ctx, null, null, null, null, null, null);                    client.processBackgroundOperation(operationAndData, event);                }            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f751_0(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setPath(path).commit();    if ((rc == KeeperException.Code.NOTEMPTY.intValue()) && deletingChildrenIfNeeded) {        backgroundDeleteChildrenThenNode(operationAndData);    } else {        if ((rc == KeeperException.Code.NONODE.intValue()) && quietly) {            rc = KeeperException.Code.OK.intValue();        }        CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.DELETE, rc, path, null, ctx, null, null, null, null, null, null);        client.processBackgroundOperation(operationAndData, event);    }}
private void curator_f752_0(final OperationAndData<String> mainOperationAndData)
{    BackgroundOperation<String> operation = new BackgroundOperation<String>() {        @Override        public void performBackgroundOperation(OperationAndData<String> dummy) throws Exception {            try {                ZKPaths.deleteChildren(client.getZooKeeper(), mainOperationAndData.getData(), false);            } catch (KeeperException e) {                        }            client.queueOperation(mainOperationAndData);        }    };    OperationAndData<String> parentOperation = new OperationAndData<String>(operation, mainOperationAndData.getData(), null, null, backgrounding.getContext(), null);    client.queueOperation(parentOperation);}
public void curator_f753_0(OperationAndData<String> dummy) throws Exception
{    try {        ZKPaths.deleteChildren(client.getZooKeeper(), mainOperationAndData.getData(), false);    } catch (KeeperException e) {        }    client.queueOperation(mainOperationAndData);}
public Void curator_f754_0(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateDelete(path);    final String unfixedPath = path;    path = client.fixForNamespace(path);    if (backgrounding.inBackground()) {        OperationAndData.ErrorCallback<String> errorCallback = null;        if (guaranteed) {            errorCallback = new OperationAndData.ErrorCallback<String>() {                @Override                public void retriesExhausted(OperationAndData<String> operationAndData) {                    client.getFailedDeleteManager().addFailedOperation(unfixedPath);                }            };        }        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), errorCallback, backgrounding.getContext(), null), null);    } else {        pathInForeground(path, unfixedPath);    }    return null;}
public void curator_f755_0(OperationAndData<String> operationAndData)
{    client.getFailedDeleteManager().addFailedOperation(unfixedPath);}
protected int curator_f756_0()
{    return version;}
private void curator_f757_0(final String path, String unfixedPath) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("DeleteBuilderImpl-Foreground");    try {        RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    client.getZooKeeper().delete(path, version);                } catch (KeeperException.NoNodeException e) {                    if (!quietly) {                        throw e;                    }                } catch (KeeperException.NotEmptyException e) {                    if (deletingChildrenIfNeeded) {                        ZKPaths.deleteChildren(client.getZooKeeper(), path, true);                    } else {                        throw e;                    }                }                return null;            }        });    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                if ((RetryLoop.isRetryException(e) || (e instanceof InterruptedException)) && guaranteed) {            client.getFailedDeleteManager().addFailedOperation(unfixedPath);        }        throw e;    }    trace.setPath(path).commit();}
public Void curator_f758_0() throws Exception
{    try {        client.getZooKeeper().delete(path, version);    } catch (KeeperException.NoNodeException e) {        if (!quietly) {            throw e;        }    } catch (KeeperException.NotEmptyException e) {        if (deletingChildrenIfNeeded) {            ZKPaths.deleteChildren(client.getZooKeeper(), path, true);        } else {            throw e;        }    }    return null;}
public void curator_f759_1(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED)) {        try {            reset();        } catch (Exception e) {                    }    }}
public boolean curator_f760_0()
{    return true;}
public void curator_f761_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    reset();}
public void curator_f762_0()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.removeWatchers();        client.getConnectionStateListenable().removeListener(connectionStateListener);    }}
public void curator_f763_0(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {        reset();    }}
public QuorumVerifier curator_f764_0()
{    return currentConfig.get();}
public boolean curator_f765_0()
{    return outstanding.get() > 0;}
private void curator_f766_0() throws Exception
{    if ((client.getState() == CuratorFrameworkState.STARTED) && (state.get() == State.STARTED)) {        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                outstanding.decrementAndGet();                if ((event.getType() == CuratorEventType.GET_CONFIG) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {                    processConfigData(event.getData());                }            }        };        outstanding.incrementAndGet();        try {            client.getConfig().usingWatcher(this).inBackground(backgroundCallback).forEnsemble();                        outstanding.incrementAndGet();        } finally {            outstanding.decrementAndGet();        }    }}
public void curator_f767_0(CuratorFramework client, CuratorEvent event) throws Exception
{    outstanding.decrementAndGet();    if ((event.getType() == CuratorEventType.GET_CONFIG) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {        processConfigData(event.getData());    }}
public static String curator_f768_0(QuorumVerifier data) throws Exception
{    StringBuilder sb = new StringBuilder();    for (QuorumPeer.QuorumServer server : data.getAllMembers().values()) {        if (server.clientAddr == null) {                        continue;        }        if (sb.length() != 0) {            sb.append(",");        }        String hostAddress;        if (server.clientAddr.getAddress().isAnyLocalAddress()) {            hostAddress = server.addr.getAddress().getHostAddress();        } else {            hostAddress = server.clientAddr.getAddress().getHostAddress();        }        sb.append(hostAddress).append(":").append(server.clientAddr.getPort());    }    return sb.toString();}
private void curator_f769_1(byte[] data) throws Exception
{    Properties properties = new Properties();    properties.load(new ByteArrayInputStream(data));        if (!properties.isEmpty()) {        QuorumMaj newConfig = new QuorumMaj(properties);        String connectionString = configToConnectionString(newConfig);        if (connectionString.trim().length() > 0) {            currentConfig.set(newConfig);            ensembleProvider.setConnectionString(connectionString);        } else {                    }    } else {            }}
public ACLableExistBuilderMain curator_f770_0()
{    createParentContainersIfNeeded = false;    createParentsIfNeeded = true;    return this;}
public ACLableExistBuilderMain curator_f771_0()
{    createParentContainersIfNeeded = true;    createParentsIfNeeded = false;    return this;}
public ExistsBuilderMain curator_f772_0(List<ACL> aclList)
{    acling = new ACLing(client.getAclProvider(), aclList, true);    return this;}
public BackgroundPathable<Stat> curator_f773_0()
{    watching = new Watching(client, true);    return this;}
public BackgroundPathable<Stat> curator_f774_0(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
public BackgroundPathable<Stat> curator_f775_0(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
public ErrorListenerPathable<Stat> curator_f776_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<Stat> curator_f777_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathable<Stat> curator_f778_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<Stat> curator_f779_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public ErrorListenerPathable<Stat> curator_f780_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathable<Stat> curator_f781_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public Pathable<Stat> curator_f782_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public void curator_f783_0(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Background");        AsyncCallback.StatCallback callback = new AsyncCallback.StatCallback() {            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                watching.commitWatcher(rc, true);                trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.EXISTS, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().exists(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().exists(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
public void curator_f784_0(int rc, String path, Object ctx, Stat stat)
{    watching.commitWatcher(rc, true);    trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.EXISTS, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
public Stat curator_f785_0(String path) throws Exception
{    path = client.fixForNamespace(path);    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    Stat returnStat = null;    if (backgrounding.inBackground()) {        OperationAndData<String> operationAndData = new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching);        if (createParentContainersIfNeeded || createParentsIfNeeded) {            CreateBuilderImpl.backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData(), backgrounding, acling.getACLProviderForParents(), createParentContainersIfNeeded);        } else {            client.processBackgroundOperation(operationAndData, null);        }    } else {        returnStat = pathInForeground(path);    }    return returnStat;}
private Stat curator_f786_0(final String path) throws Exception
{    if (createParentContainersIfNeeded || createParentsIfNeeded) {        final String parent = ZKPaths.getPathAndNode(path).getPath();        if (!parent.equals(ZKPaths.PATH_SEPARATOR)) {            OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Foreground-CreateParents");            RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {                @Override                public Void call() throws Exception {                    try {                        ZKPaths.mkdirs(client.getZooKeeper(), parent, true, acling.getACLProviderForParents(), createParentContainersIfNeeded);                    } catch (KeeperException.NodeExistsException e) {                                        } catch (KeeperException.NoNodeException e) {                                        }                    return null;                }            });            trace.setPath(path).commit();        }    }    return pathInForegroundStandard(path);}
public Void curator_f787_0() throws Exception
{    try {        ZKPaths.mkdirs(client.getZooKeeper(), parent, true, acling.getACLProviderForParents(), createParentContainersIfNeeded);    } catch (KeeperException.NodeExistsException e) {        } catch (KeeperException.NoNodeException e) {        }    return null;}
private Stat curator_f788_0(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Foreground");    Stat returnStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            Stat returnStat;            if (watching.isWatched()) {                returnStat = client.getZooKeeper().exists(path, true);            } else {                returnStat = client.getZooKeeper().exists(path, watching.getWatcher(path));                int rc = (returnStat != null) ? KeeperException.NoNodeException.Code.OK.intValue() : KeeperException.NoNodeException.Code.NONODE.intValue();                watching.commitWatcher(rc, true);            }            return returnStat;        }    });    trace.setPath(path).setWithWatcher(watching.hasWatcher()).setStat(returnStat).commit();    return returnStat;}
public Stat curator_f789_0() throws Exception
{    Stat returnStat;    if (watching.isWatched()) {        returnStat = client.getZooKeeper().exists(path, true);    } else {        returnStat = client.getZooKeeper().exists(path, watching.getWatcher(path));        int rc = (returnStat != null) ? KeeperException.NoNodeException.Code.OK.intValue() : KeeperException.NoNodeException.Code.NONODE.intValue();        watching.commitWatcher(rc, true);    }    return returnStat;}
 CuratorMultiTransactionRecord curator_f790_0()
{    return record;}
public TypeAndPath curator_f791_0()
{    validate();    return record.getMetadata(0);}
public Op curator_f792_0()
{    validate();    return record.iterator().next();}
public void curator_f793_0(MessageDigest digest)
{    record.addToDigest(digest);}
private void curator_f794_0()
{    Preconditions.checkArgument(record.size() > 0, "No operation has been added");    Preconditions.checkArgument(record.size() == 1, "Multiple operations added");}
protected void curator_f795_0(String path) throws Exception
{    client.delete().guaranteed().inBackground().forPath(path);}
 void curator_f796_1(T details)
{    if (debugListener != null) {        debugListener.pathAddedForGuaranteedOperation(details);    }    if (client.getState() == CuratorFrameworkState.STARTED) {                try {            executeGuaranteedOperationInBackground(details);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            addFailedOperation(details);        }    }}
protected void curator_f797_0(FailedRemoveWatchDetails details) throws Exception
{    if (details.watcher == null) {        client.watches().removeAll().guaranteed().inBackground().forPath(details.path);    } else {        client.watches().remove(details.watcher).guaranteed().inBackground().forPath(details.path);    }}
 void curator_f798_0()
{    OperationAndData.ErrorCallback<Void> errorCallback = new OperationAndData.ErrorCallback<Void>() {        @Override        public void retriesExhausted(OperationAndData<Void> operationAndData) {            operationAndData.reset();            client.processBackgroundOperation(operationAndData, null);        }    };    OperationAndData<Void> operationAndData = new OperationAndData<Void>(this, null, null, errorCallback, null, null);    client.processBackgroundOperation(operationAndData, null);}
public void curator_f799_0(OperationAndData<Void> operationAndData)
{    operationAndData.reset();    client.processBackgroundOperation(operationAndData, null);}
public void curator_f800_1(final OperationAndData<Void> operationAndData) throws Exception
{    final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("FindAndDeleteProtectedNodeInBackground");    AsyncCallback.Children2Callback callback = new AsyncCallback.Children2Callback() {        @Override        public void processResult(int rc, String path, Object o, List<String> strings, Stat stat) {            trace.setReturnCode(rc).setPath(path).setStat(stat).commit();            if (debugInsertError.compareAndSet(true, false)) {                rc = KeeperException.Code.CONNECTIONLOSS.intValue();            }            if (rc == KeeperException.Code.OK.intValue()) {                                final String node = CreateBuilderImpl.findNode(strings, "/", protectedId);                if (node != null) {                    try {                        String deletePath = client.unfixForNamespace(ZKPaths.makePath(namespaceAdjustedParentPath, node));                        client.delete().guaranteed().inBackground().forPath(deletePath);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                                                rc = KeeperException.Code.CONNECTIONLOSS.intValue();                    }                }            }            if (rc != KeeperException.Code.OK.intValue()) {                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }    };    client.getZooKeeper().getChildren(namespaceAdjustedParentPath, false, callback, null);}
public void curator_f801_1(int rc, String path, Object o, List<String> strings, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    if (debugInsertError.compareAndSet(true, false)) {        rc = KeeperException.Code.CONNECTIONLOSS.intValue();    }    if (rc == KeeperException.Code.OK.intValue()) {                final String node = CreateBuilderImpl.findNode(strings, "/", protectedId);        if (node != null) {            try {                String deletePath = client.unfixForNamespace(ZKPaths.makePath(namespaceAdjustedParentPath, node));                client.delete().guaranteed().inBackground().forPath(deletePath);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                                rc = KeeperException.Code.CONNECTIONLOSS.intValue();            }        }    }    if (rc != KeeperException.Code.OK.intValue()) {        CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);        client.processBackgroundOperation(operationAndData, event);    }}
public ErrorListenerPathable<List<ACL>> curator_f802_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<List<ACL>> curator_f803_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathable<List<ACL>> curator_f804_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathable<List<ACL>> curator_f805_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public ErrorListenerPathable<List<ACL>> curator_f806_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<List<ACL>> curator_f807_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public Pathable<List<ACL>> curator_f808_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public Pathable<List<ACL>> curator_f809_0(Stat stat)
{    responseStat = stat;    return this;}
public void curator_f810_0(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetACLBuilderImpl-Background");        AsyncCallback.ACLCallback callback = new AsyncCallback.ACLCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat) {                trace.setReturnCode(rc).setPath(path).setStat(stat).commit();                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.GET_ACL, rc, path, null, ctx, stat, null, null, null, acl, null);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().getACL(operationAndData.getData(), responseStat, callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f811_0(int rc, String path, Object ctx, List<ACL> acl, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.GET_ACL, rc, path, null, ctx, stat, null, null, null, acl, null);    client.processBackgroundOperation(operationAndData, event);}
public List<ACL> curator_f812_0(String path) throws Exception
{    path = client.fixForNamespace(path);    List<ACL> result = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        result = pathInForeground(path);    }    return result;}
private List<ACL> curator_f813_0(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetACLBuilderImpl-Foreground");    List<ACL> result = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<ACL>>() {        @Override        public List<ACL> call() throws Exception {            return client.getZooKeeper().getACL(path, responseStat);        }    });    trace.setPath(path).setStat(responseStat).commit();    return result;}
public List<ACL> curator_f814_0() throws Exception
{    return client.getZooKeeper().getACL(path, responseStat);}
public WatchPathable<List<String>> curator_f815_0(Stat stat)
{    responseStat = stat;    return new WatchPathable<List<String>>() {        @Override        public List<String> forPath(String path) throws Exception {            return GetChildrenBuilderImpl.this.forPath(path);        }        @Override        public Pathable<List<String>> watched() {            GetChildrenBuilderImpl.this.watched();            return GetChildrenBuilderImpl.this;        }        @Override        public Pathable<List<String>> usingWatcher(Watcher watcher) {            GetChildrenBuilderImpl.this.usingWatcher(watcher);            return GetChildrenBuilderImpl.this;        }        @Override        public Pathable<List<String>> usingWatcher(CuratorWatcher watcher) {            GetChildrenBuilderImpl.this.usingWatcher(watcher);            return GetChildrenBuilderImpl.this;        }    };}
public List<String> curator_f816_0(String path) throws Exception
{    return GetChildrenBuilderImpl.this.forPath(path);}
public Pathable<List<String>> curator_f817_0()
{    GetChildrenBuilderImpl.this.watched();    return GetChildrenBuilderImpl.this;}
public Pathable<List<String>> curator_f818_0(Watcher watcher)
{    GetChildrenBuilderImpl.this.usingWatcher(watcher);    return GetChildrenBuilderImpl.this;}
public Pathable<List<String>> curator_f819_0(CuratorWatcher watcher)
{    GetChildrenBuilderImpl.this.usingWatcher(watcher);    return GetChildrenBuilderImpl.this;}
public ErrorListenerPathable<List<String>> curator_f820_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<List<String>> curator_f821_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathable<List<String>> curator_f822_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<List<String>> curator_f823_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public ErrorListenerPathable<List<String>> curator_f824_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathable<List<String>> curator_f825_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public Pathable<List<String>> curator_f826_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public BackgroundPathable<List<String>> curator_f827_0()
{    watching = new Watching(client, true);    return this;}
public BackgroundPathable<List<String>> curator_f828_0(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
public BackgroundPathable<List<String>> curator_f829_0(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
public void curator_f830_0(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetChildrenBuilderImpl-Background");        AsyncCallback.Children2Callback callback = new AsyncCallback.Children2Callback() {            @Override            public void processResult(int rc, String path, Object o, List<String> strings, Stat stat) {                watching.commitWatcher(rc, false);                trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                if (strings == null) {                    strings = Lists.newArrayList();                }                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getChildren(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getChildren(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
public void curator_f831_0(int rc, String path, Object o, List<String> strings, Stat stat)
{    watching.commitWatcher(rc, false);    trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    if (strings == null) {        strings = Lists.newArrayList();    }    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
public List<String> curator_f832_0(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    path = client.fixForNamespace(path);    List<String> children = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);    } else {        children = pathInForeground(path);    }    return children;}
private List<String> curator_f833_0(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetChildrenBuilderImpl-Foreground");    List<String> children = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<String>>() {        @Override        public List<String> call() throws Exception {            List<String> children;            if (watching.isWatched()) {                children = client.getZooKeeper().getChildren(path, true, responseStat);            } else {                children = client.getZooKeeper().getChildren(path, watching.getWatcher(path), responseStat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);            }            return children;        }    });    trace.setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();    return children;}
public List<String> curator_f834_0() throws Exception
{    List<String> children;    if (watching.isWatched()) {        children = client.getZooKeeper().getChildren(path, true, responseStat);    } else {        children = client.getZooKeeper().getChildren(path, watching.getWatcher(path), responseStat);        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    }    return children;}
public WatchBackgroundEnsembleable<byte[]> curator_f835_0(Stat stat)
{    this.stat = stat;    return new WatchBackgroundEnsembleable<byte[]>() {        @Override        public ErrorListenerEnsembleable<byte[]> inBackground() {            return GetConfigBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(Object context) {            return GetConfigBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback) {            return GetConfigBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context) {            return GetConfigBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor) {            return GetConfigBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return GetConfigBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public byte[] forEnsemble() throws Exception {            return GetConfigBuilderImpl.this.forEnsemble();        }        @Override        public BackgroundEnsembleable<byte[]> watched() {            return GetConfigBuilderImpl.this.watched();        }        @Override        public BackgroundEnsembleable<byte[]> usingWatcher(Watcher watcher) {            return GetConfigBuilderImpl.this.usingWatcher(watcher);        }        @Override        public BackgroundEnsembleable<byte[]> usingWatcher(CuratorWatcher watcher) {            return GetConfigBuilderImpl.this.usingWatcher(watcher);        }    };}
public ErrorListenerEnsembleable<byte[]> curator_f836_0()
{    return GetConfigBuilderImpl.this.inBackground();}
public ErrorListenerEnsembleable<byte[]> curator_f837_0(Object context)
{    return GetConfigBuilderImpl.this.inBackground(context);}
public ErrorListenerEnsembleable<byte[]> curator_f838_0(BackgroundCallback callback)
{    return GetConfigBuilderImpl.this.inBackground(callback);}
public ErrorListenerEnsembleable<byte[]> curator_f839_0(BackgroundCallback callback, Object context)
{    return GetConfigBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerEnsembleable<byte[]> curator_f840_0(BackgroundCallback callback, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, executor);}
public ErrorListenerEnsembleable<byte[]> curator_f841_0(BackgroundCallback callback, Object context, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, context, executor);}
public byte[] curator_f842_0() throws Exception
{    return GetConfigBuilderImpl.this.forEnsemble();}
public BackgroundEnsembleable<byte[]> curator_f843_0()
{    return GetConfigBuilderImpl.this.watched();}
public BackgroundEnsembleable<byte[]> curator_f844_0(Watcher watcher)
{    return GetConfigBuilderImpl.this.usingWatcher(watcher);}
public BackgroundEnsembleable<byte[]> curator_f845_0(CuratorWatcher watcher)
{    return GetConfigBuilderImpl.this.usingWatcher(watcher);}
public BackgroundEnsembleable<byte[]> curator_f846_0()
{    watching = new Watching(client, true);    return new InternalBackgroundEnsembleable();}
public BackgroundEnsembleable<byte[]> curator_f847_0(Watcher watcher)
{    watching = new Watching(client, watcher);    return new InternalBackgroundEnsembleable();}
public BackgroundEnsembleable<byte[]> curator_f848_0(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return new InternalBackgroundEnsembleable();}
public ErrorListenerEnsembleable<byte[]> curator_f849_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerEnsembleable<byte[]> curator_f850_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public ErrorListenerEnsembleable<byte[]> curator_f851_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerEnsembleable<byte[]> curator_f852_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerEnsembleable<byte[]> curator_f853_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
public ErrorListenerEnsembleable<byte[]> curator_f854_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public Ensembleable<byte[]> curator_f855_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public byte[] curator_f856_0() throws Exception
{    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<Void>(this, null, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);        return null;    } else {        return configInForeground();    }}
public void curator_f857_0(final OperationAndData<Void> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("GetDataBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                watching.commitWatcher(rc, false);                trace.commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_CONFIG, rc, path, null, ctx, stat, data, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getConfig(true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
public void curator_f858_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    watching.commitWatcher(rc, false);    trace.commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_CONFIG, rc, path, null, ctx, stat, data, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
private byte[] curator_f859_0() throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("GetConfigBuilderImpl-Foreground");    try {        return RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {            @Override            public byte[] call() throws Exception {                if (watching.isWatched()) {                    return client.getZooKeeper().getConfig(true, stat);                }                byte[] config = client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), stat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);                return config;            }        });    } finally {        trace.commit();    }}
public byte[] curator_f860_0() throws Exception
{    if (watching.isWatched()) {        return client.getZooKeeper().getConfig(true, stat);    }    byte[] config = client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), stat);    watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    return config;}
public ErrorListenerEnsembleable<byte[]> curator_f861_0()
{    return GetConfigBuilderImpl.this.inBackground();}
public ErrorListenerEnsembleable<byte[]> curator_f862_0(Object context)
{    return GetConfigBuilderImpl.this.inBackground(context);}
public ErrorListenerEnsembleable<byte[]> curator_f863_0(BackgroundCallback callback)
{    return GetConfigBuilderImpl.this.inBackground(callback);}
public ErrorListenerEnsembleable<byte[]> curator_f864_0(BackgroundCallback callback, Object context)
{    return GetConfigBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerEnsembleable<byte[]> curator_f865_0(BackgroundCallback callback, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, executor);}
public ErrorListenerEnsembleable<byte[]> curator_f866_0(BackgroundCallback callback, Object context, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, context, executor);}
public byte[] curator_f867_0() throws Exception
{    return GetConfigBuilderImpl.this.forEnsemble();}
public GetDataWatchBackgroundStatable curator_f868_0()
{    decompress = true;    return new GetDataWatchBackgroundStatable() {        @Override        public ErrorListenerPathable<byte[]> inBackground() {            return GetDataBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context) {            return GetDataBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return GetDataBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(Object context) {            return GetDataBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback) {            return GetDataBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Executor executor) {            return GetDataBuilderImpl.this.inBackground(callback, executor);        }        @Override        public byte[] forPath(String path) throws Exception {            return GetDataBuilderImpl.this.forPath(path);        }        @Override        public WatchPathable<byte[]> storingStatIn(Stat stat) {            return GetDataBuilderImpl.this.storingStatIn(stat);        }        @Override        public BackgroundPathable<byte[]> watched() {            return GetDataBuilderImpl.this.watched();        }        @Override        public BackgroundPathable<byte[]> usingWatcher(Watcher watcher) {            return GetDataBuilderImpl.this.usingWatcher(watcher);        }        @Override        public BackgroundPathable<byte[]> usingWatcher(CuratorWatcher watcher) {            return GetDataBuilderImpl.this.usingWatcher(watcher);        }    };}
public ErrorListenerPathable<byte[]> curator_f869_0()
{    return GetDataBuilderImpl.this.inBackground();}
public ErrorListenerPathable<byte[]> curator_f870_0(BackgroundCallback callback, Object context)
{    return GetDataBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathable<byte[]> curator_f871_0(BackgroundCallback callback, Object context, Executor executor)
{    return GetDataBuilderImpl.this.inBackground(callback, context, executor);}
public ErrorListenerPathable<byte[]> curator_f872_0(Object context)
{    return GetDataBuilderImpl.this.inBackground(context);}
public ErrorListenerPathable<byte[]> curator_f873_0(BackgroundCallback callback)
{    return GetDataBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathable<byte[]> curator_f874_0(BackgroundCallback callback, Executor executor)
{    return GetDataBuilderImpl.this.inBackground(callback, executor);}
public byte[] curator_f875_0(String path) throws Exception
{    return GetDataBuilderImpl.this.forPath(path);}
public WatchPathable<byte[]> curator_f876_0(Stat stat)
{    return GetDataBuilderImpl.this.storingStatIn(stat);}
public BackgroundPathable<byte[]> curator_f877_0()
{    return GetDataBuilderImpl.this.watched();}
public BackgroundPathable<byte[]> curator_f878_0(Watcher watcher)
{    return GetDataBuilderImpl.this.usingWatcher(watcher);}
public BackgroundPathable<byte[]> curator_f879_0(CuratorWatcher watcher)
{    return GetDataBuilderImpl.this.usingWatcher(watcher);}
public WatchPathable<byte[]> curator_f880_0(Stat stat)
{    this.responseStat = stat;    return new WatchPathable<byte[]>() {        @Override        public byte[] forPath(String path) throws Exception {            return GetDataBuilderImpl.this.forPath(path);        }        @Override        public Pathable<byte[]> watched() {            GetDataBuilderImpl.this.watched();            return GetDataBuilderImpl.this;        }        @Override        public Pathable<byte[]> usingWatcher(Watcher watcher) {            GetDataBuilderImpl.this.usingWatcher(watcher);            return GetDataBuilderImpl.this;        }        @Override        public Pathable<byte[]> usingWatcher(CuratorWatcher watcher) {            GetDataBuilderImpl.this.usingWatcher(watcher);            return GetDataBuilderImpl.this;        }    };}
public byte[] curator_f881_0(String path) throws Exception
{    return GetDataBuilderImpl.this.forPath(path);}
public Pathable<byte[]> curator_f882_0()
{    GetDataBuilderImpl.this.watched();    return GetDataBuilderImpl.this;}
public Pathable<byte[]> curator_f883_0(Watcher watcher)
{    GetDataBuilderImpl.this.usingWatcher(watcher);    return GetDataBuilderImpl.this;}
public Pathable<byte[]> curator_f884_0(CuratorWatcher watcher)
{    GetDataBuilderImpl.this.usingWatcher(watcher);    return GetDataBuilderImpl.this;}
public ErrorListenerPathable<byte[]> curator_f885_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<byte[]> curator_f886_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathable<byte[]> curator_f887_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<byte[]> curator_f888_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public ErrorListenerPathable<byte[]> curator_f889_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathable<byte[]> curator_f890_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public Pathable<byte[]> curator_f891_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public BackgroundPathable<byte[]> curator_f892_0()
{    watching = new Watching(client, true);    return this;}
public BackgroundPathable<byte[]> curator_f893_0(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
public BackgroundPathable<byte[]> curator_f894_0(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
public void curator_f895_1(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                watching.commitWatcher(rc, false);                trace.setReturnCode(rc).setResponseBytesLength(data).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                if ((responseStat != null) && (stat != null)) {                    DataTree.copyStat(stat, responseStat);                }                if (decompress && (data != null)) {                    try {                        data = client.getCompressionProvider().decompress(path, data);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                                                rc = KeeperException.Code.DATAINCONSISTENCY.intValue();                    }                }                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_DATA, rc, path, null, ctx, stat, data, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getData(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getData(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
public void curator_f896_1(int rc, String path, Object ctx, byte[] data, Stat stat)
{    watching.commitWatcher(rc, false);    trace.setReturnCode(rc).setResponseBytesLength(data).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    if ((responseStat != null) && (stat != null)) {        DataTree.copyStat(stat, responseStat);    }    if (decompress && (data != null)) {        try {            data = client.getCompressionProvider().decompress(path, data);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);                        rc = KeeperException.Code.DATAINCONSISTENCY.intValue();        }    }    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_DATA, rc, path, null, ctx, stat, data, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
public byte[] curator_f897_0(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    path = client.fixForNamespace(path);    byte[] responseData = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);    } else {        responseData = pathInForeground(path);    }    return responseData;}
private byte[] curator_f898_0(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            byte[] responseData;            if (watching.isWatched()) {                responseData = client.getZooKeeper().getData(path, true, responseStat);            } else {                responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);            }            return responseData;        }    });    trace.setResponseBytesLength(responseData).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();    return decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;}
public byte[] curator_f899_0() throws Exception
{    byte[] responseData;    if (watching.isWatched()) {        responseData = client.getZooKeeper().getData(path, true, responseStat);    } else {        responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    }    return responseData;}
private static Deflater curator_f900_0()
{    Deflater deflater = DEFLATER_POOL.poll();    if (deflater == null) {                deflater = new Deflater(Deflater.DEFAULT_COMPRESSION, true);    }    return deflater;}
private static Inflater curator_f901_0()
{    Inflater inflater = INFLATER_POOL.poll();    if (inflater == null) {                inflater = new Inflater(true);    }    return inflater;}
public byte[] curator_f902_0(String path, byte[] data)
{    if (data.length == 0) {                return COMPRESSED_EMPTY_BYTES.clone();    }    return doCompress(data);}
 static byte[] curator_f903_0(byte[] data)
{    byte[] result = Arrays.copyOf(GZIP_HEADER, conservativeGZippedSizeEstimate(data.length));    Deflater deflater = acquireDeflater();    try {        deflater.setInput(data);        deflater.finish();        int offset = GZIP_HEADER_SIZE;        while (true) {            int available = result.length - GZIP_TRAILER_SIZE - offset;            int numCompressedBytes = deflater.deflate(result, offset, available);            offset += numCompressedBytes;            if (deflater.finished()) {                break;            }            int newResultLength = result.length + (result.length / 2);            result = Arrays.copyOf(result, newResultLength);        }                CRC32 crc = new CRC32();        crc.update(data, 0, data.length);        writeLittleEndianInt(result, offset, (int) crc.getValue());        writeLittleEndianInt(result, offset + 4, data.length);        int endOffset = offset + GZIP_TRAILER_SIZE;        if (result.length != endOffset) {            result = Arrays.copyOf(result, endOffset);        }        return result;    } finally {        deflater.reset();        DEFLATER_POOL.add(deflater);    }}
private static int curator_f904_0(int dataSize)
{    int conservativeCompressedDataSizeEstimate;    if (dataSize < 512) {                conservativeCompressedDataSizeEstimate = Math.max(dataSize, MIN_COMPRESSED_DATA_SIZE);    } else {                conservativeCompressedDataSizeEstimate = Math.max(512, dataSize / 2);    }    return GZIP_HEADER_SIZE + conservativeCompressedDataSizeEstimate + GZIP_TRAILER_SIZE;}
private static void curator_f905_0(byte[] b, int offset, int v)
{    b[offset] = (byte) v;    b[offset + 1] = (byte) (v >> 8);    b[offset + 2] = (byte) (v >> 16);    b[offset + 3] = (byte) (v >> 24);}
public byte[] curator_f906_0(String path, byte[] gzippedDataBytes) throws IOException
{    if (Arrays.equals(gzippedDataBytes, COMPRESSED_EMPTY_BYTES)) {                return new byte[0];    }    ByteBuffer gzippedData = ByteBuffer.wrap(gzippedDataBytes);    gzippedData.order(ByteOrder.LITTLE_ENDIAN);    int headerSize = readGzipHeader(gzippedData);    if (gzippedDataBytes.length < headerSize + MIN_COMPRESSED_DATA_SIZE + GZIP_TRAILER_SIZE) {        throw new EOFException("Too short GZipped data");    }    int compressedDataSize = gzippedDataBytes.length - headerSize - GZIP_TRAILER_SIZE;            int initialResultLength = (int) Math.min(compressedDataSize * 3L, MAX_SAFE_JAVA_BYTE_ARRAY_SIZE);    byte[] result = new byte[initialResultLength];    Inflater inflater = acquireInflater();    try {        inflater.setInput(gzippedDataBytes, headerSize, compressedDataSize);        CRC32 crc = new CRC32();        int offset = 0;        while (true) {            int numDecompressedBytes;            try {                numDecompressedBytes = inflater.inflate(result, offset, result.length - offset);            } catch (DataFormatException e) {                String s = e.getMessage();                throw new ZipException(s != null ? s : "Invalid ZLIB data format");            }            crc.update(result, offset, numDecompressedBytes);            offset += numDecompressedBytes;            if (inflater.finished() || inflater.needsDictionary()) {                break;            } else             if (numDecompressedBytes == 0 && inflater.needsInput()) {                throw new ZipException("Corrupt GZipped data");            }                        if (result.length == MAX_SAFE_JAVA_BYTE_ARRAY_SIZE && numDecompressedBytes == 0) {                throw new OutOfMemoryError("Unable to uncompress that much data into a single byte[] array");            }            int newResultLength = (int) Math.min((long) result.length + (result.length / 2), MAX_SAFE_JAVA_BYTE_ARRAY_SIZE);            if (result.length != newResultLength) {                result = Arrays.copyOf(result, newResultLength);            }        }        if (inflater.getRemaining() != 0) {            throw new ZipException("Expected just one GZip block, without garbage in the end");        }        int checksum = gzippedData.getInt(gzippedDataBytes.length - GZIP_TRAILER_SIZE);        int numUncompressedBytes = gzippedData.getInt(gzippedDataBytes.length - Integer.BYTES);        if (checksum != (int) crc.getValue() || numUncompressedBytes != offset) {            throw new ZipException("Corrupt GZIP trailer");        }        if (result.length != offset) {            result = Arrays.copyOf(result, offset);        }        return result;    } finally {        inflater.reset();        INFLATER_POOL.add(inflater);    }}
private static int curator_f907_0(ByteBuffer gzippedData) throws IOException
{    try {        return doReadHeader(gzippedData);    } catch (BufferUnderflowException e) {        throw new EOFException();    }}
private static int curator_f908_0(ByteBuffer gzippedData) throws IOException
{    if (gzippedData.getChar() != GZIP_MAGIC) {        throw new ZipException("Not in GZip format");    }    if (gzippedData.get() != Deflater.DEFLATED) {        throw new ZipException("Unsupported compression method");    }    int flags = gzippedData.get();        skip(gzippedData, Integer.BYTES + Byte.BYTES + Byte.BYTES);    if ((flags & FEXTRA) != 0) {        int extraBytes = gzippedData.getChar();        skip(gzippedData, extraBytes);    }    if ((flags & FNAME) != 0) {        skipZeroTerminatedString(gzippedData);    }    if ((flags & FCOMMENT) != 0) {        skipZeroTerminatedString(gzippedData);    }    if ((flags & FHCRC) != 0) {        CRC32 crc = new CRC32();        crc.update(gzippedData.array(), 0, gzippedData.position());        if (gzippedData.getChar() != (char) crc.getValue()) {            throw new ZipException("Corrupt GZIP header");        }    }    return gzippedData.position();}
private static void curator_f909_0(ByteBuffer gzippedData, int skipBytes) throws IOException
{    try {        gzippedData.position(gzippedData.position() + skipBytes);    } catch (IllegalArgumentException e) {        throw new EOFException();    }}
private static void curator_f910_0(ByteBuffer gzippedData)
{    while (gzippedData.get() != 0) {        }}
public CuratorFramework curator_f911_0()
{    return usingNamespace(null);}
public CuratorFramework curator_f912_0(String newNamespace)
{    return client.getNamespaceFacadeCache().get(newNamespace);}
public String curator_f913_0()
{    return namespace.getNamespace();}
public void curator_f914_0()
{    throw new UnsupportedOperationException();}
public void curator_f915_0()
{    throw new UnsupportedOperationException();}
public Listenable<ConnectionStateListener> curator_f916_0()
{    return client.getConnectionStateListenable();}
public Listenable<CuratorListener> curator_f917_0()
{    throw new UnsupportedOperationException("getCuratorListenable() is only available from a non-namespaced CuratorFramework instance");}
public Listenable<UnhandledErrorListener> curator_f918_0()
{    return client.getUnhandledErrorListenable();}
public void curator_f919_0(String path, Object context)
{    internalSync(this, path, context);}
public CuratorZookeeperClient curator_f920_0()
{    return client.getZookeeperClient();}
 RetryLoop curator_f921_0()
{    return client.newRetryLoop();}
 ZooKeeper curator_f922_0() throws Exception
{    return client.getZooKeeper();}
 void curator_f923_0(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    client.processBackgroundOperation(operationAndData, event);}
 void curator_f924_0(String reason, Throwable e)
{    client.logError(reason, e);}
 String curator_f925_0(String path)
{    return namespace.unfixForNamespace(path);}
 String curator_f926_0(String path)
{    return namespace.fixForNamespace(path, false);}
 String curator_f927_0(String path, boolean isSequential)
{    return namespace.fixForNamespace(path, isSequential);}
public EnsurePath curator_f928_0(String path)
{    return namespace.newNamespaceAwareEnsurePath(path);}
 FailedDeleteManager curator_f929_0()
{    return failedDeleteManager;}
public NamespaceFacade curator_f930_0(String namespace) throws Exception
{    return new NamespaceFacade(client, namespace);}
 NamespaceFacade curator_f931_0(String namespace)
{    try {        return (namespace != null) ? cache.get(namespace) : nullNamespace;    } catch (ExecutionException e) {                throw new RuntimeException(e);    }}
 String curator_f932_0()
{    return namespace;}
 String curator_f933_0(String path)
{    if ((namespace != null) && (path != null)) {        String namespacePath = ZKPaths.makePath(namespace, null);        if (!namespacePath.equals("/") && path.startsWith(namespacePath)) {            path = (path.length() > namespacePath.length()) ? path.substring(namespacePath.length()) : "/";        }    }    return path;}
 String curator_f934_0(String path, boolean isSequential)
{    if (ensurePathNeeded.get()) {        try {            final CuratorZookeeperClient zookeeperClient = client.getZookeeperClient();            RetryLoop.callWithRetry(zookeeperClient, new Callable<Object>() {                @Override                public Object call() throws Exception {                    ZKPaths.mkdirs(zookeeperClient.getZooKeeper(), ZKPaths.makePath("/", namespace), true, client.getAclProvider(), true);                    return null;                }            });            ensurePathNeeded.set(false);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            client.logError("Ensure path threw exception", e);        }    }    return ZKPaths.fixForNamespace(namespace, path, isSequential);}
public Object curator_f935_0() throws Exception
{    ZKPaths.mkdirs(zookeeperClient.getZooKeeper(), ZKPaths.makePath("/", namespace), true, client.getAclProvider(), true);    return null;}
 EnsurePath curator_f936_0(String path)
{    return new EnsurePath(fixForNamespace(path, false), client.getAclProvider());}
 String curator_f937_0()
{    return unfixedPath;}
public void curator_f938_0()
{    client = null;    actualWatcher = null;    curatorWatcher = null;}
public void curator_f939_0(WatchedEvent event)
{    if (client != null) {        if ((event.getType() != Event.EventType.None) && (client.getWatcherRemovalManager() != null)) {            client.getWatcherRemovalManager().noteTriggeredWatcher(this);        }        if (actualWatcher != null) {            actualWatcher.process(new NamespaceWatchedEvent(client, event));        } else if (curatorWatcher != null) {            try {                curatorWatcher.process(new NamespaceWatchedEvent(client, event));            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                client.logError("Watcher exception", e);            }        }    }}
public boolean curator_f940_0(Object o)
{    if (this == o) {        return true;    }    if (o == null) {        return false;    }    if (getClass() == o.getClass()) {        NamespaceWatcher watcher = (NamespaceWatcher) o;        return Objects.equal(unfixedPath, watcher.getUnfixedPath()) && Objects.equal(actualWatcher, watcher.actualWatcher) && Objects.equal(curatorWatcher, watcher.curatorWatcher);    }    return false;}
public int curator_f941_0()
{    return Objects.hashCode(actualWatcher, unfixedPath, curatorWatcher);}
 void curator_f942_0()
{    retryCount.set(0);    ordinal.set(nextOrdinal.getAndIncrement());}
 Object curator_f943_0()
{    return context;}
 boolean curator_f944_0()
{    return connectionRequired;}
 void curator_f945_0() throws Exception
{    operation.performBackgroundOperation(this);}
 T curator_f946_0()
{    return data;}
 long curator_f947_0()
{    return System.currentTimeMillis() - startTimeMs;}
 int curator_f948_0()
{    return retryCount.getAndIncrement();}
 BackgroundCallback curator_f949_0()
{    return callback;}
 ErrorCallback<T> curator_f950_0()
{    return errorCallback;}
 BackgroundOperation<T> curator_f951_0()
{    return operation;}
 void curator_f952_0()
{    sleepUntilTimeMs.set(0);}
public void curator_f953_0(long time, TimeUnit unit) throws InterruptedException
{    sleepUntilTimeMs.set(System.currentTimeMillis() + TimeUnit.MILLISECONDS.convert(time, unit));}
public long curator_f954_0(TimeUnit unit)
{    return unit.convert(sleepUntilTimeMs.get() - System.currentTimeMillis(), TimeUnit.MILLISECONDS);}
public int curator_f955_0(Delayed o)
{    if (o == this) {        return 0;    }    long diff = getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS);    if (diff == 0) {        if (o instanceof OperationAndData) {            diff = ordinal.get() - ((OperationAndData) o).ordinal.get();        }    }    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
 String curator_f956_0()
{    return path;}
 byte[] curator_f957_0()
{    return data;}
 void curator_f958_0()
{    doProtected = true;    resetProtectedId();}
 void curator_f959_0()
{    protectedId = UUID.randomUUID().toString();}
 boolean curator_f960_0()
{    return doProtected;}
 String curator_f961_0()
{    return protectedId;}
 void curator_f962_0(CuratorFrameworkImpl client, CreateMode createMode) throws Exception
{    if (doProtected && (sessionId == 0) && createMode.isEphemeral()) {        sessionId = client.getZooKeeper().getSessionId();    }}
 String curator_f963_1(CuratorFrameworkImpl client, CreateMode createMode, String foundNode) throws Exception
{    if (doProtected && createMode.isEphemeral()) {        long clientSessionId = client.getZooKeeper().getSessionId();        if (this.sessionId != clientSessionId) {                        if (foundNode != null) {                                client.getFailedDeleteManager().executeGuaranteedOperationInBackground(foundNode);                foundNode = null;            }            this.sessionId = clientSessionId;        }    }    return foundNode;}
public byte[] curator_f964_0() throws Exception
{    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, null, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);        return new byte[0];    } else {        return ensembleInForeground();    }}
public ErrorListenerReconfigBuilderMain curator_f965_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerReconfigBuilderMain curator_f966_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public ErrorListenerReconfigBuilderMain curator_f967_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerReconfigBuilderMain curator_f968_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerReconfigBuilderMain curator_f969_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
public ErrorListenerReconfigBuilderMain curator_f970_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ReconfigBuilderMain curator_f971_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public StatConfigureEnsembleable curator_f972_0(String... server)
{    return withNewMembers((server != null) ? Arrays.asList(server) : null);}
public StatConfigureEnsembleable curator_f973_0(List<String> servers)
{    newMembers = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new StatConfigureEnsembleable() {        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }    };}
public Ensembleable<byte[]> curator_f974_0(long config) throws Exception
{    fromConfig = config;    return this;}
public byte[] curator_f975_0() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
public ConfigureEnsembleable curator_f976_0(Stat stat)
{    responseStat = stat;    return this;}
public LeaveStatConfigEnsembleable curator_f977_0(String... server)
{    return joining((server != null) ? Arrays.asList(server) : null);}
public LeaveStatConfigEnsembleable curator_f978_0(List<String> servers)
{    joining = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new LeaveStatConfigEnsembleable() {        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public JoinStatConfigEnsembleable leaving(String... server) {            return ReconfigBuilderImpl.this.leaving(server);        }        @Override        public JoinStatConfigEnsembleable leaving(List<String> servers) {            return ReconfigBuilderImpl.this.leaving(servers);        }    };}
public byte[] curator_f979_0() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
public ConfigureEnsembleable curator_f980_0(Stat stat)
{    responseStat = stat;    return this;}
public Ensembleable<byte[]> curator_f981_0(long config) throws Exception
{    fromConfig = config;    return this;}
public JoinStatConfigEnsembleable curator_f982_0(String... server)
{    return ReconfigBuilderImpl.this.leaving(server);}
public JoinStatConfigEnsembleable curator_f983_0(List<String> servers)
{    return ReconfigBuilderImpl.this.leaving(servers);}
public JoinStatConfigEnsembleable curator_f984_0(String... server)
{    return leaving((server != null) ? Arrays.asList(server) : null);}
public JoinStatConfigEnsembleable curator_f985_0(List<String> servers)
{    leaving = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new JoinStatConfigEnsembleable() {        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public LeaveStatConfigEnsembleable joining(String... server) {            return joining((server != null) ? Arrays.asList(server) : null);        }        @Override        public LeaveStatConfigEnsembleable joining(List<String> servers) {            return ReconfigBuilderImpl.this.joining(servers);        }    };}
public byte[] curator_f986_0() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
public ConfigureEnsembleable curator_f987_0(Stat stat)
{    responseStat = stat;    return this;}
public Ensembleable<byte[]> curator_f988_0(long config) throws Exception
{    fromConfig = config;    return this;}
public LeaveStatConfigEnsembleable curator_f989_0(String... server)
{    return joining((server != null) ? Arrays.asList(server) : null);}
public LeaveStatConfigEnsembleable curator_f990_0(List<String> servers)
{    return ReconfigBuilderImpl.this.joining(servers);}
public void curator_f991_0(final OperationAndData<Void> data) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("ReconfigBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat) {                trace.commit();                if ((responseStat != null) && (stat != null)) {                    DataTree.copyStat(stat, responseStat);                }                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.RECONFIG, rc, path, null, ctx, stat, bytes, null, null, null, null);                client.processBackgroundOperation(data, event);            }        };        client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f992_0(int rc, String path, Object ctx, byte[] bytes, Stat stat)
{    trace.commit();    if ((responseStat != null) && (stat != null)) {        DataTree.copyStat(stat, responseStat);    }    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.RECONFIG, rc, path, null, ctx, stat, bytes, null, null, null, null);    client.processBackgroundOperation(data, event);}
private byte[] curator_f993_0() throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("ReconfigBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            return client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, responseStat);        }    });    trace.commit();    return responseData;}
public byte[] curator_f994_0() throws Exception
{    return client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, responseStat);}
 void curator_f995_0(Watcher watcher, String path) throws Exception
{    this.watcher = watcher;    watcherType = WatcherType.Any;    quietly = true;    guaranteed = true;    if (Boolean.getBoolean(DebugUtils.PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND)) {        this.backgrounding = new Backgrounding();        pathInForeground(path);    } else {        this.backgrounding = new Backgrounding(true);        pathInBackground(path);    }}
public RemoveWatchesType curator_f996_0(Watcher watcher)
{    this.watcher = watcher;    this.curatorWatcher = null;    return this;}
public RemoveWatchesType curator_f997_0(CuratorWatcher watcher)
{    this.watcher = null;    this.curatorWatcher = watcher;    return this;}
public RemoveWatchesType curator_f998_0()
{    this.watcher = null;    this.curatorWatcher = null;    return this;}
public RemoveWatchesLocal curator_f999_0(WatcherType watcherType)
{    this.watcherType = watcherType;    return this;}
public ErrorListenerPathable<Void> curator_f1000_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<Void> curator_f1001_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathable<Void> curator_f1002_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<Void> curator_f1003_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public ErrorListenerPathable<Void> curator_f1004_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathable<Void> curator_f1005_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public Pathable<Void> curator_f1006_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public RemoveWatchesLocal curator_f1007_0()
{    guaranteed = true;    return this;}
public BackgroundPathableQuietlyable<Void> curator_f1008_0()
{    local = true;    return this;}
public BackgroundPathable<Void> curator_f1009_0()
{    quietly = true;    return this;}
public Void curator_f1010_0(String path) throws Exception
{    final String adjustedPath = client.fixForNamespace(path);    if (backgrounding.inBackground()) {        pathInBackground(adjustedPath);    } else {        pathInForeground(adjustedPath);    }    return null;}
private void curator_f1011_0(final String path)
{    OperationAndData.ErrorCallback<String> errorCallback = null;        if (guaranteed) {        errorCallback = new OperationAndData.ErrorCallback<String>() {            @Override            public void retriesExhausted(OperationAndData<String> operationAndData) {                client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, watcher));            }        };    }    client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), errorCallback, backgrounding.getContext(), !local), null);}
public void curator_f1012_0(OperationAndData<String> operationAndData)
{    client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, watcher));}
private void curator_f1013_0(final String path) throws Exception
{    NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(path);        if (local) {        ZooKeeper zkClient = client.getZooKeeper();        if (namespaceWatcher != null) {            zkClient.removeWatches(path, namespaceWatcher, watcherType, local);        } else {            zkClient.removeAllWatches(path, watcherType, local);        }    } else {        final NamespaceWatcher finalNamespaceWatcher = namespaceWatcher;        RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    ZooKeeper zkClient = client.getZookeeperClient().getZooKeeper();                    if (finalNamespaceWatcher != null) {                        zkClient.removeWatches(path, finalNamespaceWatcher, watcherType, false);                    } else {                        zkClient.removeAllWatches(path, watcherType, false);                    }                } catch (Exception e) {                    if (RetryLoop.isRetryException(e) && guaranteed) {                                                client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, finalNamespaceWatcher));                        throw e;                    } else if (e instanceof KeeperException.NoWatcherException && quietly) {                                        } else {                                                throw e;                    }                }                return null;            }        });    }}
public Void curator_f1014_0() throws Exception
{    try {        ZooKeeper zkClient = client.getZookeeperClient().getZooKeeper();        if (finalNamespaceWatcher != null) {            zkClient.removeWatches(path, finalNamespaceWatcher, watcherType, false);        } else {            zkClient.removeAllWatches(path, watcherType, false);        }    } catch (Exception e) {        if (RetryLoop.isRetryException(e) && guaranteed) {                        client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, finalNamespaceWatcher));            throw e;        } else if (e instanceof KeeperException.NoWatcherException && quietly) {                } else {                        throw e;        }    }    return null;}
private NamespaceWatcher curator_f1015_0(String path)
{    NamespaceWatcher namespaceWatcher = null;    if (watcher != null) {        if (watcher instanceof NamespaceWatcher) {            namespaceWatcher = (NamespaceWatcher) watcher;        } else {            namespaceWatcher = new NamespaceWatcher(client, watcher, path);        }    } else if (curatorWatcher != null) {        namespaceWatcher = new NamespaceWatcher(client, curatorWatcher, path);    }    return namespaceWatcher;}
public void curator_f1016_0(final OperationAndData<String> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("RemoteWatches-Background");        AsyncCallback.VoidCallback callback = new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, null, ctx, null, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        ZooKeeper zkClient = client.getZooKeeper();        NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(operationAndData.getData());        if (namespaceWatcher == null) {            zkClient.removeAllWatches(operationAndData.getData(), watcherType, local, callback, operationAndData.getContext());        } else {            zkClient.removeWatches(operationAndData.getData(), namespaceWatcher, watcherType, local, callback, operationAndData.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f1017_0(int rc, String path, Object ctx)
{    trace.commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, null, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
public BackgroundPathable<Stat> curator_f1018_0(List<ACL> aclList)
{    acling = new ACLing(client.getAclProvider(), aclList, false);    return this;}
public ACLable<BackgroundPathable<Stat>> curator_f1019_0(int version)
{    this.version = version;    return this;}
public ErrorListenerPathable<Stat> curator_f1020_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathable<Stat> curator_f1021_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public ErrorListenerPathable<Stat> curator_f1022_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<Stat> curator_f1023_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<Stat> curator_f1024_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathable<Stat> curator_f1025_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public Pathable<Stat> curator_f1026_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public Stat curator_f1027_0(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    List<ACL> aclList = acling.getAclList(fixedPath);    client.getSchemaSet().getSchema(path).validateGeneral(path, null, aclList);    Stat resultStat = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, fixedPath, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        resultStat = pathInForeground(fixedPath, aclList);    }    return resultStat;}
public void curator_f1028_0(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetACLBuilderImpl-Background");        String path = operationAndData.getData();        client.getZooKeeper().setACL(path, acling.getAclList(path), version, new AsyncCallback.StatCallback() {            @SuppressWarnings({ "unchecked" })            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                trace.setReturnCode(rc).setPath(path).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_ACL, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f1029_0(int rc, String path, Object ctx, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_ACL, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
private Stat curator_f1030_0(final String path, final List<ACL> aclList) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetACLBuilderImpl-Foreground");    Stat resultStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            return client.getZooKeeper().setACL(path, aclList, version);        }    });    trace.setPath(path).setStat(resultStat).commit();    return resultStat;}
public Stat curator_f1031_0() throws Exception
{    return client.getZooKeeper().setACL(path, aclList, version);}
 TransactionSetDataBuilder<T> curator_f1032_0(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionSetDataBuilder<T>() {        @Override        public T forPath(String path, byte[] data) throws Exception {            if (compress) {                data = client.getCompressionProvider().compress(path, data);            }            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.setData(fixedPath, data, version), OperationType.SET_DATA, path);            return context;        }        @Override        public T forPath(String path) throws Exception {            return forPath(path, client.getDefaultData());        }        @Override        public PathAndBytesable<T> withVersion(int version) {            SetDataBuilderImpl.this.withVersion(version);            return this;        }        @Override        public VersionPathAndBytesable<T> compressed() {            compress = true;            return this;        }    };}
public T curator_f1033_0(String path, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.setData(fixedPath, data, version), OperationType.SET_DATA, path);    return context;}
public T curator_f1034_0(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
public PathAndBytesable<T> curator_f1035_0(int version)
{    SetDataBuilderImpl.this.withVersion(version);    return this;}
public VersionPathAndBytesable<T> curator_f1036_0()
{    compress = true;    return this;}
public SetDataBackgroundVersionable curator_f1037_0()
{    compress = true;    return new SetDataBackgroundVersionable() {        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground() {            return SetDataBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context) {            return SetDataBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return SetDataBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(Object context) {            return SetDataBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback) {            return SetDataBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Executor executor) {            return SetDataBuilderImpl.this.inBackground(callback, executor);        }        @Override        public Stat forPath(String path, byte[] data) throws Exception {            return SetDataBuilderImpl.this.forPath(path, data);        }        @Override        public Stat forPath(String path) throws Exception {            return SetDataBuilderImpl.this.forPath(path);        }        @Override        public BackgroundPathAndBytesable<Stat> withVersion(int version) {            return SetDataBuilderImpl.this.withVersion(version);        }    };}
public ErrorListenerPathAndBytesable<Stat> curator_f1038_0()
{    return SetDataBuilderImpl.this.inBackground();}
public ErrorListenerPathAndBytesable<Stat> curator_f1039_0(BackgroundCallback callback, Object context)
{    return SetDataBuilderImpl.this.inBackground(callback, context);}
public ErrorListenerPathAndBytesable<Stat> curator_f1040_0(BackgroundCallback callback, Object context, Executor executor)
{    return SetDataBuilderImpl.this.inBackground(callback, context, executor);}
public ErrorListenerPathAndBytesable<Stat> curator_f1041_0(Object context)
{    return SetDataBuilderImpl.this.inBackground(context);}
public ErrorListenerPathAndBytesable<Stat> curator_f1042_0(BackgroundCallback callback)
{    return SetDataBuilderImpl.this.inBackground(callback);}
public ErrorListenerPathAndBytesable<Stat> curator_f1043_0(BackgroundCallback callback, Executor executor)
{    return SetDataBuilderImpl.this.inBackground(callback, executor);}
public Stat curator_f1044_0(String path, byte[] data) throws Exception
{    return SetDataBuilderImpl.this.forPath(path, data);}
public Stat curator_f1045_0(String path) throws Exception
{    return SetDataBuilderImpl.this.forPath(path);}
public BackgroundPathAndBytesable<Stat> curator_f1046_0(int version)
{    return SetDataBuilderImpl.this.withVersion(version);}
public BackgroundPathAndBytesable<Stat> curator_f1047_0(int version)
{    this.version = version;    return this;}
public ErrorListenerPathAndBytesable<Stat> curator_f1048_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathAndBytesable<Stat> curator_f1049_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public ErrorListenerPathAndBytesable<Stat> curator_f1050_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathAndBytesable<Stat> curator_f1051_0()
{    backgrounding = new Backgrounding(true);    return this;}
public ErrorListenerPathAndBytesable<Stat> curator_f1052_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public ErrorListenerPathAndBytesable<Stat> curator_f1053_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public PathAndBytesable<Stat> curator_f1054_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public void curator_f1055_0(final OperationAndData<PathAndBytes> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetDataBuilderImpl-Background");        final byte[] data = operationAndData.getData().getData();        client.getZooKeeper().setData(operationAndData.getData().getPath(), data, version, new AsyncCallback.StatCallback() {            @SuppressWarnings({ "unchecked" })            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f1056_0(int rc, String path, Object ctx, Stat stat)
{    trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
public Stat curator_f1057_0(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
public Stat curator_f1058_0(String path, byte[] data) throws Exception
{    client.getSchemaSet().getSchema(path).validateGeneral(path, data, null);    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    path = client.fixForNamespace(path);    Stat resultStat = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, new PathAndBytes(path, data), backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        resultStat = pathInForeground(path, data);    }    return resultStat;}
 int curator_f1059_0()
{    return version;}
private Stat curator_f1060_0(final String path, final byte[] data) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetDataBuilderImpl-Foreground");    Stat resultStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            return client.getZooKeeper().setData(path, data, version);        }    });    trace.setRequestBytesLength(data).setPath(path).setStat(resultStat).commit();    return resultStat;}
public Stat curator_f1061_0() throws Exception
{    return client.getZooKeeper().setData(path, data, version);}
public void curator_f1062_0(CuratorFrameworkImpl client)
{    client.setToSuspended();}
public void curator_f1063_0(CuratorFrameworkImpl client)
{    client.checkInstanceIndex();}
public ErrorListenerPathable<Void> curator_f1064_0()
{        return this;}
public ErrorListenerPathable<Void> curator_f1065_0(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
public ErrorListenerPathable<Void> curator_f1066_0(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
public ErrorListenerPathable<Void> curator_f1067_0(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
public ErrorListenerPathable<Void> curator_f1068_0(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
public ErrorListenerPathable<Void> curator_f1069_0(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
public Pathable<Void> curator_f1070_0(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
public void curator_f1071_0(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SyncBuilderImpl-Background");        final String path = operationAndData.getData();        String adjustedPath = client.fixForNamespace(path);        AsyncCallback.VoidCallback voidCallback = new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.setReturnCode(rc).setPath(path).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, path, ctx, null, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().sync(adjustedPath, voidCallback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
public void curator_f1072_0(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setPath(path).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, path, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
public Void curator_f1073_0(String path) throws Exception
{    OperationAndData<String> operationAndData = new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), null);    client.processBackgroundOperation(operationAndData, null);    return null;}
public StatPathable<byte[]> curator_f1074_0()
{    decompress = true;    return this;}
public Pathable<byte[]> curator_f1075_0(Stat stat)
{    responseStat = stat;    return this;}
public byte[] curator_f1076_0(String path) throws Exception
{    final String localPath = client.fixForNamespace(path);    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            return client.getZooKeeper().getData(localPath, false, responseStat);        }    });    trace.setResponseBytesLength(responseData).setPath(path).setStat(responseStat).commit();    return decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;}
public byte[] curator_f1077_0() throws Exception
{    return client.getZooKeeper().getData(localPath, false, responseStat);}
public TransactionCreateBuilder<CuratorOp> curator_f1078_0()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new CreateBuilderImpl(client).<CuratorOp>asTransactionCreateBuilder(op, op.getRecord());}
public TransactionDeleteBuilder<CuratorOp> curator_f1079_0()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new DeleteBuilderImpl(client).<CuratorOp>asTransactionDeleteBuilder(op, op.getRecord());}
public TransactionSetDataBuilder<CuratorOp> curator_f1080_0()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new SetDataBuilderImpl(client).<CuratorOp>asTransactionSetDataBuilder(op, op.getRecord());}
public TransactionCheckBuilder<CuratorOp> curator_f1081_0()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return CuratorTransactionImpl.<CuratorOp>makeTransactionCheckBuilder(client, op, op.getRecord());}
public WatcherRemoveCuratorFramework curator_f1082_0()
{    return client.newWatcherRemoveCuratorFramework();}
 WatcherRemovalManager curator_f1083_0()
{    return removalManager;}
public QuorumVerifier curator_f1084_0()
{    return client.getCurrentConfig();}
public void curator_f1085_0()
{    removalManager.removeWatchers();}
 WatcherRemovalManager curator_f1086_0()
{    return removalManager;}
public CuratorFramework curator_f1087_0()
{    return client.nonNamespaceView();}
public CuratorFramework curator_f1088_0(String newNamespace)
{    return client.usingNamespace(newNamespace);}
public String curator_f1089_0()
{    return client.getNamespace();}
public void curator_f1090_0()
{    throw new UnsupportedOperationException();}
public void curator_f1091_0()
{    throw new UnsupportedOperationException();}
public Listenable<ConnectionStateListener> curator_f1092_0()
{    return client.getConnectionStateListenable();}
public Listenable<CuratorListener> curator_f1093_0()
{    return client.getCuratorListenable();}
public Listenable<UnhandledErrorListener> curator_f1094_0()
{    return client.getUnhandledErrorListenable();}
public void curator_f1095_0(String path, Object context)
{    client.sync(path, context);}
public CuratorZookeeperClient curator_f1096_0()
{    return client.getZookeeperClient();}
 RetryLoop curator_f1097_0()
{    return client.newRetryLoop();}
 ZooKeeper curator_f1098_0() throws Exception
{    return client.getZooKeeper();}
 void curator_f1099_0(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    client.processBackgroundOperation(operationAndData, event);}
 void curator_f1100_0(String reason, Throwable e)
{    client.logError(reason, e);}
 String curator_f1101_0(String path)
{    return client.unfixForNamespace(path);}
 String curator_f1102_0(String path)
{    return client.fixForNamespace(path);}
 String curator_f1103_0(String path, boolean isSequential)
{    return client.fixForNamespace(path, isSequential);}
public EnsurePath curator_f1104_0(String path)
{    return client.newNamespaceAwareEnsurePath(path);}
 FailedDeleteManager curator_f1105_0()
{    return client.getFailedDeleteManager();}
 void curator_f1106_0(NamespaceWatcher watcher)
{    watcher = Preconditions.checkNotNull(watcher, "watcher cannot be null");    entries.add(watcher);}
 Set<? extends Watcher> curator_f1107_0()
{    return Sets.newHashSet(entries);}
 void curator_f1108_1()
{    if (client.isZk34CompatibilityMode()) {        return;    }    List<NamespaceWatcher> localEntries = Lists.newArrayList(entries);    while (localEntries.size() > 0) {        NamespaceWatcher watcher = localEntries.remove(0);        if (entries.remove(watcher) && !client.isZk34CompatibilityMode()) {            try {                                RemoveWatchesBuilderImpl builder = new RemoveWatchesBuilderImpl(client);                builder.internalRemoval(watcher, watcher.getUnfixedPath());            } catch (Exception e) {                            }        }    }}
 void curator_f1109_0(NamespaceWatcher watcher)
{    entries.remove(watcher);}
 Watcher curator_f1110_0(String unfixedPath)
{    namespaceWatcher = null;    if (watcher != null) {        namespaceWatcher = new NamespaceWatcher(client, this.watcher, unfixedPath);    } else if (curatorWatcher != null) {        namespaceWatcher = new NamespaceWatcher(client, curatorWatcher, unfixedPath);    }    return namespaceWatcher;}
 boolean curator_f1111_0()
{    return (watcher != null) || (curatorWatcher != null);}
 boolean curator_f1112_0()
{    return watched;}
 void curator_f1113_0(int rc, boolean isExists)
{    boolean doCommit = false;    if (isExists) {        doCommit = ((rc == KeeperException.Code.OK.intValue()) || (rc == KeeperException.Code.NONODE.intValue()));    } else {        doCommit = (rc == KeeperException.Code.OK.intValue());    }    if (doCommit && (namespaceWatcher != null)) {        if (client.getWatcherRemovalManager() != null) {            client.getWatcherRemovalManager().add(namespaceWatcher);        }    }}
public void curator_f1114_0(T listener)
{    addListener(listener, MoreExecutors.directExecutor());}
public void curator_f1115_0(T listener, Executor executor)
{    listeners.put(listener, new ListenerEntry<T>(listener, executor));}
public void curator_f1116_0(T listener)
{    if (listener != null) {        listeners.remove(listener);    }}
public void curator_f1117_0()
{    listeners.clear();}
public int curator_f1118_0()
{    return listeners.size();}
public void curator_f1119_1(final Function<T, Void> function)
{    for (final ListenerEntry<T> entry : listeners.values()) {        entry.executor.execute(new Runnable() {            @Override            public void run() {                try {                    function.apply(entry.listener);                } catch (Throwable e) {                    ThreadUtils.checkInterrupted(e);                                    }            }        });    }}
public void curator_f1120_1()
{    try {        function.apply(entry.listener);    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);            }}
 boolean curator_f1121_0()
{    return size() == 0;}
public static ListenerManager<K, V> curator_f1122_0(Function<K, V> mapper)
{    return new MappingListenerManager<>(mapper);}
public void curator_f1123_0(K listener)
{    addListener(listener, Runnable::run);}
public void curator_f1124_0(K listener, Executor executor)
{    V mapped = mapper.apply(listener);    listeners.put(listener, new ListenerEntry<>(mapped, executor));}
public void curator_f1125_0(K listener)
{    if (listener != null) {        listeners.remove(listener);    }}
public void curator_f1126_0()
{    listeners.clear();}
public int curator_f1127_0()
{    return listeners.size();}
public void curator_f1128_1(Consumer<V> function)
{    for (ListenerEntry<V> entry : listeners.values()) {        entry.executor.execute(() -> {            try {                function.accept(entry.listener);            } catch (Throwable e) {                ThreadUtils.checkInterrupted(e);                            }        });    }}
public static StandardListenerManager<T> curator_f1129_0()
{    MappingListenerManager<T, T> container = new MappingListenerManager<>(Function.identity());    return new StandardListenerManager<>(container);}
public static StandardListenerManager<T> curator_f1130_0(UnaryOperator<T> mapper)
{    MappingListenerManager<T, T> container = new MappingListenerManager<>(mapper);    return new StandardListenerManager<>(container);}
public void curator_f1131_0(T listener)
{    container.addListener(listener);}
public void curator_f1132_0(T listener, Executor executor)
{    container.addListener(listener, executor);}
public void curator_f1133_0(T listener)
{    container.removeListener(listener);}
public void curator_f1134_0()
{    container.clear();}
public int curator_f1135_0()
{    return container.size();}
public void curator_f1136_0(Consumer<T> function)
{    container.forEach(function);}
public boolean curator_f1137_0(CreateMode mode)
{    return mode.isTTL();}
public static boolean curator_f1138_0(CreateMode mode)
{    return !Compatibility.isZK34() && Internal.instance.isTtl(mode);}
public boolean curator_f1139_0(Schema schema, String path, byte[] data, List<ACL> acl)
{    return true;}
public static SchemaBuilder curator_f1140_0(String path)
{    return new SchemaBuilder(null, path);}
public static SchemaBuilder curator_f1141_0(Pattern pathRegex)
{    return new SchemaBuilder(pathRegex, null);}
public static SchemaBuilder curator_f1142_0(String parentPath)
{    return new SchemaBuilder(null, parentPath).sequential(Allowance.CANNOT).ephemeral(Allowance.CANNOT);}
public static SchemaBuilder curator_f1143_0(String parentPath)
{    return new SchemaBuilder(Pattern.compile(ZKPaths.makePath(parentPath, ".*")), null).sequential(Allowance.MUST).ephemeral(Allowance.MUST).watched(Allowance.MUST).canBeDeleted(true);}
private String curator_f1144_0(String path)
{    if (path != null) {        if (path.endsWith(ZKPaths.PATH_SEPARATOR)) {            return (path.length() > 1) ? path.substring(0, path.length() - 1) : "";        }        return path;    }    return null;}
public void curator_f1145_0(String path)
{    if (!canBeDeleted) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Cannot be deleted");    }}
public void curator_f1146_0(String path, boolean isWatching)
{    if (isWatching && (watched == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Cannot be watched");    }    if (!isWatching && (watched == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Must be watched");    }}
public void curator_f1147_0(CreateMode mode, String path, byte[] data, List<ACL> acl)
{    if (mode.isEphemeral() && (ephemeral == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Cannot be ephemeral");    }    if (!mode.isEphemeral() && (ephemeral == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Must be ephemeral");    }    if (mode.isSequential() && (sequential == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Cannot be sequential");    }    if (!mode.isSequential() && (sequential == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Must be sequential");    }    validateGeneral(path, data, acl);}
public void curator_f1148_0(String path, byte[] data, List<ACL> acl)
{    if (!schemaValidator.isValid(this, path, data, acl)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Data is not valid");    }}
public String curator_f1149_0()
{    return name;}
public String curator_f1150_0()
{    return (fixedPath != null) ? fixedPath : pathRegex.pattern();}
public Map<String, String> curator_f1151_0()
{    return metadata;}
public Pattern curator_f1152_0()
{    return pathRegex;}
public String curator_f1153_0()
{    return fixedPath;}
public String curator_f1154_0()
{    return documentation;}
public SchemaValidator curator_f1155_0()
{    return schemaValidator;}
public Allowance curator_f1156_0()
{    return ephemeral;}
public Allowance curator_f1157_0()
{    return sequential;}
public Allowance curator_f1158_0()
{    return watched;}
public boolean curator_f1159_0()
{    return canBeDeleted;}
public boolean curator_f1160_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Schema schema = (Schema) o;        if (!pathRegex.equals(schema.pathRegex)) {        return false;    }    return fixedPath.equals(schema.fixedPath);}
public int curator_f1161_0()
{    int result = pathRegex.hashCode();    result = 31 * result + fixedPath.hashCode();    return result;}
public String curator_f1162_0()
{    return "Schema{" + "name='" + name + '\'' + ", pathRegex=" + pathRegex + ", path='" + fixedPath + '\'' + ", documentation='" + documentation + '\'' + ", dataValidator=" + schemaValidator.getClass() + ", ephemeral=" + ephemeral + ", sequential=" + sequential + ", watched=" + watched + ", canBeDeleted=" + canBeDeleted + ", metadata=" + metadata + '}';}
public String curator_f1163_0()
{    String pathLabel = (pathRegex != null) ? "Path Regex: " : "Path: ";    return "Name: " + name + '\n' + pathLabel + getRawPath() + '\n' + "Doc: " + documentation + '\n' + "Validator: " + schemaValidator.getClass().getSimpleName() + '\n' + "Meta: " + metadata + '\n' + String.format("ephemeral: %s | sequential: %s | watched: %s | canBeDeleted: %s", ephemeral, sequential, watched, canBeDeleted) + '\n';}
public Schema curator_f1164_0()
{    return new Schema(name, pathRegex, path, documentation, schemaValidator, ephemeral, sequential, watched, canBeDeleted, metadata);}
public SchemaBuilder curator_f1165_0(String name)
{    this.name = Preconditions.checkNotNull(name, "name cannot be null");    return this;}
public SchemaBuilder curator_f1166_0(String documentation)
{    this.documentation = Preconditions.checkNotNull(documentation, "documentation cannot be null");    return this;}
public SchemaBuilder curator_f1167_0(SchemaValidator schemaValidator)
{    this.schemaValidator = Preconditions.checkNotNull(schemaValidator, "dataValidator cannot be null");    return this;}
public SchemaBuilder curator_f1168_0(Schema.Allowance ephemeral)
{    this.ephemeral = Preconditions.checkNotNull(ephemeral, "ephemeral cannot be null");    return this;}
public SchemaBuilder curator_f1169_0(Schema.Allowance sequential)
{    this.sequential = Preconditions.checkNotNull(sequential, "sequential cannot be null");    return this;}
public SchemaBuilder curator_f1170_0(Schema.Allowance watched)
{    this.watched = watched;    return this;}
public SchemaBuilder curator_f1171_0(boolean canBeDeleted)
{    this.canBeDeleted = canBeDeleted;    return this;}
public SchemaBuilder curator_f1172_0(Map<String, String> metadata)
{    this.metadata = ImmutableMap.copyOf(metadata);    return this;}
public Schema curator_f1173_1(String path) throws Exception
{    for (Schema schema : regexSchemas) {        if (schema.getPathRegex().matcher(path).matches()) {                        return schema;        }    }    return nullSchema;}
public static SchemaSet curator_f1174_0()
{    return new SchemaSet(Collections.<Schema>emptyList(), true) {        @Override        public String toDocumentation() {            return "Default schema";        }    };}
public String curator_f1175_0()
{    return "Default schema";}
public String curator_f1176_0(Schema schema)
{    return schema.getName();}
public Collection<Schema> curator_f1177_0()
{    return schemas.values();}
public Schema curator_f1178_0(String path)
{    if (schemas.size() > 0) {        Schema schema = pathToSchemas.get(path);        if (schema == null) {            try {                schema = regexCache.get(path);                if (schema.equals(nullSchema)) {                    schema = useDefaultSchema ? defaultSchema : null;                }            } catch (ExecutionException e) {                throw new RuntimeException(e);            }        }        if (schema != null) {            return schema;        }    }    if (useDefaultSchema) {        return defaultSchema;    }    throw new SchemaViolation(null, new SchemaViolation.ViolatorData(path, null, null), "No schema found for: " + path);}
public static String curator_f1179_0(CuratorFramework client, String name)
{    return client.getSchemaSet().getNamedSchema(name).getRawPath();}
public Schema curator_f1180_0(String name)
{    return schemas.get(name);}
public String curator_f1181_0()
{    StringBuilder str = new StringBuilder("Curator Schemas:\n\n");    for (Map.Entry<String, Schema> schemaEntry : schemas.entrySet()) {        str.append(schemaEntry.getKey()).append('\n').append(schemaEntry.getValue().toDocumentation()).append('\n');    }    return str.toString();}
public SchemaSet curator_f1182_0(boolean useDefaultSchema)
{    return new SchemaSet(schemas, useDefaultSchema);}
public List<Schema> curator_f1183_0()
{    return schemas;}
private static JsonNode curator_f1184_0(Reader in)
{    try {        return new ObjectMapper().readTree(in);    } catch (IOException e) {        throw new RuntimeException(e);    }}
private void curator_f1185_0(ImmutableList.Builder<Schema> builder, JsonNode node, SchemaValidatorMapper schemaValidatorMapper)
{    for (JsonNode child : node) {        readNode(builder, child, schemaValidatorMapper);    }}
private void curator_f1186_0(ImmutableList.Builder<Schema> builder, JsonNode node, SchemaValidatorMapper schemaValidatorMapper)
{    String name = getText(node, "name", null);    String path = getText(node, "path", null);    boolean isRegex = getBoolean(node, "isRegex");    if (name == null) {        throw new RuntimeException("name is required at: " + node);    }    if (path == null) {        throw new RuntimeException("path is required at: " + node);    }    SchemaBuilder schemaBuilder = isRegex ? Schema.builder(Pattern.compile(path)) : Schema.builder(path);    String schemaValidatorName = getText(node, "schemaValidator", null);    if (schemaValidatorName != null) {        if (schemaValidatorMapper == null) {            throw new RuntimeException("No SchemaValidatorMapper provided but needed at: " + node);        }        schemaBuilder.dataValidator(schemaValidatorMapper.getSchemaValidator(schemaValidatorName));    }    Map<String, String> metadata = Maps.newHashMap();    if (node.has("metadata")) {        JsonNode metadataNode = node.get("metadata");        Iterator<String> fieldNameIterator = metadataNode.fieldNames();        while (fieldNameIterator.hasNext()) {            String fieldName = fieldNameIterator.next();            metadata.put(fieldName, getText(metadataNode, fieldName, ""));        }    }    Schema schema = schemaBuilder.name(name).documentation(getText(node, "documentation", "")).ephemeral(getAllowance(node, "ephemeral")).sequential(getAllowance(node, "sequential")).watched(getAllowance(node, "watched")).canBeDeleted(getBoolean(node, "canBeDeleted")).metadata(metadata).build();    builder.add(schema);}
private String curator_f1187_0(JsonNode node, String name, String defaultValue)
{    JsonNode namedNode = node.get(name);    return (namedNode != null) ? namedNode.asText() : defaultValue;}
private boolean curator_f1188_0(JsonNode node, String name)
{    JsonNode namedNode = node.get(name);    return (namedNode != null) && namedNode.asBoolean();}
private Schema.Allowance curator_f1189_0(JsonNode node, String name)
{    JsonNode namedNode = node.get(name);    try {        return (namedNode != null) ? Schema.Allowance.valueOf(namedNode.asText().toUpperCase()) : Schema.Allowance.CAN;    } catch (IllegalArgumentException ignore) {        throw new RuntimeException("Must be one of: " + Arrays.toString(Schema.Allowance.values()) + " at " + node);    }}
public String curator_f1190_0()
{    return path;}
public byte[] curator_f1191_0()
{    return data;}
public List<ACL> curator_f1192_0()
{    return acl;}
public String curator_f1193_0()
{    String dataString = (data != null) ? new String(data) : "";    return "ViolatorData{" + "path='" + path + '\'' + ", data=" + dataString + ", acl=" + acl + '}';}
public Schema curator_f1194_0()
{    return schema;}
public String curator_f1195_0()
{    return violation;}
public ViolatorData curator_f1196_0()
{    return violatorData;}
public String curator_f1197_0()
{    return toString(schema, violation, violatorData) + super.toString();}
private static String curator_f1198_0(Schema schema, String violation, ViolatorData violatorData)
{    return (violation != null ? violation : "") + " " + schema + " " + violatorData;}
 static CircuitBreaker curator_f1199_0(RetryPolicy retryPolicy)
{    return new CircuitBreaker(retryPolicy, ThreadUtils.newSingleThreadScheduledExecutor("CircuitBreakingConnectionStateListener"));}
 static CircuitBreaker curator_f1200_0(RetryPolicy retryPolicy, ScheduledExecutorService service)
{    return new CircuitBreaker(retryPolicy, service);}
 boolean curator_f1201_0()
{    return isOpen;}
 int curator_f1202_0()
{    return retryCount;}
 boolean curator_f1203_0(Runnable completion)
{    if (isOpen) {        return false;    }    isOpen = true;    retryCount = 0;    startNanos = System.nanoTime();    if (tryToRetry(completion)) {        return true;    }    close();    return false;}
 boolean curator_f1204_0(Runnable completion)
{    if (!isOpen) {        return false;    }    long[] sleepTimeNanos = new long[] { 0L };    RetrySleeper retrySleeper = (time, unit) -> sleepTimeNanos[0] = unit.toNanos(time);    Duration elapsedTime = Duration.ofNanos(System.nanoTime() - startNanos);    if (retryPolicy.allowRetry(retryCount, elapsedTime.toMillis(), retrySleeper)) {        ++retryCount;        service.schedule(completion, sleepTimeNanos[0], TimeUnit.NANOSECONDS);        return true;    }    return false;}
 boolean curator_f1205_0()
{    boolean wasOpen = isOpen;    retryCount = 0;    isOpen = false;    startNanos = 0;    return wasOpen;}
public synchronized void curator_f1206_0(CuratorFramework client, ConnectionState newState)
{    if (circuitBreaker.isOpen()) {        handleOpenStateChange(newState);    } else {        handleClosedStateChange(newState);    }}
public synchronized boolean curator_f1207_0()
{    return circuitBreaker.isOpen();}
private synchronized void curator_f1208_1(ConnectionState newState)
{    if (!newState.isConnected()) {        if (circuitBreaker.tryToOpen(this::checkCloseCircuit)) {                        circuitLastState = circuitInitialState = newState;            circuitLostHasBeenSent = (newState == ConnectionState.LOST);        } else {                    }    }    callListener(newState);}
private synchronized void curator_f1209_1(ConnectionState newState)
{    if (circuitLostHasBeenSent || (newState != ConnectionState.LOST)) {                circuitLastState = newState;    } else {                circuitLostHasBeenSent = true;        circuitLastState = circuitInitialState = ConnectionState.LOST;        callListener(ConnectionState.LOST);    }}
private synchronized void curator_f1210_1()
{    if ((circuitLastState == null) || circuitLastState.isConnected()) {                closeCircuit();    } else if (circuitBreaker.tryToRetry(this::checkCloseCircuit)) {            } else {                closeCircuit();    }}
private synchronized void curator_f1211_0(ConnectionState newState)
{    if (newState != null) {        listener.stateChanged(client, newState);    }}
private synchronized void curator_f1212_0()
{    ConnectionState stateToSend = (circuitLastState == circuitInitialState) ? null : circuitLastState;    reset();    callListener(stateToSend);}
private synchronized void curator_f1213_0()
{    circuitLastState = null;    circuitInitialState = null;    circuitLostHasBeenSent = false;    circuitBreaker.close();}
public void curator_f1214_0()
{    doNotProxyContainer.clear();    mainContainer.clear();}
public int curator_f1215_0()
{    return mainContainer.size() + doNotProxyContainer.size();}
public void curator_f1216_0(Consumer<ConnectionStateListener> function)
{    doNotProxyContainer.forEach(function);    function.accept(masterListener);}
public void curator_f1217_0(ConnectionStateListener listener)
{    if (listener.doNotProxy()) {        doNotProxyContainer.addListener(listener);    } else {        mainContainer.addListener(listener);    }}
public void curator_f1218_0(ConnectionStateListener listener, Executor executor)
{    if (listener.doNotProxy()) {        doNotProxyContainer.addListener(listener, executor);    } else {        mainContainer.addListener(listener, executor);    }}
public void curator_f1219_0(ConnectionStateListener listener)
{    mainContainer.removeListener(listener);    doNotProxyContainer.removeListener(listener);}
public boolean curator_f1220_0()
{    return true;}
public boolean curator_f1221_0()
{    return false;}
public boolean curator_f1222_0()
{    return true;}
public boolean curator_f1223_0()
{    return false;}
public boolean curator_f1224_0()
{    return true;}
 boolean curator_f1225_0()
{    return false;}
 static ConnectionStateListenerManagerFactory curator_f1226_0(RetryPolicy retryPolicy)
{    return client -> new CircuitBreakingManager(client, CircuitBreaker.build(retryPolicy));}
 static ConnectionStateListenerManagerFactory curator_f1227_0(RetryPolicy retryPolicy, ScheduledExecutorService service)
{    return client -> new CircuitBreakingManager(client, CircuitBreaker.build(retryPolicy, service));}
public void curator_f1228_0()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    service.submit(new Callable<Object>() {        @Override        public Object call() throws Exception {            processEvents();            return null;        }    });}
public Object curator_f1229_0() throws Exception
{    processEvents();    return null;}
public void curator_f1230_0()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        service.shutdownNow();        listeners.clear();    }}
public Listenable<ConnectionStateListener> curator_f1231_0()
{    return listeners;}
public synchronized boolean curator_f1232_0()
{    if (state.get() != State.STARTED) {        return false;    }    if ((currentConnectionState == ConnectionState.LOST) || (currentConnectionState == ConnectionState.SUSPENDED)) {        return false;    }    setCurrentConnectionState(ConnectionState.SUSPENDED);    postState(ConnectionState.SUSPENDED);    return true;}
public synchronized boolean curator_f1233_0(ConnectionState newConnectionState)
{    if (state.get() != State.STARTED) {        return false;    }    ConnectionState previousState = currentConnectionState;    if (previousState == newConnectionState) {        return false;    }    setCurrentConnectionState(newConnectionState);    ConnectionState localState = newConnectionState;    boolean isNegativeMessage = ((newConnectionState == ConnectionState.LOST) || (newConnectionState == ConnectionState.SUSPENDED) || (newConnectionState == ConnectionState.READ_ONLY));    if (!isNegativeMessage && initialConnectMessageSent.compareAndSet(false, true)) {        localState = ConnectionState.CONNECTED;    }    postState(localState);    return true;}
public synchronized boolean curator_f1234_0(int maxWaitTime, TimeUnit units) throws InterruptedException
{    long startTime = System.currentTimeMillis();    boolean hasMaxWait = (units != null);    long maxWaitTimeMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWaitTime, units) : 0;    while (!isConnected()) {        if (hasMaxWait) {            long waitTime = maxWaitTimeMs - (System.currentTimeMillis() - startTime);            if (waitTime <= 0) {                return isConnected();            }            wait(waitTime);        } else {            wait();        }    }    return isConnected();}
public synchronized boolean curator_f1235_0()
{    return (currentConnectionState != null) && currentConnectionState.isConnected();}
private void curator_f1236_1(ConnectionState state)
{        notifyAll();    while (!eventQueue.offer(state)) {        eventQueue.poll();            }}
private void curator_f1237_1()
{    while (state.get() == State.STARTED) {        try {            int useSessionTimeoutMs = getUseSessionTimeoutMs();            long elapsedMs = startOfSuspendedEpoch == 0 ? useSessionTimeoutMs / 2 : System.currentTimeMillis() - startOfSuspendedEpoch;            long pollMaxMs = useSessionTimeoutMs - elapsedMs;            final ConnectionState newState = eventQueue.poll(pollMaxMs, TimeUnit.MILLISECONDS);            if (newState != null) {                if (listeners.isEmpty()) {                                    }                listeners.forEach(listener -> listener.stateChanged(client, newState));            } else if (sessionExpirationPercent > 0) {                synchronized (this) {                    checkSessionExpiration();                }            }        } catch (InterruptedException e) {                                }    }}
private void curator_f1238_1()
{    if ((currentConnectionState == ConnectionState.SUSPENDED) && (startOfSuspendedEpoch != 0)) {        long elapsedMs = System.currentTimeMillis() - startOfSuspendedEpoch;        int useSessionTimeoutMs = getUseSessionTimeoutMs();        if (elapsedMs >= useSessionTimeoutMs) {                        startOfSuspendedEpoch = System.currentTimeMillis();                        try {                Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());            } catch (Exception e) {                            }        }    } else if (currentConnectionState == ConnectionState.LOST) {        try {                        client.getZookeeperClient().getZooKeeper();        } catch (Exception e) {                    }    }}
private void curator_f1239_0(ConnectionState newConnectionState)
{    currentConnectionState = newConnectionState;    startOfSuspendedEpoch = (currentConnectionState == ConnectionState.SUSPENDED) ? System.currentTimeMillis() : 0;}
private int curator_f1240_0()
{    int lastNegotiatedSessionTimeoutMs = client.getZookeeperClient().getLastNegotiatedSessionTimeoutMs();    int useSessionTimeoutMs = (lastNegotiatedSessionTimeoutMs > 0) ? lastNegotiatedSessionTimeoutMs : sessionTimeoutMs;    useSessionTimeoutMs = sessionExpirationPercent > 0 && startOfSuspendedEpoch != 0 ? (useSessionTimeoutMs * sessionExpirationPercent) / 100 : useSessionTimeoutMs;    return useSessionTimeoutMs;}
public boolean curator_f1241_0(ConnectionState state)
{    return state == ConnectionState.LOST;}
public boolean curator_f1242_0(ConnectionState state)
{    return ((state == ConnectionState.SUSPENDED) || (state == ConnectionState.LOST));}
public void curator_f1243_0()
{    Semaphore counter = new Semaphore(0);    final CuratorFramework client = newClient(counter);    try {        client.start();        Assert.assertTrue(timing.acquireSemaphore(counter));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1244_0() throws Exception
{    TestingServer oldServer = server;    Semaphore counter = new Semaphore(0);    final CuratorFramework client = newClient(counter);    try {        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        counter.drainPermits();        for (int i = 0; i < 5; ++i) {                        Assert.assertTrue(timing.acquireSemaphore(counter), "Failed when i is: " + i);        }                server = new TestingServer();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(oldServer);    }}
public void curator_f1245_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
private CuratorFramework curator_f1246_0(Semaphore counter)
{    return CuratorFrameworkFactory.builder().ensembleProvider(new CountingEnsembleProvider(counter)).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).build();}
public void curator_f1247_0()
{}
public String curator_f1248_0()
{    getConnectionStringCounter.release();    return server.getConnectString();}
public void curator_f1249_0()
{}
public void curator_f1250_0(String connectionString)
{}
public boolean curator_f1251_0()
{    return false;}
public void curator_f1252_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        final CountDownLatch connectedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState.isConnected()) {                    connectedLatch.countDown();                }            }        });        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch), "Timed out awaiting latch");        Assert.assertTrue(client.blockUntilConnected(1, TimeUnit.SECONDS), "Not connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1253_0(CuratorFramework client, ConnectionState newState)
{    if (newState.isConnected()) {        connectedLatch.countDown();    }}
public void curator_f1254_0()
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Not connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1255_0()
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).build();    final CountDownLatch lostLatch = new CountDownLatch(1);    client.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.LOST) {                lostLatch.countDown();            }        }    });    try {        client.start();                Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Failed to connect");                CloseableUtils.closeQuietly(server);                Assert.assertTrue(timing.awaitLatch(lostLatch), "Failed to reach LOST state");        server = new TestingServer(server.getPort(), server.getTempDirectory());        Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Not connected");    } catch (Exception e) {        Assert.fail("Unexpected exception " + e);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1256_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
public void curator_f1257_0()
{        CloseableUtils.closeQuietly(server);    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        Assert.assertFalse(client.blockUntilConnected(5, TimeUnit.SECONDS), "Connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1258_0()
{        CloseableUtils.closeQuietly(server);    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final Thread threadToInterrupt = Thread.currentThread();        Timer timer = new Timer();        timer.schedule(new TimerTask() {            @Override            public void run() {                threadToInterrupt.interrupt();            }        }, 3000);        client.blockUntilConnected(5, TimeUnit.SECONDS);        Assert.fail("Expected interruption did not occur");    } catch (InterruptedException e) {        } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1259_0()
{    threadToInterrupt.interrupt();}
public void curator_f1260_0() throws InterruptedException
{    CuratorFramework client;    for (int i = 0; i < 50; i++) {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(100));        try {            client.start();            client.blockUntilConnected();            Assert.assertTrue(client.getZookeeperClient().isConnected(), "Not connected after blocking for connection #" + i);        } finally {            client.close();        }    }}
public static void curator_f1261_0(CuratorFramework client)
{    if (client == null) {        return;    }    if (Compatibility.isZK34()) {        CloseableUtils.closeQuietly(client);        return;    }    try {        Timing2 timing = new Timing2();        CuratorFrameworkImpl internalClient = (CuratorFrameworkImpl) client;        EnsembleTracker ensembleTracker = internalClient.getEnsembleTracker();        if (ensembleTracker != null) {            while (ensembleTracker.hasOutstanding()) {                Thread.sleep(100);            }            ensembleTracker.close();        }        ZooKeeper zooKeeper = internalClient.getZooKeeper();        if (zooKeeper != null) {            final int maxLoops = 3;            for (            int i = 0;             i < maxLoops;             ++i) {                if (i > 0) {                    timing.multiple(.5).sleepABit();                }                boolean isLast = (i + 1) == maxLoops;                if (WatchersDebug.getChildWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more child watchers are still registered: " + WatchersDebug.getChildWatches(zooKeeper));                    }                    continue;                }                if (WatchersDebug.getExistWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more exists watchers are still registered: " + WatchersDebug.getExistWatches(zooKeeper));                    }                    continue;                }                if (WatchersDebug.getDataWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more data watchers are still registered: " + WatchersDebug.getDataWatches(zooKeeper));                    }                    continue;                }                break;            }        }    } catch (IllegalStateException ignore) {        } catch (Exception e) {                e.printStackTrace();    } finally {        CloseableUtils.closeQuietly(client);    }}
public static void curator_f1262_0(CuratorFramework client, Callable<Void> proc) throws Exception
{    boolean succeeded = false;    try {        proc.call();        succeeded = true;    } finally {        if (succeeded) {            closeAndTestClean(client);        } else {            CloseableUtils.closeQuietly(client);        }    }}
public void curator_f1263_0() throws Exception
{    final byte[] data = "here's a string".getBytes();    final AtomicInteger compressCounter = new AtomicInteger();    final AtomicInteger decompressCounter = new AtomicInteger();    CompressionProvider compressionProvider = new CompressionProvider() {        @Override        public byte[] compress(String path, byte[] data) throws Exception {            compressCounter.incrementAndGet();            byte[] bytes = new byte[data.length * 2];            System.arraycopy(data, 0, bytes, 0, data.length);            System.arraycopy(data, 0, bytes, data.length, data.length);            return bytes;        }        @Override        public byte[] decompress(String path, byte[] compressedData) throws Exception {            decompressCounter.incrementAndGet();            byte[] bytes = new byte[compressedData.length / 2];            System.arraycopy(compressedData, 0, bytes, 0, bytes.length);            return bytes;        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().compressionProvider(compressionProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        client.create().compressed().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertNotEquals(data, client.getData().forPath("/a/b/c"));        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }    Assert.assertEquals(compressCounter.get(), 1);    Assert.assertEquals(decompressCounter.get(), 1);}
public byte[] curator_f1264_0(String path, byte[] data) throws Exception
{    compressCounter.incrementAndGet();    byte[] bytes = new byte[data.length * 2];    System.arraycopy(data, 0, bytes, 0, data.length);    System.arraycopy(data, 0, bytes, data.length, data.length);    return bytes;}
public byte[] curator_f1265_0(String path, byte[] compressedData) throws Exception
{    decompressCounter.incrementAndGet();    byte[] bytes = new byte[compressedData.length / 2];    System.arraycopy(compressedData, 0, bytes, 0, bytes.length);    return bytes;}
public void curator_f1266_0() throws Exception
{    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertEquals(data, client.getData().forPath("/a/b/c"));        client.setData().compressed().forPath("/a/b/c", data);        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1267_0() throws Exception
{    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().compressed().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertNotEquals(data, client.getData().forPath("/a/b/c"));        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1268_0() throws Exception
{    final String path = "/a";    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                CuratorOp op = client.transactionOp().create().forPath(path, data);        client.transaction().forOperations(op);        Assert.assertEquals(data, client.getData().forPath(path));                op = client.transactionOp().setData().compressed().forPath(path, data);        client.transaction().forOperations(op);        Assert.assertEquals(data, client.getData().decompressed().forPath(path));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1269_0() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1);        CuratorOp op2 = client.transactionOp().create().forPath(path2);        client.transaction().forOperations(op1, op2);                Assert.assertNotNull(client.checkExists().forPath(path1));        Assert.assertNotNull(client.checkExists().forPath(path2));                op1 = client.transactionOp().setData().compressed().forPath(path1, data1);        op2 = client.transactionOp().setData().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1270_0() throws Exception
{    final String path1 = "/a";    final String path2 = "/a/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1, data1);        CuratorOp op2 = client.transactionOp().create().compressed().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertNotEquals(data2, client.getData().forPath(path2));        Assert.assertEquals(data2, client.getData().decompressed().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1271_0() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1, data1);        CuratorOp op2 = client.transactionOp().create().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1272_0() throws Exception
{    final String path = "/a";    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                client.inTransaction().create().forPath(path, data).and().commit();        Assert.assertEquals(data, client.getData().forPath(path));                client.inTransaction().setData().compressed().forPath(path, data).and().commit();        Assert.assertEquals(data, client.getData().decompressed().forPath(path));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1273_0() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                client.inTransaction().create().compressed().forPath(path1).and().create().forPath(path2).and().commit();                Assert.assertNotNull(client.checkExists().forPath(path1));        Assert.assertNotNull(client.checkExists().forPath(path2));                client.inTransaction().setData().compressed().forPath(path1, data1).and().setData().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1274_0() throws Exception
{    final String path1 = "/a";    final String path2 = "/a/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.inTransaction().create().compressed().forPath(path1, data1).and().create().compressed().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertNotEquals(data2, client.getData().forPath(path2));        Assert.assertEquals(data2, client.getData().decompressed().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1275_0() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.inTransaction().create().compressed().forPath(path1, data1).and().create().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
public List<ACL> curator_f1276_0()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
public List<ACL> curator_f1277_0(String path)
{    switch(path) {        case "/bar":            return READ_CREATE;        case "/bar/foo":            return READ_CREATE_WRITE;    }    return null;}
private CuratorFramework curator_f1278_0(ACLProvider aclProvider)
{    return CuratorFrameworkFactory.builder().aclProvider(aclProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
public void curator_f1279_0() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        client.create().creatingParentsIfNeeded().withACL(acl).forPath(path);        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, ZooDefs.Ids.OPEN_ACL_UNSAFE);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1280_0() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        client.create().creatingParentsIfNeeded().withACL(acl, true).forPath(path);        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1281_0() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().creatingParentsIfNeeded().withACL(acl).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, ZooDefs.Ids.OPEN_ACL_UNSAFE);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1282_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
public void curator_f1283_0() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().creatingParentsIfNeeded().withACL(acl, true).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1284_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
public void curator_f1285_0() throws Exception
{    CuratorFramework client = createClient(testACLProvider);    try {        client.start();        String path = "/bar/foo/boo";        client.create().creatingParentsIfNeeded().forPath(path);        List<ACL> actual_bar_foo_boo = client.getACL().forPath("/bar/foo/boo");        Assert.assertEquals(actual_bar_foo_boo, ZooDefs.Ids.OPEN_ACL_UNSAFE);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, READ_CREATE_WRITE);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, READ_CREATE);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1286_0() throws Exception
{    CuratorFramework client = createClient(testACLProvider);    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        final String path = "/bar/foo/boo";        client.create().creatingParentsIfNeeded().inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo_boo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo_boo, ZooDefs.Ids.OPEN_ACL_UNSAFE);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, READ_CREATE_WRITE);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, READ_CREATE);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1287_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
private CuratorFramework curator_f1288_0()
{    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
private void curator_f1289_0(CuratorFramework client, String path, Stat expected) throws Exception
{    Stat queriedStat = client.checkExists().forPath(path);    Assert.assertEquals(queriedStat, expected);}
public void curator_f1290_0() throws Exception
{    try (CuratorFramework client = createClient()) {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final String path = "/test";        final Stat versionZeroStat = new Stat();        client.create().orSetData().storingStatIn(versionZeroStat).forPath(path);        Assert.assertEquals(0, versionZeroStat.getVersion());        final Stat versionOneStat = new Stat();        client.create().orSetData().storingStatIn(versionOneStat).forPath(path);        Assert.assertEquals(versionZeroStat.getAversion(), versionOneStat.getAversion());        Assert.assertEquals(versionZeroStat.getCtime(), versionOneStat.getCtime());        Assert.assertEquals(versionZeroStat.getCversion(), versionOneStat.getCversion());        Assert.assertEquals(versionZeroStat.getCzxid(), versionOneStat.getCzxid());        Assert.assertEquals(versionZeroStat.getDataLength(), versionOneStat.getDataLength());        Assert.assertEquals(versionZeroStat.getEphemeralOwner(), versionOneStat.getEphemeralOwner());        Assert.assertTrue(versionZeroStat.getMtime() <= versionOneStat.getMtime());        Assert.assertNotEquals(versionZeroStat.getMzxid(), versionOneStat.getMzxid());        Assert.assertEquals(versionZeroStat.getNumChildren(), versionOneStat.getNumChildren());        Assert.assertEquals(versionZeroStat.getPzxid(), versionOneStat.getPzxid());        Assert.assertEquals(1, versionOneStat.getVersion());    }}
public void curator_f1291_0() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        client.create().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1292_0() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla/bla";        Stat stat = new Stat();        client.create().creatingParentsIfNeeded().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1293_0() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla/bla";        Stat stat = new Stat();        client.create().storingStatIn(stat).creatingParentsIfNeeded().forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1294_0() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        client.create().compressed().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1295_0() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        path = client.create().withProtection().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1296_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        final CountDownLatch latch = new CountDownLatch(1);        final AtomicReference<Stat> statRef = new AtomicReference<>();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    statRef.set(event.getStat());                    latch.countDown();                }            }        };        client.create().storingStatIn(stat).inBackground(callback).forPath(path);        if (!timing.awaitLatch(latch)) {            Assert.fail("Timed out awaing latch");        }        compare(client, path, statRef.get());        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1297_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        statRef.set(event.getStat());        latch.countDown();    }}
public void curator_f1298_0() throws Exception
{    super.setup();    client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).build();    client.start();    states = Queues.newLinkedBlockingQueue();    ConnectionStateListener listener = new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            states.add(newState);        }    };    client.getConnectionStateListenable().addListener(listener);}
public void curator_f1299_0(CuratorFramework client, ConnectionState newState)
{    states.add(newState);}
public void curator_f1300_0() throws Exception
{    try {        CloseableUtils.closeQuietly(client);    } finally {        super.teardown();    }}
public void curator_f1301_0() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);        client.checkExists().forPath("/");    client.getZookeeperClient().reset();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
public void curator_f1302_0() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.None) {                if (event.getState() == Event.KeeperState.Expired) {                    latch.countDown();                }            }        }    };    client.checkExists().usingWatcher(watcher).forPath("/");    server.stop();    Assert.assertTrue(timing.forSessionSleep().awaitLatch(latch));}
public void curator_f1303_0(WatchedEvent event)
{    if (event.getType() == Event.EventType.None) {        if (event.getState() == Event.KeeperState.Expired) {            latch.countDown();        }    }}
public void curator_f1304_0() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
public void curator_f1305_0() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    try {                client.checkExists().forPath("/");    } catch (KeeperException.ConnectionLossException ignore) {    }    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    server.restart();    client.checkExists().forPath("/");    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
public void curator_f1306_0() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);}
public void curator_f1307_0() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    timing.forSessionSleep().sleep();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    server.restart();    client.checkExists().forPath("/");    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);        Assert.assertNull(states.poll(timing.multiple(.5).milliseconds(), TimeUnit.MILLISECONDS));}
public void curator_f1308_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        EnsureContainers ensureContainers = new EnsureContainers(client, "/one/two/three");        ensureContainers.ensure();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1309_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        EnsureContainers ensureContainers = new EnsureContainers(client, "/one/two/three");        ensureContainers.ensure();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client.delete().forPath("/one/two/three");        ensureContainers.ensure();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1310_0() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo/test";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        assertNull(client.checkExists().creatingParentsIfNeeded().withACL(acl).forPath(path));        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1311_0() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo/test";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.checkExists().creatingParentsIfNeeded().withACL(acl).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1312_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
private CuratorFramework curator_f1313_0(ACLProvider aclProvider)
{    return CuratorFrameworkFactory.builder().aclProvider(aclProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
public void curator_f1314_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        client.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            client.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1315_0(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
public void curator_f1316_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).namespace("aisa").build();    try {        client.start();        client.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            client.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1317_0(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
public void curator_f1318_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();    try {        client.start();        CuratorFramework namespaceClient = client.usingNamespace("foo");        namespaceClient.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        namespaceClient.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            namespaceClient.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(namespaceClient.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1319_0(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
public void curator_f1320_0() throws Exception
{    final String PATH = "/one/two/three";    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session());    CuratorFrameworkImpl client = new CuratorFrameworkImpl(builder);    client.start();    try {        client.create().creatingParentsIfNeeded().forPath(PATH);        Assert.assertNotNull(client.checkExists().forPath(PATH));                server.stop();        try {            client.delete().forPath(PATH);            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        server.restart();        Assert.assertNotNull(client.checkExists().forPath(PATH));                server.stop();        try {            client.delete().guaranteed().forPath(PATH);            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        server.restart();        final int TRIES = 5;        for (int i = 0; i < TRIES; ++i) {            if (client.checkExists().forPath(PATH) != null) {                timing.sleepABit();            }        }        Assert.assertNull(client.checkExists().forPath(PATH));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1321_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    final AtomicBoolean pathAdded = new AtomicBoolean(false);    ((CuratorFrameworkImpl) client).getFailedDeleteManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<String>() {        @Override        public void pathAddedForGuaranteedOperation(String path) {            pathAdded.set(true);        }    };    try {        client.delete().guaranteed().forPath("/nonexistent");        Assert.fail();    } catch (NoNodeException e) {                Assert.assertFalse(pathAdded.get());    } finally {        client.close();    }}
public void curator_f1322_0(String path)
{    pathAdded.set(true);}
public void curator_f1323_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    final AtomicBoolean pathAdded = new AtomicBoolean(false);    ((CuratorFrameworkImpl) client).getFailedDeleteManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<String>() {        @Override        public void pathAddedForGuaranteedOperation(String path) {            pathAdded.set(true);        }    };    final CountDownLatch backgroundLatch = new CountDownLatch(1);    BackgroundCallback background = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            backgroundLatch.countDown();        }    };    try {        client.delete().guaranteed().inBackground(background).forPath("/nonexistent");        backgroundLatch.await();                Assert.assertFalse(pathAdded.get());    } finally {        client.close();    }}
public void curator_f1324_0(String path)
{    pathAdded.set(true);}
public void curator_f1325_0(CuratorFramework client, CuratorEvent event) throws Exception
{    backgroundLatch.countDown();}
public void curator_f1326_0() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1000");    super.setup();}
public void curator_f1327_0() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
public void curator_f1328_0() throws Exception
{    final BlockingQueue<Integer> timeoutQueue = new ArrayBlockingQueue<>(1);    ZookeeperFactory zookeeperFactory = new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException {            return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly) {                @Override                public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException {                    timeoutQueue.add(waitForShutdownTimeoutMs);                    return super.close(waitForShutdownTimeoutMs);                }            };        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).zookeeperFactory(zookeeperFactory).waitForShutdownTimeoutMs(10064).build();    try {        client.start();        client.checkExists().forPath("/foo");    } finally {        CloseableUtils.closeQuietly(client);    }    Integer polledValue = timeoutQueue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);    Assert.assertNotNull(polledValue);    Assert.assertEquals(10064, polledValue.intValue());}
public ZooKeeper curator_f1329_0(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException
{    return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly) {        @Override        public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException {            timeoutQueue.add(waitForShutdownTimeoutMs);            return super.close(waitForShutdownTimeoutMs);        }    };}
public boolean curator_f1330_0(int waitForShutdownTimeoutMs) throws InterruptedException
{    timeoutQueue.add(waitForShutdownTimeoutMs);    return super.close(waitForShutdownTimeoutMs);}
public void curator_f1331_0() throws Exception
{    final Timing timing = new Timing();    try (final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.forWaiting().milliseconds(), timing.connection(), new RetryOneTime(1))) {        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch restartedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                } else if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    restartedLatch.countDown();                }            }        });        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.stop();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(lostLatch));        server.restart();        Assert.assertTrue(timing.awaitLatch(restartedLatch));    }}
public void curator_f1332_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    } else if (newState == ConnectionState.LOST) {        lostLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        restartedLatch.countDown();    }}
public void curator_f1333_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        final BlockingQueue<ConnectionState> queue = new LinkedBlockingQueue<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                queue.add(newState);            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.CONNECTED);        server.stop();        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1334_0(CuratorFramework client, ConnectionState newState)
{    queue.add(newState);}
public void curator_f1335_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        String name = client.create().forPath("/hey", "there".getBytes());        Assert.assertEquals(name, "/hey");        name = client.create().orSetData().forPath("/hey", "other".getBytes());        Assert.assertEquals(name, "/hey");        Assert.assertEquals(client.getData().forPath("/hey"), "other".getBytes());        name = client.create().orSetData().creatingParentsIfNeeded().forPath("/a/b/c", "there".getBytes());        Assert.assertEquals(name, "/a/b/c");        name = client.create().orSetData().creatingParentsIfNeeded().forPath("/a/b/c", "what".getBytes());        Assert.assertEquals(name, "/a/b/c");        Assert.assertEquals(client.getData().forPath("/a/b/c"), "what".getBytes());        final BlockingQueue<CuratorEvent> queue = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event);            }        };        client.create().orSetData().inBackground(backgroundCallback).forPath("/a/b/c", "another".getBytes());        CuratorEvent event = queue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(event);        Assert.assertEquals(event.getResultCode(), KeeperException.Code.OK.intValue());        Assert.assertEquals(event.getType(), CuratorEventType.CREATE);        Assert.assertEquals(event.getPath(), "/a/b/c");        Assert.assertEquals(event.getName(), "/a/b/c");                CuratorEvent unexpectedEvent = queue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNull(unexpectedEvent);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1336_0(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event);}
public void curator_f1337_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.delete().quietly().forPath("/foo/bar");        final BlockingQueue<Integer> rc = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                rc.add(event.getResultCode());            }        };        client.delete().quietly().inBackground(backgroundCallback).forPath("/foo/bar/hey");        Integer code = rc.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(code);        Assert.assertEquals(code.intValue(), KeeperException.Code.OK.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1338_0(CuratorFramework client, CuratorEvent event) throws Exception
{    rc.add(event.getResultCode());}
public void curator_f1339_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                try {                    queue.put(event.getPath());                } catch (InterruptedException e) {                    throw new Error(e);                }            }        };        client.create().forPath("/base");        client.getChildren().usingWatcher(watcher).forPath("/base");        client.create().forPath("/base/child");        String path = new Timing2().takeFromQueue(queue);        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1340_0(WatchedEvent event)
{    try {        queue.put(event.getPath());    } catch (InterruptedException e) {        throw new Error(e);    }}
public void curator_f1341_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        CuratorListener listener = new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.EXISTS) {                    queue.put(event.getPath());                }            }        };        client.getCuratorListenable().addListener(listener);        client.create().forPath("/base");        client.checkExists().inBackground().forPath("/base");        String path = queue.poll(10, TimeUnit.SECONDS);        Assert.assertEquals(path, "/base");        client.getCuratorListenable().removeListener(listener);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.put(event.getPath());            }        };        client.getChildren().inBackground(callback).forPath("/base");        path = queue.poll(10, TimeUnit.SECONDS);        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1342_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.EXISTS) {        queue.put(event.getPath());    }}
public void curator_f1343_0(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.put(event.getPath());}
public void curator_f1344_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());            Assert.fail("Should have failed with auth exception");        } catch (KeeperException.NoAuthException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1345_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1));    Assert.assertNull(builder.getAuthScheme());    Assert.assertNull(builder.getAuthValue());    builder = builder.authorization("digest", "me1:pass1".getBytes());    Assert.assertEquals(builder.getAuthScheme(), "digest");    Assert.assertEquals(builder.getAuthValue(), "me1:pass1".getBytes());}
public void curator_f1346_0() throws Exception
{        List<AuthInfo> authInfos = new ArrayList<AuthInfo>();    authInfos.add(new AuthInfo("digest", "me1:pass1".getBytes()));    authInfos.add(new AuthInfo("digest", "me2:pass2".getBytes()));    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization(authInfos).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me2:pass2".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());            Assert.fail("Should have failed with auth exception");        } catch (KeeperException.NoAuthException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1347_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", "me:pass".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            client.checkExists().forPath("/");            Assert.fail("Connection should be down");        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1348_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
public void curator_f1349_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.create().creatingParentsIfNeeded().forPath("/one/two/another", "bar".getBytes());        data = client.getData().forPath("/one/two/another");        Assert.assertEquals(data, "bar".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1350_0() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).dontUseContainerParents().build();    try {        client.start();        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.delete().forPath("/one/two/three");        new Timing().sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        new Timing().sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1351_0() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.delete().forPath("/one/two/three");        new Timing().sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two"));        new Timing().sleepABit();        Assert.assertNull(client.checkExists().forPath("/one"));    } finally {        CloseableUtils.closeQuietly(client);    }}
private boolean curator_f1352_0()
{    if (ZKPaths.getContainerCreateMode() == CreateMode.PERSISTENT) {        System.out.println("Not using CreateMode.CONTAINER enabled version of ZooKeeper");        return false;    }    return true;}
public void curator_f1353_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        client.delete().deletingChildrenIfNeeded().forPath("/one");        Assert.assertNull(client.checkExists().forPath("/one"));        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1354_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertNull(client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1355_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.checkExists().creatingParentContainersIfNeeded().inBackground(callback).forPath("/one/two/three");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertNull(client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1356_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
public void curator_f1357_0() throws Exception
{    final String namespace = "jz";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    client.start();    try {        EnsurePath ensurePath = new EnsurePath("/pity/the/fool");        ensurePath.ensure(client.getZookeeperClient());        Assert.assertNull(client.getZookeeperClient().getZooKeeper().exists("/jz/pity/the/fool", false));        ensurePath = client.newNamespaceAwareEnsurePath("/pity/the/fool");        ensurePath.ensure(client.getZookeeperClient());        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/jz/pity/the/fool", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1358_0() throws Exception
{    final String namespace = "container1";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    try {        client.start();        String path = "/path1/path2";        client.createContainers(path);        Assert.assertNotNull(client.checkExists().forPath(path));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/" + namespace + path, false));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1359_0() throws Exception
{    final String namespace = "container2";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        CuratorFramework nsClient = client.usingNamespace(namespace);        String path = "/path1/path2";        nsClient.createContainers(path);        Assert.assertNotNull(nsClient.checkExists().forPath(path));        Assert.assertNotNull(nsClient.getZookeeperClient().getZooKeeper().exists("/" + namespace + path, false));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1360_0() throws Exception
{    final String namespace = "TestNamespace";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    client.start();    try {        String actualPath = client.create().forPath("/test");        Assert.assertEquals(actualPath, "/test");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/" + namespace + "/test", false));        Assert.assertNull(client.getZookeeperClient().getZooKeeper().exists("/test", false));        actualPath = client.usingNamespace(null).create().forPath("/non");        Assert.assertEquals(actualPath, "/non");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/non", false));        client.create().forPath("/test/child", "hey".getBytes());        byte[] bytes = client.getData().forPath("/test/child");        Assert.assertEquals(bytes, "hey".getBytes());        bytes = client.usingNamespace(null).getData().forPath("/" + namespace + "/test/child");        Assert.assertEquals(bytes, "hey".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1361_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    if (event.getPath().equals("/head")) {                        latch.countDown();                    }                }            }        };        client.create().inBackground(callback).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1362_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        if (event.getPath().equals("/head")) {            latch.countDown();        }    }}
public void curator_f1363_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    Assert.assertEquals(event.getPath(), "/head");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        CountDownLatch latch = new CountDownLatch(1);        client.sync("/head", latch);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1364_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        Assert.assertEquals(event.getPath(), "/head");        ((CountDownLatch) event.getContext()).countDown();    }}
public void curator_f1365_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    latch.countDown();                }            }        };        client.sync().inBackground(callback).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1366_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        latch.countDown();    }}
public void curator_f1367_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.DELETE) {                    Assert.assertEquals(event.getPath(), "/head");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        CountDownLatch latch = new CountDownLatch(1);        client.delete().inBackground(latch).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1368_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.DELETE) {        Assert.assertEquals(event.getPath(), "/head");        ((CountDownLatch) event.getContext()).countDown();    }}
public void curator_f1369_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.DELETE) {                    Assert.assertEquals(event.getPath(), "/one/two");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three/four"));        CountDownLatch latch = new CountDownLatch(1);        client.delete().deletingChildrenIfNeeded().inBackground(latch).forPath("/one/two");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1370_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.DELETE) {        Assert.assertEquals(event.getPath(), "/one/two");        ((CountDownLatch) event.getContext()).countDown();    }}
public void curator_f1371_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        client.delete().forPath("/head");        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1372_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four/five/six", "foo".getBytes());        client.delete().deletingChildrenIfNeeded().forPath("/one/two/three/four/five");        Assert.assertNull(client.checkExists().forPath("/one/two/three/four/five"));        client.delete().deletingChildrenIfNeeded().forPath("/one/two");        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1373_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four/five/six", "foo".getBytes());        client.delete().guaranteed().deletingChildrenIfNeeded().forPath("/one/two/three/four/five");        Assert.assertNull(client.checkExists().forPath("/one/two/three/four/five"));        client.delete().guaranteed().deletingChildrenIfNeeded().forPath("/one/two");        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1374_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        for (int i = 0; i < 10; ++i) {            client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/head/child");        }        List<String> children = client.getChildren().forPath("/head");        Assert.assertEquals(children.size(), 10);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1375_0() throws Exception
{    final byte[] data1 = { 1, 2, 3 };    final byte[] data2 = { 4, 5, 6, 7 };    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch watchedLatch = new CountDownLatch(1);        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.GET_DATA) {                    Assert.assertEquals(event.getPath(), "/test");                    Assert.assertEquals(event.getData(), data1);                    ((CountDownLatch) event.getContext()).countDown();                } else if (event.getType() == CuratorEventType.WATCHED) {                    if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {                        Assert.assertEquals(event.getPath(), "/test");                        watchedLatch.countDown();                    }                }            }        });        client.create().forPath("/test", data1);        CountDownLatch backgroundLatch = new CountDownLatch(1);        client.getData().watched().inBackground(backgroundLatch).forPath("/test");        Assert.assertTrue(backgroundLatch.await(10, TimeUnit.SECONDS));        client.setData().forPath("/test", data2);        Assert.assertTrue(watchedLatch.await(10, TimeUnit.SECONDS));        byte[] checkData = client.getData().forPath("/test");        Assert.assertEquals(checkData, data2);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1376_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.GET_DATA) {        Assert.assertEquals(event.getPath(), "/test");        Assert.assertEquals(event.getData(), data1);        ((CountDownLatch) event.getContext()).countDown();    } else if (event.getType() == CuratorEventType.WATCHED) {        if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {            Assert.assertEquals(event.getPath(), "/test");            watchedLatch.countDown();        }    }}
public void curator_f1377_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    Assert.assertEquals(event.getPath(), "/test");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        CountDownLatch latch = new CountDownLatch(1);        client.create().inBackground(latch).forPath("/test", new byte[] { 1, 2, 3 });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1378_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        Assert.assertEquals(event.getPath(), "/test");        ((CountDownLatch) event.getContext()).countDown();    }}
public void curator_f1379_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        byte[] writtenBytes = { 1, 2, 3 };                client.create().forPath("/test", writtenBytes);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        byte[] readBytes = client.getData().forPath("/test");        Assert.assertEquals(writtenBytes, readBytes);        client.create().withMode(CreateMode.EPHEMERAL).forPath("/ghost", writtenBytes);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        readBytes = client.getData().forPath("/test");        Assert.assertEquals(writtenBytes, readBytes);        Stat stat = client.checkExists().forPath("/ghost");        Assert.assertNull(stat);        String realPath = client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/pseq", writtenBytes);        Assert.assertNotSame(realPath, "/pseq");        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        readBytes = client.getData().forPath(realPath);        Assert.assertEquals(writtenBytes, readBytes);        realPath = client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/eseq", writtenBytes);        Assert.assertNotSame(realPath, "/eseq");        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        stat = client.checkExists().forPath(realPath);        Assert.assertNull(stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1380_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        String path = client.create().withMode(CreateMode.PERSISTENT).forPath("/test", new byte[] { 1, 2, 3 });        Assert.assertEquals(path, "/test");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1381_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");                String path = client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test/");        Assert.assertTrue(path.startsWith("/test/"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1382_0() throws Exception
{                final AtomicBoolean aclProviderCalled = new AtomicBoolean(false);    ACLProvider badAclProvider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }        @Override        public List<ACL> getAclForPath(String path) {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).aclProvider(badAclProvider).build();    try {        client.start();        final CountDownLatch errorLatch = new CountDownLatch(1);        UnhandledErrorListener listener = new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                if (e instanceof UnsupportedOperationException) {                    errorLatch.countDown();                }            }        };        client.create().inBackground().withUnhandledErrorListener(listener).forPath("/foo");        Assert.assertTrue(new Timing().awaitLatch(errorLatch));    } finally {        CloseableUtils.closeQuietly(client);    }}
public List<ACL> curator_f1383_0()
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
public List<ACL> curator_f1384_0(String path)
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
public void curator_f1385_0(String message, Throwable e)
{    if (e instanceof UnsupportedOperationException) {        errorLatch.countDown();    }}
public void curator_f1386_0() throws Exception
{    server.stop();    Timing timing = new Timing(2);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(0, 0));    try {        client.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final AtomicBoolean firstListenerAction = new AtomicBoolean(true);        final AtomicReference<ConnectionState> firstListenerState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (firstListenerAction.compareAndSet(true, false)) {                    firstListenerState.set(newState);                    System.out.println("First listener state is " + newState);                }                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);                client.create().inBackground().forPath("/foo");        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        Assert.assertFalse(firstListenerAction.get());        ConnectionState firstconnectionState = firstListenerState.get();        Assert.assertEquals(firstconnectionState, ConnectionState.CONNECTED, "First listener state MUST BE CONNECTED but is " + firstconnectionState);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1387_0(CuratorFramework client, ConnectionState newState)
{    if (firstListenerAction.compareAndSet(true, false)) {        firstListenerState.set(newState);        System.out.println("First listener state is " + newState);    }    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
public void curator_f1388_0() throws Exception
{    final int SLEEP = 1000;    final int TIMES = 5;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(TIMES, SLEEP));    try {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final CountDownLatch latch = new CountDownLatch(TIMES);        final List<Long> times = Lists.newArrayList();        final AtomicLong start = new AtomicLong(System.currentTimeMillis());        ((CuratorFrameworkImpl) client).debugListener = new CuratorFrameworkImpl.DebugBackgroundListener() {            @Override            public void listen(OperationAndData<?> data) {                if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {                    long now = System.currentTimeMillis();                    times.add(now - start.get());                    start.set(now);                    latch.countDown();                }            }        };        server.stop();        client.create().inBackground().forPath("/one");        latch.await();        for (        long elapsed :         times.subList(1, times.size())) {            Assert.assertTrue(elapsed >= SLEEP, elapsed + ": " + times);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1389_0(OperationAndData<?> data)
{    if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {        long now = System.currentTimeMillis();        times.add(now - start.get());        start.set(now);        latch.countDown();    }}
public void curator_f1390_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final BlockingQueue<String> paths = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                paths.add(event.getPath());            }        };        client.create().inBackground(callback).forPath("/one");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one");        client.create().inBackground(callback).forPath("/one/two");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one/two");        client.create().inBackground(callback).forPath("/one/two/three");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one/two/three");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1391_0(CuratorFramework client, CuratorEvent event) throws Exception
{    paths.add(event.getPath());}
public void curator_f1392_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1000)).build();    final CountDownLatch latch = new CountDownLatch(1);    try {        client.start();        BackgroundCallback curatorCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getResultCode() == Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        };                server.stop();                client.getChildren().inBackground(curatorCallback).forPath("/");                Assert.assertTrue(timing.awaitLatch(latch), "Callback has not been called by curator !");    } finally {        client.close();    }}
public void curator_f1393_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
public void curator_f1394_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).maxCloseWaitMs(timing.forWaiting().milliseconds()).build();    try {        final AtomicBoolean hadIllegalStateException = new AtomicBoolean(false);        ((CuratorFrameworkImpl) client).debugUnhandledErrorListener = new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                if (e instanceof IllegalStateException) {                    hadIllegalStateException.set(true);                }            }        };        client.start();        final CountDownLatch operationReadyLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).debugListener = new CuratorFrameworkImpl.DebugBackgroundListener() {            @Override            public void listen(OperationAndData<?> data) {                try {                    operationReadyLatch.await();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }        };                client.create().inBackground().forPath("/hey");        timing.sleepABit();                client.close();                operationReadyLatch.countDown();        timing.sleepABit();                Assert.assertFalse(hadIllegalStateException.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1395_0(String message, Throwable e)
{    if (e instanceof IllegalStateException) {        hadIllegalStateException.set(true);    }}
public void curator_f1396_0(OperationAndData<?> data)
{    try {        operationReadyLatch.await();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
public static void curator_f1397_0()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
public void curator_f1398_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        CountDownLatch expiredLatch = new CountDownLatch(1);        Watcher watcher = event -> {            if (event.getState() == Watcher.Event.KeeperState.Expired) {                expiredLatch.countDown();            }        };        client.checkExists().usingWatcher(watcher).forPath("/foobar");        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(expiredLatch));    }}
public void curator_f1399_0() throws Exception
{        server.stop();    try (TestingCluster cluster = new TestingCluster(3)) {        cluster.start();        InstanceSpec instanceSpec0 = cluster.getServers().get(0).getInstanceSpec();        CountDownLatch serverStoppedLatch = new CountDownLatch(1);        RetryPolicy retryPolicy = new RetryForever(100) {            @Override            public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) {                if (serverStoppedLatch.getCount() > 0) {                    try {                        cluster.killServer(instanceSpec0);                    } catch (Exception e) {                                        }                    serverStoppedLatch.countDown();                }                return super.allowRetry(retryCount, elapsedTimeMs, sleeper);            }        };        try (CuratorFramework client = CuratorFrameworkFactory.newClient(instanceSpec0.getConnectString(), timing.session(), timing.connection(), retryPolicy)) {            BlockingQueue<String> createdNode = new LinkedBlockingQueue<>();            BackgroundCallback callback = (__, event) -> {                if (event.getType() == CuratorEventType.CREATE) {                    createdNode.offer(event.getPath());                }            };            client.start();            client.create().forPath("/test");            ErrorListenerPathAndBytesable<String> builder = client.create().withProtection().withMode(CreateMode.EPHEMERAL).inBackground(callback);            ((CreateBuilderImpl) builder).failNextCreateForTesting = true;            builder.forPath("/test/hey");            Assert.assertTrue(timing.awaitLatch(serverStoppedLatch));                        timing.forSessionSleep().sleep();            cluster.restartServer(instanceSpec0);            String path = timing.takeFromQueue(createdNode);            List<String> children = client.getChildren().forPath("/test");            Assert.assertEquals(Collections.singletonList(ZKPaths.getNodeFromPath(path)), children);        }    }}
public boolean curator_f1400_0(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    if (serverStoppedLatch.getCount() > 0) {        try {            cluster.killServer(instanceSpec0);        } catch (Exception e) {                }        serverStoppedLatch.countDown();    }    return super.allowRetry(retryCount, elapsedTimeMs, sleeper);}
public void curator_f1401_0() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        ((CuratorFrameworkImpl) client).sleepAndQueueOperationSeconds = Integer.MAX_VALUE;        final CountDownLatch latch = new CountDownLatch(3);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if ((event.getType() == CuratorEventType.CREATE) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {                    latch.countDown();                }            }        };                client.create().inBackground(callback).forPath("/test");        client.create().inBackground(callback).forPath("/test/one");        client.create().inBackground(callback).forPath("/test/two");        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1402_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if ((event.getType() == CuratorEventType.CREATE) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {        latch.countDown();    }}
public void curator_f1403_0() throws Exception
{    final int serverPort = server.getPort();    server.close();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 1000, 1000, new RetryNTimes(10, timing.forSleepingABit().milliseconds()));    try {        new Thread() {            @Override            public void run() {                try {                    Thread.sleep(3000);                    server = new TestingServer(serverPort, true);                } catch (Exception e) {                    e.printStackTrace();                }            }        }.start();        client.start();        client.createContainers("/this/does/not/exist");        Assert.assertNotNull(client.checkExists().forPath("/this/does/not/exist"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1404_0()
{    try {        Thread.sleep(3000);        server = new TestingServer(serverPort, true);    } catch (Exception e) {        e.printStackTrace();    }}
public void curator_f1405_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryNTimes(0, 0));    try {        client.start();        client.close();    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1406_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryNTimes(0, 0));    try {        client.start();        for (int i = 0; i < 2; ++i) {            CuratorFramework localClient = (i == 0) ? client : client.usingNamespace("nm");            localClient.create().forPath("/parent");            Assert.assertEquals(localClient.getChildren().forPath("/parent").size(), 0);            CreateBuilderImpl createBuilder = (CreateBuilderImpl) localClient.create();            createBuilder.failNextCreateForTesting = true;            FindAndDeleteProtectedNodeInBackground.debugInsertError.set(true);            try {                createBuilder.withProtection().forPath("/parent/test");                Assert.fail("failNextCreateForTesting should have caused a ConnectionLossException");            } catch (KeeperException.ConnectionLossException e) {                        }            timing.sleepABit();            List<String> children = localClient.getChildren().forPath("/parent");                        Assert.assertEquals(children.size(), 0, children.toString());            localClient.delete().forPath("/parent");        }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1407_0() throws Exception
{    for (CreateMode mode : CreateMode.values()) {        internalTestPathsFromProtectingInBackground(mode);    }}
private void curator_f1408_0(CreateMode mode) throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/a/b/c");        final BlockingQueue<String> paths = new ArrayBlockingQueue<String>(2);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                paths.put(event.getName());                paths.put(event.getPath());            }        };        final String TEST_PATH = "/a/b/c/test-";        long ttl = timing.forWaiting().milliseconds() * 1000;        CreateBuilder firstCreateBuilder = client.create();        if (SafeIsTtlMode.isTtl(mode)) {            firstCreateBuilder.withTtl(ttl);        }        firstCreateBuilder.withMode(mode).inBackground(callback).forPath(TEST_PATH);        String name1 = timing.takeFromQueue(paths);        String path1 = timing.takeFromQueue(paths);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));        client.start();        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.withProtection();        if (SafeIsTtlMode.isTtl(mode)) {            createBuilder.withTtl(ttl);        }        client.create().forPath(createBuilder.adjustPath(TEST_PATH));        createBuilder.debugForceFindProtectedNode = true;        createBuilder.withMode(mode).inBackground(callback).forPath(TEST_PATH);        String name2 = timing.takeFromQueue(paths);        String path2 = timing.takeFromQueue(paths);        Assert.assertEquals(ZKPaths.getPathAndNode(name1).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(name2).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(path1).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(path2).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        client.delete().deletingChildrenIfNeeded().forPath("/a/b/c");        client.delete().forPath("/a/b");        client.delete().forPath("/a");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1409_0(CuratorFramework client, CuratorEvent event) throws Exception
{    paths.put(event.getName());    paths.put(event.getPath());}
public void curator_f1410_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));    try {        final CountDownLatch latch = new CountDownLatch(1);        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        server.close();        client.getChildren().inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        }).forPath("/");        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1411_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
public void curator_f1412_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.checkExists().forPath("/");        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            client.checkExists().forPath("/");            Assert.fail();        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        client.checkExists().forPath("/");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1413_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
public void curator_f1414_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        try {            client.getACL().forPath("/");        } catch (NullPointerException e) {            Assert.fail();        }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1415_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.failNextCreateForTesting = true;        final BlockingQueue<String> queue = Queues.newArrayBlockingQueue(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.put(event.getPath());            }        };        createBuilder.withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(callback).forPath("/");        String ourPath = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertTrue(ourPath.startsWith(ZKPaths.makePath("/", CreateBuilderImpl.PROTECTED_PREFIX)));        Assert.assertFalse(createBuilder.failNextCreateForTesting);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1416_0(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.put(event.getPath());}
public void curator_f1417_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.failNextCreateForTesting = true;        String ourPath = createBuilder.withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/");        Assert.assertTrue(ourPath.startsWith(ZKPaths.makePath("/", CreateBuilderImpl.PROTECTED_PREFIX)));        Assert.assertFalse(createBuilder.failNextCreateForTesting);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1418_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/sessionTest");        CountDownLatch sessionDiedLatch = new CountDownLatch(1);        Watcher watcher = event -> {            if (event.getState() == Watcher.Event.KeeperState.Expired) {                sessionDiedLatch.countDown();            }        };        client.checkExists().usingWatcher(watcher).forPath("/sessionTest");        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(sessionDiedLatch));        Assert.assertNotNull(client.checkExists().forPath("/sessionTest"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1419_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.EXISTS) {                    Stat stat = client.checkExists().forPath("/yo/yo/yo");                    Assert.assertNull(stat);                    client.create().inBackground(event.getContext()).forPath("/what");                } else if (event.getType() == CuratorEventType.CREATE) {                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        CountDownLatch latch = new CountDownLatch(1);        client.checkExists().inBackground(latch).forPath("/hey");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1420_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.EXISTS) {        Stat stat = client.checkExists().forPath("/yo/yo/yo");        Assert.assertNull(stat);        client.create().inBackground(event.getContext()).forPath("/what");    } else if (event.getType() == CuratorEventType.CREATE) {        ((CountDownLatch) event.getContext()).countDown();    }}
public void curator_f1421_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    latch.countDown();                }            }        });        client.checkExists().forPath("/hey");        client.checkExists().inBackground().forPath("/hey");        server.stop();        client.checkExists().inBackground().forPath("/hey");        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1422_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        latch.countDown();    }}
public void curator_f1423_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 100, 100, new RetryOneTime(1));    client.start();    try {        client.checkExists().forPath("/hey");        client.checkExists().inBackground().forPath("/hey");        server.stop();        client.checkExists().forPath("/hey");        Assert.fail();    } catch (KeeperException.ConnectionLossException e) {        } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1424_0() throws Exception
{    final int MAX_RETRIES = 3;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(10));    client.start();    try {        final AtomicInteger retries = new AtomicInteger(0);        final Semaphore semaphore = new Semaphore(0);        RetryPolicy policy = new RetryPolicy() {            @Override            public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) {                semaphore.release();                if (retries.incrementAndGet() == MAX_RETRIES) {                    try {                        server.restart();                    } catch (Exception e) {                        throw new Error(e);                    }                }                try {                    sleeper.sleepFor(100, TimeUnit.MILLISECONDS);                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }                return true;            }        };        client.getZookeeperClient().setRetryPolicy(policy);        server.stop();                client.checkExists().forPath("/hey");        Assert.assertTrue(semaphore.tryAcquire(MAX_RETRIES, timing.forWaiting().seconds(), TimeUnit.SECONDS), "Remaining leases: " + semaphore.availablePermits());                client.getZookeeperClient().setRetryPolicy(new RetryOneTime(100));        client.checkExists().forPath("/hey");        client.getZookeeperClient().setRetryPolicy(policy);        semaphore.drainPermits();        retries.set(0);        server.stop();                client.checkExists().inBackground().forPath("/hey");        Assert.assertTrue(semaphore.tryAcquire(MAX_RETRIES, timing.forWaiting().seconds(), TimeUnit.SECONDS), "Remaining leases: " + semaphore.availablePermits());    } finally {        CloseableUtils.closeQuietly(client);    }}
public boolean curator_f1425_0(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    semaphore.release();    if (retries.incrementAndGet() == MAX_RETRIES) {        try {            server.restart();        } catch (Exception e) {            throw new Error(e);        }    }    try {        sleeper.sleepFor(100, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return true;}
public void curator_f1426_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.getData();        Assert.fail();    } catch (Exception e) {        } catch (Throwable e) {        Assert.fail("", e);    }}
public void curator_f1427_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.getData();    } finally {        CloseableUtils.closeQuietly(client);    }    try {        client.getData();        Assert.fail();    } catch (Exception e) {        }}
public void curator_f1428_1() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        client2.start();        client2.getZookeeperClient().blockUntilConnectedOrTimedOut();        int childCount = 5000;        for (int i = 0; i < childCount; i++) {            client.create().creatingParentsIfNeeded().forPath("/parent/child" + i);        }        final CountDownLatch latch = new CountDownLatch(1);        new Thread(new Runnable() {            @Override            public void run() {                long start = System.currentTimeMillis();                try {                    client.delete().deletingChildrenIfNeeded().forPath("/parent");                } catch (Exception e) {                    if (e instanceof KeeperException.NoNodeException) {                        Assert.fail("client delete failed, shouldn't throw NoNodeException", e);                    } else {                        Assert.fail("unexpected exception", e);                    }                } finally {                                        latch.countDown();                }            }        }).start();        boolean threadDeleted = false;        boolean client2Deleted = false;        Random random = new Random();        for (int i = 0; i < childCount; i++) {            String child = "/parent/child" + random.nextInt(childCount);            try {                if (!threadDeleted) {                    Stat stat = client2.checkExists().forPath(child);                    if (stat == null) {                                                threadDeleted = true;                                            }                } else {                    try {                        client2.delete().forPath(child);                        client2Deleted = true;                                                break;                    } catch (Exception e) {                        if (e instanceof KeeperException.NoNodeException) {                                                } else {                            Assert.fail("unexpected exception", e);                        }                    }                }            } catch (Exception e) {                Assert.fail("unexpected exception", e);            }        }                Assert.assertTrue(client2Deleted);        Assert.assertTrue(timing.awaitLatch(latch));        Assert.assertNull(client2.checkExists().forPath("/parent"));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(client2);    }}
public void curator_f1429_1()
{    long start = System.currentTimeMillis();    try {        client.delete().deletingChildrenIfNeeded().forPath("/parent");    } catch (Exception e) {        if (e instanceof KeeperException.NoNodeException) {            Assert.fail("client delete failed, shouldn't throw NoNodeException", e);        } else {            Assert.fail("unexpected exception", e);        }    } finally {                latch.countDown();    }}
public void curator_f1430_0() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    byte[] data = "Hello, world!".getBytes();    byte[] compressedData = provider.compress(null, data);    byte[] jdkCompressedData = jdkCompress(data);    Assert.assertTrue(Arrays.equals(compressedData, jdkCompressedData));    byte[] decompressedData = provider.decompress(null, compressedData);    Assert.assertTrue(Arrays.equals(decompressedData, data));}
public void curator_f1431_0() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    byte[] compressedData = provider.compress(null, new byte[0]);    byte[] compressedData2 = GzipCompressionProvider.doCompress(new byte[0]);    byte[] jdkCompress = jdkCompress(new byte[0]);        Assert.assertTrue(Arrays.equals(compressedData, compressedData2));    Assert.assertTrue(Arrays.equals(compressedData, jdkCompress));    byte[] decompressedData = provider.decompress(null, compressedData);    Assert.assertEquals(0, decompressedData.length);}
public void curator_f1432_0()
{    GzipCompressionProvider provider = new GzipCompressionProvider();    try {        provider.decompress(null, new byte[100]);        Assert.fail("Expected IOException");    } catch (IOException ignore) {        }    byte[] compressedData = provider.compress(null, new byte[0]);    for (int i = 0; i < compressedData.length; i++) {        try {            provider.decompress(null, Arrays.copyOf(compressedData, i));        } catch (IOException ignore) {                }        for (int change = 1; change < 256; change++) {            byte b = compressedData[i];            compressedData[i] = (byte) (b + change);            try {                provider.decompress(null, compressedData);                        } catch (IOException ignore) {                        }                        compressedData[i] = b;        }    }}
public void curator_f1433_0() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    ThreadLocalRandom random = ThreadLocalRandom.current();    for (int len = 1; len < 100; len++) {        byte[] data = new byte[len];        for (int i = 0; i < 100; i++) {            byte[] compressedData = provider.compress(null, data);            byte[] jdkCompressedData = jdkCompress(data);            Assert.assertTrue(Arrays.equals(compressedData, jdkCompressedData));            byte[] decompressedData = provider.decompress(null, compressedData);            Assert.assertTrue(Arrays.equals(decompressedData, data));                        random.nextBytes(data);        }    }}
private static byte[] curator_f1434_0(byte[] data) throws IOException
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    try (GZIPOutputStream out = new GZIPOutputStream(bytes)) {        out.write(data);        out.finish();    }    return bytes.toByteArray();}
public void curator_f1435_0() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client1.start();        client2.start();        final CountDownLatch latch = new CountDownLatch(1);        client1.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.WATCHED) {                    if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {                        if (event.getPath().equals("/test")) {                            latch.countDown();                        }                    }                }            }        });        client1.create().forPath("/test", new byte[] { 1, 2, 3 });        client1.checkExists().watched().forPath("/test");        client2.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    client.setData().forPath("/test", new byte[] { 10, 20 });                }            }        });        client2.sync().forPath("/test");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);    }}
public void curator_f1436_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.WATCHED) {        if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {            if (event.getPath().equals("/test")) {                latch.countDown();            }        }    }}
public void curator_f1437_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        client.setData().forPath("/test", new byte[] { 10, 20 });    }}
public void curator_f1438_0() throws Exception
{    try {        CuratorFrameworkFactory.builder().namespace("/snafu").retryPolicy(new RetryOneTime(1)).connectString("foo").build();        Assert.fail();    } catch (IllegalArgumentException e) {        }}
public void curator_f1439_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.builder().namespace("snafu").retryPolicy(new RetryOneTime(1)).connectString("foo").build();    try {        client.start();        CuratorFramework fooClient = client.usingNamespace("foo");        CuratorFramework barClient = client.usingNamespace("bar");        Assert.assertEquals(client.getNamespace(), "");        Assert.assertEquals(client2.getNamespace(), "snafu");        Assert.assertEquals(fooClient.getNamespace(), "foo");        Assert.assertEquals(barClient.getNamespace(), "bar");    } finally {        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client);    }}
public void curator_f1440_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorFramework fooClient = client.usingNamespace("foo");        CuratorFramework barClient = client.usingNamespace("bar");        fooClient.create().forPath("/one");        barClient.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/foo/one", false));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/bar/one", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1441_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertSame(client.usingNamespace("foo"), client.usingNamespace("foo"));        Assert.assertNotSame(client.usingNamespace("foo"), client.usingNamespace("bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1442_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/one", false));        client.usingNamespace("space").create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/space", false));        client.usingNamespace("name").create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/name", false));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/name/one", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1443_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/one", false));        Assert.assertNotNull(client.checkExists().forPath("/"));        try {            client.checkExists().forPath("");            Assert.fail("IllegalArgumentException expected");        } catch (IllegalArgumentException expected) {        }        Assert.assertNotNull(client.usingNamespace("one").checkExists().forPath("/"));        try {            client.usingNamespace("one").checkExists().forPath("");            Assert.fail("IllegalArgumentException expected");        } catch (IllegalArgumentException expected) {        }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1444_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    CuratorFramework namespaced = client.usingNamespace(null);    Assert.assertEquals(client.getState(), namespaced.getState(), "Namespaced state did not match true state after call to start.");    client.close();    Assert.assertEquals(client.getState(), namespaced.getState(), "Namespaced state did not match true state after call to close.");}
public void curator_f1445_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    client.getZookeeperClient().blockUntilConnectedOrTimedOut();    client.create().creatingParentsIfNeeded().forPath("/parent/child", "A string".getBytes());    CuratorFramework client2 = client.usingNamespace("parent");    Assert.assertNotNull(client2.getData().forPath("/child"));    client.setACL().withACL(Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.ANYONE_ID_UNSAFE))).forPath("/parent/child");        try {        List<ACL> acls = client2.getACL().forPath("/child");        Assert.assertNotNull(acls);        Assert.assertEquals(acls.size(), 1);        Assert.assertEquals(acls.get(0).getId(), ZooDefs.Ids.ANYONE_ID_UNSAFE);        Assert.assertEquals(acls.get(0).getPerms(), ZooDefs.Perms.WRITE);        client2.setACL().withACL(Collections.singletonList(new ACL(ZooDefs.Perms.DELETE, ZooDefs.Ids.ANYONE_ID_UNSAFE))).forPath("/child");        Assert.fail("Expected auth exception was not thrown");    } catch (NoAuthException e) {        }}
public void curator_f1446_0()
{    CuratorFramework client = CuratorFrameworkFactory.builder().namespace("").retryPolicy(new RetryOneTime(1)).connectString("foo").build();    CuratorFrameworkImpl clientImpl = (CuratorFrameworkImpl) client;    Assert.assertEquals(clientImpl.unfixForNamespace("/foo/bar"), "/foo/bar");    CloseableUtils.closeQuietly(client);}
public void curator_f1447_0() throws Exception
{    Timing timing = new Timing();        CuratorFramework client = CuratorFrameworkFactory.newClient("localhost:1111", 100, 100, new RetryOneTime(1));    try {        final BlockingQueue<ConnectionState> queue = Queues.newLinkedBlockingQueue();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState state) {                queue.add(state);            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        client.create().inBackground().forPath("/");        ConnectionState polled = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(polled, ConnectionState.SUSPENDED);        polled = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(polled, ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1448_0(CuratorFramework client, ConnectionState state)
{    queue.add(state);}
public void curator_f1449_0()
{    System.setProperty("readonlymode.enabled", "true");}
public void curator_f1450_0()
{    System.setProperty("readonlymode.enabled", "false");}
public void curator_f1451_0() throws Exception
{    Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(3);    CuratorFramework client = null;    try {        cluster.start();        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(100));        client.start();        client.checkExists().forPath("/");        client.close();        client = null;        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        for (int i = 0; i < 2; ++i) {            cluster.killServer(iterator.next());        }        client = CuratorFrameworkFactory.builder().connectString(cluster.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryNTimes(3, timing.milliseconds())).canBeReadOnly(true).build();        final BlockingQueue<ConnectionState> states = Queues.newLinkedBlockingQueue();        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                states.add(newState);            }        });        client.start();        client.checkExists().forPath("/");        ConnectionState state = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertEquals(state, ConnectionState.READ_ONLY);    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f1452_0(CuratorFramework client, ConnectionState newState)
{    states.add(newState);}
public void curator_f1453_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(2);    try {        cluster.start();        client = CuratorFrameworkFactory.builder().connectString(cluster.getConnectString()).canBeReadOnly(true).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();        client.start();        client.create().forPath("/test");        final CountDownLatch readOnlyLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.READ_ONLY) {                    readOnlyLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        InstanceSpec ourInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        InstanceSpec killInstance = iterator.next();        if (killInstance.equals(ourInstance)) {                        killInstance = iterator.next();        }        cluster.killServer(killInstance);        Assert.assertEquals(reconnectedLatch.getCount(), 1);        Assert.assertTrue(timing.awaitLatch(readOnlyLatch));        Assert.assertEquals(reconnectedLatch.getCount(), 1);        cluster.restartServer(killInstance);        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f1454_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.READ_ONLY) {        readOnlyLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
public void curator_f1455_0() throws Exception
{    super.setup();    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", superUserPasswordDigest);    CloseableUtils.closeQuietly(server);    server = null;    cluster = new TestingCluster(3);    cluster.start();}
public void curator_f1456_0() throws Exception
{    CloseableUtils.closeQuietly(cluster);    ensembleProvider = null;    System.clearProperty("zookeeper.DigestAuthenticationProvider.superDigest");    super.teardown();}
public void curator_f1457_0() throws Exception
{        Watcher watcher = null;    Stat stat = null;    CuratorFramework client = null;    client.getConfig().forEnsemble();    client.getConfig().inBackground().forEnsemble();    client.getConfig().usingWatcher(watcher).forEnsemble();    client.getConfig().usingWatcher(watcher).inBackground().forEnsemble();    client.getConfig().storingStatIn(stat).forEnsemble();    client.getConfig().storingStatIn(stat).inBackground().forEnsemble();    client.getConfig().storingStatIn(stat).usingWatcher(watcher).forEnsemble();    client.getConfig().storingStatIn(stat).usingWatcher(watcher).inBackground().forEnsemble();        client.reconfig().leaving().forEnsemble();    client.reconfig().joining().forEnsemble();    client.reconfig().leaving().joining().forEnsemble();    client.reconfig().joining().leaving().forEnsemble();    client.reconfig().withNewMembers().forEnsemble();    client.reconfig().leaving().fromConfig(0).forEnsemble();    client.reconfig().joining().fromConfig(0).forEnsemble();    client.reconfig().leaving().joining().fromConfig(0).forEnsemble();    client.reconfig().joining().leaving().fromConfig(0).forEnsemble();    client.reconfig().withNewMembers().fromConfig(0).forEnsemble();    client.reconfig().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().joining().storingStatIn(stat).forEnsemble();    client.reconfig().leaving().joining().storingStatIn(stat).forEnsemble();    client.reconfig().joining().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().withNewMembers().storingStatIn(stat).forEnsemble();    client.reconfig().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().leaving().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().joining().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().withNewMembers().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().forEnsemble();    client.reconfig().inBackground().joining().forEnsemble();    client.reconfig().inBackground().leaving().joining().forEnsemble();    client.reconfig().inBackground().joining().leaving().forEnsemble();    client.reconfig().inBackground().withNewMembers().forEnsemble();    client.reconfig().inBackground().leaving().fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().joining().fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().leaving().fromConfig(0).forEnsemble();    client.reconfig().inBackground().withNewMembers().fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().joining().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().leaving().joining().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().joining().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().withNewMembers().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().withNewMembers().storingStatIn(stat).fromConfig(0).forEnsemble();}
public void curator_f1458_0() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        byte[] configData = client.getConfig().forEnsemble();        QuorumVerifier quorumVerifier = toQuorumVerifier(configData);        System.out.println(quorumVerifier);        assertConfig(quorumVerifier, cluster.getInstances());        Assert.assertEquals(EnsembleTracker.configToConnectionString(quorumVerifier), ensembleProvider.getConnectionString());    }}
public void curator_f1459_0() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            client.reconfig().joining(toReconfigSpec(newCluster.getInstances())).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            List<InstanceSpec> newInstances = Lists.newArrayList(cluster.getInstances());            newInstances.addAll(newCluster.getInstances());            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
public void curator_f1460_0() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            final CountDownLatch callbackLatch = new CountDownLatch(1);            BackgroundCallback callback = new BackgroundCallback() {                @Override                public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                    if (event.getType() == CuratorEventType.RECONFIG) {                        callbackLatch.countDown();                    }                }            };            client.reconfig().inBackground(callback).joining(toReconfigSpec(newCluster.getInstances())).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(callbackLatch));            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            List<InstanceSpec> newInstances = Lists.newArrayList(cluster.getInstances());            newInstances.addAll(newCluster.getInstances());            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
public void curator_f1461_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.RECONFIG) {        callbackLatch.countDown();    }}
public void curator_f1462_0() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            Collection<InstanceSpec> oldInstances = cluster.getInstances();            InstanceSpec us = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());            InstanceSpec removeSpec = oldInstances.iterator().next();            if (us.equals(removeSpec)) {                Iterator<InstanceSpec> iterator = oldInstances.iterator();                iterator.next();                removeSpec = iterator.next();            }            Collection<InstanceSpec> instances = newCluster.getInstances();            client.reconfig().leaving(Integer.toString(removeSpec.getServerId())).joining(toReconfigSpec(instances)).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            ArrayList<InstanceSpec> newInstances = Lists.newArrayList(oldInstances);            newInstances.addAll(instances);            newInstances.remove(removeSpec);            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
public void curator_f1463_0() throws Exception
{    cluster.close();    cluster = null;    TestingCluster smallCluster = null;    TestingCluster localCluster = new TestingCluster(5);    try {        List<TestingZooKeeperServer> servers = localCluster.getServers();        List<InstanceSpec> smallClusterInstances = Lists.newArrayList();        for (        int i = 0;         i < 3;         ++i) {            TestingZooKeeperServer server = servers.get(i);            server.start();            smallClusterInstances.add(server.getInstanceSpec());        }        smallCluster = new TestingCluster(smallClusterInstances);        try (CuratorFramework client = newClient(smallCluster.getConnectString())) {            client.start();            QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());            Assert.assertEquals(oldConfig.getAllMembers().size(), 5);            assertConfig(oldConfig, localCluster.getInstances());            CountDownLatch latch = setChangeWaiter(client);            client.reconfig().withNewMembers(toReconfigSpec(smallClusterInstances)).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            Assert.assertEquals(newConfig.getAllMembers().size(), 3);            assertConfig(newConfig, smallClusterInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    } finally {        CloseableUtils.closeQuietly(smallCluster);        CloseableUtils.closeQuietly(localCluster);    }}
public void curator_f1464_0() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;10.2.3.4:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.2.3.4:2181", configString);}
public void curator_f1465_0() throws Exception
{    String config = "server.1=[1010:0001:0002:0003:0004:0005:0006:0007]:2888:3888:participant;[2001:db8:85a3:0:0:8a2e:370:7334]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("2001:db8:85a3:0:0:8a2e:370:7334:2181", configString);}
public void curator_f1466_0() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
public void curator_f1467_0() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;0.0.0.0:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
public void curator_f1468_0() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("", configString);}
public void curator_f1469_0() throws Exception
{    String config = "server.1=[2001:db8:85a3:0:0:8a2e:370:7334]:2888:3888:participant;[::]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("2001:db8:85a3:0:0:8a2e:370:7334:2181", configString);}
public void curator_f1470_0() throws Exception
{    String config = "server.1=[1010:0001:0002:0003:0004:0005:0006:0007]:2888:3888:participant;[::0]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("1010:1:2:3:4:5:6:7:2181", configString);}
public void curator_f1471_0() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;[::]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
public void curator_f1472_0() throws Exception
{    String config = "server.1=[2001:db8:85a3:0:0:8a2e:370:7334]:2888:3888:participant;127.0.0.1:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("127.0.0.1:2181", configString);}
private CuratorFramework curator_f1473_0()
{    return newClient(cluster.getConnectString());}
private CuratorFramework curator_f1474_0(String connectionString)
{    final AtomicReference<String> connectString = new AtomicReference<>(connectionString);    ensembleProvider = new EnsembleProvider() {        @Override        public void start() throws Exception {        }        @Override        public boolean updateServerListEnabled() {            return false;        }        @Override        public String getConnectionString() {            return connectString.get();        }        @Override        public void close() throws IOException {        }        @Override        public void setConnectionString(String connectionString) {            connectString.set(connectionString);        }    };    return CuratorFrameworkFactory.builder().ensembleProvider(ensembleProvider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", superUserPassword.getBytes()).retryPolicy(new ExponentialBackoffRetry(timing.forSleepingABit().milliseconds(), 3)).build();}
public void curator_f1475_0() throws Exception
{}
public boolean curator_f1476_0()
{    return false;}
public String curator_f1477_0()
{    return connectString.get();}
public void curator_f1478_0() throws IOException
{}
public void curator_f1479_0(String connectionString)
{    connectString.set(connectionString);}
private CountDownLatch curator_f1480_0(CuratorFramework client) throws Exception
{    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.NodeDataChanged) {                latch.countDown();            }        }    };    client.getConfig().usingWatcher(watcher).forEnsemble();    return latch;}
public void curator_f1481_0(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeDataChanged) {        latch.countDown();    }}
private void curator_f1482_0(QuorumVerifier config, Collection<InstanceSpec> instances)
{    for (InstanceSpec instance : instances) {        QuorumPeer.QuorumServer quorumServer = config.getAllMembers().get((long) instance.getServerId());        Assert.assertNotNull(quorumServer, String.format("Looking for %s - found %s", instance.getServerId(), config.getAllMembers()));        Assert.assertEquals(quorumServer.clientAddr.getPort(), instance.getPort());    }}
private List<String> curator_f1483_0(Collection<InstanceSpec> instances) throws Exception
{    String localhost = new InetSocketAddress((InetAddress) null, 0).getAddress().getHostAddress();    List<String> specs = Lists.newArrayList();    for (InstanceSpec instance : instances) {        specs.add("server." + instance.getServerId() + "=" + localhost + ":" + instance.getElectionPort() + ":" + instance.getQuorumPort() + ";" + instance.getPort());    }    return specs;}
private static QuorumVerifier curator_f1484_0(byte[] bytes) throws Exception
{    Assert.assertNotNull(bytes);    Properties properties = new Properties();    properties.load(new ByteArrayInputStream(bytes));    return new QuorumMaj(properties);}
private AtomicReference<ConnectionState> curator_f1485_0(CuratorFramework client)
{    final AtomicReference<ConnectionState> state = new AtomicReference<ConnectionState>();    client.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            state.set(newState);            synchronized (state) {                state.notify();            }        }    });    return state;}
public void curator_f1486_0(CuratorFramework client, ConnectionState newState)
{    state.set(newState);    synchronized (state) {        state.notify();    }}
private boolean curator_f1487_0(AtomicReference<ConnectionState> stateRef, Timing timing, final ConnectionState desiredState)
{    if (stateRef.get() == desiredState) {        return true;    }        synchronized (stateRef) {        if (stateRef.get() == desiredState) {            return true;        }        try {            stateRef.wait(timing.milliseconds());            return stateRef.get() == desiredState;        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return false;        }    }}
public void curator_f1488_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.WATCHED && event.getWatchedEvent().getType() == EventType.DataWatchRemoved) {                    removedLatch.countDown();                }            }        });        client.checkExists().watched().forPath(path);        client.watches().removeAll().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1489_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.WATCHED && event.getWatchedEvent().getType() == EventType.DataWatchRemoved) {        removedLatch.countDown();    }}
public void curator_f1490_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        CuratorWatcher watcher = new CuratorWatcher() {            @Override            public void process(WatchedEvent event) throws Exception {                if (event.getPath().equals(path) && event.getType() == EventType.DataWatchRemoved) {                    removedLatch.countDown();                }            }        };        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1491_0(WatchedEvent event) throws Exception
{    if (event.getPath().equals(path) && event.getType() == EventType.DataWatchRemoved) {        removedLatch.countDown();    }}
public void curator_f1492_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1493_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();                final CountDownLatch removedLatch = new CountDownLatch(2);        final String path = "/";        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.REMOVE_WATCHES && event.getPath().equals(path)) {                    removedLatch.countDown();                }            }        };        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).ofType(WatcherType.Any).inBackground(callback).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1494_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.REMOVE_WATCHES && event.getPath().equals(path)) {        removedLatch.countDown();    }}
public void curator_f1495_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).inBackground().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1496_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(2);        Watcher watcher1 = new CountDownWatcher(path, removedLatch, EventType.ChildWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.getChildren().usingWatcher(watcher1).forPath(path);        client.checkExists().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1497_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final AtomicBoolean removedFlag = new AtomicBoolean(false);        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher1 = new BooleanWatcher(path, removedFlag, EventType.ChildWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.getChildren().usingWatcher(watcher1).forPath(path);        client.checkExists().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().ofType(WatcherType.Data).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");        Assert.assertEquals(removedFlag.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1498_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final AtomicBoolean removedFlag = new AtomicBoolean(false);        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher1 = new BooleanWatcher(path, removedFlag, EventType.DataWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.ChildWatchRemoved);        client.checkExists().usingWatcher(watcher1).forPath(path);        client.getChildren().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().ofType(WatcherType.Children).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");        Assert.assertEquals(removedFlag.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1499_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);                server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));        client.watches().removeAll().locally().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1500_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);                server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));        client.watches().removeAll().locally().inBackground().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1501_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {            }        };        try {            client.watches().remove(watcher).forPath(path);            Assert.fail("Expected KeeperException.NoWatcherException");        } catch (KeeperException.NoWatcherException expected) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1502_0(WatchedEvent event)
{}
public void curator_f1503_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final AtomicBoolean watcherRemoved = new AtomicBoolean(false);        final String path = "/";        Watcher watcher = new BooleanWatcher(path, watcherRemoved, EventType.DataWatchRemoved);        client.watches().remove(watcher).quietly().forPath(path);        timing.sleepABit();                Assert.assertEquals(watcherRemoved.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1504_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        String path = "/";        CountDownLatch removeLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removeLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));                try {            client.watches().remove(watcher).guaranteed().forPath(path);            Assert.fail();        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        timing.awaitLatch(removeLatch);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1505_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final CountDownLatch guaranteeAddedLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).getFailedRemoveWatcherManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<FailedRemoveWatchManager.FailedRemoveWatchDetails>() {            @Override            public void pathAddedForGuaranteedOperation(FailedRemoveWatchDetails detail) {                guaranteeAddedLatch.countDown();            }        };        String path = "/";        CountDownLatch removeLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removeLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));                client.watches().remove(watcher).guaranteed().inBackground().forPath(path);        timing.awaitLatch(guaranteeAddedLatch);        server.restart();        timing.awaitLatch(removeLatch);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1506_0(FailedRemoveWatchDetails detail)
{    guaranteeAddedLatch.countDown();}
public void curator_f1507_0(WatchedEvent event)
{    if (event.getPath() == null || event.getType() == null) {        return;    }    if (event.getPath().equals(path) && event.getType() == eventType) {        removeLatch.countDown();    }}
public void curator_f1508_0(WatchedEvent event)
{    if (event.getPath() == null || event.getType() == null) {        return;    }    if (event.getPath().equals(path) && event.getType() == eventType) {        removedFlag.set(true);    }}
public void curator_f1509_0() throws Exception
{    CuratorTempFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).buildTemp();    try {        client.inTransaction().create().forPath("/foo", "data".getBytes()).and().commit();        byte[] bytes = client.getData().forPath("/foo");        Assert.assertEquals(bytes, "data".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1510_0() throws Exception
{    final CuratorTempFrameworkImpl client = (CuratorTempFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).buildTemp(1, TimeUnit.SECONDS);    try {        ScheduledExecutorService service = Executors.newScheduledThreadPool(1);        Runnable command = new Runnable() {            @Override            public void run() {                client.updateLastAccess();            }        };        service.scheduleAtFixedRate(command, 10, 10, TimeUnit.MILLISECONDS);        client.inTransaction().create().forPath("/foo", "data".getBytes()).and().commit();        service.shutdownNow();        Thread.sleep(2000);        Assert.assertNull(client.getCleanup());        Assert.assertNull(client.getClient());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1511_0()
{    client.updateLastAccess();}
public void curator_f1512_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/bar");        CuratorOp createOp2 = client.transactionOp().create().forPath("/z/blue");        final BlockingQueue<CuratorEvent> callbackQueue = new LinkedBlockingQueue<>();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                callbackQueue.add(event);            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2);        CuratorEvent event = callbackQueue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(event);        Assert.assertNotNull(event.getOpResults());        Assert.assertEquals(event.getOpResults().size(), 2);        Assert.assertEquals(event.getOpResults().get(0).getError(), KeeperException.Code.OK.intValue());        Assert.assertEquals(event.getOpResults().get(1).getError(), KeeperException.Code.NONODE.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1513_0(CuratorFramework client, CuratorEvent event) throws Exception
{    callbackQueue.add(event);}
public void curator_f1514_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/foo");                Stat stat = client.setData().forPath("/foo", "new".getBytes());        CuratorOp statOp = client.transactionOp().check().withVersion(stat.getVersion() + 1).forPath("/foo");        CuratorOp createOp = client.transactionOp().create().forPath("/bar");        try {            client.transaction().forOperations(statOp, createOp);            Assert.fail();        } catch (KeeperException.BadVersionException correct) {                }        Assert.assertNull(client.checkExists().forPath("/bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1515_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo", "one".getBytes());        CuratorOp createOp2 = client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes());        CuratorOp setDataOp = client.transactionOp().setData().forPath("/foo", "two".getBytes());        CuratorOp createOp3 = client.transactionOp().create().forPath("/foo/bar");        CuratorOp deleteOp = client.transactionOp().delete().forPath("/foo/bar");        Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp1, createOp2, setDataOp, createOp3, deleteOp);        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1516_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo");        CuratorOp createOp2 = client.transactionOp().create().forPath("/foo/bar", "snafu".getBytes());        Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp1, createOp2);        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1517_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo");        CuratorOp createOp2 = client.transactionOp().create().forPath("/foo/bar", "snafu".getBytes());        final BlockingQueue<List<CuratorTransactionResult>> queue = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event.getOpResults());            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2);        Collection<CuratorTransactionResult> results = queue.poll(5, TimeUnit.SECONDS);        Assert.assertNotNull(results);        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1518_0(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event.getOpResults());}
public void curator_f1519_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo", "one".getBytes());        CuratorOp createOp2 = client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes());        CuratorOp setDataOp = client.transactionOp().setData().forPath("/foo", "two".getBytes());        CuratorOp createOp3 = client.transactionOp().create().forPath("/foo/bar");        CuratorOp deleteOp = client.transactionOp().delete().forPath("/foo/bar");        final BlockingQueue<List<CuratorTransactionResult>> queue = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event.getOpResults());            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2, setDataOp, createOp3, deleteOp);        Collection<CuratorTransactionResult> results = queue.poll(5, TimeUnit.SECONDS);        Assert.assertNotNull(results);        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1520_0(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event.getOpResults());}
public void curator_f1521_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/foo");                Stat stat = client.setData().forPath("/foo", "new".getBytes());        try {            client.inTransaction().check().withVersion(stat.getVersion() + 1).forPath(            "/foo").and().create().forPath("/bar").and().commit();            Assert.fail();        } catch (KeeperException.BadVersionException correct) {                }        Assert.assertNull(client.checkExists().forPath("/bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1522_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        Collection<CuratorTransactionResult> results = client.inTransaction().create().forPath("/foo", "one".getBytes()).and().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes()).and().setData().forPath("/foo", "two".getBytes()).and().create().forPath("/foo/bar").and().delete().forPath("/foo/bar").and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1523_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    client.start();    try {        Collection<CuratorTransactionResult> results = client.inTransaction().create().compressed().forPath("/foo", "one".getBytes()).and().create().compressed().withACL(ZooDefs.Ids.READ_ACL_UNSAFE).forPath("/bar", "two".getBytes()).and().create().compressed().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "three".getBytes()).and().create().compressed().withMode(CreateMode.PERSISTENT).withACL(ZooDefs.Ids.READ_ACL_UNSAFE).forPath("/baz", "four".getBytes()).and().setData().compressed().withVersion(0).forPath("/foo", "five".getBytes()).and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/foo"), "five".getBytes());        Assert.assertTrue(client.checkExists().forPath("/bar") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/bar"), "two".getBytes());        Assert.assertEquals(client.getACL().forPath("/bar"), ZooDefs.Ids.READ_ACL_UNSAFE);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));        Assert.assertTrue(client.checkExists().forPath("/baz") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/baz"), "four".getBytes());        Assert.assertEquals(client.getACL().forPath("/baz"), ZooDefs.Ids.READ_ACL_UNSAFE);    } finally {        client.close();    }}
public void curator_f1524_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Collection<CuratorTransactionResult> results = client.inTransaction().create().forPath("/foo").and().create().forPath("/foo/bar", "snafu".getBytes()).and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
public static void curator_f1525_0()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
public void curator_f1526_0() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1");    super.setup();}
public void curator_f1527_0() throws Exception
{    super.teardown();    System.clearProperty("znode.container.checkIntervalMs");}
public void curator_f1528_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        client.create().withTtl(10).creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_WITH_TTL).forPath("/a/b/c");        Thread.sleep(20);        Assert.assertNull(client.checkExists().forPath("/a/b/c"));    }}
public void curator_f1529_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().withTtl(10).creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_WITH_TTL).inBackground(callback).forPath("/a/b/c");        Assert.assertTrue(new Timing().awaitLatch(latch));        Thread.sleep(20);        Assert.assertNull(client.checkExists().forPath("/a/b/c"));    }}
public void curator_f1530_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
public void curator_f1531_0(WatchedEvent event) throws Exception
{    count.incrementAndGet();}
public void curator_f1532_0(WatchedEvent event)
{    count.incrementAndGet();}
public void curator_f1533_0() throws Exception
{    CountZKWatcher actualWatcher = new CountZKWatcher();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");                client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.getData().usingWatcher(actualWatcher).forPath("/test");        client.setData().forPath("/test", "foo".getBytes());        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.getAndSet(0), 1);        client.create().forPath("/test");        client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.get(), 1);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1534_0() throws Exception
{    CountCuratorWatcher actualWatcher = new CountCuratorWatcher();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");                client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.getData().usingWatcher(actualWatcher).forPath("/test");        client.setData().forPath("/test", "foo".getBytes());        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.getAndSet(0), 1);        client.create().forPath("/test");        client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.get(), 1);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1535_0()
{    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {        }    };    NamespaceWatcher namespaceWatcher1 = new NamespaceWatcher(null, watcher, "/foo");    NamespaceWatcher namespaceWatcher2 = new NamespaceWatcher(null, watcher, "/foo");    Assert.assertEquals(namespaceWatcher1, namespaceWatcher2);    Assert.assertFalse(namespaceWatcher1.equals(watcher));    Assert.assertFalse(watcher.equals(namespaceWatcher1));    Set<Watcher> set = Sets.newHashSet();    set.add(namespaceWatcher1);    set.add(namespaceWatcher2);    Assert.assertEquals(set.size(), 1);}
public void curator_f1536_0(WatchedEvent event)
{}
public void curator_f1537_0() throws Exception
{    Timing timing = new Timing();    CountCuratorWatcher watcher = new CountCuratorWatcher();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);                client.getData().usingWatcher(watcher).forPath(PATH);        client.getData().usingWatcher(watcher).forPath(PATH);                client.setData().forPath(PATH, new byte[] {});        timing.sleepABit();        Assert.assertEquals(1, watcher.count.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1538_0() throws Exception
{    Timing timing = new Timing();    CountZKWatcher watcher = new CountZKWatcher();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);                client.getData().usingWatcher(watcher).forPath(PATH);        client.getData().usingWatcher(watcher).forPath(PATH);                client.setData().forPath(PATH, new byte[] {});        timing.sleepABit();        Assert.assertEquals(1, watcher.count.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1539_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/d/e/f");        removerClient.create().creatingParentsIfNeeded().forPath("/d/e/f");        Timing timing = new Timing();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1540_0(WatchedEvent event)
{    latch.countDown();}
public void curator_f1541_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/d/e/f");        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 2);        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1542_0(WatchedEvent event)
{}
public void curator_f1543_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        removerClient.create().creatingParentsIfNeeded().forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.getData().usingWatcher(watcher).forPath("/a/b/c");        removerClient.setData().forPath("/a/b/c", "new".getBytes());        Timing timing = new Timing();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1544_0(WatchedEvent event)
{    latch.countDown();}
public void curator_f1545_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.create().creatingParentsIfNeeded().forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.getData().usingWatcher(watcher).forPath("/a/b/c");        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1546_0(WatchedEvent event)
{}
public void curator_f1547_0() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        try {            removerClient.checkExists().usingWatcher(w).forPath("/one/two/three");            Assert.fail("Should have thrown ConnectionLossException");        } catch (KeeperException.ConnectionLossException expected) {                }        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1548_0(WatchedEvent event)
{}
public void curator_f1549_0() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        removerClient.checkExists().usingWatcher(w).inBackground(callback).forPath("/one/two/three");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1550_0(WatchedEvent event)
{}
public void curator_f1551_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
public void curator_f1552_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        try {            removerClient.getData().usingWatcher(w).forPath("/one/two/three");            Assert.fail("Should have thrown NoNodeException");        } catch (KeeperException.NoNodeException expected) {                }        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1553_0(WatchedEvent event)
{}
public void curator_f1554_0() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    Callable<Void> proc = new Callable<Void>() {        @Override        public Void call() throws Exception {            client.start();            WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();            Watcher w = new Watcher() {                @Override                public void process(WatchedEvent event) {                                }            };            final CountDownLatch latch = new CountDownLatch(1);            BackgroundCallback callback = new BackgroundCallback() {                @Override                public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                    latch.countDown();                }            };            removerClient.getData().usingWatcher(w).inBackground(callback).forPath("/one/two/three");            Assert.assertTrue(new Timing().awaitLatch(latch));            Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);            removerClient.removeWatchers();            return null;        }    };    TestCleanState.test(client, proc);}
public Void curator_f1555_0() throws Exception
{    client.start();    WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();    Watcher w = new Watcher() {        @Override        public void process(WatchedEvent event) {                }    };    final CountDownLatch latch = new CountDownLatch(1);    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            latch.countDown();        }    };    removerClient.getData().usingWatcher(w).inBackground(callback).forPath("/one/two/three");    Assert.assertTrue(new Timing().awaitLatch(latch));    Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    removerClient.removeWatchers();    return null;}
public void curator_f1556_0(WatchedEvent event)
{}
public void curator_f1557_0(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
public void curator_f1558_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        internalTryBasic(client);    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1559_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        internalTryBasic(client.usingNamespace("foo"));    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1560_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("hey").build();    try {        client.start();        internalTryBasic(client);    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1561_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("hey").build();    try {        client.start();        internalTryBasic(client.usingNamespace("lakjsf"));    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1562_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.getData().usingWatcher(watcher).forPath("/test");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.getData().usingWatcher(watcher).forPath("/test");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1563_0(WatchedEvent event)
{}
public void curator_f1564_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == Event.EventType.NodeCreated) {                    latch.countDown();                }            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/yo");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.create().forPath("/yo");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1565_0(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeCreated) {        latch.countDown();    }}
public void curator_f1566_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch createdLatch = new CountDownLatch(1);        final CountDownLatch deletedLatch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == Event.EventType.NodeCreated) {                    try {                        removerClient.checkExists().usingWatcher(this).forPath("/yo");                    } catch (Exception e) {                        e.printStackTrace();                    }                    createdLatch.countDown();                } else if (event.getType() == Event.EventType.NodeDeleted) {                    deletedLatch.countDown();                }            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/yo");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.create().forPath("/yo");        Assert.assertTrue(timing.awaitLatch(createdLatch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.delete().forPath("/yo");        Assert.assertTrue(timing.awaitLatch(deletedLatch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f1567_0(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeCreated) {        try {            removerClient.checkExists().usingWatcher(this).forPath("/yo");        } catch (Exception e) {            e.printStackTrace();        }        createdLatch.countDown();    } else if (event.getType() == Event.EventType.NodeDeleted) {        deletedLatch.countDown();    }}
private void curator_f1568_0(CuratorFramework client) throws Exception
{    WatcherRemoveCuratorFramework removerClient = client.newWatcherRemoveCuratorFramework();    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.DataWatchRemoved) {                latch.countDown();            }        }    };    removerClient.checkExists().usingWatcher(watcher).forPath("/hey");    List<String> existWatches = WatchersDebug.getExistWatches(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(existWatches.size(), 1);    removerClient.removeWatchers();    Assert.assertTrue(new Timing().awaitLatch(latch));    existWatches = WatchersDebug.getExistWatches(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(existWatches.size(), 0);}
public void curator_f1569_0(WatchedEvent event)
{    if (event.getType() == Event.EventType.DataWatchRemoved) {        latch.countDown();    }}
public void curator_f1570_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        client.start();        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                    ;                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.create().withMode(CreateMode.EPHEMERAL).forPath("/temp", "value".getBytes());        Assert.assertNotNull(client.checkExists().forPath("/temp"));        for (InstanceSpec spec : cluster.getInstances()) {            cluster.killServer(spec);            timing.sleepABit();            cluster.restartServer(spec);            timing.sleepABit();        }        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertNotNull(client.checkExists().forPath("/temp"));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f1571_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();        ;    }}
public void curator_f1572_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {                for (InstanceSpec instanceSpec : cluster.getInstances()) {            client = CuratorFrameworkFactory.newClient(instanceSpec.getConnectString(), new RetryOneTime(1));            client.start();            client.checkExists().forPath("/");            client.close();            client = null;        }        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final CountDownLatch latch = new CountDownLatch(2);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                    latch.countDown();                }            }        });        client.checkExists().forPath("/");        for (InstanceSpec instanceSpec : cluster.getInstances()) {            if (!instanceSpec.equals(cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper()))) {                Assert.assertTrue(cluster.killServer(instanceSpec));            }        }        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f1573_0(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {        latch.countDown();    }}
public void curator_f1574_0() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema1.json", null);    Schema schema = schemaSet.getNamedSchema("test");    Assert.assertNotNull(schema);    Map<String, String> expectedMetadata = Maps.newHashMap();    expectedMetadata.put("one", "1");    expectedMetadata.put("two", "2");    Assert.assertEquals(schema.getMetadata(), expectedMetadata);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            String rawPath = schema.getRawPath();            Assert.assertEquals(rawPath, "/a/b/c");            client.create().creatingParentsIfNeeded().forPath(rawPath);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/a/b/c");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1575_0() throws Exception
{    final SchemaValidator schemaValidator = new SchemaValidator() {        @Override        public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl) {            return data.length > 0;        }    };    SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper = new SchemaSetLoader.SchemaValidatorMapper() {        @Override        public SchemaValidator getSchemaValidator(String name) {            return schemaValidator;        }    };    SchemaSet schemaSet = loadSchemaSet("schema3.json", schemaValidatorMapper);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().forPath("/test", new byte[0]);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.create().forPath("/test", "good".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
public boolean curator_f1576_0(Schema schema, String path, byte[] data, List<ACL> acl)
{    return data.length > 0;}
public SchemaValidator curator_f1577_0(String name)
{    return schemaValidator;}
public void curator_f1578_0() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema2.json", null);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().creatingParentsIfNeeded().forPath("/a/b/c");            Assert.fail("Should've violated schema: test");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/a/b/c/d/e");            Assert.fail("Should've violated schema: test2");        } catch (SchemaViolation dummy) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1579_0() throws Exception
{    final SchemaValidator schemaValidator = new SchemaValidator() {        @Override        public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl) {            return data.length > 0;        }    };    SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper = new SchemaSetLoader.SchemaValidatorMapper() {        @Override        public SchemaValidator getSchemaValidator(String name) {            return schemaValidator;        }    };    SchemaSet schemaSet = loadSchemaSet("schema4.json", schemaValidatorMapper);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        CuratorOp createAPersistent = client.transactionOp().create().forPath("/a");        CuratorOp createAEphemeral = client.transactionOp().create().withMode(CreateMode.EPHEMERAL).forPath("/a");        CuratorOp deleteA = client.transactionOp().delete().forPath("/a");        CuratorOp createBEmptyData = client.transactionOp().create().forPath("/b", new byte[0]);        CuratorOp createBWithData = client.transactionOp().create().forPath("/b", new byte[10]);        CuratorOp setBEmptyData = client.transactionOp().setData().forPath("/b", new byte[0]);        CuratorOp setBWithData = client.transactionOp().setData().forPath("/b", new byte[10]);        try {            client.transaction().forOperations(createAPersistent, createAEphemeral);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(createAEphemeral);        try {            client.transaction().forOperations(deleteA);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.transaction().forOperations(createBEmptyData);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(createBWithData);        try {            client.transaction().forOperations(setBEmptyData);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(setBWithData);    } finally {        CloseableUtils.closeQuietly(client);    }}
public boolean curator_f1580_0(Schema schema, String path, byte[] data, List<ACL> acl)
{    return data.length > 0;}
public SchemaValidator curator_f1581_0(String name)
{    return schemaValidator;}
public void curator_f1582_0() throws Exception
{    String yaml = Resources.toString(Resources.getResource("schema.yaml"), Charsets.UTF_8);    JsonNode root = new ObjectMapper(new YAMLFactory()).readTree(yaml);    List<Schema> schemas = new SchemaSetLoader(root, null).getSchemas();    Assert.assertEquals(schemas.size(), 2);    Assert.assertEquals(schemas.get(0).getName(), "test");    Assert.assertEquals(schemas.get(0).getMetadata().size(), 0);    Assert.assertEquals(schemas.get(1).getName(), "test2");    Assert.assertEquals(schemas.get(1).getMetadata().size(), 2);    Assert.assertEquals(schemas.get(1).getMetadata().get("two"), "2");}
public void curator_f1583_0() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema5.json", null);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/exact/match");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/exact/foo/bar");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/exact/other/bar");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }                client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/exact/match");                client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/exact/other/thing");                client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/exact/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
private CuratorFramework curator_f1584_0(SchemaSet schemaSet)
{    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(schemaSet).build();}
private SchemaSet curator_f1585_0(String name, SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper) throws IOException
{    String json = Resources.toString(Resources.getResource(name), Charsets.UTF_8);    return new SchemaSetLoader(json, schemaValidatorMapper).toSchemaSet(true);}
public ScheduledFuture<?> curator_f1586_0(Runnable command, long delay, TimeUnit unit)
{    lastDelay[0] = Duration.of(unit.toNanos(delay), ChronoUnit.NANOS);    command.run();    return null;}
public void curator_f1587_0()
{    service.shutdownNow();}
public void curator_f1588_0()
{    final int retryQty = 1;    final Duration delay = Duration.ofSeconds(10);    CircuitBreaker circuitBreaker = CircuitBreaker.build(new RetryNTimes(retryQty, (int) delay.toMillis()), service);    AtomicInteger counter = new AtomicInteger(0);    Assert.assertTrue(circuitBreaker.tryToOpen(counter::incrementAndGet));    Assert.assertEquals(lastDelay[0], delay);    Assert.assertFalse(circuitBreaker.tryToOpen(counter::incrementAndGet));    Assert.assertEquals(circuitBreaker.getRetryCount(), 1);    Assert.assertEquals(counter.get(), 1);    Assert.assertFalse(circuitBreaker.tryToRetry(counter::incrementAndGet));    Assert.assertEquals(circuitBreaker.getRetryCount(), 1);    Assert.assertEquals(counter.get(), 1);    Assert.assertTrue(circuitBreaker.close());    Assert.assertEquals(circuitBreaker.getRetryCount(), 0);    Assert.assertFalse(circuitBreaker.close());}
public void curator_f1589_0()
{    CircuitBreaker circuitBreaker = CircuitBreaker.build(new RetryForever(1), service);    Assert.assertFalse(circuitBreaker.tryToRetry(() -> {    }));    Assert.assertTrue(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertFalse(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertTrue(circuitBreaker.close());    Assert.assertFalse(circuitBreaker.close());}
public void curator_f1590_0()
{    RetryPolicy retryPolicy = new RetryUntilElapsed(10000, 10000);    CircuitBreaker circuitBreaker = CircuitBreaker.build(retryPolicy, service);    Assert.assertTrue(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertEquals(lastDelay[0], Duration.ofMillis(10000));}
public void curator_f1591_0(CuratorFramework client, ConnectionState newState)
{    stateChanges.offer(newState);}
public boolean curator_f1592_0(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    return isRetrying && super.allowRetry(retryCount, elapsedTimeMs, sleeper);}
public void curator_f1593_0()
{    service = new ScheduledThreadPoolExecutor(1);}
public void curator_f1594_0()
{    service.shutdownNow();}
public void curator_f1595_0() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    TestRetryPolicy retryPolicy = new TestRetryPolicy();    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryPolicy, service);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);        listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    synchronized (    listener) {                listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);                listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);                listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);                listener.stateChanged(dummyClient, ConnectionState.LOST);                listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    }    retryTiming.multiple(2).sleep();    Assert.assertTrue(recordingListener.stateChanges.isEmpty());        retryPolicy.isRetrying = false;    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);}
public void curator_f1596_0() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    TestRetryPolicy retryPolicy = new TestRetryPolicy();    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryPolicy, service);    synchronized (    listener) {        listener.stateChanged(dummyClient, ConnectionState.LOST);                listener.stateChanged(dummyClient, ConnectionState.LOST);    }    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());        listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);}
public void curator_f1597_0() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryNever = (retryCount, elapsedTimeMs, sleeper) -> false;    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryNever, service);    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertFalse(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertFalse(listener.isOpen());}
public void curator_f1598_0() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryOnce = new RetryOneTime(retryTiming.milliseconds());    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryOnce, service);    synchronized (    listener) {        listener.stateChanged(dummyClient, ConnectionState.LOST);        listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);        Assert.assertTrue(listener.isOpen());    }    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);    Assert.assertFalse(listener.isOpen());}
public void curator_f1599_0() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryInfinite = new RetryForever(Integer.MAX_VALUE);    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryInfinite, service);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertFalse(listener.isOpen());    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(listener.isOpen());    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());}
public void curator_f1600_0() throws Exception
{    Timing2 timing = new Timing2();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).connectionHandlingPolicy(new StandardConnectionHandlingPolicy(30)).build();        final int lostStateExpectedMs = (timing.session() / 3) + timing.forSleepingABit().milliseconds();    try {        CountDownLatch connectedLatch = new CountDownLatch(1);        CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        timing.sleepABit();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.close();        Assert.assertTrue(lostLatch.await(lostStateExpectedMs, TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f1601_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
public static Future<?> curator_f1602_1(final CuratorFramework client, final Runnable runAfterConnection) throws Exception
{        final ExecutorService executor = ThreadUtils.newSingleThreadExecutor(ThreadUtils.getProcessName(runAfterConnection.getClass()));    Runnable internalCall = new Runnable() {        @Override        public void run() {            try {                client.blockUntilConnected();                runAfterConnection.run();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            } finally {                executor.shutdown();            }        }    };    return executor.submit(internalCall);}
public void curator_f1603_1()
{    try {        client.blockUntilConnected();        runAfterConnection.run();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            } finally {        executor.shutdown();    }}
public int curator_f1604_0()
{    return optimisticTries;}
public int curator_f1605_0()
{    return promotedLockTries;}
public long curator_f1606_0()
{    return optimisticTimeMs;}
public long curator_f1607_0()
{    return promotedTimeMs;}
 void curator_f1608_0()
{    ++optimisticTries;}
 void curator_f1609_0()
{    ++promotedLockTries;}
 void curator_f1610_0(long optimisticTimeMs)
{    this.optimisticTimeMs = optimisticTimeMs;}
 void curator_f1611_0(long promotedTimeMs)
{    this.promotedTimeMs = promotedTimeMs;}
public AtomicValue<Integer> curator_f1612_0() throws Exception
{    MutableAtomicValue<Integer> result = new MutableAtomicValue<Integer>(0, 0);    if (currentValue == null) {        currentValue = number.add(cacheFactor);        if (!currentValue.succeeded()) {            currentValue = null;            result.succeeded = false;            return result;        }        currentIndex = 0;    }    result.succeeded = true;    result.preValue = currentValue.preValue() + currentIndex;    result.postValue = result.preValue + 1;    if (++currentIndex >= cacheFactor) {        currentValue = null;    }    return result;}
public AtomicValue<Long> curator_f1613_0() throws Exception
{    MutableAtomicValue<Long> result = new MutableAtomicValue<Long>(0L, 0L);    if (currentValue == null) {        currentValue = number.add(cacheFactor);        if (!currentValue.succeeded()) {            currentValue = null;            result.succeeded = false;            return result;        }        currentIndex = 0;    }    result.succeeded = true;    result.preValue = currentValue.preValue() + currentIndex;    result.postValue = result.preValue + 1;    if (++currentIndex >= cacheFactor) {        currentValue = null;    }    return result;}
public AtomicValue<Integer> curator_f1614_0() throws Exception
{    return new AtomicInteger(value.get());}
public void curator_f1615_0(Integer newValue) throws Exception
{    value.forceSet(valueToBytes(newValue));}
public AtomicValue<Integer> curator_f1616_0(Integer expectedValue, Integer newValue) throws Exception
{    return new AtomicInteger(value.compareAndSet(valueToBytes(expectedValue), valueToBytes(newValue)));}
public AtomicValue<Integer> curator_f1617_0(Integer newValue) throws Exception
{    return new AtomicInteger(value.trySet(valueToBytes(newValue)));}
public boolean curator_f1618_0(Integer initialize) throws Exception
{    return value.initialize(valueToBytes(initialize));}
public AtomicValue<Integer> curator_f1619_0() throws Exception
{    return worker(1);}
public AtomicValue<Integer> curator_f1620_0() throws Exception
{    return worker(-1);}
public AtomicValue<Integer> curator_f1621_0(Integer delta) throws Exception
{    return worker(delta);}
public AtomicValue<Integer> curator_f1622_0(Integer delta) throws Exception
{    return worker(-1 * delta);}
 byte[] curator_f1623_0(Integer newValue)
{    Preconditions.checkNotNull(newValue, "newValue cannot be null");    byte[] newData = new byte[4];    ByteBuffer wrapper = ByteBuffer.wrap(newData);    wrapper.putInt(newValue);    return newData;}
 int curator_f1624_0(byte[] data)
{    if ((data == null) || (data.length == 0)) {        return 0;    }    ByteBuffer wrapper = ByteBuffer.wrap(data);    try {        return wrapper.getInt();    } catch (BufferUnderflowException e) {        throw value.createCorruptionException(data);    } catch (BufferOverflowException e) {        throw value.createCorruptionException(data);    }}
private AtomicValue<Integer> curator_f1625_0(final Integer addAmount) throws Exception
{    Preconditions.checkNotNull(addAmount, "addAmount cannot be null");    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            int previousValue = (previous != null) ? bytesToValue(previous) : 0;            int newValue = previousValue + addAmount;            return valueToBytes(newValue);        }    };    AtomicValue<byte[]> result = value.trySet(makeValue);    return new AtomicInteger(result);}
public byte[] curator_f1626_0(byte[] previous)
{    int previousValue = (previous != null) ? bytesToValue(previous) : 0;    int newValue = previousValue + addAmount;    return valueToBytes(newValue);}
public boolean curator_f1627_0()
{    return bytes.succeeded();}
public Integer curator_f1628_0()
{    return bytesToValue(bytes.preValue());}
public Integer curator_f1629_0()
{    return bytesToValue(bytes.postValue());}
public AtomicStats curator_f1630_0()
{    return bytes.getStats();}
public AtomicValue<Long> curator_f1631_0() throws Exception
{    return new AtomicLong(value.get());}
public void curator_f1632_0(Long newValue) throws Exception
{    value.forceSet(valueToBytes(newValue));}
public AtomicValue<Long> curator_f1633_0(Long expectedValue, Long newValue) throws Exception
{    return new AtomicLong(value.compareAndSet(valueToBytes(expectedValue), valueToBytes(newValue)));}
public AtomicValue<Long> curator_f1634_0(Long newValue) throws Exception
{    return new AtomicLong(value.trySet(valueToBytes(newValue)));}
public boolean curator_f1635_0(Long initialize) throws Exception
{    return value.initialize(valueToBytes(initialize));}
public AtomicValue<Long> curator_f1636_0() throws Exception
{    return worker(1L);}
public AtomicValue<Long> curator_f1637_0() throws Exception
{    return worker(-1L);}
public AtomicValue<Long> curator_f1638_0(Long delta) throws Exception
{    return worker(delta);}
public AtomicValue<Long> curator_f1639_0(Long delta) throws Exception
{    return worker(-1 * delta);}
 byte[] curator_f1640_0(Long newValue)
{    Preconditions.checkNotNull(newValue, "newValue cannot be null");    byte[] newData = new byte[8];    ByteBuffer wrapper = ByteBuffer.wrap(newData);    wrapper.putLong(newValue);    return newData;}
 long curator_f1641_0(byte[] data)
{    if ((data == null) || (data.length == 0)) {        return 0;    }    ByteBuffer wrapper = ByteBuffer.wrap(data);    try {        return wrapper.getLong();    } catch (BufferUnderflowException e) {        throw value.createCorruptionException(data);    } catch (BufferOverflowException e) {        throw value.createCorruptionException(data);    }}
private AtomicValue<Long> curator_f1642_0(final Long addAmount) throws Exception
{    Preconditions.checkNotNull(addAmount, "addAmount cannot be null");    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            long previousValue = (previous != null) ? bytesToValue(previous) : 0;            long newValue = previousValue + addAmount;            return valueToBytes(newValue);        }    };    AtomicValue<byte[]> result = value.trySet(makeValue);    return new AtomicLong(result);}
public byte[] curator_f1643_0(byte[] previous)
{    long previousValue = (previous != null) ? bytesToValue(previous) : 0;    long newValue = previousValue + addAmount;    return valueToBytes(newValue);}
public boolean curator_f1644_0()
{    return bytes.succeeded();}
public Long curator_f1645_0()
{    return bytesToValue(bytes.preValue());}
public Long curator_f1646_0()
{    return bytesToValue(bytes.postValue());}
public AtomicStats curator_f1647_0()
{    return bytes.getStats();}
public AtomicValue<byte[]> curator_f1648_0() throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    getCurrentValue(result, new Stat());    result.postValue = result.preValue;    result.succeeded = true;    return result;}
public void curator_f1649_0(byte[] newValue) throws Exception
{    try {        client.setData().forPath(path, newValue);    } catch (KeeperException.NoNodeException dummy) {        try {            client.create().creatingParentContainersIfNeeded().forPath(path, newValue);        } catch (KeeperException.NodeExistsException dummy2) {            client.setData().forPath(path, newValue);        }    }}
public AtomicValue<byte[]> curator_f1650_0(byte[] expectedValue, byte[] newValue) throws Exception
{    Stat stat = new Stat();    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    boolean createIt = getCurrentValue(result, stat);    if (!createIt && Arrays.equals(expectedValue, result.preValue)) {        try {            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);            result.succeeded = true;            result.postValue = newValue;        } catch (KeeperException.BadVersionException dummy) {            result.succeeded = false;        } catch (KeeperException.NoNodeException dummy) {            result.succeeded = false;        }    } else {        result.succeeded = false;    }    return result;}
public AtomicValue<byte[]> curator_f1651_0(final byte[] newValue) throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            return newValue;        }    };    tryOptimistic(result, makeValue);    if (!result.succeeded() && (mutex != null)) {        tryWithMutex(result, makeValue);    }    return result;}
public byte[] curator_f1652_0(byte[] previous)
{    return newValue;}
public boolean curator_f1653_0(byte[] value) throws Exception
{    try {        client.create().creatingParentContainersIfNeeded().forPath(path, value);    } catch (KeeperException.NodeExistsException ignore) {                return false;    }    return true;}
 AtomicValue<byte[]> curator_f1654_0(MakeValue makeValue) throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    tryOptimistic(result, makeValue);    if (!result.succeeded() && (mutex != null)) {        tryWithMutex(result, makeValue);    }    return result;}
 RuntimeException curator_f1655_0(byte[] bytes)
{    StringBuilder str = new StringBuilder();    str.append('[');    boolean first = true;    for (byte b : bytes) {        if (first) {            first = false;        } else {            str.append(", ");        }        str.append("0x").append(Integer.toHexString((b & 0xff)));    }    str.append(']');    return new RuntimeException(String.format("Corrupted data for node \"%s\": %s", path, str.toString()));}
private boolean curator_f1656_0(MutableAtomicValue<byte[]> result, Stat stat) throws Exception
{    boolean createIt = false;    try {        result.preValue = client.getData().storingStatIn(stat).forPath(path);    } catch (KeeperException.NoNodeException e) {        result.preValue = null;        createIt = true;    }    return createIt;}
private void curator_f1657_0(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    long startMs = System.currentTimeMillis();    int retryCount = 0;    if (mutex.acquire(promotedToLock.getMaxLockTime(), promotedToLock.getMaxLockTimeUnit())) {        try {            boolean done = false;            while (!done) {                result.stats.incrementPromotedTries();                if (tryOnce(result, makeValue)) {                    result.succeeded = true;                    done = true;                } else {                    if (!promotedToLock.getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMs, RetryLoop.getDefaultRetrySleeper())) {                        done = true;                    }                }            }        } finally {            mutex.release();        }    }    result.stats.setPromotedTimeMs(System.currentTimeMillis() - startMs);}
private void curator_f1658_0(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    long startMs = System.currentTimeMillis();    int retryCount = 0;    boolean done = false;    while (!done) {        result.stats.incrementOptimisticTries();        if (tryOnce(result, makeValue)) {            result.succeeded = true;            done = true;        } else {            if (!retryPolicy.allowRetry(retryCount++, System.currentTimeMillis() - startMs, RetryLoop.getDefaultRetrySleeper())) {                done = true;            }        }    }    result.stats.setOptimisticTimeMs(System.currentTimeMillis() - startMs);}
private boolean curator_f1659_0(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    Stat stat = new Stat();    boolean createIt = getCurrentValue(result, stat);    boolean success = false;    try {        byte[] newValue = makeValue.makeFrom(result.preValue);        if (createIt) {            client.create().creatingParentContainersIfNeeded().forPath(path, newValue);        } else {            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);        }        result.postValue = Arrays.copyOf(newValue, newValue.length);        success = true;    } catch (KeeperException.NodeExistsException e) {        } catch (KeeperException.BadVersionException e) {        } catch (KeeperException.NoNodeException e) {        }    return success;}
public T curator_f1660_0()
{    return preValue;}
public T curator_f1661_0()
{    return postValue;}
public boolean curator_f1662_0()
{    return succeeded;}
public AtomicStats curator_f1663_0()
{    return stats;}
public static Builder curator_f1664_0()
{    return new Builder();}
public PromotedToLock curator_f1665_0()
{    Preconditions.checkNotNull(instance.path, "path cannot be null");    Preconditions.checkNotNull(instance.retryPolicy, "retryPolicy cannot be null");    return new PromotedToLock(instance.path, instance.maxLockTime, instance.maxLockTimeUnit, instance.retryPolicy);}
public Builder curator_f1666_0(String path)
{    instance = new PromotedToLock(PathUtils.validatePath(path), instance.maxLockTime, instance.maxLockTimeUnit, instance.retryPolicy);    return this;}
public Builder curator_f1667_0(RetryPolicy retryPolicy)
{    instance = new PromotedToLock(instance.path, instance.maxLockTime, instance.maxLockTimeUnit, retryPolicy);    return this;}
public Builder curator_f1668_0(long maxLockTime, TimeUnit maxLockTimeUnit)
{    instance = new PromotedToLock(instance.path, maxLockTime, maxLockTimeUnit, instance.retryPolicy);    return this;}
 String curator_f1669_0()
{    return path;}
 long curator_f1670_0()
{    return maxLockTime;}
 TimeUnit curator_f1671_0()
{    return maxLockTimeUnit;}
 RetryPolicy curator_f1672_0()
{    return retryPolicy;}
public void curator_f1673_0(WatchedEvent event)
{    client.postSafeNotify(DistributedBarrier.this);}
public synchronized void curator_f1674_0() throws Exception
{    try {        client.create().creatingParentContainersIfNeeded().forPath(barrierPath);    } catch (KeeperException.NodeExistsException ignore) {        }}
public synchronized void curator_f1675_0() throws Exception
{    try {        client.delete().forPath(barrierPath);    } catch (KeeperException.NoNodeException ignore) {        }}
public synchronized void curator_f1676_0() throws Exception
{    waitOnBarrier(-1, null);}
public synchronized boolean curator_f1677_0(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    boolean result;    for (; ; ) {        result = (client.checkExists().usingWatcher(watcher).forPath(barrierPath) == null);        if (result) {            break;        }        if (hasMaxWait) {            long elapsed = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsed;            if (thisWaitMs <= 0) {                break;            }            wait(thisWaitMs);        } else {            wait();        }    }    return result;}
public void curator_f1678_0(WatchedEvent event)
{    connectionLost.set(event.getState() != Event.KeeperState.SyncConnected);    client.runSafe(() -> {        synchronized (DistributedDoubleBarrier.this) {            hasBeenNotified.set(true);            DistributedDoubleBarrier.this.notifyAll();        }    });}
public void curator_f1679_0() throws Exception
{    enter(-1, null);}
public boolean curator_f1680_0(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    boolean readyPathExists = (client.checkExists().usingWatcher(watcher).forPath(readyPath) != null);    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(ourPath);    boolean result = (readyPathExists || internalEnter(startMs, hasMaxWait, maxWaitMs));    if (connectionLost.get()) {        throw new KeeperException.ConnectionLossException();    }    return result;}
public synchronized void curator_f1681_0() throws Exception
{    leave(-1, null);}
public synchronized boolean curator_f1682_0(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    return internalLeave(startMs, hasMaxWait, maxWaitMs);}
protected List<String> curator_f1683_0() throws Exception
{    return client.getChildren().forPath(barrierPath);}
private List<String> curator_f1684_0(List<String> children)
{    Iterable<String> filtered = Iterables.filter(children, new Predicate<String>() {        @Override        public boolean apply(String name) {            return !name.equals(READY_NODE);        }    });    ArrayList<String> filteredList = Lists.newArrayList(filtered);    Collections.sort(filteredList);    return filteredList;}
public boolean curator_f1685_0(String name)
{    return !name.equals(READY_NODE);}
private boolean curator_f1686_0(long startMs, boolean hasMaxWait, long maxWaitMs) throws Exception
{    String ourPathName = ZKPaths.getNodeFromPath(ourPath);    boolean ourNodeShouldExist = true;    boolean result = true;    for (; ; ) {        if (connectionLost.get()) {            throw new KeeperException.ConnectionLossException();        }        List<String> children;        try {            children = client.getChildren().forPath(barrierPath);        } catch (KeeperException.NoNodeException dummy) {            children = Lists.newArrayList();        }        children = filterAndSortChildren(children);        if ((children == null) || (children.size() == 0)) {            break;        }        int ourIndex = children.indexOf(ourPathName);        if ((ourIndex < 0) && ourNodeShouldExist) {            if (connectionLost.get()) {                                break;            } else {                throw new IllegalStateException(String.format("Our path (%s) is missing", ourPathName));            }        }        if (children.size() == 1) {            if (ourNodeShouldExist && !children.get(0).equals(ourPathName)) {                throw new IllegalStateException(String.format("Last path (%s) is not ours (%s)", children.get(0), ourPathName));            }            checkDeleteOurPath(ourNodeShouldExist);            break;        }        Stat stat;        boolean IsLowestNode = (ourIndex == 0);        if (IsLowestNode) {            String highestNodePath = ZKPaths.makePath(barrierPath, children.get(children.size() - 1));            stat = client.checkExists().usingWatcher(watcher).forPath(highestNodePath);        } else {            String lowestNodePath = ZKPaths.makePath(barrierPath, children.get(0));            stat = client.checkExists().usingWatcher(watcher).forPath(lowestNodePath);            checkDeleteOurPath(ourNodeShouldExist);            ourNodeShouldExist = false;        }        if (stat != null) {            if (hasMaxWait) {                long elapsed = System.currentTimeMillis() - startMs;                long thisWaitMs = maxWaitMs - elapsed;                if (thisWaitMs <= 0) {                    result = false;                    break;                } else {                    wait(thisWaitMs);                }            } else {                wait();            }        }    }    try {        client.delete().forPath(readyPath);    } catch (KeeperException.NoNodeException ignore) {        }    return result;}
private void curator_f1687_0(boolean shouldExist) throws Exception
{    if (shouldExist) {        client.delete().forPath(ourPath);    }}
private synchronized boolean curator_f1688_0(long startMs, boolean hasMaxWait, long maxWaitMs) throws Exception
{    boolean result = true;    do {        List<String> children = getChildrenForEntering();        int count = (children != null) ? children.size() : 0;        if (count >= memberQty) {            try {                client.create().forPath(readyPath);            } catch (KeeperException.NodeExistsException ignore) {                        }            break;        }        if (hasMaxWait && !hasBeenNotified.get()) {            long elapsed = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsed;            if (thisWaitMs <= 0) {                result = false;            } else {                wait(thisWaitMs);            }            if (!hasBeenNotified.get()) {                result = false;            }        } else {            wait();        }    } while (false);    return result;}
public int curator_f1689_0(ChildData rhs)
{    if (this == rhs) {        return 0;    }    if (rhs == null || getClass() != rhs.getClass()) {        return -1;    }    return path.compareTo(rhs.path);}
public boolean curator_f1690_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ChildData childData = (ChildData) o;    if (!Arrays.equals(data, childData.data)) {        return false;    }    if (path != null ? !path.equals(childData.path) : childData.path != null) {        return false;    }    if (stat != null ? !stat.equals(childData.stat) : childData.stat != null) {        return false;    }    return true;}
public int curator_f1691_0()
{    int result = path != null ? path.hashCode() : 0;    result = 31 * result + (stat != null ? stat.hashCode() : 0);    result = 31 * result + Arrays.hashCode(data);    return result;}
public String curator_f1692_0()
{    return path;}
public Stat curator_f1693_0()
{    return stat;}
public byte[] curator_f1694_0()
{    return data;}
public String curator_f1695_0()
{    return "ChildData{" + "path='" + path + '\'' + ", stat=" + stat + ", data=" + Arrays.toString(data) + '}';}
public boolean curator_f1696_0(String fullPath)
{    return true;}
public boolean curator_f1697_0(String fullPath)
{    return true;}
public void curator_f1698_0()
{    cache.callListeners(event);}
public String curator_f1699_0()
{    return "EventOperation{" + "event=" + event + '}';}
public void curator_f1700_0() throws Exception
{    cache.getDataAndStat(fullPath);}
public boolean curator_f1701_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    GetDataOperation that = (GetDataOperation) o;        if (!fullPath.equals(that.fullPath)) {        return false;    }    return true;}
public int curator_f1702_0()
{    return fullPath.hashCode();}
public String curator_f1703_0()
{    return "GetDataOperation{" + "fullPath='" + fullPath + '\'' + '}';}
public void curator_f1704_1(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED)) {        if (isConnected.compareAndSet(false, true)) {            try {                reset();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }        }    } else {        isConnected.set(false);    }}
public void curator_f1705_0(WatchedEvent event)
{    try {        reset();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
public void curator_f1706_0(CuratorFramework client, CuratorEvent event) throws Exception
{    processBackgroundResult(event);}
public CuratorFramework curator_f1707_0()
{    return client;}
public void curator_f1708_0() throws Exception
{    start(false);}
public void curator_f1709_0(boolean buildInitial) throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    if (buildInitial) {        client.checkExists().creatingParentContainersIfNeeded().forPath(path);        internalRebuild();    }    reset();}
public void curator_f1710_0() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.removeWatchers();        listeners.clear();        client.getConnectionStateListenable().removeListener(connectionStateListener);                                        connectionStateListener = null;        watcher = null;    }}
public ListenerContainer<NodeCacheListener> curator_f1711_0()
{    Preconditions.checkState(state.get() != State.CLOSED, "Closed");    return listeners;}
public void curator_f1712_0() throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    internalRebuild();    reset();}
public ChildData curator_f1713_0()
{    return data.get();}
public String curator_f1714_0()
{    return path;}
private void curator_f1715_0() throws Exception
{    if ((state.get() == State.STARTED) && isConnected.get()) {        client.checkExists().creatingParentContainersIfNeeded().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);    }}
private void curator_f1716_0() throws Exception
{    try {        Stat stat = new Stat();        byte[] bytes = dataIsCompressed ? client.getData().decompressed().storingStatIn(stat).forPath(path) : client.getData().storingStatIn(stat).forPath(path);        data.set(new ChildData(path, stat, bytes));    } catch (KeeperException.NoNodeException e) {        data.set(null);    }}
private void curator_f1717_0(CuratorEvent event) throws Exception
{    switch(event.getType()) {        case GET_DATA:            {                if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                    ChildData childData = new ChildData(path, event.getStat(), event.getData());                    setNewData(childData);                }                break;            }        case EXISTS:            {                if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                    setNewData(null);                } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                    if (dataIsCompressed) {                        client.getData().decompressed().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);                    } else {                        client.getData().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);                    }                }                break;            }    }}
private void curator_f1718_1(ChildData newData) throws InterruptedException
{    ChildData previousData = data.getAndSet(newData);    if (!Objects.equal(previousData, newData)) {        listeners.forEach(new Function<NodeCacheListener, Void>() {            @Override            public Void apply(NodeCacheListener listener) {                try {                    listener.nodeChanged();                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    }                return null;            }        });        if (rebuildTestExchanger != null) {            try {                rebuildTestExchanger.exchange(new Object());            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        }    }}
public Void curator_f1719_1(NodeCacheListener listener)
{    try {        listener.nodeChanged();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
protected void curator_f1720_1(Throwable e)
{    }
public void curator_f1721_0(WatchedEvent event)
{    offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.STANDARD));}
public void curator_f1722_0(WatchedEvent event)
{    try {        if (event.getType() == Event.EventType.NodeDeleted) {            remove(event.getPath());        } else if (event.getType() == Event.EventType.NodeDataChanged) {            offerOperation(new GetDataOperation(PathChildrenCache.this, event.getPath()));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
public void curator_f1723_0(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
public void curator_f1724_0() throws Exception
{    start(StartMode.NORMAL);}
public void curator_f1725_0(boolean buildInitial) throws Exception
{    start(buildInitial ? StartMode.BUILD_INITIAL_CACHE : StartMode.NORMAL);}
public void curator_f1726_0(StartMode mode) throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "already started");    mode = Preconditions.checkNotNull(mode, "mode cannot be null");    client.getConnectionStateListenable().addListener(connectionStateListener);    switch(mode) {        case NORMAL:            {                offerOperation(new RefreshOperation(this, RefreshMode.STANDARD));                break;            }        case BUILD_INITIAL_CACHE:            {                rebuild();                break;            }        case POST_INITIALIZED_EVENT:            {                initialSet.set(Maps.<String, ChildData>newConcurrentMap());                offerOperation(new RefreshOperation(this, RefreshMode.POST_INITIALIZED));                break;            }    }}
public void curator_f1727_0() throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "cache has been closed");    ensurePath();    clear();    List<String> children = client.getChildren().forPath(path);    for (String child : children) {        String fullPath = ZKPaths.makePath(path, child);        internalRebuildNode(fullPath);        if (rebuildTestExchanger != null) {            rebuildTestExchanger.exchange(new Object());        }    }        offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));}
public void curator_f1728_0(String fullPath) throws Exception
{    Preconditions.checkArgument(ZKPaths.getPathAndNode(fullPath).getPath().equals(path), "Node is not part of this cache: " + fullPath);    Preconditions.checkState(state.get() == State.STARTED, "cache has been closed");    ensurePath();    internalRebuildNode(fullPath);            offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));}
public void curator_f1729_0() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.getConnectionStateListenable().removeListener(connectionStateListener);        listeners.clear();        executorService.close();        client.removeWatchers();                                connectionStateListener = null;        childrenWatcher = null;        dataWatcher = null;    }}
public ListenerContainer<PathChildrenCacheListener> curator_f1730_0()
{    return listeners;}
public List<ChildData> curator_f1731_0()
{    return ImmutableList.copyOf(Sets.<ChildData>newTreeSet(currentData.values()));}
public ChildData curator_f1732_0(String fullPath)
{    return currentData.get(fullPath);}
public void curator_f1733_0(String fullPath)
{    clearDataBytes(fullPath, -1);}
public boolean curator_f1734_0(String fullPath, int ifVersion)
{    ChildData data = currentData.get(fullPath);    if (data != null) {        if ((ifVersion < 0) || (ifVersion == data.getStat().getVersion())) {            if (data.getData() != null) {                currentData.replace(fullPath, data, new ChildData(data.getPath(), data.getStat(), null));            }            return true;        }    }    return false;}
public void curator_f1735_0() throws Exception
{    currentData.clear();    offerOperation(new RefreshOperation(this, RefreshMode.STANDARD));}
public void curator_f1736_0()
{    currentData.clear();}
 void curator_f1737_1(final RefreshMode mode) throws Exception
{    ensurePath();    final BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (reRemoveWatchersOnBackgroundClosed()) {                return;            }            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                processChildren(event.getChildren(), mode);            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                if (mode == RefreshMode.NO_NODE_EXCEPTION) {                                        ensureContainers.reset();                } else {                                        ensureContainers.reset();                    offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.NO_NODE_EXCEPTION));                }            }        }    };    client.getChildren().usingWatcher(childrenWatcher).inBackground(callback).forPath(path);}
public void curator_f1738_1(CuratorFramework client, CuratorEvent event) throws Exception
{    if (reRemoveWatchersOnBackgroundClosed()) {        return;    }    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        processChildren(event.getChildren(), mode);    } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {        if (mode == RefreshMode.NO_NODE_EXCEPTION) {                        ensureContainers.reset();        } else {                        ensureContainers.reset();            offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.NO_NODE_EXCEPTION));        }    }}
 void curator_f1739_0(final PathChildrenCacheEvent event)
{    listeners.forEach(new Function<PathChildrenCacheListener, Void>() {        @Override        public Void apply(PathChildrenCacheListener listener) {            try {                listener.childEvent(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            return null;        }    });}
public Void curator_f1740_0(PathChildrenCacheListener listener)
{    try {        listener.childEvent(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }    return null;}
 void curator_f1741_0(final String fullPath) throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (reRemoveWatchersOnBackgroundClosed()) {                return;            }            applyNewData(fullPath, event.getResultCode(), event.getStat(), cacheData ? event.getData() : null);        }    };    if (USE_EXISTS && !cacheData) {        client.checkExists().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);    } else {                if (dataIsCompressed && cacheData) {            client.getData().decompressed().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);        } else {            client.getData().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);        }    }}
public void curator_f1742_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (reRemoveWatchersOnBackgroundClosed()) {        return;    }    applyNewData(fullPath, event.getResultCode(), event.getStat(), cacheData ? event.getData() : null);}
protected void curator_f1743_1(Throwable e)
{    }
protected void curator_f1744_0() throws Exception
{    ensureContainers.ensure();}
protected void curator_f1745_0(String fullPath)
{    ChildData data = currentData.remove(fullPath);    if (data != null) {        offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_REMOVED, data)));    }    Map<String, ChildData> localInitialSet = initialSet.get();    if (localInitialSet != null) {        localInitialSet.remove(ZKPaths.getNodeFromPath(fullPath));        maybeOfferInitializedEvent(localInitialSet);    }}
private boolean curator_f1746_0()
{    if (state.get().equals(State.CLOSED)) {        client.removeWatchers();        return true;    }    return false;}
private void curator_f1747_0(String fullPath) throws Exception
{    if (cacheData) {        try {            Stat stat = new Stat();            byte[] bytes = dataIsCompressed ? client.getData().decompressed().storingStatIn(stat).forPath(fullPath) : client.getData().storingStatIn(stat).forPath(fullPath);            currentData.put(fullPath, new ChildData(fullPath, stat, bytes));        } catch (KeeperException.NoNodeException ignore) {                        currentData.remove(fullPath);        }    } else {        Stat stat = client.checkExists().forPath(fullPath);        if (stat != null) {            currentData.put(fullPath, new ChildData(fullPath, stat, null));        } else {                        currentData.remove(fullPath);        }    }}
private void curator_f1748_0(ConnectionState newState)
{    switch(newState) {        case SUSPENDED:            {                offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED, null)));                break;            }        case LOST:            {                offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_LOST, null)));                break;            }        case CONNECTED:        case RECONNECTED:            {                try {                    offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));                    offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED, null)));                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }                break;            }    }}
private void curator_f1749_0(List<String> children, RefreshMode mode) throws Exception
{    Set<String> removedNodes = Sets.newHashSet(currentData.keySet());    for (String child : children) {        removedNodes.remove(ZKPaths.makePath(path, child));    }    for (String fullPath : removedNodes) {        remove(fullPath);    }    for (String name : children) {        String fullPath = ZKPaths.makePath(path, name);        if ((mode == RefreshMode.FORCE_GET_DATA_AND_STAT) || !currentData.containsKey(fullPath)) {            getDataAndStat(fullPath);        }        updateInitialSet(name, NULL_CHILD_DATA);    }    maybeOfferInitializedEvent(initialSet.get());}
private void curator_f1750_1(String fullPath, int resultCode, Stat stat, byte[] bytes)
{    if (    resultCode == KeeperException.Code.OK.intValue()) {        ChildData data = new ChildData(fullPath, stat, bytes);        ChildData previousData = currentData.put(fullPath, data);        if (        previousData == null) {            offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_ADDED, data)));        } else if (stat.getMzxid() != previousData.getStat().getMzxid()) {            offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_UPDATED, data)));        }        updateInitialSet(ZKPaths.getNodeFromPath(fullPath), data);    } else if (resultCode == KeeperException.Code.NONODE.intValue()) {                remove(fullPath);    }}
private void curator_f1751_0(String name, ChildData data)
{    Map<String, ChildData> localInitialSet = initialSet.get();    if (localInitialSet != null) {        localInitialSet.put(name, data);        maybeOfferInitializedEvent(localInitialSet);    }}
private void curator_f1752_0(Map<String, ChildData> localInitialSet)
{    if (!hasUninitialized(localInitialSet)) {        if (        initialSet.getAndSet(null) != null) {            final List<ChildData> children = ImmutableList.copyOf(localInitialSet.values());            PathChildrenCacheEvent event = new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.INITIALIZED, null) {                @Override                public List<ChildData> getInitialData() {                    return children;                }            };            offerOperation(new EventOperation(this, event));        }    }}
public List<ChildData> curator_f1753_0()
{    return children;}
private boolean curator_f1754_0(Map<String, ChildData> localInitialSet)
{    if (localInitialSet == null) {        return false;    }    Map<String, ChildData> uninitializedChildren = Maps.filterValues(localInitialSet, new Predicate<ChildData>() {        @Override        public boolean apply(ChildData input) {                        return (input == NULL_CHILD_DATA);        }    });    return (uninitializedChildren.size() != 0);}
public boolean curator_f1755_0(ChildData input)
{        return (input == NULL_CHILD_DATA);}
 void curator_f1756_0(final Operation operation)
{    if (operationsQuantizer.add(operation)) {        submitToExecutor(new Runnable() {            @Override            public void run() {                try {                    operationsQuantizer.remove(operation);                    operation.invoke();                } catch (InterruptedException e) {                                        if (state.get() != State.CLOSED) {                        handleException(e);                    }                    Thread.currentThread().interrupt();                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }            }        });    }}
public void curator_f1757_0()
{    try {        operationsQuantizer.remove(operation);        operation.invoke();    } catch (InterruptedException e) {                if (state.get() != State.CLOSED) {            handleException(e);        }        Thread.currentThread().interrupt();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
private synchronized void curator_f1758_0(final Runnable command)
{    if (state.get() == State.STARTED) {        executorService.submit(command);    }}
public Type curator_f1759_0()
{    return type;}
public ChildData curator_f1760_0()
{    return data;}
public List<ChildData> curator_f1761_0()
{    return null;}
public String curator_f1762_0()
{    return "PathChildrenCacheEvent{" + "type=" + type + ", data=" + data + '}';}
public void curator_f1763_0() throws Exception
{    cache.refresh(mode);}
public boolean curator_f1764_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    RefreshOperation that = (RefreshOperation) o;        if (mode != that.mode) {        return false;    }    return true;}
public int curator_f1765_0()
{    return mode.hashCode();}
public String curator_f1766_0()
{    return "RefreshOperation(" + mode + "){}";}
public TreeCache curator_f1767_0()
{    ExecutorService executor = executorService;    if (executor == null) {        executor = Executors.newSingleThreadExecutor(defaultThreadFactory);    }    return new TreeCache(client, path, cacheData, dataIsCompressed, maxDepth, executor, createParentNodes, disableZkWatches, selector);}
public Builder curator_f1768_0(boolean cacheData)
{    this.cacheData = cacheData;    return this;}
public Builder curator_f1769_0(boolean dataIsCompressed)
{    this.dataIsCompressed = dataIsCompressed;    return this;}
public Builder curator_f1770_0(ThreadFactory threadFactory)
{    return setExecutor(Executors.newSingleThreadExecutor(threadFactory));}
public Builder curator_f1771_0(ExecutorService executorService)
{    this.executorService = checkNotNull(executorService);    return this;}
public Builder curator_f1772_0(int maxDepth)
{    this.maxDepth = maxDepth;    return this;}
public Builder curator_f1773_0(boolean createParentNodes)
{    this.createParentNodes = createParentNodes;    return this;}
public Builder curator_f1774_0(boolean disableZkWatches)
{    this.disableZkWatches = disableZkWatches;    return this;}
public Builder curator_f1775_0(TreeCacheSelector selector)
{    this.selector = selector;    return this;}
public static Builder curator_f1776_0(CuratorFramework client, String path)
{    return new Builder(client, path);}
private static boolean curator_f1777_0(ChildData cd)
{    return cd != null && cd != DEAD;}
private void curator_f1778_0() throws Exception
{    if ((depth < maxDepth) && selector.traverseChildren(path)) {        outstandingOps.addAndGet(2);        doRefreshData();        doRefreshChildren();    } else {        refreshData();    }}
private void curator_f1779_0() throws Exception
{    if ((depth < maxDepth) && selector.traverseChildren(path)) {        outstandingOps.incrementAndGet();        doRefreshChildren();    }}
private void curator_f1780_0() throws Exception
{    outstandingOps.incrementAndGet();    doRefreshData();}
private void curator_f1781_0() throws Exception
{    if (treeState.get() == TreeState.STARTED) {        maybeWatch(client.getChildren()).forPath(path);    }}
private void curator_f1782_0() throws Exception
{    if (treeState.get() == TreeState.STARTED) {        if (dataIsCompressed) {            maybeWatch(client.getData().decompressed()).forPath(path);        } else {            maybeWatch(client.getData()).forPath(path);        }    }}
private Pathable<T> curator_f1783_0(P dataBuilder)
{    if (disableZkWatches) {        return dataBuilder.inBackground(this);    } else {        return dataBuilder.usingWatcher(this).inBackground(this);    }}
 void curator_f1784_0() throws Exception
{    refresh();    ConcurrentMap<String, TreeNode> childMap = children;    if (childMap != null) {        for (TreeNode child : childMap.values()) {            child.wasReconnected();        }    }}
 void curator_f1785_0() throws Exception
{    refresh();}
 void curator_f1786_0() throws Exception
{    ChildData oldChildData = childDataUpdater.getAndSet(this, DEAD);    if (oldChildData == DEAD) {        return;    }    ConcurrentMap<String, TreeNode> childMap = childrenUpdater.getAndSet(this, null);    if (childMap != null) {        ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());        childMap.clear();        for (TreeNode child : childCopy) {            child.wasDeleted();        }    }    if (treeState.get() == TreeState.CLOSED) {        return;    }    if (isLive(oldChildData)) {        publishEvent(TreeCacheEvent.Type.NODE_REMOVED, oldChildData);    }    if (parent == null) {                maybeWatch(client.checkExists()).forPath(path);    } else {                ConcurrentMap<String, TreeNode> parentChildMap = parent.children;        if (parentChildMap != null) {            parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);        }    }}
public void curator_f1787_1(WatchedEvent event)
{        try {        switch(event.getType()) {            case NodeCreated:                Preconditions.checkState(parent == null, "unexpected NodeCreated on non-root node");                wasCreated();                break;            case NodeChildrenChanged:                refreshChildren();                break;            case NodeDataChanged:                refreshData();                break;            case NodeDeleted:                wasDeleted();                break;        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
public void curator_f1788_1(CuratorFramework client, CuratorEvent event) throws Exception
{        Stat newStat = event.getStat();    switch(event.getType()) {        case EXISTS:            Preconditions.checkState(parent == null, "unexpected EXISTS on non-root node");            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                childDataUpdater.compareAndSet(this, DEAD, null);                wasCreated();            }            break;        case CHILDREN:            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                ChildData oldChildData = childData;                                if (isLive(oldChildData) && oldChildData.getStat().getMzxid() == newStat.getMzxid()) {                                                            childDataUpdater.compareAndSet(this, oldChildData, new ChildData(oldChildData.getPath(), newStat, oldChildData.getData()));                }                if (event.getChildren().isEmpty()) {                    break;                }                ConcurrentMap<String, TreeNode> childMap = children;                while (childMap == null) {                    childMap = Maps.newConcurrentMap();                    if (!childrenUpdater.compareAndSet(this, null, childMap)) {                        childMap = children;                    }                }                                List<String> newChildren = new ArrayList<String>();                for (String child : event.getChildren()) {                    if (!childMap.containsKey(child) && selector.acceptChild(ZKPaths.makePath(path, child))) {                        newChildren.add(child);                    }                }                Collections.sort(newChildren);                for (String child : newChildren) {                    String fullPath = ZKPaths.makePath(path, child);                    TreeNode node = new TreeNode(fullPath, this);                    if (childMap.putIfAbsent(child, node) == null) {                        node.wasCreated();                    }                }            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                wasDeleted();            }            break;        case GET_DATA:            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                String eventPath = event.getPath();                ChildData toPublish = new ChildData(eventPath, newStat, event.getData());                ChildData toUpdate = cacheData ? toPublish : new ChildData(eventPath, newStat, null);                while (true) {                    final ChildData oldChildData = childData;                                        if (isLive(oldChildData) && newStat.getMzxid() <= oldChildData.getStat().getMzxid()) {                        break;                    }                                        if (parent != null && oldChildData == DEAD) {                        break;                    }                    if (childDataUpdater.compareAndSet(this, oldChildData, toUpdate)) {                        publishEvent(isLive(oldChildData) ? TreeCacheEvent.Type.NODE_UPDATED : TreeCacheEvent.Type.NODE_ADDED, toPublish);                        break;                    }                }            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                wasDeleted();            }            break;        default:                                                outstandingOps.decrementAndGet();            return;    }    if (outstandingOps.decrementAndGet() == 0) {        if (isInitialized.compareAndSet(false, true)) {            publishEvent(TreeCacheEvent.Type.INITIALIZED);        }    }}
public void curator_f1789_0(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
public TreeCache curator_f1790_0() throws Exception
{    Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), "already started");    if (createParentNodes) {        client.createContainers(root.path);    }    client.getConnectionStateListenable().addListener(connectionStateListener);    if (client.getZookeeperClient().isConnected()) {        root.wasCreated();    }    return this;}
public void curator_f1791_0()
{    if (treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED)) {        client.removeWatchers();        client.getConnectionStateListenable().removeListener(connectionStateListener);        listeners.clear();        executorService.shutdown();        try {            root.wasDeleted();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            handleException(e);        }    }}
public Listenable<TreeCacheListener> curator_f1792_0()
{    return listeners;}
public Listenable<UnhandledErrorListener> curator_f1793_0()
{    return errorListeners;}
private TreeNode curator_f1794_0(String findPath)
{    PathUtils.validatePath(findPath);    LinkedList<String> rootElements = new LinkedList<String>(ZKPaths.split(root.path));    LinkedList<String> findElements = new LinkedList<String>(ZKPaths.split(findPath));    while (!rootElements.isEmpty()) {        if (findElements.isEmpty()) {                        return null;        }        String nextRoot = rootElements.removeFirst();        String nextFind = findElements.removeFirst();        if (!nextFind.equals(nextRoot)) {                        return null;        }    }    TreeNode current = root;    while (!findElements.isEmpty()) {        String nextFind = findElements.removeFirst();        ConcurrentMap<String, TreeNode> map = current.children;        if (map == null) {            return null;        }        current = map.get(nextFind);        if (current == null) {            return null;        }    }    return current;}
public Map<String, ChildData> curator_f1795_0(String fullPath)
{    TreeNode node = find(fullPath);    if (node == null || !isLive(node.childData)) {        return null;    }    ConcurrentMap<String, TreeNode> map = node.children;    Map<String, ChildData> result;    if (map == null) {        result = ImmutableMap.of();    } else {        ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();        for (Map.Entry<String, TreeNode> entry : map.entrySet()) {            ChildData childData = entry.getValue().childData;                        if (isLive(childData)) {                builder.put(entry.getKey(), childData);            }        }        result = builder.build();    }        return isLive(node.childData) ? result : null;}
public ChildData curator_f1796_0(String fullPath)
{    TreeNode node = find(fullPath);    if (node == null) {        return null;    }    ChildData result = node.childData;    return isLive(result) ? result : null;}
private void curator_f1797_0(final TreeCacheEvent event)
{    listeners.forEach(new Function<TreeCacheListener, Void>() {        @Override        public Void apply(TreeCacheListener listener) {            try {                listener.childEvent(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            return null;        }    });}
public Void curator_f1798_0(TreeCacheListener listener)
{    try {        listener.childEvent(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }    return null;}
private void curator_f1799_1(final Throwable e)
{    if (errorListeners.size() == 0) {            } else {        errorListeners.forEach(new Function<UnhandledErrorListener, Void>() {            @Override            public Void apply(UnhandledErrorListener listener) {                try {                    listener.unhandledError("", e);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    }                return null;            }        });    }}
public Void curator_f1800_1(UnhandledErrorListener listener)
{    try {        listener.unhandledError("", e);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
private void curator_f1801_0(ConnectionState newState)
{    switch(newState) {        case SUSPENDED:            publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);            break;        case LOST:            isInitialized.set(false);            publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);            break;        case CONNECTED:            try {                root.wasCreated();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            break;        case RECONNECTED:            try {                root.wasReconnected();                publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            break;    }}
private void curator_f1802_0(TreeCacheEvent.Type type)
{    publishEvent(new TreeCacheEvent(type, null));}
private void curator_f1803_0(TreeCacheEvent.Type type, ChildData data)
{    publishEvent(new TreeCacheEvent(type, data));}
private void curator_f1804_1(final TreeCacheEvent event)
{    if (treeState.get() != TreeState.CLOSED) {                executorService.submit(new Runnable() {            @Override            public void run() {                try {                    callListeners(event);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }            }        });    }}
public void curator_f1805_0()
{    try {        callListeners(event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
public Type curator_f1806_0()
{    return type;}
public ChildData curator_f1807_0()
{    return data;}
public String curator_f1808_0()
{    return TreeCacheEvent.class.getSimpleName() + "{" + "type=" + type + ", data=" + data + '}';}
public void curator_f1809_0(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
public String curator_f1810_0(String str, String lockName)
{    return StandardLockInternalsDriver.standardFixForSorting(str, lockName);}
public void curator_f1811_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    startTask.set(AfterConnectionEstablished.execute(client, new Runnable() {        @Override        public void run() {            try {                internalStart();            } finally {                startTask.set(null);            }        }    }));}
public void curator_f1812_0()
{    try {        internalStart();    } finally {        startTask.set(null);    }}
public void curator_f1813_0() throws IOException
{    close(closeMode);}
public synchronized void curator_f1814_0(CloseMode closeMode) throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    Preconditions.checkNotNull(closeMode, "closeMode cannot be null");    cancelStartTask();    try {        setNode(null);        client.removeWatchers();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    } finally {        client.getConnectionStateListenable().removeListener(listener);        switch(closeMode) {            case NOTIFY_LEADER:                {                    setLeadership(false);                    listeners.clear();                    break;                }            default:                {                    listeners.clear();                    setLeadership(false);                    break;                }        }    }}
protected boolean curator_f1815_0()
{    Future<?> localStartTask = startTask.getAndSet(null);    if (localStartTask != null) {        localStartTask.cancel(true);        return true;    }    return false;}
public void curator_f1816_0(LeaderLatchListener listener)
{    listeners.addListener(listener);}
public void curator_f1817_0(LeaderLatchListener listener, Executor executor)
{    listeners.addListener(listener, executor);}
public void curator_f1818_0(LeaderLatchListener listener)
{    listeners.removeListener(listener);}
public void curator_f1819_0() throws InterruptedException, EOFException
{    synchronized (this) {        while ((state.get() == State.STARTED) && !hasLeadership.get()) {            wait();        }    }    if (state.get() != State.STARTED) {        throw new EOFException();    }}
public boolean curator_f1820_0(long timeout, TimeUnit unit) throws InterruptedException
{    long waitNanos = TimeUnit.NANOSECONDS.convert(timeout, unit);    synchronized (this) {        while (true) {            if (state.get() != State.STARTED) {                return false;            }            if (hasLeadership()) {                return true;            }            if (waitNanos <= 0) {                return false;            }            long startNanos = System.nanoTime();            TimeUnit.NANOSECONDS.timedWait(this, waitNanos);            long elapsed = System.nanoTime() - startNanos;            waitNanos -= elapsed;        }    }}
public String curator_f1821_0()
{    return id;}
public State curator_f1822_0()
{    return state.get();}
public Collection<Participant> curator_f1823_0() throws Exception
{    Collection<String> participantNodes = LockInternals.getParticipantNodes(client, latchPath, LOCK_NAME, sorter);    return LeaderSelector.getParticipants(client, participantNodes);}
public Participant curator_f1824_0() throws Exception
{    Collection<String> participantNodes = LockInternals.getParticipantNodes(client, latchPath, LOCK_NAME, sorter);    return LeaderSelector.getLeader(client, participantNodes);}
public boolean curator_f1825_0()
{    return (state.get() == State.STARTED) && hasLeadership.get();}
public String curator_f1826_0()
{    return ourPath.get();}
 void curator_f1827_1() throws Exception
{    setLeadership(false);    setNode(null);    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (debugResetWaitLatch != null) {                debugResetWaitLatch.await();                debugResetWaitLatch = null;            }            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                setNode(event.getName());                if (state.get() == State.CLOSED) {                    setNode(null);                } else {                    getChildren();                }            } else {                            }        }    };    client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(callback).forPath(ZKPaths.makePath(latchPath, LOCK_NAME), LeaderSelector.getIdBytes(id));}
public void curator_f1828_1(CuratorFramework client, CuratorEvent event) throws Exception
{    if (debugResetWaitLatch != null) {        debugResetWaitLatch.await();        debugResetWaitLatch = null;    }    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        setNode(event.getName());        if (state.get() == State.CLOSED) {            setNode(null);        } else {            getChildren();        }    } else {            }}
private synchronized void curator_f1829_1()
{    if (state.get() == State.STARTED) {        client.getConnectionStateListenable().addListener(listener);        try {            reset();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);                    }    }}
private void curator_f1830_1(List<String> children) throws Exception
{    if (debugCheckLeaderShipLatch != null) {        debugCheckLeaderShipLatch.await();    }    final String localOurPath = ourPath.get();    List<String> sortedChildren = LockInternals.getSortedChildren(LOCK_NAME, sorter, children);    int ourIndex = (localOurPath != null) ? sortedChildren.indexOf(ZKPaths.getNodeFromPath(localOurPath)) : -1;    if (ourIndex < 0) {                reset();    } else if (ourIndex == 0) {        setLeadership(true);    } else {        String watchPath = sortedChildren.get(ourIndex - 1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if ((state.get() == State.STARTED) && (event.getType() == Event.EventType.NodeDeleted) && (localOurPath != null)) {                    try {                        getChildren();                    } catch (Exception ex) {                        ThreadUtils.checkInterrupted(ex);                                            }                }            }        };        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                                        reset();                }            }        };                client.getData().usingWatcher(watcher).inBackground(callback).forPath(ZKPaths.makePath(latchPath, watchPath));    }}
public void curator_f1831_1(WatchedEvent event)
{    if ((state.get() == State.STARTED) && (event.getType() == Event.EventType.NodeDeleted) && (localOurPath != null)) {        try {            getChildren();        } catch (Exception ex) {            ThreadUtils.checkInterrupted(ex);                    }    }}
public void curator_f1832_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                reset();    }}
private void curator_f1833_0() throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                checkLeadership(event.getChildren());            }        }    };    client.getChildren().inBackground(callback).forPath(ZKPaths.makePath(latchPath, null));}
public void curator_f1834_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        checkLeadership(event.getChildren());    }}
protected void curator_f1835_1(ConnectionState newState)
{    switch(newState) {        default:            {                                break;            }        case RECONNECTED:            {                try {                    if (client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED) || !hasLeadership.get()) {                        reset();                    }                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                        setLeadership(false);                }                break;            }        case SUSPENDED:            {                if (client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED)) {                    setLeadership(false);                }                break;            }        case LOST:            {                setLeadership(false);                break;            }    }}
private synchronized void curator_f1836_0(boolean newValue)
{    boolean oldValue = hasLeadership.getAndSet(newValue);    if (oldValue && !newValue) {                listeners.forEach(new Function<LeaderLatchListener, Void>() {            @Override            public Void apply(LeaderLatchListener listener) {                listener.notLeader();                return null;            }        });    } else if (!oldValue && newValue) {                listeners.forEach(new Function<LeaderLatchListener, Void>() {            @Override            public Void apply(LeaderLatchListener input) {                input.isLeader();                return null;            }        });    }    notifyAll();}
public Void curator_f1837_0(LeaderLatchListener listener)
{    listener.notLeader();    return null;}
public Void curator_f1838_0(LeaderLatchListener input)
{    input.isLeader();    return null;}
private void curator_f1839_0(String newValue) throws Exception
{    String oldPath = ourPath.getAndSet(newValue);    if (oldPath != null) {        client.delete().guaranteed().inBackground().forPath(oldPath);    }}
protected byte[] curator_f1840_0()
{    return (id.length() > 0) ? getIdBytes(id) : null;}
 static byte[] curator_f1841_0(String id)
{    try {        return id.getBytes("UTF-8");    } catch (UnsupportedEncodingException e) {                throw new Error(e);    }}
public void curator_f1842_0()
{    autoRequeue.set(true);}
public void curator_f1843_0(String id)
{    Preconditions.checkNotNull(id, "id cannot be null");    this.id = id;}
public String curator_f1844_0()
{    return id;}
public void curator_f1845_0()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    Preconditions.checkState(!executorService.isShutdown(), "Already started");    Preconditions.checkState(!hasLeadership, "Already has leadership");    client.getConnectionStateListenable().addListener(listener);    requeue();}
public boolean curator_f1846_0()
{    Preconditions.checkState(state.get() == State.STARTED, "close() has already been called");    return internalRequeue();}
private synchronized boolean curator_f1847_0()
{    if (!isQueued && (state.get() == State.STARTED)) {        isQueued = true;        Future<Void> task = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    doWorkLoop();                } finally {                    clearIsQueued();                    if (autoRequeue.get()) {                        internalRequeue();                    }                }                return null;            }        });        ourTask.set(task);        return true;    }    return false;}
public Void curator_f1848_0() throws Exception
{    try {        doWorkLoop();    } finally {        clearIsQueued();        if (autoRequeue.get()) {            internalRequeue();        }    }    return null;}
public synchronized void curator_f1849_0()
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    client.getConnectionStateListenable().removeListener(listener);    executorService.close();    ourTask.set(null);}
public Collection<Participant> curator_f1850_0() throws Exception
{    Collection<String> participantNodes = mutex.getParticipantNodes();    return getParticipants(client, participantNodes);}
 static Collection<Participant> curator_f1851_0(CuratorFramework client, Collection<String> participantNodes) throws Exception
{    ImmutableList.Builder<Participant> builder = ImmutableList.builder();    boolean isLeader = true;    for (String path : participantNodes) {        Participant participant = participantForPath(client, path, isLeader);        if (participant != null) {            builder.add(participant);                        isLeader = false;        }    }    return builder.build();}
public Participant curator_f1852_0() throws Exception
{    Collection<String> participantNodes = mutex.getParticipantNodes();    return getLeader(client, participantNodes);}
 static Participant curator_f1853_0(CuratorFramework client, Collection<String> participantNodes) throws Exception
{    Participant result = null;    if (participantNodes.size() > 0) {        Iterator<String> iter = participantNodes.iterator();        while (iter.hasNext()) {            result = participantForPath(client, iter.next(), true);            if (result != null) {                break;            }        }    }    if (result == null) {        result = new Participant();    }    return result;}
public boolean curator_f1854_0()
{    return hasLeadership;}
public synchronized void curator_f1855_0()
{    Future<?> task = ourTask.get();    if (task != null) {        task.cancel(true);    }}
private static Participant curator_f1856_0(CuratorFramework client, String path, boolean markAsLeader) throws Exception
{    try {        byte[] bytes = client.getData().forPath(path);        String thisId = new String(bytes, "UTF-8");        return new Participant(thisId, markAsLeader);    } catch (KeeperException.NoNodeException e) {        return null;    }}
 void curator_f1857_1() throws Exception
{    hasLeadership = false;    try {        mutex.acquire();        hasLeadership = true;        try {            if (debugLeadershipLatch != null) {                debugLeadershipLatch.countDown();            }            if (debugLeadershipWaitLatch != null) {                debugLeadershipWaitLatch.await();            }            listener.takeLeadership(client);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            throw e;        } catch (Throwable e) {            ThreadUtils.checkInterrupted(e);        } finally {            clearIsQueued();        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw e;    } finally {        if (hasLeadership) {            hasLeadership = false;                        boolean wasInterrupted = Thread.interrupted();            try {                mutex.release();            } catch (Exception e) {                if (failedMutexReleaseCount != null) {                    failedMutexReleaseCount.incrementAndGet();                }                ThreadUtils.checkInterrupted(e);                                        } finally {                if (wasInterrupted) {                    Thread.currentThread().interrupt();                }            }        }    }}
private void curator_f1858_0() throws Exception
{    KeeperException exception = null;    try {        doWork();    } catch (KeeperException.ConnectionLossException e) {        exception = e;    } catch (KeeperException.SessionExpiredException e) {        exception = e;    } catch (InterruptedException ignore) {        Thread.currentThread().interrupt();    }    if (    (exception != null) && !autoRequeue.get()) {        throw exception;    }}
private synchronized void curator_f1859_0()
{    isQueued = false;}
private static ExecutorService curator_f1860_0(final Executor executor)
{    return new AbstractExecutorService() {        private volatile boolean isShutdown = false;        private volatile boolean isTerminated = false;        @Override        public void shutdown() {            isShutdown = true;        }        @Override        public List<Runnable> shutdownNow() {            return Lists.newArrayList();        }        @Override        public boolean isShutdown() {            return isShutdown;        }        @Override        public boolean isTerminated() {            return isTerminated;        }        @Override        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {            throw new UnsupportedOperationException();        }        @Override        public void execute(Runnable command) {            try {                executor.execute(command);            } finally {                isShutdown = true;                isTerminated = true;            }        }    };}
public void curator_f1861_0()
{    isShutdown = true;}
public List<Runnable> curator_f1862_0()
{    return Lists.newArrayList();}
public boolean curator_f1863_0()
{    return isShutdown;}
public boolean curator_f1864_0()
{    return isTerminated;}
public boolean curator_f1865_0(long timeout, TimeUnit unit) throws InterruptedException
{    throw new UnsupportedOperationException();}
public void curator_f1866_0(Runnable command)
{    try {        executor.execute(command);    } finally {        isShutdown = true;        isTerminated = true;    }}
public void curator_f1867_0(CuratorFramework client) throws Exception
{    listener.takeLeadership(client);}
public void curator_f1868_0(CuratorFramework client, ConnectionState newState)
{    try {        listener.stateChanged(client, newState);    } catch (CancelLeadershipException dummy) {        leaderSelector.interruptLeadership();    }}
public void curator_f1869_0(CuratorFramework client, ConnectionState newState)
{    if (client.getConnectionStateErrorPolicy().isErrorState(newState)) {        throw new CancelLeadershipException();    }}
public String curator_f1870_0()
{    return id;}
public boolean curator_f1871_0()
{    return isLeader;}
public String curator_f1872_0()
{    return "Participant{" + "id='" + id + '\'' + ", isLeader=" + isLeader + '}';}
public boolean curator_f1873_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Participant that = (Participant) o;    if (isLeader != that.isLeader) {        return false;    }    if (!id.equals(that.id)) {        return false;    }    return true;}
public int curator_f1874_0()
{    int result = id.hashCode();    result = 31 * result + (isLeader ? 1 : 0);    return result;}
public void curator_f1875_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    task = executor.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            doWork();        }    }, reapingThresholdMs, reapingThresholdMs, TimeUnit.MILLISECONDS);    if (leaderLatch != null) {        leaderLatch.start();    }    reaper.start();}
public void curator_f1876_0()
{    doWork();}
public void curator_f1877_0() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        CloseableUtils.closeQuietly(reaper);        if (leaderLatch != null) {            CloseableUtils.closeQuietly(leaderLatch);        }        task.cancel(true);    }}
public ChildReaper curator_f1878_0(String path)
{    paths.add(PathUtils.validatePath(path));    return this;}
public boolean curator_f1879_0(String path)
{    return paths.remove(PathUtils.validatePath(path));}
public void curator_f1880_0(int maxChildren)
{    this.maxChildren.set(maxChildren);}
public static ScheduledExecutorService curator_f1881_0()
{    return ThreadUtils.newFixedThreadScheduledPool(2, "ChildReaper");}
protected void curator_f1882_1(String path, Stat stat)
{    }
private void curator_f1883_1()
{    if (shouldDoWork()) {        if ((pathIterator == null) || !pathIterator.hasNext()) {            pathIterator = paths.iterator();        }        while (pathIterator.hasNext()) {            String path = pathIterator.next();            try {                int maxChildren = this.maxChildren.get();                if (maxChildren > 0) {                    Stat stat = client.checkExists().forPath(path);                    if ((stat != null) && (stat.getNumChildren() > maxChildren)) {                        warnMaxChildren(path, stat);                        continue;                    }                }                List<String> children = client.getChildren().forPath(path);                                for (String name : children) {                    String childPath = ZKPaths.makePath(path, name);                    addPathToReaperIfEmpty(childPath);                    for (String subNode : lockSchema) {                        addPathToReaperIfEmpty(ZKPaths.makePath(childPath, subNode));                    }                }            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }        }    }}
private void curator_f1884_1(String path) throws Exception
{    Stat stat = client.checkExists().forPath(path);    if ((stat != null) && (stat.getNumChildren() == 0)) {                reaper.addPath(path, mode);    }}
private boolean curator_f1885_0()
{    return this.leaderLatch == null || this.leaderLatch.hasLeadership();}
private static List<InterProcessLock> curator_f1886_0(CuratorFramework client, List<String> paths)
{    ImmutableList.Builder<InterProcessLock> builder = ImmutableList.builder();    for (String path : paths) {        InterProcessLock lock = new InterProcessMutex(client, path);        builder.add(lock);    }    return builder.build();}
public void curator_f1887_0() throws Exception
{    acquire(-1, null);}
public boolean curator_f1888_0(long time, TimeUnit unit) throws Exception
{    Exception exception = null;    List<InterProcessLock> acquired = Lists.newArrayList();    boolean success = true;    for (InterProcessLock lock : locks) {        try {            if (unit == null) {                lock.acquire();                acquired.add(lock);            } else {                if (lock.acquire(time, unit)) {                    acquired.add(lock);                } else {                    success = false;                    break;                }            }        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            success = false;            exception = e;        }    }    if (!success) {        for (InterProcessLock lock : reverse(acquired)) {            try {                lock.release();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                        }        }    }    if (exception != null) {        throw exception;    }    return success;}
public synchronized void curator_f1889_0() throws Exception
{    Exception baseException = null;    for (InterProcessLock lock : reverse(locks)) {        try {            lock.release();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            if (baseException == null) {                baseException = e;            } else {                baseException = new Exception(baseException);            }        }    }    if (baseException != null) {        throw baseException;    }}
public synchronized boolean curator_f1890_0()
{    for (InterProcessLock lock : locks) {        if (!lock.isAcquiredInThisProcess()) {            return false;        }    }    return true;}
public void curator_f1891_0() throws Exception
{    if (!internalLock(-1, null)) {        throw new IOException("Lost connection while trying to acquire lock: " + basePath);    }}
public boolean curator_f1892_0(long time, TimeUnit unit) throws Exception
{    return internalLock(time, unit);}
public boolean curator_f1893_0()
{    return (threadData.size() > 0);}
public void curator_f1894_0() throws Exception
{    /*            Note on concurrency: a given lockData instance            can be only acted on by a single thread so locking isn't necessary         */    Thread currentThread = Thread.currentThread();    LockData lockData = threadData.get(currentThread);    if (lockData == null) {        throw new IllegalMonitorStateException("You do not own the lock: " + basePath);    }    int newLockCount = lockData.lockCount.decrementAndGet();    if (newLockCount > 0) {        return;    }    if (newLockCount < 0) {        throw new IllegalMonitorStateException("Lock count has gone negative for lock: " + basePath);    }    try {        internals.releaseLock(lockData.lockPath);    } finally {        threadData.remove(currentThread);    }}
public Collection<String> curator_f1895_0() throws Exception
{    return LockInternals.getParticipantNodes(internals.getClient(), basePath, internals.getLockName(), internals.getDriver());}
public void curator_f1896_0(RevocationListener<InterProcessMutex> listener)
{    makeRevocable(listener, MoreExecutors.directExecutor());}
public void curator_f1897_0(final RevocationListener<InterProcessMutex> listener, Executor executor)
{    internals.makeRevocable(new RevocationSpec(executor, new Runnable() {        @Override        public void run() {            listener.revocationRequested(InterProcessMutex.this);        }    }));}
public void curator_f1898_0()
{    listener.revocationRequested(InterProcessMutex.this);}
public boolean curator_f1899_0()
{    LockData lockData = threadData.get(Thread.currentThread());    return (lockData != null) && (lockData.lockCount.get() > 0);}
protected byte[] curator_f1900_0()
{    return null;}
protected String curator_f1901_0()
{    LockData lockData = threadData.get(Thread.currentThread());    return lockData != null ? lockData.lockPath : null;}
private boolean curator_f1902_0(long time, TimeUnit unit) throws Exception
{    /*           Note on concurrency: a given lockData instance           can be only acted on by a single thread so locking isn't necessary        */    Thread currentThread = Thread.currentThread();    LockData lockData = threadData.get(currentThread);    if (lockData != null) {                lockData.lockCount.incrementAndGet();        return true;    }    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());    if (lockPath != null) {        LockData newLockData = new LockData(currentThread, lockPath);        threadData.put(currentThread, newLockData);        return true;    }    return false;}
public final String curator_f1903_0(String str, String lockName)
{    str = super.fixForSorting(str, READ_LOCK_NAME);    str = super.fixForSorting(str, WRITE_LOCK_NAME);    return str;}
public Collection<String> curator_f1904_0() throws Exception
{    Collection<String> nodes = super.getParticipantNodes();    Iterable<String> filtered = Iterables.filter(nodes, new Predicate<String>() {        @Override        public boolean apply(String node) {            return node.contains(lockName);        }    });    return ImmutableList.copyOf(filtered);}
public boolean curator_f1905_0(String node)
{    return node.contains(lockName);}
protected byte[] curator_f1906_0()
{    return lockData;}
public PredicateResults curator_f1907_0(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    return super.getsTheLock(client, children, sequenceNodeName, maxLeases);}
public PredicateResults curator_f1908_0(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    return readLockPredicate(children, sequenceNodeName);}
public InterProcessMutex curator_f1909_0()
{    return readMutex;}
public InterProcessMutex curator_f1910_0()
{    return writeMutex;}
private PredicateResults curator_f1911_0(List<String> children, String sequenceNodeName) throws Exception
{    if (writeMutex.isOwnedByCurrentThread()) {        return new PredicateResults(null, true);    }    int index = 0;    int firstWriteIndex = Integer.MAX_VALUE;    int ourIndex = -1;    for (String node : children) {        if (node.contains(WRITE_LOCK_NAME)) {            firstWriteIndex = Math.min(index, firstWriteIndex);        } else if (node.startsWith(sequenceNodeName)) {            ourIndex = index;            break;        }        ++index;    }    StandardLockInternalsDriver.validateOurIndex(sequenceNodeName, ourIndex);    boolean getsTheLock = (ourIndex < firstWriteIndex);    String pathToWatch = getsTheLock ? null : children.get(firstWriteIndex);    return new PredicateResults(pathToWatch, getsTheLock);}
public void curator_f1912_0(SharedCountReader sharedCount, int newCount) throws Exception
{    internals.setMaxLeases(newCount);}
public void curator_f1913_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f1914_0(Collection<Lease> leases)
{    for (Lease l : leases) {        CloseableUtils.closeQuietly(l);    }}
public void curator_f1915_0(Lease lease)
{    CloseableUtils.closeQuietly(lease);}
public Lease curator_f1916_0() throws Exception
{    String path = internals.attemptLock(-1, null, null);    return makeLease(path);}
public Collection<Lease> curator_f1917_0(int qty) throws Exception
{    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    try {        while (qty-- > 0) {            String path = internals.attemptLock(-1, null, null);            builder.add(makeLease(path));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        returnAll(builder.build());        throw e;    }    return builder.build();}
public Lease curator_f1918_0(long time, TimeUnit unit) throws Exception
{    String path = internals.attemptLock(time, unit, null);    return (path != null) ? makeLease(path) : null;}
public Collection<Lease> curator_f1919_0(int qty, long time, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    long waitMs = TimeUnit.MILLISECONDS.convert(time, unit);    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    try {        while (qty-- > 0) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = waitMs - elapsedMs;            String path = (thisWaitMs > 0) ? internals.attemptLock(thisWaitMs, TimeUnit.MILLISECONDS, null) : null;            if (path == null) {                returnAll(builder.build());                return null;            }            builder.add(makeLease(path));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        returnAll(builder.build());        throw e;    }    return builder.build();}
private Lease curator_f1920_1(final String path)
{    return new Lease() {        @Override        public void close() throws IOException {            try {                internals.releaseLock(path);            } catch (KeeperException.NoNodeException e) {                            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                throw new IOException(e);            }        }        @Override        public byte[] getData() throws Exception {            return internals.getClient().getData().forPath(path);        }        @Override        public String getNodeName() {            return ZKPaths.getNodeFromPath(path);        }    };}
public void curator_f1921_1() throws IOException
{    try {        internals.releaseLock(path);    } catch (KeeperException.NoNodeException e) {            } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }}
public byte[] curator_f1922_0() throws Exception
{    return internals.getClient().getData().forPath(path);}
public String curator_f1923_0()
{    return ZKPaths.getNodeFromPath(path);}
public void curator_f1924_0() throws Exception
{    lease = semaphore.acquire();}
public boolean curator_f1925_0(long time, TimeUnit unit) throws Exception
{    Lease acquiredLease = semaphore.acquire(time, unit);    if (acquiredLease == null) {                return false;    }    lease = acquiredLease;    return true;}
public void curator_f1926_0() throws Exception
{    Lease lease = this.lease;    Preconditions.checkState(lease != null, "Not acquired");    this.lease = null;    lease.close();    watcherRemoveClient.removeWatchers();}
public boolean curator_f1927_0()
{    return (lease != null);}
public void curator_f1928_0(WatchedEvent event)
{    client.postSafeNotify(InterProcessSemaphoreV2.this);}
public void curator_f1929_0(SharedCountReader sharedCount, int newCount) throws Exception
{    InterProcessSemaphoreV2.this.maxLeases = newCount;    client.postSafeNotify(InterProcessSemaphoreV2.this);}
public void curator_f1930_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f1931_0(byte[] nodeData)
{    this.nodeData = (nodeData != null) ? Arrays.copyOf(nodeData, nodeData.length) : null;}
public Collection<String> curator_f1932_0() throws Exception
{    return client.getChildren().forPath(leasesPath);}
public void curator_f1933_0(Collection<Lease> leases)
{    for (Lease l : leases) {        CloseableUtils.closeQuietly(l);    }}
public void curator_f1934_0(Lease lease)
{    CloseableUtils.closeQuietly(lease);}
public Lease curator_f1935_0() throws Exception
{    Collection<Lease> leases = acquire(1, 0, null);    return leases.iterator().next();}
public Collection<Lease> curator_f1936_0(int qty) throws Exception
{    return acquire(qty, 0, null);}
public Lease curator_f1937_0(long time, TimeUnit unit) throws Exception
{    Collection<Lease> leases = acquire(1, time, unit);    return (leases != null) ? leases.iterator().next() : null;}
public Collection<Lease> curator_f1938_0(int qty, long time, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasWait = (unit != null);    long waitMs = hasWait ? TimeUnit.MILLISECONDS.convert(time, unit) : 0;    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    boolean success = false;    try {        while (qty-- > 0) {            int retryCount = 0;            long startMillis = System.currentTimeMillis();            boolean isDone = false;            while (!isDone) {                switch(internalAcquire1Lease(builder, startMs, hasWait, waitMs)) {                    case CONTINUE:                        {                            isDone = true;                            break;                        }                    case RETURN_NULL:                        {                            return null;                        }                    case RETRY_DUE_TO_MISSING_NODE:                        {                                                        if (!client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper())) {                                throw new KeeperException.NoNodeException("Sequential path not found - possible session loss");                            }                                                        break;                        }                }            }        }        success = true;    } finally {        if (!success) {            returnAll(builder.build());        }    }    return builder.build();}
private InternalAcquireResult curator_f1939_1(ImmutableList.Builder<Lease> builder, long startMs, boolean hasWait, long waitMs) throws Exception
{    if (client.getState() != CuratorFrameworkState.STARTED) {        return InternalAcquireResult.RETURN_NULL;    }    if (hasWait) {        long thisWaitMs = getThisWaitMs(startMs, waitMs);        if (!lock.acquire(thisWaitMs, TimeUnit.MILLISECONDS)) {            return InternalAcquireResult.RETURN_NULL;        }    } else {        lock.acquire();    }    Lease lease = null;    boolean success = false;    try {        PathAndBytesable<String> createBuilder = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL);        String path = (nodeData != null) ? createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME), nodeData) : createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME));        String nodeName = ZKPaths.getNodeFromPath(path);        lease = makeLease(path);        if (debugAcquireLatch != null) {            debugAcquireLatch.await();        }        try {            synchronized (this) {                for (; ; ) {                    List<String> children;                    try {                        children = client.getChildren().usingWatcher(watcher).forPath(leasesPath);                    } catch (Exception e) {                        if (debugFailedGetChildrenLatch != null) {                            debugFailedGetChildrenLatch.countDown();                        }                        throw e;                    }                    if (!children.contains(nodeName)) {                                                return InternalAcquireResult.RETRY_DUE_TO_MISSING_NODE;                    }                    if (children.size() <= maxLeases) {                        break;                    }                    if (hasWait) {                        long thisWaitMs = getThisWaitMs(startMs, waitMs);                        if (thisWaitMs <= 0) {                            return InternalAcquireResult.RETURN_NULL;                        }                        if (debugWaitLatch != null) {                            debugWaitLatch.countDown();                        }                        wait(thisWaitMs);                    } else {                        if (debugWaitLatch != null) {                            debugWaitLatch.countDown();                        }                        wait();                    }                }                success = true;            }        } finally {            if (!success) {                returnLease(lease);            }            client.removeWatchers();        }    } finally {        lock.release();    }    builder.add(Preconditions.checkNotNull(lease));    return InternalAcquireResult.CONTINUE;}
private long curator_f1940_0(long startMs, long waitMs)
{    long elapsedMs = System.currentTimeMillis() - startMs;    return waitMs - elapsedMs;}
private Lease curator_f1941_1(final String path)
{    return new Lease() {        @Override        public void close() throws IOException {            try {                client.delete().guaranteed().forPath(path);            } catch (KeeperException.NoNodeException e) {                            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                throw new IOException(e);            }        }        @Override        public byte[] getData() throws Exception {            return client.getData().forPath(path);        }        @Override        public String getNodeName() {            return ZKPaths.getNodeFromPath(path);        }    };}
public void curator_f1942_1() throws IOException
{    try {        client.delete().guaranteed().forPath(path);    } catch (KeeperException.NoNodeException e) {            } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }}
public byte[] curator_f1943_0() throws Exception
{    return client.getData().forPath(path);}
public String curator_f1944_0()
{    return ZKPaths.getNodeFromPath(path);}
public void curator_f1945_0() throws Exception
{    if (acquired.compareAndSet(true, false)) {        releaseLock();    }}
protected void curator_f1946_0() throws Exception
{    lock.release();}
protected void curator_f1947_0(InterProcessLock lock) throws Exception
{    lock.acquire();}
protected boolean curator_f1948_0(InterProcessLock lock, long timeout, TimeUnit unit) throws Exception
{    return lock.acquire(timeout, unit);}
public void curator_f1949_0(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {        checkRevocableWatcher(event.getPath());    }}
public void curator_f1950_0(WatchedEvent event)
{    client.postSafeNotify(LockInternals.this);}
public void curator_f1951_0() throws Exception
{    try {        client.delete().forPath(basePath);    } catch (KeeperException.BadVersionException ignore) {        } catch (KeeperException.NotEmptyException ignore) {        }}
 synchronized void curator_f1952_0(int maxLeases)
{    this.maxLeases = maxLeases;    notifyAll();}
 void curator_f1953_0(RevocationSpec entry)
{    revocable.set(entry);}
 final void curator_f1954_0(String lockPath) throws Exception
{    client.removeWatchers();    revocable.set(null);    deleteOurPath(lockPath);}
 CuratorFramework curator_f1955_0()
{    return client;}
public static Collection<String> curator_f1956_0(CuratorFramework client, final String basePath, String lockName, LockInternalsSorter sorter) throws Exception
{    List<String> names = getSortedChildren(client, basePath, lockName, sorter);    Iterable<String> transformed = Iterables.transform(names, new Function<String, String>() {        @Override        public String apply(String name) {            return ZKPaths.makePath(basePath, name);        }    });    return ImmutableList.copyOf(transformed);}
public String curator_f1957_0(String name)
{    return ZKPaths.makePath(basePath, name);}
public static List<String> curator_f1958_0(CuratorFramework client, String basePath, final String lockName, final LockInternalsSorter sorter) throws Exception
{    try {        List<String> children = client.getChildren().forPath(basePath);        List<String> sortedList = Lists.newArrayList(children);        Collections.sort(sortedList, new Comparator<String>() {            @Override            public int compare(String lhs, String rhs) {                return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));            }        });        return sortedList;    } catch (KeeperException.NoNodeException ignore) {        return Collections.emptyList();    }}
public int curator_f1959_0(String lhs, String rhs)
{    return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));}
public static List<String> curator_f1960_0(final String lockName, final LockInternalsSorter sorter, List<String> children)
{    List<String> sortedList = Lists.newArrayList(children);    Collections.sort(sortedList, new Comparator<String>() {        @Override        public int compare(String lhs, String rhs) {            return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));        }    });    return sortedList;}
public int curator_f1961_0(String lhs, String rhs)
{    return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));}
 List<String> curator_f1962_0() throws Exception
{    return getSortedChildren(client, basePath, lockName, driver);}
 String curator_f1963_0()
{    return lockName;}
 LockInternalsDriver curator_f1964_0()
{    return driver;}
 String curator_f1965_0(long time, TimeUnit unit, byte[] lockNodeBytes) throws Exception
{    final long startMillis = System.currentTimeMillis();    final Long millisToWait = (unit != null) ? unit.toMillis(time) : null;    final byte[] localLockNodeBytes = (revocable.get() != null) ? new byte[0] : lockNodeBytes;    int retryCount = 0;    String ourPath = null;    boolean hasTheLock = false;    boolean isDone = false;    while (!isDone) {        isDone = true;        try {            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);        } catch (KeeperException.NoNodeException e) {                        if (client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper())) {                isDone = false;            } else {                throw e;            }        }    }    if (hasTheLock) {        return ourPath;    }    return null;}
private void curator_f1966_0(String path) throws Exception
{    RevocationSpec entry = revocable.get();    if (entry != null) {        try {            byte[] bytes = client.getData().usingWatcher(revocableWatcher).forPath(path);            if (Arrays.equals(bytes, REVOKE_MESSAGE)) {                entry.getExecutor().execute(entry.getRunnable());            }        } catch (KeeperException.NoNodeException ignore) {                }    }}
private boolean curator_f1967_0(long startMillis, Long millisToWait, String ourPath) throws Exception
{    boolean haveTheLock = false;    boolean doDelete = false;    try {        if (revocable.get() != null) {            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);        }        while ((client.getState() == CuratorFrameworkState.STARTED) && !haveTheLock) {            List<String> children = getSortedChildren();                        String sequenceNodeName = ourPath.substring(basePath.length() + 1);            PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);            if (predicateResults.getsTheLock()) {                haveTheLock = true;            } else {                String previousSequencePath = basePath + "/" + predicateResults.getPathToWatch();                synchronized (this) {                    try {                                                client.getData().usingWatcher(watcher).forPath(previousSequencePath);                        if (millisToWait != null) {                            millisToWait -= (System.currentTimeMillis() - startMillis);                            startMillis = System.currentTimeMillis();                            if (millisToWait <= 0) {                                                                doDelete = true;                                break;                            }                            wait(millisToWait);                        } else {                            wait();                        }                    } catch (KeeperException.NoNodeException e) {                                        }                }            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        doDelete = true;        throw e;    } finally {        if (doDelete) {            deleteOurPath(ourPath);        }    }    return haveTheLock;}
private void curator_f1968_0(String ourPath) throws Exception
{    try {        client.delete().guaranteed().forPath(ourPath);    } catch (KeeperException.NoNodeException e) {        }}
public String curator_f1969_0()
{    return pathToWatch;}
public boolean curator_f1970_0()
{    return getsTheLock;}
public void curator_f1971_0()
{    reap(this);}
public void curator_f1972_0(String path)
{    addPath(path, Mode.REAP_INDEFINITELY);}
public void curator_f1973_0(String path, Mode mode)
{    PathHolder pathHolder = new PathHolder(path, mode, 0);    activePaths.put(path, pathHolder);    schedule(pathHolder, reapingThresholdMs);}
public boolean curator_f1974_0(String path)
{    return activePaths.remove(path) != null;}
public void curator_f1975_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    if (leaderLatch != null && ownsLeaderLatch) {        leaderLatch.start();    }}
public void curator_f1976_0() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        executor.close();        if (leaderLatch != null && ownsLeaderLatch) {            leaderLatch.close();        }    }}
protected Future<?> curator_f1977_0(PathHolder pathHolder, int reapingThresholdMs)
{    if (reapingIsActive.get()) {        return executor.schedule(pathHolder, reapingThresholdMs, TimeUnit.MILLISECONDS);    }    return null;}
protected void curator_f1978_1(PathHolder holder)
{    if (!activePaths.containsKey(holder.path)) {        return;    }    boolean addBack = true;    int newEmptyCount = 0;    try {        Stat stat = client.checkExists().forPath(holder.path);        if (        stat != null) {            if (stat.getNumChildren() == 0) {                if ((holder.emptyCount + 1) >= EMPTY_COUNT_THRESHOLD) {                    try {                        client.delete().forPath(holder.path);                                                if (holder.mode == Mode.REAP_UNTIL_DELETE || holder.mode == Mode.REAP_UNTIL_GONE) {                            addBack = false;                        }                    } catch (KeeperException.NoNodeException ignore) {                                                if (holder.mode == Mode.REAP_UNTIL_GONE) {                            addBack = false;                        }                    } catch (KeeperException.NotEmptyException ignore) {                                        }                } else {                    newEmptyCount = holder.emptyCount + 1;                }            }        } else {            if (holder.mode == Mode.REAP_UNTIL_GONE) {                addBack = false;            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    if (!addBack) {        activePaths.remove(holder.path);    } else if (!Thread.currentThread().isInterrupted() && (state.get() == State.STARTED) && activePaths.containsKey(holder.path)) {        activePaths.put(holder.path, holder);        schedule(new PathHolder(holder.path, holder.mode, newEmptyCount), reapingThresholdMs);    }}
public static ScheduledExecutorService curator_f1979_0()
{    return ThreadUtils.newSingleThreadScheduledExecutor("Reaper");}
private void curator_f1980_0(LeaderLatch leaderLatch)
{    LeaderLatchListener listener = new LeaderLatchListener() {        @Override        public void isLeader() {            reapingIsActive.set(true);            for (PathHolder holder : activePaths.values()) {                schedule(holder, reapingThresholdMs);            }        }        @Override        public void notLeader() {            reapingIsActive.set(false);        }    };    leaderLatch.addListener(listener);    reapingIsActive.set(leaderLatch.hasLeadership());}
public void curator_f1981_0()
{    reapingIsActive.set(true);    for (PathHolder holder : activePaths.values()) {        schedule(holder, reapingThresholdMs);    }}
public void curator_f1982_0()
{    reapingIsActive.set(false);}
private static LeaderLatch curator_f1983_0(CuratorFramework client, String leaderPath)
{    if (leaderPath == null) {        return null;    } else {        return new LeaderLatch(client, leaderPath);    }}
 Runnable curator_f1984_0()
{    return runnable;}
 Executor curator_f1985_0()
{    return executor;}
public static void curator_f1986_0(CuratorFramework client, String path) throws Exception
{    try {        client.setData().forPath(path, LockInternals.REVOKE_MESSAGE);    } catch (KeeperException.NoNodeException ignore) {        }}
public PredicateResults curator_f1987_0(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    int ourIndex = children.indexOf(sequenceNodeName);    validateOurIndex(sequenceNodeName, ourIndex);    boolean getsTheLock = ourIndex < maxLeases;    String pathToWatch = getsTheLock ? null : children.get(ourIndex - maxLeases);    return new PredicateResults(pathToWatch, getsTheLock);}
public String curator_f1988_0(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception
{    String ourPath;    if (lockNodeBytes != null) {        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);    } else {        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);    }    return ourPath;}
public String curator_f1989_0(String str, String lockName)
{    return standardFixForSorting(str, lockName);}
public static String curator_f1990_0(String str, String lockName)
{    int index = str.lastIndexOf(lockName);    if (index >= 0) {        index += lockName.length();        return index <= str.length() ? str.substring(index) : "";    }    return str;}
 static void curator_f1991_0(String sequenceNodeName, int ourIndex) throws KeeperException
{    if (ourIndex < 0) {        throw new KeeperException.NoNodeException("Sequential path not found: " + sequenceNodeName);    }}
public void curator_f1992_0()
{    pen.start();    try {        cache.start();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        Throwables.propagate(e);    }}
public void curator_f1993_0(byte[] data)
{    try {        pen.setData(data);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        Throwables.propagate(e);    }}
public void curator_f1994_0()
{    CloseableUtils.closeQuietly(cache);    CloseableUtils.closeQuietly(pen);}
public Map<String, byte[]> curator_f1995_0()
{    ImmutableMap.Builder<String, byte[]> builder = ImmutableMap.builder();    boolean thisIdAdded = false;    for (ChildData data : cache.getCurrentData()) {        String id = idFromPath(data.getPath());        thisIdAdded = thisIdAdded || id.equals(thisId);        builder.put(id, data.getData());    }    if (!thisIdAdded) {                builder.put(thisId, pen.getData());    }    return builder.build();}
public String curator_f1996_0(String path)
{    return ZKPaths.getNodeFromPath(path);}
protected PersistentEphemeralNode curator_f1997_0(CuratorFramework client, String membershipPath, String thisId, byte[] payload)
{    return new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, ZKPaths.makePath(membershipPath, thisId), payload);}
protected PathChildrenCache curator_f1998_0(CuratorFramework client, String membershipPath)
{    return new PathChildrenCache(client, membershipPath, true);}
protected CreateMode curator_f1999_0(boolean pathIsSet)
{    return CreateMode.EPHEMERAL;}
protected boolean curator_f2000_0()
{    return false;}
protected CreateMode curator_f2001_0(boolean pathIsSet)
{    return pathIsSet ? CreateMode.EPHEMERAL : CreateMode.EPHEMERAL_SEQUENTIAL;}
protected boolean curator_f2002_0()
{    return false;}
protected CreateMode curator_f2003_0(boolean pathIsSet)
{    return CreateMode.EPHEMERAL;}
protected boolean curator_f2004_0()
{    return true;}
protected CreateMode curator_f2005_0(boolean pathIsSet)
{    return pathIsSet ? CreateMode.EPHEMERAL : CreateMode.EPHEMERAL_SEQUENTIAL;}
protected boolean curator_f2006_0()
{    return true;}
public void curator_f2007_0(WatchedEvent event) throws Exception
{    if (isActive()) {        if (event.getType() == EventType.NodeDeleted) {            createNode();        } else if (event.getType() == EventType.NodeDataChanged) {            watchNode();        }    }}
public void curator_f2008_1(CuratorFramework dummy, CuratorEvent event) throws Exception
{    if (isActive()) {        if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {            createNode();        } else {            boolean isEphemeral = event.getStat().getEphemeralOwner() != 0;            if (isEphemeral != mode.isEphemeral()) {                            }        }    } else {        client.removeWatchers();    }}
public void curator_f2009_1(CuratorFramework dummy, CuratorEvent event) throws Exception
{        if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                initialisationComplete();    } else if (event.getResultCode() == KeeperException.Code.NOAUTH.intValue()) {                authFailure.set(true);    }}
public void curator_f2010_0(CuratorFramework dummy, ConnectionState newState)
{    if ((newState == ConnectionState.RECONNECTED) && isActive()) {        createNode();    }}
public void curator_f2011_0(CuratorFramework dummy, CuratorEvent event) throws Exception
{    if (isActive()) {        processBackgroundCallback(event);    } else {        processBackgroundCallbackClosedState(event);    }}
private void curator_f2012_1(CuratorEvent event)
{    String path = null;    if (event.getResultCode() == KeeperException.Code.NODEEXISTS.intValue()) {        path = event.getPath();    } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        path = event.getName();    }    if (path != null) {        try {            client.delete().guaranteed().inBackground().forPath(path);        } catch (Exception e) {                    }    }}
private void curator_f2013_1(CuratorEvent event) throws Exception
{    String path = null;    boolean nodeExists = false;    if (event.getResultCode() == KeeperException.Code.NODEEXISTS.intValue()) {        path = event.getPath();        nodeExists = true;    } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        path = event.getName();    } else if (event.getResultCode() == KeeperException.Code.NOAUTH.intValue()) {                authFailure.set(true);        return;    }    if (path != null) {        authFailure.set(false);        nodePath.set(path);        watchNode();        if (nodeExists) {            client.setData().inBackground(setDataCallback).forPath(getActualPath(), getData());        } else {            initialisationComplete();            notifyListeners();        }    } else {        createNode();    }}
private void curator_f2014_0()
{    CountDownLatch localLatch = initialCreateLatch.getAndSet(null);    if (localLatch != null) {        localLatch.countDown();    }}
public void curator_f2015_0()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Already started");    client.getConnectionStateListenable().addListener(connectionStateListener);    createNode();}
public boolean curator_f2016_0(long timeout, TimeUnit unit) throws InterruptedException
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    CountDownLatch localLatch = initialCreateLatch.get();    return (localLatch == null) || localLatch.await(timeout, unit);}
public void curator_f2017_0() throws IOException
{    if (debugWaitMsForBackgroundBeforeClose.get() > 0) {        try {            Thread.sleep(debugWaitMsForBackgroundBeforeClose.get());        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    if (!state.compareAndSet(State.STARTED, State.CLOSED)) {        return;    }    client.getConnectionStateListenable().removeListener(connectionStateListener);    try {        deleteNode();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }    client.removeWatchers();}
public ListenerContainer<PersistentNodeListener> curator_f2018_0()
{    return listeners;}
public String curator_f2019_0()
{    return nodePath.get();}
public void curator_f2020_0(byte[] data) throws Exception
{    data = Preconditions.checkNotNull(data, "data cannot be null");    Preconditions.checkState(nodePath.get() != null, "initial create has not been processed. Call waitForInitialCreate() to ensure.");    this.data.set(Arrays.copyOf(data, data.length));    if (isActive()) {        client.setData().inBackground(setDataCallback).forPath(getActualPath(), getData());    }}
public byte[] curator_f2021_0()
{    return this.data.get();}
protected void curator_f2022_0() throws Exception
{    String localNodePath = nodePath.getAndSet(null);    if (localNodePath != null) {        try {            client.delete().guaranteed().forPath(localNodePath);        } catch (KeeperException.NoNodeException ignore) {                }    }}
private void curator_f2023_0()
{    if (!isActive()) {        return;    }    if (debugCreateNodeLatch != null) {        try {            debugCreateNodeLatch.await();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return;        }    }    try {        String existingPath = nodePath.get(), createPath;        if (existingPath != null && !useProtection) {            createPath = existingPath;        } else if (existingPath != null && mode.isSequential()) {            createPath = basePath + ZKPaths.extractSequentialSuffix(existingPath);        } else {            createPath = basePath;        }        CreateModable<ACLBackgroundPathAndBytesable<String>> localCreateMethod = createMethod.get();        if (localCreateMethod == null) {            CreateBuilderMain createBuilder = SafeIsTtlMode.isTtl(mode) ? client.create().withTtl(ttl) : client.create();            CreateModable<ACLBackgroundPathAndBytesable<String>> tempCreateMethod = useProtection ? createBuilder.creatingParentContainersIfNeeded().withProtection() : createBuilder.creatingParentContainersIfNeeded();            createMethod.compareAndSet(null, tempCreateMethod);            localCreateMethod = createMethod.get();        }        localCreateMethod.withMode(getCreateMode(existingPath != null)).inBackground(backgroundCallback).forPath(createPath, data.get());    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                throw new RuntimeException("Creating node. BasePath: " + basePath, e);    }}
private CreateMode curator_f2024_0(boolean pathIsSet)
{    if (pathIsSet) {        switch(mode) {            default:                {                    break;                }            case EPHEMERAL_SEQUENTIAL:                {                                        return CreateMode.EPHEMERAL;                }            case PERSISTENT_SEQUENTIAL:                {                                        return CreateMode.PERSISTENT;                }            case PERSISTENT_SEQUENTIAL_WITH_TTL:                {                                        return CreateMode.PERSISTENT_WITH_TTL;                }        }    }    return mode;}
private void curator_f2025_0() throws Exception
{    if (!isActive()) {        return;    }    String localNodePath = nodePath.get();    if (localNodePath != null) {        client.checkExists().usingWatcher(watcher).inBackground(checkExistsCallback).forPath(localNodePath);    }}
private void curator_f2026_1()
{    final String path = getActualPath();    listeners.forEach(new Function<PersistentNodeListener, Void>() {        @Override        public Void apply(PersistentNodeListener listener) {            try {                listener.nodeCreated(path);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }            return null;        }    });}
public Void curator_f2027_1(PersistentNodeListener listener)
{    try {        listener.nodeCreated(path);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
private boolean curator_f2028_0()
{    return (state.get() == State.STARTED);}
 boolean curator_f2029_0()
{    return authFailure.get();}
protected void curator_f2030_0()
{}
public void curator_f2031_1()
{    node.start();    Runnable touchTask = new Runnable() {        @Override        public void run() {            try {                try {                    client.setData().forPath(childPath);                } catch (KeeperException.NoNodeException e) {                    client.create().orSetData().withTtl(ttlMs).withMode(CreateMode.PERSISTENT_WITH_TTL).forPath(childPath);                }            } catch (KeeperException.NoNodeException ignore) {                        } catch (Exception e) {                if (!ThreadUtils.checkInterrupted(e)) {                                    }            }        }    };    Future<?> future = executorService.scheduleAtFixedRate(touchTask, ttlMs / touchScheduleFactor, ttlMs / touchScheduleFactor, TimeUnit.MILLISECONDS);    futureRef.set(future);}
public void curator_f2032_1()
{    try {        try {            client.setData().forPath(childPath);        } catch (KeeperException.NoNodeException e) {            client.create().orSetData().withTtl(ttlMs).withMode(CreateMode.PERSISTENT_WITH_TTL).forPath(childPath);        }    } catch (KeeperException.NoNodeException ignore) {        } catch (Exception e) {        if (!ThreadUtils.checkInterrupted(e)) {                    }    }}
public boolean curator_f2033_0(long timeout, TimeUnit unit) throws InterruptedException
{    return node.waitForInitialCreate(timeout, unit);}
public void curator_f2034_0(byte[] data) throws Exception
{    node.setData(data);}
public byte[] curator_f2035_0()
{    return node.getData();}
public void curator_f2036_0()
{    Future<?> future = futureRef.getAndSet(null);    if (future != null) {        future.cancel(true);    }    try {        node.close();    } catch (IOException e) {        throw new RuntimeException(e);    }}
public void curator_f2037_0(T message) throws Exception
{    items.add(message);}
public List<T> curator_f2038_0()
{    return ImmutableList.copyOf(items);}
public int curator_f2039_0()
{    return items.size();}
public T curator_f2040_0() throws InterruptedException
{    return items.take();}
public T curator_f2041_0(int time, TimeUnit unit) throws InterruptedException
{    return items.poll(time, unit);}
public int curator_f2042_0(Collection<? super T> c)
{    return items.drainTo(c);}
public void curator_f2043_0(CuratorFramework client, ConnectionState newState)
{    connectionStateListener.stateChanged(client, newState);}
public void curator_f2044_0(WatchedEvent event) throws Exception
{    if (!isClosed.get()) {        sync(true);    }}
public void curator_f2045_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        setNewChildren(event.getChildren());    }}
 void curator_f2046_0() throws Exception
{    sync(true);}
public void curator_f2047_0() throws IOException
{    client.removeWatchers();    isClosed.set(true);    notifyFromCallback();}
 Data curator_f2048_0()
{    return children.get();}
 Data curator_f2049_0(long startVersion) throws InterruptedException
{    return blockingNextGetData(startVersion, 0, null);}
 synchronized Data curator_f2050_0(long startVersion, long maxWait, TimeUnit unit) throws InterruptedException
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? unit.toMillis(maxWait) : -1;    while (startVersion == children.get().version) {        if (hasMaxWait) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsedMs;            if (thisWaitMs <= 0) {                break;            }            wait(thisWaitMs);        } else {            wait();        }    }    return children.get();}
private synchronized void curator_f2051_0()
{    notifyAll();}
private synchronized void curator_f2052_0(boolean watched) throws Exception
{    if (watched) {        client.getChildren().usingWatcher(watcher).inBackground(callback).forPath(path);    } else {        client.getChildren().inBackground(callback).forPath(path);    }}
private synchronized void curator_f2053_0(List<String> newChildren)
{    if (newChildren != null) {        Data currentData = children.get();        children.set(new Data(newChildren, currentData.version + 1));        notifyFromCallback();    }}
protected long curator_f2054_0(String itemNode)
{    return getDelay(itemNode, System.currentTimeMillis());}
private long curator_f2055_0(String itemNode, long sortTime)
{    long epoch = getEpoch(itemNode);    return epoch - sortTime;}
protected void curator_f2056_0(List<String> children)
{    final long sortTime = System.currentTimeMillis();    Collections.sort(children, new Comparator<String>() {        @Override        public int compare(String o1, String o2) {            long diff = getDelay(o1, sortTime) - getDelay(o2, sortTime);            return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);        }    });}
public int curator_f2057_0(String o1, String o2)
{    long diff = getDelay(o1, sortTime) - getDelay(o2, sortTime);    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
public void curator_f2058_0() throws Exception
{    queue.start();}
public void curator_f2059_0() throws IOException
{    queue.close();}
public void curator_f2060_0(T item, long delayUntilEpoch) throws Exception
{    put(item, delayUntilEpoch, 0, null);}
public boolean curator_f2061_0(T item, long delayUntilEpoch, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(delayUntilEpoch > 0, "delayUntilEpoch cannot be negative");    queue.checkState();    return queue.internalPut(item, null, queue.makeItemPath() + epochToString(delayUntilEpoch), maxWait, unit);}
public void curator_f2062_0(MultiItem<T> items, long delayUntilEpoch) throws Exception
{    putMulti(items, delayUntilEpoch, 0, null);}
public boolean curator_f2063_0(MultiItem<T> items, long delayUntilEpoch, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(delayUntilEpoch > 0, "delayUntilEpoch cannot be negative");    queue.checkState();    return queue.internalPut(null, items, queue.makeItemPath() + epochToString(delayUntilEpoch), maxWait, unit);}
public void curator_f2064_0(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
public boolean curator_f2065_0(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
public ListenerContainer<QueuePutListener<T>> curator_f2066_0()
{    return queue.getPutListenerContainer();}
public int curator_f2067_0()
{    return queue.getLastMessageCount();}
 static String curator_f2068_0(long epoch)
{    return SEPARATOR + String.format("%08X", epoch) + SEPARATOR;}
private static long curator_f2069_0(String itemNode)
{    int index2 = itemNode.lastIndexOf(SEPARATOR);    int index1 = (index2 > 0) ? itemNode.lastIndexOf(SEPARATOR, index2 - 1) : -1;    if ((index1 > 0) && (index2 > (index1 + 1))) {        try {            String epochStr = itemNode.substring(index1 + 1, index2);            return Long.parseLong(epochStr, 16);        } catch (NumberFormatException ignore) {                }    }    return 0;}
protected void curator_f2070_0(List<String> children)
{    internalSortChildren(children);}
protected String curator_f2071_0(String itemPath)
{    return makeIdPath(parseId(itemPath).id);}
public void curator_f2072_0() throws Exception
{    queue.start();}
public void curator_f2073_0() throws IOException
{    queue.close();}
public ListenerContainer<QueuePutListener<T>> curator_f2074_0()
{    return queue.getPutListenerContainer();}
public void curator_f2075_0(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
public boolean curator_f2076_0(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
public int curator_f2077_0()
{    return queue.getLastMessageCount();}
public void curator_f2078_0(T item, String itemId) throws Exception
{    put(item, itemId, 0, null);}
public boolean curator_f2079_0(T item, String itemId, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(isValidId(itemId), "Invalid id: " + itemId);    queue.checkState();    return queue.internalPut(item, null, makeIdPath(itemId), maxWait, unit);}
public int curator_f2080_0(String id) throws Exception
{    id = Preconditions.checkNotNull(id, "id cannot be null");    queue.checkState();    int count = 0;    for (String name : queue.getChildren()) {        if (parseId(name).id.equals(id)) {            if (queue.tryRemove(name)) {                ++count;            }        }    }    return count;}
 boolean curator_f2081_0(String id) throws Exception
{    for (String name : queue.getChildren()) {        if (parseId(name).id.equals(id)) {            return true;        }    }    return false;}
private String curator_f2082_0(String itemId)
{    return queue.makeItemPath() + SEPARATOR + fixId(itemId) + SEPARATOR;}
private void curator_f2083_0(List<String> children)
{    Collections.sort(children, new Comparator<String>() {        @Override        public int compare(String o1, String o2) {            return parseId(o1).cleaned.compareTo(parseId(o2).cleaned);        }    });}
public int curator_f2084_0(String o1, String o2)
{    return parseId(o1).cleaned.compareTo(parseId(o2).cleaned);}
private boolean curator_f2085_0(String id)
{    return (id != null) && (id.length() > 0);}
private static String curator_f2086_0(String id)
{    String fixed = id.replace('/', '_');    return fixed.replace(SEPARATOR, '_');}
private Parts curator_f2087_1(String name)
{    int firstIndex = name.indexOf(SEPARATOR);    int secondIndex = name.indexOf(SEPARATOR, firstIndex + 1);    if ((firstIndex < 0) || (secondIndex < 0)) {                return new Parts(name, name);    }    return new Parts(name.substring(firstIndex + 1, secondIndex), name.substring(0, firstIndex) + name.substring(secondIndex + 1));}
public void curator_f2088_0() throws Exception
{    queue.start();}
public void curator_f2089_0() throws IOException
{    queue.close();}
public void curator_f2090_0(T item, int priority) throws Exception
{    put(item, priority, 0, null);}
public boolean curator_f2091_0(T item, int priority, int maxWait, TimeUnit unit) throws Exception
{    queue.checkState();    String priorityHex = priorityToString(priority);    return queue.internalPut(item, null, queue.makeItemPath() + priorityHex, maxWait, unit);}
public void curator_f2092_0(MultiItem<T> items, int priority) throws Exception
{    putMulti(items, priority, 0, null);}
public boolean curator_f2093_0(MultiItem<T> items, int priority, int maxWait, TimeUnit unit) throws Exception
{    queue.checkState();    String priorityHex = priorityToString(priority);    return queue.internalPut(null, items, queue.makeItemPath() + priorityHex, maxWait, unit);}
public void curator_f2094_0(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
public boolean curator_f2095_0(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
public ListenerContainer<QueuePutListener<T>> curator_f2096_0()
{    return queue.getPutListenerContainer();}
public int curator_f2097_0()
{    return queue.getLastMessageCount();}
 ChildrenCache curator_f2098_0()
{    return queue.getCache();}
 static String curator_f2099_0(int priority)
{            long l = (long) priority & 0xFFFFFFFFL;    return String.format("%s%08X", (priority >= 0) ? "1" : "0", l);}
public void curator_f2100_0() throws Exception
{    if (!state.compareAndSet(State.LATENT, State.STARTED)) {        throw new IllegalStateException();    }    try {        client.create().creatingParentContainersIfNeeded().forPath(queuePath);    } catch (KeeperException.NodeExistsException ignore) {        }    if (lockPath != null) {        try {            client.create().creatingParentContainersIfNeeded().forPath(lockPath);        } catch (KeeperException.NodeExistsException ignore) {                }    }    if (!isProducerOnly || (maxItems != QueueBuilder.NOT_SET)) {        childrenCache.start();    }    if (!isProducerOnly) {        service.submit(new Callable<Object>() {            @Override            public Object call() {                runLoop();                return null;            }        });    }}
public Object curator_f2101_0()
{    runLoop();    return null;}
public void curator_f2102_0() throws IOException
{    if (state.compareAndSet(State.STARTED, State.STOPPED)) {        if (finalFlushMs > 0) {            try {                flushPuts(finalFlushMs, TimeUnit.MILLISECONDS);            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        }        CloseableUtils.closeQuietly(childrenCache);        putListenerContainer.clear();        service.shutdownNow();    }}
public ListenerContainer<QueuePutListener<T>> curator_f2103_0()
{    return putListenerContainer;}
public void curator_f2104_1(ErrorMode newErrorMode)
{    Preconditions.checkNotNull(lockPath, "lockPath cannot be null");    if (newErrorMode == ErrorMode.REQUEUE) {            }    errorMode.set(newErrorMode);}
public boolean curator_f2105_0(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    long msWaitRemaining = TimeUnit.MILLISECONDS.convert(waitTime, timeUnit);    synchronized (putCount) {        while (putCount.get() > 0) {            if (msWaitRemaining <= 0) {                return false;            }            long startMs = System.currentTimeMillis();            putCount.wait(msWaitRemaining);            long elapsedMs = System.currentTimeMillis() - startMs;            msWaitRemaining -= elapsedMs;        }    }    return true;}
public void curator_f2106_0(T item) throws Exception
{    put(item, 0, null);}
public boolean curator_f2107_0(T item, int maxWait, TimeUnit unit) throws Exception
{    checkState();    String path = makeItemPath();    return internalPut(item, null, path, maxWait, unit);}
public void curator_f2108_0(MultiItem<T> items) throws Exception
{    putMulti(items, 0, null);}
public boolean curator_f2109_0(MultiItem<T> items, int maxWait, TimeUnit unit) throws Exception
{    checkState();    String path = makeItemPath();    return internalPut(null, items, path, maxWait, unit);}
public int curator_f2110_0()
{    return lastChildCount.get();}
 boolean curator_f2111_0(final T item, MultiItem<T> multiItem, String path, int maxWait, TimeUnit unit) throws Exception
{    if (!blockIfMaxed(maxWait, unit)) {        return false;    }    final MultiItem<T> givenMultiItem = multiItem;    if (item != null) {        final AtomicReference<T> ref = new AtomicReference<T>(item);        multiItem = new MultiItem<T>() {            @Override            public T nextItem() throws Exception {                return ref.getAndSet(null);            }        };    }    putCount.incrementAndGet();    byte[] bytes = ItemSerializer.serialize(multiItem, serializer);    if (putInBackground) {        doPutInBackground(item, path, givenMultiItem, bytes);    } else {        doPutInForeground(item, path, givenMultiItem, bytes);    }    return true;}
public T curator_f2112_0() throws Exception
{    return ref.getAndSet(null);}
private void curator_f2113_0(final T item, String path, final MultiItem<T> givenMultiItem, byte[] bytes) throws Exception
{    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(path, bytes);    synchronized (putCount) {        putCount.decrementAndGet();        putCount.notifyAll();    }    putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {        @Override        public Void apply(QueuePutListener<T> listener) {            if (item != null) {                listener.putCompleted(item);            } else {                listener.putMultiCompleted(givenMultiItem);            }            return null;        }    });}
public Void curator_f2114_0(QueuePutListener<T> listener)
{    if (item != null) {        listener.putCompleted(item);    } else {        listener.putMultiCompleted(givenMultiItem);    }    return null;}
private void curator_f2115_0(final T item, String path, final MultiItem<T> givenMultiItem, byte[] bytes) throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (event.getResultCode() != KeeperException.Code.OK.intValue()) {                return;            }            if (event.getType() == CuratorEventType.CREATE) {                synchronized (putCount) {                    putCount.decrementAndGet();                    putCount.notifyAll();                }            }            putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {                @Override                public Void apply(QueuePutListener<T> listener) {                    if (item != null) {                        listener.putCompleted(item);                    } else {                        listener.putMultiCompleted(givenMultiItem);                    }                    return null;                }            });        }    };    internalCreateNode(path, bytes, callback);}
public void curator_f2116_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() != KeeperException.Code.OK.intValue()) {        return;    }    if (event.getType() == CuratorEventType.CREATE) {        synchronized (putCount) {            putCount.decrementAndGet();            putCount.notifyAll();        }    }    putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {        @Override        public Void apply(QueuePutListener<T> listener) {            if (item != null) {                listener.putCompleted(item);            } else {                listener.putMultiCompleted(givenMultiItem);            }            return null;        }    });}
public Void curator_f2117_0(QueuePutListener<T> listener)
{    if (item != null) {        listener.putCompleted(item);    } else {        listener.putMultiCompleted(givenMultiItem);    }    return null;}
 void curator_f2118_0(String path, byte[] bytes, BackgroundCallback callback) throws Exception
{    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);}
 void curator_f2119_0() throws Exception
{    if (state.get() != State.STARTED) {        throw new IllegalStateException();    }}
 String curator_f2120_0()
{    return ZKPaths.makePath(queuePath, QUEUE_ITEM_NAME);}
 ChildrenCache curator_f2121_0()
{    return childrenCache;}
protected void curator_f2122_0(List<String> children)
{    Collections.sort(children);}
protected List<String> curator_f2123_0() throws Exception
{    return client.getChildren().forPath(queuePath);}
protected long curator_f2124_0(String itemNode)
{    return 0;}
protected boolean curator_f2125_0(String itemNode) throws Exception
{    boolean isUsingLockSafety = (lockPath != null);    if (isUsingLockSafety) {        return processWithLockSafety(itemNode, ProcessType.REMOVE);    }    return processNormally(itemNode, ProcessType.REMOVE);}
private boolean curator_f2126_0(int maxWait, TimeUnit unit) throws Exception
{    ChildrenCache.Data data = childrenCache.getData();    while (data.children.size() >= maxItems) {        long previousVersion = data.version;        data = childrenCache.blockingNextGetData(data.version, maxWait, unit);        if (data.version == previousVersion) {            return false;        }    }    return true;}
private void curator_f2127_1()
{    long currentVersion = -1;    long maxWaitMs = -1;    try {        while (state.get() == State.STARTED) {            try {                ChildrenCache.Data data = (maxWaitMs > 0) ? childrenCache.blockingNextGetData(currentVersion, maxWaitMs, TimeUnit.MILLISECONDS) : childrenCache.blockingNextGetData(currentVersion);                currentVersion = data.version;                List<String> children = Lists.newArrayList(data.children);                                sortChildren(children);                if (children.size() > 0) {                    maxWaitMs = getDelay(children.get(0));                    if (maxWaitMs > 0) {                        continue;                    }                } else {                    continue;                }                processChildren(children, currentVersion);            } catch (InterruptedException e) {                                                }        }    } catch (Exception e) {            }}
private void curator_f2128_1(List<String> children, long currentVersion) throws Exception
{    final Semaphore processedLatch = new Semaphore(0);    final boolean isUsingLockSafety = (lockPath != null);    int min = minItemsBeforeRefresh;    for (final String itemNode : children) {        if (Thread.currentThread().isInterrupted()) {            processedLatch.release(children.size());            break;        }        if (!itemNode.startsWith(QUEUE_ITEM_NAME)) {                        processedLatch.release();            continue;        }        if (min-- <= 0) {            if (refreshOnWatch && (currentVersion != childrenCache.getData().version)) {                processedLatch.release(children.size());                break;            }        }        if (getDelay(itemNode) > 0) {            processedLatch.release();            continue;        }        executor.execute(new Runnable() {            @Override            public void run() {                try {                    if (isUsingLockSafety) {                        processWithLockSafety(itemNode, ProcessType.NORMAL);                    } else {                        processNormally(itemNode, ProcessType.NORMAL);                    }                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                                    } finally {                    processedLatch.release();                }            }        });    }    processedLatch.acquire(children.size());}
public void curator_f2129_1()
{    try {        if (isUsingLockSafety) {            processWithLockSafety(itemNode, ProcessType.NORMAL);        } else {            processNormally(itemNode, ProcessType.NORMAL);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            } finally {        processedLatch.release();    }}
private ProcessMessageBytesCode curator_f2130_1(String itemNode, byte[] bytes) throws Exception
{    ProcessMessageBytesCode resultCode = ProcessMessageBytesCode.NORMAL;    MultiItem<T> items;    try {        items = ItemSerializer.deserialize(bytes, serializer);    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);                return resultCode;    }    for (; ; ) {        T item = items.nextItem();        if (item == null) {            break;        }        try {            consumer.consumeMessage(item);        } catch (Throwable e) {            ThreadUtils.checkInterrupted(e);                        if (errorMode.get() == ErrorMode.REQUEUE) {                resultCode = ProcessMessageBytesCode.REQUEUE;                break;            }        }    }    return resultCode;}
private boolean curator_f2131_0(String itemNode, ProcessType type) throws Exception
{    try {        String itemPath = ZKPaths.makePath(queuePath, itemNode);        Stat stat = new Stat();        byte[] bytes = null;        if (type == ProcessType.NORMAL) {            bytes = client.getData().storingStatIn(stat).forPath(itemPath);        }        if (client.getState() == CuratorFrameworkState.STARTED) {            client.delete().withVersion(stat.getVersion()).forPath(itemPath);        }        if (type == ProcessType.NORMAL) {            processMessageBytes(itemNode, bytes);        }        return true;    } catch (KeeperException.NodeExistsException ignore) {        } catch (KeeperException.NoNodeException ignore) {        } catch (KeeperException.BadVersionException ignore) {        }    return false;}
protected boolean curator_f2132_0(String itemNode, ProcessType type) throws Exception
{    String lockNodePath = ZKPaths.makePath(lockPath, itemNode);    boolean lockCreated = false;    try {        client.create().withMode(CreateMode.EPHEMERAL).forPath(lockNodePath);        lockCreated = true;        String itemPath = ZKPaths.makePath(queuePath, itemNode);        boolean requeue = false;        byte[] bytes = null;        if (type == ProcessType.NORMAL) {            bytes = client.getData().forPath(itemPath);            requeue = (processMessageBytes(itemNode, bytes) == ProcessMessageBytesCode.REQUEUE);        }        if (requeue) {            client.inTransaction().delete().forPath(itemPath).and().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(makeRequeueItemPath(itemPath), bytes).and().commit();        } else {            client.delete().forPath(itemPath);        }        return true;    } catch (KeeperException.NodeExistsException ignore) {        } catch (KeeperException.NoNodeException ignore) {        } catch (KeeperException.BadVersionException ignore) {        } finally {        if (lockCreated) {            client.delete().guaranteed().forPath(lockNodePath);        }    }    return false;}
protected String curator_f2133_0(String itemPath)
{    return makeItemPath();}
 static MultiItem<T> curator_f2134_0(byte[] bytes, QueueSerializer<T> serializer) throws Exception
{    DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));    int version = in.readInt();    if (version != VERSION) {        throw new IOException(String.format("Incorrect version. Expected %d - Found: %d", VERSION, version));    }    List<T> items = Lists.newArrayList();    for (; ; ) {        byte opcode = in.readByte();        if (opcode == EOF_OPCODE) {            break;        }        if (opcode != ITEM_OPCODE) {            throw new IOException(String.format("Incorrect opcode. Expected %d - Found: %d", ITEM_OPCODE, opcode));        }        int size = in.readInt();        if (size < 0) {            throw new IOException(String.format("Bad size: %d", size));        }        byte[] itemBytes = new byte[size];        if (size > 0) {            in.readFully(itemBytes);        }        items.add(serializer.deserialize(itemBytes));    }    final Iterator<T> iterator = items.iterator();    return new MultiItem<T>() {        @Override        public T nextItem() {            return iterator.hasNext() ? iterator.next() : null;        }    };}
public T curator_f2135_0()
{    return iterator.hasNext() ? iterator.next() : null;}
 static byte[] curator_f2136_0(MultiItem<T> items, QueueSerializer<T> serializer) throws Exception
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);    DataOutputStream out = new DataOutputStream(bytes);    out.writeInt(VERSION);    for (; ; ) {        T item = items.nextItem();        if (item == null) {            break;        }        byte[] itemBytes = serializer.serialize(item);        out.writeByte(ITEM_OPCODE);        out.writeInt(itemBytes.length);        if (itemBytes.length > 0) {            out.write(itemBytes);        }    }    out.writeByte(EOF_OPCODE);    out.close();    return bytes.toByteArray();}
public static QueueBuilder<T> curator_f2137_0(CuratorFramework client, QueueConsumer<T> consumer, QueueSerializer<T> serializer, String queuePath)
{    return new QueueBuilder<T>(client, consumer, serializer, queuePath);}
public DistributedQueue<T> curator_f2138_0()
{    return new DistributedQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, false, lockPath, maxItems, putInBackground, finalFlushMs);}
public DistributedIdQueue<T> curator_f2139_0()
{    return new DistributedIdQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, false, lockPath, maxItems, putInBackground, finalFlushMs);}
public DistributedPriorityQueue<T> curator_f2140_0(int minItemsBeforeRefresh)
{    return new DistributedPriorityQueue<T>(client, consumer, serializer, queuePath, factory, executor, minItemsBeforeRefresh, lockPath, maxItems, putInBackground, finalFlushMs);}
public DistributedDelayQueue<T> curator_f2141_0()
{    return new DistributedDelayQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, lockPath, maxItems, putInBackground, finalFlushMs);}
public QueueBuilder<T> curator_f2142_0(ThreadFactory factory)
{    Preconditions.checkNotNull(factory, "factory cannot be null");    this.factory = factory;    return this;}
public QueueBuilder<T> curator_f2143_0(Executor executor)
{    Preconditions.checkNotNull(executor, "executor cannot be null");    this.executor = executor;    return this;}
public QueueBuilder<T> curator_f2144_0(String path)
{    lockPath = PathUtils.validatePath(path);    return this;}
public QueueBuilder<T> curator_f2145_0(int maxItems)
{    this.maxItems = maxItems;    putInBackground = false;    return this;}
public QueueBuilder<T> curator_f2146_0(boolean putInBackground)
{    this.putInBackground = putInBackground;    return this;}
public QueueBuilder<T> curator_f2147_0(int time, TimeUnit unit)
{    finalFlushMs = (int) unit.toMillis(time);    return this;}
 String curator_f2148_0()
{    return lockPath;}
 QueueConsumer<T> curator_f2149_0()
{    return consumer;}
 BlockingQueue<T> curator_f2150_0()
{    return queue;}
public void curator_f2151_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.createContainers(queuePath);    getInitialQueues();    leaderLatch.start();    service.submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            while (state.get() == State.STARTED) {                try {                    Thread.sleep(policies.getThresholdCheckMs());                    checkThreshold();                } catch (InterruptedException e) {                                                                }            }            return null;        }    });}
public Void curator_f2152_0() throws Exception
{    while (state.get() == State.STARTED) {        try {            Thread.sleep(policies.getThresholdCheckMs());            checkThreshold();        } catch (InterruptedException e) {                                }    }    return null;}
public void curator_f2153_1()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        service.shutdownNow();        CloseableUtils.closeQuietly(leaderLatch);        for (T queue : queues.values()) {            try {                queue.close();            } catch (IOException e) {                            }        }    }}
public T curator_f2154_0()
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    List<String> localPreferredQueues = Lists.newArrayList(preferredQueues);    if (localPreferredQueues.size() > 0) {        String key = localPreferredQueues.get(random.nextInt(localPreferredQueues.size()));        return queues.get(key);    }    List<String> keys = Lists.newArrayList(queues.keySet());    String key = keys.get(random.nextInt(keys.size()));    return queues.get(key);}
public int curator_f2155_0()
{    return queues.size();}
public Collection<String> curator_f2156_0()
{    return ImmutableSet.copyOf(queues.keySet());}
private void curator_f2157_0() throws Exception
{    List<String> children = client.getChildren().forPath(queuePath);    for (String child : children) {        String queuePath = ZKPaths.makePath(this.queuePath, child);        addNewQueueIfNeeded(queuePath);    }    if (children.size() == 0) {        addNewQueueIfNeeded(null);    }}
private void curator_f2158_0(String newQueuePath) throws Exception
{    if (newQueuePath == null) {        newQueuePath = ZKPaths.makePath(queuePath, QUEUE_PREFIX + UUID.randomUUID().toString());    }    if (!queues.containsKey(newQueuePath)) {        T queue = queueAllocator.allocateQueue(client, newQueuePath);        if (queues.putIfAbsent(newQueuePath, queue) == null) {            queue.start();            preferredQueues.add(newQueuePath);        }    }}
private void curator_f2159_1()
{    try {        boolean addAQueueIfLeader = false;        int size = 0;        List<String> children = client.getChildren().forPath(queuePath);        for (String child : children) {            String queuePath = ZKPaths.makePath(this.queuePath, child);            addNewQueueIfNeeded(queuePath);            Stat stat = client.checkExists().forPath(queuePath);            if (stat.getNumChildren() >= policies.getNewQueueThreshold()) {                size = stat.getNumChildren();                addAQueueIfLeader = true;                preferredQueues.remove(queuePath);            } else if (stat.getNumChildren() <= (policies.getNewQueueThreshold() / 2)) {                preferredQueues.add(queuePath);            }        }        if (addAQueueIfLeader && leaderLatch.hasLeadership()) {            if (queues.size() < policies.getMaxQueues()) {                                addNewQueueIfNeeded(null);            } else {                            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }}
public Builder curator_f2160_0(int newQueueThreshold)
{    Preconditions.checkArgument(newQueueThreshold > 0, "newQueueThreshold must be a positive number");    policies.newQueueThreshold = newQueueThreshold;    return this;}
public Builder curator_f2161_0(int thresholdCheckMs)
{    Preconditions.checkArgument(thresholdCheckMs > 0, "thresholdCheckMs must be a positive number");    policies.thresholdCheckMs = thresholdCheckMs;    return this;}
public Builder curator_f2162_0(int maxQueues)
{    Preconditions.checkArgument(maxQueues > 0, "thresholdCheckMs must be a positive number");    policies.maxQueues = maxQueues;    return this;}
public Builder curator_f2163_0(ThreadFactory threadFactory)
{    policies.threadFactory = Preconditions.checkNotNull(threadFactory, "threadFactory cannot be null");    return this;}
public QueueSharderPolicies curator_f2164_0()
{    try {        return policies;    } finally {        policies = new QueueSharderPolicies();    }}
public static Builder curator_f2165_0()
{    return new Builder();}
 int curator_f2166_0()
{    return newQueueThreshold;}
 int curator_f2167_0()
{    return thresholdCheckMs;}
 int curator_f2168_0()
{    return maxQueues;}
 ThreadFactory curator_f2169_0()
{    return threadFactory;}
public byte[] curator_f2170_0() throws Exception
{    byte[] bytes = internalElement(false, null);    if (bytes == null) {        throw new NoSuchElementException();    }    return bytes;}
public byte[] curator_f2171_0() throws Exception
{    byte[] bytes = internalElement(true, null);    if (bytes == null) {        throw new NoSuchElementException();    }    return bytes;}
public byte[] curator_f2172_0() throws Exception
{    return internalPoll(0, null);}
public boolean curator_f2173_0(byte[] data) throws Exception
{    String thisPath = ZKPaths.makePath(path, PREFIX);    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(thisPath, data);    return true;}
public byte[] curator_f2174_0() throws Exception
{    try {        return element();    } catch (NoSuchElementException e) {        return null;    }}
public byte[] curator_f2175_0(long timeout, TimeUnit unit) throws Exception
{    return internalPoll(timeout, unit);}
public byte[] curator_f2176_0() throws Exception
{    try {        return remove();    } catch (NoSuchElementException e) {        return null;    }}
protected void curator_f2177_0() throws Exception
{    ensureContainers.ensure();}
private byte[] curator_f2178_1(long timeout, TimeUnit unit) throws Exception
{    ensurePath();    long startMs = System.currentTimeMillis();    boolean hasTimeout = (unit != null);    long maxWaitMs = hasTimeout ? TimeUnit.MILLISECONDS.convert(timeout, unit) : Long.MAX_VALUE;    for (; ; ) {        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        byte[] bytes;        try {            bytes = internalElement(true, watcher);        } catch (NoSuchElementException dummy) {                        ensureContainers.reset();            continue;        }        if (bytes != null) {            return bytes;        }        if (hasTimeout) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsedMs;            if (thisWaitMs <= 0) {                return null;            }            latch.await(thisWaitMs, TimeUnit.MILLISECONDS);        } else {            latch.await();        }    }}
public void curator_f2179_0(WatchedEvent event)
{    latch.countDown();}
private byte[] curator_f2180_1(boolean removeIt, Watcher watcher) throws Exception
{    ensurePath();    List<String> nodes;    try {        nodes = (watcher != null) ? client.getChildren().usingWatcher(watcher).forPath(path) : client.getChildren().forPath(path);    } catch (KeeperException.NoNodeException dummy) {        throw new NoSuchElementException();    }    Collections.sort(nodes);    for (String node : nodes) {        if (!node.startsWith(PREFIX)) {                        continue;        }        String thisPath = ZKPaths.makePath(path, node);        try {            byte[] bytes = client.getData().forPath(thisPath);            if (removeIt) {                client.delete().forPath(thisPath);            }            return bytes;        } catch (KeeperException.NoNodeException ignore) {                }    }    return null;}
public int curator_f2181_0()
{    return fromBytes(sharedValue.getValue());}
public VersionedValue<Integer> curator_f2182_0()
{    VersionedValue<byte[]> localValue = sharedValue.getVersionedValue();    return new VersionedValue<Integer>(localValue.getVersion(), fromBytes(localValue.getValue()));}
public void curator_f2183_0(int newCount) throws Exception
{    sharedValue.setValue(toBytes(newCount));}
public boolean curator_f2184_0(int newCount) throws Exception
{    return sharedValue.trySetValue(toBytes(newCount));}
public boolean curator_f2185_0(VersionedValue<Integer> previous, int newCount) throws Exception
{    VersionedValue<byte[]> previousCopy = new VersionedValue<byte[]>(previous.getVersion(), toBytes(previous.getValue()));    return sharedValue.trySetValue(previousCopy, toBytes(newCount));}
public void curator_f2186_0(SharedCountListener listener)
{    addListener(listener, MoreExecutors.directExecutor());}
public void curator_f2187_0(final SharedCountListener listener, Executor executor)
{    SharedValueListener valueListener = new SharedValueListener() {        @Override        public void valueHasChanged(SharedValueReader sharedValue, byte[] newValue) throws Exception {            listener.countHasChanged(SharedCount.this, fromBytes(newValue));        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            listener.stateChanged(client, newState);        }    };    sharedValue.getListenable().addListener(valueListener, executor);    listeners.put(listener, valueListener);}
public void curator_f2188_0(SharedValueReader sharedValue, byte[] newValue) throws Exception
{    listener.countHasChanged(SharedCount.this, fromBytes(newValue));}
public void curator_f2189_0(CuratorFramework client, ConnectionState newState)
{    listener.stateChanged(client, newState);}
public void curator_f2190_0(SharedCountListener listener)
{    SharedValueListener valueListener = listeners.remove(listener);    if (valueListener != null) {        sharedValue.getListenable().removeListener(valueListener);    }}
public void curator_f2191_0() throws Exception
{    sharedValue.start();}
public void curator_f2192_0() throws IOException
{    sharedValue.close();}
 static byte[] curator_f2193_0(int value)
{    byte[] bytes = new byte[4];    ByteBuffer.wrap(bytes).putInt(value);    return bytes;}
private static int curator_f2194_0(byte[] bytes)
{    return ByteBuffer.wrap(bytes).getInt();}
public void curator_f2195_0(WatchedEvent event) throws Exception
{    if (state.get() == State.STARTED && event.getType() != Watcher.Event.EventType.None) {                readValueAndNotifyListenersInBackground();    }}
public void curator_f2196_1(CuratorFramework client, ConnectionState newState)
{    notifyListenerOfStateChanged(newState);    if (newState.isConnected()) {        try {            readValueAndNotifyListenersInBackground();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);                    }    }}
public byte[] curator_f2197_0()
{    VersionedValue<byte[]> localCopy = currentValue.get();    return Arrays.copyOf(localCopy.getValue(), localCopy.getValue().length);}
public VersionedValue<byte[]> curator_f2198_0()
{    VersionedValue<byte[]> localCopy = currentValue.get();    return new VersionedValue<byte[]>(localCopy.getVersion(), Arrays.copyOf(localCopy.getValue(), localCopy.getValue().length));}
public void curator_f2199_0(byte[] newValue) throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "not started");    Stat result = client.setData().forPath(path, newValue);    updateValue(result.getVersion(), Arrays.copyOf(newValue, newValue.length));}
public boolean curator_f2200_0(byte[] newValue) throws Exception
{    return trySetValue(currentValue.get(), newValue);}
public boolean curator_f2201_0(VersionedValue<byte[]> previous, byte[] newValue) throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "not started");    VersionedValue<byte[]> current = currentValue.get();    if (previous.getVersion() != current.getVersion() || !Arrays.equals(previous.getValue(), current.getValue())) {        return false;    }    try {        Stat result = client.setData().withVersion(previous.getVersion()).forPath(path, newValue);        updateValue(result.getVersion(), Arrays.copyOf(newValue, newValue.length));        return true;    } catch (KeeperException.BadVersionException ignore) {        }    readValue();    return false;}
private void curator_f2202_0(int version, byte[] bytes)
{    while (true) {        VersionedValue<byte[]> current = currentValue.get();        if (current.getVersion() >= version) {                        return;        }        if (currentValue.compareAndSet(current, new VersionedValue<byte[]>(version, bytes))) {                        return;        }        }}
public ListenerContainer<SharedValueListener> curator_f2203_0()
{    return listeners;}
public void curator_f2204_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    try {        client.create().creatingParentContainersIfNeeded().forPath(path, seedValue);    } catch (KeeperException.NodeExistsException ignore) {        }    readValue();}
public void curator_f2205_0() throws IOException
{    state.set(State.CLOSED);    client.removeWatchers();    client.getConnectionStateListenable().removeListener(connectionStateListener);    listeners.clear();}
private void curator_f2206_0() throws Exception
{    Stat localStat = new Stat();    byte[] bytes = client.getData().storingStatIn(localStat).usingWatcher(watcher).forPath(path);    updateValue(localStat.getVersion(), bytes);}
public void curator_f2207_0(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        updateValue(event.getStat().getVersion(), event.getData());        notifyListeners();    }}
private void curator_f2208_0() throws Exception
{    client.getData().usingWatcher(watcher).inBackground(upadateAndNotifyListenerCallback).forPath(path);}
private void curator_f2209_1()
{    final byte[] localValue = getValue();    listeners.forEach(new Function<SharedValueListener, Void>() {        @Override        public Void apply(SharedValueListener listener) {            try {                listener.valueHasChanged(SharedValue.this, localValue);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                            }            return null;        }    });}
public Void curator_f2210_1(SharedValueListener listener)
{    try {        listener.valueHasChanged(SharedValue.this, localValue);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }    return null;}
private void curator_f2211_0(final ConnectionState newState)
{    listeners.forEach(new Function<SharedValueListener, Void>() {        @Override        public Void apply(SharedValueListener listener) {            listener.stateChanged(client, newState);            return null;        }    });}
public Void curator_f2212_0(SharedValueListener listener)
{    listener.stateChanged(client, newState);    return null;}
public int curator_f2213_0()
{    return version;}
public T curator_f2214_0()
{    return value;}
public void curator_f2215_0() throws Exception
{    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final AtomicReference<ConnectionState> lastState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                lastState.set(newState);                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server = new TestingServer(server.getPort());        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        server.restart();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(lastState.get(), ConnectionState.RECONNECTED);    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(node);    }}
public void curator_f2216_0(CuratorFramework client, ConnectionState newState)
{    lastState.set(newState);    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
public void curator_f2217_0() throws Exception
{    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(timing.milliseconds()));    try {        client.start();        final BlockingQueue<ConnectionState> stateVector = Queues.newLinkedBlockingQueue(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                stateVector.offer(newState);            }        };        Timing waitingTiming = timing.forWaiting();        client.getConnectionStateListenable().addListener(listener);        server = new TestingServer(server.getPort());        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);        server.stop();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);        server.restart();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);        server.close();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2218_0(CuratorFramework client, ConnectionState newState)
{    stateVector.offer(newState);}
public void curator_f2219_1() throws Exception
{    server.stop();    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        timing.sleepABit();        LeaderSelectorListener listenerLeader = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                Thread.currentThread().join();            }        };        selector = new LeaderSelector(client, "/leader", listenerLeader);        selector.autoRequeue();        selector.start();        final BlockingQueue<ConnectionState> listenerSequence = Queues.newLinkedBlockingQueue();        ConnectionStateListener listener1 = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                listenerSequence.add(newState);            }        };        Timing forWaiting = timing.forWaiting();        client.getConnectionStateListenable().addListener(listener1);                server.restart();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);                server.stop();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);                server.restart();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);                server.close();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2220_0(CuratorFramework client) throws Exception
{    Thread.currentThread().join();}
public void curator_f2221_0(CuratorFramework client, ConnectionState newState)
{    listenerSequence.add(newState);}
public void curator_f2222_0() throws Exception
{    final int FACTOR = 100;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AtomicValue<Long> value = new MutableAtomicValue<Long>(0L, (long) FACTOR, true);        final AtomicReference<AtomicValue<Long>> fakeValueRef = new AtomicReference<AtomicValue<Long>>(value);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/", null, null) {            @Override            public AtomicValue<Long> trySet(Long newValue) throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> get() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> increment() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> decrement() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> add(Long delta) throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> subtract(Long delta) throws Exception {                return fakeValueRef.get();            }            @Override            public void forceSet(Long newValue) throws Exception {            }            @Override            public AtomicValue<Long> compareAndSet(Long expectedValue, Long newValue) throws Exception {                return fakeValueRef.get();            }        };        CachedAtomicLong cachedLong = new CachedAtomicLong(dal, FACTOR);        for (int i = 0; i < FACTOR; ++i) {            value = cachedLong.next();            Assert.assertTrue(value.succeeded());            Assert.assertEquals(value.preValue().longValue(), i);            Assert.assertEquals(value.postValue().longValue(), i + 1);            if (i == 0) {                MutableAtomicValue<Long> badValue = new MutableAtomicValue<Long>(0L, 0L);                badValue.succeeded = false;                fakeValueRef.set(badValue);            }        }        value = cachedLong.next();        Assert.assertFalse(value.succeeded());    } finally {        client.close();    }}
public AtomicValue<Long> curator_f2223_0(Long newValue) throws Exception
{    return fakeValueRef.get();}
public AtomicValue<Long> curator_f2224_0() throws Exception
{    return fakeValueRef.get();}
public AtomicValue<Long> curator_f2225_0() throws Exception
{    return fakeValueRef.get();}
public AtomicValue<Long> curator_f2226_0() throws Exception
{    return fakeValueRef.get();}
public AtomicValue<Long> curator_f2227_0(Long delta) throws Exception
{    return fakeValueRef.get();}
public AtomicValue<Long> curator_f2228_0(Long delta) throws Exception
{    return fakeValueRef.get();}
public void curator_f2229_0(Long newValue) throws Exception
{}
public AtomicValue<Long> curator_f2230_0(Long expectedValue, Long newValue) throws Exception
{    return fakeValueRef.get();}
public void curator_f2231_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        CachedAtomicLong cachedLong = new CachedAtomicLong(dal, 100);        for (long i = 0; i < 200; ++i) {            AtomicValue<Long> value = cachedLong.next();            Assert.assertTrue(value.succeeded());            Assert.assertEquals(value.preValue().longValue(), i);            Assert.assertEquals(value.postValue().longValue(), i + 1);        }    } finally {        client.close();    }}
public void curator_f2232_0() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/counter", "foo".getBytes());        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        try {            dal.get().postValue();        } catch (BufferUnderflowException e) {            Assert.fail("", e);        } catch (BufferOverflowException e) {            Assert.fail("", e);        } catch (RuntimeException e) {                }    } finally {        client.close();    }}
public void curator_f2233_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        AtomicValue<Long> result = dal.compareAndSet(0L, 1L);        Assert.assertFalse(result.succeeded());        Assert.assertTrue(dal.initialize(0L));        result = dal.compareAndSet(0L, 1L);        Assert.assertTrue(result.succeeded());        Assert.assertFalse(dal.initialize(0L));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2234_0() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean doIncrement = new AtomicBoolean(false);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1)) {            @Override            public byte[] valueToBytes(Long newValue) {                if (doIncrement.get()) {                    DistributedAtomicLong inc = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));                    try {                                                inc.increment();                    } catch (Exception e) {                        throw new Error(e);                    }                }                return super.valueToBytes(newValue);            }        };        dal.forceSet(1L);        Assert.assertTrue(dal.compareAndSet(1L, 5L).succeeded());        Assert.assertFalse(dal.compareAndSet(1L, 5L).succeeded());        doIncrement.set(true);        Assert.assertFalse(dal.compareAndSet(5L, 10L).succeeded());    } finally {        client.close();    }}
public byte[] curator_f2235_0(Long newValue)
{    if (doIncrement.get()) {        DistributedAtomicLong inc = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        try {                        inc.increment();        } catch (Exception e) {            throw new Error(e);        }    }    return super.valueToBytes(newValue);}
public void curator_f2236_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        ExecutorService executorService = Executors.newFixedThreadPool(2);        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < 1000; ++i) {                    dal.increment();                    Thread.sleep(10);                }                return null;            }        });        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < 1000; ++i) {                    dal.forceSet(0L);                    Thread.sleep(10);                }                return null;            }        });        Assert.assertTrue(dal.get().preValue() < 10);    } finally {        client.close();    }}
public Object curator_f2237_0() throws Exception
{    for (int i = 0; i < 1000; ++i) {        dal.increment();        Thread.sleep(10);    }    return null;}
public Object curator_f2238_0() throws Exception
{    for (int i = 0; i < 1000; ++i) {        dal.forceSet(0L);        Thread.sleep(10);    }    return null;}
public void curator_f2239_0() throws Exception
{    final int threadQty = 20;    final int executionQty = 50;    final AtomicInteger optimisticTries = new AtomicInteger();    final AtomicInteger promotedLockTries = new AtomicInteger();    final AtomicInteger failures = new AtomicInteger();    final AtomicInteger errors = new AtomicInteger();    final SummaryStatistics timingStats = new SynchronizedSummaryStatistics();    List<Future<Void>> procs = Lists.newArrayList();    ExecutorService executorService = Executors.newFixedThreadPool(threadQty);    for (int i = 0; i < threadQty; ++i) {        Callable<Void> proc = new Callable<Void>() {            @Override            public Void call() throws Exception {                doSimulation(executionQty, timingStats, optimisticTries, promotedLockTries, failures, errors);                return null;            }        };        procs.add(executorService.submit(proc));    }    for (Future<Void> f : procs) {        f.get();    }    System.out.println("OptimisticTries: " + optimisticTries.get());    System.out.println("PromotedLockTries: " + promotedLockTries.get());    System.out.println("Failures: " + failures.get());    System.out.println("Errors: " + errors.get());    System.out.println();    System.out.println("Avg time: " + timingStats.getMean());    System.out.println("Max time: " + timingStats.getMax());    System.out.println("Min time: " + timingStats.getMin());    System.out.println("Qty: " + timingStats.getN());    Assert.assertEquals(errors.get(), 0);    Assert.assertTrue(optimisticTries.get() > 0);    Assert.assertTrue(promotedLockTries.get() > 0);}
public Void curator_f2240_0() throws Exception
{    doSimulation(executionQty, timingStats, optimisticTries, promotedLockTries, failures, errors);    return null;}
public void curator_f2241_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/foo/bar/counter", new RetryOneTime(1));        AtomicValue<Long> value = dal.increment();        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 0L);        Assert.assertEquals(value.postValue().longValue(), 1L);        value = dal.decrement();        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 1L);        Assert.assertEquals(value.postValue().longValue(), 0L);        value = dal.add(10L);        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 0L);        Assert.assertEquals(value.postValue().longValue(), 10L);        value = dal.subtract(5L);        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 10L);        Assert.assertEquals(value.postValue().longValue(), 5L);    } finally {        client.close();    }}
private void curator_f2242_0(int executionQty, SummaryStatistics timingStats, AtomicInteger optimisticTries, AtomicInteger promotedLockTries, AtomicInteger failures, AtomicInteger errors) throws Exception
{    Random random = new Random();    long previousValue = -1;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(3, 3);        PromotedToLock.Builder builder = PromotedToLock.builder().lockPath("/lock").retryPolicy(retryPolicy);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", retryPolicy, builder.build());        for (int i = 0; i < executionQty; ++i) {            Thread.sleep(random.nextInt(10));            long start = System.currentTimeMillis();            AtomicValue<Long> value = dal.increment();            long elapsed = System.currentTimeMillis() - start;            timingStats.addValue(elapsed);            if (value.succeeded()) {                if (value.postValue() <= previousValue) {                    errors.incrementAndGet();                }                previousValue = value.postValue();            } else {                failures.incrementAndGet();            }            optimisticTries.addAndGet(value.getStats().getOptimisticTries());            promotedLockTries.addAndGet(value.getStats().getPromotedLockTries());        }    } finally {        client.close();    }}
public void curator_f2243_0() throws Exception
{    final int TIMEOUT = 1000;    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(TIMEOUT).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        barrier.setBarrier();        final ExecutorService service = Executors.newSingleThreadExecutor();        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Thread.sleep(TIMEOUT / 2);                server.stop();                return null;            }        });        barrier.waitOnBarrier(TIMEOUT * 2, TimeUnit.SECONDS);        future.get();        Assert.fail();    } catch (KeeperException.ConnectionLossException expected) {        } finally {        client.close();    }}
public Object curator_f2244_0() throws Exception
{    Thread.sleep(TIMEOUT / 2);    server.stop();    return null;}
public void curator_f2245_0() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            try {                client.start();                DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");                barrier.setBarrier();            } finally {                CloseableUtils.closeQuietly(client);            }        }        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        List<Future<Object>> futures = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (final CuratorFramework c : new CuratorFramework[] { client1, client2 }) {            Future<Object> future = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    c.start();                    DistributedBarrier barrier = new DistributedBarrier(c, "/barrier");                    barrier.waitOnBarrier(10, TimeUnit.MILLISECONDS);                    return null;                }            });            futures.add(future);        }        Thread.sleep(1000);        {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            try {                client.start();                DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");                barrier.removeBarrier();            } finally {                CloseableUtils.closeQuietly(client);            }        }        for (Future<Object> f : futures) {            f.get();        }    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);    }}
public Object curator_f2246_0() throws Exception
{    c.start();    DistributedBarrier barrier = new DistributedBarrier(c, "/barrier");    barrier.waitOnBarrier(10, TimeUnit.MILLISECONDS);    return null;}
public void curator_f2247_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        Assert.assertTrue(barrier.waitOnBarrier(10, TimeUnit.SECONDS));                ExecutorService service = Executors.newSingleThreadExecutor();        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                barrier.waitOnBarrier();                return "";            }        });        Assert.assertTrue(future.get(10, TimeUnit.SECONDS) != null);    } finally {        client.close();    }}
public Object curator_f2248_0() throws Exception
{    barrier.waitOnBarrier();    return "";}
public void curator_f2249_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        barrier.setBarrier();        ExecutorService service = Executors.newSingleThreadExecutor();        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Thread.sleep(1000);                barrier.removeBarrier();                return null;            }        });        Assert.assertTrue(barrier.waitOnBarrier(10, TimeUnit.SECONDS));    } finally {        client.close();    }}
public Object curator_f2250_0() throws Exception
{    Thread.sleep(1000);    barrier.removeBarrier();    return null;}
public void curator_f2251_0() throws Exception
{    final Timing timing = new Timing();    final CountDownLatch postEnterLatch = new CountDownLatch(QTY);    final CountDownLatch postLeaveLatch = new CountDownLatch(QTY);    final AtomicInteger count = new AtomicInteger(0);    final AtomicInteger max = new AtomicInteger(0);    List<Future<Void>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < QTY; ++i) {        Future<Void> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                try {                    client.start();                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    synchronized (TestDistributedDoubleBarrier.this) {                        int thisCount = count.incrementAndGet();                        if (thisCount > max.get()) {                            max.set(thisCount);                        }                    }                    postEnterLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                    Assert.assertEquals(count.get(), QTY);                    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));                    count.decrementAndGet();                    postLeaveLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                } finally {                    CloseableUtils.closeQuietly(client);                }                return null;            }        });        futures.add(future);    }    for (Future<Void> f : futures) {        f.get();    }    Assert.assertEquals(count.get(), 0);    Assert.assertEquals(max.get(), QTY);}
public Void curator_f2252_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);        Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));        synchronized (TestDistributedDoubleBarrier.this) {            int thisCount = count.incrementAndGet();            if (thisCount > max.get()) {                max.set(thisCount);            }        }        postEnterLatch.countDown();        Assert.assertTrue(timing.awaitLatch(postEnterLatch));        Assert.assertEquals(count.get(), QTY);        Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));        count.decrementAndGet();        postLeaveLatch.countDown();        Assert.assertTrue(timing.awaitLatch(postEnterLatch));    } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
public void curator_f2253_0() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService service = Executors.newCachedThreadPool();    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(service);    try {        client.start();        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch latch = new CountDownLatch(1);        for (int i = 0; i < (QTY + 1); ++i) {            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY) {                        @Override                        protected List<String> getChildrenForEntering() throws Exception {                            semaphore.release();                            Assert.assertTrue(timing.awaitLatch(latch));                            return super.getChildrenForEntering();                        }                    };                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));                    return null;                }            });        }                Assert.assertTrue(semaphore.tryAcquire(QTY + 1, timing.seconds(), TimeUnit.SECONDS));        latch.countDown();        for (int i = 0; i < (QTY + 1); ++i) {                        completionService.take().get();        }    } finally {        service.shutdown();        CloseableUtils.closeQuietly(client);    }}
public Void curator_f2254_0() throws Exception
{    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY) {        @Override        protected List<String> getChildrenForEntering() throws Exception {            semaphore.release();            Assert.assertTrue(timing.awaitLatch(latch));            return super.getChildrenForEntering();        }    };    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));    return null;}
protected List<String> curator_f2255_0() throws Exception
{    semaphore.release();    Assert.assertTrue(timing.awaitLatch(latch));    return super.getChildrenForEntering();}
public void curator_f2256_0() throws Exception
{    final Timing timing = new Timing();    final List<Closeable> closeables = Lists.newArrayList();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        closeables.add(client);        client.start();        final CountDownLatch postEnterLatch = new CountDownLatch(QTY);        final CountDownLatch postLeaveLatch = new CountDownLatch(QTY);        final AtomicInteger count = new AtomicInteger(0);        final AtomicInteger max = new AtomicInteger(0);        List<Future<Void>> futures = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (int i = 0; i < QTY; ++i) {            Future<Void> future = service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    synchronized (TestDistributedDoubleBarrier.this) {                        int thisCount = count.incrementAndGet();                        if (thisCount > max.get()) {                            max.set(thisCount);                        }                    }                    postEnterLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                    Assert.assertEquals(count.get(), QTY);                    Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));                    count.decrementAndGet();                    postLeaveLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postLeaveLatch));                    return null;                }            });            futures.add(future);        }        for (Future<Void> f : futures) {            f.get();        }        Assert.assertEquals(count.get(), 0);        Assert.assertEquals(max.get(), QTY);    } finally {        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public Void curator_f2257_0() throws Exception
{    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));    synchronized (TestDistributedDoubleBarrier.this) {        int thisCount = count.incrementAndGet();        if (thisCount > max.get()) {            max.set(thisCount);        }    }    postEnterLatch.countDown();    Assert.assertTrue(timing.awaitLatch(postEnterLatch));    Assert.assertEquals(count.get(), QTY);    Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));    count.decrementAndGet();    postLeaveLatch.countDown();    Assert.assertTrue(timing.awaitLatch(postLeaveLatch));    return null;}
public void curator_f2258_0(CuratorFramework client, TreeCacheEvent event) throws Exception
{        if (event.getData() != null && event.getData().getPath().startsWith("/zookeeper")) {        return;    }    events.add(event);}
public void curator_f2259_0(String message, Throwable e)
{    hadBackgroundException.set(true);    e.printStackTrace(System.err);}
protected TreeCache curator_f2260_0(CuratorFramework client, String path)
{    TreeCache result = new TreeCache(client, path);    result.getListenable().addListener(eventListener);    result.getUnhandledErrorListenable().addListener(errorListener);    return result;}
protected TreeCache curator_f2261_0(TreeCache.Builder builder)
{    TreeCache result = builder.build();    result.getListenable().addListener(eventListener);    result.getUnhandledErrorListenable().addListener(errorListener);    return result;}
public void curator_f2262_0() throws Exception
{    super.setup();    initCuratorFramework();}
 void curator_f2263_0()
{    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    client.getUnhandledErrorListenable().addListener(errorListener);}
public void curator_f2264_0() throws Exception
{    try {        try {            Assert.assertFalse(hadBackgroundException.get(), "Background exceptions were thrown, see stderr for details");            assertNoMoreEvents();        } finally {            CloseableUtils.closeQuietly(cache);            TestCleanState.closeAndTestClean(client);        }    } finally {        super.teardown();    }}
 void curator_f2265_0() throws InterruptedException
{    timing.sleepABit();    Assert.assertTrue(events.isEmpty(), String.format("Expected no events, found %d; first event: %s", events.size(), events.peek()));}
 TreeCacheEvent curator_f2266_0(TreeCacheEvent.Type expectedType) throws InterruptedException
{    return assertEvent(expectedType, null);}
 TreeCacheEvent curator_f2267_0(TreeCacheEvent.Type expectedType, String expectedPath) throws InterruptedException
{    return assertEvent(expectedType, expectedPath, null);}
 TreeCacheEvent curator_f2268_0(TreeCacheEvent.Type expectedType, String expectedPath, byte[] expectedData) throws InterruptedException
{    return assertEvent(expectedType, expectedPath, expectedData, false);}
 TreeCacheEvent curator_f2269_0(TreeCacheEvent.Type expectedType, String expectedPath, byte[] expectedData, boolean ignoreConnectionEvents) throws InterruptedException
{    TreeCacheEvent event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(event, String.format("Expected type: %s, path: %s", expectedType, expectedPath));    if (ignoreConnectionEvents) {        if ((event.getType() == TreeCacheEvent.Type.CONNECTION_SUSPENDED) || (event.getType() == TreeCacheEvent.Type.CONNECTION_LOST) || (event.getType() == TreeCacheEvent.Type.CONNECTION_RECONNECTED)) {            return assertEvent(expectedType, expectedPath, expectedData, ignoreConnectionEvents);        }    }    String message = event.toString();    Assert.assertEquals(event.getType(), expectedType, message);    if (expectedPath == null) {        Assert.assertNull(event.getData(), message);    } else {        Assert.assertNotNull(event.getData(), message);        Assert.assertEquals(event.getData().getPath(), expectedPath, message);    }    if (expectedData != null) {        Assert.assertEquals(event.getData().getData(), expectedData, message);    }    return event;}
public void curator_f2270_0() throws Exception
{    ExecutorService executorService = Executors.newFixedThreadPool(THREAD_QTY);    BlockingQueue<Event> events = Queues.newLinkedBlockingQueue();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    T cache = null;    try {        client.start();        client.create().forPath("/root");        cache = newCache(client, "/root", events);        final Random random = new Random();        final Callable<Void> task = new Callable<Void>() {            @Override            public Void call() throws Exception {                for (int i = 0; i < ITERATIONS; ++i) {                    String node = "/root/" + random.nextInt(NODE_QTY);                    try {                        switch(random.nextInt(3)) {                            default:                            case 0:                                client.create().forPath(node);                                break;                            case 1:                                client.setData().forPath(node, "new".getBytes());                                break;                            case 2:                                client.delete().forPath(node);                                break;                        }                    } catch (KeeperException ignore) {                                        }                }                return null;            }        };        final CountDownLatch latch = new CountDownLatch(THREAD_QTY);        for (int i = 0; i < THREAD_QTY; ++i) {            Callable<Void> wrapped = new Callable<Void>() {                @Override                public Void call() throws Exception {                    try {                        return task.call();                    } finally {                        latch.countDown();                    }                }            };            executorService.submit(wrapped);        }        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        List<Event> localEvents = Lists.newArrayList();        int eventSuggestedQty = 0;        while (events.size() > 0) {            Event event = timing.takeFromQueue(events);            localEvents.add(event);            eventSuggestedQty += (event.eventType == EventType.ADDED) ? 1 : -1;        }        int actualQty = getActualQty(cache);        Assert.assertEquals(actualQty, eventSuggestedQty, String.format("actual %s expected %s:\n %s", actualQty, eventSuggestedQty, asString(localEvents)));    } finally {        executorService.shutdownNow();                executorService.awaitTermination(timing.milliseconds(), TimeUnit.MILLISECONDS);        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
public Void curator_f2271_0() throws Exception
{    for (int i = 0; i < ITERATIONS; ++i) {        String node = "/root/" + random.nextInt(NODE_QTY);        try {            switch(random.nextInt(3)) {                default:                case 0:                    client.create().forPath(node);                    break;                case 1:                    client.setData().forPath(node, "new".getBytes());                    break;                case 2:                    client.delete().forPath(node);                    break;            }        } catch (KeeperException ignore) {                }    }    return null;}
public Void curator_f2272_0() throws Exception
{    try {        return task.call();    } finally {        latch.countDown();    }}
private String curator_f2273_0(List<Event> events)
{    int qty = 0;    StringBuilder str = new StringBuilder();    for (Event event : events) {        qty += (event.eventType == EventType.ADDED) ? 1 : -1;        str.append(event.eventType).append(" ").append(event.path).append(" @ ").append(event.time - start).append(' ').append(qty);        str.append("\n");    }    return str.toString();}
public void curator_f2274_0() throws Exception
{    NodeCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/test/foo", "one".getBytes());        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();        client.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                error.set(e);            }        });        final Semaphore semaphore = new Semaphore(0);        cache = new NodeCache(client, "/test/foo");        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                semaphore.release();            }        });        cache.start(true);        Assert.assertEquals(cache.getCurrentData().getData(), "one".getBytes());        client.delete().forPath("/test/foo");        Assert.assertTrue(semaphore.tryAcquire(1, 10, TimeUnit.SECONDS));        client.create().forPath("/test/foo", "two".getBytes());        Assert.assertTrue(semaphore.tryAcquire(1, 10, TimeUnit.SECONDS));        Throwable t = error.get();        if (t != null) {            Assert.fail("Assert", t);        }        Assert.assertEquals(cache.getCurrentData().getData(), "two".getBytes());        cache.close();    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2275_0(String message, Throwable e)
{    error.set(e);}
public void curator_f2276_0() throws Exception
{    semaphore.release();}
public void curator_f2277_0() throws Exception
{    Timing2 timing2 = new Timing2();    NodeCache cache = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/snafu", "original".getBytes());        final CountDownLatch latch = new CountDownLatch(1);        cache = new NodeCache(client, "/test/snafu");        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                latch.countDown();            }        });        cache.rebuildTestExchanger = new Exchanger<Object>();        ExecutorService service = Executors.newSingleThreadExecutor();        final NodeCache finalCache = cache;        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);                                client.setData().forPath("/test/snafu", "other".getBytes());                ChildData currentData = finalCache.getCurrentData();                Assert.assertNotNull(currentData);                finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);                return null;            }        });        cache.start(false);        future.get();        Assert.assertTrue(timing2.awaitLatch(latch));        Assert.assertNotNull(cache.getCurrentData());        Assert.assertEquals(cache.getCurrentData().getData(), "other".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2278_0() throws Exception
{    latch.countDown();}
public Object curator_f2279_0() throws Exception
{    finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);        client.setData().forPath("/test/snafu", "other".getBytes());    ChildData currentData = finalCache.getCurrentData();    Assert.assertNotNull(currentData);    finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);    return null;}
public void curator_f2280_0() throws Exception
{    NodeCache cache = null;    Timing timing = new Timing();    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/node", "start".getBytes());        cache = new NodeCache(client, "/test/node");        cache.start(true);        final CountDownLatch latch = new CountDownLatch(1);        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                latch.countDown();            }        });        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Thread.sleep(timing.multiple(1.5).session());        Assert.assertEquals(cache.getCurrentData().getData(), "start".getBytes());        client.setData().forPath("/test/node", "new data".getBytes());        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2281_0() throws Exception
{    latch.countDown();}
public void curator_f2282_0() throws Exception
{    NodeCache cache = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        cache = new NodeCache(client, "/test/node");        cache.start(true);        final Semaphore semaphore = new Semaphore(0);        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                semaphore.release();            }        });        Assert.assertNull(cache.getCurrentData());        client.create().forPath("/test/node", "a".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(cache.getCurrentData().getData(), "a".getBytes());        client.setData().forPath("/test/node", "b".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(cache.getCurrentData().getData(), "b".getBytes());        client.delete().forPath("/test/node");        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertNull(cache.getCurrentData());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2283_0() throws Exception
{    semaphore.release();}
public void curator_f2284_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    PathChildrenCache cache = new PathChildrenCache(client, "/a/b/test", true);    try {        client.start();                client.blockUntilConnected();        final BlockingQueue<PathChildrenCacheEvent.Type> events = Queues.newLinkedBlockingQueue();        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());            }        };        cache.getListenable().addListener(listener);        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.INITIALIZED);        client.create().forPath("/a/b/test/one");        client.create().forPath("/a/b/test/two");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        client.delete().forPath("/a/b/test/one");        client.delete().forPath("/a/b/test/two");        client.delete().forPath("/a/b/test");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        timing.sleepABit();        client.create().creatingParentContainersIfNeeded().forPath("/a/b/test/new");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2285_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());}
public void curator_f2286_0() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    PathChildrenCache cache = new PathChildrenCache(client, "/a/b/test", true) {        @Override        void getDataAndStat(final String fullPath) throws Exception {                        client.delete().forPath("/a/b/test/one");            super.getDataAndStat(fullPath);        }    };    Timing timing = new Timing();    try {        client.start();        final CountDownLatch cacheInitialized = new CountDownLatch(1);        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    cacheInitialized.countDown();                }            }        };        cache.getListenable().addListener(listener);        client.create().creatingParentsIfNeeded().forPath("/a/b/test/one");        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(cacheInitialized));        Assert.assertEquals(cache.getCurrentData().size(), 0);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
 void curator_f2287_0(final String fullPath) throws Exception
{        client.delete().forPath("/a/b/test/one");    super.getDataAndStat(fullPath);}
public void curator_f2288_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        cacheInitialized.countDown();    }}
public void curator_f2289_0() throws Exception
{    final int serverPort = server.getPort();    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 1000, 1000, new RetryOneTime(1));    try {        client.start();        final CountDownLatch ensurePathLatch = new CountDownLatch(1);        PathChildrenCache cache = new PathChildrenCache(client, "/", true) {            @Override            protected void ensurePath() throws Exception {                try {                    super.ensurePath();                } catch (Exception e) {                    ensurePathLatch.countDown();                    throw e;                }            }        };        final CountDownLatch addedLatch = new CountDownLatch(1);        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED && event.getData().getPath().equals("/baz")) {                    addedLatch.countDown();                }            }        };        cache.getListenable().addListener(listener);        cache.start();        Assert.assertTrue(timing.awaitLatch(ensurePathLatch));        final CountDownLatch connectedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        });        server = new TestingServer(serverPort, true);        Assert.assertTrue(timing.awaitLatch(connectedLatch));        client.create().creatingParentContainersIfNeeded().forPath("/baz", new byte[] { 1, 2, 3 });        assertNotNull("/baz does not exist", client.checkExists().forPath("/baz"));        Assert.assertTrue(timing.awaitLatch(addedLatch));        assertNotNull("cache doesn't see /baz", cache.getCurrentData("/baz"));    } finally {        CloseableUtils.closeQuietly(client);    }}
protected void curator_f2290_0() throws Exception
{    try {        super.ensurePath();    } catch (Exception e) {        ensurePathLatch.countDown();        throw e;    }}
public void curator_f2291_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED && event.getData().getPath().equals("/baz")) {        addedLatch.countDown();    }}
public void curator_f2292_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
public void curator_f2293_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        cache = new PathChildrenCache(client, "/test", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    latch.countDown();                }            }        });        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2294_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        latch.countDown();    }}
public void curator_f2295_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        client.create().forPath("/test/one", "hey there".getBytes());        final BlockingQueue<PathChildrenCacheEvent> events = new LinkedBlockingQueue<PathChildrenCacheEvent>();        cache = new PathChildrenCache(client, "/test", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.offer(event);            }        });        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        PathChildrenCacheEvent event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(event.getType(), PathChildrenCacheEvent.Type.CHILD_ADDED);        event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);        Assert.assertEquals(event.getInitialData().size(), 1);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2296_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.offer(event);}
public void curator_f2297_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        final CountDownLatch addedLatch = new CountDownLatch(3);        final CountDownLatch initLatch = new CountDownLatch(1);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    initLatch.countDown();                }            }        });        client.create().forPath("/test/1", "1".getBytes());        client.create().forPath("/test/2", "2".getBytes());        client.create().forPath("/test/3", "3".getBytes());        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(addedLatch));        Assert.assertTrue(timing.awaitLatch(initLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);        Assert.assertEquals(cache.getCurrentData().get(0).getData(), "1".getBytes());        Assert.assertEquals(cache.getCurrentData().get(1).getData(), "2".getBytes());        Assert.assertEquals(cache.getCurrentData().get(2).getData(), "3".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2298_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        initLatch.countDown();    }}
public void curator_f2299_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        final CountDownLatch addedLatch = new CountDownLatch(3);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                Assert.assertNotEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                }            }        });        client.create().forPath("/test/1", "1".getBytes());        client.create().forPath("/test/2", "2".getBytes());        client.create().forPath("/test/3", "3".getBytes());        cache.start(PathChildrenCache.StartMode.NORMAL);        Assert.assertTrue(timing.awaitLatch(addedLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);        Assert.assertEquals(cache.getCurrentData().get(0).getData(), "1".getBytes());        Assert.assertEquals(cache.getCurrentData().get(1).getData(), "2".getBytes());        Assert.assertEquals(cache.getCurrentData().get(2).getData(), "3".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2300_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    Assert.assertNotEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    }}
public void curator_f2301_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch updatedLatch = new CountDownLatch(1);        final CountDownLatch addedLatch = new CountDownLatch(1);        client.create().creatingParentsIfNeeded().forPath("/test");        cache = new PathChildrenCache(client, "/test", false);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {                    updatedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                }            }        });        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        client.create().forPath("/test/foo", "first".getBytes());        Assert.assertTrue(timing.awaitLatch(addedLatch));        client.setData().forPath("/test/foo", "something new".getBytes());        Assert.assertTrue(timing.awaitLatch(updatedLatch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2302_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {        updatedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    }}
public void curator_f2303_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        try (PathChildrenCache cache = new PathChildrenCache(client, "/one/two/three", false)) {            cache.start();            timing.sleepABit();            try {                client.create().forPath("/one/two/three/four");            } catch (KeeperException.NoNodeException e) {                Assert.fail("Path should exist", e);            }        }        timing.sleepABit();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2304_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/foo", "one".getBytes());        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();        client.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                error.set(e);            }        });        final CountDownLatch removedLatch = new CountDownLatch(1);        final CountDownLatch postRemovedLatch = new CountDownLatch(1);        final CountDownLatch dataLatch = new CountDownLatch(1);        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                        removedLatch.countDown();                        Assert.assertTrue(postRemovedLatch.await(10, TimeUnit.SECONDS));                    } else {                        try {                            Assert.assertEquals(event.getData().getData(), "two".getBytes());                        } finally {                            dataLatch.countDown();                        }                    }                }            });            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);            client.delete().forPath("/test/foo");            Assert.assertTrue(timing.awaitLatch(removedLatch));            client.create().forPath("/test/foo", "two".getBytes());            postRemovedLatch.countDown();            Assert.assertTrue(timing.awaitLatch(dataLatch));            Throwable t = error.get();            if (t != null) {                Assert.fail("Assert", t);            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2305_0(String message, Throwable e)
{    error.set(e);}
public void curator_f2306_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        removedLatch.countDown();        Assert.assertTrue(postRemovedLatch.await(10, TimeUnit.SECONDS));    } else {        try {            Assert.assertEquals(event.getData().getData(), "two".getBytes());        } finally {            dataLatch.countDown();        }    }}
public void curator_f2307_0() throws Exception
{    Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/foo");        client.create().forPath("/test/bar");        client.create().forPath("/test/snafu", "original".getBytes());        final CountDownLatch addedLatch = new CountDownLatch(2);        try (final PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                        if (event.getData().getPath().equals("/test/test")) {                            addedLatch.countDown();                        }                    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {                        if (event.getData().getPath().equals("/test/snafu")) {                            addedLatch.countDown();                        }                    }                }            });            cache.rebuildTestExchanger = new Exchanger<Object>();            ExecutorService service = Executors.newSingleThreadExecutor();            final AtomicReference<String> deletedPath = new AtomicReference<String>();            Future<Object> future = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    cache.rebuildTestExchanger.exchange(new Object());                                        client.create().forPath("/test/test");                    List<ChildData> currentData = cache.getCurrentData();                    Assert.assertTrue(currentData.size() > 0);                                        client.delete().forPath(currentData.get(0).getPath());                    deletedPath.set(currentData.get(0).getPath());                    cache.rebuildTestExchanger.exchange(new Object());                    ChildData childData = null;                    while (childData == null) {                        childData = cache.getCurrentData("/test/snafu");                        Thread.sleep(1000);                    }                    Assert.assertEquals(childData.getData(), "original".getBytes());                    client.setData().forPath("/test/snafu", "grilled".getBytes());                    cache.rebuildTestExchanger.exchange(new Object());                    return null;                }            });            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);            future.get();            Assert.assertTrue(timing.awaitLatch(addedLatch));            Assert.assertNotNull(cache.getCurrentData("/test/test"));            Assert.assertNull(cache.getCurrentData(deletedPath.get()));            Assert.assertEquals(cache.getCurrentData("/test/snafu").getData(), "grilled".getBytes());        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2308_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        if (event.getData().getPath().equals("/test/test")) {            addedLatch.countDown();        }    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {        if (event.getData().getPath().equals("/test/snafu")) {            addedLatch.countDown();        }    }}
public Object curator_f2309_0() throws Exception
{    cache.rebuildTestExchanger.exchange(new Object());        client.create().forPath("/test/test");    List<ChildData> currentData = cache.getCurrentData();    Assert.assertTrue(currentData.size() > 0);        client.delete().forPath(currentData.get(0).getPath());    deletedPath.set(currentData.get(0).getPath());    cache.rebuildTestExchanger.exchange(new Object());    ChildData childData = null;    while (childData == null) {        childData = cache.getCurrentData("/test/snafu");        Thread.sleep(1000);    }    Assert.assertEquals(childData.getData(), "original".getBytes());    client.setData().forPath("/test/snafu", "grilled".getBytes());    cache.rebuildTestExchanger.exchange(new Object());    return null;}
public void curator_f2310_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/base");        client.create().forPath("/base/a");        client.create().forPath("/base/b");        client.create().forPath("/base/c");        client.getChildren().forPath("/base");        final List<PathChildrenCacheEvent.Type> events = Lists.newArrayList();        final Semaphore semaphore = new Semaphore(0);        cache = new PathChildrenCache(client, "/base", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());                semaphore.release();            }        });        cache.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 3));        client.delete().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        client.create().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        List<PathChildrenCacheEvent.Type> expected = Lists.newArrayList(PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_REMOVED, PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(expected, events);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2311_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());    semaphore.release();}
public void curator_f2312_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/base");        client.create().forPath("/base/a");        client.create().forPath("/base/b");        client.create().forPath("/base/c");        client.getChildren().forPath("/base");        final List<PathChildrenCacheEvent.Type> events = Lists.newArrayList();        final Semaphore semaphore = new Semaphore(0);        cache = new PathChildrenCache(client, "/base", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());                semaphore.release();            }        });        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        client.delete().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        client.create().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        List<PathChildrenCacheEvent.Type> expected = Lists.newArrayList(PathChildrenCacheEvent.Type.CHILD_REMOVED, PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(expected, events);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2313_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());    semaphore.release();}
public void curator_f2314_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        cache.start();        final CountDownLatch childAddedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final CountDownLatch removedLatch = new CountDownLatch(1);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    childAddedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_LOST) {                    lostLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {                    reconnectedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                    removedLatch.countDown();                }            }        });        client.create().withMode(CreateMode.EPHEMERAL).forPath("/test/me", "data".getBytes());        Assert.assertTrue(timing.awaitLatch(childAddedLatch));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(lostLatch));        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertTrue(timing.awaitLatch(removedLatch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2315_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        childAddedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_LOST) {        lostLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {        reconnectedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        removedLatch.countDown();    }}
public void curator_f2316_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        for (boolean cacheData : new boolean[] { false, true }) {            internalTestMode(client, cacheData);            client.delete().forPath("/test/one");            client.delete().forPath("/test/two");        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2317_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one", "one".getBytes());        final CountDownLatch latch = new CountDownLatch(1);        final AtomicInteger counter = new AtomicInteger();        final Semaphore semaphore = new Semaphore(1);        cache = new PathChildrenCache(client, "/test", true) {            @Override            void getDataAndStat(String fullPath) throws Exception {                semaphore.acquire();                counter.incrementAndGet();                super.getDataAndStat(fullPath);                latch.countDown();            }        };        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        Assert.assertTrue(timing.awaitLatch(latch));        int saveCounter = counter.get();        client.setData().forPath("/test/one", "alt".getBytes());        cache.rebuildNode("/test/one");        Assert.assertEquals(cache.getCurrentData("/test/one").getData(), "alt".getBytes());        Assert.assertEquals(saveCounter, counter.get());        semaphore.release(1000);        timing.sleepABit();    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
 void curator_f2318_0(String fullPath) throws Exception
{    semaphore.acquire();    counter.incrementAndGet();    super.getDataAndStat(fullPath);    latch.countDown();}
private void curator_f2319_0(CuratorFramework client, boolean cacheData) throws Exception
{    try (PathChildrenCache cache = new PathChildrenCache(client, "/test", cacheData)) {        final CountDownLatch latch = new CountDownLatch(2);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    latch.countDown();                }            }        });        cache.start();        client.create().forPath("/test/one", "one".getBytes());        client.create().forPath("/test/two", "two".getBytes());        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        for (ChildData data : cache.getCurrentData()) {            if (cacheData) {                Assert.assertNotNull(data.getData());                Assert.assertNotNull(data.getStat());            } else {                Assert.assertNull(data.getData());                Assert.assertNotNull(data.getStat());            }        }    }}
public void curator_f2320_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        latch.countDown();    }}
public void curator_f2321_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final BlockingQueue<PathChildrenCacheEvent.Type> events = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getData().getPath().equals("/test/one")) {                        events.offer(event.getType());                    }                }            });            cache.start();            client.create().forPath("/test/one", "hey there".getBytes());            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);            client.setData().forPath("/test/one", "sup!".getBytes());            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);            Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");            client.delete().forPath("/test/one");            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2322_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events.offer(event.getType());    }}
public void curator_f2323_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final BlockingQueue<PathChildrenCacheEvent.Type> events = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();        final ExecutorService exec = Executors.newSingleThreadExecutor();        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true, false, exec)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getData().getPath().equals("/test/one")) {                        events.offer(event.getType());                    }                }            });            cache.start();            final BlockingQueue<PathChildrenCacheEvent.Type> events2 = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();            try (PathChildrenCache cache2 = new PathChildrenCache(client, "/test", true, false, exec)) {                cache2.getListenable().addListener(new PathChildrenCacheListener() {                    @Override                    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                        if (event.getData().getPath().equals("/test/one")) {                            events2.offer(event.getType());                        }                    }                });                cache2.start();                client.create().forPath("/test/one", "hey there".getBytes());                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);                client.setData().forPath("/test/one", "sup!".getBytes());                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);                Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");                Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "sup!");                client.delete().forPath("/test/one");                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2324_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events.offer(event.getType());    }}
public void curator_f2325_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events2.offer(event.getType());    }}
public void curator_f2326_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final ExecuteCalledWatchingExecutorService exec = new ExecuteCalledWatchingExecutorService(Executors.newSingleThreadExecutor());        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true, false, exec)) {            cache.start();            client.create().forPath("/test/one", "hey there".getBytes());            cache.rebuild();            Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");            Assert.assertTrue(exec.isExecuteCalled());            exec.setExecuteCalled(false);        }        Assert.assertFalse(exec.isExecuteCalled());        client.delete().forPath("/test/one");        timing.sleepABit();        Assert.assertFalse(exec.isExecuteCalled());    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2327_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 30000, 30000, new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        try (final PathChildrenCache cache = new PathChildrenCache(client, "/test", false) {            @Override            protected void handleException(Throwable e) {                latch.countDown();            }        }) {            cache.start();            cache.offerOperation(new Operation() {                @Override                public void invoke() throws Exception {                    Thread.sleep(5000);                }            });            Thread.sleep(1000);        }        latch.await(5, TimeUnit.SECONDS);        Assert.assertTrue(latch.getCount() == 1, "Unexpected exception occurred");    } finally {        TestCleanState.closeAndTestClean(client);    }}
protected void curator_f2328_0(Throwable e)
{    latch.countDown();}
public void curator_f2329_0() throws Exception
{    Thread.sleep(5000);}
protected int curator_f2330_0(PathChildrenCache cache)
{    return cache.getCurrentData().size();}
protected PathChildrenCache curator_f2331_0(CuratorFramework client, String path, final BlockingQueue<Event> events) throws Exception
{    PathChildrenCache cache = new PathChildrenCache(client, path, false);    PathChildrenCacheListener listener = new PathChildrenCacheListener() {        @Override        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {            if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                events.add(new Event(EventType.ADDED, event.getData().getPath()));            }            if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                events.add(new Event(EventType.DELETED, event.getData().getPath()));            }        }    };    cache.getListenable().addListener(listener);    cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);    return cache;}
public void curator_f2332_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        events.add(new Event(EventType.ADDED, event.getData().getPath()));    }    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        events.add(new Event(EventType.DELETED, event.getData().getPath()));    }}
public void curator_f2333_0() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client1 = null;    CuratorFramework client2 = null;    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();                InstanceSpec client1Instance = cluster.getInstances().iterator().next();        client1 = CuratorFrameworkFactory.newClient(client1Instance.getConnectString(), 1000, 1000, new RetryOneTime(1));        cache = new PathChildrenCache(client1, "/test", true);        final BlockingQueue<PathChildrenCacheEvent.Type> events = Queues.newLinkedBlockingQueue();        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());            }        };        cache.getListenable().addListener(listener);        client2 = CuratorFrameworkFactory.newClient(cluster.getConnectString(), 1000, 1000, new RetryOneTime(1));        client1.start();        client2.start();        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.INITIALIZED);        client2.create().creatingParentsIfNeeded().forPath("/test/node", "first".getBytes());        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        cluster.killServer(client1Instance);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_LOST);        client2.delete().forPath("/test/node");        client2.create().forPath("/test/node", "second".getBytes());        cluster.restartServer(client1Instance);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED);                Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f2334_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());}
public void curator_f2335_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    PathChildrenCache cache = null;    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().creatingParentsIfNeeded().forPath("/test");        cache = new PathChildrenCache(client, "/test", false);        cache.start();        final CountDownLatch resetLatch = new CountDownLatch(1);        final CountDownLatch reconnectLatch = new CountDownLatch(1);        final AtomicReference<CountDownLatch> latch = new AtomicReference<CountDownLatch>(new CountDownLatch(3));        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED) {                    resetLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {                    reconnectLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    latch.get().countDown();                }            }        });        client.create().forPath("/test/one");        client.create().forPath("/test/two");        client.create().forPath("/test/three");        Assert.assertTrue(latch.get().await(10, TimeUnit.SECONDS));        InstanceSpec connectionInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        cluster.killServer(connectionInstance);        Assert.assertTrue(timing.awaitLatch(reconnectLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f2336_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED) {        resetLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {        reconnectLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        latch.get().countDown();    }}
public void curator_f2337_0() throws Exception
{    client.create().forPath("/root");    client.create().forPath("/root/n1-a");    client.create().forPath("/root/n1-b");    client.create().forPath("/root/n1-b/n2-a");    client.create().forPath("/root/n1-b/n2-b");    client.create().forPath("/root/n1-b/n2-b/n3-a");    client.create().forPath("/root/n1-c");    client.create().forPath("/root/n1-d");    TreeCacheSelector selector = new TreeCacheSelector() {        @Override        public boolean traverseChildren(String fullPath) {            return !fullPath.equals("/root/n1-b/n2-b");        }        @Override        public boolean acceptChild(String fullPath) {            return !fullPath.equals("/root/n1-c");        }    };    cache = buildWithListeners(TreeCache.newBuilder(client, "/root").setSelector(selector));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-a");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-d");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b/n2-a");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b/n2-b");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
public boolean curator_f2338_0(String fullPath)
{    return !fullPath.equals("/root/n1-b/n2-b");}
public boolean curator_f2339_0(String fullPath)
{    return !fullPath.equals("/root/n1-c");}
public void curator_f2340_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2/sub", "two-sub".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("1", "2", "3"));    Assert.assertEquals(cache.getCurrentChildren("/test/1").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test/2").keySet(), ImmutableSet.of("sub"));    Assert.assertNull(cache.getCurrentChildren("/test/non_exist"));}
public void curator_f2341_0() throws Exception
{    cache = newTreeCacheWithListeners(client, "/one/two/three");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertNull(client.checkExists().forPath("/one/two/three"));    cache.close();    cache = buildWithListeners(TreeCache.newBuilder(client, "/one/two/three").setCreateParentNodes(true));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/one/two/three");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));}
public void curator_f2342_0() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertNoMoreEvents();}
public void curator_f2343_0() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test/foo/bar");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().creatingParentsIfNeeded().forPath("/test/foo");    assertNoMoreEvents();    client.create().forPath("/test/foo/bar");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar");    assertNoMoreEvents();}
public void curator_f2344_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setMaxDepth(0));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/1"));    Assert.assertNull(cache.getCurrentChildren("/test/1"));    Assert.assertNull(cache.getCurrentData("/test/non_exist"));}
public void curator_f2345_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("1", "2", "3"));    Assert.assertEquals(cache.getCurrentChildren("/test/1").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test/2").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/2/sub"));    Assert.assertNull(cache.getCurrentChildren("/test/2/sub"));    Assert.assertNull(cache.getCurrentChildren("/test/non_exist"));}
public void curator_f2346_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo");    client.create().forPath("/test/foo/bar");    client.create().forPath("/test/foo/bar/1", "one".getBytes());    client.create().forPath("/test/foo/bar/2", "two".getBytes());    client.create().forPath("/test/foo/bar/3", "three".getBytes());    client.create().forPath("/test/foo/bar/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test/foo/bar").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
public void curator_f2347_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
public void curator_f2348_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client, "/");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertTrue(cache.getCurrentChildren("/").keySet().contains("test"));    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
public void curator_f2349_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertTrue(cache.getCurrentChildren("/").keySet().contains("test"));    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/one"));    Assert.assertNull(cache.getCurrentChildren("/test/one"));}
public void curator_f2350_0() throws Exception
{    client.create().forPath("/outer");    client.create().forPath("/outer/foo");    client.create().forPath("/outer/test");    client.create().forPath("/outer/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client.usingNamespace("outer"), "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
public void curator_f2351_0() throws Exception
{    client.create().forPath("/outer");    client.create().forPath("/outer/foo");    client.create().forPath("/outer/test");    client.create().forPath("/outer/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client.usingNamespace("outer"), "/");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/foo");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/").keySet(), ImmutableSet.of("foo", "test"));    Assert.assertEquals(cache.getCurrentChildren("/foo").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
public void curator_f2352_0() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertNoMoreEvents();}
public void curator_f2353_0() throws Exception
{    client.create().forPath("/test", "".getBytes());    client.create().forPath("/test/1", "1".getBytes());    client.create().forPath("/test/2", "2".getBytes());    client.create().forPath("/test/3", "3".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
public void curator_f2354_0() throws Exception
{    client.create().forPath("/test");    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setCacheData(false));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/foo", "first".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.setData().forPath("/test/foo", "something new".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/foo");    assertNoMoreEvents();    Assert.assertNotNull(cache.getCurrentData("/test/foo"));        Assert.assertNull(cache.getCurrentData("/test/foo").getData());}
public void curator_f2355_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo", "one".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo", "one".getBytes());    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo", "two".getBytes());    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertNoMoreEvents();}
public void curator_f2356_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo", "one".getBytes());    cache = newTreeCacheWithListeners(client, "/test/foo");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo");    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo");    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertNoMoreEvents();}
public void curator_f2357_0() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/foo", "foo".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.create().withMode(CreateMode.EPHEMERAL).forPath("/test/me", "data".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/me");    Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/me", "data".getBytes(), true);    assertEvent(TreeCacheEvent.Type.INITIALIZED, null, null, true);    assertNoMoreEvents();}
public void curator_f2358_0() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/t"));    Assert.assertNull(cache.getCurrentChildren("/testing"));    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/test/o"));    Assert.assertNull(cache.getCurrentChildren("/test/onely"));    client.setData().forPath("/test/one", "sup!".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/one");    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");    client.delete().forPath("/test/one");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/one", "sup!".getBytes());    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    assertNoMoreEvents();}
public void curator_f2359_0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").disableZkWatches(true));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/test/o"));    Assert.assertNull(cache.getCurrentChildren("/test/onely"));    Assert.assertNull(cache.getCurrentChildren("/t"));    Assert.assertNull(cache.getCurrentChildren("/testing"));    assertNoMoreEvents();}
public void curator_f2360_0() throws Exception
{    TreeCache cache2 = newTreeCacheWithListeners(client, "/test");        cache2.getListenable().removeListener(eventListener);        final Semaphore semaphore = new Semaphore(0);    cache2.getListenable().addListener(new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            semaphore.release();        }    });    try {        client.create().forPath("/test");        cache = newTreeCacheWithListeners(client, "/test");        cache.start();        cache2.start();        assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");        assertEvent(TreeCacheEvent.Type.INITIALIZED);        semaphore.acquire(2);        client.create().forPath("/test/one", "hey there".getBytes());        assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");        Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");        semaphore.acquire();        Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "hey there");        client.setData().forPath("/test/one", "sup!".getBytes());        assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/one");        Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");        semaphore.acquire();        Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "sup!");        client.delete().forPath("/test/one");        assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/one", "sup!".getBytes());        Assert.assertNull(cache.getCurrentData("/test/one"));        semaphore.acquire();        Assert.assertNull(cache2.getCurrentData("/test/one"));        assertNoMoreEvents();        Assert.assertEquals(semaphore.availablePermits(), 0);    } finally {        CloseableUtils.closeQuietly(cache2);    }}
public void curator_f2361_0(CuratorFramework client, TreeCacheEvent event) throws Exception
{    semaphore.release();}
public void curator_f2362_0() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    cache.close();    assertNoMoreEvents();    client.delete().forPath("/test/one");    assertNoMoreEvents();}
public void curator_f2363_0() throws Exception
{        server.stop();        client.close();    initCuratorFramework();        cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertNoMoreEvents();        server.restart();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertNoMoreEvents();}
public void curator_f2364_0() throws Exception
{    client.create().forPath("/test");    cache = buildWithListeners(TreeCache.newBuilder(client, "/test"));        cache.getListenable().addListener(new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            if (event.getType() == Type.NODE_UPDATED) {                throw new RuntimeException("Test Exception");            }        }    });    cache.getUnhandledErrorListenable().removeListener(errorListener);    final AtomicBoolean isProcessed = new AtomicBoolean(false);    cache.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {        @Override        public void unhandledError(String message, Throwable e) {            Assert.assertFalse(isProcessed.compareAndSet(false, true));        }    });    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.setData().forPath("/test", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test");    assertNoMoreEvents();}
public void curator_f2365_0(CuratorFramework client, TreeCacheEvent event) throws Exception
{    if (event.getType() == Type.NODE_UPDATED) {        throw new RuntimeException("Test Exception");    }}
public void curator_f2366_0(String message, Throwable e)
{    Assert.assertFalse(isProcessed.compareAndSet(false, true));}
protected int curator_f2367_0(TreeCache cache)
{    return cache.getCurrentChildren("/root").size();}
protected TreeCache curator_f2368_0(CuratorFramework client, String path, final BlockingQueue<Event> events) throws Exception
{    TreeCache cache = new TreeCache(client, path);    TreeCacheListener listener = new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            if ((event.getData() != null) && (event.getData().getPath().startsWith("/root/"))) {                if (event.getType() == TreeCacheEvent.Type.NODE_ADDED) {                    events.add(new Event(EventType.ADDED, event.getData().getPath()));                }                if (event.getType() == TreeCacheEvent.Type.NODE_REMOVED) {                    events.add(new Event(EventType.DELETED, event.getData().getPath()));                }            }        }    };    cache.getListenable().addListener(listener);    cache.start();    return cache;}
public void curator_f2369_0(CuratorFramework client, TreeCacheEvent event) throws Exception
{    if ((event.getData() != null) && (event.getData().getPath().startsWith("/root/"))) {        if (event.getType() == TreeCacheEvent.Type.NODE_ADDED) {            events.add(new Event(EventType.ADDED, event.getData().getPath()));        }        if (event.getType() == TreeCacheEvent.Type.NODE_REMOVED) {            events.add(new Event(EventType.DELETED, event.getData().getPath()));        }    }}
public void curator_f2370_0() throws Exception
{    doTestGiantRandomDeepTree();}
public void curator_f2371_0() throws Exception
{    withDepth = true;    doTestGiantRandomDeepTree();}
private void curator_f2372_0() throws Exception
{    client.create().forPath("/tree", null);    CuratorFramework cl = client.usingNamespace("tree");    if (withDepth) {        cache = buildWithListeners(TreeCache.newBuilder(cl, "/").setMaxDepth(TEST_DEPTH));    } else {        cache = newTreeCacheWithListeners(cl, "/");    }    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    TestNode root = new TestNode("/", null);    int maxDepth = 0;    int adds = 0;    int removals = 0;    int updates = 0;    for (int i = 0; i < ITERATIONS; ++i) {                int depth = 0;        TestNode last = null;        TestNode node = root;        while (!node.children.isEmpty() && random.nextDouble() < DIVE_CHANCE) {                        last = node;            node = Iterables.get(node.children.values(), random.nextInt(node.children.size()));            ++depth;        }        maxDepth = Math.max(depth, maxDepth);                switch(random.nextInt(3)) {            case 0:                                if (node != root && node.children.isEmpty()) {                                        TestNode removed = last.children.remove(ZKPaths.getNodeFromPath(node.fullPath));                    Assert.assertSame(node, removed);                                        cl.delete().forPath(node.fullPath);                                        if (shouldSeeEventAt(node.fullPath)) {                        assertEvent(TreeCacheEvent.Type.NODE_REMOVED, node.fullPath);                    }                    ++removals;                }                break;            case 1:                                byte[] newData = new byte[10];                random.nextBytes(newData);                if (Arrays.equals(node.data, newData)) {                                        continue;                }                                node.data = newData;                                cl.setData().forPath(node.fullPath, node.data);                                if (shouldSeeEventAt(node.fullPath)) {                    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, node.fullPath, node.data);                }                ++updates;                break;            case 2:                                String name = Long.toHexString(random.nextLong());                if (node.children.containsKey(name)) {                                        continue;                }                                byte[] data = new byte[10];                random.nextBytes(data);                TestNode child = new TestNode(ZKPaths.makePath(node.fullPath, name), data);                node.children.put(name, child);                                cl.create().forPath(child.fullPath, child.data);                                if (shouldSeeEventAt(child.fullPath)) {                    assertEvent(TreeCacheEvent.Type.NODE_ADDED, child.fullPath, child.data);                }                ++adds;                break;        }                assertNodeEquals(cache.getCurrentData("/"), root);        assertTreeEquals(cache, root, 0);    }            System.out.println(String.format("maxDepth: %s, adds: %s, removals: %s, updates: %s", maxDepth, adds, removals, updates));    assertNoMoreEvents();}
private boolean curator_f2373_0(String fullPath)
{    return !withDepth || ZKPaths.split(fullPath).size() <= TEST_DEPTH;}
private void curator_f2374_0(TreeCache cache, TestNode expectedNode, int depth)
{    String path = expectedNode.fullPath;    Map<String, ChildData> cacheChildren = cache.getCurrentChildren(path);    Assert.assertNotNull(cacheChildren, path);    if (withDepth && depth == TEST_DEPTH) {        return;    }    Assert.assertEquals(cacheChildren.keySet(), expectedNode.children.keySet(), path);    for (Map.Entry<String, TestNode> entry : expectedNode.children.entrySet()) {        String nodeName = entry.getKey();        ChildData childData = cacheChildren.get(nodeName);        TestNode expectedChild = entry.getValue();        assertNodeEquals(childData, expectedChild);        assertTreeEquals(cache, expectedChild, depth + 1);    }}
private static void curator_f2375_0(ChildData actualChild, TestNode expectedNode)
{    String path = expectedNode.fullPath;    Assert.assertNotNull(actualChild, path);    Assert.assertEquals(actualChild.getData(), expectedNode.data, path);}
public void curator_f2376_0(ZooKeeperServer zks) throws IOException, InterruptedException
{    super.startup(new ChaosMonkeyZookeeperServer(zks));}
public void curator_f2377_0()
{    super.startup();    if (zks instanceof TestingZooKeeperMain.TestZooKeeperServer) {        ((TestingZooKeeperMain.TestZooKeeperServer) zks).noteStartup();    } else {        throw new RuntimeException("Unknown ZooKeeperServer: " + zks.getClass());    }}
public void curator_f2378_1(Request si)
{    long remaining = firstError != 0 ? LOCKOUT_DURATION_MS - (System.currentTimeMillis() - firstError) : 0;    if (si.type != ZooDefs.OpCode.createSession && si.type != ZooDefs.OpCode.sync && si.type != ZooDefs.OpCode.ping && firstError != 0 && remaining > 0) {                                ((NIOServerCnxn) si.cnxn).close();        return;    }            super.submitRequest(si);        if ((si.type == ZooDefs.OpCode.create) || (si.type == ZooDefs.OpCode.create2)) {        CreateRequest createRequest = new CreateRequest();        try {            ByteBuffer duplicate = si.request.duplicate();            duplicate.rewind();            ByteBufferInputStream.byteBuffer2Record(duplicate, createRequest);            if (createRequest.getPath().startsWith(CHAOS_ZNODE_PREFIX) && firstError == 0) {                firstError = System.currentTimeMillis();                                                ((NIOServerCnxn) si.cnxn).close();            }        } catch (Exception e) {                        ((NIOServerCnxn) si.cnxn).close();        }    }}
public void curator_f2379_0() throws Exception
{    ACLProvider provider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            return ZooDefs.Ids.OPEN_ACL_UNSAFE;        }        @Override        public List<ACL> getAclForPath(String path) {            if (path.equals("/base")) {                try {                    String testDigest = DigestAuthenticationProvider.generateDigest("test:test");                    return Collections.singletonList(new ACL(ZooDefs.Perms.ALL, new Id("digest", testDigest)));                } catch (NoSuchAlgorithmException e) {                    e.printStackTrace();                }            }            return getDefaultAcl();        }    };    RetryPolicy retryPolicy = new ExponentialBackoffRetry(timing.milliseconds(), 3);    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(retryPolicy).aclProvider(provider).authorization("digest", "test:test".getBytes());    CuratorFramework client = builder.build();    LeaderLatch latch = null;    try {        client.start();        latch = new LeaderLatch(client, "/base");        latch.start();        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        latch.close();        latch = null;        CuratorFramework noAuthClient = CuratorFrameworkFactory.newClient(server.getConnectString(), retryPolicy);        try {            noAuthClient.start();            final CountDownLatch noAuthLatch = new CountDownLatch(1);            UnhandledErrorListener listener = new UnhandledErrorListener() {                @Override                public void unhandledError(String message, Throwable e) {                    if (e instanceof KeeperException.NoAuthException) {                        noAuthLatch.countDown();                    }                }            };            noAuthClient.getUnhandledErrorListenable().addListener(listener);                                    latch = new LeaderLatch(noAuthClient, "/base/second");            latch.start();            Assert.assertTrue(timing.awaitLatch(noAuthLatch));        } finally {            CloseableUtils.closeQuietly(noAuthClient);        }    } finally {        CloseableUtils.closeQuietly(latch);        CloseableUtils.closeQuietly(client);    }}
public List<ACL> curator_f2380_0()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
public List<ACL> curator_f2381_0(String path)
{    if (path.equals("/base")) {        try {            String testDigest = DigestAuthenticationProvider.generateDigest("test:test");            return Collections.singletonList(new ACL(ZooDefs.Perms.ALL, new Id("digest", testDigest)));        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }    }    return getDefaultAcl();}
public void curator_f2382_0(String message, Throwable e)
{    if (e instanceof KeeperException.NoAuthException) {        noAuthLatch.countDown();    }}
public void curator_f2383_0() throws Exception
{    final int threadQty = 5;    ExecutorService executorService = Executors.newFixedThreadPool(threadQty);    List<Holder> holders = Collections.emptyList();    Timing2 timing = new Timing2();    ConnectionStateListenerManagerFactory managerFactory = ConnectionStateListenerManagerFactory.circuitBreaking(new RetryForever(timing.multiple(2).milliseconds()));    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).connectionStateListenerManagerFactory(managerFactory).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).build();    try {        client.start();        client.create().forPath("/hey");        Semaphore lostSemaphore = new Semaphore(0);        ConnectionStateListener unProxiedListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostSemaphore.release();                }            }            @Override            public boolean doNotProxy() {                return true;            }        };        client.getConnectionStateListenable().addListener(unProxiedListener);        holders = IntStream.range(0, threadQty).mapToObj(index -> {            Holder holder = new Holder();            holder.latch = new LeaderLatch(client, "/foo/bar/" + index) {                @Override                protected void handleStateChange(ConnectionState newState) {                    holder.stateChanges.offer(newState);                    super.handleStateChange(newState);                }            };            return holder;        }).collect(Collectors.toList());        holders.forEach(holder -> {            executorService.submit(() -> {                holder.latch.start();                Assert.assertTrue(holder.latch.await(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));                holder.isLockedLatch.countDown();                return null;            });            timing.awaitLatch(holder.isLockedLatch);        });        for (        int i = 0;         i < 4;         ++i) {            server.stop();            Assert.assertTrue(timing.acquireSemaphore(lostSemaphore));            server.restart();            timing.sleepABit();        }        for (Holder holder : holders) {            Assert.assertTrue(holder.latch.await(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.SUSPENDED);            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.LOST);            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.RECONNECTED);        }    } finally {        holders.forEach(holder -> CloseableUtils.closeQuietly(holder.latch));        CloseableUtils.closeQuietly(client);        executorService.shutdownNow();    }}
public void curator_f2384_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostSemaphore.release();    }}
public boolean curator_f2385_0()
{    return true;}
protected void curator_f2386_0(ConnectionState newState)
{    holder.stateChanges.offer(newState);    super.handleStateChange(newState);}
public void curator_f2387_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        LeaderLatch latch = new LeaderLatch(client, "/foo/bar");                latch.getLeader();    }}
public void curator_f2388_0() throws Exception
{    final String latchPath = "/foo/bar";    Timing2 timing = new Timing2();    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1))) {        client.start();        LeaderLatch latch1 = new LeaderLatch(client, latchPath, "1");        try (LeaderLatch latch2 = new LeaderLatch(client, latchPath, "2")) {            latch1.start();            latch1.await();                        latch2.start();            timing.sleepABit();            latch2.debugCheckLeaderShipLatch = new CountDownLatch(1);                        latch1.close();            latch1 = null;                        timing.sleepABit();                        latch2.reset();                        latch2.debugCheckLeaderShipLatch.countDown();            Assert.assertTrue(latch2.await(timing.forSessionSleep().forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            timing.sleepABit();            Assert.assertEquals(client.getChildren().forPath(latchPath).size(), 1);        } finally {            CloseableUtils.closeQuietly(latch1);        }    }}
public void curator_f2389_0() throws Exception
{    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = null;    for (int i = 0; i < 2; ++i) {        boolean isSessionIteration = (i == 0);        try {            client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(10000).sessionTimeoutMs(60000).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(isSessionIteration ? new SessionConnectionStateErrorPolicy() : new StandardConnectionStateErrorPolicy()).build();            final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();            ConnectionStateListener stateListener = new ConnectionStateListener() {                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                    states.add(newState.name());                }            };            client.getConnectionStateListenable().addListener(stateListener);            client.start();            latch = new LeaderLatch(client, "/test");            LeaderLatchListener listener = new LeaderLatchListener() {                @Override                public void isLeader() {                    states.add("true");                }                @Override                public void notLeader() {                    states.add("false");                }            };            latch.addListener(listener);            latch.start();            Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());            Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");            server.stop();            if (isSessionIteration) {                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());                server.restart();                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED.name());                Assert.assertNull(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS));            } else {                String s = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);                Assert.assertTrue("false".equals(s) || ConnectionState.SUSPENDED.name().equals(s));                s = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);                Assert.assertTrue("false".equals(s) || ConnectionState.SUSPENDED.name().equals(s));                server.restart();                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED.name());                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");            }        } finally {            CloseableUtils.closeQuietly(latch);            CloseableUtils.closeQuietly(client);        }    }}
public void curator_f2390_0(CuratorFramework client, ConnectionState newState)
{    states.add(newState.name());}
public void curator_f2391_0()
{    states.add("true");}
public void curator_f2392_0()
{    states.add("false");}
public void curator_f2393_0() throws Exception
{    Timing2 timing = new Timing2();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy()).build();    try {        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                states.add(newState.name());            }        };        client.getConnectionStateListenable().addListener(stateListener);        client.start();        latch = new LeaderLatch(client, "/test");        LeaderLatchListener listener = new LeaderLatchListener() {            @Override            public void isLeader() {                states.add("true");            }            @Override            public void notLeader() {                states.add("false");            }        };        latch.addListener(listener);        latch.start();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");        server.close();        List<String> next = Lists.newArrayList();        next.add(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        next.add(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.SUSPENDED.name(), "false")) || next.equals(Arrays.asList("false", ConnectionState.SUSPENDED.name())), next.toString());        Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST.name());        latch.close();        client.close();        timing.sleepABit();        states.clear();        server = new TestingServer();        client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).build();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        latch = new LeaderLatch(client, "/test");        latch.addListener(listener);        latch.start();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");        server.close();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());        next = Lists.newArrayList();        next.add(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.LOST.name(), "false")) || next.equals(Arrays.asList("false", ConnectionState.LOST.name())), next.toString());    } finally {        CloseableUtils.closeQuietly(latch);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2394_0(CuratorFramework client, ConnectionState newState)
{    states.add(newState.name());}
public void curator_f2395_0()
{    states.add("true");}
public void curator_f2396_0()
{    states.add("false");}
public void curator_f2397_0() throws Exception
{    server.stop();    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final AtomicBoolean resetCalled = new AtomicBoolean(false);        final CountDownLatch cancelStartTaskLatch = new CountDownLatch(1);        latch = new LeaderLatch(client, PATH_NAME) {            @Override            void reset() throws Exception {                resetCalled.set(true);                super.reset();            }            @Override            protected boolean cancelStartTask() {                if (super.cancelStartTask()) {                    cancelStartTaskLatch.countDown();                    return true;                }                return false;            }        };        latch.start();        latch.close();        latch = null;        Assert.assertTrue(timing.awaitLatch(cancelStartTaskLatch));        Assert.assertFalse(resetCalled.get());    } finally {        CloseableUtils.closeQuietly(latch);        TestCleanState.closeAndTestClean(client);    }}
 void curator_f2398_0() throws Exception
{    resetCalled.set(true);    super.reset();}
protected boolean curator_f2399_0()
{    if (super.cancelStartTask()) {        cancelStartTaskLatch.countDown();        return true;    }    return false;}
public void curator_f2400_0() throws Exception
{    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        latch = new LeaderLatch(client, PATH_NAME);        latch.debugResetWaitLatch = new CountDownLatch(1);                latch.start();                latch.reset();        timing.sleepABit();        latch.debugResetWaitLatch.countDown();        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath(PATH_NAME).size(), 1);    } finally {        CloseableUtils.closeQuietly(latch);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2401_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath(PATH_NAME);        LeaderLatch latch = new LeaderLatch(client, PATH_NAME);        latch.debugResetWaitLatch = new CountDownLatch(1);        latch.start();        latch.close();        timing.sleepABit();        latch.debugResetWaitLatch.countDown();        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath(PATH_NAME).size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2402_0() throws Exception
{    final int PARTICIPANT_QTY = 10;    List<LeaderLatch> latches = Lists.newArrayList();    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch countDownLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    countDownLatch.countDown();                }            }        });        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            latch.start();            latches.add(latch);        }        waitForALeader(latches, timing);        server.stop();        Assert.assertTrue(timing.awaitLatch(countDownLatch));        timing.forWaiting().sleepABit();        Assert.assertEquals(getLeaders(latches).size(), 0);        server.restart();                Assert.assertEquals(waitForALeader(latches, timing).size(), 1);    } finally {        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2403_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        countDownLatch.countDown();    }}
public void curator_f2404_0() throws Exception
{    final int PARTICIPANT_QTY = 10;    final int PARTICIPANT_ID = 2;    List<LeaderLatch> latches = Lists.newArrayList();    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            latch.start();            latches.add(latch);            waitForALeader(latches, timing);        }                latches.get(PARTICIPANT_ID).close();                        Assert.assertTrue(!latches.get(PARTICIPANT_ID - 1).hasLeadership());    } finally {                latches.remove(PARTICIPANT_ID);        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2405_0() throws Exception
{    final int LOOPS = 10;    for (int i = 0; i < LOOPS; ++i) {        System.out.println("TRY #" + i);        internalTestWaitingOnce();        Thread.sleep(10);    }}
private void curator_f2406_0() throws Exception
{    final int PARTICIPANT_QTY = 10;    ExecutorService executorService = Executors.newFixedThreadPool(PARTICIPANT_QTY);    ExecutorCompletionService<Void> service = new ExecutorCompletionService<Void>(executorService);    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final AtomicBoolean thereIsALeader = new AtomicBoolean(false);        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    LeaderLatch latch = new LeaderLatch(client, PATH_NAME);                    try {                        latch.start();                        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));                        Assert.assertTrue(thereIsALeader.compareAndSet(false, true));                        Thread.sleep((int) (10 * Math.random()));                        thereIsALeader.set(false);                    } finally {                        latch.close();                    }                    return null;                }            });        }        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            service.take().get();        }    } finally {        executorService.shutdownNow();        TestCleanState.closeAndTestClean(client);    }}
public Void curator_f2407_0() throws Exception
{    LeaderLatch latch = new LeaderLatch(client, PATH_NAME);    try {        latch.start();        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertTrue(thereIsALeader.compareAndSet(false, true));        Thread.sleep((int) (10 * Math.random()));        thereIsALeader.set(false);    } finally {        latch.close();    }    return null;}
public void curator_f2408_0() throws Exception
{    basic(Mode.START_IMMEDIATELY);}
public void curator_f2409_0() throws Exception
{    basic(Mode.START_IN_THREADS);}
public void curator_f2410_0() throws Exception
{    final int PARTICIPANT_QTY = 10;    final CountDownLatch timesSquare = new CountDownLatch(PARTICIPANT_QTY);    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService exec = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).setNameFormat("callbackSanity-%s").build());    List<LeaderLatch> latches = Lists.newArrayList();    for (int i = 0; i < PARTICIPANT_QTY; ++i) {        final LeaderLatch latch = new LeaderLatch(client, PATH_NAME);        latch.addListener(new LeaderLatchListener() {            boolean beenLeader = false;            @Override            public void isLeader() {                if (!beenLeader) {                    masterCounter.incrementAndGet();                    beenLeader = true;                    try {                        latch.reset();                    } catch (Exception e) {                        throw Throwables.propagate(e);                    }                } else {                    masterCounter.incrementAndGet();                    CloseableUtils.closeQuietly(latch);                    timesSquare.countDown();                }            }            @Override            public void notLeader() {                notLeaderCounter.incrementAndGet();            }        }, exec);        latches.add(latch);    }    try {        client.start();        for (LeaderLatch latch : latches) {            latch.start();        }        timesSquare.await();        Assert.assertEquals(masterCounter.get(), PARTICIPANT_QTY * 2);        Assert.assertEquals(notLeaderCounter.get(), PARTICIPANT_QTY);        for (LeaderLatch latch : latches) {            Assert.assertEquals(latch.getState(), LeaderLatch.State.CLOSED);        }    } finally {        for (LeaderLatch latch : latches) {            if (latch.getState() != LeaderLatch.State.CLOSED) {                CloseableUtils.closeQuietly(latch);            }        }        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2411_0()
{    if (!beenLeader) {        masterCounter.incrementAndGet();        beenLeader = true;        try {            latch.reset();        } catch (Exception e) {            throw Throwables.propagate(e);        }    } else {        masterCounter.incrementAndGet();        CloseableUtils.closeQuietly(latch);        timesSquare.countDown();    }}
public void curator_f2412_0()
{    notLeaderCounter.incrementAndGet();}
public void curator_f2413_0() throws Exception
{    final int PARTICIPANT_QTY = 10;    final int SILENT_QTY = 3;    final CountDownLatch timesSquare = new CountDownLatch(PARTICIPANT_QTY);    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService exec = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).setNameFormat("callbackNotifyLeader-%s").build());    List<LeaderLatch> latches = Lists.newArrayList();    for (int i = 0; i < PARTICIPANT_QTY; ++i) {        LeaderLatch.CloseMode closeMode = i < SILENT_QTY ? LeaderLatch.CloseMode.SILENT : LeaderLatch.CloseMode.NOTIFY_LEADER;        final LeaderLatch latch = new LeaderLatch(client, PATH_NAME, "", closeMode);        latch.addListener(new LeaderLatchListener() {            boolean beenLeader = false;            @Override            public void isLeader() {                if (!beenLeader) {                    masterCounter.incrementAndGet();                    beenLeader = true;                    try {                        latch.reset();                    } catch (Exception e) {                        throw Throwables.propagate(e);                    }                } else {                    masterCounter.incrementAndGet();                    CloseableUtils.closeQuietly(latch);                    timesSquare.countDown();                }            }            @Override            public void notLeader() {                notLeaderCounter.incrementAndGet();            }        }, exec);        latches.add(latch);    }    try {        client.start();        for (LeaderLatch latch : latches) {            latch.start();        }        timesSquare.await();        Assert.assertEquals(masterCounter.get(), PARTICIPANT_QTY * 2);        Assert.assertEquals(notLeaderCounter.get(), PARTICIPANT_QTY * 2 - SILENT_QTY);        for (LeaderLatch latch : latches) {            Assert.assertEquals(latch.getState(), LeaderLatch.State.CLOSED);        }    } finally {        for (LeaderLatch latch : latches) {            if (latch.getState() != LeaderLatch.State.CLOSED) {                CloseableUtils.closeQuietly(latch);            }        }        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2414_0()
{    if (!beenLeader) {        masterCounter.incrementAndGet();        beenLeader = true;        try {            latch.reset();        } catch (Exception e) {            throw Throwables.propagate(e);        }    } else {        masterCounter.incrementAndGet();        CloseableUtils.closeQuietly(latch);        timesSquare.countDown();    }}
public void curator_f2415_0()
{    notLeaderCounter.incrementAndGet();}
public void curator_f2416_0() throws Exception
{    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final LeaderLatch leader = new LeaderLatch(client, PATH_NAME);    final LeaderLatch notifiedLeader = new LeaderLatch(client, PATH_NAME, "", LeaderLatch.CloseMode.NOTIFY_LEADER);    leader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {        }        @Override        public void notLeader() {            masterCounter.incrementAndGet();        }    });    notifiedLeader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {        }        @Override        public void notLeader() {            notLeaderCounter.incrementAndGet();        }    });    try {        client.start();        leader.start();        timing.sleepABit();        notifiedLeader.start();        timing.sleepABit();        notifiedLeader.close();        timing.sleepABit();                leader.close(LeaderLatch.CloseMode.NOTIFY_LEADER);        Assert.assertEquals(leader.getState(), LeaderLatch.State.CLOSED);        Assert.assertEquals(notifiedLeader.getState(), LeaderLatch.State.CLOSED);        Assert.assertEquals(masterCounter.get(), 1);        Assert.assertEquals(notLeaderCounter.get(), 0);    } finally {        if (leader.getState() != LeaderLatch.State.CLOSED) {            CloseableUtils.closeQuietly(leader);        }        if (notifiedLeader.getState() != LeaderLatch.State.CLOSED) {            CloseableUtils.closeQuietly(notifiedLeader);        }        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2417_0()
{}
public void curator_f2418_0()
{    masterCounter.incrementAndGet();}
public void curator_f2419_0()
{}
public void curator_f2420_0()
{    notLeaderCounter.incrementAndGet();}
public void curator_f2421_0()
{    CloseableUtils.closeQuietly(server);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(5, 1000));    client.start();    final LeaderLatch leader = new LeaderLatch(client, PATH_NAME);    final CountDownLatch leaderCounter = new CountDownLatch(1);    final AtomicInteger leaderCount = new AtomicInteger(0);    final AtomicInteger notLeaderCount = new AtomicInteger(0);    leader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {            leaderCounter.countDown();            leaderCount.incrementAndGet();        }        @Override        public void notLeader() {            notLeaderCount.incrementAndGet();        }    });    try {        leader.start();        timing.sleepABit();                server = new TestingServer(server.getPort(), server.getTempDirectory());        Assert.assertTrue(timing.awaitLatch(leaderCounter), "Not elected leader");        Assert.assertEquals(leaderCount.get(), 1, "Elected too many times");        Assert.assertEquals(notLeaderCount.get(), 0, "Unelected too many times");    } catch (Exception e) {        Assert.fail("Unexpected exception", e);    } finally {        CloseableUtils.closeQuietly(leader);        TestCleanState.closeAndTestClean(client);        CloseableUtils.closeQuietly(server);    }}
public void curator_f2422_0()
{    leaderCounter.countDown();    leaderCount.incrementAndGet();}
public void curator_f2423_0()
{    notLeaderCount.incrementAndGet();}
private void curator_f2424_0(Mode mode) throws Exception
{        final int PARTICIPANT_QTY = 1;    List<LeaderLatch> latches = Lists.newArrayList();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            if (mode == Mode.START_IMMEDIATELY) {                latch.start();            }            latches.add(latch);        }        if (mode == Mode.START_IN_THREADS) {            ExecutorService service = Executors.newFixedThreadPool(latches.size());            for (final LeaderLatch latch : latches) {                service.submit(new Callable<Object>() {                    @Override                    public Object call() throws Exception {                        Thread.sleep((int) (100 * Math.random()));                        latch.start();                        return null;                    }                });            }            service.shutdown();        }        while (latches.size() > 0) {            List<LeaderLatch> leaders = waitForALeader(latches, timing);                        Assert.assertEquals(leaders.size(), 1);            LeaderLatch theLeader = leaders.get(0);            if (mode == Mode.START_IMMEDIATELY) {                                Assert.assertEquals(latches.indexOf(theLeader), 0);            }            theLeader.close();            latches.remove(theLeader);        }    } finally {        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2425_0() throws Exception
{    Thread.sleep((int) (100 * Math.random()));    latch.start();    return null;}
private List<LeaderLatch> curator_f2426_0(List<LeaderLatch> latches, Timing timing) throws InterruptedException
{    for (int i = 0; i < MAX_LOOPS; ++i) {        List<LeaderLatch> leaders = getLeaders(latches);        if (leaders.size() != 0) {            return leaders;        }        timing.sleepABit();    }    return Lists.newArrayList();}
private List<LeaderLatch> curator_f2427_0(Collection<LeaderLatch> latches)
{    List<LeaderLatch> leaders = Lists.newArrayList();    for (LeaderLatch latch : latches) {        if (latch.hasLeadership()) {            leaders.add(latch);        }    }    return leaders;}
public void curator_f2428_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    new LeaderLatch(client, "parent");}
public void curator_f2429_0() throws Exception
{    final int PARTICIPANT_QTY = 3;    List<ClientAndLatch> clients = Lists.newArrayList();    Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(PARTICIPANT_QTY);    try {        cluster.start();        List<InstanceSpec> instances = Lists.newArrayList(cluster.getInstances());        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            CuratorFramework client = CuratorFrameworkFactory.newClient(instances.get(i).getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));            LeaderLatch latch = new LeaderLatch(client, "/latch");            clients.add(new ClientAndLatch(client, latch, i));            client.start();            latch.start();        }        ClientAndLatch leader = waitForALeader(clients, timing);        Assert.assertNotNull(leader);        cluster.killServer(instances.get(leader.index));        Thread.sleep(timing.multiple(2).session());        leader = waitForALeader(clients, timing);        Assert.assertNotNull(leader);        Assert.assertEquals(getLeaders(clients).size(), 1);    } finally {        for (ClientAndLatch client : clients) {            CloseableUtils.closeQuietly(client.latch);            CloseableUtils.closeQuietly(client.client);        }        CloseableUtils.closeQuietly(cluster);    }}
private ClientAndLatch curator_f2430_0(List<ClientAndLatch> latches, Timing timing) throws InterruptedException
{    for (int i = 0; i < MAX_LOOPS; ++i) {        List<ClientAndLatch> leaders = getLeaders(latches);        if (leaders.size() != 0) {            return leaders.get(0);        }        timing.sleepABit();    }    return null;}
private List<ClientAndLatch> curator_f2431_0(Collection<ClientAndLatch> latches)
{    List<ClientAndLatch> leaders = Lists.newArrayList();    for (ClientAndLatch clientAndLatch : latches) {        if (clientAndLatch.latch.hasLeadership()) {            leaders.add(clientAndLatch);        }    }    return leaders;}
public void curator_f2432_0() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CountDownLatch exitLatch = new CountDownLatch(1);        BlockingQueue<Thread> threadExchange = new ArrayBlockingQueue<>(1);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                threadExchange.put(Thread.currentThread());                try {                    Thread.currentThread().join();                } finally {                    exitLatch.countDown();                }            }        };        selector = new LeaderSelector(client, PATH_NAME, listener);        selector.failedMutexReleaseCount = new AtomicInteger();        selector.start();        Thread leaderThread = timing.takeFromQueue(threadExchange);        leaderThread.interrupt();        Assert.assertTrue(timing.awaitLatch(exitLatch));                timing.sleepABit();        Assert.assertEquals(0, selector.failedMutexReleaseCount.get());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2433_0(CuratorFramework client) throws Exception
{    threadExchange.put(Thread.currentThread());    try {        Thread.currentThread().join();    } finally {        exitLatch.countDown();    }}
public void curator_f2434_0() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy()).build();    try {        final BlockingQueue<String> changes = Queues.newLinkedBlockingQueue();        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                changes.add(newState.name());            }        };        client.getConnectionStateListenable().addListener(stateListener);        client.start();        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                changes.add("leader");                try {                    Thread.currentThread().join();                } catch (InterruptedException e) {                    changes.add("release");                    Thread.currentThread().interrupt();                }            }        };        selector = new LeaderSelector(client, "/test", listener);        selector.start();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "leader");        server.close();        List<String> next = Lists.newArrayList();        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.SUSPENDED.name(), "release")) || next.equals(Arrays.asList("release", ConnectionState.SUSPENDED.name())), next.toString());        Assert.assertEquals(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST.name());        selector.close();        client.close();        timing.sleepABit();        changes.clear();        server = new TestingServer();        client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).build();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        selector = new LeaderSelector(client, "/test", listener);        selector.start();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "leader");        server.stop();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());        next = Lists.newArrayList();        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.LOST.name(), "release")) || next.equals(Arrays.asList("release", ConnectionState.LOST.name())), next.toString());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2435_0(CuratorFramework client, ConnectionState newState)
{    changes.add(newState.name());}
public void curator_f2436_0(CuratorFramework client) throws Exception
{    changes.add("leader");    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        changes.add("release");        Thread.currentThread().interrupt();    }}
public void curator_f2437_0() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener connectionStateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(connectionStateListener);        client.start();        final BlockingQueue<Thread> queue = new ArrayBlockingQueue<Thread>(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                queue.add(Thread.currentThread());                try {                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Thread leaderThread = timing.takeFromQueue(queue);        server.stop();        leaderThread.interrupt();        server.restart();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath("/leader").size(), 0);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2438_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
public void curator_f2439_0(CuratorFramework client) throws Exception
{    queue.add(Thread.currentThread());    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
public void curator_f2440_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2441_0() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                semaphore.release();                Thread.currentThread().join();            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        selector.interruptLeadership();        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2442_0(CuratorFramework client) throws Exception
{    semaphore.release();    Thread.currentThread().join();}
public void curator_f2443_0() throws Exception
{    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch isLeaderLatch = new CountDownLatch(1);        final CountDownLatch losingLeaderLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                isLeaderLatch.countDown();                try {                    Thread.currentThread().join();                } finally {                    losingLeaderLatch.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Assert.assertTrue(timing.awaitLatch(isLeaderLatch));        selector.interruptLeadership();        Assert.assertTrue(timing.awaitLatch(losingLeaderLatch));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2444_0(CuratorFramework client) throws Exception
{    isLeaderLatch.countDown();    try {        Thread.currentThread().join();    } finally {        losingLeaderLatch.countDown();    }}
public void curator_f2445_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2446_0() throws Exception
{    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch takeLeadershipLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                                takeLeadershipLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                } else if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                    throw new CancelLeadershipException();                }            }        };        selector = new LeaderSelector(client, "/leader", listener);        CountDownLatch debugLeadershipLatch = new CountDownLatch(1);        CountDownLatch debugLeadershipWaitLatch = new CountDownLatch(1);        selector.debugLeadershipLatch = debugLeadershipLatch;        selector.debugLeadershipWaitLatch = debugLeadershipWaitLatch;        selector.start();        Assert.assertTrue(timing.awaitLatch(debugLeadershipLatch));        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        timing.sleepABit();        debugLeadershipWaitLatch.countDown();        server.restart();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertFalse(takeLeadershipLatch.await(3, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2447_0(CuratorFramework client) throws Exception
{        takeLeadershipLatch.countDown();}
public void curator_f2448_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    } else if (newState == ConnectionState.LOST) {        lostLatch.countDown();        throw new CancelLeadershipException();    }}
public void curator_f2449_0() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).sessionTimeoutMs(timing.session()).build();    try {        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                Thread.sleep(10);                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 2));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2450_0(CuratorFramework client) throws Exception
{    Thread.sleep(10);    semaphore.release();}
public void curator_f2451_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2452_0() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectionTimeoutMs(timing.connection()).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).sessionTimeoutMs(timing.session()).build();    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                semaphore.release();                Thread.sleep(Integer.MAX_VALUE);            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    semaphore.release();                }            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        timing.acquireSemaphore(semaphore);        server.close();        timing.acquireSemaphore(semaphore);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2453_0(CuratorFramework client) throws Exception
{    semaphore.release();    Thread.sleep(Integer.MAX_VALUE);}
public void curator_f2454_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        semaphore.release();    }}
public void curator_f2455_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch interruptedLatch = new CountDownLatch(1);        final AtomicInteger leaderCount = new AtomicInteger(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderCount.incrementAndGet();                try {                    semaphore.release();                    try {                        Thread.currentThread().join();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        interruptedLatch.countDown();                    }                } finally {                    leaderCount.decrementAndGet();                }            }        };        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, listener);        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, listener);        boolean leaderSelector1Closed = false;        boolean leaderSelector2Closed = false;        leaderSelector1.start();        leaderSelector2.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(interruptedLatch));        timing.sleepABit();        boolean requeued1 = leaderSelector1.requeue();        boolean requeued2 = leaderSelector2.requeue();        Assert.assertTrue(requeued1);        Assert.assertTrue(requeued2);        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (leaderSelector1.hasLeadership()) {            leaderSelector1.close();            leaderSelector1Closed = true;        } else if (leaderSelector2.hasLeadership()) {            leaderSelector2.close();            leaderSelector2Closed = true;        } else {            fail("No leaderselector has leadership!");        }                Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (!leaderSelector1Closed) {            leaderSelector1.close();        }        if (!leaderSelector2Closed) {            leaderSelector2.close();        }    } finally {        client.close();    }}
public void curator_f2456_0(CuratorFramework client) throws Exception
{    leaderCount.incrementAndGet();    try {        semaphore.release();        try {            Thread.currentThread().join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            interruptedLatch.countDown();        }    } finally {        leaderCount.decrementAndGet();    }}
public void curator_f2457_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch interruptedLatch = new CountDownLatch(1);        final AtomicInteger leaderCount = new AtomicInteger(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderCount.incrementAndGet();                try {                    semaphore.release();                    try {                        Thread.currentThread().join();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        interruptedLatch.countDown();                    }                } finally {                    leaderCount.decrementAndGet();                }            }        };        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, listener);        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, listener);        boolean leaderSelector1Closed = false;        boolean leaderSelector2Closed = false;        leaderSelector1.autoRequeue();        leaderSelector2.autoRequeue();        leaderSelector1.start();        leaderSelector2.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        int port = server.getPort();        server.stop();        timing.sleepABit();        server = new TestingServer(port);        Assert.assertTrue(timing.awaitLatch(interruptedLatch));        timing.sleepABit();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (leaderSelector1.hasLeadership()) {            leaderSelector1.close();            leaderSelector1Closed = true;        } else if (leaderSelector2.hasLeadership()) {            leaderSelector2.close();            leaderSelector2Closed = true;        } else {            fail("No leaderselector has leadership!");        }                Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (!leaderSelector1Closed) {            leaderSelector1.close();        }        if (!leaderSelector2Closed) {            leaderSelector2.close();        }    } finally {        client.close();    }}
public void curator_f2458_0(CuratorFramework client) throws Exception
{    leaderCount.incrementAndGet();    try {        semaphore.release();        try {            Thread.currentThread().join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            interruptedLatch.countDown();        }    } finally {        leaderCount.decrementAndGet();    }}
public void curator_f2459_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.await(10, TimeUnit.SECONDS);            }        });        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.await(10, TimeUnit.SECONDS);            }        });        leaderSelector1.start();        leaderSelector2.start();        while (!leaderSelector1.hasLeadership() && !leaderSelector2.hasLeadership()) {            Thread.sleep(1000);        }        Assert.assertNotSame(leaderSelector1.hasLeadership(), leaderSelector2.hasLeadership());        LeaderSelector positiveLeader;        LeaderSelector negativeLeader;        if (leaderSelector1.hasLeadership()) {            positiveLeader = leaderSelector1;            negativeLeader = leaderSelector2;        } else {            positiveLeader = leaderSelector2;            negativeLeader = leaderSelector1;        }        negativeLeader.close();        Thread.sleep(1000);        Assert.assertNotSame(positiveLeader.hasLeadership(), negativeLeader.hasLeadership());        Assert.assertTrue(positiveLeader.hasLeadership());        positiveLeader.close();        Thread.sleep(1000);        Assert.assertFalse(positiveLeader.hasLeadership());    } finally {        client.close();    }}
public void curator_f2460_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2461_0(CuratorFramework client) throws Exception
{    latch.await(10, TimeUnit.SECONDS);}
public void curator_f2462_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2463_0(CuratorFramework client) throws Exception
{    latch.await(10, TimeUnit.SECONDS);}
public void curator_f2464_0() throws Exception
{    final int LEADER_QTY = 5;    final int REPEAT_QTY = 3;    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final BlockingQueue<Integer> leaderList = new LinkedBlockingQueue<Integer>();        List<LeaderSelector> selectors = Lists.newArrayList();        for (int i = 0; i < LEADER_QTY; ++i) {            final int ourIndex = i;            LeaderSelector leaderSelector = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {                @Override                public void takeLeadership(CuratorFramework client) throws Exception {                    timing.sleepABit();                    leaderList.add(ourIndex);                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            });            selectors.add(leaderSelector);        }        List<Integer> localLeaderList = Lists.newArrayList();        for (int i = 1; i <= REPEAT_QTY; ++i) {            for (LeaderSelector leaderSelector : selectors) {                if (i > 1) {                    leaderSelector.requeue();                } else {                    leaderSelector.start();                }            }            while (localLeaderList.size() != (i * selectors.size())) {                Integer polledIndex = leaderList.poll(10, TimeUnit.SECONDS);                Assert.assertNotNull(polledIndex);                localLeaderList.add(polledIndex);            }            timing.sleepABit();        }        for (LeaderSelector leaderSelector : selectors) {            leaderSelector.close();        }        System.out.println(localLeaderList);        for (int i = 0; i < REPEAT_QTY; ++i) {            Set<Integer> uniques = Sets.newHashSet();            for (int j = 0; j < selectors.size(); ++j) {                Assert.assertTrue(localLeaderList.size() > 0);                int thisIndex = localLeaderList.remove(0);                Assert.assertFalse(uniques.contains(thisIndex));                uniques.add(thisIndex);            }        }    } finally {        client.close();    }}
public void curator_f2465_0(CuratorFramework client) throws Exception
{    timing.sleepABit();    leaderList.add(ourIndex);}
public void curator_f2466_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2467_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                List<String> names = client.getChildren().forPath("/leader");                Assert.assertTrue(names.size() > 0);                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        LeaderSelector selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        InstanceSpec connectionInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        cluster.killServer(connectionInstance);        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f2468_0(CuratorFramework client) throws Exception
{    List<String> names = client.getChildren().forPath("/leader");    Assert.assertTrue(names.size() > 0);    semaphore.release();}
public void curator_f2469_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2470_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.sync().forPath("/");        final AtomicReference<Exception> error = new AtomicReference<Exception>(null);        final AtomicReference<String> lockNode = new AtomicReference<String>(null);        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch internalLostLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                try {                    List<String> names = client.getChildren().forPath("/leader");                    if (names.size() != 1) {                        semaphore.release();                        Exception exception = new Exception("Names size isn't 1: " + names.size());                        error.set(exception);                        return;                    }                    lockNode.set(names.get(0));                    semaphore.release();                    if (!timing.multiple(4).awaitLatch(internalLostLatch)) {                        error.set(new Exception("internalLostLatch await failed"));                    }                } finally {                    lostLatch.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    internalLostLatch.countDown();                }            }        };        LeaderSelector selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));        if (error.get() != null) {            throw new AssertionError(error.get());        }        Collection<InstanceSpec> instances = cluster.getInstances();        cluster.stop();        Assert.assertTrue(timing.multiple(4).awaitLatch(lostLatch));        timing.sleepABit();        Assert.assertFalse(selector.hasLeadership());        Assert.assertNotNull(lockNode.get());        cluster = new TestingCluster(instances.toArray(new InstanceSpec[instances.size()]));        cluster.start();        try {                        client.delete().forPath(ZKPaths.makePath("/leader", lockNode.get()));        } catch (Exception ignore) {                }        Assert.assertTrue(semaphore.availablePermits() == 0);        Assert.assertFalse(selector.hasLeadership());        selector.requeue();        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f2471_0(CuratorFramework client) throws Exception
{    try {        List<String> names = client.getChildren().forPath("/leader");        if (names.size() != 1) {            semaphore.release();            Exception exception = new Exception("Names size isn't 1: " + names.size());            error.set(exception);            return;        }        lockNode.set(names.get(0));        semaphore.release();        if (!timing.multiple(4).awaitLatch(internalLostLatch)) {            error.set(new Exception("internalLostLatch await failed"));        }    } finally {        lostLatch.countDown();    }}
public void curator_f2472_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        internalLostLatch.countDown();    }}
public static void curator_f2473_0()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, ChaosMonkeyCnxnFactory.class.getName());}
public static void curator_f2474_0()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
public void curator_f2475_0() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(1, 500)).sessionTimeoutMs(30000).build();    final TestLeaderSelectorListener listener = new TestLeaderSelectorListener();    LeaderSelector leaderSelector1 = new LeaderSelector(client, ChaosMonkeyCnxnFactory.CHAOS_ZNODE, listener);    LeaderSelector leaderSelector2 = null;    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        leaderSelector1.start();                        Assert.assertTrue(listener.reconnected.await(10, TimeUnit.SECONDS), "Connection has not been lost");                Assert.assertEquals(listener.takeLeadership.getCount(), 1);                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");                leaderSelector2 = new LeaderSelector(client, ChaosMonkeyCnxnFactory.CHAOS_ZNODE, listener);        leaderSelector2.start();        Assert.assertTrue(listener.takeLeadership.await(1, TimeUnit.SECONDS));    } finally {        try {            leaderSelector1.close();        } catch (IllegalStateException e) {            Assert.fail(e.getMessage());        }        try {            if (leaderSelector2 != null) {                leaderSelector2.close();            }        } catch (IllegalStateException e) {            Assert.fail(e.getMessage());        }        client.close();    }}
public void curator_f2476_1(CuratorFramework client) throws Exception
{        takeLeadership.countDown();    }
public void curator_f2477_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnected.countDown();    }}
public void curator_f2478_1() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(2, 100)).connectionTimeoutMs(1000).sessionTimeoutMs(60000).build();    final CountDownLatch latch = new CountDownLatch(1);    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                                if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        }).forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE_PREFIX + "foo-");        Assert.assertTrue(latch.await(30, TimeUnit.SECONDS), "Callback has not been called");                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");    } finally {        client.close();    }}
public void curator_f2479_1(CuratorFramework client, CuratorEvent event) throws Exception
{        if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
public void curator_f2480_1() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(0, 0)).connectionTimeoutMs(1000).sessionTimeoutMs(60000).build();    final CountDownLatch latch = new CountDownLatch(1);    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                                if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        }).forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE_PREFIX + "foo-");        Assert.assertTrue(latch.await(30, TimeUnit.SECONDS), "Callback has not been called");                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");    } finally {        client.close();    }}
public void curator_f2481_1(CuratorFramework client, CuratorEvent event) throws Exception
{        if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
public void curator_f2482_0() throws Exception
{    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.countDown();                Thread.currentThread().join();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/ls", listener);        selector.setId("A is A");        selector.start();        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Participant leader = selector.getLeader();        Assert.assertTrue(leader.isLeader());        Assert.assertEquals(leader.getId(), "A is A");        Collection<Participant> participants = selector.getParticipants();        Assert.assertEquals(participants.size(), 1);        Assert.assertEquals(participants.iterator().next().getId(), "A is A");        Assert.assertEquals(participants.iterator().next().getId(), selector.getId());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2483_0(CuratorFramework client) throws Exception
{    latch.countDown();    Thread.currentThread().join();}
public void curator_f2484_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2485_0() throws Exception
{    final int SELECTOR_QTY = 10;    List<LeaderSelector> selectors = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch leaderLatch = new CountDownLatch(1);        final CountDownLatch workingLatch = new CountDownLatch(SELECTOR_QTY);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderLatch.countDown();                Thread.currentThread().join();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        for (int i = 0; i < SELECTOR_QTY; ++i) {            LeaderSelector selector = new LeaderSelector(client, "/ls", listener) {                @Override                void doWork() throws Exception {                    workingLatch.countDown();                    super.doWork();                }            };            selector.setId(Integer.toString(i));            selectors.add(selector);        }        for (LeaderSelector selector : selectors) {            selector.start();        }        Assert.assertTrue(leaderLatch.await(10, TimeUnit.SECONDS));        Assert.assertTrue(workingLatch.await(10, TimeUnit.SECONDS));                Thread.sleep(1000);        Collection<Participant> participants = selectors.get(0).getParticipants();        for (int i = 1; i < selectors.size(); ++i) {            Assert.assertEquals(participants, selectors.get(i).getParticipants());        }        Set<String> ids = Sets.newHashSet();        int leaderCount = 0;        for (Participant participant : participants) {            if (participant.isLeader()) {                ++leaderCount;            }            Assert.assertFalse(ids.contains(participant.getId()));            ids.add(participant.getId());        }        Assert.assertEquals(leaderCount, 1);        Set<String> expectedIds = Sets.newHashSet();        for (int i = 0; i < SELECTOR_QTY; ++i) {            expectedIds.add(Integer.toString(i));        }        Assert.assertEquals(expectedIds, ids);    } finally {        for (LeaderSelector selector : selectors) {            CloseableUtils.closeQuietly(selector);        }        CloseableUtils.closeQuietly(client);    }}
public void curator_f2486_0(CuratorFramework client) throws Exception
{    leaderLatch.countDown();    Thread.currentThread().join();}
public void curator_f2487_0(CuratorFramework client, ConnectionState newState)
{}
 void curator_f2488_0() throws Exception
{    workingLatch.countDown();    super.doWork();}
public void curator_f2489_0() throws Exception
{    Timing timing = new Timing();    LeaderSelector leaderSelector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().retryPolicy(new ExponentialBackoffRetry(100, 3)).connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).build();    try {        client.start();        MyLeaderSelectorListener listener = new MyLeaderSelectorListener();        ExecutorService executorPool = Executors.newFixedThreadPool(20);        leaderSelector = new LeaderSelector(client, "/test", threadFactory, executorPool, listener);        leaderSelector.autoRequeue();        leaderSelector.start();        timing.sleepABit();        Assert.assertEquals(listener.getLeaderCount(), 1);    } finally {        CloseableUtils.closeQuietly(leaderSelector);        CloseableUtils.closeQuietly(client);    }}
public int curator_f2490_0()
{    return leaderCount.get();}
public void curator_f2491_0(CuratorFramework curatorFramework) throws Exception
{    ourThread = Thread.currentThread();    try {        leaderCount.incrementAndGet();        while (!Thread.currentThread().isInterrupted()) {            Thread.sleep(1000);        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        leaderCount.decrementAndGet();    }}
public void curator_f2492_0(CuratorFramework curatorFramework, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        if (ourThread != null) {            ourThread.interrupt();        }    }}
public void curator_f2493_0() throws IOException
{    shouldRun = false;}
 boolean curator_f2494_0()
{    return hasAcquired;}
public void curator_f2495_0(CuratorFramework client, ConnectionState newState)
{    hasAcquired = false;}
 static SemaphoreClient curator_f2496_0()
{    return activeClient.get();}
public Void curator_f2497_0() throws Exception
{    shouldRun = true;    client.getConnectionStateListenable().addListener(this);    try {        while (shouldRun) {            try {                acquireAndRun();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();                                throw e;            } catch (Exception e) {                Thread.sleep(CLIENT_EXCEPTION_HANDLER_SLEEP_TIME_SECS * 1000L);            }        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
private void curator_f2498_0() throws Exception
{    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, semaphorePath, MAX_SEMAPHORE_LEASES);    Lease lease = semaphore.acquire();    try {        hasAcquired = true;        if (activeClient.compareAndSet(null, this)) {            throw new Exception("Multiple acquirers");        }        try {            while (hasAcquired && shouldRun) {                operation.call();            }        } finally {            if (activeClient.compareAndSet(this, null)) {                                throw new Exception("Bad release");            }        }    } finally {        semaphore.returnLease(lease);    }}
 synchronized void curator_f2499_0() throws InterruptedException
{    while (available == 0) {        wait();    }    --available;    notifyAll();}
 synchronized void curator_f2500_0(int qty)
{    available += qty;    notifyAll();}
public void curator_f2501_0() throws Exception
{    server.close();    final int LARGE_QTY = 10000;    System.setProperty("jute.maxbuffer", "" + LARGE_QTY);    server = new TestingServer();    try {        Timing timing = new Timing();        ChildReaper reaper = null;        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            for (int i = 0; i < LARGE_QTY; ++i) {                if ((i % 1000) == 0) {                    System.out.println(i);                }                client.create().creatingParentsIfNeeded().forPath("/big/node-" + i);            }            try {                client.getChildren().forPath("/big");                Assert.fail("Should have been a connection loss");            } catch (KeeperException.ConnectionLossException e) {                        }            final CountDownLatch latch = new CountDownLatch(1);            reaper = new ChildReaper(client, "/big", Reaper.Mode.REAP_UNTIL_DELETE, 1) {                @Override                protected void warnMaxChildren(String path, Stat stat) {                    latch.countDown();                    super.warnMaxChildren(path, stat);                }            };            reaper.setMaxChildren(100);            reaper.start();            Assert.assertTrue(timing.awaitLatch(latch));        } finally {            CloseableUtils.closeQuietly(reaper);            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("jute.maxbuffer");    }}
protected void curator_f2502_0(String path, Stat stat)
{    latch.countDown();    super.warnMaxChildren(path, stat);}
public void curator_f2503_0() throws Exception
{    server.close();    final int LARGE_QTY = 10000;    final int SMALL_QTY = 100;    System.setProperty("jute.maxbuffer", "" + LARGE_QTY);    server = new TestingServer();    try {        Timing timing = new Timing();        ChildReaper reaper = null;        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            for (int i = 0; i < LARGE_QTY; ++i) {                if ((i % 1000) == 0) {                    System.out.println(i);                }                client.create().creatingParentsIfNeeded().forPath("/big/node-" + i);                if (i < SMALL_QTY) {                    client.create().creatingParentsIfNeeded().forPath("/small/node-" + i);                }            }            reaper = new ChildReaper(client, "/foo", Reaper.Mode.REAP_UNTIL_DELETE, 1);            reaper.start();            reaper.addPath("/big");            reaper.addPath("/small");            int count = -1;            for (int i = 0; (i < 10) && (count != 0); ++i) {                timing.sleepABit();                count = client.checkExists().forPath("/small").getNumChildren();            }            Assert.assertEquals(count, 0);        } finally {            CloseableUtils.closeQuietly(reaper);            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("jute.maxbuffer");    }}
public void curator_f2504_0() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        Random r = new Random();        int nonEmptyNodes = 0;        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));            if (r.nextBoolean()) {                client.create().forPath("/test/" + Integer.toString(i) + "/foo");                ++nonEmptyNodes;            }        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), nonEmptyNodes);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2505_0() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2506_0() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    LeaderLatch otherLeader = null;    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        otherLeader = new LeaderLatch(client, "/test-leader");        otherLeader.start();        otherLeader.await();        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, ChildReaper.newExecutorService(), 1, "/test-leader");        reaper.start();        timing.forWaiting().sleepABit();                Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 10);        CloseableUtils.closeQuietly(otherLeader);        timing.forWaiting().sleepABit();        stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        if (otherLeader != null && otherLeader.getState() == LeaderLatch.State.STARTED) {            CloseableUtils.closeQuietly(otherLeader);        }        CloseableUtils.closeQuietly(client);    }}
public void curator_f2507_0() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test1/" + Integer.toString(i));            client.create().creatingParentsIfNeeded().forPath("/test2/" + Integer.toString(i));            client.create().creatingParentsIfNeeded().forPath("/test3/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test2", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        reaper.addPath("/test1");        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test1");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.checkExists().forPath("/test2");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.checkExists().forPath("/test3");        Assert.assertEquals(stat.getNumChildren(), 10);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2508_0() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).namespace("foo").build();    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.usingNamespace(null).checkExists().forPath("/foo/test");        Assert.assertNotNull(stat);        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
protected InterProcessLock curator_f2509_0(CuratorFramework client)
{    return new InterProcessMultiLock(client, Arrays.asList(LOCK_PATH_1, LOCK_PATH_2));}
public void curator_f2510_0() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        InterProcessLock goodLock = new InterProcessMutex(client, LOCK_PATH_1);        final InterProcessLock otherGoodLock = new InterProcessMutex(client, LOCK_PATH_2);        InterProcessLock badLock = new InterProcessLock() {            @Override            public void acquire() throws Exception {                otherGoodLock.acquire();            }            @Override            public boolean acquire(long time, TimeUnit unit) throws Exception {                return otherGoodLock.acquire(time, unit);            }            @Override            public void release() throws Exception {                throw new Exception("foo");            }            @Override            public boolean isAcquiredInThisProcess() {                return otherGoodLock.isAcquiredInThisProcess();            }        };        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(goodLock, badLock));        try {            lock.acquire();            lock.release();            Assert.fail();        } catch (Exception e) {                }        Assert.assertFalse(goodLock.isAcquiredInThisProcess());        Assert.assertTrue(otherGoodLock.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2511_0() throws Exception
{    otherGoodLock.acquire();}
public boolean curator_f2512_0(long time, TimeUnit unit) throws Exception
{    return otherGoodLock.acquire(time, unit);}
public void curator_f2513_0() throws Exception
{    throw new Exception("foo");}
public boolean curator_f2514_0()
{    return otherGoodLock.isAcquiredInThisProcess();}
public void curator_f2515_0() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean goodLockWasLocked = new AtomicBoolean(false);        final InterProcessLock goodLock = new InterProcessMutex(client, LOCK_PATH_1);        InterProcessLock badLock = new InterProcessLock() {            @Override            public void acquire() throws Exception {                if (goodLock.isAcquiredInThisProcess()) {                    goodLockWasLocked.set(true);                }                throw new Exception("foo");            }            @Override            public boolean acquire(long time, TimeUnit unit) throws Exception {                throw new Exception("foo");            }            @Override            public void release() throws Exception {                throw new Exception("foo");            }            @Override            public boolean isAcquiredInThisProcess() {                return false;            }        };        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(goodLock, badLock));        try {            lock.acquire();            Assert.fail();        } catch (Exception e) {                }        Assert.assertFalse(goodLock.isAcquiredInThisProcess());        Assert.assertTrue(goodLockWasLocked.get());    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2516_0() throws Exception
{    if (goodLock.isAcquiredInThisProcess()) {        goodLockWasLocked.set(true);    }    throw new Exception("foo");}
public boolean curator_f2517_0(long time, TimeUnit unit) throws Exception
{    throw new Exception("foo");}
public void curator_f2518_0() throws Exception
{    throw new Exception("foo");}
public boolean curator_f2519_0()
{    return false;}
protected InterProcessLock curator_f2520_0(CuratorFramework client)
{    return new InterProcessMutex(client, LOCK_PATH);}
public void curator_f2521_0() throws Exception
{    Schema schemaRoot = Schema.builderForRecipeParent("/foo").name("root").build();    Schema schemaLocks = Schema.builderForRecipe("/foo").name("locks").build();    SchemaSet schemaSet = new SchemaSet(Lists.newArrayList(schemaRoot, schemaLocks), false);    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(schemaSet).build();    try {        client.start();        InterProcessMutex lock = new InterProcessMutex(client, "/foo");        lock.acquire();        lock.release();    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2522_0() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH);        ExecutorService executorService = Executors.newCachedThreadPool();        final CountDownLatch revokeLatch = new CountDownLatch(1);        final CountDownLatch lockLatch = new CountDownLatch(1);        Future<Void> f1 = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                RevocationListener<InterProcessMutex> listener = new RevocationListener<InterProcessMutex>() {                    @Override                    public void revocationRequested(InterProcessMutex lock) {                        revokeLatch.countDown();                    }                };                lock.makeRevocable(listener);                lock.acquire();                lockLatch.countDown();                revokeLatch.await();                lock.release();                return null;            }        });        Future<Void> f2 = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                Assert.assertTrue(lockLatch.await(10, TimeUnit.SECONDS));                Collection<String> nodes = lock.getParticipantNodes();                Assert.assertEquals(nodes.size(), 1);                Revoker.attemptRevoke(client, nodes.iterator().next());                InterProcessMutex l2 = new InterProcessMutex(client, LOCK_PATH);                Assert.assertTrue(l2.acquire(5, TimeUnit.SECONDS));                l2.release();                return null;            }        });        f2.get();        f1.get();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Void curator_f2523_0() throws Exception
{    RevocationListener<InterProcessMutex> listener = new RevocationListener<InterProcessMutex>() {        @Override        public void revocationRequested(InterProcessMutex lock) {            revokeLatch.countDown();        }    };    lock.makeRevocable(listener);    lock.acquire();    lockLatch.countDown();    revokeLatch.await();    lock.release();    return null;}
public void curator_f2524_0(InterProcessMutex lock)
{    revokeLatch.countDown();}
public Void curator_f2525_0() throws Exception
{    Assert.assertTrue(lockLatch.await(10, TimeUnit.SECONDS));    Collection<String> nodes = lock.getParticipantNodes();    Assert.assertEquals(nodes.size(), 1);    Revoker.attemptRevoke(client, nodes.iterator().next());    InterProcessMutex l2 = new InterProcessMutex(client, LOCK_PATH);    Assert.assertTrue(l2.acquire(5, TimeUnit.SECONDS));    l2.release();    return null;}
public void curator_f2526_0() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH, new StandardLockInternalsDriver() {            @Override            public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception {                String ourPath;                if (lockNodeBytes != null) {                    ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path, lockNodeBytes);                } else {                    ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path);                }                return ourPath;            }        });                lock.acquire(10, TimeUnit.SECONDS);        Assert.assertTrue(lock.isAcquiredInThisProcess());                Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertNotNull(client.checkExists().forPath(LOCK_PATH));                String actualLockPath = lock.getLockPath();        lock.release();        Assert.assertNull(client.checkExists().forPath(actualLockPath));    } finally {        TestCleanState.closeAndTestClean(client);    }}
public String curator_f2527_0(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception
{    String ourPath;    if (lockNodeBytes != null) {        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path, lockNodeBytes);    } else {        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path);    }    return ourPath;}
public void curator_f2528_0() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        InterProcessLock lock = makeLock(client);        try (Locker locker = new Locker(lock, timing.milliseconds(), TimeUnit.MILLISECONDS)) {            Assert.assertTrue(lock.isAcquiredInThisProcess());        }        Assert.assertFalse(lock.isAcquiredInThisProcess());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2529_0() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (!newState.isConnected()) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        final AtomicBoolean isFirst = new AtomicBoolean(true);        final Object result = new Object();        ExecutorCompletionService<Object> service = new ExecutorCompletionService<Object>(Executors.newFixedThreadPool(2));        for (int i = 0; i < 2; ++i) {            service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    InterProcessLock lock = makeLock(client);                    lock.acquire();                    try {                        if (isFirst.compareAndSet(true, false)) {                            timing.sleepABit();                            server.stop();                            Assert.assertTrue(timing.forWaiting().awaitLatch(latch));                            server.restart();                        }                    } finally {                        try {                            lock.release();                        } catch (KeeperException.SessionExpiredException dummy) {                                                }                    }                    return result;                }            });        }        for (int i = 0; i < 2; ++i) {            Assert.assertEquals(service.take().get(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), result);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2530_0(CuratorFramework client, ConnectionState newState)
{    if (!newState.isConnected()) {        latch.countDown();    }}
public Object curator_f2531_0() throws Exception
{    InterProcessLock lock = makeLock(client);    lock.acquire();    try {        if (isFirst.compareAndSet(true, false)) {            timing.sleepABit();            server.stop();            Assert.assertTrue(timing.forWaiting().awaitLatch(latch));            server.restart();        }    } finally {        try {            lock.release();        } catch (KeeperException.SessionExpiredException dummy) {                }    }    return result;}
public void curator_f2532_0() throws Exception
{    final Timing2 timing = new Timing2();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        final InterProcessLock mutex1 = makeLock(client);        final InterProcessLock mutex2 = makeLock(client);        final Semaphore semaphore = new Semaphore(0);        ExecutorCompletionService<Object> service = new ExecutorCompletionService<Object>(Executors.newFixedThreadPool(2));        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                mutex1.acquire();                semaphore.release();                Thread.sleep(1000000);                return null;            }        });        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                mutex2.acquire();                semaphore.release();                Thread.sleep(1000000);                return null;            }        });        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.forSessionSleep().acquireSemaphore(semaphore, 1));    } finally {        client.close();    }}
public Object curator_f2533_0() throws Exception
{    mutex1.acquire();    semaphore.release();    Thread.sleep(1000000);    return null;}
public Object curator_f2534_0() throws Exception
{    mutex2.acquire();    semaphore.release();    Thread.sleep(1000000);    return null;}
public void curator_f2535_0() throws Exception
{    if (!ZKPaths.hasContainerSupport()) {        System.out.println("ZooKeeper version does not support Containers. Skipping test");        return;    }    server.close();    System.setProperty("znode.container.checkIntervalMs", "10");    try {        server = new TestingServer();        final int THREAD_QTY = 10;        ExecutorService service = null;        final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            List<Future<Object>> threads = Lists.newArrayList();            service = Executors.newCachedThreadPool();            for (int i = 0; i < THREAD_QTY; ++i) {                Future<Object> t = service.submit(new Callable<Object>() {                    @Override                    public Object call() throws Exception {                        InterProcessLock lock = makeLock(client);                        lock.acquire();                        try {                            Thread.sleep(10);                        } finally {                            lock.release();                        }                        return null;                    }                });                threads.add(t);            }            for (Future<Object> t : threads) {                t.get();            }            new Timing().sleepABit();            Assert.assertNull(client.checkExists().forPath(LOCK_BASE_PATH));        } finally {            if (service != null) {                service.shutdownNow();            }            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("znode.container.checkIntervalMs");    }}
public Object curator_f2536_0() throws Exception
{    InterProcessLock lock = makeLock(client);    lock.acquire();    try {        Thread.sleep(10);    } finally {        lock.release();    }    return null;}
public void curator_f2537_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new ExponentialBackoffRetry(100, 3)).namespace("test").build();    client.start();    try {        InterProcessLock mutex = makeLock(client);        mutex.acquire(10, TimeUnit.SECONDS);        Thread.sleep(100);        mutex.release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2538_0() throws Exception
{    final int THREAD_QTY = 10;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        final AtomicBoolean hasLock = new AtomicBoolean(false);        final AtomicBoolean isFirst = new AtomicBoolean(true);        final Semaphore semaphore = new Semaphore(1);        final InterProcessLock mutex = makeLock(client);        List<Future<Object>> threads = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (int i = 0; i < THREAD_QTY; ++i) {            Future<Object> t = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    semaphore.acquire();                    mutex.acquire();                    Assert.assertTrue(hasLock.compareAndSet(false, true));                    try {                        if (isFirst.compareAndSet(true, false)) {                            semaphore.release(THREAD_QTY - 1);                            while (semaphore.availablePermits() > 0) {                                Thread.sleep(100);                            }                        } else {                            Thread.sleep(100);                        }                    } finally {                        mutex.release();                        hasLock.set(false);                    }                    return null;                }            });            threads.add(t);        }        for (Future<Object> t : threads) {            t.get();        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2539_0() throws Exception
{    semaphore.acquire();    mutex.acquire();    Assert.assertTrue(hasLock.compareAndSet(false, true));    try {        if (isFirst.compareAndSet(true, false)) {            semaphore.release(THREAD_QTY - 1);            while (semaphore.availablePermits() > 0) {                Thread.sleep(100);            }        } else {            Thread.sleep(100);        }    } finally {        mutex.release();        hasLock.set(false);    }    return null;}
public void curator_f2540_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        waitLatchForBar = new CountDownLatch(1);        countLatchForBar = new CountDownLatch(1);        final InterProcessLock mutex = makeLock(client);        Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(countLatchForBar.await(10, TimeUnit.SECONDS));                try {                    mutex.acquire(10, TimeUnit.SECONDS);                    Assert.fail();                } catch (Exception e) {                                } finally {                    waitLatchForBar.countDown();                }                return null;            }        });        foo(mutex);        Assert.assertFalse(mutex.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2541_0() throws Exception
{    Assert.assertTrue(countLatchForBar.await(10, TimeUnit.SECONDS));    try {        mutex.acquire(10, TimeUnit.SECONDS);        Assert.fail();    } catch (Exception e) {        } finally {        waitLatchForBar.countDown();    }    return null;}
public void curator_f2542_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        InterProcessLock mutex = makeLock(client);        foo(mutex);        Assert.assertFalse(mutex.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
private void curator_f2543_0(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    bar(mutex);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();}
private void curator_f2544_0(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    if (countLatchForBar != null) {        countLatchForBar.countDown();        waitLatchForBar.await(10, TimeUnit.SECONDS);    }    snafu(mutex);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();}
private void curator_f2545_0(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();    Assert.assertTrue(mutex.isAcquiredInThisProcess());}
public void curator_f2546_0() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        client1.start();        client2.start();        final InterProcessLock mutexForClient1 = makeLock(client1);        final InterProcessLock mutexForClient2 = makeLock(client2);        final CountDownLatch latchForClient1 = new CountDownLatch(1);        final CountDownLatch latchForClient2 = new CountDownLatch(1);        final CountDownLatch acquiredLatchForClient1 = new CountDownLatch(1);        final CountDownLatch acquiredLatchForClient2 = new CountDownLatch(1);        final AtomicReference<Exception> exceptionRef = new AtomicReference<Exception>();        ExecutorService service = Executors.newCachedThreadPool();        Future<Object> future1 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                try {                    mutexForClient1.acquire(10, TimeUnit.SECONDS);                    acquiredLatchForClient1.countDown();                    latchForClient1.await(10, TimeUnit.SECONDS);                    mutexForClient1.release();                } catch (Exception e) {                    exceptionRef.set(e);                }                return null;            }        });        Future<Object> future2 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                try {                    mutexForClient2.acquire(10, TimeUnit.SECONDS);                    acquiredLatchForClient2.countDown();                    latchForClient2.await(10, TimeUnit.SECONDS);                    mutexForClient2.release();                } catch (Exception e) {                    exceptionRef.set(e);                }                return null;            }        });        while (!mutexForClient1.isAcquiredInThisProcess() && !mutexForClient2.isAcquiredInThisProcess()) {            Thread.sleep(1000);            Assert.assertFalse(future1.isDone() && future2.isDone());        }        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() != mutexForClient2.isAcquiredInThisProcess());        Thread.sleep(1000);        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() || mutexForClient2.isAcquiredInThisProcess());        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() != mutexForClient2.isAcquiredInThisProcess());        Exception exception = exceptionRef.get();        if (exception != null) {            throw exception;        }        if (mutexForClient1.isAcquiredInThisProcess()) {            latchForClient1.countDown();            Assert.assertTrue(acquiredLatchForClient2.await(10, TimeUnit.SECONDS));            Assert.assertTrue(mutexForClient2.isAcquiredInThisProcess());        } else {            latchForClient2.countDown();            Assert.assertTrue(acquiredLatchForClient1.await(10, TimeUnit.SECONDS));            Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess());        }        future1.get();        future2.get();    } finally {        TestCleanState.closeAndTestClean(client1);        TestCleanState.closeAndTestClean(client2);    }}
public Object curator_f2547_0() throws Exception
{    try {        mutexForClient1.acquire(10, TimeUnit.SECONDS);        acquiredLatchForClient1.countDown();        latchForClient1.await(10, TimeUnit.SECONDS);        mutexForClient1.release();    } catch (Exception e) {        exceptionRef.set(e);    }    return null;}
public Object curator_f2548_0() throws Exception
{    try {        mutexForClient2.acquire(10, TimeUnit.SECONDS);        acquiredLatchForClient2.countDown();        latchForClient2.await(10, TimeUnit.SECONDS);        mutexForClient2.release();    } catch (Exception e) {        exceptionRef.set(e);    }    return null;}
public void curator_f2549_0() throws Exception
{    final int READERS = 20;    final int WRITERS = 8;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(READERS + WRITERS);        final CountDownLatch readLatch = new CountDownLatch(READERS);        final InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        final CountDownLatch exitLatch = new CountDownLatch(1);        ExecutorCompletionService<Void> service = new ExecutorCompletionService<Void>(Executors.newCachedThreadPool());        for (int i = 0; i < READERS; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    lock.readLock().acquire();                    try {                        latch.countDown();                        readLatch.countDown();                        exitLatch.await();                    } finally {                        lock.readLock().release();                    }                    return null;                }            });        }        for (int i = 0; i < WRITERS; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    Assert.assertTrue(readLatch.await(10, TimeUnit.SECONDS));                                        latch.countDown();                    lock.writeLock().acquire();                    try {                        exitLatch.await();                    } finally {                        lock.writeLock().release();                    }                    return null;                }            });        }        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Collection<String> readers = lock.readLock().getParticipantNodes();        Collection<String> writers = lock.writeLock().getParticipantNodes();        Assert.assertEquals(readers.size(), READERS);        Assert.assertEquals(writers.size(), WRITERS);        exitLatch.countDown();        for (int i = 0; i < (READERS + WRITERS); ++i) {            service.take().get();        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Void curator_f2550_0() throws Exception
{    lock.readLock().acquire();    try {        latch.countDown();        readLatch.countDown();        exitLatch.await();    } finally {        lock.readLock().release();    }    return null;}
public Void curator_f2551_0() throws Exception
{    Assert.assertTrue(readLatch.await(10, TimeUnit.SECONDS));        latch.countDown();    lock.writeLock().acquire();    try {        exitLatch.await();    } finally {        lock.writeLock().release();    }    return null;}
public void curator_f2552_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        lock.readLock().acquire();        Assert.assertFalse(lock.writeLock().acquire(5, TimeUnit.SECONDS));        lock.readLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2553_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        ExecutorService t1 = Executors.newSingleThreadExecutor();        ExecutorService t2 = Executors.newSingleThreadExecutor();        final CountDownLatch latch = new CountDownLatch(1);        final CountDownLatch releaseLatch = new CountDownLatch(1);        Future<Object> f1 = t1.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                lock.writeLock().acquire();                latch.countDown();                try {                    releaseLatch.await();                } finally {                    lock.writeLock().release();                }                return null;            }        });        Future<Object> f2 = t2.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));                Assert.assertFalse(lock.readLock().acquire(5, TimeUnit.SECONDS));                return null;            }        });        f2.get();        releaseLatch.countDown();        f1.get();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2554_0() throws Exception
{    lock.writeLock().acquire();    latch.countDown();    try {        releaseLatch.await();    } finally {        lock.writeLock().release();    }    return null;}
public Object curator_f2555_0() throws Exception
{    Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    Assert.assertFalse(lock.readLock().acquire(5, TimeUnit.SECONDS));    return null;}
public void curator_f2556_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        lock.writeLock().acquire();        Assert.assertTrue(lock.readLock().acquire(5, TimeUnit.SECONDS));        lock.writeLock().release();        lock.readLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2557_0() throws Exception
{    final int CONCURRENCY = 8;    final int ITERATIONS = 100;    final Random random = new Random();    final AtomicInteger concurrentCount = new AtomicInteger(0);    final AtomicInteger maxConcurrentCount = new AtomicInteger(0);    final AtomicInteger writeCount = new AtomicInteger(0);    final AtomicInteger readCount = new AtomicInteger(0);    List<Future<Void>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < CONCURRENCY; ++i) {        Future<Void> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));                client.start();                try {                    InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");                    for (int i = 0; i < ITERATIONS; ++i) {                        if (random.nextInt(100) < 10) {                            doLocking(lock.writeLock(), concurrentCount, maxConcurrentCount, random, 1);                            writeCount.incrementAndGet();                        } else {                            doLocking(lock.readLock(), concurrentCount, maxConcurrentCount, random, Integer.MAX_VALUE);                            readCount.incrementAndGet();                        }                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        });        futures.add(future);    }    for (Future<Void> future : futures) {        future.get();    }    System.out.println("Writes: " + writeCount.get() + " - Reads: " + readCount.get() + " - Max Reads: " + maxConcurrentCount.get());    Assert.assertTrue(writeCount.get() > 0);    Assert.assertTrue(readCount.get() > 0);    Assert.assertTrue(maxConcurrentCount.get() > 1);}
public Void curator_f2558_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        for (int i = 0; i < ITERATIONS; ++i) {            if (random.nextInt(100) < 10) {                doLocking(lock.writeLock(), concurrentCount, maxConcurrentCount, random, 1);                writeCount.incrementAndGet();            } else {                doLocking(lock.readLock(), concurrentCount, maxConcurrentCount, random, Integer.MAX_VALUE);                readCount.incrementAndGet();            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
public void curator_f2559_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final byte[] nodeData = new byte[] { 1, 2, 3, 4 };        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock", nodeData);                nodeData[0] = 5;        lock.writeLock().acquire();        List<String> children = client.getChildren().forPath("/lock");        Assert.assertEquals(1, children.size());        byte[] dataInZk = client.getData().forPath("/lock/" + children.get(0));        Assert.assertNotNull(dataInZk);        Assert.assertEquals(new byte[] { 1, 2, 3, 4 }, dataInZk);        lock.writeLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
private void curator_f2560_0(InterProcessLock lock, AtomicInteger concurrentCount, AtomicInteger maxConcurrentCount, Random random, int maxAllowed) throws Exception
{    try {        Assert.assertTrue(lock.acquire(10, TimeUnit.SECONDS));        int localConcurrentCount;        synchronized (this) {            localConcurrentCount = concurrentCount.incrementAndGet();            if (localConcurrentCount > maxConcurrentCount.get()) {                maxConcurrentCount.set(localConcurrentCount);            }        }        Assert.assertTrue(localConcurrentCount <= maxAllowed, "" + localConcurrentCount);        Thread.sleep(random.nextInt(9) + 1);    } finally {        synchronized (this) {            concurrentCount.decrementAndGet();            lock.release();        }    }}
public void curator_f2561_0() throws Exception
{        final String SEMAPHORE_PATH = "/test";    final int MAX_SEMAPHORES = 1;    final int NUM_CLIENTS = 10;    ExecutorService executor = Executors.newFixedThreadPool(NUM_CLIENTS);    final Timing timing = new Timing();        final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.forWaiting().milliseconds(), timing.connection(), new RetryOneTime(1));    try {        client.start();                InterProcessSemaphoreV2.debugAcquireLatch = new CountDownLatch(1);                InterProcessSemaphoreV2.debugFailedGetChildrenLatch = new CountDownLatch(1);        final CountDownLatch isReadyLatch = new CountDownLatch(NUM_CLIENTS);        final BlockingQueue<Boolean> acquiredQueue = Queues.newLinkedBlockingQueue();        Runnable runner = new Runnable() {            @Override            public void run() {                while (!Thread.currentThread().isInterrupted()) {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, SEMAPHORE_PATH, MAX_SEMAPHORES);                    Lease lease = null;                    try {                        isReadyLatch.countDown();                        lease = semaphore.acquire();                        acquiredQueue.add(true);                        timing.sleepABit();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        break;                    } catch (KeeperException e) {                        try {                            timing.sleepABit();                        } catch (InterruptedException e2) {                            Thread.currentThread().interrupt();                            break;                        }                    } catch (Exception ignore) {                                        } finally {                        if (lease != null) {                            semaphore.returnLease(lease);                        }                    }                }            }        };        for (int i = 0; i < NUM_CLIENTS; ++i) {            executor.execute(runner);        }        Assert.assertTrue(timing.awaitLatch(isReadyLatch));        timing.sleepABit();        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch restartedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    restartedLatch.countDown();                }            }        });        server.stop();        Assert.assertTrue(timing.multiple(1.25).awaitLatch(lostLatch));                InterProcessSemaphoreV2.debugAcquireLatch.countDown();                Assert.assertTrue(timing.awaitLatch(InterProcessSemaphoreV2.debugFailedGetChildrenLatch));        server.restart();        Assert.assertTrue(timing.awaitLatch(restartedLatch));        for (int i = 0; i < NUM_CLIENTS; ++i) {                        Boolean polled = acquiredQueue.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);            if ((polled == null) || !polled) {                Assert.fail("Semaphores not reacquired after restart");            }        }    } finally {        executor.shutdownNow();        CloseableUtils.closeQuietly(client);    }}
public void curator_f2562_0()
{    while (!Thread.currentThread().isInterrupted()) {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, SEMAPHORE_PATH, MAX_SEMAPHORES);        Lease lease = null;        try {            isReadyLatch.countDown();            lease = semaphore.acquire();            acquiredQueue.add(true);            timing.sleepABit();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            break;        } catch (KeeperException e) {            try {                timing.sleepABit();            } catch (InterruptedException e2) {                Thread.currentThread().interrupt();                break;            }        } catch (Exception ignore) {                } finally {            if (lease != null) {                semaphore.returnLease(lease);            }        }    }}
public void curator_f2563_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        restartedLatch.countDown();    }}
public void curator_f2564_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final SharedCount count = new SharedCount(client, "/foo/count", 1);        count.start();        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", count);        ExecutorService service = Executors.newCachedThreadPool();        final CountDownLatch latch1 = new CountDownLatch(1);        final CountDownLatch latch2 = new CountDownLatch(1);        Future<Object> future1 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Lease lease = semaphore.acquire(timing.seconds(), TimeUnit.SECONDS);                Assert.assertNotNull(lease);                latch1.countDown();                lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                Assert.assertNotNull(lease);                latch2.countDown();                return null;            }        });        Future<Object> future2 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(latch1.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));                                timing.sleepABit();                Assert.assertTrue(count.trySetCount(2));                                timing.sleepABit();                Assert.assertTrue(latch2.await(0, TimeUnit.SECONDS));                return null;            }        });        future1.get();        future2.get();        count.close();    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2565_0() throws Exception
{    Lease lease = semaphore.acquire(timing.seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(lease);    latch1.countDown();    lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(lease);    latch2.countDown();    return null;}
public Object curator_f2566_0() throws Exception
{    Assert.assertTrue(latch1.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        timing.sleepABit();    Assert.assertTrue(count.trySetCount(2));        timing.sleepABit();    Assert.assertTrue(latch2.await(0, TimeUnit.SECONDS));    return null;}
public void curator_f2567_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client1 = null;    CuratorFramework client2 = null;    InterProcessSemaphoreV2 semaphore1;    InterProcessSemaphoreV2 semaphore2;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client1.start();        client2.start();        semaphore1 = new InterProcessSemaphoreV2(client1, "/test", 1);        semaphore2 = new InterProcessSemaphoreV2(client2, "/test", 1);        Lease lease = semaphore2.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        lease.close();        lease = semaphore1.acquire(10, TimeUnit.SECONDS);        Assert.assertNotNull(lease);                client1.close();        client1 = null;        Assert.assertNotNull(semaphore2.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client1);        TestCleanState.closeAndTestClean(client2);    }}
public void curator_f2568_0() throws Exception
{    final int CLIENT_QTY = 10;    final int LOOP_QTY = 100;    final Random random = new Random();    final int SESSION_MAX = random.nextInt(75) + 25;    final Timing timing = new Timing();    List<Future<Object>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    final Counter counter = new Counter();    final AtomicInteger available = new AtomicInteger(SESSION_MAX);    for (int i = 0; i < CLIENT_QTY; ++i) {        futures.add(service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                client.start();                try {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", SESSION_MAX);                    for (int i = 0; i < LOOP_QTY; ++i) {                        long start = System.currentTimeMillis();                        int thisQty;                        synchronized (available) {                            if ((System.currentTimeMillis() - start) > 10000) {                                throw new TimeoutException();                            }                            while (available.get() == 0) {                                available.wait(timing.forWaiting().milliseconds());                            }                            thisQty = (available.get() > 1) ? (random.nextInt(available.get()) + 1) : 1;                            available.addAndGet(-1 * thisQty);                            Assert.assertTrue(available.get() >= 0);                        }                        Collection<Lease> leases = semaphore.acquire(thisQty, timing.forWaiting().seconds(), TimeUnit.SECONDS);                        Assert.assertNotNull(leases);                        try {                            synchronized (counter) {                                counter.currentCount += thisQty;                                if (counter.currentCount > counter.maxCount) {                                    counter.maxCount = counter.currentCount;                                }                            }                            Thread.sleep(random.nextInt(25));                        } finally {                            synchronized (counter) {                                counter.currentCount -= thisQty;                            }                            semaphore.returnAll(leases);                            synchronized (available) {                                available.addAndGet(thisQty);                                available.notifyAll();                            }                        }                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        }));    }    for (Future<Object> f : futures) {        f.get();    }    synchronized (counter) {        Assert.assertTrue(counter.currentCount == 0);        Assert.assertTrue(counter.maxCount > 0);        Assert.assertTrue(counter.maxCount <= SESSION_MAX);        System.out.println(counter.maxCount);    }}
public Object curator_f2569_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", SESSION_MAX);        for (int i = 0; i < LOOP_QTY; ++i) {            long start = System.currentTimeMillis();            int thisQty;            synchronized (available) {                if ((System.currentTimeMillis() - start) > 10000) {                    throw new TimeoutException();                }                while (available.get() == 0) {                    available.wait(timing.forWaiting().milliseconds());                }                thisQty = (available.get() > 1) ? (random.nextInt(available.get()) + 1) : 1;                available.addAndGet(-1 * thisQty);                Assert.assertTrue(available.get() >= 0);            }            Collection<Lease> leases = semaphore.acquire(thisQty, timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(leases);            try {                synchronized (counter) {                    counter.currentCount += thisQty;                    if (counter.currentCount > counter.maxCount) {                        counter.maxCount = counter.currentCount;                    }                }                Thread.sleep(random.nextInt(25));            } finally {                synchronized (counter) {                    counter.currentCount -= thisQty;                }                semaphore.returnAll(leases);                synchronized (available) {                    available.addAndGet(thisQty);                    available.notifyAll();                }            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
public void curator_f2570_0() throws Exception
{    final Timing timing = new Timing();    final int CLIENT_QTY = 10;    final int MAX = CLIENT_QTY / 2;    final AtomicInteger maxLeases = new AtomicInteger(0);    final AtomicInteger activeQty = new AtomicInteger(0);    final AtomicInteger uses = new AtomicInteger(0);    List<Future<Object>> futures = Lists.newArrayList();    ExecutorService service = Executors.newFixedThreadPool(CLIENT_QTY);    for (int i = 0; i < CLIENT_QTY; ++i) {        Future<Object> f = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                client.start();                try {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX);                    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                    Assert.assertNotNull(lease);                    uses.incrementAndGet();                    try {                        synchronized (maxLeases) {                            int qty = activeQty.incrementAndGet();                            if (qty > maxLeases.get()) {                                maxLeases.set(qty);                            }                        }                        timing.sleepABit();                    } finally {                        activeQty.decrementAndGet();                        lease.close();                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        });        futures.add(f);    }    for (Future<Object> f : futures) {        f.get();    }    Assert.assertEquals(uses.get(), CLIENT_QTY);    Assert.assertEquals(maxLeases.get(), MAX);}
public Object curator_f2571_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        uses.incrementAndGet();        try {            synchronized (maxLeases) {                int qty = activeQty.incrementAndGet();                if (qty > maxLeases.get()) {                    maxLeases.set(qty);                }            }            timing.sleepABit();        } finally {            activeQty.decrementAndGet();            lease.close();        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
public void curator_f2572_0() throws Exception
{    final Timing timing = new Timing();    final int MAX_LEASES = 11;    final int THREADS = 100;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Stepper latch = new Stepper();        final Random random = new Random();        final Counter counter = new Counter();        ExecutorService service = Executors.newCachedThreadPool();        ExecutorCompletionService<Object> completionService = new ExecutorCompletionService<Object>(service);        for (int i = 0; i < THREADS; ++i) {            completionService.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);                    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                    if (lease == null) {                        throw new Exception("timed out");                    }                    try {                        synchronized (counter) {                            ++counter.currentCount;                            if (counter.currentCount > counter.maxCount) {                                counter.maxCount = counter.currentCount;                            }                            counter.notifyAll();                        }                        latch.await();                    } finally {                        synchronized (counter) {                            --counter.currentCount;                        }                        semaphore.returnLease(lease);                    }                    return null;                }            });        }        int remaining = THREADS;        while (remaining > 0) {            int times = Math.min(random.nextInt(5) + 1, remaining);            latch.countDown(times);            remaining -= times;            Thread.sleep(random.nextInt(100) + 1);        }        for (int i = 0; i < THREADS; ++i) {            completionService.take();        }        timing.sleepABit();        synchronized (counter) {            Assert.assertTrue(counter.currentCount == 0);            Assert.assertTrue(counter.maxCount > 0);            Assert.assertTrue(counter.maxCount <= MAX_LEASES);            System.out.println(counter.maxCount);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2573_0() throws Exception
{    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);    if (lease == null) {        throw new Exception("timed out");    }    try {        synchronized (counter) {            ++counter.currentCount;            if (counter.currentCount > counter.maxCount) {                counter.maxCount = counter.currentCount;            }            counter.notifyAll();        }        latch.await();    } finally {        synchronized (counter) {            --counter.currentCount;        }        semaphore.returnLease(lease);    }    return null;}
public void curator_f2574_0() throws Exception
{    final int THREAD_QTY = 10;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        ExecutorService service = Executors.newFixedThreadPool(THREAD_QTY);        for (int i = 0; i < THREAD_QTY; ++i) {            service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    Lease lease = semaphore.acquire();                    try {                        Thread.sleep(1);                    } finally {                        lease.close();                    }                    return null;                }            });        }        service.shutdown();        Assert.assertTrue(service.awaitTermination(10, TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2575_0() throws Exception
{    Lease lease = semaphore.acquire();    try {        Thread.sleep(1);    } finally {        lease.close();    }    return null;}
public void curator_f2576_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2577_0() throws Exception
{    final int MAX_LEASES = 3;    Timing timing = new Timing();    List<Lease> leases = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        for (int i = 0; i < MAX_LEASES; ++i) {            InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);            Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(lease);            leases.add(lease);        }        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNull(lease);        leases.remove(0).close();        Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        for (Lease l : leases) {            CloseableUtils.closeQuietly(l);        }        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2578_0() throws Exception
{    final int LEASES = 3;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    List<Lease> leases = Lists.newArrayList();    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", LEASES);        for (int i = 0; i < LEASES; ++i) {            leases.add(semaphore.acquire());        }        Assert.assertEquals(semaphore.getParticipantNodes().size(), LEASES);    } finally {        for (Lease l : leases) {            CloseableUtils.closeQuietly(l);        }        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2579_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    ChildReaper childReaper = null;    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test/lock", 1);        semaphore.returnLease(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertTrue(client.getChildren().forPath("/test").size() > 0);        childReaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_GONE, ChildReaper.newExecutorService(), 1, "/test-leader", InterProcessSemaphoreV2.LOCK_SCHEMA);        childReaper.start();        timing.forWaiting().sleepABit();        try {            List<String> children = client.getChildren().forPath("/test");            Assert.assertEquals(children.size(), 0, "All children of /test should have been reaped");        } catch (KeeperException.NoNodeException ok) {                }    } finally {        CloseableUtils.closeQuietly(childReaper);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2580_0() throws Exception
{    final Timing timing = new Timing();    final ExecutorService executor = Executors.newFixedThreadPool(1);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        final List<String> childNodes = client.getChildren().forPath("/test/leases");        Assert.assertEquals(childNodes.size(), 1);        final CountDownLatch nodeCreatedLatch = new CountDownLatch(1);        client.getChildren().usingWatcher(new CuratorWatcher() {            @Override            public void process(WatchedEvent event) throws Exception {                if (event.getType() == Watcher.Event.EventType.NodeCreated) {                    nodeCreatedLatch.countDown();                }            }        }).forPath("/test/leases");        final Future<Lease> leaseFuture = executor.submit(new Callable<Lease>() {            @Override            public Lease call() throws Exception {                return semaphore.acquire(timing.forWaiting().multiple(2).seconds(), TimeUnit.SECONDS);            }        });                timing.awaitLatch(nodeCreatedLatch);        String newNode = null;        for (String c : client.getChildren().forPath("/test/leases")) {            if (!childNodes.contains(c)) {                newNode = c;            }        }        Assert.assertNotNull(newNode);                client.delete().forPath("/test/leases/" + newNode);                lease.close();        lease = leaseFuture.get();        Assert.assertNotNull(lease);        lease.close();        Assert.assertEquals(client.getChildren().forPath("/test/leases").size(), 0);                Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        executor.shutdownNow();        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2581_0(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeCreated) {        nodeCreatedLatch.countDown();    }}
public Lease curator_f2582_0() throws Exception
{    return semaphore.acquire(timing.forWaiting().multiple(2).seconds(), TimeUnit.SECONDS);}
public void curator_f2583_0() throws Exception
{        final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 s1 = new InterProcessSemaphoreV2(client, "/test", 1);        final InterProcessSemaphoreV2 s2 = new InterProcessSemaphoreV2(client, "/test", 1);        final InterProcessSemaphoreV2 s3 = new InterProcessSemaphoreV2(client, "/test", 1);        final CountDownLatch debugWaitLatch = s2.debugWaitLatch = new CountDownLatch(1);                Lease lease = s1.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);                Future<Object> handle = Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                s2.acquire();                return null;            }        });                Assert.assertTrue(timing.awaitLatch(debugWaitLatch));                handle.cancel(true);                timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath("/test/leases").size(), 1);                s1.returnLease(lease);        Assert.assertNotNull(s3.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
public Object curator_f2584_0() throws Exception
{    s2.acquire();    return null;}
public void curator_f2585_0() throws Exception
{    final int CLIENT_QTY = 10;    final Timing timing = new Timing();    final String PATH = "/foo/bar/lock";    ExecutorService executorService = Executors.newFixedThreadPool(CLIENT_QTY);    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executorService);    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();        final AtomicReference<String> connectionString = new AtomicReference<String>(cluster.getConnectString());        final EnsembleProvider provider = new EnsembleProvider() {            @Override            public void setConnectionString(String connectionString) {            }            @Override            public boolean updateServerListEnabled() {                return false;            }            @Override            public void start() throws Exception {            }            @Override            public String getConnectionString() {                return connectionString.get();            }            @Override            public void close() throws IOException {            }        };        final Semaphore acquiredSemaphore = new Semaphore(0);        final AtomicInteger acquireCount = new AtomicInteger(0);        final CountDownLatch suspendedLatch = new CountDownLatch(CLIENT_QTY);        for (int i = 0; i < CLIENT_QTY; ++i) {            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = CuratorFrameworkFactory.builder().ensembleProvider(provider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();                    try {                        final Semaphore suspendedSemaphore = new Semaphore(0);                        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {                            @Override                            public void stateChanged(CuratorFramework client, ConnectionState newState) {                                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                                    suspendedLatch.countDown();                                    suspendedSemaphore.release();                                }                            }                        });                        client.start();                        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, PATH, 1);                        while (!Thread.currentThread().isInterrupted()) {                            Lease lease = null;                            try {                                lease = semaphore.acquire();                                acquiredSemaphore.release();                                acquireCount.incrementAndGet();                                suspendedSemaphore.acquire();                            } catch (Exception e) {                                                        } finally {                                if (lease != null) {                                    acquireCount.decrementAndGet();                                    CloseableUtils.closeQuietly(lease);                                }                            }                        }                    } finally {                        TestCleanState.closeAndTestClean(client);                    }                    return null;                }            });        }        Assert.assertTrue(timing.acquireSemaphore(acquiredSemaphore));        Assert.assertEquals(1, acquireCount.get());        cluster.close();        timing.awaitLatch(suspendedLatch);        timing.forWaiting().sleepABit();        Assert.assertEquals(0, acquireCount.get());        cluster = new TestingCluster(3);        cluster.start();        connectionString.set(cluster.getConnectString());        timing.forWaiting().sleepABit();        Assert.assertTrue(timing.acquireSemaphore(acquiredSemaphore));        timing.forWaiting().sleepABit();        Assert.assertEquals(1, acquireCount.get());    } finally {        executorService.shutdown();        executorService.awaitTermination(10, TimeUnit.SECONDS);        executorService.shutdownNow();        CloseableUtils.closeQuietly(cluster);    }}
public void curator_f2586_0(String connectionString)
{}
public boolean curator_f2587_0()
{    return false;}
public void curator_f2588_0() throws Exception
{}
public String curator_f2589_0()
{    return connectionString.get();}
public void curator_f2590_0() throws IOException
{}
public Void curator_f2591_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().ensembleProvider(provider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();    try {        final Semaphore suspendedSemaphore = new Semaphore(0);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                    suspendedLatch.countDown();                    suspendedSemaphore.release();                }            }        });        client.start();        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, PATH, 1);        while (!Thread.currentThread().isInterrupted()) {            Lease lease = null;            try {                lease = semaphore.acquire();                acquiredSemaphore.release();                acquireCount.incrementAndGet();                suspendedSemaphore.acquire();            } catch (Exception e) {                        } finally {                if (lease != null) {                    acquireCount.decrementAndGet();                    CloseableUtils.closeQuietly(lease);                }            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
public void curator_f2592_0(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {        suspendedLatch.countDown();        suspendedSemaphore.release();    }}
public void curator_f2593_0() throws Exception
{    final int QTY = 20;    final int OPERATION_TIME_MS = 1000;    final String PATH = "/foo/bar/lock";    ExecutorService executorService = Executors.newFixedThreadPool(QTY);    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executorService);    final Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(3);    List<SemaphoreClient> semaphoreClients = Lists.newArrayList();    try {        cluster.start();        final AtomicInteger opCount = new AtomicInteger(0);        for (int i = 0; i < QTY; ++i) {            SemaphoreClient semaphoreClient = new SemaphoreClient(cluster.getConnectString(), PATH, new Callable<Void>() {                @Override                public Void call() throws Exception {                    opCount.incrementAndGet();                    Thread.sleep(OPERATION_TIME_MS);                    return null;                }            });            completionService.submit(semaphoreClient);            semaphoreClients.add(semaphoreClient);        }        timing.forWaiting().sleepABit();        Assert.assertNotNull(SemaphoreClient.getActiveClient());        final CountDownLatch latch = new CountDownLatch(1);        CuratorFramework client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        try {            client.getZookeeperClient().blockUntilConnectedOrTimedOut();            cluster.stop();            latch.await();        } finally {            CloseableUtils.closeQuietly(client);        }        long startTicks = System.currentTimeMillis();        for (; ; ) {            int thisOpCount = opCount.get();            Thread.sleep(2 * OPERATION_TIME_MS);            if (thisOpCount == opCount.get()) {                                break;            }            Assert.assertTrue((System.currentTimeMillis() - startTicks) < timing.forWaiting().milliseconds());        }        int thisOpCount = opCount.get();        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        cluster = new TestingCluster(iterator.next(), iterator.next());        cluster.start();        timing.forWaiting().sleepABit();        startTicks = System.currentTimeMillis();        for (; ; ) {            Thread.sleep(2 * OPERATION_TIME_MS);            if (opCount.get() > thisOpCount) {                                break;            }            Assert.assertTrue((System.currentTimeMillis() - startTicks) < timing.forWaiting().milliseconds());        }    } finally {        for (SemaphoreClient semaphoreClient : semaphoreClients) {            CloseableUtils.closeQuietly(semaphoreClient);        }        CloseableUtils.closeQuietly(cluster);        executorService.shutdownNow();    }}
public Void curator_f2594_0() throws Exception
{    opCount.incrementAndGet();    Thread.sleep(OPERATION_TIME_MS);    return null;}
public void curator_f2595_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        latch.countDown();    }}
public void curator_f2596_0()
{}
public void curator_f2597_0()
{}
public void curator_f2598_0()
{}
protected InterProcessLock curator_f2599_0(CuratorFramework client)
{    return new InterProcessSemaphoreMutex(client, LOCK_PATH);}
private CuratorFramework curator_f2600_0(ACLProvider provider) throws Exception
{    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    CuratorFramework client = CuratorFrameworkFactory.builder().namespace("ns").connectString(server.getConnectString()).retryPolicy(retryPolicy).aclProvider(provider).build();    client.start();    return client;}
public void curator_f2601_0() throws Exception
{    CuratorFramework client = createClient(new TestLockACLsProvider());    try {        client.create().forPath("/foo");        Assert.assertNotNull(client.checkExists().forPath("/foo"));        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/foo").get(0).getPerms());        Assert.assertEquals("ip", client.getACL().forPath("/foo").get(0).getId().getScheme());        Assert.assertEquals("127.0.0.1", client.getACL().forPath("/foo").get(0).getId().getId());        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/bar");        InterProcessMutex writeLock = lock.writeLock();        writeLock.acquire();        Assert.assertNotNull(client.checkExists().forPath("/bar"));        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/bar").get(0).getPerms());        Assert.assertEquals("ip", client.getACL().forPath("/bar").get(0).getId().getScheme());        Assert.assertEquals("127.0.0.1", client.getACL().forPath("/bar").get(0).getId().getId());    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2602_0() throws Exception
{    CuratorFramework client = createClient(new TestACLsCreatingParentsProvider());    try {        client.create().creatingParentsIfNeeded().forPath("/parent/foo");        Assert.assertEquals(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, client.getACL().forPath("/parent").get(0).getPerms());        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/parent/foo").get(0).getPerms());    } finally {        CloseableUtils.closeQuietly(client);    }}
public List<ACL> curator_f2603_0()
{    return ACLS1;}
public List<ACL> curator_f2604_0(String path)
{    if (path.equals("/ns/parent")) {        return ACLS2;    }    return ACLS1;}
public List<ACL> curator_f2605_0()
{    return ACLS1;}
public List<ACL> curator_f2606_0(String path)
{    return ACLS1;}
public void curator_f2607_0() throws Exception
{    final String PATH = "/foo/bar";    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(0, 0));        client.start();        client.create().creatingParentsIfNeeded().forPath(PATH);        Assert.assertEquals(client.checkExists().forPath(PATH).getNumChildren(), 0);        LockInternals internals = new LockInternals(client, new StandardLockInternalsDriver(), PATH, "lock-", 1) {            @Override            List<String> getSortedChildren() throws Exception {                throw new KeeperException.NoNodeException();            }        };        try {            internals.attemptLock(0, null, null);            Assert.fail();        } catch (KeeperException.NoNodeException dummy) {                }                Assert.assertEquals(client.checkExists().forPath(PATH).getNumChildren(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
 List<String> curator_f2608_0() throws Exception
{    throw new KeeperException.NoNodeException();}
public void curator_f2609_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = makeClient(timing, null);    Reaper reaper1 = null;    Reaper reaper2 = null;    try {        final AtomicInteger reaper1Count = new AtomicInteger();        reaper1 = new Reaper(client, Reaper.newExecutorService(), 1, "/reaper/leader") {            @Override            protected void reap(PathHolder holder) {                reaper1Count.incrementAndGet();                super.reap(holder);            }        };        final AtomicInteger reaper2Count = new AtomicInteger();        reaper2 = new Reaper(client, Reaper.newExecutorService(), 1, "/reaper/leader") {            @Override            protected void reap(PathHolder holder) {                reaper2Count.incrementAndGet();                super.reap(holder);            }        };        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        reaper1.start();        reaper2.start();        reaper1.addPath("/one/two/three");        reaper2.addPath("/one/two/three");        timing.sleepABit();        Assert.assertTrue((reaper1Count.get() == 0) || (reaper2Count.get() == 0));        Assert.assertTrue((reaper1Count.get() > 0) || (reaper2Count.get() > 0));        Reaper activeReaper;        AtomicInteger inActiveReaperCount;        if (reaper1Count.get() > 0) {            activeReaper = reaper1;            inActiveReaperCount = reaper2Count;        } else {            activeReaper = reaper2;            inActiveReaperCount = reaper1Count;        }        Assert.assertEquals(inActiveReaperCount.get(), 0);        activeReaper.close();        timing.sleepABit();        Assert.assertTrue(inActiveReaperCount.get() > 0);    } finally {        CloseableUtils.closeQuietly(reaper1);        CloseableUtils.closeQuietly(reaper2);        CloseableUtils.closeQuietly(client);    }}
protected void curator_f2610_0(PathHolder holder)
{    reaper1Count.incrementAndGet();    super.reap(holder);}
protected void curator_f2611_0(PathHolder holder)
{    reaper2Count.incrementAndGet();    super.reap(holder);}
public void curator_f2612_0() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = makeClient(timing, null);    Reaper reaper1 = null;    Reaper reaper2 = null;    LeaderLatch leaderLatch1 = null;    LeaderLatch leaderLatch2 = null;    try {        final AtomicInteger reaper1Count = new AtomicInteger();        leaderLatch1 = new LeaderLatch(client, "/reaper/leader");        reaper1 = new Reaper(client, Reaper.newExecutorService(), 1, leaderLatch1) {            @Override            protected void reap(PathHolder holder) {                reaper1Count.incrementAndGet();                super.reap(holder);            }        };        final AtomicInteger reaper2Count = new AtomicInteger();        leaderLatch2 = new LeaderLatch(client, "/reaper/leader");        reaper2 = new Reaper(client, Reaper.newExecutorService(), 1, leaderLatch2) {            @Override            protected void reap(PathHolder holder) {                reaper2Count.incrementAndGet();                super.reap(holder);            }        };        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        leaderLatch1.start();        leaderLatch2.start();        reaper1.start();        reaper2.start();        reaper1.addPath("/one/two/three");        reaper2.addPath("/one/two/three");        timing.sleepABit();        Assert.assertTrue((reaper1Count.get() == 0) || (reaper2Count.get() == 0));        Assert.assertTrue((reaper1Count.get() > 0) || (reaper2Count.get() > 0));        Reaper activeReaper;        LeaderLatch activeLeaderLeatch;        AtomicInteger inActiveReaperCount;        if (reaper1Count.get() > 0) {            activeReaper = reaper1;            activeLeaderLeatch = leaderLatch1;            inActiveReaperCount = reaper2Count;        } else {            activeReaper = reaper2;            activeLeaderLeatch = leaderLatch2;            inActiveReaperCount = reaper1Count;        }        Assert.assertEquals(inActiveReaperCount.get(), 0);        activeReaper.close();        activeLeaderLeatch.close();        timing.sleepABit();        Assert.assertTrue(inActiveReaperCount.get() > 0);    } finally {        CloseableUtils.closeQuietly(reaper1);        CloseableUtils.closeQuietly(reaper2);        if (leaderLatch1 != null && LeaderLatch.State.STARTED == leaderLatch1.getState()) {            CloseableUtils.closeQuietly(leaderLatch1);        }        if (leaderLatch2 != null && LeaderLatch.State.STARTED == leaderLatch2.getState()) {            CloseableUtils.closeQuietly(leaderLatch2);        }        CloseableUtils.closeQuietly(client);    }}
protected void curator_f2613_0(PathHolder holder)
{    reaper1Count.incrementAndGet();    super.reap(holder);}
protected void curator_f2614_0(PathHolder holder)
{    reaper2Count.incrementAndGet();    super.reap(holder);}
public void curator_f2615_0() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = makeClient(timing, null);    final CountDownLatch latch = new CountDownLatch(1);    LeaderSelectorListener listener = new LeaderSelectorListener() {        @Override        public void takeLeadership(CuratorFramework client) throws Exception {            Reaper reaper = new Reaper(client, 1);            try {                reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);                reaper.start();                timing.sleepABit();                latch.countDown();            } finally {                CloseableUtils.closeQuietly(reaper);            }        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    LeaderSelector selector = new LeaderSelector(client, "/leader", listener);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        selector.start();        timing.awaitLatch(latch);        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2616_0(CuratorFramework client) throws Exception
{    Reaper reaper = new Reaper(client, 1);    try {        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);        reaper.start();        timing.sleepABit();        latch.countDown();    } finally {        CloseableUtils.closeQuietly(reaper);    }}
public void curator_f2617_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2618_0() throws Exception
{    final int THRESHOLD = 3000;    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, null);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        final Queue<Reaper.PathHolder> holders = new ConcurrentLinkedQueue<Reaper.PathHolder>();        final ExecutorService pool = Executors.newCachedThreadPool();        ScheduledExecutorService service = new ScheduledThreadPoolExecutor(1);        reaper = new Reaper(client, service, THRESHOLD) {            @Override            protected Future<Void> schedule(final PathHolder pathHolder, int reapingThresholdMs) {                holders.add(pathHolder);                final Future<?> f = super.schedule(pathHolder, reapingThresholdMs);                pool.submit(new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        f.get();                        holders.remove(pathHolder);                        return null;                    }                });                return null;            }        };        reaper.start();        reaper.addPath("/one/two/three");        long start = System.currentTimeMillis();        boolean emptyCountIsCorrect = false;        while (        ((System.currentTimeMillis() - start) < timing.forWaiting().milliseconds()) && !emptyCountIsCorrect) {            for (Reaper.PathHolder holder : holders) {                if (holder.path.endsWith("/one/two/three")) {                    emptyCountIsCorrect = (holder.emptyCount > 0);                    break;                }            }            Thread.sleep(1);        }        Assert.assertTrue(emptyCountIsCorrect);        client.create().forPath("/one/two/three/foo");        Thread.sleep(2 * (THRESHOLD / Reaper.EMPTY_COUNT_THRESHOLD));        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client.delete().forPath("/one/two/three/foo");        Thread.sleep(THRESHOLD);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
protected Future<Void> curator_f2619_0(final PathHolder pathHolder, int reapingThresholdMs)
{    holders.add(pathHolder);    final Future<?> f = super.schedule(pathHolder, reapingThresholdMs);    pool.submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            f.get();            holders.remove(pathHolder);            return null;        }    });    return null;}
public Void curator_f2620_0() throws Exception
{    f.get();    holders.remove(pathHolder);    return null;}
public void curator_f2621_0() throws Exception
{    testReapUntilDelete(null);}
public void curator_f2622_0() throws Exception
{    testReapUntilDelete("test");}
public void curator_f2623_0() throws Exception
{    testReapUntilGone(null);}
public void curator_f2624_0() throws Exception
{    testReapUntilGone("test");}
public void curator_f2625_0() throws Exception
{    testRemove(null);}
public void curator_f2626_0() throws Exception
{    testRemove("test");}
public void curator_f2627_0() throws Exception
{    testSimulationWithLocks(null);}
public void curator_f2628_0() throws Exception
{    testSimulationWithLocks("test");}
public void curator_f2629_0() throws Exception
{    testWithEphemerals(null);}
public void curator_f2630_0() throws Exception
{    testWithEphemerals("test");}
public void curator_f2631_0() throws Exception
{    testBasic(null);}
public void curator_f2632_0() throws Exception
{    testBasic("test");}
private void curator_f2633_0(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        client.create().forPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
private void curator_f2634_0(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_GONE);        timing.sleepABit();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_GONE);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
private CuratorFramework curator_f2635_0(Timing timing, String namespace) throws IOException
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1));    if (namespace != null) {        builder = builder.namespace(namespace);    }    return builder.build();}
private void curator_f2636_0(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertTrue(reaper.removePath("/one/two/three"));        client.create().forPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
private void curator_f2637_0(String namespace) throws Exception
{    final int LOCK_CLIENTS = 10;    final int ITERATIONS = 250;    final int MAX_WAIT_MS = 10;    ExecutorService service = Executors.newFixedThreadPool(LOCK_CLIENTS);    ExecutorCompletionService<Object> completionService = new ExecutorCompletionService<Object>(service);    Timing timing = new Timing();    Reaper reaper = null;    final CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        reaper = new Reaper(client, MAX_WAIT_MS / 2);        reaper.start();        reaper.addPath("/a/b");        for (int i = 0; i < LOCK_CLIENTS; ++i) {            completionService.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    final InterProcessMutex lock = new InterProcessMutex(client, "/a/b");                    for (int i = 0; i < ITERATIONS; ++i) {                        lock.acquire();                        try {                            Thread.sleep((int) (Math.random() * MAX_WAIT_MS));                        } finally {                            lock.release();                        }                    }                    return null;                }            });        }        for (int i = 0; i < LOCK_CLIENTS; ++i) {            completionService.take().get();        }        Thread.sleep(timing.session());        timing.sleepABit();        Stat stat = client.checkExists().forPath("/a/b");        Assert.assertNull(stat, "Child qty: " + ((stat != null) ? stat.getNumChildren() : 0));    } finally {        service.shutdownNow();        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
public Object curator_f2638_0() throws Exception
{    final InterProcessMutex lock = new InterProcessMutex(client, "/a/b");    for (int i = 0; i < ITERATIONS; ++i) {        lock.acquire();        try {            Thread.sleep((int) (Math.random() * MAX_WAIT_MS));        } finally {            lock.release();        }    }    return null;}
private void curator_f2639_0(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client2 = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client2 = makeClient(timing, namespace);        client2.start();        for (int i = 0; i < 10; ++i) {            client2.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/one/two/three/foo-");        }        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));                client2.close();        client2 = null;        Thread.sleep(timing.session());        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client);    }}
private void curator_f2640_0(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2641_0() throws Exception
{    Timing timing = new Timing();    GroupMember groupMember1 = null;    GroupMember groupMember2 = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        groupMember1 = new GroupMember(client, "/member", "1");        Assert.assertTrue(groupMember1.getCurrentMembers().containsKey("1"));        groupMember1.start();        groupMember2 = new GroupMember(client, "/member", "2");        groupMember2.start();        timing.sleepABit();        Map<String, byte[]> currentMembers1 = groupMember1.getCurrentMembers();        Map<String, byte[]> currentMembers2 = groupMember2.getCurrentMembers();        Map<String, String> convertMembers1 = Maps.transformValues(currentMembers1, new Function<byte[], String>() {            @Override            public String apply(byte[] input) {                return new String(input);            }        });        Map<String, String> convertMembers2 = Maps.transformValues(currentMembers1, new Function<byte[], String>() {            @Override            public String apply(byte[] input) {                return new String(input);            }        });        Assert.assertEquals(convertMembers1.size(), 2);        Assert.assertEquals(convertMembers2.size(), 2);        Assert.assertEquals(convertMembers1, convertMembers2);        Assert.assertTrue(convertMembers1.containsKey("1"));        Assert.assertTrue(convertMembers1.containsKey("2"));        groupMember2.close();        timing.sleepABit();        currentMembers1 = groupMember1.getCurrentMembers();        Assert.assertEquals(currentMembers1.size(), 1);        Assert.assertTrue(currentMembers1.containsKey("1"));        Assert.assertFalse(currentMembers1.containsKey("2"));        groupMember1.setThisData("something".getBytes());        timing.sleepABit();        currentMembers1 = groupMember1.getCurrentMembers();        Assert.assertTrue(currentMembers1.containsKey("1"));        Assert.assertEquals(currentMembers1.get("1"), "something".getBytes());    } finally {        CloseableUtils.closeQuietly(groupMember1);        CloseableUtils.closeQuietly(groupMember2);        CloseableUtils.closeQuietly(client);    }}
public String curator_f2642_0(byte[] input)
{    return new String(input);}
public String curator_f2643_0(byte[] input)
{    return new String(input);}
public void curator_f2644_0() throws Exception
{    try {        for (PersistentEphemeralNode node : createdNodes) {            CloseableUtils.closeQuietly(node);        }        for (CuratorFramework curator : curatorInstances) {            TestCleanState.closeAndTestClean(curator);        }    } finally {        super.teardown();    }}
public void curator_f2645_0() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        try (PersistentEphemeralNode node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes())) {            node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());            node.start();            final CountDownLatch connectedLatch = new CountDownLatch(1);            final CountDownLatch reconnectedLatch = new CountDownLatch(1);            ConnectionStateListener listener = new ConnectionStateListener() {                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                    if (newState == ConnectionState.CONNECTED) {                        connectedLatch.countDown();                    }                    if (newState == ConnectionState.RECONNECTED) {                        reconnectedLatch.countDown();                    }                }            };            client.getConnectionStateListenable().addListener(listener);            timing.sleepABit();            server.restart();            Assert.assertTrue(timing.awaitLatch(connectedLatch));            timing.sleepABit();            Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            server.stop();            timing.sleepABit();            server.restart();            timing.sleepABit();            Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2646_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
public void curator_f2647_0() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(node);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2648_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
public void curator_f2649_0() throws Exception
{    new PersistentEphemeralNode(null, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);}
public void curator_f2650_0() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, null, new byte[0]);}
public void curator_f2651_0() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, null);}
public void curator_f2652_0() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, null, PATH, new byte[0]);}
public void curator_f2653_0() throws Exception
{    setDataTest(PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL);}
public void curator_f2654_0() throws Exception
{    setDataTest(PersistentEphemeralNode.Mode.EPHEMERAL);}
protected void curator_f2655_0(PersistentEphemeralNode.Mode mode) throws Exception
{    PersistentEphemeralNode node = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        node = new PersistentEphemeralNode(client, mode, PATH, "a".getBytes());        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertEquals(client.getData().forPath(node.getActualPath()), "a".getBytes());        final Semaphore semaphore = new Semaphore(0);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent arg0) {                semaphore.release();            }        };        client.checkExists().usingWatcher(watcher).forPath(node.getActualPath());        node.setData("b".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(node.getActualPath(), node.getActualPath());        Assert.assertEquals(client.getData().usingWatcher(watcher).forPath(node.getActualPath()), "b".getBytes());        node.setData("c".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(node.getActualPath(), node.getActualPath());        Assert.assertEquals(client.getData().usingWatcher(watcher).forPath(node.getActualPath()), "c".getBytes());        node.close();        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(node);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2656_0(WatchedEvent arg0)
{    semaphore.release();}
public void curator_f2657_0() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    String path = null;    try {        node.waitForInitialCreate(5, TimeUnit.SECONDS);        path = node.getActualPath();        assertNodeExists(curator, path);    } finally {        CloseableUtils.closeQuietly(node);    }    assertNodeDoesNotExist(curator, path);}
public void curator_f2658_0() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);    String path = node.getActualPath();    node.close();    assertNodeDoesNotExist(curator, path);    node.close();    assertNodeDoesNotExist(curator, path);}
public void curator_f2659_0() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());                Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        node.debugCreateNodeLatch = new CountDownLatch(1);        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forSessionSleep().seconds(), TimeUnit.SECONDS));        node.debugCreateNodeLatch.countDown();    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2660_0() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(5, TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());        Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        node.debugCreateNodeLatch = new CountDownLatch(1);        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forSessionSleep().seconds(), TimeUnit.SECONDS));        node.debugCreateNodeLatch.countDown();                Trigger createdTrigger = Trigger.created();        Stat stat = observer.checkExists().usingWatcher(createdTrigger).forPath(node.getActualPath());        assertTrue(stat != null || createdTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2661_0() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String path = node.getActualPath();        assertNodeExists(observer, path);                for (int i = 0; i < 5; i++) {            Trigger deletionTrigger = Trigger.deletedOrSetData();            Stat stat = observer.checkExists().usingWatcher(deletionTrigger).forPath(path);            Assert.assertNotNull(stat, "node should exist: " + path);            node.debugCreateNodeLatch = new CountDownLatch(1);                        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                        assertTrue(deletionTrigger.firedWithin(timing.multiple(1.5).forSessionSleep().seconds(), TimeUnit.SECONDS));            node.debugCreateNodeLatch.countDown();                        Trigger creationTrigger = Trigger.created();            stat = observer.checkExists().usingWatcher(creationTrigger).forPath(path);            assertTrue(stat != null || creationTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));        }    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2662_0() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework nodeCreator = newCurator();    CuratorFramework observer = newCurator();    nodeCreator.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(PATH, new byte[0]);    Trigger dataChangedTrigger = Trigger.dataChanged();    observer.getData().usingWatcher(dataChangedTrigger).forPath(PATH);    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    try {        node.waitForInitialCreate(5, TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());        assertTrue(dataChangedTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        Compatibility.injectSessionExpiration(nodeCreator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));                Trigger createdTrigger = Trigger.created();        Stat stat = observer.checkExists().usingWatcher(createdTrigger).forPath(node.getActualPath());        assertTrue(stat != null || createdTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        node.close();    }}
public void curator_f2663_0() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String originalNode = node.getActualPath();        assertNodeExists(curator, originalNode);                curator.delete().forPath(originalNode);                        Trigger createdWatchTrigger = Trigger.created();        Stat stat = curator.checkExists().usingWatcher(createdWatchTrigger).forPath(originalNode);        assertTrue(stat != null || createdWatchTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2664_0() throws Exception
{    CuratorFramework curator = newCurator();    try (PersistentEphemeralNode node1 = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL, PATH, new byte[0])) {        node1.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node1.start();        node1.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String path1 = node1.getActualPath();        PersistentEphemeralNode node2 = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL, PATH, new byte[0]);        node2.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node2.start();        try {            node2.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);            String path2 = node2.getActualPath();            assertFalse(path1.equals(path2));        } finally {            node2.close();        }    }}
public void curator_f2665_0() throws Exception
{    CuratorFramework curator = newCurator();    byte[] data = "Hello World".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, data);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), data));    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2666_0() throws Exception
{    CuratorFramework curator = newCurator();    curator.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(PATH, "InitialData".getBytes());    byte[] data = "Hello World".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, data);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), data));    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2667_0() throws Exception
{    CuratorFramework curator = newCurator();    byte[] initialData = "Hello World".getBytes();    byte[] updatedData = "Updated".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, initialData);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), initialData));        server.stop();        final CountDownLatch dataUpdateLatch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == EventType.NodeDataChanged) {                    dataUpdateLatch.countDown();                }            }        };        curator.getData().usingWatcher(watcher).inBackground().forPath(node.getActualPath());        node.setData(updatedData);        server.restart();        assertTrue(timing.awaitLatch(dataUpdateLatch));        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2668_0(WatchedEvent event)
{    if (event.getType() == EventType.NodeDataChanged) {        dataUpdateLatch.countDown();    }}
public void curator_f2669_0() throws Exception
{    CuratorFramework curator = newCurator();    byte[] initialData = "Hello World".getBytes();    byte[] updatedData = "Updated".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, initialData);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), initialData));        node.setData(updatedData);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));        server.restart();        final CountDownLatch dataUpdateLatch = new CountDownLatch(1);        curator.getData().inBackground(new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                dataUpdateLatch.countDown();            }        }).forPath(node.getActualPath());        assertTrue(timing.awaitLatch(dataUpdateLatch));        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2670_0(CuratorFramework client, CuratorEvent event) throws Exception
{    dataUpdateLatch.countDown();}
public void curator_f2671_0() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.PROTECTED_EPHEMERAL, PATH, new byte[0]);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertNodeExists(curator, node.getActualPath());        server.restart();        curator.blockUntilConnected(5, TimeUnit.SECONDS);        assertNodeExists(curator, node.getActualPath());                List<String> children = curator.getChildren().forPath(DIR);        assertFalse(children == null);        assertEquals(children.size(), 1);    } finally {        CloseableUtils.closeQuietly(node);    }}
public void curator_f2672_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    PersistentEphemeralNode node = null;    try {        client.start();        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath(DIR, new byte[0]);        client.close();                client = newCurator();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.seconds(), TimeUnit.SECONDS);        assertNodeDoesNotExist(client, PATH);        assertTrue(node.isAuthFailure());    } finally {        CloseableUtils.closeQuietly(node);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2673_0() throws Exception
{    final ACLProvider aclProvider = new ACLProvider() {        final ACL acl = new ACL(ZooDefs.Perms.READ | ZooDefs.Perms.CREATE | ZooDefs.Perms.DELETE, ZooDefs.Ids.ANYONE_ID_UNSAFE);        final List<ACL> aclList = Collections.singletonList(acl);        @Override        public List<ACL> getDefaultAcl() {            return aclList;        }        @Override        public List<ACL> getAclForPath(String path) {            return aclList;        }    };    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).aclProvider(aclProvider).retryPolicy(new RetryOneTime(1)).build();    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);        node.start();        assertTrue(node.waitForInitialCreate(timing.seconds(), TimeUnit.SECONDS), "Node not created");        assertNodeExists(client, PATH);        assertFalse(node.isAuthFailure(), "AuthFailure when creating node.");        byte[] NEW_DATA = "NEW_DATA".getBytes();        node.setData(NEW_DATA);        timing.sleepABit();        byte[] read_data = client.getData().forPath(PATH);        assertNotEquals(read_data, NEW_DATA, "Data matches - write went through.");        assertTrue(node.isAuthFailure(), "AuthFailure response not received.");    } finally {        CloseableUtils.closeQuietly(node);        CloseableUtils.closeQuietly(client);    }}
public List<ACL> curator_f2674_0()
{    return aclList;}
public List<ACL> curator_f2675_0(String path)
{    return aclList;}
private void curator_f2676_0(CuratorFramework curator, String path) throws Exception
{    assertNotNull(path);    assertTrue(curator.checkExists().forPath(path) != null);}
private void curator_f2677_0(CuratorFramework curator, String path) throws Exception
{    assertTrue(curator.checkExists().forPath(path) == null);}
private CuratorFramework curator_f2678_0() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    curatorInstances.add(client);    return client;}
public void curator_f2679_1(WatchedEvent event)
{    if (types.contains(event.getType())) {        latch.countDown();    } else if (event.getType() != EventType.None) {            }}
public boolean curator_f2680_0(long duration, TimeUnit unit)
{    try {        return latch.await(duration, unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw Throwables.propagate(e);    }}
private static Trigger curator_f2681_0()
{    return new Trigger(Event.EventType.NodeCreated);}
private static Trigger curator_f2682_0()
{    return new Trigger(Event.EventType.NodeDeleted, EventType.NodeDataChanged);}
private static Trigger curator_f2683_0()
{    return new Trigger(EventType.NodeDataChanged);}
public void curator_f2684_0() throws Exception
{    server.stop();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        PersistentEphemeralNode node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final AtomicReference<ConnectionState> lastState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                lastState.set(newState);                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        server.restart();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(lastState.get(), ConnectionState.RECONNECTED);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2685_0(CuratorFramework client, ConnectionState newState)
{    lastState.set(newState);    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
public void curator_f2686_0() throws Exception
{    final byte[] TEST_DATA = "hey".getBytes();    final byte[] ALT_TEST_DATA = "there".getBytes();    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test", TEST_DATA);        pen.start();        try {            pen.setData(ALT_TEST_DATA);            Assert.fail("IllegalStateException should have been thrown");        } catch (IllegalStateException dummy) {                }    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2687_0() throws Exception
{    final byte[] TEST_DATA = "hey".getBytes();    Timing2 timing = new Timing2();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test", TEST_DATA);        pen.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        pen.start();        Assert.assertTrue(pen.waitForInitialCreate(timing.milliseconds(), TimeUnit.MILLISECONDS));                client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        byte[] bytes = client.getData().forPath("/test");        Assert.assertEquals(bytes, TEST_DATA);    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2688_0() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test/one/two", new byte[0]);        pen.start();        pen.close();        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test/one/two"));    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2689_0() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one/two");        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test/one/two", new byte[0]);        pen.start();        pen.close();        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test/one/two"));    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2690_0() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one");        pen = new PersistentNode(client, CreateMode.EPHEMERAL_SEQUENTIAL, true, "/test/one/two", new byte[0]);        pen.start();        List<String> children = client.getChildren().forPath("/test/one");        System.out.println("children before restart: " + children);        Assert.assertEquals(1, children.size());        server.stop();        timing.sleepABit();        server.restart();        timing.sleepABit();        List<String> childrenAfter = client.getChildren().forPath("/test/one");        System.out.println("children after restart: " + childrenAfter);        Assert.assertEquals(children, childrenAfter, "unexpected znodes: " + childrenAfter);    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
public static void curator_f2691_0()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
public void curator_f2692_0() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1");    super.setup();}
public void curator_f2693_0() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
public void curator_f2694_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            node.start();            Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));            for (int i = 0; i < 5; ++i) {                                Thread.sleep(ttlMs + (ttlMs / 2));                Assert.assertNotNull(client.checkExists().forPath("/test"));            }        }        Assert.assertNotNull(client.checkExists().forPath("/test"));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test"));    }}
public void curator_f2695_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            node.start();            Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));            for (int i = 0; i < 5; ++i) {                Thread.sleep(ttlMs);                client.delete().quietly().forPath(ZKPaths.makePath("test", PersistentTtlNode.DEFAULT_CHILD_NODE_NAME));            }            timing.sleepABit();            Assert.assertNotNull(client.checkExists().forPath("/test"));        }    }}
public void curator_f2696_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            try (PathChildrenCache cache = new PathChildrenCache(client, "/", true)) {                final Semaphore changes = new Semaphore(0);                PathChildrenCacheListener listener = new PathChildrenCacheListener() {                    @Override                    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                        if ((event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) && "/test".equals(event.getData().getPath())) {                            changes.release();                        }                    }                };                cache.getListenable().addListener(listener);                node.start();                Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));                cache.start(BUILD_INITIAL_CACHE);                Assert.assertEquals(changes.availablePermits(), 0);                timing.sleepABit();                Assert.assertEquals(changes.availablePermits(), 0);                client.setData().forPath("/test", "changed".getBytes());                Assert.assertTrue(timing.acquireSemaphore(changes));                timing.sleepABit();                Assert.assertEquals(changes.availablePermits(), 0);            }        }        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test"));    }}
public void curator_f2697_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if ((event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) && "/test".equals(event.getData().getPath())) {        changes.release();    }}
public byte[] curator_f2698_0(TestQueueItem item)
{    return item.str.getBytes();}
public TestQueueItem curator_f2699_0(byte[] bytes)
{    return new TestQueueItem(new String(bytes));}
public Void curator_f2700_0() throws Exception
{    int count = 0;    while (!Thread.currentThread().isInterrupted() && (count < itemQty)) {        queue.put(new TestQueueItem(Integer.toString(count + startIndex)));        ++count;    }    return null;}
public byte[] curator_f2701_0(String item)
{    return item.getBytes();}
public String curator_f2702_0(byte[] bytes)
{    return new String(bytes);}
public void curator_f2703_0() throws Exception
{    final String PATH = "/queue";    final int CLIENT_QTY = 4;    final int MAX_ITEMS = 10;    final int ADD_ITEMS = MAX_ITEMS * 100;    final QueueConsumer<String> consumer = new QueueConsumer<String>() {        @Override        public void consumeMessage(String message) throws Exception {            Thread.sleep(10);        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    final Timing timing = new Timing();    final ExecutorService executor = Executors.newCachedThreadPool();    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executor);    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);        final CountDownLatch isWaitingLatch = new CountDownLatch(1);        final AtomicBoolean isDone = new AtomicBoolean(false);        final List<Integer> counts = new CopyOnWriteArrayList<Integer>();        final Object lock = new Object();        executor.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                Watcher watcher = new Watcher() {                    @Override                    public void process(WatchedEvent event) {                        synchronized (lock) {                            lock.notifyAll();                        }                    }                };                while (!Thread.currentThread().isInterrupted() && client.getState() == CuratorFrameworkState.STARTED && !isDone.get()) {                    synchronized (lock) {                        int size = client.getChildren().usingWatcher(watcher).forPath(PATH).size();                        counts.add(size);                        isWaitingLatch.countDown();                        lock.wait();                    }                }                return null;            }        });        isWaitingLatch.await();        for (int i = 0; i < CLIENT_QTY; ++i) {            final int index = i;            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = null;                    DistributedQueue<String> queue = null;                    try {                        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                        client.start();                        queue = QueueBuilder.builder(client, consumer, serializer, PATH).executor(executor).maxItems(MAX_ITEMS).putInBackground(false).lockPath("/locks").buildQueue();                        queue.start();                        for (int i = 0; i < ADD_ITEMS; ++i) {                            queue.put("" + index + "-" + i);                        }                    } finally {                        CloseableUtils.closeQuietly(queue);                        CloseableUtils.closeQuietly(client);                    }                    return null;                }            });        }        for (int i = 0; i < CLIENT_QTY; ++i) {            completionService.take().get();        }        isDone.set(true);        synchronized (lock) {            lock.notifyAll();        }        for (int count : counts) {            Assert.assertTrue(count <= (MAX_ITEMS * CLIENT_QTY), counts.toString());        }    } finally {        executor.shutdownNow();        CloseableUtils.closeQuietly(client);    }}
public void curator_f2704_0(String message) throws Exception
{    Thread.sleep(10);}
public void curator_f2705_0(CuratorFramework client, ConnectionState newState)
{}
public Void curator_f2706_0() throws Exception
{    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            synchronized (lock) {                lock.notifyAll();            }        }    };    while (!Thread.currentThread().isInterrupted() && client.getState() == CuratorFrameworkState.STARTED && !isDone.get()) {        synchronized (lock) {            int size = client.getChildren().usingWatcher(watcher).forPath(PATH).size();            counts.add(size);            isWaitingLatch.countDown();            lock.wait();        }    }    return null;}
public void curator_f2707_0(WatchedEvent event)
{    synchronized (lock) {        lock.notifyAll();    }}
public Void curator_f2708_0() throws Exception
{    CuratorFramework client = null;    DistributedQueue<String> queue = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        queue = QueueBuilder.builder(client, consumer, serializer, PATH).executor(executor).maxItems(MAX_ITEMS).putInBackground(false).lockPath("/locks").buildQueue();        queue.start();        for (int i = 0; i < ADD_ITEMS; ++i) {            queue.put("" + index + "-" + i);        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }    return null;}
public void curator_f2709_0() throws Exception
{    Timing timing = new Timing();    DistributedQueue<String> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final List<String> messages = new CopyOnWriteArrayList<String>();        final CountDownLatch latch = new CountDownLatch(2);        final Semaphore semaphore = new Semaphore(0);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                messages.add(message);                semaphore.acquire();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, "/queue").executor(Executors.newSingleThreadExecutor()).maxItems(1).buildQueue();        queue.start();        QueuePutListener<String> listener = new QueuePutListener<String>() {            @Override            public void putCompleted(String item) {                latch.countDown();            }            @Override            public void putMultiCompleted(MultiItem<String> items) {            }        };        queue.getPutListenerContainer().addListener(listener);                Assert.assertTrue(queue.put("1", timing.milliseconds(), TimeUnit.MILLISECONDS));                Assert.assertTrue(queue.put("2", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertFalse(queue.put("3", timing.multiple(.5).milliseconds(), TimeUnit.MILLISECONDS));        semaphore.release(100);        Assert.assertTrue(queue.put("3", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(queue.put("4", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(queue.put("5", timing.milliseconds(), TimeUnit.MILLISECONDS));        for (int i = 0; i < 5; ++i) {            if (messages.size() == 3) {                break;            }            timing.sleepABit();        }        timing.sleepABit();        Assert.assertEquals(messages, Arrays.asList("1", "2", "3", "4", "5"));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2710_0(String message) throws Exception
{    messages.add(message);    semaphore.acquire();}
public void curator_f2711_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2712_0(String item)
{    latch.countDown();}
public void curator_f2713_0(MultiItem<String> items)
{}
public void curator_f2714_0() throws Exception
{    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();                queue.put(1L, System.currentTimeMillis() + Integer.MAX_VALUE);        Long value = consumer.take(1, TimeUnit.SECONDS);        Assert.assertNull(value);        queue.put(2L, System.currentTimeMillis());        value = consumer.take(timing.seconds(), TimeUnit.SECONDS);        Assert.assertEquals(value, Long.valueOf(2));        value = consumer.take(1, TimeUnit.SECONDS);        Assert.assertNull(value);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2715_0() throws Exception
{    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();        queue.put(1L, System.currentTimeMillis() + 1000);        Thread.sleep(100);                Assert.assertEquals(consumer.size(), 0);        Long value = consumer.take(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(value, Long.valueOf(1));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2716_0() throws Exception
{    final int QTY = 10;    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();        Random random = new Random();        for (int i = 0; i < QTY; ++i) {            long delay = System.currentTimeMillis() + random.nextInt(100);            queue.put(delay, delay);        }        long lastValue = -1;        for (int i = 0; i < QTY; ++i) {            Long value = consumer.take(timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(value);            Assert.assertTrue(value >= lastValue);            lastValue = value;        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2717_0() throws Exception
{    Timing timing = new Timing();        final int QTY = 1000;    final int DELAY_MS = timing.multiple(.1).milliseconds();    DistributedDelayQueue<Long> putQueue = null;    DistributedDelayQueue<Long> getQueue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        putQueue = QueueBuilder.builder(client, null, new LongSerializer(), "/test2").putInBackground(false).buildDelayQueue();        putQueue.start();        Map<Long, Long> data = new HashMap<Long, Long>();                                        long delay = System.currentTimeMillis() + DELAY_MS;        for (long i = 0; i < QTY; ++i) {            data.put(delay, i);                        delay += 1;        }                List<Long> keys = new ArrayList<Long>(data.keySet());        Collections.shuffle(keys);                for (Long key : keys) {            putQueue.put(data.get(key), key);        }        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        getQueue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test2").putInBackground(false).buildDelayQueue();        getQueue.start();        long lastValue = -1;        for (int i = 0; i < QTY; ++i) {            Long value = consumer.take(DELAY_MS * 2, TimeUnit.MILLISECONDS);            Assert.assertNotNull(value);            Assert.assertEquals(value, new Long(lastValue + 1));            lastValue = value;        }    } finally {        CloseableUtils.closeQuietly(putQueue);        CloseableUtils.closeQuietly(getQueue);        CloseableUtils.closeQuietly(client);    }}
public byte[] curator_f2718_0(Long item)
{    return Long.toString(item).getBytes();}
public Long curator_f2719_0(byte[] bytes)
{    return Long.parseLong(new String(bytes));}
public void curator_f2720_0() throws Exception
{    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch consumingLatch = new CountDownLatch(1);        final CountDownLatch waitLatch = new CountDownLatch(1);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                consumingLatch.countDown();                waitLatch.await();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildIdQueue();        queue.start();        queue.put(new TestQueueItem("test"), "id");                Assert.assertTrue(consumingLatch.await(10, TimeUnit.SECONDS));        Assert.assertEquals(queue.remove("id"), 0);        waitLatch.countDown();    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2721_0(TestQueueItem message) throws Exception
{    consumingLatch.countDown();    waitLatch.await();}
public void curator_f2722_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2723_0() throws Exception
{    final int ITEM_QTY = 100;    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildIdQueue();        queue.start();        List<String> ids = Lists.newArrayList();        for (int i = 0; i < ITEM_QTY; ++i) {            String id = Double.toString(Math.random());            ids.add(id);            queue.put(new TestQueueItem(id), id);        }        int iteration = 0;        while (consumer.size() < ITEM_QTY) {            Assert.assertTrue(++iteration < ITEM_QTY);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, ids.get(i++));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2724_0() throws Exception
{    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch consumingLatch = new CountDownLatch(1);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                consumingLatch.countDown();                                throw new Exception("Consumer failed");            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildIdQueue();        queue.start();        queue.put(new TestQueueItem("test"), "id");                Assert.assertTrue(consumingLatch.await(10, TimeUnit.SECONDS));                Thread.sleep(1000);        Assert.assertTrue(queue.debugIsQueued("id"));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2725_0(TestQueueItem message) throws Exception
{    consumingLatch.countDown();        throw new Exception("Consumer failed");}
public void curator_f2726_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2727_0() throws Exception
{    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final int minItemsBeforeRefresh = 3;        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(minItemsBeforeRefresh);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(i, 10 + i);        }        Assert.assertEquals(consumer.take(1, TimeUnit.SECONDS), new Integer(0));                queue.put(1000, 1);        int count = 0;        while (consumer.take(1, TimeUnit.SECONDS) < 1000) {            ++count;        }                Assert.assertTrue(Math.abs(minItemsBeforeRefresh - count) < minItemsBeforeRefresh, String.format("Diff: %d - min: %d", Math.abs(minItemsBeforeRefresh - count), minItemsBeforeRefresh));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2728_0() throws Exception
{    Timing timing = new Timing();    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final BlockingQueue<Integer> blockingQueue = new SynchronousQueue<Integer>();        QueueConsumer<Integer> consumer = new QueueConsumer<Integer>() {            @Override            public void consumeMessage(Integer message) throws Exception {                blockingQueue.put(message);            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(0);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(i, 10);        }        Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(0));        timing.sleepABit();                queue.put(1000, 1);        timing.sleepABit();                Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(1));        Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(1000));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2729_0(Integer message) throws Exception
{    blockingQueue.put(message);}
public void curator_f2730_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2731_0() throws Exception
{    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        QueueSerializer<Integer> serializer = new IntSerializer() {            @Override            public Integer deserialize(byte[] bytes) {                                try {                    latch.await();                } catch (InterruptedException e) {                                }                return super.deserialize(bytes);            }        };        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, "/test").buildPriorityQueue(1);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(10, 10);            if (i == 0) {                queue.put(1, 1);                latch.countDown();            }        }        assertOrdering(consumer, 10);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public Integer curator_f2732_0(byte[] bytes)
{        try {        latch.await();    } catch (InterruptedException e) {        }    return super.deserialize(bytes);}
public void curator_f2733_0() throws Exception
{    List<Integer> nums = new ArrayList<Integer>();    Timing timing = new Timing();    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch hasConsumedLatch = new CountDownLatch(1);        final CountDownLatch okToConsumeLatch = new CountDownLatch(1);        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class)) {            @Override            public void consumeMessage(Integer message) throws Exception {                hasConsumedLatch.countDown();                okToConsumeLatch.await();                super.consumeMessage(message);            }        };        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(0);        queue.start();        nums.add(Integer.MIN_VALUE);                queue.put(Integer.MIN_VALUE, Integer.MIN_VALUE);        Assert.assertTrue(timing.awaitLatch(hasConsumedLatch));        Random random = new Random();        for (int i = 0; i < 100; ++i) {            int priority = random.nextInt();            nums.add(priority);            queue.put(priority, priority);        }        while (        queue.getCache().getData().children.size() < (nums.size() - 1)) {                        timing.sleepABit();        }        okToConsumeLatch.countDown();        assertOrdering(consumer, nums.size());    } catch (AssertionError e) {        StringBuilder message = new StringBuilder(e.getMessage());        for (int i : nums) {            message.append(i).append("\t").append(DistributedPriorityQueue.priorityToString(i)).append("\n");        }        Assert.fail(message.toString());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2734_0(Integer message) throws Exception
{    hasConsumedLatch.countDown();    okToConsumeLatch.await();    super.consumeMessage(message);}
private void curator_f2735_0(BlockingQueueConsumer<Integer> consumer, int qty) throws Exception
{    int previous = 0;    for (int i = 0; i < qty; ++i) {        Integer value = consumer.take(10, TimeUnit.SECONDS);        Assert.assertNotNull(value);        if (i > 0) {            Assert.assertTrue(value >= previous, String.format("Value: (%d:%s) Previous: (%d:%s)", value, DistributedPriorityQueue.priorityToString(value), previous, DistributedPriorityQueue.priorityToString(previous)));        }        previous = value;    }}
public byte[] curator_f2736_0(Integer item)
{    return Integer.toString(item).getBytes();}
public Integer curator_f2737_0(byte[] bytes)
{    return Integer.parseInt(new String(bytes));}
public void curator_f2738_0() throws Exception
{    /*            https://issues.apache.org/jira/browse/CURATOR-56            This tests against ever growing node name bug         */    DistributedQueue<TestQueueItem> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final int RETRY_COUNT = 1;        final CountDownLatch retryCounter = new CountDownLatch(RETRY_COUNT + 1);        final List<String> names = new ArrayList<String>();        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem messsage) throws Exception {                List<String> queueItems = client.getChildren().forPath(QUEUE_PATH);                names.add(queueItems.get(0));                if (retryCounter.getCount() > 1) {                    retryCounter.countDown();                    throw new Exception("Something went wrong");                } else {                    retryCounter.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/lock").buildQueue();        queue.start();        queue.put(new TestQueueItem("test"));        retryCounter.await(10, TimeUnit.SECONDS);        Assert.assertEquals(retryCounter.getCount(), 0, "Queue item was not consumed. Retry counter is " + retryCounter.getCount());        Assert.assertEquals(names.size(), 2);        Assert.assertEquals(names.get(0).length(), names.get(1).length(), "name1: " + names.get(0) + " - " + "name2: " + names.get(1));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2739_0(TestQueueItem messsage) throws Exception
{    List<String> queueItems = client.getChildren().forPath(QUEUE_PATH);    names.add(queueItems.get(0));    if (retryCounter.getCount() > 1) {        retryCounter.countDown();        throw new Exception("Something went wrong");    } else {        retryCounter.countDown();    }}
public void curator_f2740_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2741_0() throws Exception
{    final int ITERATIONS = 1000;    Timing timing = new Timing();    DistributedQueue<String> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(ITERATIONS);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        QueueSerializer<String> serializer = new QueueSerializer<String>() {            @Override            public byte[] serialize(String item) {                return item.getBytes();            }            @Override            public String deserialize(byte[] bytes) {                return new String(bytes);            }        };        Executor executor = Executors.newCachedThreadPool();        final Set<String> used = Sets.newHashSet();        final Set<String> doubleUsed = Sets.newHashSet();        queue = new DistributedQueue<String>(client, consumer, serializer, QUEUE_PATH, QueueBuilder.defaultThreadFactory, executor, Integer.MAX_VALUE, false, "/lock", QueueBuilder.NOT_SET, true, timing.milliseconds()) {            @SuppressWarnings("SimplifiableConditionalExpression")            @Override            protected boolean processWithLockSafety(String itemNode, DistributedQueue.ProcessType type) throws Exception {                if (used.contains(itemNode)) {                    doubleUsed.add(itemNode);                } else {                    used.add(itemNode);                }                return (client.getState() == CuratorFrameworkState.STARTED) ? super.processWithLockSafety(itemNode, type) : false;            }        };        queue.start();        for (int i = 0; i < ITERATIONS; ++i) {            queue.put(Integer.toString(i));        }        Assert.assertTrue(timing.awaitLatch(latch));        Assert.assertTrue(doubleUsed.size() == 0, doubleUsed.toString());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2742_0(String message) throws Exception
{    latch.countDown();}
public void curator_f2743_0(CuratorFramework client, ConnectionState newState)
{}
public byte[] curator_f2744_0(String item)
{    return item.getBytes();}
public String curator_f2745_0(byte[] bytes)
{    return new String(bytes);}
protected boolean curator_f2746_0(String itemNode, DistributedQueue.ProcessType type) throws Exception
{    if (used.contains(itemNode)) {        doubleUsed.add(itemNode);    } else {        used.add(itemNode);    }    return (client.getState() == CuratorFrameworkState.STARTED) ? super.processWithLockSafety(itemNode, type) : false;}
public void curator_f2747_0() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        final AtomicInteger listenerCalls = new AtomicInteger(0);        QueuePutListener<TestQueueItem> listener = new QueuePutListener<TestQueueItem>() {            @Override            public void putCompleted(TestQueueItem item) {                listenerCalls.incrementAndGet();            }            @Override            public void putMultiCompleted(MultiItem<TestQueueItem> items) {            }        };        queue.getPutListenerContainer().addListener(listener);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, Integer.toString(i++));        }        Assert.assertEquals(listenerCalls.get(), itemQty);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2748_0(TestQueueItem item)
{    listenerCalls.incrementAndGet();}
public void curator_f2749_0(MultiItem<TestQueueItem> items)
{}
public void curator_f2750_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final AtomicReference<CountDownLatch> latch = new AtomicReference<CountDownLatch>(new CountDownLatch(1));        final AtomicInteger count = new AtomicInteger(0);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                if (count.incrementAndGet() < 2) {                    throw new Exception();                }                latch.get().countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        DistributedQueue<TestQueueItem> queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildQueue();        try {            queue.start();            TestQueueItem item = new TestQueueItem("1");            queue.put(item);            Assert.assertTrue(timing.awaitLatch(latch.get()));            Assert.assertEquals(count.get(), 2);            queue.setErrorMode(ErrorMode.DELETE);            count.set(0);            latch.set(new CountDownLatch(1));            item = new TestQueueItem("1");            queue.put(item);                        Assert.assertFalse(latch.get().await(5, TimeUnit.SECONDS));            Assert.assertEquals(count.get(), 1);        } finally {            queue.close();        }    } finally {        client.close();    }}
public void curator_f2751_0(TestQueueItem message) throws Exception
{    if (count.incrementAndGet() < 2) {        throw new Exception();    }    latch.get().countDown();}
public void curator_f2752_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2753_0() throws Exception
{    final int itemQty = 1000;    final int consumerQty = 4;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        DistributedQueue<TestQueueItem> producerQueue = QueueBuilder.builder(client, null, serializer, QUEUE_PATH).buildQueue();        try {            producerQueue.start();            for (int i = 0; i < itemQty; ++i) {                TestQueueItem item = new TestQueueItem(Integer.toString(i));                producerQueue.put(item);            }            producerQueue.flushPuts(timing.multiple(2).seconds(), TimeUnit.SECONDS);        } finally {            producerQueue.close();        }    } finally {        client.close();    }    final Set<String> consumedMessages = Sets.newHashSet();    final Set<String> duplicateMessages = Sets.newHashSet();    final CountDownLatch latch = new CountDownLatch(itemQty);    List<DistributedQueue<TestQueueItem>> consumers = Lists.newArrayList();    List<CuratorFramework> consumerClients = Lists.newArrayList();    try {        final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) {                synchronized (consumedMessages) {                    if (consumedMessages.contains(message.str)) {                        duplicateMessages.add(message.str);                    }                    consumedMessages.add(message.str);                }                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        for (int i = 0; i < consumerQty; ++i) {            CuratorFramework thisClient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            consumerClients.add(thisClient);            thisClient.start();            DistributedQueue<TestQueueItem> thisConsumer = QueueBuilder.builder(thisClient, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumers.add(thisConsumer);        }        for (DistributedQueue<TestQueueItem> consumer : consumers) {            consumer.start();        }        timing.awaitLatch(latch);        Assert.assertTrue(duplicateMessages.size() == 0, duplicateMessages.toString());    } finally {        for (DistributedQueue<TestQueueItem> consumer : consumers) {            CloseableUtils.closeQuietly(consumer);        }        for (CuratorFramework curatorFramework : consumerClients) {            CloseableUtils.closeQuietly(curatorFramework);        }    }}
public void curator_f2754_0(TestQueueItem message)
{    synchronized (consumedMessages) {        if (consumedMessages.contains(message.str)) {            duplicateMessages.add(message.str);        }        consumedMessages.add(message.str);    }    latch.countDown();}
public void curator_f2755_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2756_0() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> producerQueue = null;    DistributedQueue<TestQueueItem> consumerQueue1 = null;    DistributedQueue<TestQueueItem> consumerQueue2 = null;    CuratorFramework producerClient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework consumerClient1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework consumerClient2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        producerClient.start();        consumerClient1.start();        consumerClient2.start();        ExecutorService service = Executors.newCachedThreadPool();                {            producerQueue = QueueBuilder.builder(producerClient, null, serializer, QUEUE_PATH).buildQueue();            producerQueue.start();            QueueTestProducer producer = new QueueTestProducer(producerQueue, itemQty, 0);            service.submit(producer);        }        final Set<TestQueueItem> takenItems = Sets.newTreeSet();        final Set<TestQueueItem> takenItemsForConsumer1 = Sets.newTreeSet();        final Set<TestQueueItem> takenItemsForConsumer2 = Sets.newTreeSet();        final AtomicReference<TestQueueItem> thrownItemFromConsumer1 = new AtomicReference<TestQueueItem>(null);                {            final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {                @Override                public void consumeMessage(TestQueueItem message) throws Exception {                    synchronized (takenItems) {                        if (takenItems.size() > 10) {                            thrownItemFromConsumer1.set(message);                                                        throw new Exception("dummy");                        }                    }                    addToTakenItems(message, takenItems, itemQty);                    synchronized (takenItemsForConsumer1) {                        takenItemsForConsumer1.add(message);                    }                    Thread.sleep((long) (Math.random() * 5));                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            };            consumerQueue1 = QueueBuilder.builder(consumerClient1, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumerQueue1.start();        }                {            final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {                @Override                public void consumeMessage(TestQueueItem message) throws Exception {                    addToTakenItems(message, takenItems, itemQty);                    synchronized (takenItemsForConsumer2) {                        takenItemsForConsumer2.add(message);                    }                    Thread.sleep((long) (Math.random() * 5));                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            };            consumerQueue2 = QueueBuilder.builder(consumerClient2, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumerQueue2.start();        }        synchronized (takenItems) {            while (takenItems.size() < itemQty) {                takenItems.wait(1000);            }        }        int i = 0;        for (TestQueueItem item : takenItems) {            Assert.assertEquals(item.str, Integer.toString(i++));        }        Assert.assertNotNull(thrownItemFromConsumer1.get());        Assert.assertTrue((takenItemsForConsumer2.contains(thrownItemFromConsumer1.get())));        Assert.assertTrue(Sets.intersection(takenItemsForConsumer1, takenItemsForConsumer2).size() == 0);    } finally {        CloseableUtils.closeQuietly(producerQueue);        CloseableUtils.closeQuietly(consumerQueue1);        CloseableUtils.closeQuietly(consumerQueue2);        CloseableUtils.closeQuietly(producerClient);        CloseableUtils.closeQuietly(consumerClient1);        CloseableUtils.closeQuietly(consumerClient2);    }}
public void curator_f2757_0(TestQueueItem message) throws Exception
{    synchronized (takenItems) {        if (takenItems.size() > 10) {            thrownItemFromConsumer1.set(message);                        throw new Exception("dummy");        }    }    addToTakenItems(message, takenItems, itemQty);    synchronized (takenItemsForConsumer1) {        takenItemsForConsumer1.add(message);    }    Thread.sleep((long) (Math.random() * 5));}
public void curator_f2758_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2759_0(TestQueueItem message) throws Exception
{    addToTakenItems(message, takenItems, itemQty);    synchronized (takenItemsForConsumer2) {        takenItemsForConsumer2.add(message);    }    Thread.sleep((long) (Math.random() * 5));}
public void curator_f2760_0(CuratorFramework client, ConnectionState newState)
{}
private void curator_f2761_0(TestQueueItem message, Set<TestQueueItem> takenItems, int itemQty)
{    synchronized (takenItems) {        takenItems.add(message);        if (takenItems.size() > itemQty) {            takenItems.notifyAll();        }    }}
public void curator_f2762_0() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        final CountDownLatch latch = new CountDownLatch(1);        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < itemQty; ++i) {                    TestQueueItem item = consumer.take();                    Assert.assertEquals(item.str, Integer.toString(i));                }                latch.countDown();                return null;            }        });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public Object curator_f2763_0() throws Exception
{    for (int i = 0; i < itemQty; ++i) {        TestQueueItem item = consumer.take();        Assert.assertEquals(item.str, Integer.toString(i));    }    latch.countDown();    return null;}
public void curator_f2764_0() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        MultiItem<TestQueueItem> items = new MultiItem<TestQueueItem>() {            private int index = 0;            @Override            public TestQueueItem nextItem() throws Exception {                if (index >= itemQty) {                    return null;                }                return new TestQueueItem(Integer.toString(index++));            }        };        queue.putMulti(items);        for (int i = 0; i < itemQty; ++i) {            TestQueueItem queueItem = consumer.take(1, TimeUnit.SECONDS);            Assert.assertNotNull(queueItem);            Assert.assertEquals(queueItem, new TestQueueItem(Integer.toString(i)));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public TestQueueItem curator_f2765_0() throws Exception
{    if (index >= itemQty) {        return null;    }    return new TestQueueItem(Integer.toString(index++));}
public void curator_f2766_0() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer1 = new QueueTestProducer(queue, itemQty / 2, 0);        QueueTestProducer producer2 = new QueueTestProducer(queue, ((itemQty + 1) / 2), itemQty / 2);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer1);        service.submit(producer2);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        List<TestQueueItem> items = consumer.getItems();                Assert.assertEquals(com.google.common.collect.Sets.<TestQueueItem>newHashSet(items).size(), items.size());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2767_0() throws Exception
{    final Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    DistributedQueue<TestQueueItem> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean firstTime = new AtomicBoolean(true);        queue = new DistributedQueue<TestQueueItem>(client, null, serializer, "/test", new ThreadFactoryBuilder().build(), MoreExecutors.directExecutor(), 10, true, null, QueueBuilder.NOT_SET, true, 0) {            @Override            void internalCreateNode(final String path, final byte[] bytes, final BackgroundCallback callback) throws Exception {                if (firstTime.compareAndSet(true, false)) {                    Executors.newSingleThreadExecutor().submit(new Callable<Object>() {                        @Override                        public Object call() throws Exception {                            latch.await();                            timing.sleepABit();                            client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);                            return null;                        }                    });                } else {                    super.internalCreateNode(path, bytes, callback);                }            }        };        queue.start();        queue.put(new TestQueueItem("1"));        Assert.assertFalse(queue.flushPuts(timing.forWaiting().seconds(), TimeUnit.SECONDS));        latch.countDown();        Assert.assertTrue(queue.flushPuts(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        if (latch.getCount() > 0) {            latch.countDown();        }        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
 void curator_f2768_0(final String path, final byte[] bytes, final BackgroundCallback callback) throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                latch.await();                timing.sleepABit();                client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);                return null;            }        });    } else {        super.internalCreateNode(path, bytes, callback);    }}
public Object curator_f2769_0() throws Exception
{    latch.await();    timing.sleepABit();    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);    return null;}
public void curator_f2770_0() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, Integer.toString(i++));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
public int curator_f2771_0(TestQueueItem rhs)
{    if (this == rhs) {        return 0;    }    int val = Integer.parseInt(str);    int rhsVal = Integer.parseInt(rhs.str);    int diff = val - rhsVal;    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
public boolean curator_f2772_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestQueueItem that = (TestQueueItem) o;    return str.equals(that.str);}
public int curator_f2773_0()
{    return str.hashCode();}
public void curator_f2774_0() throws Exception
{    final int threshold = 100;    final int factor = 10;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    QueueSharder<String, DistributedQueue<String>> sharder = null;    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                latch.await();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);        QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(threshold).thresholdCheckMs(1).build();        sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);        sharder.start();        for (int i = 0; i < (factor * threshold); ++i) {            sharder.getQueue().put(Integer.toString(i));            Thread.sleep(5);        }        timing.forWaiting().sleepABit();        SummaryStatistics statistics = new SummaryStatistics();        for (String path : sharder.getQueuePaths()) {            int numChildren = client.checkExists().forPath(path).getNumChildren();            Assert.assertTrue(numChildren > 0);            Assert.assertTrue(numChildren >= (threshold * .1));            statistics.addValue(numChildren);        }        latch.countDown();        Assert.assertTrue(statistics.getMean() >= (threshold * .9));    } finally {                timing.sleepABit();        CloseableUtils.closeQuietly(sharder);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2775_0(String message) throws Exception
{    latch.await();}
public void curator_f2776_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2777_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final BlockingQueueConsumer<String> consumer = makeConsumer(null);    QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);    QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(2).thresholdCheckMs(1).build();    QueueSharder<String, DistributedQueue<String>> sharder1 = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    QueueSharder<String, DistributedQueue<String>> sharder2 = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    try {        client.start();        sharder1.start();        sharder2.start();        for (int i = 0; i < 20; ++i) {            sharder1.getQueue().put(Integer.toString(i));        }        timing.sleepABit();        Assert.assertTrue((sharder1.getShardQty() > 1) || (sharder2.getShardQty() > 1));        timing.forWaiting().sleepABit();        Assert.assertEquals(sharder1.getShardQty(), sharder2.getShardQty());    } finally {                timing.sleepABit();        CloseableUtils.closeQuietly(sharder1);        CloseableUtils.closeQuietly(sharder2);        CloseableUtils.closeQuietly(client);    }}
public void curator_f2778_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final CountDownLatch latch = new CountDownLatch(1);    final BlockingQueueConsumer<String> consumer = makeConsumer(latch);    QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);    QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(2).thresholdCheckMs(1).build();    QueueSharder<String, DistributedQueue<String>> sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    try {        client.start();        sharder.start();        sharder.getQueue().put("one");        sharder.getQueue().put("two");        sharder.getQueue().put("three");        sharder.getQueue().put("four");        latch.countDown();        timing.sleepABit();        sharder.getQueue().put("five");        sharder.getQueue().put("six");        sharder.getQueue().put("seven");        sharder.getQueue().put("eight");        timing.sleepABit();        Assert.assertTrue(sharder.getShardQty() > 1);        Set<String> consumed = Sets.newHashSet();        for (int i = 0; i < 8; ++i) {            String s = consumer.take(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);            Assert.assertNotNull(s);            consumed.add(s);        }        Assert.assertEquals(consumed, Sets.newHashSet("one", "two", "three", "four", "five", "six", "seven", "eight"));        int shardQty = sharder.getShardQty();        sharder.close();                sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);        sharder.start();        Assert.assertEquals(sharder.getShardQty(), shardQty);    } finally {        CloseableUtils.closeQuietly(sharder);        CloseableUtils.closeQuietly(client);    }}
private QueueAllocator<String, DistributedQueue<String>> curator_f2779_0(final QueueConsumer<String> consumer)
{    final QueueSerializer<String> serializer = new QueueSerializer<String>() {        @Override        public byte[] serialize(String item) {            return item.getBytes();        }        @Override        public String deserialize(byte[] bytes) {            return new String(bytes);        }    };    return new QueueAllocator<String, DistributedQueue<String>>() {        @Override        public DistributedQueue<String> allocateQueue(CuratorFramework client, String queuePath) {            return QueueBuilder.<String>builder(client, consumer, serializer, queuePath).buildQueue();        }    };}
public byte[] curator_f2780_0(String item)
{    return item.getBytes();}
public String curator_f2781_0(byte[] bytes)
{    return new String(bytes);}
public DistributedQueue<String> curator_f2782_0(CuratorFramework client, String queuePath)
{    return QueueBuilder.<String>builder(client, consumer, serializer, queuePath).buildQueue();}
private BlockingQueueConsumer<String> curator_f2783_0(final CountDownLatch latch)
{    ConnectionStateListener connectionStateListener = new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    return new BlockingQueueConsumer<String>(connectionStateListener) {        @Override        public void consumeMessage(String message) throws Exception {            if (latch != null) {                latch.await();            }            super.consumeMessage(message);        }    };}
public void curator_f2784_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2785_0(String message) throws Exception
{    if (latch != null) {        latch.await();    }    super.consumeMessage(message);}
public void curator_f2786_0()
{    try {        for (int i = 0; i < ITEM_COUNT; i++) {            processItem(i);            Thread.sleep(sleepMillis);        }    } catch (Exception e) {        throw new RuntimeException(e);    }}
public void curator_f2787_0() throws Exception
{        server.close();    System.setProperty("znode.container.checkIntervalMs", "100");    server = new TestingServer();    Timing timing = new Timing().multiple(.1);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        ExecutorService executor = Executors.newFixedThreadPool(2);        executor.execute(new QueueUser(client, timing.milliseconds()) {            @Override            protected void processItem(int itemNumber) throws Exception {                System.out.println("Offering item");                queue.offer(new byte[] { (byte) itemNumber });            }        });        executor.execute(new QueueUser(client, timing.multiple(.5).milliseconds()) {            @Override            protected void processItem(int itemNumber) throws Exception {                System.out.println("Taking item " + itemNumber);                byte[] item = queue.take();                if (item == null) {                    throw new IllegalStateException("Null result for item " + itemNumber);                }                System.out.println("Got item " + item[0]);            }        });        executor.shutdown();        Assert.assertTrue(executor.awaitTermination((QueueUser.ITEM_COUNT * 2) * timing.milliseconds(), TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(client);        System.clearProperty("znode.container.checkIntervalMs");    }}
protected void curator_f2788_0(int itemNumber) throws Exception
{    System.out.println("Offering item");    queue.offer(new byte[] { (byte) itemNumber });}
protected void curator_f2789_0(int itemNumber) throws Exception
{    System.out.println("Taking item " + itemNumber);    byte[] item = queue.take();    if (item == null) {        throw new IllegalStateException("Null result for item " + itemNumber);    }    System.out.println("Got item " + item[0]);}
public void curator_f2790_0() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer1";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        Assert.assertNull(queueHandles[0].poll(3, TimeUnit.SECONDS));    } finally {        closeAll(clients);    }}
public void curator_f2791_0() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer1";        String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[0].remove();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
public void curator_f2792_0() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer2";        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[1].remove();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
public void curator_f2793_0() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testTake1";        String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[0].take();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
public void curator_f2794_0() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testRemove1";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        try {            queueHandles[0].remove();        } catch (NoSuchElementException e) {            return;        }        assertTrue(false);    } finally {        closeAll(clients);    }}
public void curator_f2795_0(String dir, int n, int m) throws Exception
{    CuratorFramework[] clients = null;    try {        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        for (int i = 0; i < n; i++) {            String offerString = testString + i;            queueHandles[0].offer(offerString.getBytes());        }        byte[] data = null;        for (int i = 0; i < m; i++) {            data = queueHandles[1].remove();        }        assertEquals(new String(data), testString + (m - 1));    } finally {        closeAll(clients);    }}
public void curator_f2796_0() throws Exception
{    createNremoveMtest("/testRemove2", 10, 2);}
public void curator_f2797_0() throws Exception
{    createNremoveMtest("/testRemove3", 1000, 1000);}
public void curator_f2798_0(String dir, int n, int m) throws Exception
{    CuratorFramework[] clients = null;    try {        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        for (int i = 0; i < n; i++) {            String offerString = testString + i;            queueHandles[0].offer(offerString.getBytes());        }        for (int i = 0; i < m; i++) {            queueHandles[1].remove();        }        assertEquals(new String(queueHandles[1].element()), testString + m);    } finally {        closeAll(clients);    }}
public void curator_f2799_0() throws Exception
{    createNremoveMelementTest("/testElement1", 1, 0);}
public void curator_f2800_0() throws Exception
{    createNremoveMelementTest("/testElement2", 10, 2);}
public void curator_f2801_0() throws Exception
{    createNremoveMelementTest("/testElement3", 1000, 500);}
public void curator_f2802_0() throws Exception
{    createNremoveMelementTest("/testElement4", 1000, 1000 - 1);}
public void curator_f2803_0() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testTakeWait1";        final String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        final SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        final byte[][] takeResult = new byte[1][];        Thread takeThread = new Thread() {            public void run() {                try {                    takeResult[0] = queueHandles[0].take();                } catch (Exception e) {                                }            }        };        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread() {            public void run() {                try {                    queueHandles[0].offer(testString.getBytes());                } catch (Exception e) {                                }            }        };        offerThread.start();        offerThread.join();        takeThread.join();        assertTrue(takeResult[0] != null);        assertEquals(new String(takeResult[0]), testString);    } finally {        closeAll(clients);    }}
public void curator_f2804_0()
{    try {        takeResult[0] = queueHandles[0].take();    } catch (Exception e) {        }}
public void curator_f2805_0()
{    try {        queueHandles[0].offer(testString.getBytes());    } catch (Exception e) {        }}
public void curator_f2806_0() throws Exception
{    String dir = "/testTakeWait2";    final String testString = "Hello World";    final int num_clients = 1;    final CuratorFramework[] clients = new CuratorFramework[num_clients];    final SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];    for (int i = 0; i < clients.length; i++) {        clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        clients[i].start();        queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);    }    int num_attempts = 2;    for (int i = 0; i < num_attempts; i++) {        final byte[][] takeResult = new byte[1][];        final String threadTestString = testString + i;        Thread takeThread = new Thread() {            public void run() {                try {                    takeResult[0] = queueHandles[0].take();                } catch (Exception e) {                                }            }        };        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread() {            public void run() {                try {                    queueHandles[0].offer(threadTestString.getBytes());                } catch (Exception e) {                                }            }        };        offerThread.start();        offerThread.join();        takeThread.join();        assertTrue(takeResult[0] != null);        assertEquals(new String(takeResult[0]), threadTestString);    }}
public void curator_f2807_0()
{    try {        takeResult[0] = queueHandles[0].take();    } catch (Exception e) {        }}
public void curator_f2808_0()
{    try {        queueHandles[0].offer(threadTestString.getBytes());    } catch (Exception e) {        }}
private void curator_f2809_0(CuratorFramework[] clients)
{    if (clients != null) {        for (CuratorFramework c : clients) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f2810_0() throws Exception
{    final int CLIENT_QTY = 5;    List<Future<List<Integer>>> futures = Lists.newArrayList();    final List<CuratorFramework> clients = new CopyOnWriteArrayList<CuratorFramework>();    final List<SharedCount> counts = new CopyOnWriteArrayList<SharedCount>();    try {        final CountDownLatch startLatch = new CountDownLatch(CLIENT_QTY);        final Semaphore semaphore = new Semaphore(0);        ExecutorService service = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("Test-%d").build());        for (int i = 0; i < CLIENT_QTY; ++i) {            Future<List<Integer>> future = service.submit(new Callable<List<Integer>>() {                @Override                public List<Integer> call() throws Exception {                    final List<Integer> countList = Lists.newArrayList();                    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));                    clients.add(client);                    client.start();                                        client.checkExists().forPath("/");                    SharedCount count = new SharedCount(client, "/count", 10);                    counts.add(count);                    final CountDownLatch latch = new CountDownLatch(1);                    count.addListener(new SharedCountListener() {                        @Override                        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                            if (newCount < 0) {                                latch.countDown();                            } else {                                countList.add(newCount);                            }                            semaphore.release();                        }                        @Override                        public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }                    });                    count.start();                    startLatch.countDown();                    latch.await();                    return countList;                }            });            futures.add(future);        }        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        clients.add(client);        client.start();                client.checkExists().forPath("/");        Assert.assertTrue(startLatch.await(10, TimeUnit.SECONDS));        SharedCount count = new SharedCount(client, "/count", 10);        counts.add(count);        count.start();        List<Integer> countList = Lists.newArrayList();        Random random = new Random();        for (int i = 0; i < 100; ++i) {            Thread.sleep(random.nextInt(10));            int next = random.nextInt(100);            countList.add(next);            count.setCount(next);            Assert.assertTrue(semaphore.tryAcquire(CLIENT_QTY, 10, TimeUnit.SECONDS));        }        count.setCount(-1);        for (Future<List<Integer>> future : futures) {            List<Integer> thisCountList = future.get();            Assert.assertEquals(thisCountList, countList);        }    } finally {        for (SharedCount count : counts) {            CloseableUtils.closeQuietly(count);        }        for (CuratorFramework client : clients) {            TestCleanState.closeAndTestClean(client);        }    }}
public List<Integer> curator_f2811_0() throws Exception
{    final List<Integer> countList = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    clients.add(client);    client.start();        client.checkExists().forPath("/");    SharedCount count = new SharedCount(client, "/count", 10);    counts.add(count);    final CountDownLatch latch = new CountDownLatch(1);    count.addListener(new SharedCountListener() {        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            if (newCount < 0) {                latch.countDown();            } else {                countList.add(newCount);            }            semaphore.release();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    });    count.start();    startLatch.countDown();    latch.await();    return countList;}
public void curator_f2812_0(SharedCountReader sharedCount, int newCount) throws Exception
{    if (newCount < 0) {        latch.countDown();    } else {        countList.add(newCount);    }    semaphore.release();}
public void curator_f2813_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2814_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count = new SharedCount(client, "/count", 0);    try {        client.start();        count.start();        final CountDownLatch setLatch = new CountDownLatch(3);        SharedCountListener listener = new SharedCountListener() {            @Override            public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                setLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        count.addListener(listener);        Assert.assertTrue(count.trySetCount(1));        timing.sleepABit();        Assert.assertTrue(count.trySetCount(2));        timing.sleepABit();        Assert.assertTrue(count.trySetCount(10));        timing.sleepABit();        Assert.assertEquals(count.getCount(), 10);        Assert.assertTrue(new Timing().awaitLatch(setLatch));    } finally {        CloseableUtils.closeQuietly(count);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2815_0(SharedCountReader sharedCount, int newCount) throws Exception
{    setLatch.countDown();}
public void curator_f2816_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2817_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count = new SharedCount(client, "/count", 0);    client.start();    try {        count.start();        VersionedValue<Integer> current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 0);        Assert.assertTrue(count.trySetCount(current, 1));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 1);        Assert.assertEquals(count.getCount(), 1);        Assert.assertTrue(count.trySetCount(current, 5));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 2);        Assert.assertEquals(count.getCount(), 5);        Assert.assertTrue(count.trySetCount(current, 10));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 3);        Assert.assertEquals(count.getCount(), 10);                Assert.assertFalse(count.trySetCount(new VersionedValue<Integer>(3, 20), 7));                Assert.assertFalse(count.trySetCount(new VersionedValue<Integer>(10, 10), 7));                client.setData().forPath("/count", SharedCount.toBytes(88));        Assert.assertFalse(count.trySetCount(current, 234));    } finally {        CloseableUtils.closeQuietly(count);        TestCleanState.closeAndTestClean(client);    }}
public void curator_f2818_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count1 = new SharedCount(client1, "/count", 0);    SharedCount count2 = new SharedCount(client2, "/count", 0);    try {        client1.start();        client2.start();        count1.start();        count2.start();        VersionedValue<Integer> versionedValue = count1.getVersionedValue();        Assert.assertTrue(count1.trySetCount(versionedValue, 10));        timing.sleepABit();        versionedValue = count2.getVersionedValue();        Assert.assertTrue(count2.trySetCount(versionedValue, 20));        timing.sleepABit();        final CountDownLatch setLatch = new CountDownLatch(2);        SharedCountListener listener = new SharedCountListener() {            @Override            public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                setLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        count1.addListener(listener);        VersionedValue<Integer> versionedValue1 = count1.getVersionedValue();        VersionedValue<Integer> versionedValue2 = count2.getVersionedValue();        Assert.assertTrue(count2.trySetCount(versionedValue2, 30));        Assert.assertFalse(count1.trySetCount(versionedValue1, 40));        versionedValue1 = count1.getVersionedValue();        Assert.assertTrue(count1.trySetCount(versionedValue1, 40));        Assert.assertTrue(timing.awaitLatch(setLatch));    } finally {        CloseableUtils.closeQuietly(count2);        CloseableUtils.closeQuietly(count1);        TestCleanState.closeAndTestClean(client2);        TestCleanState.closeAndTestClean(client1);    }}
public void curator_f2819_0(SharedCountReader sharedCount, int newCount) throws Exception
{    setLatch.countDown();}
public void curator_f2820_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f2821_0() throws Exception
{    CuratorFramework client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count1 = new SharedCount(client1, "/count", 10);    SharedCount count2 = new SharedCount(client2, "/count", 20);    try {        client1.start();        client2.start();        count1.start();        count2.start();        Assert.assertEquals(count1.getCount(), 10);        Assert.assertEquals(count2.getCount(), 10);    } finally {        CloseableUtils.closeQuietly(count2);        CloseableUtils.closeQuietly(count1);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client1);    }}
public void curator_f2822_0() throws Exception
{    final CountDownLatch gotSuspendEvent = new CountDownLatch(1);    CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 1000));    curatorFramework.start();    curatorFramework.blockUntilConnected();    SharedCount sharedCount = new SharedCount(curatorFramework, "/count", 10);    sharedCount.start();    curatorFramework.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.countDown();            }        }    });    try {        server.stop();                Assert.assertTrue(gotSuspendEvent.await(5, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(sharedCount);        TestCleanState.closeAndTestClean(curatorFramework);    }}
public void curator_f2823_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.countDown();    }}
public void curator_f2824_0() throws Exception
{    final CountDownLatch gotSuspendEvent = new CountDownLatch(1);    final CountDownLatch gotChangeEvent = new CountDownLatch(1);    final CountDownLatch getReconnectEvent = new CountDownLatch(1);    final AtomicInteger numChangeEvents = new AtomicInteger(0);    CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    curatorFramework.start();    curatorFramework.blockUntilConnected();    SharedCount sharedCount = new SharedCount(curatorFramework, "/count", 10);    sharedCount.addListener(new SharedCountListener() {        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            numChangeEvents.incrementAndGet();            gotChangeEvent.countDown();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.countDown();            } else if (newState == ConnectionState.RECONNECTED) {                getReconnectEvent.countDown();            }        }    });    sharedCount.start();    try {        sharedCount.setCount(11);        Assert.assertTrue(gotChangeEvent.await(2, TimeUnit.SECONDS));        server.stop();        Assert.assertTrue(gotSuspendEvent.await(2, TimeUnit.SECONDS));        server.restart();        Assert.assertTrue(getReconnectEvent.await(2, TimeUnit.SECONDS));        Assert.assertEquals(numChangeEvents.get(), 1);        sharedCount.trySetCount(sharedCount.getVersionedValue(), 12);                final CountDownLatch flushDone = new CountDownLatch(1);        curatorFramework.getData().inBackground(new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                flushDone.countDown();            }        }).forPath("/count");        flushDone.await(5, TimeUnit.SECONDS);                        Assert.assertEquals(numChangeEvents.get(), 3);    } finally {        CloseableUtils.closeQuietly(sharedCount);        TestCleanState.closeAndTestClean(curatorFramework);    }}
public void curator_f2825_0(SharedCountReader sharedCount, int newCount) throws Exception
{    numChangeEvents.incrementAndGet();    gotChangeEvent.countDown();}
public void curator_f2826_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        getReconnectEvent.countDown();    }}
public void curator_f2827_0(CuratorFramework client, CuratorEvent event) throws Exception
{    flushDone.countDown();}
public void curator_f2828_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework curatorFramework1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    CuratorFramework curatorFramework2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    curatorFramework1.start();        curatorFramework1.checkExists().forPath("/");    curatorFramework2.start();        curatorFramework2.checkExists().forPath("/");    final String sharedCountPath = "/count";    final int initialCount = 10;    SharedCount sharedCount1 = new SharedCount(curatorFramework1, sharedCountPath, initialCount);    SharedCount sharedCountWithFaultyWatcher = createSharedCountWithFaultyWatcher(curatorFramework2, sharedCountPath, initialCount);    class MySharedCountListener implements SharedCountListener {        final public Phaser gotSuspendEvent = new Phaser(1);        final public Phaser gotChangeEvent = new Phaser(1);        final public Phaser getReconnectEvent = new Phaser(1);        final public AtomicInteger numChangeEvents = new AtomicInteger(0);        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            numChangeEvents.incrementAndGet();            gotChangeEvent.arrive();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.arrive();            } else if (newState == ConnectionState.RECONNECTED) {                getReconnectEvent.arrive();            }        }    }    MySharedCountListener listener1 = new MySharedCountListener();    sharedCount1.addListener(listener1);    sharedCount1.start();    MySharedCountListener listener2 = new MySharedCountListener();    sharedCountWithFaultyWatcher.addListener(listener2);    try {        sharedCount1.setCount(12);        Assert.assertEquals(listener1.gotChangeEvent.awaitAdvanceInterruptibly(0, timing.seconds(), TimeUnit.SECONDS), 1);        Assert.assertEquals(sharedCount1.getCount(), 12);        Assert.assertEquals(sharedCountWithFaultyWatcher.getCount(), 10);                sharedCountWithFaultyWatcher.start();        for (int i = 0; i < 10; i++) {            sharedCount1.setCount(13 + i);            Assert.assertEquals(sharedCount1.getCount(), 13 + i);            server.restart();            Assert.assertEquals(listener2.getReconnectEvent.awaitAdvanceInterruptibly(i, timing.forWaiting().seconds(), TimeUnit.SECONDS), i + 1);                                    Assert.assertEquals(listener2.gotChangeEvent.awaitAdvanceInterruptibly(i, timing.forWaiting().seconds(), TimeUnit.SECONDS), i + 1);            Assert.assertEquals(sharedCountWithFaultyWatcher.getCount(), 13 + i);        }    } finally {        CloseableUtils.closeQuietly(sharedCount1);        CloseableUtils.closeQuietly(curatorFramework1);        CloseableUtils.closeQuietly(sharedCountWithFaultyWatcher);        CloseableUtils.closeQuietly(curatorFramework2);    }}
public void curator_f2829_0(SharedCountReader sharedCount, int newCount) throws Exception
{    numChangeEvents.incrementAndGet();    gotChangeEvent.arrive();}
public void curator_f2830_0(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.arrive();    } else if (newState == ConnectionState.RECONNECTED) {        getReconnectEvent.arrive();    }}
private SharedCount curator_f2831_0(CuratorFramework curatorFramework, String path, int val)
{    final CuratorWatcher faultyWatcher = new CuratorWatcher() {        @Override        public void process(WatchedEvent event) throws Exception {                }    };    class FaultySharedValue extends SharedValue {        public FaultySharedValue(CuratorFramework client, String path, byte[] seedValue) {            super(client.newWatcherRemoveCuratorFramework(), path, seedValue, faultyWatcher);        }    }    ;    final SharedValue faultySharedValue = new FaultySharedValue(curatorFramework, path, SharedCount.toBytes(val));    class FaultySharedCount extends SharedCount {        public FaultySharedCount(CuratorFramework client, String path, int val) {            super(client, path, faultySharedValue);        }    }    ;    return new FaultySharedCount(curatorFramework, path, val);}
public void curator_f2832_0(WatchedEvent event) throws Exception
{}
public void curator_f2833_0(ITestContext context)
{    IInvokedMethodListener2 methodListener2 = new IInvokedMethodListener2() {        @Override        public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {            method.getTestMethod().setRetryAnalyzer(BaseClassForTests.this::retry);        }        @Override        public void beforeInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {            beforeInvocation(method, testResult);        }        @Override        public void afterInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {                }        @Override        public void afterInvocation(IInvokedMethod method, ITestResult testResult) {                }    };    context.getSuite().addListener(methodListener2);}
public void curator_f2834_0(IInvokedMethod method, ITestResult testResult)
{    method.getTestMethod().setRetryAnalyzer(BaseClassForTests.this::retry);}
public void curator_f2835_0(IInvokedMethod method, ITestResult testResult, ITestContext context)
{    beforeInvocation(method, testResult);}
public void curator_f2836_0(IInvokedMethod method, ITestResult testResult, ITestContext context)
{}
public void curator_f2837_0(IInvokedMethod method, ITestResult testResult)
{}
public void curator_f2838_0() throws Exception
{    if (INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES != null) {        System.setProperty(INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES, "true");    }    System.setProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND, "true");    System.setProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY, "true");    createServer();}
protected void curator_f2839_0() throws Exception
{    while (server == null) {        try {            server = new TestingServer();        } catch (BindException e) {            System.err.println("Getting bind exception - retrying to allocate server");            server = null;        }    }}
public void curator_f2840_0() throws Exception
{    System.clearProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY);    System.clearProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND);    if (server != null) {        try {            server.close();        } catch (IOException e) {            e.printStackTrace();        } finally {            server = null;        }    }}
private boolean curator_f2841_1(ITestResult result)
{    if (result.isSuccess() || isRetrying.get()) {        isRetrying.set(false);        return false;    }    result.setStatus(ITestResult.SKIP);    if (result.getThrowable() != null) {            } else {            }    isRetrying.set(true);    return true;}
public int curator_f2842_0()
{    return (int) TimeUnit.MILLISECONDS.convert(value, unit);}
public int curator_f2843_0()
{    return (int) value;}
public boolean curator_f2844_0(CountDownLatch latch)
{    Timing2 m = forWaiting();    try {        return latch.await(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
public T curator_f2845_0(BlockingQueue<T> queue) throws Exception
{    Timing2 m = forWaiting();    try {        T value = queue.poll(m.value, m.unit);        if (value == null) {            throw new TimeoutException("Timed out trying to take from queue");        }        return value;    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw e;    }}
public boolean curator_f2846_0(Semaphore semaphore)
{    Timing2 m = forWaiting();    try {        return semaphore.tryAcquire(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
public boolean curator_f2847_0(Semaphore semaphore, int n)
{    Timing2 m = forWaiting();    try {        return semaphore.tryAcquire(n, m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
public Timing2 curator_f2848_0(double n)
{    return new Timing2((int) (value * n), unit);}
public Timing2 curator_f2849_0(double n, int waitingMultiple)
{    return new Timing2((int) (value * n), unit, waitingMultiple);}
public Timing2 curator_f2850_0()
{    return multiple(waitingMultiple);}
public Timing2 curator_f2851_0()
{    return multiple(SESSION_SLEEP_MULTIPLE, 1);}
public Timing2 curator_f2852_0()
{    return multiple(.25);}
public void curator_f2853_0() throws InterruptedException
{    forSleepingABit().sleep();}
public void curator_f2854_0() throws InterruptedException
{    unit.sleep(value);}
public int curator_f2855_0()
{    return multiple(SESSION_MULTIPLE).milliseconds();}
public int curator_f2856_0()
{    return milliseconds();}
private static Integer curator_f2857_0()
{    return Integer.getInteger("timing-waiting-multiple", DEFAULT_WAITING_MULTIPLE);}
public List<IMethodInstance> curator_f2858_0(List<IMethodInstance> methods, ITestContext context)
{    if (!Compatibility.isZK34()) {        return methods;    }    List<IMethodInstance> filteredMethods = new ArrayList<>();    for (IMethodInstance method : methods) {        if (!isInGroup(method.getMethod().getGroups())) {            filteredMethods.add(method);        }    }    return filteredMethods;}
private boolean curator_f2859_0(String[] groups)
{    return (groups != null) && Arrays.asList(groups).contains(zk35Group);}
public static boolean curator_f2860_0()
{    return false;}
public void curator_f2861_0()
{    delegate.shutdown();}
public List<Runnable> curator_f2862_0()
{    return delegate.shutdownNow();}
public boolean curator_f2863_0()
{    return delegate.isShutdown();}
public boolean curator_f2864_0()
{    return delegate.isTerminated();}
public boolean curator_f2865_0(long timeout, TimeUnit unit) throws InterruptedException
{    return delegate.awaitTermination(timeout, unit);}
public Future<T> curator_f2866_0(Callable<T> task)
{    return delegate.submit(task);}
public Future<T> curator_f2867_0(Runnable task, T result)
{    return delegate.submit(task, result);}
public Future<?> curator_f2868_0(Runnable task)
{    return delegate.submit(task);}
public List<Future<T>> curator_f2869_0(Collection<? extends Callable<T>> tasks) throws InterruptedException
{    return delegate.invokeAll(tasks);}
public List<Future<T>> curator_f2870_0(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException
{    return delegate.invokeAll(tasks, timeout, unit);}
public T curator_f2871_0(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
{    return delegate.invokeAny(tasks);}
public T curator_f2872_0(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    return delegate.invokeAny(tasks, timeout, unit);}
public void curator_f2873_0(Runnable command)
{    delegate.execute(command);}
public static void curator_f2874_1(File file) throws IOException
{    if (file.isDirectory()) {        deleteDirectoryContents(file);    }    if (!file.delete()) {            }}
public static void curator_f2875_1(File directory) throws IOException
{    Preconditions.checkArgument(directory.isDirectory(), "Not a directory: %s", directory);    File[] files = directory.listFiles();    if (files == null) {                return;    }    for (File file : files) {        deleteRecursively(file);    }}
public synchronized void curator_f2876_0(Runnable command)
{    executeCalled = true;    super.execute(command);}
public synchronized boolean curator_f2877_0()
{    return executeCalled;}
public synchronized void curator_f2878_0(boolean executeCalled)
{    this.executeCalled = executeCalled;}
public static void curator_f2879_0()
{    nextServerId.set(1);}
public static InstanceSpec curator_f2880_0()
{    return new InstanceSpec(null, -1, -1, -1, true, -1, -1, -1);}
public static int curator_f2881_0()
{    ServerSocket server = null;    try {        server = new ServerSocket(0);        return server.getLocalPort();    } catch (IOException e) {        throw new Error(e);    } finally {        if (server != null) {            try {                server.close();            } catch (IOException ignore) {                        }        }    }}
public int curator_f2882_0()
{    return serverId;}
public File curator_f2883_0()
{    return dataDirectory;}
public int curator_f2884_0()
{    return port;}
public int curator_f2885_0()
{    return electionPort;}
public int curator_f2886_0()
{    return quorumPort;}
public String curator_f2887_0()
{    return hostname + ":" + port;}
public int curator_f2888_0()
{    return tickTime;}
public int curator_f2889_0()
{    return maxClientCnxns;}
public boolean curator_f2890_0()
{    return deleteDataDirectoryOnClose;}
public Map<String, Object> curator_f2891_0()
{    return customProperties;}
public String curator_f2892_0()
{    return hostname;}
public String curator_f2893_0()
{    return "InstanceSpec{" + "dataDirectory=" + dataDirectory + ", port=" + port + ", electionPort=" + electionPort + ", quorumPort=" + quorumPort + ", deleteDataDirectoryOnClose=" + deleteDataDirectoryOnClose + ", serverId=" + serverId + ", tickTime=" + tickTime + ", maxClientCnxns=" + maxClientCnxns + ", customProperties=" + customProperties + ", hostname=" + hostname + "} " + super.toString();}
public boolean curator_f2894_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    InstanceSpec that = (InstanceSpec) o;    return hostname.equals(that.getHostname()) && port == that.port;}
public int curator_f2895_0()
{    return hostname.hashCode() + port;}
public static void curator_f2896_0(ZooKeeper client)
{    client.getTestable().injectSessionExpiration();}
public static void curator_f2897_0(ZooKeeper client, String connectString) throws Exception
{    kill(client);}
public static void curator_f2898_0(ZooKeeper client, String connectString, int maxMs) throws Exception
{    kill(client);}
public boolean curator_f2899_0()
{    return fromRandom;}
public QuorumPeerConfig curator_f2900_0() throws Exception
{    return buildConfig(0);}
public InstanceSpec curator_f2901_0(int index)
{    return instanceSpecs.get(index);}
public List<InstanceSpec> curator_f2902_0()
{    return instanceSpecs;}
public int curator_f2903_0()
{    return instanceSpecs.size();}
public void curator_f2904_0()
{    if (fakeConfigFile != null) {                fakeConfigFile.delete();    }}
public QuorumPeerConfig curator_f2905_0(int instanceIndex) throws Exception
{    boolean isCluster = (instanceSpecs.size() > 1);    InstanceSpec spec = instanceSpecs.get(instanceIndex);    if (isCluster) {        Files.write(Integer.toString(spec.getServerId()).getBytes(), new File(spec.getDataDirectory(), "myid"));    }    Properties properties = new Properties();    properties.setProperty("initLimit", "10");    properties.setProperty("syncLimit", "5");    properties.setProperty("dataDir", spec.getDataDirectory().getCanonicalPath());    properties.setProperty("clientPort", Integer.toString(spec.getPort()));    int tickTime = spec.getTickTime();    if (tickTime >= 0) {        properties.setProperty("tickTime", Integer.toString(tickTime));    }    int maxClientCnxns = spec.getMaxClientCnxns();    if (maxClientCnxns >= 0) {        properties.setProperty("maxClientCnxns", Integer.toString(maxClientCnxns));    }    if (isCluster) {        for (InstanceSpec thisSpec : instanceSpecs) {            properties.setProperty("server." + thisSpec.getServerId(), String.format("%s:%d:%d;%s:%d", thisSpec.getHostname(), thisSpec.getQuorumPort(), thisSpec.getElectionPort(), thisSpec.getHostname(), thisSpec.getPort()));        }    }    Map<String, Object> customProperties = spec.getCustomProperties();    if (customProperties != null) {        for (Map.Entry<String, Object> property : customProperties.entrySet()) {            properties.put(property.getKey(), property.getValue());        }    }    QuorumPeerConfig config = new QuorumPeerConfig() {        {            if (fakeConfigFile != null) {                configFileStr = fakeConfigFile.getPath();            }        }    };    config.parseProperties(properties);    return config;}
 static Object curator_f2906_0(ZooKeeperServer server, int port) throws Exception
{    Object factory;    if (nioServerCnxn != null) {        factory = nioServerCnxn.constructor.newInstance(new InetSocketAddress(port));        if (server != null) {            nioServerCnxn.startupMethod.invoke(factory, server);        }    } else {        factory = serverCnxnFactoryMethods.constructor.newInstance();        serverCnxnFactoryMethods.configureMethod.invoke(factory, new InetSocketAddress(port), 0);        if (server != null) {            serverCnxnFactoryMethods.startupMethod.invoke(factory, server);        }    }    return factory;}
 static void curator_f2907_0(Object factory)
{    try {        if (nioServerCnxn != null) {            nioServerCnxn.shutdownMethod.invoke(factory);        } else {            serverCnxnFactoryMethods.shutdownMethod.invoke(factory);        }    } catch (Exception e) {        e.printStackTrace();        throw new Error(e);    }}
public Collection<InstanceSpec> curator_f2908_0()
{    Iterable<InstanceSpec> transformed = Iterables.transform(servers, new Function<TestingZooKeeperServer, InstanceSpec>() {        @Override        public InstanceSpec apply(TestingZooKeeperServer server) {            return server.getInstanceSpec();        }    });    return Lists.newArrayList(transformed);}
public InstanceSpec curator_f2909_0(TestingZooKeeperServer server)
{    return server.getInstanceSpec();}
public List<TestingZooKeeperServer> curator_f2910_0()
{    return Lists.newArrayList(servers);}
public String curator_f2911_0()
{    StringBuilder str = new StringBuilder();    for (InstanceSpec spec : getInstances()) {        if (str.length() > 0) {            str.append(",");        }        str.append(spec.getConnectString());    }    return str.toString();}
public void curator_f2912_0() throws Exception
{    for (TestingZooKeeperServer server : servers) {        server.start();    }}
public void curator_f2913_0() throws IOException
{    for (TestingZooKeeperServer server : servers) {        server.stop();    }}
public void curator_f2914_0() throws IOException
{    for (TestingZooKeeperServer server : servers) {        server.close();    }}
public boolean curator_f2915_0(InstanceSpec instance) throws Exception
{    for (TestingZooKeeperServer server : servers) {        if (server.getInstanceSpec().equals(instance)) {            server.kill();            return true;        }    }    return false;}
public boolean curator_f2916_0(InstanceSpec instance) throws Exception
{    for (TestingZooKeeperServer server : servers) {        if (server.getInstanceSpec().equals(instance)) {            server.restart();            return true;        }    }    return false;}
public InstanceSpec curator_f2917_0(ZooKeeper client) throws Exception
{    Method m = client.getClass().getDeclaredMethod("testableRemoteSocketAddress");    m.setAccessible(true);    InetSocketAddress address = (InetSocketAddress) m.invoke(client);    if (address != null) {        for (TestingZooKeeperServer server : servers) {            if (server.getInstanceSpec().getPort() == address.getPort()) {                return server.getInstanceSpec();            }        }    }    return null;}
public static Map<InstanceSpec, Collection<InstanceSpec>> curator_f2918_0(int instanceQty)
{    return makeSpecs(instanceQty, true);}
public static Map<InstanceSpec, Collection<InstanceSpec>> curator_f2919_0(int instanceQty, boolean resetServerIds)
{    if (resetServerIds) {        InstanceSpec.reset();    }    ImmutableList.Builder<InstanceSpec> builder = ImmutableList.builder();    for (int i = 0; i < instanceQty; ++i) {        builder.add(InstanceSpec.newInstanceSpec());    }    return listToMap(builder.build());}
private static Map<InstanceSpec, Collection<InstanceSpec>> curator_f2920_0(Collection<InstanceSpec> list)
{    ImmutableMap.Builder<InstanceSpec, Collection<InstanceSpec>> mapBuilder = ImmutableMap.builder();    for (InstanceSpec spec : list) {        mapBuilder.put(spec, list);    }    return mapBuilder.build();}
public void curator_f2921_0()
{    try {        if (quorumPeer != null) {            Field cnxnFactoryField = QuorumPeer.class.getDeclaredField("cnxnFactory");            cnxnFactoryField.setAccessible(true);            ServerCnxnFactory cnxnFactory = (ServerCnxnFactory) cnxnFactoryField.get(quorumPeer);            cnxnFactory.closeAll();            Field ssField = cnxnFactory.getClass().getDeclaredField("ss");            ssField.setAccessible(true);            ServerSocketChannel ss = (ServerSocketChannel) ssField.get(cnxnFactory);            ss.close();        }        close();    } catch (Exception e) {        e.printStackTrace();    }}
public QuorumPeer curator_f2922_0()
{    return quorumPeer;}
public void curator_f2923_0() throws IOException
{    if ((quorumPeer != null) && !isClosed) {        isClosed = true;        quorumPeer.shutdown();    }}
public void curator_f2924_0() throws Exception
{    long startTime = System.currentTimeMillis();    while ((quorumPeer == null) && ((System.currentTimeMillis() - startTime) <= TestingZooKeeperMain.MAX_WAIT_MS)) {        try {            Thread.sleep(10);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            break;        }    }    if (quorumPeer == null) {        throw new Exception("quorumPeer never got set");    }}
public int curator_f2925_0()
{    return spec.getPort();}
public File curator_f2926_0()
{    return spec.getDataDirectory();}
public void curator_f2927_0() throws Exception
{    testingZooKeeperServer.start();}
public void curator_f2928_0() throws IOException
{    testingZooKeeperServer.stop();}
public void curator_f2929_0() throws Exception
{    testingZooKeeperServer.restart();}
public void curator_f2930_0() throws IOException
{    testingZooKeeperServer.close();}
public String curator_f2931_0()
{    return spec.getConnectString();}
public void curator_f2932_0()
{    try {        if (cnxnFactory != null) {            cnxnFactory.closeAll();            Field ssField = cnxnFactory.getClass().getDeclaredField("ss");            ssField.setAccessible(true);            ServerSocketChannel ss = (ServerSocketChannel) ssField.get(cnxnFactory);            ss.close();        }        close();    } catch (Exception e) {                e.printStackTrace();    }}
public void curator_f2933_1(QuorumPeerConfig config) throws Exception
{    try {        Field instance = MBeanRegistry.class.getDeclaredField("instance");        instance.setAccessible(true);        MBeanRegistry nopMBeanRegistry = new MBeanRegistry() {            @Override            public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException {                        }            @Override            public void unregister(ZKMBeanInfo bean) {                        }        };        instance.set(null, nopMBeanRegistry);    } catch (Exception e) {            }    ServerConfig serverConfig = new ServerConfig();    serverConfig.readFrom(config);    try {        internalRunFromConfig(serverConfig);    } catch (IOException e) {        startingException.set(e);        throw e;    }}
public void curator_f2934_0(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException
{}
public void curator_f2935_0(ZKMBeanInfo bean)
{}
public void curator_f2936_0() throws Exception
{    if (!timing.awaitLatch(latch))        throw new IllegalStateException("Timed out waiting for watch removal");    if (zkServer != null) {                synchronized (zkServer) {            while (!zkServer.isRunning()) {                zkServer.wait();            }        }    } else {        throw new Exception("No zkServer.");    }    Exception exception = startingException.get();    if (exception != null) {        throw exception;    }}
public void curator_f2937_0() throws IOException
{    try {        cnxnFactory.shutdown();    } catch (Throwable e) {                e.printStackTrace();    } finally {        cnxnFactory = null;    }    if (containerManager != null) {        containerManager.stop();        containerManager = null;    }    try {        if (zkServer != null) {            zkServer.shutdown();            ZKDatabase zkDb = zkServer.getZKDatabase();            if (zkDb != null) {                                zkDb.close();            }        }    } catch (Throwable e) {                e.printStackTrace();    } finally {        zkServer = null;    }}
private void curator_f2938_1(ServerConfig config) throws IOException
{        FileTxnSnapLog txnLog = null;    try {                                        txnLog = new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir());        zkServer = new TestZooKeeperServer(txnLog, config);        try {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns());        } catch (IOException e) {                        timing.sleepABit();            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns());        }        cnxnFactory.startup(zkServer);        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.getFirstProcessor(), Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1L)), Integer.getInteger("znode.container.maxPerMinute", 10000));        containerManager.start();        latch.countDown();        cnxnFactory.join();        if ((zkServer != null) && zkServer.isRunning()) {            zkServer.shutdown();        }    } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {        if (txnLog != null) {            txnLog.close();        }    }}
public RequestProcessor curator_f2939_0()
{    return firstProcessor;}
protected void curator_f2940_0(State state)
{    this.state = state;}
protected void curator_f2941_0()
{}
protected void curator_f2942_0()
{}
public boolean curator_f2943_0()
{    return isRunning.get() || super.isRunning();}
public void curator_f2944_0()
{    synchronized (this) {        isRunning.set(true);        this.notifyAll();    }}
private boolean curator_f2945_0()
{    return configBuilder.size() > 1;}
public QuorumPeer curator_f2946_0()
{    if (isCluster()) {        return ((TestingQuorumPeerMain) main).getTestingQuorumPeer();    }    throw new UnsupportedOperationException();}
public Collection<InstanceSpec> curator_f2947_0()
{    return configBuilder.getInstanceSpecs();}
public void curator_f2948_0()
{    main.kill();    state.set(State.STOPPED);}
public void curator_f2949_0() throws Exception
{        if (state.get() == State.CLOSED) {        throw new IllegalStateException("Cannot restart a closed instance");    }        if (state.get() == State.STARTED) {        stop();    }        state.set(State.LATENT);    main = isCluster() ? new TestingQuorumPeerMain() : new TestingZooKeeperMain();    start();}
public void curator_f2950_0() throws IOException
{    if (state.compareAndSet(State.STARTED, State.STOPPED)) {        main.close();    }}
public InstanceSpec curator_f2951_0()
{    return configBuilder.getInstanceSpec(thisInstanceIndex);}
public void curator_f2952_0() throws IOException
{    stop();    if (state.compareAndSet(State.STOPPED, State.CLOSED)) {        configBuilder.close();        InstanceSpec spec = getInstanceSpec();        if (spec.deleteDataDirectoryOnClose()) {            DirectoryUtils.deleteRecursively(spec.getDataDirectory());        }    }}
public void curator_f2953_1() throws Exception
{    if (!state.compareAndSet(State.LATENT, State.STARTED)) {        return;    }    new Thread(new Runnable() {        public void run() {            try {                QuorumPeerConfig config = configBuilder.buildConfig(thisInstanceIndex);                main.runFromConfig(config);            } catch (Exception e) {                            }        }    }).start();    main.blockUntilStarted();}
public void curator_f2954_1()
{    try {        QuorumPeerConfig config = configBuilder.buildConfig(thisInstanceIndex);        main.runFromConfig(config);    } catch (Exception e) {            }}
public int curator_f2955_0()
{    return (int) TimeUnit.MILLISECONDS.convert(value, unit);}
public int curator_f2956_0()
{    return (int) value;}
public boolean curator_f2957_0(CountDownLatch latch)
{    Timing m = forWaiting();    try {        return latch.await(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
public boolean curator_f2958_0(Semaphore semaphore)
{    Timing m = forWaiting();    try {        return semaphore.tryAcquire(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
public boolean curator_f2959_0(Semaphore semaphore, int n)
{    Timing m = forWaiting();    try {        return semaphore.tryAcquire(n, m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
public Timing curator_f2960_0(double n)
{    return new Timing((int) (value * n), unit);}
public Timing curator_f2961_0()
{    return multiple(waitingMultiple);}
public void curator_f2962_0() throws InterruptedException
{    unit.sleep(value / 4);}
public int curator_f2963_0()
{    return multiple(SESSION_MULTIPLE).milliseconds();}
public int curator_f2964_0()
{    return milliseconds();}
private static Integer curator_f2965_0()
{    return Integer.getInteger("timing-waiting-multiple", DEFAULT_WAITING_MULTIPLE);}
public static List<String> curator_f2966_0(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, WatchersDebug.getDataWatches);}
public static List<String> curator_f2967_0(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, getExistWatches);}
public static List<String> curator_f2968_0(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, getChildWatches);}
private static Method curator_f2969_0(String name) throws NoSuchMethodException
{    Method m = ZooKeeper.class.getDeclaredMethod(name);    m.setAccessible(true);    return m;}
private static List<String> curator_f2970_0(ZooKeeper zooKeeper, Method method)
{    if (zooKeeper == null) {        return null;    }    try {                return (List<String>) method.invoke(zooKeeper);    } catch (Exception e) {        throw new RuntimeException(e);    }}
public void curator_f2971_0() throws Exception
{    Map<String, Object> customProperties = new HashMap<String, Object>();    customProperties.put("authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    customProperties.put("kerberos.removeHostFromPrincipal", "true");    customProperties.put("kerberos.removeRealmFromPrincipal", "true");    InstanceSpec spec = new InstanceSpec(null, -1, -1, -1, true, 1, -1, -1, customProperties);    TestingServer server = new TestingServer(spec, true);    try {        assertEquals("org.apache.zookeeper.server.auth.SASLAuthenticationProvider", System.getProperty("zookeeper.authProvider.1"));        assertEquals("true", System.getProperty("zookeeper.kerberos.removeHostFromPrincipal"));        assertEquals("true", System.getProperty("zookeeper.kerberos.removeRealmFromPrincipal"));    } finally {        server.close();    }}
public static boolean curator_f2972_0()
{    return true;}
public void curator_f2973_0()
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    Assert.assertTrue(client.isZk34CompatibilityMode());}
public void curator_f2974_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().withTtl(100).forPath("/foo");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2975_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.reconfig().withNewMembers("a", "b");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2976_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getConfig().forEnsemble();    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f2977_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.watches().removeAll();    } finally {        CloseableUtils.closeQuietly(client);    }}
 static AsyncCuratorFramework curator_f2978_0(CuratorFramework client)
{    return new AsyncCuratorFrameworkImpl(client);}
 static CompletionStage<AsyncResult<T>> curator_f2979_0(AsyncStage<T> stage)
{    return stage.handle((value, ex) -> {        if (ex != null) {            if (ex instanceof KeeperException) {                return new AsyncResultImpl<T>(((KeeperException) ex).code());            }            return new AsyncResultImpl<T>(ex);        }        return new AsyncResultImpl<T>(value);    });}
public static CompletionStage<Map<String, byte[]>> curator_f2980_0(AsyncCuratorFramework client, String path)
{    return childrenWithData(client, path, false);}
public static CompletionStage<Map<String, byte[]>> curator_f2981_0(AsyncCuratorFramework client, String path, boolean isCompressed)
{    CompletableFuture<Map<String, byte[]>> future = new CompletableFuture<>();    client.getChildren().forPath(path).handle((children, e) -> {        if (e != null) {            if (Throwables.getRootCause(e) instanceof KeeperException.NoNodeException) {                future.complete(Maps.newHashMap());            } else {                future.completeExceptionally(e);            }        } else {            completeChildren(client, future, path, children, isCompressed);        }        return null;    });    return future;}
public static CompletionStage<Void> curator_f2982_0(AsyncCuratorFramework client, String path)
{    return ensure(client, path, ExistsOption.createParentsIfNeeded);}
public static CompletionStage<Void> curator_f2983_0(AsyncCuratorFramework client, String path)
{    return ensure(client, path, ExistsOption.createParentsAsContainers);}
public static CompletionStage<Void> curator_f2984_0(InterProcessLock lock, long timeout, TimeUnit unit, Executor executor)
{    CompletableFuture<Void> future = new CompletableFuture<>();    if (executor == null) {        CompletableFuture.runAsync(() -> lock(future, lock, timeout, unit));    } else {        CompletableFuture.runAsync(() -> lock(future, lock, timeout, unit), executor);    }    return future;}
public static CompletionStage<Boolean> curator_f2985_0(InterProcessLock lock, long timeout, TimeUnit unit, Executor executor)
{    CompletableFuture<Boolean> future = new CompletableFuture<>();    if (executor == null) {        CompletableFuture.runAsync(() -> lockIf(future, lock, timeout, unit));    } else {        CompletableFuture.runAsync(() -> lockIf(future, lock, timeout, unit), executor);    }    return future;}
public static CompletionStage<Void> curator_f2986_0(InterProcessLock lock, Executor executor)
{    return lockAsync(lock, 0, null, executor);}
public static CompletionStage<Void> curator_f2987_0(InterProcessLock lock, long timeout, TimeUnit unit)
{    return lockAsync(lock, timeout, unit, null);}
public static CompletionStage<Boolean> curator_f2988_0(InterProcessLock lock, long timeout, TimeUnit unit)
{    return lockAsyncIf(lock, timeout, unit, null);}
public static CompletionStage<Void> curator_f2989_0(InterProcessLock lock)
{    return lockAsync(lock, 0, null, null);}
public static void curator_f2990_0(InterProcessLock lock)
{    release(lock, true);}
public static void curator_f2991_0(InterProcessLock lock, boolean ignoreNoLockExceptions)
{    try {        lock.release();    } catch (IllegalStateException e) {        if (!ignoreNoLockExceptions) {            throw new RuntimeException(e);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new RuntimeException(e);    }}
private static void curator_f2992_0(CompletableFuture<Boolean> future, InterProcessLock lock, long timeout, TimeUnit unit)
{    try {        future.complete(lock.acquire(timeout, unit));    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        future.completeExceptionally(e);    }}
private static void curator_f2993_0(CompletableFuture<Void> future, InterProcessLock lock, long timeout, TimeUnit unit)
{    try {        if (unit != null) {            if (lock.acquire(timeout, unit)) {                future.complete(null);            } else {                future.completeExceptionally(new TimeoutException());            }        } else {            lock.acquire();            future.complete(null);        }    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        future.completeExceptionally(e);    }}
private static void curator_f2994_0(AsyncCuratorFramework client, CompletableFuture<Map<String, byte[]>> future, String parentPath, List<String> children, boolean isCompressed)
{    Map<String, byte[]> nodes = Maps.newHashMap();    if (children.size() == 0) {        future.complete(nodes);        return;    }    children.forEach(node -> {        String path = ZKPaths.makePath(parentPath, node);        AsyncStage<byte[]> stage = isCompressed ? client.getData().decompressed().forPath(path) : client.getData().forPath(path);        stage.handle((data, e) -> {            if (e != null) {                future.completeExceptionally(e);            } else {                nodes.put(path, data);                if (nodes.size() == children.size()) {                    future.complete(nodes);                }            }            return null;        });    });}
private static CompletionStage<Void> curator_f2995_0(AsyncCuratorFramework client, String path, ExistsOption option)
{    String localPath = ZKPaths.makePath(path, "foo");    return client.checkExists().withOptions(Collections.singleton(option)).forPath(localPath).thenApply(__ -> null);}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f2996_0(Stat stat)
{    this.stat = stat;    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f2997_0(CreateMode createMode)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f2998_0(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f2999_0(long ttl)
{    this.ttl = ttl;    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3000_0(int version)
{    this.setDataVersion = version;    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3001_0(Set<CreateOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3002_0(Set<CreateOption> options, List<ACL> aclList)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3003_0(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3004_0(Set<CreateOption> options, CreateMode createMode)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3005_0(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3006_0(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat, long ttl)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    this.ttl = ttl;    return this;}
public AsyncPathAndBytesable<AsyncStage<String>> curator_f3007_0(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat, long ttl, int setDataVersion)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    this.ttl = ttl;    this.setDataVersion = setDataVersion;    return this;}
public AsyncStage<String> curator_f3008_0(String path)
{    return internalForPath(path, null, false);}
public AsyncStage<String> curator_f3009_0(String path, byte[] data)
{    return internalForPath(path, data, true);}
private AsyncStage<String> curator_f3010_0(String path, byte[] data, boolean useData)
{    BuilderCommon<String> common = new BuilderCommon<>(filters, nameProc);    CreateBuilderImpl builder = new CreateBuilderImpl(client, createMode, common.backgrounding, options.contains(CreateOption.createParentsIfNeeded) || options.contains(CreateOption.createParentsAsContainers), options.contains(CreateOption.createParentsAsContainers), options.contains(CreateOption.doProtected), options.contains(CreateOption.compress), options.contains(CreateOption.setDataIfExists), aclList, stat, ttl);    builder.setSetDataIfExistsVersion(setDataVersion);    return safeCall(common.internalCallback, () -> useData ? builder.forPath(path, data) : builder.forPath(path));}
private static CuratorFrameworkImpl curator_f3011_0(CuratorFramework client)
{    try {        return (CuratorFrameworkImpl) Objects.requireNonNull(client, "client cannot be null");    } catch (Exception e) {        throw new IllegalArgumentException("Only Curator clients created through CuratorFrameworkFactory are supported: " + client.getClass().getName());    }}
public AsyncCreateBuilder curator_f3012_0()
{    return new AsyncCreateBuilderImpl(client, filters);}
public AsyncDeleteBuilder curator_f3013_0()
{    return new AsyncDeleteBuilderImpl(client, filters);}
public AsyncSetDataBuilder curator_f3014_0()
{    return new AsyncSetDataBuilderImpl(client, filters);}
public AsyncGetACLBuilder curator_f3015_0()
{    return new AsyncGetACLBuilder() {        private Stat stat = null;        @Override        public AsyncPathable<AsyncStage<List<ACL>>> storingStatIn(Stat stat) {            this.stat = stat;            return this;        }        @Override        public AsyncStage<List<ACL>> forPath(String path) {            BuilderCommon<List<ACL>> common = new BuilderCommon<>(filters, aclProc);            GetACLBuilderImpl builder = new GetACLBuilderImpl(client, common.backgrounding, stat);            return safeCall(common.internalCallback, () -> builder.forPath(path));        }    };}
public AsyncPathable<AsyncStage<List<ACL>>> curator_f3016_0(Stat stat)
{    this.stat = stat;    return this;}
public AsyncStage<List<ACL>> curator_f3017_0(String path)
{    BuilderCommon<List<ACL>> common = new BuilderCommon<>(filters, aclProc);    GetACLBuilderImpl builder = new GetACLBuilderImpl(client, common.backgrounding, stat);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
public AsyncSetACLBuilder curator_f3018_0()
{    return new AsyncSetACLBuilderImpl(client, filters);}
public AsyncReconfigBuilder curator_f3019_0()
{    return new AsyncReconfigBuilderImpl(client, filters);}
public AsyncMultiTransaction curator_f3020_0()
{    return operations -> {        BuilderCommon<List<CuratorTransactionResult>> common = new BuilderCommon<>(filters, opResultsProc);        CuratorMultiTransactionImpl builder = new CuratorMultiTransactionImpl(client, common.backgrounding);        return safeCall(common.internalCallback, () -> builder.forOperations(operations));    };}
public AsyncSyncBuilder curator_f3021_0()
{    return path -> {        BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);        SyncBuilderImpl builder = new SyncBuilderImpl(client, common.backgrounding);        return safeCall(common.internalCallback, () -> builder.forPath(path));    };}
public AsyncRemoveWatchesBuilder curator_f3022_0()
{    return new AsyncRemoveWatchesBuilderImpl(client, filters);}
public CuratorFramework curator_f3023_0()
{    return client;}
public WatchableAsyncCuratorFramework curator_f3024_0()
{    return new AsyncCuratorFrameworkImpl(client, filters, watchMode, true);}
public AsyncCuratorFrameworkDsl curator_f3025_0(WatchMode mode)
{    return new AsyncCuratorFrameworkImpl(client, filters, mode, watched);}
public AsyncCuratorFrameworkDsl curator_f3026_0(WatchMode mode, UnhandledErrorListener listener, UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, filters.getResultFilter(), filters.getWatcherFilter()), mode, watched);}
public AsyncCuratorFrameworkDsl curator_f3027_0(UnhandledErrorListener listener)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, filters.getResultFilter(), filters.getWatcherFilter()), watchMode, watched);}
public AsyncCuratorFrameworkDsl curator_f3028_0(UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(filters.getListener(), resultFilter, watcherFilter), watchMode, watched);}
public AsyncCuratorFrameworkDsl curator_f3029_0(UnhandledErrorListener listener, UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, resultFilter, watcherFilter), watchMode, watched);}
public AsyncTransactionOp curator_f3030_0()
{    return new AsyncTransactionOpImpl(client);}
public AsyncExistsBuilder curator_f3031_0()
{    return new AsyncExistsBuilderImpl(client, filters, getBuilderWatchMode());}
public AsyncGetDataBuilder curator_f3032_0()
{    return new AsyncGetDataBuilderImpl(client, filters, getBuilderWatchMode());}
public AsyncGetChildrenBuilder curator_f3033_0()
{    return new AsyncGetChildrenBuilderImpl(client, filters, getBuilderWatchMode());}
public AsyncGetConfigBuilder curator_f3034_0()
{    return new AsyncGetConfigBuilderImpl(client, filters, getBuilderWatchMode());}
private WatchMode curator_f3035_0()
{    return watched ? watchMode : null;}
public AsyncPathable<AsyncStage<Void>> curator_f3036_0(Set<DeleteOption> options)
{    return withOptionsAndVersion(options, -1);}
public AsyncPathable<AsyncStage<Void>> curator_f3037_0(Set<DeleteOption> options, int version)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.version = version;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3038_0(int version)
{    this.version = version;    return this;}
public AsyncStage<Void> curator_f3039_0(String path)
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    DeleteBuilderImpl builder = new DeleteBuilderImpl(client, version, common.backgrounding, options.contains(DeleteOption.deletingChildrenIfNeeded), options.contains(DeleteOption.guaranteed), options.contains(DeleteOption.quietly));    return safeCall(common.internalCallback, () -> builder.forPath(path));}
public AsyncPathable<AsyncStage<Stat>> curator_f3040_0(Set<ExistsOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    return this;}
public AsyncStage<Stat> curator_f3041_0(String path)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, watchMode, safeStatProc);    ExistsBuilderImpl builder = new ExistsBuilderImpl(client, common.backgrounding, common.watcher, options.contains(ExistsOption.createParentsIfNeeded), options.contains(ExistsOption.createParentsAsContainers));    return safeCall(common.internalCallback, () -> builder.forPath(path));}
public AsyncStage<List<String>> curator_f3042_0(String path)
{    BuilderCommon<List<String>> common = new BuilderCommon<>(filters, watchMode, childrenProc);    GetChildrenBuilderImpl builder = new GetChildrenBuilderImpl(client, common.watcher, common.backgrounding, stat);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
public AsyncPathable<AsyncStage<List<String>>> curator_f3043_0(Stat stat)
{    this.stat = stat;    return this;}
public AsyncEnsemblable<AsyncStage<byte[]>> curator_f3044_0(Stat stat)
{    this.stat = stat;    return this;}
public AsyncStage<byte[]> curator_f3045_0()
{    BuilderCommon<byte[]> common = new BuilderCommon<>(filters, watchMode, dataProc);    GetConfigBuilderImpl builder = new GetConfigBuilderImpl(client, common.backgrounding, common.watcher, stat);    return safeCall(common.internalCallback, builder::forEnsemble);}
public AsyncPathable<AsyncStage<byte[]>> curator_f3046_0()
{    decompressed = true;    return this;}
public AsyncPathable<AsyncStage<byte[]>> curator_f3047_0(Stat stat)
{    this.stat = stat;    return this;}
public AsyncPathable<AsyncStage<byte[]>> curator_f3048_0(Stat stat)
{    decompressed = true;    this.stat = stat;    return this;}
public AsyncStage<byte[]> curator_f3049_0(String path)
{    BuilderCommon<byte[]> common = new BuilderCommon<>(filters, watchMode, dataProc);    GetDataBuilderImpl builder = new GetDataBuilderImpl(client, stat, common.watcher, common.backgrounding, decompressed);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3050_0(List<String> servers)
{    this.newMembers = servers;    return this;}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3051_0(List<String> joining, List<String> leaving)
{    this.joining = joining;    this.leaving = leaving;    return this;}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3052_0(List<String> servers, Stat stat)
{    this.newMembers = servers;    this.stat = stat;    return this;}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3053_0(List<String> joining, List<String> leaving, Stat stat)
{    this.joining = joining;    this.leaving = leaving;    return this;}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3054_0(List<String> servers, Stat stat, long fromConfig)
{    this.newMembers = servers;    this.stat = stat;    this.fromConfig = fromConfig;    return this;}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3055_0(List<String> joining, List<String> leaving, Stat stat, long fromConfig)
{    this.joining = joining;    this.leaving = leaving;    this.stat = stat;    this.fromConfig = fromConfig;    return this;}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3056_0(List<String> servers, long fromConfig)
{    this.newMembers = servers;    this.fromConfig = fromConfig;    return this;}
public AsyncEnsemblable<AsyncStage<Void>> curator_f3057_0(List<String> joining, List<String> leaving, long fromConfig)
{    this.joining = joining;    this.leaving = leaving;    this.fromConfig = fromConfig;    return this;}
public AsyncStage<Void> curator_f3058_0()
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    ReconfigBuilderImpl builder = new ReconfigBuilderImpl(client, common.backgrounding, stat, fromConfig, newMembers, joining, leaving);    return safeCall(common.internalCallback, () -> {        builder.forEnsemble();        return null;    });}
public AsyncPathable<AsyncStage<Void>> curator_f3059_0(Watcher watcher)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.curatorWatcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3060_0(CuratorWatcher watcher)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3061_0()
{    this.curatorWatcher = null;    this.watcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3062_0(Watcher watcher, Set<RemoveWatcherOption> options)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.curatorWatcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3063_0(CuratorWatcher watcher, Set<RemoveWatcherOption> options)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3064_0(Set<RemoveWatcherOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3065_0(Watcher watcher, Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3066_0(CuratorWatcher watcher, Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.watcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3067_0(Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3068_0(Watcher watcher, Watcher.WatcherType watcherType)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3069_0(CuratorWatcher watcher, Watcher.WatcherType watcherType)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.watcher = null;    return this;}
public AsyncPathable<AsyncStage<Void>> curator_f3070_0(Watcher.WatcherType watcherType)
{    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
public AsyncStage<Void> curator_f3071_0(String path)
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    RemoveWatchesBuilderImpl builder = new RemoveWatchesBuilderImpl(client, watcher, curatorWatcher, watcherType, options.contains(RemoveWatcherOption.guaranteed), options.contains(RemoveWatcherOption.local), options.contains(RemoveWatcherOption.guaranteed), common.backgrounding);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
public T curator_f3072_0()
{    return value;}
public Optional<T> curator_f3073_0()
{    return Optional.ofNullable(value);}
public KeeperException.Code curator_f3074_0()
{    return code;}
public Throwable curator_f3075_0()
{    return exception;}
public Optional<Throwable> curator_f3076_0()
{    return Optional.ofNullable(exception);}
public void curator_f3077_0()
{    if (exception != null) {        throw new RuntimeException(exception);    }}
public void curator_f3078_0()
{    checkException();    if (code != KeeperException.Code.OK) {        throw new RuntimeException(KeeperException.create(code));    }}
public boolean curator_f3079_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    AsyncResultImpl<?> that = (AsyncResultImpl<?>) o;    if (value != null ? !value.equals(that.value) : that.value != null) {        return false;    }        if (code != that.code) {        return false;    }    return exception != null ? exception.equals(that.exception) : that.exception == null;}
public int curator_f3080_0()
{    int result = value != null ? value.hashCode() : 0;    result = 31 * result + code.hashCode();    result = 31 * result + (exception != null ? exception.hashCode() : 0);    return result;}
public String curator_f3081_0()
{    return "AsyncResult{" + "value=" + value + ", code=" + code + ", exception=" + exception + '}';}
public AsyncPathable<AsyncStage<Stat>> curator_f3082_0(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
public AsyncPathable<AsyncStage<Stat>> curator_f3083_0(List<ACL> aclList, int version)
{    this.aclList = aclList;    this.version = version;    return this;}
public AsyncStage<Stat> curator_f3084_0(String path)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, statProc);    SetACLBuilderImpl builder = new SetACLBuilderImpl(client, common.backgrounding, aclList, version);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
public AsyncStage<Stat> curator_f3085_0(String path)
{    return internalForPath(path, null, false);}
public AsyncStage<Stat> curator_f3086_0(String path, byte[] data)
{    return internalForPath(path, data, true);}
public AsyncPathAndBytesable<AsyncStage<Stat>> curator_f3087_0()
{    compressed = true;    return this;}
public AsyncPathAndBytesable<AsyncStage<Stat>> curator_f3088_0(int version)
{    compressed = true;    this.version = version;    return this;}
public AsyncPathAndBytesable<AsyncStage<Stat>> curator_f3089_0(int version)
{    this.version = version;    return this;}
private AsyncStage<Stat> curator_f3090_0(String path, byte[] data, boolean useData)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, statProc);    SetDataBuilderImpl builder = new SetDataBuilderImpl(client, common.backgrounding, version, compressed);    return safeCall(common.internalCallback, () -> useData ? builder.forPath(path, data) : builder.forPath(path));}
public AsyncTransactionCreateBuilder curator_f3091_0()
{    return new AsyncTransactionCreateBuilder() {        private List<ACL> aclList = null;        private CreateMode createMode = CreateMode.PERSISTENT;        private boolean compressed = false;        private long ttl = -1;        @Override        public AsyncPathAndBytesable<CuratorOp> withMode(CreateMode createMode) {            this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withACL(List<ACL> aclList) {            this.aclList = aclList;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> compressed() {            compressed = true;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withTtl(long ttl) {            this.ttl = ttl;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed) {            return withOptions(createMode, aclList, compressed, ttl);        }        @Override        public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed, long ttl) {            this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");            this.aclList = aclList;            this.compressed = compressed;            this.ttl = ttl;            return this;        }        @Override        public CuratorOp forPath(String path, byte[] data) {            return internalForPath(path, data, true);        }        @Override        public CuratorOp forPath(String path) {            return internalForPath(path, null, false);        }        private CuratorOp internalForPath(String path, byte[] data, boolean useData) {            TransactionCreateBuilder2<CuratorOp> builder1 = (ttl > 0) ? client.transactionOp().create().withTtl(ttl) : client.transactionOp().create();            ACLPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed().withMode(createMode) : builder1.withMode(createMode);            PathAndBytesable<CuratorOp> builder3 = builder2.withACL(aclList);            try {                return useData ? builder3.forPath(path, data) : builder3.forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
public AsyncPathAndBytesable<CuratorOp> curator_f3092_0(CreateMode createMode)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
public AsyncPathAndBytesable<CuratorOp> curator_f3093_0(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
public AsyncPathAndBytesable<CuratorOp> curator_f3094_0()
{    compressed = true;    return this;}
public AsyncPathAndBytesable<CuratorOp> curator_f3095_0(long ttl)
{    this.ttl = ttl;    return this;}
public AsyncPathAndBytesable<CuratorOp> curator_f3096_0(CreateMode createMode, List<ACL> aclList, boolean compressed)
{    return withOptions(createMode, aclList, compressed, ttl);}
public AsyncPathAndBytesable<CuratorOp> curator_f3097_0(CreateMode createMode, List<ACL> aclList, boolean compressed, long ttl)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.aclList = aclList;    this.compressed = compressed;    this.ttl = ttl;    return this;}
public CuratorOp curator_f3098_0(String path, byte[] data)
{    return internalForPath(path, data, true);}
public CuratorOp curator_f3099_0(String path)
{    return internalForPath(path, null, false);}
private CuratorOp curator_f3100_0(String path, byte[] data, boolean useData)
{    TransactionCreateBuilder2<CuratorOp> builder1 = (ttl > 0) ? client.transactionOp().create().withTtl(ttl) : client.transactionOp().create();    ACLPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed().withMode(createMode) : builder1.withMode(createMode);    PathAndBytesable<CuratorOp> builder3 = builder2.withACL(aclList);    try {        return useData ? builder3.forPath(path, data) : builder3.forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
public AsyncTransactionDeleteBuilder curator_f3101_0()
{    return new AsyncTransactionDeleteBuilder() {        private int version = -1;        @Override        public AsyncPathable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public CuratorOp forPath(String path) {            try {                return client.transactionOp().delete().withVersion(version).forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
public AsyncPathable<CuratorOp> curator_f3102_0(int version)
{    this.version = version;    return this;}
public CuratorOp curator_f3103_0(String path)
{    try {        return client.transactionOp().delete().withVersion(version).forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
public AsyncTransactionSetDataBuilder curator_f3104_0()
{    return new AsyncTransactionSetDataBuilder() {        private int version = -1;        private boolean compressed = false;        @Override        public AsyncPathAndBytesable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> compressed() {            compressed = true;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withVersionCompressed(int version) {            this.version = version;            compressed = true;            return this;        }        @Override        public CuratorOp forPath(String path, byte[] data) {            return internalForPath(path, data, true);        }        @Override        public CuratorOp forPath(String path) {            return internalForPath(path, null, false);        }        private CuratorOp internalForPath(String path, byte[] data, boolean useData) {            TransactionSetDataBuilder<CuratorOp> builder1 = client.transactionOp().setData();            VersionPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed() : builder1;            PathAndBytesable<CuratorOp> builder3 = builder2.withVersion(version);            try {                return useData ? builder3.forPath(path, data) : builder3.forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
public AsyncPathAndBytesable<CuratorOp> curator_f3105_0(int version)
{    this.version = version;    return this;}
public AsyncPathAndBytesable<CuratorOp> curator_f3106_0()
{    compressed = true;    return this;}
public AsyncPathAndBytesable<CuratorOp> curator_f3107_0(int version)
{    this.version = version;    compressed = true;    return this;}
public CuratorOp curator_f3108_0(String path, byte[] data)
{    return internalForPath(path, data, true);}
public CuratorOp curator_f3109_0(String path)
{    return internalForPath(path, null, false);}
private CuratorOp curator_f3110_0(String path, byte[] data, boolean useData)
{    TransactionSetDataBuilder<CuratorOp> builder1 = client.transactionOp().setData();    VersionPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed() : builder1;    PathAndBytesable<CuratorOp> builder3 = builder2.withVersion(version);    try {        return useData ? builder3.forPath(path, data) : builder3.forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
public AsyncTransactionCheckBuilder curator_f3111_0()
{    return new AsyncTransactionCheckBuilder() {        private int version = -1;        @Override        public AsyncPathable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public CuratorOp forPath(String path) {            try {                return client.transactionOp().check().withVersion(version).forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
public AsyncPathable<CuratorOp> curator_f3112_0(int version)
{    this.version = version;    return this;}
public CuratorOp curator_f3113_0(String path)
{    try {        return client.transactionOp().check().withVersion(version).forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
 static BackgroundProc<T> curator_f3114_0(Function<CuratorEvent, T> proc)
{    return (event, future) -> {        if (event.getResultCode() == 0) {            future.complete(proc.apply(event));        } else {            future.completeExceptionally(KeeperException.create(KeeperException.Code.get(event.getResultCode()), event.getPath()));        }        return null;    };}
 static InternalCallback<T> curator_f3115_0(InternalCallback<T> callback, Callable<?> proc)
{    try {        proc.call();    } catch (Exception e) {        callback.toCompletableFuture().completeExceptionally(e);    }    return callback;}
public UnhandledErrorListener curator_f3116_0()
{    return listener;}
public UnaryOperator<CuratorEvent> curator_f3117_0()
{    return resultFilter;}
public UnaryOperator<WatchedEvent> curator_f3118_0()
{    return watcherFilter;}
public CompletionStage<WatchedEvent> curator_f3119_0()
{    return (watcher != null) ? watcher.getFuture() : null;}
public void curator_f3120_0(CuratorFramework client, CuratorEvent event) throws Exception
{    event = (resultFilter != null) ? resultFilter.apply(event) : event;    resultFunction.apply(event, this);}
 CompletableFuture<WatchedEvent> curator_f3121_0()
{    return future;}
public void curator_f3122_0(WatchedEvent event)
{    final WatchedEvent localEvent = (watcherFilter != null) ? watcherFilter.apply(event) : event;    switch(localEvent.getState()) {        default:            {                if ((watchMode != WatchMode.stateChangeOnly) && (localEvent.getType() != Event.EventType.None)) {                    if (!future.complete(localEvent)) {                        future.obtrudeValue(localEvent);                    }                }                break;            }        case Disconnected:        case AuthFailed:        case Expired:            {                if (watchMode != WatchMode.successOnly) {                    AsyncEventException exception = new AsyncEventException() {                        private final AtomicBoolean isReset = new AtomicBoolean(false);                        @Override                        public Event.KeeperState getKeeperState() {                            return localEvent.getState();                        }                        @Override                        public CompletionStage<WatchedEvent> reset() {                            Preconditions.checkState(isReset.compareAndSet(false, true), "Already reset");                            future = new CompletableFuture<>();                            return future;                        }                    };                    future.completeExceptionally(exception);                }                break;            }    }}
public Event.KeeperState curator_f3123_0()
{    return localEvent.getState();}
public CompletionStage<WatchedEvent> curator_f3124_0()
{    Preconditions.checkState(isReset.compareAndSet(false, true), "Already reset");    future = new CompletableFuture<>();    return future;}
public String curator_f3125_0()
{    return migrationId;}
public CompletionStage<Void> curator_f3126_0(MigrationSet set)
{    InterProcessLock lock = new InterProcessSemaphoreMutex(client.unwrap(), ZKPaths.makePath(lockPath, set.id()));    CompletionStage<Void> lockStage = lockAsync(lock, lockMax.toMillis(), TimeUnit.MILLISECONDS, executor);    return lockStage.thenCompose(__ -> runMigrationInLock(lock, set));}
protected List<Migration> curator_f3127_0(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException
{    if (operationHashesInOrder.size() > set.migrations().size()) {        throw new MigrationException(set.id(), String.format("More metadata than migrations. Migration ID: %s", set.id()));    }    int compareSize = Math.min(set.migrations().size(), operationHashesInOrder.size());    for (int i = 0; i < compareSize; ++i) {        byte[] setHash = hash(set.migrations().get(i).operations());        if (!Arrays.equals(setHash, operationHashesInOrder.get(i))) {            throw new MigrationException(set.id(), String.format("Metadata mismatch. Migration ID: %s", set.id()));        }    }    return set.migrations().subList(operationHashesInOrder.size(), set.migrations().size());}
private byte[] curator_f3128_0(List<CuratorOp> operations)
{    MessageDigest digest;    try {        digest = MessageDigest.getInstance("SHA-256");    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }    operations.forEach(op -> {        if (op instanceof ExtractingCuratorOp) {            ((ExtractingCuratorOp) op).addToDigest(digest);        } else {            digest.update(op.toString().getBytes());        }    });    return digest.digest();}
private CompletionStage<Void> curator_f3129_0(InterProcessLock lock, MigrationSet set)
{    String thisMetaDataPath = ZKPaths.makePath(metaDataPath, set.id());    return childrenWithData(client, thisMetaDataPath).thenCompose(metaData -> applyMetaData(set, metaData, thisMetaDataPath)).handle((v, e) -> {        release(lock, true);        if (e != null) {            Throwables.propagate(e);        }        return v;    });}
private CompletionStage<Void> curator_f3130_0(MigrationSet set, Map<String, byte[]> metaData, String thisMetaDataPath)
{    List<byte[]> sortedMetaData = metaData.keySet().stream().sorted(Comparator.naturalOrder()).map(metaData::get).collect(Collectors.toList());    List<Migration> toBeApplied;    try {        toBeApplied = filter(set, sortedMetaData);    } catch (MigrationException e) {        CompletableFuture<Void> future = new CompletableFuture<>();        future.completeExceptionally(e);        return future;    }    if (toBeApplied.size() == 0) {        return CompletableFuture.completedFuture(null);    }    return asyncEnsureContainers(client, thisMetaDataPath).thenCompose(__ -> applyMetaDataAfterEnsure(toBeApplied, thisMetaDataPath));}
private CompletionStage<Void> curator_f3131_0(List<Migration> toBeApplied, String thisMetaDataPath)
{    if (debugCount != null) {        debugCount.incrementAndGet();    }    List<CuratorOp> operations = new ArrayList<>();    String metaDataBasePath = ZKPaths.makePath(thisMetaDataPath, META_DATA_NODE_NAME);    toBeApplied.forEach(migration -> {        List<CuratorOp> thisMigrationOperations = migration.operations();        operations.addAll(thisMigrationOperations);        operations.add(client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(metaDataBasePath, hash(thisMigrationOperations)));    });    return client.transaction().forOperations(operations).thenApply(__ -> null);}
 static MigrationSet curator_f3132_0(String id, List<Migration> migrations)
{    Objects.requireNonNull(id, "id cannot be null");    final List<Migration> migrationsCopy = ImmutableList.copyOf(migrations);    return new MigrationSet() {        @Override        public String id() {            return id;        }        @Override        public List<Migration> migrations() {            return migrationsCopy;        }    };}
public String curator_f3133_0()
{    return id;}
public List<Migration> curator_f3134_0()
{    return migrationsCopy;}
 void curator_f3135_0()
{}
 void curator_f3136_0(Exception e)
{    LoggerFactory.getLogger(getClass()).error("Could not process cache message", e);}
 ModeledCacheListener<T> curator_f3137_0()
{    return new ModeledCacheListener<T>() {        private volatile boolean isInitialized = false;        @Override        public void accept(Type type, ZPath path, Stat stat, T model) {            if (isInitialized) {                ModeledCacheListener.this.accept(type, path, stat, model);            }        }        @Override        public void initialized() {            isInitialized = true;            ModeledCacheListener.this.initialized();        }    };}
public void curator_f3138_0(Type type, ZPath path, Stat stat, T model)
{    if (isInitialized) {        ModeledCacheListener.this.accept(type, path, stat, model);    }}
public void curator_f3139_0()
{    isInitialized = true;    ModeledCacheListener.this.initialized();}
public ModeledCache<T> curator_f3140_0()
{    return cache;}
public void curator_f3141_0()
{    cache.start();}
public void curator_f3142_0()
{    cache.close();}
public Listenable<ModeledCacheListener<T>> curator_f3143_0()
{    return cache.listenable();}
public CachedModeledFramework<T> curator_f3144_0()
{    throw new UnsupportedOperationException("Already a cached instance");}
public CachedModeledFramework<T> curator_f3145_0(ExecutorService executor)
{    throw new UnsupportedOperationException("Already a cached instance");}
public VersionedModeledFramework<T> curator_f3146_0()
{    return new VersionedModeledFrameworkImpl<>(this);}
public AsyncCuratorFramework curator_f3147_0()
{    return client.unwrap();}
public ModelSpec<T> curator_f3148_0()
{    return client.modelSpec();}
public CachedModeledFramework<T> curator_f3149_0(Object child)
{    return new CachedModeledFrameworkImpl<>(client.child(child), cache, executor);}
public ModeledFramework<T> curator_f3150_0()
{    throw new UnsupportedOperationException("Not supported for CachedModeledFramework. Instead, call parent() on the ModeledFramework before calling cached()");}
public CachedModeledFramework<T> curator_f3151_0(ZPath path)
{    return new CachedModeledFrameworkImpl<>(client.withPath(path), cache, executor);}
public AsyncStage<String> curator_f3152_0(T model)
{    return client.set(model);}
public AsyncStage<String> curator_f3153_0(T model, Stat storingStatIn)
{    return client.set(model, storingStatIn);}
public AsyncStage<String> curator_f3154_0(T model, Stat storingStatIn, int version)
{    return client.set(model, storingStatIn, version);}
public AsyncStage<String> curator_f3155_0(T model, int version)
{    return client.set(model, version);}
public AsyncStage<T> curator_f3156_0()
{    return internalRead(ZNode::model, this::exceptionally);}
public AsyncStage<T> curator_f3157_0(Stat storingStatIn)
{    return internalRead(n -> {        if (storingStatIn != null) {            DataTree.copyStat(n.stat(), storingStatIn);        }        return n.model();    }, this::exceptionally);}
public AsyncStage<ZNode<T>> curator_f3158_0()
{    return internalRead(Function.identity(), this::exceptionally);}
public AsyncStage<T> curator_f3159_0()
{    return internalRead(ZNode::model, client::read);}
public AsyncStage<T> curator_f3160_0(Stat storingStatIn)
{    return internalRead(ZNode::model, () -> client.read(storingStatIn));}
public AsyncStage<ZNode<T>> curator_f3161_0()
{    return internalRead(Function.identity(), client::readAsZNode);}
public AsyncStage<List<T>> curator_f3162_0()
{    List<T> children = cache.currentChildren().values().stream().map(ZNode::model).collect(Collectors.toList());    return ModelStage.completed(children);}
public AsyncStage<Stat> curator_f3163_0(T model)
{    return client.update(model);}
public AsyncStage<Stat> curator_f3164_0(T model, int version)
{    return client.update(model, version);}
public AsyncStage<Void> curator_f3165_0()
{    return client.delete();}
public AsyncStage<Void> curator_f3166_0(int version)
{    return client.delete(version);}
public AsyncStage<Stat> curator_f3167_0()
{    ZPath path = client.modelSpec().path();    Optional<ZNode<T>> data = cache.currentData(path);    return data.map(node -> completed(node.stat())).orElseGet(() -> completed(null));}
public AsyncStage<List<ZPath>> curator_f3168_0()
{    List<ZPath> paths = cache.currentChildren(client.modelSpec().path()).keySet().stream().filter(path -> !path.isRoot() && path.parent().equals(client.modelSpec().path())).collect(Collectors.toList());    return completed(paths);}
public AsyncStage<List<ZNode<T>>> curator_f3169_0()
{    List<ZNode<T>> nodes = cache.currentChildren(client.modelSpec().path()).entrySet().stream().filter(e -> !e.getKey().isRoot() && e.getKey().parent().equals(client.modelSpec().path())).map(Map.Entry::getValue).collect(Collectors.toList());    return completed(nodes);}
public CuratorOp curator_f3170_0(T model)
{    return client.createOp(model);}
public CuratorOp curator_f3171_0(T model)
{    return client.updateOp(model);}
public CuratorOp curator_f3172_0(T model, int version)
{    return client.updateOp(model, version);}
public CuratorOp curator_f3173_0()
{    return client.deleteOp();}
public CuratorOp curator_f3174_0(int version)
{    return client.deleteOp(version);}
public CuratorOp curator_f3175_0()
{    return client.checkExistsOp();}
public CuratorOp curator_f3176_0(int version)
{    return client.checkExistsOp(version);}
public AsyncStage<List<CuratorTransactionResult>> curator_f3177_0(List<CuratorOp> operations)
{    return client.inTransaction(operations);}
private AsyncStage<U> curator_f3178_0(U value)
{    return ModelStage.completed(value);}
private AsyncStage<U> curator_f3179_0()
{    KeeperException.NoNodeException exception = new KeeperException.NoNodeException(client.modelSpec().path().fullPath());    return ModelStage.exceptionally(exception);}
private AsyncStage<U> curator_f3180_0(Function<ZNode<T>, U> resolver, Supplier<AsyncStage<U>> elseProc)
{    ZPath path = client.modelSpec().path();    Optional<ZNode<T>> data = cache.currentData(path);    return data.map(node -> completed(resolver.apply(node))).orElseGet(elseProc);}
public void curator_f3181_0()
{    try {        cache.getListenable().addListener(this);        cache.start();    } catch (Exception e) {        throw new RuntimeException(e);    }}
public void curator_f3182_0()
{    cache.getListenable().removeListener(this);    cache.close();    entries.clear();}
public Optional<ZNode<T>> curator_f3183_0(ZPath path)
{    Entry<T> entry = entries.remove(path);    if (entry != null) {        return Optional.of(new ZNodeImpl<>(path, entry.stat, entry.model));    }    return Optional.empty();}
 ZPath curator_f3184_0()
{    return basePath;}
 Map<ZPath, ZNode<T>> curator_f3185_0()
{    return currentChildren(basePath);}
public Map<ZPath, ZNode<T>> curator_f3186_0(ZPath path)
{    return entries.entrySet().stream().filter(entry -> entry.getKey().startsWith(path)).map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(), new ZNodeImpl<>(entry.getKey(), entry.getValue().stat, entry.getValue().model))).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));}
public Listenable<ModeledCacheListener<T>> curator_f3187_0()
{    return listenerContainer;}
public void curator_f3188_0(CuratorFramework client, TreeCacheEvent event)
{    try {        internalChildEvent(event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        listenerContainer.forEach(l -> {            l.handleException(e);            return null;        });    }}
private void curator_f3189_0(TreeCacheEvent event) throws Exception
{    switch(event.getType()) {        case NODE_ADDED:        case NODE_UPDATED:            {                ZPath path = ZPath.parse(event.getData().getPath());                if (!path.equals(basePath)) {                    byte[] bytes = event.getData().getData();                    if (                    (bytes != null) && (bytes.length > 0)) {                        T model = serializer.deserialize(bytes);                        entries.put(path, new Entry<>(event.getData().getStat(), model));                        ModeledCacheListener.Type type = (event.getType() == TreeCacheEvent.Type.NODE_ADDED) ? ModeledCacheListener.Type.NODE_ADDED : ModeledCacheListener.Type.NODE_UPDATED;                        accept(type, path, event.getData().getStat(), model);                    }                }                break;            }        case NODE_REMOVED:            {                ZPath path = ZPath.parse(event.getData().getPath());                if (!path.equals(basePath)) {                    Entry<T> entry = entries.remove(path);                    T model = (entry != null) ? entry.model : serializer.deserialize(event.getData().getData());                    Stat stat = (entry != null) ? entry.stat : event.getData().getStat();                    accept(ModeledCacheListener.Type.NODE_REMOVED, path, stat, model);                }                break;            }        case INITIALIZED:            {                listenerContainer.forEach(l -> {                    l.initialized();                    return null;                });                break;            }        default:                        break;    }}
private void curator_f3190_0(ModeledCacheListener.Type type, ZPath path, Stat stat, T model)
{    listenerContainer.forEach(l -> {        l.accept(type, path, stat, model);        return null;    });}
public static ModeledFrameworkImpl<T> curator_f3191_0(AsyncCuratorFramework client, ModelSpec<T> model, WatchMode watchMode, UnaryOperator<WatchedEvent> watcherFilter, UnhandledErrorListener unhandledErrorListener, UnaryOperator<CuratorEvent> resultFilter, Set<ModeledOptions> modeledOptions)
{    boolean isWatched = (watchMode != null);    Objects.requireNonNull(client, "client cannot be null");    Objects.requireNonNull(model, "model cannot be null");    modeledOptions = ImmutableSet.copyOf(Objects.requireNonNull(modeledOptions, "modeledOptions cannot be null"));    watchMode = (watchMode != null) ? watchMode : WatchMode.stateChangeAndSuccess;    AsyncCuratorFrameworkDsl dslClient = client.with(watchMode, unhandledErrorListener, resultFilter, watcherFilter);    WatchableAsyncCuratorFramework watchableClient = isWatched ? dslClient.watched() : dslClient;    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, model, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
public CachedModeledFramework<T> curator_f3192_0()
{    return cached(ThreadUtils.newSingleThreadExecutor("CachedModeledFramework"));}
public CachedModeledFramework<T> curator_f3193_0(ExecutorService executor)
{    Preconditions.checkState(!isWatched, "CachedModeledFramework cannot be used with watched instances as the internal cache would bypass the watchers.");    return new CachedModeledFrameworkImpl<>(this, Objects.requireNonNull(executor, "executor cannot be null"));}
public VersionedModeledFramework<T> curator_f3194_0()
{    return new VersionedModeledFrameworkImpl<>(this);}
public ModelSpec<T> curator_f3195_0()
{    return modelSpec;}
public AsyncCuratorFramework curator_f3196_0()
{    return client;}
public AsyncStage<String> curator_f3197_0(T item)
{    return set(item, null, -1);}
public AsyncStage<String> curator_f3198_0(T item, Stat storingStatIn)
{    return set(item, storingStatIn, -1);}
public AsyncStage<String> curator_f3199_0(T item, int version)
{    return set(item, null, version);}
public AsyncStage<String> curator_f3200_0(T item, Stat storingStatIn, int version)
{    try {        byte[] bytes = modelSpec.serializer().serialize(item);        return dslClient.create().withOptions(modelSpec.createOptions(), modelSpec.createMode(), fixAclList(modelSpec.aclList()), storingStatIn, modelSpec.ttl(), version).forPath(resolveForSet(item), bytes);    } catch (Exception e) {        return ModelStage.exceptionally(e);    }}
public AsyncStage<T> curator_f3201_0()
{    return internalRead(ZNode::model, null);}
public AsyncStage<T> curator_f3202_0(Stat storingStatIn)
{    return internalRead(ZNode::model, storingStatIn);}
public AsyncStage<ZNode<T>> curator_f3203_0()
{    return internalRead(Function.identity(), null);}
public AsyncStage<Stat> curator_f3204_0(T item)
{    return update(item, -1);}
public AsyncStage<Stat> curator_f3205_0(T item, int version)
{    try {        byte[] bytes = modelSpec.serializer().serialize(item);        AsyncPathAndBytesable<AsyncStage<Stat>> next = isCompressed() ? dslClient.setData().compressedWithVersion(version) : dslClient.setData();        return next.forPath(resolveForSet(item), bytes);    } catch (Exception e) {        return ModelStage.exceptionally(e);    }}
public AsyncStage<Stat> curator_f3206_0()
{    return watchableClient.checkExists().forPath(modelSpec.path().fullPath());}
public AsyncStage<Void> curator_f3207_0()
{    return delete(-1);}
public AsyncStage<Void> curator_f3208_0(int version)
{    return dslClient.delete().withVersion(version).forPath(modelSpec.path().fullPath());}
public AsyncStage<List<ZPath>> curator_f3209_0()
{    return internalGetChildren(modelSpec.path());}
public AsyncStage<List<ZNode<T>>> curator_f3210_0()
{    ModelStage<List<ZNode<T>>> modelStage = ModelStage.make();    Preconditions.checkState(!isWatched, "childrenAsZNodes() cannot be used with watched instances.");    children().handle((children, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            completeChildrenAsZNodes(modelStage, children);        }        return null;    });    return modelStage;}
private void curator_f3211_0(ModelStage<List<ZNode<T>>> modelStage, List<ZPath> children)
{    List<ZNode<T>> nodes = Lists.newArrayList();    if (children.size() == 0) {        modelStage.complete(nodes);        return;    }    children.forEach(path -> withPath(path).readAsZNode().handle((node, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            nodes.add(node);            if (nodes.size() == children.size()) {                modelStage.complete(nodes);            }        }        return null;    }));}
private AsyncStage<List<ZPath>> curator_f3212_0(ZPath path)
{    AsyncStage<List<String>> asyncStage = watchableClient.getChildren().forPath(path.fullPath());    ModelStage<List<ZPath>> modelStage = ModelStage.make(asyncStage.event());    asyncStage.whenComplete((children, e) -> {        if (e != null) {            if (modeledOptions.contains(ModeledOptions.ignoreMissingNodesForChildren) && (Throwables.getRootCause(e) instanceof KeeperException.NoNodeException)) {                modelStage.complete(Collections.emptyList());            } else {                modelStage.completeExceptionally(e);            }        } else {            modelStage.complete(children.stream().map(path::child).collect(Collectors.toList()));        }    });    return modelStage;}
public ModeledFramework<T> curator_f3213_0()
{    ModelSpec<T> newModelSpec = modelSpec.parent();    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
public ModeledFramework<T> curator_f3214_0(Object child)
{    ModelSpec<T> newModelSpec = modelSpec.child(child);    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
public ModeledFramework<T> curator_f3215_0(ZPath path)
{    ModelSpec<T> newModelSpec = modelSpec.withPath(path);    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
public static boolean curator_f3216_0(Set<CreateOption> createOptions)
{    return createOptions.contains(CreateOption.compress);}
public CuratorOp curator_f3217_0(T model)
{    return client.transactionOp().create().withOptions(modelSpec.createMode(), fixAclList(modelSpec.aclList()), modelSpec.createOptions().contains(CreateOption.compress), modelSpec.ttl()).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));}
public CuratorOp curator_f3218_0(T model)
{    return updateOp(model, -1);}
public CuratorOp curator_f3219_0(T model, int version)
{    AsyncTransactionSetDataBuilder builder = client.transactionOp().setData();    if (isCompressed()) {        return builder.withVersionCompressed(version).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));    }    return builder.withVersion(version).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));}
public CuratorOp curator_f3220_0()
{    return deleteOp(-1);}
public CuratorOp curator_f3221_0(int version)
{    return client.transactionOp().delete().withVersion(version).forPath(modelSpec.path().fullPath());}
public CuratorOp curator_f3222_0()
{    return checkExistsOp(-1);}
public CuratorOp curator_f3223_0(int version)
{    return client.transactionOp().check().withVersion(version).forPath(modelSpec.path().fullPath());}
public AsyncStage<List<CuratorTransactionResult>> curator_f3224_0(List<CuratorOp> operations)
{    return client.transaction().forOperations(operations);}
private boolean curator_f3225_0()
{    return modelSpec.createOptions().contains(CreateOption.compress);}
private ModelStage<U> curator_f3226_0(Function<ZNode<T>, U> resolver, Stat storingStatIn)
{    Stat stat = (storingStatIn != null) ? storingStatIn : new Stat();    AsyncPathable<AsyncStage<byte[]>> next = isCompressed() ? watchableClient.getData().decompressedStoringStatIn(stat) : watchableClient.getData().storingStatIn(stat);    AsyncStage<byte[]> asyncStage = next.forPath(modelSpec.path().fullPath());    ModelStage<U> modelStage = ModelStage.make(asyncStage.event());    asyncStage.whenComplete((value, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            try {                ZNode<T> node = new ZNodeImpl<>(modelSpec.path(), stat, modelSpec.serializer().deserialize(value));                modelStage.complete(resolver.apply(node));            } catch (Exception deserializeException) {                modelStage.completeExceptionally(deserializeException);            }        }    });    return modelStage;}
private String curator_f3227_0(T model)
{    if (modelSpec.path().isResolved()) {        return modelSpec.path().fullPath();    }    return modelSpec.path().resolved(model).fullPath();}
private List<ACL> curator_f3228_0(List<ACL> aclList)
{        return (aclList.size() > 0) ? aclList : null;}
public ModelSpec<T> curator_f3229_0(Object child)
{    return withPath(path.child(child));}
public ModelSpec<T> curator_f3230_0()
{    return withPath(path.parent());}
public ModelSpec<T> curator_f3231_0(Object... parameters)
{    return withPath(path.resolved(parameters));}
public ModelSpec<T> curator_f3232_0(List<Object> parameters)
{    return withPath(path.resolved(parameters));}
public ModelSpec<T> curator_f3233_0(ZPath newPath)
{    return new ModelSpecImpl<>(newPath, serializer, createMode, aclList, createOptions, deleteOptions, ttl);}
public ZPath curator_f3234_0()
{    return path;}
public ModelSerializer<T> curator_f3235_0()
{    return serializer;}
public CreateMode curator_f3236_0()
{    return createMode;}
public List<ACL> curator_f3237_0()
{    return aclList;}
public Set<CreateOption> curator_f3238_0()
{    return createOptions;}
public Set<DeleteOption> curator_f3239_0()
{    return deleteOptions;}
public long curator_f3240_0()
{    return ttl;}
public Schema curator_f3241_0()
{    if (schema == null) {        schema = Schema.builder(path.toSchemaPathPattern()).dataValidator(this).ephemeral(createMode.isEphemeral() ? Schema.Allowance.MUST : Schema.Allowance.CANNOT).canBeDeleted(true).sequential(createMode.isSequential() ? Schema.Allowance.MUST : Schema.Allowance.CANNOT).watched(Schema.Allowance.CAN).build();    }    return schema;}
public boolean curator_f3242_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ModelSpecImpl<?> modelSpec = (ModelSpecImpl<?>) o;    if (ttl != modelSpec.ttl) {        return false;    }    if (!path.equals(modelSpec.path)) {        return false;    }    if (!serializer.equals(modelSpec.serializer)) {        return false;    }    if (createMode != modelSpec.createMode) {        return false;    }    if (!aclList.equals(modelSpec.aclList)) {        return false;    }    if (!createOptions.equals(modelSpec.createOptions)) {        return false;    }        if (!deleteOptions.equals(modelSpec.deleteOptions)) {        return false;    }    return schema.equals(modelSpec.schema);}
public int curator_f3243_0()
{    int result = path.hashCode();    result = 31 * result + serializer.hashCode();    result = 31 * result + createMode.hashCode();    result = 31 * result + aclList.hashCode();    result = 31 * result + createOptions.hashCode();    result = 31 * result + deleteOptions.hashCode();    result = 31 * result + (int) (ttl ^ (ttl >>> 32));    result = 31 * result + schema.hashCode();    return result;}
public String curator_f3244_0()
{    return "ModelSpecImpl{" + "path=" + path + ", serializer=" + serializer + ", createMode=" + createMode + ", aclList=" + aclList + ", createOptions=" + createOptions + ", deleteOptions=" + deleteOptions + ", ttl=" + ttl + ", schema=" + schema + '}';}
public boolean curator_f3245_0(Schema schema, String path, byte[] data, List<ACL> acl)
{    if (acl != null) {        List<ACL> localAclList = (aclList.size() > 0) ? aclList : ZooDefs.Ids.OPEN_ACL_UNSAFE;        if (!acl.equals(localAclList)) {            throw new SchemaViolation(schema, new SchemaViolation.ViolatorData(path, data, acl), "ACLs do not match model ACLs");        }    }    if (data != null) {        try {            serializer.deserialize(data);        } catch (RuntimeException e) {            throw new SchemaViolation(schema, new SchemaViolation.ViolatorData(path, data, acl), "Data cannot be deserialized into a model");        }    }    return true;}
 static ModelStage<U> curator_f3246_0()
{    return new ModelStage<>(null);}
 static ModelStage<U> curator_f3247_0(CompletionStage<WatchedEvent> event)
{    return new ModelStage<>(event);}
 static ModelStage<U> curator_f3248_0(U value)
{    ModelStage<U> stage = new ModelStage<>(null);    stage.complete(value);    return stage;}
 static ModelStage<U> curator_f3249_0(Exception e)
{    ModelStage<U> stage = new ModelStage<>(null);    stage.completeExceptionally(e);    return stage;}
 static ModelStage<U> curator_f3250_0(Executor executor)
{    return new AsyncModelStage<>(executor);}
 static ModelStage<U> curator_f3251_0(U value, Executor executor)
{    ModelStage<U> stage = new AsyncModelStage<>(executor);    stage.complete(value);    return stage;}
 static ModelStage<U> curator_f3252_0(Exception e, Executor executor)
{    ModelStage<U> stage = new AsyncModelStage<>(executor);    stage.completeExceptionally(e);    return stage;}
public CompletionStage<WatchedEvent> curator_f3253_0()
{    return event;}
public CompletableFuture<U1> curator_f3254_0(Function<? super U, ? extends U1> fn)
{    return super.thenApplyAsync(fn, executor);}
public CompletableFuture<Void> curator_f3255_0(Consumer<? super U> action)
{    return super.thenAcceptAsync(action, executor);}
public CompletableFuture<Void> curator_f3256_0(Runnable action)
{    return super.thenRunAsync(action, executor);}
public CompletableFuture<V> curator_f3257_0(CompletionStage<? extends U1> other, BiFunction<? super U, ? super U1, ? extends V> fn)
{    return super.thenCombineAsync(other, fn, executor);}
public CompletableFuture<Void> curator_f3258_0(CompletionStage<? extends U1> other, BiConsumer<? super U, ? super U1> action)
{    return super.thenAcceptBothAsync(other, action, executor);}
public CompletableFuture<Void> curator_f3259_0(CompletionStage<?> other, Runnable action)
{    return super.runAfterBothAsync(other, action, executor);}
public CompletableFuture<U1> curator_f3260_0(CompletionStage<? extends U> other, Function<? super U, U1> fn)
{    return super.applyToEitherAsync(other, fn, executor);}
public CompletableFuture<Void> curator_f3261_0(CompletionStage<? extends U> other, Consumer<? super U> action)
{    return super.acceptEitherAsync(other, action, executor);}
public CompletableFuture<Void> curator_f3262_0(CompletionStage<?> other, Runnable action)
{    return super.runAfterEitherAsync(other, action, executor);}
public CompletableFuture<U1> curator_f3263_0(Function<? super U, ? extends CompletionStage<U1>> fn)
{    return super.thenComposeAsync(fn, executor);}
public CompletableFuture<U> curator_f3264_0(BiConsumer<? super U, ? super Throwable> action)
{    return super.whenCompleteAsync(action, executor);}
public CompletableFuture<U1> curator_f3265_0(BiFunction<? super U, Throwable, ? extends U1> fn)
{    return super.handleAsync(fn, executor);}
public AsyncStage<String> curator_f3266_0(Versioned<T> model)
{    return client.set(model.model(), model.version());}
public AsyncStage<String> curator_f3267_0(Versioned<T> model, Stat storingStatIn)
{    return client.set(model.model(), storingStatIn, model.version());}
public AsyncStage<Versioned<T>> curator_f3268_0()
{    return read(null);}
public AsyncStage<Versioned<T>> curator_f3269_0(Stat storingStatIn)
{    Stat localStat = (storingStatIn != null) ? storingStatIn : new Stat();    AsyncStage<T> stage = client.read(localStat);    ModelStage<Versioned<T>> modelStage = ModelStage.make(stage.event());    stage.whenComplete((model, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            modelStage.complete(Versioned.from(model, localStat.getVersion()));        }    });    return modelStage;}
public AsyncStage<Stat> curator_f3270_0(Versioned<T> model)
{    return client.update(model.model(), model.version());}
public CuratorOp curator_f3271_0(Versioned<T> model)
{    return client.updateOp(model.model(), model.version());}
public ZPath curator_f3272_0()
{    return path;}
public Stat curator_f3273_0()
{    return stat;}
public T curator_f3274_0()
{    return model;}
public static ZPath curator_f3275_0(String fullPath, UnaryOperator<String> nameFilter)
{    return parseInternal(fullPath, nameFilter);}
private static ZPathImpl curator_f3276_0(String fullPath, UnaryOperator<String> nameFilter)
{    List<String> nodes = ImmutableList.<String>builder().add(PATH_SEPARATOR).addAll(Splitter.on(PATH_SEPARATOR).omitEmptyStrings().splitToList(fullPath).stream().map(nameFilter).collect(Collectors.toList())).build();    nodes.forEach(ZPathImpl::validate);    return new ZPathImpl(nodes, null);}
public static ZPath curator_f3277_0(String[] names)
{    return from(null, Arrays.asList(names));}
public static ZPath curator_f3278_0(List<String> names)
{    return from(null, names);}
public static ZPath curator_f3279_0(ZPath base, String[] names)
{    return from(base, Arrays.asList(names));}
public static ZPath curator_f3280_0(ZPath base, List<String> names)
{    names = Objects.requireNonNull(names, "names cannot be null");    names.forEach(ZPathImpl::validate);    ImmutableList.Builder<String> builder = ImmutableList.builder();    if (base != null) {        if (base instanceof ZPathImpl) {            builder.addAll(((ZPathImpl) base).nodes);        } else {            builder.addAll(Splitter.on(PATH_SEPARATOR).omitEmptyStrings().splitToList(base.fullPath()));        }    } else {        builder.add(PATH_SEPARATOR);    }    List<String> nodes = builder.addAll(names).build();    return new ZPathImpl(nodes, null);}
public ZPath curator_f3281_0(Object child)
{    return new ZPathImpl(nodes, NodeName.nameFrom(child));}
public ZPath curator_f3282_0()
{    checkRootAccess();    if (parent == null) {        parent = new ZPathImpl(nodes.subList(0, nodes.size() - 1), null);    }    return parent;}
public boolean curator_f3283_0()
{    return nodes.size() == 1;}
public boolean curator_f3284_0(ZPath path)
{    ZPathImpl rhs;    if (path instanceof ZPathImpl) {        rhs = (ZPathImpl) path;    } else {        rhs = parseInternal(path.fullPath(), s -> s);    }    return (nodes.size() >= rhs.nodes.size()) && nodes.subList(0, rhs.nodes.size()).equals(rhs.nodes);}
public Pattern curator_f3285_0()
{    if (schema == null) {        schema = Pattern.compile(buildFullPath(s -> isParameter(s) ? ".*" : s));    }    return schema;}
public String curator_f3286_0()
{    checkResolved();    if (fullPath == null) {        fullPath = buildFullPath(s -> s);    }    return fullPath;}
public String curator_f3287_0()
{    return nodes.get(nodes.size() - 1);}
public boolean curator_f3288_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ZPathImpl zPaths = (ZPathImpl) o;    return nodes.equals(zPaths.nodes);}
public int curator_f3289_0()
{    return nodes.hashCode();}
public String curator_f3290_0()
{    return nodes.subList(1, nodes.size()).stream().map(name -> isParameter(name) ? name.substring(1) : name).collect(Collectors.joining(PATH_SEPARATOR, PATH_SEPARATOR, ""));}
public ZPath curator_f3291_0(List<Object> parameters)
{    Iterator<Object> iterator = parameters.iterator();    List<String> nodeNames = nodes.stream().map(name -> {        if (isParameter(name) && iterator.hasNext()) {            return NodeName.nameFrom(iterator.next());        }        return name;    }).collect(Collectors.toList());    return new ZPathImpl(nodeNames, null);}
public boolean curator_f3292_0()
{    return isResolved;}
private static boolean curator_f3293_0(String name)
{    return (name.length() > 1) && name.startsWith(PATH_SEPARATOR);}
private void curator_f3294_0()
{    if (isRoot()) {        throw new NoSuchElementException("The root has no parent");    }}
private void curator_f3295_0()
{    if (!isResolved) {        throw new IllegalStateException("This ZPath has not been resolved: " + toString());    }}
private static void curator_f3296_0(String nodeName)
{    if (isParameter(Objects.requireNonNull(nodeName, "nodeName cannot be null"))) {        return;    }    if (nodeName.equals(PATH_SEPARATOR)) {        return;    }    PathUtils.validatePath(PATH_SEPARATOR + nodeName);}
private String curator_f3297_0(UnaryOperator<String> filter)
{    boolean addSeparator = false;    StringBuilder str = new StringBuilder();    int size = nodes.size();    int parameterIndex = 0;    for (int i = 0; i < size; ++i) {        if (i > 1) {            str.append(PATH_SEPARATOR);        }        str.append(filter.apply(nodes.get(i)));    }    return str.toString();}
public static JacksonModelSerializer<T> curator_f3298_0(Class<T> modelClass)
{    return new JacksonModelSerializer<>(modelClass);}
public static JacksonModelSerializer<T> curator_f3299_0(JavaType type)
{    return new JacksonModelSerializer<>(type);}
public static JacksonModelSerializer<T> curator_f3300_0(TypeReference type)
{    return new JacksonModelSerializer<>(type);}
public byte[] curator_f3301_0(T model)
{    try {        return writer.writeValueAsBytes(model);    } catch (JsonProcessingException e) {        throw new RuntimeException(String.format("Could not serialize value: %s", model), e);    }}
public T curator_f3302_0(byte[] bytes)
{    try {        return reader.readValue(bytes);    } catch (IOException e) {        throw new RuntimeException(String.format("Could not deserialize value: %s", Arrays.toString(bytes)), e);    }}
 static ModeledFramework<T> curator_f3303_0(AsyncCuratorFramework client, ModelSpec<T> model)
{    return builder(client, model).build();}
 static ModeledFrameworkBuilder<T> curator_f3304_0(AsyncCuratorFramework client, ModelSpec<T> model)
{    return new ModeledFrameworkBuilder<>(client, model);}
 static ModeledFrameworkBuilder<T> curator_f3305_0()
{    return new ModeledFrameworkBuilder<>();}
public ModeledFramework<T> curator_f3306_0()
{    return ModeledFrameworkImpl.build(client, modelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, modeledOptions);}
public ModeledFrameworkBuilder<T> curator_f3307_0()
{    this.watchMode = WatchMode.stateChangeAndSuccess;    return this;}
public ModeledFrameworkBuilder<T> curator_f3308_0(WatchMode watchMode)
{    this.watchMode = watchMode;    return this;}
public ModeledFrameworkBuilder<T> curator_f3309_0(WatchMode watchMode, UnaryOperator<WatchedEvent> watcherFilter)
{    this.watchMode = watchMode;    this.watcherFilter = watcherFilter;    return this;}
public ModeledFrameworkBuilder<T> curator_f3310_0(UnhandledErrorListener unhandledErrorListener)
{    this.unhandledErrorListener = unhandledErrorListener;    return this;}
public ModeledFrameworkBuilder<T> curator_f3311_0(UnaryOperator<CuratorEvent> resultFilter)
{    this.resultFilter = resultFilter;    return this;}
public ModeledFrameworkBuilder<T> curator_f3312_0(ModelSpec<T> modelSpec)
{    this.modelSpec = Objects.requireNonNull(modelSpec, "modelSpec cannot be null");    return this;}
public ModeledFrameworkBuilder<T> curator_f3313_0(AsyncCuratorFramework client)
{    this.client = Objects.requireNonNull(client, "client cannot be null");    return this;}
public ModeledFrameworkBuilder<T> curator_f3314_0(Set<ModeledOptions> modeledOptions)
{    this.modeledOptions = ImmutableSet.copyOf(Objects.requireNonNull(modeledOptions, "client cannot be null"));    return this;}
public byte[] curator_f3315_0(byte[] model)
{    return model;}
public byte[] curator_f3316_0(byte[] bytes)
{    return bytes;}
 static ModelSpecBuilder<T> curator_f3317_0(ZPath path, ModelSerializer<T> serializer)
{    return new ModelSpecBuilder<>(path, serializer).withCreateOptions(defaultCreateOptions).withDeleteOptions(defaultDeleteOptions);}
 static ModelSpecBuilder<T> curator_f3318_0(ModelSerializer<T> serializer)
{    return new ModelSpecBuilder<>(serializer).withCreateOptions(defaultCreateOptions).withDeleteOptions(defaultDeleteOptions);}
public ModelSpec<T> curator_f3319_0()
{    return new ModelSpecImpl<>(path, serializer, createMode, aclList, createOptions, deleteOptions, ttl);}
public ModelSpecBuilder<T> curator_f3320_0(CreateMode createMode)
{    this.createMode = createMode;    return this;}
public ModelSpecBuilder<T> curator_f3321_0(long ttl)
{    this.ttl = ttl;    return this;}
public ModelSpecBuilder<T> curator_f3322_0(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
public ModelSpecBuilder<T> curator_f3323_0(Set<CreateOption> createOptions)
{    this.createOptions = (createOptions != null) ? ImmutableSet.copyOf(createOptions) : null;    return this;}
public ModelSpecBuilder<T> curator_f3324_0(Set<DeleteOption> deleteOptions)
{    this.deleteOptions = (deleteOptions != null) ? ImmutableSet.copyOf(deleteOptions) : null;    return this;}
public ModelSpecBuilder<T> curator_f3325_0(ZPath path)
{    this.path = Objects.requireNonNull(path, "path cannot be null");    return this;}
 static String curator_f3326_0(Object obj)
{    if (obj instanceof NodeName) {        return ((NodeName) obj).nodeName();    }    return String.valueOf(obj);}
 Object curator_f3327_0(Object... parameters)
{    return resolved(Arrays.asList(parameters));}
 static TypedModeledFramework<M, P1> curator_f3328_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec<M, P1> modelSpec)
{    return (client, p1) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1)).build();}
 static TypedModeledFramework<M, P1> curator_f3329_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec<M, P1> typedModelSpec = TypedModelSpec.from(modelSpecBuilder, pathWithIds);    return (client, p1) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1)).build();}
 static TypedModeledFramework0<M> curator_f3330_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec0<M> modelSpec)
{    return (client) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved()).build();}
 static TypedModeledFramework0<M> curator_f3331_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec0<M> typedModelSpec = TypedModelSpec0.from(modelSpecBuilder, pathWithIds);    return (client) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved()).build();}
 static TypedModeledFramework10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> curator_f3332_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
 static TypedModeledFramework10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> curator_f3333_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> typedModelSpec = TypedModelSpec10.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
 static TypedModeledFramework2<M, P1, P2> curator_f3334_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec2<M, P1, P2> modelSpec)
{    return (client, p1, p2) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2)).build();}
 static TypedModeledFramework2<M, P1, P2> curator_f3335_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec2<M, P1, P2> typedModelSpec = TypedModelSpec2.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2)).build();}
 static TypedModeledFramework3<M, P1, P2, P3> curator_f3336_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec3<M, P1, P2, P3> modelSpec)
{    return (client, p1, p2, p3) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3)).build();}
 static TypedModeledFramework3<M, P1, P2, P3> curator_f3337_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec3<M, P1, P2, P3> typedModelSpec = TypedModelSpec3.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3)).build();}
 static TypedModeledFramework4<M, P1, P2, P3, P4> curator_f3338_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec4<M, P1, P2, P3, P4> modelSpec)
{    return (client, p1, p2, p3, p4) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4)).build();}
 static TypedModeledFramework4<M, P1, P2, P3, P4> curator_f3339_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec4<M, P1, P2, P3, P4> typedModelSpec = TypedModelSpec4.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4)).build();}
 static TypedModeledFramework5<M, P1, P2, P3, P4, P5> curator_f3340_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec5<M, P1, P2, P3, P4, P5> modelSpec)
{    return (client, p1, p2, p3, p4, p5) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5)).build();}
 static TypedModeledFramework5<M, P1, P2, P3, P4, P5> curator_f3341_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec5<M, P1, P2, P3, P4, P5> typedModelSpec = TypedModelSpec5.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5)).build();}
 static TypedModeledFramework6<M, P1, P2, P3, P4, P5, P6> curator_f3342_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6)).build();}
 static TypedModeledFramework6<M, P1, P2, P3, P4, P5, P6> curator_f3343_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> typedModelSpec = TypedModelSpec6.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6)).build();}
 static TypedModeledFramework7<M, P1, P2, P3, P4, P5, P6, P7> curator_f3344_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
 static TypedModeledFramework7<M, P1, P2, P3, P4, P5, P6, P7> curator_f3345_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> typedModelSpec = TypedModelSpec7.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
 static TypedModeledFramework8<M, P1, P2, P3, P4, P5, P6, P7, P8> curator_f3346_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
 static TypedModeledFramework8<M, P1, P2, P3, P4, P5, P6, P7, P8> curator_f3347_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> typedModelSpec = TypedModelSpec8.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
 static TypedModeledFramework9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> curator_f3348_0(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
 static TypedModeledFramework9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> curator_f3349_0(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> typedModelSpec = TypedModelSpec9.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
 static TypedModelSpec<M, P1> curator_f3350_0(ModelSpecBuilder<M> builder, TypedZPath<P1> path)
{    return p1 -> builder.withPath(path.resolved(p1)).build();}
 static TypedModelSpec<M, P1> curator_f3351_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath<P1> zPath = TypedZPath.from(pathWithIds);    return p1 -> builder.withPath(zPath.resolved(p1)).build();}
 static TypedModelSpec0<M> curator_f3352_0(ModelSpecBuilder<M> builder, TypedZPath0 path)
{    return () -> builder.withPath(path.resolved()).build();}
 static TypedModelSpec0<M> curator_f3353_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath0 zPath = TypedZPath0.from(pathWithIds);    return () -> builder.withPath(zPath.resolved()).build();}
 static TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> curator_f3354_0(ModelSpecBuilder<M> builder, TypedZPath10<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
 static TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> curator_f3355_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath10<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> zPath = TypedZPath10.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
 static TypedModelSpec2<M, P1, P2> curator_f3356_0(ModelSpecBuilder<M> builder, TypedZPath2<P1, P2> path)
{    return (p1, p2) -> builder.withPath(path.resolved(p1, p2)).build();}
 static TypedModelSpec2<M, P1, P2> curator_f3357_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath2<P1, P2> zPath = TypedZPath2.from(pathWithIds);    return (p1, p2) -> builder.withPath(zPath.resolved(p1, p2)).build();}
 static TypedModelSpec3<M, P1, P2, P3> curator_f3358_0(ModelSpecBuilder<M> builder, TypedZPath3<P1, P2, P3> path)
{    return (p1, p2, p3) -> builder.withPath(path.resolved(p1, p2, p3)).build();}
 static TypedModelSpec3<M, P1, P2, P3> curator_f3359_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath3<P1, P2, P3> zPath = TypedZPath3.from(pathWithIds);    return (p1, p2, p3) -> builder.withPath(zPath.resolved(p1, p2, p3)).build();}
 static TypedModelSpec4<M, P1, P2, P3, P4> curator_f3360_0(ModelSpecBuilder<M> builder, TypedZPath4<P1, P2, P3, P4> path)
{    return (p1, p2, p3, p4) -> builder.withPath(path.resolved(p1, p2, p3, p4)).build();}
 static TypedModelSpec4<M, P1, P2, P3, P4> curator_f3361_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath4<P1, P2, P3, P4> zPath = TypedZPath4.from(pathWithIds);    return (p1, p2, p3, p4) -> builder.withPath(zPath.resolved(p1, p2, p3, p4)).build();}
 static TypedModelSpec5<M, P1, P2, P3, P4, P5> curator_f3362_0(ModelSpecBuilder<M> builder, TypedZPath5<P1, P2, P3, P4, P5> path)
{    return (p1, p2, p3, p4, p5) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5)).build();}
 static TypedModelSpec5<M, P1, P2, P3, P4, P5> curator_f3363_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath5<P1, P2, P3, P4, P5> zPath = TypedZPath5.from(pathWithIds);    return (p1, p2, p3, p4, p5) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5)).build();}
 static TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> curator_f3364_0(ModelSpecBuilder<M> builder, TypedZPath6<P1, P2, P3, P4, P5, P6> path)
{    return (p1, p2, p3, p4, p5, p6) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6)).build();}
 static TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> curator_f3365_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath6<P1, P2, P3, P4, P5, P6> zPath = TypedZPath6.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6)).build();}
 static TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> curator_f3366_0(ModelSpecBuilder<M> builder, TypedZPath7<P1, P2, P3, P4, P5, P6, P7> path)
{    return (p1, p2, p3, p4, p5, p6, p7) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
 static TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> curator_f3367_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath7<P1, P2, P3, P4, P5, P6, P7> zPath = TypedZPath7.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
 static TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> curator_f3368_0(ModelSpecBuilder<M> builder, TypedZPath8<P1, P2, P3, P4, P5, P6, P7, P8> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
 static TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> curator_f3369_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath8<P1, P2, P3, P4, P5, P6, P7, P8> zPath = TypedZPath8.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
 static TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> curator_f3370_0(ModelSpecBuilder<M> builder, TypedZPath9<P1, P2, P3, P4, P5, P6, P7, P8, P9> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
 static TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> curator_f3371_0(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath9<P1, P2, P3, P4, P5, P6, P7, P8, P9> zPath = TypedZPath9.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
 static TypedZPath<T> curator_f3372_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath<T> curator_f3373_0(ZPath path)
{    return path::resolved;}
 static TypedZPath0 curator_f3374_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath0 curator_f3375_0(ZPath path)
{    return path::resolved;}
 static TypedZPath10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> curator_f3376_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> curator_f3377_0(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);}
 static TypedZPath2<T1, T2> curator_f3378_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath2<T1, T2> curator_f3379_0(ZPath path)
{    return (p1, p2) -> path.resolved(p1, p2);}
 static TypedZPath3<T1, T2, T3> curator_f3380_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath3<T1, T2, T3> curator_f3381_0(ZPath path)
{    return (p1, p2, p3) -> path.resolved(p1, p2, p3);}
 static TypedZPath4<T1, T2, T3, T4> curator_f3382_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath4<T1, T2, T3, T4> curator_f3383_0(ZPath path)
{    return (p1, p2, p3, p4) -> path.resolved(p1, p2, p3, p4);}
 static TypedZPath5<T1, T2, T3, T4, T5> curator_f3384_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath5<T1, T2, T3, T4, T5> curator_f3385_0(ZPath path)
{    return (p1, p2, p3, p4, p5) -> path.resolved(p1, p2, p3, p4, p5);}
 static TypedZPath6<T1, T2, T3, T4, T5, T6> curator_f3386_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath6<T1, T2, T3, T4, T5, T6> curator_f3387_0(ZPath path)
{    return (p1, p2, p3, p4, p5, p6) -> path.resolved(p1, p2, p3, p4, p5, p6);}
 static TypedZPath7<T1, T2, T3, T4, T5, T6, T7> curator_f3388_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath7<T1, T2, T3, T4, T5, T6, T7> curator_f3389_0(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7) -> path.resolved(p1, p2, p3, p4, p5, p6, p7);}
 static TypedZPath8<T1, T2, T3, T4, T5, T6, T7, T8> curator_f3390_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath8<T1, T2, T3, T4, T5, T6, T7, T8> curator_f3391_0(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8);}
 static TypedZPath9<T1, T2, T3, T4, T5, T6, T7, T8, T9> curator_f3392_0(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
 static TypedZPath9<T1, T2, T3, T4, T5, T6, T7, T8, T9> curator_f3393_0(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9);}
 int curator_f3394_0()
{    return -1;}
 static Versioned<T> curator_f3395_0(T model, int version)
{    return new Versioned<T>() {        @Override        public int version() {            return version;        }        @Override        public T model() {            return model;        }    };}
public int curator_f3396_0()
{    return version;}
public T curator_f3397_0()
{    return model;}
 static CompletionStage<List<T>> curator_f3398_0(AsyncStage<List<ZNode<T>>> from)
{    return from.thenApply(nodes -> nodes.stream().map(ZNode::model).collect(Collectors.toList()));}
 static CompletionStage<T> curator_f3399_0(AsyncStage<ZNode<T>> from)
{    return from.thenApply(ZNode::model);}
 static String curator_f3400_0()
{    return parameter("id");}
 static String curator_f3401_0(String name)
{    return PATH_SEPARATOR + "{" + name + "}";}
 static ZPath curator_f3402_0(String fullPath)
{    return ZPathImpl.parse(fullPath, s -> s);}
 static ZPath curator_f3403_0(String fullPath)
{        return ZPathImpl.parse(fullPath, s -> isId(s) ? (PATH_SEPARATOR + s) : s);}
 static boolean curator_f3404_0(String s)
{    return s.startsWith("{") && s.endsWith("}");}
 static ZPath curator_f3405_0(String fullPath, UnaryOperator<String> nameFilter)
{    return ZPathImpl.parse(fullPath, nameFilter);}
 static ZPath curator_f3406_0(String... names)
{    return ZPathImpl.from(names);}
 static ZPath curator_f3407_0(List<String> names)
{    return ZPathImpl.from(names);}
 static ZPath curator_f3408_0(ZPath base, String... names)
{    return ZPathImpl.from(base, names);}
 static ZPath curator_f3409_0(ZPath base, List<String> names)
{    return ZPathImpl.from(base, names);}
 ZPath curator_f3410_0(Object... parameters)
{    return resolved(Arrays.asList(parameters));}
public void curator_f3411_0() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1000");    super.setup();}
public void curator_f3412_0() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
public void curator_f3413_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.delete().withOptions(EnumSet.of(DeleteOption.quietly)).forPath("/foo/bar");        final BlockingQueue<Integer> rc = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = (client1, event) -> rc.add(event.getResultCode());        async.delete().withOptions(EnumSet.of(DeleteOption.quietly)).forPath("/foo/bar/hey").handle((v, e) -> {            if (e == null) {                rc.add(KeeperException.Code.OK.intValue());            } else {                rc.add(((KeeperException) e).code().intValue());            }            return null;        });        Integer code = rc.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(code);        Assert.assertEquals(code.intValue(), KeeperException.Code.OK.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3414_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        async.create().forPath("/base").thenRun(() -> async.watched().getChildren().forPath("/base").event().handle((event, x) -> {            try {                queue.put(event.getPath());            } catch (InterruptedException e) {                throw new Error(e);            }            return null;        })).thenRun(() -> async.create().forPath("/base/child"));        String path = queue.take();        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3415_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();            Assert.fail("Should have failed with auth exception");        } catch (ExecutionException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3416_0() throws Exception
{        List<AuthInfo> authInfos = new ArrayList<AuthInfo>();    authInfos.add(new AuthInfo("digest", "me1:pass1".getBytes()));    authInfos.add(new AuthInfo("digest", "me2:pass2".getBytes()));    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization(authInfos).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me2:pass2".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();            Assert.fail("Should have failed with auth exception");        } catch (ExecutionException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3417_0() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", "me:pass".getBytes()).retryPolicy(new ExponentialBackoffRetry(100, 5)).build();    client.start();    try {        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = (client1, newState) -> {            if (newState == ConnectionState.LOST) {                lostLatch.countDown();            }        };        client.getConnectionStateListenable().addListener(listener);        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.checkExists().forPath("/").toCompletableFuture().get();            Assert.fail("Connection should be down");        } catch (ExecutionException e) {                }        server.restart();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed", e);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3418_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three", "foo".getBytes()).toCompletableFuture().get();        byte[] data = async.getData().forPath("/one/two/three").toCompletableFuture().get();        Assert.assertEquals(data, "foo".getBytes());        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/another", "bar".getBytes());        data = async.getData().forPath("/one/two/another").toCompletableFuture().get();        Assert.assertEquals(data, "bar".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3419_0() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsAsContainers)).forPath("/one/two/three", "foo".getBytes()).toCompletableFuture().get();        byte[] data = async.getData().forPath("/one/two/three").toCompletableFuture().get();        Assert.assertEquals(data, "foo".getBytes());        async.delete().forPath("/one/two/three").toCompletableFuture().get();        new Timing().sleepABit();        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        new Timing().sleepABit();        Assert.assertNull(async.checkExists().forPath("/one").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3420_0() throws ExecutionException, InterruptedException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        String path = async.create().withOptions(Collections.singleton(CreateOption.doProtected)).forPath("/yo").toCompletableFuture().get();        String node = ZKPaths.getNodeFromPath(path);        Assert.assertTrue(node.startsWith(CreateBuilderImpl.PROTECTED_PREFIX), node);                        int expectedProtectedIdLength = 36;                int delimeterLength = 1;        int expectedNodeLength = CreateBuilderImpl.PROTECTED_PREFIX.length() + expectedProtectedIdLength + delimeterLength + "yo".length();        Assert.assertEquals(node.length(), expectedNodeLength);        int uuidStart = CreateBuilderImpl.PROTECTED_PREFIX.length();        String protectedId = node.substring(uuidStart, uuidStart + expectedProtectedIdLength);                UUID.fromString(protectedId);    } finally {        CloseableUtils.closeQuietly(client);    }}
private boolean curator_f3421_0()
{    if (ZKPaths.getContainerCreateMode() == CreateMode.PERSISTENT) {        System.out.println("Not using CreateMode.CONTAINER enabled version of ZooKeeper");        return false;    }    return true;}
public void curator_f3422_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        Assert.assertNull(client.checkExists().forPath("/one/two"));        async.create().withOptions(EnumSet.of(CreateOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.delete().withOptions(EnumSet.of(DeleteOption.deletingChildrenIfNeeded)).forPath("/one").toCompletableFuture().get();        Assert.assertNull(client.checkExists().forPath("/one"));        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        Assert.assertNull(async.checkExists().forPath("/one/two/three").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3423_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        Assert.assertNull(async.checkExists().forPath("/one/two/three").toCompletableFuture().get());        Assert.assertNull(async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3424_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        final CountDownLatch latch = new CountDownLatch(1);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.sync().forPath("/head").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3425_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        CountDownLatch latch = new CountDownLatch(1);        async.create().forPath("/head").thenRun(() -> async.delete().forPath("/head").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        }));        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3426_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener((client1, event) -> {            if (event.getType() == CuratorEventType.DELETE) {                Assert.assertEquals(event.getPath(), "/one/two");                ((CountDownLatch) event.getContext()).countDown();            }        });        CountDownLatch latch = new CountDownLatch(1);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three/four").thenRun(() -> async.delete().withOptions(EnumSet.of(DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        }));        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3427_0() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three/four/five/six", "foo".getBytes()).toCompletableFuture().get();        async.delete().withOptions(EnumSet.of(DeleteOption.guaranteed, DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two/three/four/five").toCompletableFuture().get();        Assert.assertNull(async.checkExists().forPath("/one/two/three/four/five").toCompletableFuture().get());        async.delete().withOptions(EnumSet.of(DeleteOption.guaranteed, DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two").toCompletableFuture().get();        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3428_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        Semaphore semaphore = new Semaphore(0);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath("/head").thenRun(() -> {            for (int i = 0; i < 10; ++i) {                async.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/head/child").thenRun(semaphore::release);            }        });        Assert.assertTrue(new Timing().acquireSemaphore(semaphore, 10));        List<String> children = async.getChildren().forPath("/head").toCompletableFuture().get();        Assert.assertEquals(children.size(), 10);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3429_0() throws Exception
{    final byte[] data1 = { 1, 2, 3 };    final byte[] data2 = { 4, 5, 6, 7 };    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath("/test", data1).toCompletableFuture().get();        CountDownLatch watchedLatch = new CountDownLatch(1);        CountDownLatch backgroundLatch = new CountDownLatch(1);        AsyncStage<byte[]> stage = async.watched().getData().forPath("/test");        stage.event().handle((event, x) -> {            Assert.assertEquals(event.getPath(), "/test");            watchedLatch.countDown();            return null;        });        stage.handle((d, x) -> {            Assert.assertEquals(d, data1);            backgroundLatch.countDown();            return null;        });        Assert.assertTrue(backgroundLatch.await(10, TimeUnit.SECONDS));        async.setData().forPath("/test", data2);        Assert.assertTrue(watchedLatch.await(10, TimeUnit.SECONDS));        byte[] checkData = async.getData().forPath("/test").toCompletableFuture().get();        Assert.assertEquals(checkData, data2);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3430_0() throws Exception
{                final AtomicBoolean aclProviderCalled = new AtomicBoolean(false);    ACLProvider badAclProvider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }        @Override        public List<ACL> getAclForPath(String path) {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).aclProvider(badAclProvider).build();    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch errorLatch = new CountDownLatch(1);        UnhandledErrorListener listener = (message, e) -> {            if (e instanceof UnsupportedOperationException) {                errorLatch.countDown();            }        };        async.with(listener).create().forPath("/foo");        Assert.assertTrue(new Timing().awaitLatch(errorLatch));    } finally {        CloseableUtils.closeQuietly(client);    }}
public List<ACL> curator_f3431_0()
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
public List<ACL> curator_f3432_0(String path)
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
public void curator_f3433_0() throws Exception
{    server.stop();    Timing timing = new Timing(2);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(0, 0));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch connectedLatch = new CountDownLatch(1);        final AtomicBoolean firstListenerAction = new AtomicBoolean(true);        final AtomicReference<ConnectionState> firstListenerState = new AtomicReference<>();        ConnectionStateListener listener = (client1, newState) -> {            if (firstListenerAction.compareAndSet(true, false)) {                firstListenerState.set(newState);                System.out.println("First listener state is " + newState);            }            if (newState == ConnectionState.CONNECTED) {                connectedLatch.countDown();            }        };        client.getConnectionStateListenable().addListener(listener);                async.create().forPath("/foo");        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        Assert.assertFalse(firstListenerAction.get());        ConnectionState firstconnectionState = firstListenerState.get();        Assert.assertEquals(firstconnectionState, ConnectionState.CONNECTED, "First listener state MUST BE CONNECTED but is " + firstconnectionState);    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3434_0() throws Exception
{    final int SLEEP = 1000;    final int TIMES = 5;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(TIMES, SLEEP));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final CountDownLatch latch = new CountDownLatch(TIMES);        final List<Long> times = Lists.newArrayList();        final AtomicLong start = new AtomicLong(System.currentTimeMillis());        ((CuratorFrameworkImpl) client).debugListener = data -> {            if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {                long now = System.currentTimeMillis();                times.add(now - start.get());                start.set(now);                latch.countDown();            }        };        server.stop();        async.create().forPath("/one");        latch.await();        for (        long elapsed :         times.subList(1, times.size())) {            Assert.assertTrue(elapsed >= SLEEP, elapsed + ": " + times);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
public void curator_f3435_0() throws Exception
{    Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    try (CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1000)).build()) {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);                server.stop();                async.getChildren().forPath("/").handle((children, e) -> {            if (e instanceof KeeperException.ConnectionLossException) {                latch.countDown();            }            return null;        });                Assert.assertTrue(timing.awaitLatch(latch), "Callback has not been called by curator !");    }}
public void curator_f3436_0() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).maxCloseWaitMs(timing.forWaiting().milliseconds()).build();    try {        final AtomicBoolean hadIllegalStateException = new AtomicBoolean(false);        ((CuratorFrameworkImpl) client).debugUnhandledErrorListener = (message, e) -> {            if (e instanceof IllegalStateException) {                hadIllegalStateException.set(true);            }        };        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch operationReadyLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).debugListener = data -> {            try {                operationReadyLatch.await();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        };                async.create().forPath("/hey");        timing.sleepABit();                client.close();                operationReadyLatch.countDown();        timing.sleepABit();                Assert.assertFalse(hadIllegalStateException.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
protected void curator_f3437_0(CompletionStage<T> stage)
{    complete(stage, (v, e) -> {        if (e != null) {            Throwables.propagate(e);        }    });}
protected void curator_f3438_0(CompletionStage<T> stage, BiConsumer<? super T, Throwable> handler)
{    try {        stage.handle((v, e) -> {            handler.accept(v, e);            return null;        }).toCompletableFuture().get(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.interrupted();    } catch (ExecutionException e) {        if (e.getCause() instanceof AssertionError) {            throw (AssertionError) e.getCause();        }        Assert.fail("get() failed", e);    } catch (TimeoutException e) {        Assert.fail("get() timed out");    }}
public String curator_f3439_0()
{    return name;}
public String curator_f3440_0()
{    return name;}
public int curator_f3441_0()
{    return age;}
public String curator_f3442_0()
{    return firstName;}
public String curator_f3443_0()
{    return lastName;}
public int curator_f3444_0()
{    return age;}
public void curator_f3445_0() throws Exception
{    super.setup();    filterIsSetLatch = new CountDownLatch(1);    CuratorFramework rawClient = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(100));    rawClient.start();    this.client = AsyncCuratorFramework.wrap(rawClient);    ZPath modelPath = ZPath.parse("/test/it");    v1Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV1.class)).build();    v2Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV2.class)).build();    v3Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV3.class)).build();    v1opA = client.unwrap().transactionOp().create().forPath(v1Spec.path().parent().fullPath());    v1opB = ModeledFramework.wrap(client, v1Spec).createOp(new ModelV1("Test"));    v2op = ModeledFramework.wrap(client, v2Spec).updateOp(new ModelV2("Test 2", 10));    v3op = ModeledFramework.wrap(client, v3Spec).updateOp(new ModelV3("One", "Two", 30));    executor = Executors.newCachedThreadPool();    manager = new MigrationManager(client, LOCK_PATH, META_DATA_PATH, executor, Duration.ofMinutes(10)) {        @Override        protected List<Migration> filter(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException {            CountDownLatch localLatch = filterLatch.getAndSet(null);            if (localLatch != null) {                filterIsSetLatch.countDown();                try {                    localLatch.await();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                    Throwables.propagate(e);                }            }            return super.filter(set, operationHashesInOrder);        }    };    manager.debugCount = new AtomicInteger();}
protected List<Migration> curator_f3446_0(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException
{    CountDownLatch localLatch = filterLatch.getAndSet(null);    if (localLatch != null) {        filterIsSetLatch.countDown();        try {            localLatch.await();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            Throwables.propagate(e);        }    }    return super.filter(set, operationHashesInOrder);}
public void curator_f3447_0() throws Exception
{    CloseableUtils.closeQuietly(client.unwrap());    executor.shutdownNow();    super.teardown();}
public void curator_f3448_0()
{    Migration m1 = () -> Arrays.asList(v1opA, v1opB);    Migration m2 = () -> Collections.singletonList(v2op);    Migration m3 = () -> Collections.singletonList(v3op);    MigrationSet migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2, m3));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV3> v3Client = ModeledFramework.wrap(client, v3Spec);    complete(v3Client.read(), (m, e) -> {        Assert.assertEquals(m.getAge(), 30);        Assert.assertEquals(m.getFirstName(), "One");        Assert.assertEquals(m.getLastName(), "Two");    });    int count = manager.debugCount.get();    complete(manager.migrate(migrationSet));        Assert.assertEquals(manager.debugCount.get(), count);}
public void curator_f3449_0()
{    Migration m1 = () -> Arrays.asList(v1opA, v1opB);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(m1));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV1> v1Client = ModeledFramework.wrap(client, v1Spec);    complete(v1Client.read(), (m, e) -> Assert.assertEquals(m.getName(), "Test"));    Migration m2 = () -> Collections.singletonList(v2op);    migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV2> v2Client = ModeledFramework.wrap(client, v2Spec);    complete(v2Client.read(), (m, e) -> {        Assert.assertEquals(m.getName(), "Test 2");        Assert.assertEquals(m.getAge(), 10);    });    Migration m3 = () -> Collections.singletonList(v3op);    migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2, m3));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV3> v3Client = ModeledFramework.wrap(client, v3Spec);    complete(v3Client.read(), (m, e) -> {        Assert.assertEquals(m.getAge(), 30);        Assert.assertEquals(m.getFirstName(), "One");        Assert.assertEquals(m.getLastName(), "Two");    });}
public void curator_f3450_0() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/parent");    CuratorOp op2 = client.transactionOp().create().forPath("/parent/one");    CuratorOp op3 = client.transactionOp().create().forPath("/parent/two");    CuratorOp op4 = client.transactionOp().create().forPath("/parent/three");    CuratorOp op5 = client.transactionOp().create().forPath("/main", "hey".getBytes());    Migration initialMigration = () -> Arrays.asList(op1, op2, op3, op4, op5);    MigrationSet migrationSet = MigrationSet.build("main", Collections.singletonList(initialMigration));    complete(manager.migrate(migrationSet));    Assert.assertNotNull(client.unwrap().checkExists().forPath("/parent/three"));    Assert.assertEquals(client.unwrap().getData().forPath("/main"), "hey".getBytes());    CuratorOp newOp1 = client.transactionOp().create().forPath("/new");        CuratorOp newOp2 = client.transactionOp().delete().forPath("/main");    Migration newMigration = () -> Arrays.asList(newOp1, newOp2);    migrationSet = MigrationSet.build("main", Arrays.asList(initialMigration, newMigration));    complete(manager.migrate(migrationSet));    Assert.assertNull(client.unwrap().checkExists().forPath("/main"));}
public void curator_f3451_0()
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    complete(manager.migrate(migrationSet));    CuratorOp op2Changed = client.transactionOp().create().forPath("/test/bar", "second".getBytes());    migration = () -> Arrays.asList(op1, op2Changed);    migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof MigrationException);    }}
public void curator_f3452_0()
{    CuratorOp op1 = client.transactionOp().create().forPath("/test2");    CuratorOp op2 = client.transactionOp().create().forPath("/test2/bar");    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    complete(manager.migrate(migrationSet));    CuratorOp op2Changed = client.transactionOp().create().forPath("/test/bar");    migration = () -> Arrays.asList(op1, op2Changed);    migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof MigrationException);    }}
public void curator_f3453_0() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test", "something".getBytes());    CuratorOp op2 = client.transactionOp().create().forPath("/a/b/c");    Migration m1 = () -> Collections.singletonList(op1);    Migration m2 = () -> Collections.singletonList(op2);    MigrationSet migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof KeeperException.NoNodeException);    }        Assert.assertNull(client.unwrap().checkExists().forPath("/test"));}
public void curator_f3454_0() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test2", "something".getBytes());    CuratorOp op2 = client.transactionOp().create().forPath("/a/b/c/d");    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof KeeperException.NoNodeException);    }    Assert.assertNull(client.unwrap().checkExists().forPath("/test"));}
public void curator_f3455_0() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    CountDownLatch latch = new CountDownLatch(1);    filterLatch.set(latch);    CompletionStage<Void> first = manager.migrate(migrationSet);    Assert.assertTrue(timing.awaitLatch(filterIsSetLatch));    MigrationManager manager2 = new MigrationManager(client, LOCK_PATH, META_DATA_PATH, executor, Duration.ofMillis(timing.forSleepingABit().milliseconds()));    try {        complete(manager2.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof AsyncWrappers.TimeoutException, "Should throw AsyncWrappers.TimeoutException, was: " + Throwables.getStackTraceAsString(Throwables.getRootCause(e)));    }    latch.countDown();    complete(first);    Assert.assertEquals(client.unwrap().getData().forPath("/test/bar"), "first".getBytes());}
public void curator_f3456_0() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    CountDownLatch latch = new CountDownLatch(1);    filterLatch.set(latch);    CompletionStage<Void> first = manager.migrate(migrationSet);    Assert.assertTrue(timing.awaitLatch(filterIsSetLatch));    CompletionStage<Void> second = manager.migrate(migrationSet);    try {        second.toCompletableFuture().get(timing.forSleepingABit().milliseconds(), TimeUnit.MILLISECONDS);        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof TimeoutException, "Should throw TimeoutException, was: " + Throwables.getStackTraceAsString(Throwables.getRootCause(e)));    }    latch.countDown();    complete(first);    Assert.assertEquals(client.unwrap().getData().forPath("/test/bar"), "first".getBytes());    complete(second);    Assert.assertEquals(manager.debugCount.get(), 1);}
public String curator_f3457_0()
{    return firstName;}
public String curator_f3458_0()
{    return lastName;}
public String curator_f3459_0()
{    return address;}
public int curator_f3460_0()
{    return age;}
public BigInteger curator_f3461_0()
{    return salary;}
public boolean curator_f3462_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestModel testModel = (TestModel) o;    if (age != testModel.age) {        return false;    }    if (!firstName.equals(testModel.firstName)) {        return false;    }    if (!lastName.equals(testModel.lastName)) {        return false;    }        if (!address.equals(testModel.address)) {        return false;    }    return salary.equals(testModel.salary);}
public int curator_f3463_0()
{    int result = firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + address.hashCode();    result = 31 * result + age;    result = 31 * result + salary.hashCode();    return result;}
public String curator_f3464_0()
{    return firstName;}
public String curator_f3465_0()
{    return lastName;}
public String curator_f3466_0()
{    return address;}
public int curator_f3467_0()
{    return age;}
public BigInteger curator_f3468_0()
{    return salary;}
public long curator_f3469_0()
{    return newField;}
public boolean curator_f3470_0(TestModel model)
{    return firstName.equals(model.getFirstName()) && lastName.equals(model.getLastName()) && address.equals(model.getAddress()) && salary.equals(model.getSalary()) && age == model.getAge();}
public boolean curator_f3471_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestNewerModel that = (TestNewerModel) o;    if (age != that.age) {        return false;    }    if (newField != that.newField) {        return false;    }    if (!firstName.equals(that.firstName)) {        return false;    }    if (!lastName.equals(that.lastName)) {        return false;    }        if (!address.equals(that.address)) {        return false;    }    return salary.equals(that.salary);}
public int curator_f3472_0()
{    int result = firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + address.hashCode();    result = 31 * result + age;    result = 31 * result + salary.hashCode();    result = 31 * result + (int) (newField ^ (newField >>> 32));    return result;}
public String curator_f3473_0()
{    return name;}
public int curator_f3474_0()
{    return age;}
public boolean curator_f3475_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestSimpleModel that = (TestSimpleModel) o;        if (age != that.age) {        return false;    }    return name.equals(that.name);}
public int curator_f3476_0()
{    int result = name.hashCode();    result = 31 * result + age;    return result;}
public String curator_f3477_0()
{    return "TestSimpleModel{" + "name='" + name + '\'' + ", age=" + age + '}';}
public void curator_f3478_0() throws IOException
{    Timing timing = new Timing();    TestModel model = new TestModel("a", "b", "c", 1, BigInteger.ONE);    CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached();    Semaphore semaphore = new Semaphore(0);    client.listenable().addListener((t, p, s, m) -> semaphore.release());    client.start();    try {        client.child(model).set(model);        Assert.assertTrue(timing.acquireSemaphore(semaphore));        CountDownLatch latch = new CountDownLatch(1);        rawClient.getConnectionStateListenable().addListener((__, state) -> {            if (state == ConnectionState.LOST) {                latch.countDown();            }        });        server.stop();        Assert.assertTrue(timing.awaitLatch(latch));        complete(client.child(model).read().whenComplete((value, e) -> {            Assert.assertNotNull(value);            Assert.assertNull(e);        }));    } finally {        client.close();    }}
public void curator_f3479_0()
{    TestModel model1 = new TestModel("a", "b", "c", 1, BigInteger.ONE);    TestModel model2 = new TestModel("d", "e", "f", 1, BigInteger.ONE);    CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached();    Semaphore semaphore = new Semaphore(0);    ModeledCacheListener<TestModel> listener = (t, p, s, m) -> semaphore.release();    client.listenable().addListener(listener.postInitializedOnly());        complete(client.child("1").set(model1));    client.start();    try {        Assert.assertFalse(timing.forSleepingABit().acquireSemaphore(semaphore));                client.child("2").set(model2);        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        client.close();    }}
public void curator_f3480_0()
{    TestModel parent = new TestModel("a", "b", "c", 20, BigInteger.ONE);    TestModel child1 = new TestModel("d", "e", "f", 1, BigInteger.ONE);    TestModel child2 = new TestModel("g", "h", "i", 1, BigInteger.ONE);    TestModel grandChild1 = new TestModel("j", "k", "l", 10, BigInteger.ONE);    TestModel grandChild2 = new TestModel("m", "n", "0", 5, BigInteger.ONE);    try (CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached()) {        CountDownLatch latch = new CountDownLatch(5);        client.listenable().addListener((t, p, s, m) -> latch.countDown());        client.start();        complete(client.child("p").set(parent));        complete(client.child("p").child("c1").set(child1));        complete(client.child("p").child("c2").set(child2));        complete(client.child("p").child("c1").child("g1").set(grandChild1));        complete(client.child("p").child("c2").child("g2").set(grandChild2));        Assert.assertTrue(timing.awaitLatch(latch));        complete(client.child("p").children(), (v, e) -> {            List<ZPath> paths = Arrays.asList(client.child("p").child("c1").modelSpec().path(), client.child("p").child("c2").modelSpec().path());            Assert.assertEquals(v, paths);        });        complete(client.child("p").childrenAsZNodes(), (v, e) -> {            Set<TestModel> cachedModels = toSet(v.stream(), ZNode::model);            Assert.assertEquals(cachedModels, Sets.newHashSet(child1, child2));                        complete(ModeledFramework.wrap(async, modelSpec).child("p").childrenAsZNodes(), (v2, e2) -> {                Set<TestModel> uncachedModels = toSet(v2.stream(), ZNode::model);                Assert.assertEquals(cachedModels, uncachedModels);            });        });        complete(client.child("p").child("c1").childrenAsZNodes(), (v, e) -> {            Assert.assertEquals(toSet(v.stream(), ZNode::model), Sets.newHashSet(grandChild1));        });        complete(client.child("p").child("c2").childrenAsZNodes(), (v, e) -> {            Assert.assertEquals(toSet(v.stream(), ZNode::model), Sets.newHashSet(grandChild2));        });    }}
private Set<R> curator_f3481_0(Stream<T> stream, Function<? super T, ? extends R> mapper)
{    return stream.map(mapper).collect(Collectors.toSet());}
public void curator_f3482_0()
{    TestModel rawModel = new TestModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1));    TestModel rawModel2 = new TestModel("Wayne", "Rooney", "Old Trafford", 10, BigInteger.valueOf(1));    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec);    AsyncStage<String> stage = client.set(rawModel);    Assert.assertNull(stage.event());    complete(stage, (s, e) -> Assert.assertNotNull(s));    complete(client.read(), (model, e) -> Assert.assertEquals(model, rawModel));    complete(client.update(rawModel2));    complete(client.read(), (model, e) -> Assert.assertEquals(model, rawModel2));    complete(client.delete());    complete(client.checkExists(), (stat, e) -> Assert.assertNull(stat));}
public void curator_f3483_0()
{    TestNewerModel rawNewModel = new TestNewerModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1), 100);    ModeledFramework<TestNewerModel> clientForNew = ModeledFramework.wrap(async, newModelSpec);    complete(clientForNew.set(rawNewModel), (s, e) -> Assert.assertNotNull(s));    ModeledFramework<TestModel> clientForOld = ModeledFramework.wrap(async, modelSpec);    complete(clientForOld.read(), (model, e) -> Assert.assertTrue(rawNewModel.equalsOld(model)));}
public void curator_f3484_0() throws InterruptedException
{    CountDownLatch latch = new CountDownLatch(1);    ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).watched().build();    client.checkExists().event().whenComplete((event, ex) -> latch.countDown());    timing.sleepABit();    Assert.assertEquals(latch.getCount(), 1);    client.set(new TestModel());    Assert.assertTrue(timing.awaitLatch(latch));}
public void curator_f3485_0()
{    TestModel model = new TestModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1));    ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).build();    complete(client.child("one").set(model));    complete(client.child("two").set(model));    complete(client.child("three").set(model));    Set<ZPath> expected = Sets.newHashSet(path.child("one"), path.child("two"), path.child("three"));    complete(client.children(), (children, e) -> Assert.assertEquals(Sets.newHashSet(children), expected));}
public void curator_f3486_0()
{    complete(async.create().forPath(modelSpec.path().fullPath(), "fubar".getBytes()), (v, e) -> {    });        ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).watched().build();    complete(client.read(), (model, e) -> Assert.assertTrue(e instanceof KeeperException.NoNodeException));}
public void curator_f3487_0() throws Exception
{    Schema schema = modelSpec.schema();    try (CuratorFramework schemaClient = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(new SchemaSet(Collections.singletonList(schema), false)).build()) {        schemaClient.start();        try {            schemaClient.create().forPath(modelSpec.path().fullPath(), "asflasfas".getBytes());            Assert.fail("Should've thrown SchemaViolation");        } catch (SchemaViolation dummy) {                }        ModeledFramework<TestModel> modeledSchemaClient = ModeledFramework.wrap(AsyncCuratorFramework.wrap(schemaClient), modelSpec);        complete(modeledSchemaClient.set(new TestModel("one", "two", "three", 4, BigInteger.ONE)), (dummy, e) -> Assert.assertNull(e));    }}
public void curator_f3488_0()
{    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec);    TestModel model = new TestModel("John", "Galt", "Galt's Gulch", 21, BigInteger.valueOf(1010101));    complete(client.set(model));        complete(client.set(model));    VersionedModeledFramework<TestModel> versioned = client.versioned();    complete(versioned.read().whenComplete((v, e) -> {        Assert.assertNull(e);        Assert.assertTrue(v.version() > 0);    }).thenCompose(versioned::set),     (s, e) -> Assert.assertNull(e));    Versioned<TestModel> badVersion = Versioned.from(model, 100000);    complete(versioned.set(badVersion), (v, e) -> Assert.assertTrue(e instanceof KeeperException.BadVersionException));    final Stat stat = new Stat();    complete(client.read(stat));        complete(client.delete(stat.getVersion() + 1), (v, e) -> Assert.assertTrue(e instanceof KeeperException.BadVersionException));        complete(client.delete(stat.getVersion()));}
public void curator_f3489_0() throws NoSuchAlgorithmException
{    List<ACL> aclList = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("digest", DigestAuthenticationProvider.generateDigest("test:test"))));    ModelSpec<TestModel> aclModelSpec = ModelSpec.builder(modelSpec.path(), modelSpec.serializer()).withAclList(aclList).build();    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, aclModelSpec);    complete(client.set(new TestModel("John", "Galt", "Galt's Gulch", 21, BigInteger.valueOf(1010101))));    complete(client.update(new TestModel("John", "Galt", "Galt's Gulch", 54, BigInteger.valueOf(88))), (__, e) -> Assert.assertNotNull(e, "Should've gotten an auth failure"));    try (CuratorFramework authCurator = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).authorization("digest", "test:test".getBytes()).build()) {        authCurator.start();        ModeledFramework<TestModel> authClient = ModeledFramework.wrap(AsyncCuratorFramework.wrap(authCurator), aclModelSpec);        complete(authClient.update(new TestModel("John", "Galt", "Galt's Gulch", 42, BigInteger.valueOf(66))), (__, e) -> Assert.assertNull(e, "Should've succeeded"));    }}
public void curator_f3490_0() throws Exception
{    super.setup();    rawClient = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    rawClient.start();    async = AsyncCuratorFramework.wrap(rawClient);    JacksonModelSerializer<TestModel> serializer = JacksonModelSerializer.build(TestModel.class);    JacksonModelSerializer<TestNewerModel> newSerializer = JacksonModelSerializer.build(TestNewerModel.class);    modelSpec = ModelSpec.builder(path, serializer).build();    newModelSpec = ModelSpec.builder(path, newSerializer).build();}
public void curator_f3491_0() throws Exception
{    CloseableUtils.closeQuietly(rawClient);    super.teardown();}
public void curator_f3492_0()
{    Assert.assertEquals(ZPath.root.nodeName(), ZKPaths.PATH_SEPARATOR);    Assert.assertEquals(ZPath.root, ZPathImpl.root);    Assert.assertTrue(ZPath.root.isRoot());    Assert.assertEquals(ZPath.root.child("foo").parent(), ZPath.root);    Assert.assertTrue(ZPath.root.child("foo").parent().isRoot());}
public void curator_f3493_0()
{    ZPath path = ZPath.root.child("one").child("two");    Assert.assertFalse(path.isRoot());    Assert.assertEquals(path, ZPath.root.child("one").child("two"));    Assert.assertNotEquals(path, ZPath.root.child("onex").child("two"));    Assert.assertEquals(path.nodeName(), "two");    Assert.assertEquals(path.fullPath(), "/one/two");    Assert.assertEquals(path.parent().fullPath(), "/one");        Assert.assertEquals(path.fullPath(), "/one/two");        Assert.assertEquals(path.parent().fullPath(), "/one");    Assert.assertTrue(path.startsWith(ZPath.root.child("one")));    Assert.assertFalse(path.startsWith(ZPath.root.child("two")));    ZPath checkIdLike = ZPath.parse("/one/{two}/three");    Assert.assertTrue(checkIdLike.isResolved());    checkIdLike = ZPath.parse("/one/" + ZPath.parameter() + "/three");    Assert.assertTrue(checkIdLike.isResolved());    checkIdLike = ZPath.parse("/one/" + ZPath.parameter("others") + "/three");    Assert.assertTrue(checkIdLike.isResolved());}
public void curator_f3494_0()
{    Assert.assertEquals(ZPath.parse("/"), ZPath.root);    Assert.assertEquals(ZPath.parse("/one/two/three"), ZPath.root.child("one").child("two").child("three"));    Assert.assertEquals(ZPath.parse("/one/two/three"), ZPath.from("one", "two", "three"));    Assert.assertEquals(ZPath.parseWithIds("/one/{id}/two/{id}"), ZPath.from("one", parameter(), "two", parameter()));}
public void curator_f3495_0()
{    ZPath path = ZPath.from("one", parameter(), "two");    path.fullPath();}
public void curator_f3496_0()
{    ZPath path = ZPath.from("one", parameter(), "two", parameter());    Assert.assertEquals(path.resolved("a", "b"), ZPath.from("one", "a", "two", "b"));}
public void curator_f3497_0()
{    ZPath path = ZPath.from("one", parameter(), "two", parameter());    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/.*/two/.*");    path = ZPath.parse("/one/two/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/two/three");    path = ZPath.parseWithIds("/one/{id}/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/.*/three");    path = ZPath.parseWithIds("/{id}/{id}/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/.*/.*/three");}
public void curator_f3498_0()
{    Assert.assertEquals(ZPath.parseWithIds("/a/{a}/bee/{bee}/c/{c}").toString(), "/a/{a}/bee/{bee}/c/{c}");    Assert.assertEquals(ZPath.from("a", parameter(), "b", parameter()).toString(), "/a/{id}/b/{id}");    Assert.assertEquals(ZPath.from("a", parameter("foo"), "b", parameter("bar")).toString(), "/a/{foo}/b/{bar}");}
public void curator_f3499_0()
{    ZPath path = ZPath.parseWithIds("/one/{1}/two/{2}");    Assert.assertFalse(path.parent().isResolved());    Assert.assertFalse(path.parent().parent().isResolved());    Assert.assertTrue(path.parent().parent().parent().isResolved());    Assert.assertFalse(path.isResolved());    path = path.resolved("p1");    Assert.assertFalse(path.isResolved());    Assert.assertTrue(path.parent().isResolved());    Assert.assertEquals(path.toString(), "/one/p1/two/{2}");    path = path.resolved("p2");    Assert.assertTrue(path.isResolved());    Assert.assertEquals(path.toString(), "/one/p1/two/p2");}
public void curator_f3500_0()
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        InterProcessMutex lock = new InterProcessMutex(client, "/one/two");        complete(AsyncWrappers.lockAsync(lock), (__, e) -> {            Assert.assertNull(e);            AsyncWrappers.release(lock);        });    }}
public void curator_f3501_0() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        InterProcessMutex lock1 = new InterProcessMutex(client, "/one/two");        InterProcessMutex lock2 = new InterProcessMutex(client, "/one/two");        CountDownLatch latch = new CountDownLatch(1);        AsyncWrappers.lockAsync(lock1).thenAccept(__ -> {                        latch.countDown();        });        Assert.assertTrue(timing.awaitLatch(latch));        CountDownLatch latch2 = new CountDownLatch(1);        AsyncWrappers.lockAsync(lock2, timing.forSleepingABit().milliseconds(), TimeUnit.MILLISECONDS).exceptionally(e -> {            if (e instanceof AsyncWrappers.TimeoutException) {                                latch2.countDown();            }            return null;        });        Assert.assertTrue(timing.awaitLatch(latch2));    }}
public void curator_f3502_0() throws Exception
{    super.setup();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(timing.forSleepingABit().milliseconds()));    client.start();    this.client = AsyncCuratorFramework.wrap(client);}
public void curator_f3503_0() throws Exception
{    CloseableUtils.closeQuietly(client.unwrap());    super.teardown();}
public void curator_f3504_0() throws Exception
{    complete(AsyncWrappers.asyncEnsureContainers(client, "/test"));    CuratorOp op1 = client.transactionOp().create().withMode(PERSISTENT_SEQUENTIAL).forPath("/test/node-");    CuratorOp op2 = client.transactionOp().create().withMode(PERSISTENT_SEQUENTIAL).forPath("/test/node-");    complete(client.transaction().forOperations(Arrays.asList(op1, op2)));    Assert.assertEquals(client.unwrap().getChildren().forPath("/test").size(), 2);}
public void curator_f3505_0()
{    AsyncStage<String> createStage = client.create().forPath("/test", "one".getBytes());    complete(createStage, (path, e) -> Assert.assertEquals(path, "/test"));    AsyncStage<byte[]> getStage = client.getData().forPath("/test");    complete(getStage, (data, e) -> Assert.assertEquals(data, "one".getBytes()));    CompletionStage<byte[]> combinedStage = client.setData().forPath("/test", "new".getBytes()).thenCompose(__ -> client.getData().forPath("/test"));    complete(combinedStage, (data, e) -> Assert.assertEquals(data, "new".getBytes()));    CompletionStage<Void> combinedDelete = client.create().withMode(EPHEMERAL_SEQUENTIAL).forPath("/deleteme").thenCompose(path -> client.delete().forPath(path));    complete(combinedDelete, (v, e) -> Assert.assertNull(e));    CompletionStage<byte[]> setDataIfStage = client.create().withOptions(of(compress, setDataIfExists)).forPath("/test", "last".getBytes()).thenCompose(__ -> client.getData().decompressed().forPath("/test"));    complete(setDataIfStage, (data, e) -> Assert.assertEquals(data, "last".getBytes()));}
public void curator_f3506_0()
{    CountDownLatch latch = new CountDownLatch(1);    client.getData().forPath("/woop").exceptionally(e -> {        Assert.assertTrue(e instanceof KeeperException);        Assert.assertEquals(((KeeperException) e).code(), KeeperException.Code.NONODE);        latch.countDown();        return null;    });    Assert.assertTrue(timing.awaitLatch(latch));}
public void curator_f3507_0()
{    CountDownLatch latch = new CountDownLatch(1);    client.watched().checkExists().forPath("/test").event().whenComplete((event, exception) -> {        Assert.assertNull(exception);        Assert.assertEquals(event.getType(), Watcher.Event.EventType.NodeCreated);        latch.countDown();    });    client.create().forPath("/test");    Assert.assertTrue(timing.awaitLatch(latch));}
public void curator_f3508_0() throws Exception
{    AsyncStage<Stat> stage = client.watched().checkExists().forPath("/test");    stage.thenRun(() -> {        try {            server.stop();        } catch (IOException e) {                }    });    CountDownLatch latch = new CountDownLatch(1);    complete(stage.event(), (v, e) -> {        Assert.assertTrue(e instanceof AsyncEventException);        Assert.assertEquals(((AsyncEventException) e).getKeeperState(), Watcher.Event.KeeperState.Disconnected);        ((AsyncEventException) e).reset().thenRun(latch::countDown);    });    server.restart();    client.create().forPath("/test");    Assert.assertTrue(timing.awaitLatch(latch));}
public void curator_f3509_0() throws Exception
{    CompletionStage<AsyncResult<String>> resultStage = AsyncResult.of(client.create().forPath("/first"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertEquals(v.getRawValue(), "/first");        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.OK);    });    resultStage = AsyncResult.of(client.create().forPath("/foo/bar"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.NONODE);    });    resultStage = AsyncResult.of(client.create().forPath("illegal path"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNotNull(v.getRawException());        Assert.assertTrue(v.getRawException() instanceof IllegalArgumentException);        Assert.assertEquals(v.getCode(), KeeperException.Code.SYSTEMERROR);    });    server.stop();    resultStage = AsyncResult.of(client.create().forPath("/second"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.CONNECTIONLOSS);    });}
public void curator_f3510_0()
{    complete(client.create().forPath("/test", "hey".getBytes()));    Stat stat = new Stat();    complete(client.getData().storingStatIn(stat).forPath("/test"));    Assert.assertEquals(stat.getDataLength(), "hey".length());}
 void curator_f3511_0(ServiceInstance<?> instance)
{    purge();    Status newStatus = new Status();    Status oldStatus = statuses.putIfAbsent(instance, newStatus);    Status useStatus = (oldStatus != null) ? oldStatus : newStatus;    useStatus.errorCount.incrementAndGet();}
public boolean curator_f3512_0(ServiceInstance<T> instance)
{    purge();    Status status = statuses.get(instance);    return (status == null) || (status.errorCount.get() < downInstancePolicy.getErrorThreshold());}
private void curator_f3513_0()
{    long localLastPurge = lastPurge.get();    long ticksSinceLastPurge = System.currentTimeMillis() - localLastPurge;    if (ticksSinceLastPurge < (downInstancePolicy.getTimeoutMs() / 2)) {        return;    }    if (!lastPurge.compareAndSet(localLastPurge, System.currentTimeMillis())) {        return;    }    Iterator<Entry<ServiceInstance<?>, Status>> it = statuses.entrySet().iterator();    while (it.hasNext()) {        Entry<ServiceInstance<?>, Status> entry = it.next();        long elapsedMs = System.currentTimeMillis() - entry.getValue().startMs;        if (elapsedMs >= downInstancePolicy.getTimeoutMs()) {            it.remove();        }    }}
public List<ServiceInstance<T>> curator_f3514_0() throws Exception
{    Iterable<ServiceInstance<T>> filtered = Iterables.filter(instanceProvider.getInstances(), predicates);    return ImmutableList.copyOf(filtered);}
public ServiceInstance<T> curator_f3515_0(byte[] bytes) throws Exception
{    ServiceInstance rawServiceInstance = mapper.readValue(bytes, type);        payloadClass.cast(rawServiceInstance.getPayload());    return (ServiceInstance<T>) rawServiceInstance;}
public byte[] curator_f3516_0(ServiceInstance<T> instance) throws Exception
{    if (compatibleSerializationMode) {        OldServiceInstance<T> compatible = new OldServiceInstance<T>(instance.getName(), instance.getId(), instance.getAddress(), instance.getPort(), instance.getSslPort(), instance.getPayload(), instance.getRegistrationTimeUTC(), instance.getServiceType(), instance.getUriSpec());        return mapper.writeValueAsBytes(compatible);    }    return mapper.writeValueAsBytes(instance);}
 synchronized void curator_f3517_0()
{    laden = true;    notifyAll();}
 synchronized void curator_f3518_0() throws InterruptedException
{    while (!laden) {        wait();    }    laden = false;}
public String curator_f3519_0()
{    return name;}
public String curator_f3520_0()
{    return id;}
public String curator_f3521_0()
{    return address;}
public Integer curator_f3522_0()
{    return port;}
public Integer curator_f3523_0()
{    return sslPort;}
public T curator_f3524_0()
{    return payload;}
public long curator_f3525_0()
{    return registrationTimeUTC;}
public ServiceType curator_f3526_0()
{    return serviceType;}
public UriSpec curator_f3527_0()
{    return uriSpec;}
public boolean curator_f3528_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    OldServiceInstance that = (OldServiceInstance) o;    if (registrationTimeUTC != that.registrationTimeUTC) {        return false;    }    if (address != null ? !address.equals(that.address) : that.address != null) {        return false;    }    if (id != null ? !id.equals(that.id) : that.id != null) {        return false;    }    if (name != null ? !name.equals(that.name) : that.name != null) {        return false;    }    if (payload != null ? !payload.equals(that.payload) : that.payload != null) {        return false;    }    if (port != null ? !port.equals(that.port) : that.port != null) {        return false;    }    if (serviceType != that.serviceType) {        return false;    }    if (sslPort != null ? !sslPort.equals(that.sslPort) : that.sslPort != null) {        return false;    }    if (uriSpec != null ? !uriSpec.equals(that.uriSpec) : that.uriSpec != null) {        return false;    }    return true;}
public int curator_f3529_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (id != null ? id.hashCode() : 0);    result = 31 * result + (address != null ? address.hashCode() : 0);    result = 31 * result + (port != null ? port.hashCode() : 0);    result = 31 * result + (sslPort != null ? sslPort.hashCode() : 0);    result = 31 * result + (payload != null ? payload.hashCode() : 0);    result = 31 * result + (int) (registrationTimeUTC ^ (registrationTimeUTC >>> 32));    result = 31 * result + (serviceType != null ? serviceType.hashCode() : 0);    result = 31 * result + (uriSpec != null ? uriSpec.hashCode() : 0);    return result;}
public String curator_f3530_0()
{    return "ServiceInstance{" + "name='" + name + '\'' + ", id='" + id + '\'' + ", address='" + address + '\'' + ", port=" + port + ", sslPort=" + sslPort + ", payload=" + payload + ", registrationTimeUTC=" + registrationTimeUTC + ", serviceType=" + serviceType + ", uriSpec=" + uriSpec + '}';}
public ServiceCache<T> curator_f3531_0()
{    if (executorService != null) {        return new ServiceCacheImpl<T>(discovery, name, executorService);    } else {        return new ServiceCacheImpl<T>(discovery, name, threadFactory);    }}
public ServiceCacheBuilder<T> curator_f3532_0(String name)
{    this.name = name;    return this;}
public ServiceCacheBuilder<T> curator_f3533_0(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    this.executorService = null;    return this;}
public ServiceCacheBuilder<T> curator_f3534_0(ExecutorService executorService)
{    this.executorService = new CloseableExecutorService(executorService);    this.threadFactory = null;    return this;}
public ServiceCacheBuilder<T> curator_f3535_0(CloseableExecutorService executorService)
{    this.executorService = executorService;    this.threadFactory = null;    return this;}
private static CloseableExecutorService curator_f3536_0(ThreadFactory threadFactory)
{    Preconditions.checkNotNull(threadFactory, "threadFactory cannot be null");    return new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory));}
public List<ServiceInstance<T>> curator_f3537_0()
{    return Lists.newArrayList(instances.values());}
public void curator_f3538_0() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    cache.start(true);    if (debugStartLatch != null) {        debugStartLatch.countDown();        debugStartLatch = null;    }    if (debugStartWaitLatch != null) {        debugStartWaitLatch.await();        debugStartWaitLatch = null;    }    for (ChildData childData : cache.getCurrentData()) {        if (        childData.getData() != null) {            addInstance(childData, true);        }    }    discovery.cacheOpened(this);}
public void curator_f3539_0() throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.STOPPED), "Already closed or has not been started");    listenerContainer.forEach(new Function<ServiceCacheListener, Void>() {        @Override        public Void apply(ServiceCacheListener listener) {            discovery.getClient().getConnectionStateListenable().removeListener(listener);            return null;        }    });    listenerContainer.clear();    CloseableUtils.closeQuietly(cache);    discovery.cacheClosed(this);}
public Void curator_f3540_0(ServiceCacheListener listener)
{    discovery.getClient().getConnectionStateListenable().removeListener(listener);    return null;}
public void curator_f3541_0(ServiceCacheListener listener)
{    listenerContainer.addListener(listener);    discovery.getClient().getConnectionStateListenable().addListener(listener);}
public void curator_f3542_0(ServiceCacheListener listener, Executor executor)
{    listenerContainer.addListener(listener, executor);    discovery.getClient().getConnectionStateListenable().addListener(listener, executor);}
public void curator_f3543_0(ServiceCacheListener listener)
{    listenerContainer.removeListener(listener);    discovery.getClient().getConnectionStateListenable().removeListener(listener);}
public void curator_f3544_0(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    boolean notifyListeners = false;    switch(event.getType()) {        case CHILD_ADDED:        case CHILD_UPDATED:            {                addInstance(event.getData(), false);                notifyListeners = true;                break;            }        case CHILD_REMOVED:            {                instances.remove(instanceIdFromData(event.getData()));                notifyListeners = true;                break;            }    }    if (notifyListeners) {        listenerContainer.forEach(new Function<ServiceCacheListener, Void>() {            @Override            public Void apply(ServiceCacheListener listener) {                listener.cacheChanged();                return null;            }        });    }}
public Void curator_f3545_0(ServiceCacheListener listener)
{    listener.cacheChanged();    return null;}
private String curator_f3546_0(ChildData childData)
{    return ZKPaths.getNodeFromPath(childData.getPath());}
private void curator_f3547_0(ChildData childData, boolean onlyIfAbsent) throws Exception
{    String instanceId = instanceIdFromData(childData);    ServiceInstance<T> serviceInstance = discovery.getSerializer().deserialize(childData.getData());    if (onlyIfAbsent) {        instances.putIfAbsent(instanceId, serviceInstance);    } else {        instances.put(instanceId, serviceInstance);    }    cache.clearDataBytes(childData.getPath(), childData.getStat().getVersion());}
public void curator_f3548_1(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.RECONNECTED) || (newState == ConnectionState.CONNECTED)) {        try {                        reRegisterServices();        } catch (InterruptedException ex) {            Thread.currentThread().interrupt();        } catch (Exception e) {                    }    }}
public void curator_f3549_1() throws Exception
{    try {        reRegisterServices();    } catch (KeeperException e) {            }    client.getConnectionStateListenable().addListener(connectionStateListener);}
public void curator_f3550_1() throws IOException
{    ExceptionAccumulator accumulator = new ExceptionAccumulator();    for (ServiceProvider<T> provider : Lists.newArrayList(providers)) {        CloseableUtils.closeQuietly(provider);    }    for (Entry<T> entry : services.values()) {        try {            internalUnregisterService(entry);        } catch (KeeperException.NoNodeException ignore) {                } catch (Exception e) {            accumulator.add(e);                    }    }    client.getConnectionStateListenable().removeListener(connectionStateListener);    accumulator.propagate();}
public void curator_f3551_0(ServiceInstance<T> service) throws Exception
{    Entry<T> newEntry = new Entry<T>(service);    Entry<T> oldEntry = services.putIfAbsent(service.getId(), newEntry);    Entry<T> useEntry = (oldEntry != null) ? oldEntry : newEntry;    synchronized (useEntry) {        if (        useEntry == newEntry) {            useEntry.cache = makeNodeCache(service);        }        internalRegisterService(service);    }}
public void curator_f3552_0(final ServiceInstance<T> service) throws Exception
{    Entry<T> entry = services.get(service.getId());    if (entry == null) {        throw new Exception("Service not registered: " + service);    }    synchronized (entry) {        entry.service = service;        byte[] bytes = serializer.serialize(service);        String path = pathForInstance(service.getName(), service.getId());        client.setData().forPath(path, bytes);    }}
protected void curator_f3553_0(ServiceInstance<T> service) throws Exception
{    byte[] bytes = serializer.serialize(service);    String path = pathForInstance(service.getName(), service.getId());    final int MAX_TRIES = 2;    boolean isDone = false;    for (int i = 0; !isDone && (i < MAX_TRIES); ++i) {        try {            CreateMode mode;            switch(service.getServiceType()) {                case DYNAMIC:                    mode = CreateMode.EPHEMERAL;                    break;                case DYNAMIC_SEQUENTIAL:                    mode = CreateMode.EPHEMERAL_SEQUENTIAL;                    break;                default:                    mode = CreateMode.PERSISTENT;                    break;            }            client.create().creatingParentContainersIfNeeded().withMode(mode).forPath(path, bytes);            isDone = true;        } catch (KeeperException.NodeExistsException e) {                        client.delete().forPath(path);        }    }}
public void curator_f3554_0(ServiceInstance<T> service) throws Exception
{    Entry<T> entry = services.remove(service.getId());    internalUnregisterService(entry);}
public ServiceProviderBuilder<T> curator_f3555_0()
{    return new ServiceProviderBuilderImpl<T>(this).providerStrategy(new RoundRobinStrategy<T>()).threadFactory(ThreadUtils.newThreadFactory("ServiceProvider"));}
public ServiceCacheBuilder<T> curator_f3556_0()
{    return new ServiceCacheBuilderImpl<T>(this).threadFactory(ThreadUtils.newThreadFactory("ServiceCache"));}
public Collection<String> curator_f3557_0() throws Exception
{    List<String> names = client.getChildren().forPath(basePath);    return ImmutableList.copyOf(names);}
public Collection<ServiceInstance<T>> curator_f3558_0(String name) throws Exception
{    return queryForInstances(name, null);}
public ServiceInstance<T> curator_f3559_0(String name, String id) throws Exception
{    String path = pathForInstance(name, id);    try {        byte[] bytes = client.getData().forPath(path);        return serializer.deserialize(bytes);    } catch (KeeperException.NoNodeException ignore) {        }    return null;}
 void curator_f3560_0(ServiceCache<T> cache)
{    caches.add(cache);}
 void curator_f3561_0(ServiceCache<T> cache)
{    caches.remove(cache);}
 void curator_f3562_0(ServiceProvider<T> provider)
{    providers.add(provider);}
 void curator_f3563_0(ServiceProvider<T> cache)
{    providers.remove(cache);}
 CuratorFramework curator_f3564_0()
{    return client;}
 String curator_f3565_0(String name)
{    return ZKPaths.makePath(basePath, name);}
 InstanceSerializer<T> curator_f3566_0()
{    return serializer;}
 List<ServiceInstance<T>> curator_f3567_0(String name, Watcher watcher) throws Exception
{    ImmutableList.Builder<ServiceInstance<T>> builder = ImmutableList.builder();    String path = pathForName(name);    List<String> instanceIds;    if (watcher != null) {        instanceIds = getChildrenWatched(path, watcher, true);    } else {        try {            instanceIds = client.getChildren().forPath(path);        } catch (KeeperException.NoNodeException e) {            instanceIds = Lists.newArrayList();        }    }    for (String id : instanceIds) {        ServiceInstance<T> instance = queryForInstance(name, id);        if (instance != null) {            builder.add(instance);        }    }    return builder.build();}
 int curator_f3568_0()
{    return services.size();}
private List<String> curator_f3569_0(String path, Watcher watcher, boolean recurse) throws Exception
{    List<String> instanceIds;    try {        instanceIds = client.getChildren().usingWatcher(watcher).forPath(path);    } catch (KeeperException.NoNodeException e) {        if (recurse) {            try {                client.create().creatingParentContainersIfNeeded().forPath(path);            } catch (KeeperException.NodeExistsException ignore) {                        }            instanceIds = getChildrenWatched(path, watcher, false);        } else {            throw e;        }    }    return instanceIds;}
 String curator_f3570_0(String name, String id)
{    return ZKPaths.makePath(pathForName(name), id);}
 ServiceInstance<T> curator_f3571_0(String id)
{    Entry<T> entry = services.get(id);    return (entry != null) ? entry.service : null;}
private void curator_f3572_0() throws Exception
{    for (final Entry<T> entry : services.values()) {        synchronized (entry) {            internalRegisterService(entry.service);        }    }}
private NodeCache curator_f3573_1(final ServiceInstance<T> instance)
{    if (!watchInstances) {        return null;    }    final NodeCache nodeCache = new NodeCache(client, pathForInstance(instance.getName(), instance.getId()));    try {        nodeCache.start(true);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        return null;    } catch (Exception e) {            }    NodeCacheListener listener = new NodeCacheListener() {        @Override        public void nodeChanged() throws Exception {            if (nodeCache.getCurrentData() != null) {                ServiceInstance<T> newInstance = serializer.deserialize(nodeCache.getCurrentData().getData());                Entry<T> entry = services.get(newInstance.getId());                if (entry != null) {                    synchronized (entry) {                        entry.service = newInstance;                    }                }            } else {                            }        }    };    nodeCache.getListenable().addListener(listener);    return nodeCache;}
public void curator_f3574_1() throws Exception
{    if (nodeCache.getCurrentData() != null) {        ServiceInstance<T> newInstance = serializer.deserialize(nodeCache.getCurrentData().getData());        Entry<T> entry = services.get(newInstance.getId());        if (entry != null) {            synchronized (entry) {                entry.service = newInstance;            }        }    } else {            }}
private void curator_f3575_0(final Entry<T> entry) throws Exception
{    if (entry != null) {        synchronized (entry) {            if (entry.cache != null) {                CloseableUtils.closeQuietly(entry.cache);                entry.cache = null;            }            String path = pathForInstance(entry.service.getName(), entry.service.getId());            try {                client.delete().guaranteed().forPath(path);            } catch (KeeperException.NoNodeException ignore) {                        }        }    }}
public ServiceProvider<T> curator_f3576_0()
{    return new ServiceProviderImpl<T>(discovery, serviceName, providerStrategy, threadFactory, filters, downInstancePolicy);}
public ServiceProviderBuilder<T> curator_f3577_0(String serviceName)
{    this.serviceName = serviceName;    return this;}
public ServiceProviderBuilder<T> curator_f3578_0(ProviderStrategy<T> providerStrategy)
{    this.providerStrategy = providerStrategy;    return this;}
public ServiceProviderBuilder<T> curator_f3579_0(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    return this;}
public ServiceProviderBuilder<T> curator_f3580_0(DownInstancePolicy downInstancePolicy)
{    this.downInstancePolicy = downInstancePolicy;    return this;}
public ServiceProviderBuilder<T> curator_f3581_0(InstanceFilter<T> filter)
{    filters.add(filter);    return this;}
public boolean curator_f3582_0(ServiceInstance<T> instance)
{    return instance.isEnabled();}
public void curator_f3583_0() throws Exception
{    cache.start();    discovery.providerOpened(this);}
public void curator_f3584_0() throws IOException
{    discovery.providerClosed(this);    cache.close();}
public Collection<ServiceInstance<T>> curator_f3585_0() throws Exception
{    return instanceProvider.getInstances();}
public ServiceInstance<T> curator_f3586_0() throws Exception
{    return providerStrategy.getInstance(instanceProvider);}
public void curator_f3587_0(ServiceInstance<T> instance)
{    downInstanceManager.add(instance);}
public long curator_f3588_0()
{    return timeoutMs;}
public int curator_f3589_0()
{    return errorThreshold;}
public static ServiceDiscoveryBuilder<T> curator_f3590_0(Class<T> payloadClass)
{    return new ServiceDiscoveryBuilder<T>(payloadClass);}
public ServiceDiscovery<T> curator_f3591_0()
{    if (serializer == null) {        serializer(new JsonInstanceSerializer<T>(payloadClass));    }    return new ServiceDiscoveryImpl<T>(client, basePath, serializer, thisInstance, watchInstances);}
public ServiceDiscoveryBuilder<T> curator_f3592_0(CuratorFramework client)
{    this.client = client;    return this;}
public ServiceDiscoveryBuilder<T> curator_f3593_0(String basePath)
{    this.basePath = basePath;    return this;}
public ServiceDiscoveryBuilder<T> curator_f3594_0(InstanceSerializer<T> serializer)
{    this.serializer = serializer;    return this;}
public ServiceDiscoveryBuilder<T> curator_f3595_0(ServiceInstance<T> thisInstance)
{    this.thisInstance = thisInstance;    return this;}
public ServiceDiscoveryBuilder<T> curator_f3596_0(boolean watchInstances)
{    this.watchInstances = watchInstances;    return this;}
public static ServiceInstanceBuilder<T> curator_f3597_0() throws Exception
{    String address = null;    Collection<InetAddress> ips = ServiceInstanceBuilder.getAllLocalIPs();    if (ips.size() > 0) {                address = ips.iterator().next().getHostAddress();    }    String id = UUID.randomUUID().toString();    return new ServiceInstanceBuilder<T>().address(address).id(id).registrationTimeUTC(System.currentTimeMillis());}
public String curator_f3598_0()
{    return name;}
public String curator_f3599_0()
{    return id;}
public String curator_f3600_0()
{    return address;}
public Integer curator_f3601_0()
{    return port;}
public Integer curator_f3602_0()
{    return sslPort;}
public T curator_f3603_0()
{    return payload;}
public long curator_f3604_0()
{    return registrationTimeUTC;}
public ServiceType curator_f3605_0()
{    return serviceType;}
public UriSpec curator_f3606_0()
{    return uriSpec;}
public boolean curator_f3607_0()
{    return enabled;}
public String curator_f3608_0()
{    return buildUriSpec(Maps.<String, Object>newHashMap());}
public String curator_f3609_0(Map<String, Object> variables)
{    return (uriSpec != null) ? uriSpec.build(this, variables) : "";}
public boolean curator_f3610_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ServiceInstance that = (ServiceInstance) o;    if (registrationTimeUTC != that.registrationTimeUTC) {        return false;    }    if (address != null ? !address.equals(that.address) : that.address != null) {        return false;    }    if (id != null ? !id.equals(that.id) : that.id != null) {        return false;    }    if (name != null ? !name.equals(that.name) : that.name != null) {        return false;    }    if (payload != null ? !payload.equals(that.payload) : that.payload != null) {        return false;    }    if (port != null ? !port.equals(that.port) : that.port != null) {        return false;    }    if (serviceType != that.serviceType) {        return false;    }    if (sslPort != null ? !sslPort.equals(that.sslPort) : that.sslPort != null) {        return false;    }    if (uriSpec != null ? !uriSpec.equals(that.uriSpec) : that.uriSpec != null) {        return false;    }    if (enabled != that.enabled) {        return false;    }    return true;}
public int curator_f3611_0()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (id != null ? id.hashCode() : 0);    result = 31 * result + (address != null ? address.hashCode() : 0);    result = 31 * result + (port != null ? port.hashCode() : 0);    result = 31 * result + (sslPort != null ? sslPort.hashCode() : 0);    result = 31 * result + (payload != null ? payload.hashCode() : 0);    result = 31 * result + (int) (registrationTimeUTC ^ (registrationTimeUTC >>> 32));    result = 31 * result + (serviceType != null ? serviceType.hashCode() : 0);    result = 31 * result + (uriSpec != null ? uriSpec.hashCode() : 0);    result = 31 * result + (enabled ? 1 : 0);    return result;}
public String curator_f3612_0()
{    return "ServiceInstance{" + "name='" + name + '\'' + ", id='" + id + '\'' + ", address='" + address + '\'' + ", port=" + port + ", sslPort=" + sslPort + ", payload=" + payload + ", registrationTimeUTC=" + registrationTimeUTC + ", serviceType=" + serviceType + ", uriSpec=" + uriSpec + ", enabled=" + enabled + '}';}
public boolean curator_f3613_0(NetworkInterface nif, InetAddress adr) throws SocketException
{    return (adr != null) && !adr.isLoopbackAddress() && (nif.isPointToPoint() || !adr.isLinkLocalAddress());}
public static void curator_f3614_0(LocalIpFilter newLocalIpFilter)
{    localIpFilter.set(newLocalIpFilter);}
public static LocalIpFilter curator_f3615_0()
{    return localIpFilter.get();}
public ServiceInstance<T> curator_f3616_0()
{    return new ServiceInstance<T>(name, id, address, port, sslPort, payload, registrationTimeUTC, serviceType, uriSpec, enabled);}
public ServiceInstanceBuilder<T> curator_f3617_0(String name)
{    this.name = name;    return this;}
public ServiceInstanceBuilder<T> curator_f3618_0(String address)
{    this.address = address;    return this;}
public ServiceInstanceBuilder<T> curator_f3619_0(String id)
{    this.id = id;    return this;}
public ServiceInstanceBuilder<T> curator_f3620_0(int port)
{    this.port = port;    return this;}
public ServiceInstanceBuilder<T> curator_f3621_0(int port)
{    this.sslPort = port;    return this;}
public ServiceInstanceBuilder<T> curator_f3622_0(T payload)
{    this.payload = payload;    return this;}
public ServiceInstanceBuilder<T> curator_f3623_0(ServiceType serviceType)
{    this.serviceType = serviceType;    return this;}
public ServiceInstanceBuilder<T> curator_f3624_0(long registrationTimeUTC)
{    this.registrationTimeUTC = registrationTimeUTC;    return this;}
public ServiceInstanceBuilder<T> curator_f3625_0(UriSpec uriSpec)
{    this.uriSpec = uriSpec;    return this;}
public ServiceInstanceBuilder<T> curator_f3626_0(boolean enabled)
{    this.enabled = enabled;    return this;}
public static Collection<InetAddress> curator_f3627_0() throws SocketException
{    List<InetAddress> listAdr = Lists.newArrayList();    Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();    if (nifs == null)        return listAdr;    while (nifs.hasMoreElements()) {        NetworkInterface nif = nifs.nextElement();                Enumeration<InetAddress> adrs = nif.getInetAddresses();        while (adrs.hasMoreElements()) {            InetAddress adr = adrs.nextElement();            if (localIpFilter.get().use(nif, adr)) {                listAdr.add(adr);            }        }    }    return listAdr;}
public boolean curator_f3628_0()
{    return this == DYNAMIC || this == DYNAMIC_SEQUENTIAL;}
public ServiceInstance<T> curator_f3629_0(InstanceProvider<T> instanceProvider) throws Exception
{    List<ServiceInstance<T>> instances = instanceProvider.getInstances();    if (instances.size() == 0) {        return null;    }    int thisIndex = random.nextInt(instances.size());    return instances.get(thisIndex);}
public ServiceInstance<T> curator_f3630_0(InstanceProvider<T> instanceProvider) throws Exception
{    List<ServiceInstance<T>> instances = instanceProvider.getInstances();    if (instances.size() == 0) {        return null;    }    int thisIndex = Math.abs(index.getAndIncrement());    return instances.get(thisIndex % instances.size());}
public ServiceInstance<T> curator_f3631_0(InstanceProvider<T> instanceProvider) throws Exception
{    final List<ServiceInstance<T>> instances = instanceProvider.getInstances();    {        ServiceInstance<T> localOurInstance = ourInstance.get();        if (!instances.contains(localOurInstance)) {            ourInstance.compareAndSet(localOurInstance, null);        }    }    if (ourInstance.get() == null) {        ServiceInstance<T> instance = masterStrategy.getInstance(new InstanceProvider<T>() {            @Override            public List<ServiceInstance<T>> getInstances() throws Exception {                return instances;            }        });        if (ourInstance.compareAndSet(null, instance)) {            instanceNumber.incrementAndGet();        }    }    return ourInstance.get();}
public List<ServiceInstance<T>> curator_f3632_0() throws Exception
{    return instances;}
public int curator_f3633_0()
{    return instanceNumber.get();}
public String curator_f3634_0()
{    return value;}
public boolean curator_f3635_0()
{    return variable;}
public boolean curator_f3636_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Part part = (Part) o;    if (variable != part.variable) {        return false;    }    if (!value.equals(part.value)) {        return false;    }    return true;}
public int curator_f3637_0()
{    int result = value.hashCode();    result = 31 * result + (variable ? 1 : 0);    return result;}
public String curator_f3638_0()
{    return build(null, Maps.<String, Object>newHashMap());}
public String curator_f3639_0(ServiceInstance<?> serviceInstance)
{    return build(serviceInstance, Maps.<String, Object>newHashMap());}
public String curator_f3640_0(Map<String, Object> variables)
{    return build(null, variables);}
public String curator_f3641_1(ServiceInstance<?> serviceInstance, Map<String, Object> variables)
{    Map<String, Object> localVariables = Maps.newHashMap();    localVariables.put(FIELD_OPEN_BRACE, "{");    localVariables.put(FIELD_CLOSE_BRACE, "}");    localVariables.put(FIELD_SCHEME, "http");    if (serviceInstance != null) {        localVariables.put(FIELD_NAME, nullCheck(serviceInstance.getName()));        localVariables.put(FIELD_ID, nullCheck(serviceInstance.getId()));        localVariables.put(FIELD_ADDRESS, nullCheck(serviceInstance.getAddress()));        localVariables.put(FIELD_PORT, nullCheck(serviceInstance.getPort()));        localVariables.put(FIELD_SSL_PORT, nullCheck(serviceInstance.getSslPort()));        localVariables.put(FIELD_REGISTRATION_TIME_UTC, nullCheck(serviceInstance.getRegistrationTimeUTC()));        localVariables.put(FIELD_SERVICE_TYPE, (serviceInstance.getServiceType() != null) ? serviceInstance.getServiceType().name().toLowerCase() : "");        if (serviceInstance.getSslPort() != null) {            localVariables.put(FIELD_SCHEME, "https");        }    }    localVariables.putAll(variables);    StringBuilder str = new StringBuilder();    for (Part p : parts) {        if (p.isVariable()) {            Object value = localVariables.get(p.getValue());            if (value == null) {                            } else {                str.append(value);            }        } else {            str.append(p.getValue());        }    }    return str.toString();}
public Iterator<Part> curator_f3642_0()
{    return Iterators.unmodifiableIterator(parts.iterator());}
public List<Part> curator_f3643_0()
{    return ImmutableList.copyOf(parts);}
public void curator_f3644_0(Part part)
{    parts.add(part);}
public void curator_f3645_0(Part part)
{    parts.remove(part);}
public boolean curator_f3646_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    UriSpec spec = (UriSpec) o;    if (!parts.equals(spec.parts)) {        return false;    }    return true;}
public int curator_f3647_0()
{    return parts.hashCode();}
private Object curator_f3648_0(Object o)
{    return (o != null) ? o : "";}
public void curator_f3649_0() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugDownInstancePolicy);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
public void curator_f3650_0() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugMultiDownInstancePolicy);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
public void curator_f3651_0() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugDownInstancePolicy);    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    Thread.sleep(debugDownInstancePolicy.getTimeoutMs());    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
public void curator_f3652_0() throws Exception
{    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class, true, true);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = new ServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    OldServiceInstance<TestJsonInstanceSerializer.Payload> oldInstance = new OldServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"));    ObjectMapper mapper = new ObjectMapper();    byte[] oldBytes = mapper.writeValueAsBytes(oldInstance);    Assert.assertEquals(bytes, oldBytes, String.format("%s vs %s", new String(bytes), new String(oldBytes)));}
public void curator_f3653_0() throws Exception
{    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class, true, true);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = new ServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    instance = serializer.deserialize(bytes);        Assert.assertTrue(instance.isEnabled());    ObjectMapper mapper = new ObjectMapper();    JavaType type = mapper.getTypeFactory().constructType(OldServiceInstance.class);    OldServiceInstance rawServiceInstance = mapper.readValue(bytes, type);        TestJsonInstanceSerializer.Payload.class.cast(rawServiceInstance.getPayload());        OldServiceInstance<TestJsonInstanceSerializer.Payload> check = (OldServiceInstance<TestJsonInstanceSerializer.Payload>) rawServiceInstance;    Assert.assertEquals(check.getName(), instance.getName());    Assert.assertEquals(check.getId(), instance.getId());    Assert.assertEquals(check.getAddress(), instance.getAddress());    Assert.assertEquals(check.getPort(), instance.getPort());    Assert.assertEquals(check.getSslPort(), instance.getSslPort());    Assert.assertEquals(check.getPayload(), instance.getPayload());    Assert.assertEquals(check.getRegistrationTimeUTC(), instance.getRegistrationTimeUTC());    Assert.assertEquals(check.getServiceType(), instance.getServiceType());    Assert.assertEquals(check.getUriSpec(), instance.getUriSpec());}
public void curator_f3654_0() throws Exception
{    OldServiceInstance<TestJsonInstanceSerializer.Payload> oldInstance = new OldServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"));    ObjectMapper mapper = new ObjectMapper();    byte[] oldJson = mapper.writeValueAsBytes(oldInstance);    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = serializer.deserialize(oldJson);    Assert.assertEquals(oldInstance.getName(), instance.getName());    Assert.assertEquals(oldInstance.getId(), instance.getId());    Assert.assertEquals(oldInstance.getAddress(), instance.getAddress());    Assert.assertEquals(oldInstance.getPort(), instance.getPort());    Assert.assertEquals(oldInstance.getSslPort(), instance.getSslPort());    Assert.assertEquals(oldInstance.getPayload(), instance.getPayload());    Assert.assertEquals(oldInstance.getRegistrationTimeUTC(), instance.getRegistrationTimeUTC());    Assert.assertEquals(oldInstance.getServiceType(), instance.getServiceType());    Assert.assertEquals(oldInstance.getUriSpec(), instance.getUriSpec());    Assert.assertTrue(instance.isEnabled());}
public void curator_f3655_0() throws Exception
{    TestNewServiceInstance<String> newInstance = new TestNewServiceInstance<String>("name", "id", "address", 10, 20, "hey", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false, "what", 10101L, new Date(), new URI("http://hey"));    byte[] newInstanceBytes = new ObjectMapper().writeValueAsBytes(newInstance);    JsonInstanceSerializer<String> serializer = new JsonInstanceSerializer<String>(String.class);    ServiceInstance<String> instance = serializer.deserialize(newInstanceBytes);    Assert.assertEquals(instance.getName(), "name");    Assert.assertEquals(instance.getPayload(), "hey");    Assert.assertEquals(instance.isEnabled(), false);}
public String curator_f3656_0()
{    return name;}
public String curator_f3657_0()
{    return id;}
public String curator_f3658_0()
{    return address;}
public Integer curator_f3659_0()
{    return port;}
public Integer curator_f3660_0()
{    return sslPort;}
public T curator_f3661_0()
{    return payload;}
public long curator_f3662_0()
{    return registrationTimeUTC;}
public ServiceType curator_f3663_0()
{    return serviceType;}
public UriSpec curator_f3664_0()
{    return uriSpec;}
public boolean curator_f3665_0()
{    return enabled;}
public String curator_f3666_0()
{    return new1;}
public Long curator_f3667_0()
{    return new2;}
public Date curator_f3668_0()
{    return new3;}
public URI curator_f3669_0()
{    return new4;}
public void curator_f3670_0() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        CountDownLatch cacheStartLatch = new CountDownLatch(1);        CountDownLatch cacheWaitLatch = new CountDownLatch(1);        final ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);                ((ServiceCacheImpl) cache).debugStartLatch = cacheStartLatch;                ((ServiceCacheImpl) cache).debugStartWaitLatch = cacheWaitLatch;        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("test").name("test").port(10064).build();        discovery.registerService(instance1);        CloseableExecutorService closeableExecutorService = new CloseableExecutorService(Executors.newSingleThreadExecutor());        closeables.add(closeableExecutorService);        final CountDownLatch startCompletedLatch = new CountDownLatch(1);        Runnable proc = new Runnable() {            @Override            public void run() {                try {                    cache.start();                    startCompletedLatch.countDown();                } catch (Exception e) {                    LoggerFactory.getLogger(getClass()).error("Start failed", e);                    throw new RuntimeException(e);                }            }        };        closeableExecutorService.submit(proc);                Assert.assertTrue(timing.awaitLatch(cacheStartLatch));        final CountDownLatch cacheChangedLatch = new CountDownLatch(1);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                cacheChangedLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        cache.addListener(listener);        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("test").name("test").port(10065).build();                discovery.registerService(instance2);        Assert.assertTrue(timing.awaitLatch(cacheChangedLatch));        cacheWaitLatch.countDown();        Assert.assertTrue(timing.awaitLatch(startCompletedLatch));    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3671_0()
{    try {        cache.start();        startCompletedLatch.countDown();    } catch (Exception e) {        LoggerFactory.getLogger(getClass()).error("Start failed", e);        throw new RuntimeException(e);    }}
public void curator_f3672_0()
{    cacheChangedLatch.countDown();}
public void curator_f3673_0(CuratorFramework client, ConnectionState newState)
{}
public int curator_f3674_0(ServiceInstance<Void> o1, ServiceInstance<Void> o2)
{    return o1.getId().compareTo(o2.getId());}
public void curator_f3675_0() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("thing").name("test").port(10065).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance1, false) {            @Override            protected void internalRegisterService(ServiceInstance<String> service) throws Exception {                super.internalRegisterService(service);                semaphore.release();            }        };        discovery.start();        discovery.registerService(instance2);        timing.acquireSemaphore(semaphore, 2);        Assert.assertEquals(discovery.queryForInstances("test").size(), 2);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        server.stop();        server.restart();        timing.acquireSemaphore(semaphore, 2);        Assert.assertEquals(discovery.queryForInstances("test").size(), 2);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
protected void curator_f3676_0(ServiceInstance<String> service) throws Exception
{    super.internalRegisterService(service);    semaphore.release();}
public void curator_f3677_0() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance, false) {            @Override            protected void internalRegisterService(ServiceInstance<String> service) throws Exception {                super.internalRegisterService(service);                semaphore.release();            }        };        discovery.start();        timing.acquireSemaphore(semaphore);        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        server.stop();        server.restart();        timing.acquireSemaphore(semaphore);        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
protected void curator_f3678_0(ServiceInstance<String> service) throws Exception
{    super.internalRegisterService(service);    semaphore.release();}
public void curator_f3679_0() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance, false);        discovery.start();        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Thread.sleep(timing.multiple(1.5).session());        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
public void curator_f3680_0() throws Exception
{    final String SERVICE_ONE = "one";    final String SERVICE_TWO = "two";    CuratorFramework client = null;    ServiceDiscovery<Void> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<Void> s1_i1 = ServiceInstance.<Void>builder().name(SERVICE_ONE).build();        ServiceInstance<Void> s1_i2 = ServiceInstance.<Void>builder().name(SERVICE_ONE).build();        ServiceInstance<Void> s2_i1 = ServiceInstance.<Void>builder().name(SERVICE_TWO).build();        ServiceInstance<Void> s2_i2 = ServiceInstance.<Void>builder().name(SERVICE_TWO).build();        discovery = ServiceDiscoveryBuilder.builder(Void.class).client(client).basePath("/test").build();        discovery.start();        discovery.registerService(s1_i1);        discovery.registerService(s1_i2);        discovery.registerService(s2_i1);        discovery.registerService(s2_i2);        Assert.assertEquals(Sets.newHashSet(discovery.queryForNames()), Sets.newHashSet(SERVICE_ONE, SERVICE_TWO));        List<ServiceInstance<Void>> list = Lists.newArrayList();        list.add(s1_i1);        list.add(s1_i2);        Collections.sort(list, comparator);        List<ServiceInstance<Void>> queriedInstances = Lists.newArrayList(discovery.queryForInstances(SERVICE_ONE));        Collections.sort(queriedInstances, comparator);        Assert.assertEquals(queriedInstances, list, String.format("Not equal l: %s - d: %s", list, queriedInstances));        list.clear();        list.add(s2_i1);        list.add(s2_i2);        Collections.sort(list, comparator);        queriedInstances = Lists.newArrayList(discovery.queryForInstances(SERVICE_TWO));        Collections.sort(queriedInstances, comparator);        Assert.assertEquals(queriedInstances, list, String.format("Not equal 2: %s - d: %s", list, queriedInstances));    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
public void curator_f3681_0() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        Assert.assertEquals(discovery.queryForNames(), Collections.singletonList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
public void curator_f3682_0() throws Exception
{    Timing timing = new Timing();    server.stop();    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        server.restart();        timing.sleepABit();        Assert.assertEquals(discovery.queryForNames(), Collections.singletonList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
public void curator_f3683_0() throws Exception
{    final String name = "name";    final CountDownLatch restartLatch = new CountDownLatch(1);    InstanceSerializer<String> slowSerializer = new JsonInstanceSerializer<String>(String.class) {        private boolean first = true;        @Override        public byte[] serialize(ServiceInstance<String> instance) throws Exception {            if (first) {                System.out.println("Serializer first registration.");                first = false;            } else {                System.out.println("Waiting for reconnect to finish.");                                                restartLatch.await();            }            return super.serialize(instance);        }    };    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name(name).port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).serializer(slowSerializer).watchInstances(true).build();        discovery.start();        Assert.assertFalse(discovery.queryForInstances(name).isEmpty(), "Service should start registered.");        server.stop();        server.restart();        discovery.unregisterService(instance);        restartLatch.countDown();                new Timing().sleepABit();        Assert.assertTrue(discovery.queryForInstances(name).isEmpty(), "Service should have unregistered.");    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
public byte[] curator_f3684_0(ServiceInstance<String> instance) throws Exception
{    if (first) {        System.out.println("Serializer first registration.");        first = false;    } else {        System.out.println("Waiting for reconnect to finish.");                        restartLatch.await();    }    return super.serialize(instance);}
public void curator_f3685_0() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        discovery.unregisterService(instance);        Assert.assertEquals(((ServiceDiscoveryImpl) discovery).debugServicesQty(), 0);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
public void curator_f3686_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    ServiceDiscoveryBuilder<Object> builder = ServiceDiscoveryBuilder.builder(Object.class).client(client);    ServiceDiscoveryImpl<?> discovery = (ServiceDiscoveryImpl<?>) builder.basePath("/path").build();    Assert.assertNotNull(discovery.getSerializer(), "default serializer not set");    Assert.assertTrue(discovery.getSerializer() instanceof JsonInstanceSerializer, "default serializer not JSON");}
public void curator_f3687_0() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    ServiceDiscoveryBuilder<Object> builder = ServiceDiscoveryBuilder.builder(Object.class).client(client);    builder.serializer(new InstanceSerializer<Object>() {        @Override        public byte[] serialize(ServiceInstance<Object> instance) {            return null;        }        @Override        public ServiceInstance<Object> deserialize(byte[] bytes) {            return null;        }    });    ServiceDiscoveryImpl<?> discovery = (ServiceDiscoveryImpl<?>) builder.basePath("/path").build();    Assert.assertNotNull(discovery.getSerializer(), "default serializer not set");    Assert.assertFalse(discovery.getSerializer() instanceof JsonInstanceSerializer, "set serializer is JSON");}
public byte[] curator_f3688_0(ServiceInstance<Object> instance)
{    return null;}
public ServiceInstance<Object> curator_f3689_0(byte[] bytes)
{    return null;}
public void curator_f3690_0() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> provider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(provider);        provider.start();        Assert.assertEquals(provider.getInstance(), instance);        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(provider.getAllInstances(), list);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3691_0() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).enabled(false).build();        InstanceSerializer<String> serializer = new JsonInstanceSerializer<>(String.class, false);        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).serializer(serializer).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> provider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(provider);        provider.start();        Assert.assertEquals(provider.getInstance(), null);        Assert.assertTrue(provider.getAllInstances().isEmpty(), "Disabled instance still appears available via service provider");    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3692_0() throws Exception
{    Timing timing = new Timing();    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).watchInstances(true).build();        closeables.add(discovery);        discovery.start();        Assert.assertEquals(discovery.queryForNames(), Arrays.asList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);        ServiceDiscoveryImpl<String> discoveryImpl = (ServiceDiscoveryImpl<String>) discovery;        ServiceInstance<String> changedInstance = ServiceInstance.<String>builder().id(instance.getId()).address(instance.getAddress()).payload("different").name(instance.getName()).port(instance.getPort()).build();        String path = discoveryImpl.pathForInstance("test", instance.getId());        byte[] bytes = discoveryImpl.getSerializer().serialize(changedInstance);        client.setData().forPath(path, bytes);        timing.sleepABit();        ServiceInstance<String> registeredService = discoveryImpl.getRegisteredService(instance.getId());        Assert.assertNotNull(registeredService);        Assert.assertEquals(registeredService.getPayload(), "different");    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public static void curator_f3693_0(String[] args) throws Exception
{    TestingServer testingServer = new TestingServer();    final CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(testingServer.getConnectString(), new RetryOneTime(1));    try {        curatorFramework.start();        doWork(curatorFramework);        System.gc();        System.out.println("Done - get dump");        Thread.currentThread().join();    } finally {        CloseableUtils.closeQuietly(curatorFramework);        CloseableUtils.closeQuietly(testingServer);    }}
private static void curator_f3694_0(CuratorFramework curatorFramework) throws Exception
{    ServiceInstance<Void> thisInstance = ServiceInstance.<Void>builder().name("myservice").build();    final ServiceDiscovery<Void> serviceDiscovery = ServiceDiscoveryBuilder.builder(Void.class).client(curatorFramework.usingNamespace("dev")).basePath("/instances").thisInstance(thisInstance).build();    serviceDiscovery.start();    for (int i = 0; i < 100000; i++) {        final ServiceProvider<Void> s = serviceProvider(serviceDiscovery, "myservice");        s.start();        try {            s.getInstance().buildUriSpec();        } finally {            s.close();        }    }}
private static ServiceProvider<Void> curator_f3695_0(ServiceDiscovery<Void> serviceDiscovery, String name) throws Exception
{    return serviceDiscovery.serviceProviderBuilder().serviceName(name).providerStrategy(new RandomStrategy<Void>()).build();}
public void curator_f3696_0() throws Exception
{    JsonInstanceSerializer<String> serializer = new JsonInstanceSerializer<String>(String.class);    ServiceInstance<String> instance = new ServiceInstance<String>("name", "id", "address", 10, 20, "payload", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<String> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
public void curator_f3697_0() throws Exception
{    JsonInstanceSerializer<String> stringSerializer = new JsonInstanceSerializer<String>(String.class);    JsonInstanceSerializer<Double> doubleSerializer = new JsonInstanceSerializer<Double>(Double.class);    byte[] bytes = stringSerializer.serialize(new ServiceInstance<String>("name", "id", "address", 10, 20, "payload", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true));    try {        doubleSerializer.deserialize(bytes);        Assert.fail();    } catch (ClassCastException e) {        }}
public void curator_f3698_0() throws Exception
{    JsonInstanceSerializer<Void> serializer = new JsonInstanceSerializer<Void>(Void.class);    ServiceInstance<Void> instance = new ServiceInstance<Void>("name", "id", "address", 10, 20, null, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Void> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
public void curator_f3699_0() throws Exception
{    JsonInstanceSerializer<Void> serializer = new JsonInstanceSerializer<Void>(Void.class);    byte[] bytes = "{}".getBytes("utf-8");    ServiceInstance<Void> instance = serializer.deserialize(bytes);    Assert.assertTrue(instance.isEnabled(), "Instance that has no 'enabled' should be assumed enabled");}
public void curator_f3700_0() throws Exception
{    JsonInstanceSerializer<Object> serializer = new JsonInstanceSerializer<Object>(Object.class, false);    List<String> payload = new ArrayList<String>();    payload.add("Test value 1");    payload.add("Test value 2");    ServiceInstance<Object> instance = new ServiceInstance<Object>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Object> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
public void curator_f3701_0() throws Exception
{    JsonInstanceSerializer<Object> serializer = new JsonInstanceSerializer<Object>(Object.class, false);    Map<String, String> payload = new HashMap<String, String>();    payload.put("1", "Test value 1");    payload.put("2", "Test value 2");    ServiceInstance<Object> instance = new ServiceInstance<Object>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Object> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
public void curator_f3702_0() throws Exception
{    JsonInstanceSerializer<Payload> serializer = new JsonInstanceSerializer<Payload>(Payload.class);    Payload payload = new Payload();    payload.setVal("Test value");    ServiceInstance<Payload> instance = new ServiceInstance<Payload>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Payload> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
public String curator_f3703_0()
{    return val;}
public void curator_f3704_0(String val)
{    this.val = val;}
public boolean curator_f3705_0(Object other)
{    if (other == null || !(other instanceof Payload))        return false;    String otherVal = ((Payload) other).getVal();    if (val == null)        return val == otherVal;    return val.equals(otherVal);}
public void curator_f3706_0() throws SocketException
{    LocalIpFilter localIpFilter = ServiceInstanceBuilder.getLocalIpFilter();    try {        ServiceInstanceBuilder.setLocalIpFilter(new LocalIpFilter() {            @Override            public boolean use(NetworkInterface networkInterface, InetAddress address) throws SocketException {                return false;            }        });        List<InetAddress> allLocalIPs = Lists.newArrayList(ServiceInstanceBuilder.getAllLocalIPs());        Assert.assertEquals(allLocalIPs.size(), 0);    } finally {        ServiceInstanceBuilder.setLocalIpFilter(localIpFilter);    }    List<InetAddress> allLocalIPs = Lists.newArrayList(ServiceInstanceBuilder.getAllLocalIPs());    Assert.assertTrue(allLocalIPs.size() > 0);}
public boolean curator_f3707_0(NetworkInterface networkInterface, InetAddress address) throws SocketException
{    return false;}
public void curator_f3708_0() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        final CountDownLatch latch = new CountDownLatch(3);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        cache.start();        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("test").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("test").name("test").port(10065).build();        ServiceInstance<String> instance3 = ServiceInstance.<String>builder().payload("test").name("test").port(10066).build();        discovery.registerService(instance1);        discovery.registerService(instance2);        discovery.registerService(instance3);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        ServiceCache<String> cache2 = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache2);        cache2.start();        Assert.assertEquals(cache2.getInstances().size(), 3);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3709_0()
{    latch.countDown();}
public void curator_f3710_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f3711_0() throws Exception
{    Timing timing = new Timing();    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> serviceProvider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(serviceProvider);        serviceProvider.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery.registerService(instance);        int count = 0;        ServiceInstance<String> foundInstance = null;        while (foundInstance == null) {            Assert.assertTrue(count++ < 5);            foundInstance = serviceProvider.getInstance();            timing.sleepABit();        }        Assert.assertEquals(foundInstance, instance);        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().address("foo").payload("thing").name("test").port(10064).build();        discovery.registerService(instance2);        timing.sleepABit();        Collection<ServiceInstance<String>> allInstances = serviceProvider.getAllInstances();        Assert.assertEquals(allInstances.size(), 2);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3712_0() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        final CountDownLatch latch = new CountDownLatch(1);        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        cache.start();        instance = ServiceInstance.<String>builder().payload("changed").name("test").port(10064).id(instance.getId()).build();        discovery.updateService(instance);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertEquals(cache.getInstances().size(), 1);        Assert.assertEquals(cache.getInstances().get(0).getPayload(), instance.getPayload());    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3713_0()
{    latch.countDown();}
public void curator_f3714_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f3715_0() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        cache.start();        final Semaphore semaphore = new Semaphore(0);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("thing").name("test").port(10065).build();        discovery.registerService(instance1);        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));        discovery.registerService(instance2);        Assert.assertTrue(semaphore.tryAcquire(3, TimeUnit.SECONDS));        ServiceInstance<String> instance3 = ServiceInstance.<String>builder().payload("thing").name("another").port(10064).build();        discovery.registerService(instance3);                Assert.assertFalse(semaphore.tryAcquire(3, TimeUnit.SECONDS));    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3716_0()
{    semaphore.release();}
public void curator_f3717_0(CuratorFramework client, ConnectionState newState)
{}
public void curator_f3718_0() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ExecuteCalledWatchingExecutorService exec = new ExecuteCalledWatchingExecutorService(Executors.newSingleThreadExecutor());        Assert.assertFalse(exec.isExecuteCalled());        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").executorService(exec).build();        closeables.add(cache);        cache.start();        final Semaphore semaphore = new Semaphore(0);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery.registerService(instance1);        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));        Assert.assertTrue(exec.isExecuteCalled());    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
public void curator_f3719_0()
{    semaphore.release();}
public void curator_f3720_0(CuratorFramework client, ConnectionState newState)
{}
public List<ServiceInstance<Void>> curator_f3721_0() throws Exception
{    return instances;}
public void curator_f3722_0() throws Exception
{    final int QTY = 10;    final int ITERATIONS = 1000;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY, 0);    ProviderStrategy<Void> strategy = new RandomStrategy<Void>();    long[] counts = new long[QTY];    for (int i = 0; i < ITERATIONS; ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        int id = Integer.parseInt(instance.getId());        counts[id]++;    }    SummaryStatistics statistic = new SummaryStatistics();    for (int i = 0; i < QTY; ++i) {        statistic.addValue(counts[i]);    }        Assert.assertTrue(statistic.getStandardDeviation() <= (QTY * 2), "" + statistic.getStandardDeviation());}
public void curator_f3723_0() throws Exception
{    final int QTY = 10;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY);    ProviderStrategy<Void> strategy = new RoundRobinStrategy<Void>();    for (int i = 0; i < QTY; ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        Assert.assertEquals(instance.getId(), Integer.toString(i));    }    for (int i = 0; i < (1234 * QTY); ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        Assert.assertEquals(instance.getId(), Integer.toString(i % QTY));    }}
public void curator_f3724_0() throws Exception
{    final int QTY = 10;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY);    StickyStrategy<Void> strategy = new StickyStrategy<Void>(new RandomStrategy<Void>());    ServiceInstance<Void> theInstance = strategy.getInstance(instanceProvider);    int instanceNumber = strategy.getInstanceNumber();    for (int i = 0; i < 1000; ++i) {        Assert.assertEquals(strategy.getInstance(instanceProvider), theInstance);    }        instanceProvider = new TestInstanceProvider(QTY, QTY);    Assert.assertFalse(strategy.getInstance(instanceProvider).equals(theInstance));    Assert.assertFalse(instanceNumber == strategy.getInstanceNumber());    theInstance = strategy.getInstance(instanceProvider);    for (int i = 0; i < 1000; ++i) {        Assert.assertEquals(strategy.getInstance(instanceProvider), theInstance);    }}
public void curator_f3725_0()
{    UriSpec spec = new UriSpec("{scheme}://foo.com");    ServiceInstanceBuilder<Void> builder = new ServiceInstanceBuilder<Void>();    builder.id("x");    builder.name("foo");    builder.port(5);    ServiceInstance<Void> instance = builder.build();    Assert.assertEquals(spec.build(instance), "http://foo.com");    builder.sslPort(5);    instance = builder.build();    Assert.assertEquals(spec.build(instance), "https://foo.com");}
public void curator_f3726_0()
{    ServiceInstanceBuilder<Void> builder = new ServiceInstanceBuilder<Void>();    builder.address("1.2.3.4");    builder.name("foo");    builder.id("bar");    builder.port(5);    builder.sslPort(6);    builder.registrationTimeUTC(789);    builder.serviceType(ServiceType.PERMANENT);    ServiceInstance<Void> instance = builder.build();    UriSpec spec = new UriSpec("{scheme}://{address}:{port}:{ssl-port}/{name}/{id}/{registration-time-utc}/{service-type}");    Map<String, Object> m = Maps.newHashMap();    m.put("scheme", "test");    Assert.assertEquals(spec.build(instance, m), "test://1.2.3.4:5:6/foo/bar/789/permanent");}
public void curator_f3727_0()
{    UriSpec spec = new UriSpec("{one}two-three-{[}four{]}-five{six}");    Iterator<UriSpec.Part> iterator = spec.iterator();    checkPart(iterator.next(), "one", true);    checkPart(iterator.next(), "two-three-", false);    checkPart(iterator.next(), "[", true);    checkPart(iterator.next(), "four", false);    checkPart(iterator.next(), "]", true);    checkPart(iterator.next(), "-five", false);    checkPart(iterator.next(), "six", true);    Map<String, Object> m = Maps.newHashMap();    m.put("one", 1);    m.put("six", 6);    Assert.assertEquals(spec.build(m), "1two-three-{four}-five6");}
public void curator_f3728_0()
{    UriSpec spec = new UriSpec("{one}{two}three-four-five{six}seven{eight}");    Iterator<UriSpec.Part> iterator = spec.iterator();    checkPart(iterator.next(), "one", true);    checkPart(iterator.next(), "two", true);    checkPart(iterator.next(), "three-four-five", false);    checkPart(iterator.next(), "six", true);    checkPart(iterator.next(), "seven", false);    checkPart(iterator.next(), "eight", true);}
private void curator_f3729_0(UriSpec.Part p, String value, boolean isVariable)
{    Assert.assertEquals(p.getValue(), value);    Assert.assertEquals(p.isVariable(), isVariable);}
public ProviderStrategy<T> curator_f3730_0()
{    return providerStrategy;}
public int curator_f3731_0()
{    return instanceRefreshMs;}
public ServiceDiscovery<T> curator_f3732_0()
{    return serviceDiscovery;}
public void curator_f3733_0(ObjectNode node, String fieldName, T payload) throws Exception
{    if (payload == null) {                payload = (T) payloadType.getRawType().newInstance();    }    node.putPOJO(fieldName, payload);}
public T curator_f3734_0(JsonNode node) throws Exception
{    T payload;    ObjectMapper mapper = new ObjectMapper();        payload = (T) mapper.readValue(node.toString(), payloadType.getRawType());    return payload;}
public DiscoveryContext<T> curator_f3735_0(Class<?> type)
{    return this;}
public ProviderStrategy<Integer> curator_f3736_0()
{    return providerStrategy;}
public int curator_f3737_0()
{    return instanceRefreshMs;}
public ServiceDiscovery<Integer> curator_f3738_0()
{    return serviceDiscovery;}
public void curator_f3739_0(ObjectNode node, String fieldName, Integer payload) throws Exception
{    if (payload != null) {        node.put(fieldName, payload.toString());    }}
public Integer curator_f3740_0(JsonNode node) throws Exception
{    if (node != null) {        return Integer.parseInt(node.asText());    }    return null;}
public DiscoveryContext<Integer> curator_f3741_0(Class<?> type)
{    return this;}
public ProviderStrategy<String> curator_f3742_0()
{    return providerStrategy;}
public int curator_f3743_0()
{    return instanceRefreshMs;}
public ServiceDiscovery<String> curator_f3744_0()
{    return serviceDiscovery;}
public void curator_f3745_0(ObjectNode node, String fieldName, String payload) throws Exception
{    if (payload != null) {        node.put(fieldName, payload);    }}
public String curator_f3746_0(JsonNode node) throws Exception
{    return (node != null) ? node.asText() : null;}
public DiscoveryContext<String> curator_f3747_0(Class<?> type)
{    return this;}
 static ServiceInstance<T> curator_f3748_0(JsonNode node, DiscoveryContext<T> context) throws Exception
{    ServiceInstanceBuilder<T> builder = ServiceInstance.builder();    builder.name(node.get("name").asText());    builder.id(node.get("id").asText());    builder.address(node.get("address").asText());    builder.registrationTimeUTC(node.get("registrationTimeUTC").asLong());    builder.serviceType(ServiceType.valueOf(node.get("serviceType").asText()));    builder.payload(context.unMarshallJson(node.get("payload")));    Integer port = getInteger(node, "port");    Integer sslPort = getInteger(node, "sslPort");    if (port != null) {        builder.port(port);    }    if (sslPort != null) {        builder.sslPort(sslPort);    }    return builder.build();}
 static ObjectNode curator_f3749_0(ObjectMapper mapper, ServiceInstance<T> instance, DiscoveryContext<T> context)
{    ObjectNode node = mapper.createObjectNode();    node.put("name", instance.getName());    node.put("id", instance.getId());    node.put("address", instance.getAddress());    putInteger(node, "port", instance.getPort());    putInteger(node, "sslPort", instance.getSslPort());    node.put("registrationTimeUTC", instance.getRegistrationTimeUTC());    node.put("serviceType", instance.getServiceType().name());    try {        context.marshallJson(node, "payload", instance.getPayload());    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }    return node;}
private static Integer curator_f3750_0(JsonNode node, String fieldName)
{    JsonNode intNode = node.get(fieldName);    return (intNode != null) ? intNode.asInt() : null;}
private static void curator_f3751_0(ObjectNode node, String fieldName, Integer value)
{    if (value != null) {        node.put(fieldName, value);    }}
public boolean curator_f3752_0(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return isWriteable(type, genericType, annotations, mediaType);}
public boolean curator_f3753_0(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ServiceInstance.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
public long curator_f3754_0(ServiceInstance<T> serviceInstance, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
public ServiceInstance<T> curator_f3755_0(Class<ServiceInstance<T>> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    try {        ObjectMapper mapper = new ObjectMapper();        JsonNode node = mapper.reader().readTree(entityStream);        return readInstance(node, context);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }}
public void curator_f3756_0(ServiceInstance<T> serviceInstance, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ObjectNode node = writeInstance(mapper, serviceInstance, context);    mapper.writer().writeValue(entityStream, node);}
public boolean curator_f3757_0(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return isWriteable(type, genericType, annotations, mediaType);}
public boolean curator_f3758_0(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ServiceInstances.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
public long curator_f3759_0(ServiceInstances<T> serviceInstances, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
public ServiceInstances<T> curator_f3760_0(Class<ServiceInstances<T>> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    try {        List<ServiceInstance<T>> instances = Lists.newArrayList();        ObjectMapper mapper = new ObjectMapper();        JsonNode tree = mapper.reader().readTree(entityStream);        for (int i = 0; i < tree.size(); ++i) {            JsonNode node = tree.get(i);            ServiceInstance<T> instance = JsonServiceInstanceMarshaller.readInstance(node, context);            instances.add(instance);        }        return new ServiceInstances<T>(instances);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }}
public void curator_f3761_0(ServiceInstances<T> serviceInstances, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ArrayNode arrayNode = mapper.createArrayNode();    List<? extends ServiceInstance<T>> instanceList = serviceInstances.getServices();    for (ServiceInstance<T> instance : instanceList) {        ObjectNode node = JsonServiceInstanceMarshaller.writeInstance(mapper, instance, context);        arrayNode.add(node);    }    mapper.writer().writeValue(entityStream, arrayNode);}
public boolean curator_f3762_0(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return allow(type, mediaType);}
public ServiceNames curator_f3763_0(Class<ServiceNames> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    List<String> names = Lists.newArrayList();    ObjectMapper mapper = new ObjectMapper();    JsonNode tree = mapper.reader().readTree(entityStream);    for (int i = 0; i < tree.size(); ++i) {        JsonNode node = tree.get(i);        names.add(node.get("name").asText());    }    return new ServiceNames(names);}
public boolean curator_f3764_0(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return allow(type, mediaType);}
public long curator_f3765_0(ServiceNames serviceNames, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
public void curator_f3766_0(ServiceNames serviceNames, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ArrayNode arrayNode = mapper.createArrayNode();    for (String name : serviceNames.getNames()) {        ObjectNode node = mapper.createObjectNode();        node.put("name", name);        arrayNode.add(node);    }    mapper.writer().writeValue(entityStream, arrayNode);}
private static boolean curator_f3767_0(Class<?> type, MediaType mediaType)
{    return ServiceNames.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
public List<ServiceInstance<T>> curator_f3768_0()
{    return ImmutableList.copyOf(services);}
public List<String> curator_f3769_0()
{    return ImmutableList.copyOf(names);}
public Response curator_f3770_1(ServiceInstance<T> instance, @PathParam("name") String name, @PathParam("id") String id)
{    if (!instance.getId().equals(id) || !instance.getName().equals(name)) {                return Response.status(Response.Status.BAD_REQUEST).build();    }    if (instance.getServiceType().isDynamic()) {                return Response.status(Response.Status.BAD_REQUEST).build();    }    try {        context.getServiceDiscovery().registerService(instance);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }    return Response.status(Response.Status.CREATED).build();}
public Response curator_f3771_1(@PathParam("name") String name, @PathParam("id") String id)
{    try {        ServiceInstance<T> instance = context.getServiceDiscovery().queryForInstance(name, id);        if (instance != null) {                        context.getServiceDiscovery().unregisterService(instance);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }    return Response.ok().build();}
public Response curator_f3772_0(@PathParam("name") String name, @PathParam("id") String id)
{    return internalGet(name, id, true);}
public Response curator_f3773_0(@PathParam("name") String name, @PathParam("id") String id)
{    return internalGet(name, id, false);}
public Response curator_f3774_1()
{    try {        List<String> instances = Lists.newArrayList(context.getServiceDiscovery().queryForNames());        Collections.sort(instances);        return Response.ok(new ServiceNames(instances)).build();    } catch (Exception e) {                return Response.serverError().build();    }}
public Response curator_f3775_1(@PathParam("name") String name)
{    try {        Collection<ServiceInstance<T>> instances = context.getServiceDiscovery().queryForInstances(name);        return Response.ok(new ServiceInstances<T>(instances)).build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }}
public Response curator_f3776_1(@PathParam("name") String name)
{    try {        final List<ServiceInstance<T>> instances = Lists.newArrayList(context.getServiceDiscovery().queryForInstances(name));        ServiceInstance<?> randomInstance = context.getProviderStrategy().getInstance(new InstanceProvider<T>() {            @Override            public List<ServiceInstance<T>> getInstances() throws Exception {                return instances;            }        });        if (randomInstance == null) {            return Response.status(Response.Status.NOT_FOUND).build();        }        return Response.ok(randomInstance).build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }}
public List<ServiceInstance<T>> curator_f3777_0() throws Exception
{    return instances;}
private Response curator_f3778_1(String name, String id, boolean addDeprecationHeader)
{    try {        ServiceInstance<T> instance = context.getServiceDiscovery().queryForInstance(name, id);        if (instance == null) {            return Response.status(Response.Status.NOT_FOUND).build();        }        Response.ResponseBuilder builder = Response.ok(instance);        if (addDeprecationHeader) {            builder = builder.header("Warning", "This API has been deprecated. Please see the updated spec for the replacement API.");        }        return builder.build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                return Response.serverError().build();    }}
public void curator_f3779_0()
{    Preconditions.checkArgument(!service.isShutdown(), "already started");    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            doWork();        }    }, instanceRefreshMs, instanceRefreshMs, TimeUnit.MILLISECONDS);}
public void curator_f3780_0()
{    doWork();}
public void curator_f3781_0() throws IOException
{    Preconditions.checkArgument(!service.isShutdown(), "not started");    service.shutdownNow();}
private void curator_f3782_1()
{    try {        for (String name : discovery.queryForNames()) {            checkService(name);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }}
private void curator_f3783_1(String name)
{    try {        Collection<ServiceInstance<Object>> instances = discovery.queryForInstances(name);        for (ServiceInstance<Object> instance : instances) {            if (instance.getServiceType() == ServiceType.STATIC) {                if ((System.currentTimeMillis() - instance.getRegistrationTimeUTC()) > instanceRefreshMs) {                    discovery.unregisterService(instance);                }            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);            }}
public String curator_f3784_0()
{    return description;}
public void curator_f3785_0(String description)
{    this.description = description;}
public void curator_f3786_0(Map<String, String> data)
{    this.data = data;}
public Map<String, String> curator_f3787_0()
{    return data;}
public int curator_f3788_0()
{    final int prime = 31;    int result = 1;    result = prime * result + ((data == null) ? 0 : data.hashCode());    result = prime * result + ((description == null) ? 0 : description.hashCode());    return result;}
public boolean curator_f3789_0(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ServiceDetails other = (ServiceDetails) obj;    if (data == null) {        if (other.data != null)            return false;    } else if (!data.equals(other.data))        return false;    if (description == null) {        if (other.description != null)            return false;    } else if (!description.equals(other.description))        return false;    return true;}
public void curator_f3790_0() throws Exception
{    context = new MapDiscoveryContext(new MockServiceDiscovery<Map<String, String>>(), new RandomStrategy<Map<String, String>>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<Map<String, String>>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<Map<String, String>>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(MapDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
public Set<Class<?>> curator_f3791_0()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(MapDiscoveryResource.class);    return classes;}
public Set<Object> curator_f3792_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
public void curator_f3793_0() throws Exception
{    server.stop();    server.join();}
public void curator_f3794_0() throws Exception
{    Map<String, String> payload = Maps.newHashMap();    payload.put("one", "1");    payload.put("two", "2");    payload.put("three", "3");    ServiceInstance<Map<String, String>> service = ServiceInstance.<Map<String, String>>builder().name("test").payload(payload).serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<Map<String, String>>> type = new GenericType<ServiceInstances<Map<String, String>>>() {    };    ServiceInstances<Map<String, String>> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);    Assert.assertEquals(instances.getServices().get(0).getPayload(), payload);        GenericType<ServiceInstance<Map<String, String>>> singleInstanceType = new GenericType<ServiceInstance<Map<String, String>>>() {    };    ServiceInstance<Map<String, String>> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
public Set<Object> curator_f3795_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
public void curator_f3796_0() throws Exception
{    context = new ServiceDetailsDiscoveryContext(new MockServiceDiscovery<ServiceDetails>(), new RandomStrategy<ServiceDetails>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<ServiceDetails>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<ServiceDetails>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(ServiceDetailsDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
public Set<Class<?>> curator_f3797_0()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(ServiceDetailsDiscoveryResource.class);    return classes;}
public Set<Object> curator_f3798_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
public void curator_f3799_0() throws Exception
{    server.stop();    server.join();}
public void curator_f3800_0() throws Exception
{    ServiceDetails payload = new ServiceDetails();    payload.setDescription("Example description for test");    payload.getData().put("one", "1");    payload.getData().put("two", "2");    payload.getData().put("three", "3");    ServiceInstance<ServiceDetails> service = ServiceInstance.<ServiceDetails>builder().name("test").payload(payload).serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<ServiceDetails>> type = new GenericType<ServiceInstances<ServiceDetails>>() {    };    ServiceInstances<ServiceDetails> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);    Assert.assertEquals(instances.getServices().get(0).getPayload(), payload);        GenericType<ServiceInstance<ServiceDetails>> singleInstanceType = new GenericType<ServiceInstance<ServiceDetails>>() {    };    ServiceInstance<ServiceDetails> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
public Set<Object> curator_f3801_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
public void curator_f3802_0() throws Exception
{    context = new StringDiscoveryContext(new MockServiceDiscovery<String>(), new RandomStrategy<String>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<String>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<String>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(StringDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
public Set<Class<?>> curator_f3803_0()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(StringDiscoveryResource.class);    return classes;}
public Set<Object> curator_f3804_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
public void curator_f3805_0() throws Exception
{    server.stop();    server.join();}
public void curator_f3806_0() throws Exception
{    ServiceInstance<String> service = ServiceInstance.<String>builder().name("test").payload("From Test").serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<String>> type = new GenericType<ServiceInstances<String>>() {    };    ServiceInstances<String> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);        GenericType<ServiceInstance<String>> singleInstanceType = new GenericType<ServiceInstance<String>>() {    };    ServiceInstance<String> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
public Set<Object> curator_f3807_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
public void curator_f3808_0()
{    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.<String>newArrayList());}
public Set<Object> curator_f3809_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
public Set<Class<?>> curator_f3810_0()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(StringDiscoveryResource.class);    return classes;}
public Set<Object> curator_f3811_0()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(singletonsRef.get().contextSingleton);    singletons.add(singletonsRef.get().serviceNamesMarshallerSingleton);    singletons.add(singletonsRef.get().serviceInstanceMarshallerSingleton);    singletons.add(singletonsRef.get().serviceInstancesMarshallerSingleton);    return singletons;}
private static DiscoveryContext<String> curator_f3812_0(Providers providers)
{    ContextResolver<DiscoveryContext> contextResolver = providers.getContextResolver(DiscoveryContext.class, MediaType.WILDCARD_TYPE);        return contextResolver.getContext(DiscoveryContext.class);}
public void curator_f3813_0() throws Exception
{    RestEasyApplication.singletonsRef.set(new RestEasySingletons());    ResteasyProviderFactory.setInstance(new ResteasyProviderFactory());    HttpServletDispatcher dispatcher = new HttpServletDispatcher();    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.getInitParams().put("javax.ws.rs.Application", RestEasyApplication.class.getName());    root.addServlet(new ServletHolder(dispatcher), "/*");    root.addEventListener(new ResteasyBootstrap());    server.start();}
public void curator_f3814_0() throws Exception
{    server.stop();    server.join();}
public void curator_f3815_0() throws Exception
{    RestEasySingletons restEasySingletons = RestEasyApplication.singletonsRef.get();    ServiceInstance<String> service = ServiceInstance.<String>builder().name("test").payload("From Test").serviceType(ServiceType.STATIC).build();    ByteArrayOutputStream out = new ByteArrayOutputStream();    restEasySingletons.serviceInstanceMarshallerSingleton.writeTo(service, null, null, null, null, null, out);    getJson("http://localhost:" + port + "/v1/service/test/" + service.getId(), new String(out.toByteArray()));    String json = getJson("http://localhost:" + port + "/v1/service", null);    ServiceNames names = restEasySingletons.serviceNamesMarshallerSingleton.readFrom(ServiceNames.class, null, null, MediaType.APPLICATION_JSON_TYPE, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    json = getJson("http://localhost:" + port + "/v1/service/test", null);    ServiceInstances<String> instances = restEasySingletons.serviceInstancesMarshallerSingleton.readFrom(null, null, null, null, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);        json = getJson("http://localhost:" + port + "/v1/service/test/" + service.getId(), null);    ServiceInstance<String> instance = restEasySingletons.serviceInstanceMarshallerSingleton.readFrom(null, null, null, null, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(instance, service);}
public void curator_f3816_0() throws Exception
{    String json = getJson("http://localhost:" + port + "/v1/service", null);    ServiceNames names = RestEasyApplication.singletonsRef.get().serviceNamesMarshallerSingleton.readFrom(ServiceNames.class, null, null, MediaType.APPLICATION_JSON_TYPE, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(names.getNames(), Lists.<String>newArrayList());}
private String curator_f3817_0(String urlStr, String body) throws IOException
{    URL url = new URL(urlStr);    URLConnection urlConnection = url.openConnection();    urlConnection.addRequestProperty("Accept", "application/json");    if (body != null) {        ((HttpURLConnection) urlConnection).setRequestMethod("PUT");        urlConnection.addRequestProperty("Content-Type", "application/json");        urlConnection.addRequestProperty("Content-Length", Integer.toString(body.length()));        urlConnection.setDoOutput(true);        OutputStream out = urlConnection.getOutputStream();        ByteSource.wrap(body.getBytes()).copyTo(out);    }    BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));    try {        return CharStreams.toString(in);    } finally {        in.close();    }}
public Collection<ServiceInstance<T>> curator_f3818_0()
{    return Lists.newArrayList();}
public void curator_f3819_0() throws Exception
{}
public void curator_f3820_0(ServiceInstance<T> service) throws Exception
{    services.put(service.getName(), service);}
public void curator_f3821_0(ServiceInstance<T> service) throws Exception
{    services.remove(service.getName(), service);}
public void curator_f3822_0(ServiceInstance<T> service) throws Exception
{    services.put(service.getName(), service);}
public ServiceCacheBuilder<T> curator_f3823_0()
{    throw new UnsupportedOperationException();}
public Collection<String> curator_f3824_0() throws Exception
{    return services.keys();}
public Collection<ServiceInstance<T>> curator_f3825_0(String name) throws Exception
{    return services.get(name);}
public ServiceInstance<T> curator_f3826_0(String name, String id) throws Exception
{    Collection<ServiceInstance<T>> instances = services.get(name);    for (ServiceInstance<T> instance : instances) {        if (instance.getId().equals(id)) {            return instance;        }    }    return null;}
public ServiceProviderBuilder<T> curator_f3827_0()
{    throw new UnsupportedOperationException();}
public void curator_f3828_0() throws IOException
{}
