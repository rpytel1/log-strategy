public void metron_f6228_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    dateTimeFormatter = getDateFormatter(parserConfig);    dateTimeFormatter = getDateFormatterWithZone(dateTimeFormatter, parserConfig);    init();}
public void metron_f6231_0()
{    if (converter == null) {        converter = new CSVConverter();        Map<String, Object> config = new HashMap<>();        config.put(CSVConverter.SEPARATOR_KEY, recordDelimiter);        config.put(CSVConverter.COLUMNS_KEY, Lists.newArrayList(fieldNames));        converter.initialize(config);    }}
private long metron_f6233_0(String snortDatetime) throws ParseException
{    ZonedDateTime zonedDateTime = ZonedDateTime.parse(snortDatetime.trim(), dateTimeFormatter);    return zonedDateTime.toInstant().toEpochMilli();}
public String metron_f6234_0()
{    return this.recordDelimiter;}
public void metron_f6235_0(String recordDelimiter)
{    this.recordDelimiter = recordDelimiter;}
public String[] metron_f6236_0()
{    return this.fieldNames;}
public void metron_f6237_0(String[] fieldNames)
{    this.fieldNames = fieldNames;}
public void metron_f6238_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
protected long metron_f6241_0(Object value)
{    long epochTimestamp = System.currentTimeMillis();    if (value != null) {        try {            epochTimestamp = toEpoch(Calendar.getInstance().get(Calendar.YEAR) + " " + value);        } catch (ParseException e) {                }    }    return epochTimestamp;}
protected void metron_f6242_0(JSONObject message)
{    removeEmptyFields(message);    message.remove("timestamp_string");    if (message.containsKey("message")) {        String messageValue = (String) message.get("message");        if (messageValue.contains("logged into")) {            parseLoginMessage(message);        } else if (messageValue.contains("logged out")) {            parseLogoutMessage(message);        } else if (messageValue.contains("rbm(")) {            parseRBMMessage(message);        } else {            parseOtherMessage(message);        }    }}
private void metron_f6243_0(JSONObject json)
{    Iterator<Object> keyIter = json.keySet().iterator();    while (keyIter.hasNext()) {        Object key = keyIter.next();        Object value = json.get(key);        if (null == value || "".equals(value.toString())) {            keyIter.remove();        }    }}
private void metron_f6244_0(JSONObject json)
{    json.put("event_subtype", "login");    String message = (String) json.get("message");    if (message.contains(":")) {        String[] parts = message.split(":");        String user = parts[0];        String ip_src_addr = parts[1];        if (user.contains("user(") && user.contains(")")) {            user = user.substring(user.indexOf("user(") + "user(".length());            user = user.substring(0, user.indexOf(")"));            json.put("username", user);        }        if (ip_src_addr.contains("[") && ip_src_addr.contains("]")) {            ip_src_addr = ip_src_addr.substring(ip_src_addr.indexOf("[") + 1);            ip_src_addr = ip_src_addr.substring(0, ip_src_addr.indexOf("]"));            json.put("ip_src_addr", ip_src_addr);        }        json.remove("message");    }}
private void metron_f6245_0(JSONObject json)
{    json.put("event_subtype", "logout");    String message = (String) json.get("message");    if (message.matches(".*'.*'.*'.*'.*")) {        String[] parts = message.split("'");        String ip_src_addr = parts[0];        if (ip_src_addr.contains("[") && ip_src_addr.contains("]")) {            ip_src_addr = ip_src_addr.substring(ip_src_addr.indexOf("[") + 1);            ip_src_addr = ip_src_addr.substring(0, ip_src_addr.indexOf("]"));            json.put("ip_src_addr", ip_src_addr);        }        json.put("username", parts[1]);        json.put("security_domain", parts[3]);        json.remove("message");    }}
private void metron_f6246_0(JSONObject json)
{    String message = (String) json.get("message");    if (message.contains("(")) {        json.put("process", message.substring(0, message.indexOf("(")));        if (message.contains(":")) {            json.put("message", message.substring(message.indexOf(":") + 2));        }    }}
private void metron_f6247_0(JSONObject json)
{    String message = (String) json.get("message");    if (message.contains("(")) {        json.put("process", message.substring(0, message.indexOf("(")));        if (message.contains(":")) {            json.put("message", message.substring(message.indexOf(":") + 2));        }    }}
public void metron_f6248_0()
{    Assert.assertNull(Filters.get("DEFAULT", null));}
public void metron_f6249_0() throws Exception
{    {        Map<String, Object> config = new HashMap<String, Object>() {            {                put("filter.query", "exists(foo)");            }        };        MessageFilter<JSONObject> filter = Filters.get(Filters.STELLAR.name(), config);        Assert.assertTrue(filter.emit(new JSONObject(ImmutableMap.of("foo", 1)), Context.EMPTY_CONTEXT()));        Assert.assertFalse(filter.emit(new JSONObject(ImmutableMap.of("bar", 1)), Context.EMPTY_CONTEXT()));    }}
public void metron_f6250_0() throws Exception
{    parserConfig = new HashMap<>();    asaParser = new BasicAsaParser();    asaParser.configure(parserConfig);    asaParser.init();}
public void metron_f6251_0()
{    BasicAsaParser testParser = new BasicAsaParser();    testParser.configure(parserConfig);    testParser.init();    assertTrue(testParser.deviceClock.getZone().equals(ZoneOffset.UTC));}
public void metron_f6252_0()
{    parserConfig.put("deviceTimeZone", "UTC-05:00");    BasicAsaParser testParser = new BasicAsaParser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6253_0()
{    parserConfig.put("deviceTimeZone", "America/New_York");    BasicAsaParser testParser = new BasicAsaParser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6254_0()
{    String rawMessage = "<164>Aug 05 2016 01:01:34: %ASA-4-106023: Deny tcp src Inside:10.30.9.121/54580 dst Outside:192.168.135.51/42028 by access-group \"Inside_access_in\" [0x962df600, 0x0]";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue(asaJson.get("ip_src_addr").equals("10.30.9.121"));    assertTrue(asaJson.get("ip_dst_addr").equals("192.168.135.51"));    assertTrue(asaJson.get("ip_src_port").equals(54580));    assertTrue(asaJson.get("ip_dst_port").equals(42028));    assertTrue((long) asaJson.get("timestamp") == 1470358894000L);}
public void metron_f6255_0()
{    String rawMessage = "<162>Aug 05 2016 01:02:25: %ASA-2-106006: Deny inbound UDP from 10.25.177.164/63279 to 10.2.52.71/161 on interface Inside";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue(asaJson.get("ip_src_addr").equals("10.25.177.164"));    assertTrue(asaJson.get("ip_dst_addr").equals("10.2.52.71"));    assertTrue(asaJson.get("ip_src_port").equals(63279));    assertTrue(asaJson.get("ip_dst_port").equals(161));    assertTrue((long) asaJson.get("timestamp") == 1470358945000L);}
public void metron_f6256_0()
{    String rawMessage = "<174>Jan  5 14:52:35 10.22.8.212 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    ZonedDateTime fixedInstant = ZonedDateTime.of(2016, 1, 6, 1, 30, 30, 0, ZoneOffset.UTC);    Clock fixedClock = Clock.fixed(fixedInstant.toInstant(), fixedInstant.getZone());    BasicAsaParser fixedClockParser = new BasicAsaParser();    fixedClockParser.deviceClock = fixedClock;    fixedClockParser.init();    JSONObject asaJson = fixedClockParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue(asaJson.get("ip_src_addr").equals("10.22.8.110"));    assertTrue(asaJson.get("ip_dst_addr").equals("192.111.72.8"));    assertTrue(asaJson.get("ip_src_port").equals(49886));    assertTrue(asaJson.get("ip_dst_port").equals(8612));    assertTrue((long) asaJson.get("timestamp") == 1452005555000L);}
public void metron_f6257_0()
{    String rawMessage = "<165>Aug 16 2016 04:08:36: %ASA-5-713049: Group = 172.22.136.20, IP = 172.22.136.20, Security negotiation complete for LAN-to-LAN Group (172.22.136.20)  Initiator, Inbound SPI = 0x891fb03f, Outbound SPI = 0xbe4b5d8d";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue((long) asaJson.get("timestamp") == 1471320516000L);}
public void metron_f6258_0()
{    String rawMessage = "<164>Aug 05 2016 01:01:34: %ASA-4-106023: Deny tcp src Inside:10.30.9.121/54580 dst Outside:192.168.256.51/42028 by access-group \"Inside_access_in\" [0x962df600, 0x0]";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(asaJson.get("original_string"), rawMessage);    assertTrue((long) asaJson.get("timestamp") == 1470358894000L);    assertNull(asaJson.get("ip_dst_addr"));}
public void metron_f6259_0()
{    String rawMessage = "<174>Jan 05 2016 14:52:35 10.22.8.212 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:2001:db8:85a3::8a2e:370:7334/49886 (10.22.8.110/49886) to inside:2001:0db8:85a3:0000:0000:8a2e:0370:7334/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals(rawMessage, asaJson.get("original_string"));    assertEquals("2001:db8:85a3::8a2e:370:7334", asaJson.get("ip_src_addr"));    assertEquals("2001:0db8:85a3:0000:0000:8a2e:0370:7334", asaJson.get("ip_dst_addr"));    assertEquals(49886, asaJson.get("ip_src_port"));    assertEquals(8612, asaJson.get("ip_dst_port"));    assertEquals(1452005555000L, asaJson.get("timestamp"));}
public void metron_f6260_0()
{    String rawMessage = "<174>Jan  5 14:52:35 10.22.8.212 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals("10.22.8.212", asaJson.get("syslog_host"));}
public void metron_f6261_0()
{    String rawMessage = "<174>Jan  5 14:52:35 hostname-2 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals("hostname-2", asaJson.get("syslog_host"));}
public void metron_f6262_0()
{    String rawMessage = "<174>Jan  5 14:52:35 hostname-2 progName-2 %ASA-6-302015: Built inbound UDP connection 76245506 for outside:10.22.8.110/49886 (10.22.8.110/49886) to inside:192.111.72.8/8612 (192.111.72.8/8612) (user.name)";    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertEquals("hostname-2", asaJson.get("syslog_host"));    assertEquals("progName-2", asaJson.get("syslog_prog"));}
public void metron_f6263_0()
{    String rawMessage = "-- MARK --";    UnitTestHelper.setLog4jLevel(BasicAsaParser.class, Level.FATAL);    thrown.expect(RuntimeException.class);    thrown.expectMessage(startsWith("[Metron] Message '-- MARK --'"));    JSONObject asaJson = asaParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);    UnitTestHelper.setLog4jLevel(BasicAsaParser.class, Level.ERROR);}
public void metron_f6264_0()
{    parserConfig.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    asaParser.configure(parserConfig);    assertThat(asaParser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6265_0()
{    asaParser.configure(parserConfig);    assertThat(asaParser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public static void metron_f6266_0()
{    UnitTestHelper.setLog4jLevel(BasicBroParser.class, Level.FATAL);}
public static void metron_f6267_0()
{    UnitTestHelper.setLog4jLevel(BasicBroParser.class, Level.ERROR);}
public void metron_f6268_0()
{    Pair[] pairs = { Pair.of(12345678d, "12345678.0"), Pair.of(12345678.0d, "12345678.0"), Pair.of(12345678.1d, "12345678.1"), Pair.of(12345678.11d, "12345678.11"), Pair.of(12345678.111d, "12345678.111"), Pair.of(12345678.1111d, "12345678.1111"), Pair.of(12345678.11111d, "12345678.11111"), Pair.of(12345678.111111d, "12345678.111111") };    for (Pair pair : pairs) {        Assert.assertEquals("Format did not match", pair.getRight(), BasicBroParser.DECIMAL_FORMAT.get().format(pair.getLeft()));    }}
public void metron_f6269_0() throws ParseException
{    JSONObject rawJson = (JSONObject) jsonParser.parse(unwrappedBroMessage);    JSONObject broJson = broParser.parse(unwrappedBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1449511228.474";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1449511228474";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port"), rawJson.get("id.orig_p"));    Assert.assertEquals(broJson.get("ip_dst_port"), rawJson.get("id.resp_p"));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("trans_id").toString(), rawJson.get("trans_id").toString());    Assert.assertEquals(broJson.get("sensor").toString(), rawJson.get("sensor").toString());    Assert.assertEquals(broJson.get("type").toString(), rawJson.get("type").toString());    Assert.assertEquals(broJson.get("rcode").toString(), rawJson.get("rcode").toString());    Assert.assertEquals(broJson.get("rcode_name").toString(), rawJson.get("rcode_name").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DNS"));}
public void metron_f6270_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(httpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(httpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1402307733.473";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1402307733473";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("method").toString(), rawJson.get("method").toString());    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("resp_mime_types").toString(), rawJson.get("resp_mime_types").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("HTTP"));}
public void metron_f6271_0() throws ParseException
{    {        String rawMessage = "{\"http\": {\"ts\":1467657279,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279000";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.0";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }    {        String rawMessage = "{\"http\": {\"ts\":1467657279.0,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279000";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.0";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }    {        String rawMessage = "{\"http\": {\"ts\":1467657279.1,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279100";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.1";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }    {        String rawMessage = "{\"http\": {\"ts\":1467657279.11,\"uid\":\"CMYLzP3PKiwZAgBa51\",\"id.orig_h\":\"192.168.138.158\",\"id.orig_p\":49206,\"id.resp_h\":\"95.163.121.204\"," + "\"id.resp_p\":80,\"trans_depth\":2,\"method\":\"GET\",\"host\":\"7oqnsnzwwnm6zb7y.gigapaysun.com\",\"uri\":\"/img/flags/it.png\",\"referrer\":\"http://7oqnsnzwwnm6zb7y.gigapaysun.com/11iQmfg\",\"user_agent\":\"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)\",\"request_body_len\":0,\"response_body_len\":552,\"status_code\":200,\"status_msg\":\"OK\",\"tags\":[],\"resp_fuids\":[\"F3m7vB2RjUe4n01aqj\"],\"resp_mime_types\":[\"image/png\"]}}";        Map rawMessageMap = (Map) jsonParser.parse(rawMessage);        JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());        JSONObject broJson = broParser.parse(rawMessage.getBytes(StandardCharsets.UTF_8)).get(0);        String expectedTimestamp = "1467657279110";        Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);        String expectedBroTimestamp = "1467657279.11";        Assert.assertEquals(broJson.get("bro_timestamp").toString(), expectedBroTimestamp);    }}
public void metron_f6272_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(httpBroDecimalMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(httpBroDecimalMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1457149494.166991";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1457149494166";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("method").toString(), rawJson.get("method").toString());    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("resp_mime_types").toString(), rawJson.get("resp_mime_types").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("HTTP"));}
public void metron_f6273_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(dnsBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(dnsBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1402308259.609";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1402308259609";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("qtype").toString(), rawJson.get("qtype").toString());    Assert.assertEquals(broJson.get("trans_id").toString(), rawJson.get("trans_id").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DNS"));}
public void metron_f6274_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(filesBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(filesBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1425845251.334";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1425845251334";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), ((JSONArray) rawJson.get("tx_hosts")).get(0).toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), ((JSONArray) rawJson.get("rx_hosts")).get(0).toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("fuid").toString(), rawJson.get("fuid").toString());    Assert.assertEquals(broJson.get("md5").toString(), rawJson.get("md5").toString());    Assert.assertEquals(broJson.get("analyzers").toString(), rawJson.get("analyzers").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("FILES"));}
public void metron_f6275_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(connBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(connBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1166289883.163553";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1166289883163";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("proto").toString(), rawJson.get("proto").toString());    Assert.assertEquals(broJson.get("service").toString(), rawJson.get("service").toString());    Assert.assertEquals(broJson.get("duration").toString(), rawJson.get("duration").toString());    Assert.assertEquals(broJson.get("orig_bytes").toString(), rawJson.get("orig_bytes").toString());    Assert.assertEquals(broJson.get("resp_bytes").toString(), rawJson.get("resp_bytes").toString());    Assert.assertEquals(broJson.get("conn_state").toString(), rawJson.get("conn_state").toString());    Assert.assertEquals(broJson.get("missed_bytes").toString(), rawJson.get("missed_bytes").toString());    Assert.assertEquals(broJson.get("history").toString(), rawJson.get("history").toString());    Assert.assertEquals(broJson.get("orig_pkts").toString(), rawJson.get("orig_pkts").toString());    Assert.assertEquals(broJson.get("orig_ip_bytes").toString(), rawJson.get("orig_ip_bytes").toString());    Assert.assertEquals(broJson.get("resp_pkts").toString(), rawJson.get("resp_pkts").toString());    Assert.assertEquals(broJson.get("resp_ip_bytes").toString(), rawJson.get("resp_ip_bytes").toString());    Assert.assertEquals(broJson.get("tunnel_parents").toString(), rawJson.get("tunnel_parents").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("CONN"));}
public void metron_f6276_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(dpdBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(dpdBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216704078.712276";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216704078712";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("proto").toString(), rawJson.get("proto").toString());    Assert.assertEquals(broJson.get("analyzer").toString(), rawJson.get("analyzer").toString());    Assert.assertEquals(broJson.get("failure_reason").toString(), rawJson.get("failure_reason").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DPD"));}
public void metron_f6277_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(ftpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(ftpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1166289883.164645";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1166289883164";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("user").toString(), rawJson.get("user").toString());    Assert.assertEquals(broJson.get("password").toString(), rawJson.get("password").toString());    Assert.assertEquals(broJson.get("command").toString(), rawJson.get("command").toString());    Assert.assertEquals(broJson.get("arg").toString(), rawJson.get("arg").toString());    Assert.assertEquals(broJson.get("mime_type").toString(), rawJson.get("mime_type").toString());    Assert.assertEquals(broJson.get("file_size").toString(), rawJson.get("file_size").toString());    Assert.assertEquals(broJson.get("reply_code").toString(), rawJson.get("reply_code").toString());    Assert.assertEquals(broJson.get("reply_msg").toString(), rawJson.get("reply_msg").toString());    Assert.assertEquals(broJson.get("fuid").toString(), rawJson.get("fuid").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("FTP"));}
public void metron_f6278_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(knownCertsBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(knownCertsBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706999.896836";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706999896";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("port_num").toString(), rawJson.get("port_num").toString());    Assert.assertEquals(broJson.get("subject").toString(), rawJson.get("subject").toString());    Assert.assertEquals(broJson.get("issuer_subject").toString(), rawJson.get("issuer_subject").toString());    Assert.assertEquals(broJson.get("serial").toString(), rawJson.get("serial").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("KNOWN_CERTS"));}
public void metron_f6279_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(smtpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(smtpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1258568059.130219";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1258568059130";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("trans_depth").toString(), rawJson.get("trans_depth").toString());    Assert.assertEquals(broJson.get("helo").toString(), rawJson.get("helo").toString());    Assert.assertEquals(broJson.get("last_reply").toString(), rawJson.get("last_reply").toString());    Assert.assertEquals(broJson.get("path").toString(), rawJson.get("path").toString());    Assert.assertEquals(broJson.get("tls").toString(), rawJson.get("tls").toString());    Assert.assertEquals(broJson.get("fuids").toString(), rawJson.get("fuids").toString());    Assert.assertEquals(broJson.get("is_webmail").toString(), rawJson.get("is_webmail").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SMTP"));}
public void metron_f6280_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(sslBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(sslBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706999.444925";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706999444";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("version").toString(), rawJson.get("version").toString());    Assert.assertEquals(broJson.get("cipher").toString(), rawJson.get("cipher").toString());    Assert.assertEquals(broJson.get("server_name").toString(), rawJson.get("server_name").toString());    Assert.assertEquals(broJson.get("resumed").toString(), rawJson.get("resumed").toString());    Assert.assertEquals(broJson.get("established").toString(), rawJson.get("established").toString());    Assert.assertEquals(broJson.get("cert_chain_fuids").toString(), rawJson.get("cert_chain_fuids").toString());    Assert.assertEquals(broJson.get("client_cert_chain_fuids").toString(), rawJson.get("client_cert_chain_fuids").toString());    Assert.assertEquals(broJson.get("subject").toString(), rawJson.get("subject").toString());    Assert.assertEquals(broJson.get("issuer").toString(), rawJson.get("issuer").toString());    Assert.assertEquals(broJson.get("validation_status").toString(), rawJson.get("validation_status").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SSL"));}
public void metron_f6281_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(weirdBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(weirdBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706886.239896";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706886239";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("name").toString(), rawJson.get("name").toString());    Assert.assertEquals(broJson.get("notice").toString(), rawJson.get("notice").toString());    Assert.assertEquals(broJson.get("peer").toString(), rawJson.get("peer").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("WEIRD"));}
public void metron_f6282_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(noticeBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(noticeBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706377.196728";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706377196";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("proto").toString(), rawJson.get("proto").toString());    Assert.assertEquals(broJson.get("note").toString(), rawJson.get("note").toString());    Assert.assertEquals(broJson.get("msg").toString(), rawJson.get("msg").toString());    Assert.assertEquals(broJson.get("sub").toString(), rawJson.get("sub").toString());    Assert.assertEquals(broJson.get("src").toString(), rawJson.get("src").toString());    Assert.assertEquals(broJson.get("dst").toString(), rawJson.get("dst").toString());    Assert.assertEquals(broJson.get("p").toString(), rawJson.get("p").toString());    Assert.assertEquals(broJson.get("peer_descr").toString(), rawJson.get("peer_descr").toString());    Assert.assertEquals(broJson.get("actions").toString(), rawJson.get("actions").toString());    Assert.assertEquals(broJson.get("suppress_for").toString(), rawJson.get("suppress_for").toString());    Assert.assertEquals(broJson.get("dropped").toString(), rawJson.get("dropped").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("NOTICE"));}
public void metron_f6283_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(dhcpBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(dhcpBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1258567562.944638";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1258567562944";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("mac").toString(), rawJson.get("mac").toString());    Assert.assertEquals(broJson.get("assigned_ip").toString(), rawJson.get("assigned_ip").toString());    Assert.assertEquals(broJson.get("lease_time").toString(), rawJson.get("lease_time").toString());    Assert.assertEquals(broJson.get("trans_id").toString(), rawJson.get("trans_id").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("DHCP"));}
public void metron_f6284_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(sshBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(sshBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1320435870.747967";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1320435870747";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("version").toString(), rawJson.get("version").toString());    Assert.assertEquals(broJson.get("auth_success").toString(), rawJson.get("auth_success").toString());    Assert.assertEquals(broJson.get("client").toString(), rawJson.get("client").toString());    Assert.assertEquals(broJson.get("server").toString(), rawJson.get("server").toString());    Assert.assertEquals(broJson.get("cipher_alg").toString(), rawJson.get("cipher_alg").toString());    Assert.assertEquals(broJson.get("mac_alg").toString(), rawJson.get("mac_alg").toString());    Assert.assertEquals(broJson.get("compression_alg").toString(), rawJson.get("compression_alg").toString());    Assert.assertEquals(broJson.get("kex_alg").toString(), rawJson.get("kex_alg").toString());    Assert.assertEquals(broJson.get("host_key_alg").toString(), rawJson.get("host_key_alg").toString());    Assert.assertEquals(broJson.get("host_key").toString(), rawJson.get("host_key").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SSH"));}
public void metron_f6285_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(softwareBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(softwareBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216707079.49066";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216707079490";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("host_p").toString(), rawJson.get("host_p").toString());    Assert.assertEquals(broJson.get("software_type").toString(), rawJson.get("software_type").toString());    Assert.assertEquals(broJson.get("name").toString(), rawJson.get("name").toString());    Assert.assertEquals(broJson.get("version.major").toString(), rawJson.get("version.major").toString());    Assert.assertEquals(broJson.get("version.minor").toString(), rawJson.get("version.minor").toString());    Assert.assertEquals(broJson.get("version.minor2").toString(), rawJson.get("version.minor2").toString());    Assert.assertEquals(broJson.get("unparsed_version").toString(), rawJson.get("unparsed_version").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SOFTWARE"));}
public void metron_f6286_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(softwareBroMessage2);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(softwareBroMessage2.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216707079.518447";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216707079518";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("host").toString(), rawJson.get("host").toString());    Assert.assertEquals(broJson.get("host_p").toString(), rawJson.get("host_p").toString());    Assert.assertEquals(broJson.get("software_type").toString(), rawJson.get("software_type").toString());    Assert.assertEquals(broJson.get("name").toString(), rawJson.get("name").toString());    Assert.assertEquals(broJson.get("unparsed_version").toString(), rawJson.get("unparsed_version").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("SOFTWARE"));}
public void metron_f6287_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(radiusBroMessageFailed);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(radiusBroMessageFailed.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1440447766.441298";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1440447766441";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("username").toString(), rawJson.get("username").toString());    Assert.assertEquals(broJson.get("result").toString(), rawJson.get("result").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("RADIUS"));}
public void metron_f6288_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(radiusBroMessageSuccess);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(radiusBroMessageSuccess.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1440447839.947956";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1440447839947";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("username").toString(), rawJson.get("username").toString());    Assert.assertEquals(broJson.get("result").toString(), rawJson.get("result").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("RADIUS"));}
public void metron_f6289_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(x509BroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(x509BroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216706999.661483";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216706999661";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("id").toString(), rawJson.get("id").toString());    Assert.assertEquals(broJson.get("certificate.version").toString(), rawJson.get("certificate.version").toString());    Assert.assertEquals(broJson.get("certificate.serial").toString(), rawJson.get("certificate.serial").toString());    Assert.assertEquals(broJson.get("certificate.subject").toString(), rawJson.get("certificate.subject").toString());    Assert.assertEquals(broJson.get("certificate.issuer").toString(), rawJson.get("certificate.issuer").toString());    Assert.assertEquals(broJson.get("certificate.not_valid_before").toString(), rawJson.get("certificate.not_valid_before").toString());    Assert.assertEquals(broJson.get("certificate.not_valid_after").toString(), rawJson.get("certificate.not_valid_after").toString());    Assert.assertEquals(broJson.get("certificate.key_alg").toString(), rawJson.get("certificate.key_alg").toString());    Assert.assertEquals(broJson.get("certificate.sig_alg").toString(), rawJson.get("certificate.sig_alg").toString());    Assert.assertEquals(broJson.get("certificate.key_type").toString(), rawJson.get("certificate.key_type").toString());    Assert.assertEquals(broJson.get("certificate.key_length").toString(), rawJson.get("certificate.key_length").toString());    Assert.assertEquals(broJson.get("certificate.exponent").toString(), rawJson.get("certificate.exponent").toString());    Assert.assertEquals(broJson.get("basic_constraints.ca").toString(), rawJson.get("basic_constraints.ca").toString());    Assert.assertEquals(broJson.get("basic_constraints.path_len").toString(), rawJson.get("basic_constraints.path_len").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("X509"));}
public void metron_f6290_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(knownDevicesBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(knownDevicesBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1258532046.693816";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1258532046693";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("mac").toString(), rawJson.get("mac").toString());    Assert.assertEquals(broJson.get("dhcp_host_name").toString(), rawJson.get("dhcp_host_name").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("KNOWN_DEVICES"));}
public void metron_f6291_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(rfbBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(rfbBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1328634261.675248";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1328634261675";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertEquals(broJson.get("client_major_version").toString(), rawJson.get("client_major_version").toString());    Assert.assertEquals(broJson.get("client_minor_version").toString(), rawJson.get("client_minor_version").toString());    Assert.assertEquals(broJson.get("server_major_version").toString(), rawJson.get("server_major_version").toString());    Assert.assertEquals(broJson.get("server_minor_version").toString(), rawJson.get("server_minor_version").toString());    Assert.assertEquals(broJson.get("authentication_method").toString(), rawJson.get("authentication_method").toString());    Assert.assertEquals(broJson.get("auth").toString(), rawJson.get("auth").toString());    Assert.assertEquals(broJson.get("share_flag").toString(), rawJson.get("share_flag").toString());    Assert.assertEquals(broJson.get("desktop_name").toString(), rawJson.get("desktop_name").toString());    Assert.assertEquals(broJson.get("width").toString(), rawJson.get("width").toString());    Assert.assertEquals(broJson.get("height").toString(), rawJson.get("height").toString());}
public void metron_f6292_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(statsBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(statsBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1440447766.440305";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1440447766440";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("peer").toString(), rawJson.get("peer").toString());    Assert.assertEquals(broJson.get("mem").toString(), rawJson.get("mem").toString());    Assert.assertEquals(broJson.get("pkts_proc").toString(), rawJson.get("pkts_proc").toString());    Assert.assertEquals(broJson.get("bytes_recv").toString(), rawJson.get("bytes_recv").toString());    Assert.assertEquals(broJson.get("events_proc").toString(), rawJson.get("events_proc").toString());    Assert.assertEquals(broJson.get("events_queued").toString(), rawJson.get("events_queued").toString());    Assert.assertEquals(broJson.get("active_tcp_conns").toString(), rawJson.get("active_tcp_conns").toString());    Assert.assertEquals(broJson.get("active_udp_conns").toString(), rawJson.get("active_udp_conns").toString());    Assert.assertEquals(broJson.get("active_icmp_conns").toString(), rawJson.get("active_icmp_conns").toString());    Assert.assertEquals(broJson.get("tcp_conns").toString(), rawJson.get("tcp_conns").toString());    Assert.assertEquals(broJson.get("udp_conns").toString(), rawJson.get("udp_conns").toString());    Assert.assertEquals(broJson.get("icmp_conns").toString(), rawJson.get("icmp_conns").toString());    Assert.assertEquals(broJson.get("timers").toString(), rawJson.get("timers").toString());    Assert.assertEquals(broJson.get("active_timers").toString(), rawJson.get("active_timers").toString());    Assert.assertEquals(broJson.get("files").toString(), rawJson.get("files").toString());    Assert.assertEquals(broJson.get("active_files").toString(), rawJson.get("active_files").toString());    Assert.assertEquals(broJson.get("dns_requests").toString(), rawJson.get("dns_requests").toString());    Assert.assertEquals(broJson.get("active_dns_requests").toString(), rawJson.get("active_dns_requests").toString());    Assert.assertEquals(broJson.get("reassem_tcp_size").toString(), rawJson.get("reassem_tcp_size").toString());    Assert.assertEquals(broJson.get("reassem_file_size").toString(), rawJson.get("reassem_file_size").toString());    Assert.assertEquals(broJson.get("reassem_frag_size").toString(), rawJson.get("reassem_frag_size").toString());    Assert.assertEquals(broJson.get("reassem_unknown_size").toString(), rawJson.get("reassem_unknown_size").toString());}
public void metron_f6293_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(captureLossBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(captureLossBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1320435958.419451";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1320435958419";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("ts_delta").toString(), rawJson.get("ts_delta").toString());    Assert.assertEquals(broJson.get("peer").toString(), rawJson.get("peer").toString());    Assert.assertEquals(broJson.get("gaps").toString(), rawJson.get("gaps").toString());    Assert.assertEquals(broJson.get("acks").toString(), rawJson.get("acks").toString());    Assert.assertEquals(broJson.get("percent_lost").toString(), rawJson.get("percent_lost").toString());}
public void metron_f6294_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(sipBroMessage);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(sipBroMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1216698441.346819";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1216698441346";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertTrue(broJson.get("original_string").toString().startsWith(rawMessageMap.keySet().iterator().next().toString().toUpperCase()));    Assert.assertEquals(broJson.get("uid").toString(), rawJson.get("uid").toString());    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertEquals(broJson.get("trans_depth").toString(), rawJson.get("trans_depth").toString());    Assert.assertEquals(broJson.get("method").toString(), rawJson.get("method").toString());    Assert.assertEquals(broJson.get("uri").toString(), rawJson.get("uri").toString());    Assert.assertEquals(broJson.get("request_from").toString(), rawJson.get("request_from").toString());    Assert.assertEquals(broJson.get("request_to").toString(), rawJson.get("request_to").toString());    Assert.assertEquals(broJson.get("response_from").toString(), rawJson.get("response_from").toString());    Assert.assertEquals(broJson.get("response_to").toString(), rawJson.get("response_to").toString());    Assert.assertEquals(broJson.get("call_id").toString(), rawJson.get("call_id").toString());    Assert.assertEquals(broJson.get("seq").toString(), rawJson.get("seq").toString());    Assert.assertEquals(broJson.get("request_path").toString(), rawJson.get("request_path").toString());    Assert.assertEquals(broJson.get("response_path").toString(), rawJson.get("response_path").toString());    Assert.assertEquals(broJson.get("user_agent").toString(), rawJson.get("user_agent").toString());    Assert.assertEquals(broJson.get("status_code").toString(), rawJson.get("status_code").toString());    Assert.assertEquals(broJson.get("status_msg").toString(), rawJson.get("status_msg").toString());    Assert.assertEquals(broJson.get("request_body_len").toString(), rawJson.get("request_body_len").toString());    Assert.assertEquals(broJson.get("response_body_len").toString(), rawJson.get("response_body_len").toString());}
public void metron_f6295_0() throws ParseException
{    Map rawMessageMap = (Map) jsonParser.parse(protocolKeyCleanedUp);    JSONObject rawJson = (JSONObject) rawMessageMap.get(rawMessageMap.keySet().iterator().next());    JSONObject broJson = broParser.parse(protocolKeyCleanedUp.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedBroTimestamp = "1402307733.473";    Assert.assertEquals(broJson.get("bro_timestamp"), expectedBroTimestamp);    String expectedTimestamp = "1402307733473";    Assert.assertEquals(broJson.get("timestamp").toString(), expectedTimestamp);    Assert.assertEquals(broJson.get("ip_src_addr").toString(), rawJson.get("id.orig_h").toString());    Assert.assertEquals(broJson.get("ip_dst_addr").toString(), rawJson.get("id.resp_h").toString());    Assert.assertEquals(broJson.get("ip_src_port").toString(), rawJson.get("id.orig_p").toString());    Assert.assertEquals(broJson.get("ip_dst_port").toString(), rawJson.get("id.resp_p").toString());    Assert.assertTrue(broJson.get("original_string").toString().startsWith("HTTP"));}
public void metron_f6296_0() throws ParseException
{    broParser.parse("{ \"foo\" : \"bar\"}".getBytes(StandardCharsets.UTF_8));}
public void metron_f6297_0()
{    broParser.parse("foo bar".getBytes(StandardCharsets.UTF_8));}
public void metron_f6298_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    broParser.configure(config);    assertThat(broParser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6299_0()
{    Map<String, Object> config = new HashMap<>();    broParser.configure(config);    assertThat(broParser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6300_0()
{    parser = new CEFParser();    parser.init();}
public void metron_f6301_0()
{    List<JSONObject> obj = parse("test test test nonsense\n");    Assert.assertEquals(0, obj.size());}
public void metron_f6302_0()
{    for (JSONObject obj : parse("Sep 19 08:26:10 host CEF:0|security|threatmanager|1.0|100|detected a \\ in packet|10|src=10.0.0.1 act=blocked a \\ dst=1.1.1.1")) {        Assert.assertEquals("10.0.0.1", obj.get(Fields.SRC_ADDR.getName()));        Assert.assertEquals("blocked a \\", obj.get("deviceAction"));        Assert.assertEquals("1.1.1.1", obj.get(Fields.DST_ADDR.getName()));    }}
public void metron_f6303_0()
{    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals("Security", obj.get("DeviceVendor"));        Assert.assertEquals("threatmanager", obj.get("DeviceProduct"));        Assert.assertEquals("1.0", obj.get("DeviceVersion"));        Assert.assertEquals("100", obj.get("DeviceEvent"));        Assert.assertEquals("worm successfully stopped", obj.get("Name"));        Assert.assertEquals(10, obj.get("Severity"));    }}
public void metron_f6304_0()
{    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals("10.0.0.1", obj.get(Fields.SRC_ADDR.getName()));        Assert.assertEquals("2.1.2.2", obj.get(Fields.DST_ADDR.getName()));        Assert.assertEquals(1232, obj.get(Fields.SRC_PORT.getName()));    }}
public void metron_f6305_0()
{    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232 custom=Text with space customLabel=Label with space")) {        Assert.assertEquals(true, obj.containsKey("Label with space"));        Assert.assertEquals("Text with space", obj.get("Label with space"));    }}
public void metron_f6306_0() throws java.text.ParseException
{    long correctTime = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz").parse("2016-05-01T09:29:11.356-0400").getTime();    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz");    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=May 1 2016 09:29:11.356 -0400 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-06-01T09:29:11.356-04:00 host CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=May 1 2016 09:29:11.356 -0400 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-05-01T09:29:11.356-04:00 host CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 dst=2.1.2.2 spt=1232")) {        Assert.assertNotNull(obj.get(Fields.TIMESTAMP.getName()));    }}
public void metron_f6307_0() throws java.text.ParseException
{    long correctTime = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz").parse("2016-05-01T09:29:11.356-0400").getTime();    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=" + String.valueOf(correctTime) + " dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }}
private void metron_f6308_0(Calendar expected, Calendar input)
{    SimpleDateFormat sdf = new SimpleDateFormat("MMM dd HH:mm:ss.SSS");    for (JSONObject obj : parse("CEF:0|Security|threatmanager|1.0|100|worm successfully stopped|10|src=10.0.0.1 rt=" + sdf.format(input.getTime()) + " dst=2.1.2.2 spt=1232")) {        Assert.assertEquals(expected.getTimeInMillis(), obj.get(Fields.TIMESTAMP.getName()));        Assert.assertEquals(expected.getTime(), new Date((long) obj.get(Fields.TIMESTAMP.getName())));    }}
public void metron_f6309_0() throws java.text.ParseException
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    correct.setTimeInMillis(current.getTimeInMillis());    runMissingYear(correct, current);}
public void metron_f6310_0()
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    current.add(Calendar.DAY_OF_MONTH, 5);        correct.setTimeInMillis(current.getTimeInMillis());    correct.add(Calendar.YEAR, -1);    runMissingYear(correct, current);}
public void metron_f6311_0() throws Exception
{    runTest("adallom", Resources.readLines(Resources.getResource(getClass(), "adallom.cef"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "adallom.schema"), StandardCharsets.UTF_8));}
public void metron_f6312_0() throws Exception
{    runTest("cyberark", Resources.readLines(Resources.getResource(getClass(), "cyberark.cef"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "cyberark.schema"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "cyberark.json"), StandardCharsets.UTF_8));}
public void metron_f6313_0() throws Exception
{    URL waf_url = Resources.getResource(getClass(), "waf.cef");    runTest("waf", Resources.readLines(waf_url, StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "waf.schema"), StandardCharsets.UTF_8));}
public void metron_f6314_0() throws Exception
{    URL palo_url = Resources.getResource(getClass(), "palo.cef");    runTest("palo", Resources.readLines(palo_url, StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "palo.schema"), StandardCharsets.UTF_8));}
private void metron_f6315_0(String name, List<String> lines, String schema) throws Exception
{    runTest(name, lines, schema, "");}
private void metron_f6316_0(String name, List<String> lines, String schema, String targetJson) throws Exception
{    for (String inputString : lines) {        JSONObject parsed = parse(inputString).get(0);        Assert.assertNotNull(parsed);        Assert.assertNotNull(parsed.get(Fields.TIMESTAMP.getName()));        Assert.assertTrue((long) parsed.get(Fields.TIMESTAMP.getName()) > 0);        JSONParser parser = new JSONParser();        Map<?, ?> json = null;        json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertEquals(true, validateJsonData(schema, json.toString()));    }}
public void metron_f6317_0() throws JsonProcessingException, IOException
{    List<JSONObject> parse = parse(sample);    JSONObject obj = parse.get(0);    Assert.assertEquals("TestVendor", obj.get("DeviceVendor"));    Assert.assertEquals(1423441663000L, obj.get(Fields.TIMESTAMP.getName()));    Assert.assertEquals("9223372036854775807", obj.get("Test Long"));    Assert.assertEquals(obj.get("Test FP Number"), String.valueOf(1.234F));    Assert.assertEquals("00:00:0c:07:ac:00", obj.get("smac"));    Assert.assertEquals("2001:cdba::3257:9652", obj.get("Test IPv6"));    Assert.assertEquals("test test test chocolate", obj.get("Test String"));    Assert.assertEquals("123.123.123.123", obj.get("destinationTranslatedAddress"));    JsonNode inner = new ObjectMapper().readTree((String) obj.get("JSON payload"));    Assert.assertEquals("chocolate!", inner.get("test_test_test").asText());}
protected boolean metron_f6318_0(final String jsonSchema, final String jsonData) throws Exception
{    final JsonNode d = JsonLoader.fromString(jsonData);    final JsonNode s = JsonLoader.fromString(jsonSchema);    final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();    JsonValidator v = factory.getValidator();    ProcessingReport report = v.validate(s, d);    return report.toString().contains("success");}
private List<JSONObject> metron_f6319_0(String string)
{    List<JSONObject> parse = parser.parse(string.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(parse);    return parse;}
public void metron_f6320_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6321_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6322_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/FireEyeParserTest.txt");    parser = new BasicFireEyeParser();}
public void metron_f6323_0() throws ParseException
{    for (String inputString : inputStrings) {        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map json = (Map) parser.parse(parsed.toJSONString());        Assert.assertNotNull(json);        Assert.assertFalse(json.isEmpty());        for (Object o : json.entrySet()) {            Entry entry = (Entry) o;            String key = (String) entry.getKey();            String value = json.get(key).toString();            Assert.assertNotNull(value);        }    }}
public void metron_f6324_0() throws ParseException
{    JSONObject parsed = parser.parse(fireeyeMessage.getBytes(StandardCharsets.UTF_8)).get(0);    JSONParser parser = new JSONParser();    Map json = (Map) parser.parse(parsed.toJSONString());    long expectedTimestamp = ZonedDateTime.of(Year.now(ZoneOffset.UTC).getValue(), 3, 19, 5, 24, 39, 0, ZoneOffset.UTC).toInstant().toEpochMilli();    Assert.assertEquals(expectedTimestamp, json.get("timestamp"));}
public void metron_f6325_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6326_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6327_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/IseParserTest.txt");    parser = new BasicIseParser();    URL schema_url = getClass().getClassLoader().getResource("TestSchemas/IseSchema.json");    super.setSchemaJsonString(super.readSchemaFromFile(schema_url));}
public void metron_f6328_0() throws org.json.simple.parser.ParseException, IOException, ProcessingException
{    for (String inputString : inputStrings) {        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map<?, ?> json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertTrue(validateJsonData(getSchemaJsonString(), json.toString()));    }}
public void metron_f6329_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6330_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6331_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/LancopeParserTest.txt");    parser = new BasicLancopeParser();    URL schema_url = getClass().getClassLoader().getResource("TestSchemas/LancopeSchema.json");    super.setSchemaJsonString(super.readSchemaFromFile(schema_url));}
public void metron_f6332_0() throws ParseException, IOException, ProcessingException
{    for (String inputString : inputStrings) {        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map<?, ?> json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertTrue(validateJsonData(getSchemaJsonString(), json.toString()));    }}
public void metron_f6333_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6334_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6335_0()
{    parser = new LEEFParser();    parser.init();}
public void metron_f6336_0()
{    List<JSONObject> obj = parse("test test test nonsense\n");    Assert.assertEquals(0, obj.size());}
public void metron_f6337_0() throws java.text.ParseException
{    long correctTime = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz").parse("2016-05-01T09:29:11.356-0400").getTime();    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSz");    for (JSONObject obj : parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-06-01T09:29:11.356-04:00 host LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("2016-05-01T09:29:11.356-04:00 host LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(new Date(correctTime), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(correctTime, obj.get(Fields.TIMESTAMP.getName()));    }    for (JSONObject obj : parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|src=10.0.0.1\tdevTime=May 1 2016 09:29:11.356 -0400\tdst=2.1.2.2\tspt=1232")) {        Assert.assertNotNull(obj.get(Fields.TIMESTAMP.getName()));    }}
private void metron_f6338_0(Calendar expected, Calendar input)
{    SimpleDateFormat sdf = new SimpleDateFormat("MMM dd HH:mm:ss.SSS");    for (JSONObject obj : parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|\t|src=10.0.0.1\tdevTime=" + sdf.format(input.getTime()) + "\tdevTimeFormat=MMM dd HH:mm:ss.SSS" + "\tdst=2.1.2.2\tspt=1232")) {        Assert.assertEquals(expected.getTime(), new Date((long) obj.get(Fields.TIMESTAMP.getName())));        Assert.assertEquals(expected.getTimeInMillis(), obj.get(Fields.TIMESTAMP.getName()));    }}
public void metron_f6339_0() throws java.text.ParseException
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    correct.setTimeInMillis(current.getTimeInMillis());    runMissingYear(correct, current);}
public void metron_f6340_0()
{    Calendar current = Calendar.getInstance();    Calendar correct = Calendar.getInstance();    current.add(Calendar.DAY_OF_MONTH, 5);        correct.setTimeInMillis(current.getTimeInMillis());    correct.add(Calendar.YEAR, -1);    runMissingYear(correct, current);}
public void metron_f6341_0()
{    List<JSONObject> parse = parse("LEEF:0|Incapsula|SIEMintegration|0|SQL Injection| fileId=3412364560000000008 sourceServiceName=test56111115.incaptest.co siteid=1333546 suid=300656 requestClientApplication=Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0 popName=mia cs2=true cs2Label=Javascript Support cs3=true cs3Label=CO Support cs1=NA cs1Label=Cap Support cs4=936e64c2-bdd1-4719-9bd0-2d882a72f30d cs4Label=VID cs5=bab1712be85b00ab21d20bf0d7b5db82701f27f53fbac19a4252efc722ac9131fdc60c0da620282b02dfb8051e7a60f9 cs5Label=clappsig dproc=Browser cs6=Firefox cs6Label=clapp calCountryOrRegion=IL cicode=Rehovot cs7=31.8969 cs7Label=latitude cs8=34.8186 cs8Label=longitude Customer=siemtest start=1460303291788 url=test56111115.incaptest.co/ requestMethod=GET qstr=keywords\\=3%29%29%29%20AND%203434%3d%28%27%3amvc%3a%27%7c%7c%28SELECT%20CASE%203434%20WHEN%203434%20THEN%201%20ELSE%200%20END%20FROM%20RDB%24DATABASE%29%7c%7c%27%3aqvi%3a%27%29%20AND%20%28%28%283793%3d3793 cn1=200 proto=HTTP cat=REQ_PASSED deviceExternalId=2323800832649 dst=54.195.35.43 dstPort=80 in=406 xff=127.0.0.1 srcPort=443 src=127.0.0.1 protoVer=TLSv1.2 ECDHE-RSA-AES128-GCM-SHA256 fileType=12999,50999,50037,50044, filePermission=37,20,1,1, cs9=,High Risk SQL Expressions,,SQL SELECT Expression, cs9Label=Rule name");    JSONObject obj = parse.get(0);    Assert.assertNotNull(obj);    Assert.assertEquals("3412364560000000008", obj.get("fileId"));    Assert.assertEquals("Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0", obj.get("requestClientApplication"));    Assert.assertTrue(obj.containsKey("longitude"));    Assert.assertFalse(obj.containsKey("cs8"));    Assert.assertFalse(obj.containsKey("cs8Label"));}
public void metron_f6342_0() throws Exception
{    runTest("sample", Resources.readLines(Resources.getResource(getClass(), "sample.leef"), StandardCharsets.UTF_8), Resources.toString(Resources.getResource(getClass(), "sample.schema"), StandardCharsets.UTF_8));}
private void metron_f6343_0(String name, List<String> lines, String schema) throws Exception
{    runTest(name, lines, schema, "");}
private void metron_f6344_0(String name, List<String> lines, String schema, String targetJson) throws Exception
{    for (String inputString : lines) {        JSONObject parsed = parse(inputString).get(0);        Assert.assertNotNull(parsed);        Assert.assertNotNull(parsed.get(Fields.TIMESTAMP.getName()));        Assert.assertTrue((long) parsed.get(Fields.TIMESTAMP.getName()) > 0);        JSONParser parser = new JSONParser();        Map<?, ?> json = null;        json = (Map<?, ?>) parser.parse(parsed.toJSONString());        Assert.assertEquals(true, validateJsonData(schema, json.toString()));    }}
private void metron_f6345_0(List<JSONObject> parse)
{    JSONObject obj = parse.get(0);    Assert.assertNotNull(obj);    Assert.assertTrue(obj.containsKey(Fields.SRC_ADDR.getName()));    Assert.assertEquals("192.0.2.0", obj.get(Fields.SRC_ADDR.getName()));}
public void metron_f6346_0()
{    List<JSONObject> parse = parse("LEEF:1.0|Microsoft|MSExchange|4.0 SP1|15345| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=joe.black");    assertSimpleSample(parse);}
public void metron_f6347_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Vendor|Product|Version|EventID| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=joe.black");    assertSimpleSample(parse);}
public void metron_f6348_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0^dst=172.50.123.1^sev=5^cat=anomaly^srcPort=81^dstPort=21^usrName=joe.black");    assertSimpleSample(parse);}
public void metron_f6349_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=joe.black");    assertFalse(parse.get(0).containsKey(Fields.DST_ADDR));}
public void metron_f6350_0()
{    List<JSONObject> parse = parse("LEEF:2.0|Vendor|Product|Version|EventID| src=192.0.2.0\tdst=172.50.123.1\tsev=5\tcat=anomaly\tsrcPort=81\tdstPort=21\tusrName=line1" + "\nLEEF:2.0|Vendor|Product|Version|EventID| src=192.0.2.1\tdst=172.50.123.2\tsev=6\tcat=anomaly\tsrcPort=82\tdstPort=22\tusrName=line2");    assertSimpleSample(parse);    assertEquals(2, parse.size());}
public void metron_f6351_0()
{    String customFormat = "yyyy-MM-dd HH:mm:ss.SSS zzz";    Date customDate = new Date();    DateFormat customFormatter = new SimpleDateFormat(customFormat);    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0^dst=172.50.123.1^sev=5^cat=anomaly^srcPort=81^dstPort=21^usrName=joe.black^devTime=" + customFormatter.format(customDate) + "^devTimeFormat=" + customFormat);    JSONObject obj = parse.get(0);    assertEquals(obj.get(Fields.TIMESTAMP.getName()), customDate.getTime());}
public void metron_f6352_0()
{    String standardFormat = "MMM dd yyyy HH:mm:ss.SSS zzz";    Date customDate = new Date();    long expected = customDate.getTime();    DateFormat customFormatter = new SimpleDateFormat(standardFormat);    List<JSONObject> parse = parse("LEEF:2.0|Lancope|StealthWatch|1.0|41|^| src=192.0.2.0^dst=172.50.123.1^sev=5^cat=anomaly^srcPort=81^dstPort=21^usrName=joe.black^devTime=" + customFormatter.format(customDate));    JSONObject obj = parse.get(0);    assertEquals(obj.get(Fields.TIMESTAMP.getName()), expected);}
protected boolean metron_f6353_0(final String jsonSchema, final String jsonData) throws Exception
{    final JsonNode d = JsonLoader.fromString(jsonData);    final JsonNode s = JsonLoader.fromString(jsonSchema);    final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();    JsonValidator v = factory.getValidator();    ProcessingReport report = v.validate(s, d);    return report.toString().contains("success");}
private List<JSONObject> metron_f6354_0(String string)
{    Optional<MessageParserResult<JSONObject>> parse = parser.parseOptionalResult(string.getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(parse.isPresent());    return parse.get().getMessages();}
public void metron_f6355_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6356_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6357_0() throws Exception
{    parser = new BasicPaloAltoFirewallParser();}
public void metron_f6358_0() throws ParseException
{    final String SYSTEM_61 = "1,2017/08/11 12:37:58,008900008659,SYSTEM,general,1,2017/08/11 11:37:58,vsys1,eventId_test,object_test,Futureuse1_test,futureuse2_test,management,high,Description_test,1354,0x0";    JSONObject actual = parser.parse(SYSTEM_61.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "SYSTEM");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "general");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.EventId, "eventId_test");    expected.put(BasicPaloAltoFirewallParser.Object, "object_test");    expected.put(BasicPaloAltoFirewallParser.Module, "management");    expected.put(BasicPaloAltoFirewallParser.Severity, "high");    expected.put(BasicPaloAltoFirewallParser.Description, "Description_test");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 61);    expected.put("original_string", SYSTEM_61);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6359_0() throws ParseException
{    final String SYSTEM_80 = "1,2017/08/11 12:37:58,008900008659,SYSTEM,general,1,2017/08/11 11:37:58,vsys1,eventId_test,object_test,Futureuse1_test,futureuse2_test,management,high,Description_test,1354,0x0,12,34,45,0,virSys1,dev-something200-01";    JSONObject actual = parser.parse(SYSTEM_80.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "SYSTEM");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "general");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.EventId, "eventId_test");    expected.put(BasicPaloAltoFirewallParser.Object, "object_test");    expected.put(BasicPaloAltoFirewallParser.Module, "management");    expected.put(BasicPaloAltoFirewallParser.Severity, "high");    expected.put(BasicPaloAltoFirewallParser.Description, "Description_test");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "12");    expected.put(BasicPaloAltoFirewallParser.DGH2, "34");    expected.put(BasicPaloAltoFirewallParser.DGH3, "45");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.VSYSName, "virSys1");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "dev-something200-01");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put("original_string", SYSTEM_80);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6360_0() throws ParseException
{    final String CONFIG_61_customFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0";    JSONObject actual = parser.parse(CONFIG_61_customFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 61);    expected.put("original_string", CONFIG_61_customFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6361_0() throws ParseException
{    final String CONFIG_61_noCustomFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0,/FatherNode/KidNode/GrandsonNode1,/FatherNode/KidNode/GrandsonNode2";    JSONObject actual = parser.parse(CONFIG_61_noCustomFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.BeforeChangeDetail, "/FatherNode/KidNode/GrandsonNode1");    expected.put(BasicPaloAltoFirewallParser.AfterChangeDetail, "/FatherNode/KidNode/GrandsonNode2");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 61);    expected.put("original_string", CONFIG_61_noCustomFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6362_0() throws ParseException
{    final String CONFIG_70_80_noCustomFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0,12,34,45,0,virSys1,dev-something200-01";    JSONObject actual = parser.parse(CONFIG_70_80_noCustomFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "12");    expected.put(BasicPaloAltoFirewallParser.DGH2, "34");    expected.put(BasicPaloAltoFirewallParser.DGH3, "45");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.VSYSName, "virSys1");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "dev-something200-01");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put("original_string", CONFIG_70_80_noCustomFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6363_0() throws ParseException
{    final String CONFIG_70_80_customFields = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded,config shared log-settings config,/FatherNode/KidNode/GrandsonNode1,/FatherNode/KidNode/GrandsonNode2,1354,0x0,12,34,45,0,virSys1,dev-something200-01";    JSONObject actual = parser.parse(CONFIG_70_80_customFields.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/08/11 12:37:58");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "008900008659");    expected.put(BasicPaloAltoFirewallParser.Type, "CONFIG");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "0");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/08/11 11:37:58");    expected.put(BasicPaloAltoFirewallParser.HOST, "192.168.14.162");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.Command, "edit");    expected.put(BasicPaloAltoFirewallParser.Admin, "admin");    expected.put(BasicPaloAltoFirewallParser.Client, "Web");    expected.put(BasicPaloAltoFirewallParser.Result, "Succeeded");    expected.put(BasicPaloAltoFirewallParser.ConfigurationPath, "config shared log-settings config");    expected.put(BasicPaloAltoFirewallParser.BeforeChangeDetail, "/FatherNode/KidNode/GrandsonNode1");    expected.put(BasicPaloAltoFirewallParser.AfterChangeDetail, "/FatherNode/KidNode/GrandsonNode2");    expected.put(BasicPaloAltoFirewallParser.Seqno, "1354");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "12");    expected.put(BasicPaloAltoFirewallParser.DGH2, "34");    expected.put(BasicPaloAltoFirewallParser.DGH3, "45");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.VSYSName, "virSys1");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "dev-something200-01");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put("original_string", CONFIG_70_80_customFields);    expected.put("timestamp", actual.get("timestamp"));    assertEquals(expected, actual);}
public void metron_f6364_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_60.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "reset-both");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "web-browsing");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.Direction, "client-to-server");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "US");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x80004000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "internal");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/2");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "216.0.10.198");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "80");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "10.0.0.115");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "54180");    expected.put(BasicPaloAltoFirewallParser.LogAction, "LOG-Default");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", THREAT_60);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 60);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "1200568889751109656");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2015/01/05 05:38:58");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "EX-Allow");    expected.put(BasicPaloAltoFirewallParser.Seqno, "347368099");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0006C110285");    expected.put(BasicPaloAltoFirewallParser.SessionID, "12031");    expected.put(BasicPaloAltoFirewallParser.Severity, "high");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.SourceUser, "example\\user.name");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2015/01/05 05:38:58");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "vulnerability");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "HTTP: IIS Denial Of Service Attempt(40019)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2015/01/05 05:38:58");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "external");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "ad.aspx?f=300x250&id=12;tile=1;ord=67AF705D60B1119C0F18BEA336F9");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    assertEquals(expected, actual);}
public void metron_f6365_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_60.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "allow");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "ms-ds-smb");    expected.put(BasicPaloAltoFirewallParser.Bytes, "2229");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "942");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "1287");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.DestinationUser, "example\\\\user.name");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "30");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x401a");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "v_external");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/2");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "10.1.0.163");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "445");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "10.0.0.39");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "52688");    expected.put(BasicPaloAltoFirewallParser.LogAction, "LOG-Default");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", TRAFFIC_60);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.Packets, "10");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 60);    expected.put(BasicPaloAltoFirewallParser.PktsSent, "6");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2015/01/05 12:51:33");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "EX-Allow");    expected.put(BasicPaloAltoFirewallParser.Seqno, "17754932062");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0011C103117");    expected.put(BasicPaloAltoFirewallParser.SessionID, "33760927");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2015/01/05 12:51:01");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "end");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2015/01/05 12:51:33");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "v_internal");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    assertEquals(expected, actual);}
public void metron_f6366_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_70.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "reset-both");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "web-browsing");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "0");    expected.put(BasicPaloAltoFirewallParser.Direction, "server-to-client");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "10.0.0.0-10.255.255.255");    expected.put(BasicPaloAltoFirewallParser.DestinationUser, "user");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x400000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "Untrust");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "10.1.8.7");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "51787");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "217.1.2.3");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Std-Log-Forward");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "25025");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "214.123.1.2");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "217.1.2.3");    expected.put("original_string", THREAT_70);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "0");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/24 09:53:10");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "WLAN-Internet");    expected.put(BasicPaloAltoFirewallParser.Seqno, "329423829");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001801000001");    expected.put(BasicPaloAltoFirewallParser.SessionID, "49567");    expected.put(BasicPaloAltoFirewallParser.Severity, "medium");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "DE");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/24 09:53:10");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "virus");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "Virus/Win32.WGeneric.lumeo(2457399)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/24 09:53:10");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "wifi_zone");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "abcdef310.exe");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.URLIndex, "1");    expected.put(BasicPaloAltoFirewallParser.WFReportID, "0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "19");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6367_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_70.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "deny");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ActionSource, "from-policy");    expected.put(BasicPaloAltoFirewallParser.Application, "not-applicable");    expected.put(BasicPaloAltoFirewallParser.Bytes, "114");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "0");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "114");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "DE");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "0");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x0");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "intern");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "192.168.1.10");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "137");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "10.2.1.8");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "137");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Std-Log-Forward");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", TRAFFIC_70);    expected.put(BasicPaloAltoFirewallParser.Packets, "1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PktsReceived, "0");    expected.put(BasicPaloAltoFirewallParser.PktsSent, "1");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "udp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/25 21:38:13");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "DropLog");    expected.put(BasicPaloAltoFirewallParser.Seqno, "9953744");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001606000003");    expected.put(BasicPaloAltoFirewallParser.EndReason, "policy-deny");    expected.put(BasicPaloAltoFirewallParser.SessionID, "0");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "192.168.0.0-192.168.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/25 21:38:12");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "drop");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/25 21:38:13");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "VPN");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.DGH1, "19");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6368_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_71.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "deny");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ActionSource, "from-policy");    expected.put(BasicPaloAltoFirewallParser.Application, "not-applicable");    expected.put(BasicPaloAltoFirewallParser.Bytes, "60");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "0");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "60");    expected.put(BasicPaloAltoFirewallParser.Category, "any");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "0");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "DE");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "0");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x0");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "untrust");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "201.1.4.5");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "123");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "185.94.1.1");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "59836");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Standard-Syslog");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "0");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "0.0.0.0");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "0");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "0.0.0.0");    expected.put("original_string", TRAFFIC_71);    expected.put(BasicPaloAltoFirewallParser.Packets, "1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PktsReceived, "0");    expected.put(BasicPaloAltoFirewallParser.PktsSent, "1");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "udp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/31 23:59:57");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "DropLog");    expected.put(BasicPaloAltoFirewallParser.Seqno, "3433072193");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0006C000005");    expected.put(BasicPaloAltoFirewallParser.EndReason, "policy-deny");    expected.put(BasicPaloAltoFirewallParser.SessionID, "0");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "RU");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/31 23:59:57");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "drop");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/31 23:59:57");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "untrust");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.DGH1, "16");    expected.put(BasicPaloAltoFirewallParser.DGH2, "11");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6369_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_71.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "alert");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "ssl");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "0");    expected.put(BasicPaloAltoFirewallParser.Direction, "client-to-server");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "IE");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x40b000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "mgmt");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "vlan.199");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "140.177.26.29");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "192.168.1.7");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "56059");    expected.put(BasicPaloAltoFirewallParser.LogAction, "Standard-Syslog");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "140.177.26.29");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "14810");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "201.1.4.5");    expected.put("original_string", THREAT_71);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "vlan.1");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 70);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "0");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2017/05/25 19:31:13");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "ms_out");    expected.put(BasicPaloAltoFirewallParser.Seqno, "10030265");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "0006C000005");    expected.put(BasicPaloAltoFirewallParser.SessionID, "50556");    expected.put(BasicPaloAltoFirewallParser.Severity, "informational");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "192.168.0.0-192.168.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2017/05/25 19:31:13");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "url");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "(9999)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2017/05/25 19:31:13");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "untrust");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "settings-win.data.microsoft.com/");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.URLIndex, "0");    expected.put(BasicPaloAltoFirewallParser.WFReportID, "0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "16");    expected.put(BasicPaloAltoFirewallParser.DGH2, "11");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6370_0() throws ParseException
{    JSONObject actual = parser.parse(THREAT_80.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "reset-server");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.Application, "web-browsing");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.ContentVersion, "AppThreat-771-4450");    expected.put(BasicPaloAltoFirewallParser.Direction, "server-to-client");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "172.16.0.0-172.31.255.255");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x402000");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "internet");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "172.16.2.6");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "53161");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "213.211.198.62");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.LogAction, "test");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "32812");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "192.168.178.202");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "80");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "213.211.198.62");    expected.put("original_string", THREAT_80);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/2.2");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParentSessionId, "0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put(BasicPaloAltoFirewallParser.PCAPID, "0");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2018/02/01 21:29:03");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "Outgoing");    expected.put(BasicPaloAltoFirewallParser.Seqno, "27438839");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001606000007");    expected.put(BasicPaloAltoFirewallParser.SessionID, "18720");    expected.put(BasicPaloAltoFirewallParser.Severity, "medium");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "Germany");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2018/02/01 21:29:03");    expected.put(BasicPaloAltoFirewallParser.ThreatCategory, "code-execution");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "vulnerability");    expected.put(BasicPaloAltoFirewallParser.ThreatID, "Eicar File Detected(39040)");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2018/02/01 21:29:03");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "guest");    expected.put(BasicPaloAltoFirewallParser.TunnelId, "0");    expected.put(BasicPaloAltoFirewallParser.TunnelType, "N/A");    expected.put(BasicPaloAltoFirewallParser.Type, "THREAT");    expected.put(BasicPaloAltoFirewallParser.URL, "www.eicar.org/download/eicar.com");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.URLIndex, "9");    expected.put(BasicPaloAltoFirewallParser.WFReportID, "0");    expected.put(BasicPaloAltoFirewallParser.DGH1, "0");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6371_0() throws ParseException
{    JSONObject actual = parser.parse(TRAFFIC_80.getBytes(StandardCharsets.UTF_8)).get(0);    JSONObject expected = new JSONObject();    expected.put(BasicPaloAltoFirewallParser.Action, "allow");    expected.put(BasicPaloAltoFirewallParser.ActionFlags, "0x0");    expected.put(BasicPaloAltoFirewallParser.ActionSource, "from-policy");    expected.put(BasicPaloAltoFirewallParser.Application, "ssl");    expected.put(BasicPaloAltoFirewallParser.Bytes, "7936");    expected.put(BasicPaloAltoFirewallParser.BytesReceived, "6205");    expected.put(BasicPaloAltoFirewallParser.BytesSent, "1731");    expected.put(BasicPaloAltoFirewallParser.Category, "computer-and-internet-info");    expected.put(BasicPaloAltoFirewallParser.ConfigVersion, "1");    expected.put(BasicPaloAltoFirewallParser.DestinationLocation, "United States");    expected.put(BasicPaloAltoFirewallParser.ElapsedTimeInSec, "1395");    expected.put(BasicPaloAltoFirewallParser.Flags, "0x40001c");    expected.put(BasicPaloAltoFirewallParser.SourceZone, "guest");    expected.put(BasicPaloAltoFirewallParser.InboundInterface, "ethernet1/2.2");    expected.put(BasicPaloAltoFirewallParser.DestinationAddress, "134.19.6.22");    expected.put(BasicPaloAltoFirewallParser.DestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.SourceAddress, "172.16.2.31");    expected.put(BasicPaloAltoFirewallParser.SourcePort, "41537");    expected.put(BasicPaloAltoFirewallParser.LogAction, "test");    expected.put(BasicPaloAltoFirewallParser.NATDestinationPort, "443");    expected.put(BasicPaloAltoFirewallParser.NATDestinationIP, "134.19.6.22");    expected.put(BasicPaloAltoFirewallParser.NATSourcePort, "12211");    expected.put(BasicPaloAltoFirewallParser.NATSourceIP, "192.168.18.2");    expected.put("original_string", TRAFFIC_80);    expected.put(BasicPaloAltoFirewallParser.OutboundInterface, "ethernet1/1");    expected.put(BasicPaloAltoFirewallParser.Packets, "24");    expected.put(BasicPaloAltoFirewallParser.PaloAltoDomain, "1");    expected.put(BasicPaloAltoFirewallParser.ParentSessionId, "0");    expected.put(BasicPaloAltoFirewallParser.ParserVersion, 80);    expected.put(BasicPaloAltoFirewallParser.PktsReceived, "10");    expected.put(BasicPaloAltoFirewallParser.PktsSent, "14");    expected.put(BasicPaloAltoFirewallParser.IPProtocol, "tcp");    expected.put(BasicPaloAltoFirewallParser.ReceiveTime, "2018/02/01 21:24:11");    expected.put(BasicPaloAltoFirewallParser.RepeatCount, "1");    expected.put(BasicPaloAltoFirewallParser.Rule, "Outgoing");    expected.put(BasicPaloAltoFirewallParser.Seqno, "62977478");    expected.put(BasicPaloAltoFirewallParser.SerialNum, "001606000007");    expected.put(BasicPaloAltoFirewallParser.EndReason, "tcp-rst-from-client");    expected.put(BasicPaloAltoFirewallParser.SessionID, "19468");    expected.put(BasicPaloAltoFirewallParser.SourceLocation, "172.16.0.0-172.31.255.255");    expected.put(BasicPaloAltoFirewallParser.StartTime, "2018/02/01 21:00:42");    expected.put(BasicPaloAltoFirewallParser.ThreatContentType, "end");    expected.put(BasicPaloAltoFirewallParser.GenerateTime, "2018/02/01 21:24:11");    expected.put("timestamp", actual.get("timestamp"));    expected.put(BasicPaloAltoFirewallParser.DestinationZone, "internet");    expected.put(BasicPaloAltoFirewallParser.TunnelId, "0");    expected.put(BasicPaloAltoFirewallParser.TunnelType, "N/A");    expected.put(BasicPaloAltoFirewallParser.Type, "TRAFFIC");    expected.put(BasicPaloAltoFirewallParser.VirtualSystem, "vsys1");    expected.put(BasicPaloAltoFirewallParser.DGH1, "0");    expected.put(BasicPaloAltoFirewallParser.DGH2, "0");    expected.put(BasicPaloAltoFirewallParser.DGH3, "0");    expected.put(BasicPaloAltoFirewallParser.DGH4, "0");    expected.put(BasicPaloAltoFirewallParser.DeviceName, "PAN1");    assertEquals(expected, actual);}
public void metron_f6372_0() throws ParseException
{    final String unsupportedLogTypeMessage = "1,2017/08/11 12:37:58,008900008659,INVALIDlogType,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config,1354,0x0";    List<JSONObject> actual = parser.parse(unsupportedLogTypeMessage.getBytes(StandardCharsets.UTF_8));    assertNull(actual);}
public void metron_f6373_0() throws ParseException
{    final String invalidLengthMessage = "1,2017/08/11 12:37:58,008900008659,CONFIG,0,1,2017/08/11 11:37:58,192.168.14.162,vsys1,edit,admin,Web,Succeeded, config shared log-settings config";    JSONObject actual = parser.parse(invalidLengthMessage.getBytes(StandardCharsets.UTF_8)).get(0);    String expectedParserVersion = actual.get(BasicPaloAltoFirewallParser.ParserVersion).toString();    assertEquals(expectedParserVersion, "0");}
public void metron_f6374_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6375_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6376_0()
{    BasicSnortParser parser = new BasicSnortParser();    parser.configure(new HashMap());    Map out = parser.parse(goodMessage.getBytes(StandardCharsets.UTF_8)).get(0);    Assert.assertEquals(out.get("msg"), "Consecutive TCP small segments, exceeding threshold");    Assert.assertEquals(out.get("sig_rev"), "1");    Assert.assertEquals(out.get("ip_dst_addr"), "10.0.2.15");    Assert.assertEquals(out.get("ip_dst_port"), "22");    Assert.assertEquals(out.get("ethsrc"), "52:54:00:12:35:02");    Assert.assertEquals(out.get("tcpseq"), "0x9AFF3D7");    Assert.assertEquals(out.get("dgmlen"), "64");    Assert.assertEquals(out.get("icmpid"), "");    Assert.assertEquals(out.get("tcplen"), "");    Assert.assertEquals(out.get("tcpwindow"), "0xFFFF");    Assert.assertEquals(out.get("icmpseq").toString().trim(), "");    Assert.assertEquals(out.get("tcpack"), "0xC8761D52");    Assert.assertEquals(out.get("icmpcode"), "");    Assert.assertEquals(out.get("tos"), "0");    Assert.assertEquals(out.get("id"), "59677");    Assert.assertEquals(out.get("ethdst"), "08:00:27:7F:93:2D");    Assert.assertEquals(out.get("ip_src_addr"), "10.0.2.2");    Assert.assertEquals(out.get("ttl"), "64");    Assert.assertEquals(out.get("ethlen"), "0x4E");    Assert.assertEquals(out.get("iplen"), "65536");    Assert.assertEquals(out.get("icmptype"), "");    Assert.assertEquals(out.get("protocol"), "TCP");    Assert.assertEquals(out.get("ip_src_port"), "56642");    Assert.assertEquals(out.get("tcpflags"), "***AP***");    Assert.assertEquals(out.get("sig_id"), "12");    Assert.assertEquals(out.get("sig_generator"), "129");    Assert.assertEquals(out.get("is_alert"), "true");}
public void metron_f6377_0()
{    thrown.expect(IllegalStateException.class);    BasicSnortParser parser = new BasicSnortParser();    parser.init();    UnitTestHelper.setLog4jLevel(BasicSnortParser.class, Level.FATAL);    parser.parse("foo bar".getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicSnortParser.class, Level.ERROR);}
public void metron_f6378_0()
{        TimeZone defaultTimeZone = TimeZone.getDefault();    try {        TimeZone.setDefault(TimeZone.getTimeZone(ZoneId.of("America/New_York")));        BasicSnortParser parser = new BasicSnortParser();        parser.configure(new HashMap());        Map out = parser.parse(goodMessage.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertEquals(out.get("timestamp"), 1453928464877L);    } finally {                TimeZone.setDefault(defaultTimeZone);    }}
public void metron_f6379_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("dateFormat", "MM/dd/yyyy-HH:mm:ss.SSSSSS");    parserConfig.put("timeZone", "America/New_York");    BasicSnortParser parser = new BasicSnortParser();    parser.configure(parserConfig);    Map result = parser.parse(dateFormattedMessage.getBytes(StandardCharsets.UTF_8)).get(0);    assertThat("timestamp should match", result.get(Constants.Fields.TIMESTAMP.getName()), equalTo(1453928464877L));}
public void metron_f6380_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage(startsWith("Unable to find ZoneId"));    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("dateFormat", "MM/dd/yyyy-HH:mm:ss.SSSSSS");    parserConfig.put("timeZone", "blahblahBADZONE");    BasicSnortParser parser = new BasicSnortParser();    parser.configure(parserConfig);}
public void metron_f6381_0()
{    thrown.expect(IllegalArgumentException.class);    thrown.expectMessage(startsWith("Unknown pattern letter:"));    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("dateFormat", "BADFORMAT");    BasicSnortParser parser = new BasicSnortParser();    parser.configure(parserConfig);}
public void metron_f6382_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    BasicSnortParser parser = new BasicSnortParser();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6383_0()
{    Map<String, Object> config = new HashMap<>();    BasicSnortParser parser = new BasicSnortParser();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6384_0() throws Exception
{    inputStrings = super.readTestDataFromFile("src/test/resources/logData/SourcefireParserTest.txt");    parser = new BasicSourcefireParser();}
public void metron_f6385_0() throws ParseException
{    for (String inputString : inputStrings) {        byte[] srcBytes = inputString.getBytes(StandardCharsets.UTF_8);        JSONObject parsed = parser.parse(inputString.getBytes(StandardCharsets.UTF_8)).get(0);        Assert.assertNotNull(parsed);        JSONParser parser = new JSONParser();        Map json = (Map) parser.parse(parsed.toJSONString());        for (Object o : json.entrySet()) {            Entry entry = (Entry) o;            String key = (String) entry.getKey();            String value = json.get("original_string").toString();            Assert.assertNotNull(value);        }    }}
public void metron_f6386_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6387_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public Map<String, String> metron_f6388_0()
{    String input1 = "1461576382.642    161 127.0.0.1 TCP_MISS/200 103701 GET http://www.cnn.com/ - DIRECT/199.27.79.73 text/html";    String input2 = "1469539185.270      0 139.196.181.68 TCP_DENIED/403 3617 CONNECT search.yahoo.com:443 - NONE/- text/html";    HashMap testData = new HashMap<String, String>();    testData.put(input1, result1);    testData.put(input2, result2);    return testData;}
public String metron_f6389_0()
{    return "false";}
public String metron_f6390_0()
{    return "../metron-parsers/src/main/resources/patterns/squid";}
public String metron_f6391_0()
{    return "SQUID_DELIMITED";}
public List<String> metron_f6392_0()
{    return new ArrayList<>();}
public String metron_f6393_0()
{    return null;}
public String metron_f6394_0()
{    return "timestamp";}
public void metron_f6395_0()
{    parserConfig = new HashMap<>();    parserConfig.put("grokPath", "src/main/resources/patterns/websphere");    parserConfig.put("patternLabel", "WEBSPHERE");    parserConfig.put("timestampField", "timestamp_string");    parserConfig.put("dateFormat", "yyyy MMM dd HH:mm:ss");    parser = new GrokWebSphereParser();    parser.configure(parserConfig);}
public void metron_f6396_0() throws Exception
{    String testString = "<133>Apr 15 17:47:28 ABCXML1413 [rojOut][0x81000033][auth][notice] user(rick007): " + "[120.43.200.6]: User logged into 'cohlOut'.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 47, 28, 0, UTC).toInstant().toEpochMilli();        assertEquals(133, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ABCXML1413", parsedJSON.get("hostname"));    assertEquals("rojOut", parsedJSON.get("security_domain"));    assertEquals("0x81000033", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("notice", parsedJSON.get("severity"));    assertEquals("login", parsedJSON.get("event_subtype"));    assertEquals("rick007", parsedJSON.get("username"));    assertEquals("120.43.200.6", parsedJSON.get("ip_src_addr"));}
public void metron_f6397_0() throws Exception
{    String testString = "<134>Apr 15 18:02:27 PHIXML3RWD [0x81000019][auth][info] [14.122.2.201]: " + "User 'hjpotter' logged out from 'default'.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 18, 2, 27, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("PHIXML3RWD", parsedJSON.get("hostname"));    assertEquals("0x81000019", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals("14.122.2.201", parsedJSON.get("ip_src_addr"));    assertEquals("hjpotter", parsedJSON.get("username"));    assertEquals("default", parsedJSON.get("security_domain"));}
public void metron_f6398_0() throws Exception
{    String testString = "<131>Apr 15 17:36:35 ROBXML3QRS [0x80800018][auth][error] rbm(RBM-Settings): " + "trans(3502888135)[request] gtid(3502888135): RBM: Resource access denied.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 36, 35, 0, UTC).toInstant().toEpochMilli();        assertEquals(131, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ROBXML3QRS", parsedJSON.get("hostname"));    assertEquals("0x80800018", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("error", parsedJSON.get("severity"));    assertEquals("rbm", parsedJSON.get("process"));    assertEquals("trans(3502888135)[request] gtid(3502888135): RBM: Resource access denied.", parsedJSON.get("message"));}
public void metron_f6399_0() throws Exception
{    String testString = "<134>Apr 15 17:17:34 SAGPXMLQA333 [0x8240001c][audit][info] trans(191): (admin:default:system:*): " + "ntp-service 'NTP Service' - Operational state down";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 17, 34, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("SAGPXMLQA333", parsedJSON.get("hostname"));    assertEquals("0x8240001c", parsedJSON.get("event_code"));    assertEquals("audit", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals("trans", parsedJSON.get("process"));    assertEquals("(admin:default:system:*): ntp-service 'NTP Service' - Operational state down", parsedJSON.get("message"));}
public void metron_f6400_0() throws Exception
{    String testString = "<133>Apr 15 17:47:28 ABCXML1413 [rojOut][0x81000033][auth][notice] rick007): " + "[120.43.200. User logged into 'cohlOut'.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 47, 28, 0, UTC).toInstant().toEpochMilli();        assertEquals(133, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ABCXML1413", parsedJSON.get("hostname"));    assertEquals("rojOut", parsedJSON.get("security_domain"));    assertEquals("0x81000033", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("notice", parsedJSON.get("severity"));    assertEquals("login", parsedJSON.get("event_subtype"));    assertEquals(null, parsedJSON.get("username"));    assertEquals(null, parsedJSON.get("ip_src_addr"));}
public void metron_f6401_0() throws Exception
{    String testString = "<134>Apr 15 18:02:27 PHIXML3RWD [0x81000019][auth][info] [14.122.2.201: " + "User 'hjpotter' logged out from 'default.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 18, 2, 27, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("PHIXML3RWD", parsedJSON.get("hostname"));    assertEquals("0x81000019", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals(null, parsedJSON.get("ip_src_addr"));    assertEquals(null, parsedJSON.get("username"));    assertEquals(null, parsedJSON.get("security_domain"));}
public void metron_f6402_0() throws Exception
{    String testString = "<131>Apr 15 17:36:35 ROBXML3QRS [0x80800018][auth][error] rbmRBM-Settings): " + "trans3502888135)[request] gtid3502888135) RBM: Resource access denied.";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 36, 35, 0, UTC).toInstant().toEpochMilli();        assertEquals(131, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("ROBXML3QRS", parsedJSON.get("hostname"));    assertEquals("0x80800018", parsedJSON.get("event_code"));    assertEquals("auth", parsedJSON.get("event_type"));    assertEquals("error", parsedJSON.get("severity"));    assertEquals(null, parsedJSON.get("process"));    assertEquals("rbmRBM-Settings): trans3502888135)[request] gtid3502888135) RBM: Resource access denied.", parsedJSON.get("message"));}
public void metron_f6403_0() throws Exception
{    String testString = "<134>Apr 15 17:17:34 SAGPXMLQA333 [0x8240001c][audit][info] trans 191)  admindefaultsystem*): " + "ntp-service 'NTP Service' - Operational state down:";    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(testString.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> result = resultOptional.get().getMessages();    JSONObject parsedJSON = result.get(0);    long expectedTimestamp = ZonedDateTime.of(Year.now(UTC).getValue(), 4, 15, 17, 17, 34, 0, UTC).toInstant().toEpochMilli();        assertEquals(134, parsedJSON.get("priority"));    assertEquals(expectedTimestamp, parsedJSON.get("timestamp"));    assertEquals("SAGPXMLQA333", parsedJSON.get("hostname"));    assertEquals("0x8240001c", parsedJSON.get("event_code"));    assertEquals("audit", parsedJSON.get("event_type"));    assertEquals("info", parsedJSON.get("severity"));    assertEquals(null, parsedJSON.get("process"));    assertEquals("trans 191)  admindefaultsystem*): ntp-service 'NTP Service' - Operational state down:", parsedJSON.get("message"));}
public void metron_f6404_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6405_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public Map metron_f6406_0()
{    Map testData = new HashMap<String, String>();    String input = "2016-01-28 15:29:48.512|2016-01-28 15:29:48.512|   0.000|   0.000|  6|                          216.21.170.221|   80|                               10.0.2.15|39468|      AS|       0|       0|       0|22efa001|00000000|000|000|       1|      44|       0|       0|    0|idle";    testData.put(input, result);    return testData;}
public String metron_f6407_0()
{    return "false";}
public String metron_f6408_0()
{    return "../metron-parsers/src/main/resources/patterns/yaf";}
public String metron_f6409_0()
{    return "YAF_DELIMITED";}
public List<String> metron_f6410_0()
{    return new ArrayList<String>() {        {            add("start_time");            add("end_time");        }    };}
public String metron_f6411_0()
{    return "yyyy-MM-dd HH:mm:ss.S";}
public String metron_f6412_0()
{    return "start_time";}
public boolean metron_f6413_0(JSONObject message)
{    JSONObject value = message;    final String invalidMessageTemplate = "[Metron] Message does not have {}: {}";    if (!(value.containsKey(ORIGINAL.getName()))) {        LOG.trace(invalidMessageTemplate, ORIGINAL.getName(), message);        return false;    } else if (!(value.containsKey(TIMESTAMP.getName()))) {        LOG.trace(invalidMessageTemplate, TIMESTAMP.getName(), message);        return false;    } else {        LOG.trace("[Metron] Message conforms to schema: {}", message);        return true;    }}
public String metron_f6414_0(JSONObject value)
{    try {        String ipSrcAddr = null;        String ipDstAddr = null;        if (value.containsKey(SRC_ADDR.getName()))            ipSrcAddr = value.get(SRC_ADDR.getName()).toString();        if (value.containsKey(DST_ADDR.getName()))            ipDstAddr = value.get(DST_ADDR.getName()).toString();        if (ipSrcAddr == null && ipDstAddr == null)            return "0";        if (ipSrcAddr == null || ipSrcAddr.length() == 0)            return ipDstAddr;        if (ipDstAddr == null || ipDstAddr.length() == 0)            return ipSrcAddr;        double ip1 = Double.parseDouble(ipSrcAddr.replace(".", ""));        double ip2 = Double.parseDouble(ipDstAddr.replace(".", ""));        return String.valueOf(ip1 + ip2);    } catch (Exception e) {        return "0";    }}
public void metron_f6415_0(Map<String, Object> config)
{    if (config.containsKey(READ_CHARSET)) {        readCharset = Charset.forName((String) config.get(READ_CHARSET));    } else {        readCharset = MessageParser.super.getReadCharset();    }}
public Charset metron_f6416_0()
{    return null == this.readCharset ? MessageParser.super.getReadCharset() : this.readCharset;}
public void metron_f6417_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    converter = new CSVConverter();    converter.initialize(parserConfig);    Object tsFormatObj = parserConfig.get(TIMESTAMP_FORMAT_CONF);    if (tsFormatObj != null) {        timestampFormat = new SimpleDateFormat(tsFormatObj.toString());    }}
public List<JSONObject> metron_f6419_1(byte[] rawMessage)
{    try {        String msg = new String(rawMessage, getReadCharset());        Map<String, String> value = converter.toMap(msg);        if (value != null) {            value.put("original_string", msg);            Object timestampObj = value.get("timestamp");            Long timestamp = null;            if (timestampObj == null) {                timestamp = System.currentTimeMillis();            } else {                if (timestampFormat == null) {                    timestamp = ConversionUtils.convert(timestampObj, Long.class);                } else {                    try {                        timestamp = timestampFormat.parse(timestampObj.toString()).getTime();                    } catch (Exception e) {                                            }                }            }            JSONObject jsonVal = new JSONObject(value);            if (timestamp != null) {                jsonVal.put("timestamp", timestamp);            }            return ImmutableList.of(jsonVal);        } else {            return Collections.emptyList();        }    } catch (Throwable e) {        String message = "Unable to parse " + new String(rawMessage, getReadCharset()) + ": " + e.getMessage();                throw new IllegalStateException(message, e);    }}
public void metron_f6420_0(T message)
{    messages.add(message);}
public void metron_f6421_0(Object message, Throwable throwable)
{    errors.put(message, throwable);}
public List<T> metron_f6422_0()
{    return messages;}
public Map<Object, Throwable> metron_f6423_0()
{    return errors;}
public Optional<Throwable> metron_f6424_0()
{    return Optional.ofNullable(masterThrowable);}
public List<JSONObject> metron_f6425_0()
{    return messages;}
public List<MetronError> metron_f6426_0()
{    return errors;}
public void metron_f6427_0(JSONObject message)
{    this.messages.add(message);}
public void metron_f6428_0(MetronError error)
{    this.errors.add(error);}
public void metron_f6429_0(List<MetronError> errors)
{    this.errors.addAll(errors);}
public boolean metron_f6430_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ParserRunnerResults parserResult = (ParserRunnerResults) o;    return Objects.equals(messages, parserResult.getMessages()) && Objects.equals(errors, parserResult.getErrors());}
public int metron_f6431_0()
{    int result = messages != null ? messages.hashCode() : 0;    result = 31 * result + (errors != null ? errors.hashCode() : 0);    return result;}
public void metron_f6432_0(Map<String, Object> config)
{    Object protocolsObj = config.get("bro.filter.source.known.protocols");    Object keyObj = config.get("bro.filter.source.key");    if (keyObj != null) {        _key = keyObj.toString();    }    if (protocolsObj != null) {        if (protocolsObj instanceof String) {            _known_protocols.clear();            _known_protocols.add(protocolsObj.toString());        } else if (protocolsObj instanceof List) {            _known_protocols.clear();            for (Object o : (List) protocolsObj) {                _known_protocols.add(o.toString());            }        }    }}
public boolean metron_f6433_0(JSONObject message, Context context)
{    String protocol = (String) message.get(_key);    return _known_protocols.contains(protocol);}
public static MessageFilter<JSONObject> metron_f6434_0(String filterName, Map<String, Object> config)
{    if (filterName == null || filterName.trim().isEmpty()) {        return null;    }    Class<? extends MessageFilter> filterClass;    try {        Filters f = Filters.valueOf(filterName);        filterClass = f.clazz;    } catch (Exception ex) {        try {            filterClass = (Class<? extends MessageFilter>) Class.forName(filterName);        } catch (ClassNotFoundException e) {            throw new IllegalStateException("Unable to find class " + filterName, e);        }    }    if (filterClass != null) {        MessageFilter<JSONObject> filter = ReflectionUtils.createInstance(filterClass);        filter.configure(config);        return filter;    }    return null;}
public void metron_f6435_0(Map<String, Object> config)
{    Object o = config.get(QUERY_STRING_CONF);    if (o instanceof String) {        query = o.toString();    }    Context stellarContext = (Context) config.get("stellarContext");    if (stellarContext == null) {        stellarContext = Context.EMPTY_CONTEXT();    }    processor.validate(query, true, stellarContext);}
public boolean metron_f6436_0(JSONObject message, Context context)
{    VariableResolver resolver = new MapVariableResolver(message);    return processor.parse(query, resolver, functionResolver, context);}
public void metron_f6437_1(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    this.grokPath = (String) parserConfig.get("grokPath");    String multiLineString = (String) parserConfig.get("multiLine");    if (!StringUtils.isBlank(multiLineString)) {        multiLine = Boolean.parseBoolean(multiLineString);    }    this.patternLabel = (String) parserConfig.get("patternLabel");    this.timestampField = (String) parserConfig.get("timestampField");    List<String> timeFieldsParam = (List<String>) parserConfig.get("timeFields");    if (timeFieldsParam != null) {        this.timeFields = timeFieldsParam;    }    String dateFormatParam = (String) parserConfig.get("dateFormat");    if (dateFormatParam != null) {        this.dateFormat = new SimpleDateFormat(dateFormatParam);    }    String timeZoneParam = (String) parserConfig.get("timeZone");    if (timeZoneParam != null) {        dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneParam));            } else {        dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));            }}
public InputStream metron_f6438_1(String streamName) throws IOException
{    FileSystem fs = FileSystem.get(new Configuration());    Path path = new Path(streamName);    if (fs.exists(path)) {                return fs.open(path);    } else {                return getClass().getResourceAsStream(streamName);    }}
public void metron_f6439_1()
{    grok = new Grok();    try {        InputStream commonInputStream = openInputStream(patternsCommonDir);                if (commonInputStream == null) {            throw new RuntimeException("Unable to initialize grok parser: Unable to load " + patternsCommonDir + " from either classpath or HDFS");        }        grok.addPatternFromReader(new InputStreamReader(commonInputStream, getReadCharset()));                InputStream patterInputStream = openInputStream(grokPath);        if (patterInputStream == null) {            throw new RuntimeException("Grok parser unable to initialize grok parser: Unable to load " + grokPath + " from either classpath or HDFS");        }        grok.addPatternFromReader(new InputStreamReader(patterInputStream, getReadCharset()));                String grokPattern = "%{" + patternLabel + "}";        grok.compile(grokPattern);            } catch (Throwable e) {                throw new RuntimeException("Grok parser Error: " + e.getMessage(), e);    }}
public Optional<MessageParserResult<JSONObject>> metron_f6440_0(byte[] rawMessage)
{    if (grok == null) {        init();    }    if (multiLine) {        return parseMultiLine(rawMessage);    }    return parseSingleLine(rawMessage);}
private Optional<MessageParserResult<JSONObject>> metron_f6441_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    Map<Object, Throwable> errors = new HashMap<>();    String originalMessage = null;        try (BufferedReader reader = new BufferedReader(new StringReader(new String(rawMessage, getReadCharset())))) {        while ((originalMessage = reader.readLine()) != null) {                        try {                Match gm = grok.match(originalMessage);                gm.captures();                JSONObject message = new JSONObject();                message.putAll(gm.toMap());                if (message.size() == 0) {                    Throwable rte = new RuntimeException("Grok statement produced a null message. Original message was: " + originalMessage + " and the parsed message was: " + message + " . Check the pattern at: " + grokPath);                    errors.put(originalMessage, rte);                    continue;                }                message.put("original_string", originalMessage);                for (String timeField : timeFields) {                    String fieldValue = (String) message.get(timeField);                    if (fieldValue != null) {                        message.put(timeField, toEpoch(fieldValue));                    }                }                if (timestampField != null) {                    message.put(Constants.Fields.TIMESTAMP.getName(), formatTimestamp(message.get(timestampField)));                }                message.remove(patternLabel);                postParse(message);                messages.add(message);                            } catch (Exception e) {                                errors.put(originalMessage, e);            }        }    } catch (IOException e) {                Exception innerException = new IllegalStateException("Grok parser Error: " + e.getMessage() + " on " + originalMessage, e);        return Optional.of(new DefaultMessageParserResult<>(innerException));    }    return Optional.of(new DefaultMessageParserResult<>(messages, errors));}
private Optional<MessageParserResult<JSONObject>> metron_f6442_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    Map<Object, Throwable> errors = new HashMap<>();    String originalMessage = null;    try {        originalMessage = new String(rawMessage, StandardCharsets.UTF_8);                Match gm = grok.match(originalMessage);        gm.captures();        JSONObject message = new JSONObject();        message.putAll(gm.toMap());        if (message.size() == 0) {            Throwable rte = new RuntimeException("Grok statement produced a null message. Original message was: " + originalMessage + " and the parsed message was: " + message + " . Check the pattern at: " + grokPath);            errors.put(originalMessage, rte);        } else {            message.put("original_string", originalMessage);            for (String timeField : timeFields) {                String fieldValue = (String) message.get(timeField);                if (fieldValue != null) {                    message.put(timeField, toEpoch(fieldValue));                }            }            if (timestampField != null) {                message.put(Constants.Fields.TIMESTAMP.getName(), formatTimestamp(message.get(timestampField)));            }            message.remove(patternLabel);            postParse(message);            messages.add(message);                    }    } catch (Exception e) {                Exception innerException = new IllegalStateException("Grok parser Error: " + e.getMessage() + " on " + originalMessage, e);        return Optional.of(new DefaultMessageParserResult<>(innerException));    }    return Optional.of(new DefaultMessageParserResult<JSONObject>(messages, errors));}
public boolean metron_f6443_1(JSONObject message)
{        Object timestampObject = message.get(Constants.Fields.TIMESTAMP.getName());    if (timestampObject instanceof Long) {        Long timestamp = (Long) timestampObject;        if (timestamp > 0) {                        return true;        }    }        return false;}
protected long metron_f6445_1(String datetime) throws ParseException
{            Date date = dateFormat.parse(datetime);        return date.getTime();}
protected long metron_f6446_1(Object value)
{        if (value == null) {        throw new RuntimeException(patternLabel + " pattern does not include field " + timestampField);    }    if (value instanceof Number) {        return ((Number) value).longValue();    } else {        return Long.parseLong(Joiner.on("").join(Splitter.on('.').split(value + "")));    }}
public void metron_f6447_0(Map<String, Object> config)
{    if (config.containsKey(READ_CHARSET)) {        readCharset = Charset.forName((String) config.get(READ_CHARSET));    } else {        readCharset = MessageParser.super.getReadCharset();    }}
public Charset metron_f6448_0()
{    return null == this.readCharset ? MessageParser.super.getReadCharset() : this.readCharset;}
 List<T> metron_f6449_0(byte[] rawMessage)
{    throw new NotImplementedException("parse is not implemented");}
 Optional<List<T>> metron_f6450_0(byte[] parseMessage)
{    return Optional.ofNullable(parse(parseMessage));}
 Optional<MessageParserResult<T>> metron_f6451_0(byte[] parseMessage)
{    Optional<MessageParserResult<T>> result = Optional.empty();    try {        Optional<List<T>> optionalMessages = parseOptional(parseMessage);        if (optionalMessages.isPresent()) {            result = Optional.of(new DefaultMessageParserResult<>(optionalMessages.get()));        }    } catch (Throwable t) {        return Optional.of(new DefaultMessageParserResult<>(t));    }    return result;}
 Charset metron_f6452_0()
{    return StandardCharsets.UTF_8;}
private static JSONObject metron_f6453_0(String key, Map value, JSONObject obj)
{    Set<Map.Entry<Object, Object>> entrySet = value.entrySet();    for (Map.Entry<Object, Object> kv : entrySet) {        String newKey = Joiner.on(".").join(key, kv.getKey().toString());        if (kv.getValue() instanceof Map) {            recursiveUnfold(newKey, (Map) kv.getValue(), obj);        } else {            obj.put(newKey, kv.getValue());        }    }    return obj;}
public JSONObject metron_f6454_0(String key, Map value, JSONObject obj)
{    return handler.handle(key, value, obj);}
public void metron_f6455_0(Map<String, Object> config)
{    setReadCharset(config);    String strategyStr = (String) config.getOrDefault(MAP_STRATEGY_CONFIG, MapStrategy.DROP.name());    mapStrategy = MapStrategy.valueOf(strategyStr);    overrideOriginalString = (Boolean) config.getOrDefault(OVERRIDE_ORIGINAL_STRING, false);    if (config.containsKey(JSONP_QUERY)) {        typeRef = new TypeRef<List<Map<String, Object>>>() {        };        jsonpQuery = (String) config.get(JSONP_QUERY);        if (!StringUtils.isBlank(jsonpQuery) && config.containsKey(WRAP_JSON)) {            Object wrapObject = config.get(WRAP_JSON);            if (wrapObject instanceof String) {                wrapJson = Boolean.valueOf((String) wrapObject);            } else if (wrapObject instanceof Boolean) {                wrapJson = (Boolean) config.get(WRAP_JSON);            }            String entityName = (String) config.get(WRAP_ENTITY_NAME);            if (!StringUtils.isBlank(entityName)) {                wrapEntityName = entityName;            }        }        Configuration.setDefaults(new Configuration.Defaults() {            private final JsonProvider jsonProvider = new JacksonJsonProvider();            private final MappingProvider mappingProvider = new JacksonMappingProvider();            @Override            public JsonProvider jsonProvider() {                return jsonProvider;            }            @Override            public MappingProvider mappingProvider() {                return mappingProvider;            }            @Override            public Set<Option> options() {                return EnumSet.of(Option.SUPPRESS_EXCEPTIONS);            }        });        if (CacheProvider.getCache() == null) {            CacheProvider.setCache(new LRUCache(100));        }    }}
public JsonProvider metron_f6456_0()
{    return jsonProvider;}
public MappingProvider metron_f6457_0()
{    return mappingProvider;}
public Set<Option> metron_f6458_0()
{    return EnumSet.of(Option.SUPPRESS_EXCEPTIONS);}
public List<JSONObject> metron_f6460_1(byte[] rawMessage)
{    try {        String rawString = new String(rawMessage, getReadCharset());        List<Map<String, Object>> messages = new ArrayList<>();                if (wrapJson) {            rawString = wrapMessageJson(rawString);        }        if (!StringUtils.isEmpty(jsonpQuery)) {            Object parsedObject = JsonPath.parse(rawString).read(jsonpQuery, typeRef);            if (parsedObject != null) {                messages.addAll((List<Map<String, Object>>) parsedObject);            }        } else {            messages.add(JSONUtils.INSTANCE.load(rawString, JSONUtils.MAP_SUPPLIER));        }        ArrayList<JSONObject> parsedMessages = new ArrayList<>();        for (Map<String, Object> rawMessageMap : messages) {            JSONObject ret = normalizeJson(rawMessageMap);            if (overrideOriginalString) {                                                JSONObject originalJsonObject = new JSONObject(rawMessageMap);                ret.put("original_string", originalJsonObject.toJSONString());            }            if (!ret.containsKey("timestamp")) {                ret.put("timestamp", System.currentTimeMillis());            }            parsedMessages.add(ret);        }        return Collections.unmodifiableList(parsedMessages);    } catch (Throwable e) {        String message = "Unable to parse " + new String(rawMessage, getReadCharset()) + ": " + e.getMessage();                throw new IllegalStateException(message, e);    }}
private JSONObject metron_f6461_0(Map<String, Object> map)
{    JSONObject ret = new JSONObject();    for (Map.Entry<String, Object> kv : map.entrySet()) {        if (kv.getValue() instanceof Map) {            mapStrategy.handle(kv.getKey(), (Map) kv.getValue(), ret);        } else {            ret.put(kv.getKey(), kv.getValue());        }    }    return ret;}
private String metron_f6462_0(String jsonMessage)
{    String base = new StringBuilder(String.format(WRAP_START_FMT, wrapEntityName)).append(jsonMessage).toString().trim();    if (base.endsWith(",")) {        base = base.substring(0, base.length() - 1);    }    return base + WRAP_END;}
public MessageParser<JSONObject> metron_f6463_0()
{    return messageParser;}
public MessageFilter<JSONObject> metron_f6464_0()
{    return filter;}
public void metron_f6465_0(MessageParser<JSONObject> messageParser)
{    this.messageParser = messageParser;}
public void metron_f6466_0(MessageFilter<JSONObject> filter)
{    this.filter = filter;}
public JSONObject metron_f6467_0()
{    return message;}
public MetronError metron_f6468_0()
{    return error;}
public boolean metron_f6469_0()
{    return error != null;}
public Map<String, ParserComponent> metron_f6470_0()
{    return sensorToParserComponentMap;}
public void metron_f6471_0(Map<String, ParserComponent> sensorToParserComponentMap)
{    this.sensorToParserComponentMap = sensorToParserComponentMap;}
public Context metron_f6472_0()
{    return stellarContext;}
public Set<String> metron_f6473_0()
{    return sensorTypes;}
public void metron_f6474_0(Supplier<ParserConfigurations> parserConfigSupplier, Context stellarContext)
{    if (parserConfigSupplier == null) {        throw new IllegalStateException("A parser config supplier must be set before initializing the ParserRunner.");    }    if (stellarContext == null) {        throw new IllegalStateException("A stellar context must be set before initializing the ParserRunner.");    }    this.stellarContext = stellarContext;    initializeParsers(parserConfigSupplier);}
public ParserRunnerResults<JSONObject> metron_f6475_0(String sensorType, RawMessage rawMessage, ParserConfigurations parserConfigurations)
{    DefaultParserRunnerResults parserRunnerResults = new DefaultParserRunnerResults();    SensorParserConfig sensorParserConfig = parserConfigurations.getSensorParserConfig(sensorType);    if (sensorParserConfig != null) {        MessageParser<JSONObject> parser = sensorToParserComponentMap.get(sensorType).getMessageParser();        Optional<MessageParserResult<JSONObject>> optionalMessageParserResult = parser.parseOptionalResult(rawMessage.getMessage());        if (optionalMessageParserResult.isPresent()) {            MessageParserResult<JSONObject> messageParserResult = optionalMessageParserResult.get();                        messageParserResult.getMessages().forEach(message -> {                Optional<ProcessResult> processResult = processMessage(sensorType, message, rawMessage, parser, parserConfigurations);                if (processResult.isPresent()) {                    if (processResult.get().isError()) {                        parserRunnerResults.addError(processResult.get().getError());                    } else {                        parserRunnerResults.addMessage(processResult.get().getMessage());                    }                }            });                        messageParserResult.getMasterThrowable().ifPresent(throwable -> parserRunnerResults.addError(new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(throwable).withSensorType(Collections.singleton(sensorType)).withMetadata(rawMessage.getMetadata()).addRawMessage(rawMessage.getMessage())));                        parserRunnerResults.addErrors(messageParserResult.getMessageThrowables().entrySet().stream().map(entry -> new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(entry.getValue()).withSensorType(Collections.singleton(sensorType)).withMetadata(rawMessage.getMetadata()).addRawMessage(entry.getKey())).collect(Collectors.toList()));        }    } else {        throw new IllegalStateException(String.format("Could not execute parser.  Cannot find configuration for sensor %s.", sensorType));    }    return parserRunnerResults;}
private void metron_f6476_1(Supplier<ParserConfigurations> parserConfigSupplier)
{        sensorToParserComponentMap = new HashMap<>();    for (String sensorType : sensorTypes) {        if (parserConfigSupplier.get().getSensorParserConfig(sensorType) == null) {            throw new IllegalStateException(String.format("Could not initialize parsers.  Cannot find configuration for sensor %s.", sensorType));        }        SensorParserConfig parserConfig = parserConfigSupplier.get().getSensorParserConfig(sensorType);                        MessageParser<JSONObject> parser = ReflectionUtils.createInstance(parserConfig.getParserClassName());                MessageFilter<JSONObject> filter = null;        parserConfig.getParserConfig().putIfAbsent("stellarContext", stellarContext);        if (!StringUtils.isEmpty(parserConfig.getFilterClassName())) {            filter = Filters.get(parserConfig.getFilterClassName(), parserConfig.getParserConfig());        }        parser.configure(parserConfig.getParserConfig());        parser.init();        sensorToParserComponentMap.put(sensorType, new ParserComponent(parser, filter));    }}
protected Optional<ProcessResult> metron_f6477_0(String sensorType, JSONObject message, RawMessage rawMessage, MessageParser<JSONObject> parser, ParserConfigurations parserConfigurations)
{    Optional<ProcessResult> processResult = Optional.empty();    SensorParserConfig sensorParserConfig = parserConfigurations.getSensorParserConfig(sensorType);    sensorParserConfig.getRawMessageStrategy().mergeMetadata(message, rawMessage.getMetadata(), sensorParserConfig.getMergeMetadata(), sensorParserConfig.getRawMessageStrategyConfig());    message.put(Constants.SENSOR_TYPE, sensorType);    applyFieldTransformations(message, rawMessage, sensorParserConfig);    if (!message.containsKey(Constants.GUID)) {        message.put(Constants.GUID, UUID.randomUUID().toString());    }    message.putIfAbsent(Fields.ORIGINAL.getName(), new String(rawMessage.getMessage(), parser.getReadCharset()));    MessageFilter<JSONObject> filter = sensorToParserComponentMap.get(sensorType).getFilter();    if (filter == null || filter.emit(message, stellarContext)) {        boolean isInvalid = !parser.validate(message);        List<FieldValidator> failedValidators = null;        if (!isInvalid) {            failedValidators = getFailedValidators(message, parserConfigurations);            isInvalid = !failedValidators.isEmpty();        }        if (isInvalid) {            MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton(sensorType)).withMetadata(rawMessage.getMetadata()).addRawMessage(message);            Set<String> errorFields = failedValidators == null ? null : failedValidators.stream().flatMap(fieldValidator -> fieldValidator.getInput().stream()).collect(Collectors.toSet());            if (errorFields != null && !errorFields.isEmpty()) {                error.withErrorFields(errorFields);            }            processResult = Optional.of(new ProcessResult(error));        } else {            processResult = Optional.of(new ProcessResult(message));        }    }    return processResult;}
private void metron_f6478_0(JSONObject message, RawMessage rawMessage, SensorParserConfig sensorParserConfig)
{    for (FieldTransformer handler : sensorParserConfig.getFieldTransformations()) {        if (handler != null) {            if (!sensorParserConfig.getMergeMetadata()) {                                handler.transformAndUpdate(message, stellarContext, sensorParserConfig.getParserConfig(), rawMessage.getMetadata());            } else {                handler.transformAndUpdate(message, stellarContext, sensorParserConfig.getParserConfig());            }        }    }}
private List<FieldValidator> metron_f6479_0(JSONObject message, ParserConfigurations parserConfigurations)
{    List<FieldValidator> fieldValidations = parserConfigurations.getFieldValidations();    List<FieldValidator> failedValidators = new ArrayList<>();    for (FieldValidator validator : fieldValidations) {        if (!validator.isValid(message, parserConfigurations.getGlobalConfig(), stellarContext)) {            failedValidators.add(validator);        }    }    return failedValidators;}
public List<JSONObject> metron_f6480_1(byte[] rawMessage)
{    String originalMessage = null;    try {        originalMessage = new String(rawMessage, getReadCharset()).trim();                if (originalMessage.isEmpty()) {                        return Arrays.asList(new JSONObject());        }    } catch (Exception e) {                throw new RuntimeException(e.getMessage(), e);    }    JSONObject parsedJson = new JSONObject();    if (messageHeaderPatternsMap.size() > 0) {        parsedJson.putAll(extractHeaderFields(originalMessage));    }    parsedJson.putAll(parse(originalMessage));    parsedJson.put(Constants.Fields.ORIGINAL.getName(), originalMessage);    /**     * Populate the output json with default timestamp.     */    parsedJson.put(Constants.Fields.TIMESTAMP.getName(), System.currentTimeMillis());    applyFieldTransformations(parsedJson);    return Arrays.asList(parsedJson);}
private void metron_f6481_0(JSONObject parsedJson)
{    if (getParserConfig().get(ParserConfigConstants.CONVERT_CAMELCASE_TO_UNDERSCORE.getName()) != null && (Boolean) getParserConfig().get(ParserConfigConstants.CONVERT_CAMELCASE_TO_UNDERSCORE.getName())) {        convertCamelCaseToUnderScore(parsedJson);    }}
public void metron_f6482_1(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);    setParserConfig(parserConfig);    setFields((List<Map<String, Object>>) getParserConfig().get(ParserConfigConstants.FIELDS.getName()));    String recordTypeRegex = (String) getParserConfig().get(ParserConfigConstants.RECORD_TYPE_REGEX.getName());    if (StringUtils.isBlank(recordTypeRegex)) {                throw new IllegalStateException("Invalid config :recordTypeRegex is missing in parserConfig");    }    setRecordTypePattern(recordTypeRegex);    recordTypePatternNamedGroups.addAll(getNamedGroups(recordTypeRegex));    List<Map<String, Object>> fields = (List<Map<String, Object>>) getParserConfig().get(ParserConfigConstants.FIELDS.getName());    try {        configureRecordTypePatterns(fields);        configureMessageHeaderPattern();    } catch (PatternSyntaxException e) {                throw new IllegalStateException("Invalid config : " + e.getMessage());    }    validateConfig();}
private void metron_f6483_0()
{    if (getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName()) != null) {        if (getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName()) instanceof List) {            List<String> messageHeaderPatternList = (List<String>) getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName());            for (String messageHeaderPatternStr : messageHeaderPatternList) {                messageHeaderPatternsMap.put(Pattern.compile(messageHeaderPatternStr), getNamedGroups(messageHeaderPatternStr));            }        } else if (getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName()) instanceof String) {            String messageHeaderPatternStr = (String) getParserConfig().get(ParserConfigConstants.MESSAGE_HEADER.getName());            if (StringUtils.isNotBlank(messageHeaderPatternStr)) {                messageHeaderPatternsMap.put(Pattern.compile(messageHeaderPatternStr), getNamedGroups(messageHeaderPatternStr));            }        }    }}
private void metron_f6484_0(List<Map<String, Object>> fields)
{    for (Map<String, Object> field : fields) {        if (field.get(ParserConfigConstants.RECORD_TYPE.getName()) != null && field.get(ParserConfigConstants.REGEX.getName()) != null) {            String recordType = ((String) field.get(ParserConfigConstants.RECORD_TYPE.getName())).toLowerCase();            recordTypePatternMap.put(recordType, new LinkedHashMap<>());            if (field.get(ParserConfigConstants.REGEX.getName()) instanceof List) {                List<String> regexList = (List<String>) field.get(ParserConfigConstants.REGEX.getName());                regexList.forEach(s -> {                    recordTypePatternMap.get(recordType).put(Pattern.compile(s), getNamedGroups(s));                });            } else if (field.get(ParserConfigConstants.REGEX.getName()) instanceof String) {                recordTypePatternMap.get(recordType).put(Pattern.compile((String) field.get(ParserConfigConstants.REGEX.getName())), getNamedGroups((String) field.get(ParserConfigConstants.REGEX.getName())));            }        }    }}
private void metron_f6485_0(String recordTypeRegex)
{    if (recordTypeRegex != null) {        recordTypePattern = Pattern.compile(recordTypeRegex);    }}
private JSONObject metron_f6486_0(String originalMessage)
{    JSONObject parsedJson = new JSONObject();    Optional<String> recordIdentifier = getField(recordTypePattern, originalMessage);    if (recordIdentifier.isPresent()) {        extractNamedGroups(parsedJson, recordIdentifier.get(), originalMessage);    }    /*         * Extract fields(named groups) from record type regular expression         */    Matcher matcher = recordTypePattern.matcher(originalMessage);    if (matcher.find()) {        for (String namedGroup : recordTypePatternNamedGroups) {            if (matcher.group(namedGroup) != null) {                parsedJson.put(namedGroup, matcher.group(namedGroup).trim());            }        }    }    return parsedJson;}
private void metron_f6487_1(Map<String, Object> json, String recordType, String originalMessage)
{    Map<Pattern, Set<String>> patternMap = recordTypePatternMap.get(recordType.toLowerCase());    if (patternMap != null) {        for (Map.Entry<Pattern, Set<String>> entry : patternMap.entrySet()) {            Pattern pattern = entry.getKey();            Set<String> namedGroups = entry.getValue();            if (pattern != null && namedGroups != null && namedGroups.size() > 0) {                Matcher m = pattern.matcher(originalMessage);                if (m.matches()) {                                        for (String namedGroup : namedGroups) {                        if (m.group(namedGroup) != null) {                            json.put(namedGroup, m.group(namedGroup).trim());                        }                    }                    break;                }            }        }    } else {            }}
public Optional<String> metron_f6488_0(Pattern pattern, String originalMessage)
{    Matcher matcher = pattern.matcher(originalMessage);    while (matcher.find()) {        return Optional.of(matcher.group());    }    return Optional.empty();}
private Set<String> metron_f6489_0(String regex)
{    Set<String> namedGroups = new TreeSet<>();    Matcher matcher = namedGroupPattern.matcher(regex);    while (matcher.find()) {        namedGroups.add(matcher.group(1));    }    return namedGroups;}
private Map<String, Object> metron_f6490_0(String originalMessage)
{    Map<String, Object> messageHeaderJson = new JSONObject();    for (Map.Entry<Pattern, Set<String>> syslogPatternEntry : messageHeaderPatternsMap.entrySet()) {        Matcher m = syslogPatternEntry.getKey().matcher(originalMessage);        if (m.find()) {            for (String namedGroup : syslogPatternEntry.getValue()) {                if (StringUtils.isNotBlank(m.group(namedGroup))) {                    messageHeaderJson.put(namedGroup, m.group(namedGroup).trim());                }            }            break;        }    }    return messageHeaderJson;}
public void metron_f6491_1()
{    }
public void metron_f6492_1()
{    if (getFields() == null) {                throw new IllegalStateException("Invalid config :fields is missing in parserConfig");    }}
private void metron_f6493_0(Map<String, Object> json)
{    Map<String, String> oldKeyNewKeyMap = new HashMap<>();    for (Map.Entry<String, Object> entry : json.entrySet()) {        if (capitalLettersPattern.matcher(entry.getKey()).matches()) {            oldKeyNewKeyMap.put(entry.getKey(), CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, entry.getKey()));        }    }    oldKeyNewKeyMap.forEach((oldKey, newKey) -> json.put(newKey, json.remove(oldKey)));}
public List<Map<String, Object>> metron_f6494_0()
{    return fields;}
public void metron_f6495_0(List<Map<String, Object>> fields)
{    this.fields = fields;}
public Map<String, Object> metron_f6496_0()
{    return parserConfig;}
public void metron_f6497_0(Map<String, Object> parserConfig)
{    this.parserConfig = parserConfig;}
public String metron_f6498_0()
{    return name;}
public static ParserConfigConstants metron_f6499_0(String fieldName)
{    return nameToField.get(fieldName);}
protected void metron_f6500_0(SyslogParser syslogParser)
{    this.syslogParser = syslogParser;}
protected void metron_f6501_0(Consumer<JSONObject> function)
{    this.messageProcessorOptional = Optional.of(function);}
public boolean metron_f6504_0(JSONObject message)
{    if (!(message.containsKey("original_string"))) {        LOG.trace("[Metron] Message does not have original_string: {}", message);        return false;    } else if (!(message.containsKey("timestamp"))) {        LOG.trace("[Metron] Message does not have timestamp: {}", message);        return false;    } else {        LOG.trace("[Metron] Message conforms to schema: {}", message);        return true;    }}
public Optional<MessageParserResult<JSONObject>> metron_f6505_1(byte[] rawMessage)
{    try {        if (rawMessage == null || rawMessage.length == 0) {            return Optional.empty();        }        String originalString = new String(rawMessage, getReadCharset());        final List<JSONObject> returnList = new ArrayList<>();        Map<Object, Throwable> errorMap = new HashMap<>();        try (Reader reader = new BufferedReader(new StringReader(originalString))) {            syslogParser.parseLines(reader, (m) -> {                JSONObject jsonObject = new JSONObject(m);                                                jsonObject.put("original_string", originalString);                try {                    setTimestamp(jsonObject);                } catch (ParseException pe) {                    errorMap.put(originalString, pe);                    return;                }                messageProcessorOptional.ifPresent((c) -> c.accept(jsonObject));                returnList.add(jsonObject);            }, errorMap::put);            return Optional.of(new DefaultMessageParserResult<JSONObject>(returnList, errorMap));        }    } catch (IOException e) {        String message = "Unable to read buffer " + new String(rawMessage, StandardCharsets.UTF_8) + ": " + e.getMessage();                return Optional.of(new DefaultMessageParserResult<JSONObject>(new IllegalStateException(message, e)));    }}
private void metron_f6506_0(JSONObject message) throws ParseException
{    String timeStampString = (String) message.get(SyslogFieldKeys.HEADER_TIMESTAMP.getField());    if (!StringUtils.isBlank(timeStampString) && !timeStampString.equals("-")) {        message.put("timestamp", SyslogUtils.parseTimestampToEpochMillis(timeStampString, deviceClock));    } else {        message.put("timestamp", LocalDateTime.now().toEpochSecond(ZoneOffset.UTC));    }}
public void metron_f6507_0(Map<String, Object> config)
{    if (config.containsKey(READ_CHARSET)) {        readCharset = Charset.forName((String) config.get(READ_CHARSET));    } else {        readCharset = MessageParser.super.getReadCharset();    }}
public Charset metron_f6508_0()
{    return null == this.readCharset ? MessageParser.super.getReadCharset() : this.readCharset;}
public SyslogParser metron_f6509_0(Map<String, Object> config)
{    return new SyslogParserBuilder().forSpecification(SyslogSpecification.RFC_3164).withDeviations(EnumSet.of(AllowableDeviations.PRIORITY, AllowableDeviations.VERSION)).build();}
public SyslogParser metron_f6510_0(Map<String, Object> config)
{            String nilPolicyStr = (String) config.getOrDefault(NIL_POLICY_CONFIG, NilPolicy.OMIT.name());    NilPolicy nilPolicy = NilPolicy.valueOf(nilPolicyStr);    return new SyslogParserBuilder().forSpecification(SyslogSpecification.RFC_5424).withNilPolicy(nilPolicy).withDeviations(EnumSet.of(AllowableDeviations.PRIORITY, AllowableDeviations.VERSION)).build();}
public static long metron_f6511_0(String candidate, List<SimpleDateFormat> validPatterns) throws ParseException
{    if (StringUtils.isNumeric(candidate)) {        return Long.valueOf(candidate);    } else {        for (SimpleDateFormat pattern : validPatterns) {            try {                Calendar cal = Calendar.getInstance();                cal.setTime(pattern.parse(candidate));                Calendar current = Calendar.getInstance();                if (cal.get(Calendar.YEAR) == 1970) {                    cal.set(Calendar.YEAR, current.get(Calendar.YEAR));                }                current.add(Calendar.DAY_OF_MONTH, 4);                if (cal.after(current)) {                    cal.add(Calendar.YEAR, -1);                }                return cal.getTimeInMillis();            } catch (ParseException e) {                continue;            }        }        throw new ParseException("Failed to parse any of the given date formats", 0);    }}
public static File metron_f6512_0(InputStream in) throws IOException
{    final File tempFile = File.createTempFile(PREFIX, SUFFIX);    tempFile.deleteOnExit();    try (FileOutputStream out = new FileOutputStream(tempFile)) {        IOUtils.copy(in, out);    }    return tempFile;}
public static Long metron_f6513_0(String m, String d, String ts, boolean adjust_timezone) throws ParseException
{    d = d.trim();    if (d.length() <= 2) {        d = "0" + d;    }    Date date = new SimpleDateFormat("MMM", Locale.ENGLISH).parse(m);    Calendar cal = Calendar.getInstance();    cal.setTime(date);    String month = String.valueOf(cal.get(Calendar.MONTH) + 1);    int year = Calendar.getInstance().get(Calendar.YEAR);    if (month.length() <= 2) {        month = "0" + month;    }    String coglomerated_ts = year + "-" + month + "-" + d + " " + ts;    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    if (adjust_timezone) {        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));    }    date = sdf.parse(coglomerated_ts);    long timeInMillisSinceEpoch = date.getTime();    return timeInMillisSinceEpoch;}
public static long metron_f6514_0(String logTimestamp, Clock deviceClock) throws ParseException
{    ZoneId deviceTimeZone = deviceClock.getZone();        if (Pattern.matches("[A-Z][a-z]{2}(?:(?:\\s{2}\\d)|(?:\\s\\d{2}))\\s\\d{2}:\\d{2}:\\d{2}", logTimestamp)) {        DateTimeFormatter inputFormat = DateTimeFormatter.ofPattern("MMM ppd HH:mm:ss").withZone(deviceTimeZone);        TemporalAccessor inputDate = inputFormat.parse(logTimestamp);        int inputMonth = inputDate.get(MONTH_OF_YEAR);        int inputDay = inputDate.get(DAY_OF_MONTH);        int inputHour = inputDate.get(HOUR_OF_DAY);        int inputMinute = inputDate.get(MINUTE_OF_HOUR);        int inputSecond = inputDate.get(SECOND_OF_MINUTE);        ZonedDateTime currentDate = ZonedDateTime.now(deviceClock);        int currentYear = currentDate.getYear();        ZonedDateTime inputDateWithCurrentYear = ZonedDateTime.of(currentYear, inputMonth, inputDay, inputHour, inputMinute, inputSecond, 0, deviceTimeZone);                if (inputDateWithCurrentYear.isAfter(currentDate.plusDays(4L))) {            ZonedDateTime inputDateWithPreviousYear = ZonedDateTime.of(currentYear - 1, inputMonth, inputDay, inputHour, inputMinute, inputSecond, 0, deviceTimeZone);            return inputDateWithPreviousYear.toInstant().toEpochMilli();        } else            return inputDateWithCurrentYear.toInstant().toEpochMilli();    } else     if (Pattern.matches("[A-Z][a-z]{2}\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}", logTimestamp))        return convertToEpochMillis(logTimestamp, DateTimeFormatter.ofPattern("MMM dd yyyy HH:mm:ss").withZone(deviceTimeZone));    else     if (Pattern.matches("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})", logTimestamp))        return convertToEpochMillis(logTimestamp, DateTimeFormatter.ISO_OFFSET_DATE_TIME);    else        throw new ParseException(String.format("Unsupported date format: '%s'", logTimestamp));}
private static long metron_f6515_0(String logTimestamp, DateTimeFormatter logTimeFormat)
{    ZonedDateTime timestamp = ZonedDateTime.parse(logTimestamp, logTimeFormat);    return timestamp.toInstant().toEpochMilli();}
public static String metron_f6516_0(int priority)
{    int severity = priority & 0x07;    switch(severity) {        case 0:            return "emerg";        case 1:            return "alert";        case 2:            return "crit";        case 3:            return "err";        case 4:            return "warn";        case 5:            return "notice";        case 6:            return "info";        case 7:            return "debug";        default:            return "unknown";    }}
public static String metron_f6517_0(int priority)
{    int facility = priority >> 3;    switch(facility) {        case 0:            return "kern";        case 1:            return "user";        case 2:            return "mail";        case 3:            return "daemon";        case 4:            return "auth";        case 5:            return "syslog";        case 6:            return "lpr";        case 7:            return "news";        case 8:            return "uucp";                case 10:            return "authpriv";        case 11:            return "ftp";                case 15:            return "cron";        case 16:            return "local0";        case 17:            return "local1";        case 18:            return "local2";        case 19:            return "local3";        case 20:            return "local4";        case 21:            return "local5";        case 22:            return "local6";        case 23:            return "local7";        default:            return "unknown";    }}
public void metron_f6518_0()
{    Assert.assertNull(Filters.get("DEFAULT", null));}
public void metron_f6519_0() throws Exception
{    {        Map<String, Object> config = new HashMap<String, Object>() {            {                put("filter.query", "exists(foo)");            }        };        MessageFilter<JSONObject> filter = Filters.get(Filters.STELLAR.name(), config);        Assert.assertTrue(filter.emit(new JSONObject(ImmutableMap.of("foo", 1)), Context.EMPTY_CONTEXT()));        Assert.assertFalse(filter.emit(new JSONObject(ImmutableMap.of("bar", 1)), Context.EMPTY_CONTEXT()));    }}
protected boolean metron_f6520_0(final String jsonSchema, final String jsonData) throws IOException, ProcessingException
{    final JsonNode d = JsonLoader.fromString(jsonData);    final JsonNode s = JsonLoader.fromString(jsonSchema);    final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();    JsonValidator v = factory.getValidator();    ProcessingReport report = v.validate(s, d);    return report.toString().contains("success");}
protected String metron_f6521_0(URL schema_url) throws Exception
{    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(schema_url.getFile()), StandardCharsets.UTF_8));    String line;    StringBuilder sb = new StringBuilder();    while ((line = br.readLine()) != null) {        sb.append(line);    }    br.close();    String schema_string = sb.toString().replaceAll("\n", "");    schema_string = schema_string.replaceAll(" ", "");    return schema_string;}
protected String[] metron_f6522_0(String test_data_url) throws Exception
{    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(test_data_url), StandardCharsets.UTF_8));    ArrayList<String> inputDataLines = new ArrayList<>();    String line;    while ((line = br.readLine()) != null) {        inputDataLines.add(line.replaceAll("\n", ""));    }    br.close();    String[] inputData = new String[inputDataLines.size()];    inputData = inputDataLines.toArray(inputData);    return inputData;}
public void metron_f6523_0(String schemaJsonString)
{    this.schemaJsonString = schemaJsonString;}
public String metron_f6524_0()
{    return this.schemaJsonString;}
public void metron_f6526_0(Map<String, Object> config)
{    setReadCharset(config);}
public Optional<MessageParserResult<JSONObject>> metron_f6527_0(byte[] parseMessage)
{    String message = new String(parseMessage, getReadCharset());    Map<String, Object> out = new HashMap<>();    out.put(KEY1, message);    MessageParserResult<JSONObject> result = new DefaultMessageParserResult<JSONObject>(Arrays.asList(new JSONObject(out)));    return Optional.of(result);}
public void metron_f6529_0() throws IOException, InterruptedException
{    tempFolder.create();    parserWithCharset = new SomeParserWithCharset();    parserNoCharset = new SomeParserNoCharset();    parserConfig = new HashMap<>();    fileUTF_16 = new File(tempFolder.getRoot(), "fileUTF-16");    fileUTF_8 = new File(tempFolder.getRoot(), "fileUTF-8");    writeDataEncodedAs(fileUTF_16, SAMPLE_DATA, StandardCharsets.UTF_16);    writeDataEncodedAs(fileUTF_8, SAMPLE_DATA, StandardCharsets.UTF_8);}
private void metron_f6530_0(File file, String data, Charset charset) throws IOException
{    byte[] bytes = data.getBytes(charset);    FileUtils.writeByteArrayToFile(file, bytes);}
public void metron_f6531_0() throws IOException
{                String utf16_8 = readDataEncodedAs(fileUTF_16, StandardCharsets.UTF_8);    String utf16_16 = readDataEncodedAs(fileUTF_16, StandardCharsets.UTF_16);    File utf16_16_8 = new File(tempFolder.getRoot(), "outUTF-8");    writeDataEncodedAs(utf16_16_8, utf16_16, StandardCharsets.UTF_8);    String utf8_8 = readDataEncodedAs(utf16_16_8, StandardCharsets.UTF_8);    assertThat(utf8_8, equalTo(utf16_16));    assertThat(utf8_8, not(equalTo(utf16_8)));    assertThat(utf8_8, equalTo(utf16_16));    assertThat(utf8_8, not(equalTo(utf16_8)));}
private String metron_f6532_0(File file, Charset charset) throws IOException
{    return FileUtils.readFileToString(file, charset);}
public void metron_f6533_0()
{    parserConfig.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parserWithCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserWithCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_16));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), equalTo(SAMPLE_DATA));}
public void metron_f6534_0()
{    parserConfig.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_8.toString());    parserWithCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserWithCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_16));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), not(equalTo(SAMPLE_DATA)));}
public void metron_f6535_0()
{    parserWithCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserWithCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_8));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), equalTo(SAMPLE_DATA));}
public void metron_f6536_0()
{    parserNoCharset.configure(parserConfig);    Optional<MessageParserResult<JSONObject>> result = parserNoCharset.parseOptionalResult(SAMPLE_DATA.getBytes(StandardCharsets.UTF_8));    MessageParserResult<JSONObject> json = result.get();    assertThat(json.getMessages().size(), equalTo(1));    assertThat(json.getMessages().get(0).get(KEY1), equalTo(SAMPLE_DATA));}
public void metron_f6537_0() throws IOException
{    CSVParser parser = new CSVParser();    SensorParserConfig config = JSONUtils.INSTANCE.load(parserConfig, SensorParserConfig.class);    parser.init();    parser.configure(config.getParserConfig());    {        String line = "#foo,bar,grok";        Assert.assertEquals(0, parser.parse(Bytes.toBytes(line)).size());    }    {        String line = "";        Assert.assertEquals(0, parser.parse(Bytes.toBytes(line)).size());    }    {        String line = "foo,bar,grok";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));    }    {        String line = "\"foo\", \"bar\",\"grok\"";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));    }    {        String line = "foo, bar, grok";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));    }    {        String line = " foo , bar , grok ";        List<JSONObject> results = parser.parse(Bytes.toBytes(line));        Assert.assertEquals(1, results.size());        JSONObject o = results.get(0);        Assert.assertTrue(parser.validate(o));        Assert.assertEquals(5, o.size());        Assert.assertEquals("foo", o.get("col1"));        Assert.assertEquals("bar", o.get("col2"));        Assert.assertEquals("grok", o.get("col3"));        Assert.assertEquals(null, o.get(" col2"));        Assert.assertEquals(null, o.get("col3 "));    }    {        UnitTestHelper.setLog4jLevel(CSVParser.class, Level.FATAL);        String line = "foo";        try {            List<JSONObject> results = parser.parse(Bytes.toBytes(line));            Assert.fail("Expected exception");        } catch (IllegalStateException iae) {        }        UnitTestHelper.setLog4jLevel(CSVParser.class, Level.ERROR);    }}
public void metron_f6538_0() throws IOException
{    SensorParserConfig config = JSONUtils.INSTANCE.load(parserConfig, SensorParserConfig.class);    CSVParser parser = new CSVParser();    parser.init();    config.getParserConfig().put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config.getParserConfig());    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6539_0() throws IOException
{    SensorParserConfig config = JSONUtils.INSTANCE.load(parserConfig, SensorParserConfig.class);    CSVParser parser = new CSVParser();    parser.init();    parser.configure(config.getParserConfig());    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6540_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        JSONObject expected = (JSONObject) jsonParser.parse(e.getValue());        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertNotNull(resultOptional);        Assert.assertTrue(resultOptional.isPresent());        List<JSONObject> parsedList = resultOptional.get().getMessages();        Assert.assertEquals(1, parsedList.size());        compare(expected, parsedList.get(0));    }}
public boolean metron_f6541_0(JSONObject expected, JSONObject actual)
{    MapDifference mapDifferences = Maps.difference(expected, actual);    if (mapDifferences.entriesOnlyOnLeft().size() > 0)        Assert.fail("Expected JSON has extra parameters: " + mapDifferences.entriesOnlyOnLeft());    if (mapDifferences.entriesOnlyOnRight().size() > 0)        Assert.fail("Actual JSON has extra parameters: " + mapDifferences.entriesOnlyOnRight());    Map actualDifferences = new HashMap();    if (mapDifferences.entriesDiffering().size() > 0) {        Map differences = Collections.unmodifiableMap(mapDifferences.entriesDiffering());        for (Object key : differences.keySet()) {            Object expectedValueObject = expected.get(key);            Object actualValueObject = actual.get(key);            if (expectedValueObject instanceof Long || expectedValueObject instanceof Integer) {                Long expectedValue = Long.parseLong(expectedValueObject.toString());                Long actualValue = Long.parseLong(actualValueObject.toString());                if (!expectedValue.equals(actualValue)) {                    actualDifferences.put(key, differences.get(key));                }            } else {                actualDifferences.put(key, differences.get(key));            }        }    }    if (actualDifferences.size() > 0)        Assert.fail("Expected and Actual JSON values don't match: " + actualDifferences);    return true;}
public void metron_f6542_0(ParserDriver driver) throws IOException
{    Map<String, Object> inputRecord = new HashMap<String, Object>() {        {            put(Constants.Fields.ORIGINAL.getName(), "real_original_string");            put("data", "field1_val,100");            put("metadata_field", "metadata_val");        }    };    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(JSONUtils.INSTANCE.toJSONPretty(inputRecord)));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> outputRecord = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("field1_val", outputRecord.get("field1"));    Assert.assertEquals(inputRecord.get(Constants.Fields.ORIGINAL.getName()), outputRecord.get(Constants.Fields.ORIGINAL.getName()));    Assert.assertEquals(inputRecord.get(MetadataUtil.METADATA_PREFIX + ".metadata_field"), outputRecord.get("metadata_field"));}
public void metron_f6543_0(ParserDriver driver) throws IOException
{    Map<String, Object> inputRecord = new HashMap<String, Object>() {        {            put(Constants.Fields.ORIGINAL.getName(), "real_original_string");            put("data", "field1_val,100");            put("metadata_field", "metadata_val");        }    };    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(JSONUtils.INSTANCE.toJSONPretty(inputRecord)));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> outputRecord = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("field1_val", outputRecord.get("field1"));    Assert.assertEquals(inputRecord.get(Constants.Fields.ORIGINAL.getName()), outputRecord.get(Constants.Fields.ORIGINAL.getName()));    Assert.assertEquals(inputRecord.get("metadata_field"), outputRecord.get("metadata_field"));}
public void metron_f6544_0(ParserDriver driver) throws IOException
{    Map<String, Object> inputRecord = new HashMap<String, Object>() {        {            put(Constants.Fields.ORIGINAL.getName(), "real_original_string");            put("data", "field1_val,100");            put("metadata_field", "metadata_val");        }    };    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(JSONUtils.INSTANCE.toJSONPretty(inputRecord)));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> outputRecord = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("field1_val", outputRecord.get("field1"));    Assert.assertEquals(inputRecord.get(Constants.Fields.ORIGINAL.getName()), outputRecord.get(Constants.Fields.ORIGINAL.getName()));    Assert.assertFalse(outputRecord.containsKey(MetadataUtil.METADATA_PREFIX + ".metadata_field"));}
public void metron_f6545_0(ParserDriver syslogDriver, ParserDriver driver) throws Exception
{    byte[] envelopedData = null;    String inputRecord = "Mar 29 2004 09:54:18: %PIX-6-302005: Built UDP connection for faddr 198.207.223.240/53337 gaddr 10.0.0.187/53 laddr 192.168.0.2/53";    ProcessorResult<List<byte[]>> syslogResult = syslogDriver.run(ImmutableList.of(inputRecord.getBytes(StandardCharsets.UTF_8)));    Assert.assertFalse(syslogResult.failed());    List<byte[]> syslogResultList = syslogResult.getResult();    envelopedData = syslogResultList.get(0);    ProcessorResult<List<byte[]>> results = driver.run(ImmutableList.of(envelopedData));    Assert.assertFalse(results.failed());    List<byte[]> resultList = results.getResult();    Assert.assertEquals(1, resultList.size());    Map<String, Object> result = JSONUtils.INSTANCE.load(new String(resultList.get(0), StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);    Assert.assertEquals("UDP", result.get("protocol"));    Assert.assertTrue((long) result.get("timestamp") > 1000);}
protected String metron_f6546_0() throws IOException
{    File configsRoot = new File("../" + TestConstants.SAMPLE_CONFIG_PATH);    return new String(Files.readAllBytes(new File(configsRoot, "global.json").toPath()), StandardCharsets.UTF_8);}
protected String metron_f6547_0(String sensorType) throws IOException
{        File configsRoot = new File("../" + TestConstants.PARSER_COMMON_CONFIGS_PATH);    File parsersRoot = new File(configsRoot, "parsers");    System.out.println("Workspace: " + System.getProperty("user.dir"));    System.out.println("Parsers root: " + parsersRoot);    if (!Files.exists(new File(parsersRoot, sensorType + ".json").toPath())) {                configsRoot = new File("../" + TestConstants.PARSER_CONFIGS_PATH);        parsersRoot = new File(configsRoot, "parsers");    }    return new String(Files.readAllBytes(new File(parsersRoot, sensorType + ".json").toPath()), StandardCharsets.UTF_8);}
public void metron_f6548_0(ParserDriver driver) throws Exception
{    String sensorType = driver.getSensorType();    inputMessages = TestUtils.readSampleData(SampleDataUtils.getSampleDataPath("..", sensorType, TestDataType.RAW));    ProcessorResult<List<byte[]>> result = driver.run(inputMessages);    List<byte[]> outputMessages = result.getResult();    StringBuffer buffer = new StringBuffer();    if (result.failed()) {        result.getBadResults(buffer);        buffer.append(String.format("%d Valid Messages Processed", outputMessages.size())).append("\n");        dumpParsedMessages(outputMessages, buffer);        Assert.fail(buffer.toString());    } else {        List<ParserValidation> validations = getValidations();        if (validations == null || validations.isEmpty()) {            buffer.append("No validations configured for sensorType ").append(sensorType).append(".  Dumping parsed messages").append("\n");            dumpParsedMessages(outputMessages, buffer);            Assert.fail(buffer.toString());        } else {            for (ParserValidation validation : validations) {                System.out.println("Running " + validation.getName() + " on sensorType " + sensorType);                validation.validate(sensorType, outputMessages);            }        }    }}
public void metron_f6549_0(List<byte[]> outputMessages, StringBuffer buffer)
{    for (byte[] outputMessage : outputMessages) {        buffer.append(new String(outputMessage, StandardCharsets.UTF_8)).append("\n");    }}
public String metron_f6550_0()
{    return sensorType;}
public String metron_f6551_0()
{    return "Sample Data Validation";}
public void metron_f6552_0(String sensorType, List<byte[]> actualMessages) throws Exception
{    List<byte[]> expectedMessages = TestUtils.readSampleData(SampleDataUtils.getSampleDataPath("..", sensorType, TestDataType.PARSED));    Assert.assertEquals(expectedMessages.size(), actualMessages.size());    for (int i = 0; i < actualMessages.size(); i++) {        String expectedMessage = new String(expectedMessages.get(i), StandardCharsets.UTF_8);        String actualMessage = new String(actualMessages.get(i), StandardCharsets.UTF_8);        try {            ValidationUtils.assertJsonEqual(expectedMessage, actualMessage);        } catch (Throwable t) {            System.out.println("expected: " + expectedMessage);            System.out.println("actual: " + actualMessage);            throw t;        }    }}
public void metron_f6553_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(2, output.size());    JSONObject message = output.get(0);        Assert.assertEquals(4, message.size());    Assert.assertEquals("foo1", message.get("name"));    Assert.assertEquals("bar", message.get("value"));    Assert.assertEquals(1.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should be handled external to the parser by default", message.containsKey(Fields.ORIGINAL.getName()), equalTo(false));    message = output.get(1);        Assert.assertEquals(4, message.size());    Assert.assertEquals("foo2", message.get("name"));    Assert.assertEquals("baz", message.get("value"));    Assert.assertEquals(2.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should be handled external to the parser by default", message.containsKey(Fields.ORIGINAL.getName()), equalTo(false));}
public void metron_f6554_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");            put(JSONMapParser.OVERRIDE_ORIGINAL_STRING, true);        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(2, output.size());    JSONObject message = output.get(0);        Assert.assertEquals(5, message.size());    Assert.assertEquals("foo1", message.get("name"));    Assert.assertEquals("bar", message.get("value"));    Assert.assertEquals(1.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should have been handled by the parser", message.get(Fields.ORIGINAL.getName()), equalTo("{\"name\":\"foo1\",\"number\":1.0,\"value\":\"bar\"}"));    message = output.get(1);        Assert.assertEquals(5, message.size());    Assert.assertEquals("foo2", message.get("name"));    Assert.assertEquals("baz", message.get("value"));    Assert.assertEquals(2.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    Assert.assertThat("original_string should have been handled by the parser", message.get(Fields.ORIGINAL.getName()), equalTo("{\"name\":\"foo2\",\"number\":2.0,\"value\":\"baz\"}"));}
public void metron_f6555_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$$..$$SDSE$#$#.");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));}
public void metron_f6556_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_SINGLE.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(0, output.size());}
public void metron_f6557_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);        Assert.assertEquals(output.get(0).size(), 1);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6558_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ERROR.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.FATAL);    parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.ERROR);}
public void metron_f6559_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ALLOW.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 2);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 2);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6560_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 5);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.blah"), 7);    Assert.assertEquals(message.get("collection.blah2"), "foo");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "grey");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 5);    message = output.get(1);    Assert.assertEquals(message.get("collection.blah"), 8);    Assert.assertEquals(message.get("collection.blah2"), "bar");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz2");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "blue");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6561_0()
{    parser = new JSONMapParser();}
public void metron_f6562_0()
{    List<JSONObject> output = parser.parse(happyPathJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 4);    JSONObject message = output.get(0);    Assert.assertEquals("bar", message.get("foo"));    Assert.assertEquals("blah", message.get("blah"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);}
public void metron_f6563_0()
{    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 1);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6564_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ERROR.name()));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.FATAL);    parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.ERROR);}
public void metron_f6565_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ALLOW.name()));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 2);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6566_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name()));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 1);        Assert.assertEquals(output.get(0).size(), 5);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.blah"), 7);    Assert.assertEquals(message.get("collection.blah2"), "foo");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "grey");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6567_0()
{    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name()));    List<JSONObject> output = parser.parse(mixCollectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.get(0).size(), 3);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.key"), "value");    Assert.assertEquals(message.get("key"), "value");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6568_0()
{    Map<String, Object> config = new HashMap<>();    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6569_0()
{    Map<String, Object> config = new HashMap<>();    parser.configure(config);    assertThat(parser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public void metron_f6570_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.WRAP_JSON, true);            put(JSONMapParser.WRAP_ENTITY_NAME, "foo");            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);        Assert.assertEquals(output.get(0).size(), 4);    JSONObject message = output.get(0);    Assert.assertEquals("foo1", message.get("name"));    Assert.assertEquals("bar", message.get("value"));    Assert.assertEquals(1.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);    message = output.get(1);    Assert.assertEquals("foo2", message.get("name"));    Assert.assertEquals("baz", message.get("value"));    Assert.assertEquals(2.0, message.get("number"));    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertNotNull(message.get("number"));    Assert.assertTrue(message.get("number") instanceof Number);}
public void metron_f6571_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$$..$$SDSE$#$#.");        }    });    List<JSONObject> output = parser.parse(JSON_LIST.getBytes(StandardCharsets.UTF_8));}
public void metron_f6572_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(JSON_SINGLE.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(0, output.size());}
public void metron_f6573_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(new HashMap<String, Object>() {        {            put(JSONMapParser.JSONP_QUERY, "$.foo");        }    });    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);        Assert.assertEquals(output.get(0).size(), 1);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6574_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ERROR.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.FATAL);    parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    UnitTestHelper.setLog4jLevel(BasicParser.class, Level.ERROR);}
public void metron_f6575_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.ALLOW.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 2);    JSONObject message = output.get(0);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 2);    message = output.get(1);    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public void metron_f6576_0()
{    JSONMapParser parser = new JSONMapParser();    parser.configure(ImmutableMap.of(JSONMapParser.MAP_STRATEGY_CONFIG, JSONMapParser.MapStrategy.UNFOLD.name(), JSONMapParser.JSONP_QUERY, "$.foo"));    List<JSONObject> output = parser.parse(collectionHandlingJSON.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(output.size(), 2);    Assert.assertEquals(output.get(0).size(), 5);    JSONObject message = output.get(0);    Assert.assertEquals(message.get("collection.blah"), 7);    Assert.assertEquals(message.get("collection.blah2"), "foo");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "grey");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);    Assert.assertEquals(output.get(1).size(), 5);    message = output.get(1);    Assert.assertEquals(message.get("collection.blah"), 8);    Assert.assertEquals(message.get("collection.blah2"), "bar");    Assert.assertEquals(message.get("collection.bigblah.innerBlah"), "baz2");    Assert.assertEquals(message.get("collection.bigblah.reallyInnerBlah.color"), "blue");    Assert.assertNotNull(message.get("timestamp"));    Assert.assertTrue(message.get("timestamp") instanceof Number);}
public boolean metron_f6578_0(JSONObject message)
{    return false;}
public void metron_f6580_0() throws Exception
{    MessageParser parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            return null;        }    };    Assert.assertNotNull(parser.parseOptionalResult(null));    Assert.assertFalse(parser.parseOptionalResult(null).isPresent());}
public List<JSONObject> metron_f6581_0(byte[] rawMessage)
{    return null;}
public void metron_f6582_0() throws Exception
{    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            return new ArrayList<>();        }    };    Assert.assertNotNull(parser.parseOptionalResult(null));    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult(null);    Assert.assertTrue(ret.isPresent());    Assert.assertEquals(0, ret.get().getMessages().size());}
public List<JSONObject> metron_f6583_0(byte[] rawMessage)
{    return new ArrayList<>();}
public void metron_f6584_0()
{    JSONObject message = new JSONObject();    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            return Collections.singletonList(message);        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertEquals(1, ret.get().getMessages().size());    Assert.assertEquals(message, ret.get().getMessages().get(0));}
public List<JSONObject> metron_f6585_0(byte[] rawMessage)
{    return Collections.singletonList(message);}
public void metron_f6586_0()
{    JSONObject message = new JSONObject();    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public Optional<List<JSONObject>> parseOptional(byte[] rawMessage) {            return Optional.of(Collections.singletonList(message));        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertEquals(1, ret.get().getMessages().size());    Assert.assertEquals(message, ret.get().getMessages().get(0));}
public Optional<List<JSONObject>> metron_f6587_0(byte[] rawMessage)
{    return Optional.of(Collections.singletonList(message));}
public void metron_f6588_0()
{    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public List<JSONObject> parse(byte[] rawMessage) {            throw new RuntimeException("parse exception");        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertTrue(ret.get().getMasterThrowable().isPresent());    Assert.assertEquals("parse exception", ret.get().getMasterThrowable().get().getMessage());}
public List<JSONObject> metron_f6589_0(byte[] rawMessage)
{    throw new RuntimeException("parse exception");}
public void metron_f6590_0()
{    MessageParser<JSONObject> parser = new TestMessageParser() {        @Override        public Optional<List<JSONObject>> parseOptional(byte[] rawMessage) {            throw new RuntimeException("parse exception");        }    };    Optional<MessageParserResult<JSONObject>> ret = parser.parseOptionalResult("message".getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(ret.isPresent());    Assert.assertTrue(ret.get().getMasterThrowable().isPresent());    Assert.assertEquals("parse exception", ret.get().getMasterThrowable().get().getMessage());}
public Optional<List<JSONObject>> metron_f6591_0(byte[] rawMessage)
{    throw new RuntimeException("parse exception");}
public void metron_f6592_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertNotNull(resultOptional);        Assert.assertTrue(resultOptional.isPresent());        List<JSONObject> parsedList = resultOptional.get().getMessages();        Assert.assertEquals(10, parsedList.size());    }}
public void metron_f6593_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertTrue(resultOptional.isPresent());        Optional<Throwable> throwableOptional = resultOptional.get().getMasterThrowable();        List<JSONObject> resultList = resultOptional.get().getMessages();        Map<Object, Throwable> errorMap = resultOptional.get().getMessageThrowables();        Assert.assertFalse(throwableOptional.isPresent());        Assert.assertEquals(0, errorMap.size());        Assert.assertEquals(10, resultList.size());    }}
public Map metron_f6594_0()
{    Map testData = new HashMap<String, String>();    String input;    try (FileInputStream stream = new FileInputStream(new File("src/test/resources/logData/multi_elb_log.txt"))) {        input = IOUtils.toString(stream);    } catch (IOException ioe) {        throw new IllegalStateException("failed to open file", ioe);    }        testData.put(input, "");    return testData;}
public String metron_f6595_0()
{    return "true";}
public String metron_f6596_0()
{    return "../../metron-integration-test/src/main/sample/patterns/test";}
public String metron_f6597_0()
{    return "ELBACCESSLOGS";}
public List<String> metron_f6598_0()
{    return new ArrayList<String>() {        {            add("timestamp");        }    };}
public String metron_f6599_0()
{    return "yyyy-MM-dd'T'HH:mm:ss.S'Z'";}
public String metron_f6600_0()
{    return "timestamp";}
public void metron_f6601_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        List<JSONObject> parsedList = grokParser.parse(rawMessage);    }}
public void metron_f6602_0() throws IOException, ParseException
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("grokPath", getGrokPath());    parserConfig.put("patternLabel", getGrokPatternLabel());    parserConfig.put("timestampField", getTimestampField());    parserConfig.put("dateFormat", getDateFormat());    parserConfig.put("timeFields", getTimeFields());    parserConfig.put("multiLine", getMultiLine());    GrokParser grokParser = new GrokParser();    grokParser.configure(parserConfig);    grokParser.init();    JSONParser jsonParser = new JSONParser();    Map<String, String> testData = getTestData();    for (Map.Entry<String, String> e : testData.entrySet()) {        byte[] rawMessage = e.getKey().getBytes(StandardCharsets.UTF_8);        Optional<MessageParserResult<JSONObject>> resultOptional = grokParser.parseOptionalResult(rawMessage);        Assert.assertTrue(resultOptional.isPresent());        Optional<Throwable> throwableOptional = resultOptional.get().getMasterThrowable();        List<JSONObject> resultList = resultOptional.get().getMessages();        Map<Object, Throwable> errorMap = resultOptional.get().getMessageThrowables();        Assert.assertFalse(throwableOptional.isPresent());        Assert.assertEquals(3, errorMap.size());        Assert.assertEquals(10, resultList.size());    }}
public Map metron_f6603_0()
{    Map testData = new HashMap<String, String>();    String input;    try (FileInputStream stream = new FileInputStream(new File("src/test/resources/logData/multi_elb_with_errors_log.txt"))) {        input = IOUtils.toString(stream);    } catch (IOException ioe) {        throw new IllegalStateException("failed to open file", ioe);    }        testData.put(input, "");    return testData;}
public String metron_f6604_0()
{    return "../../metron-integration-test/src/main/sample/patterns/test";}
public String metron_f6605_0()
{    return "ELBACCESSLOGS";}
public List<String> metron_f6606_0()
{    return new ArrayList<String>() {        {            add("timestamp");        }    };}
public String metron_f6607_0()
{    return "true";}
public String metron_f6608_0()
{    return "yyyy-MM-dd'T'HH:mm:ss.S'Z'";}
public String metron_f6609_0()
{    return "timestamp";}
public void metron_f6610_0() throws IOException
{    parserConfigurations = new ParserConfigurations();    SensorParserConfig broConfig = SensorParserConfig.fromBytes(broConfigString.getBytes(StandardCharsets.UTF_8));    SensorParserConfig snortConfig = SensorParserConfig.fromBytes(snortConfigString.getBytes(StandardCharsets.UTF_8));    parserConfigurations.updateSensorParserConfig("bro", broConfig);    parserConfigurations.updateSensorParserConfig("snort", snortConfig);    parserConfigurations.updateGlobalConfig(JSONUtils.INSTANCE.load(globalConfigString, JSONUtils.MAP_SUPPLIER));    parserRunner = new ParserRunnerImpl(new HashSet<>(Arrays.asList("bro", "snort")));    broParser = mock(MessageParser.class);    snortParser = mock(MessageParser.class);    stellarFilter = mock(StellarFilter.class);    mockStatic(ReflectionUtils.class);    mockStatic(Filters.class);    when(broParser.getReadCharset()).thenReturn(StandardCharsets.UTF_8);    when(ReflectionUtils.createInstance("org.apache.metron.parsers.bro.BasicBroParser")).thenReturn(broParser);    when(ReflectionUtils.createInstance("org.apache.metron.parsers.snort.BasicSnortParser")).thenReturn(snortParser);    when(Filters.get("org.apache.metron.parsers.filters.StellarFilter", broConfig.getParserConfig())).thenReturn(stellarFilter);}
public void metron_f6611_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("A parser config supplier must be set before initializing the ParserRunner.");    parserRunner.init(null, null);}
public void metron_f6612_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("A stellar context must be set before initializing the ParserRunner.");    parserRunner.init(() -> parserConfigurations, null);}
public void metron_f6613_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("Could not initialize parsers.  Cannot find configuration for sensor test.");    parserRunner = new ParserRunnerImpl(new HashSet<String>() {        {            add("test");        }    });    parserRunner.init(() -> parserConfigurations, mock(Context.class));}
public void metron_f6614_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("Could not execute parser.  Cannot find configuration for sensor test.");    parserRunner = new ParserRunnerImpl(new HashSet<String>() {        {            add("test");        }    });    parserRunner.execute("test", mock(RawMessage.class), parserConfigurations);}
public void metron_f6615_0() throws Exception
{    Context stellarContext = mock(Context.class);    Map<String, Object> broParserConfig = parserConfigurations.getSensorParserConfig("bro").getParserConfig();    Map<String, Object> snortParserConfig = parserConfigurations.getSensorParserConfig("snort").getParserConfig();    parserRunner.init(() -> parserConfigurations, stellarContext);    {                Assert.assertEquals(stellarContext, parserRunner.getStellarContext());    }    Map<String, ParserComponent> sensorToParserComponentMap = parserRunner.getSensorToParserComponentMap();    {                Assert.assertEquals(2, sensorToParserComponentMap.size());        ParserComponent broComponent = sensorToParserComponentMap.get("bro");        Assert.assertEquals(broParser, broComponent.getMessageParser());        Assert.assertEquals(stellarFilter, broComponent.getFilter());        verify(broParser, times(1)).init();        verify(broParser, times(1)).configure(broParserConfig);        verifyNoMoreInteractions(broParser);        verifyNoMoreInteractions(stellarFilter);    }    {                ParserComponent snortComponent = sensorToParserComponentMap.get("snort");        Assert.assertEquals(snortParser, snortComponent.getMessageParser());        Assert.assertNull(snortComponent.getFilter());        verify(snortParser, times(1)).init();        verify(snortParser, times(1)).configure(snortParserConfig);        verifyNoMoreInteractions(snortParser);    }}
public void metron_f6616_0()
{    parserRunner = spy(parserRunner);    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), new HashMap<>());    JSONObject parsedMessage1 = new JSONObject();    parsedMessage1.put("field", "parsedMessage1");    JSONObject parsedMessage2 = new JSONObject();    parsedMessage2.put("field", "parsedMessage2");    Object rawMessage1 = new RawMessage("raw_message1".getBytes(StandardCharsets.UTF_8), new HashMap<>());    Object rawMessage2 = new RawMessage("raw_message2".getBytes(StandardCharsets.UTF_8), new HashMap<>());    Throwable throwable1 = mock(Throwable.class);    Throwable throwable2 = mock(Throwable.class);    MessageParserResult<JSONObject> messageParserResult = new DefaultMessageParserResult<>(Arrays.asList(parsedMessage1, parsedMessage2), new HashMap<Object, Throwable>() {        {            put(rawMessage1, throwable1);            put(rawMessage2, throwable2);        }    });    JSONObject processedMessage = new JSONObject();    processedMessage.put("field", "processedMessage1");    MetronError processedError = new MetronError().withMessage("processedError");    ProcessResult processedMessageResult = mock(ProcessResult.class);    ProcessResult processedErrorResult = mock(ProcessResult.class);    when(broParser.parseOptionalResult(rawMessage.getMessage())).thenReturn(Optional.of(messageParserResult));    when(processedMessageResult.getMessage()).thenReturn(processedMessage);    when(processedErrorResult.isError()).thenReturn(true);    when(processedErrorResult.getError()).thenReturn(processedError);    doReturn(Optional.of(processedMessageResult)).when(parserRunner).processMessage("bro", parsedMessage1, rawMessage, broParser, parserConfigurations);    doReturn(Optional.of(processedErrorResult)).when(parserRunner).processMessage("bro", parsedMessage2, rawMessage, broParser, parserConfigurations);    MetronError expectedParseError1 = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(throwable1).withSensorType(Collections.singleton("bro")).addRawMessage(rawMessage1);    MetronError expectedParseError2 = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(throwable2).withSensorType(Collections.singleton("bro")).addRawMessage(rawMessage2);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    ParserRunnerResults<JSONObject> parserRunnerResults = parserRunner.execute("bro", rawMessage, parserConfigurations);    Assert.assertEquals(1, parserRunnerResults.getMessages().size());    Assert.assertTrue(parserRunnerResults.getMessages().contains(processedMessage));    Assert.assertEquals(3, parserRunnerResults.getErrors().size());    Assert.assertTrue(parserRunnerResults.getErrors().contains(processedError));    Assert.assertTrue(parserRunnerResults.getErrors().contains(expectedParseError1));    Assert.assertTrue(parserRunnerResults.getErrors().contains(expectedParseError2));}
public void metron_f6617_0()
{    parserRunner = spy(parserRunner);    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), new HashMap<>());    Throwable masterThrowable = mock(Throwable.class);    MessageParserResult<JSONObject> messageParserResult = new DefaultMessageParserResult<>(masterThrowable);    when(broParser.parseOptionalResult(rawMessage.getMessage())).thenReturn(Optional.of(messageParserResult));    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    ParserRunnerResults<JSONObject> parserRunnerResults = parserRunner.execute("bro", rawMessage, parserConfigurations);    verify(parserRunner, times(0)).processMessage(any(), any(), any(), any(), any());    MetronError expectedError = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(masterThrowable).withSensorType(Collections.singleton("bro")).addRawMessage(rawMessage.getMessage());    Assert.assertEquals(1, parserRunnerResults.getErrors().size());    Assert.assertTrue(parserRunnerResults.getErrors().contains(expectedError));}
public void metron_f6618_0()
{    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    inputMessage.put("ip_src_addr", "192.168.1.1");    inputMessage.put("ip_dst_addr", "192.168.1.2");    RawMessage rawMessage = new RawMessage("raw_message_for_testing".getBytes(StandardCharsets.UTF_8), new HashMap<>());    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("source.type", "bro");    expectedOutput.put("ip_src_addr", "192.168.1.1");    expectedOutput.put("ip_dst_addr", "192.168.1.2");    expectedOutput.put(Fields.ORIGINAL.getName(), "raw_message_for_testing");    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);    when(broParser.validate(expectedOutput)).thenReturn(true);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertFalse(processResult.get().isError());    Assert.assertEquals(expectedOutput, processResult.get().getMessage());}
public void metron_f6619_0()
{    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    inputMessage.put("ip_src_addr", "192.168.1.1");    inputMessage.put("ip_dst_addr", "192.168.1.2");    inputMessage.put(Fields.ORIGINAL.getName(), "original_string_added_by_parser");    RawMessage rawMessage = new RawMessage("raw_message_for_testing".getBytes(StandardCharsets.UTF_8), new HashMap<>());    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("source.type", "bro");    expectedOutput.put("ip_src_addr", "192.168.1.1");    expectedOutput.put("ip_dst_addr", "192.168.1.2");    expectedOutput.put(Fields.ORIGINAL.getName(), "original_string_added_by_parser");    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);    when(broParser.validate(expectedOutput)).thenReturn(true);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertFalse(processResult.get().isError());    Assert.assertEquals(expectedOutput, processResult.get().getMessage());}
public void metron_f6620_0()
{    Map<String, Object> metadata = new HashMap<>();    metadata.put("metron.metadata.topic", "bro");    metadata.put("metron.metadata.partition", 0);    metadata.put("metron.metadata.offset", 123);    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), metadata);    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("source.type", "bro");    expectedOutput.put(Fields.ORIGINAL.getName(), "raw_message");    MetronError expectedMetronError = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton("bro")).withMetadata(metadata).addRawMessage(inputMessage);    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);        when(broParser.validate(expectedOutput)).thenReturn(false);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertTrue(processResult.get().isError());    Assert.assertEquals(expectedMetronError, processResult.get().getError());}
public void metron_f6621_0()
{    Map<String, Object> metadata = new HashMap<>();    metadata.put("metron.metadata.topic", "bro");    metadata.put("metron.metadata.partition", 0);    metadata.put("metron.metadata.offset", 123);    JSONObject inputMessage = new JSONObject();    inputMessage.put("guid", "guid");    inputMessage.put("ip_src_addr", "test");    inputMessage.put("ip_dst_addr", "test");    RawMessage rawMessage = new RawMessage("raw_message".getBytes(StandardCharsets.UTF_8), metadata);    JSONObject expectedOutput = new JSONObject();    expectedOutput.put("guid", "guid");    expectedOutput.put("ip_src_addr", "test");    expectedOutput.put("ip_dst_addr", "test");    expectedOutput.put("source.type", "bro");    expectedOutput.put(Fields.ORIGINAL.getName(), "raw_message");    MetronError expectedMetronError = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton("bro")).addRawMessage(inputMessage).withMetadata(metadata).withErrorFields(new HashSet<>(Arrays.asList("ip_src_addr", "ip_dst_addr")));    when(stellarFilter.emit(expectedOutput, parserRunner.getStellarContext())).thenReturn(true);    when(broParser.validate(expectedOutput)).thenReturn(true);    parserRunner.setSensorToParserComponentMap(new HashMap<String, ParserComponent>() {        {            put("bro", new ParserComponent(broParser, stellarFilter));        }    });    Optional<ParserRunnerImpl.ProcessResult> processResult = parserRunner.processMessage("bro", inputMessage, rawMessage, broParser, parserConfigurations);    Assert.assertTrue(processResult.isPresent());    Assert.assertTrue(processResult.get().isError());    Assert.assertEquals(expectedMetronError, processResult.get().getError());}
public void metron_f6622_0() throws Exception
{    regularExpressionsParser = new RegularExpressionsParser();}
public void metron_f6623_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(parserConfig1);    regularExpressionsParser.configure(parserConfig);    JSONObject parsed = parse(message);        Map<String, Object> expectedJson = new HashMap<>();    Assert.assertEquals(parsed.get("device_name"), "deviceName");    Assert.assertEquals(parsed.get("dst_process_name"), "sshd");    Assert.assertEquals(parsed.get("dst_process_id"), "11672");    Assert.assertEquals(parsed.get("dst_user_id"), "prod");    Assert.assertEquals(parsed.get("ip_src_addr"), "22.22.22.22");    Assert.assertEquals(parsed.get("ip_src_port"), "55555");    Assert.assertEquals(parsed.get("app_protocol"), "ssh2");    Assert.assertEquals(parsed.get("original_string"), "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2");    Assert.assertTrue(parsed.containsKey("timestamp"));}
public void metron_f6624_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(parserConfigNoMessageHeader);    regularExpressionsParser.configure(parserConfig);    JSONObject parsed = parse(message);        Assert.assertEquals(parsed.get("dst_process_name"), "sshd");    Assert.assertEquals(parsed.get("dst_process_id"), "11672");    Assert.assertEquals(parsed.get("dst_user_id"), "prod");    Assert.assertEquals(parsed.get("ip_src_addr"), "22.22.22.22");    Assert.assertEquals(parsed.get("ip_src_port"), "55555");    Assert.assertEquals(parsed.get("app_protocol"), "ssh2");    Assert.assertEquals(parsed.get("original_string"), "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2");    Assert.assertTrue(parsed.containsKey("timestamp"));}
public void metron_f6625_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(invalidParserConfig);    regularExpressionsParser.configure(parserConfig);    parse(message);}
public void metron_f6626_0() throws Exception
{    String message = "<38>Jun 20 15:01:17 deviceName sshd[11672]: Accepted publickey for prod from 22.22.22.22 port 55555 ssh2";    JSONObject parserConfig = (JSONObject) new JSONParser().parse(noRecordTypeParserConfig);    regularExpressionsParser.configure(parserConfig);    parse(message);}
private JSONObject metron_f6627_0(String message) throws Exception
{    List<JSONObject> result = regularExpressionsParser.parse(message.getBytes(StandardCharsets.UTF_8));    if (result.size() > 0) {        return result.get(0);    }    throw new Exception("Could not parse : " + message);}
public void metron_f6628_0() throws ParseException
{    JSONObject config = (JSONObject) new JSONParser().parse(parserConfig1);    config.put(MessageParser.READ_CHARSET, StandardCharsets.UTF_16.toString());    regularExpressionsParser.configure(config);    assertThat(regularExpressionsParser.getReadCharset(), equalTo(StandardCharsets.UTF_16));}
public void metron_f6629_0() throws ParseException
{    JSONObject config = (JSONObject) new JSONParser().parse(parserConfig1);    regularExpressionsParser.configure(config);    assertThat(regularExpressionsParser.getReadCharset(), equalTo(StandardCharsets.UTF_8));}
public Map metron_f6630_0()
{    Map testData = new HashMap<String, String>();    String input = "1453994987000|2016-01-28 15:29:48|   0.000|   0.000|  6|                          216.21.170.221|   80|                               10.0.2.15|39468|      AS|       0|       0|       0|22efa001|00000000|000|000|       1|      44|       0|       0|    0|idle";    testData.put(input, result);    return testData;}
public String metron_f6631_0()
{    return "false";}
public String metron_f6632_0()
{    return "../../metron-integration-test/src/main/sample/patterns/test";}
public String metron_f6633_0()
{    return "YAF_DELIMITED";}
public List<String> metron_f6634_0()
{    return new ArrayList<String>() {        {            add("end_time");        }    };}
public String metron_f6635_0()
{    return "yyyy-MM-dd HH:mm:ss";}
public String metron_f6636_0()
{    return "start_time";}
public void metron_f6637_0()
{    Map<String, Object> parserConfig = new HashMap<>();    Syslog3164Parser testParser = new Syslog3164Parser();    testParser.configure(parserConfig);    testParser.init();    assertTrue(testParser.deviceClock.getZone().equals(ZoneOffset.UTC));}
public void metron_f6638_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "UTC-05:00");    Syslog3164Parser testParser = new Syslog3164Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6639_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "America/New_York");    Syslog3164Parser testParser = new Syslog3164Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6640_0()
{    test(expectedMessage1, (message) -> Assert.assertEquals(expectedHostNameOne, message.get(SyslogFieldKeys.HEADER_HOSTNAME.getField())));}
public void metron_f6641_0()
{    test("not valid", (message) -> Assert.assertTrue(false));}
public void metron_f6642_0(String line, Consumer<JSONObject> msgIdChecker)
{    Syslog3164Parser parser = new Syslog3164Parser();    Map<String, Object> config = new HashMap<>();    parser.configure(config);    parser.parseOptionalResult(line.getBytes(StandardCharsets.UTF_8));}
public void metron_f6643_0() throws Exception
{    Syslog3164Parser parser = new Syslog3164Parser();    Map<String, Object> config = new HashMap<>();    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append(SYSLOG_LINE_ALL);    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> parsedList = resultOptional.get().getMessages();    Assert.assertEquals(3, parsedList.size());}
public void metron_f6644_0() throws Exception
{    Syslog3164Parser parser = new Syslog3164Parser();    Map<String, Object> config = new HashMap<>();    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append("HEREWEGO!!!!\n").append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append("BOOM!\n").append(SYSLOG_LINE_ALL).append("\nOHMY!");    Optional<MessageParserResult<JSONObject>> output = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(output.isPresent());    Assert.assertEquals(3, output.get().getMessages().size());    Assert.assertEquals(3, output.get().getMessageThrowables().size());}
public void metron_f6645_0()
{    Map<String, Object> parserConfig = new HashMap<>();    Syslog5424Parser testParser = new Syslog5424Parser();    testParser.configure(parserConfig);    testParser.init();    assertTrue(testParser.deviceClock.getZone().equals(ZoneOffset.UTC));}
public void metron_f6646_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "UTC-05:00");    Syslog5424Parser testParser = new Syslog5424Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6647_0()
{    Map<String, Object> parserConfig = new HashMap<>();    parserConfig.put("deviceTimeZone", "America/New_York");    Syslog5424Parser testParser = new Syslog5424Parser();    testParser.configure(parserConfig);    testParser.init();    ZonedDateTime deviceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), testParser.deviceClock.getZone());    ZonedDateTime referenceTime = ZonedDateTime.ofInstant(Instant.ofEpochSecond(1475323200), ZoneOffset.ofHours(-5));    assertTrue(deviceTime.isEqual(referenceTime));}
public void metron_f6648_0()
{    test(null, SYSLOG_LINE_ALL, (message) -> Assert.assertEquals(expectedMessageId, message.get(SyslogFieldKeys.HEADER_MSGID.getField())));}
public void metron_f6649_0()
{    test(NilPolicy.OMIT, SYSLOG_LINE_MISSING, (message) -> Assert.assertFalse(message.containsKey(SyslogFieldKeys.HEADER_MSGID)));}
public void metron_f6650_0()
{    test(NilPolicy.DASH, SYSLOG_LINE_MISSING, (message) -> Assert.assertEquals("-", message.get(SyslogFieldKeys.HEADER_MSGID.getField())));}
public void metron_f6651_0()
{    test(NilPolicy.NULL, SYSLOG_LINE_MISSING, (message) -> {        Assert.assertTrue(message.containsKey(SyslogFieldKeys.HEADER_MSGID.getField()));        Assert.assertNull(message.get(SyslogFieldKeys.HEADER_MSGID.getField()));    });}
public void metron_f6652_0()
{    test(null, "not valid", (message) -> Assert.assertTrue(false));}
public void metron_f6653_0(NilPolicy nilPolicy, String line, Consumer<JSONObject> msgIdChecker)
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    if (nilPolicy != null) {        config.put(Syslog5424Parser.NIL_POLICY_CONFIG, nilPolicy.name());    }    parser.configure(config);    parser.parseOptionalResult(line.getBytes(StandardCharsets.UTF_8));}
public void metron_f6654_0() throws Exception
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.DASH.name());    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append(SYSLOG_LINE_ALL);    Optional<MessageParserResult<JSONObject>> resultOptional = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(resultOptional);    Assert.assertTrue(resultOptional.isPresent());    List<JSONObject> parsedList = resultOptional.get().getMessages();    Assert.assertEquals(3, parsedList.size());}
public void metron_f6655_0() throws Exception
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.DASH.name());    parser.configure(config);    StringBuilder builder = new StringBuilder();    builder.append("HEREWEGO!!!!\n").append(SYSLOG_LINE_ALL).append("\n").append(SYSLOG_LINE_MISSING).append("\n").append("BOOM!\n").append(SYSLOG_LINE_ALL).append("\nOHMY!");    Optional<MessageParserResult<JSONObject>> output = parser.parseOptionalResult(builder.toString().getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(output.isPresent());    Assert.assertEquals(3, output.get().getMessages().size());    Assert.assertEquals(3, output.get().getMessageThrowables().size());}
public void metron_f6656_0()
{    Syslog5424Parser parser = new Syslog5424Parser();    Map<String, Object> config = new HashMap<>();    String timeStampString = null;    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.DASH.name());    parser.configure(config);    Optional<MessageParserResult<JSONObject>> output = parser.parseOptionalResult(SYSLOG_LINE_MISSING_DATE.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(output);    Assert.assertTrue(output.isPresent());    Assert.assertNotNull(output.get().getMessages().get(0).get("timestamp").toString());    config.clear();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.NULL.name());    parser.configure(config);    output = parser.parseOptionalResult(SYSLOG_LINE_MISSING_DATE.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(output);    Assert.assertTrue(output.isPresent());    timeStampString = output.get().getMessages().get(0).get("timestamp").toString();    Assert.assertNotNull(timeStampString);    config.clear();    config.put(Syslog5424Parser.NIL_POLICY_CONFIG, NilPolicy.OMIT.name());    parser.configure(config);    output = parser.parseOptionalResult(SYSLOG_LINE_MISSING_DATE.getBytes(StandardCharsets.UTF_8));    Assert.assertNotNull(output);    Assert.assertTrue(output.isPresent());}
public void metron_f6657_0() throws ParseException
{    Boolean adjustTimezone = true;    String[] timeToTest = { "Mar", "2", "05:24:39" };    int year = Calendar.getInstance().get(Calendar.YEAR);    String timeToTestWithYear = String.valueOf(year) + " " + timeToTest[0] + " " + timeToTest[1] + " " + timeToTest[2];    SimpleDateFormat sdf = new SimpleDateFormat("yyyy MMM d HH:mm:ss", Locale.ENGLISH);    sdf.setTimeZone(TimeZone.getTimeZone("GMT"));    Date date = sdf.parse(timeToTestWithYear);    Long expectedTs = date.getTime();    Long ts = ParserUtils.convertToEpoch(timeToTest[0], timeToTest[1], timeToTest[2], adjustTimezone);    assertEquals(expectedTs, ts);}
public void metron_f6658_0() throws ParseException
{    String originalTimestamp = "Oct  9 13:42:11";        ZonedDateTime fixedInstant = ZonedDateTime.of(2016, 10, 8, 18, 30, 30, 0, ZoneOffset.UTC);    Clock fixedClock = Clock.fixed(fixedInstant.toInstant(), fixedInstant.getZone());    assertEquals(SyslogUtils.parseTimestampToEpochMillis(originalTimestamp, fixedClock), 1476020531000L);}
public void metron_f6659_0() throws ParseException
{    String originalTimestamp = "Oct  9 13:42:11";        ZonedDateTime fixedInstant = ZonedDateTime.of(2016, 10, 1, 18, 30, 30, 0, ZoneOffset.UTC);    Clock fixedClock = Clock.fixed(fixedInstant.toInstant(), fixedInstant.getZone());    assertEquals(SyslogUtils.parseTimestampToEpochMillis(originalTimestamp, fixedClock), 1444398131000L);}
public void metron_f6660_0() throws ParseException
{    String originalTimestamp = "Oct 09 2015 13:42:11";    assertEquals(getParsedEpochMillis(originalTimestamp), 1444398131000L);}
public void metron_f6661_0() throws ParseException
{    String originalTimestamp = "2015-10-09T13:42:11.52Z";    assertEquals(getParsedEpochMillis(originalTimestamp), 1444398131520L);}
public void metron_f6662_0() throws ParseException
{    String originalTimestamp = "2015-10-09T08:42:11.52-05:00";    assertEquals(getParsedEpochMillis(originalTimestamp), 1444398131520L);}
private long metron_f6663_0(String originalTimestamp) throws ParseException
{    return SyslogUtils.parseTimestampToEpochMillis(originalTimestamp, Clock.systemUTC());}
public ParserBolt metron_f6664_0(int batchTimeoutDivisor)
{    if (batchTimeoutDivisor <= 0) {        throw new IllegalArgumentException(String.format("batchTimeoutDivisor must be positive. Value provided was %s", batchTimeoutDivisor));    }    this.batchTimeoutDivisor = batchTimeoutDivisor;    return this;}
public int metron_f6665_0()
{    return batchTimeoutDivisor;}
protected void metron_f6666_0(Map<String, WriterHandler> sensorToWriterMap)
{    this.sensorToWriterMap = sensorToWriterMap;}
protected Map<String, String> metron_f6667_0()
{    return topicToSensorMap;}
protected void metron_f6668_0(Map<String, String> topicToSensorMap)
{    this.topicToSensorMap = topicToSensorMap;}
public void metron_f6669_0(MessageGetStrategy messageGetStrategy)
{    this.messageGetStrategy = messageGetStrategy;}
public void metron_f6670_0(OutputCollector collector)
{    this.collector = collector;}
public void metron_f6671_0(AckTuplesPolicy ackTuplesPolicy)
{    this.ackTuplesPolicy = ackTuplesPolicy;}
public Map<String, Object> metron_f6672_1()
{                Function<WriterConfiguration, WriterConfiguration> configurationXform;    WriterHandler writer = sensorToWriterMap.entrySet().iterator().next().getValue();    if (writer.isWriterToBulkWriter()) {        configurationXform = WriterToBulkWriter.TRANSFORMATION;    } else {        configurationXform = x -> x;    }    WriterConfiguration writerconf = configurationXform.apply(getConfigurationStrategy().createWriterConfig(writer.getBulkMessageWriter(), getConfigurations()));    BatchTimeoutHelper timeoutHelper = new BatchTimeoutHelper(writerconf::getAllConfiguredTimeouts, batchTimeoutDivisor);    this.requestedTickFreqSecs = timeoutHelper.getRecommendedTickInterval();        this.maxBatchTimeout = timeoutHelper.getMaxBatchTimeout();    Map<String, Object> conf = super.getComponentConfiguration();    if (conf == null) {        conf = new HashMap<>();    }    conf.put(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, requestedTickFreqSecs);        return conf;}
public void metron_f6673_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    super.prepare(stormConf, context, collector);    messageGetStrategy = MessageGetters.DEFAULT_BYTES_FROM_POSITION.get();    this.collector = collector;    this.parserRunner.init(this::getConfigurations, initializeStellar());    ackTuplesPolicy = new AckTuplesPolicy(collector, messageGetStrategy);        for (Map.Entry<String, WriterHandler> entry : sensorToWriterMap.entrySet()) {        String sensor = entry.getKey();        SensorParserConfig config = getSensorParserConfig(sensor);        if (config != null) {            config.init();            topicToSensorMap.put(config.getSensorTopic(), sensor);        } else {            throw new IllegalStateException("Unable to retrieve a parser config for " + sensor);        }        WriterHandler writer = sensorToWriterMap.get(sensor);        if (maxBatchTimeout == 0) {                                    WriterConfiguration writerConfig = getConfigurationStrategy().createWriterConfig(writer.getBulkMessageWriter(), getConfigurations());            BatchTimeoutHelper timeoutHelper = new BatchTimeoutHelper(writerConfig::getAllConfiguredTimeouts, batchTimeoutDivisor);            maxBatchTimeout = timeoutHelper.getMaxBatchTimeout();        }        writer.init(stormConf, context, collector, getConfigurations(), ackTuplesPolicy, maxBatchTimeout);    }}
public void metron_f6674_0(Tuple tuple)
{    if (TupleUtils.isTick(tuple)) {        handleTickTuple(tuple);        return;    }    byte[] originalMessage = (byte[]) messageGetStrategy.get(tuple);    String topic = tuple.getStringByField(FieldsConfiguration.TOPIC.getFieldName());    String sensorType = topicToSensorMap.get(topic);    try {        ParserConfigurations parserConfigurations = getConfigurations();        SensorParserConfig sensorParserConfig = parserConfigurations.getSensorParserConfig(sensorType);        RawMessage rawMessage = RawMessageUtil.INSTANCE.getRawMessage(sensorParserConfig.getRawMessageStrategy(), tuple, originalMessage, sensorParserConfig.getReadMetadata(), sensorParserConfig.getRawMessageStrategyConfig());        ParserRunnerResults<JSONObject> parserRunnerResults = parserRunner.execute(sensorType, rawMessage, parserConfigurations);        parserRunnerResults.getErrors().forEach(error -> handleError(collector, error));        WriterHandler writer = sensorToWriterMap.get(sensorType);        int numWritten = 0;        List<JSONObject> messages = parserRunnerResults.getMessages();        List<String> messageIds = messages.stream().map(MessageUtils::getGuid).collect(Collectors.toList());        ackTuplesPolicy.addTupleMessageIds(tuple, messageIds);        for (int i = 0; i < messages.size(); i++) {            String messageId = messageIds.get(i);            JSONObject message = messages.get(i);            try {                writer.write(sensorType, new BulkMessage<>(messageId, message), getConfigurations());                numWritten++;            } catch (Exception ex) {                handleError(sensorType, originalMessage, tuple, ex, collector);            }        }        if (numWritten == 0) {            collector.ack(tuple);        }    } catch (Throwable ex) {        handleError(sensorType, originalMessage, tuple, ex, collector);        collector.ack(tuple);    }}
protected Context metron_f6675_0()
{    Map<String, Object> cacheConfig = new HashMap<>();    for (String sensorType : this.parserRunner.getSensorTypes()) {        SensorParserConfig config = getSensorParserConfig(sensorType);        if (config != null) {            cacheConfig.putAll(config.getCacheConfig());        }    }    Cache<CachingStellarProcessor.Key, Object> cache = CachingStellarProcessor.createCache(cacheConfig);    Context.Builder builder = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).with(Context.Capabilities.GLOBAL_CONFIG, () -> getConfigurations().getGlobalConfig()).with(Context.Capabilities.STELLAR_CONFIG, () -> getConfigurations().getGlobalConfig());    if (cache != null) {        builder = builder.with(Context.Capabilities.CACHE, () -> cache);    }    Context stellarContext = builder.build();    StellarFunctions.initialize(stellarContext);    return stellarContext;}
protected void metron_f6676_0(Tuple tuple)
{    try {        for (Entry<String, WriterHandler> entry : sensorToWriterMap.entrySet()) {            entry.getValue().flush(getConfigurations(), messageGetStrategy);        }    } catch (Exception e) {        throw new RuntimeException("This should have been caught in the writerHandler.  If you see this, file a JIRA", e);    } finally {        collector.ack(tuple);    }}
protected void metron_f6677_0(String sensorType, byte[] originalMessage, Tuple tuple, Throwable ex, OutputCollector collector)
{    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(ex).withSensorType(Collections.singleton(sensorType)).addRawMessage(originalMessage);    handleError(collector, error);}
protected void metron_f6678_0(OutputCollector collector, MetronError error)
{    StormErrorUtils.handleError(collector, error);}
public void metron_f6679_0(OutputFieldsDeclarer declarer)
{    declarer.declareStream(Constants.ERROR_STREAM, new Fields("message"));}
public WriterBolt metron_f6680_0(Constants.ErrorType errorType)
{    this.errorType = errorType;    return this;}
public void metron_f6681_0(Map stormConf, TopologyContext context, OutputCollector collector)
{    this.collector = collector;    messageGetStrategy = MessageGetters.DEFAULT_JSON_FROM_FIELD.get();    ackTuplesPolicy = new AckTuplesPolicy(collector, messageGetStrategy);    handler.init(stormConf, context, collector, configuration, ackTuplesPolicy, UNINITIALIZED_MAX_BATCH_TIMEOUT);}
private JSONObject metron_f6682_0(Tuple tuple)
{    Object ret = tuple.getValueByField("message");    if (ret != null) {        ret = tuple.getValue(0);    }    if (ret != null) {        return (JSONObject) ((JSONObject) ret).clone();    } else {        return null;    }}
public void metron_f6683_0(Tuple tuple)
{    JSONObject message = null;    try {        message = (JSONObject) messageGetStrategy.get(tuple);        String messageId = MessageUtils.getGuid(message);        ackTuplesPolicy.addTupleMessageIds(tuple, Collections.singleton(messageId));        handler.write(sensorType, new BulkMessage<>(messageId, message), configuration);    } catch (Throwable e) {        MetronError error = new MetronError().withErrorType(errorType).withThrowable(e).withSensorType(Collections.singleton(sensorType)).addRawMessage(message);        StormErrorUtils.handleError(collector, error);        collector.ack(tuple);    }}
public boolean metron_f6685_0()
{    return messageWriter instanceof WriterToBulkWriter;}
public BulkMessageWriter metron_f6686_0()
{    return messageWriter;}
public void metron_f6687_0(Map stormConf, TopologyContext topologyContext, OutputCollector collector, ParserConfigurations configurations, AckTuplesPolicy ackTuplesPolicy, int maxBatchTimeout)
{    if (isBulk) {        writerTransformer = config -> configStrategy.createWriterConfig(messageWriter, config);    } else {        writerTransformer = config -> new SingleBatchConfigurationFacade(configStrategy.createWriterConfig(messageWriter, config));    }    try {        messageWriter.init(stormConf, writerTransformer.apply(configurations));    } catch (Exception e) {        throw new IllegalStateException("Unable to initialize message writer", e);    }    this.writerComponent = new BulkWriterComponent<>(maxBatchTimeout);    this.writerComponent.addFlushPolicy(ackTuplesPolicy);}
public void metron_f6688_0(String sensorType, BulkMessage<JSONObject> bulkWriterMessage, ParserConfigurations configurations) throws Exception
{    writerComponent.write(sensorType, bulkWriterMessage, messageWriter, writerTransformer.apply(configurations));}
public void metron_f6689_1(ParserConfigurations configurations, MessageGetStrategy messageGetStrategy) throws Exception
{    if (!(messageWriter instanceof WriterToBulkWriter)) {                        writerComponent.flushAll(messageWriter, writerTransformer.apply(configurations));    }}
public Config metron_f6690_0()
{    return config;}
public String metron_f6691_0()
{    return arg;}
public Config metron_f6692_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setNumWorkers(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6693_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setNumAckers(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6694_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setMaxTaskParallelism(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6695_0(Arg arg)
{    if (arg.getArg() != null) {        arg.getConfig().setMessageTimeoutSecs(Integer.parseInt(arg.getArg()));    }    return arg.getConfig();}
public Config metron_f6696_0(Arg arg)
{    if (arg.getArg() != null) {        File inputFile = new File(arg.getArg());        String json = null;        if (inputFile.exists()) {            try {                json = FileUtils.readFileToString(inputFile);            } catch (IOException e) {                throw new IllegalStateException("Unable to process JSON file " + inputFile, e);            }        } else {            json = arg.getArg();        }        try {            arg.getConfig().putAll(JSONUtils.INSTANCE.load(json, JSONUtils.MAP_SUPPLIER));        } catch (IOException e) {            throw new IllegalStateException("Unable to process JSON snippet.", e);        }    }    return arg.getConfig();}
public void metron_f6697_1(InputStream input, OutputStream output) throws IOException
{    String extraJars = System.getenv().get(EXTRA_JARS_ENV);    if (extraJars == null || extraJars.length() == 0) {        underlyingTransformer.transform(input, output);        return;    }    File tmpFile = File.createTempFile("metron", "jar");    tmpFile.deleteOnExit();    Set<String> entries = new HashSet<>();    try (JarOutputStream jout = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(tmpFile)))) {        try (JarInputStream jin = new JarInputStream(new BufferedInputStream(input))) {            copy(jin, jout, entries);        }        for (String fileStr : Splitter.on(",").split(extraJars)) {            File f = new File(fileStr);            if (!f.exists()) {                continue;            }                        try (JarInputStream jin = new JarInputStream(new BufferedInputStream(new FileInputStream(f)))) {                copy(jin, jout, entries);            }        }    }    underlyingTransformer.transform(new BufferedInputStream(new FileInputStream(tmpFile)), output);}
private Set<String> metron_f6698_1(JarInputStream jin, JarOutputStream jout, Set<String> entries) throws IOException
{    byte[] buffer = new byte[1024];    for (JarEntry entry = jin.getNextJarEntry(); entry != null; entry = jin.getNextJarEntry()) {        if (entries.contains(entry.getName())) {            continue;        }                entries.add(entry.getName());        jout.putNextEntry(entry);        int len = 0;        while ((len = jin.read(buffer)) > 0) {            jout.write(buffer, 0, len);        }    }    return entries;}
public TopologyBuilder metron_f6699_0()
{    return builder;}
public Config metron_f6700_0()
{    return topologyConfig;}
public static ParserTopology metron_f6701_0(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorTypes, ValueSupplier<List> spoutParallelismSupplier, ValueSupplier<List> spoutNumTasksSupplier, ValueSupplier<Integer> parserParallelismSupplier, ValueSupplier<Integer> parserNumTasksSupplier, ValueSupplier<Integer> errorWriterParallelismSupplier, ValueSupplier<Integer> errorWriterNumTasksSupplier, ValueSupplier<List> kafkaSpoutConfigSupplier, ValueSupplier<String> securityProtocolSupplier, ValueSupplier<String> outputTopicSupplier, ValueSupplier<String> errorTopicSupplier, ValueSupplier<Config> stormConfigSupplier) throws Exception
{        ParserConfigurations configs = new ParserConfigurations();    Map<String, SensorParserConfig> sensorToParserConfigs = getSensorParserConfig(zookeeperUrl, sensorTypes, configs);    Collection<SensorParserConfig> parserConfigs = sensorToParserConfigs.values();    @SuppressWarnings("unchecked")    List<Integer> spoutParallelism = (List<Integer>) spoutParallelismSupplier.get(parserConfigs, List.class);    @SuppressWarnings("unchecked")    List<Integer> spoutNumTasks = (List<Integer>) spoutNumTasksSupplier.get(parserConfigs, List.class);    int parserParallelism = parserParallelismSupplier.get(parserConfigs, Integer.class);    int parserNumTasks = parserNumTasksSupplier.get(parserConfigs, Integer.class);    int errorWriterParallelism = errorWriterParallelismSupplier.get(parserConfigs, Integer.class);    int errorWriterNumTasks = errorWriterNumTasksSupplier.get(parserConfigs, Integer.class);    String outputTopic = outputTopicSupplier.get(parserConfigs, String.class);    List<Map<String, Object>> kafkaSpoutConfig = kafkaSpoutConfigSupplier.get(parserConfigs, List.class);    Optional<String> securityProtocol = Optional.ofNullable(securityProtocolSupplier.get(parserConfigs, String.class));        TopologyBuilder builder = new TopologyBuilder();    int i = 0;    List<String> spoutIds = new ArrayList<>();    for (Entry<String, SensorParserConfig> entry : sensorToParserConfigs.entrySet()) {        KafkaSpout kafkaSpout = createKafkaSpout(zookeeperUrl, entry.getKey(), securityProtocol, Optional.ofNullable(kafkaSpoutConfig.get(i)), entry.getValue());        String spoutId = sensorToParserConfigs.size() > 1 ? "kafkaSpout-" + entry.getKey() : "kafkaSpout";        builder.setSpout(spoutId, kafkaSpout, spoutParallelism.get(i)).setNumTasks(spoutNumTasks.get(i));        spoutIds.add(spoutId);        ++i;    }        ParserBolt parserBolt = createParserBolt(zookeeperUrl, brokerUrl, sensorToParserConfigs, securityProtocol, configs, Optional.ofNullable(outputTopic));    BoltDeclarer boltDeclarer = builder.setBolt("parserBolt", parserBolt, parserParallelism).setNumTasks(parserNumTasks);    for (String spoutId : spoutIds) {        boltDeclarer.localOrShuffleGrouping(spoutId);    }        if (errorWriterNumTasks > 0) {        String errorTopic = errorTopicSupplier.get(parserConfigs, String.class);        WriterBolt errorBolt = createErrorBolt(zookeeperUrl, brokerUrl, sensorTypes.get(0), securityProtocol, configs, parserConfigs.iterator().next(), errorTopic);        builder.setBolt("errorMessageWriter", errorBolt, errorWriterParallelism).setNumTasks(errorWriterNumTasks).localOrShuffleGrouping("parserBolt", Constants.ERROR_STREAM);    }    return new ParserTopology(builder, stormConfigSupplier.get(parserConfigs, Config.class));}
private static StormKafkaSpout<Object, Object> metron_f6702_0(String zkQuorum, String sensorType, Optional<String> securityProtocol, Optional<Map<String, Object>> kafkaConfigOptional, SensorParserConfig parserConfig)
{    Map<String, Object> kafkaSpoutConfigOptions = kafkaConfigOptional.orElse(new HashMap<>());    String inputTopic = parserConfig.getSensorTopic() != null ? parserConfig.getSensorTopic() : sensorType;    kafkaSpoutConfigOptions.putIfAbsent(SpoutConfiguration.FIRST_POLL_OFFSET_STRATEGY.key, KafkaSpoutConfig.FirstPollOffsetStrategy.UNCOMMITTED_EARLIEST.name());    kafkaSpoutConfigOptions.putIfAbsent(ConsumerConfig.GROUP_ID_CONFIG, inputTopic + "_parser");    if (securityProtocol.isPresent()) {        kafkaSpoutConfigOptions.putIfAbsent("security.protocol", KafkaUtils.INSTANCE.normalizeProtocol(securityProtocol.get()));    }    return SimpleStormKafkaBuilder.create(inputTopic, zkQuorum, Arrays.asList(SimpleStormKafkaBuilder.FieldsConfiguration.VALUE.getFieldName(), SimpleStormKafkaBuilder.FieldsConfiguration.KEY.getFieldName(), SimpleStormKafkaBuilder.FieldsConfiguration.TOPIC.getFieldName()), kafkaSpoutConfigOptions);}
protected static KafkaWriter metron_f6703_0(Optional<String> broker, String zkQuorum, Optional<String> securityProtocol)
{    KafkaWriter writer = new KafkaWriter();        if (broker.isPresent()) {        writer.withBrokerUrl(broker.get());    } else {        writer.withZkQuorum(zkQuorum);    }        if (securityProtocol.isPresent()) {        HashMap<String, Object> config = new HashMap<>();        config.put("security.protocol", securityProtocol.get());        writer.withProducerConfigs(config);    }    return writer;}
private static ParserBolt metron_f6704_0(String zookeeperUrl, Optional<String> brokerUrl, Map<String, SensorParserConfig> sensorTypeToParserConfig, Optional<String> securityProtocol, ParserConfigurations configs, Optional<String> outputTopic)
{    Map<String, WriterHandler> writerConfigs = createWriterConfigs(zookeeperUrl, brokerUrl, sensorTypeToParserConfig, securityProtocol, configs, outputTopic);    return new ParserBolt(zookeeperUrl, new ParserRunnerImpl(new HashSet<>(sensorTypeToParserConfig.keySet())), writerConfigs);}
protected static Map<String, WriterHandler> metron_f6705_0(String zookeeperUrl, Optional<String> brokerUrl, Map<String, SensorParserConfig> sensorTypeToParserConfig, Optional<String> securityProtocol, ParserConfigurations configs, Optional<String> outputTopic)
{    Map<String, WriterHandler> writerConfigs = new HashMap<>();    for (Entry<String, SensorParserConfig> entry : sensorTypeToParserConfig.entrySet()) {        String sensorType = entry.getKey();        SensorParserConfig parserConfig = entry.getValue();                AbstractWriter writer;        if (parserConfig.getWriterClassName() == null) {                        writer = createKafkaWriter(brokerUrl, zookeeperUrl, securityProtocol).withTopic(outputTopic.orElse(parserConfig.getOutputTopic() != null ? parserConfig.getOutputTopic() : Constants.ENRICHMENT_TOPIC));        } else {            writer = ReflectionUtils.createInstance(parserConfig.getWriterClassName());        }                writer.configure(sensorType, new ParserWriterConfiguration(configs));                WriterHandler writerHandler = createWriterHandler(writer);        writerConfigs.put(sensorType, writerHandler);    }    return writerConfigs;}
private static WriterBolt metron_f6706_0(String zookeeperUrl, Optional<String> brokerUrl, String sensorType, Optional<String> securityProtocol, ParserConfigurations configs, SensorParserConfig parserConfig, String errorTopic)
{        AbstractWriter writer;    if (parserConfig.getErrorWriterClassName() == null) {        if (errorTopic == null) {            errorTopic = (String) configs.getGlobalConfig().get(Constants.PARSER_ERROR_TOPIC_GLOBALS_KEY);        }                writer = createKafkaWriter(brokerUrl, zookeeperUrl, securityProtocol).withTopic(errorTopic).withConfigPrefix("error");    } else {        writer = ReflectionUtils.createInstance(parserConfig.getWriterClassName());    }        writer.configure(sensorType, new ParserWriterConfiguration(configs));        WriterHandler writerHandler = createWriterHandler(writer);    return new WriterBolt(writerHandler, configs, sensorType).withErrorType(Constants.ErrorType.PARSER_ERROR);}
private static Map<String, SensorParserConfig> metron_f6707_0(String zookeeperUrl, List<String> sensorTypes, ParserConfigurations configs) throws Exception
{    Map<String, SensorParserConfig> parserConfigs = new HashMap<>();    try (CuratorFramework client = ConfigurationsUtils.getClient(zookeeperUrl)) {        client.start();        ConfigurationsUtils.updateParserConfigsFromZookeeper(configs, client);        for (String sensorType : sensorTypes) {            SensorParserConfig parserConfig = configs.getSensorParserConfig(sensorType);            if (parserConfig == null) {                throw new IllegalStateException("Cannot find the parser configuration in zookeeper for " + sensorType + "." + "  Please check that it exists in zookeeper by using the 'zk_load_configs.sh -m DUMP' command.");            }            parserConfigs.put(sensorType, parserConfig);        }    }    return parserConfigs;}
private static WriterHandler metron_f6708_0(AbstractWriter writer)
{    if (writer instanceof BulkMessageWriter) {        return new WriterHandler((BulkMessageWriter<JSONObject>) writer);    } else if (writer instanceof MessageWriter) {        return new WriterHandler((MessageWriter<JSONObject>) writer);    } else {        throw new IllegalStateException("Unable to create parser bolt: writer must be a MessageWriter or a BulkMessageWriter");    }}
public boolean metron_f6709_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f6710_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public String metron_f6711_0(CommandLine cli, String def)
{    return has(cli) ? cli.getOptionValue(shortCode) : def;}
public static Optional<Config> metron_f6712_0(CommandLine cli)
{    return getConfig(cli, new Config());}
public static Optional<Config> metron_f6713_0(CommandLine cli, Config config)
{    if (EXTRA_OPTIONS.has(cli)) {        Map<String, Object> extraOptions = readJSONMapFromFile(new File(EXTRA_OPTIONS.get(cli)));        config.putAll(extraOptions);    }    for (ParserOptions option : ParserOptions.values()) {        config = option.configHandler.apply(new Arg(config, option.get(cli)));    }    return config.isEmpty() ? Optional.empty() : Optional.of(config);}
public static CommandLine metron_f6714_0(CommandLineParser parser, String[] args) throws ParseException
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        throw e;    }}
public static void metron_f6715_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("ParserTopologyCLI", getOptions());}
public static Options metron_f6716_0()
{    Options ret = new Options();    for (ParserOptions o : ParserOptions.values()) {        ret.addOption(o.option);    }    return ret;}
private static CommandLine metron_f6717_0(Options options, String[] args)
{    /*     * The general gist is that in order to pass args to storm jar,     * we have to disregard options that we don't know about in the CLI.     * Storm will ignore our args, we have to do the same.     */    CommandLineParser parser = new PosixParser() {        @Override        protected void processOption(String arg, ListIterator iter) throws ParseException {            if (getOptions().hasOption(arg)) {                super.processOption(arg, iter);            }        }    };    try {        return ParserOptions.parse(parser, args);    } catch (ParseException pe) {        pe.printStackTrace();        final HelpFormatter usageFormatter = new HelpFormatter();        usageFormatter.printHelp("ParserTopologyCLI", null, options, null, true);        System.exit(-1);        return null;    }}
protected void metron_f6718_0(String arg, ListIterator iter) throws ParseException
{    if (getOptions().hasOption(arg)) {        super.processOption(arg, iter);    }}
public ParserTopologyBuilder.ParserTopology metron_f6719_0(final CommandLine cmd) throws Exception
{    String zookeeperUrl = ParserOptions.ZK_QUORUM.get(cmd);    Optional<String> brokerUrl = ParserOptions.BROKER_URL.has(cmd) ? Optional.of(ParserOptions.BROKER_URL.get(cmd)) : Optional.empty();    String sensorTypeRaw = ParserOptions.SENSOR_TYPES.get(cmd);    List<String> sensorTypes = Arrays.stream(sensorTypeRaw.split(TOPOLOGY_OPTION_SEPARATOR)).map(String::trim).collect(Collectors.toList());    /*     * It bears mentioning why we're creating this ValueSupplier indirection here.     * As a separation of responsibilities, the CLI class defines the order of precedence     * for the various topological and structural properties for creating a parser.  This is     * desirable because there are now (i.e. integration tests)     * and may be in the future (i.e. a REST service to start parsers without using the CLI)     * other mechanisms to construct parser topologies.  It's sensible to split those concerns..     *     * Unfortunately, determining the structural parameters for a parser requires interacting with     * external services (e.g. zookeeper) that are set up well within the ParserTopology class.     * Rather than pulling the infrastructure to interact with those services out and moving it into the     * CLI class and breaking that separation of concerns, we've created a supplier     * indirection where are providing the logic as to how to create precedence in the CLI class     * without owning the responsibility of constructing the infrastructure where the values are     * necessarily supplied.     *     */        ValueSupplier<List> spoutParallelism = (parserConfigs, clazz) -> {        if (ParserOptions.SPOUT_PARALLELISM.has(cmd)) {                        if (parserConfigs.size() == 1) {                return Collections.singletonList(Integer.parseInt(ParserOptions.SPOUT_PARALLELISM.get(cmd, "1")));            }                        String parallelismRaw = ParserOptions.SPOUT_PARALLELISM.get(cmd, "1");            List<String> parallelisms = Arrays.stream(parallelismRaw.split(TOPOLOGY_OPTION_SEPARATOR)).map(String::trim).collect(Collectors.toList());            if (parallelisms.size() != parserConfigs.size()) {                throw new IllegalArgumentException("Spout parallelism should match number of sensors 1:1");            }            List<Integer> spoutParallelisms = new ArrayList<>();            for (String s : parallelisms) {                spoutParallelisms.add(Integer.parseInt(s));            }            return spoutParallelisms;        }        List<Integer> spoutParallelisms = new ArrayList<>();        for (SensorParserConfig parserConfig : parserConfigs) {            spoutParallelisms.add(parserConfig.getSpoutParallelism());        }        return spoutParallelisms;    };        ValueSupplier<List> spoutNumTasks = (parserConfigs, clazz) -> {        if (ParserOptions.SPOUT_NUM_TASKS.has(cmd)) {                        if (parserConfigs.size() == 1) {                return Collections.singletonList(Integer.parseInt(ParserOptions.SPOUT_NUM_TASKS.get(cmd, "1")));            }                        String numTasksRaw = ParserOptions.SPOUT_NUM_TASKS.get(cmd, "1");            List<String> numTasks = Arrays.stream(numTasksRaw.split(TOPOLOGY_OPTION_SEPARATOR)).map(String::trim).collect(Collectors.toList());            if (numTasks.size() != parserConfigs.size()) {                throw new IllegalArgumentException("Spout num tasks should match number of sensors 1:1");            }            List<Integer> spoutTasksList = new ArrayList<>();            for (String s : numTasks) {                spoutTasksList.add(Integer.parseInt(s));            }            return spoutTasksList;        }        List<Integer> numTasks = new ArrayList<>();        for (SensorParserConfig parserConfig : parserConfigs) {            numTasks.add(parserConfig.getSpoutNumTasks());        }        return numTasks;    };        ValueSupplier<Integer> parserParallelism = (parserConfigs, clazz) -> {        if (ParserOptions.PARSER_PARALLELISM.has(cmd)) {            return Integer.parseInt(ParserOptions.PARSER_PARALLELISM.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getParserParallelism();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<Integer> parserNumTasks = (parserConfigs, clazz) -> {        if (ParserOptions.PARSER_NUM_TASKS.has(cmd)) {            return Integer.parseInt(ParserOptions.PARSER_NUM_TASKS.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getParserNumTasks();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<Integer> errorParallelism = (parserConfigs, clazz) -> {        if (ParserOptions.ERROR_WRITER_PARALLELISM.has(cmd)) {            return Integer.parseInt(ParserOptions.ERROR_WRITER_PARALLELISM.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getErrorWriterParallelism();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<Integer> errorNumTasks = (parserConfigs, clazz) -> {        if (ParserOptions.ERROR_WRITER_NUM_TASKS.has(cmd)) {            return Integer.parseInt(ParserOptions.ERROR_WRITER_NUM_TASKS.get(cmd, "1"));        }        int retValue = 1;        for (SensorParserConfig config : parserConfigs) {            Integer configValue = config.getErrorWriterNumTasks();            retValue = configValue == null ? retValue : configValue;        }        return retValue;    };        ValueSupplier<List> spoutConfig = (parserConfigs, clazz) -> {        if (ParserOptions.SPOUT_CONFIG.has(cmd)) {            return Collections.singletonList(readJSONMapFromFile(new File(ParserOptions.SPOUT_CONFIG.get(cmd))));        }        List<Map<String, Object>> retValue = new ArrayList<>();        for (SensorParserConfig config : parserConfigs) {            retValue.add(config.getSpoutConfig());        }        return retValue;    };        ValueSupplier<String> securityProtocol = (parserConfigs, clazz) -> {        Optional<String> sp = Optional.empty();        if (ParserOptions.SECURITY_PROTOCOL.has(cmd)) {            sp = Optional.of(ParserOptions.SECURITY_PROTOCOL.get(cmd));        }                if (!sp.isPresent()) {            sp = getSecurityProtocol(sp, spoutConfig.get(parserConfigs, List.class));        }                String parserConfigSp = SecurityProtocol.PLAINTEXT.name;        for (SensorParserConfig config : parserConfigs) {            String configSp = config.getSecurityProtocol();            if (!SecurityProtocol.PLAINTEXT.name.equals(configSp)) {                                parserConfigSp = configSp;            }        }        return sp.orElse(Optional.ofNullable(parserConfigSp).orElse(null));    };        ValueSupplier<Config> stormConf = (parserConfigs, clazz) -> {                Config finalConfig = new Config();        for (SensorParserConfig parserConfig : parserConfigs) {            Map<String, Object> c = parserConfig.getStormConfig();            if (c != null && !c.isEmpty()) {                finalConfig.putAll(c);            }            if (parserConfig.getNumAckers() != null) {                Config.setNumAckers(finalConfig, parserConfig.getNumAckers());            }            if (parserConfig.getNumWorkers() != null) {                Config.setNumWorkers(finalConfig, parserConfig.getNumWorkers());            }        }        return ParserOptions.getConfig(cmd, finalConfig).orElse(finalConfig);    };        ValueSupplier<String> outputTopic = (parserConfigs, clazz) -> {        String topic = null;        if (ParserOptions.OUTPUT_TOPIC.has(cmd)) {            topic = ParserOptions.OUTPUT_TOPIC.get(cmd);        }        return topic;    };        ValueSupplier<String> errorTopic = (parserConfigs, clazz) -> {                String topic = null;        for (SensorParserConfig parserConfig : parserConfigs) {            String currentTopic = parserConfig.getErrorTopic();            if (topic != null && !topic.equals(currentTopic)) {                throw new IllegalArgumentException("Parser Aggregation specified with differing error topics");            }            topic = currentTopic;        }        return topic;    };    return getParserTopology(zookeeperUrl, brokerUrl, sensorTypes, spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, stormConf, outputTopic, errorTopic);}
protected ParserTopologyBuilder.ParserTopology metron_f6720_0(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorTypes, ValueSupplier<List> spoutParallelism, ValueSupplier<List> spoutNumTasks, ValueSupplier<Integer> parserParallelism, ValueSupplier<Integer> parserNumTasks, ValueSupplier<Integer> errorParallelism, ValueSupplier<Integer> errorNumTasks, ValueSupplier<List> spoutConfig, ValueSupplier<String> securityProtocol, ValueSupplier<Config> stormConf, ValueSupplier<String> outputTopic, ValueSupplier<String> errorTopic) throws Exception
{    return ParserTopologyBuilder.build(zookeeperUrl, brokerUrl, sensorTypes, spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, outputTopic, errorTopic, stormConf);}
public static void metron_f6721_0(String[] args)
{    try {        Options options = new Options();        final CommandLine cmd = parse(options, args);        if (cmd.hasOption("h")) {            final HelpFormatter usageFormatter = new HelpFormatter();            usageFormatter.printHelp("ParserTopologyCLI", null, options, null, true);            System.exit(0);        }        ParserTopologyCLI cli = new ParserTopologyCLI();        ParserTopologyBuilder.ParserTopology topology = cli.createParserTopology(cmd);        String sensorTypes = ParserOptions.SENSOR_TYPES.get(cmd);        String topologyName = sensorTypes.replaceAll(TOPOLOGY_OPTION_SEPARATOR, STORM_JOB_SEPARATOR);        if (ParserOptions.TEST.has(cmd)) {            topology.getTopologyConfig().put(Config.TOPOLOGY_DEBUG, true);            LocalCluster cluster = new LocalCluster();            cluster.submitTopology(topologyName, topology.getTopologyConfig(), topology.getBuilder().createTopology());            Utils.sleep(300000);            cluster.shutdown();        } else {            StormSubmitter.submitTopology(topologyName, topology.getTopologyConfig(), topology.getBuilder().createTopology());        }    } catch (Exception e) {        e.printStackTrace();        System.exit(-1);    }}
private static Optional<String> metron_f6722_0(Optional<String> protocol, List<Map<String, Object>> spoutConfig)
{    Optional<String> ret = protocol;    if (ret.isPresent() && protocol.get().equalsIgnoreCase(SecurityProtocol.PLAINTEXT.name)) {        ret = Optional.empty();    }    if (!ret.isPresent()) {                String spoutConfigSp = null;        for (Map<String, Object> config : spoutConfig) {            String configSp = (String) config.get(KafkaUtils.SECURITY_PROTOCOL);            if (configSp != null && !SecurityProtocol.PLAINTEXT.name.equals(configSp)) {                                spoutConfigSp = configSp;            } else if (configSp != null) {                                spoutConfigSp = configSp;            }        }        ret = Optional.ofNullable(spoutConfigSp);    }    if (ret.isPresent() && ret.get().equalsIgnoreCase(SecurityProtocol.PLAINTEXT.name)) {        ret = Optional.empty();    }    return ret;}
private static Map<String, Object> metron_f6723_0(File inputFile)
{    String json = null;    if (inputFile.exists()) {        try {            json = FileUtils.readFileToString(inputFile);        } catch (IOException e) {            throw new IllegalStateException("Unable to process JSON file " + inputFile, e);        }    } else {        throw new IllegalArgumentException("Unable to load JSON file at " + inputFile.getAbsolutePath());    }    try {        return JSONUtils.INSTANCE.load(json, JSONUtils.MAP_SUPPLIER);    } catch (IOException e) {        throw new IllegalStateException("Unable to process JSON.", e);    }}
public ParserRunnerResults<JSONObject> metron_f6724_0(String sensorType, RawMessage rawMessage, ParserConfigurations parserConfigurations)
{    DefaultParserRunnerResults parserRunnerResults = new DefaultParserRunnerResults();    this.rawMessage = rawMessage;    for (JSONObject message : messages) {        if (!isInvalid) {            parserRunnerResults.addMessage(message);        } else {            MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton(sensorType)).addRawMessage(message);            parserRunnerResults.addError(error);        }    }    return parserRunnerResults;}
protected void metron_f6725_0(boolean isInvalid)
{    this.isInvalid = isInvalid;}
protected void metron_f6726_0(List<JSONObject> messages)
{    this.messages = messages;}
protected RawMessage metron_f6727_0()
{    return rawMessage;}
public void metron_f6728_0()
{    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }).withBatchTimeoutDivisor(5);    Assert.assertEquals(5, parserBolt.getBatchTimeoutDivisor());}
public void metron_f6729_0()
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("batchTimeoutDivisor must be positive. Value provided was -1");    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }).withBatchTimeoutDivisor(-1);}
public void metron_f6730_0()
{    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            ParserConfigurations configurations = new ParserConfigurations();            SensorParserConfig sensorParserConfig = new SensorParserConfig();            sensorParserConfig.setParserConfig(new HashMap<String, Object>() {                {                    put(IndexingConfigurations.BATCH_SIZE_CONF, 10);                }            });            configurations.updateSensorParserConfig("yaf", sensorParserConfig);            return configurations;        }    };    Map<String, Object> componentConfiguration = parserBolt.getComponentConfiguration();    Assert.assertEquals(1, componentConfiguration.size());    Assert.assertEquals(14, componentConfiguration.get(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS));}
public ParserConfigurations metron_f6731_0()
{    ParserConfigurations configurations = new ParserConfigurations();    SensorParserConfig sensorParserConfig = new SensorParserConfig();    sensorParserConfig.setParserConfig(new HashMap<String, Object>() {        {            put(IndexingConfigurations.BATCH_SIZE_CONF, 10);        }    });    configurations.updateSensorParserConfig("yaf", sensorParserConfig);    return configurations;}
public void metron_f6732_0()
{    Map stormConf = mock(Map.class);    SensorParserConfig yafConfig = mock(SensorParserConfig.class);    when(yafConfig.getSensorTopic()).thenReturn("yafTopic");    when(yafConfig.getParserConfig()).thenReturn(new HashMap<String, Object>() {        {            put(IndexingConfigurations.BATCH_SIZE_CONF, 10);        }    });    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        protected SensorParserConfig getSensorParserConfig(String sensorType) {            if ("yaf".equals(sensorType)) {                return yafConfig;            }            return null;        }        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    doReturn(stellarContext).when(parserBolt).initializeStellar();    parserBolt.setCuratorFramework(client);    parserBolt.setZKCache(cache);    parserBolt.prepare(stormConf, topologyContext, outputCollector);    verify(parserRunner, times(1)).init(any(Supplier.class), eq(stellarContext));    verify(yafConfig, times(1)).init();    Map<String, String> topicToSensorMap = parserBolt.getTopicToSensorMap();    Assert.assertEquals(1, topicToSensorMap.size());    Assert.assertEquals("yaf", topicToSensorMap.get("yafTopic"));    verify(writerHandler).init(eq(stormConf), eq(topologyContext), eq(outputCollector), eq(parserConfigurations), any(AckTuplesPolicy.class), eq(14));}
protected SensorParserConfig metron_f6733_0(String sensorType)
{    if ("yaf".equals(sensorType)) {        return yafConfig;    }    return null;}
public ParserConfigurations metron_f6734_0()
{    return parserConfigurations;}
public void metron_f6735_0()
{    exception.expect(IllegalStateException.class);    exception.expectMessage("Unable to retrieve a parser config for yaf");    Map stormConf = mock(Map.class);    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    });    parserBolt.setCuratorFramework(client);    parserBolt.setZKCache(cache);    parserBolt.prepare(stormConf, topologyContext, outputCollector);}
public void metron_f6736_0() throws Exception
{    when(t1.getSourceComponent()).thenReturn("__system");    when(t1.getSourceStreamId()).thenReturn("__tick");    ParserConfigurations parserConfigurations = mock(ParserConfigurations.class);    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    };    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.execute(t1);    verify(writerHandler, times(1)).flush(parserConfigurations, messageGetStrategy);    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6737_0()
{    return parserConfigurations;}
public void metron_f6738_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    parserBolt.setAckTuplesPolicy(bulkWriterResponseHandler);    JSONObject message = new JSONObject();    message.put(Constants.GUID, "messageId");    message.put("field", "value");    mockParserRunner.setMessages(Collections.singletonList(message));    RawMessage expectedRawMessage = new RawMessage("originalMessage".getBytes(StandardCharsets.UTF_8), new HashMap<>());    {        parserBolt.execute(t1);        Assert.assertEquals(expectedRawMessage, mockParserRunner.getRawMessage());        verify(bulkWriterResponseHandler).addTupleMessageIds(t1, Collections.singletonList("messageId"));        verify(writerHandler, times(1)).write("yaf", new BulkMessage<>("messageId", message), parserConfigurations);    }}
public ParserConfigurations metron_f6739_0()
{    return parserConfigurations;}
public void metron_f6740_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    parserBolt.setAckTuplesPolicy(bulkWriterResponseHandler);    List<BulkMessage<JSONObject>> messages = new ArrayList<>();    for (int i = 0; i < 5; i++) {        String messageId = String.format("messageId%s", i + 1);        JSONObject message = new JSONObject();        message.put(Constants.GUID, messageId);        message.put("field", String.format("value%s", i + 1));        messages.add(new BulkMessage<>(messageId, message));    }    mockParserRunner.setMessages(messages.stream().map(BulkMessage::getMessage).collect(Collectors.toList()));    RawMessage expectedRawMessage = new RawMessage("originalMessage".getBytes(StandardCharsets.UTF_8), new HashMap<>());    {                parserBolt.execute(t1);        Assert.assertEquals(expectedRawMessage, mockParserRunner.getRawMessage());        InOrder inOrder = inOrder(bulkWriterResponseHandler, writerHandler);        inOrder.verify(bulkWriterResponseHandler).addTupleMessageIds(t1, Arrays.asList("messageId1", "messageId2", "messageId3", "messageId4", "messageId5"));        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(0), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(1), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(2), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(3), parserConfigurations);        inOrder.verify(writerHandler, times(1)).write("yaf", messages.get(4), parserConfigurations);    }    verifyNoMoreInteractions(writerHandler, bulkWriterResponseHandler, outputCollector);}
public ParserConfigurations metron_f6741_0()
{    return parserConfigurations;}
public void metron_f6742_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    mockParserRunner.setInvalid(true);    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    };    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    JSONObject message = new JSONObject();    message.put("field", "value");    mockParserRunner.setMessages(Collections.singletonList(message));    RawMessage expectedRawMessage = new RawMessage("originalMessage".getBytes(StandardCharsets.UTF_8), new HashMap<>());    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_INVALID).withSensorType(Collections.singleton("yaf")).addRawMessage(message);    parserBolt.execute(t1);    Assert.assertEquals(expectedRawMessage, mockParserRunner.getRawMessage());    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6743_0()
{    return parserConfigurations;}
public void metron_f6744_0()
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    doThrow(new IllegalStateException("parserRunner.execute failed")).when(parserRunner).execute(eq("yaf"), any(), eq(parserConfigurations));    ParserBolt parserBolt = new ParserBolt("zookeeperUrl", parserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    };    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(new IllegalStateException("parserRunner.execute failed")).withSensorType(Collections.singleton("yaf")).addRawMessage("originalMessage".getBytes(StandardCharsets.UTF_8));    parserBolt.execute(t1);    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    verify(outputCollector, times(1)).reportError(any(IllegalStateException.class));    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6745_0()
{    return parserConfigurations;}
public void metron_f6746_0() throws Exception
{    when(messageGetStrategy.get(t1)).thenReturn("originalMessage".getBytes(StandardCharsets.UTF_8));    when(t1.getStringByField(FieldsConfiguration.TOPIC.getFieldName())).thenReturn("yafTopic");    MockParserRunner mockParserRunner = new MockParserRunner(new HashSet<String>() {        {            add("yaf");        }    });    ParserConfigurations parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig("yaf", new SensorParserConfig());    doThrow(new IllegalStateException("write failed")).when(writerHandler).write(any(), any(), any());    ParserBolt parserBolt = spy(new ParserBolt("zookeeperUrl", mockParserRunner, new HashMap<String, WriterHandler>() {        {            put("yaf", writerHandler);        }    }) {        @Override        public ParserConfigurations getConfigurations() {            return parserConfigurations;        }    });    parserBolt.setMessageGetStrategy(messageGetStrategy);    parserBolt.setOutputCollector(outputCollector);    parserBolt.setTopicToSensorMap(new HashMap<String, String>() {        {            put("yafTopic", "yaf");        }    });    parserBolt.setAckTuplesPolicy(bulkWriterResponseHandler);    JSONObject message = new JSONObject();    message.put(Constants.GUID, "messageId");    message.put("field", "value");    mockParserRunner.setMessages(Collections.singletonList(message));    MetronError error = new MetronError().withErrorType(Constants.ErrorType.PARSER_ERROR).withThrowable(new IllegalStateException("write failed")).withSensorType(Collections.singleton("yaf")).addRawMessage("originalMessage".getBytes(StandardCharsets.UTF_8));    parserBolt.execute(t1);    verify(bulkWriterResponseHandler, times(1)).addTupleMessageIds(t1, Collections.singletonList("messageId"));    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));    verify(outputCollector, times(1)).reportError(any(IllegalStateException.class));    verify(outputCollector, times(1)).ack(t1);}
public ParserConfigurations metron_f6747_0()
{    return parserConfigurations;}
private ParserConfigurations metron_f6748_0(int batchSize)
{    return new ParserConfigurations() {        @Override        public SensorParserConfig getSensorParserConfig(String sensorType) {            return new SensorParserConfig() {                @Override                public Map<String, Object> getParserConfig() {                    return new HashMap<String, Object>() {                        {                            put(IndexingConfigurations.BATCH_SIZE_CONF, batchSize);                        }                    };                }            };        }    };}
public SensorParserConfig metron_f6749_0(String sensorType)
{    return new SensorParserConfig() {        @Override        public Map<String, Object> getParserConfig() {            return new HashMap<String, Object>() {                {                    put(IndexingConfigurations.BATCH_SIZE_CONF, batchSize);                }            };        }    };}
public Map<String, Object> metron_f6750_0()
{    return new HashMap<String, Object>() {        {            put(IndexingConfigurations.BATCH_SIZE_CONF, batchSize);        }    };}
public void metron_f6751_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(5);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<MessageId> messageIds = new ArrayList<>();    for (int i = 0; i < 5; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(new MessageId(messageId));        JSONObject message = new JSONObject();        message.put(Constants.GUID, messageId);        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }        BulkWriterResponse writerResponse = new BulkWriterResponse();    writerResponse.addAllSuccesses(messageIds);    when(batchWriter.write(any(), any(), any())).thenReturn(writerResponse);    bolt.execute(tuples.get(4));    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(0)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6752_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(1);    String sensorType = "test";    Tuple t = mock(Tuple.class);    when(t.getValueByField(eq("message"))).thenReturn(new JSONObject());    WriterBolt bolt = new WriterBolt(new WriterHandler(writer), configurations, sensorType);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(writer, times(1)).init();    bolt.execute(t);    verify(outputCollector, times(1)).ack(t);    verify(writer, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(0)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6753_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(1);    String sensorType = "test";    Tuple t = mock(Tuple.class);    when(t.getValueByField(eq("message"))).thenThrow(new IllegalStateException());    WriterBolt bolt = new WriterBolt(new WriterHandler(writer), configurations, sensorType);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(writer, times(1)).init();    bolt.execute(t);    verify(outputCollector, times(1)).ack(t);    verify(writer, times(0)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6754_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(1);    String sensorType = "test";    Tuple t = mock(Tuple.class);    when(t.toString()).thenReturn("tuple");    when(t.getValueByField(eq("message"))).thenReturn(new JSONObject());    WriterBolt bolt = new WriterBolt(new WriterHandler(writer), configurations, sensorType);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    doThrow(new Exception("write error")).when(writer).write(any(), any(), any());    verify(writer, times(1)).init();    bolt.execute(t);    verify(outputCollector, times(1)).ack(t);    verify(writer, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());    MetronError error = new MetronError().withErrorType(Constants.ErrorType.INDEXING_ERROR).withThrowable(new Exception("write error")).withSensorType(Collections.singleton(sensorType)).addRawMessage(new JSONObject());    verify(outputCollector, times(1)).emit(eq(Constants.ERROR_STREAM), argThat(new MetronErrorJSONMatcher(error.getJSONObject())));}
public void metron_f6755_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(5);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<MessageId> messageIds = new ArrayList<>();    for (int i = 0; i < 4; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(new MessageId(messageId));        JSONObject message = new JSONObject();        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    Tuple errorTuple = mock(Tuple.class);    Tuple goodTuple = mock(Tuple.class);    when(goodTuple.getValueByField(eq("message"))).thenReturn(new JSONObject());    when(errorTuple.getValueByField(eq("message"))).thenThrow(new IllegalStateException());    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }        BulkWriterResponse writerResponse = new BulkWriterResponse();    writerResponse.addAllSuccesses(messageIds);    writerResponse.addSuccess(new MessageId("goodMessage"));    when(batchWriter.write(any(), any(), any())).thenReturn(writerResponse);    bolt.execute(errorTuple);    for (Tuple t : tuples) {        verify(outputCollector, times(0)).ack(t);    }    bolt.execute(goodTuple);    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(outputCollector, times(1)).ack(goodTuple);    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6756_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(6);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<MessageId> messageIds = new ArrayList<>();    for (int i = 0; i < 4; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(new MessageId(messageId));        JSONObject message = new JSONObject();        message.put(Constants.GUID, messageId);        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    Tuple errorTuple = mock(Tuple.class);    Tuple goodTuple = mock(Tuple.class);    JSONObject goodMessage = new JSONObject();    goodMessage.put(Constants.GUID, "goodMessageId");    goodMessage.put("value", "goodMessage");    JSONObject errorMessage = new JSONObject();    goodMessage.put(Constants.GUID, "errorMessageId");    errorMessage.put("value", "errorMessage");    when(goodTuple.getValueByField(eq("message"))).thenReturn(goodMessage);    when(errorTuple.getValueByField(eq("message"))).thenReturn(errorMessage);    bolt.prepare(new HashMap(), topologyContext, outputCollector);    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }        BulkWriterResponse writerResponse = new BulkWriterResponse();    writerResponse.addAllSuccesses(messageIds);    writerResponse.addSuccess(new MessageId("goodMessageId"));    writerResponse.addError(new IllegalStateException(), new MessageId("errorMessageId"));    when(batchWriter.write(any(), any(), any())).thenReturn(writerResponse);    bolt.execute(errorTuple);    for (Tuple t : tuples) {        verify(outputCollector, times(0)).ack(t);    }    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.FATAL);    bolt.execute(goodTuple);    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.ERROR);    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(outputCollector, times(1)).ack(goodTuple);    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public void metron_f6757_0() throws Exception
{    ParserConfigurations configurations = getConfigurations(5);    String sensorType = "test";    WriterBolt bolt = spy(new WriterBolt(new WriterHandler(batchWriter), configurations, sensorType));    List<Tuple> tuples = new ArrayList<>();    List<String> messageIds = new ArrayList<>();    for (int i = 0; i < 4; ++i) {        Tuple t = mock(Tuple.class);        String messageId = String.format(MESSAGE_ID_FORMAT, i + 1);        messageIds.add(messageId);        JSONObject message = new JSONObject();        message.put("value", String.format(MESSAGE_FORMAT, i + 1));        when(t.getValueByField(eq("message"))).thenReturn(message);        tuples.add(t);    }    Tuple goodTuple = mock(Tuple.class);    when(goodTuple.getValueByField(eq("message"))).thenReturn(new JSONObject());    bolt.prepare(new HashMap(), topologyContext, outputCollector);    doThrow(new Exception()).when(batchWriter).write(any(), any(), any());    verify(batchWriter, times(1)).init(any(), any());    for (int i = 0; i < 4; ++i) {        Tuple t = tuples.get(i);        bolt.execute(t);        verify(outputCollector, times(0)).ack(t);        verify(batchWriter, times(0)).write(eq(sensorType), any(), any());    }    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.FATAL);    bolt.execute(goodTuple);    UnitTestHelper.setLog4jLevel(BulkWriterComponent.class, Level.ERROR);    for (Tuple t : tuples) {        verify(outputCollector, times(1)).ack(t);    }    verify(batchWriter, times(1)).write(eq(sensorType), any(), any());    verify(outputCollector, times(1)).ack(goodTuple);    verify(outputCollector, times(1)).reportError(any());    verify(outputCollector, times(0)).fail(any());}
public Builder metron_f6758_0(Properties topologyProperties)
{    this.topologyProperties = topologyProperties;    return this;}
public Builder metron_f6759_0(String brokerUrl)
{    this.brokerUrl = brokerUrl;    return this;}
public Builder metron_f6760_0(List<String> sensorTypes)
{    this.sensorTypes = sensorTypes;    return this;}
public Builder metron_f6761_0(String topic)
{    this.outputTopic = topic;    return this;}
public Builder metron_f6762_0(String topic)
{    this.errorTopic = topic;    return this;}
public ParserTopologyComponent metron_f6763_0()
{    if (sensorTypes == null || sensorTypes.isEmpty()) {        throw new IllegalArgumentException("The sensor type must be defined.");    }    if (outputTopic == null) {        throw new IllegalArgumentException("The output topic must be defined.");    }    return new ParserTopologyComponent(topologyProperties, brokerUrl, sensorTypes, outputTopic, errorTopic);}
public void metron_f6764_0(List<String> sensorTypes)
{    this.sensorTypes = sensorTypes;}
public void metron_f6765_0() throws UnableToStartException
{    try {        final Map<String, Object> stormConf = new HashMap<>();        stormConf.put(Config.TOPOLOGY_DEBUG, true);        ParserTopologyBuilder.ParserTopology topologyBuilder = ParserTopologyBuilder.build(topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY), Optional.ofNullable(brokerUrl), sensorTypes, (x, y) -> Collections.nCopies(sensorTypes.size(), 1), (x, y) -> Collections.nCopies(sensorTypes.size(), 1), (x, y) -> 1, (x, y) -> 1, (x, y) -> 1, (x, y) -> 1, (x, y) -> Collections.nCopies(sensorTypes.size(), new HashMap<>()), (x, y) -> null, (x, y) -> outputTopic, (x, y) -> errorTopic, (x, y) -> {            Config c = new Config();            c.putAll(stormConf);            return c;        });        stormCluster = new LocalCluster();        stormCluster.submitTopology(getTopologyName(), stormConf, topologyBuilder.getBuilder().createTopology());    } catch (Exception e) {        throw new UnableToStartException("Unable to start parser topology for sensorTypes: " + sensorTypes, e);    }}
public void metron_f6766_1()
{    if (stormCluster != null) {        try {            try {                                killTopology();                stormCluster.shutdown();            } catch (IllegalStateException ise) {                if (!(ise.getMessage().contains("It took over") && ise.getMessage().contains("to shut down slot"))) {                    throw ise;                } else {                    assassinateSlots();                                    }            }        } catch (Throwable t) {                    } finally {            cleanupWorkerDir();        }    }}
public void metron_f6767_0()
{    if (stormCluster != null) {        killTopology();    }}
protected void metron_f6768_0()
{    KillOptions ko = new KillOptions();    ko.set_wait_secs(0);    stormCluster.killTopologyWithOpts(getTopologyName(), ko);    try {                Thread.sleep(2000);    } catch (InterruptedException e) {        }}
protected String metron_f6769_0()
{    return StringUtils.join(sensorTypes, "__");}
public static Iterable<String> metron_f6770_0()
{    return sensorTypes;}
public void metron_f6771_0() throws Exception
{    ParserDriver driver = new StormParserDriver(sensorType, readSensorConfig(sensorType), readGlobalConfig());    runTest(driver);}
 List<ParserValidation> metron_f6772_0()
{    return new ArrayList<ParserValidation>() {        {            add(new SampleDataValidation());        }    };}
public BulkWriterResponse metron_f6774_0(String sensorType, WriterConfiguration configurations, List<BulkMessage<JSONObject>> messages) throws Exception
{    messages.forEach(bulkWriterMessage -> output.add(bulkWriterMessage.getMessage().toJSONString().getBytes(StandardCharsets.UTF_8)));    Set<MessageId> ids = messages.stream().map(BulkMessage::getId).collect(Collectors.toSet());    BulkWriterResponse bulkWriterResponse = new BulkWriterResponse();    bulkWriterResponse.addAllSuccesses(ids);    return bulkWriterResponse;}
public String metron_f6775_0()
{    return "collecting";}
public List<byte[]> metron_f6777_0()
{    return output;}
public ParserConfigurations metron_f6778_0()
{    config.getSensorParserConfig(sensorType).getParserConfig().putIfAbsent(IndexingConfigurations.BATCH_SIZE_CONF, 1);    return config;}
protected void metron_f6780_1(String sensorType, byte[] originalMessage, Tuple tuple, Throwable ex, OutputCollector collector)
{    errors.add(originalMessage);    }
protected void metron_f6781_1(OutputCollector collector, MetronError error)
{    for (Object rawMessage : error.getRawMessages()) {        errors.add((byte[]) rawMessage);    }    if (error.getThrowable().isPresent()) {        Throwable throwable = error.getThrowable().get();            }}
public ProcessorResult<List<byte[]>> metron_f6782_0()
{    return new ProcessorResult.Builder<List<byte[]>>().withProcessErrors(errors).withResult(output).build();}
public ProcessorResult<List<byte[]>> metron_f6783_0(Iterable<byte[]> in)
{    ShimParserBolt bolt = new ShimParserBolt(new ArrayList<>());    byte[] b = SerializationUtils.serialize(bolt);    ShimParserBolt b2 = (ShimParserBolt) SerializationUtils.deserialize(b);    OutputCollector collector = mock(OutputCollector.class);    bolt.prepare(null, null, collector);    for (byte[] record : in) {        Tuple tuple = toTuple(record);        bolt.execute(tuple);        verify(collector, times(1)).ack(tuple);    }    return bolt.getResults();}
public Tuple metron_f6784_0(byte[] record)
{    Tuple ret = mock(Tuple.class);    when(ret.getStringByField("topic")).thenReturn(sensorType);    when(ret.getBinary(eq(0))).thenReturn(record);    return ret;}
public void metron_f6785_0()
{    spy(ParserTopologyBuilder.class);    when(ParserTopologyBuilder.createKafkaWriter(Optional.of("brokerUrl"), "zookeeperUrl", Optional.of("securityProtocol"))).thenReturn(kafkaWriter);}
public void metron_f6786_0()
{    SensorParserConfig broConfig = new SensorParserConfig();    broConfig.setSensorTopic("bro");    when(configs.getSensorParserConfig("bro")).thenReturn(broConfig);    KafkaWriter enrichmentWriter = mock(KafkaWriter.class);    when(kafkaWriter.withTopic(Constants.ENRICHMENT_TOPIC)).thenReturn(enrichmentWriter);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("bro", broConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.empty());    assertEquals(1, writerConfigs.size());    assertEquals(enrichmentWriter, writerConfigs.get("bro").getBulkMessageWriter());    verify(enrichmentWriter, times(1)).configure(eq("bro"), any(ParserWriterConfiguration.class));    verifyNoMoreInteractions(enrichmentWriter);}
public void metron_f6787_0()
{    SensorParserConfig snortConfig = new SensorParserConfig();    snortConfig.setSensorTopic("snort");    snortConfig.setOutputTopic("snort_topic");    when(configs.getSensorParserConfig("snort")).thenReturn(snortConfig);    KafkaWriter snortTestWriter = mock(KafkaWriter.class);    when(kafkaWriter.withTopic("snort_topic")).thenReturn(snortTestWriter);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("snort", snortConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.empty());    assertEquals(1, writerConfigs.size());    assertEquals(snortTestWriter, writerConfigs.get("snort").getBulkMessageWriter());    verify(snortTestWriter, times(1)).configure(eq("snort"), any(ParserWriterConfiguration.class));    verifyNoMoreInteractions(snortTestWriter);}
public void metron_f6788_0()
{    SensorParserConfig snortConfig = new SensorParserConfig();    snortConfig.setSensorTopic("snort");    when(configs.getSensorParserConfig("snort")).thenReturn(snortConfig);    KafkaWriter suppliedTopicWriter = mock(KafkaWriter.class);    when(kafkaWriter.withTopic("supplied_topic")).thenReturn(suppliedTopicWriter);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("snort", snortConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.of("supplied_topic"));    assertEquals(1, writerConfigs.size());    assertEquals(suppliedTopicWriter, writerConfigs.get("snort").getBulkMessageWriter());    verify(suppliedTopicWriter, times(1)).configure(eq("snort"), any(ParserWriterConfiguration.class));    verifyNoMoreInteractions(suppliedTopicWriter);}
public void metron_f6789_0()
{    SensorParserConfig yafConfig = new SensorParserConfig();    yafConfig.setSensorTopic("yaf");    yafConfig.setWriterClassName("org.apache.metron.writer.NoopWriter");    when(configs.getSensorParserConfig("yaf")).thenReturn(yafConfig);    Map<String, SensorParserConfig> sensorTypeToParserConfig = new HashMap<String, SensorParserConfig>() {        {            put("yaf", yafConfig);        }    };    Map<String, WriterHandler> writerConfigs = ParserTopologyBuilder.createWriterConfigs("zookeeperUrl", Optional.of("brokerUrl"), sensorTypeToParserConfig, Optional.of("securityProtocol"), configs, Optional.empty());    assertEquals(1, writerConfigs.size());    assertTrue(writerConfigs.get("yaf").getBulkMessageWriter() instanceof NoopWriter);}
public CLIBuilder metron_f6790_0(ParserTopologyCLI.ParserOptions option, String val)
{    map.put(option, val);    return this;}
public CLIBuilder metron_f6791_0(ParserTopologyCLI.ParserOptions option)
{    map.put(option, null);    return this;}
public CommandLine metron_f6792_0(boolean longOpt) throws ParseException
{    return getCLI(map, longOpt);}
private CommandLine metron_f6793_0(EnumMap<ParserTopologyCLI.ParserOptions, String> options, boolean longOpt) throws ParseException
{    ArrayList<String> args = new ArrayList<>();    for (Map.Entry<ParserTopologyCLI.ParserOptions, String> option : options.entrySet()) {        boolean hasLongOpt = option.getKey().option.hasLongOpt();        if (hasLongOpt && longOpt) {            args.add("--" + option.getKey().option.getLongOpt());            if (option.getKey().option.hasArg() && option.getValue() != null) {                args.add(option.getValue());            }        } else if (hasLongOpt && !longOpt) {            args.add("-" + option.getKey().shortCode);            if (option.getKey().option.hasArg() && option.getValue() != null) {                args.add(option.getValue());            }        }    }    return ParserTopologyCLI.ParserOptions.parse(new PosixParser(), args.toArray(new String[args.size()]));}
public void metron_f6794_0() throws Exception
{    Set<String> optionStrs = new HashSet<>();    for (ParserTopologyCLI.ParserOptions option : ParserTopologyCLI.ParserOptions.values()) {        if (optionStrs.contains(option.option.getLongOpt())) {            throw new IllegalStateException("Reused long option: " + option.option.getLongOpt());        }        if (optionStrs.contains(option.shortCode)) {            throw new IllegalStateException("Reused short option: " + option.shortCode);        }        optionStrs.add(option.option.getLongOpt());        optionStrs.add(option.shortCode);    }}
public void metron_f6795_0() throws ParseException
{    kafkaOffset(true);    kafkaOffset(false);}
public void metron_f6796_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").build(longOpt);    Assert.assertEquals("myzk", ParserTopologyCLI.ParserOptions.ZK_QUORUM.get(cli));    Assert.assertEquals("mybroker", ParserTopologyCLI.ParserOptions.BROKER_URL.get(cli));    Assert.assertEquals("mysensor", ParserTopologyCLI.ParserOptions.SENSOR_TYPES.get(cli));}
public void metron_f6797_0() throws ParseException
{    happyPath(true);    happyPath(false);}
public void metron_f6798_0() throws ParseException
{    UnitTestHelper.setLog4jLevel(Parser.class, Level.FATAL);    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").build(true);    UnitTestHelper.setLog4jLevel(Parser.class, Level.ERROR);}
public void metron_f6799_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").build(longOpt);    Assert.assertEquals("myzk", ParserTopologyCLI.ParserOptions.ZK_QUORUM.get(cli));    Assert.assertEquals("mybroker", ParserTopologyCLI.ParserOptions.BROKER_URL.get(cli));    Assert.assertEquals("mysensor", ParserTopologyCLI.ParserOptions.SENSOR_TYPES.get(cli));}
public void metron_f6800_0() throws ParseException
{    testConfig_noExtra(true);    testConfig_noExtra(false);}
public void metron_f6801_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").with(ParserTopologyCLI.ParserOptions.NUM_WORKERS, "1").with(ParserTopologyCLI.ParserOptions.NUM_ACKERS, "2").with(ParserTopologyCLI.ParserOptions.NUM_MAX_TASK_PARALLELISM, "3").with(ParserTopologyCLI.ParserOptions.MESSAGE_TIMEOUT, "4").build(longOpt);    Optional<Config> configOptional = ParserTopologyCLI.ParserOptions.getConfig(cli);    Config config = configOptional.get();    Assert.assertEquals(1, config.get(Config.TOPOLOGY_WORKERS));    Assert.assertEquals(2, config.get(Config.TOPOLOGY_ACKER_EXECUTORS));    Assert.assertEquals(3, config.get(Config.TOPOLOGY_MAX_TASK_PARALLELISM));    Assert.assertEquals(4, config.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS));}
public void metron_f6802_0() throws Exception
{    testOutputTopic(true);    testOutputTopic(false);}
public void metron_f6803_0(boolean longOpt) throws ParseException
{    CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").with(ParserTopologyCLI.ParserOptions.OUTPUT_TOPIC, "my_topic").build(longOpt);    Assert.assertEquals("my_topic", ParserTopologyCLI.ParserOptions.OUTPUT_TOPIC.get(cli));}
public void metron_f6804_0() throws Exception
{    testConfig_extra(true);    testConfig_extra(false);}
public void metron_f6805_0(boolean longOpt) throws IOException, ParseException
{    File extraFile = File.createTempFile("extra", "json");    try {        FileUtils.write(extraFile, extraConfig);        CommandLine cli = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor").with(ParserTopologyCLI.ParserOptions.MESSAGE_TIMEOUT, "4").with(ParserTopologyCLI.ParserOptions.EXTRA_OPTIONS, extraFile.getAbsolutePath()).build(longOpt);        Optional<Config> configOptional = ParserTopologyCLI.ParserOptions.getConfig(cli);        Config config = configOptional.get();        Assert.assertEquals(4, config.get(Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS));        Assert.assertEquals("foo", config.get("string"));        Assert.assertEquals(1, config.get("integer"));    } finally {        extraFile.deleteOnExit();    }}
public List<Integer> metron_f6806_0()
{    return spoutParallelism;}
public List<Integer> metron_f6807_0()
{    return spoutNumTasks;}
public Integer metron_f6808_0()
{    return parserParallelism;}
public Integer metron_f6809_0()
{    return parserNumTasks;}
public Integer metron_f6810_0()
{    return errorParallelism;}
public Integer metron_f6811_0()
{    return errorNumTasks;}
public List<Map<String, Object>> metron_f6812_0()
{    return spoutConfig;}
public String metron_f6813_0()
{    return securityProtocol;}
public Config metron_f6814_0()
{    return stormConf;}
public String metron_f6815_0()
{    return outputTopic;}
public String metron_f6816_0()
{    return errorTopic;}
private static SensorParserConfig metron_f6817_0()
{    try {        return JSONUtils.INSTANCE.load(baseConfig, SensorParserConfig.class);    } catch (IOException e) {        throw new IllegalStateException(e.getMessage(), e);    }}
public void metron_f6818_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_PARALLELISM, "10", input -> input.getSpoutParallelism().equals(Collections.singletonList(10)), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutParallelism(20);        return Collections.singletonList(config);    }, input -> input.getSpoutParallelism().equals(Collections.singletonList(20)));}
public void metron_f6819_0() throws Exception
{            List<Integer> spoutParCli = new ArrayList<>();    spoutParCli.add(10);    spoutParCli.add(12);    List<Integer> spoutParConfig = new ArrayList<>();    spoutParConfig.add(20);    spoutParConfig.add(30);    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_PARALLELISM, "10,12", input -> input.getSpoutParallelism().equals(spoutParCli), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutParallelism(20);        SensorParserConfig config2 = getBaseConfig();        config2.setSpoutParallelism(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getSpoutParallelism().equals(spoutParConfig));}
public void metron_f6820_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_NUM_TASKS, "10", input -> input.getSpoutNumTasks().equals(Collections.singletonList(10)), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutNumTasks(20);        return Collections.singletonList(config);    }, input -> input.getSpoutNumTasks().equals(Collections.singletonList(20)));}
public void metron_f6821_0() throws Exception
{        List<Integer> numTasksCli = new ArrayList<>();    numTasksCli.add(10);    numTasksCli.add(12);    List<Integer> numTasksConfig = new ArrayList<>();    numTasksConfig.add(20);    numTasksConfig.add(30);    testConfigOption(ParserTopologyCLI.ParserOptions.SPOUT_NUM_TASKS, "10,12", input -> input.getSpoutNumTasks().equals(numTasksCli), () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutNumTasks(20);        SensorParserConfig config2 = getBaseConfig();        config2.setSpoutNumTasks(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getSpoutNumTasks().equals(numTasksConfig));}
public void metron_f6822_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_PARALLELISM, "10", input -> input.getParserParallelism().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserParallelism(20);        return Collections.singletonList(config);    }, input -> input.getParserParallelism().equals(20));}
public void metron_f6823_0() throws Exception
{        testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_PARALLELISM, "10", input -> input.getParserParallelism().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserParallelism(20);        SensorParserConfig config2 = getBaseConfig();        config2.setParserParallelism(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getParserParallelism().equals(30));}
public void metron_f6824_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_NUM_TASKS, "10", input -> input.getParserNumTasks().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserNumTasks(20);        SensorParserConfig config2 = getBaseConfig();        config2.setParserNumTasks(30);        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getParserNumTasks().equals(30));}
public void metron_f6825_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.PARSER_NUM_TASKS, "10", input -> input.getParserNumTasks().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setParserNumTasks(20);        return Collections.singletonList(config);    }, input -> input.getParserNumTasks().equals(20));}
public void metron_f6826_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.ERROR_WRITER_PARALLELISM, "10", input -> input.getErrorParallelism().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setErrorWriterParallelism(20);        return Collections.singletonList(config);    }, input -> input.getErrorParallelism().equals(20));}
public void metron_f6827_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.ERROR_WRITER_NUM_TASKS, "10", input -> input.getErrorNumTasks().equals(10), () -> {        SensorParserConfig config = getBaseConfig();        config.setErrorWriterNumTasks(20);        return Collections.singletonList(config);    }, input -> input.getErrorNumTasks().equals(20));}
public void metron_f6828_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT", input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {        SensorParserConfig config = getBaseConfig();        config.setSecurityProtocol("KERBEROS");        return Collections.singletonList(config);    }, input -> input.getSecurityProtocol().equals("KERBEROS"));}
public void metron_f6829_0() throws Exception
{    testConfigOption(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT", input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {        SensorParserConfig config = getBaseConfig();        config.setSecurityProtocol("PLAINTEXT");        SensorParserConfig config2 = getBaseConfig();        config2.setSecurityProtocol("PLAINTEXT");        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        return configs;    }, input -> input.getSecurityProtocol().equals("PLAINTEXT"));}
public void metron_f6830_0() throws Exception
{        testConfigOption(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT", input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {        SensorParserConfig config = getBaseConfig();        config.setSecurityProtocol("PLAINTEXT");        SensorParserConfig config2 = getBaseConfig();        config2.setSecurityProtocol("KERBEROS");        SensorParserConfig config3 = getBaseConfig();        config3.setSecurityProtocol("PLAINTEXT");        List<SensorParserConfig> configs = new ArrayList<>();        configs.add(config);        configs.add(config2);        configs.add(config3);        return configs;    }, input -> input.getSecurityProtocol().equals("KERBEROS"));}
public void metron_f6831_0() throws Exception
{        File extraConfig = File.createTempFile("spoutConfig", "json");    extraConfig.deleteOnExit();    writeMap(extraConfig, new HashMap<String, Object>() {        {            put("security.protocol", "PLAINTEXTSASL");        }    });    {                testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {            {                put(ParserTopologyCLI.ParserOptions.SPOUT_CONFIG, extraConfig.getAbsolutePath());                put(ParserTopologyCLI.ParserOptions.SECURITY_PROTOCOL, "PLAINTEXT");            }        }, input -> input.getSecurityProtocol().equals("PLAINTEXT"), () -> {            SensorParserConfig config = getBaseConfig();            config.setSecurityProtocol("PLAINTEXTSASL_FROM_ZK");            return Collections.singletonList(config);        }, input -> input.getSecurityProtocol().equals("PLAINTEXTSASL_FROM_ZK"));    }    {                testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {            {                put(ParserTopologyCLI.ParserOptions.SPOUT_CONFIG, extraConfig.getAbsolutePath());            }        }, input -> input.getSecurityProtocol().equals("PLAINTEXTSASL"), () -> {            SensorParserConfig config = getBaseConfig();            config.setSecurityProtocol("PLAINTEXTSASL_FROM_ZK");            return Collections.singletonList(config);        }, input -> input.getSecurityProtocol().equals("PLAINTEXTSASL_FROM_ZK"));    }}
public void metron_f6832_0() throws Exception
{    testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(ParserTopologyCLI.ParserOptions.NUM_WORKERS, "10");            put(ParserTopologyCLI.ParserOptions.NUM_ACKERS, "20");        }    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 10 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 20;    }, () -> {        SensorParserConfig config = getBaseConfig();        config.setNumWorkers(100);        config.setNumAckers(200);        return Collections.singletonList(config);    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 100 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 200;    });}
public void metron_f6833_0() throws Exception
{    File extraConfig = File.createTempFile("topologyConfig", "json");    extraConfig.deleteOnExit();    writeMap(extraConfig, new HashMap<String, Object>() {        {            put(Config.TOPOLOGY_DEBUG, true);        }    });    testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(ParserTopologyCLI.ParserOptions.NUM_WORKERS, "10");            put(ParserTopologyCLI.ParserOptions.NUM_ACKERS, "20");            put(ParserTopologyCLI.ParserOptions.EXTRA_OPTIONS, extraConfig.getAbsolutePath());        }    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 10 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 20 && (boolean) c.get(Config.TOPOLOGY_DEBUG);    }, () -> {        SensorParserConfig config = getBaseConfig();        config.setStormConfig(new HashMap<String, Object>() {            {                put(Config.TOPOLOGY_WORKERS, 100);                put(Config.TOPOLOGY_ACKER_EXECUTORS, 200);            }        });        return Collections.singletonList(config);    }, input -> {        Config c = input.getStormConf();        return (int) c.get(Config.TOPOLOGY_WORKERS) == 100 && (int) c.get(Config.TOPOLOGY_ACKER_EXECUTORS) == 200 && !c.containsKey(Config.TOPOLOGY_DEBUG);    });}
public void metron_f6834_0() throws Exception
{    File extraConfig = File.createTempFile("spoutConfig", "json");    extraConfig.deleteOnExit();    writeMap(extraConfig, new HashMap<String, Object>() {        {            put("extra_config", "from_file");        }    });    EnumMap<ParserTopologyCLI.ParserOptions, String> cliOptions = new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(ParserTopologyCLI.ParserOptions.SPOUT_CONFIG, extraConfig.getAbsolutePath());        }    };    Predicate<ParserInput> cliOverrideExpected = input -> {        return input.getSpoutConfig().get(0).get("extra_config").equals("from_file");    };    Predicate<ParserInput> configOverrideExpected = input -> {        return input.getSpoutConfig().get(0).get("extra_config").equals("from_zk");    };    Supplier<List<SensorParserConfig>> configSupplier = () -> {        SensorParserConfig config = getBaseConfig();        config.setSpoutConfig(new HashMap<String, Object>() {            {                put("extra_config", "from_zk");            }        });        return Collections.singletonList(config);    };    testConfigOption(cliOptions, cliOverrideExpected, configSupplier, configOverrideExpected);}
private void metron_f6835_0(File outFile, Map<String, Object> config) throws IOException
{    FileUtils.write(outFile, JSONUtils.INSTANCE.toJSON(config, true));}
private void metron_f6836_0(ParserTopologyCLI.ParserOptions option, String cliOverride, Predicate<ParserInput> cliOverrideCondition, Supplier<List<SensorParserConfig>> configSupplier, Predicate<ParserInput> configOverrideCondition) throws Exception
{    testConfigOption(new EnumMap<ParserTopologyCLI.ParserOptions, String>(ParserTopologyCLI.ParserOptions.class) {        {            put(option, cliOverride);        }    }, cliOverrideCondition, configSupplier, configOverrideCondition);}
private void metron_f6837_0(EnumMap<ParserTopologyCLI.ParserOptions, String> options, Predicate<ParserInput> cliOverrideCondition, Supplier<List<SensorParserConfig>> configSupplier, Predicate<ParserInput> configOverrideCondition) throws Exception
{        List<SensorParserConfig> configs = configSupplier.get();    {        CLIBuilder builder = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor");        for (Map.Entry<ParserTopologyCLI.ParserOptions, String> entry : options.entrySet()) {            builder.with(entry.getKey(), entry.getValue());        }        CommandLine cmd = builder.build(true);        ParserInput input = getInput(cmd, configs);        Assert.assertTrue(cliOverrideCondition.test(input));    }        {        CLIBuilder builder = new CLIBuilder().with(ParserTopologyCLI.ParserOptions.BROKER_URL, "mybroker").with(ParserTopologyCLI.ParserOptions.ZK_QUORUM, "myzk").with(ParserTopologyCLI.ParserOptions.SENSOR_TYPES, "mysensor");        CommandLine cmd = builder.build(true);        ParserInput input = getInput(cmd, configs);        Assert.assertTrue(configOverrideCondition.test(input));    }}
private static ParserInput metron_f6838_0(CommandLine cmd, List<SensorParserConfig> configs) throws Exception
{    final ParserInput[] parserInput = new ParserInput[] { null };    new ParserTopologyCLI() {        @Override        protected ParserTopologyBuilder.ParserTopology getParserTopology(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorType, ValueSupplier<List> spoutParallelism, ValueSupplier<List> spoutNumTasks, ValueSupplier<Integer> parserParallelism, ValueSupplier<Integer> parserNumTasks, ValueSupplier<Integer> errorParallelism, ValueSupplier<Integer> errorNumTasks, ValueSupplier<List> spoutConfig, ValueSupplier<String> securityProtocol, ValueSupplier<Config> stormConf, ValueSupplier<String> outputTopic, ValueSupplier<String> errorTopic) throws Exception {            parserInput[0] = new ParserInput(spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, stormConf, outputTopic, errorTopic, configs);            return null;        }    }.createParserTopology(cmd);    return parserInput[0];}
protected ParserTopologyBuilder.ParserTopology metron_f6839_0(String zookeeperUrl, Optional<String> brokerUrl, List<String> sensorType, ValueSupplier<List> spoutParallelism, ValueSupplier<List> spoutNumTasks, ValueSupplier<Integer> parserParallelism, ValueSupplier<Integer> parserNumTasks, ValueSupplier<Integer> errorParallelism, ValueSupplier<Integer> errorNumTasks, ValueSupplier<List> spoutConfig, ValueSupplier<String> securityProtocol, ValueSupplier<Config> stormConf, ValueSupplier<String> outputTopic, ValueSupplier<String> errorTopic) throws Exception
{    parserInput[0] = new ParserInput(spoutParallelism, spoutNumTasks, parserParallelism, parserNumTasks, errorParallelism, errorNumTasks, spoutConfig, securityProtocol, stormConf, outputTopic, errorTopic, configs);    return null;}
public void metron_f6840_0() throws UnableToStartException, IOException
{    final String sensorType = "dummy";        final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("col11,col12,col13"));            add(Bytes.toBytes("col21,col22,col23"));            add(Bytes.toBytes("col31,col32,col33"));        }    };        MockHBaseTableProvider.addToCache(sensorType, "cf");    final Properties topologyProperties = new Properties();    final ZKServerComponent zkServerComponent = getZKServerComponent(topologyProperties);    final KafkaComponent kafkaComponent = getKafkaComponent(topologyProperties, new ArrayList<KafkaComponent.Topic>() {        {            add(new KafkaComponent.Topic(sensorType, 1));        }    });    topologyProperties.setProperty("kafka.broker", kafkaComponent.getBrokerList());    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(parserConfigJSON, SensorParserConfig.class);    System.out.println("Workspace: " + System.getProperty("user.dir"));    System.out.println("Configs path: ../" + TestConstants.SAMPLE_CONFIG_PATH);    ConfigUploadComponent configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties).withGlobalConfigsPath("../" + TestConstants.SAMPLE_CONFIG_PATH).withParserSensorConfig(sensorType, parserConfig);    ParserTopologyComponent parserTopologyComponent = new ParserTopologyComponent.Builder().withSensorTypes(Collections.singletonList(sensorType)).withTopologyProperties(topologyProperties).withBrokerUrl(kafkaComponent.getBrokerList()).withOutputTopic(parserConfig.getOutputTopic()).build();    ComponentRunner runner = new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("org/apache/storm", parserTopologyComponent).withMillisecondsBetweenAttempts(5000).withCustomShutdownOrder(new String[] { "org/apache/storm", "config", "kafka", "zk" }).withNumRetries(10).build();    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        ProcessorResult<List<LookupKV<EnrichmentKey, EnrichmentValue>>> result = runner.process(new Processor<List<LookupKV<EnrichmentKey, EnrichmentValue>>>() {            List<LookupKV<EnrichmentKey, EnrichmentValue>> messages = null;            @Override            public ReadinessState process(ComponentRunner runner) {                MockHTable table = (MockHTable) MockHBaseTableProvider.getFromCache(sensorType);                if (table != null && table.size() == inputMessages.size()) {                    EnrichmentConverter converter = new EnrichmentConverter();                    messages = new ArrayList<>();                    try {                        for (Result r : table.getScanner(Bytes.toBytes("cf"))) {                            messages.add(converter.fromResult(r, "cf"));                        }                    } catch (IOException e) {                    }                    return ReadinessState.READY;                }                return ReadinessState.NOT_READY;            }            @Override            public ProcessorResult<List<LookupKV<EnrichmentKey, EnrichmentValue>>> getResult() {                ProcessorResult.Builder<List<LookupKV<EnrichmentKey, EnrichmentValue>>> builder = new ProcessorResult.Builder();                return builder.withResult(messages).build();            }        });        Set<String> validIndicators = new HashSet<>(ImmutableList.of("col12", "col22", "col32"));        Map<String, Map<String, String>> validMetadata = new HashMap<String, Map<String, String>>() {            {                put("col12", new HashMap<String, String>() {                    {                        put("col1", "col11");                        put("col3", "col13");                    }                });                put("col22", new HashMap<String, String>() {                    {                        put("col1", "col21");                        put("col3", "col23");                    }                });                put("col32", new HashMap<String, String>() {                    {                        put("col1", "col31");                        put("col3", "col33");                    }                });            }        };        for (LookupKV<EnrichmentKey, EnrichmentValue> kv : result.getResult()) {            Assert.assertTrue(validIndicators.contains(kv.getKey().indicator));            Assert.assertEquals(kv.getValue().getMetadata().get("source.type"), "dummy");            Assert.assertNotNull(kv.getValue().getMetadata().get("timestamp"));            Assert.assertNotNull(kv.getValue().getMetadata().get("original_string"));            Map<String, String> metadata = validMetadata.get(kv.getKey().indicator);            for (Map.Entry<String, String> x : metadata.entrySet()) {                Assert.assertEquals(kv.getValue().getMetadata().get(x.getKey()), x.getValue());            }            Assert.assertEquals(metadata.size() + 4, kv.getValue().getMetadata().size());        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public ReadinessState metron_f6841_0(ComponentRunner runner)
{    MockHTable table = (MockHTable) MockHBaseTableProvider.getFromCache(sensorType);    if (table != null && table.size() == inputMessages.size()) {        EnrichmentConverter converter = new EnrichmentConverter();        messages = new ArrayList<>();        try {            for (Result r : table.getScanner(Bytes.toBytes("cf"))) {                messages.add(converter.fromResult(r, "cf"));            }        } catch (IOException e) {        }        return ReadinessState.READY;    }    return ReadinessState.NOT_READY;}
public ProcessorResult<List<LookupKV<EnrichmentKey, EnrichmentValue>>> metron_f6842_0()
{    ProcessorResult.Builder<List<LookupKV<EnrichmentKey, EnrichmentValue>>> builder = new ProcessorResult.Builder();    return builder.withResult(messages).build();}
public void metron_f6843_0() throws IOException
{    ParserDriver driver = new StormParserDriver("test", parserConfig_default, "{}");    super.testEnvelopedData(driver);}
public void metron_f6844_0() throws IOException
{    ParserDriver driver = new StormParserDriver("test", parserConfig_withPrefix, "{}");    super.testEnvelopedData_withMetadataPrefix(driver);}
public void metron_f6845_0() throws IOException
{    ParserDriver driver = new StormParserDriver("test", parserConfig_nomerge, "{}");    super.testEnvelopedData_noMergeMetadata(driver);}
public void metron_f6846_0() throws Exception
{    ParserDriver syslogDriver = new StormParserDriver("ciscoPix", ciscoPixSyslogConfig, "{}");    ParserDriver driver = new StormParserDriver("cisco302020", cisco302020Config, "{}");    super.testCiscoPixEnvelopingCisco302020(syslogDriver, driver);}
public boolean metron_f6847_0(Map<String, Object> input, Map<String, Object> validationConfig, Map<String, Object> globalConfig, Context context)
{    if (input.get("action") != null && input.get("action").equals("invalid")) {        return false;    }    return true;}
public void metron_f6849_0() throws Exception
{    final String sensorType = "dummy";    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(parserConfigJSONKafkaRedirection, SensorParserConfig.class);    final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("metron,foo"));            add(Bytes.toBytes("notmetron,foo"));            add(Bytes.toBytes("metron,bar"));            add(Bytes.toBytes("metron,baz"));        }    };    final Properties topologyProperties = new Properties();    ComponentRunner runner = setupTopologyComponents(topologyProperties, Collections.singletonList(sensorType), Collections.singletonList(parserConfig), globalConfigWithValidation);    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        KafkaProcessor<Map<String, List<JSONObject>>> kafkaProcessor = getKafkaProcessor(parserConfig.getOutputTopic(), parserConfig.getErrorTopic(), kafkaMessageSet -> kafkaMessageSet.getMessages().size() == 3 && kafkaMessageSet.getErrors().isEmpty());        ProcessorResult<Map<String, List<JSONObject>>> result = runner.process(kafkaProcessor);                Map<String, List<JSONObject>> outputMessages = result.getResult();        for (JSONObject j : outputMessages.get(Constants.ENRICHMENT_TOPIC)) {            Assert.assertEquals("metron", j.get("name"));            Assert.assertEquals("output", j.get("route_field"));            Assert.assertTrue(ImmutableSet.of("foo", "bar", "baz").contains(j.get("dummy")));        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public void metron_f6850_0() throws Exception
{    final String sensorType = "dummy";    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(parserConfigJSON, SensorParserConfig.class);    final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("valid,foo"));            add(Bytes.toBytes("invalid,foo"));            add(Bytes.toBytes("error"));        }    };    final Properties topologyProperties = new Properties();    ComponentRunner runner = setupTopologyComponents(topologyProperties, Collections.singletonList(sensorType), Collections.singletonList(parserConfig), globalConfigWithValidation);    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        KafkaProcessor<Map<String, List<JSONObject>>> kafkaProcessor = getKafkaProcessor(parserConfig.getOutputTopic(), parserConfig.getErrorTopic());        ProcessorResult<Map<String, List<JSONObject>>> result = runner.process(kafkaProcessor);                Map<String, List<JSONObject>> outputMessages = result.getResult();        Assert.assertEquals(2, outputMessages.size());        Assert.assertEquals(1, outputMessages.get(Constants.ENRICHMENT_TOPIC).size());        Assert.assertEquals("valid", outputMessages.get(Constants.ENRICHMENT_TOPIC).get(0).get("action"));        Assert.assertEquals(2, outputMessages.get(parserConfig.getErrorTopic()).size());                JSONObject invalidMessage = outputMessages.get(parserConfig.getErrorTopic()).get(0);        Assert.assertEquals(Constants.ErrorType.PARSER_INVALID.getType(), invalidMessage.get(Constants.ErrorFields.ERROR_TYPE.getName()));        JSONObject rawMessage = JSONUtils.INSTANCE.load((String) invalidMessage.get(Constants.ErrorFields.RAW_MESSAGE.getName()), JSONObject.class);        Assert.assertEquals("foo", rawMessage.get("dummy"));        Assert.assertEquals("invalid", rawMessage.get("action"));                JSONObject errorMessage = outputMessages.get(parserConfig.getErrorTopic()).get(1);        Assert.assertEquals(Constants.ErrorType.PARSER_ERROR.getType(), errorMessage.get(Constants.ErrorFields.ERROR_TYPE.getName()));        Assert.assertEquals("error", errorMessage.get(Constants.ErrorFields.RAW_MESSAGE.getName()));    } finally {        if (runner != null) {            runner.stop();        }    }}
public ComponentRunner metron_f6851_0(Properties topologyProperties, List<String> sensorTypes, List<SensorParserConfig> parserConfigs, String globalConfig)
{    zkServerComponent = getZKServerComponent(topologyProperties);    List<KafkaComponent.Topic> topics = new ArrayList<>();    for (String sensorType : sensorTypes) {        topics.add(new KafkaComponent.Topic(sensorType, 1));    }    topics.add(new KafkaComponent.Topic(Constants.ENRICHMENT_TOPIC, 1));    kafkaComponent = getKafkaComponent(topologyProperties, topics);    topologyProperties.setProperty("kafka.broker", kafkaComponent.getBrokerList());    configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties).withGlobalConfig(globalConfig);    for (int i = 0; i < sensorTypes.size(); ++i) {        configUploadComponent.withParserSensorConfig(sensorTypes.get(i), parserConfigs.get(i));    }    parserTopologyComponent = new ParserTopologyComponent.Builder().withSensorTypes(sensorTypes).withTopologyProperties(topologyProperties).withBrokerUrl(kafkaComponent.getBrokerList()).withErrorTopic(parserConfigs.get(0).getErrorTopic()).withOutputTopic(parserConfigs.get(0).getOutputTopic()).build();    return new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("org/apache/storm", parserTopologyComponent).withMillisecondsBetweenAttempts(5000).withNumRetries(10).withCustomShutdownOrder(new String[] { "org/apache/storm", "config", "kafka", "zk" }).build();}
private KafkaProcessor<Map<String, List<JSONObject>>> metron_f6852_0(String outputTopic, String errorTopic)
{    return getKafkaProcessor(outputTopic, errorTopic, messageSet -> (messageSet.getMessages().size() == 1) && (messageSet.getErrors().size() == 2));}
private KafkaProcessor<Map<String, List<JSONObject>>> metron_f6853_0(String outputTopic, String errorTopic, Predicate<KafkaMessageSet> predicate)
{    return new KafkaProcessor<>().withKafkaComponentName("kafka").withReadTopic(outputTopic).withErrorTopic(errorTopic).withValidateReadMessages(new Function<KafkaMessageSet, Boolean>() {        @Nullable        @Override        public Boolean apply(@Nullable KafkaMessageSet messageSet) {            return predicate.test(messageSet);        }    }).withProvideResult(new Function<KafkaMessageSet, Map<String, List<JSONObject>>>() {        @Nullable        @Override        public Map<String, List<JSONObject>> apply(@Nullable KafkaMessageSet messageSet) {            return new HashMap<String, List<JSONObject>>() {                {                    put(Constants.ENRICHMENT_TOPIC, loadMessages(messageSet.getMessages()));                    put(errorTopic, loadMessages(messageSet.getErrors()));                }            };        }    });}
public Boolean metron_f6854_0(@Nullable KafkaMessageSet messageSet)
{    return predicate.test(messageSet);}
public Map<String, List<JSONObject>> metron_f6855_0(@Nullable KafkaMessageSet messageSet)
{    return new HashMap<String, List<JSONObject>>() {        {            put(Constants.ENRICHMENT_TOPIC, loadMessages(messageSet.getMessages()));            put(errorTopic, loadMessages(messageSet.getErrors()));        }    };}
private static List<JSONObject> metron_f6856_0(List<byte[]> outputMessages)
{    List<JSONObject> tmp = new ArrayList<>();    Iterables.addAll(tmp, Iterables.transform(outputMessages, message -> {        try {            return new JSONObject(JSONUtils.INSTANCE.load(new String(message, StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER));        } catch (Exception ex) {            throw new IllegalStateException(ex);        }    }));    return tmp;}
public void metron_f6857_0() throws Exception
{    final String sensorType = "emptyobjectparser";    SensorParserConfig parserConfig = JSONUtils.INSTANCE.load(offsetParserConfigJSON, SensorParserConfig.class);    final List<byte[]> inputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("foo"));            add(Bytes.toBytes("bar"));            add(Bytes.toBytes("baz"));        }    };    final Properties topologyProperties = new Properties();    ComponentRunner runner = setupTopologyComponents(topologyProperties, Collections.singletonList(sensorType), Collections.singletonList(parserConfig), globalConfigEmpty);    try {        runner.start();        kafkaComponent.writeMessages(sensorType, inputMessages);        Processor allResultsProcessor = new AllResultsProcessor(inputMessages, Constants.ENRICHMENT_TOPIC);        ProcessorResult<Set<JSONObject>> result = runner.process(allResultsProcessor);                assertThat("size should match", result.getResult().size(), equalTo(inputMessages.size()));        for (JSONObject record : result.getResult()) {            assertThat("record should have a guid", record.containsKey("guid"), equalTo(true));            assertThat("record should have correct source.type", record.get("source.type"), equalTo(sensorType));        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public void metron_f6858_0() throws Exception
{        final String emptyObjectSensorType = "emptyobjectparser";    SensorParserConfig emptyObjectParserConfig = JSONUtils.INSTANCE.load(offsetParserConfigJSON, SensorParserConfig.class);    final List<byte[]> emptyObjectInputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("foo"));            add(Bytes.toBytes("bar"));            add(Bytes.toBytes("baz"));        }    };        final String dummySensorType = "dummyobjectparser";    SensorParserConfig dummyParserConfig = JSONUtils.INSTANCE.load(dummyParserConfigJSON, SensorParserConfig.class);    final List<byte[]> dummyInputMessages = new ArrayList<byte[]>() {        {            add(Bytes.toBytes("dummy_foo"));            add(Bytes.toBytes("dummy_bar"));            add(Bytes.toBytes("dummy_baz"));        }    };    final Properties topologyProperties = new Properties();    List<String> sensorTypes = new ArrayList<>();    sensorTypes.add(emptyObjectSensorType);    sensorTypes.add(dummySensorType);    List<SensorParserConfig> parserConfigs = new ArrayList<>();    parserConfigs.add(emptyObjectParserConfig);    parserConfigs.add(dummyParserConfig);    ComponentRunner runner = setupTopologyComponents(topologyProperties, sensorTypes, parserConfigs, globalConfigEmpty);    try {        runner.start();        kafkaComponent.writeMessages(emptyObjectSensorType, emptyObjectInputMessages);        kafkaComponent.writeMessages(dummySensorType, dummyInputMessages);        final List<byte[]> allInputMessages = new ArrayList<>();        allInputMessages.addAll(emptyObjectInputMessages);        allInputMessages.addAll(dummyInputMessages);        Processor allResultsProcessor = new AllResultsProcessor(allInputMessages, Constants.ENRICHMENT_TOPIC);        @SuppressWarnings("unchecked")        ProcessorResult<Set<JSONObject>> result = runner.process(allResultsProcessor);                assertThat("size should match", result.getResult().size(), equalTo(allInputMessages.size()));        for (JSONObject record : result.getResult()) {            assertThat("record should have a guid", record.containsKey("guid"), equalTo(true));        }    } finally {        if (runner != null) {            runner.stop();        }    }}
public List<JSONObject> metron_f6860_0(byte[] bytes)
{    return ImmutableList.of(new JSONObject());}
public boolean metron_f6861_0(JSONObject message)
{    return true;}
public List<JSONObject> metron_f6864_0(byte[] bytes)
{    JSONObject dummy = new JSONObject();    dummy.put("dummy_key", "dummy_value");    return ImmutableList.of(dummy);}
public boolean metron_f6865_0(JSONObject message)
{    return true;}
public ReadinessState metron_f6867_0(ComponentRunner runner)
{    KafkaComponent kc = runner.getComponent("kafka", KafkaComponent.class);    outputMessages.addAll(readMessagesFromKafka(kc, outputKafkaTopic));    return calcReadiness(inputMessages.size(), outputMessages.size());}
private Set<JSONObject> metron_f6868_0(KafkaComponent kc, String topic)
{    Set<JSONObject> out = new HashSet<>();    for (byte[] b : kc.readMessages(topic)) {        try {            JSONObject m = new JSONObject(JSONUtils.INSTANCE.load(new String(b, StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER));            out.add(m);        } catch (IOException e) {            throw new IllegalStateException(e);        }    }    return out;}
private ReadinessState metron_f6869_0(int in, int out)
{    return in == out ? ReadinessState.READY : ReadinessState.NOT_READY;}
public ProcessorResult<Set<JSONObject>> metron_f6870_0()
{    return new ProcessorResult<>(outputMessages, null);}
public Map<String, String> metron_f6871_0()
{    return PcapOptions.FIELDS.get(this, Map.class);}
public void metron_f6872_0(Map<String, String> fixedFields)
{    PcapOptions.FIELDS.put(this, fixedFields);}
public void metron_f6873_0(String key, String value)
{    Map<String, String> fixedFields = PcapOptions.FIELDS.get(this, Map.class);    String trimmedVal = value != null ? value.trim() : null;    if (!isNullOrEmpty(trimmedVal)) {        fixedFields.put(key, value);    }}
public Object metron_f6874_0(ConfigOption option)
{    Object o = get(option.getKey());    return option.transform().apply(option.getKey(), o);}
public String metron_f6875_0()
{    return PcapOptions.FINAL_FILENAME_PREFIX.get(this, String.class);}
public void metron_f6876_0(String prefix)
{    PcapOptions.FINAL_FILENAME_PREFIX.put(this, prefix);}
public int metron_f6877_0()
{    return PcapOptions.NUM_REDUCERS.get(this, Integer.class);}
public boolean metron_f6878_0()
{    return showHelp;}
public void metron_f6879_0(boolean showHelp)
{    this.showHelp = showHelp;}
public boolean metron_f6880_0()
{    return PcapOptions.PRINT_JOB_STATUS.get(this, Boolean.class);}
public void metron_f6881_0(boolean printJobStatus)
{    PcapOptions.PRINT_JOB_STATUS.put(this, printJobStatus);}
public String metron_f6882_0()
{    return PcapOptions.BASE_PATH.get(this, String.class);}
public String metron_f6883_0()
{    return PcapOptions.BASE_INTERIM_RESULT_PATH.get(this, String.class);}
public long metron_f6884_0()
{    return PcapOptions.START_TIME_MS.get(this, Long.class);}
public long metron_f6885_0()
{    return PcapOptions.END_TIME_MS.get(this, Long.class);}
public void metron_f6886_0(String basePath)
{    PcapOptions.BASE_PATH.put(this, basePath);}
public void metron_f6887_0(String baseOutputPath)
{    PcapOptions.BASE_INTERIM_RESULT_PATH.put(this, baseOutputPath);}
public void metron_f6888_0(long startTime)
{    PcapOptions.START_TIME_MS.put(this, startTime);}
public void metron_f6889_0(long endTime)
{    PcapOptions.END_TIME_MS.put(this, endTime);}
public boolean metron_f6890_0(String val)
{    return StringUtils.isEmpty(val);}
public void metron_f6891_0(String dateFormat)
{    this.dateFormat = new SimpleDateFormat(dateFormat);}
public DateFormat metron_f6892_0()
{    return dateFormat;}
public void metron_f6893_0(int numReducers)
{    PcapOptions.NUM_REDUCERS.put(this, numReducers);}
public int metron_f6894_0()
{    return PcapOptions.NUM_RECORDS_PER_FILE.get(this, Integer.class);}
public void metron_f6895_0(int numRecordsPerFile)
{    PcapOptions.NUM_RECORDS_PER_FILE.put(this, numRecordsPerFile);}
public void metron_f6896_0(String yarnQueue)
{    this.yarnQueue = yarnQueue;}
public Optional<String> metron_f6897_0()
{    return Optional.ofNullable(yarnQueue);}
public void metron_f6898_0(String numThreads)
{    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(this, numThreads);}
public String metron_f6899_0()
{    return key;}
public BiFunction<String, Object, Object> metron_f6900_0()
{    return transform;}
public String metron_f6901_0()
{    return PcapOptions.FIELDS.get(this, String.class);}
public void metron_f6902_0(String query)
{    PcapOptions.FIELDS.put(this, query);}
public void metron_f6903_0(Map<String, String> fields, Configuration conf)
{    for (Map.Entry<String, String> kv : fields.entrySet()) {        conf.set(kv.getKey(), kv.getValue());    }    conf.set(PCAP_FILTER_NAME_CONF, PcapFilters.FIXED.name());}
public String metron_f6904_0(Map<String, String> fields)
{    return (fields == null ? "" : Joiner.on("_").join(fields.values()).replaceAll("\\s", "_"));}
public void metron_f6905_0(Iterable<Map.Entry<String, String>> config)
{    for (Map.Entry<String, String> kv : config) {        if (kv.getKey().equals(Constants.Fields.DST_ADDR.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.dstAddr = kv.getValue();            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.SRC_ADDR.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.srcAddr = kv.getValue();            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.DST_PORT.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.dstPort = Integer.parseInt(kv.getValue());            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.SRC_PORT.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.srcPort = Integer.parseInt(kv.getValue());            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.PROTOCOL.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.protocol = kv.getValue();            doHeaderFiltering = true;        }        if (kv.getKey().equals(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.includesReverseTraffic = Boolean.parseBoolean(kv.getValue());        }        if (kv.getKey().equals(PcapHelper.PacketFields.PACKET_FILTER.getName())) {            System.out.println("Processing: " + kv.getKey() + " => " + kv.getValue());            this.packetFilter = kv.getValue();        }    }}
public boolean metron_f6906_0(PacketInfo pi)
{    Map<String, Object> fields = packetToFields(pi);    VariableResolver resolver = new MapVariableResolver(fields);    String srcAddrIn = (String) resolver.resolve(Constants.Fields.SRC_ADDR.getName());    Integer srcPortIn = (Integer) resolver.resolve(Constants.Fields.SRC_PORT.getName());    String dstAddrIn = (String) resolver.resolve(Constants.Fields.DST_ADDR.getName());    Integer dstPortIn = (Integer) resolver.resolve(Constants.Fields.DST_PORT.getName());    String protocolIn = "" + resolver.resolve(Constants.Fields.PROTOCOL.getName());    if (!doHeaderFiltering || testHeader(srcAddrIn, srcPortIn, dstAddrIn, dstPortIn, protocolIn)) {                if (packetFilter != null) {                        byte[] data = (byte[]) resolver.resolve(PcapHelper.PacketFields.PACKET_DATA.getName());            try {                return ByteArrayMatchingUtil.INSTANCE.match(packetFilter, data);            } catch (ExecutionException e) {                throw new IllegalStateException("Unable to perform binary filter: " + packetFilter + " on " + DatatypeConverter.printHexBinary(data), e);            }        } else if (!doHeaderFiltering) {                        return true;        } else {                        return true;        }    } else {                return false;    }}
private boolean metron_f6907_0(String srcAddrIn, Integer srcPortIn, String dstAddrIn, Integer dstPortIn, String protocolIn)
{    if (areMatch(protocol, protocolIn)) {        if (matchesSourceAndDestination(srcAddrIn, srcPortIn, dstAddrIn, dstPortIn)) {            return true;        } else if (includesReverseTraffic) {            return matchesReverseSourceAndDestination(srcAddrIn, srcPortIn, dstAddrIn, dstPortIn);        }    }    return false;}
private boolean metron_f6908_0(Integer filter, Integer input)
{    return filter == null || areMatch(Integer.toUnsignedString(filter), input == null ? null : Integer.toUnsignedString(input));}
private boolean metron_f6909_0(String filter, String input)
{    if (filter != null) {        return input != null && input.equals(filter);    } else {        return true;    }}
protected Map<String, Object> metron_f6910_0(PacketInfo pi)
{    return PcapHelper.packetToFields(pi);}
private boolean metron_f6911_0(String srcAddrComp, Integer srcPortComp, String dstAddrComp, Integer dstPortComp)
{    boolean isMatch = true;    isMatch &= areMatch(this.srcAddr, srcAddrComp);    isMatch &= areMatch(this.srcPort, srcPortComp);    isMatch &= areMatch(this.dstAddr, dstAddrComp);    isMatch &= areMatch(this.dstPort, dstPortComp);    return isMatch;}
private boolean metron_f6912_0(String srcAddr, Integer srcPort, String dstAddr, Integer dstPort)
{    return matchesSourceAndDestination(dstAddr, dstPort, srcAddr, srcPort);}
public Object metron_f6913_0(String variable)
{    if (variable.equals(VariableResolver.ALL_FIELDS)) {        return new ConcatMap(ImmutableList.of(fieldsMap));    }    return fieldsMap.get(variable);}
public boolean metron_f6914_0(String variable)
{    return fieldsMap.containsKey(variable);}
public PcapFilter metron_f6915_0()
{    return creator.create();}
public PcapFilter metron_f6916_0()
{    return new FixedPcapFilter();}
public PcapFilter metron_f6917_0()
{    return new QueryPcapFilter();}
public void metron_f6918_0(String query, Configuration conf)
{    conf.set(QUERY_STR_CONFIG, query);    conf.set(PCAP_FILTER_NAME_CONF, PcapFilters.QUERY.name());}
public String metron_f6919_0(String fields)
{    return (fields == null ? "" : fields.trim().replaceAll("\\s", "_"));}
public void metron_f6920_0(Iterable<Map.Entry<String, String>> config)
{    for (Map.Entry<String, String> entry : config) {        if (entry.getKey().equals(QUERY_STR_CONFIG)) {            queryString = entry.getValue();        }    }    predicateProcessor.validate(queryString);}
public boolean metron_f6921_0(PacketInfo input)
{    Map<String, Object> fields = packetToFields(input);    VariableResolver resolver = new MapVariableResolver(fields);    return predicateProcessor.parse(queryString, resolver, StellarFunctions.FUNCTION_RESOLVER(), Context.EMPTY_CONTEXT());}
protected Map<String, Object> metron_f6922_0(PacketInfo pi)
{    return PcapHelper.packetToFields(pi);}
protected void metron_f6923_0(PcapResultsWriter resultsWriter, Configuration hadoopConfig, List<byte[]> data, Path outputPath) throws IOException
{    resultsWriter.writeLocal(data, outputPath.toString());}
protected Path metron_f6924_0(Map<String, Object> config, int partition)
{    Path finalOutputPath = PcapOptions.FINAL_OUTPUT_PATH.get(config, PcapOptions.STRING_TO_PATH, Path.class);    String prefix = PcapOptions.FINAL_FILENAME_PREFIX.get(config, String.class);    return new Path(String.format(PCAP_CLI_FILENAME_FORMAT, finalOutputPath, prefix, partition));}
protected PcapResultsWriter metron_f6925_0()
{    return resultsWriter;}
public Pageable<Path> metron_f6926_1(Map<String, Object> config) throws JobException
{    Configuration hadoopConfig = PcapOptions.HADOOP_CONF.get(config, Configuration.class);    int recPerFile = PcapOptions.NUM_RECORDS_PER_FILE.getOrDefault(config, Integer.class, NUM_RECORDS_PER_FILE_DEFAULT);    Path interimResultPath = PcapOptions.INTERIM_RESULT_PATH.get(config, PcapOptions.STRING_TO_PATH, Path.class);    FileSystem fs = PcapOptions.FILESYSTEM.get(config, FileSystem.class);    int parallelism = getNumThreads(PcapOptions.FINALIZER_THREADPOOL_SIZE.get(config, String.class));        SequenceFileIterable interimResults = null;    try {        interimResults = readInterimResults(interimResultPath, hadoopConfig, fs);    } catch (IOException e) {        throw new JobException("Unable to read interim job results while finalizing", e);    }    List<Path> outFiles = new ArrayList<>();    try {        Iterable<List<byte[]>> partitions = Iterables.partition(interimResults, recPerFile);        Map<Path, List<byte[]>> toWrite = new HashMap<>();        int part = 1;        if (partitions.iterator().hasNext()) {            for (List<byte[]> data : partitions) {                Path outputPath = getOutputPath(config, part++);                toWrite.put(outputPath, data);            }            outFiles = writeParallel(hadoopConfig, toWrite, parallelism);        } else {                    }    } catch (IOException e) {        throw new JobException("Failed to finalize results", e);    } finally {        try {            interimResults.cleanup();        } catch (IOException e) {                    }    }        return new PcapPages(outFiles);}
private static int metron_f6927_0(String numThreads) throws JobException
{    String numThreadsStr = ((String) numThreads).trim().toUpperCase();    try {        if (numThreadsStr.endsWith("C")) {            Integer factor = Integer.parseInt(numThreadsStr.replace("C", ""));            return factor * Runtime.getRuntime().availableProcessors();        } else {            return Integer.parseInt(numThreadsStr);        }    } catch (NumberFormatException e) {        throw new JobException(format("Unable to set number of threads for finalizing from property value '%s'", numThreads));    }}
protected List<Path> metron_f6928_0(Configuration hadoopConfig, Map<Path, List<byte[]>> toWrite, int parallelism) throws IOException
{    List<Path> outFiles = Collections.synchronizedList(new ArrayList<>());    ForkJoinPool tp = new ForkJoinPool(parallelism);    try {        tp.submit(() -> {            toWrite.entrySet().parallelStream().forEach(e -> {                Path path = e.getKey();                List<byte[]> data = e.getValue();                if (data.size() > 0) {                    try {                        write(getResultsWriter(), hadoopConfig, data, path);                    } catch (IOException ioe) {                        throw new RuntimeException(String.format("Failed to write results to path '%s'", path.toString()), ioe);                    }                    outFiles.add(path);                }            });        }).get();    } catch (InterruptedException | ExecutionException e) {        throw new IOException("Error finalizing results.", e);    } catch (RuntimeException e) {        throw new IOException(e.getMessage(), e.getCause());    }    outFiles.sort((o1, o2) -> o1.getName().compareTo(o2.getName()));    return outFiles;}
protected SequenceFileIterable metron_f6929_1(Path interimResultPath, Configuration config, FileSystem fs) throws IOException
{    List<Path> files = new ArrayList<>();    for (RemoteIterator<LocatedFileStatus> it = fs.listFiles(interimResultPath, false); it.hasNext(); ) {        Path p = it.next().getPath();        if (p.getName().equals("_SUCCESS")) {            fs.delete(p, false);            continue;        }        files.add(p);    }    if (files.size() == 0) {            } else {                Collections.sort(files, (o1, o2) -> o1.getName().compareTo(o2.getName()));    }    return new SequenceFileIterable(files, config);}
public Pageable<Path> metron_f6930_0(Map<String, Object> config) throws JobException
{    return finalizer.finalizeJob(config);}
protected void metron_f6931_0(PcapResultsWriter resultsWriter, Configuration hadoopConfig, List<byte[]> data, Path outputPath) throws IOException
{    resultsWriter.write(hadoopConfig, data, outputPath.toString());}
protected Path metron_f6932_0(Map<String, Object> config, int partition)
{    String finalOutputPath = PcapOptions.FINAL_OUTPUT_PATH.getOrDefault(config, String.class, FINAL_OUTPUT_PATH_DEFAULT);    String user = PcapOptions.USERNAME.get(config, String.class);    String jobId = PcapOptions.JOB_ID.get(config, String.class);    return new Path(String.format(PCAP_REST_FILEPATH_FORMAT, finalOutputPath, user, jobType, jobId, partition));}
public int metron_f6933_0()
{    return priorityCodePoint;}
public int metron_f6934_0()
{    return dropEligibleIndicator;}
public int metron_f6935_0()
{    return vLANIdentifier;}
public void metron_f6936_0(EthernetProcessor processor)
{    this.callbacks.add(processor);}
public void metron_f6937_0(int type, EthernetProcessor processor)
{    Set<EthernetProcessor> processors = typeCallbacks.get(type);    if (processors == null) {        processors = new HashSet<EthernetProcessor>();        typeCallbacks.put(type, processors);    }    processors.add(processor);}
public void metron_f6938_0(EthernetProcessor processor)
{    this.callbacks.remove(processor);}
public void metron_f6939_0(int type, EthernetProcessor processor)
{    Set<EthernetProcessor> processors = typeCallbacks.get(type);    if (processors == null)        return;    processors.remove(processor);}
public void metron_f6940_0(PcapPacket packet)
{        MacAddress destination = getMacAddress(packet.getPacketData());    MacAddress source = getMacAddress(packet.getPacketData());    int type = getEtherType(packet.getPacketData());    if (type == 0x8100) {                IEEE_802_1Q iee802_1qTag = get802_1qTag(packet.getPacketData());                type = getEtherType(packet.getPacketData());    }    Buffer buffer = packet.getPacketData();    buffer.discardReadBytes();    EthernetFrame frame = new EthernetFrame(source, destination, type, buffer);    frame.setPcapPacket(packet);    dispatch(frame);}
private MacAddress metron_f6941_0(Buffer data)
{    byte[] mac = new byte[6];    data.gets(mac, 0, 6);    return new MacAddress(mac);}
private int metron_f6942_0(Buffer data)
{    return ((int) data.getShort()) & 0x0000FFFF;}
private IEEE_802_1Q metron_f6943_0(Buffer data)
{            byte[] b802_1qTag = new byte[2];    data.gets(b802_1qTag, 0, 2);    BitSet bits = BitSet.valueOf(b802_1qTag);    int pcp = convertBitToInt(bits.get(0, 3));    int dei = convertBitToInt(bits.get(3, 4));    int vid = convertBitToInt(bits.get(4, 16));    return new IEEE_802_1Q(pcp, dei, vid);}
public static int metron_f6944_0(BitSet bits)
{    int value = 0;    for (int i = 0; i < bits.length(); ++i) {        value += bits.get(i) ? (1 << i) : 0;    }    return value;}
private void metron_f6945_0(EthernetFrame frame)
{    for (EthernetProcessor processor : callbacks) processor.process(frame);    Set<EthernetProcessor> processors = typeCallbacks.get(frame.getType());    if (processors == null)        return;    for (EthernetProcessor processor : processors) processor.process(frame.dup());}
public String metron_f6946_0(long beginNS, long endNS, String query)
{    return sanitize(Joiner.on("_").join(beginNS, endNS, query, UUID.randomUUID().toString()));}
private String metron_f6947_0(String path)
{    return path.replace(".", "-").replace("'", "").replace(":", "");}
public int metron_f6948_0(LongWritable longWritable, BytesWritable bytesWritable, int numPartitions)
{    if (start == null) {        initialize();    }    long x = longWritable.get();    int ret = (int) Long.divideUnsigned(x - start, width);    if (ret > numPartitions) {        throw new IllegalArgumentException(String.format("Bad partition: key=%s, width=%d, partition=%d, numPartitions=%d", Long.toUnsignedString(x), width, ret, numPartitions));    }    return ret;}
private void metron_f6949_0()
{    start = Long.parseUnsignedLong(configuration.get(START_TS_CONF));    end = Long.parseUnsignedLong(configuration.get(END_TS_CONF));    width = Long.parseLong(configuration.get(WIDTH_CONF));}
public void metron_f6950_0(Configuration conf)
{    this.configuration = conf;}
public Configuration metron_f6951_0()
{    return configuration;}
protected void metron_f6952_0(Context context) throws IOException, InterruptedException
{    super.setup(context);    filter = PcapFilters.valueOf(context.getConfiguration().get(PcapFilterConfigurator.PCAP_FILTER_NAME_CONF)).create();    filter.configure(context.getConfiguration());    start = Long.parseUnsignedLong(context.getConfiguration().get(START_TS_CONF));    end = Long.parseUnsignedLong(context.getConfiguration().get(END_TS_CONF));}
protected void metron_f6953_0(LongWritable key, BytesWritable value, Context context) throws IOException, InterruptedException
{    if (greaterThanOrEqualTo(key.get(), start) && lessThanOrEqualTo(key.get(), end)) {                                        List<PacketInfo> packetInfos;        try {            packetInfos = PcapHelper.toPacketInfo(value.copyBytes());        } catch (Exception e) {                        context.getCounter(PCAP_COUNTER.MALFORMED_PACKET_COUNT).increment(1);            return;        }        boolean send = filteredPacketInfo(packetInfos).findAny().isPresent();        if (send) {            context.write(key, value);        }    }}
private Stream<PacketInfo> metron_f6954_0(List<PacketInfo> packetInfos) throws IOException
{    return packetInfos.stream().filter(filter);}
protected void metron_f6955_0(LongWritable key, Iterable<BytesWritable> values, Context context) throws IOException, InterruptedException
{    for (BytesWritable value : values) {        context.write(key, value);    }}
public void metron_f6956_0(long interval)
{    statusInterval = interval;}
public void metron_f6957_0(long interval)
{    completeCheckInterval = interval;}
public Statusable<Path> metron_f6958_0(Finalizer<Path> finalizer, Map<String, Object> config) throws JobException
{    this.finalizer = finalizer;    this.configuration = config;    Optional<String> jobName = Optional.ofNullable(PcapOptions.JOB_NAME.get(configuration, String.class));    Configuration hadoopConf = PcapOptions.HADOOP_CONF.get(configuration, Configuration.class);    FileSystem fileSystem = PcapOptions.FILESYSTEM.get(configuration, FileSystem.class);    Path basePath = PcapOptions.BASE_PATH.getTransformed(configuration, Path.class);    Path baseInterimResultPath = PcapOptions.BASE_INTERIM_RESULT_PATH.getTransformedOrDefault(configuration, Path.class, new Path(PcapGlobalDefaults.BASE_INTERIM_RESULT_PATH_DEFAULT));    long startTimeNs;    if (configuration.containsKey(PcapOptions.START_TIME_NS.getKey())) {        startTimeNs = PcapOptions.START_TIME_NS.getOrDefault(configuration, Long.class, 0L);    } else {        startTimeNs = TimestampConverters.MILLISECONDS.toNanoseconds(PcapOptions.START_TIME_MS.getOrDefault(configuration, Long.class, 0L));    }    long endTimeNs;    if (configuration.containsKey(PcapOptions.END_TIME_NS.getKey())) {        endTimeNs = PcapOptions.END_TIME_NS.getOrDefault(configuration, Long.class, TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis()));    } else {        endTimeNs = TimestampConverters.MILLISECONDS.toNanoseconds(PcapOptions.END_TIME_MS.getOrDefault(configuration, Long.class, System.currentTimeMillis()));    }    int numReducers = PcapOptions.NUM_REDUCERS.getOrDefault(configuration, Integer.class, NUM_REDUCERS_DEFAULT);    T fields = (T) PcapOptions.FIELDS.get(configuration, Object.class);    PcapFilterConfigurator<T> filterImpl = PcapOptions.FILTER_IMPL.get(configuration, PcapFilterConfigurator.class);    try {        Statusable<Path> statusable = query(jobName, basePath, baseInterimResultPath, startTimeNs, endTimeNs, numReducers, fields,         new Configuration(hadoopConf), fileSystem, filterImpl);        PcapOptions.JOB_ID.put(configuration, statusable.getStatus().getJobId());        return statusable;    } catch (IOException | InterruptedException | ClassNotFoundException e) {        throw new JobException("Failed to run pcap query.", e);    }}
public Statusable<Path> metron_f6959_1(Optional<String> jobName, Path basePath, Path baseInterimResultPath, long beginNS, long endNS, int numReducers, T fields, Configuration conf, FileSystem fs, PcapFilterConfigurator<T> filterImpl) throws IOException, ClassNotFoundException, InterruptedException
{    String outputDirName = outputDirFormatter.format(beginNS, endNS, filterImpl.queryToString(fields));    if (LOG.isDebugEnabled()) {        DateFormat format = SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.LONG, SimpleDateFormat.LONG);        String from = format.format(new Date(Long.divideUnsigned(beginNS, 1000000)));        String to = format.format(new Date(Long.divideUnsigned(endNS, 1000000)));            }    Path interimResultPath = new Path(baseInterimResultPath, outputDirName);    PcapOptions.INTERIM_RESULT_PATH.put(configuration, interimResultPath);    mrJob = createJob(jobName, basePath, interimResultPath, beginNS, endNS, numReducers, fields, conf, fs, filterImpl);    if (mrJob == null) {                try {            setFinalResults(input -> new PcapPages(), configuration);            jobStatus.withState(State.SUCCEEDED).withDescription("No results in specified date range.").withPercentComplete(100.0);        } catch (JobException e) {                        jobStatus.withState(State.FAILED).withDescription("Unable to finalize empty job.").withFailureException(e);        }        return this;    }    synchronized (this) {                                        mrJob.submit();        jobStatus.withState(State.SUBMITTED).withDescription("Job submitted").withJobId(mrJob.getJobID().toString());    }    startJobStatusTimerThread(statusInterval);    return this;}
private void metron_f6960_0(long interval)
{    getTimer().scheduleAtFixedRate(new TimerTask() {        @Override        public void run() {            if (!updateStatus()) {                                cancel();            }        }    }, interval, interval);}
public void metron_f6961_0()
{    if (!updateStatus()) {                cancel();    }}
public void metron_f6962_0(Timer timer)
{    this.timer = timer;}
private Timer metron_f6963_0()
{    return timer;}
private boolean metron_f6964_0()
{    JobStatus tempStatus = null;        final float mrJobFraction = 0.75f;    synchronized (this) {        tempStatus = new JobStatus(jobStatus);    }    boolean keepUpdating = true;    try {        boolean mrJobComplete = false;        org.apache.hadoop.mapreduce.JobStatus.State mrJobState = null;        String mrJobFailureInfo = null;        float mapProg = 0.0f;        float reduceProg = 0.0f;        synchronized (this) {            mrJobComplete = mrJob.isComplete();            org.apache.hadoop.mapreduce.JobStatus mrJobStatus = mrJob.getStatus();            mrJobState = mrJobStatus.getState();            mrJobFailureInfo = mrJobStatus.getFailureInfo();            mapProg = mrJob.mapProgress();            reduceProg = mrJob.reduceProgress();        }        if (mrJobComplete) {            switch(mrJobState) {                case SUCCEEDED:                    tempStatus.withPercentComplete(100.0 * mrJobFraction).withState(State.FINALIZING).withDescription("Finalizing job.");                    try {                        synchronized (this) {                                                        jobStatus = new JobStatus(tempStatus);                        }                        setFinalResults(finalizer, configuration);                        tempStatus.withPercentComplete(100.0).withState(State.SUCCEEDED).withDescription("Job completed.");                    } catch (JobException je) {                        tempStatus.withPercentComplete(100.0).withState(State.FAILED).withDescription("Job finalize failed.").withFailureException(je);                    }                    break;                case FAILED:                    tempStatus.withPercentComplete(100.0).withState(State.FAILED).withDescription(mrJobFailureInfo);                    break;                case KILLED:                    tempStatus.withPercentComplete(100.0).withState(State.KILLED).withDescription(mrJobFailureInfo);                    break;            }            keepUpdating = false;        } else {            float mrJobProgress = ((mapProg / 2) + (reduceProg / 2)) * 100;            float totalProgress = mrJobProgress * mrJobFraction;            String description = String.format("map: %s%%, reduce: %s%%", mapProg * 100, reduceProg * 100);            tempStatus.withPercentComplete(totalProgress).withState(State.RUNNING).withDescription(description);        }    } catch (InterruptedException | IOException e) {        tempStatus.withPercentComplete(100.0).withState(State.FAILED).withFailureException(e);        keepUpdating = false;    }    synchronized (this) {        jobStatus = new JobStatus(tempStatus);    }    return keepUpdating;}
private void metron_f6965_0(Finalizer<Path> finalizer, Map<String, Object> configuration) throws JobException
{    Pageable<Path> results = finalizer.finalizeJob(configuration);    if (results == null) {        results = new PcapPages();    }    synchronized (this) {        finalResults = results;    }}
public Job metron_f6966_0(Optional<String> jobName, Path basePath, Path jobOutputPath, long beginNS, long endNS, int numReducers, T fields, Configuration conf, FileSystem fs, PcapFilterConfigurator<T> filterImpl) throws IOException
{    Iterable<String> filteredPaths = FileFilterUtil.getPathsInTimeRange(beginNS, endNS, listFiles(fs, basePath));    String inputPaths = Joiner.on(',').join(filteredPaths);    if (StringUtils.isEmpty(inputPaths)) {        return null;    }    conf.set(START_TS_CONF, Long.toUnsignedString(beginNS));    conf.set(END_TS_CONF, Long.toUnsignedString(endNS));    conf.set(WIDTH_CONF, "" + findWidth(beginNS, endNS, numReducers));    filterImpl.addToConfig(fields, conf);    Job job = Job.getInstance(conf);    jobName.ifPresent(job::setJobName);    job.setJarByClass(PcapJob.class);    job.setMapperClass(PcapJob.PcapMapper.class);    job.setMapOutputKeyClass(LongWritable.class);    job.setMapOutputValueClass(BytesWritable.class);    job.setNumReduceTasks(numReducers);    job.setReducerClass(PcapReducer.class);    job.setPartitionerClass(PcapPartitioner.class);    job.setOutputKeyClass(LongWritable.class);    job.setOutputValueClass(BytesWritable.class);    SequenceFileInputFormat.addInputPaths(job, inputPaths);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    SequenceFileOutputFormat.setOutputPath(job, jobOutputPath);    return job;}
public static long metron_f6967_0(long start, long end, int numReducers)
{    return Long.divideUnsigned(end - start, numReducers) + 1;}
protected Iterable<Path> metron_f6968_0(FileSystem fs, Path basePath) throws IOException
{    List<Path> ret = new ArrayList<>();    RemoteIterator<LocatedFileStatus> filesIt = fs.listFiles(basePath, true);    while (filesIt.hasNext()) {        ret.add(filesIt.next().getPath());    }    return ret;}
public JobType metron_f6969_0()
{    return JobType.MAP_REDUCE;}
public synchronized JobStatus metron_f6970_0() throws JobException
{    return new JobStatus(jobStatus);}
protected void metron_f6971_0(JobStatus jobStatus)
{    this.jobStatus = jobStatus;}
protected void metron_f6972_0(Job mrJob)
{    this.mrJob = mrJob;}
public Pageable<Path> metron_f6973_1() throws JobException, InterruptedException
{    if (PcapOptions.PRINT_JOB_STATUS.getOrDefault(configuration, Boolean.class, false) && mrJob != null) {        try {            mrJob.monitorAndPrintJob();        } catch (IOException e) {            throw new JobException("Could not monitor job status", e);        }    }    for (; ; ) {        JobStatus status = getStatus();        if (status.getState() == State.SUCCEEDED || status.getState() == State.KILLED || status.getState() == State.FAILED) {            return getFinalResults();        } else {                    }        Thread.sleep(completeCheckInterval);    }}
private synchronized Pageable<Path> metron_f6974_0()
{    return new PcapPages(finalResults);}
public boolean metron_f6975_0()
{    State jobState = null;    synchronized (this) {        jobState = jobStatus.getState();    }    return (jobState == State.SUCCEEDED || jobState == State.KILLED || jobState == State.FAILED);}
public void metron_f6976_0() throws JobException
{    try {        synchronized (this) {            mrJob.killJob();        }    } catch (IOException e) {        throw new JobException("Unable to kill pcap job.", e);    }}
public boolean metron_f6977_0(Map<String, Object> configuration)
{        return true;}
public Map<String, Object> metron_f6978_0()
{    return new HashMap<>(this.configuration);}
protected void metron_f6979_0(Map<String, Object> configuration)
{    this.configuration = configuration;}
public GlobalHeader metron_f6980_0()
{    return globalHeader;}
public byte[] metron_f6981_0()
{    return packetBytes;}
public PacketHeader metron_f6982_0()
{    return packetHeader;}
public PcapPacket metron_f6983_0()
{    return packet;}
public Ipv4Packet metron_f6984_0()
{    return ipv4Packet;}
public TcpPacket metron_f6985_0()
{    return tcpPacket;}
public UdpPacket metron_f6986_0()
{    return udpPacket;}
public String metron_f6987_0()
{    int sourcePort = 0;    int destinationPort = 0;    if (Constants.PROTOCOL_UDP == ipv4Packet.getProtocol()) {        sourcePort = udpPacket.getSourcePort();        destinationPort = udpPacket.getDestinationPort();    } else if (Constants.PROTOCOL_TCP == ipv4Packet.getProtocol()) {        sourcePort = tcpPacket.getSourcePort();        destinationPort = tcpPacket.getDestinationPort();    }    return PcapUtils.getSessionKey(ipv4Packet.getSourceAddress().getHostAddress(), ipv4Packet.getDestinationAddress().getHostAddress(), ipv4Packet.getProtocol(), sourcePort, destinationPort, ipv4Packet.getId(), ipv4Packet.getFragmentOffset());}
public String metron_f6988_0()
{    int sourcePort = 0;    int destinationPort = 0;    if (Constants.PROTOCOL_UDP == ipv4Packet.getProtocol()) {        sourcePort = udpPacket.getSourcePort();        destinationPort = udpPacket.getDestinationPort();    } else if (Constants.PROTOCOL_TCP == ipv4Packet.getProtocol()) {        sourcePort = tcpPacket.getSourcePort();        destinationPort = tcpPacket.getDestinationPort();    }    return PcapUtils.getShortSessionKey(ipv4Packet.getSourceAddress().getHostAddress(), ipv4Packet.getDestinationAddress().getHostAddress(), ipv4Packet.getProtocol(), sourcePort, destinationPort);}
public String metron_f6989_0()
{    return getJsonDocUsingSBAppend();}
public String metron_f6990_0()
{    return getJsonIndexDocUsingSBAppend();}
private String metron_f6991_0()
{    StringBuffer jsonSb = new StringBuffer(1024);        jsonSb.append("{\"global_header\":{\"pcap_id\":\"").append(getKey());    jsonSb.append("\",\"inc_len\":").append(packetHeader.getInclLen());    jsonSb.append(",\"orig_len\":").append(packetHeader.getOrigLen());    jsonSb.append(",\"ts_sec\":").append(packetHeader.getTsSec());    jsonSb.append(",\"ts_usec\":").append(packetHeader.getTsUsec());        jsonSb.append("},");        jsonSb.append("\"ipv4_header\":{");    jsonSb.append("\"ip_dst\":").append(ipv4Packet.getDestination());    jsonSb.append(",\"ip_dst_addr\":\"").append(ipv4Packet.getDestinationAddress().getHostAddress());    jsonSb.append("\",\"ip_flags\":").append(ipv4Packet.getFlags());    jsonSb.append(",\"ip_fragment_offset\":").append(ipv4Packet.getFragmentOffset());    jsonSb.append(",\"ip_header_checksum\":").append(ipv4Packet.getHeaderChecksum());    jsonSb.append(",\"ip_id\":").append(ipv4Packet.getId());    jsonSb.append(",\"ip_header_length\":").append(ipv4Packet.getIhl());    jsonSb.append(",\"ip_protocol\":").append(ipv4Packet.getProtocol());    jsonSb.append(",\"ip_src\":").append(ipv4Packet.getSource());    jsonSb.append(",\"ip_src_addr\":\"").append(ipv4Packet.getSourceAddress().getHostAddress());    jsonSb.append("\",\"ip_tos\":").append(ipv4Packet.getTos());    jsonSb.append(",\"ip_total_length\":").append(ipv4Packet.getTotalLength());    jsonSb.append(",\"ip_ttl\":").append(ipv4Packet.getTtl());    jsonSb.append(",\"ip_version\":").append(ipv4Packet.getVersion());    jsonSb.append('}');        if (tcpPacket != null) {        jsonSb.append(",\"tcp_header\":{\"ack\":").append(tcpPacket.getAck());        jsonSb.append(",\"checksum\":").append(tcpPacket.getChecksum());        jsonSb.append(",\"data_length\":").append(tcpPacket.getDataLength());        jsonSb.append(",\"data_offset\":").append(tcpPacket.getDataOffset());        jsonSb.append(",\"dst_addr\":\"").append(tcpPacket.getDestinationAddress().getHostAddress());        jsonSb.append("\",\"dst_port\":").append(tcpPacket.getDestinationPort());        jsonSb.append(",\"direction\":").append(tcpPacket.getDirection());        jsonSb.append(",\"flags\":").append(tcpPacket.getFlags());        jsonSb.append(",\"reassembled_length \":").append(tcpPacket.getReassembledLength());        jsonSb.append(",\"relative_ack\":").append(tcpPacket.getRelativeAck());        jsonSb.append(",\"relative_seq\":").append(tcpPacket.getRelativeSeq());        jsonSb.append(",\"seq\":").append(tcpPacket.getSeq());        jsonSb.append(",\"session_key\":\"").append(tcpPacket.getSessionKey());        jsonSb.append("\",\"src_addr\":\"").append(tcpPacket.getSourceAddress().getHostAddress());        jsonSb.append("\",\"src_port\":").append(tcpPacket.getSourcePort());        jsonSb.append(",\"total_length\":").append(tcpPacket.getTotalLength());        jsonSb.append(",\"urgent_pointer\":").append(tcpPacket.getUrgentPointer());        jsonSb.append(",\"window\":").append(tcpPacket.getWindow());        jsonSb.append('}');    }        if (udpPacket != null) {        jsonSb.append(",\"udp_header\":{\"checksum\":").append(udpPacket.getChecksum());        jsonSb.append(",\"dst_port\":").append(udpPacket.getDestinationPort());        jsonSb.append(",\"length\":").append(udpPacket.getLength());        jsonSb.append(",\"src_port\":").append(udpPacket.getSourcePort());        jsonSb.append(",\"dst_addr\":\"").append(udpPacket.getDestination().getAddress().getHostAddress());        jsonSb.append("\",\"src_addr\":\"").append(udpPacket.getSource().getAddress().getHostAddress());        jsonSb.append("\"}");    }    jsonSb.append('}');    return jsonSb.toString();}
private String metron_f6992_0()
{    StringBuffer jsonSb = new StringBuffer(600);    jsonSb.append(MessageFormat.format(globalHeaderJsonTemplateString, getKey(), packetHeader.getInclLen(), packetHeader.getOrigLen(), packetHeader.getTsSec(), packetHeader.getTsUsec()));    jsonSb.append(MessageFormat.format(ipv4HeaderJsonTemplateString, ipv4Packet.getDestination(), ipv4Packet.getDestinationAddress().getHostAddress(), ipv4Packet.getFlags(), ipv4Packet.getFragmentOffset(), ipv4Packet.getHeaderChecksum(), ipv4Packet.getId(), ipv4Packet.getIhl(), ipv4Packet.getProtocol(), ipv4Packet.getSource(), ipv4Packet.getSourceAddress().getHostAddress(), ipv4Packet.getTos(), ipv4Packet.getTotalLength(), ipv4Packet.getTtl(), ipv4Packet.getVersion()));        if (tcpPacket != null) {        jsonSb.append(MessageFormat.format(tcpHeaderJsonTemplateString, tcpPacket.getAck(), tcpPacket.getChecksum(), tcpPacket.getDataLength(), tcpPacket.getDataOffset(), tcpPacket.getDestinationAddress().getHostAddress(), tcpPacket.getDestinationPort(), tcpPacket.getDirection(), tcpPacket.getFlags(), tcpPacket.getReassembledLength(), tcpPacket.getRelativeAck(), tcpPacket.getRelativeSeq(), tcpPacket.getSeq(), tcpPacket.getSessionKey(), tcpPacket.getSourceAddress().getHostAddress(), tcpPacket.getSourcePort(), tcpPacket.getTotalLength(), tcpPacket.getUrgentPointer(), tcpPacket.getWindow()));    } else     if (udpPacket != null) {        jsonSb.append(MessageFormat.format(udpHeaderJsonTemplateString, udpPacket.getChecksum(), udpPacket.getDestinationPort(), udpPacket.getLength(), udpPacket.getSourcePort(), udpPacket.getDestination().getAddress().getHostAddress(), udpPacket.getSource().getAddress().getHostAddress()));    } else {        jsonSb.append('}');    }    return jsonSb.toString().replace('<', '{').replace('>', '}');}
private String metron_f6993_0()
{    Long ts_micro = getPacketTimeInNanos() / 1000L;    StringBuffer jsonSb = new StringBuffer(175);    jsonSb.append("{\"pcap_id\":\"").append(getShortKey());    jsonSb.append("\",\"ip_protocol\":").append(ipv4Packet.getProtocol());    jsonSb.append(",\"ip_id\":").append(ipv4Packet.getId());    jsonSb.append(",\"frag_offset\":").append(ipv4Packet.getFragmentOffset());    jsonSb.append(",\"ts_micro\":").append(ts_micro);        if (tcpPacket != null) {        jsonSb.append(",\"ip_src_addr\":\"").append(tcpPacket.getSourceAddress().getHostAddress());        jsonSb.append("\",\"ip_src_port\":").append(tcpPacket.getSourcePort());        jsonSb.append(",\"ip_dst_addr\":\"").append(tcpPacket.getDestinationAddress().getHostAddress());        jsonSb.append("\",\"ip_dst_port\":").append(tcpPacket.getDestinationPort());    }        if (udpPacket != null) {        jsonSb.append(",\"ip_src_addr\":\"").append(udpPacket.getSource().getAddress().getHostAddress());        jsonSb.append("\",\"ip_src_port\":").append(udpPacket.getSourcePort());        jsonSb.append(",\"ip_dst_addr\":\"").append(udpPacket.getDestination().getAddress().getHostAddress());        jsonSb.append("\",\"ip_dst_port\":").append(udpPacket.getDestinationPort());    }    jsonSb.append('}');    return jsonSb.toString();}
public long metron_f6994_1()
{    if (getGlobalHeader().getMagicNumber() == 0xa1b2c3d4 || getGlobalHeader().getMagicNumber() == 0xd4c3b2a1) {                        return getPacketHeader().getTsSec() * 1000000000L + getPacketHeader().getTsUsec() * 1000L;    } else if (getGlobalHeader().getMagicNumber() == 0xa1b23c4d || getGlobalHeader().getMagicNumber() == 0x4d3cb2a1) {                        return getPacketHeader().getTsSec() * 1000000000L + getPacketHeader().getTsUsec();    }            return getPacketHeader().getTsSec() * 1000000000L + getPacketHeader().getTsUsec() * 1000L;}
public Object metron_f6995_0(List<Object> args, Context context) throws ParseException
{    if (args.size() != 2) {        return new IllegalStateException("Expected 2 arguments: regex and data");    }    String regex = (String) args.get(0);    byte[] data = (byte[]) args.get(1);    try {        return ByteArrayMatchingUtil.INSTANCE.match(regex, data);    } catch (ExecutionException e) {        throw new IllegalStateException("Unable to process " + regex + " against " + DatatypeConverter.printHexBinary(data));    }}
public boolean metron_f6997_0()
{    return true;}
public Searcher<SequenceMatcher> metron_f6998_0(String pattern) throws Exception
{    return new HorspoolFinalFlagSearcher(compile(pattern));}
private SequenceMatcher metron_f6999_0(String pattern) throws CompileException
{    return compiler.compile(pattern);}
public boolean metron_f7000_0(String pattern, byte[] data) throws ExecutionException
{    if (pattern == null) {        return false;    }    Searcher<SequenceMatcher> searcher = sequenceMatchers.get(pattern);    if (data == null) {        return false;    } else {        return !searcher.searchForwards(data).isEmpty();    }}
public PcapPacket metron_f7001_0() throws IOException
{    return readPacket(globalHeader.getMagicNumber());}
public GlobalHeader metron_f7002_0()
{    return globalHeader;}
private void metron_f7003_0() throws IOException
{    int magic = is.readInt();    short major = is.readShort();    short minor = is.readShort();    int tz = is.readInt();    int sigfigs = is.readInt();    int snaplen = is.readInt();    int network = is.readInt();    globalHeader = new GlobalHeader(magic, major, minor, tz, sigfigs, snaplen, network);    if (globalHeader.getMagicNumber() == 0xD4C3B2A1) {        globalHeader.swapByteOrder();    }}
private PcapPacket metron_f7004_0(int magicNumber) throws IOException
{    PacketHeader packetHeader = readPacketHeader(magicNumber);    Buffer packetData = readPacketData(packetHeader.getInclLen());    return new PcapPacket(packetHeader, packetData);}
private PacketHeader metron_f7005_0(int magicNumber) throws IOException
{    int tsSec = is.readInt();    int tsUsec = is.readInt();    int inclLen = is.readInt();    int origLen = is.readInt();    if (magicNumber == 0xD4C3B2A1) {        tsSec = ByteOrderConverter.swap(tsSec);        tsUsec = ByteOrderConverter.swap(tsUsec);        inclLen = ByteOrderConverter.swap(inclLen);        origLen = ByteOrderConverter.swap(origLen);    }    return new PacketHeader(tsSec, tsUsec, inclLen, origLen);}
private Buffer metron_f7006_0(int packetLength) throws IOException
{    byte[] packets = new byte[packetLength];    is.read(packets);    Buffer payload = new ChainBuffer();    payload.addLast(packets);    return payload;}
public void metron_f7007_0() throws IOException
{        is.close();}
private void metron_f7008_0()
{    /* magic number(swapped) */    list.add((byte) 0xd4);    list.add((byte) 0xc3);    list.add((byte) 0xb2);    list.add((byte) 0xa1);    /* major version number */    list.add((byte) 0x02);    list.add((byte) 0x00);    /* minor version number */    list.add((byte) 0x04);    list.add((byte) 0x00);    /* GMT to local correction */    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    /* accuracy of timestamps */    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);    /* max length of captured packets, in octets */    list.add((byte) 0xff);    list.add((byte) 0xff);    list.add((byte) 0x00);    list.add((byte) 0x00);    /* data link type(ethernet) */    list.add((byte) 0x01);    list.add((byte) 0x00);    list.add((byte) 0x00);    list.add((byte) 0x00);}
private void metron_f7009_0(GlobalHeader header)
{    final byte[] magicNumber = intToByteArray(header.getMagicNumber());    final byte[] majorVersion = shortToByteArray(header.getMajorVersion());    final byte[] minorVersion = shortToByteArray(header.getMinorVersion());    final byte[] zone = intToByteArray(header.getThiszone());    final byte[] sigFigs = intToByteArray(header.getSigfigs());    final byte[] snapLen = intToByteArray(header.getSnaplen());    final byte[] network = intToByteArray(header.getNetwork());    list.add(magicNumber[0]);    list.add(magicNumber[1]);    list.add(magicNumber[2]);    list.add(magicNumber[3]);    list.add(majorVersion[1]);    list.add(majorVersion[0]);    list.add(minorVersion[1]);    list.add(minorVersion[0]);    list.add(zone[3]);    list.add(zone[2]);    list.add(zone[1]);    list.add(zone[0]);    list.add(sigFigs[3]);    list.add(sigFigs[2]);    list.add(sigFigs[1]);    list.add(sigFigs[0]);    list.add(snapLen[3]);    list.add(snapLen[2]);    list.add(snapLen[1]);    list.add(snapLen[0]);    list.add(network[3]);    list.add(network[2]);    list.add(network[1]);    list.add(network[0]);}
public void metron_f7010_0(PcapPacket packet) throws IOException
{    PacketHeader packetHeader = packet.getPacketHeader();    int tsSec = packetHeader.getTsSec();    int tsUsec = packetHeader.getTsUsec();    int inclLen = packetHeader.getInclLen();    int origLen = packetHeader.getOrigLen();    addInt(tsSec);    addInt(tsUsec);    addInt(inclLen);    addInt(origLen);    Buffer payload = packet.getPacketData();    try {        payload.mark();        while (true) {            list.add(payload.get());        }    } catch (BufferUnderflowException e) {                payload.reset();    }    cachedPacketNum++;    if (cachedPacketNum == MAX_CACHED_PACKET_NUMBER) {        flush();    }}
private void metron_f7011_0(int number)
{    list.add((byte) (number & 0xff));    list.add((byte) ((number & 0xff00) >> 8));    list.add((byte) ((number & 0xff0000) >> 16));    list.add((byte) ((number & 0xff000000) >> 24));}
private byte[] metron_f7012_0(int number)
{    return new byte[] { (byte) (number >>> 24), (byte) (number >>> 16), (byte) (number >>> 8), (byte) number };}
private byte[] metron_f7013_0(short number)
{    return new byte[] { (byte) (number >>> 8), (byte) number };}
public void metron_f7014_0() throws IOException
{    byte[] fileBinary = new byte[list.size()];    for (int i = 0; i < fileBinary.length; i++) {        fileBinary[i] = list.get(i);    }    list.clear();    baos.write(fileBinary);    cachedPacketNum = 0;}
public void metron_f7015_0() throws IOException
{    flush();        baos.close();}
public static String metron_f7016_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    return String.join("_", Arrays.copyOfRange(tokens, 0, tokens.length - 3));}
private static String metron_f7017_0(String s)
{    return s.substring(PREFIX.length());}
public static Long metron_f7018_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    try {        return Long.parseUnsignedLong(tokens[tokens.length - 3]);    } catch (NumberFormatException e) {        return null;    }}
public static Integer metron_f7019_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    try {        return Integer.parseInt(tokens[tokens.length - 2]);    } catch (NumberFormatException e) {        return null;    }}
public static String metron_f7020_0(String pcapFilename)
{    String[] tokens = stripPrefix(pcapFilename).split("_");    return tokens[tokens.length - 1];}
public String metron_f7021_0()
{    return name;}
protected MetronEthernetDecoder metron_f7022_0()
{    return createDecoder();}
public static String metron_f7023_0(String topic, long timestamp, String partition, String uuid)
{    return Joiner.on("_").join("pcap", topic, Long.toUnsignedString(timestamp), partition, uuid);}
public static boolean metron_f7024_0(org.apache.metron.spout.pcap.Endianness endianness)
{    return endianness == org.apache.metron.spout.pcap.Endianness.LITTLE;}
public static byte[] metron_f7025_0(Endianness endianness)
{    if (swapBytes(endianness)) {                return new byte[] {         (byte) 0xd4,         (byte) 0xc3,         (byte) 0xb2,         (byte) 0xa1,         0x02,         0x00,         0x04,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         (byte) 0xff,         (byte) 0xff,         0x00,         0x00,         0x01,         0x00,         0x00,         0x00 };    } else {                return new byte[] {         (byte) 0xa1,         (byte) 0xb2,         (byte) 0xc3,         (byte) 0xd4,         0x00,         0x02,         0x00,         0x04,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         0x00,         (byte) 0xff,         (byte) 0xff,         0x00,         0x00,         0x00,         0x01 };    }}
public static Long metron_f7026_0(byte[] pcap)
{    return getTimestamp(pcap, 0, pcap.length);}
public static Long metron_f7027_1(byte[] pcap, int offset, int length)
{    PcapByteInputStream pcapByteInputStream = null;    try {        pcapByteInputStream = new PcapByteInputStream(pcap, offset, length);        PcapPacket packet = pcapByteInputStream.getPacket();        GlobalHeader globalHeader = pcapByteInputStream.getGlobalHeader();        PacketHeader packetHeader = packet.getPacketHeader();        if (globalHeader.getMagicNumber() == 0xa1b2c3d4 || globalHeader.getMagicNumber() == 0xd4c3b2a1) {                                    return packetHeader.getTsSec() * 1000000000L + packetHeader.getTsUsec() * 1000L;        } else if (globalHeader.getMagicNumber() == 0xa1b23c4d || globalHeader.getMagicNumber() == 0x4d3cb2a1) {                                    return packetHeader.getTsSec() * 1000000000L + packetHeader.getTsUsec();        }                        return packetHeader.getTsSec() * 1000000000L + packetHeader.getTsUsec() * 1000L;    } catch (IOException ioe) {                    } finally {        if (pcapByteInputStream != null) {            try {                pcapByteInputStream.close();            } catch (IOException e) {                            }        }    }    return null;}
public static byte[] metron_f7028_0(long tsNano, byte[] packet, Endianness endianness)
{    byte[] ret = new byte[GLOBAL_HEADER_SIZE + PACKET_HEADER_SIZE + packet.length];    byte[] globalHeader = getPcapGlobalHeader(endianness);    int offset = 0;    System.arraycopy(globalHeader, 0, ret, offset, GLOBAL_HEADER_SIZE);    offset += globalHeader.length;    {        boolean swapBytes = swapBytes(endianness);        long micros = Long.divideUnsigned(tsNano, 1000);        int secs = (int) (micros / 1000000);        int usec = (int) (micros % 1000000);        int capLen = packet.length;        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(secs) : secs);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(usec) : usec);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }        {            byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);            System.arraycopy(b, 0, ret, offset, Integer.BYTES);            offset += Integer.BYTES;        }    }    System.arraycopy(packet, 0, ret, offset, packet.length);    return ret;}
public static byte[] metron_f7029_0(byte[] packet, Endianness endianness)
{    byte[] globalHeader = getPcapGlobalHeader(endianness);    byte[] ret = new byte[packet.length + GLOBAL_HEADER_SIZE];    int offset = 0;    System.arraycopy(globalHeader, 0, ret, offset, GLOBAL_HEADER_SIZE);    offset += globalHeader.length;    System.arraycopy(packet, 0, ret, offset, packet.length);    return ret;}
public static byte[] metron_f7030_0(long tsNano, byte[] packet, Endianness endianness)
{    boolean swapBytes = swapBytes(endianness);    long micros = Long.divideUnsigned(tsNano, 1000);    int secs = (int) (micros / 1000000);    int usec = (int) (micros % 1000000);    int capLen = packet.length;    byte[] ret = new byte[PACKET_HEADER_SIZE + packet.length];    int offset = 0;    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(secs) : secs);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(usec) : usec);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    {        byte[] b = Bytes.toBytes(swapBytes ? ByteOrderConverter.swap(capLen) : capLen);        System.arraycopy(b, 0, ret, offset, Integer.BYTES);        offset += Integer.BYTES;    }    System.arraycopy(packet, 0, ret, offset, packet.length);    return ret;}
public static Map<String, Object> metron_f7031_0(PacketInfo pi)
{    Map<String, Object> ret = new HashMap<>();    ret.put(PacketFields.PACKET_DATA.getName(), pi.getPacketBytes());    if (pi.getTcpPacket() != null) {        if (pi.getTcpPacket().getSourceAddress() != null) {            ret.put(org.apache.metron.common.Constants.Fields.SRC_ADDR.getName(), pi.getTcpPacket().getSourceAddress().getHostAddress());        }        if (pi.getTcpPacket().getSource() != null) {            ret.put(org.apache.metron.common.Constants.Fields.SRC_PORT.getName(), pi.getTcpPacket().getSource().getPort());        }        if (pi.getTcpPacket().getDestinationAddress() != null) {            ret.put(org.apache.metron.common.Constants.Fields.DST_ADDR.getName(), pi.getTcpPacket().getDestinationAddress().getHostAddress());        }        if (pi.getTcpPacket().getDestination() != null) {            ret.put(org.apache.metron.common.Constants.Fields.DST_PORT.getName(), pi.getTcpPacket().getDestination().getPort());        }    }    if (pi.getUdpPacket() != null) {        if (pi.getUdpPacket().getSource() != null) {            if (pi.getUdpPacket().getSource().getAddress() != null) {                ret.put(org.apache.metron.common.Constants.Fields.SRC_ADDR.getName(), pi.getUdpPacket().getSource().getAddress().getHostAddress());            }            ret.put(org.apache.metron.common.Constants.Fields.SRC_PORT.getName(), pi.getUdpPacket().getSource().getPort());        }        if (pi.getUdpPacket().getDestination() != null) {            if (pi.getUdpPacket().getDestination().getAddress() != null) {                ret.put(org.apache.metron.common.Constants.Fields.DST_ADDR.getName(), pi.getUdpPacket().getDestination().getAddress().getHostAddress());            }            ret.put(org.apache.metron.common.Constants.Fields.DST_PORT.getName(), pi.getUdpPacket().getDestination().getPort());        }    }    if (pi.getIpv4Packet() != null) {        ret.put(org.apache.metron.common.Constants.Fields.PROTOCOL.getName(), pi.getIpv4Packet().getProtocol());    }    return ret;}
public static List<PacketInfo> metron_f7032_0(byte[] packet) throws IOException
{    return toPacketInfo(ETHERNET_DECODER.get(), packet);}
public static MetronEthernetDecoder metron_f7033_0()
{    MetronEthernetDecoder ethernetDecoder = new MetronEthernetDecoder();    IpDecoder ipDecoder = new IpDecoder();    ethernetDecoder.register(EthernetType.IPV4, ipDecoder);    return ethernetDecoder;}
public static List<PacketInfo> metron_f7034_1(MetronEthernetDecoder decoder, byte[] pcap) throws IOException
{    List<PacketInfo> packetInfoList = new ArrayList<>();    PcapByteInputStream pcapByteInputStream = new PcapByteInputStream(pcap);    GlobalHeader globalHeader = pcapByteInputStream.getGlobalHeader();    while (true) {        try {            PcapPacket packet = pcapByteInputStream.getPacket();                                                TcpPacket tcpPacket = null;            UdpPacket udpPacket = null;                        int sourcePort = 0;            int destinationPort = 0;                                    decoder.decode(packet);            PacketHeader packetHeader = packet.getPacketHeader();            Ipv4Packet ipv4Packet = Ipv4Packet.parse(packet.getPacketData());            if (ipv4Packet.getProtocol() == Constants.PROTOCOL_TCP) {                tcpPacket = TcpPacket.parse(ipv4Packet);            }            if (ipv4Packet.getProtocol() == Constants.PROTOCOL_UDP) {                Buffer packetDataBuffer = ipv4Packet.getData();                sourcePort = packetDataBuffer.getUnsignedShort();                destinationPort = packetDataBuffer.getUnsignedShort();                udpPacket = new UdpPacket(ipv4Packet, sourcePort, destinationPort);                udpPacket.setLength(packetDataBuffer.getUnsignedShort());                udpPacket.setChecksum(packetDataBuffer.getUnsignedShort());                packetDataBuffer.discardReadBytes();                udpPacket.setData(packetDataBuffer);            }            packetInfoList.add(new PacketInfo(globalHeader, packetHeader, packet, ipv4Packet, tcpPacket, udpPacket, pcap));        } catch (NegativeArraySizeException ignored) {                    } catch (EOFException eof) {                        break;        }    }    return packetInfoList;}
public static List<JSONObject> metron_f7035_0(List<PacketInfo> packetInfoList)
{    List<JSONObject> messages = new ArrayList<>();    for (PacketInfo packetInfo : packetInfoList) {        JSONObject message = (JSONObject) JSONValue.parse(packetInfo.getJsonIndexDoc());        messages.add(message);    }    return messages;}
public static boolean metron_f7036_0(long a, long b)
{    return Long.compareUnsigned(a, b) >= 0;}
public static boolean metron_f7037_0(long a, long b)
{    return Long.compareUnsigned(a, b) <= 0;}
public static void metron_f7038_0(ByteArrayOutputStream baos, List<byte[]> pcaps) throws IOException
{    PcapByteInputStream is = null;    PcapByteOutputStream os = null;    ByteArrayOutputStream unsortedBaos = new ByteArrayOutputStream();    try {        int i = 1;        for (byte[] pcap : pcaps) {            is = new PcapByteInputStream(pcap);            if (i == 1) {                os = new PcapByteOutputStream(unsortedBaos, is.getGlobalHeader());            }            writePacket(is, os);            i++;            closeInput(is);        }    } finally {        if (unsortedBaos != null) {            unsortedBaos.close();        }        closeOutput(os);        sort(baos, unsortedBaos.toByteArray());    }}
public static void metron_f7039_0(ByteArrayOutputStream baos, byte[]... pcaps) throws IOException
{    merge(baos, Arrays.asList(pcaps));}
private static void metron_f7040_1(ByteArrayOutputStream baos, byte[] unsortedBytes) throws IOException
{    PcapByteInputStream pcapIs = new PcapByteInputStream(unsortedBytes);    PcapByteOutputStream pcapOs = new PcapByteOutputStream(baos, pcapIs.getGlobalHeader());    PcapPacket packet;    ArrayList<PcapPacket> packetList = new ArrayList<PcapPacket>();    try {        while (true) {            packet = pcapIs.getPacket();            if (packet == null)                break;            packetList.add(packet);                    }    } catch (EOFException e) {        }    Collections.sort(packetList, PCAP_PACKET_COMPARATOR);    for (PcapPacket p : packetList) {        pcapOs.write(p);            }    pcapOs.close();}
private static void metron_f7041_0(PcapByteInputStream is, PcapByteOutputStream os) throws IOException
{    PcapPacket packet = null;    try {        while (true) {            packet = is.getPacket();            if (packet == null) {                break;            }            os.write(packet);        }    } catch (EOFException e) {        }}
private static void metron_f7042_1(PcapByteInputStream is)
{    if (is == null) {        return;    }    try {                is.close();    } catch (IOException e) {            }}
private static void metron_f7043_1(PcapByteOutputStream os)
{    if (os == null) {        return;    }    try {        os.close();    } catch (IOException e) {            }}
public static void metron_f7044_0(String[] args) throws IOException
{    byte[] b1 = FileUtils.readFileToByteArray(new File("/Users/sheetal/Downloads/constructedTcpDump.1.pcap"));    byte[] b2 = FileUtils.readFileToByteArray(new File("/Users/sheetal/Downloads/constructedTcpDump.2.pcap"));    byte[] b3 = FileUtils.readFileToByteArray(new File("/Users/sheetal/Downloads/constructedTcpDump.3.pcap"));        ByteArrayOutputStream boas = new ByteArrayOutputStream();        PcapMerger.merge(boas, b1, b2, b3);    FileUtils.writeByteArrayToFile(new File("/Users/sheetal/Downloads/constructedTcpDump.automerged.1.2.pcap"), boas.toByteArray(), false);}
public int metron_f7045_1(PcapPacket p1, PcapPacket p2)
{    long p1time = p1.getPacketHeader().getTsSec() * 1000000L + p1.getPacketHeader().getTsUsec();    long p2time = p2.getPacketHeader().getTsSec() * 1000000L + p2.getPacketHeader().getTsUsec();        return Long.compare(p1time, p2time);}
public Path metron_f7046_0(int num)
{    return files.get(num);}
public int metron_f7047_0()
{    return files.size();}
public Iterator<Path> metron_f7048_0()
{    return new PcapIterator(files.iterator());}
public boolean metron_f7049_0()
{    return delegateIt.hasNext();}
public Path metron_f7050_0()
{    return delegateIt.next();}
public static Iterable<String> metron_f7051_1(long beginTs, long endTs, Iterable<Path> files)
{    Map<Integer, List<Path>> filesByPartition = getFilesByPartition(files);    List<String> filteredFiles = filterByTimestampLT(beginTs, endTs, filesByPartition);        return filteredFiles;}
public static Map<Integer, List<Path>> metron_f7052_0(Iterable<Path> files)
{    Iterator<Path> filesIt = files.iterator();    Map<Integer, List<Path>> filesByPartition = new HashMap<>();    while (filesIt.hasNext()) {        Path p = filesIt.next();        Integer partition = PcapFilenameHelper.getKafkaPartition(p.getName());        if (!filesByPartition.containsKey(partition)) {            filesByPartition.put(partition, new ArrayList<>());        }        filesByPartition.get(partition).add(p);    }    return filesByPartition;}
public static List<String> metron_f7053_0(long beginTs, long endTs, Map<Integer, List<Path>> filesByPartition)
{    List<String> filteredFiles = new ArrayList<>();    for (Integer key : filesByPartition.keySet()) {        List<Path> paths = filesByPartition.get(key);        filteredFiles.addAll(filterByTimestampLT(beginTs, endTs, paths));    }    return filteredFiles;}
public static List<String> metron_f7054_0(long beginTs, long endTs, List<Path> paths)
{    List<String> filteredFiles = new ArrayList<>();        Collections.sort(paths);    Iterator<Path> filesIt = paths.iterator();    Path leftTrailing = filesIt.hasNext() ? filesIt.next() : null;    if (leftTrailing == null) {        return filteredFiles;    }    boolean first = true;    Long fileTS = PcapFilenameHelper.getTimestamp(leftTrailing.getName());    if (fileTS != null && greaterThanOrEqualTo(fileTS, beginTs) && lessThanOrEqualTo(fileTS, endTs)) {        filteredFiles.add(leftTrailing.toString());        first = false;    }    if (first && !filesIt.hasNext()) {        filteredFiles.add(leftTrailing.toString());        return filteredFiles;    }    while (filesIt.hasNext()) {        Path p = filesIt.next();        fileTS = PcapFilenameHelper.getTimestamp(p.getName());        if (fileTS != null && greaterThanOrEqualTo(fileTS, beginTs) && lessThanOrEqualTo(fileTS, endTs)) {            if (first) {                filteredFiles.add(leftTrailing.toString());                first = false;            }            filteredFiles.add(p.toString());        } else {            leftTrailing = p;        }    }    return filteredFiles;}
public static String metron_f7055_0(String ipAddress)
{    StringBuffer hexIp = new StringBuffer(64);    String[] ipSegments = ipAddress.split("\\.");    for (String ipSegment : ipSegments) {        hexIp.append(convertIpSegmentToHex(ipSegment));    }    return hexIp.toString();}
public static String metron_f7056_0(String hex)
{    List<Integer> ipSegments = new ArrayList<>();    for (int i = 0; i < hex.length(); i += 2) {        String segment = hex.substring(i, i + 2);        ipSegments.add(Integer.parseInt(segment, 16));    }    return Joiner.on(".").join(ipSegments);}
public static String metron_f7057_0(String srcIp, String dstIp, String protocol, String srcPort, String dstPort)
{    return getSessionKey(srcIp, dstIp, protocol, srcPort, dstPort, null, null);}
public static String metron_f7058_0(String srcIp, String dstIp, String protocol, String srcPort, String dstPort, String ipId, String fragmentOffset)
{    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(SESSION_KEY_SEPERATOR).append(convertIpv4IpToHex(dstIp)).append(SESSION_KEY_SEPERATOR).append(protocol == null ? "0" : protocol).append(SESSION_KEY_SEPERATOR).append(srcPort == null ? "0" : srcPort).append(SESSION_KEY_SEPERATOR).append(dstPort == null ? "0" : dstPort).append(SESSION_KEY_SEPERATOR).append(ipId == null ? "0" : ipId).append(SESSION_KEY_SEPERATOR).append(fragmentOffset == null ? "0" : fragmentOffset);    return sb.toString();}
public static String metron_f7059_0(JSONObject message)
{    String srcIp = (String) message.get("ip_src_addr");    String dstIp = (String) message.get("ip_dst_addr");    Long protocol = (Long) message.get("ip_protocol");    Long srcPort = (Long) message.get("ip_src_port");    Long dstPort = (Long) message.get("ip_dst_port");    Long ipId = (Long) message.get("ip_id");    String ipIdString = ipId == null ? null : ipId.toString();    Long fragmentOffset = (Long) message.get("frag_offset");    String fragmentOffsetString = fragmentOffset == null ? null : fragmentOffset.toString();    return PcapUtils.getSessionKey(srcIp, dstIp, protocol.toString(), srcPort.toString(), dstPort.toString(), ipIdString, fragmentOffsetString);}
public static String metron_f7060_0(String srcIp, String dstIp, String protocol, String srcPort, String dstPort)
{    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(SESSION_KEY_SEPERATOR).append(convertIpv4IpToHex(dstIp)).append(SESSION_KEY_SEPERATOR).append(protocol == null ? "0" : protocol).append(SESSION_KEY_SEPERATOR).append(srcPort == null ? "0" : srcPort).append(SESSION_KEY_SEPERATOR).append(dstPort == null ? "0" : dstPort);    return sb.toString();}
public static String metron_f7061_0(String srcIp, String dstIp, int protocol, int srcPort, int dstPort, int ipId, int fragmentOffset)
{    String keySeperator = "-";    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(keySeperator).append(convertIpv4IpToHex(dstIp)).append(keySeperator).append(protocol).append(keySeperator).append(srcPort).append(keySeperator).append(dstPort).append(keySeperator).append(ipId).append(keySeperator).append(fragmentOffset);    return sb.toString();}
public static String metron_f7062_0(String srcIp, String dstIp, int protocol, int srcPort, int dstPort)
{    String keySeperator = "-";    StringBuffer sb = new StringBuffer(40);    sb.append(convertIpv4IpToHex(srcIp)).append(keySeperator).append(convertIpv4IpToHex(dstIp)).append(keySeperator).append(protocol).append(keySeperator).append(srcPort).append(keySeperator).append(dstPort);    return sb.toString();}
public static String metron_f7063_0(String ipSegment)
{    return convertIpSegmentToHex(Integer.valueOf(ipSegment));}
public static String metron_f7064_0(int ipSegment)
{    return convertToHex(ipSegment, 2);}
public static String metron_f7065_0(int number, int length)
{    return StringUtils.leftPad(Integer.toHexString(number), length, '0');}
public static String metron_f7066_0(int protocolNumber)
{    String protocolName = protocolIdToNameMap.get(protocolNumber);    if (protocolName == null) {        protocolName = String.valueOf(protocolNumber);    }    return protocolName;}
public static int metron_f7067_0(String protocolName)
{    Integer protocolNumber = protocolNameToIdMap.get(protocolName.toUpperCase());    if (protocolNumber == null) {        protocolNumber = -1;    }    return protocolNumber;}
private static Map<V, K> metron_f7068_0(Map<K, V> map)
{    Map<V, K> inv = new HashMap<V, K>();    for (Entry<K, V> entry : map.entrySet()) inv.put(entry.getValue(), entry.getKey());    return inv;}
public void metron_f7069_0(Configuration config, List<byte[]> pcaps, String outPath) throws IOException
{    HDFSUtils.write(config, mergePcaps(pcaps), outPath);}
public void metron_f7070_0(List<byte[]> pcaps, String outPath) throws IOException
{    File out = new File(outPath);    try (FileOutputStream fos = new FileOutputStream(out)) {        fos.write(mergePcaps(pcaps));    }}
public byte[] metron_f7071_0(List<byte[]> pcaps) throws IOException
{    if (pcaps == null) {        return new byte[] {};    }    if (pcaps.size() == 1) {        return pcaps.get(0);    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PcapMerger.merge(baos, pcaps);    return baos.toByteArray();}
public static Endianness metron_f7072_0()
{    if (ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN)) {        return BIG;    } else {        return LITTLE;    }}
public void metron_f7073_0() throws Exception
{    final LinkedHashMap<String, String> fields = new LinkedHashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    String actual = new FixedPcapFilter.Configurator().queryToString(fields);    String expected = "src_ip_0_dst_ip_1_false";    Assert.assertThat("string representation did not match", actual, equalTo(expected));}
public void metron_f7074_0() throws Exception
{    {        final LinkedHashMap<String, String> fields = new LinkedHashMap<String, String>();        String actual = new FixedPcapFilter.Configurator().queryToString(fields);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        String actual = new FixedPcapFilter.Configurator().queryToString(null);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        final LinkedHashMap<String, String> fields = new LinkedHashMap<String, String>() {            {                put(Constants.Fields.SRC_ADDR.getName(), "");                put(Constants.Fields.SRC_PORT.getName(), "");            }        };        String actual = new FixedPcapFilter.Configurator().queryToString(fields);        String expected = "_";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }}
public void metron_f7075_0() throws Exception
{    Configuration config = new Configuration();    final Map<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected Map<String, Object> metron_f7076_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7077_0() throws Exception
{    Configuration config = new Configuration();    final Map<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "true");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");                        put(Constants.Fields.SRC_PORT.getName(), 1);                        put(Constants.Fields.DST_ADDR.getName(), "src_ip");                        put(Constants.Fields.DST_PORT.getName(), 0);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected Map<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "src_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected Map<String, Object> metron_f7078_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected Map<String, Object> metron_f7079_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");            put(Constants.Fields.SRC_PORT.getName(), 1);            put(Constants.Fields.DST_ADDR.getName(), "src_ip");            put(Constants.Fields.DST_PORT.getName(), 0);        }    };}
protected Map<String, Object> metron_f7080_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "dst_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "src_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7081_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip1");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7082_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7083_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip1");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7084_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7085_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7086_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
protected HashMap<String, Object> metron_f7087_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
public void metron_f7088_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_PORT.getName(), "0");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7089_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7090_0() throws Exception
{    Configuration config = new Configuration();    final HashMap<String, String> fields = new HashMap<String, String>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), "1");            put(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), "false");        }    };    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new FixedPcapFilter.Configurator().addToConfig(fields, config);    {        FixedPcapFilter filter = new FixedPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7091_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7092_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7093_0() throws Exception
{    Assert.assertThat("filter type should be Fixed", PcapFilters.FIXED.create(), instanceOf(FixedPcapFilter.class));    Assert.assertThat("filter type should be Query", PcapFilters.QUERY.create(), instanceOf(QueryPcapFilter.class));}
public void metron_f7094_0() throws Exception
{    String query = "ip_src_addr == 'srcIp' and ip_src_port == '80' and ip_dst_addr == 'dstIp' and ip_dst_port == '100' and protocol == 'protocol'";    String actual = new QueryPcapFilter.Configurator().queryToString(query);    String expected = "ip_src_addr_==_'srcIp'_and_ip_src_port_==_'80'_and_ip_dst_addr_==_'dstIp'_and_ip_dst_port_==_'100'_and_protocol_==_'protocol'";    Assert.assertThat("string representation did not match", actual, equalTo(expected));}
public void metron_f7095_0() throws Exception
{    {        String query = "";        String actual = new QueryPcapFilter.Configurator().queryToString(query);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        String query = " ";        String actual = new QueryPcapFilter.Configurator().queryToString(query);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }    {        String query = null;        String actual = new QueryPcapFilter.Configurator().queryToString(query);        String expected = "";        Assert.assertThat("string representation did not match", actual, equalTo(expected));    }}
public void metron_f7096_0() throws Exception
{    Configuration config = new Configuration();    String query = "";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        PcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7097_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7098_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_src_port == 0 and ip_dst_addr == 'dst_ip' and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        PcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7099_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7100_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_src_port == 0 and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip_no_match");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7101_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7102_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip_no_match");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7103_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_src_port == 0 and ip_dst_addr == 'dst_ip'";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 100);                    }                };            }        };        filter.configure(config);        Assert.assertFalse(filter.test(null));    }}
protected HashMap<String, Object> metron_f7104_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7105_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
protected HashMap<String, Object> metron_f7106_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 100);        }    };}
public void metron_f7107_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_port == 0 and ip_dst_addr == 'dst_ip' and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7108_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7109_0() throws Exception
{    Configuration config = new Configuration();    String query = "ip_src_addr == 'src_ip' and ip_dst_addr == 'dst_ip' and ip_dst_port == 1";    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 0);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }    new QueryPcapFilter.Configurator().addToConfig(query, config);    {        QueryPcapFilter filter = new QueryPcapFilter() {            @Override            protected HashMap<String, Object> packetToFields(PacketInfo pi) {                return new HashMap<String, Object>() {                    {                        put(Constants.Fields.SRC_ADDR.getName(), "src_ip");                        put(Constants.Fields.SRC_PORT.getName(), 100);                        put(Constants.Fields.DST_ADDR.getName(), "dst_ip");                        put(Constants.Fields.DST_PORT.getName(), 1);                    }                };            }        };        filter.configure(config);        Assert.assertTrue(filter.test(null));    }}
protected HashMap<String, Object> metron_f7110_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 0);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
protected HashMap<String, Object> metron_f7111_0(PacketInfo pi)
{    return new HashMap<String, Object>() {        {            put(Constants.Fields.SRC_ADDR.getName(), "src_ip");            put(Constants.Fields.SRC_PORT.getName(), 100);            put(Constants.Fields.DST_ADDR.getName(), "dst_ip");            put(Constants.Fields.DST_PORT.getName(), 1);        }    };}
public void metron_f7112_0()
{    filesIn = new ArrayList<>();    filesIn.add(new Path("/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910"));    filesIn.add(new Path("/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910"));}
public void metron_f7113_0()
{    Map<Integer, List<Path>> filesByPartition = FileFilterUtil.getFilesByPartition(filesIn);    Map<Integer, List<Path>> expectedFilesPartitioned = new HashMap() {        {            put(0, toList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910"));            put(1, toList("/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910"));            put(2, toList("/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910"));            put(3, toList("/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910"));            put(4, toList("/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910"));        }    };    assertThat(filesByPartition, equalTo(expectedFilesPartitioned));}
private List<Path> metron_f7114_0(String... items)
{    return Arrays.asList(items).stream().map(i -> new Path(i)).collect(Collectors.toList());}
public void metron_f7115_0()
{    Map<Integer, List<Path>> filesByPartition = new HashMap() {        {            put(0, toList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910"));            put(1, toList("/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910"));            put(2, toList("/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910"));            put(3, toList("/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910"));            put(4, toList("/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910"));        }    };    List<String> lt = FileFilterUtil.filterByTimestampLT(1495135377055375000L, 1495135512124943000L, filesByPartition);    List<String> expectedFiles = Arrays.asList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910");    assertThat(lt, equalTo(expectedFiles));}
public void metron_f7116_0()
{    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(1495135377055375000L, 1495135512124943000L, filesIn);    List<String> expectedFiles = Arrays.asList("/apath/pcap_pcap5_1495135377055375000_0_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372168719000_1_pcap-9-1495134910", "/apath/pcap_pcap5_1495135372055519000_2_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512123943000_3_pcap-9-1495134910", "/apath/pcap_pcap5_1495135512102506000_4_pcap-9-1495134910");    assertThat(paths, equalTo(expectedFiles));}
public void metron_f7117_0() throws Exception
{    final List<Path> inputFiles = new ArrayList<Path>();    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(0, 1000, inputFiles);    Assert.assertTrue(Iterables.isEmpty(paths));}
public void metron_f7118_0() throws Exception
{    final long firstFileTSNanos = 1461589332993573000L;    final long secondFileTSNanos = 1561589332993573000L;    final List<Path> inputFiles = new ArrayList<Path>() {        {            add(new Path("/apps/metron/pcap/pcap_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            add(new Path("/apps/metron/pcap/pcap_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));        }    };    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(0, secondFileTSNanos - 1L, inputFiles);    Assert.assertEquals(1, Iterables.size(paths));}
public void metron_f7119_0() throws Exception
{    final long firstFileTSNanos = 1461589332993573000L;    final long secondFileTSNanos = 1461589333993573000L;    final long thirdFileTSNanos = 1461589334993573000L;    {        final List<Path> inputFiles = new ArrayList<Path>() {            {                add(new Path("/apps/metron/pcap/pcap0_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));                add(new Path("/apps/metron/pcap/pcap1_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            }        };        Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(secondFileTSNanos - 1L, secondFileTSNanos + 1L, inputFiles);        Assert.assertEquals(2, Iterables.size(paths));    }    {        final List<Path> inputFiles = new ArrayList<Path>() {            {                add(new Path("/apps/metron/pcap/pcap0_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));                add(new Path("/apps/metron/pcap/pcap1_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));                add(new Path("/apps/metron/pcap/pcap1_pcap_" + thirdFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            }        };        Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(thirdFileTSNanos - 1L, thirdFileTSNanos + 1L, inputFiles);        Assert.assertEquals(2, Iterables.size(paths));    }}
public void metron_f7120_0() throws Exception
{    final long firstFileTSNanos = 1461589332993573000L;    final long secondFileTSNanos = 1461589333993573000L;    final long thirdFileTSNanos = 1461589334993573000L;    final List<Path> inputFiles = new ArrayList<Path>() {        {            add(new Path("/apps/metron/pcap/pcap_pcap_" + firstFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            add(new Path("/apps/metron/pcap/pcap_pcap_" + secondFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));            add(new Path("/apps/metron/pcap/pcap1_pcap_" + thirdFileTSNanos + "_0_73686171-64a1-46e5-9e67-66cf603fb094"));        }    };    Iterable<String> paths = FileFilterUtil.getPathsInTimeRange(0, thirdFileTSNanos + 1L, inputFiles);    Assert.assertEquals(3, Iterables.size(paths));}
public void metron_f7121_0() throws Exception
{    long beginNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    long endNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    String query = "ip_dst_addr == '207.28.210.1' and protocol == 'PROTOCOL: ICMP(1)";    String queryFilterString = new QueryPcapFilter.Configurator().queryToString(query);    OutputDirFormatter formatter = new OutputDirFormatter();    String actual = formatter.format(beginNS, endNS, queryFilterString);    assertThat("Formatted directory names did not match.", actual, containsString("_ip_dst_addr_==_207-28-210-1_and_protocol_==_PROTOCOL_ICMP(1)_"));        new Path(actual);}
public void metron_f7122_0() throws Exception
{    long beginNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    long endNS = TimestampConverters.MILLISECONDS.toNanoseconds(System.currentTimeMillis());    Map<String, String> fields = new HashMap<>();    fields.put("ip_src_address", "207.28.210.1");    fields.put("protocol", "PROTOCOL: ICMP(1)");    String fixedFilterString = new FixedPcapFilter.Configurator().queryToString(fields);    OutputDirFormatter formatter = new OutputDirFormatter();    String actual = formatter.format(beginNS, endNS, fixedFilterString);    assertThat("Formatted directory names did not match.", actual, containsString("PROTOCOL_ICMP(1)_207-28-210-1"));        new Path(actual);}
public void metron_f7123_0() throws IOException
{    MockitoAnnotations.initMocks(this);    basePath = new Path("basepath");    baseOutPath = new Path("outpath");    startTime = 100;    endTime = 200;    numReducers = 5;    numRecordsPerFile = 5;    fixedFields = new HashMap<>();    fixedFields.put("ip_src_addr", "192.168.1.1");    hadoopConfig = new Configuration();    fileSystem = FileSystem.get(hadoopConfig);    finalOutputPath = new Path("finaloutpath");    when(jobId.toString()).thenReturn(jobIdVal);    when(mrStatus.getJobID()).thenReturn(jobId);    when(mrJob.getJobID()).thenReturn(jobId);    pageableResult = new PcapPages();    timer = new TestTimer();        config = new FixedPcapConfig(clock -> "clockprefix");    PcapOptions.HADOOP_CONF.put(config, hadoopConfig);    PcapOptions.FILESYSTEM.put(config, FileSystem.get(hadoopConfig));    PcapOptions.BASE_PATH.put(config, basePath);    PcapOptions.BASE_INTERIM_RESULT_PATH.put(config, baseOutPath);    PcapOptions.START_TIME_NS.put(config, startTime);    PcapOptions.END_TIME_NS.put(config, endTime);    PcapOptions.NUM_REDUCERS.put(config, numReducers);    PcapOptions.FIELDS.put(config, fixedFields);    PcapOptions.FILTER_IMPL.put(config, new FixedPcapFilter.Configurator());    PcapOptions.NUM_RECORDS_PER_FILE.put(config, numRecordsPerFile);    PcapOptions.FINAL_OUTPUT_PATH.put(config, finalOutputPath);    testJob = new TestJob<>(mrJob);    testJob.setStatusInterval(1);    testJob.setCompleteCheckInterval(1);    testJob.setTimer(timer);}
public Job metron_f7124_0(Optional<String> jobName, Path basePath, Path outputPath, long beginNS, long endNS, int numReducers, T fields, Configuration conf, FileSystem fs, PcapFilterConfigurator<T> filterImpl) throws IOException
{    return mrJob;}
public void metron_f7125_0(TimerTask task, long delay, long period)
{    this.task = task;}
public void metron_f7126_0()
{    task.run();}
public void metron_f7127_0() throws Exception
{    long start = 1473897600000000000L;    long end = TimestampConverters.MILLISECONDS.toNanoseconds(1473995927455L);    Configuration conf = new Configuration();    conf.set(PcapJob.START_TS_CONF, toUnsignedString(start));    conf.set(PcapJob.END_TS_CONF, toUnsignedString(end));    conf.set(PcapJob.WIDTH_CONF, "" + PcapJob.findWidth(start, end, 10));    PcapJob.PcapPartitioner partitioner = new PcapJob.PcapPartitioner();    partitioner.setConf(conf);    Assert.assertThat("Partition not in range", partitioner.getPartition(new LongWritable(1473978789181189000L), new BytesWritable(), 10), equalTo(8));}
public void metron_f7128_0() throws Exception
{    pageableResult = new PcapPages(Arrays.asList(new Path("1.txt"), new Path("2.txt"), new Path("3.txt")));    when(finalizer.finalizeJob(any())).thenReturn(pageableResult);    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    Assert.assertThat(results.getSize(), equalTo(3));    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.SUCCEEDED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(status.getJobId(), equalTo(jobIdVal));}
public void metron_f7129_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.FAILED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.FAILED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(results.getSize(), equalTo(0));}
public void metron_f7130_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.KILLED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.KILLED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(results.getSize(), equalTo(0));}
public void metron_f7131_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.SUCCEEDED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));}
public void metron_f7132_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(false);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.RUNNING);    when(mrJob.getStatus()).thenReturn(mrStatus);    when(mrJob.mapProgress()).thenReturn(0.5f);    when(mrJob.reduceProgress()).thenReturn(0f);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.RUNNING));    Assert.assertThat(status.getDescription(), equalTo("map: 50.0%, reduce: 0.0%"));    Assert.assertThat(status.getPercentComplete(), equalTo(25.0 * 0.75));    when(mrJob.mapProgress()).thenReturn(1.0f);    when(mrJob.reduceProgress()).thenReturn(0.5f);    timer.updateJobStatus();    status = statusable.getStatus();    Assert.assertThat(status.getDescription(), equalTo("map: 100.0%, reduce: 50.0%"));    Assert.assertThat(status.getPercentComplete(), equalTo(75.0 * 0.75));    when(mrJob.mapProgress()).thenReturn(1.0f);    when(mrJob.reduceProgress()).thenReturn(1.0f);    timer.updateJobStatus();    status = statusable.getStatus();    Assert.assertThat(status.getDescription(), equalTo("map: 100.0%, reduce: 100.0%"));    Assert.assertThat(status.getPercentComplete(), equalTo(75.0));    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.mapProgress()).thenReturn(1.0f);    when(mrJob.reduceProgress()).thenReturn(1.0f);    timer.updateJobStatus();    status = statusable.getStatus();    Assert.assertThat(status.getDescription(), equalTo("Job completed."));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));}
public void metron_f7133_0() throws Exception
{    when(mrJob.isComplete()).thenReturn(false);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.RUNNING);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    statusable.kill();    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.KILLED);    timer.updateJobStatus();    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.KILLED));}
public void metron_f7134_0() throws Exception
{    PcapOptions.START_TIME_NS.put(config, null);    PcapOptions.END_TIME_NS.put(config, null);    PcapOptions.NUM_REDUCERS.put(config, null);    PcapOptions.NUM_RECORDS_PER_FILE.put(config, null);    pageableResult = new PcapPages(Arrays.asList(new Path("1.txt"), new Path("2.txt"), new Path("3.txt")));    when(finalizer.finalizeJob(any())).thenReturn(pageableResult);    when(mrJob.isComplete()).thenReturn(true);    when(mrStatus.getState()).thenReturn(org.apache.hadoop.mapreduce.JobStatus.State.SUCCEEDED);    when(mrJob.getStatus()).thenReturn(mrStatus);    Statusable<Path> statusable = testJob.submit(finalizer, config);    timer.updateJobStatus();    Pageable<Path> results = statusable.get();    Assert.assertThat(results.getSize(), equalTo(3));    JobStatus status = statusable.getStatus();    Assert.assertThat(status.getState(), equalTo(State.SUCCEEDED));    Assert.assertThat(status.getPercentComplete(), equalTo(100.0));    Assert.assertThat(status.getJobId(), equalTo(jobIdVal));}
public void metron_f7135_0() throws Exception
{    Map<String, Object> configuration = new HashMap<>();    testJob.setConfiguration(configuration);    testJob.setMrJob(mrJob);    testJob.setJobStatus(new JobStatus().withState(State.SUCCEEDED));    testJob.get();    verify(mrJob, times(0)).monitorAndPrintJob();    PcapOptions.PRINT_JOB_STATUS.put(configuration, true);    testJob.get();    verify(mrJob, times(1)).monitorAndPrintJob();    verifyNoMoreInteractions(mrJob);}
public boolean metron_f7136_0(String pattern, byte[] data)
{    return evaluator.evaluate(pattern, data);}
public static Collection<Object[]> metron_f7137_0()
{    List<Object[]> strategies = new ArrayList<>();    for (EvaluationStrategy s : EvaluationStrategy.values()) {        strategies.add(new Object[] { s });    }    return strategies;}
public void metron_f7138_0() throws ExecutionException
{    Assert.assertTrue(strategy.evaluate("`metron`", "metron".getBytes(StandardCharsets.UTF_8)));    Assert.assertTrue(strategy.evaluate("`metron`", "metron example".getBytes(StandardCharsets.UTF_8)));    Assert.assertTrue(strategy.evaluate("`metron`", "edward metron example".getBytes(StandardCharsets.UTF_8)));    Assert.assertFalse(strategy.evaluate("`metron`", "apache".getBytes(StandardCharsets.UTF_8)));}
public void metron_f7139_0() throws ExecutionException
{    Assert.assertTrue(strategy.evaluate("2f56abd814bc56420489ca38e7faf8cec3d4", REALPACKET));    Assert.assertTrue(strategy.evaluate("2f56..14bc56420489ca38e7faf8cec3d4", REALPACKET));    Assert.assertTrue(strategy.evaluate("(2f56)(.){2}(14bc56420489ca38e7faf8cec3d4)", REALPACKET));    Assert.assertFalse(strategy.evaluate("(3f56)(.){2}(14bc56420489ca38e7faf8cec3d4)", REALPACKET));    Assert.assertFalse(strategy.evaluate("3f56abd814bc56420489ca38e7faf8cec3d4", REALPACKET));    Assert.assertTrue(strategy.evaluate("deadbeef", join(DEADBEEF, "metron".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef", join(DEADBEEF, "metron".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef `metron`", join(DEADBEEF, "metron".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef `metron`", join(DEADBEEF, "metronjones".getBytes(StandardCharsets.UTF_8))));    Assert.assertTrue(strategy.evaluate("deadbeef `metron`", join(DEADBEEF, "metronjones".getBytes(StandardCharsets.UTF_8), DEADBEEF)));    Assert.assertTrue(strategy.evaluate("([ff]){4}", ALLFS));    Assert.assertFalse(strategy.evaluate("([ff]){6}", ALLFS));    Assert.assertTrue(strategy.evaluate("[^ff]", new byte[] { (byte) 0x00 }));    Assert.assertTrue(strategy.evaluate("&01", new byte[] { (byte) 0x07 }));    Assert.assertFalse(strategy.evaluate("&01", new byte[] { (byte) 0x00 }));    Assert.assertTrue(strategy.evaluate("&01", new byte[] { (byte) 0x00, (byte) 0x01 }));    Assert.assertTrue(strategy.evaluate("(dead).{2}(beef)", DEADBEEF_DONUTHOLE));}
public byte[] metron_f7140_0(byte[]... array)
{    byte[] ret;    int size = 0;    for (int i = 0; i < array.length; ++i) {        size += array[i].length;    }    ret = new byte[size];    int j = 0;    for (int i = 0; i < array.length; ++i) {        for (int k = 0; k < array[i].length; ++k, ++j) {            ret[j] = array[i][k];        }    }    return ret;}
public void metron_f7141_0()
{    {        String pcapFilename = "pcap_pcap128_1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap128"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));        assertThat(PcapFilenameHelper.getKafkaPartition(pcapFilename), equalTo(18));        assertThat(PcapFilenameHelper.getUUID(pcapFilename), equalTo("pcap-63-1495027314"));    }    {        String pcapFilename = "pcap_pcap-128_1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap-128"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }    {        String pcapFilename = "pcap_pcap_128_1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap_128"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }    {        String pcapFilename = "pcap_pcap___128___1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("pcap___128__"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }    {        String pcapFilename = "pcap___pcap___128___1494962815457986000_18_pcap-63-1495027314";        assertThat(PcapFilenameHelper.getKafkaTopic(pcapFilename), equalTo("__pcap___128__"));        assertThat(Long.compareUnsigned(PcapFilenameHelper.getTimestamp(pcapFilename), 1494962815457986000L), equalTo(0));    }}
public void metron_f7142_0()
{    String pcapFilename = "pcap_pcap128_AAA4962815457986000_BB_pcap-63-1495027314";    assertThat(PcapFilenameHelper.getTimestamp(pcapFilename), equalTo(null));    assertThat(PcapFilenameHelper.getKafkaPartition(pcapFilename), equalTo(null));}
public static List<byte[]> metron_f7143_0(String pcapLoc) throws IOException
{    SequenceFile.Reader reader = new SequenceFile.Reader(new Configuration(), SequenceFile.Reader.file(new Path(pcapLoc)));    List<byte[]> ret = new ArrayList<>();    IntWritable key = new IntWritable();    BytesWritable value = new BytesWritable();    while (reader.next(key, value)) {        byte[] pcapWithHeader = value.copyBytes();        ret.add(pcapWithHeader);    }    return ret;}
public static byte[] metron_f7144_0(byte[] pcap)
{    byte[] ret = new byte[pcap.length - PcapHelper.GLOBAL_HEADER_SIZE - PcapHelper.PACKET_HEADER_SIZE];    int offset = PcapHelper.GLOBAL_HEADER_SIZE + PcapHelper.PACKET_HEADER_SIZE;    System.arraycopy(pcap, offset, ret, 0, ret.length);    return ret;}
public void metron_f7145_0() throws Exception
{    String pcapSampleFiles = "../metron-integration-test/src/main/sample/data/SampleInput/PCAPExampleOutput";    List<byte[]> pcaps = readSamplePackets(pcapSampleFiles);    for (byte[] pcap : pcaps) {        long ts = PcapHelper.getTimestamp(pcap);        byte[] stripped = stripHeaders(pcap);        byte[] reconstitutedPacket = PcapHelper.addGlobalHeader(PcapHelper.addPacketHeader(ts, stripped, Endianness.getNativeEndianness()), Endianness.getNativeEndianness());        if (!Arrays.equals(reconstitutedPacket, pcap)) {            int eSecs = Bytes.toInt(pcap, 25);            int rSec = Bytes.toInt(reconstitutedPacket, 25);            System.out.println(eSecs + " vs " + rSec);            for (int i = 0; i < reconstitutedPacket.length; ++i) {                System.out.println((i + 1) + ". " + String.format("%02X", pcap[i]) + " = " + String.format("%02X", reconstitutedPacket[i]));            }            Assert.assertArrayEquals(reconstitutedPacket, pcap);        }    }}
public void metron_f7146_0() throws Exception
{    PacketInfo packetInfo = mock(PacketInfo.class);    when(packetInfo.getPacketBytes()).thenReturn("packet bytes".getBytes(StandardCharsets.UTF_8));    TcpPacket tcpPacket = mock(TcpPacket.class);        InetAddress tcpSourceInetAddress = mock(InetAddress.class);    when(tcpSourceInetAddress.getHostAddress()).thenReturn("tcp source address");    when(tcpPacket.getSourceAddress()).thenReturn(tcpSourceInetAddress);    InetSocketAddress tcpSourceInetSocketAddress = new InetSocketAddress(22);    when(tcpPacket.getSource()).thenReturn(tcpSourceInetSocketAddress);        InetAddress tcpDestinationInetAddress = mock(InetAddress.class);    when(tcpDestinationInetAddress.getHostAddress()).thenReturn("tcp destination address");    when(tcpPacket.getDestinationAddress()).thenReturn(tcpDestinationInetAddress);    InetSocketAddress tcpDestinationInetSocketAddress = new InetSocketAddress(55791);    when(tcpPacket.getDestination()).thenReturn(tcpDestinationInetSocketAddress);    when(packetInfo.getTcpPacket()).thenReturn(tcpPacket);    Ipv4Packet ipv4Packet = mock(Ipv4Packet.class);    when(ipv4Packet.getProtocol()).thenReturn(6);    when(packetInfo.getIpv4Packet()).thenReturn(ipv4Packet);    Map<String, Object> actualFields = PcapHelper.packetToFields(packetInfo);    Assert.assertArrayEquals("packet bytes".getBytes(StandardCharsets.UTF_8), (byte[]) actualFields.get(PcapHelper.PacketFields.PACKET_DATA.getName()));    Assert.assertEquals("tcp source address", actualFields.get(Fields.SRC_ADDR.getName()));    Assert.assertEquals(22, actualFields.get(Fields.SRC_PORT.getName()));    Assert.assertEquals("tcp destination address", actualFields.get(Fields.DST_ADDR.getName()));    Assert.assertEquals(55791, actualFields.get(Fields.DST_PORT.getName()));    Assert.assertEquals(6, actualFields.get(Fields.PROTOCOL.getName()));}
public void metron_f7147_0() throws Exception
{    PacketInfo packetInfo = mock(PacketInfo.class);    when(packetInfo.getPacketBytes()).thenReturn("packet bytes".getBytes(StandardCharsets.UTF_8));    UdpPacket udpPacket = mock(UdpPacket.class);        InetAddress udpSourceInetAddress = mock(InetAddress.class);    when(udpSourceInetAddress.getHostAddress()).thenReturn("udp source address");    InetSocketAddress udpSourceInetSocketAddress = new InetSocketAddress(udpSourceInetAddress, 68);    when(udpPacket.getSource()).thenReturn(udpSourceInetSocketAddress);        InetAddress udpDestinationInetAddress = mock(InetAddress.class);    when(udpDestinationInetAddress.getHostAddress()).thenReturn("udp destination address");    InetSocketAddress udpDestinationInetSocketAddress = new InetSocketAddress(udpDestinationInetAddress, 67);    when(udpPacket.getDestination()).thenReturn(udpDestinationInetSocketAddress);    when(packetInfo.getUdpPacket()).thenReturn(udpPacket);    Ipv4Packet ipv4Packet = mock(Ipv4Packet.class);    when(ipv4Packet.getProtocol()).thenReturn(17);    when(packetInfo.getIpv4Packet()).thenReturn(ipv4Packet);    Map<String, Object> actualFields = PcapHelper.packetToFields(packetInfo);    Assert.assertArrayEquals("packet bytes".getBytes(StandardCharsets.UTF_8), (byte[]) actualFields.get(PcapHelper.PacketFields.PACKET_DATA.getName()));    Assert.assertEquals("udp source address", actualFields.get(Fields.SRC_ADDR.getName()));    Assert.assertEquals(68, actualFields.get(Fields.SRC_PORT.getName()));    Assert.assertEquals("udp destination address", actualFields.get(Fields.DST_ADDR.getName()));    Assert.assertEquals(67, actualFields.get(Fields.DST_PORT.getName()));    Assert.assertEquals(17, actualFields.get(Fields.PROTOCOL.getName()));}
public void metron_f7148_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket packet = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket packet2 = new PcapPacket(ph2, EMPTY_PAYLOAD);    assertEquals("Timestamps should be equal", comp.compare(packet, packet2), 0);    assertEquals("Timestamps should be equal", comp.compare(packet2, packet), 0);}
public void metron_f7149_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_PLUS_ONE_SECOND_SECONDS, 0, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7150_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_SECONDS, 1, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7151_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_PLUS_ONE_SECOND_SECONDS, 1, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7152_0() throws ParseException
{    PacketHeader ph = new PacketHeader((int) JULY_26_SECONDS, 0, 0, 0);    PcapPacket earlier = new PcapPacket(ph, EMPTY_PAYLOAD);    PacketHeader ph2 = new PacketHeader((int) JULY_26_PLUS_TWENTY_YEARS_SECONDS, 999999, 0, 0);    PcapPacket later = new PcapPacket(ph2, EMPTY_PAYLOAD);    PcapPacketComparator comp = new PcapPacketComparator();    assertTrue("Earlier should be less than later", comp.compare(earlier, later) < 0);    assertTrue("Later should be greater than earlier", comp.compare(later, earlier) > 0);}
public void metron_f7153_0()
{    Path path1 = new Path("/1.txt");    Path path2 = new Path("/2.txt");    Path path3 = new Path("/3.txt");    List<Path> paths = new ArrayList<>();    paths.add(path1);    paths.add(path2);    paths.add(path3);    PcapPages pages = new PcapPages(paths);    assertThat("Wrong num pages.", pages.getSize(), equalTo(3));    for (int i = 0; i < pages.getSize(); i++) {        assertThat("Page should be equal", pages.getPage(i).toString(), equalTo(paths.get(i).toString()));    }}
public void metron_f7154_0()
{    Path path1 = new Path("/1.txt");    Path path2 = new Path("/2.txt");    Path path3 = new Path("/3.txt");    List<Path> paths = new ArrayList<>();    paths.add(path1);    paths.add(path2);    paths.add(path3);    PcapPages pages = new PcapPages(paths);    PcapPages clonedPages = new PcapPages(pages);    assertThat(clonedPages, notNullValue());    assertThat(clonedPages.getSize(), equalTo(3));    assertThat(clonedPages, not(sameInstance(pages)));    for (int i = 0; i < pages.getSize(); i++) {        assertThat("Page should be different instance.", pages.getPage(i), not(sameInstance(clonedPages.getPage(i))));        assertThat("Page should be same path.", pages.getPage(i), equalTo(clonedPages.getPage(i)));    }}
public void metron_f7155_0()
{    String hex = "c0a88a9e";    String ipAddress = PcapUtils.convertHexToIpv4Ip(hex);    Assert.assertEquals("192.168.138.158", ipAddress);}
public Options metron_f7156_0()
{    Options options = new Options();    options.addOption(newOption("h", "help", false, "Display help"));    options.addOption(newOption("bp", "base_path", true, String.format("Base PCAP data path. Default is '%s'", BASE_INPUT_PATH_DEFAULT)));    options.addOption(newOption("bop", "base_output_path", true, String.format("Query result output path. Default is '%s'", BASE_INTERIM_RESULT_PATH_DEFAULT)));    options.addOption(newOption("st", "start_time", true, "(required) Packet start time range.", true));    options.addOption(newOption("nr", "num_reducers", true, String.format("Number of reducers to use (defaults to %s)", NUM_REDUCERS_DEFAULT)));    options.addOption(newOption("rpf", "records_per_file", true, String.format("Number of records to include in each output pcap file (defaults to %s)", NUM_RECORDS_PER_FILE_DEFAULT)));    options.addOption(newOption("et", "end_time", true, "Packet end time range. Default is current system time."));    options.addOption(newOption("df", "date_format", true, "Date format to use for parsing start_time and end_time. Default is to use time in millis since the epoch."));    options.addOption(newOption("yq", "yarn_queue", true, "Yarn queue this job will be submitted to"));    options.addOption(newOption("ft", "finalizer_threads", true, "Number of threads to use for the final output writing."));    return options;}
protected Option metron_f7157_0(String opt, String longOpt, boolean hasArg, String desc)
{    return newOption(opt, longOpt, hasArg, desc, false);}
protected Option metron_f7158_0(String opt, String longOpt, boolean hasArg, String desc, boolean required)
{    Option option = new Option(opt, longOpt, hasArg, desc);    option.setRequired(required);    return option;}
public void metron_f7159_0(CommandLine commandLine, PcapConfig config) throws java.text.ParseException
{    if (commandLine.hasOption("help")) {        config.setShowHelp(true);    }    if (commandLine.hasOption("date_format")) {        config.setDateFormat(commandLine.getOptionValue("date_format"));    }    if (commandLine.hasOption("base_path")) {        config.setBasePath(commandLine.getOptionValue("base_path"));    } else {        config.setBasePath(BASE_INPUT_PATH_DEFAULT);    }    if (commandLine.hasOption("base_output_path")) {        config.setBaseInterimResultPath(commandLine.getOptionValue("base_output_path"));    } else {        config.setBaseInterimResultPath(BASE_INTERIM_RESULT_PATH_DEFAULT);    }    if (commandLine.hasOption("start_time")) {        try {            if (commandLine.hasOption("date_format")) {                long startTime = config.getDateFormat().parse(commandLine.getOptionValue("start_time")).getTime();                config.setStartTimeMs(startTime);            } else {                long startTime = Long.parseLong(commandLine.getOptionValue("start_time"));                config.setStartTimeMs(startTime);            }        } catch (NumberFormatException nfe) {                }    }    if (commandLine.hasOption("num_reducers")) {        int numReducers = Integer.parseInt(commandLine.getOptionValue("num_reducers"));        config.setNumReducers(numReducers);    } else {        config.setNumReducers(NUM_REDUCERS_DEFAULT);    }    if (commandLine.hasOption("records_per_file")) {        int numRecordsPerFile = Integer.parseInt(commandLine.getOptionValue("records_per_file"));        config.setNumRecordsPerFile(numRecordsPerFile);    } else {        config.setNumRecordsPerFile(NUM_RECORDS_PER_FILE_DEFAULT);    }    if (commandLine.hasOption("end_time")) {        try {            if (commandLine.hasOption("date_format")) {                long endTime = config.getDateFormat().parse(commandLine.getOptionValue("end_time")).getTime();                config.setEndTimeMs(endTime);            } else {                long endTime = Long.parseLong(commandLine.getOptionValue("end_time"));                config.setEndTimeMs(endTime);            }        } catch (NumberFormatException nfe) {                }    }    if (commandLine.hasOption("yarn_queue")) {        config.setYarnQueue(commandLine.getOptionValue("yarn_queue"));    }    if (commandLine.hasOption("finalizer_threads")) {        String numThreads = commandLine.getOptionValue("finalizer_threads");        config.setFinalizerThreadpoolSize(numThreads);    } else {        config.setFinalizerThreadpoolSize(NUM_FINALIZER_THREADS_DEFAULT);    }}
public void metron_f7160_0(String msg, Options opts)
{    new HelpFormatter().printHelp(msg, opts);}
protected CommandLineParser metron_f7161_0()
{    return parser;}
private Options metron_f7162_0()
{    Options options = buildOptions();    options.addOption(newOption("sa", "ip_src_addr", true, "Source IP address"));    options.addOption(newOption("da", "ip_dst_addr", true, "Destination IP address"));    options.addOption(newOption("sp", "ip_src_port", true, "Source port"));    options.addOption(newOption("dp", "ip_dst_port", true, "Destination port"));    options.addOption(newOption("p", "protocol", true, "IP Protocol"));    options.addOption(newOption("pf", "packet_filter", true, "Packet Filter regex"));    options.addOption(newOption("pre", "prefix", true, "Result file prefix to use"));    options.addOption(newOption("ir", "include_reverse", false, "Indicates if filter should check swapped src/dest addresses and IPs"));    return options;}
public FixedPcapConfig metron_f7163_0(String[] args) throws ParseException, java.text.ParseException
{    CommandLine commandLine = getParser().parse(fixedOptions, args);    FixedPcapConfig config = new FixedPcapConfig(prefixStrategy);    super.parse(commandLine, config);    config.putFixedField(Constants.Fields.SRC_ADDR.getName(), commandLine.getOptionValue("ip_src_addr"));    config.putFixedField(Constants.Fields.DST_ADDR.getName(), commandLine.getOptionValue("ip_dst_addr"));    config.putFixedField(Constants.Fields.SRC_PORT.getName(), commandLine.getOptionValue("ip_src_port"));    config.putFixedField(Constants.Fields.DST_PORT.getName(), commandLine.getOptionValue("ip_dst_port"));    config.putFixedField(Constants.Fields.PROTOCOL.getName(), commandLine.getOptionValue("protocol"));    config.putFixedField(Constants.Fields.INCLUDES_REVERSE_TRAFFIC.getName(), Boolean.toString(commandLine.hasOption("include_reverse")));    config.putFixedField(PcapHelper.PacketFields.PACKET_FILTER.getName(), commandLine.getOptionValue("packet_filter"));    if (commandLine.hasOption("prefix")) {        config.setFinalFilenamePrefix(commandLine.getOptionValue("prefix"));    }    return config;}
public void metron_f7164_0()
{    super.printHelp("Fixed filter options", fixedOptions);}
public static void metron_f7165_0(String[] args)
{    int status = new PcapCli(new PcapJob(), PREFIX_STRATEGY).run(args);    System.exit(status);}
public int metron_f7166_1(String[] args)
{    if (args.length < 1) {        printBasicHelp();        return -1;    }    String jobType = args[0];    String[] commandArgs = Arrays.copyOfRange(args, 1, args.length);    Configuration hadoopConf = new Configuration();    String[] otherArgs = null;    try {        otherArgs = new GenericOptionsParser(hadoopConf, commandArgs).getRemainingArgs();    } catch (IOException e) {                return -1;    }    PcapConfig commonConfig = null;    Pageable<Path> results;        String execDir = System.getProperty("user.dir");    if ("fixed".equals(jobType)) {        FixedCliParser fixedParser = new FixedCliParser(prefixStrategy);        FixedPcapConfig config = null;        try {            config = fixedParser.parse(otherArgs);            commonConfig = config;            PcapOptions.FINAL_OUTPUT_PATH.put(commonConfig, new Path(execDir));        } catch (ParseException | java.text.ParseException e) {            System.err.println(e.getMessage());            System.err.flush();            fixedParser.printHelp();            return -1;        }        if (config.showHelp()) {            fixedParser.printHelp();            return 0;        }        PcapOptions.FILTER_IMPL.put(commonConfig, new FixedPcapFilter.Configurator());        config.getYarnQueue().ifPresent(s -> hadoopConf.set(MRJobConfig.QUEUE_NAME, s));        PcapOptions.HADOOP_CONF.put(commonConfig, hadoopConf);        try {            PcapOptions.FILESYSTEM.put(commonConfig, FileSystem.get(hadoopConf));            results = jobRunner.submit(PcapFinalizerStrategies.CLI, commonConfig).get();        } catch (IOException | InterruptedException | JobException e) {                        return -1;        }    } else if ("query".equals(jobType)) {        QueryCliParser queryParser = new QueryCliParser(prefixStrategy);        QueryPcapConfig config = null;        try {            config = queryParser.parse(otherArgs);            commonConfig = config;            PcapOptions.FINAL_OUTPUT_PATH.put(commonConfig, new Path(execDir));        } catch (ParseException | java.text.ParseException e) {            System.err.println(e.getMessage());            queryParser.printHelp();            return -1;        }        if (config.showHelp()) {            queryParser.printHelp();            return 0;        }        PcapOptions.FILTER_IMPL.put(commonConfig, new FixedPcapFilter.Configurator());        config.getYarnQueue().ifPresent(s -> hadoopConf.set(MRJobConfig.QUEUE_NAME, s));        PcapOptions.HADOOP_CONF.put(commonConfig, hadoopConf);        try {            PcapOptions.FILESYSTEM.put(commonConfig, FileSystem.get(hadoopConf));            results = jobRunner.submit(PcapFinalizerStrategies.CLI, commonConfig).get();        } catch (IOException | InterruptedException | JobException e) {                        return -1;        }    } else {        printBasicHelp();        return -1;    }    return 0;}
private Pair<Long, Long> metron_f7167_0(long start, long end)
{    long revisedStart = start;    if (revisedStart < 0) {        revisedStart = 0L;    }    long revisedEnd = end;    if (revisedEnd < 0) {        revisedEnd = System.currentTimeMillis();    }        revisedStart = TimestampConverters.MILLISECONDS.toNanoseconds(revisedStart);    revisedEnd = TimestampConverters.MILLISECONDS.toNanoseconds(revisedEnd);    return Pair.of(revisedStart, revisedEnd);}
public void metron_f7168_0()
{    System.out.println("Usage: [fixed|query]");}
private Options metron_f7169_0()
{    Options options = buildOptions();    options.addOption(newOption("q", "query", true, "Query string to use as a filter"));    options.addOption(newOption("pre", "prefix", true, "Result file prefix to use"));    return options;}
public QueryPcapConfig metron_f7170_0(String[] args) throws ParseException, java.text.ParseException
{    CommandLine commandLine = getParser().parse(queryOptions, args);    QueryPcapConfig config = new QueryPcapConfig(prefixStrategy);    super.parse(commandLine, config);    if (commandLine.hasOption("query")) {        config.setQuery(commandLine.getOptionValue("query"));    }    if (commandLine.hasOption("prefix")) {        config.setFinalFilenamePrefix(commandLine.getOptionValue("prefix"));    }    return config;}
public void metron_f7171_0()
{    super.printHelp("Query filter options", queryOptions);}
public static KeyValueDeserializer metron_f7172_0(String scheme, TimestampConverter converter)
{    try {        Deserializers ts = Deserializers.valueOf(scheme.toUpperCase());        return ts.creator.apply(converter);    } catch (IllegalArgumentException iae) {        return Deserializers.FROM_KEY.creator.apply(converter);    }}
public static KeyValueDeserializer metron_f7173_0(String scheme, String converter)
{    return create(scheme, TimestampConverters.getConverter(converter));}
public Result metron_f7174_0(byte[] key, byte[] value)
{    if (key == null) {        throw new IllegalArgumentException("Expected a key but none provided");    }    long ts = converter.toNanoseconds(fromBytes(key));    return new Result(ts, PcapHelper.addHeaders(ts, value, endianness), true);}
private static long metron_f7175_0(byte[] data)
{    long value = 0L;    int len = data.length;    for (int i = 0; i < len; ++i) {        byte b = data[i];                value <<= 8;                value |= (long) (b & 255);    }    return value;}
public Result metron_f7176_0(byte[] key, byte[] value)
{    Long ts = PcapHelper.getTimestamp(value);    if (ts != null) {        return new Result(ts, value, true);    } else {        return new Result(ts, value, false);    }}
public boolean metron_f7177_0(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Partition partition1 = (Partition) o;    if (partition != partition1.partition)        return false;    return topic != null ? topic.equals(partition1.topic) : partition1.topic == null;}
public int metron_f7178_0()
{    int result = topic != null ? topic.hashCode() : 0;    result = 31 * result + partition;    return result;}
public String metron_f7179_0()
{    return "Partition{" + "topic='" + topic + '\'' + ", partition=" + partition + '}';}
public HDFSWriterCallback metron_f7180_1(HDFSWriterConfig config)
{        this.config = config;    return this;}
public List<Object> metron_f7181_1(List<Object> tuple, EmitContext context)
{    byte[] key = (byte[]) tuple.get(0);    byte[] value = (byte[]) tuple.get(1);    long tsDeserializeStart = System.nanoTime();    KeyValueDeserializer.Result result = config.getDeserializer().deserializeKeyValue(key, value);    long tsDeserializeEnd = System.nanoTime();    if (LOG.isDebugEnabled() && !result.foundTimestamp) {        List<String> debugStatements = new ArrayList<>();        if (key != null) {            debugStatements.add("Key length: " + key.length);            debugStatements.add("Key: " + DatatypeConverter.printHexBinary(key));        } else {            debugStatements.add("Key is null!");        }        if (value != null) {            debugStatements.add("Value length: " + value.length);            debugStatements.add("Value: " + DatatypeConverter.printHexBinary(value));        } else {            debugStatements.add("Value is null!");        }            }    long tsWriteStart = System.nanoTime();    try {        getWriter(new Partition(topic, context.get(EmitContext.Type.PARTITION))).handle(result.key, result.value);    } catch (IOException e) {                }    long tsWriteEnd = System.nanoTime();    if (LOG.isDebugEnabled() && (Math.random() < 0.001 || !inited)) {                    }    inited = true;    return tuple;}
private PartitionHDFSWriter metron_f7182_0(Partition partition)
{        if (lastWriter != null && lastWriter.getTopic().equals(partition.topic) && lastWriter.getPartition() == partition.partition) {        return lastWriter;    }    lastWriter = writers.get(partition);    if (lastWriter == null) {        lastWriter = new PartitionHDFSWriter(partition.topic, partition.partition, context.get(EmitContext.Type.UUID), config);        writers.put(partition, lastWriter);    }    return lastWriter;}
public void metron_f7183_0(EmitContext context)
{    this.context = context;    KafkaSpoutConfig spoutConfig = context.get(EmitContext.Type.SPOUT_CONFIG);    if (spoutConfig != null && spoutConfig.getSubscription() != null) {        this.topic = spoutConfig.getSubscription().getTopicsString();        if (this.topic.length() > 0) {            int len = this.topic.length();            if (this.topic.charAt(0) == '[' && this.topic.charAt(len - 1) == ']') {                this.topic = this.topic.substring(1, len - 1);            }        }    } else {        throw new IllegalStateException("Unable to initialize, because spout config is not correctly specified");    }}
public void metron_f7184_0() throws Exception
{    for (PartitionHDFSWriter writer : writers.values()) {        writer.close();    }}
public HDFSWriterConfig metron_f7185_0(String deserializer, String timestampConverter)
{    this.deserializer = Deserializers.create(deserializer, timestampConverter);    return this;}
public HDFSWriterConfig metron_f7186_0(String path)
{    outputPath = path;    return this;}
public HDFSWriterConfig metron_f7187_0(long n)
{    numPackets = n;    return this;}
public HDFSWriterConfig metron_f7188_0(int n)
{    syncEvery = n;    return this;}
public HDFSWriterConfig metron_f7189_0(Map<String, Object> config)
{    hdfsConfig = config;    return this;}
public HDFSWriterConfig metron_f7190_0(int n)
{    replicationFactor = n;    return this;}
public HDFSWriterConfig metron_f7191_0(long t)
{    maxTimeNS = TimestampConverters.MILLISECONDS.toNanoseconds(t);    return this;}
public HDFSWriterConfig metron_f7192_0(String zookeeperQuorum)
{    this.zookeeperQuorum = zookeeperQuorum;    return this;}
public List<String> metron_f7193_0()
{    List<String> out = new ArrayList<>();    if (zookeeperQuorum != null) {        for (String hostPort : Splitter.on(',').split(zookeeperQuorum)) {            Iterable<String> tokens = Splitter.on(':').split(hostPort);            String host = Iterables.getFirst(tokens, null);            if (host != null) {                out.add(host);            }        }    }    return out;}
public Map<String, Object> metron_f7194_0()
{    return hdfsConfig;}
public Integer metron_f7195_0()
{    if (zookeeperQuorum != null) {        String hostPort = Iterables.getFirst(Splitter.on(',').split(zookeeperQuorum), null);        String portStr = Iterables.getLast(Splitter.on(':').split(hostPort));        return Integer.parseInt(portStr);    }    return null;}
public int metron_f7196_0()
{    return syncEvery;}
public int metron_f7197_0()
{    return replicationFactor;}
public KeyValueDeserializer metron_f7198_0()
{    return deserializer;}
public String metron_f7199_0()
{    return outputPath;}
public long metron_f7200_0()
{    return numPackets;}
public long metron_f7201_0()
{    return maxTimeNS;}
public String metron_f7202_0()
{    return "HDFSWriterConfig{" + "numPackets=" + numPackets + ", maxTimeNS=" + maxTimeNS + ", outputPath='" + outputPath + '\'' + '}';}
protected List<Object> metron_f7203_0()
{    return new ArrayList<>();}
protected Callback metron_f7204_0(Class<? extends Callback> callbackClass)
{    return new HDFSWriterCallback().withConfig(config);}
private void metron_f7205_0()
{    for (Object messageId : messagesToBeAcked.get()) {        super.ack(messageId);    }    messagesToBeAcked.get().clear();}
public void metron_f7206_0()
{    /*    This bears some explanation; nextTuple for a spout-only topology sans ackers, will ack as part of the emit method.    The unfortunate part about this is that this will prevent the internal bookeeping of the KafkaSpout to keep add the     message ID to the offsets to commit.  This is because it thinks it is not emitted by the time it gets to ack (because     ack is called *within* emit).  The result is that no offsets are acked.     What we have here is a correction.  The ack method will add the message ID to a queue to be acked and then at the end     of nextTuple, we will clear the cache and ack.  The net result is that the contract is adhered to for spout-only topologies,     ack happens in nextTuple().     */    super.nextTuple();    clearMessagesToBeAcked();}
public void metron_f7207_0(Object messageId)
{    messagesToBeAcked.get().add(messageId);}
public void metron_f7208_0()
{    try {        clearMessagesToBeAcked();    } finally {        super.close();    }}
private SyncHandler metron_f7209_0()
{    return func;}
public void metron_f7210_1(FSDataOutputStream input)
{    try {        func.sync(input);    } catch (IOException ioe) {            }}
public void metron_f7211_0(FSDataOutputStream outputStream) throws IOException
{    outputStream.hflush();    outputStream.hsync();}
public void metron_f7212_0(FSDataOutputStream outputStream) throws IOException
{    outputStream.hflush();    outputStream.hsync();    ((HdfsDataOutputStream) outputStream).hsync(EnumSet.of(HdfsDataOutputStream.SyncFlag.UPDATE_LENGTH));}
public void metron_f7213_0(FSDataOutputStream outputStream) throws IOException
{    outputStream.getWrappedStream().flush();    outputStream.getWrappedStream();}
public String metron_f7214_0(long ts)
{    return Long.toUnsignedString(ts);}
public void metron_f7215_1(long ts, byte[] value) throws IOException
{    turnoverIfNecessary(ts);    BytesWritable bw = new BytesWritable(value);    try {        writer.append(new LongWritable(ts), bw);    } catch (ArrayIndexOutOfBoundsException aioobe) {            }    numWritten++;    if (numWritten % config.getSyncEvery() == 0) {        syncHandler.sync(outputStream);    }}
public String metron_f7216_0()
{    return topic;}
public int metron_f7217_0()
{    return partition;}
public void metron_f7218_0() throws IOException
{    if (writer != null) {        writer.close();    }    if (outputStream != null) {        outputStream.close();    }}
private Path metron_f7219_0(long ts)
{    String fileName = PcapHelper.toFilename(topic, ts, partition + "", uuid);    return new Path(config.getOutputPath(), fileName);}
private void metron_f7220_0(long ts) throws IOException
{    turnoverIfNecessary(ts, false);}
private void metron_f7221_1(long ts, boolean force) throws IOException
{    long duration = ts - batchStartTime;    boolean initial = outputStream == null;    boolean overDuration = config.getMaxTimeNS() <= 0 ? false : Long.compareUnsigned(duration, config.getMaxTimeNS()) >= 0;    boolean tooManyPackets = numWritten >= config.getNumPackets();    if (force || initial || overDuration || tooManyPackets) {                Path path = getPath(ts);        close();        if (fs instanceof LocalFileSystem) {            outputStream = new FSDataOutputStream(new FileOutputStream(new File(path.toString())));            syncHandler = SyncHandlers.LOCAL.getHandler();        } else {            outputStream = fs.create(path, true);            if (outputStream instanceof HdfsDataOutputStream) {                if (initial) {                                    }                syncHandler = SyncHandlers.HDFS.getHandler();            } else {                if (initial) {                                    }                syncHandler = SyncHandlers.DEFAULT.getHandler();            }        }        writer = SequenceFile.createWriter(this.fsConfig, SequenceFile.Writer.keyClass(LongWritable.class), SequenceFile.Writer.valueClass(BytesWritable.class), SequenceFile.Writer.stream(outputStream), SequenceFile.Writer.compression(SequenceFile.CompressionType.NONE));                        batchStartTime = ts;        numWritten = 0;    }}
public boolean metron_f7222_0(CommandLine cli)
{    return cli.hasOption(shortCode);}
public String metron_f7223_0(CommandLine cli)
{    return cli.getOptionValue(shortCode);}
public static CommandLine metron_f7224_0(CommandLineParser parser, String[] args)
{    try {        CommandLine cli = parser.parse(getOptions(), args);        if (InspectorOptions.HELP.has(cli)) {            printHelp();            System.exit(0);        }        return cli;    } catch (ParseException e) {        System.err.println("Unable to parse args: " + Joiner.on(' ').join(args));        e.printStackTrace(System.err);        printHelp();        System.exit(-1);        return null;    }}
public static void metron_f7225_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("PcapInspector", getOptions());}
public static Options metron_f7226_0()
{    Options ret = new Options();    for (InspectorOptions o : InspectorOptions.values()) {        ret.addOption(o.option);    }    return ret;}
public Option metron_f7227_0(@Nullable String s)
{    return new Option(s, "help", false, "Generate Help screen");}
public Option metron_f7228_0(@Nullable String s)
{    Option o = new Option(s, "input", true, "Input sequence file on HDFS");    o.setArgName("SEQ_FILE");    o.setRequired(true);    return o;}
public Option metron_f7229_0(@Nullable String s)
{    Option o = new Option(s, "num_packets", true, "Number of packets to dump");    o.setArgName("N");    o.setRequired(false);    return o;}
public static void metron_f7230_0(String... argv) throws IOException
{    Configuration conf = new Configuration();    String[] otherArgs = new GenericOptionsParser(conf, argv).getRemainingArgs();    CommandLine cli = InspectorOptions.parse(new PosixParser(), otherArgs);    Path inputPath = new Path(InspectorOptions.INPUT.get(cli));    int n = -1;    if (InspectorOptions.NUM.has(cli)) {        n = Integer.parseInt(InspectorOptions.NUM.get(cli));    }    SequenceFile.Reader reader = new SequenceFile.Reader(new Configuration(), SequenceFile.Reader.file(inputPath));    LongWritable key = new LongWritable();    BytesWritable value = new BytesWritable();    for (int i = 0; (n < 0 || i < n) && reader.next(key, value); ++i) {        long millis = Long.divideUnsigned(key.get(), 1000000);        String ts = DATE_FORMAT.format(new Date(millis));        try {            for (PacketInfo pi : PcapHelper.toPacketInfo(value.copyBytes())) {                Map<String, Object> result = PcapHelper.packetToFields(pi);                List<String> fieldResults = new ArrayList<String>() {                    {                        add("TS: " + ts);                    }                };                for (Constants.Fields field : Constants.Fields.values()) {                    if (result.containsKey(field.getName())) {                        fieldResults.add(field.getName() + ": " + result.get(field.getName()));                    }                }                System.out.println(Joiner.on(",").join(fieldResults));            }        } catch (Exception e) {            System.out.println(String.format("Error: malformed packet #=%s, ts=%s, error msg=%s", i + 1, ts, e.getMessage()));        }    }}
private static void metron_f7231_0(File... dirs) throws IOException
{    for (File dir : dirs) {        for (File f : dir.listFiles()) {            if (f.isDirectory()) {                FileUtils.deleteDirectory(f);            } else {                f.delete();            }        }    }}
private static int metron_f7232_0(File outDir, Configuration config)
{    return outDir.list(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return !name.endsWith(".crc");        }    }).length;}
public boolean metron_f7233_0(File dir, String name)
{    return !name.endsWith(".crc");}
public void metron_f7234_0() throws Exception
{    setupTopology(new Function<Properties, Void>() {        @Nullable        @Override        public Void apply(@Nullable Properties input) {            input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_PACKET.toString());            return null;        }    }, (kafkaComponent, pcapEntries) -> kafkaComponent.writeMessages(KAFKA_TOPIC, Collections2.transform(pcapEntries, input -> input.getValue())), true);}
public Void metron_f7235_0(@Nullable Properties input)
{    input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_PACKET.toString());    return null;}
public static void metron_f7236_0() throws Exception
{    System.out.println("Setting up test components");    withHeaders = false;    setupTopology(new Function<Properties, Void>() {        @Nullable        @Override        public Void apply(@Nullable Properties input) {            input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_KEY.toString());            return null;        }    }, new SendEntries() {        @Override        public void send(KafkaComponent kafkaComponent, List<Map.Entry<byte[], byte[]>> pcapEntries) throws Exception {            Producer<byte[], byte[]> producer = kafkaComponent.createProducer(byte[].class, byte[].class);            KafkaUtil.send(producer, pcapEntries, KAFKA_TOPIC, 2);            System.out.println("Sent pcap data: " + pcapEntries.size());            {                int numMessages = 0;                ConsumerIterator<?, ?> it = kafkaComponent.getStreamIterator(KAFKA_TOPIC);                for (int i = 0; i < pcapEntries.size(); ++i, it.next()) {                    numMessages++;                }                Assert.assertEquals(pcapEntries.size(), numMessages);                System.out.println("Wrote " + pcapEntries.size() + " to kafka");            }        }    }, withHeaders);    System.out.println("Done with setup.");}
public Void metron_f7237_0(@Nullable Properties input)
{    input.setProperty("kafka.pcap.ts_scheme", Deserializers.FROM_KEY.toString());    return null;}
public void metron_f7238_0(KafkaComponent kafkaComponent, List<Map.Entry<byte[], byte[]>> pcapEntries) throws Exception
{    Producer<byte[], byte[]> producer = kafkaComponent.createProducer(byte[].class, byte[].class);    KafkaUtil.send(producer, pcapEntries, KAFKA_TOPIC, 2);    System.out.println("Sent pcap data: " + pcapEntries.size());    {        int numMessages = 0;        ConsumerIterator<?, ?> it = kafkaComponent.getStreamIterator(KAFKA_TOPIC);        for (int i = 0; i < pcapEntries.size(); ++i, it.next()) {            numMessages++;        }        Assert.assertEquals(pcapEntries.size(), numMessages);        System.out.println("Wrote " + pcapEntries.size() + " to kafka");    }}
private static File metron_f7239_0(String targetDir, String childDir)
{    File directory = new File(new File(targetDir), childDir);    if (!directory.exists()) {        directory.mkdirs();    }    return directory;}
public static void metron_f7240_0() throws Exception
{    System.out.println("Tearing down test infrastructure");    System.out.println("Stopping runner");    runner.stop();    System.out.println("Done stopping runner");    System.out.println("Clearing output directories");    clearOutDirs(inputDir, interimResultDir, outputDir);    System.out.println("Finished");}
private static long metron_f7241_0(int offset, List<Map.Entry<byte[], byte[]>> entries)
{    return Bytes.toLong(entries.get(offset).getKey());}
public static void metron_f7242_0(Function<Properties, Void> updatePropertiesCallback, SendEntries sendPcapEntriesCallback, boolean withHeaders) throws Exception
{    if (!new File(topologiesDir).exists()) {        topologiesDir = UnitTestHelper.findDir("topologies");    }    targetDir = UnitTestHelper.findDir("target");    inputDir = getDir(targetDir, DATA_DIR);    interimResultDir = getDir(targetDir, INTERIM_RESULT);    outputDir = getDir(targetDir, OUTPUT_DIR);    clearOutDirs(inputDir, interimResultDir, outputDir);    File baseDir = new File(new File(targetDir), BASE_DIR);        Assert.assertNotNull(topologiesDir);    Assert.assertNotNull(targetDir);    Path pcapFile = new Path("../metron-integration-test/src/main/sample/data/SampleInput/PCAPExampleOutput");    pcapEntries = Lists.newArrayList(readPcaps(pcapFile, withHeaders));    Assert.assertTrue(Iterables.size(pcapEntries) > 0);    final Properties topologyProperties = new Properties() {        {            setProperty("topology.workers", "1");            setProperty("topology.worker.childopts", "");            setProperty("spout.kafka.topic.pcap", KAFKA_TOPIC);            setProperty("kafka.pcap.start", "EARLIEST");            setProperty("kafka.pcap.out", inputDir.getAbsolutePath());            setProperty("kafka.pcap.numPackets", "2");            setProperty("kafka.pcap.maxTimeMS", "200000000");            setProperty("kafka.pcap.ts_granularity", "NANOSECONDS");            setProperty("kafka.spout.parallelism", "1");            setProperty("topology.auto-credentials", "[]");            setProperty("kafka.security.protocol", "PLAINTEXT");            setProperty("hdfs.sync.every", "1");            setProperty("hdfs.replication.factor", "-1");        }    };    updatePropertiesCallback.apply(topologyProperties);    final ZKServerComponent zkServerComponent = getZKServerComponent(topologyProperties);    final KafkaComponent kafkaComponent = getKafkaComponent(topologyProperties, Collections.singletonList(new KafkaComponent.Topic(KAFKA_TOPIC, 1)));    final MRComponent mr = new MRComponent().withBasePath(baseDir.getAbsolutePath());    FluxTopologyComponent fluxComponent = new FluxTopologyComponent.Builder().withTopologyLocation(new File(topologiesDir + "/pcap/remote.yaml")).withTopologyName("pcap").withTopologyProperties(topologyProperties).build();        runner = new ComponentRunner.Builder().withComponent("mr", mr).withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("storm", fluxComponent).withMaxTimeMS(-1).withMillisecondsBetweenAttempts(2000).withNumRetries(10).withCustomShutdownOrder(new String[] { "storm", "kafka", "zk", "mr" }).build();    runner.start();    fluxComponent.submitTopology();    sendPcapEntriesCallback.send(kafkaComponent, pcapEntries);    runner.process(new Processor<Void>() {        @Override        public ReadinessState process(ComponentRunner runner) {            int numFiles = numFiles(inputDir, mr.getConfiguration());            int expectedNumFiles = pcapEntries.size() / 2;            if (numFiles == expectedNumFiles) {                return ReadinessState.READY;            } else {                return ReadinessState.NOT_READY;            }        }        @Override        public ProcessorResult<Void> getResult() {            return null;        }    });}
public ReadinessState metron_f7243_0(ComponentRunner runner)
{    int numFiles = numFiles(inputDir, mr.getConfiguration());    int expectedNumFiles = pcapEntries.size() / 2;    if (numFiles == expectedNumFiles) {        return ReadinessState.READY;    } else {        return ReadinessState.NOT_READY;    }}
public ProcessorResult<Void> metron_f7244_0()
{    return null;}
public void metron_f7245_0() throws IOException
{    configuration = new FixedPcapConfig(PcapCli.PREFIX_STRATEGY);    Configuration hadoopConf = new Configuration();    PcapOptions.JOB_NAME.put(configuration, "jobName");    PcapOptions.HADOOP_CONF.put(configuration, hadoopConf);    PcapOptions.FILESYSTEM.put(configuration, FileSystem.get(hadoopConf));    PcapOptions.BASE_PATH.put(configuration, new Path(inputDir.getAbsolutePath()));    PcapOptions.BASE_INTERIM_RESULT_PATH.put(configuration, new Path(interimResultDir.getAbsolutePath()));    PcapOptions.NUM_REDUCERS.put(configuration, 10);    PcapOptions.NUM_RECORDS_PER_FILE.put(configuration, 1);    PcapOptions.FINAL_OUTPUT_PATH.put(configuration, new Path(outputDir.getAbsolutePath()));    PcapOptions.FINALIZER_THREADPOOL_SIZE.put(configuration, 4);}
public void metron_f7246_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(4, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(5, pcapEntries));    PcapOptions.FIELDS.put(configuration, new HashMap());    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals("Expected 2 records returned.", 2, resultPages.getSize());    Assert.assertEquals("Expected 1 record in first file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 0)).size());    Assert.assertEquals("Expected 1 record in second file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 1)).size());}
public void metron_f7247_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(4, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(5, pcapEntries));    PcapOptions.FIELDS.put(configuration, "");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Pageable<Path> resultPages = results.get();    Iterable<byte[]> bytes = Iterables.transform(resultPages, path -> {        try {            return HDFSUtils.readBytes(path);        } catch (IOException e) {            throw new IllegalStateException(e);        }    });    assertInOrder(bytes);    Assert.assertEquals("Expected 2 records returned.", 2, resultPages.getSize());    Assert.assertEquals("Expected 1 record in first file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 0)).size());    Assert.assertEquals("Expected 1 record in second file.", 1, PcapHelper.toPacketInfo(Iterables.get(bytes, 1)).size());}
public void metron_f7248_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.FIELDS.put(configuration, new HashMap<>());    PcapOptions.START_TIME_NS.put(configuration, 0);    PcapOptions.END_TIME_NS.put(configuration, 1);    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(100.0, results.getStatus().getPercentComplete(), 0.0);    Assert.assertEquals("No results in specified date range.", results.getStatus().getDescription());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7249_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, new HashMap<String, String>() {        {            put(Constants.Fields.DST_ADDR.getName(), "207.28.210.1");        }    });    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7250_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, "ip_dst_addr == '207.28.210.1'");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7251_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new FixedPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, new HashMap<String, String>() {        {            put(Constants.Fields.PROTOCOL.getName(), "foo");        }    });    PcapJob<Map<String, String>> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
public void metron_f7252_0() throws Exception
{    PcapOptions.FILTER_IMPL.put(configuration, new QueryPcapFilter.Configurator());    PcapOptions.START_TIME_NS.put(configuration, getTimestamp(0, pcapEntries));    PcapOptions.END_TIME_NS.put(configuration, getTimestamp(1, pcapEntries));    PcapOptions.FIELDS.put(configuration, "protocol == 'foo'");    PcapJob<String> job = new PcapJob<>();    Statusable<Path> results = job.submit(PcapFinalizerStrategies.CLI, configuration);    Assert.assertEquals(Statusable.JobType.MAP_REDUCE, results.getJobType());    waitForJob(results);    Assert.assertEquals(JobStatus.State.SUCCEEDED, results.getStatus().getState());    Assert.assertEquals(results.get().getSize(), 0);}
