public Document metron_f5171_0(String metaAlertGuid, MetaAlertStatus status) throws IOException
{    Document metaAlert = retrieveLatestDao.getLatest(metaAlertGuid, MetaAlertConstants.METAALERT_TYPE);    if (metaAlert == null) {        throw new IOException(String.format("Unable to update meta alert status.  Meta alert with guid %s cannot be found.", metaAlertGuid));    }    String currentStatus = (String) metaAlert.getDocument().get(MetaAlertConstants.STATUS_FIELD);    boolean metaAlertUpdated = !status.getStatusString().equals(currentStatus);    if (metaAlertUpdated) {        List<GetRequest> getRequests = new ArrayList<>();        @SuppressWarnings("unchecked")        List<Map<String, Object>> currentAlerts = (List<Map<String, Object>>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD);        currentAlerts.stream().forEach(currentAlert -> getRequests.add(new GetRequest((String) currentAlert.get(GUID), (String) currentAlert.get(config.getSourceTypeField()))));        Iterable<Document> alerts = retrieveLatestDao.getAllLatest(getRequests);        Map<Document, Optional<String>> updates = buildStatusChangeUpdates(metaAlert, alerts, status);        update(updates);    }    return metaAlert;}
protected Map<Document, Optional<String>> metron_f5172_0(Document metaAlert, Iterable<Document> alerts, MetaAlertStatus status)
{    metaAlert.getDocument().put(MetaAlertConstants.STATUS_FIELD, status.getStatusString());    Map<Document, Optional<String>> updates = new HashMap<>();    updates.put(metaAlert, Optional.of(config.getMetaAlertIndex()));    for (Document alert : alerts) {        boolean metaAlertAdded = false;        boolean metaAlertRemoved = false;                if (MetaAlertStatus.ACTIVE.equals(status)) {            metaAlertAdded = addMetaAlertToAlert(metaAlert.getGuid(), alert);        }                if (MetaAlertStatus.INACTIVE.equals(status)) {            metaAlertRemoved = removeMetaAlertFromAlert(metaAlert.getGuid(), alert);        }        if (metaAlertAdded || metaAlertRemoved) {            updates.put(alert, Optional.empty());        }    }    return updates;}
protected Map<Document, Optional<String>> metron_f5173_0(Document metaAlert, Iterable<Document> alerts)
{    Map<Document, Optional<String>> updates = new HashMap<>();    boolean metaAlertUpdated = addAlertsToMetaAlert(metaAlert, alerts);    if (metaAlertUpdated) {        MetaScores.calculateMetaScores(metaAlert, config.getThreatTriageField(), config.getThreatSort());        updates.put(metaAlert, Optional.of(config.getMetaAlertIndex()));        for (Document alert : alerts) {            if (addMetaAlertToAlert(metaAlert.getGuid(), alert)) {                updates.put(alert, Optional.empty());            }        }    }    return updates;}
protected boolean metron_f5174_0(Document metaAlert, Iterable<Document> alerts)
{    boolean alertAdded = false;    @SuppressWarnings("unchecked")    List<Map<String, Object>> currentAlerts = (List<Map<String, Object>>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD);    if (currentAlerts == null) {        currentAlerts = new ArrayList<>();        metaAlert.getDocument().put(MetaAlertConstants.ALERT_FIELD, currentAlerts);    }    Set<String> currentAlertGuids = currentAlerts.stream().map(currentAlert -> (String) currentAlert.get(GUID)).collect(Collectors.toSet());    for (Document alert : alerts) {        String alertGuid = alert.getGuid();                if (!currentAlertGuids.contains(alertGuid)) {            currentAlerts.add(alert.getDocument());            alertAdded = true;        }    }    return alertAdded;}
protected void metron_f5175_0(Map<Document, Optional<String>> updates) throws IOException
{    if (updates.size() == 1) {        Entry<Document, Optional<String>> singleUpdate = updates.entrySet().iterator().next();        updateDao.update(singleUpdate.getKey(), singleUpdate.getValue());    } else if (updates.size() > 1) {        updateDao.batchUpdate(updates);    }}
protected Set<String> metron_f5176_0(List<GetRequest> alertRequests, Iterable<Document> results) throws IOException
{    Set<String> requestGuids = alertRequests.stream().map(GetRequest::getGuid).collect(Collectors.toSet());    Set<String> resultGuids = StreamSupport.stream(results.spliterator(), false).map(Document::getGuid).collect(Collectors.toSet());    Set<String> missingGuids = new HashSet<>(requestGuids);    missingGuids.removeAll(resultGuids);    return missingGuids;}
public String metron_f5177_0()
{    return metaAlertGuid;}
public void metron_f5178_0(String metaAlertGuid)
{    this.metaAlertGuid = metaAlertGuid;}
public List<GetRequest> metron_f5179_0()
{    return alerts;}
public void metron_f5180_0(List<GetRequest> alerts)
{    this.alerts = alerts;}
public String metron_f5181_0()
{    return metaAlertIndex;}
public void metron_f5182_0(String metaAlertIndex)
{    this.metaAlertIndex = metaAlertIndex;}
public String metron_f5183_0()
{    Optional<Map<String, Object>> globalConfig = Optional.ofNullable(globalConfigSupplier.get());    if (!globalConfig.isPresent()) {        return getDefaultThreatTriageField();    }    return ConfigurationsUtils.getFieldName(globalConfig.get(), Constants.THREAT_SCORE_FIELD_PROPERTY, getDefaultThreatTriageField());}
public String metron_f5184_0()
{    return threatSort;}
public void metron_f5185_0(String threatSort)
{    this.threatSort = threatSort;}
public String metron_f5186_0()
{    Optional<Map<String, Object>> globalConfig = Optional.ofNullable(globalConfigSupplier.get());    if (!globalConfig.isPresent()) {        return getDefaultSourceTypeField();    }    return ConfigurationsUtils.getFieldName(globalConfig.get(), Constants.SENSOR_TYPE_FIELD_PROPERTY, getDefaultSourceTypeField());}
public List<GetRequest> metron_f5187_0()
{    return alerts;}
public void metron_f5188_0(List<GetRequest> alerts)
{    this.alerts = alerts;}
public List<String> metron_f5189_0()
{    return groups;}
public void metron_f5190_0(List<String> groups)
{    this.groups = groups;}
 void metron_f5191_0(IndexDao indexDao)
{    init(indexDao, Optional.empty());}
public String metron_f5192_0()
{    return statusString;}
 boolean metron_f5193_0(PatchRequest request)
{    if (request.getPatch() != null && !request.getPatch().isEmpty()) {        for (Map<String, Object> patch : request.getPatch()) {            Object pathObj = patch.get("path");            if (pathObj != null && pathObj instanceof String) {                String path = (String) pathObj;                if (STATUS_PATH.equals(path) || ALERT_PATH.equals(path)) {                    return false;                }            }        }    }    return true;}
 boolean metron_f5194_0(String metaAlertGuid, Document alert)
{    List<String> metaAlertField = new ArrayList<>();    @SuppressWarnings("unchecked")    List<String> alertField = (List<String>) alert.getDocument().get(MetaAlertConstants.METAALERT_FIELD);    if (alertField != null) {        metaAlertField.addAll(alertField);    }    boolean metaAlertRemoved = metaAlertField.remove(metaAlertGuid);    if (metaAlertRemoved) {        alert.getDocument().put(MetaAlertConstants.METAALERT_FIELD, metaAlertField);    }    return metaAlertRemoved;}
 boolean metron_f5195_0(String metaAlertGuid, Document alert)
{    List<String> metaAlertField = new ArrayList<>();    @SuppressWarnings("unchecked")    List<String> alertField = (List<String>) alert.getDocument().get(MetaAlertConstants.METAALERT_FIELD);    if (alertField != null) {        metaAlertField.addAll(alertField);    }    boolean metaAlertAdded = !metaAlertField.contains(metaAlertGuid);    if (metaAlertAdded) {        metaAlertField.add(metaAlertGuid);        alert.getDocument().put(MetaAlertConstants.METAALERT_FIELD, metaAlertField);    }    return metaAlertAdded;}
public Map<String, Object> metron_f5196_0()
{    return metaScores;}
public static void metron_f5197_0(Document metaAlert, String threatTriageField, String threatSort)
{    MetaScores metaScores = new MetaScores(new ArrayList<>());    List<Object> alertsRaw = ((List<Object>) metaAlert.getDocument().get(MetaAlertConstants.ALERT_FIELD));    if (alertsRaw != null && !alertsRaw.isEmpty()) {        ArrayList<Double> scores = new ArrayList<>();        for (Object alertRaw : alertsRaw) {            Map<String, Object> alert = (Map<String, Object>) alertRaw;            Double scoreNum = parseThreatField(alert.get(threatTriageField));            if (scoreNum != null) {                scores.add(scoreNum);            }        }        metaScores = new MetaScores(scores);    }        metaAlert.getDocument().putAll(metaScores.getMetaScores());            Object threatScore = metaScores.getMetaScores().get(threatSort);            metaAlert.getDocument().put(threatTriageField, ConversionUtils.convert(threatScore, Float.class));}
protected static Double metron_f5198_0(Object threatRaw)
{    Double threat = null;    if (threatRaw instanceof Number) {        threat = ((Number) threatRaw).doubleValue();    } else if (threatRaw instanceof String) {        threat = Double.parseDouble((String) threatRaw);    }    return threat;}
public Document metron_f5199_0(final Document update, Optional<String> index) throws IOException
{    List<String> exceptions = indices.parallelStream().map(dao -> {        try {            dao.update(update, index);            return null;        } catch (Throwable e) {            return dao.getClass() + ": " + e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e);        }    }).filter(e -> e != null).collect(Collectors.toList());    if (exceptions.size() > 0) {        throw new IOException(Joiner.on("\n").join(exceptions));    }    return update;}
public Map<Document, Optional<String>> metron_f5200_0(Map<Document, Optional<String>> updates) throws IOException
{    List<String> exceptions = indices.parallelStream().map(dao -> {        try {            dao.batchUpdate(updates);            return null;        } catch (Throwable e) {            return dao.getClass() + ": " + e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e);        }    }).filter(e -> e != null).collect(Collectors.toList());    if (exceptions.size() > 0) {        throw new IOException(Joiner.on("\n").join(exceptions));    }    return updates;}
public Map<String, FieldType> metron_f5201_0(List<String> in) throws IOException
{    for (IndexDao dao : indices) {        Map<String, FieldType> r = dao.getColumnMetadata(in);        if (r != null) {            return r;        }    }    return null;}
public Document metron_f5202_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = getLatest(request.getGuid(), request.getSensorType());    return addCommentToAlert(request, latest);}
public Document metron_f5203_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    List<DocumentContainer> output = indices.parallelStream().map(dao -> addCommentToAlert(dao, request, latest)).collect(Collectors.toList());    return getLatestDocument(output);}
public Document metron_f5205_0(CommentAddRemoveRequest request) throws IOException
{    Document latest = getLatest(request.getGuid(), request.getSensorType());    return removeCommentFromAlert(request, latest);}
public Document metron_f5206_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    List<DocumentContainer> output = indices.parallelStream().map(dao -> removeCommentFromAlert(dao, request, latest)).collect(Collectors.toList());    return getLatestDocument(output);}
public Optional<Document> metron_f5208_0()
{    return d;}
public Optional<Throwable> metron_f5209_0()
{    return t;}
public Optional<Iterable<Document>> metron_f5210_0()
{    return d;}
public Optional<Throwable> metron_f5211_0()
{    return t;}
public SearchResponse metron_f5212_0(SearchRequest searchRequest) throws InvalidSearchException
{    for (IndexDao dao : indices) {        SearchResponse s = dao.search(searchRequest);        if (s != null) {            return s;        }    }    return null;}
public GroupResponse metron_f5213_0(GroupRequest groupRequest) throws InvalidSearchException
{    for (IndexDao dao : indices) {        GroupResponse s = dao.group(groupRequest);        if (s != null) {            return s;        }    }    return null;}
public void metron_f5214_0(AccessConfig config)
{    for (IndexDao dao : indices) {        dao.init(config);    }}
public Document metron_f5215_0(final String guid, String sensorType) throws IOException
{    List<DocumentContainer> output = indices.parallelStream().map(dao -> getLatest(dao, guid, sensorType)).collect(Collectors.toList());    return getLatestDocument(output);}
public Iterable<Document> metron_f5217_0(List<GetRequest> getRequests) throws IOException
{    Iterable<Document> ret = null;    List<DocumentIterableContainer> output = indices.parallelStream().map(dao -> {        try {            return new DocumentIterableContainer(dao.getAllLatest(getRequests));        } catch (Throwable e) {            return new DocumentIterableContainer(e);        }    }).collect(Collectors.toList());    List<String> error = new ArrayList<>();    for (DocumentIterableContainer dc : output) {        if (dc.getException().isPresent()) {            Throwable e = dc.getException().get();            error.add(e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e));        } else {            if (dc.getDocumentIterable().isPresent()) {                Iterable<Document> documents = dc.getDocumentIterable().get();                if (ret == null) {                    ret = documents;                }            }        }    }    if (error.size() > 0) {        throw new IOException(Joiner.on("\n").join(error));    }    return ret;}
public List<IndexDao> metron_f5218_0()
{    return indices;}
private Document metron_f5219_0(List<DocumentContainer> documentContainers) throws IOException
{    Document latestDocument = null;    List<String> error = new ArrayList<>();    for (DocumentContainer dc : documentContainers) {        if (dc.getException().isPresent()) {                        Throwable e = dc.getException().get();            error.add(e.getMessage() + "\n" + ExceptionUtils.getStackTrace(e));        } else if (dc.getDocument().isPresent()) {            Document d = dc.getDocument().get();                        if (latestDocument == null || latestDocument.getTimestamp() < d.getTimestamp()) {                latestDocument = d;            }        } else {                }    }    if (error.size() > 0) {                throw new IOException(Joiner.on("\n").join(error));    }    return latestDocument;}
 Optional<Map<String, Object>> metron_f5220_0(GetRequest request) throws IOException
{    Document ret = getLatest(request.getGuid(), request.getSensorType());    if (ret == null) {        return Optional.empty();    } else {        return Optional.ofNullable(ret.getDocument());    }}
public String metron_f5221_0()
{    return comment;}
public String metron_f5222_0()
{    return username;}
public long metron_f5223_0()
{    return timestamp;}
public String metron_f5224_0()
{    return asJSONObject().toJSONString();}
public Map<String, Object> metron_f5225_0()
{    Map<String, Object> map = new HashMap<>();    map.put(COMMENT_FIELD, comment);    map.put(COMMENT_USERNAME_FIELD, username);    map.put(COMMENT_TIMESTAMP_FIELD, timestamp);    return map;}
public JSONObject metron_f5226_0()
{    JSONObject json = new JSONObject();    json.put(COMMENT_FIELD, comment);    json.put(COMMENT_USERNAME_FIELD, username);    json.put(COMMENT_TIMESTAMP_FIELD, timestamp);    return json;}
public boolean metron_f5227_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    AlertComment that = (AlertComment) o;    if (getTimestamp() != that.getTimestamp()) {        return false;    }    if (getComment() != null ? !getComment().equals(that.getComment()) : that.getComment() != null) {        return false;    }    return getUsername() != null ? getUsername().equals(that.getUsername()) : that.getUsername() == null;}
public int metron_f5228_0()
{    int result = getComment() != null ? getComment().hashCode() : 0;    result = 31 * result + (getUsername() != null ? getUsername().hashCode() : 0);    result = 31 * result + (int) (getTimestamp() ^ (getTimestamp() >>> 32));    return result;}
public String metron_f5229_0()
{    return "AlertComment{" + "comment='" + comment + '\'' + ", username='" + username + '\'' + ", timestamp=" + timestamp + '}';}
public String metron_f5230_0()
{    return fieldType;}
public String metron_f5231_0()
{    return guid;}
public void metron_f5232_0(String guid)
{    this.guid = guid;}
public String metron_f5233_0()
{    return sensorType;}
public void metron_f5234_0(String sensorType)
{    this.sensorType = sensorType;}
public Optional<String> metron_f5235_0()
{    return index != null ? Optional.of(this.index) : Optional.empty();}
public String metron_f5236_0()
{    return index;}
public void metron_f5237_0(String index)
{    this.index = index;}
public GroupOrder metron_f5238_0()
{    return order;}
public void metron_f5239_0(GroupOrder order)
{    this.order = order;}
public String metron_f5240_0()
{    return field;}
public void metron_f5241_0(String field)
{    this.field = field;}
public SortOrder metron_f5242_0()
{    return sortOrder;}
public void metron_f5243_0(String sortOrder)
{    this.sortOrder = SortOrder.fromString(sortOrder);}
public GroupOrderType metron_f5244_0()
{    return groupOrderType;}
public void metron_f5245_0(String groupOrderType)
{    this.groupOrderType = GroupOrderType.fromString(groupOrderType);}
public String metron_f5246_0()
{    return groupOrderType;}
public static GroupOrderType metron_f5247_0(String groupOrderType)
{    return GroupOrderType.valueOf(groupOrderType.toUpperCase());}
public List<String> metron_f5248_0()
{    return indices;}
public void metron_f5249_0(List<String> indices)
{    this.indices = indices;}
public String metron_f5250_0()
{    return query;}
public void metron_f5251_0(String query)
{    this.query = query;}
public Optional<String> metron_f5252_0()
{    return scoreField == null ? Optional.empty() : Optional.of(scoreField);}
public void metron_f5253_0(String scoreField)
{    this.scoreField = scoreField;}
public List<Group> metron_f5254_0()
{    return groups;}
public void metron_f5255_0(List<Group> groups)
{    this.groups = groups;}
public String metron_f5256_0()
{    return groupedBy;}
public void metron_f5257_0(String groupedBy)
{    this.groupedBy = groupedBy;}
public List<GroupResult> metron_f5258_0()
{    return groupResults;}
public void metron_f5259_0(List<GroupResult> groupResults)
{    this.groupResults = groupResults;}
public String metron_f5260_0()
{    return key;}
public void metron_f5261_0(String key)
{    this.key = key;}
public long metron_f5262_0()
{    return total;}
public void metron_f5263_0(long total)
{    this.total = total;}
public Double metron_f5264_0()
{    return score;}
public void metron_f5265_0(Double score)
{    this.score = score;}
public String metron_f5266_0()
{    return groupedBy;}
public void metron_f5267_0(String groupedBy)
{    this.groupedBy = groupedBy;}
public List<GroupResult> metron_f5268_0()
{    return groupResults;}
public void metron_f5269_0(List<GroupResult> groups)
{    this.groupResults = groups;}
public List<String> metron_f5270_0()
{    return indices;}
public void metron_f5271_0(List<String> indices)
{    this.indices = indices;}
public String metron_f5272_0()
{    return query;}
public void metron_f5273_0(String query)
{    this.query = query;}
public int metron_f5274_0()
{    return size;}
public void metron_f5275_0(int size)
{    this.size = size;}
public int metron_f5276_0()
{    return from;}
public void metron_f5277_0(int from)
{    this.from = from;}
public List<SortField> metron_f5278_0()
{    return sort;}
public void metron_f5279_0(List<SortField> sort)
{    this.sort = sort;}
public List<String> metron_f5280_0()
{    return fields;}
public void metron_f5281_0(List<String> fields)
{    this.fields = fields;}
public List<String> metron_f5282_0()
{    return facetFields;}
public void metron_f5283_0(List<String> facetFields)
{    this.facetFields = facetFields;}
public boolean metron_f5284_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SearchRequest that = (SearchRequest) o;    return (indices != null ? indices.equals(that.indices) : that.indices == null) && (query != null ? query.equals(that.query) : that.query == null) && size == that.size && from == that.from && (sort != null ? sort.equals(that.sort) : that.sort == null) && (fields != null ? fields.equals(that.fields) : that.fields == null) && (facetFields != null ? facetFields.equals(that.facetFields) : that.facetFields == null);}
public int metron_f5285_0()
{    int result = indices != null ? indices.hashCode() : 0;    result = 31 * result + (query != null ? query.hashCode() : 0);    result = 31 * result + getSize();    result = 31 * result + getFrom();    result = 31 * result + (sort != null ? sort.hashCode() : 0);    result = 31 * result + (fields != null ? fields.hashCode() : 0);    result = 31 * result + (facetFields != null ? facetFields.hashCode() : 0);    return result;}
public long metron_f5286_0()
{    return total;}
public void metron_f5287_0(long total)
{    this.total = total;}
public List<SearchResult> metron_f5288_0()
{    return results;}
public void metron_f5289_0(List<SearchResult> results)
{    this.results = results;}
public Map<String, Map<String, Long>> metron_f5290_0()
{    return facetCounts;}
public void metron_f5291_0(Map<String, Map<String, Long>> facetCounts)
{    this.facetCounts = facetCounts;}
public boolean metron_f5292_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SearchResponse that = (SearchResponse) o;    return getTotal() == that.getTotal() && (getResults() != null ? getResults().equals(that.getResults()) : that.getResults() != null) && (getFacetCounts() != null ? getFacetCounts().equals(that.getFacetCounts()) : that.getFacetCounts() != null);}
public int metron_f5293_0()
{    int result = 31 * (int) getTotal() + (getResults() != null ? getResults().hashCode() : 0);    result = 31 * result + (getFacetCounts() != null ? getFacetCounts().hashCode() : 0);    return result;}
public String metron_f5294_0()
{    return "SearchResponse{" + "total=" + total + ", results=" + results + ", facetCounts=" + facetCounts + '}';}
public String metron_f5295_0()
{    return index;}
public void metron_f5296_0(String index)
{    this.index = index;}
public String metron_f5297_0()
{    return id;}
public void metron_f5298_0(String id)
{    this.id = id;}
public Map<String, Object> metron_f5299_0()
{    return source;}
public void metron_f5300_0(Map<String, Object> source)
{    this.source = source;}
public float metron_f5301_0()
{    return score;}
public void metron_f5302_0(float score)
{    this.score = score;}
public String metron_f5303_0()
{    return "SearchResult{" + "id='" + id + '\'' + ", source=" + source + ", score=" + score + ", index='" + index + '\'' + '}';}
public boolean metron_f5304_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SearchResult that = (SearchResult) o;    if (Float.compare(that.getScore(), getScore()) != 0) {        return false;    }    if (getId() != null ? !getId().equals(that.getId()) : that.getId() != null) {        return false;    }    if (getSource() != null ? !getSource().equals(that.getSource()) : that.getSource() != null) {        return false;    }    return getIndex() != null ? getIndex().equals(that.getIndex()) : that.getIndex() == null;}
public int metron_f5305_0()
{    int result = getId() != null ? getId().hashCode() : 0;    result = 31 * result + (getSource() != null ? getSource().hashCode() : 0);    result = 31 * result + (getScore() != +0.0f ? Float.floatToIntBits(getScore()) : 0);    result = 31 * result + (getIndex() != null ? getIndex().hashCode() : 0);    return result;}
public String metron_f5306_0()
{    return field;}
public void metron_f5307_0(String field)
{    this.field = field;}
public SortOrder metron_f5308_0()
{    return sortOrder;}
public void metron_f5309_0(String sortOrder)
{    this.sortOrder = SortOrder.fromString(sortOrder);}
public boolean metron_f5310_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    SortField that = (SortField) o;    return (field != null ? field.equals(that.field) : that.field == null) && (sortOrder != null ? sortOrder.equals(that.sortOrder) : that.sortOrder == null);}
public String metron_f5311_0()
{    return sortOrder;}
public static SortOrder metron_f5312_0(String order)
{    return SortOrder.valueOf(order.toUpperCase());}
public String metron_f5313_0()
{    return guid;}
public void metron_f5314_0(String guid)
{    this.guid = guid;}
public String metron_f5315_0()
{    return sensorType;}
public void metron_f5316_0(String sensorType)
{    this.sensorType = sensorType;}
public String metron_f5317_0()
{    return comment;}
public void metron_f5318_0(String comment)
{    this.comment = comment;}
public String metron_f5319_0()
{    return username;}
public void metron_f5320_0(String username)
{    this.username = username;}
public long metron_f5321_0()
{    return timestamp;}
public void metron_f5322_0(long timestamp)
{    this.timestamp = timestamp;}
public String metron_f5323_0()
{    return "CommentAddRemoveRequest{" + "guid='" + guid + '\'' + ", sensorType='" + sensorType + '\'' + ", comment='" + comment + '\'' + ", username='" + username + '\'' + ", timestamp=" + timestamp + '}';}
public static Document metron_f5324_0(Map<String, Object> json)
{    String guid = getGUID(json);    Long timestamp = getTimestamp(json).orElse(0L);    String sensorType = getSensorType(json);    return new Document(json, guid, sensorType, timestamp);}
private static Map<String, Object> metron_f5325_0(String document) throws IOException
{    return JSONUtils.INSTANCE.load(document, JSONUtils.MAP_SUPPLIER);}
public String metron_f5326_0()
{    return sensorType;}
public void metron_f5327_0(String sensorType)
{    this.sensorType = sensorType;}
public Long metron_f5328_0()
{    return timestamp;}
public void metron_f5329_0(Long timestamp)
{    this.timestamp = timestamp != null ? timestamp : System.currentTimeMillis();}
public Map<String, Object> metron_f5330_0()
{    return document;}
public void metron_f5331_0(Map<String, Object> document)
{    this.document = document;}
public String metron_f5332_0()
{    return guid;}
public void metron_f5333_0(String guid)
{    this.guid = guid;}
public Optional<String> metron_f5334_0()
{    return Optional.ofNullable(documentID);}
public void metron_f5335_0(Optional<String> documentID)
{    this.documentID = documentID.orElse(null);}
public void metron_f5336_0(String documentID)
{    this.documentID = documentID;}
private static Optional<Long> metron_f5337_0(Map<String, Object> document)
{    Object value = document.get(TIMESTAMP.getName());    if (value != null && value instanceof Long) {        return Optional.of(Long.class.cast(value));    }    return Optional.empty();}
private static String metron_f5338_0(Map<String, Object> document)
{    Object value = document.get(GUID);    if (value != null && value instanceof String) {        return String.class.cast(value);    }    throw new IllegalStateException(String.format("Missing '%s' field", GUID));}
private static String metron_f5339_0(Map<String, Object> document)
{    Object value = document.get(SENSOR_TYPE);    if (value != null && value instanceof String) {        return String.class.cast(value);    }    value = document.get(SENSOR_TYPE.replace(".", ":"));    if (value != null && value instanceof String) {        return String.class.cast(value);    }    throw new IllegalStateException(String.format("Missing '%s' field", SENSOR_TYPE));}
public boolean metron_f5340_0(Object o)
{    if (this == o)        return true;    if (!(o instanceof Document))        return false;    Document document1 = (Document) o;    return Objects.equals(timestamp, document1.timestamp) && Objects.equals(document, document1.document) && Objects.equals(guid, document1.guid) && Objects.equals(sensorType, document1.sensorType) && Objects.equals(documentID, document1.documentID);}
public int metron_f5341_0()
{    return Objects.hash(timestamp, document, guid, sensorType, documentID);}
public String metron_f5342_0()
{    return "Document{" + "timestamp=" + timestamp + ", document=" + document + ", guid='" + guid + '\'' + ", sensorType='" + sensorType + '\'' + ", documentID=" + documentID + '}';}
public String metron_f5343_0()
{    return index;}
public void metron_f5344_0(String index)
{    this.index = index;}
public List<Map<String, Object>> metron_f5345_0()
{    return patch;}
public void metron_f5346_0(List<Map<String, Object>> patch)
{    this.patch = patch;}
public Map<String, Object> metron_f5347_0()
{    return source;}
public void metron_f5348_0(Map<String, Object> source)
{    this.source = source;}
public String metron_f5349_0()
{    return guid;}
public void metron_f5350_0(String guid)
{    this.guid = guid;}
public String metron_f5351_0()
{    return sensorType;}
public void metron_f5352_0(String sensorType)
{    this.sensorType = sensorType;}
public Map<String, Object> metron_f5353_0(List<Map<String, Object>> patches, Map<String, Object> source)
{    Map<String, Object> patchedObject = new HashMap<>(source);    for (Map<String, Object> patch : patches) {                String operation = (String) patch.get(OP);        PatchOperation patchOperation;        try {            patchOperation = PatchOperation.valueOf(operation.toUpperCase());        } catch (IllegalArgumentException e) {            throw new UnsupportedOperationException(String.format("The %s operation is not supported", operation));        }        Object value = patch.get(VALUE);        String path = (String) patch.get(PATH);                List<String> fieldNames = getFieldNames(path);        String nestedFieldName = fieldNames.get(fieldNames.size() - 1);        Map<String, Object> nestedObject = getNestedObject(fieldNames, patchedObject);                if (ADD.equals(patchOperation) || REPLACE.equals(patchOperation)) {            nestedObject.put(nestedFieldName, value);        } else if (REMOVE.equals(patchOperation)) {            nestedObject.remove(nestedFieldName);        } else if (COPY.equals(patchOperation) || MOVE.equals(patchOperation)) {                        String from = (String) patch.get(FROM);            List<String> fromFieldNames = getFieldNames(from);            String fromNestedFieldName = fromFieldNames.get(fromFieldNames.size() - 1);            Map<String, Object> fromNestedObject = getNestedObject(fromFieldNames, patchedObject);                        Object copyValue = fromNestedObject.get(fromNestedFieldName);            nestedObject.put(nestedFieldName, copyValue);            if (MOVE.equals(patchOperation)) {                                nestedObject.remove(fromNestedFieldName);            }        } else if (TEST.equals(patchOperation)) {            Object testValue = nestedObject.get(nestedFieldName);            if (!Objects.equals(value, testValue)) {                throw new PatchException(String.format("TEST operation failed: supplied value [%s] != target value [%s]", value, testValue));            }        }    }    return patchedObject;}
private List<String> metron_f5354_0(String path)
{    String[] parts = path.split(PATH_SEPARATOR);    return new ArrayList<>(Arrays.asList(parts).subList(1, parts.length));}
private Map<String, Object> metron_f5355_0(List<String> fieldNames, Map<String, Object> patchedObject)
{    Map<String, Object> nestedObject = patchedObject;    for (int i = 0; i < fieldNames.size() - 1; i++) {        Object object = nestedObject.get(fieldNames.get(i));        if (object == null || !(object instanceof Map)) {            throw new IllegalArgumentException(String.format("Invalid path: /%s", String.join(PATH_SEPARATOR, fieldNames)));        } else {            nestedObject = (Map<String, Object>) object;        }    }    return nestedObject;}
 Document metron_f5356_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    Document d = getPatchedDocument(retrieveLatestDao, request, timestamp);    return update(d, Optional.ofNullable(request.getIndex()));}
 Document metron_f5357_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> optionalTimestamp) throws OriginalNotFoundException, IOException
{    String guid = request.getGuid();    String sensorType = request.getSensorType();    String documentID = null;    Long timestamp = optionalTimestamp.orElse(System.currentTimeMillis());    Map<String, Object> originalSource = request.getSource();    if (originalSource == null) {                Document toPatch = retrieveLatestDao.getLatest(guid, sensorType);        if (toPatch != null && toPatch.getDocument() != null) {            originalSource = toPatch.getDocument();            documentID = toPatch.getDocumentID().orElse(null);        } else {            String error = format("Document does not exist, but is required; guid=%s, sensorType=%s", guid, sensorType);            throw new OriginalNotFoundException(error);        }    }    Map<String, Object> patchedSource = PatchUtils.INSTANCE.applyPatch(request.getPatch(), originalSource);    return new Document(patchedSource, guid, sensorType, timestamp, documentID);}
public static Function<String, String> metron_f5358_0(ConfigurationsCache cache, String writerName)
{    return sensorType -> {        String indexingTopic = sensorType;        IndexingConfigurations indexingConfigs = cache.get(IndexingConfigurations.class);        Map<String, Object> indexingSensorConfigs = indexingConfigs.getSensorIndexingConfig(sensorType);        if (indexingSensorConfigs != null) {            Map<String, Object> writerConfigs = (Map<String, Object>) indexingSensorConfigs.get(writerName);            if (writerConfigs != null) {                indexingTopic = (String) writerConfigs.getOrDefault(IndexingConfigurations.INDEX_CONF, indexingTopic);            }        }        return indexingTopic;    };}
public void metron_f5359_0()
{    dao = new HBaseDao();}
public UpdateDao metron_f5360_0()
{    return dao;}
public SearchResponse metron_f5361_0(SearchRequest searchRequest) throws InvalidSearchException
{    if (config.getMaxSearchResults() != null && searchRequest.getSize() > config.getMaxSearchResults()) {        throw new InvalidSearchException("Search result size must be less than " + config.getMaxSearchResults());    }    List<SearchResult> response = new ArrayList<>();    for (String index : searchRequest.getIndices()) {        String i = null;        for (String storedIdx : BACKING_STORE.keySet()) {            if (storedIdx.equals(index) || storedIdx.startsWith(index + "_")) {                i = storedIdx;            }        }        if (i == null) {            continue;        }        for (String doc : BACKING_STORE.get(i)) {            Map<String, Object> docParsed = parse(doc);            if (isMatch(searchRequest.getQuery(), docParsed)) {                SearchResult result = new SearchResult();                result.setSource(docParsed);                result.setScore((float) Math.random());                result.setId(docParsed.getOrDefault(Constants.GUID, UUID.randomUUID()).toString());                response.add(result);            }        }    }    if (searchRequest.getSort().size() != 0) {        Collections.sort(response, sorted(searchRequest.getSort()));    }    SearchResponse ret = new SearchResponse();    List<SearchResult> finalResp = new ArrayList<>();    int maxSize = config.getMaxSearchResults() == null ? searchRequest.getSize() : config.getMaxSearchResults();    for (int i = searchRequest.getFrom(); i < response.size() && finalResp.size() <= maxSize; ++i) {        finalResp.add(response.get(i));    }    ret.setTotal(response.size());    ret.setResults(finalResp);    Map<String, Map<String, Long>> facetCounts = new HashMap<>();    List<String> facetFields = searchRequest.getFacetFields();    if (facetFields != null) {        for (String facet : facetFields) {            facetCounts.put(facet, FACET_COUNTS.get(facet));        }        ret.setFacetCounts(facetCounts);    }    return ret;}
public GroupResponse metron_f5362_0(GroupRequest groupRequest) throws InvalidSearchException
{    GroupResponse groupResponse = new GroupResponse();    groupResponse.setGroupedBy(groupRequest.getGroups().get(0).getField());    groupResponse.setGroupResults(getGroupResults(groupRequest.getGroups(), 0));    return groupResponse;}
private List<GroupResult> metron_f5363_0(List<Group> groups, int index)
{    Group group = groups.get(index);    GroupResult groupResult = new GroupResult();    groupResult.setKey(group.getField() + "_value");    if (index < groups.size() - 1) {        groupResult.setGroupedBy(groups.get(index + 1).getField());        groupResult.setGroupResults(getGroupResults(groups, index + 1));    } else {        groupResult.setScore(50.0);    }    groupResult.setTotal(10);    return Collections.singletonList(groupResult);}
public int metron_f5364_0(Comparable o1, Comparable o2)
{    int result = ComparisonChain.start().compare(o1, o2, Ordering.natural().nullsLast()).result();    return order == SortOrder.ASC ? result : -1 * result;}
private static Comparator<SearchResult> metron_f5365_0(final List<SortField> fields)
{    return (o1, o2) -> {        ComparisonChain chain = ComparisonChain.start();        for (SortField field : fields) {            Comparable f1 = (Comparable) o1.getSource().get(field.getField());            Comparable f2 = (Comparable) o2.getSource().get(field.getField());            chain = chain.compare(f1, f2, new ComparableComparator(field.getSortOrder()));        }        return chain.result();    };}
private static boolean metron_f5366_0(String query, Map<String, Object> doc)
{    if (query == null) {        return false;    }    if (query.equals("*")) {        return true;    }    if (query.contains(":")) {        Iterable<String> splits = Splitter.on(":").split(query.trim());        String field = Iterables.getFirst(splits, "");        String val = Iterables.getLast(splits, "");                if (val == null) {            return false;        }                String nestingField = null;        if (field.contains("|")) {            Iterable<String> fieldSplits = Splitter.on('|').split(field);            nestingField = Iterables.getFirst(fieldSplits, null);            field = Iterables.getLast(fieldSplits, null);        }        if (nestingField == null) {                        Object o = doc.get(field);            return val.equals(o);        } else {                        @SuppressWarnings("unchecked")            List<Map<String, Object>> nestedList = (List<Map<String, Object>>) doc.get(nestingField);            if (nestedList == null) {                return false;            } else {                for (Map<String, Object> nestedEntry : nestedList) {                    if (val.equals(nestedEntry.get(field))) {                        return true;                    }                }            }        }    }    return false;}
public static Map<String, Object> metron_f5367_0(String doc)
{    try {        return JSONUtils.INSTANCE.load(doc, JSONUtils.MAP_SUPPLIER);    } catch (IOException e) {        throw new IllegalStateException(e.getMessage(), e);    }}
public void metron_f5368_0(AccessConfig config)
{    this.config = config;}
public Document metron_f5369_0(String guid, String sensorType) throws IOException
{    for (Map.Entry<String, List<String>> kv : BACKING_STORE.entrySet()) {        if (kv.getKey().startsWith(sensorType)) {            for (String doc : kv.getValue()) {                Map<String, Object> docParsed = parse(doc);                if (docParsed.getOrDefault(Constants.GUID, "").equals(guid)) {                    return new Document(doc, guid, sensorType, 0L);                }            }        }    }    return null;}
public Iterable<Document> metron_f5370_0(List<GetRequest> getRequests) throws IOException
{    List<Document> documents = new ArrayList<>();    for (Map.Entry<String, List<String>> kv : BACKING_STORE.entrySet()) {        for (String doc : kv.getValue()) {            Map<String, Object> docParsed = parse(doc);            String guid = (String) docParsed.getOrDefault(Constants.GUID, "");            for (GetRequest getRequest : getRequests) {                if (getRequest.getGuid().equals(guid)) {                    documents.add(new Document(doc, guid, getRequest.getSensorType(), 0L));                }            }        }    }    return documents;}
public Document metron_f5371_0(Document update, Optional<String> index) throws IOException
{    for (Map.Entry<String, List<String>> kv : BACKING_STORE.entrySet()) {        if (kv.getKey().startsWith(update.getSensorType())) {            for (Iterator<String> it = kv.getValue().iterator(); it.hasNext(); ) {                String doc = it.next();                Map<String, Object> docParsed = parse(doc);                if (docParsed.getOrDefault(Constants.GUID, "").equals(update.getGuid())) {                    it.remove();                }            }            kv.getValue().add(JSONUtils.INSTANCE.toJSON(update.getDocument(), true));        }    }    return update;}
public Map<Document, Optional<String>> metron_f5372_0(Map<Document, Optional<String>> updates) throws IOException
{    for (Map.Entry<Document, Optional<String>> update : updates.entrySet()) {        update(update.getKey(), update.getValue());    }    return updates;}
public Map<String, FieldType> metron_f5373_0(List<String> indices) throws IOException
{    Map<String, FieldType> indexColumnMetadata = new HashMap<>();    for (String index : indices) {        if (COLUMN_METADATA.containsKey(index)) {            Map<String, FieldType> columnMetadata = COLUMN_METADATA.get(index);            for (Entry entry : columnMetadata.entrySet()) {                String field = (String) entry.getKey();                FieldType type = (FieldType) entry.getValue();                if (indexColumnMetadata.containsKey(field)) {                    if (!type.equals(indexColumnMetadata.get(field))) {                        indexColumnMetadata.put(field, FieldType.OTHER);                    }                } else {                    indexColumnMetadata.put(field, type);                }            }        }    }    return indexColumnMetadata;}
public Document metron_f5374_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5375_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5376_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5377_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public static void metron_f5378_0(Map<String, Map<String, FieldType>> columnMetadata)
{    Map<String, Map<String, FieldType>> columnMetadataMap = new HashMap<>();    for (Map.Entry<String, Map<String, FieldType>> e : columnMetadata.entrySet()) {        columnMetadataMap.put(e.getKey(), Collections.unmodifiableMap(e.getValue()));    }    COLUMN_METADATA = columnMetadataMap;}
public static void metron_f5379_0(Map<String, Map<String, Long>> facetCounts)
{    Map<String, Map<String, Long>> facetCountsMap = new HashMap<>();    for (Map.Entry<String, Map<String, Long>> e : facetCounts.entrySet()) {        facetCountsMap.put(e.getKey(), Collections.unmodifiableMap(e.getValue()));    }    FACET_COUNTS = facetCountsMap;}
public static void metron_f5380_0(Map<String, List<String>> backingStore)
{    BACKING_STORE = backingStore;}
public static void metron_f5381_0()
{    BACKING_STORE.clear();    COLUMN_METADATA.clear();    FACET_COUNTS.clear();}
public SearchResponse metron_f5382_0(SearchRequest searchRequest) throws InvalidSearchException
{    return indexDao.search(searchRequest);}
public GroupResponse metron_f5383_0(GroupRequest groupRequest) throws InvalidSearchException
{    return indexDao.group(groupRequest);}
public void metron_f5385_0(IndexDao indexDao, Optional<String> threatSort)
{    this.indexDao = indexDao;    this.metaAlertRetrieveLatestDao = new InMemoryMetaAlertRetrieveLatestDao(indexDao);    Supplier<Map<String, Object>> globalConfigSupplier = () -> new HashMap<>();    MetaAlertConfig config = new MetaAlertConfig(METAALERT_INDEX, null, globalConfigSupplier) {        @Override        protected String getDefaultThreatTriageField() {            return MetaAlertConstants.THREAT_FIELD_DEFAULT;        }        @Override        protected String getDefaultSourceTypeField() {            return SENSOR_TYPE;        }    };    this.metaAlertUpdateDao = new InMemoryMetaAlertUpdateDao(indexDao, metaAlertRetrieveLatestDao, config, -1);}
protected String metron_f5386_0()
{    return MetaAlertConstants.THREAT_FIELD_DEFAULT;}
protected String metron_f5387_0()
{    return SENSOR_TYPE;}
public Document metron_f5388_0(String guid, String sensorType) throws IOException
{    return indexDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f5389_0(List<GetRequest> getRequests) throws IOException
{    return indexDao.getAllLatest(getRequests);}
public Document metron_f5390_0(Document update, Optional<String> index) throws IOException
{    return indexDao.update(update, index);}
public Map<Document, Optional<String>> metron_f5391_0(Map<Document, Optional<String>> updates)
{    throw new UnsupportedOperationException("InMemoryMetaAlertDao can't do bulk updates");}
public Map<String, FieldType> metron_f5392_0(List<String> indices) throws IOException
{    return indexDao.getColumnMetadata(indices);}
public Document metron_f5393_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5394_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5395_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5396_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Optional<Map<String, Object>> metron_f5397_0(GetRequest request) throws IOException
{    return indexDao.getLatestResult(request);}
public Document metron_f5398_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp) throws OriginalNotFoundException, IOException
{    return indexDao.patch(retrieveLatestDao, request, timestamp);}
public SearchResponse metron_f5399_0(String guid) throws InvalidSearchException
{    SearchRequest request;    try {        String replacedQuery = metaAlertsForAlertQuery.replace("${GUID}", guid);        request = JSONUtils.INSTANCE.load(replacedQuery, SearchRequest.class);    } catch (IOException e) {        throw new InvalidSearchException("Unable to process query:", e);    }    return search(request);}
public Document metron_f5400_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    return metaAlertUpdateDao.createMetaAlert(request);}
public Document metron_f5401_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.addAlertsToMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f5402_0(String metaAlertGuid, List<GetRequest> alertRequests) throws IOException
{    return metaAlertUpdateDao.removeAlertsFromMetaAlert(metaAlertGuid, alertRequests);}
public Document metron_f5403_0(String metaAlertGuid, MetaAlertStatus status) throws IOException
{    return metaAlertUpdateDao.updateMetaAlertStatus(metaAlertGuid, status);}
public static void metron_f5404_0()
{    InMemoryDao.clear();}
public Document metron_f5405_0(MetaAlertCreateRequest request) throws InvalidCreateException, IOException
{    List<GetRequest> alertRequests = request.getAlerts();    if (alertRequests.isEmpty()) {        return null;    }        Iterable<Document> alerts = indexDao.getAllLatest(alertRequests);    Document metaAlert = buildCreateDocument(alerts, request.getGroups(), MetaAlertConstants.ALERT_FIELD);    metaAlert.getDocument().put(getConfig().getSourceTypeField(), MetaAlertConstants.METAALERT_TYPE);    return metaAlert;}
public Document metron_f5406_0(Document update, Optional<String> index) throws IOException
{    return indexDao.update(update, index);}
public Document metron_f5407_0(CommentAddRemoveRequest request) throws IOException
{    return null;}
public Document metron_f5408_0(CommentAddRemoveRequest request) throws IOException
{    return null;}
public Document metron_f5409_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return null;}
public Document metron_f5410_0(CommentAddRemoveRequest request, Document latest) throws IOException
{    return null;}
public void metron_f5411_0()
{    dao = new TestLuceneMetaAlertUpdateDao();}
protected String metron_f5412_0()
{    return THREAT_FIELD_DEFAULT.replace(':', '.');}
protected String metron_f5413_0()
{    return Constants.SENSOR_TYPE;}
public Document metron_f5414_0(String guid, String sensorType)
{    return documents.get(guid);}
public Iterable<Document> metron_f5415_0(List<GetRequest> getRequests)
{    return null;}
public Document metron_f5416_0(Document update, Optional<String> index)
{    return null;}
public Document metron_f5417_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5418_0(CommentAddRemoveRequest request)
{    return null;}
public Document metron_f5419_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5420_0(CommentAddRemoveRequest request, Document latest)
{    return null;}
public Document metron_f5421_0(RetrieveLatestDao retrieveLatestDao, PatchRequest request, Optional<Long> timestamp)
{    return null;}
public Document metron_f5422_0(MetaAlertCreateRequest request)
{    return null;}
public void metron_f5423_0()
{    dao.batchUpdate(null);}
public void metron_f5424_0() throws ParseException
{    PatchRequest pr = new PatchRequest();    Map<String, Object> patch = (JSONObject) new JSONParser().parse(alertPatchRequest);    pr.setPatch(Collections.singletonList((JSONObject) ((JSONArray) patch.get("patch")).get(0)));    assertFalse(dao.isPatchAllowed(pr));}
public void metron_f5425_0() throws ParseException
{    PatchRequest pr = new PatchRequest();    Map<String, Object> patch = (JSONObject) new JSONParser().parse(statusPatchRequest);    pr.setPatch(Collections.singletonList((JSONObject) ((JSONArray) patch.get("patch")).get(0)));    assertFalse(dao.isPatchAllowed(pr));}
public void metron_f5426_0() throws ParseException
{    PatchRequest pr = new PatchRequest();    Map<String, Object> patch = (JSONObject) new JSONParser().parse(namePatchRequest);    pr.setPatch(Collections.singletonList((JSONObject) ((JSONArray) patch.get("patch")).get(0)));    assertTrue(dao.isPatchAllowed(pr));}
public void metron_f5427_0() throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<>();    Document document = new Document(new HashMap<>(), "guid", "sensor", 0L);    updates.put(document, Optional.empty());    dao.update(updates);    verify(indexDao, times(1)).update(document, Optional.empty());}
public void metron_f5428_0() throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<>();    Document documentOne = new Document(new HashMap<>(), "guid", "sensor", 0L);    updates.put(documentOne, Optional.empty());    Document documentTwo = new Document(new HashMap<>(), "guid2", "sensor", 0L);    updates.put(documentTwo, Optional.empty());    dao.update(updates);    verify(indexDao, times(1)).batchUpdate(updates);}
public void metron_f5429_0()
{    Document metaDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metaDoc.getDocument().put(ALERT_FIELD, getRawMaps(buildChildAlerts(1, METAALERT_GUID, null)));    Map<Document, Optional<String>> actual = dao.buildAddAlertToMetaAlertUpdates(metaDoc, new ArrayList<>());    assertEquals(0, actual.size());}
public void metron_f5430_0()
{    List<Document> alerts = buildChildAlerts(1, METAALERT_GUID, null);    Document metaDoc = buildMetaAlert(alerts);    List<Document> newAlerts = buildChildAlerts(2, null, "new_");    Map<Document, Optional<String>> actual = dao.buildAddAlertToMetaAlertUpdates(metaDoc, newAlerts);    assertEquals(3, actual.size());    HashMap<String, Object> expectedExistingAlert = new HashMap<>();    expectedExistingAlert.put(Constants.GUID, "child_0");    expectedExistingAlert.put(METAALERT_FIELD, Collections.singletonList(METAALERT_GUID));    expectedExistingAlert.put(THREAT_FIELD_DEFAULT, 0.0f);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(expectedExistingAlert);    expectedAlerts.addAll(getRawMaps(newAlerts));    List<Double> scores = new ArrayList<>();    scores.add(0.0d);    scores.add(0.0d);    scores.add(0.0d);    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedMetaAlertMap.putAll(new MetaScores(scores).getMetaScores());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    expected.put(newAlerts.get(0), Optional.empty());    expected.put(newAlerts.get(1), Optional.empty());    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5431_0() throws IOException
{    List<Document> alerts = buildChildAlerts(3, METAALERT_GUID, null);    Document metaDoc = buildMetaAlert(alerts);    List<Document> deletedAlerts = new ArrayList<>();    deletedAlerts.add(alerts.get(0));    deletedAlerts.add(alerts.get(2));    Map<Document, Optional<String>> actual = dao.buildRemoveAlertsFromMetaAlert(metaDoc, deletedAlerts);    assertEquals(3, actual.size());    Map<String, Object> expectedDeletedAlert = new HashMap<>();    expectedDeletedAlert.put(Constants.GUID, "child_0");    expectedDeletedAlert.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedDeletedAlert.put(MetaAlertConstants.METAALERT_FIELD, new ArrayList<>());    Document expectedDeletedDocument = new Document(expectedDeletedAlert, "child_0", "test", 0L);    Map<String, Object> expectedDeletedAlert3 = new HashMap<>();    expectedDeletedAlert3.put(Constants.GUID, "child_2");    expectedDeletedAlert3.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedDeletedAlert3.put(MetaAlertConstants.METAALERT_FIELD, new ArrayList<>());    Document expectedDeletedDocument2 = new Document(expectedDeletedAlert3, "child_2", "test", 0L);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(alerts.get(1).getDocument());    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(THREAT_FIELD_DEFAULT, 0.0f);    expectedMetaAlertMap.putAll(new MetaScores(Collections.singletonList(0.0d)).getMetaScores());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedDeletedDocument, Optional.empty());    expected.put(expectedDeletedDocument2, Optional.empty());    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5432_0() throws Exception
{    thrown.expect(IllegalStateException.class);    thrown.expectMessage("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.");    List<Document> alerts = buildChildAlerts(1, METAALERT_GUID, null);    Document metaDoc = buildMetaAlert(alerts);    dao.buildRemoveAlertsFromMetaAlert(metaDoc, alerts);}
public void metron_f5433_0()
{    Document empty = new Document(new HashMap<>(), "empty", METAALERT_TYPE, 0L);    boolean actual = dao.removeAlertsFromMetaAlert(empty, Collections.singletonList("child"));    assertFalse(actual);}
public void metron_f5434_0()
{    Document metaDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metaDoc.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    metaDoc.getDocument().put(ALERT_FIELD, new HashMap<String, Object>() {        {            put(Constants.GUID, "child_0");        }    });    boolean actual = dao.removeAlertsFromMetaAlert(metaDoc, new ArrayList<>());    assertFalse(actual);}
public void metron_f5435_0()
{    Document metaDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metaDoc.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    List<Map<String, Object>> alerts = new ArrayList<>();    alerts.add(new HashMap<String, Object>() {        {            put(Constants.GUID, "child_0");        }    });    metaDoc.getDocument().put(ALERT_FIELD, alerts);    boolean actual = dao.removeAlertsFromMetaAlert(metaDoc, Collections.singletonList("child_0"));    Document expected = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    expected.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    expected.getDocument().put(ALERT_FIELD, new ArrayList<>());    assertTrue(actual);    assertEquals(expected, metaDoc);}
public void metron_f5436_0()
{    List<Document> alerts = buildChildAlerts(2, METAALERT_GUID, null);    Map<String, Object> metaAlertMap = new HashMap<>();    metaAlertMap.put(ALERT_FIELD, getRawMaps(alerts));    metaAlertMap.put(Constants.GUID, METAALERT_GUID);    metaAlertMap.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());    Document metaDoc = new Document(metaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> actual = dao.buildStatusChangeUpdates(metaDoc, alerts, MetaAlertStatus.INACTIVE);    assertEquals(3, actual.size());    List<Document> expectedDeletedAlerts = buildChildAlerts(2, null, null);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(alerts.get(0).getDocument());    expectedAlerts.add(alerts.get(1).getDocument());    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(STATUS_FIELD, MetaAlertStatus.INACTIVE.getStatusString());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    expected.put(expectedDeletedAlerts.get(0), Optional.empty());    expected.put(expectedDeletedAlerts.get(1), Optional.empty());    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5437_0()
{    List<Document> alerts = buildChildAlerts(2, METAALERT_GUID, null);    Map<String, Object> metaAlertMap = new HashMap<>();    metaAlertMap.put(ALERT_FIELD, getRawMaps(alerts));    metaAlertMap.put(Constants.GUID, METAALERT_GUID);    metaAlertMap.put(STATUS_FIELD, MetaAlertStatus.INACTIVE.getStatusString());    Document metaDoc = new Document(metaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> actual = dao.buildStatusChangeUpdates(metaDoc, alerts, MetaAlertStatus.ACTIVE);    List<Map<String, Object>> expectedAlerts = new ArrayList<>();    expectedAlerts.add(alerts.get(0).getDocument());    expectedAlerts.add(alerts.get(1).getDocument());    Map<String, Object> expectedMetaAlertMap = new HashMap<>();    expectedMetaAlertMap.put(ALERT_FIELD, expectedAlerts);    expectedMetaAlertMap.put(Constants.GUID, METAALERT_GUID);    expectedMetaAlertMap.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());    Document expectedMetaAlertDoc = new Document(expectedMetaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);    Map<Document, Optional<String>> expected = new HashMap<>();    expected.put(expectedMetaAlertDoc, Optional.of(METAALERT_INDEX));    assertTrue(updatesMapEquals(expected, actual));}
public void metron_f5438_0()
{    Document metDoc = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    metDoc.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    List<Document> alerts = buildChildAlerts(3, null, null);    metDoc.getDocument().put(ALERT_FIELD, getRawMaps(alerts));    List<String> removeGuids = new ArrayList<>();    removeGuids.add("child_0");    removeGuids.add("child_2");    removeGuids.add("child_doesn't_exist");    boolean actual = dao.removeAlertsFromMetaAlert(metDoc, removeGuids);        Document expected = new Document(new HashMap<>(), METAALERT_GUID, METAALERT_TYPE, 0L);    expected.getDocument().put(STATUS_FIELD, ACTIVE.getStatusString());    List<Map<String, Object>> alertsExpected = new ArrayList<>();    alertsExpected.add(new HashMap<String, Object>() {        {            put(METAALERT_FIELD, new ArrayList<>());            put(Constants.GUID, "child_1");            put(THREAT_FIELD_DEFAULT, 0.0f);        }    });    expected.getDocument().put(ALERT_FIELD, alertsExpected);    assertEquals(expected, metDoc);    assertTrue(actual);}
public void metron_f5439_0() throws IOException
{    dao.removeAlertsFromMetaAlert(INACTIVE.getStatusString(), null);}
public void metron_f5440_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    metaAlertGuids.add("metaalert2");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    Document expected = new Document(new HashMap<>(), "alert", "test", 0L);    List<String> expectedMetaAlertGuids = new ArrayList<>();    expectedMetaAlertGuids.add("metaalert2");    expected.getDocument().put(METAALERT_FIELD, expectedMetaAlertGuids);    boolean actual = dao.removeMetaAlertFromAlert("metaalert1", alert);    assertTrue(actual);    assertEquals(expected, alert);}
public void metron_f5441_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    metaAlertGuids.add("metaalert2");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    boolean actual = dao.removeMetaAlertFromAlert("metaalert3", alert);    assertFalse(actual);}
public void metron_f5442_0()
{    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, new ArrayList<>());    Document alert = new Document(alertFields, "alert", "test", 0L);    Document expected = new Document(new HashMap<>(), "alert", "test", 0L);    List<String> expectedMetaAlertGuids = new ArrayList<>();    expectedMetaAlertGuids.add("metaalert1");    expected.getDocument().put(METAALERT_FIELD, expectedMetaAlertGuids);    boolean actual = dao.addMetaAlertToAlert("metaalert1", alert);    assertTrue(actual);    assertEquals(expected, alert);}
public void metron_f5443_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    Document expected = new Document(new HashMap<>(), "alert", "test", 0L);    List<String> expectedMetaAlertGuids = new ArrayList<>();    expectedMetaAlertGuids.add("metaalert1");    expectedMetaAlertGuids.add("metaalert2");    expected.getDocument().put(METAALERT_FIELD, expectedMetaAlertGuids);    boolean actual = dao.addMetaAlertToAlert("metaalert2", alert);    assertTrue(actual);    assertEquals(expected, alert);}
public void metron_f5444_0()
{    List<String> metaAlertGuids = new ArrayList<>();    metaAlertGuids.add("metaalert1");    Map<String, Object> alertFields = new HashMap<>();    alertFields.put(METAALERT_FIELD, metaAlertGuids);    Document alert = new Document(alertFields, "alert", "test", 0L);    boolean actual = dao.addMetaAlertToAlert("metaalert1", alert);    assertFalse(actual);}
public void metron_f5445_0()
{    List<String> groups = new ArrayList<>();    groups.add("group_one");    groups.add("group_two");        Map<String, Object> alertOne = new HashMap<>();    alertOne.put(Constants.GUID, "alert_one");    alertOne.put(THREAT_FIELD_DEFAULT, 10.0d);    List<Document> alerts = new ArrayList<Document>() {        {            add(new Document(alertOne, "", "", 0L));        }    };        Document actual = dao.buildCreateDocument(alerts, groups, ALERT_FIELD);    ArrayList<Map<String, Object>> alertList = new ArrayList<>();    alertList.add(alertOne);    Map<String, Object> actualDocument = actual.getDocument();    assertEquals(MetaAlertStatus.ACTIVE.getStatusString(), actualDocument.get(STATUS_FIELD));    assertEquals(alertList, actualDocument.get(ALERT_FIELD));    assertEquals(groups, actualDocument.get(GROUPS_FIELD));        UUID.fromString((String) actualDocument.get(Constants.GUID));}
public void metron_f5446_0()
{    List<String> groups = new ArrayList<>();    groups.add("group_one");    groups.add("group_two");        Map<String, Object> alertOne = new HashMap<>();    alertOne.put(Constants.GUID, "alert_one");    alertOne.put(THREAT_FIELD_DEFAULT, 10.0d);        Map<String, Object> alertTwo = new HashMap<>();    alertTwo.put(Constants.GUID, "alert_one");    alertTwo.put(THREAT_FIELD_DEFAULT, 5.0d);    List<Document> alerts = new ArrayList<>();    alerts.add(new Document(alertOne, "", "", 0L));    alerts.add(new Document(alertTwo, "", "", 0L));        Document actual = dao.buildCreateDocument(alerts, groups, ALERT_FIELD);    ArrayList<Map<String, Object>> alertList = new ArrayList<>();    alertList.add(alertOne);    alertList.add(alertTwo);    Map<String, Object> actualDocument = actual.getDocument();    assertNotNull(actualDocument.get(Fields.TIMESTAMP.getName()));    assertEquals(alertList, actualDocument.get(ALERT_FIELD));    assertEquals(groups, actualDocument.get(GROUPS_FIELD));        UUID.fromString((String) actualDocument.get(Constants.GUID));}
public void metron_f5447_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Unable to add alerts to meta alert.  Meta alert with guid some_guid cannot be found.");    dao.addAlertsToMetaAlert("some_guid", new ArrayList<>());}
public void metron_f5448_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Unable to remove alerts from meta alert.  Meta alert with guid some_guid cannot be found.");    dao.removeAlertsFromMetaAlert("some_guid", new ArrayList<>());}
public void metron_f5449_0() throws Exception
{    thrown.expect(IOException.class);    thrown.expectMessage("Unable to update meta alert status.  Meta alert with guid some_guid cannot be found.");    dao.updateMetaAlertStatus("some_guid", MetaAlertStatus.INACTIVE);}
protected boolean metron_f5450_0(Map<Document, Optional<String>> expected, Map<Document, Optional<String>> actual)
{    Entry<Document, Optional<String>> expectedMetaEntry;    Entry<Document, Optional<String>> actualMetaEntry;    expectedMetaEntry = findMetaEntry(expected);    actualMetaEntry = findMetaEntry(actual);        if (!metaAlertDocumentEquals(expectedMetaEntry.getKey(), actualMetaEntry.getKey())) {        return false;    } else {                return removeMetaEntry(expected).equals(removeMetaEntry(actual));    }}
protected Entry<Document, Optional<String>> metron_f5451_0(Map<Document, Optional<String>> expected)
{    for (Entry<Document, Optional<String>> entry : expected.entrySet()) {        if (entry.getKey().getSensorType().equals(METAALERT_TYPE)) {            return entry;        }    }    return null;}
protected Map<Document, Optional<String>> metron_f5452_0(Map<Document, Optional<String>> updates)
{    Map<Document, Optional<String>> filteredUpdates = new HashMap<>();    for (Entry<Document, Optional<String>> entry : updates.entrySet()) {        if (!(entry.getKey().getSensorType().equals(METAALERT_TYPE))) {            filteredUpdates.put(entry.getKey(), entry.getValue());        }    }    return filteredUpdates;}
private boolean metron_f5453_0(Document expected, Document actual)
{    if (!expected.getGuid().equals(actual.getGuid())) {        return false;    }    if (!expected.getSensorType().equals(actual.getSensorType())) {        return false;    }    if (!expected.getTimestamp().equals(actual.getTimestamp())) {        return false;    }        Map<String, Object> expectedDocument = expected.getDocument();    Map<String, Object> actualDocument = actual.getDocument();    if (expectedDocument.size() != actualDocument.size()) {        return false;    }    for (Entry<String, Object> entry : expectedDocument.entrySet()) {        Object value = entry.getValue();        Object actualValue = actual.getDocument().get(entry.getKey());        if (value instanceof Float) {            if (!MathUtils.equals((Float) value, (Float) actualValue, EPS)) {                return false;            }        } else if (value instanceof Double) {            if (!MathUtils.equals((Double) value, (Double) actualValue, EPS)) {                return false;            }        } else {            if (!value.equals(actual.getDocument().get(entry.getKey()))) {                return false;            }        }    }    return true;}
protected List<Document> metron_f5454_0(int num, String parent, String guidPrefix)
{    String prefix = guidPrefix != null ? guidPrefix : DEFAULT_PREFIX;    List<Document> alerts = new ArrayList<>();    for (int i = 0; i < num; i++) {        HashMap<String, Object> fields = new HashMap<>();        fields.put(Constants.GUID, prefix + i);        fields.put(THREAT_FIELD_DEFAULT, 0.0f);        if (parent != null) {            fields.put(METAALERT_FIELD, Collections.singletonList(parent));        } else {            fields.put(METAALERT_FIELD, new ArrayList<>());        }        alerts.add(new Document(fields, prefix + i, "test", 0L));    }    return alerts;}
protected List<Map<String, Object>> metron_f5455_0(List<Document> documents)
{    List<Map<String, Object>> rawMaps = new ArrayList<>();    for (Document document : documents) {        rawMaps.add(document.getDocument());    }    return rawMaps;}
protected Document metron_f5456_0(List<Document> alerts)
{    Map<String, Object> metaAlertMap = new HashMap<>();    metaAlertMap.put(ALERT_FIELD, getRawMaps(alerts));    metaAlertMap.put(Constants.GUID, METAALERT_GUID);    return new Document(metaAlertMap, METAALERT_GUID, METAALERT_TYPE, 0L);}
public void metron_f5457_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(3);    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        List<Map<String, Object>> metaAlerts = buildMetaAlerts(12, MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    metaAlerts.add(buildMetaAlert("meta_active_12", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(2)))));    metaAlerts.add(buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(2)))));        addRecords(metaAlerts, getMetaAlertIndex(), METAALERT_TYPE);        List<GetRequest> createdDocs = metaAlerts.stream().map(metaAlert -> new GetRequest((String) metaAlert.get(Constants.GUID), METAALERT_TYPE)).collect(Collectors.toList());    createdDocs.addAll(alerts.stream().map(alert -> new GetRequest((String) alert.get(Constants.GUID), SENSOR_NAME)).collect(Collectors.toList()));    findCreatedDocs(createdDocs);    {                SearchResponse searchResponse0 = metaDao.getAllMetaAlertsForAlert("message_0");        List<SearchResult> searchResults0 = searchResponse0.getResults();        Assert.assertEquals(13, searchResults0.size());        Set<Map<String, Object>> resultSet = new HashSet<>();        Iterables.addAll(resultSet, Iterables.transform(searchResults0, r -> r.getSource()));        StringBuffer reason = new StringBuffer("Unable to find " + metaAlerts.get(0) + "\n");        reason.append(Joiner.on("\n").join(resultSet));        Assert.assertTrue(reason.toString(), resultSet.contains(metaAlerts.get(0)));                SearchResponse searchResponse1 = metaDao.getAllMetaAlertsForAlert("message_1");        List<SearchResult> searchResults1 = searchResponse1.getResults();        Assert.assertEquals(0, searchResults1.size());                SearchResponse searchResponse2 = metaDao.getAllMetaAlertsForAlert("message_2");        List<SearchResult> searchResults2 = searchResponse2.getResults();        Assert.assertEquals(1, searchResults2.size());        Assert.assertEquals(metaAlerts.get(12), searchResults2.get(0).getSource());    }}
public void metron_f5458_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, "meta_active_0");    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        List<Map<String, Object>> metaAlerts = buildMetaAlerts(1, MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));        addRecords(metaAlerts, getMetaAlertIndex(), METAALERT_TYPE);        List<GetRequest> createdDocs = metaAlerts.stream().map(metaAlert -> new GetRequest((String) metaAlert.get(Constants.GUID), METAALERT_TYPE)).collect(Collectors.toList());    createdDocs.addAll(alerts.stream().map(alert -> new GetRequest((String) alert.get(Constants.GUID), SENSOR_NAME)).collect(Collectors.toList()));    findCreatedDocs(createdDocs);        SortField sf = new SortField();    sf.setField(getThreatTriageField());    sf.setSortOrder(SortOrder.DESC.getSortOrder());    SearchRequest sr = new SearchRequest();    sr.setQuery("*:*");    sr.setSize(5);    sr.setIndices(Arrays.asList(getTestIndexName(), METAALERT_TYPE));    sr.setSort(Collections.singletonList(sf));    SearchResponse result = metaDao.search(sr);    List<SearchResult> results = result.getResults();    Assert.assertEquals(2, results.size());    Assert.assertEquals("meta_active_0", results.get((0)).getSource().get(Constants.GUID));    Assert.assertEquals("message_1", results.get((1)).getSource().get(Constants.GUID));        SortField sfAsc = new SortField();    sfAsc.setField(getThreatTriageField());    sfAsc.setSortOrder(SortOrder.ASC.getSortOrder());    SearchRequest srAsc = new SearchRequest();    srAsc.setQuery("*:*");    srAsc.setSize(2);    srAsc.setIndices(Arrays.asList(getTestIndexName(), METAALERT_TYPE));    srAsc.setSort(Collections.singletonList(sfAsc));    result = metaDao.search(srAsc);    results = result.getResults();    Assert.assertEquals("message_1", results.get((0)).getSource().get(Constants.GUID));    Assert.assertEquals("meta_active_0", results.get((1)).getSource().get(Constants.GUID));    Assert.assertEquals(2, results.size());}
public void metron_f5459_0() throws Exception
{    try {        metaDao.getAllMetaAlertsForAlert("");        Assert.fail("An exception should be thrown for empty guid");    } catch (InvalidSearchException ise) {        Assert.assertEquals("Guid cannot be empty", ise.getMessage());    }}
public void metron_f5460_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(3);    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME)));    {        MetaAlertCreateRequest metaAlertCreateRequest = new MetaAlertCreateRequest() {            {                setAlerts(new ArrayList<GetRequest>() {                    {                        add(new GetRequest("message_1", SENSOR_NAME));                        add(new GetRequest("message_2", SENSOR_NAME, getTestIndexFullName()));                    }                });                setGroups(Collections.singletonList("group"));            }        };        Document actualMetaAlert = metaDao.createMetaAlert(metaAlertCreateRequest);                Map<String, Object> expectedMetaAlert = new HashMap<>();        expectedMetaAlert.put(Constants.GUID, actualMetaAlert.getGuid());        expectedMetaAlert.put(getSourceTypeField(), METAALERT_TYPE);        expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());                @SuppressWarnings("unchecked")        List<Map<String, Object>> metaAlertAlerts = new ArrayList<>();                Map<String, Object> expectedAlert1 = alerts.get(1);        expectedAlert1.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));        metaAlertAlerts.add(expectedAlert1);        Map<String, Object> expectedAlert2 = alerts.get(2);        expectedAlert2.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));        metaAlertAlerts.add(expectedAlert2);        expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);                expectedMetaAlert.put("average", 1.5d);        expectedMetaAlert.put("min", 1.0d);        expectedMetaAlert.put("median", 1.5d);        expectedMetaAlert.put("max", 2.0d);        expectedMetaAlert.put("count", 2);        expectedMetaAlert.put("sum", 3.0d);        expectedMetaAlert.put(getThreatTriageField(), 3.0d);        {                        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());            findCreatedDoc(actualMetaAlert.getGuid(), METAALERT_TYPE);        }        {                        Document alert = metaDao.getLatest("message_0", SENSOR_NAME);            Assert.assertEquals(4, alert.getDocument().size());            Assert.assertNull(alert.getDocument().get(METAALERT_FIELD));        }        {                        Map<String, Object> expectedAlert = new HashMap<>(alerts.get(1));            expectedAlert.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));            findUpdatedDoc(expectedAlert, "message_1", SENSOR_NAME);        }        {                        Map<String, Object> expectedAlert = new HashMap<>(alerts.get(2));            expectedAlert.put(METAALERT_FIELD, Collections.singletonList(actualMetaAlert.getGuid()));            findUpdatedDoc(expectedAlert, "message_2", SENSOR_NAME);        }    }}
public void metron_f5461_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(4);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        @SuppressWarnings("unchecked")    List<Map<String, Object>> metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));        Map<String, Object> expectedAlert1 = alerts.get(1);    expectedAlert1.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    metaAlertAlerts.add(expectedAlert1);    Map<String, Object> expectedAlert2 = alerts.get(2);    expectedAlert2.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    metaAlertAlerts.add(expectedAlert2);    expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 1.0d);    expectedMetaAlert.put("min", 0.0d);    expectedMetaAlert.put("median", 1.0d);    expectedMetaAlert.put("max", 2.0d);    expectedMetaAlert.put("count", 3);    expectedMetaAlert.put("sum", 3.0d);    expectedMetaAlert.put(getThreatTriageField(), 3.0d);    {                Document actualMetaAlert = metaDao.addAlertsToMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                Document actualMetaAlert = metaDao.addAlertsToMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                metaAlertAlerts = (List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD);        Map<String, Object> expectedAlert3 = alerts.get(3);        expectedAlert3.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));        metaAlertAlerts.add(expectedAlert3);        expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 1.5d);        expectedMetaAlert.put("min", 0.0d);        expectedMetaAlert.put("median", 1.5d);        expectedMetaAlert.put("max", 3.0d);        expectedMetaAlert.put("count", 4);        expectedMetaAlert.put("sum", 6.0d);        expectedMetaAlert.put(getThreatTriageField(), 6.0d);        Document actualMetaAlert = metaDao.addAlertsToMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }}
public void metron_f5462_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(4);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    alerts.get(2).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    alerts.get(3).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1), alerts.get(2), alerts.get(3))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME), new GetRequest("message_3", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        List<Map<String, Object>> metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));    metaAlertAlerts.remove(0);    metaAlertAlerts.remove(0);    expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 2.5d);    expectedMetaAlert.put("min", 2.0d);    expectedMetaAlert.put("median", 2.5d);    expectedMetaAlert.put("max", 3.0d);    expectedMetaAlert.put("count", 2);    expectedMetaAlert.put("sum", 5.0d);    expectedMetaAlert.put(getThreatTriageField(), 5.0d);    {                Document actualMetaAlert = metaDao.removeAlertsFromMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                Document actualMetaAlert = metaDao.removeAlertsFromMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));        metaAlertAlerts.remove(0);        expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        expectedMetaAlert.put("average", 3.0d);        expectedMetaAlert.put("min", 3.0d);        expectedMetaAlert.put("median", 3.0d);        expectedMetaAlert.put("max", 3.0d);        expectedMetaAlert.put("count", 1);        expectedMetaAlert.put("sum", 3.0d);        expectedMetaAlert.put(getThreatTriageField(), 3.0d);        Document actualMetaAlert = metaDao.removeAlertsFromMetaAlert("meta_alert", Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_2", SENSOR_NAME)));        assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);    }    {                metaAlertAlerts = new ArrayList<>((List<Map<String, Object>>) expectedMetaAlert.get(ALERT_FIELD));        metaAlertAlerts.remove(0);        if (isEmptyMetaAlertList()) {            expectedMetaAlert.put(ALERT_FIELD, metaAlertAlerts);        } else {            expectedMetaAlert.remove(ALERT_FIELD);        }        expectedMetaAlert.put("average", 0.0d);        expectedMetaAlert.put("count", 0);        expectedMetaAlert.put("sum", 0.0d);        expectedMetaAlert.put(getThreatTriageField(), 0.0d);                if (isFiniteDoubleOnly()) {            expectedMetaAlert.put("min", String.valueOf(Double.POSITIVE_INFINITY));            expectedMetaAlert.put("median", String.valueOf(Double.NaN));            expectedMetaAlert.put("max", String.valueOf(Double.NEGATIVE_INFINITY));        } else {            expectedMetaAlert.put("min", Double.POSITIVE_INFINITY);            expectedMetaAlert.put("median", Double.NaN);            expectedMetaAlert.put("max", Double.NEGATIVE_INFINITY);        }                try {            metaDao.removeAlertsFromMetaAlert("meta_alert", Collections.singletonList(new GetRequest("message_3", SENSOR_NAME)));            Assert.fail("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.");        } catch (IllegalStateException ise) {            Assert.assertEquals("Removing these alerts will result in an empty meta alert.  Empty meta alerts are not allowed.", ise.getMessage());        }    }}
public void metron_f5463_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.INACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));    {                try {            metaDao.addAlertsToMetaAlert("meta_alert", Collections.singletonList(new GetRequest("message_1", SENSOR_NAME)));            Assert.fail("Adding alerts to an inactive meta alert should throw an exception");        } catch (IllegalStateException ise) {            Assert.assertEquals("Adding alerts to an INACTIVE meta alert is not allowed", ise.getMessage());        }    }    {                try {            metaDao.removeAlertsFromMetaAlert("meta_alert", Collections.singletonList(new GetRequest("message_0", SENSOR_NAME)));            Assert.fail("Removing alerts from an inactive meta alert should throw an exception");        } catch (IllegalStateException ise) {            Assert.assertEquals("Removing alerts from an INACTIVE meta alert is not allowed", ise.getMessage());        }    }}
public void metron_f5464_0() throws Exception
{    int numChildAlerts = 25;    int numUnrelatedAlerts = 25;    int totalAlerts = numChildAlerts + numUnrelatedAlerts;        List<Map<String, Object>> alerts = buildAlerts(totalAlerts);    List<Map<String, Object>> childAlerts = alerts.subList(0, numChildAlerts);    List<Map<String, Object>> unrelatedAlerts = alerts.subList(numChildAlerts, totalAlerts);    for (Map<String, Object> alert : childAlerts) {        alert.put(METAALERT_FIELD, Collections.singletonList("meta_alert"));    }    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(childAlerts));        addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);    List<GetRequest> requests = new ArrayList<>();    for (int i = 0; i < numChildAlerts; ++i) {        requests.add(new GetRequest("message_" + i, SENSOR_NAME));    }    requests.add(new GetRequest("meta_alert", METAALERT_TYPE));        findCreatedDocs(requests);    {                Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.INACTIVE.getStatusString());        Document actualMetaAlert = metaDao.updateMetaAlertStatus("meta_alert", MetaAlertStatus.INACTIVE);        Assert.assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);        for (int i = 0; i < numChildAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(childAlerts.get(i));            setEmptiedMetaAlertField(expectedAlert);            findUpdatedDoc(expectedAlert, "message_" + i, SENSOR_NAME);        }                for (int i = 0; i < numUnrelatedAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(unrelatedAlerts.get(i));                        findUpdatedDoc(expectedAlert, "message_" + (i + numChildAlerts), SENSOR_NAME);        }    }    {                Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);        expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());        Document actualMetaAlert = metaDao.updateMetaAlertStatus("meta_alert", MetaAlertStatus.ACTIVE);        Assert.assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());        findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);        for (int i = 0; i < numChildAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(alerts.get(i));            expectedAlert.put("metaalerts", Collections.singletonList("meta_alert"));            findUpdatedDoc(expectedAlert, "message_" + i, SENSOR_NAME);        }                for (int i = 0; i < numUnrelatedAlerts; ++i) {            Map<String, Object> expectedAlert = new HashMap<>(unrelatedAlerts.get(i));                        findUpdatedDoc(expectedAlert, "message_" + (i + numChildAlerts), SENSOR_NAME);        }    }    {        {                        Map<String, Object> expectedMetaAlert = new HashMap<>(metaAlert);            expectedMetaAlert.put(STATUS_FIELD, MetaAlertStatus.ACTIVE.getStatusString());            Document actualMetaAlert = metaDao.updateMetaAlertStatus("meta_alert", MetaAlertStatus.ACTIVE);            Assert.assertEquals(expectedMetaAlert, actualMetaAlert.getDocument());            findUpdatedDoc(expectedMetaAlert, "meta_alert", METAALERT_TYPE);            for (int i = 0; i < numChildAlerts; ++i) {                Map<String, Object> expectedAlert = new HashMap<>(alerts.get(i));                expectedAlert.put("metaalerts", Collections.singletonList("meta_alert"));                findUpdatedDoc(expectedAlert, "message_" + i, SENSOR_NAME);            }                        for (int i = 0; i < numUnrelatedAlerts; ++i) {                Map<String, Object> expectedAlert = new HashMap<>(unrelatedAlerts.get(i));                                findUpdatedDoc(expectedAlert, "message_" + (i + numChildAlerts), SENSOR_NAME);            }        }    }}
public void metron_f5465_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(1);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(0).put("ip_src_addr", "192.168.1.1");    alerts.get(0).put("ip_src_port", 8010);        Map<String, Object> activeMetaAlert = buildMetaAlert("meta_active", MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));    Map<String, Object> inactiveMetaAlert = buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.empty());        addRecords(Arrays.asList(activeMetaAlert, inactiveMetaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("meta_active", METAALERT_TYPE), new GetRequest("meta_inactive", METAALERT_TYPE)));    SearchResponse searchResponse = metaDao.search(new SearchRequest() {        {            setQuery("*:*");            setIndices(Collections.singletonList(METAALERT_TYPE));            setFrom(0);            setSize(5);            setSort(Collections.singletonList(new SortField() {                {                    setField(Constants.GUID);                }            }));        }    });        Assert.assertEquals(1, searchResponse.getTotal());    Assert.assertEquals(MetaAlertStatus.ACTIVE.getStatusString(), searchResponse.getResults().get(0).getSource().get(STATUS_FIELD));}
public void metron_f5466_0() throws Exception
{    final String guid = "meta_alert";    setupTypings();        SortField sortField = new SortField();    sortField.setField("alert_status");    sortField.setSortOrder("asc");        Assert.assertEquals(0, searchForSortedMetaAlerts(sortField).getTotal());        createMetaAlert(guid);    Assert.assertEquals(1, searchForSortedMetaAlerts(sortField).getTotal());        escalateMetaAlert(guid);    Assert.assertEquals(1, searchForSortedMetaAlerts(sortField).getTotal());}
private Map<String, Object> metron_f5467_0(String guid) throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList(guid));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList(guid));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert(guid, MetaAlertStatus.ACTIVE, Optional.of(alerts));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));    return metaAlert;}
private void metron_f5468_0(String guid) throws Exception
{        Map<String, Object> patch = new HashMap<>();    patch.put("op", "add");    patch.put("path", "/alert_status");    patch.put("value", "escalate");        PatchRequest patchRequest = new PatchRequest();    patchRequest.setGuid(guid);    patchRequest.setIndex(getMetaAlertIndex());    patchRequest.setSensorType(METAALERT_TYPE);    patchRequest.setPatch(Collections.singletonList(patch));    metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        assertEventually(() -> {        Document updated = metaDao.getLatest(guid, METAALERT_TYPE);        Assert.assertEquals("escalate", updated.getDocument().get("alert_status"));    });}
private SearchResponse metron_f5469_0(SortField sortBy) throws InvalidSearchException
{    SearchRequest searchRequest = new SearchRequest();    searchRequest.setFrom(0);    searchRequest.setSize(10);    searchRequest.setIndices(Arrays.asList(getTestIndexName(), METAALERT_TYPE));    searchRequest.setQuery("*:*");    searchRequest.setSort(Collections.singletonList(sortBy));    return metaDao.search(searchRequest);}
public void metron_f5470_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(0).put("ip_src_addr", "192.168.1.1");    alerts.get(0).put("score", 1);    alerts.get(1).put("ip_src_addr", "192.168.1.1");    alerts.get(1).put("score", 10);    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        setupTypings();            findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME)));        Group searchGroup = new Group();    searchGroup.setField("ip_src_addr");    List<Group> groupList = new ArrayList<>();    groupList.add(searchGroup);    GroupResponse groupResponse = metaDao.group(new GroupRequest() {        {            setQuery("ip_src_addr:192.168.1.1");            setIndices(queryIndices);            setScoreField("score");            setGroups(groupList);        }    });        GroupResult result = groupResponse.getGroupResults().get(0);    Assert.assertEquals(1, result.getTotal());    Assert.assertEquals("192.168.1.1", result.getKey());        Assert.assertEquals(10.0d, result.getScore(), 0.0d);}
public void metron_f5471_0() throws Exception
{    final String expectedFieldValue = "metron";    {                List<Map<String, Object>> alerts = buildAlerts(2);        alerts.get(0).put(METAALERT_FIELD, Arrays.asList("meta_active", "meta_inactive"));        addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);                Map<String, Object> activeMetaAlert = buildMetaAlert("meta_active", MetaAlertStatus.ACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));                Map<String, Object> inactiveMetaAlert = buildMetaAlert("meta_inactive", MetaAlertStatus.INACTIVE, Optional.of(Collections.singletonList(alerts.get(0))));                addRecords(Arrays.asList(activeMetaAlert, inactiveMetaAlert), getMetaAlertIndex(), METAALERT_TYPE);                findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_active", METAALERT_TYPE), new GetRequest("meta_inactive", METAALERT_TYPE)));    }    {                Document message0 = metaDao.getLatest("message_0", SENSOR_NAME);        message0.getDocument().put(NEW_FIELD, expectedFieldValue);        message0.getDocument().put(THREAT_FIELD_DEFAULT, 10.0d);        metaDao.update(message0, Optional.of(getTestIndexFullName()));    }        assertEventually(() -> {        Document message0 = metaDao.getLatest("message_0", SENSOR_NAME);        Assert.assertNotNull(message0);        Assert.assertEquals(expectedFieldValue, message0.getDocument().get(NEW_FIELD));    });        assertEventually(() -> {        Document active = metaDao.getLatest("meta_active", METAALERT_TYPE);        Object value = active.getDocument().get(ALERT_FIELD);        List<Map<String, Object>> children = List.class.cast(value);        Assert.assertNotNull(children);        Assert.assertEquals(1, children.size());        Assert.assertEquals(expectedFieldValue, children.get(0).get(NEW_FIELD));    });        assertEventually(() -> {        Document inactive = metaDao.getLatest("meta_inactive", METAALERT_TYPE);        Object value = inactive.getDocument().get(ALERT_FIELD);        List<Map<String, Object>> children = List.class.cast(value);        Assert.assertNotNull(children);        Assert.assertEquals(1, children.size());        Assert.assertFalse(children.get(0).containsKey(NEW_FIELD));    });}
public void metron_f5472_0() throws Exception
{    Document metaAlert = new Document(new HashMap<>(), "meta_alert", METAALERT_TYPE, 0L);    try {                metaDao.update(metaAlert, Optional.empty());        Assert.fail("Direct meta alert update should throw an exception");    } catch (UnsupportedOperationException uoe) {        Assert.assertEquals("Meta alerts cannot be directly updated", uoe.getMessage());    }}
public void metron_f5473_0() throws Exception
{        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        setupTypings();        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));        addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        String namePatch = namePatchRequest.replace(META_INDEX_FLAG, getMetaAlertIndex());    PatchRequest patchRequest = JSONUtils.INSTANCE.load(namePatch, PatchRequest.class);    metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        assertEventually(() -> {        Document updated = metaDao.getLatest("meta_alert", METAALERT_TYPE);        Assert.assertEquals("New Meta Alert", updated.getDocument().get(NAME_FIELD));    });}
public void metron_f5474_0() throws Exception
{    setupTypings();        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        try {        String alertPatch = alertPatchRequest.replace(META_INDEX_FLAG, getMetaAlertIndex());        PatchRequest patchRequest = JSONUtils.INSTANCE.load(alertPatch, PatchRequest.class);        metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        Assert.fail("A patch on the alert field should throw an exception");    } catch (IllegalArgumentException iae) {        Assert.assertEquals("Meta alert patches are not allowed for /alert or /status paths.  " + "Please use the add/remove alert or update status functions instead.", iae.getMessage());    }        assertEventually(() -> {        Document updated = metaDao.getLatest("meta_alert", METAALERT_TYPE);        Assert.assertEquals(metaAlert.get(ALERT_FIELD), updated.getDocument().get(ALERT_FIELD));    });}
public void metron_f5475_0() throws Exception
{    setupTypings();        List<Map<String, Object>> alerts = buildAlerts(2);    alerts.get(0).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    alerts.get(1).put(METAALERT_FIELD, Collections.singletonList("meta_active"));    addRecords(alerts, getTestIndexFullName(), SENSOR_NAME);        Map<String, Object> metaAlert = buildMetaAlert("meta_alert", MetaAlertStatus.ACTIVE, Optional.of(Arrays.asList(alerts.get(0), alerts.get(1))));    addRecords(Collections.singletonList(metaAlert), getMetaAlertIndex(), METAALERT_TYPE);        findCreatedDocs(Arrays.asList(new GetRequest("message_0", SENSOR_NAME), new GetRequest("message_1", SENSOR_NAME), new GetRequest("meta_alert", METAALERT_TYPE)));        try {        String statusPatch = statusPatchRequest.replace(META_INDEX_FLAG, getMetaAlertIndex());        PatchRequest patchRequest = JSONUtils.INSTANCE.load(statusPatch, PatchRequest.class);        metaDao.patch(metaDao, patchRequest, Optional.of(System.currentTimeMillis()));        Assert.fail("A patch on the status field should throw an exception");    } catch (IllegalArgumentException iae) {        Assert.assertEquals("Meta alert patches are not allowed for /alert or /status paths.  " + "Please use the add/remove alert or update status functions instead.", iae.getMessage());    }        assertEventually(() -> {        Document updated = metaDao.getLatest("meta_alert", METAALERT_TYPE);        Assert.assertEquals(metaAlert.get(STATUS_FIELD), updated.getDocument().get(STATUS_FIELD));    });}
protected void metron_f5476_0(Map<String, Object> message0, String guid, String sensorType) throws InterruptedException, IOException, OriginalNotFoundException
{    commit();    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Document doc = metaDao.getLatest(guid, sensorType);                convertAlertsFieldToSet(doc.getDocument());        convertAlertsFieldToSet(message0);        if (doc.getDocument() != null && message0.equals(doc.getDocument())) {            convertAlertsFieldToList(doc.getDocument());            convertAlertsFieldToList(message0);            return;        }    }    throw new OriginalNotFoundException("Count not find " + guid + " after " + MAX_RETRIES + " tries");}
protected void metron_f5477_0(Map<String, Object> document)
{    if (document.get(ALERT_FIELD) instanceof List) {        @SuppressWarnings("unchecked")        List<Map<String, Object>> message0AlertField = (List<Map<String, Object>>) document.get(ALERT_FIELD);        Set<Map<String, Object>> message0AlertSet = new HashSet<>(message0AlertField);        document.put(ALERT_FIELD, message0AlertSet);    }}
protected void metron_f5478_0(Map<String, Object> document)
{    if (document.get(ALERT_FIELD) instanceof Set) {        @SuppressWarnings("unchecked")        Set<Map<String, Object>> message0AlertField = (Set<Map<String, Object>>) document.get(ALERT_FIELD);        List<Map<String, Object>> message0AlertList = new ArrayList<>(message0AlertField);        message0AlertList.sort(Comparator.comparing(o -> ((String) o.get(Constants.GUID))));        document.put(ALERT_FIELD, message0AlertList);    }}
protected boolean metron_f5479_0(String guid, String sensorType) throws InterruptedException, IOException, OriginalNotFoundException
{    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Document doc = metaDao.getLatest(guid, sensorType);        if (doc != null) {            return true;        }    }    throw new OriginalNotFoundException("Count not find " + guid + " after " + MAX_RETRIES + "tries");}
protected boolean metron_f5480_0(List<GetRequest> getRequests) throws InterruptedException, IOException, OriginalNotFoundException
{    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Iterable<Document> docs = metaDao.getAllLatest(getRequests);        if (docs != null) {            int docCount = 0;            for (Document doc : docs) {                docCount++;            }            if (getRequests.size() == docCount) {                return true;            }        }    }    throw new OriginalNotFoundException("Count not find guids after " + MAX_RETRIES + "tries");}
protected void metron_f5481_0(Map<String, Object> expected, Map<String, Object> actual)
{    Assert.assertEquals(expected.get(Constants.GUID), actual.get(Constants.GUID));    Assert.assertEquals(expected.get(getSourceTypeField()), actual.get(getSourceTypeField()));    Double actualThreatTriageField = actual.get(getThreatTriageField()) instanceof Float ? ((Float) actual.get(getThreatTriageField())).doubleValue() : (Double) actual.get(getThreatTriageField());    Assert.assertEquals(expected.get(getThreatTriageField()), actualThreatTriageField);    List<Map<String, Object>> expectedAlerts = (List<Map<String, Object>>) expected.get(ALERT_FIELD);    List<Map<String, Object>> actualAlerts = (List<Map<String, Object>>) actual.get(ALERT_FIELD);    expectedAlerts.sort(Comparator.comparing(o -> ((String) o.get(Constants.GUID))));    actualAlerts.sort(Comparator.comparing(o -> ((String) o.get(Constants.GUID))));    Assert.assertEquals(expectedAlerts, actualAlerts);    Assert.assertEquals(expected.get(STATUS_FIELD), actual.get(STATUS_FIELD));    Assert.assertEquals(expected.get("average"), actual.get("average"));    Assert.assertEquals(expected.get("min"), actual.get("min"));    Assert.assertEquals(expected.get("median"), actual.get("median"));    Assert.assertEquals(expected.get("max"), actual.get("max"));    Integer actualCountField = actual.get("count") instanceof Long ? ((Long) actual.get("count")).intValue() : (Integer) actual.get("count");    Assert.assertEquals(expected.get("count"), actualCountField);    Assert.assertEquals(expected.get("sum"), actual.get("sum"));}
protected List<Map<String, Object>> metron_f5482_0(int count)
{    List<Map<String, Object>> inputData = new ArrayList<>();    for (int i = 0; i < count; ++i) {        final String guid = "message_" + i;        Map<String, Object> alerts = new HashMap<>();        alerts.put(Constants.GUID, guid);        alerts.put(getSourceTypeField(), SENSOR_NAME);        alerts.put(THREAT_FIELD_DEFAULT, (double) i);        alerts.put("timestamp", System.currentTimeMillis());        inputData.add(alerts);    }    return inputData;}
protected List<Map<String, Object>> metron_f5483_0(int count, MetaAlertStatus status, Optional<List<Map<String, Object>>> alerts)
{    List<Map<String, Object>> inputData = new ArrayList<>();    for (int i = 0; i < count; ++i) {        final String guid = "meta_" + status.getStatusString() + "_" + i;        inputData.add(buildMetaAlert(guid, status, alerts));    }    return inputData;}
protected Map<String, Object> metron_f5484_0(String guid, MetaAlertStatus status, Optional<List<Map<String, Object>>> alerts)
{    Map<String, Object> metaAlert = new HashMap<>();    metaAlert.put(Constants.GUID, guid);    metaAlert.put(getSourceTypeField(), METAALERT_TYPE);    metaAlert.put(STATUS_FIELD, status.getStatusString());    metaAlert.put(getThreatTriageField(), 100.0d);    if (alerts.isPresent()) {        List<Map<String, Object>> alertsList = alerts.get();        metaAlert.put(ALERT_FIELD, alertsList);    }    return metaAlert;}
protected String metron_f5485_0()
{    return getTestIndexName();}
protected String metron_f5486_0()
{    return THREAT_FIELD_DEFAULT;}
public void metron_f5488_0()
{    final double delta = 0.001;    List<Map<String, Object>> alertList = new ArrayList<>();        alertList.add(Collections.singletonMap(THREAT_FIELD_DEFAULT, 10.0f));        alertList.add(Collections.singletonMap(THREAT_FIELD_DEFAULT, 20.0f));        alertList.add(Collections.singletonMap("alert3", "has no threat score"));        Map<String, Object> docMap = new HashMap<>();    docMap.put(ALERT_FIELD, alertList);    Document metaalert = new Document(docMap, "guid", METAALERT_TYPE, 0L);        MetaScores.calculateMetaScores(metaalert, THREAT_FIELD_DEFAULT, THREAT_SORT_DEFAULT);        assertEquals(20D, (Double) metaalert.getDocument().get("max"), delta);    assertEquals(10D, (Double) metaalert.getDocument().get("min"), delta);    assertEquals(15D, (Double) metaalert.getDocument().get("average"), delta);    assertEquals(2L, metaalert.getDocument().get("count"));    assertEquals(30D, (Double) metaalert.getDocument().get("sum"), delta);    assertEquals(15D, (Double) metaalert.getDocument().get("median"), delta);            Object threatScore = metaalert.getDocument().get(THREAT_FIELD_DEFAULT);    assertTrue(threatScore instanceof Float);        assertEquals(30.0F, threatScore);}
public void metron_f5489_0()
{    List<Map<String, Object>> alertList = new ArrayList<>();        alertList.add(Collections.singletonMap(MetaAlertConstants.THREAT_FIELD_DEFAULT, 10.0f));        Map<String, Object> docMap = new HashMap<>();    docMap.put(MetaAlertConstants.ALERT_FIELD, alertList);    Document metaalert = new Document(docMap, "guid", MetaAlertConstants.METAALERT_TYPE, 0L);        AccessConfig accessConfig = new AccessConfig();    accessConfig.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(Constants.THREAT_SCORE_FIELD_PROPERTY, MetaAlertConstants.THREAT_FIELD_DEFAULT);        }    });    MetaScores.calculateMetaScores(metaalert, MetaAlertConstants.THREAT_FIELD_DEFAULT, MetaAlertConstants.THREAT_SORT_DEFAULT);    assertNotNull(metaalert.getDocument().get(MetaAlertConstants.THREAT_FIELD_DEFAULT));}
public void metron_f5490_0()
{    dao1 = mock(IndexDao.class);    dao2 = mock(IndexDao.class);    multiIndexDao = new MultiIndexDao(dao1, dao2);    document1 = new Document(new HashMap<>(), "guid", "bro", 1L);    document2 = new Document(new HashMap<>(), "guid", "bro", 2L);}
public void metron_f5491_0() throws IOException
{    Document actual = multiIndexDao.update(document1, Optional.of("bro"));    Assert.assertEquals(document1, actual);        verify(dao1).update(eq(document1), eq(Optional.of("bro")));    verify(dao2).update(eq(document1), eq(Optional.of("bro")));}
public void metron_f5492_0() throws IOException
{        when(dao2.update(any(), any())).thenThrow(new IllegalStateException());    multiIndexDao.update(document1, Optional.of("bro"));}
public void metron_f5493_0() throws IOException
{    Map<Document, Optional<String>> updates = new HashMap<Document, Optional<String>>() {        {            put(document1, Optional.of("bro"));            put(document2, Optional.of("bro"));        }    };    Map<Document, Optional<String>> actual = multiIndexDao.batchUpdate(updates);    Assert.assertEquals(updates, actual);        verify(dao1).batchUpdate(eq(updates));    verify(dao2).batchUpdate(eq(updates));}
public void metron_f5494_0() throws IOException
{        when(dao2.batchUpdate(any())).thenThrow(new IllegalStateException());    Map<Document, Optional<String>> updates = new HashMap<Document, Optional<String>>() {        {            put(document1, Optional.of("bro"));            put(document2, Optional.of("bro"));        }    };    multiIndexDao.batchUpdate(updates);}
public void metron_f5495_0() throws Exception
{    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    when(dao1.getLatest("guid", "bro")).thenReturn(document1);    when(dao2.getLatest("guid", "bro")).thenReturn(document2);    Document expected = new Document(new HashMap<>(), "guid", "bro", 2L);    Assert.assertEquals(expected, multiIndexDao.getLatest("guid", "bro"));}
public void metron_f5496_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    when(dao1.addCommentToAlert(request, latest)).thenReturn(document1);    when(dao2.addCommentToAlert(request, latest)).thenReturn(document2);    Document expected = new Document(new HashMap<>(), "guid", "bro", 2L);    Assert.assertEquals(expected, multiIndexDao.addCommentToAlert(request, latest));}
public void metron_f5497_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");        when(dao1.addCommentToAlert(request, latest)).thenReturn(document1);    when(dao2.addCommentToAlert(request, latest)).thenThrow(new IllegalStateException());    multiIndexDao.addCommentToAlert(request, latest);}
public void metron_f5498_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    when(dao1.removeCommentFromAlert(request, latest)).thenReturn(document1);    when(dao2.removeCommentFromAlert(request, latest)).thenReturn(document2);    Document expected = new Document(new HashMap<>(), "guid", "bro", 2L);    Assert.assertEquals(expected, multiIndexDao.removeCommentFromAlert(request, latest));}
public void metron_f5499_0() throws Exception
{    Document latest = mock(Document.class);    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");        when(dao1.removeCommentFromAlert(request, latest)).thenReturn(document1);    when(dao2.removeCommentFromAlert(request, latest)).thenThrow(new IllegalStateException());    multiIndexDao.removeCommentFromAlert(request, latest);}
public void metron_f5500_0() throws Exception
{    List<String> indices = Arrays.asList("bro");    Map<String, FieldType> expected = new HashMap<String, FieldType>() {        {            put("bro", FieldType.TEXT);        }    };    when(dao1.getColumnMetadata(eq(indices))).thenReturn(null);    when(dao2.getColumnMetadata(eq(indices))).thenReturn(expected);    Map<String, FieldType> actual = multiIndexDao.getColumnMetadata(indices);    Assert.assertEquals(expected, actual);}
public void metron_f5501_0() throws Exception
{    List<String> indices = Arrays.asList("bro");        when(dao1.getColumnMetadata(eq(indices))).thenReturn(null);    when(dao2.getColumnMetadata(eq(indices))).thenReturn(null);    Map<String, FieldType> actual = multiIndexDao.getColumnMetadata(indices);    Assert.assertNull(actual);}
public void metron_f5502_0() throws Exception
{    SearchRequest request = new SearchRequest();    SearchResponse expected = new SearchResponse();    when(dao1.search(eq(request))).thenReturn(null);    when(dao2.search(eq(request))).thenReturn(expected);    SearchResponse actual = multiIndexDao.search(request);    Assert.assertEquals(expected, actual);}
public void metron_f5503_0() throws Exception
{    SearchRequest request = new SearchRequest();    when(dao1.search(eq(request))).thenReturn(null);    when(dao2.search(eq(request))).thenReturn(null);    SearchResponse actual = multiIndexDao.search(request);    Assert.assertNull(actual);}
public void metron_f5504_0() throws Exception
{    GroupRequest request = new GroupRequest();    GroupResponse expected = new GroupResponse();    when(dao1.group(eq(request))).thenReturn(null);    when(dao2.group(eq(request))).thenReturn(expected);    GroupResponse actual = multiIndexDao.group(request);    Assert.assertEquals(expected, actual);}
public void metron_f5505_0() throws Exception
{    GroupRequest request = new GroupRequest();    when(dao1.group(eq(request))).thenReturn(null);    when(dao2.group(eq(request))).thenReturn(null);    GroupResponse actual = multiIndexDao.group(request);    Assert.assertNull(actual);}
public void metron_f5506_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(allQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(10, results.size());    for (int i = 0; i < 5; ++i) {        Assert.assertEquals("snort", results.get(i).getSource().get(getSourceTypeField()));        Assert.assertEquals(getIndexName("snort"), results.get(i).getIndex());        Assert.assertEquals(10 - i + "", results.get(i).getSource().get("timestamp").toString());    }    for (int i = 5; i < 10; ++i) {        Assert.assertEquals("bro", results.get(i).getSource().get(getSourceTypeField()));        Assert.assertEquals(getIndexName("bro"), results.get(i).getIndex());        Assert.assertEquals(10 - i + "", results.get(i).getSource().get("timestamp").toString());    }}
public void metron_f5507_0() throws Exception
{    GetRequest request = JSONUtils.INSTANCE.load(findOneGuidQuery, GetRequest.class);    Optional<Map<String, Object>> response = getIndexDao().getLatestResult(request);    Assert.assertTrue(response.isPresent());    Map<String, Object> doc = response.get();    Assert.assertEquals("bro", doc.get(getSourceTypeField()));    Assert.assertEquals("3", doc.get("timestamp").toString());}
public void metron_f5508_0() throws Exception
{    List<GetRequest> request = JSONUtils.INSTANCE.load(getAllLatestQuery, new JSONUtils.ReferenceSupplier<List<GetRequest>>() {    });    Map<String, Document> docs = new HashMap<>();    for (Document doc : getIndexDao().getAllLatest(request)) {        docs.put(doc.getGuid(), doc);    }    Assert.assertEquals(2, docs.size());    Assert.assertTrue(docs.keySet().contains("bro_1"));    Assert.assertTrue(docs.keySet().contains("snort_2"));    Assert.assertEquals("bro", docs.get("bro_1").getDocument().get(getSourceTypeField()));    Assert.assertEquals("snort", docs.get("snort_2").getDocument().get(getSourceTypeField()));}
public void metron_f5509_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(filterQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(3, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals("snort", results.get(0).getSource().get(getSourceTypeField()));    Assert.assertEquals("9", results.get(0).getSource().get("timestamp").toString());    Assert.assertEquals("snort", results.get(1).getSource().get(getSourceTypeField()));    Assert.assertEquals("7", results.get(1).getSource().get("timestamp").toString());    Assert.assertEquals("bro", results.get(2).getSource().get(getSourceTypeField()));    Assert.assertEquals("1", results.get(2).getSource().get("timestamp").toString());}
public void metron_f5510_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 8001; i < 8011; ++i) {        Assert.assertEquals(i, results.get(i - 8001).getSource().get("ip_src_port"));    }}
public void metron_f5511_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortAscendingWithMissingFields, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(10, results.size());        for (int i = 0; i < 8; i++) {        Assert.assertFalse(results.get(i).getSource().containsKey("threat:triage:score"));    }        Assert.assertEquals("10.0", results.get(8).getSource().get("threat:triage:score").toString());    Assert.assertEquals("20.0", results.get(9).getSource().get("threat:triage:score").toString());}
public void metron_f5512_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortDescendingWithMissingFields, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(10, results.size());        Assert.assertEquals("20.0", results.get(0).getSource().get("threat:triage:score").toString());    Assert.assertEquals("10.0", results.get(1).getSource().get("threat:triage:score").toString());        for (int i = 2; i < 10; i++) {        Assert.assertFalse(results.get(i).getSource().containsKey("threat:triage:score"));    }}
public void metron_f5513_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(paginationQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    Assert.assertEquals(3, results.size());    Assert.assertEquals("snort", results.get(0).getSource().get(getSourceTypeField()));    Assert.assertEquals("6", results.get(0).getSource().get("timestamp").toString());    Assert.assertEquals("bro", results.get(1).getSource().get(getSourceTypeField()));    Assert.assertEquals("5", results.get(1).getSource().get("timestamp").toString());    Assert.assertEquals("bro", results.get(2).getSource().get(getSourceTypeField()));    Assert.assertEquals("4", results.get(2).getSource().get("timestamp").toString());}
public void metron_f5514_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(indexQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(5, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 5, j = 0; i > 0; i--, j++) {        Assert.assertEquals("bro", results.get(j).getSource().get(getSourceTypeField()));        Assert.assertEquals(i + "", results.get(j).getSource().get("timestamp").toString());    }}
public void metron_f5515_0() throws Exception
{    String facetQuery = facetQueryRaw.replace("source:type", getSourceTypeField());    SearchRequest request = JSONUtils.INSTANCE.load(facetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    Map<String, Map<String, Long>> facetCounts = response.getFacetCounts();    Assert.assertEquals(8, facetCounts.size());    Map<String, Long> sourceTypeCounts = facetCounts.get(getSourceTypeField());    Assert.assertEquals(2, sourceTypeCounts.size());    Assert.assertEquals(new Long(5), sourceTypeCounts.get("bro"));    Assert.assertEquals(new Long(5), sourceTypeCounts.get("snort"));    Map<String, Long> ipSrcAddrCounts = facetCounts.get("ip_src_addr");    Assert.assertEquals(8, ipSrcAddrCounts.size());    Assert.assertEquals(new Long(3), ipSrcAddrCounts.get("192.168.1.1"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.2"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.3"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.4"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.5"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.6"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.7"));    Assert.assertEquals(new Long(1), ipSrcAddrCounts.get("192.168.1.8"));    Map<String, Long> ipSrcPortCounts = facetCounts.get("ip_src_port");    Assert.assertEquals(10, ipSrcPortCounts.size());    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8001"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8002"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8003"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8004"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8005"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8006"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8007"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8008"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8009"));    Assert.assertEquals(new Long(1), ipSrcPortCounts.get("8010"));    Map<String, Long> longFieldCounts = facetCounts.get("long_field");    Assert.assertEquals(2, longFieldCounts.size());    Assert.assertEquals(new Long(8), longFieldCounts.get("10000"));    Assert.assertEquals(new Long(2), longFieldCounts.get("20000"));    Map<String, Long> timestampCounts = facetCounts.get("timestamp");    Assert.assertEquals(10, timestampCounts.size());    Assert.assertEquals(new Long(1), timestampCounts.get("1"));    Assert.assertEquals(new Long(1), timestampCounts.get("2"));    Assert.assertEquals(new Long(1), timestampCounts.get("3"));    Assert.assertEquals(new Long(1), timestampCounts.get("4"));    Assert.assertEquals(new Long(1), timestampCounts.get("5"));    Assert.assertEquals(new Long(1), timestampCounts.get("6"));    Assert.assertEquals(new Long(1), timestampCounts.get("7"));    Assert.assertEquals(new Long(1), timestampCounts.get("8"));    Assert.assertEquals(new Long(1), timestampCounts.get("9"));    Assert.assertEquals(new Long(1), timestampCounts.get("10"));    Map<String, Long> latitudeCounts = facetCounts.get("latitude");    Assert.assertEquals(2, latitudeCounts.size());    List<String> latitudeKeys = new ArrayList<>(latitudeCounts.keySet());    Collections.sort(latitudeKeys);    Assert.assertEquals(48.0001, Double.parseDouble(latitudeKeys.get(0)), 0.00001);    Assert.assertEquals(48.5839, Double.parseDouble(latitudeKeys.get(1)), 0.00001);    Assert.assertEquals(new Long(2), latitudeCounts.get(latitudeKeys.get(0)));    Assert.assertEquals(new Long(8), latitudeCounts.get(latitudeKeys.get(1)));    Map<String, Long> scoreFieldCounts = facetCounts.get("score");    Assert.assertEquals(4, scoreFieldCounts.size());    List<String> scoreFieldKeys = new ArrayList<>(scoreFieldCounts.keySet());    Collections.sort(scoreFieldKeys);    Assert.assertEquals(10.0, Double.parseDouble(scoreFieldKeys.get(0)), 0.00001);    Assert.assertEquals(20.0, Double.parseDouble(scoreFieldKeys.get(1)), 0.00001);    Assert.assertEquals(50.0, Double.parseDouble(scoreFieldKeys.get(2)), 0.00001);    Assert.assertEquals(98.0, Double.parseDouble(scoreFieldKeys.get(3)), 0.00001);    Assert.assertEquals(new Long(4), scoreFieldCounts.get(scoreFieldKeys.get(0)));    Assert.assertEquals(new Long(2), scoreFieldCounts.get(scoreFieldKeys.get(1)));    Assert.assertEquals(new Long(3), scoreFieldCounts.get(scoreFieldKeys.get(2)));    Assert.assertEquals(new Long(1), scoreFieldCounts.get(scoreFieldKeys.get(3)));    Map<String, Long> isAlertCounts = facetCounts.get("is_alert");    Assert.assertEquals(2, isAlertCounts.size());    Assert.assertEquals(new Long(6), isAlertCounts.get("true"));    Assert.assertEquals(new Long(4), isAlertCounts.get("false"));}
public void metron_f5516_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(disabledFacetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertNull(response.getFacetCounts());}
public void metron_f5517_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(missingTypeFacetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    Map<String, Map<String, Long>> facetCounts = response.getFacetCounts();    Assert.assertEquals(1, facetCounts.size());    Map<String, Long> snortFieldCounts = facetCounts.get("sig_generator");    Assert.assertEquals(5, snortFieldCounts.size());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 5").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 4").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 3").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 2").longValue());    Assert.assertEquals(1L, snortFieldCounts.get("sig_generator 1").longValue());    response.getFacetCounts();}
public void metron_f5518_0() throws Exception
{    thrown.expect(Exception.class);    SearchRequest request = JSONUtils.INSTANCE.load(differentTypeFacetQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(3, response.getTotal());}
public void metron_f5519_0() throws Exception
{    thrown.expect(InvalidSearchException.class);    thrown.expectMessage("Search result size must be less than 100");    SearchRequest request = JSONUtils.INSTANCE.load(exceededMaxResultsQuery, SearchRequest.class);    getIndexDao().search(request);}
public void metron_f5520_0() throws Exception
{        {        Map<String, FieldType> fieldTypes = getIndexDao().getColumnMetadata(Collections.singletonList("someindex"));        Assert.assertEquals(0, fieldTypes.size());    }}
public void metron_f5521_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(noResultsFieldsQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(0, response.getTotal());}
public void metron_f5522_0() throws Exception
{    GroupRequest request = JSONUtils.INSTANCE.load(groupByIpQuery, GroupRequest.class);    GroupResponse response = getIndexDao().group(request);        Assert.assertEquals("ip_src_addr", response.getGroupedBy());        List<GroupResult> groups = response.getGroupResults();    Assert.assertEquals(8, groups.size());        Assert.assertEquals("192.168.1.8", groups.get(0).getKey());    Assert.assertEquals("192.168.1.7", groups.get(1).getKey());    Assert.assertEquals("192.168.1.6", groups.get(2).getKey());    Assert.assertEquals("192.168.1.5", groups.get(3).getKey());    Assert.assertEquals("192.168.1.4", groups.get(4).getKey());    Assert.assertEquals("192.168.1.3", groups.get(5).getKey());    Assert.assertEquals("192.168.1.2", groups.get(6).getKey());    Assert.assertEquals("192.168.1.1", groups.get(7).getKey());}
public void metron_f5523_0() throws Exception
{        GroupRequest request = JSONUtils.INSTANCE.load(groupByQuery, GroupRequest.class);    GroupResponse response = getIndexDao().group(request);    Assert.assertEquals("is_alert", response.getGroupedBy());    List<GroupResult> isAlertGroups = response.getGroupResults();    Assert.assertEquals(2, isAlertGroups.size());        GroupResult trueGroup = isAlertGroups.get(0);    Assert.assertEquals("true", trueGroup.getKey());    Assert.assertEquals(6, trueGroup.getTotal());    Assert.assertEquals("latitude", trueGroup.getGroupedBy());    Assert.assertEquals(198.0, trueGroup.getScore(), 0.00001);    List<GroupResult> trueLatitudeGroups = trueGroup.getGroupResults();    Assert.assertEquals(2, trueLatitudeGroups.size());        GroupResult trueLatitudeGroup2 = trueLatitudeGroups.get(0);    Assert.assertEquals(48.5839, Double.parseDouble(trueLatitudeGroup2.getKey()), 0.00001);    Assert.assertEquals(5, trueLatitudeGroup2.getTotal());    Assert.assertEquals(148.0, trueLatitudeGroup2.getScore(), 0.00001);        GroupResult trueLatitudeGroup1 = trueLatitudeGroups.get(1);    Assert.assertEquals(48.0001, Double.parseDouble(trueLatitudeGroup1.getKey()), 0.00001);    Assert.assertEquals(1, trueLatitudeGroup1.getTotal());    Assert.assertEquals(50.0, trueLatitudeGroup1.getScore(), 0.00001);        GroupResult falseGroup = isAlertGroups.get(1);    Assert.assertEquals("false", falseGroup.getKey());    Assert.assertEquals("latitude", falseGroup.getGroupedBy());    Assert.assertEquals(130.0, falseGroup.getScore(), 0.00001);    List<GroupResult> falseLatitudeGroups = falseGroup.getGroupResults();    Assert.assertEquals(2, falseLatitudeGroups.size());        GroupResult falseLatitudeGroup2 = falseLatitudeGroups.get(0);    Assert.assertEquals(48.5839, Double.parseDouble(falseLatitudeGroup2.getKey()), 0.00001);    Assert.assertEquals(3, falseLatitudeGroup2.getTotal());    Assert.assertEquals(80.0, falseLatitudeGroup2.getScore(), 0.00001);        GroupResult falseLatitudeGroup1 = falseLatitudeGroups.get(1);    Assert.assertEquals(48.0001, Double.parseDouble(falseLatitudeGroup1.getKey()), 0.00001);    Assert.assertEquals(1, falseLatitudeGroup1.getTotal());    Assert.assertEquals(50.0, falseLatitudeGroup1.getScore(), 0.00001);}
public void metron_f5524_0() throws Exception
{        GroupRequest request = JSONUtils.INSTANCE.load(sortedGroupByQuery, GroupRequest.class);    GroupResponse response = getIndexDao().group(request);    Assert.assertEquals("is_alert", response.getGroupedBy());    List<GroupResult> isAlertGroups = response.getGroupResults();    Assert.assertEquals(2, isAlertGroups.size());        GroupResult falseGroup = isAlertGroups.get(0);    Assert.assertEquals(4, falseGroup.getTotal());    Assert.assertEquals("ip_src_addr", falseGroup.getGroupedBy());    List<GroupResult> falseIpSrcAddrGroups = falseGroup.getGroupResults();    Assert.assertEquals(4, falseIpSrcAddrGroups.size());        GroupResult falseIpSrcAddrGroup1 = falseIpSrcAddrGroups.get(0);    Assert.assertEquals("192.168.1.8", falseIpSrcAddrGroup1.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup1.getTotal());    Assert.assertNull(falseIpSrcAddrGroup1.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup1.getGroupResults());        GroupResult falseIpSrcAddrGroup2 = falseIpSrcAddrGroups.get(1);    Assert.assertEquals("192.168.1.7", falseIpSrcAddrGroup2.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup2.getTotal());    Assert.assertNull(falseIpSrcAddrGroup2.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup2.getGroupResults());        GroupResult falseIpSrcAddrGroup3 = falseIpSrcAddrGroups.get(2);    Assert.assertEquals("192.168.1.6", falseIpSrcAddrGroup3.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup3.getTotal());    Assert.assertNull(falseIpSrcAddrGroup3.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup3.getGroupResults());        GroupResult falseIpSrcAddrGroup4 = falseIpSrcAddrGroups.get(3);    Assert.assertEquals("192.168.1.2", falseIpSrcAddrGroup4.getKey());    Assert.assertEquals(1, falseIpSrcAddrGroup4.getTotal());    Assert.assertNull(falseIpSrcAddrGroup4.getGroupedBy());    Assert.assertNull(falseIpSrcAddrGroup4.getGroupResults());        GroupResult trueGroup = isAlertGroups.get(1);    Assert.assertEquals(6, trueGroup.getTotal());    Assert.assertEquals("ip_src_addr", trueGroup.getGroupedBy());    List<GroupResult> trueIpSrcAddrGroups = trueGroup.getGroupResults();    Assert.assertEquals(4, trueIpSrcAddrGroups.size());        GroupResult trueIpSrcAddrGroup1 = trueIpSrcAddrGroups.get(0);    Assert.assertEquals("192.168.1.5", trueIpSrcAddrGroup1.getKey());    Assert.assertEquals(1, trueIpSrcAddrGroup1.getTotal());    Assert.assertNull(trueIpSrcAddrGroup1.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup1.getGroupResults());        GroupResult trueIpSrcAddrGroup2 = trueIpSrcAddrGroups.get(1);    Assert.assertEquals("192.168.1.4", trueIpSrcAddrGroup2.getKey());    Assert.assertEquals(1, trueIpSrcAddrGroup2.getTotal());    Assert.assertNull(trueIpSrcAddrGroup2.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup2.getGroupResults());        GroupResult trueIpSrcAddrGroup3 = trueIpSrcAddrGroups.get(2);    Assert.assertEquals("192.168.1.3", trueIpSrcAddrGroup3.getKey());    Assert.assertEquals(1, trueIpSrcAddrGroup3.getTotal());    Assert.assertNull(trueIpSrcAddrGroup3.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup3.getGroupResults());        GroupResult trueIpSrcAddrGroup4 = trueIpSrcAddrGroups.get(3);    Assert.assertEquals("192.168.1.1", trueIpSrcAddrGroup4.getKey());    Assert.assertEquals(3, trueIpSrcAddrGroup4.getTotal());    Assert.assertNull(trueIpSrcAddrGroup4.getGroupedBy());    Assert.assertNull(trueIpSrcAddrGroup4.getGroupResults());}
public void metron_f5525_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(fieldsQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(10, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 0; i < 5; ++i) {        Map<String, Object> source = results.get(i).getSource();        Assert.assertEquals(1, source.size());        Assert.assertNotNull(source.get("ip_src_addr"));    }    for (int i = 5; i < 10; ++i) {        Map<String, Object> source = results.get(i).getSource();        Assert.assertEquals(1, source.size());        Assert.assertNotNull(source.get("ip_src_addr"));    }}
public void metron_f5526_0() throws Exception
{    SearchRequest request = JSONUtils.INSTANCE.load(sortByGuidQuery, SearchRequest.class);    SearchResponse response = getIndexDao().search(request);    Assert.assertEquals(5, response.getTotal());    List<SearchResult> results = response.getResults();    for (int i = 0; i < 5; ++i) {        Map<String, Object> source = results.get(i).getSource();        Assert.assertEquals(1, source.size());        Assert.assertEquals(source.get("guid"), "bro_" + (i + 1));    }}
public static void metron_f5527_0()
{    indexComponent.stop();}
public void metron_f5528_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.ADD.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, "value");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<>()));}
public void metron_f5529_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.REMOVE.name());            put(PatchUtils.PATH, "/remove/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");            put("remove", new HashMap<>());        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");            put("remove", new HashMap<String, Object>() {                {                    put("path", "removeValue");                }            });        }    }));}
public void metron_f5530_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.COPY.name());            put(PatchUtils.FROM, "/from");            put(PatchUtils.PATH, "/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("from", "value");            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("from", "value");        }    }));}
public void metron_f5531_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.COPY.name());            put(PatchUtils.FROM, "/nested/from");            put(PatchUtils.PATH, "/nested/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("nested", new HashMap<String, Object>() {                {                    put("from", "value");                    put("path", "value");                }            });        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("nested", new HashMap<String, Object>() {                {                    put("from", "value");                }            });        }    }));}
public void metron_f5532_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.MOVE.name());            put(PatchUtils.FROM, "/from");            put(PatchUtils.PATH, "/path");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("from", "value");        }    }));}
public void metron_f5533_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, "value");        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", "value");        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");        }    }));}
public void metron_f5534_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, 100);        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", 100);        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", 100);        }    }));}
public void metron_f5535_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, Arrays.asList(1, 2, 3));        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", Arrays.asList(1, 2, 3));        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", Arrays.asList(1, 2, 3));        }    }));}
public void metron_f5536_0()
{    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, new HashMap<String, Object>() {                {                    put("key", "value");                }            });        }    });    Map<String, Object> expected = new HashMap<String, Object>() {        {            put("path", new HashMap<String, Object>() {                {                    put("key", "value");                }            });        }    };    Assert.assertEquals(expected, PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", new HashMap<String, Object>() {                {                    put("key", "value");                }            });        }    }));}
public void metron_f5537_0()
{    exception.expect(PatchException.class);    exception.expectMessage("TEST operation failed: supplied value [value1] != target value [value2]");    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.TEST.name());            put(PatchUtils.PATH, "/path");            put(PatchUtils.VALUE, "value1");        }    });    PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value2");        }    });}
public void metron_f5538_0()
{    exception.expect(IllegalArgumentException.class);    exception.expectMessage("Invalid path: /missing/path");    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, PatchOperation.REMOVE.name());            put(PatchUtils.PATH, "/missing/path");        }    });    PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");        }    });}
public void metron_f5539_0()
{    exception.expect(UnsupportedOperationException.class);    exception.expectMessage("The invalid operation is not supported");    List<Map<String, Object>> patches = new ArrayList<>();    patches.add(new HashMap<String, Object>() {        {            put(PatchUtils.OP, "invalid");            put(PatchUtils.PATH, "/path");        }    });    PatchUtils.INSTANCE.applyPatch(patches, new HashMap<String, Object>() {        {            put("path", "value");        }    });}
public void metron_f5540_0() throws Exception
{    exception.expect(IOException.class);    exception.expectMessage("Unable to add comment. Document with guid guid cannot be found.");    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    getUpdateDao().addCommentToAlert(request, null);}
public void metron_f5541_0() throws Exception
{    exception.expect(IOException.class);    exception.expectMessage("Unable to remove comment. Document with guid guid cannot be found.");    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    getUpdateDao().removeCommentFromAlert(request, null);}
public void metron_f5542_0() throws Exception
{    exception.expect(IOException.class);    exception.expectMessage("Unable to remove comment. Document with guid guid has no comments.");    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid("guid");    Document latest = new Document(new HashMap<>(), "guid", "bro", System.currentTimeMillis());    getUpdateDao().removeCommentFromAlert(request, latest);}
public void metron_f5543_0() throws Exception
{        final String guid = UUID.randomUUID().toString();    final Long timestamp = 1526306463050L;    Document toUpdate = createDocument(guid, timestamp);        Document updated = getDao().update(toUpdate, Optional.of(SENSOR_NAME));    Assert.assertEquals(toUpdate, updated);        assertDocumentIndexed(toUpdate);}
public void metron_f5544_0() throws Exception
{    Map<Document, Optional<String>> toUpdate = new HashMap<>();        final String guid1 = UUID.randomUUID().toString();    final Long timestamp1 = 1526306463050L;    Document document1 = createDocument(guid1, timestamp1);    toUpdate.put(document1, Optional.of(SENSOR_NAME));        final String guid2 = UUID.randomUUID().toString();    final Long timestamp2 = 1526306463100L;    Document document2 = createDocument(guid2, timestamp2);    toUpdate.put(document2, Optional.of(SENSOR_NAME));        final String guid3 = UUID.randomUUID().toString();    final Long timestamp3 = 1526306463300L;    Document document3 = createDocument(guid3, timestamp3);    toUpdate.put(document3, Optional.of(SENSOR_NAME));        Map<Document, Optional<String>> updated = getDao().batchUpdate(toUpdate);    Assert.assertThat(updated.keySet(), hasItem(document1));    Assert.assertThat(updated.keySet(), hasItem(document2));    Assert.assertThat(updated.keySet(), hasItem(document3));        assertDocumentIndexed(document1);    assertDocumentIndexed(document2);    assertDocumentIndexed(document3);}
public void metron_f5545_0() throws Exception
{    Document document = createAndIndexDocument("testAddCommentAndPatch");        String commentText = "New Comment";    String commentUser = "test_user";    long commentTimestamp = 152630493050L;    Document withComment = addAlertComment(document.getGuid(), commentText, commentUser, commentTimestamp);    {                List<AlertComment> comments = getComments(withComment);        Assert.assertEquals(1, comments.size());        Assert.assertEquals(commentText, comments.get(0).getComment());        Assert.assertEquals(commentUser, comments.get(0).getUsername());        Assert.assertEquals(commentTimestamp, comments.get(0).getTimestamp());    }    {                Document indexed = findUpdatedDoc(withComment.getDocument(), withComment.getGuid(), SENSOR_NAME);        List<AlertComment> comments = getComments(indexed);        Assert.assertEquals(1, comments.size());        Assert.assertEquals(commentText, comments.get(0).getComment());        Assert.assertEquals(commentUser, comments.get(0).getUsername());        Assert.assertEquals(commentTimestamp, comments.get(0).getTimestamp());    }}
public void metron_f5546_0() throws Exception
{    Document document = createAndIndexDocument("testPatchDocumentWithComment");        String commentText = "New Comment";    String commentUser = "test_user";    long commentTimestamp = 152630493050L;    Document withComment = addAlertComment(document.getGuid(), commentText, commentUser, commentTimestamp);        List<Map<String, Object>> patches = new ArrayList<>();    Map<String, Object> patch = new HashMap<>();    patch.put("op", "add");    patch.put("path", "/project");    patch.put("value", "metron");    patches.add(patch);    PatchRequest pr = new PatchRequest();    pr.setGuid(withComment.getGuid());    pr.setIndex(SENSOR_NAME);    pr.setSensorType(SENSOR_NAME);    pr.setPatch(patches);        Document patched = getDao().patch(getDao(), pr, Optional.of(withComment.getTimestamp()));    Assert.assertEquals("metron", patched.getDocument().get("project"));        Document indexed = findUpdatedDoc(patched.getDocument(), patched.getGuid(), SENSOR_NAME);    Assert.assertEquals("metron", indexed.getDocument().get("project"));}
public void metron_f5547_0() throws Exception
{    String guid = "testRemoveComments";    createAndIndexDocument(guid);        Document withComments = addAlertComment(guid, "comment", "user1", 1526401584951L);    Assert.assertEquals(1, getComments(withComments).size());        Document indexedWithComments = findUpdatedDoc(withComments.getDocument(), withComments.getGuid(), withComments.getSensorType());    Assert.assertEquals(1, getComments(indexedWithComments).size());        AlertComment toRemove = getComments(withComments).get(0);    Document noComments = removeAlertComment(guid, toRemove.getComment(), toRemove.getUsername(), toRemove.getTimestamp());    Assert.assertEquals(0, getComments(noComments).size());        Document indexedNoComments = findUpdatedDoc(noComments.getDocument(), withComments.getGuid(), withComments.getSensorType());    Assert.assertEquals(0, getComments(indexedNoComments).size());}
protected Document metron_f5548_0(String guid, String comment, String username, long timestamp) throws IOException
{    CommentAddRemoveRequest request = buildAlertRequest(guid, comment, username, timestamp);    return getDao().addCommentToAlert(request);}
protected Document metron_f5549_0(String guid, String comment, String username, long timestamp) throws IOException
{    CommentAddRemoveRequest request = buildAlertRequest(guid, comment, username, timestamp);    return getDao().removeCommentFromAlert(request);}
private CommentAddRemoveRequest metron_f5550_0(String guid, String comment, String username, long timestamp)
{    CommentAddRemoveRequest request = new CommentAddRemoveRequest();    request.setGuid(guid);    request.setComment(comment);    request.setUsername(username);    request.setTimestamp(timestamp);    request.setSensorType(SENSOR_NAME);    return request;}
private Document metron_f5551_0(Document expected) throws Exception
{        Document actual = findUpdatedDoc(expected.getDocument(), expected.getGuid(), expected.getSensorType());        Assert.assertEquals(expected.getGuid(), actual.getGuid());    Assert.assertEquals(expected.getTimestamp(), actual.getTimestamp());    Assert.assertEquals(expected.getSensorType(), actual.getSensorType());    Assert.assertEquals(expected.getDocument(), actual.getDocument());    if (expected.getDocumentID().isPresent()) {                Assert.assertEquals(expected.getDocumentID().get(), actual.getDocumentID());    } else {                Assert.assertNotNull(expected.getDocumentID());    }    return actual;}
private Document metron_f5552_0(String guid) throws Exception
{        Long timestamp = 1526306463050L;    Document toCreate = createDocument(guid, timestamp);        Document created = getDao().update(toCreate, Optional.of(SENSOR_NAME));    Assert.assertEquals(toCreate, created);        return assertDocumentIndexed(created);}
protected Document metron_f5553_0(String guid, Long timestamp)
{    Map<String, Object> message1 = new HashMap<>();    message1.put(Constants.GUID, guid);    message1.put(Constants.SENSOR_TYPE, SENSOR_NAME);    message1.put(Constants.Fields.TIMESTAMP.getName(), timestamp);    return new Document(message1, guid, SENSOR_NAME, timestamp);}
private static List<AlertComment> metron_f5554_0(Document withComment) throws ParseException
{    return getComments(withComment.getDocument());}
private static List<AlertComment> metron_f5555_0(Map<String, Object> fields) throws ParseException
{    List<AlertComment> comments = new ArrayList<>();    boolean hasComments = fields.containsKey(COMMENTS_FIELD);    if (hasComments) {        List<Object> commentsField = List.class.cast(fields.get(COMMENTS_FIELD));        for (Object commentObject : commentsField) {            if (commentObject instanceof Map) {                                Map<String, Object> commentAsMap = (Map<String, Object>) commentObject;                comments.add(new AlertComment(commentAsMap));            } else if (commentObject instanceof String) {                                String commentAsString = (String) commentObject;                comments.add(new AlertComment(commentAsString));            } else {                throw new IllegalArgumentException(String.format("Unexpected comment value; %s", commentObject));            }        }    }    return comments;}
protected static void metron_f5556_0(Map<String, Object> fields)
{    @SuppressWarnings("unchecked")    List<Object> commentValues = (List<Object>) fields.get(COMMENTS_FIELD);    if (commentValues != null) {        try {            List<AlertComment> comments = getComments(fields);            if (comments.size() > 0) {                                List<Map<String, Object>> serializedComments = comments.stream().map(AlertComment::asMap).collect(Collectors.toList());                fields.put(COMMENTS_FIELD, serializedComments);            } else {                                fields.remove(COMMENTS_FIELD);            }        } catch (ParseException e) {            throw new IllegalStateException("Unable to parse comment", e);        }    }}
protected Document metron_f5557_0(Map<String, Object> expected, String guid, String sensorType) throws InterruptedException, IOException, OriginalNotFoundException
{        normalizeCommentsAsMap(expected);    for (int t = 0; t < MAX_RETRIES; ++t, Thread.sleep(SLEEP_MS)) {        Document found = getDao().getLatest(guid, sensorType);        if (found != null && expected.equals(found.getDocument())) {            return found;        }        if (t == MAX_RETRIES - 1) {            MapUtils.debugPrint(System.out, "Expected", expected);            MapUtils.debugPrint(System.out, "Actual", found.getDocument());        }    }    throw new OriginalNotFoundException("Count not find " + guid + " after " + MAX_RETRIES + " tries");}
protected IndexDao metron_f5558_0()
{    return dao;}
protected void metron_f5559_0(IndexDao dao)
{    this.dao = dao;}
public Document metron_f5560_0(String guid, String sensorType) throws IOException
{    return indexDao.getLatest(guid, sensorType);}
public Iterable<Document> metron_f5561_0(List<GetRequest> getRequests) throws IOException
{    return indexDao.getAllLatest(getRequests);}
public void metron_f5562_0() throws Exception
{    AccessConfig accessConfig = new AccessConfig();    accessConfig.setMaxSearchResults(1000);    accessConfig.setMaxSearchGroups(1000);    accessConfig.setGlobalConfigSupplier(() -> new HashMap<String, Object>() {        {            put(HBASE_TABLE, TABLE_NAME);            put(HBASE_CF, COLUMN_FAMILY);        }    });    MockHBaseTableProvider.addToCache(TABLE_NAME, COLUMN_FAMILY);    accessConfig.setTableProvider(new MockHBaseTableProvider());    hbaseDao = new HBaseDao();    hbaseDao.init(accessConfig);}
public void metron_f5563_0() throws Exception
{    MockHBaseTableProvider.clear();}
public void metron_f5564_0() throws IOException
{    HBaseDao.Key k = new HBaseDao.Key("guid", "sensorType");    byte[] raw = k.toBytes();    Assert.assertArrayEquals(raw, expectedKeySerialization);}
public void metron_f5565_0() throws Exception
{    HBaseDao.Key k = new HBaseDao.Key("guid", "sensorType");    Assert.assertEquals(k, HBaseDao.Key.fromBytes(HBaseDao.Key.toBytes(k)));}
public void metron_f5566_0() throws Exception
{    HBaseDao.Key k = new HBaseDao.Key(null, "sensorType");    Assert.assertEquals(k, HBaseDao.Key.fromBytes(HBaseDao.Key.toBytes(k)));}
public void metron_f5567_0() throws Exception
{    HBaseDao.Key k = new HBaseDao.Key("guid", null);    Assert.assertEquals(k, HBaseDao.Key.fromBytes(HBaseDao.Key.toBytes(k)));}
public void metron_f5568_0() throws Exception
{        List<Document> alerts = buildAlerts(3);    Map<Document, Optional<String>> updates = alerts.stream().collect(Collectors.toMap(document -> document, document -> Optional.empty()));    hbaseDao.batchUpdate(updates);    Document actualDocument = hbaseDao.getLatest("message_1", SENSOR_TYPE);    Document expectedDocument = alerts.get(1);    Assert.assertEquals(expectedDocument, actualDocument);}
public void metron_f5569_0() throws Exception
{        Document alert = buildAlerts(1).get(0);    hbaseDao.update(alert, Optional.empty());    Document actualDocument = hbaseDao.getLatest("message_0", SENSOR_TYPE);    Assert.assertEquals(alert, actualDocument);    alert.getDocument().put("field", "value");    alert.setTimestamp(0L);    hbaseDao.update(alert, Optional.empty());    actualDocument = hbaseDao.getLatest("message_0", SENSOR_TYPE);    Assert.assertEquals(alert.getDocument(), actualDocument.getDocument());}
public void metron_f5570_0() throws Exception
{        List<Document> alerts = buildAlerts(15);    alerts.stream().collect(Collectors.toMap(Document::getGuid, document -> Optional.empty()));    Map<Document, Optional<String>> updates = alerts.stream().collect(Collectors.toMap(document -> document, document -> Optional.empty()));    hbaseDao.batchUpdate(updates);    int expectedCount = 12;    List<GetRequest> getRequests = new ArrayList<>();    for (int i = 1; i < expectedCount + 1; i++) {        getRequests.add(new GetRequest("message_" + i, SENSOR_TYPE));    }    Iterator<Document> results = hbaseDao.getAllLatest(getRequests).iterator();    for (int i = 0; i < expectedCount; i++) {        Document expectedDocument = alerts.get(i + 1);        Document actualDocument = results.next();        Assert.assertEquals(expectedDocument, actualDocument);    }    Assert.assertFalse("Result size should be 12 but was greater", results.hasNext());}
protected List<Document> metron_f5571_0(int count) throws IOException
{    List<Document> alerts = new ArrayList<>();    for (int i = 0; i < count; ++i) {        String guid = "message_" + i;        String json = "{\"guid\":\"message_" + i + "\", \"source:type\":\"test\"}";        Document alert = new Document(json, guid, SENSOR_TYPE, System.currentTimeMillis());        alerts.add(alert);    }    return alerts;}
public void metron_f5572_0() throws Exception
{    Map<String, Object> fields = new HashMap<>();    fields.put("guid", "add_comment");    fields.put("source.type", SENSOR_NAME);    Document document = new Document(fields, "add_comment", SENSOR_NAME, 1526401584951L);    hbaseDao.update(document, Optional.of(SENSOR_NAME));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    addAlertComment("add_comment", "New Comment", "test_user", 1526401584951L);        ArrayList<AlertComment> comments = new ArrayList<>();    comments.add(new AlertComment("New Comment", "test_user", 1526401584951L));    document.getDocument().put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    addAlertComment("add_comment", "New Comment 2", "test_user_2", 1526401584952L);        comments.add(new AlertComment("New Comment 2", "test_user_2", 1526401584952L));    document.getDocument().put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    removeAlertComment("add_comment", "New Comment 2", "test_user_2", 1526401584952L);        comments = new ArrayList<>();    comments.add(new AlertComment(commentOne));    document.getDocument().put(COMMENTS_FIELD, comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);    removeAlertComment("add_comment", "New Comment", "test_user", 1526401584951L);        document.getDocument().remove(COMMENTS_FIELD);    findUpdatedDoc(document.getDocument(), "add_comment", SENSOR_NAME);}
protected IndexDao metron_f5573_0()
{    return hbaseDao;}
protected String metron_f5574_0()
{    return null;}
protected List<Map<String, Object>> metron_f5576_0(String indexName, String sensorType)
{    return null;}
public void metron_f5577_0()
{    IndexingConfigurations indexingConfigs = mock(IndexingConfigurations.class);    ConfigurationsCache cache = mock(ConfigurationsCache.class);    Map<String, Object> broIndexingConfig = new HashMap<String, Object>() {        {            put("writer", new HashMap<String, Object>() {                {                    put("index", "bro_index");                }            });        }    };    when(indexingConfigs.getSensorIndexingConfig("bro")).thenReturn(broIndexingConfig);    when(cache.get(IndexingConfigurations.class)).thenReturn(indexingConfigs);    assertEquals("bro_index", IndexingCacheUtil.getIndexLookupFunction(cache, "writer").apply("bro"));}
public void metron_f5578_0()
{    IndexingConfigurations indexingConfigs = mock(IndexingConfigurations.class);    ConfigurationsCache cache = mock(ConfigurationsCache.class);    Map<String, Object> broIndexingConfig = new HashMap<String, Object>() {        {            put("writer", new HashMap<String, Object>() {                {                    put("index", "bro_index");                }            });        }    };    when(indexingConfigs.getSensorIndexingConfig("bro")).thenReturn(broIndexingConfig);    when(cache.get(IndexingConfigurations.class)).thenReturn(indexingConfigs);    assertEquals("Should default to sensor type on missing sensor config", "snort", IndexingCacheUtil.getIndexLookupFunction(cache, "writer").apply("snort"));    assertEquals("Should default to sensor type on missing writer config", "bro", IndexingCacheUtil.getIndexLookupFunction(cache, "someWriter").apply("bro"));}
public static void metron_f5579_0(String hdfsDirStr)
{    File hdfsDir = new File(hdfsDirStr);    Stack<File> fs = new Stack<>();    if (hdfsDir.exists()) {        fs.push(hdfsDir);        while (!fs.empty()) {            File f = fs.pop();            if (f.isDirectory()) {                for (File child : f.listFiles()) {                    fs.push(child);                }            } else {                if (f.getName().startsWith("enrichment") || f.getName().endsWith(".json")) {                    f.delete();                }            }        }    }}
public static List<Map<String, Object>> metron_f5580_0(String hdfsDirStr) throws IOException
{    List<Map<String, Object>> ret = new ArrayList<>();    File hdfsDir = new File(hdfsDirStr);    Stack<File> fs = new Stack<>();    if (hdfsDir.exists()) {        fs.push(hdfsDir);        while (!fs.empty()) {            File f = fs.pop();            if (f.isDirectory()) {                for (File child : f.listFiles()) {                    fs.push(child);                }            } else {                System.out.println("Processed " + f);                if (f.getName().startsWith("enrichment") || f.getName().endsWith(".json")) {                    List<byte[]> data = TestUtils.readSampleData(f.getPath());                    Iterables.addAll(ret, Iterables.transform(data, bytes -> {                        String s = new String(bytes, StandardCharsets.UTF_8);                        try {                            return JSONUtils.INSTANCE.load(s, JSONUtils.MAP_SUPPLIER);                        } catch (IOException e) {                            throw new RuntimeException(e);                        }                    }));                }            }        }    }    return ret;}
protected void metron_f5581_0()
{    cleanHdfsDir(hdfsDir);}
public Processor<List<Map<String, Object>>> metron_f5582_0(List<byte[]> inputMessages)
{    return new Processor<List<Map<String, Object>>>() {        List<Map<String, Object>> docs = null;        List<byte[]> errors = null;        @Override        public ReadinessState process(ComponentRunner runner) {            KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);            try {                docs = readDocsFromDisk(hdfsDir);            } catch (IOException e) {                throw new IllegalStateException("Unable to retrieve indexed documents.", e);            }            if (docs.size() < inputMessages.size()) {                errors = kafkaComponent.readMessages(IndexingIntegrationTest.ERROR_TOPIC);                if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {                    return ReadinessState.READY;                }                return ReadinessState.NOT_READY;            } else {                return ReadinessState.READY;            }        }        @Override        public ProcessorResult<List<Map<String, Object>>> getResult() {            ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();            return builder.withResult(docs).withProcessErrors(errors).build();        }    };}
public ReadinessState metron_f5583_0(ComponentRunner runner)
{    KafkaComponent kafkaComponent = runner.getComponent("kafka", KafkaComponent.class);    try {        docs = readDocsFromDisk(hdfsDir);    } catch (IOException e) {        throw new IllegalStateException("Unable to retrieve indexed documents.", e);    }    if (docs.size() < inputMessages.size()) {        errors = kafkaComponent.readMessages(IndexingIntegrationTest.ERROR_TOPIC);        if (errors.size() > 0 && errors.size() + docs.size() == inputMessages.size()) {            return ReadinessState.READY;        }        return ReadinessState.NOT_READY;    } else {        return ReadinessState.READY;    }}
public ProcessorResult<List<Map<String, Object>>> metron_f5584_0()
{    ProcessorResult.Builder<List<Map<String, Object>>> builder = new ProcessorResult.Builder();    return builder.withResult(docs).withProcessErrors(errors).build();}
public FieldNameConverter metron_f5585_0()
{    return originalField -> originalField;}
public InMemoryComponent metron_f5586_0(Properties topologyProperties) throws Exception
{    return null;}
public void metron_f5587_0(Properties topologyProperties)
{    topologyProperties.setProperty("batch_indexing_kafka_start", "UNCOMMITTED_EARLIEST");    topologyProperties.setProperty("batch_indexing_workers", "1");    topologyProperties.setProperty("batch_indexing_acker_executors", "0");    topologyProperties.setProperty("batch_indexing_topology_max_spout_pending", "");    topologyProperties.setProperty("batch_indexing_kafka_spout_parallelism", "1");    topologyProperties.setProperty("bolt_hdfs_rotation_policy", "org.apache.storm.hdfs.bolt.rotation.TimedRotationPolicy");    topologyProperties.setProperty("bolt_hdfs_rotation_policy_count", "1");    topologyProperties.setProperty("bolt_hdfs_rotation_policy_units", "DAYS");    topologyProperties.setProperty("metron_apps_indexed_hdfs_dir", hdfsDir);    topologyProperties.setProperty("hdfs_writer_parallelism", "1");}
public String metron_f5588_0(String field)
{    return field;}
public String metron_f5589_0()
{    return "../metron-indexing-storm/src/main/config/hdfs.properties.j2";}
public String metron_f5590_0()
{    return "../metron-indexing-storm/src/main/flux/indexing/batch/remote.yaml";}
public void metron_f5592_0() throws Exception
{    final List<byte[]> inputMessages = TestUtils.readSampleData(sampleParsedPath);    final Properties topologyProperties = new Properties() {        {            setProperty("indexing_kafka_start", "UNCOMMITTED_EARLIEST");            setProperty("kafka_security_protocol", "PLAINTEXT");            setProperty("topology_auto_credentials", "[]");            setProperty("indexing_workers", "1");            setProperty("indexing_acker_executors", "0");            setProperty("indexing_topology_worker_childopts", "");            setProperty("indexing_topology_max_spout_pending", "");            setProperty("indexing_input_topic", Constants.INDEXING_TOPIC);            setProperty("indexing_error_topic", ERROR_TOPIC);            setProperty("indexing_kafka_spout_parallelism", "1");            setProperty("indexing_writer_parallelism", "1");        }    };    setAdditionalProperties(topologyProperties);    final ZKServerComponent zkServerComponent = getZKServerComponent(topologyProperties);    final KafkaComponent kafkaComponent = getKafkaComponent(topologyProperties, new ArrayList<KafkaComponent.Topic>() {        {            add(new KafkaComponent.Topic(Constants.INDEXING_TOPIC, 1));            add(new KafkaComponent.Topic(ERROR_TOPIC, 1));        }    });    List<Map<String, Object>> inputDocs = new ArrayList<>();    for (byte[] b : inputMessages) {        Map<String, Object> m = JSONUtils.INSTANCE.load(new String(b, StandardCharsets.UTF_8), JSONUtils.MAP_SUPPLIER);        inputDocs.add(m);    }    final AtomicBoolean isLoaded = new AtomicBoolean(false);    ConfigUploadComponent configUploadComponent = new ConfigUploadComponent().withTopologyProperties(topologyProperties).withGlobalConfigsPath(sampleConfigPath).withEnrichmentConfigsPath(sampleConfigPath).withIndexingConfigsPath(sampleConfigPath).withPostStartCallback(component -> {        try {            waitForIndex(component.getTopologyProperties().getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY));        } catch (Exception e) {            e.printStackTrace();        }        isLoaded.set(true);    });    FluxTopologyComponent fluxComponent = new FluxTopologyComponent.Builder().withTopologyLocation(new File(getFluxPath())).withTopologyName("test").withTemplateLocation(new File(getTemplatePath())).withTopologyProperties(topologyProperties).build();    ComponentRunner runner = null;    InMemoryComponent searchComponent = getSearchComponent(topologyProperties);    ComponentRunner.Builder componentBuilder = new ComponentRunner.Builder();    componentBuilder = componentBuilder.withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withComponent("config", configUploadComponent).withComponent("storm", fluxComponent).withMillisecondsBetweenAttempts(1500).withNumRetries(NUM_RETRIES).withMaxTimeMS(TOTAL_TIME_MS);    if (searchComponent != null) {        componentBuilder = componentBuilder.withComponent("search", getSearchComponent(topologyProperties)).withCustomShutdownOrder(new String[] { "search", "storm", "config", "kafka", "zk" });    } else {        componentBuilder = componentBuilder.withCustomShutdownOrder(new String[] { "storm", "config", "kafka", "zk" });    }    runner = componentBuilder.build();    try {        runner.start();        while (!isLoaded.get()) {            Thread.sleep(100);        }        fluxComponent.submitTopology();        kafkaComponent.writeMessages(Constants.INDEXING_TOPIC, inputMessages);        List<Map<String, Object>> docs = cleanDocs(runner.process(getProcessor(inputMessages)));        Assert.assertEquals(docs.size(), inputMessages.size());                        assertInputDocsMatchOutputs(inputDocs, docs, getFieldNameConverter());    } finally {        if (runner != null) {            runner.stop();        }    }}
private void metron_f5593_0(String zookeeperQuorum) throws Exception
{    try (CuratorFramework client = getClient(zookeeperQuorum)) {        client.start();        System.out.println("Waiting for zookeeper...");        byte[] bytes = null;        do {            try {                bytes = ConfigurationsUtils.readSensorIndexingConfigBytesFromZookeeper(testSensorType, client);                Thread.sleep(1000);            } catch (KeeperException.NoNodeException nne) {                        }        } while (bytes == null || bytes.length == 0);        System.out.println("Found index config in zookeeper...");    }}
public List<Map<String, Object>> metron_f5594_0(ProcessorResult<List<Map<String, Object>>> result)
{    List<Map<String, Object>> docs = result.getResult();    StringBuffer buffer = new StringBuffer();    boolean failed = false;    List<Map<String, Object>> ret = new ArrayList<>();    if (result.failed()) {        failed = true;        result.getBadResults(buffer);        buffer.append(String.format("%d Valid messages processed", docs.size())).append("\n");        for (Map<String, Object> doc : docs) {            Map<String, Object> msg = new HashMap<>();            for (Map.Entry<String, Object> kv : doc.entrySet()) {                                buffer.append(cleanField(kv.getKey())).append(kv.getValue().toString()).append("\n");            }        }        Assert.fail(buffer.toString());    } else {        for (Map<String, Object> doc : docs) {            Map<String, Object> msg = new HashMap<>();            for (Map.Entry<String, Object> kv : doc.entrySet()) {                                msg.put(cleanField(kv.getKey()), kv.getValue());            }            ret.add(msg);        }    }    return ret;}
public void metron_f5595_0(List<Map<String, Object>> inputDocs, List<Map<String, Object>> indexDocs, FieldNameConverter converter)
{    for (Map<String, Object> indexDoc : indexDocs) {        boolean foundMatch = false;        for (Map<String, Object> doc : inputDocs) {            if (docMatches(indexDoc, doc, converter)) {                foundMatch = true;                break;            }        }        if (!foundMatch) {            System.err.println("Unable to find: ");            printMessage(indexDoc);            dumpMessages("INPUT DOCS:", inputDocs);        }        Assert.assertTrue(foundMatch);    }}
private void metron_f5596_0(Map<String, Object> doc)
{    TreeMap<String, Object> d = new TreeMap<>(doc);    for (Map.Entry<String, Object> kv : d.entrySet()) {        System.err.println("  " + kv.getKey() + " -> " + kv.getValue());    }}
private void metron_f5597_0(String title, List<Map<String, Object>> docs)
{    System.err.println(title);    int cnt = 0;    for (Map<String, Object> doc : docs) {        System.err.println("MESSAGE " + cnt++);        printMessage(doc);    }}
 boolean metron_f5598_0(Map<String, Object> indexedDoc, Map<String, Object> inputDoc, FieldNameConverter converter)
{    String key = "original_string";    String indexKey = converter.convert(key);    String originalString = inputDoc.get(key).toString();    return originalString.equals(indexedDoc.get(indexKey).toString());}
protected static KafkaComponent metron_f5599_0(final Properties topologyProperties, List<KafkaComponent.Topic> topics)
{    return new KafkaComponent().withTopics(topics).withTopologyProperties(topologyProperties);}
protected static ZKServerComponent metron_f5600_0(final Properties topologyProperties)
{    return new ZKServerComponent().withPostStartCallback((zkComponent) -> {        topologyProperties.setProperty(ZKServerComponent.ZOOKEEPER_PROPERTY, zkComponent.getConnectionString());        topologyProperties.setProperty("kafka.zk", zkComponent.getConnectionString());    });}
public Builder metron_f5601_0(int numRetries)
{    this.numRetries = numRetries;    return this;}
public Builder metron_f5602_0(long maxTimeMS)
{    this.maxTimeMS = maxTimeMS;    return this;}
public Builder metron_f5603_0(String name, InMemoryComponent component)
{    components.put(name, component);    return this;}
public Builder metron_f5604_0(String[] startupOrder)
{    this.startupOrder = startupOrder;    return this;}
public Builder metron_f5605_0(String[] shutdownOrder)
{    this.shutdownOrder = shutdownOrder;    return this;}
public Builder metron_f5606_0(String[] resetOrder)
{    this.resetOrder = resetOrder;    return this;}
public Builder metron_f5607_0(long timeBetweenAttempts)
{    this.timeBetweenAttempts = timeBetweenAttempts;    return this;}
private static String[] metron_f5608_0(Map<String, InMemoryComponent> components)
{    String[] ret = new String[components.size()];    int i = 0;    for (String component : components.keySet()) {        ret[i++] = component;    }    return ret;}
public ComponentRunner metron_f5609_0()
{    if (shutdownOrder == null) {        shutdownOrder = toOrderedList(components);    }    if (startupOrder == null) {        startupOrder = toOrderedList(components);    }    if (resetOrder == null) {                if (shutdownOrder != null) {            resetOrder = shutdownOrder;        } else {            resetOrder = toOrderedList(components);        }    }    return new ComponentRunner(components, startupOrder, shutdownOrder, resetOrder, timeBetweenAttempts, numRetries, maxTimeMS);}
public T metron_f5610_0(String name, Class<T> clazz)
{    return clazz.cast(getComponents().get(name));}
public LinkedHashMap<String, InMemoryComponent> metron_f5611_0()
{    return components;}
public void metron_f5612_0() throws UnableToStartException
{    for (String componentName : startupOrder) {        components.get(componentName).start();    }}
public void metron_f5613_0()
{    for (String componentName : shutdownOrder) {        components.get(componentName).stop();    }}
public void metron_f5614_0()
{    for (String componentName : resetOrder) {        components.get(componentName).reset();    }}
public ProcessorResult<T> metron_f5615_0(Processor<T> successState)
{    int retryCount = 0;    long start = System.currentTimeMillis();    while (true) {        long duration = System.currentTimeMillis() - start;        if (maxTimeMS > 0 && duration > maxTimeMS) {            throw new RuntimeException("Took too long to complete: " + duration + " > " + maxTimeMS);        }        ReadinessState state = successState.process(this);        if (state == ReadinessState.READY) {            return successState.getResult();        } else if (state == ReadinessState.NOT_READY) {            retryCount++;            if (numRetries > 0 && retryCount > numRetries) {                throw new RuntimeException("Too many retries: " + retryCount);            }        }        try {            Thread.sleep(timeBetweenAttempts);        } catch (InterruptedException e) {            throw new RuntimeException("Unable to sleep", e);        }    }}
public Builder metron_f5616_0(String name)
{    this.topologyName = name;    return this;}
public Builder metron_f5617_0(File location)
{    this.topologyLocation = location;    return this;}
public Builder metron_f5618_0(File location)
{    this.templateLocation = location;    return this;}
public Builder metron_f5619_0(Properties properties)
{    this.topologyProperties = properties;    this.topologyProperties.put("storm.home", "target");    return this;}
public FluxTopologyComponent metron_f5620_0()
{    return new FluxTopologyComponent(topologyName, topologyLocation, templateLocation, topologyProperties);}
public LocalCluster metron_f5621_0()
{    return stormCluster;}
public String metron_f5622_0()
{    return topologyName;}
public File metron_f5623_0()
{    return topologyLocation;}
public File metron_f5624_0()
{    return templateLocation;}
public Properties metron_f5625_0()
{    return topologyProperties;}
public String metron_f5626_0()
{    return "localhost:2000";}
public void metron_f5627_1() throws UnableToStartException
{    try {        stormCluster = new LocalCluster();        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);        try (CuratorFramework client = CuratorFrameworkFactory.newClient(getZookeeperConnectString(), retryPolicy)) {            client.start();            String root = "/storm/leader-lock";            Stat exists = client.checkExists().forPath(root);            if (exists == null) {                client.create().creatingParentsIfNeeded().forPath(root);            }        } catch (Exception e) {                    } finally {        }    } catch (Exception e) {        throw new UnableToStartException("Unable to start flux topology: " + getTopologyLocation(), e);    }}
public static void metron_f5628_0()
{    if (new File("logs/workers-artifacts").exists()) {        Path rootPath = Paths.get("logs");        Path destPath = Paths.get("target/logs");        try {            Files.move(rootPath, destPath);            Files.walk(destPath).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);        } catch (IOException e) {            throw new IllegalStateException(e.getMessage(), e);        }    }}
public void metron_f5629_1()
{    if (stormCluster != null) {        try {            try {                                killTopology();                stormCluster.shutdown();            } catch (IllegalStateException ise) {                if (!(ise.getMessage().contains("It took over") && ise.getMessage().contains("to shut down slot"))) {                    throw ise;                } else {                                        assassinateSlots();                                    }            } catch (RuntimeException re) {                if (re.getCause() instanceof TProtocolException) {                                } else {                    throw re;                }            }        } catch (Throwable t) {                    } finally {            cleanupWorkerDir();        }    }}
public void metron_f5630_0()
{    if (stormCluster != null) {        killTopology();    }}
protected void metron_f5631_0()
{    KillOptions ko = new KillOptions();    ko.set_wait_secs(0);    stormCluster.killTopologyWithOpts(topologyName, ko);    try {                Thread.sleep(2000);    } catch (InterruptedException e) {        }}
public static void metron_f5632_1()
{    /*    You might be wondering why I'm not just casting to slot here, but that's because the Slot class moved locations    and we're supporting multiple versions of storm.     */        Thread.getAllStackTraces().keySet().stream().filter(t -> t instanceof AutoCloseable && t.getName().toLowerCase().contains("slot")).forEach(t -> {                        try {            t.stop();                    } catch (Exception e) {                }    });}
public void metron_f5633_0() throws NoSuchMethodException, IOException, InstantiationException, TException, IllegalAccessException, InvocationTargetException, ClassNotFoundException, NoSuchFieldException
{    startTopology(getTopologyName(), getTopologyLocation(), getTemplateLocation(), getTopologyProperties());}
private void metron_f5634_0(String topologyName, File topologyLoc, File templateFile, Properties properties) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, TException, NoSuchFieldException
{    TopologyDef topologyDef = loadYaml(topologyName, topologyLoc, templateFile, properties);    Config conf = FluxBuilder.buildConfig(topologyDef);    ExecutionContext context = new ExecutionContext(topologyDef, conf);    StormTopology topology = FluxBuilder.buildTopology(context);    Assert.assertNotNull(topology);    topology.validate();    try {        stormCluster.submitTopology(topologyName, conf, topology);    } catch (Exception nne) {        try {            Thread.sleep(2000);        } catch (InterruptedException e) {        }        stormCluster.submitTopology(topologyName, conf, topology);    }}
private static TopologyDef metron_f5635_0(String topologyName, File yamlFile, File templateFile, Properties properties) throws IOException
{    File tmpFile = File.createTempFile(topologyName, "props");    tmpFile.deleteOnExit();    if (templateFile != null) {        try (Writer propWriter = new OutputStreamWriter(new FileOutputStream(tmpFile), StandardCharsets.UTF_8)) {            String templateContents = FileUtils.readFileToString(templateFile);            for (Map.Entry prop : properties.entrySet()) {                String replacePattern = String.format("{{%s}}", prop.getKey());                templateContents = templateContents.replaceAll(Pattern.quote(replacePattern), (String) prop.getValue());            }            propWriter.write(templateContents);            propWriter.flush();            return FluxParser.parseFile(yamlFile.getAbsolutePath(), false, true, tmpFile.getAbsolutePath(), false);        }    } else {        try (Writer propWriter = new OutputStreamWriter(new FileOutputStream(tmpFile), StandardCharsets.UTF_8)) {            properties.store(propWriter, topologyName + " properties");            return FluxParser.parseFile(yamlFile.getAbsolutePath(), false, true, tmpFile.getAbsolutePath(), false);        }    }}
public KafkaComponent metron_f5636_0(Function<KafkaComponent, Void> f)
{    postStartCallback = f;    return this;}
public KafkaComponent metron_f5637_0(String zookeeperConnectString)
{    this.zookeeperConnectString = zookeeperConnectString;    return this;}
public KafkaComponent metron_f5638_0(Properties properties)
{    this.topologyProperties = properties;    return this;}
public KafkaComponent metron_f5639_0(int brokerPort)
{    if (brokerPort <= 0) {        brokerPort = TestUtils.RandomPort();    }    this.brokerPort = brokerPort;    return this;}
public KafkaComponent metron_f5640_0(List<Topic> topics)
{    this.topics = topics;    return this;}
public List<Topic> metron_f5641_0()
{    return topics;}
public int metron_f5642_0()
{    return brokerPort;}
public String metron_f5643_0()
{    return "localhost:" + brokerPort;}
public KafkaProducer<K, V> metron_f5644_0(Class<K> keyClass, Class<V> valueClass)
{    return createProducer(new HashMap<>(), keyClass, valueClass);}
public KafkaProducer<String, byte[]> metron_f5645_0()
{    return createProducer(String.class, byte[].class);}
public KafkaProducer<K, V> metron_f5646_0(Map<String, Object> properties, Class<K> keyClass, Class<V> valueClass)
{    Map<String, Object> producerConfig = new HashMap<>();    producerConfig.put("bootstrap.servers", getBrokerList());    producerConfig.put("key.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");    producerConfig.put("value.serializer", "org.apache.kafka.common.serialization.ByteArraySerializer");    producerConfig.put("request.required.acks", "-1");    producerConfig.put("fetch.message.max.bytes", "" + 1024 * 1024 * 10);    producerConfig.put("replica.fetch.max.bytes", "" + 1024 * 1024 * 10);    producerConfig.put("message.max.bytes", "" + 1024 * 1024 * 10);    producerConfig.put("message.send.max.retries", "10");    producerConfig.putAll(properties);    KafkaProducer<K, V> ret = new KafkaProducer<>(producerConfig);    producersCreated.add(ret);    return ret;}
public void metron_f5647_0()
{        zookeeperConnectString = topologyProperties.getProperty(ZKServerComponent.ZOOKEEPER_PROPERTY);    zkClient = new ZkClient(zookeeperConnectString, ZK_SESSION_TIMEOUT_MS, ZK_CONNECTION_TIMEOUT_MS, ZKStringSerializer$.MODULE$);        Properties props = TestUtilsWrapper.createBrokerConfig(0, zookeeperConnectString, brokerPort);    props.setProperty("zookeeper.connection.timeout.ms", Integer.toString(KAFKA_ZOOKEEPER_TIMEOUT_MS));    KafkaConfig config = new KafkaConfig(props);    Time mock = new MockTime();    kafkaServer = TestUtils.createServer(config, mock);    org.apache.log4j.Level oldLevel = UnitTestHelper.getLog4jLevel(KafkaServer.class);    UnitTestHelper.setLog4jLevel(KafkaServer.class, org.apache.log4j.Level.OFF);        TestUtilsWrapper.waitUntilBrokerIsRunning(kafkaServer, "Timed out waiting for RunningAsBroker State", 100000);    for (Topic topic : getTopics()) {        try {            createTopic(topic.name, topic.numPartitions, KAFKA_PROPAGATE_TIMEOUT_MS);        } catch (InterruptedException e) {            throw new RuntimeException("Unable to create topic", e);        }    }    UnitTestHelper.setLog4jLevel(KafkaServer.class, oldLevel);    if (postStartCallback != null) {        postStartCallback.apply(this);    }}
public String metron_f5648_0()
{    return zookeeperConnectString;}
public void metron_f5649_0()
{    shutdownConsumer();    shutdownProducers();    if (kafkaServer != null) {        try {            kafkaServer.shutdown();            kafkaServer.awaitShutdown();        } catch (Throwable fnf) {            if (!fnf.getMessage().contains("Error writing to highwatermark file")) {                throw fnf;            }        }    }    if (zkClient != null) {                for (Topic topic : topics) {            zkClient.deleteRecursive(ZkUtils.getTopicPath(topic.name));        }        zkClient.deleteRecursive(ZkUtils.BrokerIdsPath());        zkClient.deleteRecursive(ZkUtils.BrokerTopicsPath());        zkClient.deleteRecursive(ZkUtils.ConsumersPath());        zkClient.deleteRecursive(ZkUtils.ControllerPath());        zkClient.deleteRecursive(ZkUtils.ControllerEpochPath());        zkClient.deleteRecursive(ZkUtils.ReassignPartitionsPath());        zkClient.deleteRecursive(ZkUtils.DeleteTopicsPath());        zkClient.deleteRecursive(ZkUtils.PreferredReplicaLeaderElectionPath());        zkClient.deleteRecursive(ZkUtils.BrokerSequenceIdPath());        zkClient.deleteRecursive(ZkUtils.IsrChangeNotificationPath());        zkClient.deleteRecursive(ZkUtils.EntityConfigPath());        zkClient.deleteRecursive(ZkUtils.EntityConfigChangesPath());        zkClient.close();    }}
public void metron_f5650_0()
{            stop();    start();}
public List<byte[]> metron_f5651_0(String topic)
{    SimpleConsumer consumer = new SimpleConsumer("localhost", 6667, 100000, 64 * 1024, "consumer");    FetchRequest req = new FetchRequestBuilder().clientId("consumer").addFetch(topic, 0, 0, 100000).build();    FetchResponse fetchResponse = consumer.fetch(req);    Iterator<MessageAndOffset> results = fetchResponse.messageSet(topic, 0).iterator();    List<byte[]> messages = new ArrayList<>();    while (results.hasNext()) {        ByteBuffer payload = results.next().message().payload();        byte[] bytes = new byte[payload.limit()];        payload.get(bytes);        messages.add(bytes);    }    consumer.close();    return messages;}
public ConsumerIterator<byte[], byte[]> metron_f5652_0(String topic)
{    return getStreamIterator(topic, "group0", "consumer0");}
public ConsumerIterator<byte[], byte[]> metron_f5653_0(String topic, String group, String consumerName)
{        Properties consumerProperties = TestUtils.createConsumerProperties(zookeeperConnectString, group, consumerName, -1);    consumer = kafka.consumer.Consumer.createJavaConsumerConnector(new ConsumerConfig(consumerProperties));    Map<String, Integer> topicCountMap = new HashMap<String, Integer>();    topicCountMap.put(topic, 1);    Map<String, List<KafkaStream<byte[], byte[]>>> consumerMap = consumer.createMessageStreams(topicCountMap);    KafkaStream<byte[], byte[]> stream = consumerMap.get(topic).get(0);    ConsumerIterator<byte[], byte[]> iterator = stream.iterator();    return iterator;}
public void metron_f5654_0()
{    if (consumer != null) {        consumer.shutdown();    }}
public void metron_f5655_1()
{    for (KafkaProducer kp : producersCreated) {        try {            kp.close();        } catch (Exception ex) {                    }    }}
public void metron_f5656_0(String name) throws InterruptedException
{    createTopic(name, 1, KAFKA_PROPAGATE_TIMEOUT_MS);}
public void metron_f5657_0(String topic, int numPartitions, long timeOutMS)
{    List<KafkaServer> servers = new ArrayList<>();    servers.add(kafkaServer);    for (int part = 0; part < numPartitions; ++part) {        TestUtils.waitUntilMetadataIsPropagated(scala.collection.JavaConversions.asScalaBuffer(servers), topic, part, timeOutMS);    }}
public void metron_f5658_0(String name, int numPartitions, long waitThisLongForMetadataToPropagate) throws InterruptedException
{    ZkUtils zkUtils = null;    Level oldLevel = UnitTestHelper.getJavaLoggingLevel();    try {        UnitTestHelper.setJavaLoggingLevel(Level.OFF);        zkUtils = ZkUtils.apply(zookeeperConnectString, 30000, 30000, false);        AdminUtilsWrapper.createTopic(zkUtils, name, numPartitions, 1, new Properties());        if (waitThisLongForMetadataToPropagate > 0) {            waitUntilMetadataIsPropagated(name, numPartitions, waitThisLongForMetadataToPropagate);        }    } catch (TopicExistsException tee) {    } finally {        if (zkUtils != null) {            zkUtils.close();        }        UnitTestHelper.setJavaLoggingLevel(oldLevel);    }}
public void metron_f5659_0(String topic, Collection<byte[]> messages)
{    try (KafkaProducer<String, byte[]> kafkaProducer = createProducer()) {        for (byte[] message : messages) {            kafkaProducer.send(new ProducerRecord<>(topic, message));        }    }}
public void metron_f5660_0(String topic, String... messages)
{        List<byte[]> messagesAsBytes = Stream.of(messages).map(Bytes::toBytes).collect(Collectors.toList());    writeMessages(topic, messagesAsBytes);}
public void metron_f5661_0(String topic, List<String> messages)
{    writeMessages(topic, messages.toArray(new String[] {}));}
public MRComponent metron_f5662_0(String path)
{    basePath = new Path(path);    return this;}
public Configuration metron_f5663_0()
{    return configuration;}
public Path metron_f5664_0()
{    return basePath;}
public void metron_f5665_0()
{    configuration = new Configuration();    System.clearProperty(MiniDFSCluster.PROP_TEST_BUILD_DATA);    configuration.set(YarnConfiguration.YARN_MINICLUSTER_FIXED_PORTS, "true");    if (basePath == null) {        throw new RuntimeException("Unable to start cluster: You must specify the basepath");    }    configuration.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, basePath.toString());    try {        cluster = new MiniDFSCluster.Builder(configuration).build();    } catch (IOException e) {        throw new RuntimeException("Unable to start cluster", e);    }}
public void metron_f5666_0()
{    cluster.shutdown();}
public YarnComponent metron_f5667_0(Class clazz)
{    appmasterJar = JarFinder.getJar(clazz);    return this;}
public YarnComponent metron_f5668_0(String name)
{    this.testName = name;    return this;}
public String metron_f5669_0()
{    return appmasterJar;}
public YarnConfiguration metron_f5670_0()
{    return conf;}
public MiniYARNCluster metron_f5671_0()
{    return yarnCluster;}
public void metron_f5672_0() throws UnableToStartException
{    conf = new YarnConfiguration();    conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB, 128);    conf.set("yarn.log.dir", "target");    conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, true);    conf.set(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class.getName());    conf.setBoolean(YarnConfiguration.NODE_LABELS_ENABLED, true);    try {        yarnCluster = new MiniYARNCluster(testName, 1, NUM_NMS, 1, 1, true);        yarnCluster.init(conf);        yarnCluster.start();        waitForNMsToRegister();        URL url = Thread.currentThread().getContextClassLoader().getResource("yarn-site.xml");        if (url == null) {            throw new RuntimeException("Could not find 'yarn-site.xml' dummy file in classpath");        }        Configuration yarnClusterConfig = yarnCluster.getConfig();        yarnClusterConfig.set("yarn.application.classpath", new File(url.getPath()).getParent());                        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();        yarnClusterConfig.writeXml(bytesOut);        bytesOut.close();                OutputStream os = new FileOutputStream(new File(url.getPath()));        os.write(bytesOut.toByteArray());        os.close();        FileContext fsContext = FileContext.getLocalFSFileContext();        fsContext.delete(new Path(conf.get("yarn.timeline-service.leveldb-timeline-store.path")), true);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {        }    } catch (Exception e) {        throw new UnableToStartException("Exception setting up yarn cluster", e);    }}
public void metron_f5673_0()
{    if (yarnCluster != null) {        try {            yarnCluster.stop();        } finally {            yarnCluster = null;        }    }    try {        FileContext fsContext = FileContext.getLocalFSFileContext();        fsContext.delete(new Path(conf.get("yarn.timeline-service.leveldb-timeline-store.path")), true);    } catch (Exception e) {    }}
protected void metron_f5674_0() throws Exception
{    int sec = 60;    while (sec >= 0) {        if (yarnCluster.getResourceManager().getRMContext().getRMNodes().size() >= NUM_NMS) {            break;        }        Thread.sleep(1000);        sec--;    }}
public String metron_f5675_0()
{    return this.zookeeperUrl;}
public ZKServerComponent metron_f5676_0(Consumer<ZKServerComponent> f)
{    postStartCallback = Optional.ofNullable(f);    return this;}
public void metron_f5677_0() throws UnableToStartException
{    try {        testZkServer = new TestingServer(true);        zookeeperUrl = testZkServer.getConnectString();        if (postStartCallback.isPresent()) {            postStartCallback.get().accept(this);        }    } catch (Exception e) {        throw new UnableToStartException("Unable to start TestingServer", e);    }}
public void metron_f5678_0()
{    try {        if (testZkServer != null) {            testZkServer.close();        }    } catch (Exception e) {        }}
public void metron_f5679_0()
{    if (testZkServer != null) {        try {            FileUtils.deleteDirectory(testZkServer.getTempDirectory());        } catch (IOException e) {                }    }}
public Builder metron_f5681_0(T result)
{    this.result = result;    return this;}
public Builder metron_f5682_0(List<byte[]> processErrors)
{    this.processErrors = processErrors;    return this;}
public ProcessorResult<T> metron_f5683_0()
{    return new ProcessorResult<T>(result, processErrors);}
public T metron_f5684_0()
{    return result;}
public List<byte[]> metron_f5685_0()
{    return processErrors;}
public boolean metron_f5686_0()
{    return processErrors.size() > 0;}
public void metron_f5687_0(StringBuffer buffer)
{    if (buffer == null) {        return;    }    buffer.append(String.format("%d Errors", processErrors.size()));    for (byte[] outputMessage : processErrors) {        buffer.append(new String(outputMessage, StandardCharsets.UTF_8));    }    buffer.append("\n");}
public List<byte[]> metron_f5688_0()
{    return messages;}
public List<byte[]> metron_f5689_0()
{    return errors;}
public KafkaProcessor metron_f5690_0(String name)
{    this.kafkaComponentName = name;    return this;}
public KafkaProcessor metron_f5691_0(String topicName)
{    this.readTopic = topicName;    return this;}
public KafkaProcessor metron_f5692_0(String topicName)
{    this.errorTopic = topicName;    return this;}
public KafkaProcessor metron_f5693_0(Function<KafkaMessageSet, Boolean> validate)
{    this.validateReadMessages = validate;    return this;}
public KafkaProcessor metron_f5694_0(Function<KafkaMessageSet, T> provide)
{    this.provideResult = provide;    return this;}
public ReadinessState metron_f5695_0(ComponentRunner runner)
{    KafkaComponent kafkaComponent = runner.getComponent(kafkaComponentName, KafkaComponent.class);    LinkedList<byte[]> outputMessages = new LinkedList<>(kafkaComponent.readMessages(readTopic));    LinkedList<byte[]> outputErrors = null;    if (errorTopic != null) {        outputErrors = new LinkedList<>(kafkaComponent.readMessages(errorTopic));    }    Boolean validated = validateReadMessages.apply(new KafkaMessageSet(outputMessages, outputErrors));    if (validated == null) {        validated = false;    }    if (validated) {        messages.addAll(outputMessages);        errors.addAll(outputErrors);        outputMessages.clear();        outputErrors.clear();        return ReadinessState.READY;    }    return ReadinessState.NOT_READY;}
public ProcessorResult<T> metron_f5696_0()
{    ProcessorResult.Builder<T> builder = new ProcessorResult.Builder();    return builder.withResult(provideResult.apply(new KafkaMessageSet(messages, errors))).withProcessErrors(errors).build();}
public static void metron_f5697_0()
{    component = new MRComponent().withBasePath("target");    component.start();    configuration = component.getConfiguration();    try {        FileSystem fs = FileSystem.newInstance(configuration);        fs.mkdirs(new Path("/classpath-resources"));        fs.copyFromLocalFile(new Path("src/test/classpath-resources/custom-1.0-SNAPSHOT.jar"), new Path("/classpath-resources"));    } catch (IOException e) {        throw new RuntimeException("Unable to start cluster", e);    }}
public static void metron_f5698_0()
{    component.stop();}
public static ClasspathFunctionResolver metron_f5699_0(Properties config)
{    ClasspathFunctionResolver resolver = new ClasspathFunctionResolver();    Context context = new Context.Builder().with(Context.Capabilities.STELLAR_CONFIG, () -> config).build();    resolver.initialize(context);    return resolver;}
public void metron_f5700_0() throws Exception
{    Properties config = new Properties();    config.put(STELLAR_VFS_PATHS.param(), configuration.get("fs.defaultFS") + "/classpath-resources/.*.jar");    ClasspathFunctionResolver resolver = create(config);    HashSet<String> functions = new HashSet<>(Lists.newArrayList(resolver.getFunctions()));    Assert.assertTrue(functions.contains("NOW"));}
public static void metron_f5701_0(ThrowingBiConsumer<TestZKServer, CuratorFramework> testFunc) throws Exception
{    try (TestZKServer zkServer = new TestZKServer();        CuratorFramework zkClient = zkServer.newClient()) {        zkClient.start();        testFunc.accept(zkServer, zkClient);    }}
public String metron_f5702_0()
{    return zookeeperUrl;}
public CuratorFramework metron_f5703_0()
{    return ConfigurationsUtils.getClient(zookeeperUrl);}
public void metron_f5704_0()
{    testZkServer.stop();    testZkServer.reset();}
public static void metron_f5705_0(Producer<K, V> producer, K key, V value, String topic)
{    ProducerRecord<K, V> record = new ProducerRecord<K, V>(topic, key, value);    producer.send(record);}
public static void metron_f5706_0(Producer<K, V> producer, Iterable<Map.Entry<K, V>> messages, String topic, long sleepBetween) throws InterruptedException
{    for (Map.Entry<K, V> kv : messages) {        send(producer, kv.getKey(), kv.getValue(), topic);        if (sleepBetween > 0) {            Thread.sleep(sleepBetween);        }    }}
public static void metron_f5707_0(Assertion assertion) throws Exception
{    assertEventually(assertion, MAX_ASSERT_WAIT_MS);}
public static void metron_f5708_0(Assertion assertion, long msToWait) throws Exception
{    long delta = msToWait / 10;    for (int i = 0; i < 10; ++i) {        try {            assertion.apply();            return;        } catch (AssertionError t) {        }        Thread.sleep(delta);    }    assertion.apply();}
public static List<byte[]> metron_f5709_0(String samplePath) throws IOException
{    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(samplePath), StandardCharsets.UTF_8));    List<byte[]> ret = new ArrayList<>();    for (String line = null; (line = br.readLine()) != null; ) {        ret.add(line.getBytes(StandardCharsets.UTF_8));    }    br.close();    return ret;}
public static void metron_f5710_0(File file, String[] contents) throws IOException
{    StringBuilder b = new StringBuilder();    for (String line : contents) {        b.append(line);        b.append(System.lineSeparator());    }    write(file, b.toString());}
public static File metron_f5711_0(File file, String contents) throws IOException
{    com.google.common.io.Files.createParentDirs(file);    com.google.common.io.Files.write(contents, file, StandardCharsets.UTF_8);    return file;}
public static String metron_f5712_0(File in) throws IOException
{    return read(in, StandardCharsets.UTF_8);}
public static String metron_f5713_0(File in, Charset charset) throws IOException
{    byte[] bytes = Files.readAllBytes(Paths.get(in.getPath()));    return new String(bytes, charset);}
public static File metron_f5714_0(String prefix) throws IOException
{    final Path tmpDir = Files.createTempDirectory(prefix);    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            try {                cleanDir(tmpDir);            } catch (IOException e) {                System.out.println("Warning: Unable to clean tmp folder.");            }        }    });    return tmpDir.toFile();}
public void metron_f5715_0()
{    try {        cleanDir(tmpDir);    } catch (IOException e) {        System.out.println("Warning: Unable to clean tmp folder.");    }}
public static void metron_f5716_0(Path dir) throws IOException
{    Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {            if (exc == null) {                return FileVisitResult.CONTINUE;            } else {                throw exc;            }        }    });}
public FileVisitResult metron_f5717_0(Path file, BasicFileAttributes attrs) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f5718_0(Path file, IOException exc) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
public FileVisitResult metron_f5719_0(Path dir, IOException exc) throws IOException
{    if (exc == null) {        return FileVisitResult.CONTINUE;    } else {        throw exc;    }}
public static File metron_f5720_0(File parent, String child)
{    File newDir = new File(parent, child);    newDir.mkdirs();    return newDir;}
public JobStatus metron_f5721_0(String jobId)
{    this.jobId = jobId;    return this;}
public JobStatus metron_f5722_0(State state)
{    this.state = state;    return this;}
public JobStatus metron_f5723_0(double percentComplete)
{    this.percentComplete = percentComplete;    return this;}
public JobStatus metron_f5724_0(String description)
{    this.description = description;    return this;}
public JobStatus metron_f5725_0(long completionTime)
{    this.completionTime = completionTime;    return this;}
public JobStatus metron_f5726_0(Throwable failureReason)
{    this.failureReason = failureReason;    return this;}
public String metron_f5727_0()
{    return jobId;}
public State metron_f5728_0()
{    return state;}
public double metron_f5729_0()
{    return percentComplete;}
public String metron_f5730_0()
{    return description;}
public long metron_f5731_0()
{    return completionTime;}
public Throwable metron_f5732_0()
{    return failureReason;}
public JobStatus metron_f5733_0(Supplier<Statusable<PAGE_T>> jobSupplier, String username) throws JobException
{    Map<String, Statusable<PAGE_T>> userJobs = getUserJobs(username);    Statusable<PAGE_T> job = jobSupplier.get();    userJobs.put(job.getStatus().getJobId(), job);    jobs.put(username, userJobs);    return job.getStatus();}
public JobStatus metron_f5734_0(String username, String jobId) throws JobException
{    return getJob(username, jobId).getStatus();}
public boolean metron_f5735_0(String username, String jobId) throws JobException
{    return getJob(username, jobId).isDone();}
public void metron_f5736_0(String username, String jobId) throws JobException
{    getJob(username, jobId).kill();}
public Statusable<PAGE_T> metron_f5737_0(String username, String jobId) throws JobException
{    Map<String, Statusable<PAGE_T>> jobStatusables = getUserJobs(username);    if (jobStatusables.size() > 0 && jobStatusables.containsKey(jobId)) {        return jobStatusables.get(jobId);    }    throw new JobNotFoundException("Could not find job " + jobId + " for user " + username);}
private Map<String, Statusable<PAGE_T>> metron_f5738_0(String username)
{    return jobs.getOrDefault(username, Collections.synchronizedMap(new HashMap<>()));}
public List<Statusable<PAGE_T>> metron_f5739_0(String username) throws JobException
{    return new ArrayList<>(getUserJobs(username).values());}
public void metron_f5740_0()
{    jobs.clear();}
public void metron_f5741_0()
{    JobStatus original = new JobStatus().withState(State.SUCCEEDED).withCompletionTime(5000).withJobId("abc123").withDescription("All done").withPercentComplete(100.0);    JobStatus copied = new JobStatus(original);    assertThat(copied.getState(), equalTo(State.SUCCEEDED));    assertThat(copied.getCompletionTime(), equalTo(5000L));    assertThat(copied.getJobId(), equalTo("abc123"));    assertThat(copied.getDescription(), equalTo("All done"));    assertThat(copied.getPercentComplete(), equalTo(100.0));}
public void metron_f5742_0()
{    JobException e = new JobException("The job blew up.");    JobStatus original = new JobStatus().withState(State.FAILED).withDescription("Failed").withFailureException(e);    assertThat(original.getFailureReason(), equalTo(e));}
public void metron_f5743_0() throws JobException
{    MockitoAnnotations.initMocks(this);    jm = new InMemoryJobManager<Path>();    config = new HashMap<>();    username1 = "user123";    username2 = "user456";    jobId1 = "job_abc_123";    jobId2 = "job_def_456";    jobId3 = "job_ghi_789";    emptyJobId = "";    basePath = tempDir.getRoot().getAbsolutePath();    when(job1.getJobType()).thenReturn(JobType.MAP_REDUCE);    when(job2.getJobType()).thenReturn(JobType.MAP_REDUCE);    when(job3.getJobType()).thenReturn(JobType.MAP_REDUCE);    when(job1.submit(finalizer, config)).thenReturn(job1);    when(job2.submit(finalizer, config)).thenReturn(job2);    when(job3.submit(finalizer, config)).thenReturn(job3);    when(finalizer.finalizeJob(any())).thenReturn(results);}
public void metron_f5744_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId1));    JobStatus status = jm.submit(newSupplier(job1), username1);    assertThat(status.getState(), equalTo(State.RUNNING));    assertThat(status.getJobId(), equalTo(jobId1));    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1));    status = jm.getStatus(username1, status.getJobId());    assertThat(status.getState(), equalTo(State.SUCCEEDED));    assertThat(status.getJobId(), equalTo(jobId1));}
public void metron_f5745_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId1));    when(job2.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId2));    when(job3.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId3));        jm.submit(newSupplier(job1), username1);    assertThat(jm.getJob(username1, jobId1), equalTo(job1));        jm.submit(newSupplier(job2), username1);    assertThat(jm.getJob(username1, jobId1), equalTo(job1));    assertThat(jm.getJob(username1, jobId2), equalTo(job2));        jm.submit(newSupplier(job3), username1);    assertThat(jm.getJob(username1, jobId1), equalTo(job1));    assertThat(jm.getJob(username1, jobId2), equalTo(job2));    assertThat(jm.getJob(username1, jobId3), equalTo(job3));        jm.submit(newSupplier(job1), username2);    jm.submit(newSupplier(job2), username2);    jm.submit(newSupplier(job3), username2);        assertThat(jm.getJob(username1, jobId1), equalTo(job1));    assertThat(jm.getJob(username1, jobId2), equalTo(job2));    assertThat(jm.getJob(username1, jobId3), equalTo(job3));        assertThat(jm.getJob(username2, jobId1), equalTo(job1));    assertThat(jm.getJob(username2, jobId2), equalTo(job2));    assertThat(jm.getJob(username2, jobId3), equalTo(job3));}
public void metron_f5746_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(emptyJobId));        jm.submit(newSupplier(job1), username1);    assertThat(jm.getJob(username1, emptyJobId), equalTo(job1));        when(job2.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(emptyJobId));    jm.submit(newSupplier(job2), username1);    assertThat(jm.getJob(username1, emptyJobId), equalTo(job2));}
public void metron_f5747_0() throws JobException
{    JobStatus expected = new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1);    when(job1.getStatus()).thenReturn(expected);    jm.submit(newSupplier(job1), username1);    JobStatus status = jm.getStatus(username1, jobId1);    assertThat(status, equalTo(expected));}
public void metron_f5748_0() throws JobException
{    JobStatus expected = new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1);    when(job1.getStatus()).thenReturn(expected);    when(job1.isDone()).thenReturn(true);    jm.submit(newSupplier(job1), username1);    boolean done = jm.done(username1, jobId1);    assertThat(done, equalTo(true));}
public void metron_f5749_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.SUCCEEDED).withJobId(jobId1));    jm.submit(newSupplier(job1), username1);    jm.killJob(username1, jobId1);    verify(job1).kill();}
public void metron_f5750_0() throws JobException
{    when(job1.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId1));    when(job2.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId2));    when(job3.getStatus()).thenReturn(new JobStatus().withState(State.RUNNING).withJobId(jobId3));    jm.submit(newSupplier(job1), username1);    jm.submit(newSupplier(job2), username1);    jm.submit(newSupplier(job3), username1);    jm.submit(newSupplier(job1), username2);    jm.submit(newSupplier(job2), username2);    jm.submit(newSupplier(job3), username2);    List<Statusable<Path>> jobsUser1 = jm.getJobs(username1);    List<Statusable<Path>> jobsUser2 = jm.getJobs(username2);    assertThat("Wrong size", jobsUser1.size(), equalTo(3));    assertThat("Wrong size", jobsUser2.size(), equalTo(3));    assertThat("", jobsUser1.containsAll(Arrays.asList(job1, job2, job3)), equalTo(true));    assertThat("", jobsUser2.containsAll(Arrays.asList(job1, job2, job3)), equalTo(true));}
private Supplier<Statusable<Path>> metron_f5751_0(Statusable<Path> job)
{    return () -> {        try {            return job.submit(finalizer, config);        } catch (JobException e) {            throw new RuntimeException("Something went wrong", e);        }    };}
private static CuratorFramework metron_f5752_0(Context context)
{    Optional<Object> clientOpt = context.getCapability(Context.Capabilities.ZOOKEEPER_CLIENT, true);    if (clientOpt.isPresent()) {        return (CuratorFramework) clientOpt.get();    } else {        throw new IllegalStateException("Missing ZOOKEEPER_CLIENT; zookeeper connection required");    }}
public static T metron_f5753_0(int index, Class<T> clazz, List<Object> args)
{    if (index >= args.size()) {        throw new IllegalArgumentException(format("expected at least %d argument(s), found %d", index + 1, args.size()));    }    return ConversionUtils.convert(args.get(index), clazz);}
private static String metron_f5754_0(Object object)
{    if (object == null) {        return null;    }    try {        return JSONUtils.INSTANCE.toJSON(object, true);    } catch (JsonProcessingException e) {        throw new RuntimeException(e);    }}
public Object metron_f5755_0(List<Object> args, Context context) throws ParseException
{    String result;        String arg0 = getArg(0, String.class, args);    ConfigurationType type = ConfigurationType.valueOf(arg0);    try {        if (GLOBAL == type) {            result = getGlobalConfig(args);        } else if (PROFILER == type) {            result = getProfilerConfig(args);        } else if (ENRICHMENT == type) {            result = getEnrichmentConfig(args);        } else if (INDEXING == type) {            result = getIndexingConfig(args);        } else if (PARSER == type) {            result = getParserConfig(args);        } else {            throw new IllegalArgumentException("Unexpected configuration type: " + type);        }    } catch (Exception e) {        throw new RuntimeException(e);    }    return result;}
private String metron_f5756_0(List<Object> args) throws Exception
{    Map<String, Object> globals = readGlobalConfigFromZookeeper(zkClient);        if (globals == null && emptyIfNotPresent(args)) {        globals = new HashMap<>();    }    return toJSON(globals);}
private String metron_f5757_0(List<Object> args) throws Exception
{        String sensor = getArg(1, String.class, args);    SensorParserConfig sensorConfig = readSensorParserConfigFromZookeeper(sensor, zkClient);        if (sensorConfig == null && emptyIfNotPresent(args)) {        sensorConfig = new SensorParserConfig();    }    return toJSON(sensorConfig);}
private String metron_f5758_0(List<Object> args) throws Exception
{        String sensor = getArg(1, String.class, args);    SensorEnrichmentConfig sensorConfig = readSensorEnrichmentConfigFromZookeeper(sensor, zkClient);        if (sensorConfig == null && emptyIfNotPresent(args)) {        sensorConfig = new SensorEnrichmentConfig();    }    return toJSON(sensorConfig);}
private String metron_f5759_0(List<Object> args) throws Exception
{        String sensor = getArg(1, String.class, args);    Map<String, Object> sensorConfig = readSensorIndexingConfigFromZookeeper(sensor, zkClient);        if (sensorConfig == null && emptyIfNotPresent(args)) {        sensorConfig = Collections.emptyMap();    }    return toJSON(sensorConfig);}
private String metron_f5760_0(List<Object> args) throws Exception
{    ProfilerConfig profilerConfig = readProfilerConfigFromZookeeper(zkClient);        if (profilerConfig == null && emptyIfNotPresent(args)) {        profilerConfig = new ProfilerConfig();    }    return toJSON(profilerConfig);}
private boolean metron_f5761_0(List<Object> args)
{    boolean emptyIfNotPresent = true;    int lastIndex = args.size() - 1;        if (args.size() >= 2 && args.get(lastIndex) instanceof Boolean) {        emptyIfNotPresent = getArg(lastIndex, Boolean.class, args);    }    return emptyIfNotPresent;}
public void metron_f5762_0(Context context)
{    zkClient = getZookeeperClient(context);}
public boolean metron_f5763_0()
{    return initialized;}
public Object metron_f5764_1(List<Object> args, Context context) throws ParseException
{        String arg0 = getArg(0, String.class, args);    ConfigurationType type = ConfigurationType.valueOf(arg0);        String value = getArg(1, String.class, args);    if (value != null) {        CuratorFramework client = getZookeeperClient(context);        try {            if (GLOBAL == type) {                writeGlobalConfigToZookeeper(value.getBytes(StandardCharsets.UTF_8), client);            } else if (PROFILER == type) {                writeProfilerConfigToZookeeper(value.getBytes(StandardCharsets.UTF_8), client);            } else if (ENRICHMENT == type) {                String sensor = getArg(2, String.class, args);                writeSensorEnrichmentConfigToZookeeper(sensor, value.getBytes(StandardCharsets.UTF_8), client);            } else if (INDEXING == type) {                String sensor = getArg(2, String.class, args);                writeSensorIndexingConfigToZookeeper(sensor, value.getBytes(StandardCharsets.UTF_8), client);            } else if (PARSER == type) {                String sensor = getArg(2, String.class, args);                writeSensorParserConfigToZookeeper(sensor, value.getBytes(StandardCharsets.UTF_8), client);            }        } catch (Exception e) {                        throw new ParseException(e.getMessage());        }    }    return null;}
public boolean metron_f5766_0()
{    return true;}
public static Map<String, Object> metron_f5767_0(EnrichmentConfig enrichmentConfig)
{    Map<String, Object> fieldMap = enrichmentConfig.getFieldMap();    Map<String, Object> stellarHandler = (Map<String, Object>) fieldMap.getOrDefault("stellar", new HashMap<>());    fieldMap.put("stellar", stellarHandler);    stellarHandler.putIfAbsent("config", new LinkedHashMap<String, Object>());    return stellarHandler;}
public static EnrichmentConfig metron_f5768_0(SensorEnrichmentConfig sensorConfig, Type type)
{    EnrichmentConfig enrichmentConfig = null;    switch(type) {        case ENRICHMENT:            enrichmentConfig = sensorConfig.getEnrichment();            break;        case THREAT_INTEL:        case THREATINTEL:            enrichmentConfig = sensorConfig.getThreatIntel();    }    return enrichmentConfig;}
public Object metron_f5769_0(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    SensorEnrichmentConfig configObj;    String[] headers = new String[] { "Group", "Field", "Transformation" };    if (config == null || config.isEmpty()) {        return FlipTable.of(headers, new String[0][3]);    } else {        configObj = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    }    Type type = Type.valueOf((String) args.get(1));    EnrichmentConfig enrichmentConfig = getConfig(configObj, type);    Map<String, Object> stellarHandler = getStellarHandler(enrichmentConfig);    Map<String, Object> transforms = (Map<String, Object>) stellarHandler.get("config");    List<String[]> objs = new ArrayList<>();    for (Map.Entry<String, Object> kv : transforms.entrySet()) {        if (kv.getValue() instanceof Map) {            Map<String, String> groupMap = (Map<String, String>) kv.getValue();            for (Map.Entry<String, String> groupKv : groupMap.entrySet()) {                objs.add(new String[] { kv.getKey(), groupKv.getKey(), groupKv.getValue().toString() });            }        } else {            objs.add(new String[] { "(default)", kv.getKey(), kv.getValue().toString() });        }    }    String[][] data = new String[objs.size()][3];    for (int i = 0; i < objs.size(); ++i) {        data[i] = objs.get(i);    }    return FlipTable.of(headers, data);}
public boolean metron_f5771_0()
{    return true;}
public Object metron_f5772_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    SensorEnrichmentConfig configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    }    Type type = Type.valueOf((String) args.get(i++));    EnrichmentConfig enrichmentConfig = getConfig(configObj, type);    Map<String, Object> stellarHandler = getStellarHandler(enrichmentConfig);    Map<String, String> transformsToAdd = (Map<String, String>) args.get(i++);    String group = null;    if (i < args.size()) {        group = (String) args.get(i++);    }    Map<String, Object> baseTransforms = (Map<String, Object>) stellarHandler.get("config");    Map<String, Object> groupMap = baseTransforms;    if (group != null) {        groupMap = (Map<String, Object>) baseTransforms.getOrDefault(group, new LinkedHashMap<>());        baseTransforms.put(group, groupMap);    }    for (Map.Entry<String, String> kv : transformsToAdd.entrySet()) {        groupMap.put(kv.getKey(), kv.getValue());    }    if (group != null && groupMap.isEmpty()) {        baseTransforms.remove(group);    }    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public boolean metron_f5774_0()
{    return true;}
public Object metron_f5775_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    SensorEnrichmentConfig configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    }    Type type = Type.valueOf((String) args.get(i++));    EnrichmentConfig enrichmentConfig = getConfig(configObj, type);    Map<String, Object> stellarHandler = getStellarHandler(enrichmentConfig);    List<String> removals = (List<String>) args.get(i++);    String group = null;    if (i < args.size()) {        group = (String) args.get(i++);    }    Map<String, Object> baseTransforms = (Map<String, Object>) stellarHandler.get("config");    Map<String, Object> groupMap = baseTransforms;    if (group != null) {        groupMap = (Map<String, Object>) baseTransforms.getOrDefault(group, new LinkedHashMap<>());        baseTransforms.put(group, groupMap);    }    for (String remove : removals) {        groupMap.remove(remove);    }    if (group != null && groupMap.isEmpty()) {        baseTransforms.remove(group);    }    if (baseTransforms.isEmpty()) {        enrichmentConfig.getFieldMap().remove("stellar");    }    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public boolean metron_f5777_0()
{    return true;}
public FileSystem metron_f5778_0() throws IOException
{    return _func.getSystem();}
public void metron_f5779_1(Context context)
{    try {        fs = getter.getSystem();    } catch (IOException e) {        String message = "Unable to get FileSystem: " + e.getMessage();                throw new IllegalStateException(message, e);    }}
public boolean metron_f5780_0()
{    return fs != null;}
public Object metron_f5781_1(List<Object> args, Context context) throws ParseException
{    String path = (String) args.get(0);    if (path == null) {        return null;    }    try (FSDataInputStream is = fs.open(new Path(path))) {        return IOUtils.readLines(is);    } catch (IOException e) {        String message = "Unable to read " + path + ": " + e.getMessage();                return null;    }}
public Object metron_f5782_1(List<Object> args, Context context) throws ParseException
{    String path = (String) args.get(0);    if (path == null) {        return null;    }    try (FSDataInputStream is = fs.open(new Path(path))) {        return IOUtils.toString(is);    } catch (IOException e) {        String message = "Unable to read " + path + ": " + e.getMessage();                return null;    }}
public Object metron_f5783_1(List<Object> args, Context context) throws ParseException
{    String path = (String) args.get(0);    if (path == null) {        return false;    }    boolean recursive = false;    if (args.size() > 1) {        recursive = ConversionUtils.convert(args.get(1), Boolean.class);    }    try {        fs.delete(new Path(path), recursive);        return true;    } catch (IOException e) {        String message = "Unable to remove " + path + (recursive ? " recursively" : "") + ": " + e.getMessage();                return false;    }}
public Object metron_f5784_1(List<Object> args, Context context) throws ParseException
{    String content = (String) args.get(0);    if (content == null) {        return false;    }    String path = (String) args.get(1);    if (path == null) {        return false;    }    try (FSDataOutputStream os = fs.create(new Path(path))) {        os.writeBytes(content);        os.flush();        return true;    } catch (IOException e) {        String message = "Unable to write " + path + ": " + e.getMessage();                return false;    }}
protected DateFormat metron_f5785_0()
{    return DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.getDefault());}
public Object metron_f5786_1(List<Object> args, Context context) throws ParseException
{    Path path = null;    String[] headers = new String[] { "PERMISSION", "OWNER", "GROUP", "SIZE", "LAST MOD TIME", "NAME" };    if (args.size() == 0) {        path = fs.getHomeDirectory();    } else {        String pathStr = (String) args.get(0);        if (pathStr == null) {            return FlipTable.of(headers, new String[][] {});        } else {            try {                path = new Path(pathStr);            } catch (IllegalArgumentException iae) {                                return FlipTable.of(headers, new String[][] {});            }        }    }    try {        List<String[]> dataList = new ArrayList<>();        for (FileStatus status : fs.listStatus(path)) {            dataList.add(new String[] { status.getPermission().toString(), status.getOwner(), status.getGroup(), status.getLen() + "", dateFormat.get().format(new Date(status.getModificationTime())), status.getPath().getName() });        }        Collections.sort(dataList, (o1, o2) -> {            try {                Date left = dateFormat.get().parse(o1[4]);                Date right = dateFormat.get().parse(o2[4]);                int ret = left.compareTo(right);                                if (ret == 0) {                    return o1[5].compareTo(o2[5]);                } else {                    return ret;                }            } catch (java.text.ParseException e) {                String message = "Unable to parse " + Arrays.toString(o1) + " or " + Arrays.toString(o2) + " : " + e.getMessage();                                throw new IllegalStateException(message, e);            }        });        String[][] data = new String[dataList.size()][headers.length];        for (int i = 0; i < dataList.size(); ++i) {            data[i] = dataList.get(i);        }        return FlipTable.of(headers, data);    } catch (IOException e) {        String message = "Unable to list" + path + " : " + e.getMessage();                return FlipTable.of(headers, new String[][] {});    }}
public static T metron_f5787_0(String argName, int index, Class<T> clazz, List<Object> args) throws ParseException
{    if (index >= args.size()) {        String msg = format("missing '%s'; expected at least %d argument(s), found %d", argName, index + 1, args.size());        throw new ParseException(msg);    }    return ConversionUtils.convert(args.get(index), clazz);}
public static boolean metron_f5788_0(String argName, int index, Class<T> clazz, List<Object> args)
{    boolean result = false;    if (args.size() > index) {        if (clazz.isAssignableFrom(args.get(index).getClass())) {            return true;        }    }    return result;}
public static CuratorFramework metron_f5789_0(Context context) throws ParseException
{    return context.getCapability(ZOOKEEPER_CLIENT, false).filter(CuratorFramework.class::isInstance).map(CuratorFramework.class::cast).orElseThrow(() -> new ParseException("Missing ZOOKEEPER_CLIENT; zookeeper connection required"));}
private static Grok metron_f5790_0(String grokExpr) throws GrokException
{    Grok grok = new Grok();    InputStream input = GrokFunctions.class.getResourceAsStream("/patterns/common");    if (input != null) {        grok.addPatternFromReader(new InputStreamReader(input, StandardCharsets.UTF_8));    }    if (grokExpr != null) {        grok.addPatternFromReader(new StringReader("pattern " + grokExpr));        grok.compile("%{pattern}");    }    return grok;}
public Object metron_f5791_1(List<Object> args, Context context) throws ParseException
{    String grokExpression = (String) args.get(0);    Object arg = args.get(1);    if (grokExpression == null || arg == null) {        return null;    }    List<String> strs = null;    if (arg instanceof List) {        strs = (List<String>) arg;    } else if (arg instanceof String) {        strs = new ArrayList<>();        strs.add((String) arg);    } else {        return null;    }    Grok grok = null;    try {        grok = getGrok(grokExpression);    } catch (GrokException e) {                return null;    }    List<Map<String, Object>> outputMap = new ArrayList<>();    Set<String> keys = new TreeSet<>();    for (String str : strs) {        Match m = grok.match(str);        m.captures();        Map<String, Object> ret = m.toMap();        if (ret != null && ret.isEmpty()) {            outputMap.add(new HashMap<>());        } else {            ret.remove("pattern");            keys.addAll(ret.keySet());            outputMap.add(ret);        }    }    if (keys.isEmpty()) {        return "NO MATCH";    }    String[] headers = new String[keys.size()];    String[][] data = new String[outputMap.size()][keys.size()];    {        int i = 0;        for (String key : keys) {            headers[i++] = key;        }    }    int rowNum = 0;    for (Map<String, Object> output : outputMap) {        String[] row = new String[keys.size()];        int colNum = 0;        for (String key : keys) {            row[colNum++] = "" + output.getOrDefault(key, "MISSING");        }        data[rowNum++] = row;    }    return FlipTable.of(headers, data);}
public boolean metron_f5793_0()
{    return true;}
public Object metron_f5794_1(List<Object> args, Context context) throws ParseException
{    String str = (String) args.get(0);    if (str == null) {        return null;    }    Grok grok = null;    try {        grok = getGrok(null);    } catch (GrokException e) {                return null;    }    return grok.discover(str);}
public boolean metron_f5796_0()
{    return true;}
public Object metron_f5797_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    Map<String, Object> configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (Map<String, Object>) INDEXING.deserialize(config);    }    String writer = null;    if (args.size() > 1) {        writer = ConversionUtils.convert(args.get(i++), String.class);        if (!configObj.containsKey(writer)) {            configObj.put(writer, new HashMap<String, Object>());        }    }    if (writer == null) {        throw new IllegalStateException("Invalid writer name: " + config);    }    int batchSize = 1;    if (args.size() > 2) {        batchSize = ConversionUtils.convert(args.get(i++), Integer.class);        if (batchSize < 1) {            throw new IllegalArgumentException("Invalid batch size must be >= 1 : " + Integer.toString(batchSize));        }    }    configObj.put(writer, IndexingConfigurations.setBatchSize((Map<String, Object>) configObj.get(writer), batchSize));    int batchTimeout = 0;    if (args.size() > 3) {        batchTimeout = ConversionUtils.convert(args.get(i++), Integer.class);    }    configObj.put(writer, IndexingConfigurations.setBatchTimeout((Map<String, Object>) configObj.get(writer), batchTimeout));    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public boolean metron_f5799_0()
{    return true;}
public Object metron_f5800_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    Map<String, Object> configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (Map<String, Object>) INDEXING.deserialize(config);    }    String writer = null;    if (args.size() > 1) {        writer = ConversionUtils.convert(args.get(i++), String.class);        if (!configObj.containsKey(writer)) {            configObj.put(writer, new HashMap<String, Object>());        }    }    if (writer == null) {        throw new IllegalStateException("Invalid writer name: " + config);    }    boolean enabled = true;    if (args.size() > 2) {        enabled = ConversionUtils.convert(args.get(i++), Boolean.class);    }    configObj.put(writer, IndexingConfigurations.setEnabled((Map<String, Object>) configObj.get(writer), enabled));    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public boolean metron_f5802_0()
{    return true;}
public Object metron_f5803_1(List<Object> args, Context context) throws ParseException
{    int i = 0;    String config = (String) args.get(i++);    Map<String, Object> configObj;    if (config == null || config.isEmpty()) {        throw new IllegalStateException("Invalid config: " + config);    } else {        configObj = (Map<String, Object>) INDEXING.deserialize(config);    }    String writer = null;    if (args.size() > 1) {        writer = ConversionUtils.convert(args.get(i++), String.class);        if (!configObj.containsKey(writer)) {            configObj.put(writer, new HashMap<String, Object>());        }    }    if (writer == null) {        throw new IllegalStateException("Invalid writer name: " + config);    }    String sensorName = ConversionUtils.convert(args.get(i++), String.class);    if (sensorName == null) {        throw new IllegalStateException("Invalid sensor name: " + config);    }    configObj.put(writer, IndexingConfigurations.setIndex((Map<String, Object>) configObj.get(writer), sensorName));    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public boolean metron_f5805_0()
{    return true;}
public Object metron_f5806_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);        int count = 1;    if (args.size() > 1) {        count = getArg("count", 1, Integer.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 2) {        overrides = getArg("overrides", 2, Map.class, args);    }        Properties properties = buildKafkaProperties(overrides, context);    properties.put("max.poll.records", count);    return getMessages(topic, count, properties);}
public boolean metron_f5809_0()
{        return true;}
public Object metron_f5810_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);        int count = 1;    if (args.size() > 1) {        count = getArg("count", 1, Integer.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 2) {        overrides = getArg("overrides", 2, Map.class, args);    }    Properties properties = buildKafkaProperties(overrides, context);    properties.put("max.poll.records", count);    return tailMessages(topic, count, properties);}
public boolean metron_f5813_0()
{        return true;}
public Object metron_f5814_0(List<Object> args, Context context) throws ParseException
{    String topic = ConversionUtils.convert(args.get(0), String.class);    List<String> messages;    if (args.get(1) instanceof String) {                String msg = getArg("message(s)", 1, String.class, args);        messages = Collections.singletonList(msg);    } else {                messages = getArg("message(s)", 1, List.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 2) {        overrides = getArg("overrides", 2, Map.class, args);    }        Properties properties = buildKafkaProperties(overrides, context);    List<RecordMetadata> records = putMessages(topic, messages, properties);        Object view = render(records, properties);    return view;}
private Object metron_f5815_0(List<RecordMetadata> records, Properties properties)
{    Object view;    if (MESSAGE_VIEW_RICH.equals(getMessageView(properties))) {                List<Object> responses = new ArrayList<>();        for (RecordMetadata record : records) {                        Map<String, Object> richView = new HashMap<>();            richView.put("topic", record.topic());            richView.put("partition", record.partition());            richView.put("offset", record.offset());            richView.put("timestamp", record.timestamp());            responses.add(richView);        }                view = responses;    } else {                view = CollectionUtils.size(records);    }    return view;}
public boolean metron_f5819_0()
{        return true;}
public Object metron_f5820_0(List<Object> args, Context context) throws ParseException
{        Map<String, String> overrides = new HashMap<>();    if (args.size() > 0) {        overrides = getArg("overrides", 0, Map.class, args);    }    return buildKafkaProperties(overrides, context);}
public boolean metron_f5822_0()
{        return true;}
public Object metron_f5823_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);        LambdaExpression filter = getArg("filter", 1, LambdaExpression.class, args);        int count = 1;    if (args.size() > 2) {        count = getArg("count", 2, Integer.class, args);    }        Map<String, String> overrides = new HashMap<>();    if (args.size() > 3) {        overrides = getArg("overrides", 3, Map.class, args);    }    Properties properties = buildKafkaProperties(overrides, context);    properties.put("max.poll.records", 10 * count);    return findMessages(topic, filter, count, properties);}
public boolean metron_f5825_1(LambdaExpression expr, String message)
{    boolean result = false;    Map<String, Object> messageAsMap;    try {                messageAsMap = JSONUtils.INSTANCE.load(message, JSONUtils.MAP_SUPPLIER);                Object out = expr.apply(Collections.singletonList(messageAsMap));        if (out instanceof Boolean) {            result = (Boolean) out;        } else {                    }    } catch (IOException e) {            }    return result;}
public boolean metron_f5827_0()
{        return true;}
public Object metron_f5828_0(List<Object> args, Context context) throws ParseException
{        String topic = getArg("topic", 0, String.class, args);    int partition = getArg("partition", 1, Integer.class, args);    int offset = getArg("offset", 2, Integer.class, args);        Map<String, String> overrides = new HashMap<>();    if (args.size() > 3) {        overrides = getArg("overrides", 3, Map.class, args);    }    Properties properties = buildKafkaProperties(overrides, context);    return seek(topic, partition, offset, properties);}
public boolean metron_f5831_0()
{        return true;}
private static Set<TopicPartition> metron_f5833_0(String topic, KafkaConsumer<String, String> consumer)
{        Set<TopicPartition> partitions = new HashSet<>();    for (PartitionInfo partition : consumer.partitionsFor(topic)) {        partitions.add(new TopicPartition(topic, partition.partition()));    }    if (partitions.size() == 0) {        throw new IllegalStateException(format("No partitions available for consumer assignment; topic=%s", topic));    }        consumer.assign(partitions);    return partitions;}
private static Properties metron_f5834_0(Map<String, String> overrides, Context context)
{        Properties properties = new Properties();    properties.putAll(defaultProperties);        Optional<Object> globalCapability = context.getCapability(GLOBAL_CONFIG, false);    if (globalCapability.isPresent()) {        Map<String, Object> global = (Map<String, Object>) globalCapability.get();        properties.putAll(global);    }        properties.putAll(overrides);    return properties;}
private static int metron_f5835_0(Properties properties)
{    int maxWait = DEFAULT_MAX_WAIT;    Object value = properties.get(MAX_WAIT_PROPERTY);    if (value != null) {        maxWait = ConversionUtils.convert(value, Integer.class);    }    return maxWait;}
private static int metron_f5836_0(Properties properties)
{    int pollTimeout = DEFAULT_POLL_TIMEOUT;    Object value = properties.get(POLL_TIMEOUT_PROPERTY);    if (value != null) {        pollTimeout = ConversionUtils.convert(value, Integer.class);    }    return pollTimeout;}
private static String metron_f5837_0(Properties properties)
{        String messageView = MESSAGE_VIEW_SIMPLE;    if (properties.containsKey(MESSAGE_VIEW_PROPERTY)) {        messageView = ConversionUtils.convert(properties.get(MESSAGE_VIEW_PROPERTY), String.class);    }    return messageView;}
private static Properties metron_f5838_0()
{    Properties properties = new Properties();    properties.put("bootstrap.servers", "localhost:9092");    properties.put("group.id", "kafka-functions-stellar");    /*     * What to do when there is no initial offset in Kafka or if the current     * offset does not exist any more on the server (e.g. because that data has been deleted):     *     *  "earliest": automatically reset the offset to the earliest offset     *  "latest": automatically reset the offset to the latest offset     *  "none": throw exception to the consumer if no previous offset is found or the consumer's group     *  anything else: throw exception to the consumer.     */    properties.put("auto.offset.reset", "latest");        properties.put("max.poll.records", 1);        properties.put("key.deserializer", StringDeserializer.class.getName());    properties.put("value.deserializer", StringDeserializer.class.getName());        properties.put("key.serializer", StringSerializer.class.getName());    properties.put("value.serializer", StringSerializer.class.getName());        properties.put(MAX_WAIT_PROPERTY, DEFAULT_MAX_WAIT);        properties.put(POLL_TIMEOUT_PROPERTY, DEFAULT_POLL_TIMEOUT);        properties.put(MESSAGE_VIEW_PROPERTY, MESSAGE_VIEW_SIMPLE);    return properties;}
private static void metron_f5839_0(SensorParserConfig config)
{    List<FieldTransformer> toRemove = new ArrayList<>();    List<FieldTransformer> fieldTransformations = config.getFieldTransformations();    for (FieldTransformer transformer : fieldTransformations) {        if (transformer.getFieldTransformation().getClass().getName().equals(FieldTransformations.STELLAR.getMappingClass().getName()) && transformer.getConfig().isEmpty()) {            toRemove.add(transformer);        }    }    for (FieldTransformer t : toRemove) {        fieldTransformations.remove(t);    }}
private static FieldTransformer metron_f5840_0(SensorParserConfig config)
{    List<FieldTransformer> fieldTransformations = config.getFieldTransformations();    FieldTransformer stellarTransformer = null;    for (FieldTransformer transformer : fieldTransformations) {        if (transformer.getFieldTransformation().getClass().getName().equals(FieldTransformations.STELLAR.getMappingClass().getName())) {            stellarTransformer = transformer;        }    }    if (stellarTransformer == null) {        stellarTransformer = new FieldTransformer();        stellarTransformer.setConfig(new LinkedHashMap<>());        stellarTransformer.setTransformation(FieldTransformations.STELLAR.toString());        fieldTransformations.add(stellarTransformer);    }    return stellarTransformer;}
public Object metron_f5841_0(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    if (config == null) {        return null;    }    SensorParserConfig configObj = (SensorParserConfig) PARSER.deserialize(config);    FieldTransformer stellarTransformer = getStellarTransformer(configObj);    String[] headers = new String[] { "Field", "Transformation" };    String[][] data = new String[stellarTransformer.getConfig().size()][2];    int i = 0;    for (Map.Entry<String, Object> kv : stellarTransformer.getConfig().entrySet()) {        data[i++] = new String[] { kv.getKey(), kv.getValue().toString() };    }    return FlipTable.of(headers, data);}
public boolean metron_f5843_0()
{    return true;}
public Object metron_f5844_1(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    if (config == null) {        return null;    }    SensorParserConfig configObj = (SensorParserConfig) PARSER.deserialize(config);    FieldTransformer stellarTransformer = getStellarTransformer(configObj);    List<String> removals = (List<String>) args.get(1);    if (removals == null || removals.isEmpty()) {        return config;    }    for (String removal : removals) {        stellarTransformer.getConfig().remove(removal);    }    List<String> output = new ArrayList<>();    output.addAll(stellarTransformer.getConfig().keySet());    stellarTransformer.setOutput(output);    pruneEmptyStellarTransformers(configObj);    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public boolean metron_f5846_0()
{    return true;}
public Object metron_f5847_1(List<Object> args, Context context) throws ParseException
{    String config = (String) args.get(0);    if (config == null) {        return null;    }    SensorParserConfig configObj = (SensorParserConfig) PARSER.deserialize(config);    FieldTransformer stellarTransformer = getStellarTransformer(configObj);    Map<String, String> additionalTransforms = (Map<String, String>) args.get(1);    if (additionalTransforms == null || additionalTransforms.isEmpty()) {        return config;    }    for (Map.Entry<String, String> kv : additionalTransforms.entrySet()) {        stellarTransformer.getConfig().put(kv.getKey(), kv.getValue());    }    List<String> output = new ArrayList<>();    output.addAll(stellarTransformer.getConfig().keySet());    stellarTransformer.setOutput(output);    try {        return JSONUtils.INSTANCE.toJSON(configObj, true);    } catch (JsonProcessingException e) {                return config;    }}
public boolean metron_f5849_0()
{    return true;}
public Object metron_f5850_0(List<Object> args, Context context) throws ParseException
{    String sensorType = getArg("sensorType", 0, String.class, args);    StellarParserRunner parser = new StellarParserRunner(sensorType);        String configArgName = "config";    if (args.size() == 1) {                SensorParserConfig config = readFromZookeeper(context, sensorType);        parser.withParserConfiguration(sensorType, config);    } else if (hasArg(configArgName, 1, String.class, args)) {                String arg = getArg(configArgName, 1, String.class, args);        parser.withParserConfiguration(arg);    } else if (hasArg(configArgName, 1, Map.class, args)) {                Map<String, Object> arg = getArg(configArgName, 1, Map.class, args);        parser.withParserConfiguration(arg);    } else {        throw new ParseException(format("unexpected '%s' argument; expected string or map", configArgName));    }        if (hasArg("globals", 1, Map.class, args)) {        Map<String, Object> globals = getArg("globals", 1, Map.class, args);        parser.withGlobals(globals);    }    return parser;}
private SensorParserConfig metron_f5851_0(Context context, String sensorType) throws ParseException
{    SensorParserConfig config;    try {        CuratorFramework zkClient = getZookeeperClient(context);        config = readSensorParserConfigFromZookeeper(sensorType, zkClient);    } catch (Exception e) {        throw new ParseException(ExceptionUtils.getRootCauseMessage(e), e);    }    if (config == null) {        throw new ParseException("Unable to read configuration from Zookeeper; sensorType = " + sensorType);    }    return config;}
public boolean metron_f5853_0()
{    return true;}
public Object metron_f5854_0(List<Object> args, Context context) throws ParseException
{    StellarParserRunner parser = getArg("parser", 0, StellarParserRunner.class, args);    parser.withContext(context);    List<String> messages = getMessages(args);    return parser.parse(messages);}
private List<String> metron_f5855_0(List<Object> args)
{    String inputArgName = "input";    List<String> messages = new ArrayList<>();    if (hasArg(inputArgName, 1, String.class, args)) {                String msg = getArg(inputArgName, 1, String.class, args);        messages.add(msg);    } else if (hasArg(inputArgName, 1, List.class, args)) {                List<Object> arg1 = getArg(inputArgName, 1, List.class, args);        for (Object object : arg1) {            String msg = String.class.cast(object);            messages.add(msg);        }    } else {        throw new IllegalArgumentException(format("Expected a string or list of strings to parse."));    }    return messages;}
public boolean metron_f5857_0()
{    return true;}
public Object metron_f5858_0(List<Object> args)
{    StellarParserRunner parser = getArg("parser", 0, StellarParserRunner.class, args);    return parser.toJSON();}
public List<JSONObject> metron_f5859_0(List<String> messages)
{    if (parserConfigurations == null) {        throw new IllegalArgumentException("Missing required parser configuration");    }    if (context == null) {        throw new IllegalArgumentException("Missing required context");    }    return doParse(messages);}
private List<JSONObject> metron_f5860_0(List<String> messages)
{        HashSet<String> sensorTypes = new HashSet<>();    sensorTypes.add(sensorType);    ParserRunnerImpl runner = new ParserRunnerImpl(sensorTypes);    runner.init(() -> parserConfigurations, context);        List<ParserRunnerResults<JSONObject>> results = messages.stream().map(str -> str.getBytes(StandardCharsets.UTF_8)).map(bytes -> DEFAULT.get(emptyMap(), bytes, false, emptyMap())).map(msg -> runner.execute(sensorType, msg, parserConfigurations)).collect(Collectors.toList());        List<JSONObject> successes = results.stream().flatMap(result -> result.getMessages().stream()).collect(Collectors.toList());    successCount += successes.size();    List<JSONObject> errors = results.stream().flatMap(result -> result.getErrors().stream()).map(err -> err.getJSONObject()).collect(Collectors.toList());    errorCount += errors.size();        successes.addAll(errors);    return successes;}
public StellarParserRunner metron_f5861_0(String sensorConfig)
{    parserConfigurations = create(sensorConfig.getBytes(StandardCharsets.UTF_8));    return this;}
public StellarParserRunner metron_f5862_0(Map<String, Object> config)
{    parserConfigurations = create(new JSONObject(config).toJSONString().getBytes(StandardCharsets.UTF_8));    return this;}
public StellarParserRunner metron_f5863_0(String sensorType, SensorParserConfig config)
{    parserConfigurations = new ParserConfigurations();    parserConfigurations.updateSensorParserConfig(sensorType, config);    return this;}
public StellarParserRunner metron_f5864_0(Context context)
{    this.context = context;    return this;}
public StellarParserRunner metron_f5865_0(Map<String, Object> globals)
{    parserConfigurations.updateGlobalConfig(globals);    return this;}
public String metron_f5866_0()
{    try {        return parserConfigurations.getSensorParserConfig(sensorType).toJSON();    } catch (JsonProcessingException e) {        throw new RuntimeException(e);    }}
public ParserConfigurations metron_f5867_0()
{    return parserConfigurations;}
private ParserConfigurations metron_f5868_0(byte[] sensorConfig)
{    try {        ParserConfigurations result = new ParserConfigurations();        result.updateSensorParserConfig(sensorType, SensorParserConfig.fromBytes(sensorConfig));        return result;    } catch (IOException e) {        throw new IllegalArgumentException(e);    }}
public String metron_f5869_0()
{        return String.format("Parser{%d successful, %d error(s)}", successCount, errorCount);}
public Object metron_f5870_0(List<Object> args, Context context) throws ParseException
{    ThreatTriageProcessor processor;    SensorEnrichmentConfig config = new SensorEnrichmentConfig();        if (args.size() > 0) {        String json = Util.getArg(0, String.class, args);        if (json != null) {            config = (SensorEnrichmentConfig) ENRICHMENT.deserialize(json);        } else {            throw new IllegalArgumentException(format("Invalid configuration: unable to deserialize '%s'", json));        }    }    processor = new ThreatTriageProcessor(config, new ClasspathFunctionResolver(), context);    return processor;}
public boolean metron_f5872_0()
{    return true;}
public Object metron_f5873_0(List<Object> args, Context context) throws ParseException
{        String arg0 = Util.getArg(0, String.class, args);    if (arg0 == null) {        throw new IllegalArgumentException(format("expected string, got null"));    }        JSONObject message;    try {        message = (JSONObject) parser.parse(arg0);    } catch (org.json.simple.parser.ParseException e) {        throw new IllegalArgumentException("invalid message", e);    }        ThreatTriageProcessor processor = Util.getArg(1, ThreatTriageProcessor.class, args);    if (processor == null) {        throw new IllegalArgumentException(format("expected threat triage engine; got null"));    }    ThreatScore score = processor.apply(message);    return transform(score, processor.getSensorConfig());}
private Map<String, Object> metron_f5874_0(ThreatScore score, SensorEnrichmentConfig config)
{    List<Map<String, Object>> scores = new ArrayList<>();    for (RuleScore ruleScore : score.getRuleScores()) {                Map<String, Object> map = new HashMap<>();        if (ruleScore.getRule().getName() != null) {            map.put(RULE_NAME_KEY, ruleScore.getRule().getName());        }        if (ruleScore.getRule().getRule() != null) {            map.put(RULE_EXPR_KEY, ruleScore.getRule().getRule());        }        if (ruleScore.getRule().getScoreExpression() != null) {            map.put(RULE_SCORE_KEY, ruleScore.getRule().getScoreExpression());        }        if (ruleScore.getReason() != null) {            map.put(RULE_REASON_KEY, ruleScore.getReason());        }        if (ruleScore.getRule().getComment() != null) {            map.put(RULE_COMMENT_KEY, ruleScore.getRule().getComment());        }        scores.add(map);    }        Map<String, Object> result = new HashMap<>();    result.put(SCORE_KEY, score.getScore());    result.put(RULES_KEY, scores);    result.put(AGG_KEY, config.getThreatIntel().getTriageConfig().getAggregator().toString());    return result;}
public void metron_f5875_0(Context context)
{    parser = new JSONParser();}
public boolean metron_f5876_0()
{    return parser != null;}
public Object metron_f5877_0(List<Object> args, Context context) throws ParseException
{        ThreatTriageProcessor processor = Util.getArg(0, ThreatTriageProcessor.class, args);    if (processor == null) {        throw new IllegalArgumentException(format("expected threat triage engine; got null"));    }        SensorEnrichmentConfig config = processor.getSensorConfig();    return toJSON(config);}
public boolean metron_f5879_0()
{    return true;}
public Object metron_f5880_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        return "";    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        return "";    }        List<RiskLevelRule> triageRules = ListUtils.emptyIfNull(triageConfig.getRiskLevelRules());    String[] headers = new String[] { "Name", "Comment", "Triage Rule", "Score", "Reason" };    String[][] data = new String[triageRules.size()][5];    int i = 0;    for (RiskLevelRule rule : triageRules) {        String score = rule.getScoreExpression();        String name = Optional.ofNullable(rule.getName()).orElse("");        String comment = Optional.ofNullable(rule.getComment()).orElse("");        String reason = Optional.ofNullable(rule.getReason()).orElse("");        data[i++] = new String[] { name, comment, rule.getRule(), score, reason };    }    String ret = FlipTable.of(headers, data);        if (!triageRules.isEmpty()) {        ret += "Aggregation: " + triageConfig.getAggregator().name();    }    return ret;}
public boolean metron_f5882_0()
{    return true;}
public Object metron_f5883_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        tiConfig = new ThreatIntelConfig();        config.setThreatIntel(tiConfig);    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        triageConfig = new org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig();        tiConfig.setTriageConfig(triageConfig);    }        List<RiskLevelRule> newRules = new ArrayList<>();    for (Map<String, Object> newRule : getNewRuleDefinitions(args)) {        if (newRule != null && newRule.containsKey("rule") && newRule.containsKey("score")) {                        RiskLevelRule ruleToAdd = new RiskLevelRule();            ruleToAdd.setRule((String) newRule.get(RULE_EXPR_KEY));            ruleToAdd.setScoreExpression(newRule.get(RULE_SCORE_KEY));                        if (newRule.containsKey(RULE_NAME_KEY)) {                ruleToAdd.setName((String) newRule.get(RULE_NAME_KEY));            }            if (newRule.containsKey(RULE_COMMENT_KEY)) {                ruleToAdd.setComment((String) newRule.get(RULE_COMMENT_KEY));            }            if (newRule.containsKey(RULE_REASON_KEY)) {                ruleToAdd.setReason((String) newRule.get(RULE_REASON_KEY));            }            newRules.add(ruleToAdd);        }    }        List<RiskLevelRule> allRules = ListUtils.union(triageConfig.getRiskLevelRules(), newRules);    triageConfig.setRiskLevelRules(allRules);    return toJSON(config);}
private List<Map<String, Object>> metron_f5884_0(List<Object> args)
{    List<Map<String, Object>> newRules = new ArrayList<>();    Object arg1 = Util.getArg(1, Object.class, args);    if (arg1 instanceof Map) {        newRules.add((Map<String, Object>) arg1);    } else if (arg1 instanceof List) {        newRules.addAll((List<Map<String, Object>>) arg1);    } else {        throw new IllegalArgumentException(String.format("triage rule expected to be map or list, got %s", ClassUtils.getShortClassName(arg1, "null")));    }    return newRules;}
public boolean metron_f5886_0()
{    return true;}
public Object metron_f5887_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        tiConfig = new ThreatIntelConfig();        config.setThreatIntel(tiConfig);    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        triageConfig = new org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig();        tiConfig.setTriageConfig(triageConfig);    }    List<RiskLevelRule> triageRules = triageConfig.getRiskLevelRules();    if (triageRules == null) {        triageRules = new ArrayList<>();        triageConfig.setRiskLevelRules(triageRules);    }    Set<String> toRemove = new HashSet<>(Optional.ofNullable((List<String>) args.get(1)).orElse(new ArrayList<>()));    for (Iterator<RiskLevelRule> it = triageRules.iterator(); it.hasNext(); ) {        RiskLevelRule rule = it.next();        boolean remove = toRemove.contains(rule.getRule());        if (!remove && rule.getName() != null) {            remove = toRemove.contains(rule.getName());        }        if (remove) {            it.remove();        }    }    return toJSON(config);}
public boolean metron_f5889_0()
{    return true;}
public Object metron_f5890_0(List<Object> args, Context context) throws ParseException
{    SensorEnrichmentConfig config = getSensorEnrichmentConfig(args, 0);    ThreatIntelConfig tiConfig = (ThreatIntelConfig) getConfig(config, EnrichmentConfigFunctions.Type.THREAT_INTEL);    if (tiConfig == null) {        tiConfig = new ThreatIntelConfig();        config.setThreatIntel(tiConfig);    }    org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig triageConfig = tiConfig.getTriageConfig();    if (triageConfig == null) {        triageConfig = new org.apache.metron.common.configuration.enrichment.threatintel.ThreatTriageConfig();        tiConfig.setTriageConfig(triageConfig);    }    List<RiskLevelRule> triageRules = triageConfig.getRiskLevelRules();    if (triageRules == null) {        triageRules = new ArrayList<>();        triageConfig.setRiskLevelRules(triageRules);    }    String aggregator = (String) args.get(1);    triageConfig.setAggregator(aggregator);    if (args.size() > 2) {        Map<String, Object> aggConfig = (Map<String, Object>) args.get(2);        triageConfig.setAggregationConfig(aggConfig);    }    return toJSON(config);}
public boolean metron_f5892_0()
{    return true;}
private static String metron_f5893_0(SensorEnrichmentConfig enrichmentConfig)
{    try {        return JSONUtils.INSTANCE.toJSON(enrichmentConfig, true);    } catch (JsonProcessingException e) {        throw new IllegalArgumentException("Unable to serialize enrichment config to JSON", e);    }}
private static SensorEnrichmentConfig metron_f5894_0(List<Object> args, int position)
{    Object arg0 = Util.getArg(position, Object.class, args);    SensorEnrichmentConfig config = new SensorEnrichmentConfig();    if (arg0 instanceof String) {                String json = Util.getArg(0, String.class, args);        if (json != null) {            config = (SensorEnrichmentConfig) ENRICHMENT.deserialize(json);        }    } else if (arg0 instanceof ThreatTriageProcessor) {                ThreatTriageProcessor engine = Util.getArg(0, ThreatTriageProcessor.class, args);        config = engine.getSensorConfig();    } else {                throw new IllegalArgumentException(String.format("Unexpected type: got '%s'", ClassUtils.getShortClassName(arg0, "null")));    }    return config;}
public static void metron_f5895_0() throws Exception
{        testZkServer = new TestingServer(true);    zookeeperUrl = testZkServer.getConnectString();        client = ConfigurationsUtils.getClient(zookeeperUrl);    client.start();}
public void metron_f5896_0() throws Exception
{    context = new Context.Builder().with(Context.Capabilities.ZOOKEEPER_CLIENT, () -> client).build();    parser = new JSONParser();        pushConfigs(SAMPLE_CONFIG_PATH, zookeeperUrl);    pushConfigs(PARSER_CONFIGS_PATH, zookeeperUrl);    writeProfilerConfigToZookeeper(goodProfilerConfig.getBytes(StandardCharsets.UTF_8), client);}
private void metron_f5897_0(String path) throws Exception
{    client.delete().forPath(path);}
private JSONObject metron_f5898_0(String input) throws org.json.simple.parser.ParseException
{    if (input == null) {        return null;    }    return (JSONObject) parser.parse(input.trim());}
private static void metron_f5899_0(String inputPath, String zookeeperUrl) throws Exception
{    String[] args = new String[] { "-z", zookeeperUrl, "--mode", "PUSH", "--input_dir", inputPath };    CommandLine cli = ConfigurationManager.ConfigurationOptions.parse(new PosixParser(), args);    ConfigurationManager manager = new ConfigurationManager();    manager.run(cli);}
public void metron_f5900_0() throws Exception
{    String out = (String) run("CONFIG_GET('PARSER', 'bro')", context);    SensorParserConfig actual = SensorParserConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));    SensorParserConfig expected = SensorParserConfig.fromBytes(goodBroParserConfig.getBytes(StandardCharsets.UTF_8));    assertEquals(expected, actual);}
public void metron_f5901_0()
{        Object out = run("CONFIG_GET('PARSER', 'sensor', false)", context);    assertNull(out);}
public void metron_f5902_0() throws Exception
{    SensorParserConfig expected = new SensorParserConfig();    {        Object out = run("CONFIG_GET('PARSER', 'sensor')", context);        SensorParserConfig actual = SensorParserConfig.fromBytes(out.toString().getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }    {        Object out = run("CONFIG_GET('PARSER', 'sensor', true)", context);        SensorParserConfig actual = SensorParserConfig.fromBytes(out.toString().getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }}
public void metron_f5903_0() throws Exception
{    String out = (String) run("CONFIG_GET('ENRICHMENT', 'test')", context);    SensorEnrichmentConfig actual = SensorEnrichmentConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));    SensorEnrichmentConfig expected = SensorEnrichmentConfig.fromBytes(goodTestEnrichmentConfig.getBytes(StandardCharsets.UTF_8));    assertEquals(expected, actual);}
public void metron_f5904_0()
{        Object out = run("CONFIG_GET('ENRICHMENT', 'sense', false)", context);    assertNull(out);}
public void metron_f5905_0() throws Exception
{        SensorEnrichmentConfig expected = new SensorEnrichmentConfig();    {        String out = (String) run("CONFIG_GET('ENRICHMENT', 'missing-sensor')", context);        SensorEnrichmentConfig actual = SensorEnrichmentConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('ENRICHMENT', 'missing-sensor', true)", context);        SensorEnrichmentConfig actual = SensorEnrichmentConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));        assertEquals(expected, actual);    }}
public void metron_f5906_0() throws Exception
{    String out = (String) run("CONFIG_GET('INDEXING', 'test')", context);    Map<String, Object> actual = toJSONObject(out);    Map<String, Object> expected = toJSONObject(goodTestIndexingConfig);    assertEquals(expected, actual);}
public void metron_f5907_0()
{        Object out = run("CONFIG_GET('INDEXING', 'sense', false)", context);    assertNull(out);}
public void metron_f5908_0() throws Exception
{        Map<String, Object> expected = Collections.emptyMap();    {        String out = (String) run("CONFIG_GET('INDEXING', 'missing-sensor')", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('INDEXING', 'missing-sensor', true)", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }}
public void metron_f5909_0() throws Exception
{    String out = (String) run("CONFIG_GET('PROFILER')", context);    ProfilerConfig actual = ProfilerConfig.fromBytes(out.getBytes(StandardCharsets.UTF_8));    ProfilerConfig expected = ProfilerConfig.fromBytes(goodProfilerConfig.getBytes(StandardCharsets.UTF_8));    assertEquals(expected, actual);}
public void metron_f5910_0() throws Exception
{    deletePath(PROFILER.getZookeeperRoot());        String out = (String) run("CONFIG_GET('PROFILER', false)", context);    assertNull(out);}
public void metron_f5911_0() throws Exception
{        deletePath(PROFILER.getZookeeperRoot());        ProfilerConfig expected = new ProfilerConfig();    {        String out = (String) run("CONFIG_GET('PROFILER', true)", context);        ProfilerConfig actual = ProfilerConfig.fromJSON(out);        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('PROFILER')", context);        ProfilerConfig actual = ProfilerConfig.fromJSON(out);        assertEquals(expected, actual);    }}
public void metron_f5912_0() throws Exception
{    String out = (String) run("CONFIG_GET('GLOBAL')", context);    Map<String, Object> actual = toJSONObject(out);    Map<String, Object> expected = toJSONObject(goodGlobalConfig);    assertEquals(expected, actual);}
public void metron_f5913_0() throws Exception
{        deletePath(GLOBAL.getZookeeperRoot());        Object out = run("CONFIG_GET('GLOBAL', false)", context);    assertNull(out);}
public void metron_f5914_0() throws Exception
{        deletePath(GLOBAL.getZookeeperRoot());        Map<String, Object> expected = Collections.emptyMap();    {        String out = (String) run("CONFIG_GET('GLOBAL')", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }    {        String out = (String) run("CONFIG_GET('GLOBAL', true)", context);        Map<String, Object> actual = toJSONObject(out);        assertEquals(expected, actual);    }}
public void metron_f5915_0() throws Exception
{    String out = (String) run("CONFIG_GET('GLOBAL')", context);    Map<String, Object> actual = toJSONObject(out);    Map<String, Object> expected = toJSONObject(goodGlobalConfig);    assertEquals(expected, actual);}
public void metron_f5916_0()
{    {        UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);        try {            run("CONFIG_PUT('GLOBAL', 'foo bar')", context);        } catch (ParseException e) {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);            throw e;        }    }}
public void metron_f5917_0() throws InterruptedException
{    String brop = (String) run("CONFIG_GET('INDEXING', 'testIndexingPut')", context);    run("CONFIG_PUT('INDEXING', config, 'testIndexingPut')", ImmutableMap.of("config", brop), context);    boolean foundMatch = false;    for (int i = 0; i < 10 && !foundMatch; ++i) {        String bropNew = (String) run("CONFIG_GET('INDEXING', 'testIndexingPut', false)", context);        foundMatch = brop.equals(bropNew);        if (foundMatch) {            break;        }        Thread.sleep(2000);    }    assertTrue(foundMatch);}
public void metron_f5918_0() throws InterruptedException
{    {        {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);            try {                run("CONFIG_PUT('INDEXING', config, 'brop')", ImmutableMap.of("config", "foo bar"), context);            } catch (ParseException e) {                UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);                throw e;            }        }    }}
public void metron_f5919_0() throws InterruptedException
{    String config = (String) run("CONFIG_GET('ENRICHMENT', 'sensor')", context);    assertNotNull(config);    run("CONFIG_PUT('ENRICHMENT', config, 'sensor')", ImmutableMap.of("config", config), context);    boolean foundMatch = false;    for (int i = 0; i < 10 && !foundMatch; ++i) {        String newConfig = (String) run("CONFIG_GET('ENRICHMENT', 'sensor', false)", context);        foundMatch = config.equals(newConfig);        if (foundMatch) {            break;        }        Thread.sleep(2000);    }    assertTrue(foundMatch);}
public void metron_f5920_0() throws InterruptedException
{    {        {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);            try {                run("CONFIG_PUT('ENRICHMENT', config, 'brop')", ImmutableMap.of("config", "foo bar"), context);            } catch (ParseException e) {                UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);                throw e;            }        }    }}
public void metron_f5921_0() throws InterruptedException
{    String brop = (String) run("CONFIG_GET('PARSER', 'testParserPut')", context);    run("CONFIG_PUT('PARSER', config, 'testParserPut')", ImmutableMap.of("config", brop), context);    boolean foundMatch = false;    for (int i = 0; i < 10 && !foundMatch; ++i) {        String bropNew = (String) run("CONFIG_GET('PARSER', 'testParserPut', false)", context);        foundMatch = brop.equals(bropNew);        if (foundMatch) {            break;        }        Thread.sleep(2000);    }    assertTrue(foundMatch);}
public void metron_f5922_0() throws InterruptedException
{    {        UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.FATAL);        try {            run("CONFIG_PUT('PARSER', config, 'brop')", ImmutableMap.of("config", "foo bar"), context);        } catch (ParseException e) {            UnitTestHelper.setLog4jLevel(ConfigurationFunctions.class, Level.ERROR);            throw e;        }    }}
public static String metron_f5923_0()
{    SensorEnrichmentConfig config = new SensorEnrichmentConfig();    try {        return JSONUtils.INSTANCE.toJSON(config, true);    } catch (JsonProcessingException e) {        throw new IllegalStateException(e);    }}
public static Collection<Object[]> metron_f5924_0()
{        return Arrays.asList(new Object[][] { { "ENRICHMENT", "group" }, { "ENRICHMENT", null }, { "THREAT_INTEL", "group" }, { "THREAT_INTEL", null } });}
public void metron_f5925_0()
{    variables = ImmutableMap.of("upper", VariableResult.withExpression("FOO", "TO_UPPER('foo')"), "lower", VariableResult.withExpression("foo", "TO_LOWER('FOO')"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
 static Map<String, Object> metron_f5926_0(String... k)
{    Map<String, Object> ret = new HashMap<>();    for (int i = 0; i < k.length; i += 2) {        ret.put(k[i], k[i + 1]);    }    return ret;}
private int metron_f5927_0(Map<String, Object> stellarFunctions)
{    if (group == null) {        return stellarFunctions.size();    } else {        return ((Map<String, Object>) stellarFunctions.getOrDefault(group, new HashMap<>())).size();    }}
private Object metron_f5928_0(Map<String, Object> stellarFunctions, String key)
{    if (group == null) {        return stellarFunctions.get(key);    } else {        return ((Map<String, Object>) stellarFunctions.get(group)).get(key);    }}
private EnrichmentConfig metron_f5929_0(String configStr)
{    SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(configStr);    switch(enrichmentType) {        case "ENRICHMENT":            return sensorConfig.getEnrichment();        case "THREAT_INTEL":            return sensorConfig.getThreatIntel();    }    return null;}
private static Map<String, Object> metron_f5930_0(EnrichmentConfig config)
{    Map<String, Object> fieldMap = config.getFieldMap();    if (fieldMap == null) {        return new HashMap<>();    }    Map<String, Object> stellarMap = (Map<String, Object>) fieldMap.get("stellar");    if (stellarMap == null) {        return new HashMap<>();    }    return (Map<String, Object>) stellarMap.get("config");}
private Object metron_f5931_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f5932_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("upper").getExpression().get(), get(stellarFunctions, "upper"));}
public void metron_f5933_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('lower'), group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(2, size(stellarFunctions));    Assert.assertEquals(variables.get("upper").getExpression().get(), get(stellarFunctions, "upper"));    Assert.assertEquals(variables.get("lower").getExpression().get(), get(stellarFunctions, "lower"));}
public void metron_f5934_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('foo'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(0, size(stellarFunctions));}
public void metron_f5935_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("upper").getExpression().get(), get(stellarFunctions, "upper"));}
public void metron_f5936_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper', 'lower'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_REMOVE(config, type, ['upper'], group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("lower").getExpression().get(), get(stellarFunctions, "lower"));}
public void metron_f5937_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper', 'lower'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_REMOVE(config, type, ['upper', 'lower'], group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(0, size(stellarFunctions));}
public void metron_f5938_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('lower'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_REMOVE(config, type, ['upper'], group)", toMap("config", newConfig, "type", enrichmentType, "group", group));    Map<String, Object> stellarFunctions = getStellarMappings(getEnrichmentConfig(newConfig));    Assert.assertEquals(1, size(stellarFunctions));    Assert.assertEquals(variables.get("lower").getExpression().get(), get(stellarFunctions, "lower"));}
public void metron_f5939_0()
{    String newConfig = (String) run("ENRICHMENT_STELLAR_TRANSFORM_ADD(config, type, SHELL_VARS2MAP('upper'), group)", toMap("config", configStr, "type", enrichmentType, "group", group));    String out = (String) run("ENRICHMENT_STELLAR_TRANSFORM_PRINT(config, type)", toMap("config", newConfig, "type", enrichmentType));    if (group == null) {        Assert.assertEquals(testPrintExpectedWithoutGroup, out);    } else {        Assert.assertEquals(testPrintExpectedWithGroup, out);    }}
public void metron_f5940_0()
{    String out = (String) run("ENRICHMENT_STELLAR_TRANSFORM_PRINT(config, type)", toMap("config", configStr, "type", enrichmentType));    Assert.assertEquals(testPrintEmptyExpected, out);}
public void metron_f5941_0()
{    String out = (String) run("ENRICHMENT_STELLAR_TRANSFORM_PRINT(config, type)", toMap("config", configStr, "type", enrichmentType));    Assert.assertEquals(testPrintEmptyExpected, out);}
public static Collection<Object[]> metron_f5942_0()
{    return Arrays.asList(new Object[][] { { FileSystemFunctions.FS_TYPE.HDFS }, { FileSystemFunctions.FS_TYPE.LOCAL } });}
public static void metron_f5943_0() throws IOException
{    {        hdfsBaseDir = Files.createTempDirectory("test_hdfs").toFile().getAbsoluteFile();        Configuration conf = new Configuration();        conf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, hdfsBaseDir.getAbsolutePath());        MiniDFSCluster.Builder builder = new MiniDFSCluster.Builder(conf);        hdfsCluster = builder.build();        hdfsPrefix = "/";    }    {        localPrefix = "target/fsTest/";        if (new File(localPrefix).exists()) {            new File(localPrefix).delete();        }        new File(localPrefix).mkdirs();    }}
public void metron_f5944_0() throws IOException
{    if (type == FileSystemFunctions.FS_TYPE.HDFS) {        prefix = hdfsPrefix;        fsGetter = () -> hdfsCluster.getFileSystem();    } else {        prefix = localPrefix;        fsGetter = FileSystemFunctions.FS_TYPE.LOCAL;    }    get = new FileSystemFunctions.FileSystemGet(fsGetter);    get.initialize(null);    getList = new FileSystemFunctions.FileSystemGetList(fsGetter);    getList.initialize(null);    ls = new FileSystemFunctions.FileSystemLs(fsGetter);    ls.initialize(null);    put = new FileSystemFunctions.FileSystemPut(fsGetter);    put.initialize(null);    rm = new FileSystemFunctions.FileSystemRm(fsGetter);    rm.initialize(null);}
public static void metron_f5945_0()
{    {        hdfsCluster.shutdown();        FileUtil.fullyDelete(hdfsBaseDir);    }    {        new File(localPrefix).delete();    }}
public void metron_f5946_0()
{    Object putOut = put.apply(Arrays.asList("foo", prefix + "testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    String getOut = (String) get.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertEquals("foo", getOut);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertFalse(lsOut.contains("(empty)"));    Boolean rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertTrue(rmRet);    lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5947_0()
{    Object putOut = put.apply(Arrays.asList("foo\nbar", prefix + "testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    String getOut = (String) get.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertEquals("foo\nbar", getOut);    List<String> list = (List<String>) getList.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertEquals(2, list.size());    Assert.assertEquals("foo", list.get(0));    Assert.assertEquals("bar", list.get(1));}
public void metron_f5948_0()
{    Object o = put.apply(Arrays.asList("foo", null), null);    Assert.assertFalse((Boolean) o);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5949_0()
{    Object putOut = put.apply(Arrays.asList("foo", prefix + "testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    Boolean rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertTrue(rmRet);    rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "testPut.dat"), null);    Assert.assertTrue(rmRet);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5950_0()
{    Object putOut = put.apply(Arrays.asList("foo", prefix + "blah/testPut.dat"), null);    Assert.assertTrue((Boolean) putOut);    putOut = put.apply(Arrays.asList("grok", prefix + "blah/testPut2.dat"), null);    Assert.assertTrue((Boolean) putOut);    Assert.assertEquals("foo", (String) get.apply(Arrays.asList(prefix + "blah/testPut.dat"), null));    Assert.assertEquals("grok", (String) get.apply(Arrays.asList(prefix + "blah/testPut2.dat"), null));    boolean rmRet = (Boolean) rm.apply(Arrays.asList(prefix + "blah", true), null);    Assert.assertTrue(rmRet);    String lsOut = (String) ls.apply(Arrays.asList(prefix), null);    Assert.assertTrue(lsOut.contains("(empty)"));}
public void metron_f5951_0()
{    String message = "1474583120.343    142 127.0.0.1 TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, messages )", ImmutableMap.of("messages", ImmutableList.of(message), "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertTrue(out.contains("TCP_MISS"));    Assert.assertTrue(out.contains(" 494 "));    Assert.assertTrue(out.contains("157.166.226.26"));}
public void metron_f5952_0()
{    String message = "1474583120.343    142 127.0.0.1 TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String message2 = "1474583120.343    142 127.0.0.1 TCP_MISS/404 494 GET http://google.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, messages )", ImmutableMap.of("messages", ImmutableList.of(message, message2), "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertTrue(out.contains("TCP_MISS"));    Assert.assertTrue(out.contains(" 494 "));    Assert.assertTrue(out.contains("157.166.226.26"));    Assert.assertTrue(out.contains("404"));}
public void metron_f5953_0()
{    String message = "1474583120.343    142 foo TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, message )", ImmutableMap.of("message", message, "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertEquals("NO MATCH", out);}
public void metron_f5954_0()
{    String message = "1474583120.343    142 foo TCP_MISS/301 494 GET http://cnn.com/ - DIRECT/157.166.226.26 text/html";    String message2 = "1474583120.343    142 127.0.0.1 TCP_MISS/404 494 GET http://google.com/ - DIRECT/157.166.226.26 text/html";    String out = (String) run("GROK_EVAL( grok, messages )", ImmutableMap.of("messages", ImmutableList.of(message, message2), "grok", grokExpr), Context.EMPTY_CONTEXT());    Assert.assertTrue(out.contains("MISSING"));    Assert.assertTrue(out.contains("404"));}
public void metron_f5955_0()
{    String out = (String) run("GROK_PREDICT( '1474583120.343    142 127.0.0.1 TCP_MISS/301')", new HashMap<>(), Context.EMPTY_CONTEXT());    Assert.assertEquals("%{BASE10NUM}    142 %{IP} TCP_MISS%{PATH}", out);}
private Object metron_f5956_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
public void metron_f5957_0()
{    variables = ImmutableMap.of("upper", VariableResult.withExpression("FOO", "TO_UPPER('foo')"), "lower", VariableResult.withExpression("foo", "TO_LOWER('FOO')"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
public void metron_f5958_0()
{    String out = (String) run("INDEXING_SET_BATCH(config, 'hdfs', 10)", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertEquals(10, IndexingConfigurations.getBatchSize((Map<String, Object>) config.get("hdfs")));}
public void metron_f5959_0()
{    String out = (String) run("INDEXING_SET_BATCH(config, 'hdfs', 10, 2)", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertEquals(10, IndexingConfigurations.getBatchSize((Map<String, Object>) config.get("hdfs")));    Assert.assertEquals(2, IndexingConfigurations.getBatchTimeout((Map<String, Object>) config.get("hdfs")));}
public void metron_f5960_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    run("INDEXING_SET_BATCH(config, 'hdfs', 10)", variables);}
public void metron_f5961_0()
{    String out = (String) run("INDEXING_SET_ENABLED(config, 'hdfs', true)", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertTrue(IndexingConfigurations.isEnabled((Map<String, Object>) config.get("hdfs")));}
public void metron_f5962_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    run("INDEXING_SET_ENABLED(config, 'hdfs', 10)", variables);}
public void metron_f5963_0()
{    String out = (String) run("INDEXING_SET_INDEX(config, 'hdfs', 'foo')", toMap("config", "{}"));    Map<String, Object> config = (Map<String, Object>) INDEXING.deserialize(out);    Assert.assertEquals("foo", IndexingConfigurations.getIndex((Map<String, Object>) config.get("hdfs"), null));}
public void metron_f5964_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    run("INDEXING_SET_INDEX(config, 'hdfs', NULL)", variables);}
public static void metron_f5965_0()
{    executor = Executors.newFixedThreadPool(2);}
public static void metron_f5966_0()
{    if (executor != null && !executor.isShutdown()) {        executor.shutdown();    }}
public static void metron_f5967_0() throws Exception
{    Properties properties = new Properties();    zkServerComponent = getZKServerComponent(properties);    kafkaComponent = getKafkaComponent(properties, new ArrayList<>());    runner = new ComponentRunner.Builder().withComponent("zk", zkServerComponent).withComponent("kafka", kafkaComponent).withMillisecondsBetweenAttempts(5000).withNumRetries(5).withCustomShutdownOrder(new String[] { "kafka", "zk" }).build();    runner.start();}
public static void metron_f5968_0()
{        functionResolver = new SimpleFunctionResolver().withClass(KafkaFunctions.KafkaGet.class).withClass(KafkaFunctions.KafkaPut.class).withClass(KafkaFunctions.KafkaProps.class).withClass(KafkaFunctions.KafkaTail.class).withClass(KafkaFunctions.KafkaFind.class).withClass(KafkaFunctions.KafkaSeek.class).withClass(MapFunctions.MapGet.class);}
public void metron_f5969_0()
{        variables = new HashMap<>();    variables.put("message1", message1);    variables.put("message2", message2);    variables.put("message3", message3);        global = new Properties();    global.put("bootstrap.servers", kafkaComponent.getBrokerList());        global.put("auto.offset.reset", "earliest");}
public static void metron_f5970_0() throws Exception
{    runner.stop();}
public void metron_f5971_0()
{    runner.reset();}
public void metron_f5972_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        assertEquals(1, run("KAFKA_PUT(topic, [message1])"));        assertEquals(Collections.singletonList(message1), run("KAFKA_GET(topic)"));}
public void metron_f5973_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        assertEquals(2, run("KAFKA_PUT(topic, [message1, message2])"));        List<String> expected = new ArrayList<String>() {        {            add(message1);            add(message2);        }    };    assertEquals(expected, run("KAFKA_GET(topic, 2)"));}
public void metron_f5974_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, message1)");        Object actual = run("KAFKA_GET(topic)");        assertEquals(Collections.singletonList(message1), actual);}
public void metron_f5975_0()
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Object actual = run("KAFKA_PUT(topic, message1)");        assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertEquals(topicName, view.get("topic"));    assertEquals(0, view.get("partition"));    assertEquals(0L, view.get("offset"));    assertNotNull(view.get("timestamp"));}
public void metron_f5976_0()
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, message1)");        Object actual = run("KAFKA_GET(topic)");        assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertNull(view.get("key"));    assertEquals(0L, view.get("offset"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message1, view.get("value"));}
public void metron_f5977_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        Object actual = run("KAFKA_GET(topic, 3)");        List<String> expected = new ArrayList<String>() {        {            add(message1);            add(message2);            add(message3);        }    };    assertEquals(expected, actual);}
public void metron_f5978_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        assertEquals(Collections.singletonList(message1), run("KAFKA_GET(topic, 1)"));        assertEquals(Collections.singletonList(message2), run("KAFKA_GET(topic, 1)"));        assertEquals(Collections.singletonList(message3), run("KAFKA_GET(topic, 1)"));        assertEquals(Collections.emptyList(), run("KAFKA_GET(topic, 1)"));}
public void metron_f5979_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        assertEquals(Collections.emptyList(), run("KAFKA_GET(topic, 1)"));}
public void metron_f5980_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message2, message2, message2])");        Future<Object> tailFuture = runAsync("KAFKA_TAIL(topic, 1)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message1])"));        Object actual = tailFuture.get(10, TimeUnit.SECONDS);    List<String> expected = Collections.singletonList(message1);    assertEquals(expected, actual);}
public void metron_f5981_0()
{        global.put(KafkaFunctions.MAX_WAIT_PROPERTY, 2000);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        assertEquals(Collections.emptyList(), run("KAFKA_TAIL(topic, 1)"));}
public void metron_f5982_0() throws Exception
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message2, message2, message2])");        Future<Object> tailFuture = runAsync("KAFKA_TAIL(topic, 1)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message1])"));        Object actual = tailFuture.get(10, TimeUnit.SECONDS);        assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertNull(view.get("key"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message1, view.get("value"));    assertNotNull(view.get("offset"));}
public void metron_f5983_0()
{        final String overriddenKey = "bootstrap.servers";    final String expected = "foo.global.override.com:9092";    global.setProperty(overriddenKey, expected);        Map<String, String> properties = (Map<String, String>) run("KAFKA_PROPS()");    assertEquals(expected, properties.get(overriddenKey));}
public void metron_f5984_0()
{        final String overriddenKey = "bootstrap.servers";    global.setProperty(overriddenKey, "foo.global.override.com:9092");        final String expected = "foo.user.override.com:9092";    String expression = String.format("KAFKA_PROPS({ '%s' : '%s' })", overriddenKey, expected);        Map<String, String> properties = (Map<String, String>) run(expression);    assertEquals(expected, properties.get(overriddenKey));}
public void metron_f5985_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> MAP_GET('value', m) == 23)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message2])"));        Object actual = future.get(10, TimeUnit.SECONDS);    List<String> expected = Collections.singletonList(message2);    assertEquals(expected, actual);}
public void metron_f5986_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> false)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message1])"));        Object actual = future.get(10, TimeUnit.SECONDS);    List<String> expected = Collections.emptyList();    assertEquals(expected, actual);}
public void metron_f5987_0() throws Exception
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> MAP_GET('value', m) == 23)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message2])"));        Object actual = future.get(10, TimeUnit.SECONDS);    assertTrue(actual instanceof List);    List<Object> results = (List) actual;    assertEquals(1, results.size());        Map<String, Object> view = (Map) results.get(0);    assertNull(view.get("key"));    assertNotNull(view.get("offset"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message2, view.get("value"));}
public void metron_f5988_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        Future<Object> future = runAsync("KAFKA_FIND(topic, m -> true, 2)");        runAsyncAndWait(Collections.nCopies(10, "KAFKA_PUT(topic, [message2])"));        List<String> expected = new ArrayList<String>() {        {            add(message2);            add(message2);        }    };    Object actual = future.get(10, TimeUnit.SECONDS);    assertEquals(expected, actual);}
public void metron_f5989_0()
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [message1, message2, message3])");        long before = System.currentTimeMillis();    Object actual = run("KAFKA_FIND(topic, m -> false, 10, { 'stellar.kafka.max.wait.millis': 1000 })");        long wait = System.currentTimeMillis() - before;    assertTrue("Expected wait not to exceed max wait; actual wait = " + wait, wait < 2 * 1000);        List<String> expected = Collections.emptyList();    assertEquals(expected, actual);}
public void metron_f5990_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [ message1, message2, message3 ])");    {                Object actual = run("KAFKA_SEEK(topic, 0, 2)");        assertEquals(message3, actual);    }    {                Object actual = run("KAFKA_SEEK(topic, 0, 1)");        assertEquals(message2, actual);    }    {                Object actual = run("KAFKA_SEEK(topic, 0, 0)");        assertEquals(message1, actual);    }}
public void metron_f5991_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [ message1, message2, message3 ])");        Object actual = run("KAFKA_SEEK(topic, 0, 9999)");    assertNull(actual);}
public void metron_f5992_0() throws Exception
{        final String topicName = testName.getMethodName();    variables.put("topic", topicName);        run("KAFKA_PUT(topic, [ message1, message2, message3 ])");        Object actual = run("KAFKA_SEEK(topic, 99999, 0)");    assertNull(actual);}
public void metron_f5993_0() throws Exception
{        global.put(KafkaFunctions.MESSAGE_VIEW_PROPERTY, KafkaFunctions.MESSAGE_VIEW_RICH);        final String topicName = testName.getMethodName();    variables.put("topic", topicName);    run("KAFKA_PUT(topic, [ message1, message2, message3 ])");    Object actual = run("KAFKA_SEEK(topic, 0, 0)");        assertTrue(actual instanceof Map);    Map<String, Object> view = (Map) actual;    assertNull(view.get("key"));    assertNotNull(view.get("offset"));    assertEquals(0, view.get("partition"));    assertEquals(topicName, view.get("topic"));    assertEquals(message1, view.get("value"));}
private Object metron_f5994_0(String expression)
{        Context context = new Context.Builder().with(Context.Capabilities.GLOBAL_CONFIG, () -> global).build();        StellarProcessor processor = new StellarProcessor();    return processor.parse(expression, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), functionResolver, context);}
private Future<Object> metron_f5995_0(String expression)
{    return executor.submit(() -> run(expression));}
private void metron_f5996_0(Iterable<String> expressions) throws Exception
{        List<Future<Object>> putFutures = new ArrayList<>();    for (String expression : expressions) {        Future<Object> future = runAsync(expression);        putFutures.add(future);    }        for (Future<Object> future : putFutures) {        future.get(5, TimeUnit.SECONDS);    }}
public void metron_f5997_0()
{    variables = ImmutableMap.of("upper", VariableResult.withExpression("FOO", "TO_UPPER('foo')"), "lower", VariableResult.withExpression("foo", "TO_LOWER('FOO'"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
public Map<String, Object> metron_f5998_0(String parserConfig)
{    return transform(parserConfig, new HashMap<>());}
public Map<String, Object> metron_f5999_0(String parserConfig, Map<String, Object> variables)
{    JSONObject ret = new JSONObject(variables);    SensorParserConfig sensorParserConfig = (SensorParserConfig) PARSER.deserialize(parserConfig);    sensorParserConfig.init();    for (FieldTransformer handler : sensorParserConfig.getFieldTransformations()) {        if (handler != null) {            handler.transformAndUpdate(ret, context, sensorParserConfig.getParserConfig());        }    }    return ret;}
public void metron_f6000_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(1, transformations.size());    Assert.assertEquals("FOO", transformations.get("upper"));}
public void metron_f6001_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", existingTransformationsConfig), context);    Map<String, Object> transformations = transform(newConfig, ImmutableMap.of("url", "http://www.google.com"));        Assert.assertEquals(4, transformations.size());    Assert.assertEquals("FOO", transformations.get("upper"));}
public void metron_f6002_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('blah'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(0, transformations.size());}
public void metron_f6003_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", newConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(1, transformations.size());    Assert.assertEquals("FOO", transformations.get("upper"));}
public void metron_f6004_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, ['upper'])", ImmutableMap.of("config", newConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(0, transformations.size());}
public void metron_f6005_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper', 'lower'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, ['upper', 'lower'])", ImmutableMap.of("config", newConfig), context);    Map<String, Object> transformations = transform(newConfig);    Assert.assertEquals(0, transformations.size());}
public void metron_f6006_0()
{    {        String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);        newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, ['lower'])", ImmutableMap.of("config", newConfig), context);        Map<String, Object> transformations = transform(newConfig);        Assert.assertEquals(1, transformations.size());        Assert.assertEquals("FOO", transformations.get("upper"));    }    {        String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);        newConfig = (String) run("PARSER_STELLAR_TRANSFORM_REMOVE(config, [''])", ImmutableMap.of("config", newConfig), context);        Map<String, Object> transformations = transform(newConfig);        Assert.assertEquals(1, transformations.size());        Assert.assertEquals("FOO", transformations.get("upper"));    }}
public void metron_f6007_0()
{    String newConfig = (String) run("PARSER_STELLAR_TRANSFORM_ADD(config, SHELL_VARS2MAP('upper'))", ImmutableMap.of("config", emptyTransformationsConfig), context);    String out = (String) run("PARSER_STELLAR_TRANSFORM_PRINT(config )", ImmutableMap.of("config", newConfig), context);    Assert.assertEquals(testPrintExpected, out);}
public void metron_f6008_0()
{    String out = (String) run("PARSER_STELLAR_TRANSFORM_PRINT(config )", ImmutableMap.of("config", emptyTransformationsConfig), context);    Assert.assertEquals(testPrintEmptyExpected, out);}
public void metron_f6009_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    String out = (String) run("PARSER_STELLAR_TRANSFORM_PRINT(config )", variables, context);    Assert.assertNull(out);}
public void metron_f6010_0()
{    variables = new HashMap<>();    functionResolver = new SimpleFunctionResolver().withClass(ParserFunctions.ParseFunction.class).withClass(ParserFunctions.InitializeFunction.class).withClass(ParserFunctions.ConfigFunction.class);    context = new Context.Builder().build();    executor = new DefaultStellarStatefulExecutor(functionResolver, context);}
public void metron_f6011_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        set("message", broMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, message)", List.class);        Assert.assertEquals(1, messages.size());    JSONObject message = messages.get(0);    Assert.assertEquals("bro", message.get(Constants.SENSOR_TYPE));    Assert.assertEquals("10.122.196.204", message.get(SRC_ADDR.getName()));    Assert.assertEquals(33976L, message.get(SRC_PORT.getName()));    Assert.assertEquals("144.254.71.184", message.get(DST_ADDR.getName()));    Assert.assertEquals(53L, message.get(DST_PORT.getName()));    Assert.assertEquals("dns", message.get("protocol"));}
public void metron_f6012_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        set("msg1", broMessage);    set("msg2", broMessage);    set("msg3", broMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, [msg1, msg2, msg3])", List.class);        Assert.assertEquals(3, messages.size());    for (JSONObject message : messages) {        Assert.assertEquals("bro", message.get(Constants.SENSOR_TYPE));        Assert.assertTrue(message.containsKey(Constants.GUID));        Assert.assertEquals("10.122.196.204", message.get(SRC_ADDR.getName()));        Assert.assertEquals(33976L, message.get(SRC_PORT.getName()));        Assert.assertEquals("144.254.71.184", message.get(DST_ADDR.getName()));        Assert.assertEquals(53L, message.get(DST_PORT.getName()));        Assert.assertEquals("dns", message.get("protocol"));    }}
public void metron_f6013_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        String invalidMessage = "{ this is an invalid message }}";    set("message", invalidMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, message)", List.class);        Assert.assertEquals(1, messages.size());        JSONObject error = messages.get(0);    Assert.assertEquals(invalidMessage, error.get("raw_message"));    Assert.assertEquals(Constants.ERROR_TYPE, error.get(Constants.SENSOR_TYPE));    Assert.assertEquals("parser_error", error.get(ERROR_TYPE.getName()));    Assert.assertTrue(error.containsKey(MESSAGE.getName()));    Assert.assertTrue(error.containsKey(EXCEPTION.getName()));    Assert.assertTrue(error.containsKey(STACK.getName()));    Assert.assertTrue(error.containsKey(ERROR_HASH.getName()));    Assert.assertTrue(error.containsKey(Constants.GUID));}
public void metron_f6014_0()
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");        String invalidMessage = "{ this is an invalid message }}";    set("msg1", broMessage);    set("msg2", invalidMessage);    List<JSONObject> messages = execute("PARSER_PARSE(parser, [msg1, msg2])", List.class);        Assert.assertEquals(2, messages.size());    Assert.assertEquals(1, messages.stream().filter(msg -> isBro(msg)).count());    Assert.assertEquals(1, messages.stream().filter(msg -> isError(msg)).count());}
public void metron_f6015_0() throws Exception
{        set("config", broParserConfig);    assign("parser", "PARSER_INIT('bro', config)");    String config = execute("PARSER_CONFIG(parser)", String.class);    Assert.assertNotNull(config);    Assert.assertNotNull(SensorParserConfig.fromBytes(config.getBytes(StandardCharsets.UTF_8)));}
public void metron_f6016_0() throws Exception
{    set("configAsString", broParserConfig);    StellarParserRunner runner = execute("PARSER_INIT('bro', configAsString)", StellarParserRunner.class);    Assert.assertNotNull(runner);    SensorParserConfig actual = runner.getParserConfigurations().getSensorParserConfig("bro");    SensorParserConfig expected = SensorParserConfig.fromBytes(broParserConfig.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(expected, actual);}
public void metron_f6017_0() throws Exception
{    Map<String, Object> configAsMap = (JSONObject) new JSONParser().parse(broParserConfig);    set("configAsMap", configAsMap);    StellarParserRunner runner = execute("PARSER_INIT('bro', configAsMap)", StellarParserRunner.class);    Assert.assertNotNull(runner);    SensorParserConfig actual = runner.getParserConfigurations().getSensorParserConfig("bro");    SensorParserConfig expected = SensorParserConfig.fromBytes(broParserConfig.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(expected, actual);}
public void metron_f6018_0() throws Exception
{    execute("PARSER_INIT('bro', 22)", StellarParserRunner.class);    Assert.fail("expected exception");}
public void metron_f6019_0() throws Exception
{    byte[] configAsBytes = broParserConfig.getBytes(StandardCharsets.UTF_8);    CuratorFramework zkClient = zkClientForPath("/metron/topology/parsers/bro", configAsBytes);    context.addCapability(Context.Capabilities.ZOOKEEPER_CLIENT, () -> zkClient);    StellarParserRunner runner = execute("PARSER_INIT('bro')", StellarParserRunner.class);    Assert.assertNotNull(runner);    SensorParserConfig actual = runner.getParserConfigurations().getSensorParserConfig("bro");    SensorParserConfig expected = SensorParserConfig.fromBytes(broParserConfig.getBytes(StandardCharsets.UTF_8));    Assert.assertEquals(expected, actual);}
public void metron_f6020_0() throws Exception
{        CuratorFramework zkClient = zkClientMissingPath("/metron/topology/parsers/bro");    context.addCapability(Context.Capabilities.ZOOKEEPER_CLIENT, () -> zkClient);    execute("PARSER_INIT('bro')", StellarParserRunner.class);    Assert.fail("expected exception");}
private CuratorFramework metron_f6021_0(String path, byte[] value) throws Exception
{    GetDataBuilder getDataBuilder = mock(GetDataBuilder.class);    when(getDataBuilder.forPath(path)).thenReturn(value);    CuratorFramework zkClient = mock(CuratorFramework.class);    when(zkClient.getData()).thenReturn(getDataBuilder);    return zkClient;}
private CuratorFramework metron_f6022_0(String path) throws Exception
{    GetDataBuilder getDataBuilder = mock(GetDataBuilder.class);    when(getDataBuilder.forPath(path)).thenThrow(new KeeperException.NoNodeException(path));    CuratorFramework zkClient = mock(CuratorFramework.class);    when(zkClient.getData()).thenReturn(getDataBuilder);    return zkClient;}
private boolean metron_f6023_0(JSONObject message)
{    String sensorType = String.class.cast(message.get(Constants.SENSOR_TYPE));    return Constants.ERROR_TYPE.equals(sensorType);}
private boolean metron_f6024_0(JSONObject message)
{    String sensorType = String.class.cast(message.get(Constants.SENSOR_TYPE));    return "bro".equals(sensorType);}
private void metron_f6025_0(String var, Object value)
{    executor.assign(var, value);}
private Object metron_f6026_0(String var, String expression)
{    executor.assign(var, expression, Collections.emptyMap());    return executor.getState().get(var);}
private T metron_f6027_1(String expression, Class<T> clazz)
{    T results = executor.execute(expression, Collections.emptyMap(), clazz);        return results;}
public void metron_f6028_0()
{    List<String> toParse = new ArrayList<>();    toParse.add(broMessage);    toParse.add(broMessage);    toParse.add(broMessage);        StellarParserRunner runner = new StellarParserRunner("bro").withParserConfiguration(broParserConfig).withContext(Context.EMPTY_CONTEXT());    List<JSONObject> messages = runner.parse(toParse);        Assert.assertEquals(3, messages.size());    for (JSONObject message : messages) {        Assert.assertEquals("bro", message.get(Constants.SENSOR_TYPE));        Assert.assertTrue(message.containsKey(Constants.GUID));        Assert.assertEquals("10.122.196.204", message.get(SRC_ADDR.getName()));        Assert.assertEquals(33976L, message.get(SRC_PORT.getName()));        Assert.assertEquals("144.254.71.184", message.get(DST_ADDR.getName()));        Assert.assertEquals(53L, message.get(DST_PORT.getName()));        Assert.assertEquals("dns", message.get("protocol"));    }}
public void metron_f6029_0()
{    List<String> toParse = new ArrayList<>();    toParse.add("{DAS}");        StellarParserRunner runner = new StellarParserRunner("bro").withParserConfiguration(broParserConfig).withContext(Context.EMPTY_CONTEXT());    List<JSONObject> messages = runner.parse(toParse);        JSONObject error = messages.get(0);    Assert.assertEquals(toParse.get(0), error.get("raw_message"));    Assert.assertEquals(Constants.ERROR_TYPE, error.get(Constants.SENSOR_TYPE));    Assert.assertEquals("parser_error", error.get(ERROR_TYPE.getName()));    Assert.assertTrue(error.containsKey(MESSAGE.getName()));    Assert.assertTrue(error.containsKey(EXCEPTION.getName()));    Assert.assertTrue(error.containsKey(STACK.getName()));    Assert.assertTrue(error.containsKey(ERROR_HASH.getName()));    Assert.assertTrue(error.containsKey(Constants.GUID));}
public void metron_f6030_0()
{    List<String> toParse = new ArrayList<>();    toParse.add(broMessage);    toParse.add("{DAS}");        StellarParserRunner runner = new StellarParserRunner("bro").withParserConfiguration(broParserConfig).withContext(Context.EMPTY_CONTEXT());    List<JSONObject> messages = runner.parse(toParse);        Assert.assertEquals("Parser{1 successful, 1 error(s)}", runner.toString());}
public void metron_f6031_0()
{    variables = ImmutableMap.of("less", VariableResult.withExpression(true, "1 < 2"), "greater", VariableResult.withExpression(false, "1 > 2"));    context = new Context.Builder().with(Context.Capabilities.SHELL_VARIABLES, () -> variables).build();}
public static List<RiskLevelRule> metron_f6032_0(String config)
{    SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(config);    return sensorConfig.getThreatIntel().getTriageConfig().getRiskLevelRules();}
private Object metron_f6033_0(String rule, Map<String, Object> variables)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new DefaultVariableResolver(x -> variables.get(x), x -> variables.containsKey(x)), StellarFunctions.FUNCTION_RESOLVER(), context);}
private Object metron_f6034_0(String rule)
{    StellarProcessor processor = new StellarProcessor();    return processor.parse(rule, new MapVariableResolver(Collections.emptyMap()), StellarFunctions.FUNCTION_RESOLVER(), context);}
private Object metron_f6035_0(String... expressions)
{    Object result = null;    for (String expression : expressions) {        result = run(expression);    }    return result;}
public void metron_f6036_0()
{    String newConfig = (String) run("THREAT_TRIAGE_SET_AGGREGATOR(config, 'MIN' )", toMap("config", configStr));    SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(newConfig);    Assert.assertEquals("MIN", sensorConfig.getThreatIntel().getTriageConfig().getAggregator().toString());}
public void metron_f6037_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        String newConfig = (String) run("THREAT_TRIAGE_SET_AGGREGATOR(engine, 'MIN')", vars);        SensorEnrichmentConfig sensorConfig = (SensorEnrichmentConfig) ENRICHMENT.deserialize(newConfig);    Assert.assertEquals("MIN", sensorConfig.getThreatIntel().getTriageConfig().getAggregator().toString());        Assert.assertEquals("MIN", engine.getSensorConfig().getThreatIntel().getTriageConfig().getAggregator().toString());}
public void metron_f6038_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", toMap("config", configStr));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6039_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    String newConfig = (String) run("THREAT_TRIAGE_ADD(engine, {'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", vars);        List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());        Assert.assertEquals(1, engine.getSensorConfig().getThreatIntel().getTriageConfig().getRiskLevelRules().size());}
public void metron_f6040_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10, 'reason' : '2 + 2' } )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(2, triageRules.size());    RiskLevelRule less = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), less.getRule());    Assert.assertEquals("10", less.getScoreExpression());    RiskLevelRule greater = triageRules.get(1);    Assert.assertEquals(variables.get("greater").getExpression().get(), greater.getRule());    Assert.assertEquals("20", greater.getScoreExpression());}
public void metron_f6041_0()
{    Object o = run("THREAT_TRIAGE_ADD(config, { 'rule': SHELL_GET_EXPRESSION('foo'), 'score' : 10 } )", toMap("config", configStr));    Assert.assertEquals(configStr, o);}
public void metron_f6042_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 } )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6043_0()
{        String newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'name':'rule1', 'rule':'value < 2', 'score':10 } )", toMap("config", configStr));        newConfig = (String) run("THREAT_TRIAGE_ADD(config, { 'name':'rule2', 'rule':'value < 4', 'score':10 } )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(2, triageRules.size());}
public void metron_f6044_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        run("THREAT_TRIAGE_ADD(engine, { 'name':'rule1', 'rule':'value < 2', 'score':10 } )", vars);        run("THREAT_TRIAGE_ADD(engine, { 'name':'rule2', 'rule':'value < 4', 'score':10 } )", vars);    List<RiskLevelRule> triageRules = engine.getRiskLevelRules();    Assert.assertEquals(2, triageRules.size());}
public void metron_f6045_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_REMOVE(config, [ SHELL_GET_EXPRESSION('greater')] )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6046_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");        Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        String newConfig = (String) run("THREAT_TRIAGE_ADD(engine, [" + "{ 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, " + "{ 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", vars);        newConfig = (String) run("THREAT_TRIAGE_REMOVE(engine, [ " + "SHELL_GET_EXPRESSION('greater')] )", vars);    List<RiskLevelRule> triageRules = engine.getRiskLevelRules();    Assert.assertEquals(1, triageRules.size());    RiskLevelRule rule = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), rule.getRule());    Assert.assertEquals("10", rule.getScoreExpression());}
public void metron_f6047_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_REMOVE(config, [ SHELL_GET_EXPRESSION('less'), SHELL_GET_EXPRESSION('greater')] )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(0, triageRules.size());}
public void metron_f6048_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ { 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10 }, { 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    newConfig = (String) run("THREAT_TRIAGE_REMOVE(config, [ SHELL_GET_EXPRESSION('foo'), SHELL_GET_EXPRESSION('bar')] )", toMap("config", newConfig));    List<RiskLevelRule> triageRules = getTriageRules(newConfig);    Assert.assertEquals(2, triageRules.size());    RiskLevelRule less = triageRules.get(0);    Assert.assertEquals(variables.get("less").getExpression().get(), less.getRule());    Assert.assertEquals("10", less.getScoreExpression());    RiskLevelRule greater = triageRules.get(1);    Assert.assertEquals(variables.get("greater").getExpression().get(), greater.getRule());    Assert.assertEquals("20", greater.getScoreExpression());}
public void metron_f6049_0()
{    String newConfig = (String) run("THREAT_TRIAGE_ADD(config, [ " + "{ 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10, 'reason' : '2 + 2' }, " + "{ 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", toMap("config", configStr));    String out = (String) run("THREAT_TRIAGE_PRINT(config)", toMap("config", newConfig));    Assert.assertEquals(testPrintExpected, out);}
public void metron_f6050_0()
{        ThreatTriageProcessor engine = (ThreatTriageProcessor) run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        run("THREAT_TRIAGE_ADD(engine, [ " + "{ 'rule' : SHELL_GET_EXPRESSION('less'), 'score' : 10, 'reason' : '2 + 2' }, " + "{ 'rule' : SHELL_GET_EXPRESSION('greater'), 'score' : 20 } ] )", vars);        String out = (String) run("THREAT_TRIAGE_PRINT(engine)", vars);    Assert.assertEquals(testPrintExpected, out);}
public void metron_f6051_0()
{    String out = (String) run("THREAT_TRIAGE_PRINT(config)", toMap("config", configStr));    Assert.assertEquals(testPrintEmptyExpected, out);}
public void metron_f6052_0()
{    Map<String, Object> variables = new HashMap<String, Object>() {        {            put("config", null);        }    };    String out = (String) run("THREAT_TRIAGE_PRINT(config)", variables);    Assert.assertEquals(out, testPrintEmptyExpected);}
public void metron_f6053_0()
{    Object result = run("THREAT_TRIAGE_INIT()");    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof ThreatTriageProcessor);        ThreatTriageProcessor engine = (ThreatTriageProcessor) result;    Assert.assertEquals(0, engine.getRiskLevelRules().size());}
public void metron_f6054_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 10 } ])", toMap("conf", configStr));        Object result = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof ThreatTriageProcessor);        ThreatTriageProcessor engine = (ThreatTriageProcessor) result;    Assert.assertEquals(1, engine.getRiskLevelRules().size());}
public void metron_f6055_0()
{    run("THREAT_TRIAGE_INIT(missing)");}
public void metron_f6056_0()
{        Object engine = run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    vars.put("msg", message);        Object result = run("THREAT_TRIAGE_SCORE(msg, engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof Map);        Map<String, Object> score = (Map) result;    Assert.assertEquals(0, ((List) score.get(ThreatTriageFunctions.RULES_KEY)).size());        Object totalScore = score.get(ThreatTriageFunctions.SCORE_KEY);    Assert.assertTrue(totalScore instanceof Double);    Assert.assertEquals(0.0, (Double) totalScore, 0.001);}
public void metron_f6057_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 10 }])", toMap("conf", configStr));        Object engine = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    vars.put("msg", message);        Object result = run("THREAT_TRIAGE_SCORE(msg, engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof Map);        Map<String, Object> score = (Map) result;    Assert.assertEquals(1, ((List) score.get(ThreatTriageFunctions.RULES_KEY)).size());        Object totalScore = score.get(ThreatTriageFunctions.SCORE_KEY);    Assert.assertTrue(totalScore instanceof Double);    Assert.assertEquals(10.0, (Double) totalScore, 0.001);        Assert.assertEquals("MAX", score.get(ThreatTriageFunctions.AGG_KEY));}
public void metron_f6058_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 'value * 10' }])", toMap("conf", configStr));        Object engine = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);    vars.put("msg", message);        Object result = run("THREAT_TRIAGE_SCORE(msg, engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof Map);        Map<String, Object> score = (Map) result;    Assert.assertEquals(1, ((List) score.get(ThreatTriageFunctions.RULES_KEY)).size());        Object totalScore = score.get(ThreatTriageFunctions.SCORE_KEY);    Assert.assertTrue(totalScore instanceof Double);    Assert.assertEquals(220.0, (Double) totalScore, 0.001);        Assert.assertEquals("MAX", score.get(ThreatTriageFunctions.AGG_KEY));}
public void metron_f6059_0()
{        String confWithRule = (String) run("THREAT_TRIAGE_ADD(conf, [{ 'rule': 'value > 0', 'score' : 10 }])", toMap("conf", configStr));        Object engine = run("THREAT_TRIAGE_INIT(confWithRule)", toMap("confWithRule", confWithRule));    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        run("THREAT_TRIAGE_SCORE(11, engine)", vars);}
public void metron_f6060_0()
{        Object engine = run("THREAT_TRIAGE_INIT()");    Map<String, Object> vars = new HashMap<>();    vars.put("engine", engine);        Object result = run("THREAT_TRIAGE_CONFIG(engine)", vars);    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof String);        String json = (String) result;    Assert.assertEquals(emptyTransformationsConfig(), json);}
public static String metron_f6061_0(String loc)
{    try {        return Joiner.on("\n").join(Files.readLines(new File(loc), Charset.defaultCharset())).trim();    } catch (IOException e) {        throw new IllegalStateException(e);    }}
private void metron_f6063_0(String key, String pattern) throws GrokException
{    Grok grok = new Grok();    InputStream patternStream = this.getClass().getResourceAsStream("/patterns/asa");    grok.addPatternFromReader(new InputStreamReader(patternStream, StandardCharsets.UTF_8));    grok.compile("%{" + pattern + "}");    grokers.put(key, grok);}
public void metron_f6064_1()
{    syslogGrok = new Grok();    InputStream syslogStream = this.getClass().getResourceAsStream("/patterns/asa");    try {        syslogGrok.addPatternFromReader(new InputStreamReader(syslogStream, StandardCharsets.UTF_8));        syslogGrok.compile(syslogPattern);    } catch (GrokException e) {                throw new RuntimeException(e.getMessage(), e);    }    for (Entry<String, String> pattern : patternMap.entrySet()) {        try {            addGrok(pattern.getKey(), pattern.getValue());        } catch (GrokException e) {                    }    }    }
protected NumberFormat metron_f6066_0()
{    return new DecimalFormat("0.0#####");}
public void metron_f6067_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
private Long metron_f6070_0(Double timestampSeconds)
{    return ((Double) (timestampSeconds * 1000)).longValue();}
private boolean metron_f6071_0(JSONObject payload, String toKey, String[] fromKeys)
{    for (String fromKey : fromKeys) {        if (payload.containsKey(fromKey)) {            Object value = payload.remove(fromKey);            payload.put(toKey, value);            _LOG.trace("[Metron] Added {} to {}", toKey, payload);            return true;        }    }    return false;}
private boolean metron_f6072_0(JSONObject payload, String toKey, String[] fromKeys)
{    for (String fromKey : fromKeys) {        if (payload.containsKey(fromKey)) {            JSONArray value = (JSONArray) payload.remove(fromKey);            if (value != null && !value.isEmpty()) {                payload.put(toKey, value.get(0));                _LOG.trace("[Metron] Added {} to {}", toKey, payload);                return true;            }        }    }    return false;}
public JSONObject metron_f6073_0(String jsonString) throws ParseException
{    JSONParser parser = new JSONParser();    Map json = (Map) parser.parse(jsonString);    JSONObject output = new JSONObject();    Iterator iter = json.entrySet().iterator();    while (iter.hasNext()) {        Map.Entry entry = (Map.Entry) iter.next();        String key = ((String) entry.getKey()).replaceAll("[^\\._a-zA-Z0-9]+", "");        output.put(key, entry.getValue());    }    return output;}
public static void metron_f6074_0(String[] args)
{    String jsonText = "{\"first_1\": 123, \"second\": [4, 5, 6], \"third\": 789}";    JSONCleaner cleaner = new JSONCleaner();    try {                Map obj = new HashMap();        obj.put("name", "foo");        obj.put("num", 100);        obj.put("balance", 1000.21);        obj.put("is_vip", true);        obj.put("nickname", null);        Map obj1 = new HashMap();        obj1.put("sourcefile", obj);        JSONObject json = new JSONObject(obj1);        System.out.println(json);        System.out.print(jsonText);    } catch (Exception e) {        e.printStackTrace();    }}
public void metron_f6075_0()
{            String syslogTime = "(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\\b +(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]) (?!<[0-9])(?:2[0123]|[01]?[0-9]):(?:[0-5][0-9])(?::(?:(?:[0-5]?[0-9]|60)(?:[:.,][0-9]+)?))(?![0-9])?";    String syslogTime5424 = "(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2}))";    String syslogPriority = "<(?:[0-9]+)>";    String syslogHost = "[a-z0-9\\.\\\\-_]+";    StringBuilder sb = new StringBuilder("");    sb.append("(?<syslogPriority>");    sb.append(syslogPriority);    sb.append(")?");    sb.append("(?<syslogTime>");    sb.append(syslogTime);    sb.append("|");    sb.append(syslogTime5424);    sb.append(")?");    sb.append("(?<syslogHost>");    sb.append(syslogHost);    sb.append(")?");    sb.append(".*");    sb.append("CEF: ?0\\|");    headerBlock("DeviceVendor", sb);    sb.append("\\|");    headerBlock("DeviceProduct", sb);    sb.append("\\|");    headerBlock("DeviceVersion", sb);    sb.append("\\|");    headerBlock("DeviceEvent", sb);    sb.append("\\|");    headerBlock("Name", sb);    sb.append("\\|");    headerBlock("Severity", sb);    sb.append("\\|");        sb.append("(?<extensions>.*)");    String pattern = sb.toString();    p = Pattern.compile(pattern);}
public static void metron_f6076_0(String ext, JSONObject obj)
{    Matcher m = patternExtensions.matcher(ext);    int index = 0;    String key = null;    String value = null;    Map<String, String> labelMap = new HashMap<String, String>();    while (m.find()) {        if (key == null) {            key = ext.substring(index, m.start());            index = m.end();            if (!m.find()) {                break;            }        }        value = ext.substring(index, m.start());        index = m.end();        int v = value.lastIndexOf(" ");        if (v > 0) {            String temp = value.substring(0, v).trim();            if (key.endsWith("Label")) {                labelMap.put(key.substring(0, key.length() - 5), temp);            } else {                obj.put(key, temp);            }            key = value.substring(v).trim();        }    }    value = ext.substring(index);        if (key.endsWith("Label")) {        labelMap.put(key.substring(0, key.length() - 5), value);    } else {        obj.put(key, value);    }        for (Entry<String, String> label : labelMap.entrySet()) {        mutate(obj, label.getKey(), label.getValue());    }}
public List<JSONObject> metron_f6077_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    String cefString = new String(rawMessage, getReadCharset());    Matcher matcher = p.matcher(cefString);    while (matcher.find()) {        JSONObject obj = new JSONObject();        if (matcher.matches()) {                        obj.put("DeviceVendor", matcher.group("DeviceVendor"));            obj.put("DeviceProduct", matcher.group("DeviceProduct"));            obj.put("DeviceVersion", matcher.group("DeviceVersion"));            obj.put("DeviceEvent", matcher.group("DeviceEvent"));            obj.put("Name", matcher.group("Name"));            obj.put("Severity", standardizeSeverity(matcher.group("Severity")));        }        parseExtensions(matcher.group("extensions"), obj);                obj = mutate(obj, "dst", "ip_dst_addr");        obj = mutate(obj, "dpt", "ip_dst_port");        obj = convertToInt(obj, "ip_dst_port");        obj = mutate(obj, "src", "ip_src_addr");        obj = mutate(obj, "spt", "ip_src_port");        obj = convertToInt(obj, "ip_src_port");        obj = mutate(obj, "act", "deviceAction");                obj = mutate(obj, "app", "protocol");        obj.put("original_string", cefString);        if (obj.containsKey("rt")) {            String rt = (String) obj.get("rt");            try {                obj.put("timestamp", DateUtils.parseMultiformat(rt, DateUtils.DATE_FORMATS_CEF));            } catch (java.text.ParseException e) {                throw new IllegalStateException("rt field present in CEF but cannot be parsed", e);            }        } else {            String logTimestamp = matcher.group("syslogTime");            if (!(logTimestamp == null || logTimestamp.isEmpty())) {                try {                    obj.put("timestamp", SyslogUtils.parseTimestampToEpochMillis(logTimestamp, Clock.systemUTC()));                } catch (ParseException e) {                    throw new IllegalStateException("Cannot parse syslog timestamp", e);                }            } else {                obj.put("timestamp", System.currentTimeMillis());            }        }                String host = matcher.group("syslogHost");        if (!(host == null || host.isEmpty())) {            obj.put("host", host);        }        messages.add(obj);    }    return messages;}
private JSONObject metron_f6078_0(JSONObject obj, String key)
{    if (obj.containsKey(key)) {        obj.put(key, Integer.valueOf((String) obj.get(key)));    }    return obj;}
private void metron_f6079_0(String name, StringBuilder sb)
{    sb.append("(?<").append(name).append(">").append(HEADER_CAPTURE_PATTERN).append(")");}
private Integer metron_f6080_0(String severity)
{    if (severity.length() < 3) {                return Integer.valueOf(severity);    } else {        switch(severity) {            case "Low":                return 2;            case "Medium":                return 5;            case "High":                return 8;            case "Very-High":                return 10;            default:                return 0;        }    }}
public void metron_f6081_0(Map<String, Object> config)
{    setReadCharset(config);}
private static JSONObject metron_f6082_0(JSONObject json, String oldKey, String newKey)
{    if (json.containsKey(oldKey)) {        json.put(newKey, json.remove(oldKey));    }    return json;}
public void metron_f6083_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public List<JSONObject> metron_f6085_1(byte[] rawMessage)
{    String toParse;    List<JSONObject> messages = new ArrayList<>();    try {        toParse = new String(rawMessage, getReadCharset());                                Matcher m = syslogPriorityPattern.matcher(toParse);        String delimiter = "";        while (m.find()) {            delimiter = m.group();        }        if (!StringUtils.isBlank(delimiter)) {            String[] tokens = toParse.split(delimiter);            if (tokens.length > 1) {                toParse = delimiter + tokens[1];            }        }                JSONObject toReturn = parseMessage(toParse);        toReturn.put("timestamp", getTimeStamp(toParse));        messages.add(toReturn);        return messages;    } catch (Exception e) {        String message = "Unable to parse " + new String(rawMessage, StandardCharsets.UTF_8) + ": " + e.getMessage();                throw new IllegalStateException(message, e);    }}
private long metron_f6086_1(String toParse) throws ParseException
{    long timestamp = 0;    String month;    String day;    String time;    Matcher tsMatcher = tsPattern.matcher(toParse);    if (tsMatcher.find()) {        month = tsMatcher.group(1);        day = tsMatcher.group(2);        time = tsMatcher.group(3);        timestamp = ParserUtils.convertToEpoch(month, day, time, true);    } else {            }    return timestamp;}
private JSONObject metron_f6087_0(String toParse)
{    JSONObject toReturn = new JSONObject();    String[] messageTokens = toParse.split("\\s+");    String id = messageTokens[4];                    String[] tokens = id.split("\\.");    if (tokens.length == 2) {        String[] array = Arrays.copyOfRange(messageTokens, 1, messageTokens.length - 1);        String syslog = Joiner.on(" ").join(array);        Multimap<String, String> multiMap = formatMain(syslog);        for (String key : multiMap.keySet()) {            String value = Joiner.on(",").join(multiMap.get(key));            toReturn.put(key, value.trim());        }    }    toReturn.put("original_string", toParse);    final String ipSrcAddr = (String) toReturn.get("dvc");    final String ipSrcPort = (String) toReturn.get("src_port");    final String ipDstDddr = (String) toReturn.get("dst_ip");    final String ipDstPort = (String) toReturn.get("dst_port");    if (ipSrcAddr != null) {        toReturn.put("ip_src_addr", ipSrcAddr);    }    if (ipSrcPort != null) {        toReturn.put("ip_src_port", ipSrcPort);    }    if (ipDstDddr != null) {        toReturn.put("ip_dst_addr", ipDstDddr);    }    if (ipDstPort != null) {        toReturn.put("ip_dst_port", ipDstPort);    }    return toReturn;}
private Multimap<String, String> metron_f6088_0(String in)
{    Multimap<String, String> multiMap = ArrayListMultimap.create();    String input = in.replaceAll("cn3", "dst_port").replaceAll("cs5", "cncHost").replaceAll("proto", "protocol").replaceAll("rt=", "timestamp=").replaceAll("cs1", "malware").replaceAll("dst=", "dst_ip=").replaceAll("shost", "src_hostname").replaceAll("dmac", "dst_mac").replaceAll("smac", "src_mac").replaceAll("spt", "src_port").replaceAll("\\bsrc\\b", "src_ip");    String[] tokens = input.split("\\|");    if (tokens.length > 0) {        String message = tokens[tokens.length - 1];        Matcher m = nvPattern.matcher(message);        while (m.find()) {            String[] str = m.group().split("=");            multiMap.put(str[0], str[1]);        }    }    return multiMap;}
public void metron_f6089_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public boolean metron_f6092_0(JSONObject message)
{    return true;}
public JSONObject metron_f6093_0() throws ParseException
{    JSONObject toReturn = object();    if (!ensureEOF())        throw new IllegalStateException("Expected EOF, but still had content to parse");    return toReturn;}
public final boolean metron_f6094_0() throws ParseException
{    switch(jj_nt.kind) {        case COMMA:            jj_consume_token(COMMA);            break;        default:            jj_la1[0] = jj_gen;            ;    }    jj_consume_token(0);    {        if (true)            return true;    }    throw new Error("Missing return statement in function");}
public final JSONObject metron_f6095_0() throws ParseException
{    final JSONObject json = new JSONObject();    String key;    Object value;    key = objectKey();    jj_consume_token(EQUALS);    value = value();    json.put(key, value);    key = null;    value = null;    label_1: while (true) {        switch(jj_nt.kind) {            case SLASH:                ;                break;            default:                jj_la1[1] = jj_gen;                break label_1;        }        jj_consume_token(SLASH);        jj_consume_token(COMMA);        key = objectKey();        jj_consume_token(EQUALS);        value = value();        json.put(key, value);        key = null;        value = null;    }    {        if (true)            return json;    }    throw new Error("Missing return statement in function");}
public final JSONObject metron_f6096_0() throws ParseException
{    final JSONObject json = new JSONObject();    String key;    Object value;    key = objectKey();    jj_consume_token(EQUALS);    value = value();    json.put(key, value);    key = null;    value = null;    label_2: while (true) {        if (jj_2_1(2)) {            ;        } else {            break label_2;        }        jj_consume_token(COMMA);        key = objectKey();        jj_consume_token(EQUALS);        value = value();        json.put(key, value);        key = null;        value = null;    }    {        if (true)            return json;    }    throw new Error("Missing return statement in function");}
public final String metron_f6097_0() throws ParseException
{    String k;    k = string();        {        if (true)            return k.trim();    }    throw new Error("Missing return statement in function");}
public final Object metron_f6098_0() throws ParseException
{    Object x;    String eof = "EOF";    Map m = null;    if (jj_2_2(2147483647)) {        x = nullValue();    } else if (jj_2_3(2147483647)) {        x = innerMap();    } else {        switch(jj_nt.kind) {            case TAG:                x = tagString();                break;            default:                jj_la1[2] = jj_gen;                if (jj_2_4(2147483647)) {                    x = blankValue();                } else if (jj_2_5(2147483647)) {                    x = braced_string();                } else if (jj_2_6(2)) {                    x = string();                } else {                    jj_consume_token(-1);                    throw new ParseException();                }        }    }                {        if (true)            return x;    }    throw new Error("Missing return statement in function");}
public final String metron_f6099_0() throws ParseException
{    {        if (true)            return null;    }    throw new Error("Missing return statement in function");}
public final String metron_f6100_0() throws ParseException
{    String output = "(tag=0)";    jj_consume_token(TAG);    jj_consume_token(STRING_BODY);    {        if (true)            return output + token.image;    }    throw new Error("Missing return statement in function");}
public final String metron_f6101_0() throws ParseException
{    {        if (true)            return null;    }    throw new Error("Missing return statement in function");}
public final String metron_f6102_0() throws ParseException
{    String s;    jj_consume_token(STRING_BODY);    {        if (true)            return token.image.trim();    }    throw new Error("Missing return statement in function");}
public final String metron_f6103_0() throws ParseException
{    String s;    jj_consume_token(BRACED_STRING);        s = token.image;    jj_consume_token(COMMA);    {        if (true)            return s.trim();    }    throw new Error("Missing return statement in function");}
private boolean metron_f6104_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_1();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(0, xla);    }}
private boolean metron_f6105_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_2();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(1, xla);    }}
private boolean metron_f6106_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_3();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(2, xla);    }}
private boolean metron_f6107_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_4();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(3, xla);    }}
private boolean metron_f6108_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_5();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(4, xla);    }}
private boolean metron_f6109_0(int xla)
{    jj_la = xla;    jj_lastpos = jj_scanpos = token;    try {        return !jj_3_6();    } catch (LookaheadSuccess ls) {        return true;    } finally {        jj_save(5, xla);    }}
private boolean metron_f6110_0()
{    if (jj_3R_5())        return true;    return false;}
private boolean metron_f6111_0()
{    if (jj_scan_token(0))        return true;    return false;}
private boolean metron_f6112_0()
{    if (jj_scan_token(BRACED_STRING))        return true;    if (jj_scan_token(COMMA))        return true;    return false;}
private boolean metron_f6113_0()
{    if (jj_3R_4())        return true;    return false;}
private boolean metron_f6114_0()
{    if (jj_3R_3())        return true;    if (jj_scan_token(EQUALS))        return true;    if (jj_3R_7())        return true;    Token xsp;    while (true) {        xsp = jj_scanpos;        if (jj_3R_8()) {            jj_scanpos = xsp;            break;        }    }    return false;}
private boolean metron_f6115_0()
{    if (jj_scan_token(COMMA))        return true;    return false;}
private boolean metron_f6116_0()
{    if (jj_3R_6())        return true;    return false;}
private boolean metron_f6117_0()
{    if (jj_scan_token(COMMA))        return true;    if (jj_3R_3())        return true;    return false;}
private boolean metron_f6118_0()
{    if (jj_3R_5())        return true;    return false;}
private boolean metron_f6119_0()
{    if (jj_3R_16())        return true;    return false;}
private boolean metron_f6120_0()
{    if (jj_3R_15())        return true;    return false;}
private boolean metron_f6121_0()
{    if (jj_scan_token(STRING_BODY))        return true;    return false;}
private boolean metron_f6122_0()
{    if (jj_3R_4())        return true;    return false;}
private boolean metron_f6123_0()
{    if (jj_3R_14())        return true;    return false;}
private boolean metron_f6124_0()
{    Token xsp;    xsp = jj_scanpos;    if (jj_3R_9()) {        jj_scanpos = xsp;        if (jj_3R_10()) {            jj_scanpos = xsp;            if (jj_3R_11()) {                jj_scanpos = xsp;                if (jj_3R_12()) {                    jj_scanpos = xsp;                    if (jj_3R_13()) {                        jj_scanpos = xsp;                        if (jj_3_6())                            return true;                    }                }            }        }    }    return false;}
private boolean metron_f6125_0()
{    return false;}
private boolean metron_f6126_0()
{    if (jj_scan_token(TAG))        return true;    if (jj_scan_token(STRING_BODY))        return true;    return false;}
private boolean metron_f6127_0()
{    if (jj_3R_6())        return true;    return false;}
private boolean metron_f6128_0()
{    if (jj_scan_token(SLASH))        return true;    if (jj_scan_token(COMMA))        return true;    if (jj_3R_3())        return true;    if (jj_scan_token(EQUALS))        return true;    if (jj_3R_7())        return true;    return false;}
private boolean metron_f6129_0()
{    return false;}
private static void metron_f6130_0()
{    jj_la1_0 = new int[] { 0x20, 0x80, 0x100 };}
public void metron_f6131_0(java.io.InputStream stream)
{    ReInit(stream, null);}
public void metron_f6132_0(java.io.InputStream stream, String encoding)
{    try {        jj_input_stream.ReInit(stream, encoding, 1, 1);    } catch (java.io.UnsupportedEncodingException e) {        throw new RuntimeException(e);    }    token_source.ReInit(jj_input_stream);    token = new Token();    token.next = jj_nt = token_source.getNextToken();    jj_gen = 0;    for (int i = 0; i < 3; i++) jj_la1[i] = -1;    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();}
public void metron_f6133_0(java.io.Reader stream)
{    jj_input_stream.ReInit(stream, 1, 1);    token_source.ReInit(jj_input_stream);    token = new Token();    token.next = jj_nt = token_source.getNextToken();    jj_gen = 0;    for (int i = 0; i < 3; i++) jj_la1[i] = -1;    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();}
public void metron_f6134_0(ISEParserTokenManager tm)
{    token_source = tm;    token = new Token();    token.next = jj_nt = token_source.getNextToken();    jj_gen = 0;    for (int i = 0; i < 3; i++) jj_la1[i] = -1;    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();}
private Token metron_f6135_0(int kind) throws ParseException
{    Token oldToken = token;    if ((token = jj_nt).next != null)        jj_nt = jj_nt.next;    else        jj_nt = jj_nt.next = token_source.getNextToken();    if (token.kind == kind) {        jj_gen++;        if (++jj_gc > 100) {            jj_gc = 0;            for (int i = 0; i < jj_2_rtns.length; i++) {                JJCalls c = jj_2_rtns[i];                while (c != null) {                    if (c.gen < jj_gen)                        c.first = null;                    c = c.next;                }            }        }        return token;    }    jj_nt = token;    token = oldToken;    jj_kind = kind;    throw generateParseException();}
private boolean metron_f6136_0(int kind)
{    if (jj_scanpos == jj_lastpos) {        jj_la--;        if (jj_scanpos.next == null) {            jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();        } else {            jj_lastpos = jj_scanpos = jj_scanpos.next;        }    } else {        jj_scanpos = jj_scanpos.next;    }    if (jj_rescan) {        int i = 0;        Token tok = token;        while (tok != null && tok != jj_scanpos) {            i++;            tok = tok.next;        }        if (tok != null)            jj_add_error_token(kind, i);    }    if (jj_scanpos.kind != kind)        return true;    if (jj_la == 0 && jj_scanpos == jj_lastpos)        throw jj_ls;    return false;}
public final Token metron_f6137_0()
{    if ((token = jj_nt).next != null)        jj_nt = jj_nt.next;    else        jj_nt = jj_nt.next = token_source.getNextToken();    jj_gen++;    return token;}
public final Token metron_f6138_0(int index)
{    Token t = token;    for (int i = 0; i < index; i++) {        if (t.next != null)            t = t.next;        else            t = t.next = token_source.getNextToken();    }    return t;}
private void metron_f6139_0(int kind, int pos)
{    if (pos >= 100)        return;    if (pos == jj_endpos + 1) {        jj_lasttokens[jj_endpos++] = kind;    } else if (jj_endpos != 0) {        jj_expentry = new int[jj_endpos];        for (int i = 0; i < jj_endpos; i++) {            jj_expentry[i] = jj_lasttokens[i];        }        jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext(); ) {            int[] oldentry = (int[]) (it.next());            if (oldentry.length == jj_expentry.length) {                for (int i = 0; i < jj_expentry.length; i++) {                    if (oldentry[i] != jj_expentry[i]) {                        continue jj_entries_loop;                    }                }                jj_expentries.add(jj_expentry);                break jj_entries_loop;            }        }        if (pos != 0)            jj_lasttokens[(jj_endpos = pos) - 1] = kind;    }}
public ParseException metron_f6140_0()
{    jj_expentries.clear();    boolean[] la1tokens = new boolean[11];    if (jj_kind >= 0) {        la1tokens[jj_kind] = true;        jj_kind = -1;    }    for (int i = 0; i < 3; i++) {        if (jj_la1[i] == jj_gen) {            for (int j = 0; j < 32; j++) {                if ((jj_la1_0[i] & (1 << j)) != 0) {                    la1tokens[j] = true;                }            }        }    }    for (int i = 0; i < 11; i++) {        if (la1tokens[i]) {            jj_expentry = new int[1];            jj_expentry[0] = i;            jj_expentries.add(jj_expentry);        }    }    jj_endpos = 0;    jj_rescan_token();    jj_add_error_token(0, 0);    int[][] exptokseq = new int[jj_expentries.size()][];    for (int i = 0; i < jj_expentries.size(); i++) {        exptokseq[i] = jj_expentries.get(i);    }    return new ParseException(token, exptokseq, tokenImage);}
private void metron_f6143_0()
{    jj_rescan = true;    for (int i = 0; i < 6; i++) {        try {            JJCalls p = jj_2_rtns[i];            do {                if (p.gen > jj_gen) {                    jj_la = p.arg;                    jj_lastpos = jj_scanpos = p.first;                    switch(i) {                        case 0:                            jj_3_1();                            break;                        case 1:                            jj_3_2();                            break;                        case 2:                            jj_3_3();                            break;                        case 3:                            jj_3_4();                            break;                        case 4:                            jj_3_5();                            break;                        case 5:                            jj_3_6();                            break;                    }                }                p = p.next;            } while (p != null);        } catch (LookaheadSuccess ls) {        }    }    jj_rescan = false;}
private void metron_f6144_0(int index, int xla)
{    JJCalls p = jj_2_rtns[index];    while (p.gen > jj_gen) {        if (p.next == null) {            p = p.next = new JJCalls();            break;        }        p = p.next;    }    p.gen = jj_gen + xla - jj_la;    p.first = token;    p.arg = xla;}
public void metron_f6145_0(java.io.PrintStream ds)
{    debugStream = ds;}
private final int metron_f6146_0(int pos, long active0)
{    switch(pos) {        case 0:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                return 18;            }            if ((active0 & 0x80L) != 0L)                return 6;            return -1;        case 1:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                jjmatchedPos = 1;                return 18;            }            return -1;        case 2:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                jjmatchedPos = 2;                return 18;            }            return -1;        case 3:            if ((active0 & 0x100L) != 0L) {                jjmatchedKind = 9;                jjmatchedPos = 3;                return 18;            }            return -1;        case 4:            if ((active0 & 0x100L) != 0L) {                if (jjmatchedPos < 3) {                    jjmatchedKind = 9;                    jjmatchedPos = 3;                }                return -1;            }            return -1;        case 5:            if ((active0 & 0x100L) != 0L) {                if (jjmatchedPos < 3) {                    jjmatchedKind = 9;                    jjmatchedPos = 3;                }                return -1;            }            return -1;        default:            return -1;    }}
private final int metron_f6147_0(int pos, long active0)
{    return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);}
private int metron_f6148_0(int pos, int kind)
{    jjmatchedKind = kind;    jjmatchedPos = pos;    return pos + 1;}
private int metron_f6149_0()
{    switch(curChar) {        case 40:            return jjMoveStringLiteralDfa1_0(0x100L);        case 44:            return jjStopAtPos(0, 5);        case 61:            return jjStopAtPos(0, 6);        case 92:            return jjStartNfaWithStates_0(0, 7, 6);        default:            return jjMoveNfa_0(0, 0);    }}
private int metron_f6150_0(long active0)
{    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(0, active0);        return 1;    }    switch(curChar) {        case 84:        case 116:            return jjMoveStringLiteralDfa2_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(0, active0);}
private int metron_f6151_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(0, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(1, active0);        return 2;    }    switch(curChar) {        case 65:        case 97:            return jjMoveStringLiteralDfa3_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(1, active0);}
private int metron_f6152_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(1, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(2, active0);        return 3;    }    switch(curChar) {        case 71:        case 103:            return jjMoveStringLiteralDfa4_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(2, active0);}
private int metron_f6153_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(2, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(3, active0);        return 4;    }    switch(curChar) {        case 61:            return jjMoveStringLiteralDfa5_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(3, active0);}
private int metron_f6154_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(3, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(4, active0);        return 5;    }    switch(curChar) {        case 48:            return jjMoveStringLiteralDfa6_0(active0, 0x100L);        default:            break;    }    return jjStartNfa_0(4, active0);}
private int metron_f6155_0(long old0, long active0)
{    if (((active0 &= old0)) == 0L)        return jjStartNfa_0(4, old0);    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        jjStopStringLiteralDfa_0(5, active0);        return 6;    }    switch(curChar) {        case 41:            if ((active0 & 0x100L) != 0L)                return jjStopAtPos(6, 8);            break;        default:            break;    }    return jjStartNfa_0(5, active0);}
private int metron_f6156_0(int pos, int kind, int state)
{    jjmatchedKind = kind;    jjmatchedPos = pos;    try {        curChar = input_stream.readChar();    } catch (java.io.IOException e) {        return pos + 1;    }    return jjMoveNfa_0(state, pos + 1);}
private int metron_f6157_0(int startState, int curPos)
{    int startsAt = 0;    jjnewStateCnt = 18;    int i = 1;    jjstateSet[0] = startState;    int kind = 0x7fffffff;    for (; ; ) {        if (++jjround == 0x7fffffff)            ReInitRounds();        if (curChar < 64) {            long l = 1L << curChar;            do {                switch(jjstateSet[--i]) {                    case 18:                    case 4:                        if ((0xdfffeffbffffc9ffL & l) == 0L)                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 0:                        if ((0xdfffeffbffffc9ffL & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        } else if ((0x3400L & l) != 0L) {                            if (kind > 4)                                kind = 4;                        }                        if (curChar == 47)                            jjAddStates(0, 1);                        else if (curChar == 35)                            jjCheckNAddTwoStates(1, 2);                        break;                    case 6:                        if ((0xdfffeffbffffc9ffL & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        }                        if ((0x900400000000L & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        }                        break;                    case 1:                        if ((0xffffffffffffcbffL & l) != 0L)                            jjCheckNAddTwoStates(1, 2);                        break;                    case 2:                        if ((0x3400L & l) != 0L && kind > 3)                            kind = 3;                        break;                    case 3:                        if ((0x3400L & l) != 0L && kind > 4)                            kind = 4;                        break;                    case 8:                        jjAddStates(2, 3);                        break;                    case 10:                        if (curChar == 47)                            jjAddStates(0, 1);                        break;                    case 11:                        if (curChar == 47)                            jjCheckNAddTwoStates(12, 13);                        break;                    case 12:                        if ((0xffffffffffffcbffL & l) != 0L)                            jjCheckNAddTwoStates(12, 13);                        break;                    case 13:                        if ((0x3400L & l) != 0L && kind > 1)                            kind = 1;                        break;                    case 14:                        if (curChar == 42)                            jjCheckNAddTwoStates(15, 17);                        break;                    case 15:                        jjCheckNAddTwoStates(15, 17);                        break;                    case 16:                        if (curChar == 47 && kind > 2)                            kind = 2;                        break;                    case 17:                        if (curChar == 42)                            jjstateSet[jjnewStateCnt++] = 16;                        break;                    default:                        break;                }            } while (i != startsAt);        } else if (curChar < 128) {            long l = 1L << (curChar & 077);            do {                switch(jjstateSet[--i]) {                    case 18:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 0:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        if (curChar == 123)                            jjCheckNAdd(8);                        else if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 6:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        if ((0x14404410144044L & l) != 0L) {                            if (kind > 9)                                kind = 9;                            jjCheckNAddTwoStates(4, 5);                        }                        if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 1:                        jjAddStates(4, 5);                        break;                    case 4:                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 5:                        if (curChar == 92)                            jjstateSet[jjnewStateCnt++] = 6;                        break;                    case 7:                        if (curChar == 123)                            jjCheckNAdd(8);                        break;                    case 8:                        if ((0xd7ffffffffffffffL & l) != 0L)                            jjCheckNAddTwoStates(8, 9);                        break;                    case 9:                        if (curChar == 125 && kind > 10)                            kind = 10;                        break;                    case 12:                        jjAddStates(6, 7);                        break;                    case 15:                        jjAddStates(8, 9);                        break;                    default:                        break;                }            } while (i != startsAt);        } else {            int hiByte = (int) (curChar >> 8);            int i1 = hiByte >> 6;            long l1 = 1L << (hiByte & 077);            int i2 = (curChar & 0xff) >> 6;            long l2 = 1L << (curChar & 077);            do {                switch(jjstateSet[--i]) {                    case 18:                    case 4:                        if (!jjCanMove_0(hiByte, i1, i2, l1, l2))                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 0:                        if (!jjCanMove_0(hiByte, i1, i2, l1, l2))                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 6:                        if (!jjCanMove_0(hiByte, i1, i2, l1, l2))                            break;                        if (kind > 9)                            kind = 9;                        jjCheckNAddTwoStates(4, 5);                        break;                    case 1:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(4, 5);                        break;                    case 8:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(2, 3);                        break;                    case 12:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(6, 7);                        break;                    case 15:                        if (jjCanMove_0(hiByte, i1, i2, l1, l2))                            jjAddStates(8, 9);                        break;                    default:                        break;                }            } while (i != startsAt);        }        if (kind != 0x7fffffff) {            jjmatchedKind = kind;            jjmatchedPos = curPos;            kind = 0x7fffffff;        }        ++curPos;        if ((i = jjnewStateCnt) == (startsAt = 18 - (jjnewStateCnt = startsAt)))            return curPos;        try {            curChar = input_stream.readChar();        } catch (java.io.IOException e) {            return curPos;        }    }}
private static final boolean metron_f6158_0(int hiByte, int i1, int i2, long l1, long l2)
{    switch(hiByte) {        case 0:            return ((jjbitVec2[i2] & l2) != 0L);        default:            if ((jjbitVec0[i1] & l1) != 0L)                return true;            return false;    }}
public void metron_f6159_0(JavaCharStream stream)
{    jjmatchedPos = jjnewStateCnt = 0;    curLexState = defaultLexState;    input_stream = stream;    ReInitRounds();}
private void metron_f6160_0()
{    int i;    jjround = 0x80000001;    for (i = 18; i-- > 0; ) jjrounds[i] = 0x80000000;}
public void metron_f6161_0(JavaCharStream stream, int lexState)
{    ReInit(stream);    SwitchTo(lexState);}
public void metron_f6162_0(int lexState)
{    if (lexState >= 1 || lexState < 0)        throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);    else        curLexState = lexState;}
protected Token metron_f6163_0()
{    final Token t;    final String curTokenImage;    final int beginLine;    final int endLine;    final int beginColumn;    final int endColumn;    String im = jjstrLiteralImages[jjmatchedKind];    curTokenImage = (im == null) ? input_stream.GetImage() : im;    beginLine = input_stream.getBeginLine();    beginColumn = input_stream.getBeginColumn();    endLine = input_stream.getEndLine();    endColumn = input_stream.getEndColumn();    t = Token.newToken(jjmatchedKind, curTokenImage);    t.beginLine = beginLine;    t.endLine = endLine;    t.beginColumn = beginColumn;    t.endColumn = endColumn;    return t;}
public Token metron_f6164_0()
{    Token matchedToken;    int curPos = 0;    EOFLoop: for (; ; ) {        try {            curChar = input_stream.BeginToken();        } catch (java.io.IOException e) {            jjmatchedKind = 0;            matchedToken = jjFillToken();            return matchedToken;        }        jjmatchedKind = 0x7fffffff;        jjmatchedPos = 0;        curPos = jjMoveStringLiteralDfa0_0();        if (jjmatchedKind != 0x7fffffff) {            if (jjmatchedPos + 1 < curPos)                input_stream.backup(curPos - jjmatchedPos - 1);            if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {                matchedToken = jjFillToken();                return matchedToken;            } else {                continue EOFLoop;            }        }        int error_line = input_stream.getEndLine();        int error_column = input_stream.getEndColumn();        String error_after = null;        boolean EOFSeen = false;        try {            input_stream.readChar();            input_stream.backup(1);        } catch (java.io.IOException e1) {            EOFSeen = true;            error_after = curPos <= 1 ? "" : input_stream.GetImage();            if (curChar == '\n' || curChar == '\r') {                error_line++;                error_column = 0;            } else                error_column++;        }        if (!EOFSeen) {            input_stream.backup(1);            error_after = curPos <= 1 ? "" : input_stream.GetImage();        }        throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);    }}
private void metron_f6165_0(int state)
{    if (jjrounds[state] != jjround) {        jjstateSet[jjnewStateCnt++] = state;        jjrounds[state] = jjround;    }}
private void metron_f6166_0(int start, int end)
{    do {        jjstateSet[jjnewStateCnt++] = jjnextStates[start];    } while (start++ != end);}
private void metron_f6167_0(int state1, int state2)
{    jjCheckNAdd(state1);    jjCheckNAdd(state2);}
 static final int metron_f6168_0(char c) throws java.io.IOException
{    switch(c) {        case '0':            return 0;        case '1':            return 1;        case '2':            return 2;        case '3':            return 3;        case '4':            return 4;        case '5':            return 5;        case '6':            return 6;        case '7':            return 7;        case '8':            return 8;        case '9':            return 9;        case 'a':        case 'A':            return 10;        case 'b':        case 'B':            return 11;        case 'c':        case 'C':            return 12;        case 'd':        case 'D':            return 13;        case 'e':        case 'E':            return 14;        case 'f':        case 'F':            return 15;    }        throw new java.io.IOException();}
protected void metron_f6169_0(int i)
{    tabSize = i;}
protected int metron_f6170_0(int i)
{    return tabSize;}
protected void metron_f6171_0(boolean wrapAround)
{    char[] newbuffer = new char[bufsize + 2048];    int[] newbufline = new int[bufsize + 2048];    int[] newbufcolumn = new int[bufsize + 2048];    try {        if (wrapAround) {            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);            System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);            buffer = newbuffer;            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);            bufline = newbufline;            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);            bufcolumn = newbufcolumn;            bufpos += (bufsize - tokenBegin);        } else {            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);            buffer = newbuffer;            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);            bufline = newbufline;            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);            bufcolumn = newbufcolumn;            bufpos -= tokenBegin;        }    } catch (Throwable t) {        throw new Error(t.getMessage());    }    available = (bufsize += 2048);    tokenBegin = 0;}
protected void metron_f6172_0() throws java.io.IOException
{    int i;    if (maxNextCharInd == 4096)        maxNextCharInd = nextCharInd = 0;    try {        if ((i = inputStream.read(nextCharBuf, maxNextCharInd, 4096 - maxNextCharInd)) == -1) {            inputStream.close();            throw new java.io.IOException();        } else            maxNextCharInd += i;        return;    } catch (java.io.IOException e) {        if (bufpos != 0) {            --bufpos;            backup(0);        } else {            bufline[bufpos] = line;            bufcolumn[bufpos] = column;        }        throw e;    }}
protected char metron_f6173_0() throws java.io.IOException
{    if (++nextCharInd >= maxNextCharInd)        FillBuff();    return nextCharBuf[nextCharInd];}
public char metron_f6174_0() throws java.io.IOException
{    if (inBuf > 0) {        --inBuf;        if (++bufpos == bufsize)            bufpos = 0;        tokenBegin = bufpos;        return buffer[bufpos];    }    tokenBegin = 0;    bufpos = -1;    return readChar();}
protected void metron_f6175_0()
{    if (available == bufsize) {        if (tokenBegin > 2048) {            bufpos = 0;            available = tokenBegin;        } else            ExpandBuff(false);    } else if (available > tokenBegin)        available = bufsize;    else if ((tokenBegin - available) < 2048)        ExpandBuff(true);    else        available = tokenBegin;}
protected void metron_f6176_0(char c)
{    column++;    if (prevCharIsLF) {        prevCharIsLF = false;        line += (column = 1);    } else if (prevCharIsCR) {        prevCharIsCR = false;        if (c == '\n') {            prevCharIsLF = true;        } else            line += (column = 1);    }    switch(c) {        case '\r':            prevCharIsCR = true;            break;        case '\n':            prevCharIsLF = true;            break;        case '\t':            column--;            column += (tabSize - (column % tabSize));            break;        default:            break;    }    bufline[bufpos] = line;    bufcolumn[bufpos] = column;}
public char metron_f6177_0() throws java.io.IOException
{    if (inBuf > 0) {        --inBuf;        if (++bufpos == bufsize)            bufpos = 0;        return buffer[bufpos];    }    char c;    if (++bufpos == available)        AdjustBuffSize();    if ((buffer[bufpos] = c = ReadByte()) == '\\') {        UpdateLineColumn(c);        int backSlashCnt = 1;        for (; ; )         {            if (++bufpos == available)                AdjustBuffSize();            try {                if ((buffer[bufpos] = c = ReadByte()) != '\\') {                    UpdateLineColumn(c);                                        if ((c == 'u') && ((backSlashCnt & 1) == 1)) {                        if (--bufpos < 0)                            bufpos = bufsize - 1;                        break;                    }                    backup(backSlashCnt);                    return '\\';                }            } catch (java.io.IOException e) {                                if (backSlashCnt > 1)                    backup(backSlashCnt - 1);                return '\\';            }            UpdateLineColumn(c);            backSlashCnt++;        }                try {            while ((c = ReadByte()) == 'u') ++column;            buffer[bufpos] = c = (char) (hexval(c) << 12 | hexval(ReadByte()) << 8 | hexval(ReadByte()) << 4 | hexval(ReadByte()));            column += 4;        } catch (java.io.IOException e) {            throw new Error("Invalid escape character at line " + line + " column " + column + ".");        }        if (backSlashCnt == 1)            return c;        else {            backup(backSlashCnt - 1);            return '\\';        }    } else {        UpdateLineColumn(c);        return c;    }}
public int metron_f6178_0()
{    return bufcolumn[bufpos];}
public int metron_f6179_0()
{    return bufline[bufpos];}
public int metron_f6180_0()
{    return bufcolumn[bufpos];}
public int metron_f6181_0()
{    return bufline[bufpos];}
public int metron_f6182_0()
{    return bufcolumn[tokenBegin];}
public int metron_f6183_0()
{    return bufline[tokenBegin];}
public void metron_f6184_0(int amount)
{    inBuf += amount;    if ((bufpos -= amount) < 0)        bufpos += bufsize;}
public void metron_f6185_0(java.io.Reader dstream, int startline, int startcolumn, int buffersize)
{    inputStream = dstream;    line = startline;    column = startcolumn - 1;    if (buffer == null || buffersize != buffer.length) {        available = bufsize = buffersize;        buffer = new char[buffersize];        bufline = new int[buffersize];        bufcolumn = new int[buffersize];        nextCharBuf = new char[4096];    }    prevCharIsLF = prevCharIsCR = false;    tokenBegin = inBuf = maxNextCharInd = 0;    nextCharInd = bufpos = -1;}
public void metron_f6186_0(java.io.Reader dstream, int startline, int startcolumn)
{    ReInit(dstream, startline, startcolumn, 4096);}
public void metron_f6187_0(java.io.Reader dstream)
{    ReInit(dstream, 1, 1, 4096);}
public void metron_f6188_0(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
{    ReInit(encoding == null ? new java.io.InputStreamReader(dstream, StandardCharsets.UTF_8) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);}
public void metron_f6189_0(java.io.InputStream dstream, int startline, int startcolumn, int buffersize)
{    ReInit(new java.io.InputStreamReader(dstream, StandardCharsets.UTF_8), startline, startcolumn, buffersize);}
public void metron_f6190_0(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException
{    ReInit(dstream, encoding, startline, startcolumn, 4096);}
public void metron_f6191_0(java.io.InputStream dstream, int startline, int startcolumn)
{    ReInit(dstream, startline, startcolumn, 4096);}
public void metron_f6192_0(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
{    ReInit(dstream, encoding, 1, 1, 4096);}
public void metron_f6193_0(java.io.InputStream dstream)
{    ReInit(dstream, 1, 1, 4096);}
public String metron_f6194_0()
{    if (bufpos >= tokenBegin)        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);    else        return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);}
public char[] metron_f6195_0(int len)
{    char[] ret = new char[len];    if ((bufpos + 1) >= len)        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);    else {        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);    }    return ret;}
public void metron_f6196_0()
{    nextCharBuf = null;    buffer = null;    bufline = null;    bufcolumn = null;}
public void metron_f6197_0(int newLine, int newCol)
{    int start = tokenBegin;    int len;    if (bufpos >= tokenBegin) {        len = bufpos - tokenBegin + inBuf + 1;    } else {        len = bufsize - tokenBegin + bufpos + 1 + inBuf;    }    int i = 0, j = 0, k = 0;    int nextColDiff = 0, columnDiff = 0;    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {        bufline[j] = newLine;        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];        bufcolumn[j] = newCol + columnDiff;        columnDiff = nextColDiff;        i++;    }    if (i < len) {        bufline[j] = newLine++;        bufcolumn[j] = newCol + columnDiff;        while (i++ < len) {            if (bufline[j = start % bufsize] != bufline[++start % bufsize])                bufline[j] = newLine++;            else                bufline[j] = newLine;        }    }    line = bufline[j];    column = bufcolumn[j];}
private static String metron_f6198_0(Token currentToken, int[][] expectedTokenSequences, String[] tokenImage)
{    String eol = System.getProperty("line.separator", "\n");    StringBuffer expected = new StringBuffer();    int maxSize = 0;    for (int i = 0; i < expectedTokenSequences.length; i++) {        if (maxSize < expectedTokenSequences[i].length) {            maxSize = expectedTokenSequences[i].length;        }        for (int j = 0; j < expectedTokenSequences[i].length; j++) {            expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');        }        if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {            expected.append("...");        }        expected.append(eol).append("    ");    }    String retval = "Encountered \"";    Token tok = currentToken.next;    for (int i = 0; i < maxSize; i++) {        if (i != 0)            retval += " ";        if (tok.kind == 0) {            retval += tokenImage[0];            break;        }        retval += " " + tokenImage[tok.kind];        retval += " \"";        retval += add_escapes(tok.image);        retval += " \"";        tok = tok.next;    }    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;    retval += "." + eol;    if (expectedTokenSequences.length == 1) {        retval += "Was expecting:" + eol + "    ";    } else {        retval += "Was expecting one of:" + eol + "    ";    }    retval += expected.toString();    return retval;}
 static String metron_f6199_0(String str)
{    StringBuffer retval = new StringBuffer();    char ch;    for (int i = 0; i < str.length(); i++) {        switch(str.charAt(i)) {            case 0:                continue;            case '\b':                retval.append("\\b");                continue;            case '\t':                retval.append("\\t");                continue;            case '\n':                retval.append("\\n");                continue;            case '\f':                retval.append("\\f");                continue;            case '\r':                retval.append("\\r");                continue;            case '\"':                retval.append("\\\"");                continue;            case '\'':                retval.append("\\\'");                continue;            case '\\':                retval.append("\\\\");                continue;            default:                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {                    String s = "0000" + Integer.toString(ch, 16);                    retval.append("\\u" + s.substring(s.length() - 4, s.length()));                } else {                    retval.append(ch);                }                continue;        }    }    return retval.toString();}
public Object metron_f6200_0()
{    return null;}
public String metron_f6201_0()
{    return image;}
public static Token metron_f6202_0(int ofKind, String image)
{    switch(ofKind) {        default:            return new Token(ofKind, image);    }}
public static Token metron_f6203_0(int ofKind)
{    return newToken(ofKind, null);}
protected static final String metron_f6204_0(String str)
{    StringBuffer retval = new StringBuffer();    char ch;    for (int i = 0; i < str.length(); i++) {        switch(str.charAt(i)) {            case 0:                continue;            case '\b':                retval.append("\\b");                continue;            case '\t':                retval.append("\\t");                continue;            case '\n':                retval.append("\\n");                continue;            case '\f':                retval.append("\\f");                continue;            case '\r':                retval.append("\\r");                continue;            case '\"':                retval.append("\\\"");                continue;            case '\'':                retval.append("\\\'");                continue;            case '\\':                retval.append("\\\\");                continue;            default:                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {                    String s = "0000" + Integer.toString(ch, 16);                    retval.append("\\u" + s.substring(s.length() - 4, s.length()));                } else {                    retval.append(ch);                }                continue;        }    }    return retval.toString();}
protected static String metron_f6205_0(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)
{    return ("Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int) curChar + "), ") + "after : \"" + addEscapes(errorAfter) + "\"");}
public String metron_f6206_0()
{    return super.getMessage();}
public void metron_f6207_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
public String metron_f6210_0()
{    return name;}
public void metron_f6211_0()
{        String syslogTime = "(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\\b +(?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]) (?!<[0-9])(?:2[0123]|[01]?[0-9]):(?:[0-5][0-9])(?::(?:(?:[0-5]?[0-9]|60)(?:[:.,][0-9]+)?))(?![0-9])?";    String syslogTime5424 = "(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2}))";    String syslogPriority = "<(?:[0-9]+)>";    String syslogHost = "[a-z0-9\\.\\\\-_]+";    StringBuilder sb = new StringBuilder("");    sb.append("(?<syslogPriority>");    sb.append(syslogPriority);    sb.append(")?");    sb.append("(?<syslogTime>");    sb.append(syslogTime);    sb.append("|");    sb.append(syslogTime5424);    sb.append(")?");    sb.append("(?<syslogHost>");    sb.append(syslogHost);    sb.append(")?");    sb.append(".*");    sb.append("LEEF:(?<");    sb.append(HeaderFields.VERSION.getName());    sb.append(">1.0|2.0|0)?\\|");    headerBlock(HeaderFields.DEVICE_VENDOR.getName(), sb);    sb.append("\\|");    headerBlock(HeaderFields.DEVICE_PRODUCT.getName(), sb);    sb.append("\\|");    headerBlock(HeaderFields.DEVICE_VERSION.getName(), sb);    sb.append("\\|");    headerBlock(HeaderFields.DEVICE_EVENT.getName(), sb);    sb.append("\\|");        sb.append("(");    headerBlock(HeaderFields.DELIMITER.getName(), sb);    sb.append("\\|");    sb.append(")?");        sb.append(" ?(?<extensions>.*)");    pattern = Pattern.compile(sb.toString());}
public Optional<MessageParserResult<JSONObject>> metron_f6212_1(byte[] rawMessage)
{    List<JSONObject> messages = new ArrayList<>();    Map<Object, Throwable> errors = new HashMap<>();    String originalMessage = null;    try (BufferedReader reader = new BufferedReader(new StringReader(new String(rawMessage, getReadCharset())))) {        while ((originalMessage = reader.readLine()) != null) {            Matcher matcher = pattern.matcher(originalMessage);            while (matcher.find()) {                JSONObject obj = new JSONObject();                if (!matcher.matches()) {                    break;                }                                obj.put(HeaderFields.DEVICE_VENDOR.getName(), matcher.group(HeaderFields.DEVICE_VENDOR.getName()));                obj.put(HeaderFields.DEVICE_PRODUCT.getName(), matcher.group(HeaderFields.DEVICE_PRODUCT.getName()));                obj.put(HeaderFields.DEVICE_VERSION.getName(), matcher.group(HeaderFields.DEVICE_VERSION.getName()));                obj.put(HeaderFields.DEVICE_EVENT.getName(), matcher.group(HeaderFields.DEVICE_EVENT.getName()));                String ext = matcher.group("extensions");                                String version = matcher.group(HeaderFields.VERSION.getName());                if (version.equals("2.0")) {                    String delimiter = matcher.group(HeaderFields.DELIMITER.getName());                    if (delimiter == null || delimiter.length() == 0) {                        delimiter = "\\t";                    }                    delimiter = "(?<!\\\\)[" + delimiter.replace("^", "\\^").replace("\t", "\\t") + "]";                    String[] kvs = ext.split(delimiter);                    for (String kv : kvs) {                        String[] a = kv.split("=");                        obj.put(a[0], a[1]);                    }                } else if (version.equals("1.0") || version.isEmpty()) {                    String delimiter = "\t";                    String[] kvs = ext.split(delimiter);                    for (String kv : kvs) {                        String[] a = kv.split("=");                        obj.put(a[0], a[1]);                    }                } else {                                                                                CEFParser.parseExtensions(ext, obj);                }                                obj = mutate(obj, "dst", Fields.DST_ADDR.getName());                obj = mutate(obj, "dstPort", Fields.DST_PORT.getName());                obj = convertToInt(obj, Fields.DST_PORT.getName());                obj = mutate(obj, "src", Fields.SRC_ADDR.getName());                obj = mutate(obj, "srcPort", Fields.SRC_PORT.getName());                obj = convertToInt(obj, Fields.SRC_PORT.getName());                obj.put(Fields.ORIGINAL.getName(), originalMessage);                                String host = matcher.group("syslogHost");                if (!(host == null || host.isEmpty())) {                    obj.put("host", host);                }                                if (obj.containsKey(DEV_TIME)) {                    String devTime = (String) obj.get(DEV_TIME);                    try {                                                                                                                                                                        final String devTimeFormat = (String) obj.get(DEV_TIME_FORMAT);                        List<SimpleDateFormat> formats = (obj.containsKey(DEV_TIME_FORMAT)) ? new ArrayList<SimpleDateFormat>() {                            {                                add(new SimpleDateFormat(devTimeFormat));                            }                        } : DateUtils.DATE_FORMATS_LEEF;                        obj.put(Fields.TIMESTAMP.getName(), DateUtils.parseMultiformat(devTime, formats));                    } catch (java.text.ParseException e) {                        errors.put(originalMessage, new IllegalStateException("devTime field present in LEEF but cannot be parsed", e));                        continue;                    }                } else {                    String logTimestamp = matcher.group("syslogTime");                    if (!(logTimestamp == null || logTimestamp.isEmpty())) {                        try {                            obj.put(Fields.TIMESTAMP.getName(), SyslogUtils.parseTimestampToEpochMillis(logTimestamp, Clock.systemUTC()));                        } catch (ParseException e) {                            errors.put(originalMessage, new IllegalStateException("Cannot parse syslog timestamp", e));                            continue;                        }                    } else {                        obj.put(Fields.TIMESTAMP.getName(), System.currentTimeMillis());                    }                }                messages.add(obj);            }        }    } catch (IOException e) {                Exception innerException = new IllegalStateException("LEEF parser Error: " + e.getMessage() + " on " + originalMessage, e);        return Optional.of(new DefaultMessageParserResult<>(innerException));    }    return Optional.of(new DefaultMessageParserResult<>(messages, errors));}
private JSONObject metron_f6213_0(JSONObject obj, String key)
{    if (obj.containsKey(key)) {        obj.put(key, Integer.valueOf((String) obj.get(key)));    }    return obj;}
private void metron_f6214_0(String name, StringBuilder sb)
{    sb.append("(?<").append(name).append(">").append(HEADER_CAPTURE_PATTERN).append(")");}
public void metron_f6215_0(Map<String, Object> config)
{    setReadCharset(config);}
private JSONObject metron_f6216_0(JSONObject json, String oldKey, String newKey)
{    if (json.containsKey(oldKey)) {        json.put(newKey, json.remove(oldKey));    }    return json;}
public List<JSONObject> metron_f6219_0(byte[] raw_message)
{    List<JSONObject> messages = new ArrayList<>();    try {        /*			 * We need to create a new JSONParser each time because its 			 * not serializable and the parser is created on the storm nimbus			 * node, then transfered to the workers.			 */        JSONParser jsonParser = new JSONParser();        String rawString = new String(raw_message, StandardCharsets.UTF_8);        JSONObject rawJson = (JSONObject) jsonParser.parse(rawString);                rawJson.remove("@version");        rawJson.remove("type");        rawJson.remove("host");        rawJson.remove("tags");                rawJson = mutate(rawJson, "message", "original_string");        rawJson = mutate(rawJson, "src_ip", "ip_src_addr");        rawJson = mutate(rawJson, "dst_ip", "ip_dst_addr");        rawJson = mutate(rawJson, "src_port", "ip_src_port");        rawJson = mutate(rawJson, "dst_port", "ip_dst_port");        rawJson = mutate(rawJson, "src_ip", "ip_src_addr");                long timestamp = LogstashToEpoch((String) rawJson.remove("@timestamp"));        rawJson.put("timestamp", timestamp);        messages.add(rawJson);        return messages;    } catch (Exception e) {        e.printStackTrace();        return null;    }}
private JSONObject metron_f6220_0(JSONObject json, String oldKey, String newKey)
{    if (json.containsKey(oldKey)) {        json.put(newKey, json.remove(oldKey));    }    return json;}
private long metron_f6221_0(String timestamp) throws java.text.ParseException
{    SimpleDateFormat logstashDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");    return logstashDateFormat.parse(timestamp).getTime();}
private static boolean metron_f6222_0(final String s)
{    return s == null || s.trim().isEmpty() || s.equals("\"\"");}
private static String metron_f6223_0(String s)
{    s = s.trim();    if (s.startsWith("\"") && s.endsWith("\""))        return s.substring(1, s.length() - 1);    return s;}
public void metron_f6224_0(Map<String, Object> parserConfig)
{    setReadCharset(parserConfig);}
private void metron_f6227_0(String message, JSONObject outputMessage)
{    String[] tokens = Iterables.toArray(Splitter.on(Pattern.compile(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)")).split(message), String.class);    int parser_version = 0;    String type = tokens[3].trim();        if (!type.equals(LogTypeConfig) && !type.equals(LogTypeThreat) && !type.equals(LogTypeTraffic) && !type.equals(LogTypeSystem)) {        throw new UnsupportedOperationException("Unsupported log type.");    }        if (!empty_attribute(tokens[0]))        outputMessage.put(PaloAltoDomain, tokens[0].trim());    if (!empty_attribute(tokens[1]))        outputMessage.put(ReceiveTime, tokens[1].trim());    if (!empty_attribute(tokens[2]))        outputMessage.put(SerialNum, tokens[2].trim());    outputMessage.put(Type, type);    if (!empty_attribute(tokens[4]))        outputMessage.put(ThreatContentType, unquoted_attribute(tokens[4]));    if (!empty_attribute(tokens[5]))        outputMessage.put(ConfigVersion, tokens[5].trim());    if (!empty_attribute(tokens[6]))        outputMessage.put(GenerateTime, tokens[6].trim());    if (LogTypeConfig.equals(type.toUpperCase())) {                if (tokens.length == 16 || tokens.length == 18)            parser_version = 61;        else if (tokens.length == 22 || tokens.length == 24)            parser_version = 80;        if (parser_version >= 61) {            if (!empty_attribute(tokens[7]))                outputMessage.put(HOST, tokens[7].trim());            if (!empty_attribute(tokens[8]))                outputMessage.put(VirtualSystem, tokens[8].trim());            if (!empty_attribute(tokens[9]))                outputMessage.put(Command, tokens[9].trim());            if (!empty_attribute(tokens[10]))                outputMessage.put(Admin, tokens[10].trim());            if (!empty_attribute(tokens[11]))                outputMessage.put(Client, unquoted_attribute(tokens[11]));            if (!empty_attribute(tokens[12]))                outputMessage.put(Result, unquoted_attribute(tokens[12]));            if (!empty_attribute(tokens[13]))                outputMessage.put(ConfigurationPath, unquoted_attribute(tokens[13]));        }        if (parser_version == 61) {            if (!empty_attribute(tokens[14]))                outputMessage.put(Seqno, unquoted_attribute(tokens[14]));            if (!empty_attribute(tokens[15]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[15]));            if (tokens.length == 18) {                if (!empty_attribute(tokens[16]))                    outputMessage.put(BeforeChangeDetail, unquoted_attribute(tokens[16]));                if (!empty_attribute(tokens[17]))                    outputMessage.put(AfterChangeDetail, unquoted_attribute(tokens[17]));            }        }        if (parser_version >= 70) {            int custom_fields_offset = 0;            if (tokens.length == 24) {                if (!empty_attribute(tokens[14])) {                    outputMessage.put(BeforeChangeDetail, unquoted_attribute(tokens[14 + custom_fields_offset]));                }                if (!empty_attribute(tokens[15])) {                    outputMessage.put(AfterChangeDetail, unquoted_attribute(tokens[15 + custom_fields_offset]));                }                custom_fields_offset = 2;            }            if (!empty_attribute(tokens[14 + custom_fields_offset])) {                outputMessage.put(Seqno, unquoted_attribute(tokens[14 + custom_fields_offset]));            }            if (!empty_attribute(tokens[15 + custom_fields_offset])) {                outputMessage.put(ActionFlags, unquoted_attribute(tokens[15 + custom_fields_offset]));            }            if (!empty_attribute(tokens[16 + custom_fields_offset])) {                outputMessage.put(DGH1, unquoted_attribute(tokens[16 + custom_fields_offset]));            }            if (!empty_attribute(tokens[17 + custom_fields_offset])) {                outputMessage.put(DGH2, unquoted_attribute(tokens[17 + custom_fields_offset]));            }            if (!empty_attribute(tokens[18 + custom_fields_offset])) {                outputMessage.put(DGH3, unquoted_attribute(tokens[18 + custom_fields_offset]));            }            if (!empty_attribute(tokens[19 + custom_fields_offset])) {                outputMessage.put(DGH4, unquoted_attribute(tokens[19 + custom_fields_offset]));            }            if (!empty_attribute(tokens[20 + custom_fields_offset])) {                outputMessage.put(VSYSName, unquoted_attribute(tokens[20 + custom_fields_offset]));            }            if (!empty_attribute(tokens[21 + custom_fields_offset])) {                outputMessage.put(DeviceName, unquoted_attribute(tokens[21 + custom_fields_offset]));            }        }    } else if (LogTypeSystem.equals(type.toUpperCase())) {        if (tokens.length == 17)            parser_version = 61;        else if (tokens.length == 23)            parser_version = 80;        if (parser_version >= 61) {            if (!empty_attribute(tokens[7]))                outputMessage.put(VirtualSystem, tokens[7].trim());            if (!empty_attribute(tokens[8]))                outputMessage.put(EventId, tokens[8].trim());            if (!empty_attribute(tokens[9]))                outputMessage.put(Object, tokens[9].trim());            if (!empty_attribute(tokens[12]))                outputMessage.put(Module, tokens[12].trim());            if (!empty_attribute(tokens[13]))                outputMessage.put(Severity, unquoted_attribute(tokens[13]));            if (!empty_attribute(tokens[14]))                outputMessage.put(Description, unquoted_attribute(tokens[14]));            if (!empty_attribute(tokens[15]))                outputMessage.put(Seqno, unquoted_attribute(tokens[15]));            if (!empty_attribute(tokens[16]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[16]));        }        if (parser_version == 80) {            if (!empty_attribute(tokens[17]))                outputMessage.put(DGH1, tokens[17].trim());            if (!empty_attribute(tokens[18]))                outputMessage.put(DGH2, tokens[18].trim());            if (!empty_attribute(tokens[19]))                outputMessage.put(DGH3, tokens[19].trim());            if (!empty_attribute(tokens[20]))                outputMessage.put(DGH4, tokens[20].trim());            if (!empty_attribute(tokens[21]))                outputMessage.put(VSYSName, unquoted_attribute(tokens[21]));            if (!empty_attribute(tokens[22]))                outputMessage.put(DeviceName, unquoted_attribute(tokens[22]));        }    } else if (LogTypeThreat.equals(type.toUpperCase()) || LogTypeTraffic.equals(type.toUpperCase())) {        if (!empty_attribute(tokens[7]))            outputMessage.put(SourceAddress, tokens[7].trim());        if (!empty_attribute(tokens[8]))            outputMessage.put(DestinationAddress, tokens[8].trim());        if (!empty_attribute(tokens[9]))            outputMessage.put(NATSourceIP, tokens[9].trim());        if (!empty_attribute(tokens[10]))            outputMessage.put(NATDestinationIP, tokens[10].trim());        if (!empty_attribute(tokens[11]))            outputMessage.put(Rule, unquoted_attribute(tokens[11]));        if (!empty_attribute(tokens[12]))            outputMessage.put(SourceUser, unquoted_attribute(tokens[12]));        if (!empty_attribute(tokens[13]))            outputMessage.put(DestinationUser, unquoted_attribute(tokens[13]));        if (!empty_attribute(tokens[14]))            outputMessage.put(Application, unquoted_attribute(tokens[14]));        if (!empty_attribute(tokens[15]))            outputMessage.put(VirtualSystem, unquoted_attribute(tokens[15]));        if (!empty_attribute(tokens[16]))            outputMessage.put(SourceZone, unquoted_attribute(tokens[16]));        if (!empty_attribute(tokens[17]))            outputMessage.put(DestinationZone, unquoted_attribute(tokens[17]));        if (!empty_attribute(tokens[18]))            outputMessage.put(InboundInterface, unquoted_attribute(tokens[18]));        if (!empty_attribute(tokens[19]))            outputMessage.put(OutboundInterface, unquoted_attribute(tokens[19]));        if (!empty_attribute(tokens[20]))            outputMessage.put(LogAction, unquoted_attribute(tokens[20]));        if (!empty_attribute(tokens[21]))            outputMessage.put(TimeLogged, tokens[21].trim());        if (!empty_attribute(tokens[22]))            outputMessage.put(SessionID, tokens[22].trim());        if (!empty_attribute(tokens[23]))            outputMessage.put(RepeatCount, tokens[23].trim());        if (!empty_attribute(tokens[24]))            outputMessage.put(SourcePort, tokens[24].trim());        if (!empty_attribute(tokens[25]))            outputMessage.put(DestinationPort, tokens[25].trim());        if (!empty_attribute(tokens[26]))            outputMessage.put(NATSourcePort, tokens[26].trim());        if (!empty_attribute(tokens[27]))            outputMessage.put(NATDestinationPort, tokens[27].trim());        if (!empty_attribute(tokens[28]))            outputMessage.put(Flags, tokens[28].trim());        if (!empty_attribute(tokens[29]))            outputMessage.put(IPProtocol, unquoted_attribute(tokens[29]));        if (!empty_attribute(tokens[30]))            outputMessage.put(Action, unquoted_attribute(tokens[30]));        if (LogTypeThreat.equals(type.toUpperCase())) {            int p1_offset = 0;            if (tokens.length == 45)                parser_version = 60;            else if (tokens.length == 53)                parser_version = 61;            else if (tokens.length == 61) {                parser_version = 70;                p1_offset = 1;            } else if (tokens.length == 72) {                parser_version = 80;                p1_offset = 1;            }            if (!empty_attribute(tokens[31])) {                outputMessage.put(URL, unquoted_attribute(tokens[31]));                try {                    URL url = new URL(unquoted_attribute(tokens[31]));                    outputMessage.put(HOST, url.getHost());                } catch (MalformedURLException e) {                }            }            if (!empty_attribute(tokens[32]))                outputMessage.put(ThreatID, tokens[32].trim());            if (!empty_attribute(tokens[33]))                outputMessage.put(Category, unquoted_attribute(tokens[33]));            if (!empty_attribute(tokens[34]))                outputMessage.put(Severity, unquoted_attribute(tokens[34]));            if (!empty_attribute(tokens[35]))                outputMessage.put(Direction, unquoted_attribute(tokens[35]));            if (!empty_attribute(tokens[36]))                outputMessage.put(Seqno, tokens[36].trim());            if (!empty_attribute(tokens[37]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[37]));            if (!empty_attribute(tokens[38]))                outputMessage.put(SourceLocation, unquoted_attribute(tokens[38]));            if (!empty_attribute(tokens[39]))                outputMessage.put(DestinationLocation, unquoted_attribute(tokens[39]));            if (!empty_attribute(tokens[41]))                outputMessage.put(ContentType, unquoted_attribute(tokens[41]));            if (!empty_attribute(tokens[42]))                outputMessage.put(PCAPID, tokens[42].trim());            if (!empty_attribute(tokens[43]))                outputMessage.put(WFFileDigest, unquoted_attribute(tokens[43]));            if (!empty_attribute(tokens[44]))                outputMessage.put(WFCloud, unquoted_attribute(tokens[44]));            if (parser_version >= 61) {                if (!empty_attribute(tokens[(45 + p1_offset)]))                    outputMessage.put(UserAgent, unquoted_attribute(tokens[(45 + p1_offset)]));                if (!empty_attribute(tokens[(46 + p1_offset)]))                    outputMessage.put(WFFileType, unquoted_attribute(tokens[(46 + p1_offset)]));                if (!empty_attribute(tokens[(47 + p1_offset)]))                    outputMessage.put(XForwardedFor, unquoted_attribute(tokens[(47 + p1_offset)]));                if (!empty_attribute(tokens[(48 + p1_offset)]))                    outputMessage.put(Referer, unquoted_attribute(tokens[(48 + p1_offset)]));                if (!empty_attribute(tokens[(49 + p1_offset)]))                    outputMessage.put(WFSender, unquoted_attribute(tokens[(49 + p1_offset)]));                if (!empty_attribute(tokens[(50 + p1_offset)]))                    outputMessage.put(WFSubject, unquoted_attribute(tokens[(50 + p1_offset)]));                if (!empty_attribute(tokens[(51 + p1_offset)]))                    outputMessage.put(WFRecipient, unquoted_attribute(tokens[(51 + p1_offset)]));                if (!empty_attribute(tokens[(52 + p1_offset)]))                    outputMessage.put(WFReportID, unquoted_attribute(tokens[(52 + p1_offset)]));            }            if (parser_version >= 70) {                if (!empty_attribute(tokens[45]))                    outputMessage.put(URLIndex, tokens[45].trim());                if (!empty_attribute(tokens[54]))                    outputMessage.put(DGH1, tokens[54].trim());                if (!empty_attribute(tokens[55]))                    outputMessage.put(DGH2, tokens[55].trim());                if (!empty_attribute(tokens[56]))                    outputMessage.put(DGH3, tokens[56].trim());                if (!empty_attribute(tokens[57]))                    outputMessage.put(DGH4, tokens[57].trim());                if (!empty_attribute(tokens[58]))                    outputMessage.put(VSYSName, unquoted_attribute(tokens[58]));                if (!empty_attribute(tokens[59]))                    outputMessage.put(DeviceName, unquoted_attribute(tokens[59]));            }            if (parser_version >= 80) {                if (!empty_attribute(tokens[61]))                    outputMessage.put(SourceVmUuid, tokens[61].trim());                if (!empty_attribute(tokens[62]))                    outputMessage.put(DestinationVmUuid, tokens[62].trim());                if (!empty_attribute(tokens[63]))                    outputMessage.put(HTTPMethod, tokens[63].trim());                if (!empty_attribute(tokens[64]))                    outputMessage.put(TunnelId, tokens[64].trim());                if (!empty_attribute(tokens[65]))                    outputMessage.put(MonitorTag, tokens[65].trim());                if (!empty_attribute(tokens[66]))                    outputMessage.put(ParentSessionId, tokens[66].trim());                if (!empty_attribute(tokens[67]))                    outputMessage.put(ParentSessionStartTime, tokens[67].trim());                if (!empty_attribute(tokens[68]))                    outputMessage.put(TunnelType, tokens[68].trim());                if (!empty_attribute(tokens[69]))                    outputMessage.put(ThreatCategory, tokens[69].trim());                if (!empty_attribute(tokens[70]))                    outputMessage.put(ContentVersion, tokens[70].trim());            }        } else if (LogTypeTraffic.equals(type.toUpperCase())) {            if (tokens.length == 46)                parser_version = 60;            else if (tokens.length == 47)                parser_version = 61;            else if (tokens.length == 54)                parser_version = 70;            else if (tokens.length == 61)                parser_version = 80;            if (!empty_attribute(tokens[31]))                outputMessage.put(Bytes, tokens[31].trim());            if (!empty_attribute(tokens[32]))                outputMessage.put(BytesSent, tokens[32].trim());            if (!empty_attribute(tokens[33]))                outputMessage.put(BytesReceived, tokens[33].trim());            if (!empty_attribute(tokens[34]))                outputMessage.put(Packets, tokens[34].trim());            if (!empty_attribute(tokens[35]))                outputMessage.put(StartTime, tokens[35].trim());            if (!empty_attribute(tokens[36]))                outputMessage.put(ElapsedTimeInSec, tokens[36].trim());            if (!empty_attribute(tokens[37]))                outputMessage.put(Category, unquoted_attribute(tokens[37]));            if (!empty_attribute(tokens[39]))                outputMessage.put(Seqno, tokens[39].trim());            if (!empty_attribute(tokens[40]))                outputMessage.put(ActionFlags, unquoted_attribute(tokens[40]));            if (!empty_attribute(tokens[41]))                outputMessage.put(SourceLocation, unquoted_attribute(tokens[41]));            if (!empty_attribute(tokens[42]))                outputMessage.put(DestinationLocation, unquoted_attribute(tokens[42]));            if (!empty_attribute(tokens[44]))                outputMessage.put(PktsSent, tokens[44].trim());            if (!empty_attribute(tokens[45]))                outputMessage.put(PktsReceived, tokens[45].trim());            if (parser_version >= 61) {                if (!empty_attribute(tokens[46]))                    outputMessage.put(EndReason, unquoted_attribute(tokens[46]));            }            if (parser_version >= 70) {                if (!empty_attribute(tokens[47]))                    outputMessage.put(DGH1, tokens[47].trim());                if (!empty_attribute(tokens[48]))                    outputMessage.put(DGH2, tokens[48].trim());                if (!empty_attribute(tokens[49]))                    outputMessage.put(DGH3, tokens[49].trim());                if (!empty_attribute(tokens[50]))                    outputMessage.put(DGH4, tokens[50].trim());                if (!empty_attribute(tokens[51]))                    outputMessage.put(VSYSName, unquoted_attribute(tokens[51]));                if (!empty_attribute(tokens[52]))                    outputMessage.put(DeviceName, unquoted_attribute(tokens[52]));                if (!empty_attribute(tokens[53]))                    outputMessage.put(ActionSource, unquoted_attribute(tokens[53]));            }            if (parser_version >= 80) {                if (!empty_attribute(tokens[54]))                    outputMessage.put(SourceVmUuid, tokens[54].trim());                if (!empty_attribute(tokens[55]))                    outputMessage.put(DestinationVmUuid, tokens[55].trim());                if (!empty_attribute(tokens[56]))                    outputMessage.put(TunnelId, tokens[56].trim());                if (!empty_attribute(tokens[57]))                    outputMessage.put(MonitorTag, tokens[57].trim());                if (!empty_attribute(tokens[58]))                    outputMessage.put(ParentSessionId, tokens[58].trim());                if (!empty_attribute(tokens[59]))                    outputMessage.put(ParentSessionStartTime, tokens[59].trim());                if (!empty_attribute(tokens[60]))                    outputMessage.put(TunnelType, tokens[60].trim());            }        }    }    outputMessage.put(ParserVersion, parser_version);    if (parser_version == 0) {        outputMessage.put(Tokens, tokens.length);    }}
